commit c730ae0c6bb3125ccb776fb2ab6abbdff500c02c
Author: Marcos Paulo de Souza <mpdesouza@suse.com>
Date:   Tue Jun 16 15:54:29 2020 -0300

    btrfs: convert comments to fallthrough annotations
    
    Convert fall through comments to the pseudo-keyword which is now the
    preferred way.
    
    Signed-off-by: Marcos Paulo de Souza <mpdesouza@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index bc73fd670702..c3826ae883f0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -523,7 +523,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 		case Opt_compress_force:
 		case Opt_compress_force_type:
 			compress_force = true;
-			/* Fallthrough */
+			fallthrough;
 		case Opt_compress:
 		case Opt_compress_type:
 			saved_compress_type = btrfs_test_opt(info,
@@ -622,7 +622,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			btrfs_set_opt(info->mount_opt, NOSSD);
 			btrfs_clear_and_info(info, SSD,
 					     "not using ssd optimizations");
-			/* Fallthrough */
+			fallthrough;
 		case Opt_nossd_spread:
 			btrfs_clear_and_info(info, SSD_SPREAD,
 					     "not using spread ssd allocation scheme");
@@ -793,7 +793,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 		case Opt_recovery:
 			btrfs_warn(info,
 				   "'recovery' is deprecated, use 'usebackuproot' instead");
-			/* fall through */
+			fallthrough;
 		case Opt_usebackuproot:
 			btrfs_info(info,
 				   "trying to use backup root at mount time");

commit 0202e83fdab05b3bf641804afea57a2bfcbcbd70
Author: David Sterba <dsterba@suse.com>
Date:   Fri May 15 19:35:59 2020 +0200

    btrfs: simplify iget helpers
    
    The inode lookup starting at btrfs_iget takes the full location key,
    while only the objectid is used to match the inode, because the lookup
    happens inside the given root thus the inode number is unique.
    The entire location key is properly set up in btrfs_init_locked_inode.
    
    Simplify the helpers and pass only inode number, renaming it to 'ino'
    instead of 'objectid'. This allows to remove temporary variables key,
    saving some stack space.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6bbf84a26501..bc73fd670702 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1217,7 +1217,6 @@ static int btrfs_fill_super(struct super_block *sb,
 {
 	struct inode *inode;
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
-	struct btrfs_key key;
 	int err;
 
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
@@ -1245,10 +1244,7 @@ static int btrfs_fill_super(struct super_block *sb,
 		return err;
 	}
 
-	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
-	key.type = BTRFS_INODE_ITEM_KEY;
-	key.offset = 0;
-	inode = btrfs_iget(sb, &key, fs_info->fs_root);
+	inode = btrfs_iget(sb, BTRFS_FIRST_FREE_OBJECTID, fs_info->fs_root);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
 		goto fail_close;

commit 56e9357a1e8167134388d4c70654795353765c7b
Author: David Sterba <dsterba@suse.com>
Date:   Fri May 15 19:35:55 2020 +0200

    btrfs: simplify root lookup by id
    
    The main function to lookup a root by its id btrfs_get_fs_root takes the
    whole key, while only using the objectid. The value of offset is preset
    to (u64)-1 but not actually used until btrfs_find_root that does the
    actual search.
    
    Switch btrfs_get_fs_root to use only objectid and remove all local
    variables that existed just for the lookup. The actual key for search is
    set up in btrfs_get_fs_root, reusing another key variable.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 438ecba26557..6bbf84a26501 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1102,10 +1102,7 @@ char *btrfs_get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 		dirid = btrfs_root_ref_dirid(path->nodes[0], root_ref);
 		btrfs_release_path(path);
 
-		key.objectid = subvol_objectid;
-		key.type = BTRFS_ROOT_ITEM_KEY;
-		key.offset = (u64)-1;
-		fs_root = btrfs_get_fs_root(fs_info, &key, true);
+		fs_root = btrfs_get_fs_root(fs_info, subvol_objectid, true);
 		if (IS_ERR(fs_root)) {
 			ret = PTR_ERR(fs_root);
 			fs_root = NULL;

commit fb8521caa8f21f3153c5dc9feb055b6cd3e45c89
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 28 17:10:29 2020 +0200

    btrfs: add more codes to decoder table
    
    I've grepped logs for 'errno=.*unknown' and found -95, -117 and -122,
    now added to the table. The wording is adjusted so it makes sense in
    context of filesystem.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9e5d723a0d99..438ecba26557 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -90,6 +90,15 @@ const char * __attribute_const__ btrfs_decode_error(int errno)
 	case -EROFS:		/* -30 */
 		errstr = "Readonly filesystem";
 		break;
+	case -EOPNOTSUPP:	/* -95 */
+		errstr = "Operation not supported";
+		break;
+	case -EUCLEAN:		/* -117 */
+		errstr = "Filesystem corrupted";
+		break;
+	case -EDQUOT:		/* -122 */
+		errstr = "Quota exceeded";
+		break;
 	}
 
 	return errstr;

commit d54f814434c5f87356d35bc377f43ef8d0556f15
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 28 17:10:27 2020 +0200

    btrfs: sort error decoder entries
    
    Add the raw errnos and sort them accordingly.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7932d8d07cff..9e5d723a0d99 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -72,23 +72,23 @@ const char * __attribute_const__ btrfs_decode_error(int errno)
 	char *errstr = "unknown";
 
 	switch (errno) {
-	case -EIO:
+	case -ENOENT:		/* -2 */
+		errstr = "No such entry";
+		break;
+	case -EIO:		/* -5 */
 		errstr = "IO failure";
 		break;
-	case -ENOMEM:
+	case -ENOMEM:		/* -12*/
 		errstr = "Out of memory";
 		break;
-	case -EROFS:
-		errstr = "Readonly filesystem";
-		break;
-	case -EEXIST:
+	case -EEXIST:		/* -17 */
 		errstr = "Object already exists";
 		break;
-	case -ENOSPC:
+	case -ENOSPC:		/* -28 */
 		errstr = "No space left";
 		break;
-	case -ENOENT:
-		errstr = "No such entry";
+	case -EROFS:		/* -30 */
+		errstr = "Readonly filesystem";
 		break;
 	}
 

commit 7e8f19e50e3ccf0608133cd76e845c282cd84a55
Author: David Sterba <dsterba@suse.com>
Date:   Wed Nov 27 16:02:05 2019 +0100

    btrfs: adjust message level for unrecognized mount option
    
    An unrecognized option is a failure that should get user/administrator
    attention, the info level is often below what gets logged, so make it
    error.
    
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4969fcce0704..7932d8d07cff 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -873,7 +873,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			break;
 #endif
 		case Opt_err:
-			btrfs_info(info, "unrecognized mount option '%s'", p);
+			btrfs_err(info, "unrecognized mount option '%s'", p);
 			ret = -EINVAL;
 			goto out;
 		default:

commit c0c907a47dccf2cf26251a8fb4a8e7a3bf79ce84
Author: Marcos Paulo de Souza <mpdesouza@suse.com>
Date:   Fri Feb 21 14:56:12 2020 +0100

    btrfs: export helpers for subvolume name/id resolution
    
    The functions will be used outside of export.c and super.c to allow
    resolving subvolume name from a given id, eg. for subvolume deletion by
    id ioctl.
    
    Signed-off-by: Marcos Paulo de Souza <mpdesouza@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ split from the next patch ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5c16b4bcde9b..4969fcce0704 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1024,8 +1024,8 @@ static int btrfs_parse_subvol_options(const char *options, char **subvol_name,
 	return error;
 }
 
-static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
-					   u64 subvol_objectid)
+char *btrfs_get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
+					  u64 subvol_objectid)
 {
 	struct btrfs_root *root = fs_info->tree_root;
 	struct btrfs_root *fs_root = NULL;
@@ -1442,8 +1442,8 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 				goto out;
 			}
 		}
-		subvol_name = get_subvol_name_from_objectid(btrfs_sb(mnt->mnt_sb),
-							    subvol_objectid);
+		subvol_name = btrfs_get_subvol_name_from_objectid(
+					btrfs_sb(mnt->mnt_sb), subvol_objectid);
 		if (IS_ERR(subvol_name)) {
 			root = ERR_CAST(subvol_name);
 			subvol_name = NULL;

commit bf31f87f71cc7a89871ab0a451c047a0c0144bf1
Author: David Sterba <dsterba@suse.com>
Date:   Wed Feb 5 17:34:34 2020 +0100

    btrfs: add wrapper for transaction abort predicate
    
    The status of aborted transaction can change between calls and it needs
    to be accessed by READ_ONCE. Add a helper that also wraps the unlikely
    hint.
    
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6420df4e86d7..5c16b4bcde9b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -244,7 +244,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 {
 	struct btrfs_fs_info *fs_info = trans->fs_info;
 
-	trans->aborted = errno;
+	WRITE_ONCE(trans->aborted, errno);
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */
 	if (!trans->dirty && list_empty(&trans->new_bgs)) {

commit 0024652895e3479cd0d372f63b57d9581a0bdd38
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Fri Jan 24 09:33:01 2020 -0500

    btrfs: rename btrfs_put_fs_root and btrfs_grab_fs_root
    
    We are now using these for all roots, rename them to btrfs_put_root()
    and btrfs_grab_root();
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d6629e693a96..6420df4e86d7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1144,7 +1144,7 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 			ptr[0] = '/';
 			btrfs_release_path(path);
 		}
-		btrfs_put_fs_root(fs_root);
+		btrfs_put_root(fs_root);
 		fs_root = NULL;
 	}
 
@@ -1158,7 +1158,7 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 	return name;
 
 err:
-	btrfs_put_fs_root(fs_root);
+	btrfs_put_root(fs_root);
 	btrfs_free_path(path);
 	kfree(name);
 	return ERR_PTR(ret);

commit 8260edba67a2e6bd5e709d32188e23aa22cb4a38
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Fri Jan 24 09:32:59 2020 -0500

    btrfs: make the init of static elements in fs_info separate
    
    In adding things like eb leak checking and root leak checking there were
    a lot of weird corner cases that come from the fact that
    
      1) We do not init the fs_info until we get to open_ctree time in the
         normal case and
    
      2) The test infrastructure half-init's the fs_info for things that it
         needs.
    
    This makes it really annoying to make changes because you have to add
    init in two different places, have special cases for testing fs_info's
    that may not have certain things initialized, and cases for fs_info's
    that didn't make it to open_ctree and thus are not fully set up.
    
    Fix this by extracting out the non-allocating init of the fs info into
    it's own public function and use that to make sure we're all getting
    consistent views of an allocated fs_info.
    
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f1ad1189c930..d6629e693a96 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1522,14 +1522,17 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	/*
 	 * Setup a dummy root and fs_info for test/set super.  This is because
 	 * we don't actually fill this stuff out until open_ctree, but we need
-	 * it for searching for existing supers, so this lets us do that and
-	 * then open_ctree will properly initialize everything later.
+	 * then open_ctree will properly initialize the file system specific
+	 * settings later.  btrfs_init_fs_info initializes the static elements
+	 * of the fs_info (locks and such) to make cleanup easier if we find a
+	 * superblock with our given fs_devices later on at sget() time.
 	 */
 	fs_info = kvzalloc(sizeof(struct btrfs_fs_info), GFP_KERNEL);
 	if (!fs_info) {
 		error = -ENOMEM;
 		goto error_sec_opts;
 	}
+	btrfs_init_fs_info(fs_info);
 
 	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
 	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);

commit bc44d7c4b2b179c4b74fba208b9908e2ecbc1b4d
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Fri Jan 24 09:32:56 2020 -0500

    btrfs: push btrfs_grab_fs_root into btrfs_get_fs_root
    
    Now that all callers of btrfs_get_fs_root are subsequently calling
    btrfs_grab_fs_root and handling dropping the ref when they are done
    appropriately, go ahead and push btrfs_grab_fs_root up into
    btrfs_get_fs_root.
    
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a70c89b3a223..f1ad1189c930 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1102,11 +1102,6 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 			fs_root = NULL;
 			goto err;
 		}
-		if (!btrfs_grab_fs_root(fs_root)) {
-			ret = -ENOENT;
-			fs_root = NULL;
-			goto err;
-		}
 
 		/*
 		 * Walk up the filesystem tree by inode refs until we hit the

commit 0d4b0463011de06288d8ca80a873a97a7d99a948
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Fri Jan 24 09:32:53 2020 -0500

    btrfs: export and rename free_fs_info
    
    We're going to start freeing roots and doing other complicated things in
    free_fs_info, so we need to move it to disk-io.c and export it in order
    to use things lik btrfs_put_fs_root().
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2c459d29e099..a70c89b3a223 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1580,7 +1580,7 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 
 	if (s->s_root) {
 		btrfs_close_devices(fs_devices);
-		free_fs_info(fs_info);
+		btrfs_free_fs_info(fs_info);
 		if ((flags ^ s->s_flags) & SB_RDONLY)
 			error = -EBUSY;
 	} else {
@@ -1603,7 +1603,7 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 error_close_devices:
 	btrfs_close_devices(fs_devices);
 error_fs_info:
-	free_fs_info(fs_info);
+	btrfs_free_fs_info(fs_info);
 error_sec_opts:
 	security_free_mnt_opts(&new_sec_opts);
 	return ERR_PTR(error);
@@ -2179,7 +2179,7 @@ static void btrfs_kill_super(struct super_block *sb)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	kill_anon_super(sb);
-	free_fs_info(fs_info);
+	btrfs_free_fs_info(fs_info);
 }
 
 static struct file_system_type btrfs_fs_type = {

commit 5168489a079aacd5626156ce5f8ab77325bcde15
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Thu Feb 6 10:24:26 2020 -0500

    btrfs: hold a ref on the root in get_subvol_name_from_objectid
    
    We lookup the name of a subvol which means we'll cross into different
    roots.  Hold a ref while we're doing the look ups in the fs_root we're
    searching.
    
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a2c2e71af122..2c459d29e099 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1028,7 +1028,7 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 					   u64 subvol_objectid)
 {
 	struct btrfs_root *root = fs_info->tree_root;
-	struct btrfs_root *fs_root;
+	struct btrfs_root *fs_root = NULL;
 	struct btrfs_root_ref *root_ref;
 	struct btrfs_inode_ref *inode_ref;
 	struct btrfs_key key;
@@ -1099,6 +1099,12 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 		fs_root = btrfs_get_fs_root(fs_info, &key, true);
 		if (IS_ERR(fs_root)) {
 			ret = PTR_ERR(fs_root);
+			fs_root = NULL;
+			goto err;
+		}
+		if (!btrfs_grab_fs_root(fs_root)) {
+			ret = -ENOENT;
+			fs_root = NULL;
 			goto err;
 		}
 
@@ -1143,6 +1149,8 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 			ptr[0] = '/';
 			btrfs_release_path(path);
 		}
+		btrfs_put_fs_root(fs_root);
+		fs_root = NULL;
 	}
 
 	btrfs_free_path(path);
@@ -1155,6 +1163,7 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 	return name;
 
 err:
+	btrfs_put_fs_root(fs_root);
 	btrfs_free_path(path);
 	kfree(name);
 	return ERR_PTR(ret);

commit 3619c94f073e4e96bef4cc15e70adbc36f3cb203
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Fri Jan 24 09:32:24 2020 -0500

    btrfs: open code btrfs_read_fs_root_no_name
    
    All this does is call btrfs_get_fs_root() with check_ref == true.  Just
    use btrfs_get_fs_root() so we don't have a bunch of different helpers
    that do the same thing.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1cbc3f125d5a..a2c2e71af122 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1096,7 +1096,7 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 		key.objectid = subvol_objectid;
 		key.type = BTRFS_ROOT_ITEM_KEY;
 		key.offset = (u64)-1;
-		fs_root = btrfs_read_fs_root_no_name(fs_info, &key);
+		fs_root = btrfs_get_fs_root(fs_info, &key, true);
 		if (IS_ERR(fs_root)) {
 			ret = PTR_ERR(fs_root);
 			goto err;

commit cfe953c8240d1b21a81b8bd7f33cfe0b96b89f38
Author: Su Yue <Damenly_Su@gmx.com>
Date:   Tue Feb 4 12:51:56 2020 +0800

    btrfs: update the comment of btrfs_control_ioctl()
    
    Btrfsctl was removed in 2012, now the function btrfs_control_ioctl()
    is only used for devices ioctls. So update the comment.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Su Yue <Damenly_Su@gmx.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 67c63858812a..1cbc3f125d5a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2203,7 +2203,7 @@ static int btrfs_control_open(struct inode *inode, struct file *file)
 }
 
 /*
- * used by btrfsctl to scan devices when no FS is mounted
+ * Used by /dev/btrfs-control for devices ioctls.
  */
 static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg)

commit 10a3a3edc5b89a8cd095bc63495fb1e0f42047d9
Author: David Sterba <dsterba@suse.com>
Date:   Wed Feb 5 17:12:28 2020 +0100

    btrfs: log message when rw remount is attempted with unclean tree-log
    
    A remount to a read-write filesystem is not safe when there's tree-log
    to be replayed. Files that could be opened until now might be affected
    by the changes in the tree-log.
    
    A regular mount is needed to replay the log so the filesystem presents
    the consistent view with the pending changes included.
    
    CC: stable@vger.kernel.org # 4.4+
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0616a5434793..67c63858812a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1834,6 +1834,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		}
 
 		if (btrfs_super_log_root(fs_info->super_copy) != 0) {
+			btrfs_warn(fs_info,
+		"mount required to replay tree-log, cannot remount read-write");
 			ret = -EINVAL;
 			goto restore;
 		}

commit d55966c4279bfc6a0cf0b32bf13f5df228a1eeb6
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Fri Jan 31 09:31:05 2020 -0500

    btrfs: do not zero f_bavail if we have available space
    
    There was some logic added a while ago to clear out f_bavail in statfs()
    if we did not have enough free metadata space to satisfy our global
    reserve.  This was incorrect at the time, however didn't really pose a
    problem for normal file systems because we would often allocate chunks
    if we got this low on free metadata space, and thus wouldn't really hit
    this case unless we were actually full.
    
    Fast forward to today and now we are much better about not allocating
    metadata chunks all of the time.  Couple this with d792b0f19711 ("btrfs:
    always reserve our entire size for the global reserve") which now means
    we'll easily have a larger global reserve than our free space, we are
    now more likely to trip over this while still having plenty of space.
    
    Fix this by skipping this logic if the global rsv's space_info is not
    full.  space_info->full is 0 unless we've attempted to allocate a chunk
    for that space_info and that has failed.  If this happens then the space
    for the global reserve is definitely sacred and we need to report
    b_avail == 0, but before then we can just use our calculated b_avail.
    
    Reported-by: Martin Steigerwald <martin@lichtvoll.de>
    Fixes: ca8a51b3a979 ("btrfs: statfs: report zero available if metadata are exhausted")
    CC: stable@vger.kernel.org # 4.5+
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Tested-By: Martin Steigerwald <martin@lichtvoll.de>
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a906315efd19..0616a5434793 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2135,7 +2135,15 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	 */
 	thresh = SZ_4M;
 
-	if (!mixed && total_free_meta - thresh < block_rsv->size)
+	/*
+	 * We only want to claim there's no available space if we can no longer
+	 * allocate chunks for our metadata profile and our global reserve will
+	 * not fit in the free metadata space.  If we aren't ->full then we
+	 * still can allocate chunks and thus are fine using the currently
+	 * calculated f_bavail.
+	 */
+	if (!mixed && block_rsv->space_info->full &&
+	    total_free_meta - thresh < block_rsv->size)
 		buf->f_bavail = 0;
 
 	buf->f_type = BTRFS_SUPER_MAGIC;

commit b0643e59cfa609c4b5f246f2b2c33b078f87e9d9
Author: Dennis Zhou <dennis@kernel.org>
Date:   Fri Dec 13 16:22:14 2019 -0800

    btrfs: add the beginning of async discard, discard workqueue
    
    When discard is enabled, everytime a pinned extent is released back to
    the block_group's free space cache, a discard is issued for the extent.
    This is an overeager approach when it comes to discarding and helping
    the SSD maintain enough free space to prevent severe garbage collection
    situations.
    
    This adds the beginning of async discard. Instead of issuing a discard
    prior to returning it to the free space, it is just marked as untrimmed.
    The block_group is then added to a LRU which then feeds into a workqueue
    to issue discards at a much slower rate. Full discarding of unused block
    groups is still done and will be addressed in a future patch of the
    series.
    
    For now, we don't persist the discard state of extents and bitmaps.
    Therefore, our failure recovery mode will be to consider extents
    untrimmed. This lets us handle failure and unmounting as one in the
    same.
    
    On a number of Facebook webservers, I collected data every minute
    accounting the time we spent in btrfs_finish_extent_commit() (col. 1)
    and in btrfs_commit_transaction() (col. 2). btrfs_finish_extent_commit()
    is where we discard extents synchronously before returning them to the
    free space cache.
    
    discard=sync:
                     p99 total per minute       p99 total per minute
          Drive   |   extent_commit() (ms)  |    commit_trans() (ms)
        ---------------------------------------------------------------
         Drive A  |           434           |          1170
         Drive B  |           880           |          2330
         Drive C  |          2943           |          3920
         Drive D  |          4763           |          5701
    
    discard=async:
                     p99 total per minute       p99 total per minute
          Drive   |   extent_commit() (ms)  |    commit_trans() (ms)
        --------------------------------------------------------------
         Drive A  |           134           |           956
         Drive B  |            64           |          1972
         Drive C  |            59           |          1032
         Drive D  |            62           |          1200
    
    While it's not great that the stats are cumulative over 1m, all of these
    servers are running the same workload and and the delta between the two
    are substantial. We are spending significantly less time in
    btrfs_finish_extent_commit() which is responsible for discarding.
    
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: Dennis Zhou <dennis@kernel.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 08ac6a7a67f0..a906315efd19 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -46,6 +46,7 @@
 #include "sysfs.h"
 #include "tests/btrfs-tests.h"
 #include "block-group.h"
+#include "discard.h"
 
 #include "qgroup.h"
 #define CREATE_TRACE_POINTS
@@ -146,6 +147,8 @@ void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function
 	if (sb_rdonly(sb))
 		return;
 
+	btrfs_discard_stop(fs_info);
+
 	/* btrfs handle error by forcing the filesystem readonly */
 	sb->s_flags |= SB_RDONLY;
 	btrfs_info(fs_info, "forced readonly");
@@ -313,6 +316,7 @@ enum {
 	Opt_datasum, Opt_nodatasum,
 	Opt_defrag, Opt_nodefrag,
 	Opt_discard, Opt_nodiscard,
+	Opt_discard_mode,
 	Opt_nologreplay,
 	Opt_norecovery,
 	Opt_ratio,
@@ -375,6 +379,7 @@ static const match_table_t tokens = {
 	{Opt_defrag, "autodefrag"},
 	{Opt_nodefrag, "noautodefrag"},
 	{Opt_discard, "discard"},
+	{Opt_discard_mode, "discard=%s"},
 	{Opt_nodiscard, "nodiscard"},
 	{Opt_nologreplay, "nologreplay"},
 	{Opt_norecovery, "norecovery"},
@@ -695,12 +700,26 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 				   info->metadata_ratio);
 			break;
 		case Opt_discard:
-			btrfs_set_and_info(info, DISCARD_SYNC,
-					   "turning on sync discard");
+		case Opt_discard_mode:
+			if (token == Opt_discard ||
+			    strcmp(args[0].from, "sync") == 0) {
+				btrfs_clear_opt(info->mount_opt, DISCARD_ASYNC);
+				btrfs_set_and_info(info, DISCARD_SYNC,
+						   "turning on sync discard");
+			} else if (strcmp(args[0].from, "async") == 0) {
+				btrfs_clear_opt(info->mount_opt, DISCARD_SYNC);
+				btrfs_set_and_info(info, DISCARD_ASYNC,
+						   "turning on async discard");
+			} else {
+				ret = -EINVAL;
+				goto out;
+			}
 			break;
 		case Opt_nodiscard:
 			btrfs_clear_and_info(info, DISCARD_SYNC,
 					     "turning off discard");
+			btrfs_clear_and_info(info, DISCARD_ASYNC,
+					     "turning off async discard");
 			break;
 		case Opt_space_cache:
 		case Opt_space_cache_version:
@@ -1324,6 +1343,8 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",flushoncommit");
 	if (btrfs_test_opt(info, DISCARD_SYNC))
 		seq_puts(seq, ",discard");
+	if (btrfs_test_opt(info, DISCARD_ASYNC))
+		seq_puts(seq, ",discard=async");
 	if (!(info->sb->s_flags & SB_POSIXACL))
 		seq_puts(seq, ",noacl");
 	if (btrfs_test_opt(info, SPACE_CACHE))
@@ -1713,6 +1734,14 @@ static inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,
 		btrfs_cleanup_defrag_inodes(fs_info);
 	}
 
+	/* If we toggled discard async */
+	if (!btrfs_raw_test_opt(old_opts, DISCARD_ASYNC) &&
+	    btrfs_test_opt(fs_info, DISCARD_ASYNC))
+		btrfs_discard_resume(fs_info);
+	else if (btrfs_raw_test_opt(old_opts, DISCARD_ASYNC) &&
+		 !btrfs_test_opt(fs_info, DISCARD_ASYNC))
+		btrfs_discard_cleanup(fs_info);
+
 	clear_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);
 }
 
@@ -1760,6 +1789,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		 */
 		cancel_work_sync(&fs_info->async_reclaim_work);
 
+		btrfs_discard_cleanup(fs_info);
+
 		/* wait for the uuid_scan task to finish */
 		down(&fs_info->uuid_tree_rescan_sem);
 		/* avoid complains from lockdep et al. */

commit 46b27f5059e6ce7a7e3805d53144b37897723e3b
Author: Dennis Zhou <dennis@kernel.org>
Date:   Fri Dec 13 16:22:11 2019 -0800

    btrfs: rename DISCARD mount option to to DISCARD_SYNC
    
    This series introduces async discard which will use the flag
    DISCARD_ASYNC, so rename the original flag to DISCARD_SYNC as it is
    synchronously done in transaction commit.
    
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Dennis Zhou <dennis@kernel.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f452a94abdc3..08ac6a7a67f0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -695,11 +695,11 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 				   info->metadata_ratio);
 			break;
 		case Opt_discard:
-			btrfs_set_and_info(info, DISCARD,
-					   "turning on discard");
+			btrfs_set_and_info(info, DISCARD_SYNC,
+					   "turning on sync discard");
 			break;
 		case Opt_nodiscard:
-			btrfs_clear_and_info(info, DISCARD,
+			btrfs_clear_and_info(info, DISCARD_SYNC,
 					     "turning off discard");
 			break;
 		case Opt_space_cache:
@@ -1322,7 +1322,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",nologreplay");
 	if (btrfs_test_opt(info, FLUSHONCOMMIT))
 		seq_puts(seq, ",flushoncommit");
-	if (btrfs_test_opt(info, DISCARD))
+	if (btrfs_test_opt(info, DISCARD_SYNC))
 		seq_puts(seq, ",discard");
 	if (!(info->sb->s_flags & SB_POSIXACL))
 		seq_puts(seq, ",noacl");

commit 0da522107e5d9c000a4871d52e570912aa1225a2
Merge: ad0b314e0030 142b2ac82e31
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 1 13:46:15 2019 -0800

    Merge tag 'compat-ioctl-5.5' of git://git.kernel.org:/pub/scm/linux/kernel/git/arnd/playground
    
    Pull removal of most of fs/compat_ioctl.c from Arnd Bergmann:
     "As part of the cleanup of some remaining y2038 issues, I came to
      fs/compat_ioctl.c, which still has a couple of commands that need
      support for time64_t.
    
      In completely unrelated work, I spent time on cleaning up parts of
      this file in the past, moving things out into drivers instead.
    
      After Al Viro reviewed an earlier version of this series and did a lot
      more of that cleanup, I decided to try to completely eliminate the
      rest of it and move it all into drivers.
    
      This series incorporates some of Al's work and many patches of my own,
      but in the end stops short of actually removing the last part, which
      is the scsi ioctl handlers. I have patches for those as well, but they
      need more testing or possibly a rewrite"
    
    * tag 'compat-ioctl-5.5' of git://git.kernel.org:/pub/scm/linux/kernel/git/arnd/playground: (42 commits)
      scsi: sd: enable compat ioctls for sed-opal
      pktcdvd: add compat_ioctl handler
      compat_ioctl: move SG_GET_REQUEST_TABLE handling
      compat_ioctl: ppp: move simple commands into ppp_generic.c
      compat_ioctl: handle PPPIOCGIDLE for 64-bit time_t
      compat_ioctl: move PPPIOCSCOMPRESS to ppp_generic
      compat_ioctl: unify copy-in of ppp filters
      tty: handle compat PPP ioctls
      compat_ioctl: move SIOCOUTQ out of compat_ioctl.c
      compat_ioctl: handle SIOCOUTQNSD
      af_unix: add compat_ioctl support
      compat_ioctl: reimplement SG_IO handling
      compat_ioctl: move WDIOC handling into wdt drivers
      fs: compat_ioctl: move FITRIM emulation into file systems
      gfs2: add compat_ioctl support
      compat_ioctl: remove unused convert_in_user macro
      compat_ioctl: remove last RAID handling code
      compat_ioctl: remove /dev/raw ioctl translation
      compat_ioctl: remove PCI ioctl translation
      compat_ioctl: remove joystick ioctl translation
      ...

commit 8d6fac0087e538173f34ca7431ed9b58581acf28
Author: David Sterba <dsterba@suse.com>
Date:   Fri Mar 2 22:56:53 2018 +0100

    btrfs: add support for 4-copy replication (raid1c4)
    
    Add new block group profile to store 4 copies in a simliar way that
    current RAID1 does.  The profile attributes and constraints are defined
    in the raid table and used by the same code that already handles the 2-
    and 3-copy RAID1.
    
    The minimum number of devices is 4, the maximum number of devices/chunks
    that can be lost/damaged is 3. There is no comparable traditional RAID
    level, the profile is added for future needs to accompany triple-parity
    and beyond.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a5aff138e2e0..a98c3c71fc54 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1937,6 +1937,8 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 		num_stripes = 2;
 	else if (type & BTRFS_BLOCK_GROUP_RAID1C3)
 		num_stripes = 3;
+	else if (type & BTRFS_BLOCK_GROUP_RAID1C4)
+		num_stripes = 4;
 	else if (type & BTRFS_BLOCK_GROUP_RAID10)
 		num_stripes = 4;
 

commit 47e6f7423b9196ad6832d26cae52b7015f81ee7f
Author: David Sterba <dsterba@suse.com>
Date:   Fri Mar 2 22:56:53 2018 +0100

    btrfs: add support for 3-copy replication (raid1c3)
    
    Add new block group profile to store 3 copies in a simliar way that
    current RAID1 does. The profile attributes and constraints are defined
    in the raid table and used by the same code that already handles the
    2-copy RAID1.
    
    The minimum number of devices is 3, the maximum number of devices/chunks
    that can be lost/damaged is 2. Like RAID6 but with 33% space
    utilization.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3f49407cc2aa..a5aff138e2e0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1935,6 +1935,8 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 		num_stripes = nr_devices;
 	else if (type & BTRFS_BLOCK_GROUP_RAID1)
 		num_stripes = 2;
+	else if (type & BTRFS_BLOCK_GROUP_RAID1C3)
+		num_stripes = 3;
 	else if (type & BTRFS_BLOCK_GROUP_RAID10)
 		num_stripes = 4;
 

commit f5389f330d6f28d648c51624f059b0bfdd9b1806
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Thu Oct 24 17:44:54 2019 +0200

    btrfs: remove cached space_info in btrfs_statfs()
    
    In btrfs_statfs() we cache fs_info::space_info in a local variable only
    to use it once in a list_for_each_rcu() statement.
    
    Not only is the local variable unnecessary it even makes the code harder
    to follow as it's not clear which list it is iterating.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 792bb0bc9a0b..3f49407cc2aa 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2021,7 +2021,6 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(dentry->d_sb);
 	struct btrfs_super_block *disk_super = fs_info->super_copy;
-	struct list_head *head = &fs_info->space_info;
 	struct btrfs_space_info *found;
 	u64 total_used = 0;
 	u64 total_free_data = 0;
@@ -2035,7 +2034,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	int mixed = 0;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(found, head, list) {
+	list_for_each_entry_rcu(found, &fs_info->space_info, list) {
 		if (found->flags & BTRFS_BLOCK_GROUP_DATA) {
 			int i;
 

commit 352ae07b599a03b08a2149d9c2ff9c3479591af2
Author: David Sterba <dsterba@suse.com>
Date:   Mon Oct 7 11:11:02 2019 +0200

    btrfs: add blake2b to checksumming algorithms
    
    Add blake2b (with 256 bit digest) to the list of possible checksumming
    algorithms used by BTRFS.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 36440336c08b..792bb0bc9a0b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2464,3 +2464,4 @@ MODULE_LICENSE("GPL");
 MODULE_SOFTDEP("pre: crc32c");
 MODULE_SOFTDEP("pre: xxhash64");
 MODULE_SOFTDEP("pre: sha256");
+MODULE_SOFTDEP("pre: blake2b-256");

commit 3831bf0094abed51e71cbeca8b6edf8b88c2644b
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Mon Oct 7 11:11:02 2019 +0200

    btrfs: add sha256 to checksumming algorithm
    
    Add sha256 to the list of possible checksumming algorithms used by BTRFS.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c91cdf123cd8..36440336c08b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2463,3 +2463,4 @@ module_exit(exit_btrfs_fs)
 MODULE_LICENSE("GPL");
 MODULE_SOFTDEP("pre: crc32c");
 MODULE_SOFTDEP("pre: xxhash64");
+MODULE_SOFTDEP("pre: sha256");

commit 3951e7f050ac6a38bbc859fc3cd6093890c31d1c
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Mon Oct 7 11:11:01 2019 +0200

    btrfs: add xxhash64 to checksumming algorithms
    
    Add xxhash64 to the list of possible checksumming algorithms used by
    BTRFS.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d5d15a19f51d..c91cdf123cd8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2462,3 +2462,4 @@ module_exit(exit_btrfs_fs)
 
 MODULE_LICENSE("GPL");
 MODULE_SOFTDEP("pre: crc32c");
+MODULE_SOFTDEP("pre: xxhash64");

commit ba8a9d07954397f0645cf62bcc1ef536e8e7ba24
Author: Chris Mason <clm@fb.com>
Date:   Wed Jul 10 12:28:15 2019 -0700

    Btrfs: delete the entire async bio submission framework
    
    Now that we're not using btrfs_schedule_bio() anymore, delete all the
    code that supported it.
    
    Reviewed-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 144933c9b507..d5d15a19f51d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1669,7 +1669,6 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 
 	btrfs_workqueue_set_max(fs_info->workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);
-	btrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->caching_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_meta_workers, new_pool_size);

commit 4143cb8b6f00910e73a7503fd922211b9f08cf48
Author: David Sterba <dsterba@suse.com>
Date:   Tue Oct 1 19:57:37 2019 +0200

    btrfs: add const function attribute
    
    For some reason the attribute is called __attribute_const__ and not
    __const, marks functions that have no observable effects on program
    state, IOW not reading pointers, just the arguments and calculating a
    value. Allows the compiler to do some optimizations, based on
    -Wsuggest-attribute=const . The effects are rather small, though, about
    60 bytes decrese of btrfs.ko.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9c0c53e7d0fc..144933c9b507 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -66,7 +66,7 @@ static struct file_system_type btrfs_root_fs_type;
 
 static int btrfs_remount(struct super_block *sb, int *flags, char *data);
 
-const char *btrfs_decode_error(int errno)
+const char * __attribute_const__ btrfs_decode_error(int errno)
 {
 	char *errstr = "unknown";
 

commit b105e92755b448efd4800e3415dfeae5ad8054e9
Author: David Sterba <dsterba@suse.com>
Date:   Tue Oct 1 19:57:35 2019 +0200

    btrfs: add __cold attribute to more functions
    
    The attribute can mark functions supposed to be called rarely if at all
    and the text can be moved to sections far from the other code. The
    attribute has been added to several functions already, this patch is
    based on hints given by gcc -Wsuggest-attribute=cold.
    
    The net effect of this patch is decrease of btrfs.ko by 1000-1300,
    depending on the config options.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c7d78ac64b83..9c0c53e7d0fc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -187,7 +187,7 @@ static struct ratelimit_state printk_limits[] = {
 	RATELIMIT_STATE_INIT(printk_limits[7], DEFAULT_RATELIMIT_INTERVAL, 100),
 };
 
-void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
+void __cold btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 {
 	char lvl[PRINTK_MAX_SINGLE_HEADER_LEN + 1] = "\0";
 	struct va_format vaf;

commit 4c66e0d4243bb8829f2c936e966030d967726e90
Author: David Sterba <dsterba@suse.com>
Date:   Thu Oct 3 19:09:35 2019 +0200

    btrfs: drop unused parameter is_new from btrfs_iget
    
    The parameter is now always set to NULL and could be dropped. The last
    user was get_default_root but that got reworked in 05dbe6837b60 ("Btrfs:
    unify subvol= and subvolid= mounting") and the parameter became unused.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 843015b9a11e..c7d78ac64b83 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1219,7 +1219,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
 	key.type = BTRFS_INODE_ITEM_KEY;
 	key.offset = 0;
-	inode = btrfs_iget(sb, &key, fs_info->fs_root, NULL);
+	inode = btrfs_iget(sb, &key, fs_info->fs_root);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
 		goto fail_close;

commit 6f0d04f8e72e1c7fd17e7fac0fea82553a6443b4
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Mon Sep 23 10:05:18 2019 -0400

    btrfs: separate out the extent io init function
    
    We are moving extent_io_tree into it's on file, so separate out the
    extent_state init stuff from extent_io_tree_init().
    
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1b151af25772..843015b9a11e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2360,10 +2360,14 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_cachep;
 
-	err = extent_map_init();
+	err = extent_state_cache_init();
 	if (err)
 		goto free_extent_io;
 
+	err = extent_map_init();
+	if (err)
+		goto free_extent_state_cache;
+
 	err = ordered_data_init();
 	if (err)
 		goto free_extent_map;
@@ -2422,6 +2426,8 @@ static int __init init_btrfs_fs(void)
 	ordered_data_exit();
 free_extent_map:
 	extent_map_exit();
+free_extent_state_cache:
+	extent_state_cache_exit();
 free_extent_io:
 	extent_io_exit();
 free_cachep:
@@ -2442,6 +2448,7 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_prelim_ref_exit();
 	ordered_data_exit();
 	extent_map_exit();
+	extent_state_cache_exit();
 	extent_io_exit();
 	btrfs_interface_exit();
 	btrfs_end_io_wq_exit();

commit 1832f2d8ff69138aa70d3cb3b4ea3c2058e73aea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Sep 11 21:59:08 2018 +0200

    compat_ioctl: move more drivers to compat_ptr_ioctl
    
    The .ioctl and .compat_ioctl file operations have the same prototype so
    they can both point to the same function, which works great almost all
    the time when all the commands are compatible.
    
    One exception is the s390 architecture, where a compat pointer is only
    31 bit wide, and converting it into a 64-bit pointer requires calling
    compat_ptr(). Most drivers here will never run in s390, but since we now
    have a generic helper for it, it's easy enough to use it consistently.
    
    I double-checked all these drivers to ensure that all ioctl arguments
    are used as pointers or are ignored, but are not interpreted as integer
    values.
    
    Acked-by: Jason Gunthorpe <jgg@mellanox.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: David Sterba <dsterba@suse.com>
    Acked-by: Darren Hart (VMware) <dvhart@infradead.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1b151af25772..d9ba089a4973 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2297,7 +2297,7 @@ static const struct super_operations btrfs_super_ops = {
 static const struct file_operations btrfs_ctl_fops = {
 	.open = btrfs_control_open,
 	.unlocked_ioctl	 = btrfs_control_ioctl,
-	.compat_ioctl = btrfs_control_ioctl,
+	.compat_ioctl = compat_ptr_ioctl,
 	.owner	 = THIS_MODULE,
 	.llseek = noop_llseek,
 };

commit 89439109bc2be5f19c0955d392fb6ea7d0f4ecb3
Author: David Sterba <dsterba@suse.com>
Date:   Thu Aug 1 17:34:41 2019 +0200

    btrfs: move sysfs declarations out of ctree.h
    
    As the header for sysfs code already exists, use it to clean up ctree.h.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 16c7af333d3a..1b151af25772 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -43,6 +43,7 @@
 #include "free-space-cache.h"
 #include "backref.h"
 #include "space-info.h"
+#include "sysfs.h"
 #include "tests/btrfs-tests.h"
 #include "block-group.h"
 

commit aac0023c2106952538414254960c51dcf0dc39e9
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Thu Jun 20 15:37:44 2019 -0400

    btrfs: move basic block_group definitions to their own header
    
    This is prep work for moving all of the block group cache code into its
    own file.
    
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ minor comment updates ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 10bc7e6cca75..16c7af333d3a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -44,6 +44,7 @@
 #include "backref.h"
 #include "space-info.h"
 #include "tests/btrfs-tests.h"
+#include "block-group.h"
 
 #include "qgroup.h"
 #define CREATE_TRACE_POINTS

commit 559ca6ea695e3dedc7b6a11ce31fcc6eac398797
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Wed Jul 3 15:32:59 2019 +0300

    btrfs: Refactor btrfs_calc_avail_data_space
    
    Simplify the code by removing variables that don't bring any real value
    as well as simplifying the checks when buidling the candidate list of
    devices. No functional changes.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 78de9d5d80c6..10bc7e6cca75 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1899,11 +1899,10 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	struct btrfs_device_info *devices_info;
 	struct btrfs_fs_devices *fs_devices = fs_info->fs_devices;
 	struct btrfs_device *device;
-	u64 skip_space;
 	u64 type;
 	u64 avail_space;
 	u64 min_stripe_size;
-	int min_stripes, num_stripes = 1;
+	int num_stripes = 1;
 	int i = 0, nr_devices;
 	const struct btrfs_raid_attr *rattr;
 
@@ -1930,7 +1929,6 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	/* calc min stripe number for data space allocation */
 	type = btrfs_data_alloc_profile(fs_info);
 	rattr = &btrfs_raid_array[btrfs_bg_flags_to_raid_index(type)];
-	min_stripes = rattr->devs_min;
 
 	if (type & BTRFS_BLOCK_GROUP_RAID0)
 		num_stripes = nr_devices;
@@ -1956,28 +1954,21 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 		avail_space = device->total_bytes - device->bytes_used;
 
 		/* align with stripe_len */
-		avail_space = div_u64(avail_space, BTRFS_STRIPE_LEN);
-		avail_space *= BTRFS_STRIPE_LEN;
+		avail_space = rounddown(avail_space, BTRFS_STRIPE_LEN);
 
 		/*
 		 * In order to avoid overwriting the superblock on the drive,
 		 * btrfs starts at an offset of at least 1MB when doing chunk
 		 * allocation.
+		 *
+		 * This ensures we have at least min_stripe_size free space
+		 * after excluding 1MB.
 		 */
-		skip_space = SZ_1M;
-
-		/*
-		 * we can use the free space in [0, skip_space - 1], subtract
-		 * it from the total.
-		 */
-		if (avail_space && avail_space >= skip_space)
-			avail_space -= skip_space;
-		else
-			avail_space = 0;
-
-		if (avail_space < min_stripe_size)
+		if (avail_space <= SZ_1M + min_stripe_size)
 			continue;
 
+		avail_space -= SZ_1M;
+
 		devices_info[i].dev = device;
 		devices_info[i].max_avail = avail_space;
 
@@ -1991,9 +1982,8 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 
 	i = nr_devices - 1;
 	avail_space = 0;
-	while (nr_devices >= min_stripes) {
-		if (num_stripes > nr_devices)
-			num_stripes = nr_devices;
+	while (nr_devices >= rattr->devs_min) {
+		num_stripes = min(num_stripes, nr_devices);
 
 		if (devices_info[i].max_avail >= min_stripe_size) {
 			int j;

commit 8719aaae8d696bf0c73f74e6d6cc75451b50d5df
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Tue Jun 18 16:09:16 2019 -0400

    btrfs: move space_info to space-info.h
    
    Migrate the struct definition and the one helper that's in ctree.h into
    space-info.h
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7d20856ae0c4..78de9d5d80c6 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -42,6 +42,7 @@
 #include "dev-replace.h"
 #include "free-space-cache.h"
 #include "backref.h"
+#include "space-info.h"
 #include "tests/btrfs-tests.h"
 
 #include "qgroup.h"

commit e1ea2beee284d8e434e51e60de9e157a18fe8b42
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 18 20:00:13 2019 +0200

    btrfs: use raid_attr for minimum stripe count in btrfs_calc_avail_data_space
    
    Minimum stripe count matches the minimum devices required for a given
    profile. The open coded assignments match the raid_attr table.
    
    What's changed here is the meaning for RAID5/6. Previously their
    min_stripes would be 1, while newly it's devs_min. This however shold be
    the same as before because it's not possible to create filesystem on
    fewer devices than the raid_attr table allows.
    
    There's no adjustment regarding the parity stripes (like
    calc_data_stripes does), because we're interested in overall space that
    would fit on the devices.
    
    Missing devices make no difference for the whole calculation, we have
    the size stored in the structures.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2b44223e98a9..7d20856ae0c4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1902,7 +1902,7 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	u64 type;
 	u64 avail_space;
 	u64 min_stripe_size;
-	int min_stripes = 1, num_stripes = 1;
+	int min_stripes, num_stripes = 1;
 	int i = 0, nr_devices;
 	const struct btrfs_raid_attr *rattr;
 
@@ -1929,17 +1929,14 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	/* calc min stripe number for data space allocation */
 	type = btrfs_data_alloc_profile(fs_info);
 	rattr = &btrfs_raid_array[btrfs_bg_flags_to_raid_index(type)];
+	min_stripes = rattr->devs_min;
 
-	if (type & BTRFS_BLOCK_GROUP_RAID0) {
-		min_stripes = 2;
+	if (type & BTRFS_BLOCK_GROUP_RAID0)
 		num_stripes = nr_devices;
-	} else if (type & BTRFS_BLOCK_GROUP_RAID1) {
-		min_stripes = 2;
+	else if (type & BTRFS_BLOCK_GROUP_RAID1)
 		num_stripes = 2;
-	} else if (type & BTRFS_BLOCK_GROUP_RAID10) {
-		min_stripes = 4;
+	else if (type & BTRFS_BLOCK_GROUP_RAID10)
 		num_stripes = 4;
-	}
 
 	/* Adjust for more than 1 stripe per device */
 	min_stripe_size = rattr->dev_stripes * BTRFS_STRIPE_LEN;

commit 4f080f571192b0347f45b5709a291af473824484
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 18 20:00:11 2019 +0200

    btrfs: use raid_attr to adjust minimal stripe size in btrfs_calc_avail_data_space
    
    Special case for DUP can be replaced by lookup to the attribute table,
    where the dev_stripes is the right coefficient.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6e196b8a0820..2b44223e98a9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1904,6 +1904,7 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	u64 min_stripe_size;
 	int min_stripes = 1, num_stripes = 1;
 	int i = 0, nr_devices;
+	const struct btrfs_raid_attr *rattr;
 
 	/*
 	 * We aren't under the device list lock, so this is racy-ish, but good
@@ -1927,6 +1928,8 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 
 	/* calc min stripe number for data space allocation */
 	type = btrfs_data_alloc_profile(fs_info);
+	rattr = &btrfs_raid_array[btrfs_bg_flags_to_raid_index(type)];
+
 	if (type & BTRFS_BLOCK_GROUP_RAID0) {
 		min_stripes = 2;
 		num_stripes = nr_devices;
@@ -1938,10 +1941,8 @@ static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 		num_stripes = 4;
 	}
 
-	if (type & BTRFS_BLOCK_GROUP_DUP)
-		min_stripe_size = 2 * BTRFS_STRIPE_LEN;
-	else
-		min_stripe_size = BTRFS_STRIPE_LEN;
+	/* Adjust for more than 1 stripe per device */
+	min_stripe_size = rattr->dev_stripes * BTRFS_STRIPE_LEN;
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {

commit d5178578bcd461cc79118c7a139882350fe505aa
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Mon Jun 3 16:58:57 2019 +0200

    btrfs: directly call into crypto framework for checksumming
    
    Currently btrfs_csum_data() relied on the crc32c() wrapper around the
    crypto framework for calculating the CRCs.
    
    As we have our own crypto_shash structure in the fs_info now, we can
    directly call into the crypto framework without going trough the wrapper.
    
    This way we can even remove the btrfs_csum_data() and btrfs_csum_final()
    wrappers.
    
    The module dependency on crc32c is preserved via MODULE_SOFTDEP("pre:
    crc32c"), which was previously provided by LIBCRC32C config option doing
    the same.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 526dbae5c4cf..6e196b8a0820 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2464,3 +2464,4 @@ late_initcall(init_btrfs_fs);
 module_exit(exit_btrfs_fs)
 
 MODULE_LICENSE("GPL");
+MODULE_SOFTDEP("pre: crc32c");

commit cebf05ca65d68d0de869a74754e0a0be35056243
Author: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date:   Fri Oct 5 07:26:15 2018 -0500

    btrfs: Remove unused variable mode in btrfs_mount
    
    This is a leftover from 312c89fbca06 ("btrfs: cleanup btrfs_mount()
    using btrfs_mount_root()"), the mode was used for opening devices that's
    not done here anymore.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index db410c6b5f5f..526dbae5c4cf 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1603,14 +1603,10 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 {
 	struct vfsmount *mnt_root;
 	struct dentry *root;
-	fmode_t mode = FMODE_READ;
 	char *subvol_name = NULL;
 	u64 subvol_objectid = 0;
 	int error = 0;
 
-	if (!(flags & SB_RDONLY))
-		mode |= FMODE_WRITE;
-
 	error = btrfs_parse_subvol_options(data, &subvol_name,
 					&subvol_objectid);
 	if (error) {

commit 9b4e675a9978800995f83af0ed90e890ca501f31
Author: David Sterba <dsterba@suse.com>
Date:   Thu May 16 13:39:59 2019 +0200

    btrfs: detect fast implementation of crc32c on all architectures
    
    Currently, there's only check for fast crc32c implementation on X86,
    based on the CPU flags. This is used to decide if checksumming should be
    offloaded to worker threads or can be calculated by the caller.
    
    As there are more architectures that implement a faster version of
    crc32c (ARM, SPARC, s390, MIPS, PowerPC), also there are specialized hw
    cards.
    
    The detection is based on driver name, all generic C implementations
    contain 'generic', while the specialized versions do not. Alternatively
    the priority could be used, but this is not currently provided by the
    crypto API.
    
    The flag is set per-filesystem at mount time and used for the offloading
    decisions.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0645ec428b4f..db410c6b5f5f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1553,6 +1553,8 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	} else {
 		snprintf(s->s_id, sizeof(s->s_id), "%pg", bdev);
 		btrfs_sb(s)->bdev_holder = fs_type;
+		if (!strstr(crc32c_impl(), "generic"))
+			set_bit(BTRFS_FS_CSUM_IMPL_FAST, &fs_info->flags);
 		error = btrfs_fill_super(s, fs_devices, data);
 	}
 	if (!error)

commit 9f2e3a53f7ec9ef55e9d01bc29a6285d291c151e
Merge: 78438ce18f26 b1c16ac978fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 11:34:19 2019 -0700

    Merge tag 'for-5.2-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs updates from David Sterba:
     "This time the majority of changes are cleanups, though there's still a
      number of changes of user interest.
    
      User visible changes:
    
       - better read time and write checks to catch errors early and before
         writing data to disk (to catch potential memory corruption on data
         that get checksummed)
    
       - qgroups + metadata relocation: last speed up patch int the series
         to address the slowness, there should be no overhead comparing
         balance with and without qgroups
    
       - FIEMAP ioctl does not start a transaction unnecessarily, this can
         result in a speed up and less blocking due to IO
    
       - LOGICAL_INO (v1, v2) does not start transaction unnecessarily, this
         can speed up the mentioned ioctl and scrub as well
    
       - fsync on files with many (but not too many) hardlinks is faster,
         finer decision if the links should be fsynced individually or
         completely
    
       - send tries harder to find ranges to clone
    
       - trim/discard will skip unallocated chunks that haven't been touched
         since the last mount
    
      Fixes:
    
       - send flushes delayed allocation before start, otherwise it could
         miss some changes in case of a very recent rw->ro switch of a
         subvolume
    
       - fix fallocate with qgroups that could lead to space accounting
         underflow, reported as a warning
    
       - trim/discard ioctl honours the requested range
    
       - starting send and dedupe on a subvolume at the same time will let
         only one of them succeed, this is to prevent changes that send
         could miss due to dedupe; both operations are restartable
    
      Core changes:
    
       - more tree-checker validations, errors reported by fuzzing tools:
          - device item
          - inode item
          - block group profiles
    
       - tracepoints for extent buffer locking
    
       - async cow preallocates memory to avoid errors happening too deep in
         the call chain
    
       - metadata reservations for delalloc reworked to better adapt in
         many-writers/low-space scenarios
    
       - improved space flushing logic for intense DIO vs buffered workloads
    
       - lots of cleanups
          - removed unused struct members
          - redundant argument removal
          - properties and xattrs
          - extent buffer locking
          - selftests
          - use common file type conversions
          - many-argument functions reduction"
    
    * tag 'for-5.2-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux: (227 commits)
      btrfs: Use kvmalloc for allocating compressed path context
      btrfs: Factor out common extent locking code in submit_compressed_extents
      btrfs: Set io_tree only once in submit_compressed_extents
      btrfs: Replace clear_extent_bit with unlock_extent
      btrfs: Make compress_file_range take only struct async_chunk
      btrfs: Remove fs_info from struct async_chunk
      btrfs: Rename async_cow to async_chunk
      btrfs: Preallocate chunks in cow_file_range_async
      btrfs: reserve delalloc metadata differently
      btrfs: track DIO bytes in flight
      btrfs: merge calls of btrfs_setxattr and btrfs_setxattr_trans in btrfs_set_prop
      btrfs: delete unused function btrfs_set_prop_trans
      btrfs: start transaction in xattr_handler_set_prop
      btrfs: drop local copy of inode i_mode
      btrfs: drop old_fsflags in btrfs_ioctl_setflags
      btrfs: modify local copy of btrfs_inode flags
      btrfs: drop useless inode i_flags copy and restore
      btrfs: start transaction in btrfs_ioctl_setflags()
      btrfs: export btrfs_set_prop
      btrfs: refactor btrfs_set_props to validate externally
      ...

commit 26602cab411782dab49a75b316f375933ef380d3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 10 15:14:41 2019 -0400

    btrfs: use ->free_inode()
    
    a lot of stuff remains in ->destroy_inode()
    
    Acked-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 120e4340792a..236f812091a3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2298,6 +2298,7 @@ static const struct super_operations btrfs_super_ops = {
 	.show_devname	= btrfs_show_devname,
 	.alloc_inode	= btrfs_alloc_inode,
 	.destroy_inode	= btrfs_destroy_inode,
+	.free_inode	= btrfs_free_inode,
 	.statfs		= btrfs_statfs,
 	.remount_fs	= btrfs_remount,
 	.freeze_fs	= btrfs_freeze,

commit ae0bc863106ae45b189986c76fda44f6885e8769
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Mar 29 14:03:17 2019 +0800

    btrfs: drop unused parameter in mount_subvol
    
    @device_name in mount_subvol() is not used, drop it.  Also see:
    5bedc48a8f9e ("btrfs: drop unused parameters from mount_subvol").
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 120e4340792a..2c66d9ea6a3b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1400,7 +1400,7 @@ static inline int is_subvolume_inode(struct inode *inode)
 }
 
 static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
-				   const char *device_name, struct vfsmount *mnt)
+				   struct vfsmount *mnt)
 {
 	struct dentry *root;
 	int ret;
@@ -1649,7 +1649,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	}
 
 	/* mount_subvol() will free subvol_name and mnt_root */
-	root = mount_subvol(subvol_name, subvol_objectid, device_name, mnt_root);
+	root = mount_subvol(subvol_name, subvol_objectid, mnt_root);
 
 out:
 	return root;

commit 3f93aef535c8ea03e40cd8acf0753b3e6ed33e96
Author: Dennis Zhou <dennis@kernel.org>
Date:   Mon Feb 4 15:20:08 2019 -0500

    btrfs: add zstd compression level support
    
    Zstd compression requires different amounts of memory for each level of
    compression. The prior patches implemented indirection to allow for each
    compression type to manage their workspaces independently. This patch
    uses this indirection to implement compression level support for zstd.
    
    To manage the additional memory require, each compression level has its
    own queue of workspaces. A global LRU is used to help with reclaim.
    Reclaim is done via a timer which provides a mechanism to decrease
    memory utilization by keeping only workspaces around that are sized
    appropriately. Forward progress is guaranteed by a preallocated max
    workspace hidden from the LRU.
    
    When getting a workspace, it uses a bitmap to identify the levels that
    are populated and scans up. If it finds a workspace that is greater than
    it, it uses it, but does not update the last_used time and the
    corresponding place in the LRU. If we hit memory pressure, we sleep on
    the max level workspace. We continue to rescan in case we can use a
    smaller workspace, but eventually should be able to obtain the max level
    workspace or allocate one again should memory pressure subside.
    
    The memory requirement for decompression is the same as level 1, and
    therefore can use any of available workspace.
    
    The number of workspaces is bound by an upper limit of the workqueue's
    limit which currently is 2 (percpu limit). The reclaim timer is used to
    free inactive/improperly sized workspaces and is set to 307s to avoid
    colliding with transaction commit (every 30s).
    
    Repeating the experiment from v2 [1], the Silesia corpus was copied to a
    btrfs filesystem 10 times and then read back after dropping the caches.
    The btrfs filesystem was on an SSD.
    
    Level   Ratio   Compression (MB/s)  Decompression (MB/s)  Memory (KB)
    1       2.658        438.47                910.51            780
    2       2.744        364.86                886.55           1004
    3       2.801        336.33                828.41           1260
    4       2.858        286.71                886.55           1260
    5       2.916        212.77                556.84           1388
    6       2.363        119.82                990.85           1516
    7       3.000        154.06                849.30           1516
    8       3.011        159.54                875.03           1772
    9       3.025        100.51                940.15           1772
    10      3.033        118.97                616.26           1772
    11      3.036         94.19                802.11           1772
    12      3.037         73.45                931.49           1772
    13      3.041         55.17                835.26           2284
    14      3.087         44.70                716.78           2547
    15      3.126         37.30                878.84           2547
    
    [1] https://lore.kernel.org/linux-btrfs/20181031181108.289340-1-terrelln@fb.com/
    
    Cc: Nick Terrell <terrelln@fb.com>
    Cc: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Dennis Zhou <dennis@kernel.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9ac94c9d597d..120e4340792a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -544,9 +544,13 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 				btrfs_clear_opt(info->mount_opt, NODATASUM);
 				btrfs_set_fs_incompat(info, COMPRESS_LZO);
 				no_compress = 0;
-			} else if (strcmp(args[0].from, "zstd") == 0) {
+			} else if (strncmp(args[0].from, "zstd", 4) == 0) {
 				compress_type = "zstd";
 				info->compress_type = BTRFS_COMPRESS_ZSTD;
+				info->compress_level =
+					btrfs_compress_str2level(
+							 BTRFS_COMPRESS_ZSTD,
+							 args[0].from + 4);
 				btrfs_set_opt(info->mount_opt, COMPRESS);
 				btrfs_clear_opt(info->mount_opt, NODATACOW);
 				btrfs_clear_opt(info->mount_opt, NODATASUM);

commit d0ab62ce2ded36294f3a02156415b8157d660b95
Author: Dennis Zhou <dennis@kernel.org>
Date:   Mon Feb 4 15:20:05 2019 -0500

    btrfs: change set_level() to bound the level passed in
    
    Currently, the only user of set_level() is zlib which sets an internal
    workspace parameter. As level is now plumbed into get_workspace(), this
    can be handled there rather than separately.
    
    This repurposes set_level() to bound the level passed in so it can be
    used when setting the mounts compression level and as well as verifying
    the level before getting a workspace. The other benefit is this divides
    the meaning of compress(0) and get_workspace(0). The former means we
    want to use the default compression level of the compression type. The
    latter means we can use any workspace available.
    
    Signed-off-by: Dennis Zhou <dennis@kernel.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f9d13a30aa8a..9ac94c9d597d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -529,7 +529,9 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 				if (token != Opt_compress &&
 				    token != Opt_compress_force)
 					info->compress_level =
-					  btrfs_compress_str2level(args[0].from);
+					  btrfs_compress_str2level(
+							BTRFS_COMPRESS_ZLIB,
+							args[0].from + 4);
 				btrfs_set_opt(info->mount_opt, COMPRESS);
 				btrfs_clear_opt(info->mount_opt, NODATACOW);
 				btrfs_clear_opt(info->mount_opt, NODATASUM);

commit 228a73abde5c04428678e917b271f8526cfd90ed
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Jan 4 13:31:54 2019 +0800

    btrfs: introduce new ioctl to unregister a btrfs device
    
    Support for a new command that can be used eg. as a command
    
      $ btrfs device scan --forget [dev]'
    (the final name may change though)
    
    to undo the effects of 'btrfs device scan [dev]'. For this purpose
    this patch proposes to use ioctl #5 as it was empty and is next to the
    SCAN ioctl.
    
    The new ioctl BTRFS_IOC_FORGET_DEV works only on the control device
    (/dev/btrfs-control) to unregister one or all devices, devices that are
    not mounted.
    
    The argument is struct btrfs_ioctl_vol_args, ::name specifies the device
    path. To unregister all device, the path is an empty string.
    
    Again, the devices are removed only if they aren't part of a mounte
    filesystem.
    
    This new ioctl provides:
    
    - release of unwanted btrfs_fs_devices and btrfs_devices structures
      from memory if the device is not going to be mounted
    
    - ability to mount filesystem in degraded mode, when one devices is
      corrupted like in split brain raid1
    
    - running test cases which would require reloading the kernel module
      but this is not possible eg. due to mounted filesystem or built-in
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ update changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0a3f122dd61f..f9d13a30aa8a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2190,6 +2190,9 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 		ret = PTR_ERR_OR_ZERO(device);
 		mutex_unlock(&uuid_mutex);
 		break;
+	case BTRFS_IOC_FORGET_DEV:
+		ret = btrfs_forget_devices(vol->name);
+		break;
 	case BTRFS_IOC_DEVICES_READY:
 		mutex_lock(&uuid_mutex);
 		device = btrfs_scan_one_device(vol->name, FMODE_READ,

commit 312b3a93dda6db9354b0c6b0f1868c1434e8c787
Merge: 12491ed354d2 532b618bdf23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 3 08:48:33 2019 -0800

    Merge tag 'for-5.0-rc4-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs fixes from David Sterba:
    
     - regression fix: transaction commit can run away due to delayed ref
       waiting heuristic, this is not necessary now because of the proper
       reservation mechanism introduced in 5.0
    
     - regression fix: potential crash due to use-before-check of an ERR_PTR
       return value
    
     - fix for transaction abort during transaction commit that needs to
       properly clean up pending block groups
    
     - fix deadlock during b-tree node/leaf splitting, when this happens on
       some of the fundamental trees, we must prevent new tree block
       allocation to re-enter indirectly via the block group flushing path
    
     - potential memory leak after errors during mount
    
    * tag 'for-5.0-rc4-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux:
      btrfs: On error always free subvol_name in btrfs_mount
      btrfs: clean up pending block groups when transaction commit aborts
      btrfs: fix potential oops in device_list_add
      btrfs: don't end the transaction for delayed refs in throttle
      Btrfs: fix deadlock when allocating tree block during leaf/node split

commit 532b618bdf237250d6d4566536d4b6ce3d0a31fe
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jan 30 07:54:12 2019 -0600

    btrfs: On error always free subvol_name in btrfs_mount
    
    The subvol_name is allocated in btrfs_parse_subvol_options and is
    consumed and freed in mount_subvol.  Add a free to the error paths that
    don't call mount_subvol so that it is guaranteed that subvol_name is
    freed when an error happens.
    
    Fixes: 312c89fbca06 ("btrfs: cleanup btrfs_mount() using btrfs_mount_root()")
    Cc: stable@vger.kernel.org # v4.19+
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 368a5b9e6c13..74023786a735 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1677,6 +1677,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 				flags | SB_RDONLY, device_name, data);
 			if (IS_ERR(mnt_root)) {
 				root = ERR_CAST(mnt_root);
+				kfree(subvol_name);
 				goto out;
 			}
 
@@ -1686,12 +1687,14 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 			if (error < 0) {
 				root = ERR_PTR(error);
 				mntput(mnt_root);
+				kfree(subvol_name);
 				goto out;
 			}
 		}
 	}
 	if (IS_ERR(mnt_root)) {
 		root = ERR_CAST(mnt_root);
+		kfree(subvol_name);
 		goto out;
 	}
 

commit 505b050fdf42097883b2d37b8e796e1f11dbef50
Merge: 9b286efeb5eb 718c43038f28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 5 13:25:58 2019 -0800

    Merge branch 'mount.part1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount API prep from Al Viro:
     "Mount API prereqs.
    
      Mostly that's LSM mount options cleanups. There are several minor
      fixes in there, but nothing earth-shattering (leaks on failure exits,
      mostly)"
    
    * 'mount.part1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (27 commits)
      mount_fs: suppress MAC on MS_SUBMOUNT as well as MS_KERNMOUNT
      smack: rewrite smack_sb_eat_lsm_opts()
      smack: get rid of match_token()
      smack: take the guts of smack_parse_opts_str() into a new helper
      LSM: new method: ->sb_add_mnt_opt()
      selinux: rewrite selinux_sb_eat_lsm_opts()
      selinux: regularize Opt_... names a bit
      selinux: switch away from match_token()
      selinux: new helper - selinux_add_opt()
      LSM: bury struct security_mnt_opts
      smack: switch to private smack_mnt_opts
      selinux: switch to private struct selinux_mnt_opts
      LSM: hide struct security_mnt_opts from any generic code
      selinux: kill selinux_sb_get_mnt_opts()
      LSM: turn sb_eat_lsm_opts() into a method
      nfs_remount(): don't leak, don't ignore LSM options quietly
      btrfs: sanitize security_mnt_opts use
      selinux; don't open-code a loop in sb_finish_set_opts()
      LSM: split ->sb_set_mnt_opts() out of ->sb_kern_mount()
      new helper: security_sb_eat_lsm_opts()
      ...

commit 204cc0ccf1d49c6292aeef4c8edd1b3d10ff933c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 13 13:41:47 2018 -0500

    LSM: hide struct security_mnt_opts from any generic code
    
    Keep void * instead, allocate on demand (in parse_str_opts, at the
    moment).  Eventually both selinux and smack will be better off
    with private structures with several strings in those, rather than
    this "counter and two pointers to dynamically allocated arrays"
    ugliness.  This commit allows to do that at leisure, without
    disrupting anything outside of given module.
    
    Changes:
            * instead of struct security_mnt_opt use an opaque pointer
    initialized to NULL.
            * security_sb_eat_lsm_opts(), security_sb_parse_opts_str() and
    security_free_mnt_opts() take it as var argument (i.e. as void **);
    call sites are unchanged.
            * security_sb_set_mnt_opts() and security_sb_remount() take
    it by value (i.e. as void *).
            * new method: ->sb_free_mnt_opts().  Takes void *, does
    whatever freeing that needs to be done.
            * ->sb_set_mnt_opts() and ->sb_remount() might get NULL as
    mnt_opts argument, meaning "empty".
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3b04e7735b5f..e90c4616ed6a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1472,14 +1472,13 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	struct btrfs_device *device = NULL;
 	struct btrfs_fs_devices *fs_devices = NULL;
 	struct btrfs_fs_info *fs_info = NULL;
-	struct security_mnt_opts new_sec_opts;
+	void *new_sec_opts = NULL;
 	fmode_t mode = FMODE_READ;
 	int error = 0;
 
 	if (!(flags & SB_RDONLY))
 		mode |= FMODE_WRITE;
 
-	security_init_mnt_opts(&new_sec_opts);
 	if (data) {
 		error = security_sb_eat_lsm_opts(data, &new_sec_opts);
 		if (error)
@@ -1551,7 +1550,7 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 		error = btrfs_fill_super(s, fs_devices, data);
 	}
 	if (!error)
-		error = security_sb_set_mnt_opts(s, &new_sec_opts, 0, NULL);
+		error = security_sb_set_mnt_opts(s, new_sec_opts, 0, NULL);
 	security_free_mnt_opts(&new_sec_opts);
 	if (error) {
 		deactivate_locked_super(s);
@@ -1724,12 +1723,11 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	btrfs_remount_prepare(fs_info);
 
 	if (data) {
-		struct security_mnt_opts new_sec_opts;
+		void *new_sec_opts = NULL;
 
-		security_init_mnt_opts(&new_sec_opts);
 		ret = security_sb_eat_lsm_opts(data, &new_sec_opts);
 		if (!ret)
-			ret = security_sb_remount(sb, &new_sec_opts);
+			ret = security_sb_remount(sb, new_sec_opts);
 		security_free_mnt_opts(&new_sec_opts);
 		if (ret)
 			goto restore;

commit a65001e8a4d465693d0191297a6fd864c96b3147
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 10 17:19:21 2018 -0500

    btrfs: sanitize security_mnt_opts use
    
    1) keeping a copy in btrfs_fs_info is completely pointless - we never
    use it for anything.  Getting rid of that allows for simpler calling
    conventions for setup_security_options() (caller is responsible for
    freeing mnt_opts in all cases).
    
    2) on remount we want to use ->sb_remount(), not ->sb_set_mnt_opts(),
    same as we would if not for FS_BINARY_MOUNTDATA.  Behaviours *are*
    close (in fact, selinux sb_set_mnt_opts() ought to punt to
    sb_remount() in "already initialized" case), but let's handle
    that uniformly.  And the only reason why the original btrfs changes
    didn't go for security_sb_remount() in btrfs_remount() case is that
    it hadn't been exported.  Let's export it for a while - it'll be
    going away soon anyway.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6fc8e963ad44..3b04e7735b5f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1458,43 +1458,6 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 	return root;
 }
 
-static int parse_security_options(char *orig_opts,
-				  struct security_mnt_opts *sec_opts)
-{
-	return security_sb_eat_lsm_opts(orig_opts, sec_opts);
-}
-
-static int setup_security_options(struct btrfs_fs_info *fs_info,
-				  struct super_block *sb,
-				  struct security_mnt_opts *sec_opts)
-{
-	int ret = 0;
-
-	/*
-	 * Call security_sb_set_mnt_opts() to check whether new sec_opts
-	 * is valid.
-	 */
-	ret = security_sb_set_mnt_opts(sb, sec_opts, 0, NULL);
-	if (ret)
-		return ret;
-
-#ifdef CONFIG_SECURITY
-	if (!fs_info->security_opts.num_mnt_opts) {
-		/* first time security setup, copy sec_opts to fs_info */
-		memcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));
-	} else {
-		/*
-		 * Since SELinux (the only one supporting security_mnt_opts)
-		 * does NOT support changing context during remount/mount of
-		 * the same sb, this must be the same or part of the same
-		 * security options, just free it.
-		 */
-		security_free_mnt_opts(sec_opts);
-	}
-#endif
-	return ret;
-}
-
 /*
  * Find a superblock for the given device / mount point.
  *
@@ -1518,7 +1481,7 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 
 	security_init_mnt_opts(&new_sec_opts);
 	if (data) {
-		error = parse_security_options(data, &new_sec_opts);
+		error = security_sb_eat_lsm_opts(data, &new_sec_opts);
 		if (error)
 			return ERR_PTR(error);
 	}
@@ -1537,7 +1500,6 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 
 	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
 	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
-	security_init_mnt_opts(&fs_info->security_opts);
 	if (!fs_info->super_copy || !fs_info->super_for_commit) {
 		error = -ENOMEM;
 		goto error_fs_info;
@@ -1588,16 +1550,12 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 		btrfs_sb(s)->bdev_holder = fs_type;
 		error = btrfs_fill_super(s, fs_devices, data);
 	}
+	if (!error)
+		error = security_sb_set_mnt_opts(s, &new_sec_opts, 0, NULL);
+	security_free_mnt_opts(&new_sec_opts);
 	if (error) {
 		deactivate_locked_super(s);
-		goto error_sec_opts;
-	}
-
-	fs_info = btrfs_sb(s);
-	error = setup_security_options(fs_info, s, &new_sec_opts);
-	if (error) {
-		deactivate_locked_super(s);
-		goto error_sec_opts;
+		return ERR_PTR(error);
 	}
 
 	return dget(s->s_root);
@@ -1769,15 +1727,12 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		struct security_mnt_opts new_sec_opts;
 
 		security_init_mnt_opts(&new_sec_opts);
-		ret = parse_security_options(data, &new_sec_opts);
+		ret = security_sb_eat_lsm_opts(data, &new_sec_opts);
+		if (!ret)
+			ret = security_sb_remount(sb, &new_sec_opts);
+		security_free_mnt_opts(&new_sec_opts);
 		if (ret)
 			goto restore;
-		ret = setup_security_options(fs_info, sb,
-					     &new_sec_opts);
-		if (ret) {
-			security_free_mnt_opts(&new_sec_opts);
-			goto restore;
-		}
 	}
 
 	ret = btrfs_parse_options(fs_info, data, *flags);

commit f5c0c26d9008b355babb6d16f3d7c4de3bada0e7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Nov 17 12:09:18 2018 -0500

    new helper: security_sb_eat_lsm_opts()
    
    combination of alloc_secdata(), security_sb_copy_data(),
    security_sb_parse_opt_str() and free_secdata().
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b362b45dd757..6fc8e963ad44 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1461,20 +1461,7 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 static int parse_security_options(char *orig_opts,
 				  struct security_mnt_opts *sec_opts)
 {
-	char *secdata = NULL;
-	int ret = 0;
-
-	secdata = alloc_secdata();
-	if (!secdata)
-		return -ENOMEM;
-	ret = security_sb_copy_data(orig_opts, secdata);
-	if (ret) {
-		free_secdata(secdata);
-		return ret;
-	}
-	ret = security_sb_parse_opts_str(secdata, sec_opts);
-	free_secdata(secdata);
-	return ret;
+	return security_sb_eat_lsm_opts(orig_opts, sec_opts);
 }
 
 static int setup_security_options(struct btrfs_fs_info *fs_info,

commit 52042d8e82ff50d40e76a275ac0b97aa663328b0
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Wed Nov 28 12:05:13 2018 +0100

    btrfs: Fix typos in comments and strings
    
    The typos accumulate over time so once in a while time they get fixed in
    a large patch.
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d3c6bbc0aa3a..368a5b9e6c13 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -93,7 +93,7 @@ const char *btrfs_decode_error(int errno)
 
 /*
  * __btrfs_handle_fs_error decodes expected errors from the caller and
- * invokes the approciate error response.
+ * invokes the appropriate error response.
  */
 __cold
 void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function,
@@ -151,7 +151,7 @@ void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function
 	 * although there is no way to update the progress. It would add the
 	 * risk of a deadlock, therefore the canceling is omitted. The only
 	 * penalty is that some I/O remains active until the procedure
-	 * completes. The next time when the filesystem is mounted writeable
+	 * completes. The next time when the filesystem is mounted writable
 	 * again, the device replace operation continues.
 	 */
 }
@@ -1848,7 +1848,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 
 		if (!btrfs_check_rw_degradable(fs_info, NULL)) {
 			btrfs_warn(fs_info,
-				"too many missing devices, writeable remount is not allowed");
+		"too many missing devices, writable remount is not allowed");
 			ret = -EACCES;
 			goto restore;
 		}
@@ -2312,7 +2312,7 @@ static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 	 * device_list_mutex here as we only read the device data and the list
 	 * is protected by RCU.  Even if a device is deleted during the list
 	 * traversals, we'll get valid data, the freeing callback will wait at
-	 * least until until the rcu_read_unlock.
+	 * least until the rcu_read_unlock.
 	 */
 	rcu_read_lock();
 	cur_devices = fs_info->fs_devices;

commit de37aa513105f864d3c21105bf5542d498f21ca2
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Oct 30 16:43:24 2018 +0200

    btrfs: Remove fsid/metadata_fsid fields from btrfs_info
    
    Currently btrfs_fs_info structure contains a copy of the
    fsid/metadata_uuid fields. Same values are also contained in the
    btrfs_fs_devices structure which fs_info has a reference to. Let's
    reduce duplication by removing the fields from fs_info and always refer
    to the ones in fs_devices. No functional changes.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 645fc81e2a94..d3c6bbc0aa3a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2090,7 +2090,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	u64 total_free_data = 0;
 	u64 total_free_meta = 0;
 	int bits = dentry->d_sb->s_blocksize_bits;
-	__be32 *fsid = (__be32 *)fs_info->fsid;
+	__be32 *fsid = (__be32 *)fs_info->fs_devices->fsid;
 	unsigned factor = 1;
 	struct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;
 	int ret;

commit f505754fd6599230371cb01b9332754ddc104be1
Author: Filipe Manana <fdmanana@suse.com>
Date:   Wed Nov 14 11:35:24 2018 +0000

    Btrfs: ensure path name is null terminated at btrfs_control_ioctl
    
    We were using the path name received from user space without checking that
    it is null terminated. While btrfs-progs is well behaved and does proper
    validation and null termination, someone could call the ioctl and pass
    a non-null terminated patch, leading to buffer overrun problems in the
    kernel.  The ioctl is protected by CAP_SYS_ADMIN.
    
    So just set the last byte of the path to a null character, similar to what
    we do in other ioctls (add/remove/resize device, snapshot creation, etc).
    
    CC: stable@vger.kernel.org # 4.4+
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cbc9d0d2c12d..645fc81e2a94 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2237,6 +2237,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	vol = memdup_user((void __user *)arg, sizeof(*vol));
 	if (IS_ERR(vol))
 		return PTR_ERR(vol);
+	vol->name[BTRFS_PATH_NAME_MAX] = '\0';
 
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:

commit 7e17916b35797396f681a3270245fd29c1e4c250
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Nov 3 16:39:28 2018 +0100

    btrfs: avoid link error with CONFIG_NO_AUTO_INLINE
    
    Note: this patch fixes a problem in a feature outside of btrfs ("kernel
    hacking: add a config option to disable compiler auto-inlining") and is
    applied ahead of time due to cross-subsystem dependencies.
    
    On 32-bit ARM with gcc-8, I see a link error with the addition of the
    CONFIG_NO_AUTO_INLINE option:
    
    fs/btrfs/super.o: In function `btrfs_statfs':
    super.c:(.text+0x67b8): undefined reference to `__aeabi_uldivmod'
    super.c:(.text+0x67fc): undefined reference to `__aeabi_uldivmod'
    super.c:(.text+0x6858): undefined reference to `__aeabi_uldivmod'
    super.c:(.text+0x6920): undefined reference to `__aeabi_uldivmod'
    super.c:(.text+0x693c): undefined reference to `__aeabi_uldivmod'
    fs/btrfs/super.o:super.c:(.text+0x6958): more undefined references to `__aeabi_uldivmod' follow
    
    So far this is the only file that shows the behavior, so I'd propose
    to just work around it by marking the functions as 'static inline'
    that normally get inlined here.
    
    The reference to __aeabi_uldivmod comes from a div_u64() which has an
    optimization for a constant division that uses a straight '/' operator
    when the result should be known to the compiler. My interpretation is
    that as we turn off inlining, gcc still expects the result to be constant
    but fails to use that constant value.
    
    Link: https://lkml.kernel.org/r/20181103153941.1881966-1-arnd@arndb.de
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Changbin Du <changbin.du@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [ add the note ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b362b45dd757..cbc9d0d2c12d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1916,7 +1916,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 }
 
 /* Used to sort the devices by max_avail(descending sort) */
-static int btrfs_cmp_device_free_bytes(const void *dev_info1,
+static inline int btrfs_cmp_device_free_bytes(const void *dev_info1,
 				       const void *dev_info2)
 {
 	if (((struct btrfs_device_info *)dev_info1)->max_avail >
@@ -1945,8 +1945,8 @@ static inline void btrfs_descending_sort_devices(
  * The helper to calc the free space on the devices that can be used to store
  * file data.
  */
-static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
-				       u64 *free_bytes)
+static inline int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
+					      u64 *free_bytes)
 {
 	struct btrfs_device_info *devices_info;
 	struct btrfs_fs_devices *fs_devices = fs_info->fs_devices;

commit 4fd786e6c3d67b1348e0ad4f450efe9fc9d7a306
Author: Misono Tomohiro <misono.tomohiro@jp.fujitsu.com>
Date:   Mon Aug 6 14:25:24 2018 +0900

    btrfs: Remove 'objectid' member from struct btrfs_root
    
    There are two members in struct btrfs_root which indicate root's
    objectid: objectid and root_key.objectid.
    
    They are both set to the same value in __setup_root():
    
      static void __setup_root(struct btrfs_root *root,
                               struct btrfs_fs_info *fs_info,
                               u64 objectid)
      {
        ...
        root->objectid = objectid;
        ...
        root->root_key.objectid = objecitd;
        ...
      }
    
    and not changed to other value after initialization.
    
    grep in btrfs directory shows both are used in many places:
      $ grep -rI "root->root_key.objectid" | wc -l
      133
      $ grep -rI "root->objectid" | wc -l
      55
     (4.17, inc. some noise)
    
    It is confusing to have two similar variable names and it seems
    that there is no rule about which should be used in a certain case.
    
    Since ->root_key itself is needed for tree reloc tree, let's remove
    'objecitd' member and unify code to use ->root_key.objectid in all places.
    
    Signed-off-by: Misono Tomohiro <misono.tomohiro@jp.fujitsu.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6601c9aa5e35..b362b45dd757 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2177,8 +2177,10 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);
 	buf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);
 	/* Mask in the root object ID too, to disambiguate subvols */
-	buf->f_fsid.val[0] ^= BTRFS_I(d_inode(dentry))->root->objectid >> 32;
-	buf->f_fsid.val[1] ^= BTRFS_I(d_inode(dentry))->root->objectid;
+	buf->f_fsid.val[0] ^=
+		BTRFS_I(d_inode(dentry))->root->root_key.objectid >> 32;
+	buf->f_fsid.val[1] ^=
+		BTRFS_I(d_inode(dentry))->root->root_key.objectid;
 
 	return 0;
 }

commit 672d599041c862dd61a1576c32e946ef0d77aa34
Author: Misono Tomohiro <misono.tomohiro@jp.fujitsu.com>
Date:   Thu Aug 2 16:19:07 2018 +0900

    btrfs: Use wrapper macro for rcu string to remove duplicate code
    
    Cleanup patch and no functional changes.
    
    Signed-off-by: Misono Tomohiro <misono.tomohiro@jp.fujitsu.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 67de3c0fc85b..6601c9aa5e35 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2303,7 +2303,6 @@ static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 	struct btrfs_fs_devices *cur_devices;
 	struct btrfs_device *dev, *first_dev = NULL;
 	struct list_head *head;
-	struct rcu_string *name;
 
 	/*
 	 * Lightweight locking of the devices. We should not need
@@ -2327,12 +2326,10 @@ static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 		cur_devices = cur_devices->seed;
 	}
 
-	if (first_dev) {
-		name = rcu_dereference(first_dev->name);
-		seq_escape(m, name->str, " \t\n\\");
-	} else {
+	if (first_dev)
+		seq_escape(m, rcu_str_deref(first_dev->name), " \t\n\\");
+	else
 		WARN_ON(1);
-	}
 	rcu_read_unlock();
 	return 0;
 }

commit 3c4276936f6fbe52884b4ea4e6cc120b890a0f9f
Author: Josef Bacik <jbacik@fb.com>
Date:   Fri Jul 20 11:46:10 2018 -0700

    Btrfs: fix btrfs_write_inode vs delayed iput deadlock
    
    We recently ran into the following deadlock involving
    btrfs_write_inode():
    
    [  +0.005066]  __schedule+0x38e/0x8c0
    [  +0.007144]  schedule+0x36/0x80
    [  +0.006447]  bit_wait+0x11/0x60
    [  +0.006446]  __wait_on_bit+0xbe/0x110
    [  +0.007487]  ? bit_wait_io+0x60/0x60
    [  +0.007319]  __inode_wait_for_writeback+0x96/0xc0
    [  +0.009568]  ? autoremove_wake_function+0x40/0x40
    [  +0.009565]  inode_wait_for_writeback+0x21/0x30
    [  +0.009224]  evict+0xb0/0x190
    [  +0.006099]  iput+0x1a8/0x210
    [  +0.006103]  btrfs_run_delayed_iputs+0x73/0xc0
    [  +0.009047]  btrfs_commit_transaction+0x799/0x8c0
    [  +0.009567]  btrfs_write_inode+0x81/0xb0
    [  +0.008008]  __writeback_single_inode+0x267/0x320
    [  +0.009569]  writeback_sb_inodes+0x25b/0x4e0
    [  +0.008702]  wb_writeback+0x102/0x2d0
    [  +0.007487]  wb_workfn+0xa4/0x310
    [  +0.006794]  ? wb_workfn+0xa4/0x310
    [  +0.007143]  process_one_work+0x150/0x410
    [  +0.008179]  worker_thread+0x6d/0x520
    [  +0.007490]  kthread+0x12c/0x160
    [  +0.006620]  ? put_pwq_unlocked+0x80/0x80
    [  +0.008185]  ? kthread_park+0xa0/0xa0
    [  +0.007484]  ? do_syscall_64+0x53/0x150
    [  +0.007837]  ret_from_fork+0x29/0x40
    
    Writeback calls:
    
    btrfs_write_inode
      btrfs_commit_transaction
        btrfs_run_delayed_iputs
    
    If iput() is called on that same inode, evict() will wait for writeback
    forever.
    
    btrfs_write_inode() was originally added way back in 4730a4bc5bf3
    ("btrfs_dirty_inode") to support O_SYNC writes. However, ->write_inode()
    hasn't been used for O_SYNC since 148f948ba877 ("vfs: Introduce new
    helpers for syncing after writing to O_SYNC file or IS_SYNC inode"), so
    btrfs_write_inode() is actually unnecessary (and leads to a bunch of
    unnecessary commits). Get rid of it, which also gets rid of the
    deadlock.
    
    CC: stable@vger.kernel.org # 3.2+
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    [Omar: new commit message]
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index efe8b03ce380..67de3c0fc85b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2344,7 +2344,6 @@ static const struct super_operations btrfs_super_ops = {
 	.sync_fs	= btrfs_sync_fs,
 	.show_options	= btrfs_show_options,
 	.show_devname	= btrfs_show_devname,
-	.write_inode	= btrfs_write_inode,
 	.alloc_inode	= btrfs_alloc_inode,
 	.destroy_inode	= btrfs_destroy_inode,
 	.statfs		= btrfs_statfs,

commit 46df06b85e28eaf430aa5c8f8aa26120fa746b72
Author: David Sterba <dsterba@suse.com>
Date:   Fri Jul 13 20:46:30 2018 +0200

    btrfs: refactor block group replication factor calculation to a helper
    
    There are many places that open code the duplicity factor of the block
    group profiles, create a common helper. This can be easily extended for
    more copies.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d7a54c648c5f..efe8b03ce380 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2107,14 +2107,9 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 				btrfs_account_ro_block_groups_free_space(found);
 
 			for (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {
-				if (!list_empty(&found->block_groups[i])) {
-					switch (i) {
-					case BTRFS_RAID_DUP:
-					case BTRFS_RAID_RAID1:
-					case BTRFS_RAID_RAID10:
-						factor = 2;
-					}
-				}
+				if (!list_empty(&found->block_groups[i]))
+					factor = btrfs_bg_type_to_factor(
+						btrfs_raid_array[i].bg_flag);
 			}
 		}
 

commit fa59f27c8c35bbe00af8eff23de446a7f4b048b0
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Jul 16 22:18:07 2018 +0800

    btrfs: rename btrfs_parse_early_options
    
    Rename btrfs_parse_early_options() to btrfs_parse_device_options(). As
    btrfs_parse_early_options() parses the -o device options and scan the
    device provided. So this rename specifies its action. Also the function
    name is in line with btrfs_parse_subvol_options().
    No functional changes.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5384afae3364..d7a54c648c5f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -465,9 +465,8 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 		case Opt_subvolrootid:
 		case Opt_device:
 			/*
-			 * These are parsed by btrfs_parse_subvol_options
-			 * and btrfs_parse_early_options
-			 * and can be happily ignored here.
+			 * These are parsed by btrfs_parse_subvol_options or
+			 * btrfs_parse_device_options and can be ignored here.
 			 */
 			break;
 		case Opt_nodatasum:
@@ -883,8 +882,8 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
  * All other options will be parsed on much later in the mount process and
  * only when we need to allocate a new super block.
  */
-static int btrfs_parse_early_options(const char *options, fmode_t flags,
-				     void *holder)
+static int btrfs_parse_device_options(const char *options, fmode_t flags,
+				      void *holder)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *device_name, *opts, *orig, *p;
@@ -951,7 +950,7 @@ static int btrfs_parse_subvol_options(const char *options, char **subvol_name,
 
 	/*
 	 * strsep changes the string, duplicate it because
-	 * btrfs_parse_early_options gets called later
+	 * btrfs_parse_device_options gets called later
 	 */
 	opts = kstrdup(options, GFP_KERNEL);
 	if (!opts)
@@ -1558,7 +1557,7 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	}
 
 	mutex_lock(&uuid_mutex);
-	error = btrfs_parse_early_options(data, mode, fs_type);
+	error = btrfs_parse_device_options(data, mode, fs_type);
 	if (error) {
 		mutex_unlock(&uuid_mutex);
 		goto error_fs_info;

commit 36350e95a2b1feed6382fe38cc80f79ec35a1323
Author: Gu Jinxiang <gujx@cn.fujitsu.com>
Date:   Thu Jul 12 14:23:16 2018 +0800

    btrfs: return device pointer from btrfs_scan_one_device
    
    Return device pointer (with the IS_ERR semantics) from
    btrfs_scan_one_device so we don't have to return in through pointer.
    
    And since btrfs_fs_devices can be obtained from btrfs_device, return that.
    
    Signed-off-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ fixed conflics after recent changes to btrfs_scan_one_device ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 909ea2564e84..5384afae3364 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -888,7 +888,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *device_name, *opts, *orig, *p;
-	struct btrfs_fs_devices *fs_devices = NULL;
+	struct btrfs_device *device = NULL;
 	int error = 0;
 
 	lockdep_assert_held(&uuid_mutex);
@@ -918,11 +918,13 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 				error = -ENOMEM;
 				goto out;
 			}
-			error = btrfs_scan_one_device(device_name,
-					flags, holder, &fs_devices);
+			device = btrfs_scan_one_device(device_name, flags,
+					holder);
 			kfree(device_name);
-			if (error)
+			if (IS_ERR(device)) {
+				error = PTR_ERR(device);
 				goto out;
+			}
 		}
 	}
 
@@ -1518,6 +1520,7 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 {
 	struct block_device *bdev = NULL;
 	struct super_block *s;
+	struct btrfs_device *device = NULL;
 	struct btrfs_fs_devices *fs_devices = NULL;
 	struct btrfs_fs_info *fs_info = NULL;
 	struct security_mnt_opts new_sec_opts;
@@ -1561,12 +1564,14 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 		goto error_fs_info;
 	}
 
-	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
-	if (error) {
+	device = btrfs_scan_one_device(device_name, mode, fs_type);
+	if (IS_ERR(device)) {
 		mutex_unlock(&uuid_mutex);
+		error = PTR_ERR(device);
 		goto error_fs_info;
 	}
 
+	fs_devices = device->fs_devices;
 	fs_info->fs_devices = fs_devices;
 
 	error = btrfs_open_devices(fs_devices, mode, fs_type);
@@ -2227,7 +2232,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg)
 {
 	struct btrfs_ioctl_vol_args *vol;
-	struct btrfs_fs_devices *fs_devices;
+	struct btrfs_device *device = NULL;
 	int ret = -ENOTTY;
 
 	if (!capable(CAP_SYS_ADMIN))
@@ -2240,19 +2245,22 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:
 		mutex_lock(&uuid_mutex);
-		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
-					    &btrfs_root_fs_type, &fs_devices);
+		device = btrfs_scan_one_device(vol->name, FMODE_READ,
+					       &btrfs_root_fs_type);
+		ret = PTR_ERR_OR_ZERO(device);
 		mutex_unlock(&uuid_mutex);
 		break;
 	case BTRFS_IOC_DEVICES_READY:
 		mutex_lock(&uuid_mutex);
-		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
-					    &btrfs_root_fs_type, &fs_devices);
-		if (ret) {
+		device = btrfs_scan_one_device(vol->name, FMODE_READ,
+					       &btrfs_root_fs_type);
+		if (IS_ERR(device)) {
 			mutex_unlock(&uuid_mutex);
+			ret = PTR_ERR(device);
 			break;
 		}
-		ret = !(fs_devices->num_devices == fs_devices->total_devices);
+		ret = !(device->fs_devices->num_devices ==
+			device->fs_devices->total_devices);
 		mutex_unlock(&uuid_mutex);
 		break;
 	case BTRFS_IOC_GET_SUPPORTED_FEATURES:

commit d64dcbd183abab251beb0fa0acd81a772a09887e
Author: Gu Jinxiang <gujx@cn.fujitsu.com>
Date:   Thu Jul 12 14:23:15 2018 +0800

    btrfs: make fs_devices a local variable in btrfs_parse_early_options
    
    fs_devices is always passed to btrfs_scan_one_device which overrides it.
    In the call stack below fs_devices is passed to btrfs_scan_one_device
    from btrfs_mount_root.  In btrfs_mount_root the output fs_devices of
    this call stack is not used.
    
    btrfs_mount_root
      btrfs_parse_early_options
        btrfs_scan_one_device
    
    So, it is not necessary to pass fs_devices from btrfs_mount_root, using
    a local variable in btrfs_parse_early_options is enough.
    
    Signed-off-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Reviewed-by: Anand Jain <Anand.Jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 28ab75ebb983..909ea2564e84 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -884,10 +884,11 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
  * only when we need to allocate a new super block.
  */
 static int btrfs_parse_early_options(const char *options, fmode_t flags,
-		void *holder, struct btrfs_fs_devices **fs_devices)
+				     void *holder)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *device_name, *opts, *orig, *p;
+	struct btrfs_fs_devices *fs_devices = NULL;
 	int error = 0;
 
 	lockdep_assert_held(&uuid_mutex);
@@ -918,7 +919,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 				goto out;
 			}
 			error = btrfs_scan_one_device(device_name,
-					flags, holder, fs_devices);
+					flags, holder, &fs_devices);
 			kfree(device_name);
 			if (error)
 				goto out;
@@ -1554,7 +1555,7 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	}
 
 	mutex_lock(&uuid_mutex);
-	error = btrfs_parse_early_options(data, mode, fs_type, &fs_devices);
+	error = btrfs_parse_early_options(data, mode, fs_type);
 	if (error) {
 		mutex_unlock(&uuid_mutex);
 		goto error_fs_info;

commit 81ffd56b5745355b70d54ca4e1bdd0d64a66ff9f
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 19 18:04:07 2018 +0200

    btrfs: fix mount and ioctl device scan ioctl race
    
    Technically this extends the critical section covered by uuid_mutex to:
    
    - parse early mount options -- here we can call device scan on paths
      that can be passed as 'device=/dev/...'
    
    - scan the device passed to mount
    
    - open the devices related to the fs_devices -- this increases
      fs_devices::opened
    
    The race can happen when mount calls one of the scans and there's
    another one called eg. by mkfs or 'btrfs dev scan':
    
    Mount                                  Scan
    -----                                  ----
    scan_one_device (dev1, fsid1)
                                           scan_one_device (dev2, fsid1)
                                               add the device
                                               free stale devices
                                                   fsid1 fs_devices::opened == 0
                                                       find fsid1:dev1
                                                       free fsid1:dev1
                                                       if it's the last one,
                                                        free fs_devices of fsid1
                                                        too
    
    open_devices (dev1, fsid1)
       dev1 not found
    
    When fixed, the uuid mutex will make sure that mount will increase
    fs_devices::opened and this will not be touched by the racing scan
    ioctl.
    
    Reported-and-tested-by: syzbot+909a5177749d7990ffa4@syzkaller.appspotmail.com
    Reported-and-tested-by: syzbot+ceb2606025ec1cc3479c@syzkaller.appspotmail.com
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d33fc1fc4285..28ab75ebb983 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1555,19 +1555,19 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 
 	mutex_lock(&uuid_mutex);
 	error = btrfs_parse_early_options(data, mode, fs_type, &fs_devices);
-	mutex_unlock(&uuid_mutex);
-	if (error)
+	if (error) {
+		mutex_unlock(&uuid_mutex);
 		goto error_fs_info;
+	}
 
-	mutex_lock(&uuid_mutex);
 	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
-	mutex_unlock(&uuid_mutex);
-	if (error)
+	if (error) {
+		mutex_unlock(&uuid_mutex);
 		goto error_fs_info;
+	}
 
 	fs_info->fs_devices = fs_devices;
 
-	mutex_lock(&uuid_mutex);
 	error = btrfs_open_devices(fs_devices, mode, fs_type);
 	mutex_unlock(&uuid_mutex);
 	if (error)

commit 399f7f4c42e8a58c8456264d5112287aefe44cf4
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 19 18:01:24 2018 +0200

    btrfs: reorder initialization before the mount locks uuid_mutex
    
    In preparation to take a big lock, move resource initialization before
    the critical section. It's not obvious from the diff, the desired order
    is:
    
    - initialize mount security options
    - allocate temporary fs_info
    - allocate superblock buffers
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index de87b7b0367d..d33fc1fc4285 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1526,14 +1526,6 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	if (!(flags & SB_RDONLY))
 		mode |= FMODE_WRITE;
 
-	mutex_lock(&uuid_mutex);
-	error = btrfs_parse_early_options(data, mode, fs_type,
-					  &fs_devices);
-	mutex_unlock(&uuid_mutex);
-	if (error) {
-		return ERR_PTR(error);
-	}
-
 	security_init_mnt_opts(&new_sec_opts);
 	if (data) {
 		error = parse_security_options(data, &new_sec_opts);
@@ -1541,12 +1533,6 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 			return ERR_PTR(error);
 	}
 
-	mutex_lock(&uuid_mutex);
-	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
-	mutex_unlock(&uuid_mutex);
-	if (error)
-		goto error_sec_opts;
-
 	/*
 	 * Setup a dummy root and fs_info for test/set super.  This is because
 	 * we don't actually fill this stuff out until open_ctree, but we need
@@ -1559,8 +1545,6 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 		goto error_sec_opts;
 	}
 
-	fs_info->fs_devices = fs_devices;
-
 	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
 	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
 	security_init_mnt_opts(&fs_info->security_opts);
@@ -1569,6 +1553,20 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 		goto error_fs_info;
 	}
 
+	mutex_lock(&uuid_mutex);
+	error = btrfs_parse_early_options(data, mode, fs_type, &fs_devices);
+	mutex_unlock(&uuid_mutex);
+	if (error)
+		goto error_fs_info;
+
+	mutex_lock(&uuid_mutex);
+	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
+	mutex_unlock(&uuid_mutex);
+	if (error)
+		goto error_fs_info;
+
+	fs_info->fs_devices = fs_devices;
+
 	mutex_lock(&uuid_mutex);
 	error = btrfs_open_devices(fs_devices, mode, fs_type);
 	mutex_unlock(&uuid_mutex);

commit 5139cff598d42b1e531f40c84691a7e945f04553
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 19 17:50:25 2018 +0200

    btrfs: lift uuid_mutex to callers of btrfs_parse_early_options
    
    Prepartory work to fix race between mount and device scan.
    
    btrfs_parse_early_options calls the device scan from mount and we'll
    need to let mount completely manage the critical section.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d470eb6b9226..de87b7b0367d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -890,6 +890,8 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 	char *device_name, *opts, *orig, *p;
 	int error = 0;
 
+	lockdep_assert_held(&uuid_mutex);
+
 	if (!options)
 		return 0;
 
@@ -915,10 +917,8 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 				error = -ENOMEM;
 				goto out;
 			}
-			mutex_lock(&uuid_mutex);
 			error = btrfs_scan_one_device(device_name,
 					flags, holder, fs_devices);
-			mutex_unlock(&uuid_mutex);
 			kfree(device_name);
 			if (error)
 				goto out;
@@ -1526,8 +1526,10 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	if (!(flags & SB_RDONLY))
 		mode |= FMODE_WRITE;
 
+	mutex_lock(&uuid_mutex);
 	error = btrfs_parse_early_options(data, mode, fs_type,
 					  &fs_devices);
+	mutex_unlock(&uuid_mutex);
 	if (error) {
 		return ERR_PTR(error);
 	}

commit f5194e34cabaddd348a90f950e0a8188dd26cdc0
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 19 17:09:47 2018 +0200

    btrfs: lift uuid_mutex to callers of btrfs_open_devices
    
    Prepartory work to fix race between mount and device scan.
    
    The callers will have to manage the critical section, eg. mount wants to
    scan and then call btrfs_open_devices without the ioctl scan walking in
    and modifying the fs devices in the meantime.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0b6567f0c63d..d470eb6b9226 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1567,7 +1567,9 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 		goto error_fs_info;
 	}
 
+	mutex_lock(&uuid_mutex);
 	error = btrfs_open_devices(fs_devices, mode, fs_type);
+	mutex_unlock(&uuid_mutex);
 	if (error)
 		goto error_fs_info;
 

commit 899f9307c33ce4758c30a076b10ed54d5c91c6e7
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 19 16:37:36 2018 +0200

    btrfs: lift uuid_mutex to callers of btrfs_scan_one_device
    
    Prepartory work to fix race between mount and device scan.
    
    The callers will have to manage the critical section, eg. mount wants to
    scan and then call btrfs_open_devices without the ioctl scan walking in
    and modifying the fs devices in the meantime.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 39d8e39b2fe1..0b6567f0c63d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -915,8 +915,10 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 				error = -ENOMEM;
 				goto out;
 			}
+			mutex_lock(&uuid_mutex);
 			error = btrfs_scan_one_device(device_name,
 					flags, holder, fs_devices);
+			mutex_unlock(&uuid_mutex);
 			kfree(device_name);
 			if (error)
 				goto out;
@@ -1537,7 +1539,9 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 			return ERR_PTR(error);
 	}
 
+	mutex_lock(&uuid_mutex);
 	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
+	mutex_unlock(&uuid_mutex);
 	if (error)
 		goto error_sec_opts;
 
@@ -2232,15 +2236,21 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:
+		mutex_lock(&uuid_mutex);
 		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
 					    &btrfs_root_fs_type, &fs_devices);
+		mutex_unlock(&uuid_mutex);
 		break;
 	case BTRFS_IOC_DEVICES_READY:
+		mutex_lock(&uuid_mutex);
 		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
 					    &btrfs_root_fs_type, &fs_devices);
-		if (ret)
+		if (ret) {
+			mutex_unlock(&uuid_mutex);
 			break;
+		}
 		ret = !(fs_devices->num_devices == fs_devices->total_devices);
+		mutex_unlock(&uuid_mutex);
 		break;
 	case BTRFS_IOC_GET_SUPPORTED_FEATURES:
 		ret = btrfs_ioctl_get_supported_features((void __user*)arg);

commit 93b9bcdf9fbcb683d4e8c44ee8cec0989053d4de
Author: Gu Jinxiang <gujx@cn.fujitsu.com>
Date:   Mon Jul 9 14:39:15 2018 +0800

    btrfs: remove unused parameter from btrfs_parse_subvol_options
    
    Since parameter flags is no more used since commit d7407606564c ("btrfs:
    split parse_early_options() in two"), remove it.
    
    Signed-off-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e04bcf0b0ed4..39d8e39b2fe1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -933,8 +933,8 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
  *
  * The value is later passed to mount_subvol()
  */
-static int btrfs_parse_subvol_options(const char *options, fmode_t flags,
-		char **subvol_name, u64 *subvol_objectid)
+static int btrfs_parse_subvol_options(const char *options, char **subvol_name,
+		u64 *subvol_objectid)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *opts, *orig, *p;
@@ -1648,8 +1648,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (!(flags & SB_RDONLY))
 		mode |= FMODE_WRITE;
 
-	error = btrfs_parse_subvol_options(data, mode,
-					  &subvol_name, &subvol_objectid);
+	error = btrfs_parse_subvol_options(data, &subvol_name,
+					&subvol_objectid);
 	if (error) {
 		kfree(subvol_name);
 		return ERR_PTR(error);

commit d7f663fa3ff906247a979c1115bc92cbabfb19ba
Author: David Sterba <dsterba@suse.com>
Date:   Fri Jun 29 10:56:47 2018 +0200

    btrfs: prune unused includes
    
    Remove includes if none of the interfaces and exports is used in the
    given source file.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3c5f221b5303..e04bcf0b0ed4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -5,7 +5,6 @@
 
 #include <linux/blkdev.h>
 #include <linux/module.h>
-#include <linux/buffer_head.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 #include <linux/highmem.h>
@@ -15,8 +14,6 @@
 #include <linux/string.h>
 #include <linux/backing-dev.h>
 #include <linux/mount.h>
-#include <linux/mpage.h>
-#include <linux/swap.h>
 #include <linux/writeback.h>
 #include <linux/statfs.h>
 #include <linux/compat.h>

commit edf57cbf2b030781885e339f32e35a470d2f8eba
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Wed Jun 20 10:03:33 2018 -0700

    btrfs: Fix a C compliance issue
    
    The C programming language does not allow to use preprocessor statements
    inside macro arguments (pr_info() is defined as a macro). Hence rework
    the pr_info() statement in btrfs_print_mod_info() such that it becomes
    compliant. This patch allows tools like sparse to analyze the BTRFS
    source code.
    
    Fixes: 62e855771dac ("btrfs: convert printk(KERN_* to use pr_* calls")
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3e298f26a383..3c5f221b5303 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2370,7 +2370,7 @@ static __cold void btrfs_interface_exit(void)
 
 static void __init btrfs_print_mod_info(void)
 {
-	pr_info("Btrfs loaded, crc32c=%s"
+	static const char options[] = ""
 #ifdef CONFIG_BTRFS_DEBUG
 			", debug=on"
 #endif
@@ -2383,8 +2383,8 @@ static void __init btrfs_print_mod_info(void)
 #ifdef CONFIG_BTRFS_FS_REF_VERIFY
 			", ref-verify=on"
 #endif
-			"\n",
-			crc32c_impl());
+			;
+	pr_info("Btrfs loaded, crc32c=%s%s\n", crc32c_impl(), options);
 }
 
 static int __init init_btrfs_fs(void)

commit acd43e3cdffcb2e361e8b481c72e057d34fcd780
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Wed Jun 20 10:03:32 2018 -0700

    btrfs: Annotate fall-through when parsing mount option
    
    This patch avoids that the compiler complains that a fall-through
    annotation is missing when building with W=1.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 81107ad49f3a..3e298f26a383 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -760,6 +760,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 		case Opt_recovery:
 			btrfs_warn(info,
 				   "'recovery' is deprecated, use 'usebackuproot' instead");
+			/* fall through */
 		case Opt_usebackuproot:
 			btrfs_info(info,
 				   "trying to use backup root at mount time");

commit 37becec95ac31b209eb1c8e096f1093a7db00f32
Author: Omar Sandoval <osandov@fb.com>
Date:   Mon May 21 17:07:19 2018 -0700

    Btrfs: allow empty subvol= again
    
    I got a report that after upgrading to 4.16, someone's filesystems
    weren't mounting:
    
    [   23.845852] BTRFS info (device loop0): unrecognized mount option 'subvol='
    
    Before 4.16, this mounted the default subvolume. It turns out that this
    empty "subvol=" is actually an application bug, but it was causing the
    application to fail, so it's an ABI break if you squint.
    
    The generic parsing code we use for mount options (match_token())
    doesn't match an empty string as "%s". Previously, setup_root_args()
    removed the "subvol=" string, but the mount path was cleaned up to not
    need that. Add a dummy Opt_subvol_empty to fix this.
    
    The simple workaround is to use / or . for the value of 'subvol=' .
    
    Fixes: 312c89fbca06 ("btrfs: cleanup btrfs_mount() using btrfs_mount_root()")
    CC: stable@vger.kernel.org # 4.16+
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c67fafaa2fe7..81107ad49f3a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -323,6 +323,7 @@ enum {
 	Opt_ssd, Opt_nossd,
 	Opt_ssd_spread, Opt_nossd_spread,
 	Opt_subvol,
+	Opt_subvol_empty,
 	Opt_subvolid,
 	Opt_thread_pool,
 	Opt_treelog, Opt_notreelog,
@@ -388,6 +389,7 @@ static const match_table_t tokens = {
 	{Opt_ssd_spread, "ssd_spread"},
 	{Opt_nossd_spread, "nossd_spread"},
 	{Opt_subvol, "subvol=%s"},
+	{Opt_subvol_empty, "subvol="},
 	{Opt_subvolid, "subvolid=%s"},
 	{Opt_thread_pool, "thread_pool=%u"},
 	{Opt_treelog, "treelog"},
@@ -461,6 +463,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			btrfs_set_opt(info->mount_opt, DEGRADED);
 			break;
 		case Opt_subvol:
+		case Opt_subvol_empty:
 		case Opt_subvolid:
 		case Opt_subvolrootid:
 		case Opt_device:

commit 891f41cb27cf5036e88053bb0ef688f98fcc945b
Author: Chengguang Xu <cgxu519@gmx.com>
Date:   Wed May 9 21:08:23 2018 +0800

    btrfs: return original error code when failing from option parsing
    
    It's not good to overwrite -ENOMEM using -EINVAL when failing from mount
    option parsing, so just return original error code.
    
    Signed-off-by: Chengguang Xu <cgxu519@gmx.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0628092b0b1b..c67fafaa2fe7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1782,10 +1782,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	}
 
 	ret = btrfs_parse_options(fs_info, data, *flags);
-	if (ret) {
-		ret = -EINVAL;
+	if (ret)
 		goto restore;
-	}
 
 	btrfs_remount_begin(fs_info, old_opts, *flags);
 	btrfs_resize_thread_pool(fs_info,

commit c1d7c514f745628eb096c5cbb10737855879ae25
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 3 19:23:33 2018 +0200

    btrfs: replace GPL boilerplate by SPDX -- sources
    
    Remove GPL boilerplate text (long, short, one-line) and keep the rest,
    ie. personal, company or original source copyright statements. Add the
    SPDX header.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 170baef49fae..0628092b0b1b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1,19 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2007 Oracle.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License v2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
 #include <linux/blkdev.h>

commit 88c14590cdd6f3cafc7ea7487d5f4532db8c551e
Author: David Sterba <dsterba@suse.com>
Date:   Fri Mar 16 03:27:02 2018 +0100

    btrfs: use RCU in btrfs_show_devname for device list traversal
    
    The show_devname callback is used to print device name in
    /proc/self/mounts, we need to traverse the device list consistently and
    read the name that's copied to a seq buffer so we don't need further
    locking.
    
    If the first device is being deleted at the same time, the RCU will
    allow us to read the device name, though it will become stale right
    after the RCU protection ends. This is unavoidable and the user can
    expect that the device will disappear from the filesystem's list at some
    point.
    
    The device_list_mutex was pretty heavy as it is used eg. for writing
    superblock and a few other IO related contexts. This can stall any
    application that reads the proc file for no reason.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d41d5960ef4a..170baef49fae 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2304,11 +2304,18 @@ static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 	struct list_head *head;
 	struct rcu_string *name;
 
-	mutex_lock(&fs_info->fs_devices->device_list_mutex);
+	/*
+	 * Lightweight locking of the devices. We should not need
+	 * device_list_mutex here as we only read the device data and the list
+	 * is protected by RCU.  Even if a device is deleted during the list
+	 * traversals, we'll get valid data, the freeing callback will wait at
+	 * least until until the rcu_read_unlock.
+	 */
+	rcu_read_lock();
 	cur_devices = fs_info->fs_devices;
 	while (cur_devices) {
 		head = &cur_devices->devices;
-		list_for_each_entry(dev, head, dev_list) {
+		list_for_each_entry_rcu(dev, head, dev_list) {
 			if (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state))
 				continue;
 			if (!dev->name)
@@ -2320,14 +2327,12 @@ static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 	}
 
 	if (first_dev) {
-		rcu_read_lock();
 		name = rcu_dereference(first_dev->name);
 		seq_escape(m, name->str, " \t\n\\");
-		rcu_read_unlock();
 	} else {
 		WARN_ON(1);
 	}
-	mutex_unlock(&fs_info->fs_devices->device_list_mutex);
+	rcu_read_unlock();
 	return 0;
 }
 

commit 416a72022e43b4c1c5e144ec6af3f95870e8f71a
Author: David Sterba <dsterba@suse.com>
Date:   Fri Mar 9 14:37:01 2018 +0100

    btrfs: sort and group mount option definitions
    
    Sort mount options by the primary name, followed by the 'no-'
    counterpart if it exists. Group the deprecated and debugging options.
    Enum and token defintions are synced.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 121b9d40ff8f..d41d5960ef4a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -308,21 +308,50 @@ static void btrfs_put_super(struct super_block *sb)
 }
 
 enum {
-	Opt_degraded, Opt_subvol, Opt_subvolid, Opt_device, Opt_nodatasum,
-	Opt_nodatacow, Opt_max_inline, Opt_alloc_start, Opt_nobarrier, Opt_ssd,
-	Opt_nossd, Opt_ssd_spread, Opt_nossd_spread, Opt_thread_pool, Opt_noacl,
-	Opt_compress, Opt_compress_type, Opt_compress_force,
-	Opt_compress_force_type, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
-	Opt_discard, Opt_space_cache, Opt_space_cache_version, Opt_clear_cache,
-	Opt_user_subvol_rm_allowed, Opt_enospc_debug, Opt_subvolrootid,
-	Opt_defrag, Opt_inode_cache, Opt_no_space_cache, Opt_recovery,
-	Opt_skip_balance, Opt_check_integrity,
+	Opt_acl, Opt_noacl,
+	Opt_clear_cache,
+	Opt_commit_interval,
+	Opt_compress,
+	Opt_compress_force,
+	Opt_compress_force_type,
+	Opt_compress_type,
+	Opt_degraded,
+	Opt_device,
+	Opt_fatal_errors,
+	Opt_flushoncommit, Opt_noflushoncommit,
+	Opt_inode_cache, Opt_noinode_cache,
+	Opt_max_inline,
+	Opt_barrier, Opt_nobarrier,
+	Opt_datacow, Opt_nodatacow,
+	Opt_datasum, Opt_nodatasum,
+	Opt_defrag, Opt_nodefrag,
+	Opt_discard, Opt_nodiscard,
+	Opt_nologreplay,
+	Opt_norecovery,
+	Opt_ratio,
+	Opt_rescan_uuid_tree,
+	Opt_skip_balance,
+	Opt_space_cache, Opt_no_space_cache,
+	Opt_space_cache_version,
+	Opt_ssd, Opt_nossd,
+	Opt_ssd_spread, Opt_nossd_spread,
+	Opt_subvol,
+	Opt_subvolid,
+	Opt_thread_pool,
+	Opt_treelog, Opt_notreelog,
+	Opt_usebackuproot,
+	Opt_user_subvol_rm_allowed,
+
+	/* Deprecated options */
+	Opt_alloc_start,
+	Opt_recovery,
+	Opt_subvolrootid,
+
+	/* Debugging options */
+	Opt_check_integrity,
 	Opt_check_integrity_including_extent_data,
-	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
-	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
-	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
-	Opt_datasum, Opt_treelog, Opt_noinode_cache, Opt_usebackuproot,
-	Opt_nologreplay, Opt_norecovery,
+	Opt_check_integrity_print_mask,
+	Opt_enospc_debug, Opt_noenospc_debug,
 #ifdef CONFIG_BTRFS_DEBUG
 	Opt_fragment_data, Opt_fragment_metadata, Opt_fragment_all,
 #endif
@@ -333,59 +362,63 @@ enum {
 };
 
 static const match_table_t tokens = {
-	{Opt_degraded, "degraded"},
-	{Opt_subvol, "subvol=%s"},
-	{Opt_subvolid, "subvolid=%s"},
-	{Opt_device, "device=%s"},
-	{Opt_nodatasum, "nodatasum"},
-	{Opt_datasum, "datasum"},
-	{Opt_nodatacow, "nodatacow"},
-	{Opt_datacow, "datacow"},
-	{Opt_nobarrier, "nobarrier"},
-	{Opt_barrier, "barrier"},
-	{Opt_max_inline, "max_inline=%s"},
-	{Opt_alloc_start, "alloc_start=%s"},		/* deprecated */
-	{Opt_thread_pool, "thread_pool=%u"},
+	{Opt_acl, "acl"},
+	{Opt_noacl, "noacl"},
+	{Opt_clear_cache, "clear_cache"},
+	{Opt_commit_interval, "commit=%u"},
 	{Opt_compress, "compress"},
 	{Opt_compress_type, "compress=%s"},
 	{Opt_compress_force, "compress-force"},
 	{Opt_compress_force_type, "compress-force=%s"},
-	{Opt_ssd, "ssd"},
-	{Opt_ssd_spread, "ssd_spread"},
-	{Opt_nossd, "nossd"},
-	{Opt_nossd_spread, "nossd_spread"},
-	{Opt_acl, "acl"},
-	{Opt_noacl, "noacl"},
-	{Opt_notreelog, "notreelog"},
-	{Opt_treelog, "treelog"},
-	{Opt_nologreplay, "nologreplay"},
-	{Opt_norecovery, "norecovery"},
+	{Opt_degraded, "degraded"},
+	{Opt_device, "device=%s"},
+	{Opt_fatal_errors, "fatal_errors=%s"},
 	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_noflushoncommit, "noflushoncommit"},
-	{Opt_ratio, "metadata_ratio=%u"},
+	{Opt_inode_cache, "inode_cache"},
+	{Opt_noinode_cache, "noinode_cache"},
+	{Opt_max_inline, "max_inline=%s"},
+	{Opt_barrier, "barrier"},
+	{Opt_nobarrier, "nobarrier"},
+	{Opt_datacow, "datacow"},
+	{Opt_nodatacow, "nodatacow"},
+	{Opt_datasum, "datasum"},
+	{Opt_nodatasum, "nodatasum"},
+	{Opt_defrag, "autodefrag"},
+	{Opt_nodefrag, "noautodefrag"},
 	{Opt_discard, "discard"},
 	{Opt_nodiscard, "nodiscard"},
+	{Opt_nologreplay, "nologreplay"},
+	{Opt_norecovery, "norecovery"},
+	{Opt_ratio, "metadata_ratio=%u"},
+	{Opt_rescan_uuid_tree, "rescan_uuid_tree"},
+	{Opt_skip_balance, "skip_balance"},
 	{Opt_space_cache, "space_cache"},
-	{Opt_space_cache_version, "space_cache=%s"},
-	{Opt_clear_cache, "clear_cache"},
-	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
-	{Opt_enospc_debug, "enospc_debug"},
-	{Opt_noenospc_debug, "noenospc_debug"},
-	{Opt_subvolrootid, "subvolrootid=%d"},		/* deprecated */
-	{Opt_defrag, "autodefrag"},
-	{Opt_nodefrag, "noautodefrag"},
-	{Opt_inode_cache, "inode_cache"},
-	{Opt_noinode_cache, "noinode_cache"},
 	{Opt_no_space_cache, "nospace_cache"},
-	{Opt_recovery, "recovery"}, /* deprecated */
+	{Opt_space_cache_version, "space_cache=%s"},
+	{Opt_ssd, "ssd"},
+	{Opt_nossd, "nossd"},
+	{Opt_ssd_spread, "ssd_spread"},
+	{Opt_nossd_spread, "nossd_spread"},
+	{Opt_subvol, "subvol=%s"},
+	{Opt_subvolid, "subvolid=%s"},
+	{Opt_thread_pool, "thread_pool=%u"},
+	{Opt_treelog, "treelog"},
+	{Opt_notreelog, "notreelog"},
 	{Opt_usebackuproot, "usebackuproot"},
-	{Opt_skip_balance, "skip_balance"},
+	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
+
+	/* Deprecated options */
+	{Opt_alloc_start, "alloc_start=%s"},
+	{Opt_recovery, "recovery"},
+	{Opt_subvolrootid, "subvolrootid=%d"},
+
+	/* Debugging options */
 	{Opt_check_integrity, "check_int"},
 	{Opt_check_integrity_including_extent_data, "check_int_data"},
 	{Opt_check_integrity_print_mask, "check_int_print_mask=%u"},
-	{Opt_rescan_uuid_tree, "rescan_uuid_tree"},
-	{Opt_fatal_errors, "fatal_errors=%s"},
-	{Opt_commit_interval, "commit=%u"},
+	{Opt_enospc_debug, "enospc_debug"},
+	{Opt_noenospc_debug, "noenospc_debug"},
 #ifdef CONFIG_BTRFS_DEBUG
 	{Opt_fragment_data, "fragment=data"},
 	{Opt_fragment_metadata, "fragment=metadata"},

commit 62b8e077317971b74d79c9cc501db2ae861d48b2
Author: Howard McLauchlan <hmclauchlan@fb.com>
Date:   Thu Mar 8 10:48:48 2018 -0800

    btrfs: Add nossd_spread mount option
    
    Btrfs has two mount options for SSD optimizations: ssd and ssd_spread.
    Presently there is an option to disable all SSD optimizations, but there
    isn't an option to disable just ssd_spread.
    
    This patch adds a mount option nossd_spread that disables ssd_spread
    only.
    
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Howard McLauchlan <hmclauchlan@fb.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index defaccde8d16..121b9d40ff8f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -310,10 +310,10 @@ static void btrfs_put_super(struct super_block *sb)
 enum {
 	Opt_degraded, Opt_subvol, Opt_subvolid, Opt_device, Opt_nodatasum,
 	Opt_nodatacow, Opt_max_inline, Opt_alloc_start, Opt_nobarrier, Opt_ssd,
-	Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl, Opt_compress,
-	Opt_compress_type, Opt_compress_force, Opt_compress_force_type,
-	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
-	Opt_space_cache, Opt_space_cache_version, Opt_clear_cache,
+	Opt_nossd, Opt_ssd_spread, Opt_nossd_spread, Opt_thread_pool, Opt_noacl,
+	Opt_compress, Opt_compress_type, Opt_compress_force,
+	Opt_compress_force_type, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
+	Opt_discard, Opt_space_cache, Opt_space_cache_version, Opt_clear_cache,
 	Opt_user_subvol_rm_allowed, Opt_enospc_debug, Opt_subvolrootid,
 	Opt_defrag, Opt_inode_cache, Opt_no_space_cache, Opt_recovery,
 	Opt_skip_balance, Opt_check_integrity,
@@ -353,6 +353,7 @@ static const match_table_t tokens = {
 	{Opt_ssd, "ssd"},
 	{Opt_ssd_spread, "ssd_spread"},
 	{Opt_nossd, "nossd"},
+	{Opt_nossd_spread, "nossd_spread"},
 	{Opt_acl, "acl"},
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
@@ -579,6 +580,8 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			btrfs_set_opt(info->mount_opt, NOSSD);
 			btrfs_clear_and_info(info, SSD,
 					     "not using ssd optimizations");
+			/* Fallthrough */
+		case Opt_nossd_spread:
 			btrfs_clear_and_info(info, SSD_SPREAD,
 					     "not using spread ssd allocation scheme");
 			break;

commit d612ac59efc3b57858f310c8471d7ee2779658c9
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Feb 26 16:46:05 2018 +0800

    btrfs: unify types for metadata_ratio and data_chunk_allocations
    
    We have btrfs_fs_info::data_chunk_allocations and
    btrfs_fs_info::metadata_ratio declared as unsigned which would be
    unsinged int and kernel style prefers unsigned int over bare unsigned.
    So this patch changes them to u32.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1dd2e785918c..defaccde8d16 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1737,7 +1737,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	unsigned long old_compress_type = fs_info->compress_type;
 	u64 old_max_inline = fs_info->max_inline;
 	u32 old_thread_pool_size = fs_info->thread_pool_size;
-	unsigned int old_metadata_ratio = fs_info->metadata_ratio;
+	u32 old_metadata_ratio = fs_info->metadata_ratio;
 	int ret;
 
 	sync_filesystem(sb);

commit e67c718b5b9a306bde7e966be7b4ca48fa063d73
Author: David Sterba <dsterba@suse.com>
Date:   Mon Feb 19 17:24:18 2018 +0100

    btrfs: add more __cold annotations
    
    The __cold functions are placed to a special section, as they're
    expected to be called rarely. This could help i-cache prefetches or help
    compiler to decide which branches are more/less likely to be taken
    without any other annotations needed.
    
    Though we can't add more __exit annotations, it's still possible to add
    __cold (that's also added with __exit). That way the following function
    categories are tagged:
    
    - printf wrappers, error messages
    - exit helpers
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 07bc2bfbdb96..1dd2e785918c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2333,7 +2333,7 @@ static int __init btrfs_interface_init(void)
 	return misc_register(&btrfs_misc);
 }
 
-static void btrfs_interface_exit(void)
+static __cold void btrfs_interface_exit(void)
 {
 	misc_deregister(&btrfs_misc);
 }

commit ccb0e7d1c1bc222966085550e27957c17138b629
Author: Anand Jain <anand.jain@oracle.com>
Date:   Thu Feb 15 01:11:37 2018 +0800

    btrfs: verify subvolid mount parameter
    
    We aren't verifying the parameter passed to the subvolid mount option,
    so we won't report and fail the mount if a junk value is specified for
    example, -o subvolid=abc.
    This patch verifies the subvolid option with match_u64.
    
    Up to now the memparse function accepts the K/M/G/ suffixes, that are
    usually meant for size values and do not make sense for a subvolume it.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ update changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5d752f791950..07bc2bfbdb96 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -914,8 +914,8 @@ static int btrfs_parse_subvol_options(const char *options, fmode_t flags,
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *opts, *orig, *p;
-	char *num = NULL;
 	int error = 0;
+	u64 subvolid;
 
 	if (!options)
 		return 0;
@@ -945,18 +945,15 @@ static int btrfs_parse_subvol_options(const char *options, fmode_t flags,
 			}
 			break;
 		case Opt_subvolid:
-			num = match_strdup(&args[0]);
-			if (num) {
-				*subvol_objectid = memparse(num, NULL);
-				kfree(num);
-				/* we want the original fs_tree */
-				if (!*subvol_objectid)
-					*subvol_objectid =
-						BTRFS_FS_TREE_OBJECTID;
-			} else {
-				error = -EINVAL;
+			error = match_u64(&args[0], &subvolid);
+			if (error)
 				goto out;
-			}
+
+			/* we want the original fs_tree */
+			if (subvolid == 0)
+				subvolid = BTRFS_FS_TREE_OBJECTID;
+
+			*subvol_objectid = subvolid;
 			break;
 		case Opt_subvolrootid:
 			pr_warn("BTRFS: 'subvolrootid' mount option is deprecated and has no effect\n");

commit 9678c54388b6a6b309ff7ee5c8d23fa9eba7c06f
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Jan 8 11:45:05 2018 +0200

    btrfs: Remove custom crc32c init code
    
    The custom crc32 init code was introduced in
    14a958e678cd ("Btrfs: fix btrfs boot when compiled as built-in") to
    enable using btrfs as a built-in. However, later as pointed out by
    60efa5eb2e88 ("Btrfs: use late_initcall instead of module_init") this
    wasn't enough and finally btrfs was switched to late_initcall which
    comes after the generic crc32c implementation is initiliased. The
    latter commit superseeded the former. Now that we don't have to
    maintain our own code let's just remove it and switch to using the
    generic implementation.
    
    Despite touching a lot of files the patch is really simple. Here is the gist of
    the changes:
    
    1. Select LIBCRC32C rather than the low-level modules.
    2. s/btrfs_crc32c/crc32c/g
    3. replace hash.h with linux/crc32c.h
    4. Move the btrfs namehash funcs to ctree.h and change the tree accordingly.
    
    I've tested this with btrfs being both a module and a built-in and xfstest
    doesn't complain.
    
    Does seem to fix the longstanding problem of not automatically selectiong
    the crc32c module when btrfs is used. Possibly there is a workaround in
    dracut.
    
    The modinfo confirms that now all the module dependencies are there:
    
    before:
    depends:        zstd_compress,zstd_decompress,raid6_pq,xor,zlib_deflate
    
    after:
    depends:        libcrc32c,zstd_compress,zstd_decompress,raid6_pq,xor,zlib_deflate
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ add more info to changelog from mails ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 540c18511e7a..5d752f791950 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -41,6 +41,7 @@
 #include <linux/slab.h>
 #include <linux/cleancache.h>
 #include <linux/ratelimit.h>
+#include <linux/crc32c.h>
 #include <linux/btrfs.h>
 #include "delayed-inode.h"
 #include "ctree.h"
@@ -48,7 +49,6 @@
 #include "transaction.h"
 #include "btrfs_inode.h"
 #include "print-tree.h"
-#include "hash.h"
 #include "props.h"
 #include "xattr.h"
 #include "volumes.h"
@@ -2357,22 +2357,18 @@ static void __init btrfs_print_mod_info(void)
 			", ref-verify=on"
 #endif
 			"\n",
-			btrfs_crc32c_impl());
+			crc32c_impl());
 }
 
 static int __init init_btrfs_fs(void)
 {
 	int err;
 
-	err = btrfs_hash_init();
-	if (err)
-		return err;
-
 	btrfs_props_init();
 
 	err = btrfs_init_sysfs();
 	if (err)
-		goto free_hash;
+		return err;
 
 	btrfs_init_compress();
 
@@ -2453,8 +2449,7 @@ static int __init init_btrfs_fs(void)
 free_compress:
 	btrfs_exit_compress();
 	btrfs_exit_sysfs();
-free_hash:
-	btrfs_hash_exit();
+
 	return err;
 }
 
@@ -2474,7 +2469,6 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_exit_sysfs();
 	btrfs_cleanup_fs_uuids();
 	btrfs_exit_compress();
-	btrfs_hash_exit();
 }
 
 late_initcall(init_btrfs_fs);

commit eceff22a8067fa5f587d1bab0eb66503d33b7164
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue Feb 13 17:50:47 2018 +0800

    btrfs: add a comment to mark the deprecated mount option
    
    The options alloc_start and subvolrootid are deprecated, comment them in
    the tokens list. And leave them as it is. No functional changes.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3656d0575ed8..540c18511e7a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -344,7 +344,7 @@ static const match_table_t tokens = {
 	{Opt_nobarrier, "nobarrier"},
 	{Opt_barrier, "barrier"},
 	{Opt_max_inline, "max_inline=%s"},
-	{Opt_alloc_start, "alloc_start=%s"},
+	{Opt_alloc_start, "alloc_start=%s"},		/* deprecated */
 	{Opt_thread_pool, "thread_pool=%u"},
 	{Opt_compress, "compress"},
 	{Opt_compress_type, "compress=%s"},
@@ -370,7 +370,7 @@ static const match_table_t tokens = {
 	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
 	{Opt_enospc_debug, "enospc_debug"},
 	{Opt_noenospc_debug, "noenospc_debug"},
-	{Opt_subvolrootid, "subvolrootid=%d"},
+	{Opt_subvolrootid, "subvolrootid=%d"},		/* deprecated */
 	{Opt_defrag, "autodefrag"},
 	{Opt_nodefrag, "noautodefrag"},
 	{Opt_inode_cache, "inode_cache"},

commit d3740608646f72fb94705a853946f647abcfaec4
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue Feb 13 17:50:46 2018 +0800

    btrfs: manage commit mount option as %u
    
    As the commit mount option is unsigned so manage it as %u for token
    verifications, instead of %d.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d3a49b8c760b..3656d0575ed8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -384,7 +384,7 @@ static const match_table_t tokens = {
 	{Opt_check_integrity_print_mask, "check_int_print_mask=%u"},
 	{Opt_rescan_uuid_tree, "rescan_uuid_tree"},
 	{Opt_fatal_errors, "fatal_errors=%s"},
-	{Opt_commit_interval, "commit=%d"},
+	{Opt_commit_interval, "commit=%u"},
 #ifdef CONFIG_BTRFS_DEBUG
 	{Opt_fragment_data, "fragment=data"},
 	{Opt_fragment_metadata, "fragment=metadata"},
@@ -786,24 +786,18 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 		case Opt_commit_interval:
 			intarg = 0;
 			ret = match_int(&args[0], &intarg);
-			if (ret < 0) {
-				btrfs_err(info, "invalid commit interval");
-				ret = -EINVAL;
+			if (ret)
 				goto out;
-			}
-			if (intarg > 0) {
-				if (intarg > 300) {
-					btrfs_warn(info,
-						"excessive commit interval %d",
-						intarg);
-				}
-				info->commit_interval = intarg;
-			} else {
+			if (intarg == 0) {
 				btrfs_info(info,
-					   "using default commit interval %ds",
+					   "using default commit interval %us",
 					   BTRFS_DEFAULT_COMMIT_INTERVAL);
-				info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;
+				intarg = BTRFS_DEFAULT_COMMIT_INTERVAL;
+			} else if (intarg > 300) {
+				btrfs_warn(info, "excessive commit interval %d",
+					   intarg);
 			}
+			info->commit_interval = intarg;
 			break;
 #ifdef CONFIG_BTRFS_DEBUG
 		case Opt_fragment_all:
@@ -1332,7 +1326,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 	if (btrfs_test_opt(info, PANIC_ON_FATAL_ERROR))
 		seq_puts(seq, ",fatal_errors=panic");
 	if (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)
-		seq_printf(seq, ",commit=%d", info->commit_interval);
+		seq_printf(seq, ",commit=%u", info->commit_interval);
 #ifdef CONFIG_BTRFS_DEBUG
 	if (btrfs_test_opt(info, FRAGMENT_DATA))
 		seq_puts(seq, ",fragment=data");

commit 02453bdeb02482cb405700dca70d158b4c042e71
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue Feb 13 17:50:45 2018 +0800

    btrfs: manage check_int_print_mask mount option as %u
    
    As check_int_print_mask mount option is unsigned so manage it as %u for
    token verifications, instead of %d.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 79900e1135d2..d3a49b8c760b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -381,7 +381,7 @@ static const match_table_t tokens = {
 	{Opt_skip_balance, "skip_balance"},
 	{Opt_check_integrity, "check_int"},
 	{Opt_check_integrity_including_extent_data, "check_int_data"},
-	{Opt_check_integrity_print_mask, "check_int_print_mask=%d"},
+	{Opt_check_integrity_print_mask, "check_int_print_mask=%u"},
 	{Opt_rescan_uuid_tree, "rescan_uuid_tree"},
 	{Opt_fatal_errors, "fatal_errors=%s"},
 	{Opt_commit_interval, "commit=%d"},
@@ -756,17 +756,11 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			break;
 		case Opt_check_integrity_print_mask:
 			ret = match_int(&args[0], &intarg);
-			if (ret) {
-				goto out;
-			} else if (intarg >= 0) {
-				info->check_integrity_print_mask = intarg;
-				btrfs_info(info,
-					   "check_integrity_print_mask 0x%x",
-					   info->check_integrity_print_mask);
-			} else {
-				ret = -EINVAL;
+			if (ret)
 				goto out;
-			}
+			info->check_integrity_print_mask = intarg;
+			btrfs_info(info, "check_integrity_print_mask 0x%x",
+				   info->check_integrity_print_mask);
 			break;
 #else
 		case Opt_check_integrity_including_extent_data:

commit 764cb8b43d4d8047460ed0e530fc109434c346f2
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue Feb 13 17:50:44 2018 +0800

    btrfs: manage metadata_ratio mount option as %u
    
    As metadata_ratio mount option is unsinged so manage it as %u for token
    verifications, instead of %d.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 790f3ab600cd..79900e1135d2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -361,7 +361,7 @@ static const match_table_t tokens = {
 	{Opt_norecovery, "norecovery"},
 	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_noflushoncommit, "noflushoncommit"},
-	{Opt_ratio, "metadata_ratio=%d"},
+	{Opt_ratio, "metadata_ratio=%u"},
 	{Opt_discard, "discard"},
 	{Opt_nodiscard, "nodiscard"},
 	{Opt_space_cache, "space_cache"},
@@ -657,16 +657,11 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			break;
 		case Opt_ratio:
 			ret = match_int(&args[0], &intarg);
-			if (ret) {
-				goto out;
-			} else if (intarg >= 0) {
-				info->metadata_ratio = intarg;
-				btrfs_info(info, "metadata ratio %d",
-					   info->metadata_ratio);
-			} else {
-				ret = -EINVAL;
+			if (ret)
 				goto out;
-			}
+			info->metadata_ratio = intarg;
+			btrfs_info(info, "metadata ratio %u",
+				   info->metadata_ratio);
 			break;
 		case Opt_discard:
 			btrfs_set_and_info(info, DISCARD,
@@ -1339,8 +1334,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 				info->check_integrity_print_mask);
 #endif
 	if (info->metadata_ratio)
-		seq_printf(seq, ",metadata_ratio=%d",
-				info->metadata_ratio);
+		seq_printf(seq, ",metadata_ratio=%u", info->metadata_ratio);
 	if (btrfs_test_opt(info, PANIC_ON_FATAL_ERROR))
 		seq_puts(seq, ",fatal_errors=panic");
 	if (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)

commit f7b885befd05fa4f546cdc3e6c9a3b4a30484cd1
Author: Anand Jain <anand.jain@oracle.com>
Date:   Tue Feb 13 17:50:42 2018 +0800

    btrfs: manage thread_pool mount option as %u
    
    The mount option thread_pool is always unsigned. Manage it that way all
    around.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4b817947e00f..790f3ab600cd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -345,7 +345,7 @@ static const match_table_t tokens = {
 	{Opt_barrier, "barrier"},
 	{Opt_max_inline, "max_inline=%s"},
 	{Opt_alloc_start, "alloc_start=%s"},
-	{Opt_thread_pool, "thread_pool=%d"},
+	{Opt_thread_pool, "thread_pool=%u"},
 	{Opt_compress, "compress"},
 	{Opt_compress_type, "compress=%s"},
 	{Opt_compress_force, "compress-force"},
@@ -594,12 +594,11 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			ret = match_int(&args[0], &intarg);
 			if (ret) {
 				goto out;
-			} else if (intarg > 0) {
-				info->thread_pool_size = intarg;
-			} else {
+			} else if (intarg == 0) {
 				ret = -EINVAL;
 				goto out;
 			}
+			info->thread_pool_size = intarg;
 			break;
 		case Opt_max_inline:
 			num = match_strdup(&args[0]);
@@ -1284,7 +1283,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_printf(seq, ",max_inline=%llu", info->max_inline);
 	if (info->thread_pool_size !=  min_t(unsigned long,
 					     num_online_cpus() + 2, 8))
-		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);
+		seq_printf(seq, ",thread_pool=%u", info->thread_pool_size);
 	if (btrfs_test_opt(info, COMPRESS)) {
 		compress_type = btrfs_compress_type2str(info->compress_type);
 		if (btrfs_test_opt(info, FORCE_COMPRESS))
@@ -1690,7 +1689,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 }
 
 static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
-				     int new_pool_size, int old_pool_size)
+				     u32 new_pool_size, u32 old_pool_size)
 {
 	if (new_pool_size == old_pool_size)
 		return;
@@ -1758,7 +1757,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	unsigned long old_opts = fs_info->mount_opt;
 	unsigned long old_compress_type = fs_info->compress_type;
 	u64 old_max_inline = fs_info->max_inline;
-	int old_thread_pool_size = fs_info->thread_pool_size;
+	u32 old_thread_pool_size = fs_info->thread_pool_size;
 	unsigned int old_metadata_ratio = fs_info->metadata_ratio;
 	int ret;
 

commit a8fd1f71749387c9a1053a83ff1c16287499a4e7
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Feb 15 22:59:47 2018 -0500

    btrfs: use kvzalloc to allocate btrfs_fs_info
    
    The srcu_struct in btrfs_fs_info scales in size with NR_CPUS.  On
    kernels built with NR_CPUS=8192, this can result in kmalloc failures
    that prevent mounting.
    
    There is work in progress to try to resolve this for every user of
    srcu_struct but using kvzalloc will work around the failures until
    that is complete.
    
    As an example with NR_CPUS=512 on x86_64: the overall size of
    subvol_srcu is 3460 bytes, fs_info is 6496.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6e71a2a78363..4b817947e00f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1545,7 +1545,7 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	 * it for searching for existing supers, so this lets us do that and
 	 * then open_ctree will properly initialize everything later.
 	 */
-	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_KERNEL);
+	fs_info = kvzalloc(sizeof(struct btrfs_fs_info), GFP_KERNEL);
 	if (!fs_info) {
 		error = -ENOMEM;
 		goto error_sec_opts;

commit 922ea8994a39ae56d1babbdd98228aef0543bf52
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Thu Jan 4 18:01:55 2018 +0800

    btrfS: collapse btrfs_handle_error() into __btrfs_handle_fs_error()
    
    There is no other consumer for btrfs_handle_error() other than
    __btrfs_handle_fs_error(), further this function quite small.
    Merge it into its parent.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    [ reformat comment ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 786e8bc04f9c..6e71a2a78363 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -107,28 +107,6 @@ const char *btrfs_decode_error(int errno)
 	return errstr;
 }
 
-/* btrfs handle error by forcing the filesystem readonly */
-static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
-{
-	struct super_block *sb = fs_info->sb;
-
-	if (sb_rdonly(sb))
-		return;
-
-	sb->s_flags |= SB_RDONLY;
-	btrfs_info(fs_info, "forced readonly");
-	/*
-	 * Note that a running device replace operation is not
-	 * canceled here although there is no way to update
-	 * the progress. It would add the risk of a deadlock,
-	 * therefore the canceling is omitted. The only penalty
-	 * is that some I/O remains active until the procedure
-	 * completes. The next time when the filesystem is
-	 * mounted writeable again, the device replace
-	 * operation continues.
-	 */
-}
-
 /*
  * __btrfs_handle_fs_error decodes expected errors from the caller and
  * invokes the approciate error response.
@@ -175,8 +153,23 @@ void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function
 	set_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);
 
 	/* Don't go through full error handling during mount */
-	if (sb->s_flags & SB_BORN)
-		btrfs_handle_error(fs_info);
+	if (!(sb->s_flags & SB_BORN))
+		return;
+
+	if (sb_rdonly(sb))
+		return;
+
+	/* btrfs handle error by forcing the filesystem readonly */
+	sb->s_flags |= SB_RDONLY;
+	btrfs_info(fs_info, "forced readonly");
+	/*
+	 * Note that a running device replace operation is not canceled here
+	 * although there is no way to update the progress. It would add the
+	 * risk of a deadlock, therefore the canceling is omitted. The only
+	 * penalty is that some I/O remains active until the procedure
+	 * completes. The next time when the filesystem is mounted writeable
+	 * again, the device replace operation continues.
+	 */
 }
 
 #ifdef CONFIG_PRINTK

commit 61ecda68652591c3a7131e6bdb51639612a1244c
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Thu Jan 4 18:01:54 2018 +0800

    btrfs: remove check for BTRFS_FS_STATE_ERROR which we just set
    
    __btrfs_handle_fs_error() sets BTRFS_FS_STATE_ERROR, and calls
    btrfs_handle_error() so no need to check if the BTRFS_FS_STATE_ERROR
    is set in btrfs_handle_error(). And there is no other user of
    btrfs_handle_error() as well.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8af7590a5638..786e8bc04f9c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -115,20 +115,18 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 	if (sb_rdonly(sb))
 		return;
 
-	if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {
-		sb->s_flags |= SB_RDONLY;
-		btrfs_info(fs_info, "forced readonly");
-		/*
-		 * Note that a running device replace operation is not
-		 * canceled here although there is no way to update
-		 * the progress. It would add the risk of a deadlock,
-		 * therefore the canceling is omitted. The only penalty
-		 * is that some I/O remains active until the procedure
-		 * completes. The next time when the filesystem is
-		 * mounted writeable again, the device replace
-		 * operation continues.
-		 */
-	}
+	sb->s_flags |= SB_RDONLY;
+	btrfs_info(fs_info, "forced readonly");
+	/*
+	 * Note that a running device replace operation is not
+	 * canceled here although there is no way to update
+	 * the progress. It would add the risk of a deadlock,
+	 * therefore the canceling is omitted. The only penalty
+	 * is that some I/O remains active until the procedure
+	 * completes. The next time when the filesystem is
+	 * mounted writeable again, the device replace
+	 * operation continues.
+	 */
 }
 
 /*

commit 6528b99d3d20795ff947d9b3fd736affe901acef
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Mon Dec 18 17:08:59 2017 +0800

    btrfs: factor btrfs_check_rw_degradable() to check given device
    
    Update btrfs_check_rw_degradable() to check against the given device if
    its lost.
    
    We can use this function to know if the volume is going to be in
    degraded mode OR failed state, when the given device fails.  Which is
    needed when we are handling the device failed state.
    
    A preparatory patch does not affect the flow as such.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    [ enhance comment ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f40352843c0b..8af7590a5638 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1844,7 +1844,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 			goto restore;
 		}
 
-		if (!btrfs_check_rw_degradable(fs_info)) {
+		if (!btrfs_check_rw_degradable(fs_info, NULL)) {
 			btrfs_warn(fs_info,
 				"too many missing devices, writeable remount is not allowed");
 			ret = -EACCES;

commit 5bedc48a8f9e1d62fb693c4171ffddb990d034f6
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jan 2 18:19:50 2018 +0100

    btrfs: drop unused parameters from mount_subvol
    
    Recent patches reworking the mount path left some unused parameters. We
    pass a vfsmount to mount_subvol, the flags and data (ie. mount options)
    have been already applied and we will not need them.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1d33744a9326..f40352843c0b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1397,8 +1397,7 @@ static inline int is_subvolume_inode(struct inode *inode)
 }
 
 static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
-				   int flags, const char *device_name,
-				   char *data, struct vfsmount *mnt)
+				   const char *device_name, struct vfsmount *mnt)
 {
 	struct dentry *root;
 	int ret;
@@ -1693,8 +1692,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	}
 
 	/* mount_subvol() will free subvol_name and mnt_root */
-	root = mount_subvol(subvol_name, subvol_objectid, flags, device_name,
-			data, mnt_root);
+	root = mount_subvol(subvol_name, subvol_objectid, device_name, mnt_root);
 
 out:
 	return root;

commit e215772cd2abcf33adad8857c0f5a8214a6e7d22
Author: Misono, Tomohiro <misono.tomohiro@jp.fujitsu.com>
Date:   Thu Dec 14 17:28:00 2017 +0900

    btrfs: cleanup unnecessary string dup in btrfs_parse_options()
    
    Long ago, commit edf24abe51493 ("btrfs: sanity mount option parsing and
    early mount code") split the btrfs_parse_options() into two parts
    (btrfs_parse_early_options() and btrfs_parse_options()). As a result,
    btrfs_parse_optins no longer gets called twice and is the last one to
    parse mount option string. Therefore there is no need to dup it.
    
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 03367a64b5c1..1d33744a9326 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -414,7 +414,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			unsigned long new_flags)
 {
 	substring_t args[MAX_OPT_ARGS];
-	char *p, *num, *orig = NULL;
+	char *p, *num;
 	u64 cache_gen;
 	int intarg;
 	int ret = 0;
@@ -437,16 +437,6 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 	if (!options)
 		goto check;
 
-	/*
-	 * strsep changes the string, duplicate it because parse_options
-	 * gets called twice
-	 */
-	options = kstrdup(options, GFP_KERNEL);
-	if (!options)
-		return -ENOMEM;
-
-	orig = options;
-
 	while ((p = strsep(&options, ",")) != NULL) {
 		int token;
 		if (!*p)
@@ -887,7 +877,6 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 		btrfs_info(info, "disk space caching is enabled");
 	if (!ret && btrfs_test_opt(info, FREE_SPACE_TREE))
 		btrfs_info(info, "using free space tree");
-	kfree(orig);
 	return ret;
 }
 

commit 78f6beacd024e3ab8091a2a5c12ee7031f9ccc38
Author: Misono, Tomohiro <misono.tomohiro@jp.fujitsu.com>
Date:   Wed Jan 17 17:38:31 2018 +0900

    btrfs: remove unused arg from parse_subvol_options()
    
    Remove unused arg 'holder' from parse_subvol_options(), which has been
    forgotten to be cleaned in the commit b99beb110e2d ("btrfs: split
    parse_early_options() in two").
    
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 89333e118c7a..03367a64b5c1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -948,7 +948,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
  * The value is later passed to mount_subvol()
  */
 static int btrfs_parse_subvol_options(const char *options, fmode_t flags,
-		void *holder, char **subvol_name, u64 *subvol_objectid)
+		char **subvol_name, u64 *subvol_objectid)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *opts, *orig, *p;
@@ -1667,7 +1667,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (!(flags & SB_RDONLY))
 		mode |= FMODE_WRITE;
 
-	error = btrfs_parse_subvol_options(data, mode, fs_type,
+	error = btrfs_parse_subvol_options(data, mode,
 					  &subvol_name, &subvol_objectid);
 	if (error) {
 		kfree(subvol_name);

commit 83085935cc38b9752215556c02b2f080c96bf1be
Author: Misono, Tomohiro <misono.tomohiro@jp.fujitsu.com>
Date:   Thu Dec 14 17:25:54 2017 +0900

    btrfs: remove unused setup_root_args()
    
    Since setup_root_args() is not used anymore, just remove it.
    
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0d615d02eb4a..89333e118c7a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1407,42 +1407,6 @@ static inline int is_subvolume_inode(struct inode *inode)
 	return 0;
 }
 
-/*
- * This will add subvolid=0 to the argument string while removing any subvol=
- * and subvolid= arguments to make sure we get the top-level root for path
- * walking to the subvol we want.
- */
-static char *setup_root_args(char *args)
-{
-	char *buf, *dst, *sep;
-
-	if (!args)
-		return kstrdup("subvolid=0", GFP_KERNEL);
-
-	/* The worst case is that we add ",subvolid=0" to the end. */
-	buf = dst = kmalloc(strlen(args) + strlen(",subvolid=0") + 1,
-			GFP_KERNEL);
-	if (!buf)
-		return NULL;
-
-	while (1) {
-		sep = strchrnul(args, ',');
-		if (!strstarts(args, "subvol=") &&
-		    !strstarts(args, "subvolid=")) {
-			memcpy(dst, args, sep - args);
-			dst += sep - args;
-			*dst++ = ',';
-		}
-		if (*sep)
-			args = sep + 1;
-		else
-			break;
-	}
-	strcpy(dst, "subvolid=0");
-
-	return buf;
-}
-
 static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 				   int flags, const char *device_name,
 				   char *data, struct vfsmount *mnt)

commit d7407606564c595e4b9775cc6b14913e92217782
Author: Misono, Tomohiro <misono.tomohiro@jp.fujitsu.com>
Date:   Thu Dec 14 17:25:28 2017 +0900

    btrfs: split parse_early_options() in two
    
    Now parse_early_options() is used by both btrfs_mount() and
    btrfs_mount_root(). However, the former only needs subvol related part
    and the latter needs the others.
    
    Therefore extract the subvol related parts from parse_early_options() and
    move it to new parse function (parse_subvol_options()).
    
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index adf0f8b8829c..0d615d02eb4a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -463,7 +463,8 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 		case Opt_subvolrootid:
 		case Opt_device:
 			/*
-			 * These are parsed by btrfs_parse_early_options
+			 * These are parsed by btrfs_parse_subvol_options
+			 * and btrfs_parse_early_options
 			 * and can be happily ignored here.
 			 */
 			break;
@@ -897,11 +898,60 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
  * only when we need to allocate a new super block.
  */
 static int btrfs_parse_early_options(const char *options, fmode_t flags,
-		void *holder, char **subvol_name, u64 *subvol_objectid,
-		struct btrfs_fs_devices **fs_devices)
+		void *holder, struct btrfs_fs_devices **fs_devices)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *device_name, *opts, *orig, *p;
+	int error = 0;
+
+	if (!options)
+		return 0;
+
+	/*
+	 * strsep changes the string, duplicate it because btrfs_parse_options
+	 * gets called later
+	 */
+	opts = kstrdup(options, GFP_KERNEL);
+	if (!opts)
+		return -ENOMEM;
+	orig = opts;
+
+	while ((p = strsep(&opts, ",")) != NULL) {
+		int token;
+
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		if (token == Opt_device) {
+			device_name = match_strdup(&args[0]);
+			if (!device_name) {
+				error = -ENOMEM;
+				goto out;
+			}
+			error = btrfs_scan_one_device(device_name,
+					flags, holder, fs_devices);
+			kfree(device_name);
+			if (error)
+				goto out;
+		}
+	}
+
+out:
+	kfree(orig);
+	return error;
+}
+
+/*
+ * Parse mount options that are related to subvolume id
+ *
+ * The value is later passed to mount_subvol()
+ */
+static int btrfs_parse_subvol_options(const char *options, fmode_t flags,
+		void *holder, char **subvol_name, u64 *subvol_objectid)
+{
+	substring_t args[MAX_OPT_ARGS];
+	char *opts, *orig, *p;
 	char *num = NULL;
 	int error = 0;
 
@@ -909,8 +959,8 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		return 0;
 
 	/*
-	 * strsep changes the string, duplicate it because parse_options
-	 * gets called twice
+	 * strsep changes the string, duplicate it because
+	 * btrfs_parse_early_options gets called later
 	 */
 	opts = kstrdup(options, GFP_KERNEL);
 	if (!opts)
@@ -949,18 +999,6 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		case Opt_subvolrootid:
 			pr_warn("BTRFS: 'subvolrootid' mount option is deprecated and has no effect\n");
 			break;
-		case Opt_device:
-			device_name = match_strdup(&args[0]);
-			if (!device_name) {
-				error = -ENOMEM;
-				goto out;
-			}
-			error = btrfs_scan_one_device(device_name,
-					flags, holder, fs_devices);
-			kfree(device_name);
-			if (error)
-				goto out;
-			break;
 		default:
 			break;
 		}
@@ -1536,18 +1574,14 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	struct btrfs_fs_info *fs_info = NULL;
 	struct security_mnt_opts new_sec_opts;
 	fmode_t mode = FMODE_READ;
-	char *subvol_name = NULL;
-	u64 subvol_objectid = 0;
 	int error = 0;
 
 	if (!(flags & SB_RDONLY))
 		mode |= FMODE_WRITE;
 
 	error = btrfs_parse_early_options(data, mode, fs_type,
-					  &subvol_name, &subvol_objectid,
 					  &fs_devices);
 	if (error) {
-		kfree(subvol_name);
 		return ERR_PTR(error);
 	}
 
@@ -1659,7 +1693,6 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		const char *device_name, void *data)
 {
-	struct btrfs_fs_devices *fs_devices = NULL;
 	struct vfsmount *mnt_root;
 	struct dentry *root;
 	fmode_t mode = FMODE_READ;
@@ -1670,9 +1703,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (!(flags & SB_RDONLY))
 		mode |= FMODE_WRITE;
 
-	error = btrfs_parse_early_options(data, mode, fs_type,
-					  &subvol_name, &subvol_objectid,
-					  &fs_devices);
+	error = btrfs_parse_subvol_options(data, mode, fs_type,
+					  &subvol_name, &subvol_objectid);
 	if (error) {
 		kfree(subvol_name);
 		return ERR_PTR(error);

commit 312c89fbca06896cb25a0daf4fa5f44c29bbb1b1
Author: Misono, Tomohiro <misono.tomohiro@jp.fujitsu.com>
Date:   Thu Dec 14 17:25:01 2017 +0900

    btrfs: cleanup btrfs_mount() using btrfs_mount_root()
    
    Cleanup btrfs_mount() by using btrfs_mount_root(). This avoids getting
    btrfs_mount() called twice in mount path.
    
    Old btrfs_mount() will do:
    0. VFS layer calls vfs_kern_mount() with registered file_system_type
       (for btrfs, btrfs_fs_type). btrfs_mount() is called on the way.
    1. btrfs_parse_early_options() parses "subvolid=" mount option and set the
       value to subvol_objectid. Otherwise, subvol_objectid has the initial
       value of 0
    2. check subvol_objectid is 5 or not. Assume this time id is not 5, then
       btrfs_mount() returns by calling mount_subvol()
    3. In mount_subvol(), original mount options are modified to contain
       "subvolid=0" in setup_root_args(). Then, vfs_kern_mount() is called with
       btrfs_fs_type and new options
    4. btrfs_mount() is called again
    5. btrfs_parse_early_options() parses "subvolid=0" and set 5 (instead of 0)
       to subvol_objectid
    6. check subvol_objectid is 5 or not. This time id is 5 and mount_subvol()
       is not called. btrfs_mount() finishes mounting a root
    7. (in mount_subvol()) with using a return vale of vfs_kern_mount(), it
       calls mount_subtree()
    8. return subvolume's dentry
    
    Reusing the same file_system_type (and btrfs_mount()) for vfs_kern_mount()
    is the cause of complication.
    
    Instead, new btrfs_mount() will do:
    1. parse subvol id related options for later use in mount_subvol()
    2. mount device's root by calling vfs_kern_mount() with
       btrfs_root_fs_type, which is not registered to VFS by
       register_filesystem(). As a result, btrfs_mount_root() is called
    3. return by calling mount_subvol()
    
    The code of 2. is moved from the first part of mount_subvol().
    
    The semantics of device holder changes from btrfs_fs_type to
    btrfs_root_fs_type and has to be used in all contexts. Otherwise we'd
    get wrong results when mount and dev scan would not check the same
    thing. (this has been found indendently and the fix is folded into this
    patch)
    
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ fold the btrfs_control_ioctl fixup, extend the comment ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ce78906bc7d7..adf0f8b8829c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -71,6 +71,8 @@ static const struct super_operations btrfs_super_ops;
  * requested by subvol=/path. That way the callchain is straightforward and we
  * don't have to play tricks with the mount options and recursive calls to
  * btrfs_mount.
+ *
+ * The new btrfs_root_fs_type also servers as a tag for the bdev_holder.
  */
 static struct file_system_type btrfs_fs_type;
 static struct file_system_type btrfs_root_fs_type;
@@ -1405,48 +1407,11 @@ static char *setup_root_args(char *args)
 
 static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 				   int flags, const char *device_name,
-				   char *data)
+				   char *data, struct vfsmount *mnt)
 {
 	struct dentry *root;
-	struct vfsmount *mnt = NULL;
-	char *newargs;
 	int ret;
 
-	newargs = setup_root_args(data);
-	if (!newargs) {
-		root = ERR_PTR(-ENOMEM);
-		goto out;
-	}
-
-	mnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name, newargs);
-	if (PTR_ERR_OR_ZERO(mnt) == -EBUSY) {
-		if (flags & SB_RDONLY) {
-			mnt = vfs_kern_mount(&btrfs_fs_type, flags & ~SB_RDONLY,
-					     device_name, newargs);
-		} else {
-			mnt = vfs_kern_mount(&btrfs_fs_type, flags | SB_RDONLY,
-					     device_name, newargs);
-			if (IS_ERR(mnt)) {
-				root = ERR_CAST(mnt);
-				mnt = NULL;
-				goto out;
-			}
-
-			down_write(&mnt->mnt_sb->s_umount);
-			ret = btrfs_remount(mnt->mnt_sb, &flags, NULL);
-			up_write(&mnt->mnt_sb->s_umount);
-			if (ret < 0) {
-				root = ERR_PTR(ret);
-				goto out;
-			}
-		}
-	}
-	if (IS_ERR(mnt)) {
-		root = ERR_CAST(mnt);
-		mnt = NULL;
-		goto out;
-	}
-
 	if (!subvol_name) {
 		if (!subvol_objectid) {
 			ret = get_default_subvol_objectid(btrfs_sb(mnt->mnt_sb),
@@ -1502,7 +1467,6 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 
 out:
 	mntput(mnt);
-	kfree(newargs);
 	kfree(subvol_name);
 	return root;
 }
@@ -1557,6 +1521,12 @@ static int setup_security_options(struct btrfs_fs_info *fs_info,
 	return ret;
 }
 
+/*
+ * Find a superblock for the given device / mount point.
+ *
+ * Note: This is based on mount_bdev from fs/super.c with a few additions
+ *       for multiple device setup.  Make sure to keep it in sync.
+ */
 static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 		int flags, const char *device_name, void *data)
 {
@@ -1663,20 +1633,35 @@ static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
 	security_free_mnt_opts(&new_sec_opts);
 	return ERR_PTR(error);
 }
+
 /*
- * Find a superblock for the given device / mount point.
+ * Mount function which is called by VFS layer.
  *
- * Note:  This is based on get_sb_bdev from fs/super.c with a few additions
- *	  for multiple device setup.  Make sure to keep it in sync.
+ * In order to allow mounting a subvolume directly, btrfs uses mount_subtree()
+ * which needs vfsmount* of device's root (/).  This means device's root has to
+ * be mounted internally in any case.
+ *
+ * Operation flow:
+ *   1. Parse subvol id related options for later use in mount_subvol().
+ *
+ *   2. Mount device's root (/) by calling vfs_kern_mount().
+ *
+ *      NOTE: vfs_kern_mount() is used by VFS to call btrfs_mount() in the
+ *      first place. In order to avoid calling btrfs_mount() again, we use
+ *      different file_system_type which is not registered to VFS by
+ *      register_filesystem() (btrfs_root_fs_type). As a result,
+ *      btrfs_mount_root() is called. The return value will be used by
+ *      mount_subtree() in mount_subvol().
+ *
+ *   3. Call mount_subvol() to get the dentry of subvolume. Since there is
+ *      "btrfs subvolume set-default", mount_subvol() is called always.
  */
 static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		const char *device_name, void *data)
 {
-	struct block_device *bdev = NULL;
-	struct super_block *s;
 	struct btrfs_fs_devices *fs_devices = NULL;
-	struct btrfs_fs_info *fs_info = NULL;
-	struct security_mnt_opts new_sec_opts;
+	struct vfsmount *mnt_root;
+	struct dentry *root;
 	fmode_t mode = FMODE_READ;
 	char *subvol_name = NULL;
 	u64 subvol_objectid = 0;
@@ -1693,93 +1678,41 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		return ERR_PTR(error);
 	}
 
-	if (subvol_name || subvol_objectid != BTRFS_FS_TREE_OBJECTID) {
-		/* mount_subvol() will free subvol_name. */
-		return mount_subvol(subvol_name, subvol_objectid, flags,
-				    device_name, data);
-	}
-
-	security_init_mnt_opts(&new_sec_opts);
-	if (data) {
-		error = parse_security_options(data, &new_sec_opts);
-		if (error)
-			return ERR_PTR(error);
-	}
-
-	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
-	if (error)
-		goto error_sec_opts;
-
-	/*
-	 * Setup a dummy root and fs_info for test/set super.  This is because
-	 * we don't actually fill this stuff out until open_ctree, but we need
-	 * it for searching for existing supers, so this lets us do that and
-	 * then open_ctree will properly initialize everything later.
-	 */
-	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_KERNEL);
-	if (!fs_info) {
-		error = -ENOMEM;
-		goto error_sec_opts;
-	}
-
-	fs_info->fs_devices = fs_devices;
-
-	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
-	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
-	security_init_mnt_opts(&fs_info->security_opts);
-	if (!fs_info->super_copy || !fs_info->super_for_commit) {
-		error = -ENOMEM;
-		goto error_fs_info;
-	}
-
-	error = btrfs_open_devices(fs_devices, mode, fs_type);
-	if (error)
-		goto error_fs_info;
-
-	if (!(flags & SB_RDONLY) && fs_devices->rw_devices == 0) {
-		error = -EACCES;
-		goto error_close_devices;
-	}
-
-	bdev = fs_devices->latest_bdev;
-	s = sget(fs_type, btrfs_test_super, btrfs_set_super, flags | SB_NOSEC,
-		 fs_info);
-	if (IS_ERR(s)) {
-		error = PTR_ERR(s);
-		goto error_close_devices;
-	}
+	/* mount device's root (/) */
+	mnt_root = vfs_kern_mount(&btrfs_root_fs_type, flags, device_name, data);
+	if (PTR_ERR_OR_ZERO(mnt_root) == -EBUSY) {
+		if (flags & SB_RDONLY) {
+			mnt_root = vfs_kern_mount(&btrfs_root_fs_type,
+				flags & ~SB_RDONLY, device_name, data);
+		} else {
+			mnt_root = vfs_kern_mount(&btrfs_root_fs_type,
+				flags | SB_RDONLY, device_name, data);
+			if (IS_ERR(mnt_root)) {
+				root = ERR_CAST(mnt_root);
+				goto out;
+			}
 
-	if (s->s_root) {
-		btrfs_close_devices(fs_devices);
-		free_fs_info(fs_info);
-		if ((flags ^ s->s_flags) & SB_RDONLY)
-			error = -EBUSY;
-	} else {
-		snprintf(s->s_id, sizeof(s->s_id), "%pg", bdev);
-		btrfs_sb(s)->bdev_holder = fs_type;
-		error = btrfs_fill_super(s, fs_devices, data);
-	}
-	if (error) {
-		deactivate_locked_super(s);
-		goto error_sec_opts;
+			down_write(&mnt_root->mnt_sb->s_umount);
+			error = btrfs_remount(mnt_root->mnt_sb, &flags, NULL);
+			up_write(&mnt_root->mnt_sb->s_umount);
+			if (error < 0) {
+				root = ERR_PTR(error);
+				mntput(mnt_root);
+				goto out;
+			}
+		}
 	}
-
-	fs_info = btrfs_sb(s);
-	error = setup_security_options(fs_info, s, &new_sec_opts);
-	if (error) {
-		deactivate_locked_super(s);
-		goto error_sec_opts;
+	if (IS_ERR(mnt_root)) {
+		root = ERR_CAST(mnt_root);
+		goto out;
 	}
 
-	return dget(s->s_root);
+	/* mount_subvol() will free subvol_name and mnt_root */
+	root = mount_subvol(subvol_name, subvol_objectid, flags, device_name,
+			data, mnt_root);
 
-error_close_devices:
-	btrfs_close_devices(fs_devices);
-error_fs_info:
-	free_fs_info(fs_info);
-error_sec_opts:
-	security_free_mnt_opts(&new_sec_opts);
-	return ERR_PTR(error);
+out:
+	return root;
 }
 
 static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
@@ -2326,11 +2259,11 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:
 		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
-					    &btrfs_fs_type, &fs_devices);
+					    &btrfs_root_fs_type, &fs_devices);
 		break;
 	case BTRFS_IOC_DEVICES_READY:
 		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
-					    &btrfs_fs_type, &fs_devices);
+					    &btrfs_root_fs_type, &fs_devices);
 		if (ret)
 			break;
 		ret = !(fs_devices->num_devices == fs_devices->total_devices);

commit 72fa39f5c7a1c9d95c24ddf6605581ea05d6081c
Author: Misono, Tomohiro <misono.tomohiro@jp.fujitsu.com>
Date:   Thu Dec 14 17:24:30 2017 +0900

    btrfs: add btrfs_mount_root() and new file_system_type
    
    Add btrfs_mount_root() and new file_system_type for preparation of cleanup
    of btrfs_mount(). Code path is not changed yet.
    
    btrfs_mount_root() is almost the same as current btrfs_mount(), but doesn't
    have subvolume related part.
    
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 428841a17acb..ce78906bc7d7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -65,7 +65,15 @@
 #include <trace/events/btrfs.h>
 
 static const struct super_operations btrfs_super_ops;
+
+/*
+ * Types for mounting the default subvolume and a subvolume explicitly
+ * requested by subvol=/path. That way the callchain is straightforward and we
+ * don't have to play tricks with the mount options and recursive calls to
+ * btrfs_mount.
+ */
 static struct file_system_type btrfs_fs_type;
+static struct file_system_type btrfs_root_fs_type;
 
 static int btrfs_remount(struct super_block *sb, int *flags, char *data);
 
@@ -1549,6 +1557,112 @@ static int setup_security_options(struct btrfs_fs_info *fs_info,
 	return ret;
 }
 
+static struct dentry *btrfs_mount_root(struct file_system_type *fs_type,
+		int flags, const char *device_name, void *data)
+{
+	struct block_device *bdev = NULL;
+	struct super_block *s;
+	struct btrfs_fs_devices *fs_devices = NULL;
+	struct btrfs_fs_info *fs_info = NULL;
+	struct security_mnt_opts new_sec_opts;
+	fmode_t mode = FMODE_READ;
+	char *subvol_name = NULL;
+	u64 subvol_objectid = 0;
+	int error = 0;
+
+	if (!(flags & SB_RDONLY))
+		mode |= FMODE_WRITE;
+
+	error = btrfs_parse_early_options(data, mode, fs_type,
+					  &subvol_name, &subvol_objectid,
+					  &fs_devices);
+	if (error) {
+		kfree(subvol_name);
+		return ERR_PTR(error);
+	}
+
+	security_init_mnt_opts(&new_sec_opts);
+	if (data) {
+		error = parse_security_options(data, &new_sec_opts);
+		if (error)
+			return ERR_PTR(error);
+	}
+
+	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
+	if (error)
+		goto error_sec_opts;
+
+	/*
+	 * Setup a dummy root and fs_info for test/set super.  This is because
+	 * we don't actually fill this stuff out until open_ctree, but we need
+	 * it for searching for existing supers, so this lets us do that and
+	 * then open_ctree will properly initialize everything later.
+	 */
+	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_KERNEL);
+	if (!fs_info) {
+		error = -ENOMEM;
+		goto error_sec_opts;
+	}
+
+	fs_info->fs_devices = fs_devices;
+
+	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
+	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
+	security_init_mnt_opts(&fs_info->security_opts);
+	if (!fs_info->super_copy || !fs_info->super_for_commit) {
+		error = -ENOMEM;
+		goto error_fs_info;
+	}
+
+	error = btrfs_open_devices(fs_devices, mode, fs_type);
+	if (error)
+		goto error_fs_info;
+
+	if (!(flags & SB_RDONLY) && fs_devices->rw_devices == 0) {
+		error = -EACCES;
+		goto error_close_devices;
+	}
+
+	bdev = fs_devices->latest_bdev;
+	s = sget(fs_type, btrfs_test_super, btrfs_set_super, flags | SB_NOSEC,
+		 fs_info);
+	if (IS_ERR(s)) {
+		error = PTR_ERR(s);
+		goto error_close_devices;
+	}
+
+	if (s->s_root) {
+		btrfs_close_devices(fs_devices);
+		free_fs_info(fs_info);
+		if ((flags ^ s->s_flags) & SB_RDONLY)
+			error = -EBUSY;
+	} else {
+		snprintf(s->s_id, sizeof(s->s_id), "%pg", bdev);
+		btrfs_sb(s)->bdev_holder = fs_type;
+		error = btrfs_fill_super(s, fs_devices, data);
+	}
+	if (error) {
+		deactivate_locked_super(s);
+		goto error_sec_opts;
+	}
+
+	fs_info = btrfs_sb(s);
+	error = setup_security_options(fs_info, s, &new_sec_opts);
+	if (error) {
+		deactivate_locked_super(s);
+		goto error_sec_opts;
+	}
+
+	return dget(s->s_root);
+
+error_close_devices:
+	btrfs_close_devices(fs_devices);
+error_fs_info:
+	free_fs_info(fs_info);
+error_sec_opts:
+	security_free_mnt_opts(&new_sec_opts);
+	return ERR_PTR(error);
+}
 /*
  * Find a superblock for the given device / mount point.
  *
@@ -2170,6 +2284,15 @@ static struct file_system_type btrfs_fs_type = {
 	.kill_sb	= btrfs_kill_super,
 	.fs_flags	= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,
 };
+
+static struct file_system_type btrfs_root_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "btrfs",
+	.mount		= btrfs_mount_root,
+	.kill_sb	= btrfs_kill_super,
+	.fs_flags	= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,
+};
+
 MODULE_ALIAS_FS("btrfs");
 
 static int btrfs_control_open(struct inode *inode, struct file *file)

commit 87c46ec70068cd28442954ec3fd0784eb90ca19b
Author: Pravin Shedge <pravin.shedge4linux@gmail.com>
Date:   Wed Dec 6 22:14:31 2017 +0530

    btrfs: remove duplicate includes
    
    These duplicate includes have been found with scripts/checkincludes.pl but
    they have been removed manually to avoid removing false positives.
    
    Signed-off-by: Pravin Shedge <pravin.shedge4linux@gmail.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index baa8add64681..428841a17acb 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -61,7 +61,6 @@
 #include "tests/btrfs-tests.h"
 
 #include "qgroup.h"
-#include "backref.h"
 #define CREATE_TRACE_POINTS
 #include <trace/events/btrfs.h>
 

commit 0f628c632d4009527aef597dac3a4a09e628b051
Author: David Sterba <dsterba@suse.com>
Date:   Tue Oct 31 18:06:34 2017 +0100

    btrfs: show options: use helper to convert compression type string
    
    Use the helper, if the COMPRESS option is set, the result is always
    defined and not empty.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 84707e77c051..baa8add64681 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1243,7 +1243,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 {
 	struct btrfs_fs_info *info = btrfs_sb(dentry->d_sb);
-	char *compress_type;
+	const char *compress_type;
 
 	if (btrfs_test_opt(info, DEGRADED))
 		seq_puts(seq, ",degraded");
@@ -1259,12 +1259,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 					     num_online_cpus() + 2, 8))
 		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);
 	if (btrfs_test_opt(info, COMPRESS)) {
-		if (info->compress_type == BTRFS_COMPRESS_ZLIB)
-			compress_type = "zlib";
-		else if (info->compress_type == BTRFS_COMPRESS_LZO)
-			compress_type = "lzo";
-		else
-			compress_type = "zstd";
+		compress_type = btrfs_compress_type2str(info->compress_type);
 		if (btrfs_test_opt(info, FORCE_COMPRESS))
 			seq_printf(seq, ",compress-force=%s", compress_type);
 		else

commit 401e29c124eac2b9373eb72f36f202561da339d2
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Dec 4 12:54:55 2017 +0800

    btrfs: cleanup device states define BTRFS_DEV_STATE_REPLACE_TGT
    
    Currently device state is being managed by each individual int
    variable such as struct btrfs_device::is_tgtdev_for_dev_replace.
    Instead of that declare btrfs_device::dev_state
    BTRFS_DEV_STATE_MISSING and use the bit operations.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    [ whitespace adjustments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ba5324523995..84707e77c051 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1974,7 +1974,8 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	list_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {
 		if (!test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,
 						&device->dev_state) ||
-		    !device->bdev || device->is_tgtdev_for_dev_replace)
+		    !device->bdev ||
+		    test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state))
 			continue;
 
 		if (i >= nr_devices)

commit e6e674bd4d54fe8d47a06914f3b90752785b4882
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Dec 4 12:54:54 2017 +0800

    btrfs: cleanup device states define BTRFS_DEV_STATE_MISSING
    
    Currently device state is being managed by each individual int
    variable such as struct btrfs_device::missing. Instead of that
    declare btrfs_device::dev_state BTRFS_DEV_STATE_MISSING and use
    the bit operations.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by : Nikolay Borisov <nborisov@suse.com>
    [ whitespace adjustments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index bc55c5e6badd..ba5324523995 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2270,7 +2270,7 @@ static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 	while (cur_devices) {
 		head = &cur_devices->devices;
 		list_for_each_entry(dev, head, dev_list) {
-			if (dev->missing)
+			if (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state))
 				continue;
 			if (!dev->name)
 				continue;

commit e12c96214d28f9211b4035cf20e76d677ff5611f
Author: Anand Jain <anand.jain@oracle.com>
Date:   Mon Dec 4 12:54:53 2017 +0800

    btrfs: cleanup device states define BTRFS_DEV_STATE_IN_FS_METADATA
    
    Currently device state is being managed by each individual int
    variable such as struct btrfs_device::in_fs_metadata. Instead of
    that declare device state BTRFS_DEV_STATE_IN_FS_METADATA and use
    the bit operations.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    [ whitespace adjustments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7a7abe827ac4..bc55c5e6badd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1972,8 +1972,9 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {
-		if (!device->in_fs_metadata || !device->bdev ||
-		    device->is_tgtdev_for_dev_replace)
+		if (!test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,
+						&device->dev_state) ||
+		    !device->bdev || device->is_tgtdev_for_dev_replace)
 			continue;
 
 		if (i >= nr_devices)

commit f5c29bd9dbd3e90e03ab7697ecc373b49394e62e
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Thu Nov 2 17:21:50 2017 -0600

    Btrfs: add __init macro to btrfs init functions
    
    Adding __init macro gives kernel a hint that this function is only used
    during the initialization phase and its memory resources can be freed up
    after.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3a4dce153645..7a7abe827ac4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2324,7 +2324,7 @@ static struct miscdevice btrfs_misc = {
 MODULE_ALIAS_MISCDEV(BTRFS_MINOR);
 MODULE_ALIAS("devname:btrfs-control");
 
-static int btrfs_interface_init(void)
+static int __init btrfs_interface_init(void)
 {
 	return misc_register(&btrfs_misc);
 }
@@ -2334,7 +2334,7 @@ static void btrfs_interface_exit(void)
 	misc_deregister(&btrfs_misc);
 }
 
-static void btrfs_print_mod_info(void)
+static void __init btrfs_print_mod_info(void)
 {
 	pr_info("Btrfs loaded, crc32c=%s"
 #ifdef CONFIG_BTRFS_DEBUG

commit 26cd94744e142dd5d5a21e2c1e31bacc120b2d74
Merge: 198e0c0c61b6 ea37d5998b50
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 29 14:26:50 2017 -0800

    Merge tag 'for-4.15-rc2-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs fixes from David Sterba:
     "We've collected some fixes in since the pre-merge window freeze.
    
      There's technically only one regression fix for 4.15, but the rest
      seems important and candidates for stable.
    
       - fix missing flush bio puts in error cases (is serious, but rarely
         happens)
    
       - fix reporting stat::st_blocks for buffered append writes
    
       - fix space cache invalidation
    
       - fix out of bound memory access when setting zlib level
    
       - fix potential memory corruption when fsync fails in the middle
    
       - fix crash in integrity checker
    
       - incremetnal send fix, path mixup for certain unlink/rename
         combination
    
       - pass flags to writeback so compressed writes can be throttled
         properly
    
       - error handling fixes"
    
    * tag 'for-4.15-rc2-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux:
      Btrfs: incremental send, fix wrong unlink path after renaming file
      btrfs: tree-checker: Fix false panic for sanity test
      Btrfs: fix list_add corruption and soft lockups in fsync
      btrfs: Fix wild memory access in compression level parser
      btrfs: fix deadlock when writing out space cache
      btrfs: clear space cache inode generation always
      Btrfs: fix reported number of inode blocks after buffered append writes
      Btrfs: move definition of the function btrfs_find_new_delalloc_bytes
      Btrfs: bail out gracefully rather than BUG_ON
      btrfs: dev_alloc_list is not protected by RCU, use normal list_del
      btrfs: add missing device::flush_bio puts
      btrfs: Fix transaction abort during failure in btrfs_rm_dev_item
      Btrfs: add write_flags for compression bio

commit 1751e8a6cb935e555fcdbcb9ab4f0446e322ca3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 27 13:05:09 2017 -0800

    Rename superblock flags (MS_xyz -> SB_xyz)
    
    This is a pure automated search-and-replace of the internal kernel
    superblock flags.
    
    The s_flags are now called SB_*, with the names and the values for the
    moment mirroring the MS_* flags that they're equivalent to.
    
    Note how the MS_xyz flags are the ones passed to the mount system call,
    while the SB_xyz flags are what we then use in sb->s_flags.
    
    The script to do this was:
    
        # places to look in; re security/*: it generally should *not* be
        # touched (that stuff parses mount(2) arguments directly), but
        # there are two places where we really deal with superblock flags.
        FILES="drivers/mtd drivers/staging/lustre fs ipc mm \
                include/linux/fs.h include/uapi/linux/bfs_fs.h \
                security/apparmor/apparmorfs.c security/apparmor/include/lib.h"
        # the list of MS_... constants
        SYMS="RDONLY NOSUID NODEV NOEXEC SYNCHRONOUS REMOUNT MANDLOCK \
              DIRSYNC NOATIME NODIRATIME BIND MOVE REC VERBOSE SILENT \
              POSIXACL UNBINDABLE PRIVATE SLAVE SHARED RELATIME KERNMOUNT \
              I_VERSION STRICTATIME LAZYTIME SUBMOUNT NOREMOTELOCK NOSEC BORN \
              ACTIVE NOUSER"
    
        SED_PROG=
        for i in $SYMS; do SED_PROG="$SED_PROG -e s/MS_$i/SB_$i/g"; done
    
        # we want files that contain at least one of MS_...,
        # with fs/namespace.c and fs/pnode.c excluded.
        L=$(for i in $SYMS; do git grep -w -l MS_$i $FILES; done| sort|uniq|grep -v '^fs/namespace.c'|grep -v '^fs/pnode.c')
    
        for f in $L; do sed -i $f $SED_PROG; done
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 65af029559b5..305cae7444a0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -107,7 +107,7 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 		return;
 
 	if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {
-		sb->s_flags |= MS_RDONLY;
+		sb->s_flags |= SB_RDONLY;
 		btrfs_info(fs_info, "forced readonly");
 		/*
 		 * Note that a running device replace operation is not
@@ -137,7 +137,7 @@ void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function
 
 	/*
 	 * Special case: if the error is EROFS, and we're already
-	 * under MS_RDONLY, then it is safe here.
+	 * under SB_RDONLY, then it is safe here.
 	 */
 	if (errno == -EROFS && sb_rdonly(sb))
   		return;
@@ -168,7 +168,7 @@ void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function
 	set_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);
 
 	/* Don't go through full error handling during mount */
-	if (sb->s_flags & MS_BORN)
+	if (sb->s_flags & SB_BORN)
 		btrfs_handle_error(fs_info);
 }
 
@@ -625,7 +625,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			break;
 		case Opt_acl:
 #ifdef CONFIG_BTRFS_FS_POSIX_ACL
-			info->sb->s_flags |= MS_POSIXACL;
+			info->sb->s_flags |= SB_POSIXACL;
 			break;
 #else
 			btrfs_err(info, "support for ACL not compiled in!");
@@ -633,7 +633,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			goto out;
 #endif
 		case Opt_noacl:
-			info->sb->s_flags &= ~MS_POSIXACL;
+			info->sb->s_flags &= ~SB_POSIXACL;
 			break;
 		case Opt_notreelog:
 			btrfs_set_and_info(info, NOTREELOG,
@@ -851,7 +851,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 	/*
 	 * Extra check for current option against current flag
 	 */
-	if (btrfs_test_opt(info, NOLOGREPLAY) && !(new_flags & MS_RDONLY)) {
+	if (btrfs_test_opt(info, NOLOGREPLAY) && !(new_flags & SB_RDONLY)) {
 		btrfs_err(info,
 			  "nologreplay must be used with ro mount option");
 		ret = -EINVAL;
@@ -1147,7 +1147,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;
 #ifdef CONFIG_BTRFS_FS_POSIX_ACL
-	sb->s_flags |= MS_POSIXACL;
+	sb->s_flags |= SB_POSIXACL;
 #endif
 	sb->s_flags |= SB_I_VERSION;
 	sb->s_iflags |= SB_I_CGROUPWB;
@@ -1180,7 +1180,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	}
 
 	cleancache_init_fs(sb);
-	sb->s_flags |= MS_ACTIVE;
+	sb->s_flags |= SB_ACTIVE;
 	return 0;
 
 fail_close:
@@ -1277,7 +1277,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",flushoncommit");
 	if (btrfs_test_opt(info, DISCARD))
 		seq_puts(seq, ",discard");
-	if (!(info->sb->s_flags & MS_POSIXACL))
+	if (!(info->sb->s_flags & SB_POSIXACL))
 		seq_puts(seq, ",noacl");
 	if (btrfs_test_opt(info, SPACE_CACHE))
 		seq_puts(seq, ",space_cache");
@@ -1409,11 +1409,11 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 
 	mnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name, newargs);
 	if (PTR_ERR_OR_ZERO(mnt) == -EBUSY) {
-		if (flags & MS_RDONLY) {
-			mnt = vfs_kern_mount(&btrfs_fs_type, flags & ~MS_RDONLY,
+		if (flags & SB_RDONLY) {
+			mnt = vfs_kern_mount(&btrfs_fs_type, flags & ~SB_RDONLY,
 					     device_name, newargs);
 		} else {
-			mnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY,
+			mnt = vfs_kern_mount(&btrfs_fs_type, flags | SB_RDONLY,
 					     device_name, newargs);
 			if (IS_ERR(mnt)) {
 				root = ERR_CAST(mnt);
@@ -1565,7 +1565,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	u64 subvol_objectid = 0;
 	int error = 0;
 
-	if (!(flags & MS_RDONLY))
+	if (!(flags & SB_RDONLY))
 		mode |= FMODE_WRITE;
 
 	error = btrfs_parse_early_options(data, mode, fs_type,
@@ -1619,13 +1619,13 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (error)
 		goto error_fs_info;
 
-	if (!(flags & MS_RDONLY) && fs_devices->rw_devices == 0) {
+	if (!(flags & SB_RDONLY) && fs_devices->rw_devices == 0) {
 		error = -EACCES;
 		goto error_close_devices;
 	}
 
 	bdev = fs_devices->latest_bdev;
-	s = sget(fs_type, btrfs_test_super, btrfs_set_super, flags | MS_NOSEC,
+	s = sget(fs_type, btrfs_test_super, btrfs_set_super, flags | SB_NOSEC,
 		 fs_info);
 	if (IS_ERR(s)) {
 		error = PTR_ERR(s);
@@ -1635,7 +1635,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (s->s_root) {
 		btrfs_close_devices(fs_devices);
 		free_fs_info(fs_info);
-		if ((flags ^ s->s_flags) & MS_RDONLY)
+		if ((flags ^ s->s_flags) & SB_RDONLY)
 			error = -EBUSY;
 	} else {
 		snprintf(s->s_id, sizeof(s->s_id), "%pg", bdev);
@@ -1702,11 +1702,11 @@ static inline void btrfs_remount_begin(struct btrfs_fs_info *fs_info,
 {
 	if (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&
 	    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||
-	     (flags & MS_RDONLY))) {
+	     (flags & SB_RDONLY))) {
 		/* wait for any defraggers to finish */
 		wait_event(fs_info->transaction_wait,
 			   (atomic_read(&fs_info->defrag_running) == 0));
-		if (flags & MS_RDONLY)
+		if (flags & SB_RDONLY)
 			sync_filesystem(fs_info->sb);
 	}
 }
@@ -1766,10 +1766,10 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	btrfs_resize_thread_pool(fs_info,
 		fs_info->thread_pool_size, old_thread_pool_size);
 
-	if ((bool)(*flags & MS_RDONLY) == sb_rdonly(sb))
+	if ((bool)(*flags & SB_RDONLY) == sb_rdonly(sb))
 		goto out;
 
-	if (*flags & MS_RDONLY) {
+	if (*flags & SB_RDONLY) {
 		/*
 		 * this also happens on 'umount -rf' or on shutdown, when
 		 * the filesystem is busy.
@@ -1781,10 +1781,10 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		/* avoid complains from lockdep et al. */
 		up(&fs_info->uuid_tree_rescan_sem);
 
-		sb->s_flags |= MS_RDONLY;
+		sb->s_flags |= SB_RDONLY;
 
 		/*
-		 * Setting MS_RDONLY will put the cleaner thread to
+		 * Setting SB_RDONLY will put the cleaner thread to
 		 * sleep at the next loop if it's already active.
 		 * If it's already asleep, we'll leave unused block
 		 * groups on disk until we're mounted read-write again
@@ -1856,7 +1856,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 				goto restore;
 			}
 		}
-		sb->s_flags &= ~MS_RDONLY;
+		sb->s_flags &= ~SB_RDONLY;
 
 		set_bit(BTRFS_FS_OPEN, &fs_info->flags);
 	}
@@ -1866,9 +1866,9 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	return 0;
 
 restore:
-	/* We've hit an error - don't reset MS_RDONLY */
+	/* We've hit an error - don't reset SB_RDONLY */
 	if (sb_rdonly(sb))
-		old_flags |= MS_RDONLY;
+		old_flags |= SB_RDONLY;
 	sb->s_flags = old_flags;
 	fs_info->mount_opt = old_opts;
 	fs_info->compress_type = old_compress_type;

commit eae8d82529dd9820e206ecba0047b806c4410e65
Author: Qu Wenruo <wqu@suse.com>
Date:   Mon Nov 6 10:43:18 2017 +0800

    btrfs: Fix wild memory access in compression level parser
    
    [BUG]
    Kernel panic when mounting with "-o compress" mount option.
    KASAN will report like:
    ------
    ==================================================================
    BUG: KASAN: wild-memory-access in strncmp+0x31/0xc0
    Read of size 1 at addr d86735fce994f800 by task mount/662
    ...
    Call Trace:
     dump_stack+0xe3/0x175
     kasan_report+0x163/0x370
     __asan_load1+0x47/0x50
     strncmp+0x31/0xc0
     btrfs_compress_str2level+0x20/0x70 [btrfs]
     btrfs_parse_options+0xff4/0x1870 [btrfs]
     open_ctree+0x2679/0x49f0 [btrfs]
     btrfs_mount+0x1b7f/0x1d30 [btrfs]
     mount_fs+0x49/0x190
     vfs_kern_mount.part.29+0xba/0x280
     vfs_kern_mount+0x13/0x20
     btrfs_mount+0x31e/0x1d30 [btrfs]
     mount_fs+0x49/0x190
     vfs_kern_mount.part.29+0xba/0x280
     do_mount+0xaad/0x1a00
     SyS_mount+0x98/0xe0
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    ------
    
    [Cause]
    For 'compress' and 'compress_force' options, its token doesn't expect
    any parameter so its args[0] contains uninitialized data.
    Accessing args[0] will cause above wild memory access.
    
    [Fix]
    For Opt_compress and Opt_compress_force, set compression level to
    the default.
    
    Signed-off-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ set the default in advance ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 65af029559b5..ff3545e526f5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -507,9 +507,18 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			    token == Opt_compress_force ||
 			    strncmp(args[0].from, "zlib", 4) == 0) {
 				compress_type = "zlib";
+
 				info->compress_type = BTRFS_COMPRESS_ZLIB;
-				info->compress_level =
-					btrfs_compress_str2level(args[0].from);
+				info->compress_level = BTRFS_ZLIB_DEFAULT_LEVEL;
+				/*
+				 * args[0] contains uninitialized data since
+				 * for these tokens we don't expect any
+				 * parameter.
+				 */
+				if (token != Opt_compress &&
+				    token != Opt_compress_force)
+					info->compress_level =
+					  btrfs_compress_str2level(args[0].from);
 				btrfs_set_opt(info->mount_opt, COMPRESS);
 				btrfs_clear_opt(info->mount_opt, NODATACOW);
 				btrfs_clear_opt(info->mount_opt, NODATASUM);

commit fa4d885a482ef52ad3efa12a5799a3f6408b0718
Author: Adam Borowski <kilobyte@angband.pl>
Date:   Fri Sep 15 17:36:58 2017 +0200

    btrfs: allow setting zlib compression level via :9
    
    This is bikeshedding, but it seems people are drastically more likely to
    understand "zlib:9" as compression level rather than an algorithm
    version compared to "zlib9".
    
    Based on feedback on the mailinglist, the ":9" will be the only accepted
    syntax. The level must be a single digit. Unrecognized format will
    result to the default, for forward compatibility in a similar way the
    compression algorithm specifier was relaxed in commit
    a7164fa4e055daf6368c ("btrfs: prepare for extensions in compression
    options").
    
    Signed-off-by: Adam Borowski <kilobyte@angband.pl>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ tighten the accepted format ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 57f3f9600e18..65af029559b5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1261,7 +1261,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		else
 			seq_printf(seq, ",compress=%s", compress_type);
 		if (info->compress_level)
-			seq_printf(seq, "%d", info->compress_level);
+			seq_printf(seq, ":%d", info->compress_level);
 	}
 	if (btrfs_test_opt(info, NOSSD))
 		seq_puts(seq, ",nossd");

commit f51d2b59120ff364a5e612a594ed358767e1cd09
Author: David Sterba <dsterba@suse.com>
Date:   Fri Sep 15 17:36:57 2017 +0200

    btrfs: allow to set compression level for zlib
    
    Preliminary support for setting compression level for zlib, the
    following works:
    
    $ mount -o compess=zlib                 # default
    $ mount -o compess=zlib0                # same
    $ mount -o compess=zlib9                # level 9, slower sync, less data
    $ mount -o compess=zlib1                # level 1, faster sync, more data
    $ mount -o remount,compress=zlib3       # level set by remount
    
    The compress-force works the same as compress'.  The level is visible in
    the same format in /proc/mounts. Level set via file property does not
    work yet.
    
    Required patch: "btrfs: prepare for extensions in compression options"
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4fb7eefb80ae..57f3f9600e18 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -508,6 +508,8 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			    strncmp(args[0].from, "zlib", 4) == 0) {
 				compress_type = "zlib";
 				info->compress_type = BTRFS_COMPRESS_ZLIB;
+				info->compress_level =
+					btrfs_compress_str2level(args[0].from);
 				btrfs_set_opt(info->mount_opt, COMPRESS);
 				btrfs_clear_opt(info->mount_opt, NODATACOW);
 				btrfs_clear_opt(info->mount_opt, NODATASUM);
@@ -555,9 +557,9 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			      compress_force != saved_compress_force)) ||
 			    (!btrfs_test_opt(info, COMPRESS) &&
 			     no_compress == 1)) {
-				btrfs_info(info, "%s %s compression",
+				btrfs_info(info, "%s %s compression, level %d",
 					   (compress_force) ? "force" : "use",
-					   compress_type);
+					   compress_type, info->compress_level);
 			}
 			compress_force = false;
 			break;
@@ -1258,6 +1260,8 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 			seq_printf(seq, ",compress-force=%s", compress_type);
 		else
 			seq_printf(seq, ",compress=%s", compress_type);
+		if (info->compress_level)
+			seq_printf(seq, "%d", info->compress_level);
 	}
 	if (btrfs_test_opt(info, NOSSD))
 		seq_puts(seq, ",nossd");

commit d4417e22551377c6e589c15ff2b931610e5230bc
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Oct 16 16:48:40 2017 +0300

    btrfs: Replace opencoded sizes with their symbolic constants
    
    Currently btrfs' code uses a mix of opencoded sizes and defines from sizes.h.
    Let's unifiy the code base to always use the symbolic constants. No functional
    changes
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 880ab4949f69..4fb7eefb80ae 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2126,7 +2126,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	 * succeed even if the Avail is zero. But this is better than the other
 	 * way around.
 	 */
-	thresh = 4 * 1024 * 1024;
+	thresh = SZ_4M;
 
 	if (!mixed && total_free_meta - thresh < block_rsv->size)
 		buf->f_bavail = 0;

commit fb592373cddeb4ed6c21eef4d6063f15176ab463
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Fri Sep 29 15:43:48 2017 -0400

    btrfs: add ref-verify mount option
    
    This adds the infrastructure for turning ref verify on and off for a
    mount, to be used by a later patch.
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ enhnance btrfs_print_mod_info to print if ref-verify is compiled in ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 770ac088dd9c..880ab4949f69 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -325,6 +325,9 @@ enum {
 	Opt_nologreplay, Opt_norecovery,
 #ifdef CONFIG_BTRFS_DEBUG
 	Opt_fragment_data, Opt_fragment_metadata, Opt_fragment_all,
+#endif
+#ifdef CONFIG_BTRFS_FS_REF_VERIFY
+	Opt_ref_verify,
 #endif
 	Opt_err,
 };
@@ -386,6 +389,9 @@ static const match_table_t tokens = {
 	{Opt_fragment_data, "fragment=data"},
 	{Opt_fragment_metadata, "fragment=metadata"},
 	{Opt_fragment_all, "fragment=all"},
+#endif
+#ifdef CONFIG_BTRFS_FS_REF_VERIFY
+	{Opt_ref_verify, "ref_verify"},
 #endif
 	{Opt_err, NULL},
 };
@@ -824,6 +830,12 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			btrfs_info(info, "fragmenting data");
 			btrfs_set_opt(info->mount_opt, FRAGMENT_DATA);
 			break;
+#endif
+#ifdef CONFIG_BTRFS_FS_REF_VERIFY
+		case Opt_ref_verify:
+			btrfs_info(info, "doing ref verification");
+			btrfs_set_opt(info->mount_opt, REF_VERIFY);
+			break;
 #endif
 		case Opt_err:
 			btrfs_info(info, "unrecognized mount option '%s'", p);
@@ -1305,6 +1317,8 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 	if (btrfs_test_opt(info, FRAGMENT_METADATA))
 		seq_puts(seq, ",fragment=metadata");
 #endif
+	if (btrfs_test_opt(info, REF_VERIFY))
+		seq_puts(seq, ",ref_verify");
 	seq_printf(seq, ",subvolid=%llu",
 		  BTRFS_I(d_inode(dentry))->root->root_key.objectid);
 	seq_puts(seq, ",subvol=");
@@ -2318,6 +2332,9 @@ static void btrfs_print_mod_info(void)
 #endif
 #ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
 			", integrity-checker=on"
+#endif
+#ifdef CONFIG_BTRFS_FS_REF_VERIFY
+			", ref-verify=on"
 #endif
 			"\n",
 			btrfs_crc32c_impl());

commit a7e3c5f2f7ba3f1f413df5548ed51eb25cd1c74d
Author: Rakesh Pandit <rakesh@tuxera.com>
Date:   Tue Oct 10 13:48:05 2017 +0300

    btrfs: use appropriate replacements for __sb_{start,end}_write calls
    
    Commit a53f4f8e9c8eb ("btrfs: Don't call btrfs_start_transaction() on
    frozen fs to avoid deadlock.") started using internal calls and we
    replace them with more suitable ones.
    
    Signed-off-by: Rakesh Pandit <rakesh@tuxera.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f092fe057de7..770ac088dd9c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1205,8 +1205,8 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 			 * happens. The pending operations are delayed to the
 			 * next commit after thawing.
 			 */
-			if (__sb_start_write(sb, SB_FREEZE_WRITE, false))
-				__sb_end_write(sb, SB_FREEZE_WRITE);
+			if (sb_start_write_trylock(sb))
+				sb_end_write(sb);
 			else
 				return 0;
 			trans = btrfs_start_transaction(root, 0);

commit d8953d69bca83fab616f37693152384cea49f964
Author: Satoru Takeuchi <satoru.takeuchi@gmail.com>
Date:   Tue Sep 12 20:08:08 2017 +0900

    btrfs: convert all mount option checking code to use btrfs_test_opt
    
    Signed-off-by: Satoru Takeuchi <satoru.takeuchi@gmail.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e8f5e24325f3..f092fe057de7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -292,7 +292,7 @@ void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 	vaf.va = &args;
 
 	errstr = btrfs_decode_error(errno);
-	if (fs_info && (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR))
+	if (fs_info && (btrfs_test_opt(fs_info, PANIC_ON_FATAL_ERROR)))
 		panic(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\n",
 			s_id, function, line, &vaf, errno, errstr);
 

commit 3993b112dac968612b0b213ed59cb30f50b0015b
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Sep 11 16:15:28 2017 +0100

    btrfs: avoid null pointer dereference on fs_info when calling btrfs_crit
    
    There are checks on fs_info in __btrfs_panic to avoid dereferencing a
    null fs_info, however, there is a call to btrfs_crit that may also
    dereference a null fs_info. Fix this by adding a check to see if fs_info
    is null and only print the s_id if fs_info is non-null.
    
    Detected by CoverityScan CID#401973 ("Dereference after null check")
    
    Fixes: efe120a067c8 ("Btrfs: convert printk to btrfs_ and fix BTRFS prefix")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 161694b66038..e8f5e24325f3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -202,7 +202,6 @@ static struct ratelimit_state printk_limits[] = {
 
 void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 {
-	struct super_block *sb = fs_info->sb;
 	char lvl[PRINTK_MAX_SINGLE_HEADER_LEN + 1] = "\0";
 	struct va_format vaf;
 	va_list args;
@@ -228,7 +227,8 @@ void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 	vaf.va = &args;
 
 	if (__ratelimit(ratelimit))
-		printk("%sBTRFS %s (device %s): %pV\n", lvl, type, sb->s_id, &vaf);
+		printk("%sBTRFS %s (device %s): %pV\n", lvl, type,
+			fs_info ? fs_info->sb->s_id : "<unknown>", &vaf);
 
 	va_end(args);
 }

commit 357fdad075abb976ee43f2dd450c40dcef4b7e2d
Author: Matthew Garrett <mjg59@google.com>
Date:   Wed Oct 18 13:56:26 2017 -0700

    Convert fs/*/* to SB_I_VERSION
    
    [AV: in addition to the fix in previous commit]
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 35a128acfbd1..161694b66038 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1135,7 +1135,7 @@ static int btrfs_fill_super(struct super_block *sb,
 #ifdef CONFIG_BTRFS_FS_POSIX_ACL
 	sb->s_flags |= MS_POSIXACL;
 #endif
-	sb->s_flags |= MS_I_VERSION;
+	sb->s_flags |= SB_I_VERSION;
 	sb->s_iflags |= SB_I_CGROUPWB;
 
 	err = super_setup_bdi(sb);

commit 0f0d12728e56c94d3289c6831243b6faeae8a19d
Merge: 581bfce969cb e462ec50cb5f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 14 18:54:01 2017 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull mount flag updates from Al Viro:
     "Another chunk of fmount preparations from dhowells; only trivial
      conflicts for that part. It separates MS_... bits (very grotty
      mount(2) ABI) from the struct super_block ->s_flags (kernel-internal,
      only a small subset of MS_... stuff).
    
      This does *not* convert the filesystems to new constants; only the
      infrastructure is done here. The next step in that series is where the
      conflicts would be; that's the conversion of filesystems. It's purely
      mechanical and it's better done after the merge, so if you could run
      something like
    
            list=$(for i in MS_RDONLY MS_NOSUID MS_NODEV MS_NOEXEC MS_SYNCHRONOUS MS_MANDLOCK MS_DIRSYNC MS_NOATIME MS_NODIRATIME MS_SILENT MS_POSIXACL MS_KERNMOUNT MS_I_VERSION MS_LAZYTIME; do git grep -l $i fs drivers/staging/lustre drivers/mtd ipc mm include/linux; done|sort|uniq|grep -v '^fs/namespace.c$')
    
            sed -i -e 's/\<MS_RDONLY\>/SB_RDONLY/g' \
                    -e 's/\<MS_NOSUID\>/SB_NOSUID/g' \
                    -e 's/\<MS_NODEV\>/SB_NODEV/g' \
                    -e 's/\<MS_NOEXEC\>/SB_NOEXEC/g' \
                    -e 's/\<MS_SYNCHRONOUS\>/SB_SYNCHRONOUS/g' \
                    -e 's/\<MS_MANDLOCK\>/SB_MANDLOCK/g' \
                    -e 's/\<MS_DIRSYNC\>/SB_DIRSYNC/g' \
                    -e 's/\<MS_NOATIME\>/SB_NOATIME/g' \
                    -e 's/\<MS_NODIRATIME\>/SB_NODIRATIME/g' \
                    -e 's/\<MS_SILENT\>/SB_SILENT/g' \
                    -e 's/\<MS_POSIXACL\>/SB_POSIXACL/g' \
                    -e 's/\<MS_KERNMOUNT\>/SB_KERNMOUNT/g' \
                    -e 's/\<MS_I_VERSION\>/SB_I_VERSION/g' \
                    -e 's/\<MS_LAZYTIME\>/SB_LAZYTIME/g' \
                    $list
    
      and commit it with something along the lines of 'convert filesystems
      away from use of MS_... constants' as commit message, it would save a
      quite a bit of headache next cycle"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      VFS: Differentiate mount flags (MS_*) from internal superblock flags
      VFS: Convert sb->s_flags & MS_RDONLY to sb_rdonly(sb)
      vfs: Add sb_rdonly(sb) to query the MS_RDONLY flag on s_flags

commit e7cdb60fd28b252f1c15a0e50f79a01906124915
Merge: a2bc8dea9e96 87bf54bb43dd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 14 17:30:49 2017 -0700

    Merge branch 'zstd-minimal' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull zstd support from Chris Mason:
     "Nick Terrell's patch series to add zstd support to the kernel has been
      floating around for a while. After talking with Dave Sterba, Herbert
      and Phillip, we decided to send the whole thing in as one pull
      request.
    
      zstd is a big win in speed over zlib and in compression ratio over
      lzo, and the compression team here at FB has gotten great results
      using it in production. Nick will continue to update the kernel side
      with new improvements from the open source zstd userland code.
    
      Nick has a number of benchmarks for the main zstd code in his lib/zstd
      commit:
    
          I ran the benchmarks on a Ubuntu 14.04 VM with 2 cores and 4 GiB
          of RAM. The VM is running on a MacBook Pro with a 3.1 GHz Intel
          Core i7 processor, 16 GB of RAM, and a SSD. I benchmarked using
          `silesia.tar` [3], which is 211,988,480 B large. Run the following
          commands for the benchmark:
    
            sudo modprobe zstd_compress_test
            sudo mknod zstd_compress_test c 245 0
            sudo cp silesia.tar zstd_compress_test
    
          The time is reported by the time of the userland `cp`.
          The MB/s is computed with
    
            1,536,217,008 B / time(buffer size, hash)
    
          which includes the time to copy from userland.
          The Adjusted MB/s is computed with
    
            1,536,217,088 B / (time(buffer size, hash) - time(buffer size, none)).
    
          The memory reported is the amount of memory the compressor
          requests.
    
            | Method   | Size (B) | Time (s) | Ratio | MB/s    | Adj MB/s | Mem (MB) |
            |----------|----------|----------|-------|---------|----------|----------|
            | none     | 11988480 |    0.100 |     1 | 2119.88 |        - |        - |
            | zstd -1  | 73645762 |    1.044 | 2.878 |  203.05 |   224.56 |     1.23 |
            | zstd -3  | 66988878 |    1.761 | 3.165 |  120.38 |   127.63 |     2.47 |
            | zstd -5  | 65001259 |    2.563 | 3.261 |   82.71 |    86.07 |     2.86 |
            | zstd -10 | 60165346 |   13.242 | 3.523 |   16.01 |    16.13 |    13.22 |
            | zstd -15 | 58009756 |   47.601 | 3.654 |    4.45 |     4.46 |    21.61 |
            | zstd -19 | 54014593 |  102.835 | 3.925 |    2.06 |     2.06 |    60.15 |
            | zlib -1  | 77260026 |    2.895 | 2.744 |   73.23 |    75.85 |     0.27 |
            | zlib -3  | 72972206 |    4.116 | 2.905 |   51.50 |    52.79 |     0.27 |
            | zlib -6  | 68190360 |    9.633 | 3.109 |   22.01 |    22.24 |     0.27 |
            | zlib -9  | 67613382 |   22.554 | 3.135 |    9.40 |     9.44 |     0.27 |
    
          I benchmarked zstd decompression using the same method on the same
          machine. The benchmark file is located in the upstream zstd repo
          under `contrib/linux-kernel/zstd_decompress_test.c` [4]. The
          memory reported is the amount of memory required to decompress
          data compressed with the given compression level. If you know the
          maximum size of your input, you can reduce the memory usage of
          decompression irrespective of the compression level.
    
            | Method   | Time (s) | MB/s    | Adjusted MB/s | Memory (MB) |
            |----------|----------|---------|---------------|-------------|
            | none     |    0.025 | 8479.54 |             - |           - |
            | zstd -1  |    0.358 |  592.15 |        636.60 |        0.84 |
            | zstd -3  |    0.396 |  535.32 |        571.40 |        1.46 |
            | zstd -5  |    0.396 |  535.32 |        571.40 |        1.46 |
            | zstd -10 |    0.374 |  566.81 |        607.42 |        2.51 |
            | zstd -15 |    0.379 |  559.34 |        598.84 |        4.61 |
            | zstd -19 |    0.412 |  514.54 |        547.77 |        8.80 |
            | zlib -1  |    0.940 |  225.52 |        231.68 |        0.04 |
            | zlib -3  |    0.883 |  240.08 |        247.07 |        0.04 |
            | zlib -6  |    0.844 |  251.17 |        258.84 |        0.04 |
            | zlib -9  |    0.837 |  253.27 |        287.64 |        0.04 |
    
      I ran a long series of tests and benchmarks on the btrfs side and the
      gains are very similar to the core benchmarks Nick ran"
    
    * 'zstd-minimal' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs:
      squashfs: Add zstd support
      btrfs: Add zstd support
      lib: Add zstd modules
      lib: Add xxhash module

commit 583b723151794e2ff1691f1510b4e43710293875
Author: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
Date:   Fri Jul 28 08:31:28 2017 +0200

    btrfs: Do not use data_alloc_cluster in ssd mode
    
        This patch provides a band aid to improve the 'out of the box'
    behaviour of btrfs for disks that are detected as being an ssd.  In a
    general purpose mixed workload scenario, the current ssd mode causes
    overallocation of available raw disk space for data, while leaving
    behind increasing amounts of unused fragmented free space. This
    situation leads to early ENOSPC problems which are harming user
    experience and adoption of btrfs as a general purpose filesystem.
    
    This patch modifies the data extent allocation behaviour of the ssd mode
    to make it behave identical to nossd mode.  The metadata behaviour and
    additional ssd_spread option stay untouched so far.
    
    Recommendations for future development are to reconsider the current
    oversimplified nossd / ssd distinction and the broken detection
    mechanism based on the rotational attribute in sysfs and provide
    experienced users with a more flexible way to choose allocator behaviour
    for data and metadata, optimized for certain use cases, while keeping
    sane 'out of the box' default settings.  The internals of the current
    btrfs code have more potential than what currently gets exposed to the
    user to choose from.
    
        The SSD story...
    
        In the first year of btrfs development, around early 2008, btrfs
    gained a mount option which enables specific functionality for
    filesystems on solid state devices. The first occurance of this
    functionality is in commit e18e4809, labeled "Add mount -o ssd, which
    includes optimizations for seek free storage".
    
    The effect on allocating free space for doing (data) writes is to
    'cluster' writes together, writing them out in contiguous space, as
    opposed to a 'tetris' way of putting all separate writes into any free
    space fragment that fits (which is what the -o nossd behaviour does).
    
    A somewhat simplified explanation of what happens is that, when for
    example, the 'cluster' size is set to 2MiB, when we do some writes, the
    data allocator will search for a free space block that is 2MiB big, and
    put the writes in there. The ssd mode itself might allow a 2MiB cluster
    to be composed of multiple free space extents with some existing data in
    between, while the additional ssd_spread mount option kills off this
    option and requires fully free space.
    
    The idea behind this is (commit 536ac8ae): "The [...] clusters make it
    more likely a given IO will completely overwrite the ssd block, so it
    doesn't have to do an internal rwm cycle."; ssd block meaning nand erase
    block. So, effectively this means applying a "locality based algorithm"
    and trying to outsmart the actual ssd.
    
    Since then, various changes have been made to the involved code, but the
    basic idea is still present, and gets activated whenever the ssd mount
    option is active. This also happens by default, when the rotational flag
    as seen at /sys/block/<device>/queue/rotational is set to 0.
    
        However, there's a number of problems with this approach.
    
        First, what the optimization is trying to do is outsmart the ssd by
    assuming there is a relation between the physical address space of the
    block device as seen by btrfs and the actual physical storage of the
    ssd, and then adjusting data placement. However, since the introduction
    of the Flash Translation Layer (FTL) which is a part of the internal
    controller of an ssd, these attempts are futile. The use of good quality
    FTL in consumer ssd products might have been limited in 2008, but this
    situation has changed drastically soon after that time. Today, even the
    flash memory in your automatic cat feeding machine or your grandma's
    wheelchair has a full featured one.
    
    Second, the behaviour as described above results in the filesystem being
    filled up with badly fragmented free space extents because of relatively
    small pieces of space that are freed up by deletes, but not selected
    again as part of a 'cluster'. Since the algorithm prefers allocating a
    new chunk over going back to tetris mode, the end result is a filesystem
    in which all raw space is allocated, but which is composed of
    underutilized chunks with a 'shotgun blast' pattern of fragmented free
    space. Usually, the next problematic thing that happens is the
    filesystem wanting to allocate new space for metadata, which causes the
    filesystem to fail in spectacular ways.
    
    Third, the default mount options you get for an ssd ('ssd' mode enabled,
    'discard' not enabled), in combination with spreading out writes over
    the full address space and ignoring freed up space leads to worst case
    behaviour in providing information to the ssd itself, since it will
    never learn that all the free space left behind is actually free.  There
    are two ways to let an ssd know previously written data does not have to
    be preserved, which are sending explicit signals using discard or
    fstrim, or by simply overwriting the space with new data.  The worst
    case behaviour is the btrfs ssd_spread mount option in combination with
    not having discard enabled. It has a side effect of minimizing the reuse
    of free space previously written in.
    
    Fourth, the rotational flag in /sys/ does not reliably indicate if the
    device is a locally attached ssd. For example, iSCSI or NBD displays as
    non-rotational, while a loop device on an ssd shows up as rotational.
    
    The combination of the second and third problem effectively means that
    despite all the good intentions, the btrfs ssd mode reliably causes the
    ssd hardware and the filesystem structures and performance to be choked
    to death. The clickbait version of the title of this story would have
    been "Btrfs ssd optimizations considered harmful for ssds".
    
    The current nossd 'tetris' mode (even still without discard) allows a
    pattern of overwriting much more previously used space, causing many
    more implicit discards to happen because of the overwrite information
    the ssd gets. The actual location in the physical address space, as seen
    from the point of view of btrfs is irrelevant, because the actual writes
    to the low level flash are reordered anyway thanks to the FTL.
    
        Changes made in the code
    
    1. Make ssd mode data allocation identical to tetris mode, like nossd.
    2. Adjust and clean up filesystem mount messages so that we can easily
    identify if a kernel has this patch applied or not, when providing
    support to end users. Also, make better use of the *_and_info helpers to
    only trigger messages on actual state changes.
    
        Backporting notes
    
    Notes for whoever wants to backport this patch to their 4.9 LTS kernel:
    * First apply commit 951e7966 "btrfs: drop the nossd flag when
      remounting with -o ssd", or fixup the differences manually.
    * The rest of the conflicts are because of the fs_info refactoring. So,
      for example, instead of using fs_info, it's root->fs_info in
      extent-tree.c
    
    Signed-off-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8a9bcad3b06a..0b7a1d8cd08b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -549,20 +549,22 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			break;
 		case Opt_ssd:
 			btrfs_set_and_info(info, SSD,
-					   "use ssd allocation scheme");
+					   "enabling ssd optimizations");
 			btrfs_clear_opt(info->mount_opt, NOSSD);
 			break;
 		case Opt_ssd_spread:
+			btrfs_set_and_info(info, SSD,
+					   "enabling ssd optimizations");
 			btrfs_set_and_info(info, SSD_SPREAD,
-					   "use spread ssd allocation scheme");
-			btrfs_set_opt(info->mount_opt, SSD);
+					   "using spread ssd allocation scheme");
 			btrfs_clear_opt(info->mount_opt, NOSSD);
 			break;
 		case Opt_nossd:
-			btrfs_set_and_info(info, NOSSD,
-					     "not using ssd allocation scheme");
-			btrfs_clear_opt(info->mount_opt, SSD);
-			btrfs_clear_opt(info->mount_opt, SSD_SPREAD);
+			btrfs_set_opt(info->mount_opt, NOSSD);
+			btrfs_clear_and_info(info, SSD,
+					     "not using ssd optimizations");
+			btrfs_clear_and_info(info, SSD_SPREAD,
+					     "not using spread ssd allocation scheme");
 			break;
 		case Opt_barrier:
 			btrfs_clear_and_info(info, NOBARRIER,

commit a7164fa4e055daf6368cb68ed946aa5a362a1a75
Author: David Sterba <dsterba@suse.com>
Date:   Mon Jul 17 18:11:10 2017 +0200

    btrfs: prepare for extensions in compression options
    
    This is a minimal patch intended to be backported to older kernels.
    We're going to extend the string specifying the compression method and
    this would fail on kernels before that change (the string is compared
    exactly).
    
    Relax the string matching only to the prefix, ie. ignoring anything that
    goes after "zlib" or "lzo", regardless of th format extension we decide
    to use. This applies to the mount options and properties.
    
    That way, patched old kernels could be booted on systems already
    utilizing the new compression spec.
    
    Applicable since commit 63541927c8d11, v3.14.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 64981fc8e39e..8a9bcad3b06a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -499,14 +499,14 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 				btrfs_test_opt(info, FORCE_COMPRESS);
 			if (token == Opt_compress ||
 			    token == Opt_compress_force ||
-			    strcmp(args[0].from, "zlib") == 0) {
+			    strncmp(args[0].from, "zlib", 4) == 0) {
 				compress_type = "zlib";
 				info->compress_type = BTRFS_COMPRESS_ZLIB;
 				btrfs_set_opt(info->mount_opt, COMPRESS);
 				btrfs_clear_opt(info->mount_opt, NODATACOW);
 				btrfs_clear_opt(info->mount_opt, NODATASUM);
 				no_compress = 0;
-			} else if (strcmp(args[0].from, "lzo") == 0) {
+			} else if (strncmp(args[0].from, "lzo", 3) == 0) {
 				compress_type = "lzo";
 				info->compress_type = BTRFS_COMPRESS_LZO;
 				btrfs_set_opt(info->mount_opt, COMPRESS);

commit 3ec836211183eee87609f832a949dfe711af2b5a
Author: David Sterba <dsterba@suse.com>
Date:   Thu Jun 22 02:26:54 2017 +0200

    btrfs: use GFP_KERNEL in mount and remount
    
    We don't need to restrict the allocation flags in btrfs_mount or
    _remount. No big filesystem locks are held (possibly s_umount but that
    does no count here).
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e4c268c250f5..64981fc8e39e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -426,7 +426,7 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 	 * strsep changes the string, duplicate it because parse_options
 	 * gets called twice
 	 */
-	options = kstrdup(options, GFP_NOFS);
+	options = kstrdup(options, GFP_KERNEL);
 	if (!options)
 		return -ENOMEM;
 
@@ -950,7 +950,7 @@ static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
 	}
 	path->leave_spinning = 1;
 
-	name = kmalloc(PATH_MAX, GFP_NOFS);
+	name = kmalloc(PATH_MAX, GFP_KERNEL);
 	if (!name) {
 		ret = -ENOMEM;
 		goto err;
@@ -1336,10 +1336,11 @@ static char *setup_root_args(char *args)
 	char *buf, *dst, *sep;
 
 	if (!args)
-		return kstrdup("subvolid=0", GFP_NOFS);
+		return kstrdup("subvolid=0", GFP_KERNEL);
 
 	/* The worst case is that we add ",subvolid=0" to the end. */
-	buf = dst = kmalloc(strlen(args) + strlen(",subvolid=0") + 1, GFP_NOFS);
+	buf = dst = kmalloc(strlen(args) + strlen(",subvolid=0") + 1,
+			GFP_KERNEL);
 	if (!buf)
 		return NULL;
 
@@ -1568,7 +1569,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	 * it for searching for existing supers, so this lets us do that and
 	 * then open_ctree will properly initialize everything later.
 	 */
-	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_NOFS);
+	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_KERNEL);
 	if (!fs_info) {
 		error = -ENOMEM;
 		goto error_sec_opts;
@@ -1576,8 +1577,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 	fs_info->fs_devices = fs_devices;
 
-	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
-	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
+	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
+	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_KERNEL);
 	security_init_mnt_opts(&fs_info->security_opts);
 	if (!fs_info->super_copy || !fs_info->super_for_commit) {
 		error = -ENOMEM;

commit b382cfe889da5d39aeceb79e261f862c3a53eafb
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Thu Mar 9 09:34:38 2017 +0800

    btrfs: Do chunk level check for degraded remount
    
    Just the same for mount time check, use btrfs_check_rw_degradable() to
    check if we are OK to be remounted rw.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2351794fbc44..e4c268c250f5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1781,8 +1781,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 			goto restore;
 		}
 
-		if (fs_info->fs_devices->missing_devices >
-		     fs_info->num_tolerated_disk_barrier_failures) {
+		if (!btrfs_check_rw_degradable(fs_info)) {
 			btrfs_warn(fs_info,
 				"too many missing devices, writeable remount is not allowed");
 			ret = -EACCES;

commit 6c6b5a39c4bf3dbd8cf629c9f5450e983c19dbb9
Author: Aleksa Sarai <asarai@suse.de>
Date:   Tue Jul 4 21:49:06 2017 +1000

    btrfs: resume qgroup rescan on rw remount
    
    Several distributions mount the "proper root" as ro during initrd and
    then remount it as rw before pivot_root(2). Thus, if a rescan had been
    aborted by a previous shutdown, the rescan would never be resumed.
    
    This issue would manifest itself as several btrfs ioctl(2)s causing the
    entire machine to hang when btrfs_qgroup_wait_for_completion was hit
    (due to the fs_info->qgroup_rescan_running flag being set but the rescan
    itself not being resumed). Notably, Docker's btrfs storage driver makes
    regular use of BTRFS_QUOTA_CTL_DISABLE and BTRFS_IOC_QUOTA_RESCAN_WAIT
    (causing this problem to be manifested on boot for some machines).
    
    Cc: <stable@vger.kernel.org> # v3.11+
    Cc: Jeff Mahoney <jeffm@suse.com>
    Fixes: b382a324b60f ("Btrfs: fix qgroup rescan resume on mount")
    Signed-off-by: Aleksa Sarai <asarai@suse.de>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Tested-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 58650f2e0f17..2351794fbc44 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1815,6 +1815,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 			goto restore;
 		}
 
+		btrfs_qgroup_rescan_resume(fs_info);
+
 		if (!fs_info->uuid_root) {
 			btrfs_info(fs_info, "creating UUID tree");
 			ret = btrfs_create_uuid_tree(fs_info);

commit 00142756e1f8015d2f8ce96532d156689db7e448
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jul 12 16:20:08 2017 -0600

    btrfs: backref, add tracepoints for prelim_ref insertion and merging
    
    This patch adds a tracepoint event for prelim_ref insertion and
    merging.  For each, the ref being inserted or merged and the count
    of tree nodes is issued.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 12540b6104b5..58650f2e0f17 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -61,6 +61,7 @@
 #include "tests/btrfs-tests.h"
 
 #include "qgroup.h"
+#include "backref.h"
 #define CREATE_TRACE_POINTS
 #include <trace/events/btrfs.h>
 

commit 5c1aab1dd5445ed8bdcdbb575abc1b0d7ee5b2e7
Author: Nick Terrell <terrelln@fb.com>
Date:   Wed Aug 9 19:39:02 2017 -0700

    btrfs: Add zstd support
    
    Add zstd compression and decompression support to BtrFS. zstd at its
    fastest level compresses almost as well as zlib, while offering much
    faster compression and decompression, approaching lzo speeds.
    
    I benchmarked btrfs with zstd compression against no compression, lzo
    compression, and zlib compression. I benchmarked two scenarios. Copying
    a set of files to btrfs, and then reading the files. Copying a tarball
    to btrfs, extracting it to btrfs, and then reading the extracted files.
    After every operation, I call `sync` and include the sync time.
    Between every pair of operations I unmount and remount the filesystem
    to avoid caching. The benchmark files can be found in the upstream
    zstd source repository under
    `contrib/linux-kernel/{btrfs-benchmark.sh,btrfs-extract-benchmark.sh}`
    [1] [2].
    
    I ran the benchmarks on a Ubuntu 14.04 VM with 2 cores and 4 GiB of RAM.
    The VM is running on a MacBook Pro with a 3.1 GHz Intel Core i7 processor,
    16 GB of RAM, and a SSD.
    
    The first compression benchmark is copying 10 copies of the unzipped
    Silesia corpus [3] into a BtrFS filesystem mounted with
    `-o compress-force=Method`. The decompression benchmark times how long
    it takes to `tar` all 10 copies into `/dev/null`. The compression ratio is
    measured by comparing the output of `df` and `du`. See the benchmark file
    [1] for details. I benchmarked multiple zstd compression levels, although
    the patch uses zstd level 1.
    
    | Method  | Ratio | Compression MB/s | Decompression speed |
    |---------|-------|------------------|---------------------|
    | None    |  0.99 |              504 |                 686 |
    | lzo     |  1.66 |              398 |                 442 |
    | zlib    |  2.58 |               65 |                 241 |
    | zstd 1  |  2.57 |              260 |                 383 |
    | zstd 3  |  2.71 |              174 |                 408 |
    | zstd 6  |  2.87 |               70 |                 398 |
    | zstd 9  |  2.92 |               43 |                 406 |
    | zstd 12 |  2.93 |               21 |                 408 |
    | zstd 15 |  3.01 |               11 |                 354 |
    
    The next benchmark first copies `linux-4.11.6.tar` [4] to btrfs. Then it
    measures the compression ratio, extracts the tar, and deletes the tar.
    Then it measures the compression ratio again, and `tar`s the extracted
    files into `/dev/null`. See the benchmark file [2] for details.
    
    | Method | Tar Ratio | Extract Ratio | Copy (s) | Extract (s)| Read (s) |
    |--------|-----------|---------------|----------|------------|----------|
    | None   |      0.97 |          0.78 |    0.981 |      5.501 |    8.807 |
    | lzo    |      2.06 |          1.38 |    1.631 |      8.458 |    8.585 |
    | zlib   |      3.40 |          1.86 |    7.750 |     21.544 |   11.744 |
    | zstd 1 |      3.57 |          1.85 |    2.579 |     11.479 |    9.389 |
    
    [1] https://github.com/facebook/zstd/blob/dev/contrib/linux-kernel/btrfs-benchmark.sh
    [2] https://github.com/facebook/zstd/blob/dev/contrib/linux-kernel/btrfs-extract-benchmark.sh
    [3] http://sun.aei.polsl.pl/~sdeor/index.php?page=silesia
    [4] https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.11.6.tar.xz
    
    zstd source repository: https://github.com/facebook/zstd
    
    Signed-off-by: Nick Terrell <terrelln@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 12540b6104b5..c370deadb790 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -513,6 +513,14 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 				btrfs_clear_opt(info->mount_opt, NODATASUM);
 				btrfs_set_fs_incompat(info, COMPRESS_LZO);
 				no_compress = 0;
+			} else if (strcmp(args[0].from, "zstd") == 0) {
+				compress_type = "zstd";
+				info->compress_type = BTRFS_COMPRESS_ZSTD;
+				btrfs_set_opt(info->mount_opt, COMPRESS);
+				btrfs_clear_opt(info->mount_opt, NODATACOW);
+				btrfs_clear_opt(info->mount_opt, NODATASUM);
+				btrfs_set_fs_incompat(info, COMPRESS_ZSTD);
+				no_compress = 0;
 			} else if (strncmp(args[0].from, "no", 2) == 0) {
 				compress_type = "no";
 				btrfs_clear_opt(info->mount_opt, COMPRESS);
@@ -1227,8 +1235,10 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 	if (btrfs_test_opt(info, COMPRESS)) {
 		if (info->compress_type == BTRFS_COMPRESS_ZLIB)
 			compress_type = "zlib";
-		else
+		else if (info->compress_type == BTRFS_COMPRESS_LZO)
 			compress_type = "lzo";
+		else
+			compress_type = "zstd";
 		if (btrfs_test_opt(info, FORCE_COMPRESS))
 			seq_printf(seq, ",compress-force=%s", compress_type);
 		else

commit bc98a42c1f7d0f886c0c1b75a92a004976a46d9f
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 17 08:45:34 2017 +0100

    VFS: Convert sb->s_flags & MS_RDONLY to sb_rdonly(sb)
    
    Firstly by applying the following with coccinelle's spatch:
    
            @@ expression SB; @@
            -SB->s_flags & MS_RDONLY
            +sb_rdonly(SB)
    
    to effect the conversion to sb_rdonly(sb), then by applying:
    
            @@ expression A, SB; @@
            (
            -(!sb_rdonly(SB)) && A
            +!sb_rdonly(SB) && A
            |
            -A != (sb_rdonly(SB))
            +A != sb_rdonly(SB)
            |
            -A == (sb_rdonly(SB))
            +A == sb_rdonly(SB)
            |
            -!(sb_rdonly(SB))
            +!sb_rdonly(SB)
            |
            -A && (sb_rdonly(SB))
            +A && sb_rdonly(SB)
            |
            -A || (sb_rdonly(SB))
            +A || sb_rdonly(SB)
            |
            -(sb_rdonly(SB)) != A
            +sb_rdonly(SB) != A
            |
            -(sb_rdonly(SB)) == A
            +sb_rdonly(SB) == A
            |
            -(sb_rdonly(SB)) && A
            +sb_rdonly(SB) && A
            |
            -(sb_rdonly(SB)) || A
            +sb_rdonly(SB) || A
            )
    
            @@ expression A, B, SB; @@
            (
            -(sb_rdonly(SB)) ? 1 : 0
            +sb_rdonly(SB)
            |
            -(sb_rdonly(SB)) ? A : B
            +sb_rdonly(SB) ? A : B
            )
    
    to remove left over excess bracketage and finally by applying:
    
            @@ expression A, SB; @@
            (
            -(A & MS_RDONLY) != sb_rdonly(SB)
            +(bool)(A & MS_RDONLY) != sb_rdonly(SB)
            |
            -(A & MS_RDONLY) == sb_rdonly(SB)
            +(bool)(A & MS_RDONLY) == sb_rdonly(SB)
            )
    
    to make comparisons against the result of sb_rdonly() (which is a bool)
    work correctly.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 12540b6104b5..086819312a44 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -102,7 +102,7 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 {
 	struct super_block *sb = fs_info->sb;
 
-	if (sb->s_flags & MS_RDONLY)
+	if (sb_rdonly(sb))
 		return;
 
 	if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {
@@ -138,7 +138,7 @@ void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function
 	 * Special case: if the error is EROFS, and we're already
 	 * under MS_RDONLY, then it is safe here.
 	 */
-	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
+	if (errno == -EROFS && sb_rdonly(sb))
   		return;
 
 #ifdef CONFIG_PRINTK
@@ -1687,8 +1687,7 @@ static inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,
 	 * close or the filesystem is read only.
 	 */
 	if (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&
-	    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||
-	     (fs_info->sb->s_flags & MS_RDONLY))) {
+	    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) || sb_rdonly(fs_info->sb))) {
 		btrfs_cleanup_defrag_inodes(fs_info);
 	}
 
@@ -1735,7 +1734,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	btrfs_resize_thread_pool(fs_info,
 		fs_info->thread_pool_size, old_thread_pool_size);
 
-	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
+	if ((bool)(*flags & MS_RDONLY) == sb_rdonly(sb))
 		goto out;
 
 	if (*flags & MS_RDONLY) {
@@ -1835,7 +1834,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 
 restore:
 	/* We've hit an error - don't reset MS_RDONLY */
-	if (sb->s_flags & MS_RDONLY)
+	if (sb_rdonly(sb))
 		old_flags |= MS_RDONLY;
 	sb->s_flags = old_flags;
 	fs_info->mount_opt = old_opts;

commit 78dcf73421a879d22319d3889119945b85954a68
Merge: 93ff81859733 fdb254db21bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 15 12:00:42 2017 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull ->s_options removal from Al Viro:
     "Preparations for fsmount/fsopen stuff (coming next cycle). Everything
      gets moved to explicit ->show_options(), killing ->s_options off +
      some cosmetic bits around fs/namespace.c and friends. Basically, the
      stuff needed to work with fsmount series with minimum of conflicts
      with other work.
    
      It's not strictly required for this merge window, but it would reduce
      the PITA during the coming cycle, so it would be nice to have those
      bits and pieces out of the way"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      isofs: Fix isofs_show_options()
      VFS: Kill off s_options and helpers
      orangefs: Implement show_options
      9p: Implement show_options
      isofs: Implement show_options
      afs: Implement show_options
      affs: Implement show_options
      befs: Implement show_options
      spufs: Implement show_options
      bpf: Implement show_options
      ramfs: Implement show_options
      pstore: Implement show_options
      omfs: Implement show_options
      hugetlbfs: Implement show_options
      VFS: Don't use save/replace_mount_options if not using generic_show_options
      VFS: Provide empty name qstr
      VFS: Make get_filesystem() return the affected filesystem
      VFS: Clean up whitespace in fs/namespace.c and fs/super.c
      Provide a function to create a NUL-terminated string from unterminated data

commit c3d98ea08291ca26144780f601e1fd39e4f20f7e
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jul 5 16:24:09 2017 +0100

    VFS: Don't use save/replace_mount_options if not using generic_show_options
    
    btrfs, debugfs, reiserfs and tracefs call save_mount_options() and reiserfs
    calls replace_mount_options(), but they then implement their own
    ->show_options() methods and don't touch s_options, rendering the saved
    options unnecessary.  I'm trying to eliminate s_options to make it easier
    to implement a context-based mount where the mount options can be passed
    individually over a file descriptor.
    
    Remove the calls to save/replace_mount_options() call in these cases.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Chris Mason <clm@fb.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Steven Rostedt <rostedt@goodmis.org>
    cc: linux-btrfs@vger.kernel.org
    cc: reiserfs-devel@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4f1cdd5058f1..8e9758b3eb23 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1164,7 +1164,6 @@ static int btrfs_fill_super(struct super_block *sb,
 		goto fail_close;
 	}
 
-	save_mount_options(sb, data);
 	cleancache_init_fs(sb);
 	sb->s_flags |= MS_ACTIVE;
 	return 0;

commit 6374e57ad8091b9c2db2eecc536c7f0166ce099e
Author: Chris Mason <clm@fb.com>
Date:   Fri Jun 23 09:48:21 2017 -0700

    btrfs: fix integer overflow in calc_reclaim_items_nr
    
    Dave Jones hit a WARN_ON(nr < 0) in btrfs_wait_ordered_roots() with
    v4.12-rc6.  This was because commit 70e7af244 made it possible for
    calc_reclaim_items_nr() to return a negative number.  It's not really a
    bug in that commit, it just didn't go far enough down the stack to find
    all the possible 64->32 bit overflows.
    
    This switches calc_reclaim_items_nr() to return a u64 and changes everyone
    that uses the results of that math to u64 as well.
    
    Reported-by: Dave Jones <davej@codemonkey.org.uk>
    Fixes: 70e7af2 ("Btrfs: fix delalloc accounting leak caused by u32 overflow")
    Signed-off-by: Chris Mason <clm@fb.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ba2cb7f96986..74e47794e63f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1177,7 +1177,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_wait_ordered_roots(fs_info, -1, 0, (u64)-1);
+	btrfs_wait_ordered_roots(fs_info, U64_MAX, 0, (u64)-1);
 
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {

commit 0d0c71b317207082856f40dbe8a2bac813f49677
Author: David Sterba <dsterba@suse.com>
Date:   Thu Jun 15 01:30:06 2017 +0200

    btrfs: obsolete and remove mount option alloc_start
    
    The mount option alloc_start was used in the past for debugging and
    stressing the chunk allocator. Not meant to be used by users, so we're
    not breaking anybody's setup.
    
    There was some added complexity handling changes of the value and when
    it was not same as default. Such code has likely been untested and I
    think it's better to remove it.
    
    This patch kills all use of alloc_start, and by doing that also fixes
    a bug when alloc_size is set, potentially called from statfs:
    
    in btrfs_calc_avail_data_space, traversing the list in RCU, the RCU
    protection is temporarily dropped so btrfs_account_dev_extents_size can
    be called and then RCU is locked again! Doing that inside
    list_for_each_entry_rcu is just asking for trouble, but unlikely to be
    observed in practice.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2100be6ae68e..ba2cb7f96986 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -601,18 +601,8 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			}
 			break;
 		case Opt_alloc_start:
-			num = match_strdup(&args[0]);
-			if (num) {
-				mutex_lock(&info->chunk_mutex);
-				info->alloc_start = memparse(num, NULL);
-				mutex_unlock(&info->chunk_mutex);
-				kfree(num);
-				btrfs_info(info, "allocations start at %llu",
-					   info->alloc_start);
-			} else {
-				ret = -ENOMEM;
-				goto out;
-			}
+			btrfs_info(info,
+				"option alloc_start is obsolete, ignored");
 			break;
 		case Opt_acl:
 #ifdef CONFIG_BTRFS_FS_POSIX_ACL
@@ -1232,8 +1222,6 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",nobarrier");
 	if (info->max_inline != BTRFS_DEFAULT_MAX_INLINE)
 		seq_printf(seq, ",max_inline=%llu", info->max_inline);
-	if (info->alloc_start != 0)
-		seq_printf(seq, ",alloc_start=%llu", info->alloc_start);
 	if (info->thread_pool_size !=  min_t(unsigned long,
 					     num_online_cpus() + 2, 8))
 		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);
@@ -1716,7 +1704,6 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	unsigned long old_opts = fs_info->mount_opt;
 	unsigned long old_compress_type = fs_info->compress_type;
 	u64 old_max_inline = fs_info->max_inline;
-	u64 old_alloc_start = fs_info->alloc_start;
 	int old_thread_pool_size = fs_info->thread_pool_size;
 	unsigned int old_metadata_ratio = fs_info->metadata_ratio;
 	int ret;
@@ -1855,9 +1842,6 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	fs_info->mount_opt = old_opts;
 	fs_info->compress_type = old_compress_type;
 	fs_info->max_inline = old_max_inline;
-	mutex_lock(&fs_info->chunk_mutex);
-	fs_info->alloc_start = old_alloc_start;
-	mutex_unlock(&fs_info->chunk_mutex);
 	btrfs_resize_thread_pool(fs_info,
 		old_thread_pool_size, fs_info->thread_pool_size);
 	fs_info->metadata_ratio = old_metadata_ratio;
@@ -1904,11 +1888,9 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	u64 skip_space;
 	u64 type;
 	u64 avail_space;
-	u64 used_space;
 	u64 min_stripe_size;
 	int min_stripes = 1, num_stripes = 1;
 	int i = 0, nr_devices;
-	int ret;
 
 	/*
 	 * We aren't under the device list lock, so this is racy-ish, but good
@@ -1948,8 +1930,6 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	else
 		min_stripe_size = BTRFS_STRIPE_LEN;
 
-	if (fs_info->alloc_start)
-		mutex_lock(&fs_devices->device_list_mutex);
 	rcu_read_lock();
 	list_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {
 		if (!device->in_fs_metadata || !device->bdev ||
@@ -1972,34 +1952,6 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 		 */
 		skip_space = SZ_1M;
 
-		/* user can set the offset in fs_info->alloc_start. */
-		if (fs_info->alloc_start &&
-		    fs_info->alloc_start + BTRFS_STRIPE_LEN <=
-		    device->total_bytes) {
-			rcu_read_unlock();
-			skip_space = max(fs_info->alloc_start, skip_space);
-
-			/*
-			 * btrfs can not use the free space in
-			 * [0, skip_space - 1], we must subtract it from the
-			 * total. In order to implement it, we account the used
-			 * space in this range first.
-			 */
-			ret = btrfs_account_dev_extents_size(device, 0,
-							     skip_space - 1,
-							     &used_space);
-			if (ret) {
-				kfree(devices_info);
-				mutex_unlock(&fs_devices->device_list_mutex);
-				return ret;
-			}
-
-			rcu_read_lock();
-
-			/* calc the free space in [0, skip_space - 1] */
-			skip_space -= used_space;
-		}
-
 		/*
 		 * we can use the free space in [0, skip_space - 1], subtract
 		 * it from the total.
@@ -2018,8 +1970,6 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 		i++;
 	}
 	rcu_read_unlock();
-	if (fs_info->alloc_start)
-		mutex_unlock(&fs_devices->device_list_mutex);
 
 	nr_devices = i;
 
@@ -2056,10 +2006,9 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
  * multiplier to scale the sizes.
  *
  * Unused device space usage is based on simulating the chunk allocator
- * algorithm that respects the device sizes, order of allocations and the
- * 'alloc_start' value, this is a close approximation of the actual use but
- * there are other factors that may change the result (like a new metadata
- * chunk).
+ * algorithm that respects the device sizes and order of allocations.  This is
+ * a close approximation of the actual use but there are other factors that may
+ * change the result (like a new metadata chunk).
  *
  * If metadata is exhausted, f_bavail will be 0.
  */

commit fac03c8daeb581e2bc38e5a8c0c6a42cf87cf1c3
Author: David Sterba <dsterba@suse.com>
Date:   Thu Jun 15 19:10:03 2017 +0200

    btrfs: move fs_info::fs_frozen to the flags
    
    We can keep the state among the other fs_info flags, there's no reason
    why fs_frozen would need to be separate.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 53d43cd3cace..2100be6ae68e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2242,7 +2242,7 @@ static int btrfs_freeze(struct super_block *sb)
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	struct btrfs_root *root = fs_info->tree_root;
 
-	fs_info->fs_frozen = 1;
+	set_bit(BTRFS_FS_FROZEN, &fs_info->flags);
 	/*
 	 * We don't need a barrier here, we'll wait for any transaction that
 	 * could be in progress on other threads (and do delayed iputs that
@@ -2261,7 +2261,9 @@ static int btrfs_freeze(struct super_block *sb)
 
 static int btrfs_unfreeze(struct super_block *sb)
 {
-	btrfs_sb(sb)->fs_frozen = 0;
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
+
+	clear_bit(BTRFS_FS_FROZEN, &fs_info->flags);
 	return 0;
 }
 

commit 6a44517d79a394b7f317d782ed47fd4c4bccf7e8
Author: David Sterba <dsterba@suse.com>
Date:   Thu Jun 15 15:04:04 2017 +0200

    btrfs: use GFP_KERNEL in btrfs_calc_avail_data_space
    
    We don't hold any locks here. Inidirectly called from statfs.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3371213924bd..53d43cd3cace 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1926,7 +1926,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 	}
 
 	devices_info = kmalloc_array(nr_devices, sizeof(*devices_info),
-			       GFP_NOFS);
+			       GFP_KERNEL);
 	if (!devices_info)
 		return -ENOMEM;
 

commit 1b86826d12dc4acf9576cad9c43da74025dc8074
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed May 17 11:38:35 2017 -0400

    btrfs: cleanup root usage by btrfs_get_alloc_profile
    
    There are two places where we don't already know what kind of alloc
    profile we need before calling btrfs_get_alloc_profile, but we need
    access to a root everywhere we call it.
    
    This patch adds helpers for btrfs_{data,metadata,system}_alloc_profile()
    and relegates btrfs_system_alloc_profile to a static for use in those
    two cases.  The next patch will eliminate one of those.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4f1cdd5058f1..3371213924bd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1898,7 +1898,6 @@ static inline void btrfs_descending_sort_devices(
 static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 				       u64 *free_bytes)
 {
-	struct btrfs_root *root = fs_info->tree_root;
 	struct btrfs_device_info *devices_info;
 	struct btrfs_fs_devices *fs_devices = fs_info->fs_devices;
 	struct btrfs_device *device;
@@ -1932,7 +1931,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
 		return -ENOMEM;
 
 	/* calc min stripe number for data space allocation */
-	type = btrfs_get_alloc_profile(root, 1);
+	type = btrfs_data_alloc_profile(fs_info);
 	if (type & BTRFS_BLOCK_GROUP_RAID0) {
 		min_stripes = 2;
 		num_stripes = nr_devices;

commit 1176032cb12bb89ad558a3e57e82f2f25b817eff
Merge: 56868a460b83 9bcaaea7418d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 10 08:33:17 2017 -0700

    Merge branch 'for-linus-4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "This has fixes and cleanups Dave Sterba collected for the merge
      window.
    
      The biggest functional fixes are between btrfs raid5/6 and scrub, and
      raid5/6 and device replacement. Some of our pending qgroup fixes are
      included as well while I bash on the rest in testing.
    
      We also have the usual set of cleanups, including one that makes
      __btrfs_map_block() much more maintainable, and conversions from
      atomic_t to refcount_t"
    
    * 'for-linus-4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (71 commits)
      btrfs: fix the gfp_mask for the reada_zones radix tree
      Btrfs: fix reported number of inode blocks
      Btrfs: send, fix file hole not being preserved due to inline extent
      Btrfs: fix extent map leak during fallocate error path
      Btrfs: fix incorrect space accounting after failure to insert inline extent
      Btrfs: fix invalid attempt to free reserved space on failure to cow range
      btrfs: Handle delalloc error correctly to avoid ordered extent hang
      btrfs: Fix metadata underflow caused by btrfs_reloc_clone_csum error
      btrfs: check if the device is flush capable
      btrfs: delete unused member nobarriers
      btrfs: scrub: Fix RAID56 recovery race condition
      btrfs: scrub: Introduce full stripe lock for RAID56
      btrfs: Use ktime_get_real_ts for root ctime
      Btrfs: handle only applicable errors returned by btrfs_get_extent
      btrfs: qgroup: Fix qgroup corruption caused by inode_cache mount option
      btrfs: use q which is already obtained from bdev_get_queue
      Btrfs: switch to div64_u64 if with a u64 divisor
      Btrfs: update scrub_parity to use u64 stripe_len
      Btrfs: enable repair during read for raid56 profile
      btrfs: use clear_page where appropriate
      ...

commit 694752922b12bd318aa80191bd9d8c3dcfb39055
Merge: a351e9b9fc24 9438b3e080be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 1 10:39:57 2017 -0700

    Merge branch 'for-4.12/block' of git://git.kernel.dk/linux-block
    
    Pull block layer updates from Jens Axboe:
    
     - Add BFQ IO scheduler under the new blk-mq scheduling framework. BFQ
       was initially a fork of CFQ, but subsequently changed to implement
       fairness based on B-WF2Q+, a modified variant of WF2Q. BFQ is meant
       to be used on desktop type single drives, providing good fairness.
       From Paolo.
    
     - Add Kyber IO scheduler. This is a full multiqueue aware scheduler,
       using a scalable token based algorithm that throttles IO based on
       live completion IO stats, similary to blk-wbt. From Omar.
    
     - A series from Jan, moving users to separately allocated backing
       devices. This continues the work of separating backing device life
       times, solving various problems with hot removal.
    
     - A series of updates for lightnvm, mostly from Javier. Includes a
       'pblk' target that exposes an open channel SSD as a physical block
       device.
    
     - A series of fixes and improvements for nbd from Josef.
    
     - A series from Omar, removing queue sharing between devices on mostly
       legacy drivers. This helps us clean up other bits, if we know that a
       queue only has a single device backing. This has been overdue for
       more than a decade.
    
     - Fixes for the blk-stats, and improvements to unify the stats and user
       windows. This both improves blk-wbt, and enables other users to
       register a need to receive IO stats for a device. From Omar.
    
     - blk-throttle improvements from Shaohua. This provides a scalable
       framework for implementing scalable priotization - particularly for
       blk-mq, but applicable to any type of block device. The interface is
       marked experimental for now.
    
     - Bucketized IO stats for IO polling from Stephen Bates. This improves
       efficiency of polled workloads in the presence of mixed block size
       IO.
    
     - A few fixes for opal, from Scott.
    
     - A few pulls for NVMe, including a lot of fixes for NVMe-over-fabrics.
       From a variety of folks, mostly Sagi and James Smart.
    
     - A series from Bart, improving our exposed info and capabilities from
       the blk-mq debugfs support.
    
     - A series from Christoph, cleaning up how handle WRITE_ZEROES.
    
     - A series from Christoph, cleaning up the block layer handling of how
       we track errors in a request. On top of being a nice cleanup, it also
       shrinks the size of struct request a bit.
    
     - Removal of mg_disk and hd (sorry Linus) by Christoph. The former was
       never used by platforms, and the latter has outlived it's usefulness.
    
     - Various little bug fixes and cleanups from a wide variety of folks.
    
    * 'for-4.12/block' of git://git.kernel.dk/linux-block: (329 commits)
      block: hide badblocks attribute by default
      blk-mq: unify hctx delay_work and run_work
      block: add kblock_mod_delayed_work_on()
      blk-mq: unify hctx delayed_run_work and run_work
      nbd: fix use after free on module unload
      MAINTAINERS: bfq: Add Paolo as maintainer for the BFQ I/O scheduler
      blk-mq-sched: alloate reserved tags out of normal pool
      mtip32xx: use runtime tag to initialize command header
      scsi: Implement blk_mq_ops.show_rq()
      blk-mq: Add blk_mq_ops.show_rq()
      blk-mq: Show operation, cmd_flags and rq_flags names
      blk-mq: Make blk_flags_show() callers append a newline character
      blk-mq: Move the "state" debugfs attribute one level down
      blk-mq: Unregister debugfs attributes earlier
      blk-mq: Only unregister hctxs for which registration succeeded
      blk-mq-debugfs: Rename functions for registering and unregistering the mq directory
      blk-mq: Let blk_mq_debugfs_register() look up the queue name
      blk-mq: Register <dev>/queue/mq after having registered <dev>/queue
      ide-pm: always pass 0 error to ide_complete_rq in ide_do_devset
      ide-pm: always pass 0 error to __blk_end_request_all
      ..

commit 9e11ceee23f25b6bb03de97ad1b729784f09538c
Author: Jan Kara <jack@suse.cz>
Date:   Wed Apr 12 12:24:32 2017 +0200

    btrfs: Convert to separately allocated bdi
    
    Allocate struct backing_dev_info separately instead of embedding it
    inside superblock. This unifies handling of bdi among users.
    
    CC: Chris Mason <clm@fb.com>
    CC: Josef Bacik <jbacik@fb.com>
    CC: David Sterba <dsterba@suse.com>
    CC: linux-btrfs@vger.kernel.org
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index da687dc79cce..e0a7503ab31e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1133,6 +1133,13 @@ static int btrfs_fill_super(struct super_block *sb,
 #endif
 	sb->s_flags |= MS_I_VERSION;
 	sb->s_iflags |= SB_I_CGROUPWB;
+
+	err = super_setup_bdi(sb);
+	if (err) {
+		btrfs_err(fs_info, "super_setup_bdi failed");
+		return err;
+	}
+
 	err = open_ctree(sb, fs_devices, (char *)data);
 	if (err) {
 		btrfs_err(fs_info, "open_ctree failed");

commit 4d339d01063a248b3deb3aff94aaf53be6e84e08
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Sat Mar 4 12:32:50 2017 -0600

    btrfs: No need to check !(flags & MS_RDONLY) twice
    
    Code cleanup.
    The code block is for !(*flags & MS_RDONLY). We don't need
    to check it again.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9530a333d302..6346876c97ea 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1788,8 +1788,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		}
 
 		if (fs_info->fs_devices->missing_devices >
-		     fs_info->num_tolerated_disk_barrier_failures &&
-		    !(*flags & MS_RDONLY)) {
+		     fs_info->num_tolerated_disk_barrier_failures) {
 			btrfs_warn(fs_info,
 				"too many missing devices, writeable remount is not allowed");
 			ret = -EACCES;

commit 951e7966398b0fd6bacebec2d87ffd61c3f68b18
Author: Adam Borowski <kilobyte@angband.pl>
Date:   Fri Mar 31 17:19:04 2017 +0200

    btrfs: drop the nossd flag when remounting with -o ssd
    
    The opposite case was already handled right in the very next switch entry.
    And also when turning on nossd, drop ssd_spread.
    
    Reported-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    Signed-off-by: Adam Borowski <kilobyte@angband.pl>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index da687dc79cce..9530a333d302 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -549,16 +549,19 @@ int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 		case Opt_ssd:
 			btrfs_set_and_info(info, SSD,
 					   "use ssd allocation scheme");
+			btrfs_clear_opt(info->mount_opt, NOSSD);
 			break;
 		case Opt_ssd_spread:
 			btrfs_set_and_info(info, SSD_SPREAD,
 					   "use spread ssd allocation scheme");
 			btrfs_set_opt(info->mount_opt, SSD);
+			btrfs_clear_opt(info->mount_opt, NOSSD);
 			break;
 		case Opt_nossd:
 			btrfs_set_and_info(info, NOSSD,
 					     "not using ssd allocation scheme");
 			btrfs_clear_opt(info->mount_opt, SSD);
+			btrfs_clear_opt(info->mount_opt, SSD_SPREAD);
 			break;
 		case Opt_barrier:
 			btrfs_clear_and_info(info, NOBARRIER,

commit 56e033a7874ae4bb5204a38fd5d5cf99c1311321
Author: David Sterba <dsterba@suse.com>
Date:   Fri Feb 10 19:44:31 2017 +0100

    btrfs: remove unused parameter from btrfs_fill_super
    
    Never used for anything meaningful since we have our own superblock
    filler.
    
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 93ed29c2a38b..da687dc79cce 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1114,7 +1114,7 @@ static int get_default_subvol_objectid(struct btrfs_fs_info *fs_info, u64 *objec
 
 static int btrfs_fill_super(struct super_block *sb,
 			    struct btrfs_fs_devices *fs_devices,
-			    void *data, int silent)
+			    void *data)
 {
 	struct inode *inode;
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
@@ -1611,8 +1611,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	} else {
 		snprintf(s->s_id, sizeof(s->s_id), "%pg", bdev);
 		btrfs_sb(s)->bdev_holder = fs_type;
-		error = btrfs_fill_super(s, fs_devices, data,
-					 flags & MS_SILENT ? 1 : 0);
+		error = btrfs_fill_super(s, fs_devices, data);
 	}
 	if (error) {
 		deactivate_locked_super(s);

commit 20c7bcec6f8fcc305f1f2a2488657836ca8be69d
Author: Seraphime Kirkovski <kirkseraph@gmail.com>
Date:   Thu Dec 15 14:38:16 2016 +0100

    Btrfs: ACCESS_ONCE cleanup
    
    This replaces ACCESS_ONCE macro with the corresponding
    READ|WRITE macros
    
    Signed-off-by: Seraphime Kirkovski <kirkseraph@gmail.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b5ae7d3d1896..93ed29c2a38b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -265,7 +265,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 		           function, line, errstr);
 		return;
 	}
-	ACCESS_ONCE(trans->transaction->aborted) = errno;
+	WRITE_ONCE(trans->transaction->aborted, errno);
 	/* Wake up anybody who may be waiting on this transaction */
 	wake_up(&fs_info->transaction_wait);
 	wake_up(&fs_info->transaction_blocked_wait);

commit 087a76d390cbb8c0d21ea0cb3672ab4a7bb76362
Merge: 759b2656b259 2939e1a86f75
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 10:53:01 2016 -0800

    Merge branch 'for-linus-4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "Jeff Mahoney and Dave Sterba have a really nice set of cleanups in
      here, and Christoph pitched in corrections/improvements to make btrfs
      use proper helpers for bio walking instead of doing it by hand.
    
      There are some key fixes as well, including some long standing bugs
      that took forever to track down in btrfs_drop_extents and during
      balance"
    
    * 'for-linus-4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (77 commits)
      btrfs: limit async_work allocation and worker func duration
      Revert "Btrfs: adjust len of writes if following a preallocated extent"
      Btrfs: don't WARN() in btrfs_transaction_abort() for IO errors
      btrfs: opencode chunk locking, remove helpers
      btrfs: remove root parameter from transaction commit/end routines
      btrfs: split btrfs_wait_marked_extents into normal and tree log functions
      btrfs: take an fs_info directly when the root is not used otherwise
      btrfs: simplify btrfs_wait_cache_io prototype
      btrfs: convert extent-tree tracepoints to use fs_info
      btrfs: root->fs_info cleanup, access fs_info->delayed_root directly
      btrfs: root->fs_info cleanup, add fs_info convenience variables
      btrfs: root->fs_info cleanup, update_block_group{,flags}
      btrfs: root->fs_info cleanup, lock/unlock_chunks
      btrfs: root->fs_info cleanup, btrfs_calc_{trans,trunc}_metadata_size
      btrfs: pull node/sector/stripe sizes out of root and into fs_info
      btrfs: root->fs_info cleanup, io_ctl_init
      btrfs: root->fs_info cleanup, use fs_info->dev_root everywhere
      btrfs: struct reada_control.root -> reada_control.fs_info
      btrfs: struct btrfsic_state->root should be an fs_info
      btrfs: alloc_reserved_file_extent trace point should use extent_root
      ...

commit 40f7828b36e3b9dd2fdc34d065e342cddf8d7bef
Author: Petr Mladek <pmladek@suse.com>
Date:   Wed Dec 14 15:04:01 2016 -0800

    btrfs: better handle btrfs_printk() defaults
    
    Commit 262c5e86fec7 ("printk/btrfs: handle more message headers")
    triggers:
    
        warning: `ratelimit' may be used uninitialized in this function
    
    with gcc (4.1.2) and probably many other versions.  The code actually is
    correct but a bit twisted.  Let's make it more straightforward and set
    the default values at the beginning.
    
    Link: http://lkml.kernel.org/r/20161213135246.GQ3506@pathway.suse.cz
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 180f910339f4..3b713b6fcc26 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -202,12 +202,12 @@ static struct ratelimit_state printk_limits[] = {
 void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 {
 	struct super_block *sb = fs_info->sb;
-	char lvl[PRINTK_MAX_SINGLE_HEADER_LEN + 1];
+	char lvl[PRINTK_MAX_SINGLE_HEADER_LEN + 1] = "\0";
 	struct va_format vaf;
 	va_list args;
-	const char *type = NULL;
 	int kern_level;
-	struct ratelimit_state *ratelimit;
+	const char *type = logtypes[4];
+	struct ratelimit_state *ratelimit = &printk_limits[4];
 
 	va_start(args, fmt);
 
@@ -223,12 +223,6 @@ void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 		fmt += size;
 	}
 
-	if (!type) {
-		*lvl = '\0';
-		type = logtypes[4];
-		ratelimit = &printk_limits[4];
-	}
-
 	vaf.fmt = fmt;
 	vaf.va = &args;
 

commit 262c5e86fec7cfd59754732001a9ff5b13eba501
Author: Petr Mladek <pmladek@suse.com>
Date:   Mon Dec 12 16:45:50 2016 -0800

    printk/btrfs: handle more message headers
    
    Commit 4bcc595ccd80 ("printk: reinstate KERN_CONT for printing
    continuation lines") allows to define more message headers for a single
    message.  The motivation is that continuous lines might get mixed.
    Therefore it make sense to define the right log level for every piece of
    a cont line.
    
    The current btrfs_printk() macros do not support continuous lines at the
    moment.  But better be prepared for a custom messages and avoid
    potential "lvl" buffer overflow.
    
    This patch iterates over the entire message header.  It is interested
    only into the message level like the original code.
    
    This patch also introduces PRINTK_MAX_SINGLE_HEADER_LEN.  Three bytes
    are enough for the message level header at the moment.  But it used to
    be three, see the commit 04d2c8c83d0e ("printk: convert the format for
    KERN_<LEVEL> to a 2 byte pattern").
    
    Also I fixed the default ratelimit level.  It looked very strange when it
    was different from the default log level.
    
    [pmladek@suse.com: Fix a check of the valid message level]
      Link: http://lkml.kernel.org/r/20161111183236.GD2145@dhcp128.suse.cz
    Link: http://lkml.kernel.org/r/1478695291-12169-4-git-send-email-pmladek@suse.com
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Acked-by: David Sterba <dsterba@suse.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: Chris Mason <clm@fb.com>
    Cc: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 74ed5aae6cea..180f910339f4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -202,27 +202,31 @@ static struct ratelimit_state printk_limits[] = {
 void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 {
 	struct super_block *sb = fs_info->sb;
-	char lvl[4];
+	char lvl[PRINTK_MAX_SINGLE_HEADER_LEN + 1];
 	struct va_format vaf;
 	va_list args;
-	const char *type = logtypes[4];
+	const char *type = NULL;
 	int kern_level;
 	struct ratelimit_state *ratelimit;
 
 	va_start(args, fmt);
 
-	kern_level = printk_get_level(fmt);
-	if (kern_level) {
+	while ((kern_level = printk_get_level(fmt)) != 0) {
 		size_t size = printk_skip_level(fmt) - fmt;
-		memcpy(lvl, fmt,  size);
-		lvl[size] = '\0';
+
+		if (kern_level >= '0' && kern_level <= '7') {
+			memcpy(lvl, fmt,  size);
+			lvl[size] = '\0';
+			type = logtypes[kern_level - '0'];
+			ratelimit = &printk_limits[kern_level - '0'];
+		}
 		fmt += size;
-		type = logtypes[kern_level - '0'];
-		ratelimit = &printk_limits[kern_level - '0'];
-	} else {
+	}
+
+	if (!type) {
 		*lvl = '\0';
-		/* Default to debug output */
-		ratelimit = &printk_limits[7];
+		type = logtypes[4];
+		ratelimit = &printk_limits[4];
 	}
 
 	vaf.fmt = fmt;

commit 3a45bb207ee2c5548ebf6f5fcc7d249e141f15e8
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Sep 9 21:39:03 2016 -0400

    btrfs: remove root parameter from transaction commit/end routines
    
    Now we only use the root parameter to print the root objectid in
    a tracepoint.  We can use the root parameter from the transaction
    handle for that.  It's also used to join the transaction with
    async commits, so we remove the comment that it's just for checking.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3021b0f32e53..4a151930f201 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1206,7 +1206,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		if (IS_ERR(trans))
 			return PTR_ERR(trans);
 	}
-	return btrfs_commit_transaction(trans, root);
+	return btrfs_commit_transaction(trans);
 }
 
 static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
@@ -2251,7 +2251,7 @@ static int btrfs_freeze(struct super_block *sb)
 			return 0;
 		return PTR_ERR(trans);
 	}
-	return btrfs_commit_transaction(trans, root);
+	return btrfs_commit_transaction(trans);
 }
 
 static int btrfs_unfreeze(struct super_block *sb)

commit 2ff7e61e0d30ff166a2ae94575526bffe11fd1a8
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 22 18:54:24 2016 -0400

    btrfs: take an fs_info directly when the root is not used otherwise
    
    There are loads of functions in btrfs that accept a root parameter
    but only use it to obtain an fs_info pointer.  Let's convert those to
    just accept an fs_info pointer directly.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index fa2f33fe8c6c..3021b0f32e53 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -396,10 +396,9 @@ static const match_table_t tokens = {
  * reading in a new superblock is parsed here.
  * XXX JDM: This needs to be cleaned up for remount.
  */
-int btrfs_parse_options(struct btrfs_root *root, char *options,
+int btrfs_parse_options(struct btrfs_fs_info *info, char *options,
 			unsigned long new_flags)
 {
-	struct btrfs_fs_info *info = root->fs_info;
 	substring_t args[MAX_OPT_ARGS];
 	char *p, *num, *orig = NULL;
 	u64 cache_gen;
@@ -1733,7 +1732,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		}
 	}
 
-	ret = btrfs_parse_options(root, data, *flags);
+	ret = btrfs_parse_options(fs_info, data, *flags);
 	if (ret) {
 		ret = -EINVAL;
 		goto restore;

commit 0b246afa62b0cf5b09d078121f543135f28492ad
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 22 18:54:23 2016 -0400

    btrfs: root->fs_info cleanup, add fs_info convenience variables
    
    In routines where someptr->fs_info is referenced multiple times, we
    introduce a convenience variable.  This makes the code considerably
    more readable.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c91a51f1e8f2..fa2f33fe8c6c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -411,8 +411,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 	bool saved_compress_force;
 	int no_compress = 0;
 
-	cache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);
-	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE))
+	cache_gen = btrfs_super_cache_generation(info->super_copy);
+	if (btrfs_fs_compat_ro(info, FREE_SPACE_TREE))
 		btrfs_set_opt(info->mount_opt, FREE_SPACE_TREE);
 	else if (cache_gen)
 		btrfs_set_opt(info->mount_opt, SPACE_CACHE);
@@ -442,7 +442,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_degraded:
-			btrfs_info(root->fs_info, "allowing degraded mounts");
+			btrfs_info(info, "allowing degraded mounts");
 			btrfs_set_opt(info->mount_opt, DEGRADED);
 			break;
 		case Opt_subvol:
@@ -461,11 +461,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 		case Opt_datasum:
 			if (btrfs_test_opt(info, NODATASUM)) {
 				if (btrfs_test_opt(info, NODATACOW))
-					btrfs_info(root->fs_info,
+					btrfs_info(info,
 						   "setting datasum, datacow enabled");
 				else
-					btrfs_info(root->fs_info,
-						   "setting datasum");
+					btrfs_info(info, "setting datasum");
 			}
 			btrfs_clear_opt(info->mount_opt, NODATACOW);
 			btrfs_clear_opt(info->mount_opt, NODATASUM);
@@ -474,11 +473,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			if (!btrfs_test_opt(info, NODATACOW)) {
 				if (!btrfs_test_opt(info, COMPRESS) ||
 				    !btrfs_test_opt(info, FORCE_COMPRESS)) {
-					btrfs_info(root->fs_info,
+					btrfs_info(info,
 						   "setting nodatacow, compression disabled");
 				} else {
-					btrfs_info(root->fs_info,
-						   "setting nodatacow");
+					btrfs_info(info, "setting nodatacow");
 				}
 			}
 			btrfs_clear_opt(info->mount_opt, COMPRESS);
@@ -545,8 +543,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			      compress_force != saved_compress_force)) ||
 			    (!btrfs_test_opt(info, COMPRESS) &&
 			     no_compress == 1)) {
-				btrfs_info(root->fs_info,
-					   "%s %s compression",
+				btrfs_info(info, "%s %s compression",
 					   (compress_force) ? "force" : "use",
 					   compress_type);
 			}
@@ -594,10 +591,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 				if (info->max_inline) {
 					info->max_inline = min_t(u64,
 						info->max_inline,
-						root->fs_info->sectorsize);
+						info->sectorsize);
 				}
-				btrfs_info(root->fs_info, "max_inline at %llu",
-					info->max_inline);
+				btrfs_info(info, "max_inline at %llu",
+					   info->max_inline);
 			} else {
 				ret = -ENOMEM;
 				goto out;
@@ -610,8 +607,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 				info->alloc_start = memparse(num, NULL);
 				mutex_unlock(&info->chunk_mutex);
 				kfree(num);
-				btrfs_info(root->fs_info,
-					   "allocations start at %llu",
+				btrfs_info(info, "allocations start at %llu",
 					   info->alloc_start);
 			} else {
 				ret = -ENOMEM;
@@ -620,16 +616,15 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			break;
 		case Opt_acl:
 #ifdef CONFIG_BTRFS_FS_POSIX_ACL
-			root->fs_info->sb->s_flags |= MS_POSIXACL;
+			info->sb->s_flags |= MS_POSIXACL;
 			break;
 #else
-			btrfs_err(root->fs_info,
-				"support for ACL not compiled in!");
+			btrfs_err(info, "support for ACL not compiled in!");
 			ret = -EINVAL;
 			goto out;
 #endif
 		case Opt_noacl:
-			root->fs_info->sb->s_flags &= ~MS_POSIXACL;
+			info->sb->s_flags &= ~MS_POSIXACL;
 			break;
 		case Opt_notreelog:
 			btrfs_set_and_info(info, NOTREELOG,
@@ -658,8 +653,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 				goto out;
 			} else if (intarg >= 0) {
 				info->metadata_ratio = intarg;
-				btrfs_info(root->fs_info, "metadata ratio %d",
-				       info->metadata_ratio);
+				btrfs_info(info, "metadata ratio %d",
+					   info->metadata_ratio);
 			} else {
 				ret = -EINVAL;
 				goto out;
@@ -677,15 +672,14 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 		case Opt_space_cache_version:
 			if (token == Opt_space_cache ||
 			    strcmp(args[0].from, "v1") == 0) {
-				btrfs_clear_opt(root->fs_info->mount_opt,
+				btrfs_clear_opt(info->mount_opt,
 						FREE_SPACE_TREE);
 				btrfs_set_and_info(info, SPACE_CACHE,
-						   "enabling disk space caching");
+					   "enabling disk space caching");
 			} else if (strcmp(args[0].from, "v2") == 0) {
-				btrfs_clear_opt(root->fs_info->mount_opt,
+				btrfs_clear_opt(info->mount_opt,
 						SPACE_CACHE);
-				btrfs_set_and_info(info,
-						   FREE_SPACE_TREE,
+				btrfs_set_and_info(info, FREE_SPACE_TREE,
 						   "enabling free space tree");
 			} else {
 				ret = -EINVAL;
@@ -697,14 +691,12 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			break;
 		case Opt_no_space_cache:
 			if (btrfs_test_opt(info, SPACE_CACHE)) {
-				btrfs_clear_and_info(info,
-						     SPACE_CACHE,
-						     "disabling disk space caching");
+				btrfs_clear_and_info(info, SPACE_CACHE,
+					     "disabling disk space caching");
 			}
 			if (btrfs_test_opt(info, FREE_SPACE_TREE)) {
-				btrfs_clear_and_info(info,
-						     FREE_SPACE_TREE,
-						     "disabling free space tree");
+				btrfs_clear_and_info(info, FREE_SPACE_TREE,
+					     "disabling free space tree");
 			}
 			break;
 		case Opt_inode_cache:
@@ -737,10 +729,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 					     "disabling auto defrag");
 			break;
 		case Opt_recovery:
-			btrfs_warn(root->fs_info,
+			btrfs_warn(info,
 				   "'recovery' is deprecated, use 'usebackuproot' instead");
 		case Opt_usebackuproot:
-			btrfs_info(root->fs_info,
+			btrfs_info(info,
 				   "trying to use backup root at mount time");
 			btrfs_set_opt(info->mount_opt, USEBACKUPROOT);
 			break;
@@ -749,14 +741,14 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			break;
 #ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
 		case Opt_check_integrity_including_extent_data:
-			btrfs_info(root->fs_info,
+			btrfs_info(info,
 				   "enabling check integrity including extent data");
 			btrfs_set_opt(info->mount_opt,
 				      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);
 			btrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);
 			break;
 		case Opt_check_integrity:
-			btrfs_info(root->fs_info, "enabling check integrity");
+			btrfs_info(info, "enabling check integrity");
 			btrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);
 			break;
 		case Opt_check_integrity_print_mask:
@@ -765,7 +757,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 				goto out;
 			} else if (intarg >= 0) {
 				info->check_integrity_print_mask = intarg;
-				btrfs_info(root->fs_info,
+				btrfs_info(info,
 					   "check_integrity_print_mask 0x%x",
 					   info->check_integrity_print_mask);
 			} else {
@@ -777,8 +769,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 		case Opt_check_integrity_including_extent_data:
 		case Opt_check_integrity:
 		case Opt_check_integrity_print_mask:
-			btrfs_err(root->fs_info,
-				"support for check_integrity* not compiled in!");
+			btrfs_err(info,
+				  "support for check_integrity* not compiled in!");
 			ret = -EINVAL;
 			goto out;
 #endif
@@ -798,20 +790,19 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			intarg = 0;
 			ret = match_int(&args[0], &intarg);
 			if (ret < 0) {
-				btrfs_err(root->fs_info,
-					  "invalid commit interval");
+				btrfs_err(info, "invalid commit interval");
 				ret = -EINVAL;
 				goto out;
 			}
 			if (intarg > 0) {
 				if (intarg > 300) {
-					btrfs_warn(root->fs_info,
+					btrfs_warn(info,
 						"excessive commit interval %d",
 						intarg);
 				}
 				info->commit_interval = intarg;
 			} else {
-				btrfs_info(root->fs_info,
+				btrfs_info(info,
 					   "using default commit interval %ds",
 					   BTRFS_DEFAULT_COMMIT_INTERVAL);
 				info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;
@@ -819,23 +810,22 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			break;
 #ifdef CONFIG_BTRFS_DEBUG
 		case Opt_fragment_all:
-			btrfs_info(root->fs_info, "fragmenting all space");
+			btrfs_info(info, "fragmenting all space");
 			btrfs_set_opt(info->mount_opt, FRAGMENT_DATA);
 			btrfs_set_opt(info->mount_opt, FRAGMENT_METADATA);
 			break;
 		case Opt_fragment_metadata:
-			btrfs_info(root->fs_info, "fragmenting metadata");
+			btrfs_info(info, "fragmenting metadata");
 			btrfs_set_opt(info->mount_opt,
 				      FRAGMENT_METADATA);
 			break;
 		case Opt_fragment_data:
-			btrfs_info(root->fs_info, "fragmenting data");
+			btrfs_info(info, "fragmenting data");
 			btrfs_set_opt(info->mount_opt, FRAGMENT_DATA);
 			break;
 #endif
 		case Opt_err:
-			btrfs_info(root->fs_info,
-				   "unrecognized mount option '%s'", p);
+			btrfs_info(info, "unrecognized mount option '%s'", p);
 			ret = -EINVAL;
 			goto out;
 		default:
@@ -847,22 +837,22 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 	 * Extra check for current option against current flag
 	 */
 	if (btrfs_test_opt(info, NOLOGREPLAY) && !(new_flags & MS_RDONLY)) {
-		btrfs_err(root->fs_info,
+		btrfs_err(info,
 			  "nologreplay must be used with ro mount option");
 		ret = -EINVAL;
 	}
 out:
-	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE) &&
+	if (btrfs_fs_compat_ro(info, FREE_SPACE_TREE) &&
 	    !btrfs_test_opt(info, FREE_SPACE_TREE) &&
 	    !btrfs_test_opt(info, CLEAR_CACHE)) {
-		btrfs_err(root->fs_info, "cannot disable free space tree");
+		btrfs_err(info, "cannot disable free space tree");
 		ret = -EINVAL;
 
 	}
 	if (!ret && btrfs_test_opt(info, SPACE_CACHE))
-		btrfs_info(root->fs_info, "disk space caching is enabled");
+		btrfs_info(info, "disk space caching is enabled");
 	if (!ret && btrfs_test_opt(info, FREE_SPACE_TREE))
-		btrfs_info(root->fs_info, "using free space tree");
+		btrfs_info(info, "using free space tree");
 	kfree(orig);
 	return ret;
 }
@@ -1223,7 +1213,6 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 {
 	struct btrfs_fs_info *info = btrfs_sb(dentry->d_sb);
-	struct btrfs_root *root = info->tree_root;
 	char *compress_type;
 
 	if (btrfs_test_opt(info, DEGRADED))
@@ -1265,7 +1254,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",flushoncommit");
 	if (btrfs_test_opt(info, DISCARD))
 		seq_puts(seq, ",discard");
-	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
+	if (!(info->sb->s_flags & MS_POSIXACL))
 		seq_puts(seq, ",noacl");
 	if (btrfs_test_opt(info, SPACE_CACHE))
 		seq_puts(seq, ",space_cache");
@@ -1788,7 +1777,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (ret)
 			goto restore;
 	} else {
-		if (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {
+		if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {
 			btrfs_err(fs_info,
 				"Remounting read-write after error is not allowed");
 			ret = -EINVAL;
@@ -2246,9 +2235,10 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 static int btrfs_freeze(struct super_block *sb)
 {
 	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = btrfs_sb(sb)->tree_root;
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
+	struct btrfs_root *root = fs_info->tree_root;
 
-	root->fs_info->fs_frozen = 1;
+	fs_info->fs_frozen = 1;
 	/*
 	 * We don't need a barrier here, we'll wait for any transaction that
 	 * could be in progress on other threads (and do delayed iputs that
@@ -2267,9 +2257,7 @@ static int btrfs_freeze(struct super_block *sb)
 
 static int btrfs_unfreeze(struct super_block *sb)
 {
-	struct btrfs_root *root = btrfs_sb(sb)->tree_root;
-
-	root->fs_info->fs_frozen = 0;
+	btrfs_sb(sb)->fs_frozen = 0;
 	return 0;
 }
 

commit da17066c40472c2d6a1aab7bb0090c3d285531c9
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 15 09:22:56 2016 -0400

    btrfs: pull node/sector/stripe sizes out of root and into fs_info
    
    We track the node sizes per-root, but they never vary from the values
    in the superblock.  This patch messes with the 80-column style a bit,
    but subsequent patches to factor out root->fs_info into a convenience
    variable fix it up again.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 457e05eac8cf..c91a51f1e8f2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -594,7 +594,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 				if (info->max_inline) {
 					info->max_inline = min_t(u64,
 						info->max_inline,
-						root->sectorsize);
+						root->fs_info->sectorsize);
 				}
 				btrfs_info(root->fs_info, "max_inline at %llu",
 					info->max_inline);

commit 6bccf3ab1e1f0913268bfcd1c09cadb1f4f2857d
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Jun 21 21:16:51 2016 -0400

    btrfs: call functions that always use the same root with fs_info instead
    
    There are many functions that are always called with the same root
    argument.  Rather than passing the same root every time, we can
    pass an fs_info pointer instead and have the function get the root
    pointer itself.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index adec3a0b01d5..457e05eac8cf 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -305,7 +305,7 @@ void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 
 static void btrfs_put_super(struct super_block *sb)
 {
-	close_ctree(btrfs_sb(sb)->tree_root);
+	close_ctree(btrfs_sb(sb));
 }
 
 enum {
@@ -1173,7 +1173,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	return 0;
 
 fail_close:
-	close_ctree(fs_info->tree_root);
+	close_ctree(fs_info);
 	return err;
 }
 
@@ -1784,7 +1784,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		btrfs_scrub_cancel(fs_info);
 		btrfs_pause_balance(fs_info);
 
-		ret = btrfs_commit_super(root);
+		ret = btrfs_commit_super(fs_info);
 		if (ret)
 			goto restore;
 	} else {
@@ -1901,9 +1901,10 @@ static inline void btrfs_descending_sort_devices(
  * The helper to calc the free space on the devices that can be used to store
  * file data.
  */
-static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
+static int btrfs_calc_avail_data_space(struct btrfs_fs_info *fs_info,
+				       u64 *free_bytes)
 {
-	struct btrfs_fs_info *fs_info = root->fs_info;
+	struct btrfs_root *root = fs_info->tree_root;
 	struct btrfs_device_info *devices_info;
 	struct btrfs_fs_devices *fs_devices = fs_info->fs_devices;
 	struct btrfs_device *device;
@@ -2137,7 +2138,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	spin_unlock(&block_rsv->lock);
 
 	buf->f_bavail = div_u64(total_free_data, factor);
-	ret = btrfs_calc_avail_data_space(fs_info->tree_root, &total_free_data);
+	ret = btrfs_calc_avail_data_space(fs_info, &total_free_data);
 	if (ret)
 		return ret;
 	buf->f_bavail += div_u64(total_free_data, factor);

commit 5d9dbe617a9e4e85c5fc9790c354cec903b88b57
Author: David Sterba <dsterba@suse.com>
Date:   Wed Oct 5 14:23:06 2016 +0200

    btrfs: remove stale comment from btrfs_statfs
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 74ed5aae6cea..adec3a0b01d5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2086,10 +2086,6 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	u64 thresh = 0;
 	int mixed = 0;
 
-	/*
-	 * holding chunk_mutex to avoid allocating new chunks, holding
-	 * device_list_mutex to avoid the device being removed
-	 */
 	rcu_read_lock();
 	list_for_each_entry_rcu(found, head, list) {
 		if (found->flags & BTRFS_BLOCK_GROUP_DATA) {

commit ab8d0fc48dba09e0a2b8b0dbfe144d4de9eb874f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Sep 20 10:05:02 2016 -0400

    btrfs: convert pr_* to btrfs_* where possible
    
    For many printks, we want to know which file system issued the message.
    
    This patch converts most pr_* calls to use the btrfs_* versions instead.
    In some cases, this means adding plumbing to allow call sites access to
    an fs_info pointer.
    
    fs/btrfs/check-integrity.c is left alone for another day.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0128bc369292..74ed5aae6cea 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1148,7 +1148,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_iflags |= SB_I_CGROUPWB;
 	err = open_ctree(sb, fs_devices, (char *)data);
 	if (err) {
-		pr_err("BTRFS: open_ctree failed\n");
+		btrfs_err(fs_info, "open_ctree failed");
 		return err;
 	}
 
@@ -1446,12 +1446,13 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 
 	if (!IS_ERR(root)) {
 		struct super_block *s = root->d_sb;
+		struct btrfs_fs_info *fs_info = btrfs_sb(s);
 		struct inode *root_inode = d_inode(root);
 		u64 root_objectid = BTRFS_I(root_inode)->root->root_key.objectid;
 
 		ret = 0;
 		if (!is_subvolume_inode(root_inode)) {
-			pr_err("BTRFS: '%s' is not a valid subvolume\n",
+			btrfs_err(fs_info, "'%s' is not a valid subvolume",
 			       subvol_name);
 			ret = -EINVAL;
 		}
@@ -1461,8 +1462,9 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 			 * subvolume which was passed by ID is renamed and
 			 * another subvolume is renamed over the old location.
 			 */
-			pr_err("BTRFS: subvol '%s' does not match subvolid %llu\n",
-			       subvol_name, subvol_objectid);
+			btrfs_err(fs_info,
+				  "subvol '%s' does not match subvolid %llu",
+				  subvol_name, subvol_objectid);
 			ret = -EINVAL;
 		}
 		if (ret) {

commit 62e855771dacf7c4d6daf9741642a965e7066d31
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Sep 20 10:05:01 2016 -0400

    btrfs: convert printk(KERN_* to use pr_* calls
    
    This patch converts printk(KERN_* style messages to use the pr_* versions.
    
    One side effect is that anything that was KERN_DEBUG is now automatically
    a dynamic debug message.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cb45749df9c4..0128bc369292 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -151,12 +151,11 @@ void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function
 		vaf.fmt = fmt;
 		vaf.va = &args;
 
-		printk(KERN_CRIT
-			"BTRFS: error (device %s) in %s:%d: errno=%d %s (%pV)\n",
+		pr_crit("BTRFS: error (device %s) in %s:%d: errno=%d %s (%pV)\n",
 			sb->s_id, function, line, errno, errstr, &vaf);
 		va_end(args);
 	} else {
-		printk(KERN_CRIT "BTRFS: error (device %s) in %s:%d: errno=%d %s\n",
+		pr_crit("BTRFS: error (device %s) in %s:%d: errno=%d %s\n",
 			sb->s_id, function, line, errno, errstr);
 	}
 #endif
@@ -925,8 +924,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 			}
 			break;
 		case Opt_subvolrootid:
-			printk(KERN_WARNING
-				"BTRFS: 'subvolrootid' mount option is deprecated and has no effect\n");
+			pr_warn("BTRFS: 'subvolrootid' mount option is deprecated and has no effect\n");
 			break;
 		case Opt_device:
 			device_name = match_strdup(&args[0]);
@@ -1150,7 +1148,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_iflags |= SB_I_CGROUPWB;
 	err = open_ctree(sb, fs_devices, (char *)data);
 	if (err) {
-		printk(KERN_ERR "BTRFS: open_ctree failed\n");
+		pr_err("BTRFS: open_ctree failed\n");
 		return err;
 	}
 
@@ -2356,7 +2354,7 @@ static void btrfs_interface_exit(void)
 
 static void btrfs_print_mod_info(void)
 {
-	printk(KERN_INFO "Btrfs loaded, crc32c=%s"
+	pr_info("Btrfs loaded, crc32c=%s"
 #ifdef CONFIG_BTRFS_DEBUG
 			", debug=on"
 #endif

commit 5d163e0e68ce743e1e919ddd3264c96ac02e9026
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Tue Sep 20 10:05:00 2016 -0400

    btrfs: unsplit printed strings
    
    CodingStyle chapter 2:
    "[...] never break user-visible strings such as printk messages,
    because that breaks the ability to grep for them."
    
    This patch unsplits user-visible strings.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 21f2b2d87f37..cb45749df9c4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -462,9 +462,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 		case Opt_datasum:
 			if (btrfs_test_opt(info, NODATASUM)) {
 				if (btrfs_test_opt(info, NODATACOW))
-					btrfs_info(root->fs_info, "setting datasum, datacow enabled");
+					btrfs_info(root->fs_info,
+						   "setting datasum, datacow enabled");
 				else
-					btrfs_info(root->fs_info, "setting datasum");
+					btrfs_info(root->fs_info,
+						   "setting datasum");
 			}
 			btrfs_clear_opt(info->mount_opt, NODATACOW);
 			btrfs_clear_opt(info->mount_opt, NODATASUM);
@@ -476,7 +478,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 					btrfs_info(root->fs_info,
 						   "setting nodatacow, compression disabled");
 				} else {
-					btrfs_info(root->fs_info, "setting nodatacow");
+					btrfs_info(root->fs_info,
+						   "setting nodatacow");
 				}
 			}
 			btrfs_clear_opt(info->mount_opt, COMPRESS);
@@ -608,8 +611,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 				info->alloc_start = memparse(num, NULL);
 				mutex_unlock(&info->chunk_mutex);
 				kfree(num);
-				btrfs_info(root->fs_info, "allocations start at %llu",
-					info->alloc_start);
+				btrfs_info(root->fs_info,
+					   "allocations start at %llu",
+					   info->alloc_start);
 			} else {
 				ret = -ENOMEM;
 				goto out;
@@ -762,8 +766,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 				goto out;
 			} else if (intarg >= 0) {
 				info->check_integrity_print_mask = intarg;
-				btrfs_info(root->fs_info, "check_integrity_print_mask 0x%x",
-				       info->check_integrity_print_mask);
+				btrfs_info(root->fs_info,
+					   "check_integrity_print_mask 0x%x",
+					   info->check_integrity_print_mask);
 			} else {
 				ret = -EINVAL;
 				goto out;
@@ -794,19 +799,22 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			intarg = 0;
 			ret = match_int(&args[0], &intarg);
 			if (ret < 0) {
-				btrfs_err(root->fs_info, "invalid commit interval");
+				btrfs_err(root->fs_info,
+					  "invalid commit interval");
 				ret = -EINVAL;
 				goto out;
 			}
 			if (intarg > 0) {
 				if (intarg > 300) {
-					btrfs_warn(root->fs_info, "excessive commit interval %d",
-							intarg);
+					btrfs_warn(root->fs_info,
+						"excessive commit interval %d",
+						intarg);
 				}
 				info->commit_interval = intarg;
 			} else {
-				btrfs_info(root->fs_info, "using default commit interval %ds",
-				    BTRFS_DEFAULT_COMMIT_INTERVAL);
+				btrfs_info(root->fs_info,
+					   "using default commit interval %ds",
+					   BTRFS_DEFAULT_COMMIT_INTERVAL);
 				info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;
 			}
 			break;
@@ -827,7 +835,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			break;
 #endif
 		case Opt_err:
-			btrfs_info(root->fs_info, "unrecognized mount option '%s'", p);
+			btrfs_info(root->fs_info,
+				   "unrecognized mount option '%s'", p);
 			ret = -EINVAL;
 			goto out;
 		default:
@@ -917,8 +926,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 			break;
 		case Opt_subvolrootid:
 			printk(KERN_WARNING
-				"BTRFS: 'subvolrootid' mount option is deprecated and has "
-				"no effect\n");
+				"BTRFS: 'subvolrootid' mount option is deprecated and has no effect\n");
 			break;
 		case Opt_device:
 			device_name = match_strdup(&args[0]);
@@ -1830,7 +1838,9 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 			btrfs_info(fs_info, "creating UUID tree");
 			ret = btrfs_create_uuid_tree(fs_info);
 			if (ret) {
-				btrfs_warn(fs_info, "failed to create the UUID tree %d", ret);
+				btrfs_warn(fs_info,
+					   "failed to create the UUID tree %d",
+					   ret);
 				goto restore;
 			}
 		}

commit afcdd129e05a9210a5d19d4aa6e0afa475fc49e2
Author: Josef Bacik <jbacik@fb.com>
Date:   Fri Sep 2 15:40:02 2016 -0400

    Btrfs: add a flags field to btrfs_fs_info
    
    We have a lot of random ints in btrfs_fs_info that can be put into flags.  This
    is mostly equivalent with the exception of how we deal with quota going on or
    off, now instead we set a flag when we are turning it on or off and deal with
    that appropriately, rather than just having a pending state that the current
    quota_enabled gets set to.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4071fe2bd098..21f2b2d87f37 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1836,7 +1836,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		}
 		sb->s_flags &= ~MS_RDONLY;
 
-		fs_info->open = 1;
+		set_bit(BTRFS_FS_OPEN, &fs_info->flags);
 	}
 out:
 	wake_up_process(fs_info->transaction_kthread);

commit 9e7cc91a6d18a4973c6d2cc104871439c9e94f3d
Author: Wang Xiaoguang <wangxg.fnst@cn.fujitsu.com>
Date:   Mon Aug 1 13:28:08 2016 +0800

    btrfs: fix fsfreeze hang caused by delayed iputs deal
    
    When running fstests generic/068, sometimes we got below deadlock:
      xfs_io          D ffff8800331dbb20     0  6697   6693 0x00000080
      ffff8800331dbb20 ffff88007acfc140 ffff880034d895c0 ffff8800331dc000
      ffff880032d243e8 fffffffeffffffff ffff880032d24400 0000000000000001
      ffff8800331dbb38 ffffffff816a9045 ffff880034d895c0 ffff8800331dbba8
      Call Trace:
      [<ffffffff816a9045>] schedule+0x35/0x80
      [<ffffffff816abab2>] rwsem_down_read_failed+0xf2/0x140
      [<ffffffff8118f5e1>] ? __filemap_fdatawrite_range+0xd1/0x100
      [<ffffffff8134f978>] call_rwsem_down_read_failed+0x18/0x30
      [<ffffffffa06631fc>] ? btrfs_alloc_block_rsv+0x2c/0xb0 [btrfs]
      [<ffffffff810d32b5>] percpu_down_read+0x35/0x50
      [<ffffffff81217dfc>] __sb_start_write+0x2c/0x40
      [<ffffffffa067f5d5>] start_transaction+0x2a5/0x4d0 [btrfs]
      [<ffffffffa067f857>] btrfs_join_transaction+0x17/0x20 [btrfs]
      [<ffffffffa068ba34>] btrfs_evict_inode+0x3c4/0x5d0 [btrfs]
      [<ffffffff81230a1a>] evict+0xba/0x1a0
      [<ffffffff812316b6>] iput+0x196/0x200
      [<ffffffffa06851d0>] btrfs_run_delayed_iputs+0x70/0xc0 [btrfs]
      [<ffffffffa067f1d8>] btrfs_commit_transaction+0x928/0xa80 [btrfs]
      [<ffffffffa0646df0>] btrfs_freeze+0x30/0x40 [btrfs]
      [<ffffffff81218040>] freeze_super+0xf0/0x190
      [<ffffffff81229275>] do_vfs_ioctl+0x4a5/0x5c0
      [<ffffffff81003176>] ? do_audit_syscall_entry+0x66/0x70
      [<ffffffff810038cf>] ? syscall_trace_enter_phase1+0x11f/0x140
      [<ffffffff81229409>] SyS_ioctl+0x79/0x90
      [<ffffffff81003c12>] do_syscall_64+0x62/0x110
      [<ffffffff816acbe1>] entry_SYSCALL64_slow_path+0x25/0x25
    
    >From this warning, freeze_super() already holds SB_FREEZE_FS, but
    btrfs_freeze() will call btrfs_commit_transaction() again, if
    btrfs_commit_transaction() finds that it has delayed iputs to handle,
    it'll start_transaction(), which will try to get SB_FREEZE_FS lock
    again, then deadlock occurs.
    
    The root cause is that in btrfs, sync_filesystem(sb) does not make
    sure all metadata is updated. There still maybe some codes adding
    delayed iputs, see below sample race window:
    
             CPU1                                  |         CPU2
    |-> freeze_super()                             |
        |-> sync_filesystem(sb);                   |
        |                                          |-> cleaner_kthread()
        |                                          |   |-> btrfs_delete_unused_bgs()
        |                                          |       |-> btrfs_remove_chunk()
        |                                          |           |-> btrfs_remove_block_group()
        |                                          |               |-> btrfs_add_delayed_iput()
        |                                          |
        |-> sb->s_writers.frozen = SB_FREEZE_FS;   |
        |-> sb_wait_write(sb, SB_FREEZE_FS);       |
        |   acquire SB_FREEZE_FS lock.             |
        |                                          |
        |-> btrfs_freeze()                         |
            |-> btrfs_commit_transaction()         |
                |-> btrfs_run_delayed_iputs()      |
                |   will handle delayed iputs,     |
                |   that means start_transaction() |
                |   will be called, which will try |
                |   to get SB_FREEZE_FS lock.      |
    
    To fix this issue, introduce a "int fs_frozen" to record internally whether
    fs has been frozen. If fs has been frozen, we can not handle delayed iputs.
    
    Signed-off-by: Wang Xiaoguang <wangxg.fnst@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ add comment to btrfs_freeze ]
    Signed-off-by: David Sterba <dsterba@suse.com>
    
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 864ce334f696..4071fe2bd098 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2241,6 +2241,13 @@ static int btrfs_freeze(struct super_block *sb)
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root = btrfs_sb(sb)->tree_root;
 
+	root->fs_info->fs_frozen = 1;
+	/*
+	 * We don't need a barrier here, we'll wait for any transaction that
+	 * could be in progress on other threads (and do delayed iputs that
+	 * we want to avoid on a frozen filesystem), or do the commit
+	 * ourselves.
+	 */
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {
 		/* no transaction, don't bother */
@@ -2251,6 +2258,14 @@ static int btrfs_freeze(struct super_block *sb)
 	return btrfs_commit_transaction(trans, root);
 }
 
+static int btrfs_unfreeze(struct super_block *sb)
+{
+	struct btrfs_root *root = btrfs_sb(sb)->tree_root;
+
+	root->fs_info->fs_frozen = 0;
+	return 0;
+}
+
 static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(root->d_sb);
@@ -2299,6 +2314,7 @@ static const struct super_operations btrfs_super_ops = {
 	.statfs		= btrfs_statfs,
 	.remount_fs	= btrfs_remount,
 	.freeze_fs	= btrfs_freeze,
+	.unfreeze_fs	= btrfs_unfreeze,
 };
 
 static const struct file_operations btrfs_ctl_fops = {

commit 66642832f06a4351e23cea6cf254967c227f8224
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Jun 10 18:19:25 2016 -0400

    btrfs: btrfs_abort_transaction, drop root parameter
    
    __btrfs_abort_transaction doesn't use its root parameter except to
    obtain an fs_info pointer.  We can obtain that from trans->root->fs_info
    for now and from trans->fs_info in a later patch.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 959823a12c42..864ce334f696 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -251,9 +251,11 @@ void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
  */
 __cold
 void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
-			       struct btrfs_root *root, const char *function,
+			       const char *function,
 			       unsigned int line, int errno)
 {
+	struct btrfs_fs_info *fs_info = trans->fs_info;
+
 	trans->aborted = errno;
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */
@@ -261,16 +263,16 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 		const char *errstr;
 
 		errstr = btrfs_decode_error(errno);
-		btrfs_warn(root->fs_info,
+		btrfs_warn(fs_info,
 		           "%s:%d: Aborting unused transaction(%s).",
 		           function, line, errstr);
 		return;
 	}
 	ACCESS_ONCE(trans->transaction->aborted) = errno;
 	/* Wake up anybody who may be waiting on this transaction */
-	wake_up(&root->fs_info->transaction_wait);
-	wake_up(&root->fs_info->transaction_blocked_wait);
-	__btrfs_handle_fs_error(root->fs_info, function, line, errno, NULL);
+	wake_up(&fs_info->transaction_wait);
+	wake_up(&fs_info->transaction_blocked_wait);
+	__btrfs_handle_fs_error(fs_info, function, line, errno, NULL);
 }
 /*
  * __btrfs_panic decodes unexpected, fatal errors from the caller,

commit 8632daae40c1a5b8fcc1d66d788c143353fd70b7
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Jun 20 13:16:40 2016 -0400

    btrfs: tests, move initialization into tests/
    
    We have all these stubs that only exist because they're called from
    btrfs_run_sanity_tests, which is a static inside super.c.  Let's just
    move it all into tests/btrfs-tests.c and only have one stub.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4a0c0aeb0041..959823a12c42 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2342,49 +2342,6 @@ static void btrfs_print_mod_info(void)
 			btrfs_crc32c_impl());
 }
 
-static int btrfs_run_sanity_tests(void)
-{
-	int ret, i;
-	u32 sectorsize, nodesize;
-	u32 test_sectorsize[] = {
-		PAGE_SIZE,
-	};
-	ret = btrfs_init_test_fs();
-	if (ret)
-		return ret;
-	for (i = 0; i < ARRAY_SIZE(test_sectorsize); i++) {
-		sectorsize = test_sectorsize[i];
-		for (nodesize = sectorsize;
-		     nodesize <= BTRFS_MAX_METADATA_BLOCKSIZE;
-		     nodesize <<= 1) {
-			pr_info("BTRFS: selftest: sectorsize: %u  nodesize: %u\n",
-				sectorsize, nodesize);
-			ret = btrfs_test_free_space_cache(sectorsize, nodesize);
-			if (ret)
-				goto out;
-			ret = btrfs_test_extent_buffer_operations(sectorsize,
-				nodesize);
-			if (ret)
-				goto out;
-			ret = btrfs_test_extent_io(sectorsize, nodesize);
-			if (ret)
-				goto out;
-			ret = btrfs_test_inodes(sectorsize, nodesize);
-			if (ret)
-				goto out;
-			ret = btrfs_test_qgroups(sectorsize, nodesize);
-			if (ret)
-				goto out;
-			ret = btrfs_test_free_space_tree(sectorsize, nodesize);
-			if (ret)
-				goto out;
-		}
-	}
-out:
-	btrfs_destroy_test_fs();
-	return ret;
-}
-
 static int __init init_btrfs_fs(void)
 {
 	int err;

commit 3cdde2240d4533ff71fbb8dc9c32d5d57d3cdeed
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Jun 9 21:38:35 2016 -0400

    btrfs: btrfs_test_opt and friends should take a btrfs_fs_info
    
    btrfs_test_opt and friends only use the root pointer to access
    the fs_info.  Let's pass the fs_info directly in preparation to
    eliminate similar patterns all over btrfs.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d965abbcac8e..4a0c0aeb0041 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -454,12 +454,12 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			 */
 			break;
 		case Opt_nodatasum:
-			btrfs_set_and_info(root, NODATASUM,
+			btrfs_set_and_info(info, NODATASUM,
 					   "setting nodatasum");
 			break;
 		case Opt_datasum:
-			if (btrfs_test_opt(root, NODATASUM)) {
-				if (btrfs_test_opt(root, NODATACOW))
+			if (btrfs_test_opt(info, NODATASUM)) {
+				if (btrfs_test_opt(info, NODATACOW))
 					btrfs_info(root->fs_info, "setting datasum, datacow enabled");
 				else
 					btrfs_info(root->fs_info, "setting datasum");
@@ -468,9 +468,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			btrfs_clear_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_nodatacow:
-			if (!btrfs_test_opt(root, NODATACOW)) {
-				if (!btrfs_test_opt(root, COMPRESS) ||
-				    !btrfs_test_opt(root, FORCE_COMPRESS)) {
+			if (!btrfs_test_opt(info, NODATACOW)) {
+				if (!btrfs_test_opt(info, COMPRESS) ||
+				    !btrfs_test_opt(info, FORCE_COMPRESS)) {
 					btrfs_info(root->fs_info,
 						   "setting nodatacow, compression disabled");
 				} else {
@@ -483,7 +483,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_datacow:
-			btrfs_clear_and_info(root, NODATACOW,
+			btrfs_clear_and_info(info, NODATACOW,
 					     "setting datacow");
 			break;
 		case Opt_compress_force:
@@ -492,10 +492,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			/* Fallthrough */
 		case Opt_compress:
 		case Opt_compress_type:
-			saved_compress_type = btrfs_test_opt(root, COMPRESS) ?
+			saved_compress_type = btrfs_test_opt(info,
+							     COMPRESS) ?
 				info->compress_type : BTRFS_COMPRESS_NONE;
 			saved_compress_force =
-				btrfs_test_opt(root, FORCE_COMPRESS);
+				btrfs_test_opt(info, FORCE_COMPRESS);
 			if (token == Opt_compress ||
 			    token == Opt_compress_force ||
 			    strcmp(args[0].from, "zlib") == 0) {
@@ -535,10 +536,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 				 */
 				btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
 			}
-			if ((btrfs_test_opt(root, COMPRESS) &&
+			if ((btrfs_test_opt(info, COMPRESS) &&
 			     (info->compress_type != saved_compress_type ||
 			      compress_force != saved_compress_force)) ||
-			    (!btrfs_test_opt(root, COMPRESS) &&
+			    (!btrfs_test_opt(info, COMPRESS) &&
 			     no_compress == 1)) {
 				btrfs_info(root->fs_info,
 					   "%s %s compression",
@@ -548,25 +549,25 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			compress_force = false;
 			break;
 		case Opt_ssd:
-			btrfs_set_and_info(root, SSD,
+			btrfs_set_and_info(info, SSD,
 					   "use ssd allocation scheme");
 			break;
 		case Opt_ssd_spread:
-			btrfs_set_and_info(root, SSD_SPREAD,
+			btrfs_set_and_info(info, SSD_SPREAD,
 					   "use spread ssd allocation scheme");
 			btrfs_set_opt(info->mount_opt, SSD);
 			break;
 		case Opt_nossd:
-			btrfs_set_and_info(root, NOSSD,
+			btrfs_set_and_info(info, NOSSD,
 					     "not using ssd allocation scheme");
 			btrfs_clear_opt(info->mount_opt, SSD);
 			break;
 		case Opt_barrier:
-			btrfs_clear_and_info(root, NOBARRIER,
+			btrfs_clear_and_info(info, NOBARRIER,
 					     "turning on barriers");
 			break;
 		case Opt_nobarrier:
-			btrfs_set_and_info(root, NOBARRIER,
+			btrfs_set_and_info(info, NOBARRIER,
 					   "turning off barriers");
 			break;
 		case Opt_thread_pool:
@@ -626,24 +627,24 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			root->fs_info->sb->s_flags &= ~MS_POSIXACL;
 			break;
 		case Opt_notreelog:
-			btrfs_set_and_info(root, NOTREELOG,
+			btrfs_set_and_info(info, NOTREELOG,
 					   "disabling tree log");
 			break;
 		case Opt_treelog:
-			btrfs_clear_and_info(root, NOTREELOG,
+			btrfs_clear_and_info(info, NOTREELOG,
 					     "enabling tree log");
 			break;
 		case Opt_norecovery:
 		case Opt_nologreplay:
-			btrfs_set_and_info(root, NOLOGREPLAY,
+			btrfs_set_and_info(info, NOLOGREPLAY,
 					   "disabling log replay at mount time");
 			break;
 		case Opt_flushoncommit:
-			btrfs_set_and_info(root, FLUSHONCOMMIT,
+			btrfs_set_and_info(info, FLUSHONCOMMIT,
 					   "turning on flush-on-commit");
 			break;
 		case Opt_noflushoncommit:
-			btrfs_clear_and_info(root, FLUSHONCOMMIT,
+			btrfs_clear_and_info(info, FLUSHONCOMMIT,
 					     "turning off flush-on-commit");
 			break;
 		case Opt_ratio:
@@ -660,11 +661,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			}
 			break;
 		case Opt_discard:
-			btrfs_set_and_info(root, DISCARD,
+			btrfs_set_and_info(info, DISCARD,
 					   "turning on discard");
 			break;
 		case Opt_nodiscard:
-			btrfs_clear_and_info(root, DISCARD,
+			btrfs_clear_and_info(info, DISCARD,
 					     "turning off discard");
 			break;
 		case Opt_space_cache:
@@ -673,12 +674,13 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			    strcmp(args[0].from, "v1") == 0) {
 				btrfs_clear_opt(root->fs_info->mount_opt,
 						FREE_SPACE_TREE);
-				btrfs_set_and_info(root, SPACE_CACHE,
+				btrfs_set_and_info(info, SPACE_CACHE,
 						   "enabling disk space caching");
 			} else if (strcmp(args[0].from, "v2") == 0) {
 				btrfs_clear_opt(root->fs_info->mount_opt,
 						SPACE_CACHE);
-				btrfs_set_and_info(root, FREE_SPACE_TREE,
+				btrfs_set_and_info(info,
+						   FREE_SPACE_TREE,
 						   "enabling free space tree");
 			} else {
 				ret = -EINVAL;
@@ -689,12 +691,14 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			btrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);
 			break;
 		case Opt_no_space_cache:
-			if (btrfs_test_opt(root, SPACE_CACHE)) {
-				btrfs_clear_and_info(root, SPACE_CACHE,
+			if (btrfs_test_opt(info, SPACE_CACHE)) {
+				btrfs_clear_and_info(info,
+						     SPACE_CACHE,
 						     "disabling disk space caching");
 			}
-			if (btrfs_test_opt(root, FREE_SPACE_TREE)) {
-				btrfs_clear_and_info(root, FREE_SPACE_TREE,
+			if (btrfs_test_opt(info, FREE_SPACE_TREE)) {
+				btrfs_clear_and_info(info,
+						     FREE_SPACE_TREE,
 						     "disabling free space tree");
 			}
 			break;
@@ -707,7 +711,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 					     "disabling inode map caching");
 			break;
 		case Opt_clear_cache:
-			btrfs_set_and_info(root, CLEAR_CACHE,
+			btrfs_set_and_info(info, CLEAR_CACHE,
 					   "force clearing of disk cache");
 			break;
 		case Opt_user_subvol_rm_allowed:
@@ -720,11 +724,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			btrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);
 			break;
 		case Opt_defrag:
-			btrfs_set_and_info(root, AUTO_DEFRAG,
+			btrfs_set_and_info(info, AUTO_DEFRAG,
 					   "enabling auto defrag");
 			break;
 		case Opt_nodefrag:
-			btrfs_clear_and_info(root, AUTO_DEFRAG,
+			btrfs_clear_and_info(info, AUTO_DEFRAG,
 					     "disabling auto defrag");
 			break;
 		case Opt_recovery:
@@ -832,22 +836,22 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 	/*
 	 * Extra check for current option against current flag
 	 */
-	if (btrfs_test_opt(root, NOLOGREPLAY) && !(new_flags & MS_RDONLY)) {
+	if (btrfs_test_opt(info, NOLOGREPLAY) && !(new_flags & MS_RDONLY)) {
 		btrfs_err(root->fs_info,
 			  "nologreplay must be used with ro mount option");
 		ret = -EINVAL;
 	}
 out:
 	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE) &&
-	    !btrfs_test_opt(root, FREE_SPACE_TREE) &&
-	    !btrfs_test_opt(root, CLEAR_CACHE)) {
+	    !btrfs_test_opt(info, FREE_SPACE_TREE) &&
+	    !btrfs_test_opt(info, CLEAR_CACHE)) {
 		btrfs_err(root->fs_info, "cannot disable free space tree");
 		ret = -EINVAL;
 
 	}
-	if (!ret && btrfs_test_opt(root, SPACE_CACHE))
+	if (!ret && btrfs_test_opt(info, SPACE_CACHE))
 		btrfs_info(root->fs_info, "disk space caching is enabled");
-	if (!ret && btrfs_test_opt(root, FREE_SPACE_TREE))
+	if (!ret && btrfs_test_opt(info, FREE_SPACE_TREE))
 		btrfs_info(root->fs_info, "using free space tree");
 	kfree(orig);
 	return ret;
@@ -1214,13 +1218,13 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 	struct btrfs_root *root = info->tree_root;
 	char *compress_type;
 
-	if (btrfs_test_opt(root, DEGRADED))
+	if (btrfs_test_opt(info, DEGRADED))
 		seq_puts(seq, ",degraded");
-	if (btrfs_test_opt(root, NODATASUM))
+	if (btrfs_test_opt(info, NODATASUM))
 		seq_puts(seq, ",nodatasum");
-	if (btrfs_test_opt(root, NODATACOW))
+	if (btrfs_test_opt(info, NODATACOW))
 		seq_puts(seq, ",nodatacow");
-	if (btrfs_test_opt(root, NOBARRIER))
+	if (btrfs_test_opt(info, NOBARRIER))
 		seq_puts(seq, ",nobarrier");
 	if (info->max_inline != BTRFS_DEFAULT_MAX_INLINE)
 		seq_printf(seq, ",max_inline=%llu", info->max_inline);
@@ -1229,56 +1233,56 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 	if (info->thread_pool_size !=  min_t(unsigned long,
 					     num_online_cpus() + 2, 8))
 		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);
-	if (btrfs_test_opt(root, COMPRESS)) {
+	if (btrfs_test_opt(info, COMPRESS)) {
 		if (info->compress_type == BTRFS_COMPRESS_ZLIB)
 			compress_type = "zlib";
 		else
 			compress_type = "lzo";
-		if (btrfs_test_opt(root, FORCE_COMPRESS))
+		if (btrfs_test_opt(info, FORCE_COMPRESS))
 			seq_printf(seq, ",compress-force=%s", compress_type);
 		else
 			seq_printf(seq, ",compress=%s", compress_type);
 	}
-	if (btrfs_test_opt(root, NOSSD))
+	if (btrfs_test_opt(info, NOSSD))
 		seq_puts(seq, ",nossd");
-	if (btrfs_test_opt(root, SSD_SPREAD))
+	if (btrfs_test_opt(info, SSD_SPREAD))
 		seq_puts(seq, ",ssd_spread");
-	else if (btrfs_test_opt(root, SSD))
+	else if (btrfs_test_opt(info, SSD))
 		seq_puts(seq, ",ssd");
-	if (btrfs_test_opt(root, NOTREELOG))
+	if (btrfs_test_opt(info, NOTREELOG))
 		seq_puts(seq, ",notreelog");
-	if (btrfs_test_opt(root, NOLOGREPLAY))
+	if (btrfs_test_opt(info, NOLOGREPLAY))
 		seq_puts(seq, ",nologreplay");
-	if (btrfs_test_opt(root, FLUSHONCOMMIT))
+	if (btrfs_test_opt(info, FLUSHONCOMMIT))
 		seq_puts(seq, ",flushoncommit");
-	if (btrfs_test_opt(root, DISCARD))
+	if (btrfs_test_opt(info, DISCARD))
 		seq_puts(seq, ",discard");
 	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
 		seq_puts(seq, ",noacl");
-	if (btrfs_test_opt(root, SPACE_CACHE))
+	if (btrfs_test_opt(info, SPACE_CACHE))
 		seq_puts(seq, ",space_cache");
-	else if (btrfs_test_opt(root, FREE_SPACE_TREE))
+	else if (btrfs_test_opt(info, FREE_SPACE_TREE))
 		seq_puts(seq, ",space_cache=v2");
 	else
 		seq_puts(seq, ",nospace_cache");
-	if (btrfs_test_opt(root, RESCAN_UUID_TREE))
+	if (btrfs_test_opt(info, RESCAN_UUID_TREE))
 		seq_puts(seq, ",rescan_uuid_tree");
-	if (btrfs_test_opt(root, CLEAR_CACHE))
+	if (btrfs_test_opt(info, CLEAR_CACHE))
 		seq_puts(seq, ",clear_cache");
-	if (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))
+	if (btrfs_test_opt(info, USER_SUBVOL_RM_ALLOWED))
 		seq_puts(seq, ",user_subvol_rm_allowed");
-	if (btrfs_test_opt(root, ENOSPC_DEBUG))
+	if (btrfs_test_opt(info, ENOSPC_DEBUG))
 		seq_puts(seq, ",enospc_debug");
-	if (btrfs_test_opt(root, AUTO_DEFRAG))
+	if (btrfs_test_opt(info, AUTO_DEFRAG))
 		seq_puts(seq, ",autodefrag");
-	if (btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (btrfs_test_opt(info, INODE_MAP_CACHE))
 		seq_puts(seq, ",inode_cache");
-	if (btrfs_test_opt(root, SKIP_BALANCE))
+	if (btrfs_test_opt(info, SKIP_BALANCE))
 		seq_puts(seq, ",skip_balance");
 #ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
-	if (btrfs_test_opt(root, CHECK_INTEGRITY_INCLUDING_EXTENT_DATA))
+	if (btrfs_test_opt(info, CHECK_INTEGRITY_INCLUDING_EXTENT_DATA))
 		seq_puts(seq, ",check_int_data");
-	else if (btrfs_test_opt(root, CHECK_INTEGRITY))
+	else if (btrfs_test_opt(info, CHECK_INTEGRITY))
 		seq_puts(seq, ",check_int");
 	if (info->check_integrity_print_mask)
 		seq_printf(seq, ",check_int_print_mask=%d",
@@ -1287,14 +1291,14 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 	if (info->metadata_ratio)
 		seq_printf(seq, ",metadata_ratio=%d",
 				info->metadata_ratio);
-	if (btrfs_test_opt(root, PANIC_ON_FATAL_ERROR))
+	if (btrfs_test_opt(info, PANIC_ON_FATAL_ERROR))
 		seq_puts(seq, ",fatal_errors=panic");
 	if (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)
 		seq_printf(seq, ",commit=%d", info->commit_interval);
 #ifdef CONFIG_BTRFS_DEBUG
-	if (btrfs_test_opt(root, FRAGMENT_DATA))
+	if (btrfs_test_opt(info, FRAGMENT_DATA))
 		seq_puts(seq, ",fragment=data");
-	if (btrfs_test_opt(root, FRAGMENT_METADATA))
+	if (btrfs_test_opt(info, FRAGMENT_METADATA))
 		seq_puts(seq, ",fragment=metadata");
 #endif
 	seq_printf(seq, ",subvolid=%llu",

commit bc074524e123ded281cde25ebc5661910f9679e3
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Jun 9 17:27:55 2016 -0400

    btrfs: prefix fsid to all trace events
    
    When using trace events to debug a problem, it's impossible to determine
    which file system generated a particular event.  This patch adds a
    macro to prefix standard information to the head of a trace event.
    
    The extent_state alloc/free events are all that's left without an
    fs_info available.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 208b15e7a171..d965abbcac8e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1171,7 +1171,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	struct btrfs_root *root = fs_info->tree_root;
 
-	trace_btrfs_sync_fs(wait);
+	trace_btrfs_sync_fs(fs_info, wait);
 
 	if (!wait) {
 		filemap_flush(fs_info->btree_inode->i_mapping);

commit 9f8d49095b86d3494ee184f6ede4a5b179d5dc5c
Author: David Sterba <dsterba@suse.com>
Date:   Fri Jul 15 15:31:56 2016 +0200

    btrfs: remove obsolete part of comment in statfs
    
    The mixed blockgroup reporting has been fixed by commit
    ae02d1bd070767e109f4a6f1bb1f466e9698a355
    "btrfs: fix mixed block count of available space"
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8766d560a48f..208b15e7a171 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2052,9 +2052,6 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
  * chunk).
  *
  * If metadata is exhausted, f_bavail will be 0.
- *
- * FIXME: not accurate for mixed block groups, total and free/used are ok,
- * available appears slightly larger.
  */
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {

commit 35f4e5e6f198a11c11606a742b309aa80271c66d
Author: Nikolay Borisov <kernel@kyup.com>
Date:   Wed Jul 13 16:19:15 2016 +0300

    btrfs: Add ratelimit to btrfs printing
    
    This patch adds ratelimiting to all messages which are not using the _rl
    version of the various printing APIs in btrfs. This is designed to be
    used as a safety net, since a flood messages might cause the softlockup
    detector to trigger. To reduce interference between different classes of
    messages use a separate ratelimit state for every class of message.
    
    Signed-off-by: Nikolay Borisov <kernel@kyup.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 60e7179ed4b7..8766d560a48f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -184,6 +184,22 @@ static const char * const logtypes[] = {
 	"debug",
 };
 
+
+/*
+ * Use one ratelimit state per log level so that a flood of less important
+ * messages doesn't cause more important ones to be dropped.
+ */
+static struct ratelimit_state printk_limits[] = {
+	RATELIMIT_STATE_INIT(printk_limits[0], DEFAULT_RATELIMIT_INTERVAL, 100),
+	RATELIMIT_STATE_INIT(printk_limits[1], DEFAULT_RATELIMIT_INTERVAL, 100),
+	RATELIMIT_STATE_INIT(printk_limits[2], DEFAULT_RATELIMIT_INTERVAL, 100),
+	RATELIMIT_STATE_INIT(printk_limits[3], DEFAULT_RATELIMIT_INTERVAL, 100),
+	RATELIMIT_STATE_INIT(printk_limits[4], DEFAULT_RATELIMIT_INTERVAL, 100),
+	RATELIMIT_STATE_INIT(printk_limits[5], DEFAULT_RATELIMIT_INTERVAL, 100),
+	RATELIMIT_STATE_INIT(printk_limits[6], DEFAULT_RATELIMIT_INTERVAL, 100),
+	RATELIMIT_STATE_INIT(printk_limits[7], DEFAULT_RATELIMIT_INTERVAL, 100),
+};
+
 void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 {
 	struct super_block *sb = fs_info->sb;
@@ -192,6 +208,7 @@ void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 	va_list args;
 	const char *type = logtypes[4];
 	int kern_level;
+	struct ratelimit_state *ratelimit;
 
 	va_start(args, fmt);
 
@@ -202,13 +219,18 @@ void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 		lvl[size] = '\0';
 		fmt += size;
 		type = logtypes[kern_level - '0'];
-	} else
+		ratelimit = &printk_limits[kern_level - '0'];
+	} else {
 		*lvl = '\0';
+		/* Default to debug output */
+		ratelimit = &printk_limits[7];
+	}
 
 	vaf.fmt = fmt;
 	vaf.va = &args;
 
-	printk("%sBTRFS %s (device %s): %pV\n", lvl, type, sb->s_id, &vaf);
+	if (__ratelimit(ratelimit))
+		printk("%sBTRFS %s (device %s): %pV\n", lvl, type, sb->s_id, &vaf);
 
 	va_end(args);
 }

commit 90c711ab380d633bf85249bd5d819edb601feda7
Author: Zygo Blaxell <ce3g8jdj@umail.furryterror.org>
Date:   Sun Jun 12 23:39:58 2016 -0400

    btrfs: avoid blocking open_ctree from cleaner_kthread
    
    This fixes a problem introduced in commit 2f3165ecf103599f82bf0ea254039db335fb5005
    "btrfs: don't force mounts to wait for cleaner_kthread to delete one or more subvolumes".
    
    open_ctree eventually calls btrfs_replay_log which in turn calls
    btrfs_commit_super which tries to lock the cleaner_mutex, causing a
    recursive mutex deadlock during mount.
    
    Instead of playing whack-a-mole trying to keep up with all the
    functions that may want to lock cleaner_mutex, put all the cleaner_mutex
    lockers back where they were, and attack the problem more directly:
    keep cleaner_kthread asleep until the filesystem is mounted.
    
    When filesystems are mounted read-only and later remounted read-write,
    open_ctree did not set fs_info->open and neither does anything else.
    Set this flag in btrfs_remount so that neither btrfs_delete_unused_bgs
    nor cleaner_kthread get confused by the common case of "/" filesystem
    read-only mount followed by read-write remount.
    
    Signed-off-by: Zygo Blaxell <ce3g8jdj@umail.furryterror.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index bf70d33b5791..60e7179ed4b7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1807,6 +1807,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 			}
 		}
 		sb->s_flags &= ~MS_RDONLY;
+
+		fs_info->open = 1;
 	}
 out:
 	wake_up_process(fs_info->transaction_kthread);

commit 64c12921e11b3a0c10d088606e328c58e29274d8
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 8 00:36:38 2016 -0400

    btrfs: account for non-CoW'd blocks in btrfs_abort_transaction
    
    The test for !trans->blocks_used in btrfs_abort_transaction is
    insufficient to determine whether it's safe to drop the transaction
    handle on the floor.  btrfs_cow_block, informed by should_cow_block,
    can return blocks that have already been CoW'd in the current
    transaction.  trans->blocks_used is only incremented for new block
    allocations. If an operation overlaps the blocks in the current
    transaction entirely and must abort the transaction, we'll happily
    let it clean up the trans handle even though it may have modified
    the blocks and will commit an incomplete operation.
    
    In the long-term, I'd like to do closer tracking of when the fs
    is actually modified so we can still recover as gracefully as possible,
    but that approach will need some discussion.  In the short term,
    since this is the only code using trans->blocks_used, let's just
    switch it to a bool indicating whether any blocks were used and set
    it when should_cow_block returns false.
    
    Cc: stable@vger.kernel.org # 3.4+
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4339b6613f19..bf70d33b5791 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -235,7 +235,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 	trans->aborted = errno;
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */
-	if (!trans->blocks_used && list_empty(&trans->new_bgs)) {
+	if (!trans->dirty && list_empty(&trans->new_bgs)) {
 		const char *errstr;
 
 		errstr = btrfs_decode_error(errno);

commit 719da39a61173c849f70656ed1a302e4b6deaa5b
Merge: 4c52990080e3 5f9e1059d934
Author: Chris Mason <clm@fb.com>
Date:   Wed Jun 8 14:36:12 2016 -0700

    Merge branch 'misc-fixes-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.7

commit d94f43b4c6b88b9393422868d8dfde14c5923858
Author: Feifei Xu <xufeifei@linux.vnet.ibm.com>
Date:   Wed Jun 1 19:18:27 2016 +0800

    Btrfs: self-tests: Support testing all possible sectorsizes and nodesizes
    
    To test all possible sectorsizes, this commit adds a sectorsize
    array. This commit executes the tests for all possible sectorsizes and
    nodesizes.
    
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: Feifei Xu <xufeifei@linux.vnet.ibm.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5b0b354ca594..c49d7ae69617 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2318,32 +2318,42 @@ static void btrfs_print_mod_info(void)
 
 static int btrfs_run_sanity_tests(void)
 {
-	int ret;
+	int ret, i;
 	u32 sectorsize, nodesize;
-
-	sectorsize = PAGE_SIZE;
-	nodesize = PAGE_SIZE;
+	u32 test_sectorsize[] = {
+		PAGE_SIZE,
+	};
 	ret = btrfs_init_test_fs();
 	if (ret)
 		return ret;
-
-	ret = btrfs_test_free_space_cache(sectorsize, nodesize);
-	if (ret)
-		goto out;
-	ret = btrfs_test_extent_buffer_operations(sectorsize,
-		nodesize);
-	if (ret)
-		goto out;
-	ret = btrfs_test_extent_io(sectorsize, nodesize);
-	if (ret)
-		goto out;
-	ret = btrfs_test_inodes(sectorsize, nodesize);
-	if (ret)
-		goto out;
-	ret = btrfs_test_qgroups(sectorsize, nodesize);
-	if (ret)
-		goto out;
-	ret = btrfs_test_free_space_tree(sectorsize, nodesize);
+	for (i = 0; i < ARRAY_SIZE(test_sectorsize); i++) {
+		sectorsize = test_sectorsize[i];
+		for (nodesize = sectorsize;
+		     nodesize <= BTRFS_MAX_METADATA_BLOCKSIZE;
+		     nodesize <<= 1) {
+			pr_info("BTRFS: selftest: sectorsize: %u  nodesize: %u\n",
+				sectorsize, nodesize);
+			ret = btrfs_test_free_space_cache(sectorsize, nodesize);
+			if (ret)
+				goto out;
+			ret = btrfs_test_extent_buffer_operations(sectorsize,
+				nodesize);
+			if (ret)
+				goto out;
+			ret = btrfs_test_extent_io(sectorsize, nodesize);
+			if (ret)
+				goto out;
+			ret = btrfs_test_inodes(sectorsize, nodesize);
+			if (ret)
+				goto out;
+			ret = btrfs_test_qgroups(sectorsize, nodesize);
+			if (ret)
+				goto out;
+			ret = btrfs_test_free_space_tree(sectorsize, nodesize);
+			if (ret)
+				goto out;
+		}
+	}
 out:
 	btrfs_destroy_test_fs();
 	return ret;

commit 5f9e1059d9347191b271bf7d13bd83db57594d2a
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Sep 16 15:34:53 2015 +0200

    btrfs: advertise which crc32c implementation is being used at module load
    
    Since several architectures support hardware-accelerated crc32c
    calculation, it would be nice to confirm that btrfs is actually using it.
    
    We can see an elevated use count for the module, but it doesn't actually
    show who the users are.  This patch simply prints the name of the driver
    after successfully initializing the shash.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    [ added a helper and used in module load-time message ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4e59a91a11e0..4397a303fc6c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2303,7 +2303,7 @@ static void btrfs_interface_exit(void)
 
 static void btrfs_print_mod_info(void)
 {
-	printk(KERN_INFO "Btrfs loaded"
+	printk(KERN_INFO "Btrfs loaded, crc32c=%s"
 #ifdef CONFIG_BTRFS_DEBUG
 			", debug=on"
 #endif
@@ -2313,7 +2313,8 @@ static void btrfs_print_mod_info(void)
 #ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
 			", integrity-checker=on"
 #endif
-			"\n");
+			"\n",
+			btrfs_crc32c_impl());
 }
 
 static int btrfs_run_sanity_tests(void)

commit b9ef22dedde08ab1b4ccd5f53344984c4dcb89f4
Author: Feifei Xu <xufeifei@linux.vnet.ibm.com>
Date:   Wed Jun 1 19:18:25 2016 +0800

    Btrfs: self-tests: Support non-4k page size
    
    self-tests code assumes 4k as the sectorsize and nodesize. This commit
    fix hardcoded 4K. Enables the self-tests code to be executed on non-4k
    page sized systems (e.g. ppc64).
    
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Feifei Xu <xufeifei@linux.vnet.ibm.com>
    Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4e59a91a11e0..5b0b354ca594 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2319,27 +2319,31 @@ static void btrfs_print_mod_info(void)
 static int btrfs_run_sanity_tests(void)
 {
 	int ret;
+	u32 sectorsize, nodesize;
 
+	sectorsize = PAGE_SIZE;
+	nodesize = PAGE_SIZE;
 	ret = btrfs_init_test_fs();
 	if (ret)
 		return ret;
 
-	ret = btrfs_test_free_space_cache();
+	ret = btrfs_test_free_space_cache(sectorsize, nodesize);
 	if (ret)
 		goto out;
-	ret = btrfs_test_extent_buffer_operations();
+	ret = btrfs_test_extent_buffer_operations(sectorsize,
+		nodesize);
 	if (ret)
 		goto out;
-	ret = btrfs_test_extent_io();
+	ret = btrfs_test_extent_io(sectorsize, nodesize);
 	if (ret)
 		goto out;
-	ret = btrfs_test_inodes();
+	ret = btrfs_test_inodes(sectorsize, nodesize);
 	if (ret)
 		goto out;
-	ret = btrfs_test_qgroups();
+	ret = btrfs_test_qgroups(sectorsize, nodesize);
 	if (ret)
 		goto out;
-	ret = btrfs_test_free_space_tree();
+	ret = btrfs_test_free_space_tree(sectorsize, nodesize);
 out:
 	btrfs_destroy_test_fs();
 	return ret;

commit 42f31734eb7658fd01fb186d56312be869450a42
Merge: e73440868fde 0132761017e0
Author: David Sterba <dsterba@suse.com>
Date:   Wed May 25 22:51:03 2016 +0200

    Merge branch 'cleanups-4.7' into for-chris-4.7-20160525

commit 0132761017e012ab4dc8584d679503f2ba26ca86
Author: Nicholas D Steeves <nsteeves@gmail.com>
Date:   Thu May 19 21:18:45 2016 -0400

    btrfs: fix string and comment grammatical issues and typos
    
    Signed-off-by: Nicholas D Steeves <nsteeves@gmail.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 00b8f37cc306..01ef1865db63 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -121,7 +121,7 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 		 * Note that a running device replace operation is not
 		 * canceled here although there is no way to update
 		 * the progress. It would add the risk of a deadlock,
-		 * therefore the canceling is ommited. The only penalty
+		 * therefore the canceling is omitted. The only penalty
 		 * is that some I/O remains active until the procedure
 		 * completes. The next time when the filesystem is
 		 * mounted writeable again, the device replace
@@ -1881,7 +1881,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	int ret;
 
 	/*
-	 * We aren't under the device list lock, so this is racey-ish, but good
+	 * We aren't under the device list lock, so this is racy-ish, but good
 	 * enough for our purposes.
 	 */
 	nr_devices = fs_info->fs_devices->open_devices;
@@ -1900,7 +1900,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	if (!devices_info)
 		return -ENOMEM;
 
-	/* calc min stripe number for data space alloction */
+	/* calc min stripe number for data space allocation */
 	type = btrfs_get_alloc_profile(root, 1);
 	if (type & BTRFS_BLOCK_GROUP_RAID0) {
 		min_stripes = 2;
@@ -1936,7 +1936,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 		avail_space *= BTRFS_STRIPE_LEN;
 
 		/*
-		 * In order to avoid overwritting the superblock on the drive,
+		 * In order to avoid overwriting the superblock on the drive,
 		 * btrfs starts at an offset of at least 1MB when doing chunk
 		 * allocation.
 		 */

commit c315ef8d9db7f1a0ebd023a395ebdfde1c68057e
Merge: a88336d13c66 5f9a8a51d8b9
Author: Chris Mason <clm@fb.com>
Date:   Tue May 17 14:43:19 2016 -0700

    Merge branch 'for-chris-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/fdmanana/linux into for-linus-4.7
    
    Signed-off-by: Chris Mason <clm@fb.com>

commit 5ef64a3e757c94b2f2fc61465ef9603aaacaecff
Merge: 73d32ce21e17 e1860a772482
Author: David Sterba <dsterba@suse.com>
Date:   Mon May 16 15:46:24 2016 +0200

    Merge branch 'cleanups-4.7' into for-chris-4.7-20160516

commit 578def7c50f236432ba140d35bb7ca4ef0a1b20b
Author: Filipe Manana <fdmanana@suse.com>
Date:   Tue Apr 26 15:36:38 2016 +0100

    Btrfs: don't wait for unrelated IO to finish before relocation
    
    Before the relocation process of a block group starts, it sets the block
    group to readonly mode, then flushes all delalloc writes and then finally
    it waits for all ordered extents to complete. This last step includes
    waiting for ordered extents destinated at extents allocated in other block
    groups, making us waste unecessary time.
    
    So improve this by waiting only for ordered extents that fall into the
    block group's range.
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 00b8f37cc306..89d134794d47 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1160,7 +1160,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_wait_ordered_roots(fs_info, -1);
+	btrfs_wait_ordered_roots(fs_info, -1, 0, (u64)-1);
 
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {

commit 41b34accb265e3a20211a7a8ef3625678f1c6ec7
Author: Luis de Bethencourt <luisbg@osg.samsung.com>
Date:   Wed Mar 30 23:18:14 2016 +0100

    btrfs: avoid overflowing f_bfree
    
    Since mixed block groups accounting isn't byte-accurate and f_bree is an
    unsigned integer, it could overflow. Avoid this.
    
    Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
    Suggested-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index bdca79ce45f1..fe03efb5bec0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2100,7 +2100,11 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 	/* Account global block reserve as used, it's in logical size already */
 	spin_lock(&block_rsv->lock);
-	buf->f_bfree -= block_rsv->size >> bits;
+	/* Mixed block groups accounting is not byte-accurate, avoid overflow */
+	if (buf->f_bfree >= block_rsv->size >> bits)
+		buf->f_bfree -= block_rsv->size >> bits;
+	else
+		buf->f_bfree = 0;
 	spin_unlock(&block_rsv->lock);
 
 	buf->f_bavail = div_u64(total_free_data, factor);

commit ae02d1bd070767e109f4a6f1bb1f466e9698a355
Author: Luis de Bethencourt <luisbg@osg.samsung.com>
Date:   Wed Mar 30 21:53:38 2016 +0100

    btrfs: fix mixed block count of available space
    
    Metadata for mixed block is already accounted in total data and should not
    be counted as part of the free metadata space.
    
    Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=114281
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 00b8f37cc306..bdca79ce45f1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2051,6 +2051,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;
 	int ret;
 	u64 thresh = 0;
+	int mixed = 0;
 
 	/*
 	 * holding chunk_muext to avoid allocating new chunks, holding
@@ -2076,8 +2077,17 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 				}
 			}
 		}
-		if (found->flags & BTRFS_BLOCK_GROUP_METADATA)
-			total_free_meta += found->disk_total - found->disk_used;
+
+		/*
+		 * Metadata in mixed block goup profiles are accounted in data
+		 */
+		if (!mixed && found->flags & BTRFS_BLOCK_GROUP_METADATA) {
+			if (found->flags & BTRFS_BLOCK_GROUP_DATA)
+				mixed = 1;
+			else
+				total_free_meta += found->disk_total -
+					found->disk_used;
+		}
 
 		total_used += found->disk_used;
 	}
@@ -2115,7 +2125,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	 */
 	thresh = 4 * 1024 * 1024;
 
-	if (total_free_meta - thresh < block_rsv->size)
+	if (!mixed && total_free_meta - thresh < block_rsv->size)
 		buf->f_bavail = 0;
 
 	buf->f_type = BTRFS_SUPER_MAGIC;

commit 180e4d4700b1b7bfdffd9e58ae95220ae9482d17
Author: Luis de Bethencourt <luisbg@osg.samsung.com>
Date:   Mon Apr 4 15:31:22 2016 +0100

    btrfs: fix typos in comments
    
    Correct a typo in the chunk_mutex name to make it grepable.
    
    Since it is better to fix several typos at once, fixing the 2 more in the
    same file.
    
    Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index dab51118b972..957976d9d627 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1484,10 +1484,10 @@ static int setup_security_options(struct btrfs_fs_info *fs_info,
 		memcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));
 	} else {
 		/*
-		 * Since SELinux(the only one supports security_mnt_opts) does
-		 * NOT support changing context during remount/mount same sb,
-		 * This must be the same or part of the same security options,
-		 * just free it.
+		 * Since SELinux (the only one supporting security_mnt_opts)
+		 * does NOT support changing context during remount/mount of
+		 * the same sb, this must be the same or part of the same
+		 * security options, just free it.
 		 */
 		security_free_mnt_opts(sec_opts);
 	}
@@ -1665,8 +1665,8 @@ static inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,
 					 unsigned long old_opts)
 {
 	/*
-	 * We need cleanup all defragable inodes if the autodefragment is
-	 * close or the fs is R/O.
+	 * We need to cleanup all defragable inodes if the autodefragment is
+	 * close or the filesystem is read only.
 	 */
 	if (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&
 	    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||
@@ -2049,7 +2049,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	u64 thresh = 0;
 
 	/*
-	 * holding chunk_muext to avoid allocating new chunks, holding
+	 * holding chunk_mutex to avoid allocating new chunks, holding
 	 * device_list_mutex to avoid the device being removed
 	 */
 	rcu_read_lock();

commit 0713d90c75745dc6148f6346d490e9ef63a4e8b4
Author: Anand Jain <anand.jain@oracle.com>
Date:   Thu Mar 17 10:38:57 2016 +0800

    btrfs: remove save_error_info()
    
    Actually save_error_info() sets the FS state to error and nothing else.
    Further the word save doesn't induce caffeine when compared to the word
    set in what actually it does.
    
    So to make it better understandable move save_error_info() code to its
    only consumer itself.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cc077887bd9d..dab51118b972 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -97,15 +97,6 @@ const char *btrfs_decode_error(int errno)
 	return errstr;
 }
 
-static void save_error_info(struct btrfs_fs_info *fs_info)
-{
-	/*
-	 * today we only save the error info into ram.  Long term we'll
-	 * also send it down to the disk
-	 */
-	set_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);
-}
-
 /* btrfs handle error by forcing the filesystem readonly */
 static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 {
@@ -170,8 +161,13 @@ void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function
 	}
 #endif
 
+	/*
+	 * Today we only save the error info to memory.  Long term we'll
+	 * also send it down to the disk
+	 */
+	set_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);
+
 	/* Don't go through full error handling during mount */
-	save_error_info(fs_info);
 	if (sb->s_flags & MS_BORN)
 		btrfs_handle_error(fs_info);
 }

commit 34d9700702f4042ce10d68a092ab7f79575e7a3b
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Mar 16 16:43:06 2016 +0800

    btrfs: rename btrfs_std_error to btrfs_handle_fs_error
    
    btrfs_std_error() handles errors, puts FS into readonly mode
    (as of now). So its good idea to rename it to btrfs_handle_fs_error().
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ edit changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 00b8f37cc306..cc077887bd9d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -131,11 +131,11 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 }
 
 /*
- * __btrfs_std_error decodes expected errors from the caller and
+ * __btrfs_handle_fs_error decodes expected errors from the caller and
  * invokes the approciate error response.
  */
 __cold
-void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
+void __btrfs_handle_fs_error(struct btrfs_fs_info *fs_info, const char *function,
 		       unsigned int line, int errno, const char *fmt, ...)
 {
 	struct super_block *sb = fs_info->sb;
@@ -252,7 +252,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 	/* Wake up anybody who may be waiting on this transaction */
 	wake_up(&root->fs_info->transaction_wait);
 	wake_up(&root->fs_info->transaction_blocked_wait);
-	__btrfs_std_error(root->fs_info, function, line, errno, NULL);
+	__btrfs_handle_fs_error(root->fs_info, function, line, errno, NULL);
 }
 /*
  * __btrfs_panic decodes unexpected, fatal errors from the caller,

commit 8ae1af3cd127d507dcb1acf67f16120f20632aed
Author: Anand Jain <anand.jain@oracle.com>
Date:   Thu Mar 10 12:49:14 2016 +0800

    btrfs: rename btrfs_print_info to btrfs_print_mod_info
    
    So that it indicates what it does.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a958f625793b..00b8f37cc306 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2291,7 +2291,7 @@ static void btrfs_interface_exit(void)
 	misc_deregister(&btrfs_misc);
 }
 
-static void btrfs_print_info(void)
+static void btrfs_print_mod_info(void)
 {
 	printk(KERN_INFO "Btrfs loaded"
 #ifdef CONFIG_BTRFS_DEBUG
@@ -2393,7 +2393,7 @@ static int __init init_btrfs_fs(void)
 
 	btrfs_init_lockdep();
 
-	btrfs_print_info();
+	btrfs_print_mod_info();
 
 	err = btrfs_run_sanity_tests();
 	if (err)

commit f5bc27c71a1b0741cb93dbec0f216b012b21d93f
Merge: fa695b01bcea d5131b658c2e
Author: David Sterba <dsterba@suse.com>
Date:   Fri Feb 26 15:38:34 2016 +0100

    Merge branch 'dev/control-ioctl' into for-chris-4.6

commit d5131b658c2e906da11603da5d3cb4c3a445331d
Author: David Sterba <dsterba@suse.com>
Date:   Wed Feb 17 15:26:27 2016 +0100

    btrfs: drop unused argument in btrfs_ioctl_get_supported_features
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index dda6f64dfd73..737e6a85c71e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2164,8 +2164,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 		ret = !(fs_devices->num_devices == fs_devices->total_devices);
 		break;
 	case BTRFS_IOC_GET_SUPPORTED_FEATURES:
-		ret = btrfs_ioctl_get_supported_features(NULL,
-				(void __user*)arg);
+		ret = btrfs_ioctl_get_supported_features((void __user*)arg);
 		break;
 	}
 

commit c5868f8362f5620302c66848d400368f8d4b45f8
Author: David Sterba <dsterba@suse.com>
Date:   Wed Feb 17 15:24:14 2016 +0100

    btrfs: add GET_SUPPORTED_FEATURES to the control device ioctls
    
    The control device is accessible when no filesystem is mounted and we
    may want to query features supported by the module. This is already
    possible using the sysfs files, this ioctl is for parity and
    convenience.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d41e09fe8e38..dda6f64dfd73 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2163,6 +2163,10 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 			break;
 		ret = !(fs_devices->num_devices == fs_devices->total_devices);
 		break;
+	case BTRFS_IOC_GET_SUPPORTED_FEATURES:
+		ret = btrfs_ioctl_get_supported_features(NULL,
+				(void __user*)arg);
+		break;
 	}
 
 	kfree(vol);

commit fed8f166ebf3afb8b91a1fd73d706788e07a91ef
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Tue Jan 19 10:23:04 2016 +0800

    btrfs: Introduce new mount option alias for nologreplay
    
    Introduce new mount option alias "norecovery" for nologreplay, to keep
    "norecovery" behavior the same with other filesystems.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e8a7a9f88195..bf75200c6f86 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -304,7 +304,7 @@ enum {
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
 	Opt_datasum, Opt_treelog, Opt_noinode_cache, Opt_usebackuproot,
-	Opt_nologreplay,
+	Opt_nologreplay, Opt_norecovery,
 #ifdef CONFIG_BTRFS_DEBUG
 	Opt_fragment_data, Opt_fragment_metadata, Opt_fragment_all,
 #endif
@@ -337,6 +337,7 @@ static const match_table_t tokens = {
 	{Opt_notreelog, "notreelog"},
 	{Opt_treelog, "treelog"},
 	{Opt_nologreplay, "nologreplay"},
+	{Opt_norecovery, "norecovery"},
 	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_noflushoncommit, "noflushoncommit"},
 	{Opt_ratio, "metadata_ratio=%d"},
@@ -614,6 +615,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options,
 			btrfs_clear_and_info(root, NOTREELOG,
 					     "enabling tree log");
 			break;
+		case Opt_norecovery:
 		case Opt_nologreplay:
 			btrfs_set_and_info(root, NOLOGREPLAY,
 					   "disabling log replay at mount time");

commit 96da09192cda57a356467bd7c91a3641a2e78490
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Tue Jan 19 10:23:03 2016 +0800

    btrfs: Introduce new mount option to disable tree log replay
    
    Introduce a new mount option "nologreplay" to co-operate with "ro" mount
    option to get real readonly mount, like "norecovery" in ext* and xfs.
    
    Since the new parse_options() need to check new flags at remount time,
    so add a new parameter for parse_options().
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Tested-by: Austin S. Hemmelgarn <ahferroin7@gmail.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7ed3863c264b..e8a7a9f88195 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -304,6 +304,7 @@ enum {
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
 	Opt_datasum, Opt_treelog, Opt_noinode_cache, Opt_usebackuproot,
+	Opt_nologreplay,
 #ifdef CONFIG_BTRFS_DEBUG
 	Opt_fragment_data, Opt_fragment_metadata, Opt_fragment_all,
 #endif
@@ -335,6 +336,7 @@ static const match_table_t tokens = {
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
 	{Opt_treelog, "treelog"},
+	{Opt_nologreplay, "nologreplay"},
 	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_noflushoncommit, "noflushoncommit"},
 	{Opt_ratio, "metadata_ratio=%d"},
@@ -374,7 +376,8 @@ static const match_table_t tokens = {
  * reading in a new superblock is parsed here.
  * XXX JDM: This needs to be cleaned up for remount.
  */
-int btrfs_parse_options(struct btrfs_root *root, char *options)
+int btrfs_parse_options(struct btrfs_root *root, char *options,
+			unsigned long new_flags)
 {
 	struct btrfs_fs_info *info = root->fs_info;
 	substring_t args[MAX_OPT_ARGS];
@@ -394,8 +397,12 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	else if (cache_gen)
 		btrfs_set_opt(info->mount_opt, SPACE_CACHE);
 
+	/*
+	 * Even the options are empty, we still need to do extra check
+	 * against new flags
+	 */
 	if (!options)
-		goto out;
+		goto check;
 
 	/*
 	 * strsep changes the string, duplicate it because parse_options
@@ -607,6 +614,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_clear_and_info(root, NOTREELOG,
 					     "enabling tree log");
 			break;
+		case Opt_nologreplay:
+			btrfs_set_and_info(root, NOLOGREPLAY,
+					   "disabling log replay at mount time");
+			break;
 		case Opt_flushoncommit:
 			btrfs_set_and_info(root, FLUSHONCOMMIT,
 					   "turning on flush-on-commit");
@@ -797,6 +808,15 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			break;
 		}
 	}
+check:
+	/*
+	 * Extra check for current option against current flag
+	 */
+	if (btrfs_test_opt(root, NOLOGREPLAY) && !(new_flags & MS_RDONLY)) {
+		btrfs_err(root->fs_info,
+			  "nologreplay must be used with ro mount option");
+		ret = -EINVAL;
+	}
 out:
 	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE) &&
 	    !btrfs_test_opt(root, FREE_SPACE_TREE) &&
@@ -1207,6 +1227,8 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",ssd");
 	if (btrfs_test_opt(root, NOTREELOG))
 		seq_puts(seq, ",notreelog");
+	if (btrfs_test_opt(root, NOLOGREPLAY))
+		seq_puts(seq, ",nologreplay");
 	if (btrfs_test_opt(root, FLUSHONCOMMIT))
 		seq_puts(seq, ",flushoncommit");
 	if (btrfs_test_opt(root, DISCARD))
@@ -1688,7 +1710,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		}
 	}
 
-	ret = btrfs_parse_options(root, data);
+	ret = btrfs_parse_options(root, data, *flags);
 	if (ret) {
 		ret = -EINVAL;
 		goto restore;

commit 8dcddfa048de637c8bbfa20ffd22757aeab7c604
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Tue Jan 19 10:23:02 2016 +0800

    btrfs: Introduce new mount option usebackuproot to replace recovery
    
    Current "recovery" mount option will only try to use backup root.
    However the word "recovery" is too generic and may be confusing for some
    users.
    
    Here introduce a new and more specific mount option, "usebackuproot" to
    replace "recovery" mount option.
    "Recovery" will be kept for compatibility reason, but will be
    deprecated.
    
    Also, since "usebackuproot" will only affect mount behavior and after
    open_ctree() it has nothing to do with the filesystem, so clear the flag
    after mount succeeded.
    
    This provides the basis for later unified "norecovery" mount option.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    [ dropped usebackuproot from show_mount, added note about 'recovery' to
      docs ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d41e09fe8e38..7ed3863c264b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -303,7 +303,7 @@ enum {
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
-	Opt_datasum, Opt_treelog, Opt_noinode_cache,
+	Opt_datasum, Opt_treelog, Opt_noinode_cache, Opt_usebackuproot,
 #ifdef CONFIG_BTRFS_DEBUG
 	Opt_fragment_data, Opt_fragment_metadata, Opt_fragment_all,
 #endif
@@ -352,7 +352,8 @@ static const match_table_t tokens = {
 	{Opt_inode_cache, "inode_cache"},
 	{Opt_noinode_cache, "noinode_cache"},
 	{Opt_no_space_cache, "nospace_cache"},
-	{Opt_recovery, "recovery"},
+	{Opt_recovery, "recovery"}, /* deprecated */
+	{Opt_usebackuproot, "usebackuproot"},
 	{Opt_skip_balance, "skip_balance"},
 	{Opt_check_integrity, "check_int"},
 	{Opt_check_integrity_including_extent_data, "check_int_data"},
@@ -696,8 +697,12 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 					     "disabling auto defrag");
 			break;
 		case Opt_recovery:
-			btrfs_info(root->fs_info, "enabling auto recovery");
-			btrfs_set_opt(info->mount_opt, RECOVERY);
+			btrfs_warn(root->fs_info,
+				   "'recovery' is deprecated, use 'usebackuproot' instead");
+		case Opt_usebackuproot:
+			btrfs_info(root->fs_info,
+				   "trying to use backup root at mount time");
+			btrfs_set_opt(info->mount_opt, USEBACKUPROOT);
 			break;
 		case Opt_skip_balance:
 			btrfs_set_opt(info->mount_opt, SKIP_BALANCE);
@@ -1228,8 +1233,6 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",inode_cache");
 	if (btrfs_test_opt(root, SKIP_BALANCE))
 		seq_puts(seq, ",skip_balance");
-	if (btrfs_test_opt(root, RECOVERY))
-		seq_puts(seq, ",recovery");
 #ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
 	if (btrfs_test_opt(root, CHECK_INTEGRITY_INCLUDING_EXTENT_DATA))
 		seq_puts(seq, ",check_int_data");

commit 2101ae42899a14fe7caa73114e2161e778328661
Merge: 391f2a16b74b a6111d11b8b5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 22 11:49:21 2016 -0800

    Merge branch 'for-linus-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull more btrfs updates from Chris Mason:
     "These are mostly fixes that we've been testing, but also we grabbed
      and tested a few small cleanups that had been on the list for a while.
    
      Zhao Lei's patchset also fixes some early ENOSPC buglets"
    
    * 'for-linus-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (21 commits)
      btrfs: raid56: Use raid_write_end_io for scrub
      btrfs: Remove unnecessary ClearPageUptodate for raid56
      btrfs: use rbio->nr_pages to reduce calculation
      btrfs: Use unified stripe_page's index calculation
      btrfs: Fix calculation of rbio->dbitmap's size calculation
      btrfs: Fix no_space in write and rm loop
      btrfs: merge functions for wait snapshot creation
      btrfs: delete unused argument in btrfs_copy_from_user
      btrfs: Use direct way to determine raid56 write/recover mode
      btrfs: Small cleanup for get index_srcdev loop
      btrfs: Enhance chunk validation check
      btrfs: Enhance super validation check
      Btrfs: fix deadlock running delayed iputs at transaction commit time
      Btrfs: fix typo in log message when starting a balance
      btrfs: remove duplicate const specifier
      btrfs: initialize the seq counter in struct btrfs_device
      Btrfs: clean up an error code in btrfs_init_space_info()
      btrfs: fix iterator with update error in backref.c
      Btrfs: fix output of compression message in btrfs_parse_options()
      Btrfs: Initialize btrfs_root->highest_objectid when loading tree root and subvolume roots
      ...

commit 326f784281fbbdcd91bb401b2a3e32132c0f5c72
Merge: acc308556c81 546bed631203
Author: Chris Mason <clm@fb.com>
Date:   Tue Jan 19 18:21:30 2016 -0800

    Merge branch 'misc-for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.5

commit c1a198d9235b9e7d6942027374e44f78ebdcb455
Merge: 48f58ba9cbff 988f1f576d4f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 18 12:44:40 2016 -0800

    Merge branch 'for-linus-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "This has our usual assortment of fixes and cleanups, but the biggest
      change included is Omar Sandoval's free space tree.  It's not the
      default yet, mounting -o space_cache=v2 enables it and sets a readonly
      compat bit.  The tree can actually be deleted and regenerated if there
      are any problems, but it has held up really well in testing so far.
    
      For very large filesystems (30T+) our existing free space caching code
      can end up taking a huge amount of time during commits.  The new tree
      based code is faster and less work overall to update as the commit
      progresses.
    
      Omar worked on this during the summer and we'll hammer on it in
      production here at FB over the next few months"
    
    * 'for-linus-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (73 commits)
      Btrfs: fix fitrim discarding device area reserved for boot loader's use
      Btrfs: Check metadata redundancy on balance
      btrfs: statfs: report zero available if metadata are exhausted
      btrfs: preallocate path for snapshot creation at ioctl time
      btrfs: allocate root item at snapshot ioctl time
      btrfs: do an allocation earlier during snapshot creation
      btrfs: use smaller type for btrfs_path locks
      btrfs: use smaller type for btrfs_path lowest_level
      btrfs: use smaller type for btrfs_path reada
      btrfs: cleanup, use enum values for btrfs_path reada
      btrfs: constify static arrays
      btrfs: constify remaining structs with function pointers
      btrfs tests: replace whole ops structure for free space tests
      btrfs: use list_for_each_entry* in backref.c
      btrfs: use list_for_each_entry_safe in free-space-cache.c
      btrfs: use list_for_each_entry* in check-integrity.c
      Btrfs: use linux/sizes.h to represent constants
      btrfs: cleanup, remove stray return statements
      btrfs: zero out delayed node upon allocation
      btrfs: pass proper enum type to start_transaction()
      ...

commit b7c47bbb2d1856330f71ba04c8eb03b39aca87cd
Author: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
Date:   Wed Jan 6 17:03:40 2016 +0900

    Btrfs: fix output of compression message in btrfs_parse_options()
    
    The compression message might not be correctly output.
    Fix it.
    
    [[before fix]]
    
    # mount -o compress /dev/sdb3 /test3
    [  996.874264] BTRFS info (device sdb3): disk space caching is enabled
    [  996.874268] BTRFS: has skinny extents
    # mount | grep /test3
    /dev/sdb3 on /test3 type btrfs (rw,relatime,compress=zlib,space_cache,subvolid=5,subvol=/)
    
    # mount -o remount,compress-force /dev/sdb3 /test3
    [ 1035.075017] BTRFS info (device sdb3): force zlib compression
    [ 1035.075021] BTRFS info (device sdb3): disk space caching is enabled
    # mount | grep /test3
    /dev/sdb3 on /test3 type btrfs (rw,relatime,compress-force=zlib,space_cache,subvolid=5,subvol=/)
    
    # mount -o remount,compress /dev/sdb3 /test3
    [ 1053.679092] BTRFS info (device sdb3): disk space caching is enabled
    # mount | grep /test3
    /dev/sdb3 on /test3 type btrfs (rw,relatime,compress=zlib,space_cache,subvolid=5,subvol=/)
    
    [[after fix]]
    
    # mount -o compress /dev/sdb3 /test3
    [  401.021753] BTRFS info (device sdb3): use zlib compression
    [  401.021758] BTRFS info (device sdb3): disk space caching is enabled
    [  401.021760] BTRFS: has skinny extents
    # mount | grep /test3
    /dev/sdb3 on /test3 type btrfs (rw,relatime,compress=zlib,space_cache,subvolid=5,subvol=/)
    
    # mount -o remount,compress-force /dev/sdb3 /test3
    [  439.824624] BTRFS info (device sdb3): force zlib compression
    [  439.824629] BTRFS info (device sdb3): disk space caching is enabled
    # mount | grep /test3
    /dev/sdb3 on /test3 type btrfs (rw,relatime,compress-force=zlib,space_cache,subvolid=5,subvol=/)
    
    # mount -o remount,compress /dev/sdb3 /test3
    [  459.918430] BTRFS info (device sdb3): use zlib compression
    [  459.918434] BTRFS info (device sdb3): disk space caching is enabled
    # mount | grep /test3
    /dev/sdb3 on /test3 type btrfs (rw,relatime,compress=zlib,space_cache,subvolid=5,subvol=/)
    
    Signed-off-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5099e4633e50..3225ac365408 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -381,6 +381,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	int ret = 0;
 	char *compress_type;
 	bool compress_force = false;
+	enum btrfs_compression_type saved_compress_type;
+	bool saved_compress_force;
+	int no_compress = 0;
 
 	cache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);
 	if (cache_gen)
@@ -458,6 +461,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			/* Fallthrough */
 		case Opt_compress:
 		case Opt_compress_type:
+			saved_compress_type = btrfs_test_opt(root, COMPRESS) ?
+				info->compress_type : BTRFS_COMPRESS_NONE;
+			saved_compress_force =
+				btrfs_test_opt(root, FORCE_COMPRESS);
 			if (token == Opt_compress ||
 			    token == Opt_compress_force ||
 			    strcmp(args[0].from, "zlib") == 0) {
@@ -466,6 +473,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				btrfs_set_opt(info->mount_opt, COMPRESS);
 				btrfs_clear_opt(info->mount_opt, NODATACOW);
 				btrfs_clear_opt(info->mount_opt, NODATASUM);
+				no_compress = 0;
 			} else if (strcmp(args[0].from, "lzo") == 0) {
 				compress_type = "lzo";
 				info->compress_type = BTRFS_COMPRESS_LZO;
@@ -473,25 +481,21 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				btrfs_clear_opt(info->mount_opt, NODATACOW);
 				btrfs_clear_opt(info->mount_opt, NODATASUM);
 				btrfs_set_fs_incompat(info, COMPRESS_LZO);
+				no_compress = 0;
 			} else if (strncmp(args[0].from, "no", 2) == 0) {
 				compress_type = "no";
 				btrfs_clear_opt(info->mount_opt, COMPRESS);
 				btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
 				compress_force = false;
+				no_compress++;
 			} else {
 				ret = -EINVAL;
 				goto out;
 			}
 
 			if (compress_force) {
-				btrfs_set_and_info(root, FORCE_COMPRESS,
-						   "force %s compression",
-						   compress_type);
+				btrfs_set_opt(info->mount_opt, FORCE_COMPRESS);
 			} else {
-				if (!btrfs_test_opt(root, COMPRESS))
-					btrfs_info(root->fs_info,
-						   "btrfs: use %s compression",
-						   compress_type);
 				/*
 				 * If we remount from compress-force=xxx to
 				 * compress=xxx, we need clear FORCE_COMPRESS
@@ -500,6 +504,17 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				 */
 				btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
 			}
+			if ((btrfs_test_opt(root, COMPRESS) &&
+			     (info->compress_type != saved_compress_type ||
+			      compress_force != saved_compress_force)) ||
+			    (!btrfs_test_opt(root, COMPRESS) &&
+			     no_compress == 1)) {
+				btrfs_info(root->fs_info,
+					   "%s %s compression",
+					   (compress_force) ? "force" : "use",
+					   compress_type);
+			}
+			compress_force = false;
 			break;
 		case Opt_ssd:
 			btrfs_set_and_info(root, SSD,

commit b28cf57246d5b797ba725bb033110c247f2c301f
Merge: a3058101c17d a7ca42256d9f
Author: Chris Mason <clm@fb.com>
Date:   Mon Jan 11 06:08:37 2016 -0800

    Merge branch 'misc-cleanups-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.5
    
    Signed-off-by: Chris Mason <clm@fb.com>

commit a3058101c17d2825f34a0ab5c37d93ead0f4d9dc
Merge: 511711af91f2 ee592d077161
Author: Chris Mason <clm@fb.com>
Date:   Mon Jan 11 05:59:32 2016 -0800

    Merge branch 'misc-for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.5

commit ca8a51b3a979d57b082b14eda38602b7f52d81d1
Author: David Sterba <dsterba@suse.com>
Date:   Sat Oct 10 17:59:53 2015 +0200

    btrfs: statfs: report zero available if metadata are exhausted
    
    There is one ENOSPC case that's very confusing. There's Available
    greater than zero but no file operation succeds (besides removing
    files). This happens when the metadata are exhausted and there's no
    possibility to allocate another chunk.
    
    In this scenario it's normal that there's still some space in the data
    chunk and the calculation in df reflects that in the Avail value.
    
    To at least give some clue about the ENOSPC situation, let statfs report
    zero value in Avail, even if there's still data space available.
    
    Current:
      /dev/sdb1             4.0G  3.3G  719M  83% /mnt/test
    
    New:
      /dev/sdb1             4.0G  3.3G     0 100% /mnt/test
    
    We calculate the remaining metadata space minus global reserve. If this
    is (supposedly) smaller than zero, there's no space. But this does not
    hold in practice, the exhausted state happens where's still some
    positive delta. So we apply some guesswork and compare the delta to a 4M
    threshold. (Practically observed delta was 2M.)
    
    We probably cannot calculate the exact threshold value because this
    depends on the internal reservations requested by various operations, so
    some operations that consume a few metadata will succeed even if the
    Avail is zero. But this is better than the other way around.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b813fd76f03f..5099e4633e50 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1956,6 +1956,8 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
  * there are other factors that may change the result (like a new metadata
  * chunk).
  *
+ * If metadata is exhausted, f_bavail will be 0.
+ *
  * FIXME: not accurate for mixed block groups, total and free/used are ok,
  * available appears slightly larger.
  */
@@ -1967,11 +1969,13 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct btrfs_space_info *found;
 	u64 total_used = 0;
 	u64 total_free_data = 0;
+	u64 total_free_meta = 0;
 	int bits = dentry->d_sb->s_blocksize_bits;
 	__be32 *fsid = (__be32 *)fs_info->fsid;
 	unsigned factor = 1;
 	struct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;
 	int ret;
+	u64 thresh = 0;
 
 	/*
 	 * holding chunk_muext to avoid allocating new chunks, holding
@@ -1997,6 +2001,8 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 				}
 			}
 		}
+		if (found->flags & BTRFS_BLOCK_GROUP_METADATA)
+			total_free_meta += found->disk_total - found->disk_used;
 
 		total_used += found->disk_used;
 	}
@@ -2019,6 +2025,24 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_bavail += div_u64(total_free_data, factor);
 	buf->f_bavail = buf->f_bavail >> bits;
 
+	/*
+	 * We calculate the remaining metadata space minus global reserve. If
+	 * this is (supposedly) smaller than zero, there's no space. But this
+	 * does not hold in practice, the exhausted state happens where's still
+	 * some positive delta. So we apply some guesswork and compare the
+	 * delta to a 4M threshold.  (Practically observed delta was ~2M.)
+	 *
+	 * We probably cannot calculate the exact threshold value because this
+	 * depends on the internal reservations requested by various
+	 * operations, so some operations that consume a few metadata will
+	 * succeed even if the Avail is zero. But this is better than the other
+	 * way around.
+	 */
+	thresh = 4 * 1024 * 1024;
+
+	if (total_free_meta - thresh < block_rsv->size)
+		buf->f_bavail = 0;
+
 	buf->f_type = BTRFS_SUPER_MAGIC;
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_namelen = BTRFS_NAME_LEN;

commit 4d4ab6d6bc05ba65169de9a5391e6ccbe09d8719
Author: David Sterba <dsterba@suse.com>
Date:   Thu Nov 19 11:42:31 2015 +0100

    btrfs: constify static arrays
    
    There are a few statically initialized arrays that can be made const.
    The remaining (like file_system_type, sysfs attributes or prop handlers)
    do not allow that due to type mismatch when passed to the APIs or
    because the structures are modified through other members.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 24154e422945..b813fd76f03f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -309,7 +309,7 @@ enum {
 	Opt_err,
 };
 
-static match_table_t tokens = {
+static const match_table_t tokens = {
 	{Opt_degraded, "degraded"},
 	{Opt_subvol, "subvol=%s"},
 	{Opt_subvolid, "subvolid=%s"},

commit ee22184b53c823f6956314c2815d4068e3820737
Author: Byongho Lee <bhlee.kernel@gmail.com>
Date:   Tue Dec 15 01:42:10 2015 +0900

    Btrfs: use linux/sizes.h to represent constants
    
    We use many constants to represent size and offset value.  And to make
    code readable we use '256 * 1024 * 1024' instead of '268435456' to
    represent '256MB'.  However we can make far more readable with 'SZ_256MB'
    which is defined in the 'linux/sizes.h'.
    
    So this patch replaces 'xxx * 1024 * 1024' kind of expression with
    single 'SZ_xxxMB' if 'xxx' is a power of 2 then 'xxx * SZ_1M' if 'xxx' is
    not a power of 2. And I haven't touched to '4096' & '8192' because it's
    more intuitive than 'SZ_4KB' & 'SZ_8KB'.
    
    Signed-off-by: Byongho Lee <bhlee.kernel@gmail.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 24154e422945..0b6ab61aa548 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1865,7 +1865,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 		 * btrfs starts at an offset of at least 1MB when doing chunk
 		 * allocation.
 		 */
-		skip_space = 1024 * 1024;
+		skip_space = SZ_1M;
 
 		/* user can set the offset in fs_info->alloc_start. */
 		if (fs_info->alloc_start &&

commit a1c6f05733c27ba7067c06c095f49e8732a5ae17
Author: Dmitry Monakhov <dmonakhov@openvz.org>
Date:   Mon Apr 13 16:31:37 2015 +0400

    fs: use block_device name vsprintf helper
    
    Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 24154e422945..a0434c179ea9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1514,9 +1514,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		if ((flags ^ s->s_flags) & MS_RDONLY)
 			error = -EBUSY;
 	} else {
-		char b[BDEVNAME_SIZE];
-
-		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
+		snprintf(s->s_id, sizeof(s->s_id), "%pg", bdev);
 		btrfs_sb(s)->bdev_holder = fs_type;
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);

commit f7d3d2f99eeaa9f5c111965b1516972f4fc5e449
Merge: 9f9499ae8e64 70f6d82ec73c
Author: Chris Mason <clm@fb.com>
Date:   Fri Dec 18 11:11:10 2015 -0800

    Merge branch 'freespace-tree' into for-linus-4.5
    
    Signed-off-by: Chris Mason <clm@fb.com>

commit 70f6d82ec73c3ae2d3adc6853c5bebcd73610097
Author: Omar Sandoval <osandov@fb.com>
Date:   Tue Sep 29 20:50:38 2015 -0700

    Btrfs: add free space tree mount option
    
    Now we can finally hook up everything so we can actually use free space
    tree. The free space tree is enabled by passing the space_cache=v2 mount
    option. On the first mount with the this option set, the free space tree
    will be created and the FREE_SPACE_TREE read-only compat bit will be
    set. Any time the filesystem is mounted from then on, we must use the
    free space tree. The clear_cache option will also clear the free space
    tree.
    
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 442bf434b783..bfdaf123f4e9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -312,10 +312,11 @@ enum {
 	Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl, Opt_compress,
 	Opt_compress_type, Opt_compress_force, Opt_compress_force_type,
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
-	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
-	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag, Opt_inode_cache,
-	Opt_no_space_cache, Opt_recovery, Opt_skip_balance,
-	Opt_check_integrity, Opt_check_integrity_including_extent_data,
+	Opt_space_cache, Opt_space_cache_version, Opt_clear_cache,
+	Opt_user_subvol_rm_allowed, Opt_enospc_debug, Opt_subvolrootid,
+	Opt_defrag, Opt_inode_cache, Opt_no_space_cache, Opt_recovery,
+	Opt_skip_balance, Opt_check_integrity,
+	Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
@@ -354,6 +355,7 @@ static match_table_t tokens = {
 	{Opt_discard, "discard"},
 	{Opt_nodiscard, "nodiscard"},
 	{Opt_space_cache, "space_cache"},
+	{Opt_space_cache_version, "space_cache=%s"},
 	{Opt_clear_cache, "clear_cache"},
 	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
 	{Opt_enospc_debug, "enospc_debug"},
@@ -392,7 +394,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	bool compress_force = false;
 
 	cache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);
-	if (cache_gen)
+	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE))
+		btrfs_set_opt(info->mount_opt, FREE_SPACE_TREE);
+	else if (cache_gen)
 		btrfs_set_opt(info->mount_opt, SPACE_CACHE);
 
 	if (!options)
@@ -626,15 +630,35 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 					     "turning off discard");
 			break;
 		case Opt_space_cache:
-			btrfs_set_and_info(root, SPACE_CACHE,
-					   "enabling disk space caching");
+		case Opt_space_cache_version:
+			if (token == Opt_space_cache ||
+			    strcmp(args[0].from, "v1") == 0) {
+				btrfs_clear_opt(root->fs_info->mount_opt,
+						FREE_SPACE_TREE);
+				btrfs_set_and_info(root, SPACE_CACHE,
+						   "enabling disk space caching");
+			} else if (strcmp(args[0].from, "v2") == 0) {
+				btrfs_clear_opt(root->fs_info->mount_opt,
+						SPACE_CACHE);
+				btrfs_set_and_info(root, FREE_SPACE_TREE,
+						   "enabling free space tree");
+			} else {
+				ret = -EINVAL;
+				goto out;
+			}
 			break;
 		case Opt_rescan_uuid_tree:
 			btrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);
 			break;
 		case Opt_no_space_cache:
-			btrfs_clear_and_info(root, SPACE_CACHE,
-					     "disabling disk space caching");
+			if (btrfs_test_opt(root, SPACE_CACHE)) {
+				btrfs_clear_and_info(root, SPACE_CACHE,
+						     "disabling disk space caching");
+			}
+			if (btrfs_test_opt(root, FREE_SPACE_TREE)) {
+				btrfs_clear_and_info(root, FREE_SPACE_TREE,
+						     "disabling free space tree");
+			}
 			break;
 		case Opt_inode_cache:
 			btrfs_set_pending_and_info(info, INODE_MAP_CACHE,
@@ -747,8 +771,17 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		}
 	}
 out:
+	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE) &&
+	    !btrfs_test_opt(root, FREE_SPACE_TREE) &&
+	    !btrfs_test_opt(root, CLEAR_CACHE)) {
+		btrfs_err(root->fs_info, "cannot disable free space tree");
+		ret = -EINVAL;
+
+	}
 	if (!ret && btrfs_test_opt(root, SPACE_CACHE))
 		btrfs_info(root->fs_info, "disk space caching is enabled");
+	if (!ret && btrfs_test_opt(root, FREE_SPACE_TREE))
+		btrfs_info(root->fs_info, "using free space tree");
 	kfree(orig);
 	return ret;
 }
@@ -1155,6 +1188,8 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",noacl");
 	if (btrfs_test_opt(root, SPACE_CACHE))
 		seq_puts(seq, ",space_cache");
+	else if (btrfs_test_opt(root, FREE_SPACE_TREE))
+		seq_puts(seq, ",space_cache=v2");
 	else
 		seq_puts(seq, ",nospace_cache");
 	if (btrfs_test_opt(root, RESCAN_UUID_TREE))

commit 7c55ee0c4afba4434d973117234577ae6ff77a1c
Author: Omar Sandoval <osandov@fb.com>
Date:   Tue Sep 29 20:50:36 2015 -0700

    Btrfs: add free space tree sanity tests
    
    This tests the operations on the free space tree trying to excercise all
    of the main cases for both formats. Between this and xfstests, the free
    space tree should have pretty good coverage.
    
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 11d1eab9234d..442bf434b783 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2212,6 +2212,9 @@ static int btrfs_run_sanity_tests(void)
 	if (ret)
 		goto out;
 	ret = btrfs_test_qgroups();
+	if (ret)
+		goto out;
+	ret = btrfs_test_free_space_tree();
 out:
 	btrfs_destroy_test_fs();
 	return ret;

commit d0bd456074dca089579818312da7cbe726ad2ff9
Author: Josef Bacik <jbacik@fb.com>
Date:   Wed Sep 23 14:54:14 2015 -0400

    Btrfs: add fragment=* debug mount option
    
    In tracking down these weird bitmap problems it was helpful to artificially
    create an extremely fragmented file system.  These mount options let us either
    fragment data or metadata or both.  With these options I could reproduce all
    sorts of weird latencies and hangs that occur under extreme fragmentation and
    get them fixed.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b23d49daa1a2..24154e422945 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -303,6 +303,9 @@ enum {
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
 	Opt_datasum, Opt_treelog, Opt_noinode_cache,
+#ifdef CONFIG_BTRFS_DEBUG
+	Opt_fragment_data, Opt_fragment_metadata, Opt_fragment_all,
+#endif
 	Opt_err,
 };
 
@@ -355,6 +358,11 @@ static match_table_t tokens = {
 	{Opt_rescan_uuid_tree, "rescan_uuid_tree"},
 	{Opt_fatal_errors, "fatal_errors=%s"},
 	{Opt_commit_interval, "commit=%d"},
+#ifdef CONFIG_BTRFS_DEBUG
+	{Opt_fragment_data, "fragment=data"},
+	{Opt_fragment_metadata, "fragment=metadata"},
+	{Opt_fragment_all, "fragment=all"},
+#endif
 	{Opt_err, NULL},
 };
 
@@ -721,6 +729,22 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;
 			}
 			break;
+#ifdef CONFIG_BTRFS_DEBUG
+		case Opt_fragment_all:
+			btrfs_info(root->fs_info, "fragmenting all space");
+			btrfs_set_opt(info->mount_opt, FRAGMENT_DATA);
+			btrfs_set_opt(info->mount_opt, FRAGMENT_METADATA);
+			break;
+		case Opt_fragment_metadata:
+			btrfs_info(root->fs_info, "fragmenting metadata");
+			btrfs_set_opt(info->mount_opt,
+				      FRAGMENT_METADATA);
+			break;
+		case Opt_fragment_data:
+			btrfs_info(root->fs_info, "fragmenting data");
+			btrfs_set_opt(info->mount_opt, FRAGMENT_DATA);
+			break;
+#endif
 		case Opt_err:
 			btrfs_info(root->fs_info, "unrecognized mount option '%s'", p);
 			ret = -EINVAL;
@@ -1172,6 +1196,12 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",fatal_errors=panic");
 	if (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)
 		seq_printf(seq, ",commit=%d", info->commit_interval);
+#ifdef CONFIG_BTRFS_DEBUG
+	if (btrfs_test_opt(root, FRAGMENT_DATA))
+		seq_puts(seq, ",fragment=data");
+	if (btrfs_test_opt(root, FRAGMENT_METADATA))
+		seq_puts(seq, ",fragment=metadata");
+#endif
 	seq_printf(seq, ",subvolid=%llu",
 		  BTRFS_I(d_inode(dentry))->root->root_key.objectid);
 	seq_puts(seq, ",subvol=");

commit 57d816a15ba2c2690c57635134bc01cf4da4623c
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Aug 14 18:32:52 2015 +0800

    Btrfs: __btrfs_std_error() logic should be consistent w/out CONFIG_PRINTK defined
    
    error handling logic behaves differently with or without
    CONFIG_PRINTK defined, since there are two copies of the same
    function which a bit of different logic
    
    One, when CONFIG_PRINTK is defined, code is
    
    __btrfs_std_error(..)
    {
    ::
           save_error_info(fs_info);
           if (sb->s_flags & MS_BORN)
                   btrfs_handle_error(fs_info);
    }
    
    and two when CONFIG_PRINTK is not defined, the code is
    
    __btrfs_std_error(..)
    {
    ::
           if (sb->s_flags & MS_BORN) {
                   save_error_info(fs_info);
                   btrfs_handle_error(fs_info);
            }
    }
    
    I doubt if this was intentional ? and appear to have caused since
    we maintain two copies of the same function and they got diverged
    with commits.
    
    Now to decide which logic is correct reviewed changes as below,
    
     533574c6bc30cf526cc1c41bde050c854a945efb
    Commit added two copies of this function
    
     cf79ffb5b79e8a2b587fbf218809e691bb396c98
    Commit made change to only one copy of the function and to the
    copy when CONFIG_PRINTK is defined.
    
    To fix this, instead of maintaining two copies of same function
    approach, maintain single function, and just put the extra
    portion of the code under CONFIG_PRINTK define.
    
    This patch just does that. And keeps code of with CONFIG_PRINTK
    defined.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 11d1eab9234d..b23d49daa1a2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -130,7 +130,6 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 	}
 }
 
-#ifdef CONFIG_PRINTK
 /*
  * __btrfs_std_error decodes expected errors from the caller and
  * invokes the approciate error response.
@@ -140,7 +139,9 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		       unsigned int line, int errno, const char *fmt, ...)
 {
 	struct super_block *sb = fs_info->sb;
+#ifdef CONFIG_PRINTK
 	const char *errstr;
+#endif
 
 	/*
 	 * Special case: if the error is EROFS, and we're already
@@ -149,6 +150,7 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
   		return;
 
+#ifdef CONFIG_PRINTK
 	errstr = btrfs_decode_error(errno);
 	if (fmt) {
 		struct va_format vaf;
@@ -166,6 +168,7 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		printk(KERN_CRIT "BTRFS: error (device %s) in %s:%d: errno=%d %s\n",
 			sb->s_id, function, line, errno, errstr);
 	}
+#endif
 
 	/* Don't go through full error handling during mount */
 	save_error_info(fs_info);
@@ -173,6 +176,7 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		btrfs_handle_error(fs_info);
 }
 
+#ifdef CONFIG_PRINTK
 static const char * const logtypes[] = {
 	"emergency",
 	"alert",
@@ -212,27 +216,6 @@ void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 
 	va_end(args);
 }
-
-#else
-
-void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
-		       unsigned int line, int errno, const char *fmt, ...)
-{
-	struct super_block *sb = fs_info->sb;
-
-	/*
-	 * Special case: if the error is EROFS, and we're already
-	 * under MS_RDONLY, then it is safe here.
-	 */
-	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
-		return;
-
-	/* Don't go through full error handling during mount */
-	if (sb->s_flags & MS_BORN) {
-		save_error_info(fs_info);
-		btrfs_handle_error(fs_info);
-	}
-}
 #endif
 
 /*

commit 03e8f644868f147e021e8660346890e731c2e435
Merge: 101688f534fd 2b9dbef272b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 25 12:08:41 2015 -0700

    Merge branch 'for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs fixes from Chris Mason:
     "This is an assorted set I've been queuing up:
    
      Jeff Mahoney tracked down a tricky one where we ended up starting IO
      on the wrong mapping for special files in btrfs_evict_inode.  A few
      people reported this one on the list.
    
      Filipe found (and provided a test for) a difficult bug in reading
      compressed extents, and Josef fixed up some quota record keeping with
      snapshot deletion.  Chandan killed off an accounting bug during DIO
      that lead to WARN_ONs as we freed inodes"
    
    * 'for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs:
      Btrfs: keep dropped roots in cache until transaction commit
      Btrfs: Direct I/O: Fix space accounting
      btrfs: skip waiting on ordered range for special files
      Btrfs: fix read corruption of compressed and shared extents
      Btrfs: remove unnecessary locking of cleaner_mutex to avoid deadlock
      Btrfs: don't initialize a space info as full to prevent ENOSPC

commit 85e0a0f21a14bfd9145422a6a627c3df47101bd8
Author: Filipe Manana <fdmanana@suse.com>
Date:   Thu Sep 10 10:36:06 2015 +0100

    Btrfs: remove unnecessary locking of cleaner_mutex to avoid deadlock
    
    After commmit e44163e17796 ("btrfs: explictly delete unused block groups
    in close_ctree and ro-remount"), added in the 4.3 merge window, we have
    calls to btrfs_delete_unused_bgs() while holding the cleaner_mutex.
    This can cause a deadlock with a concurrent block group relocation (when
    a filesystem balance or shrink operation is in progress for example)
    because btrfs_delete_unused_bgs() locks delete_unused_bgs_mutex and the
    relocation path locks first delete_unused_bgs_mutex and then it locks
    cleaner_mutex, resulting in a classic ABBA deadlock:
    
             CPU 0                                        CPU 1
    
    lock fs_info->cleaner_mutex
    
                                               __btrfs_balance() || btrfs_shrink_device()
                                                 lock fs_info->delete_unused_bgs_mutex
                                                 btrfs_relocate_chunk()
                                                   btrfs_relocate_block_group()
                                                     lock fs_info->cleaner_mutex
    btrfs_delete_unused_bgs()
      lock fs_info->delete_unused_bgs_mutex
    
    Fix this by not taking the cleaner_mutex before calling
    btrfs_delete_unused_bgs() because it's no longer needed after
    commit 67c5e7d464bc ("Btrfs: fix race between balance and unused block
    group deletion"). The mutex fs_info->delete_unused_bgs_mutex, the
    spinlock fs_info->unused_bgs_lock and a block group's spinlock are
    enough to get correct serialization between tasks running relocation
    and unused block group deletion (as well as between multiple tasks
    concurrently calling btrfs_delete_unused_bgs()).
    
    This issue was discussed (in the mailing list) during the review of
    the patch titled "btrfs: explictly delete unused block groups in
    close_ctree and ro-remount" and it was agreed that acquiring the
    cleaner mutex had to be dropped after the patch titled
    "Btrfs: fix race between balance and unused block group deletion"
    got merged (both patches were submitted at about the same time, but
    one landed in kernel 4.2 and the other in the 4.3 merge window).
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c389c13f0f38..5a186d7180d3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1658,9 +1658,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		 * groups on disk until we're mounted read-write again
 		 * unless we clean them up here.
 		 */
-		mutex_lock(&root->fs_info->cleaner_mutex);
 		btrfs_delete_unused_bgs(fs_info);
-		mutex_unlock(&root->fs_info->cleaner_mutex);
 
 		btrfs_dev_replace_suspend_for_unmount(fs_info);
 		btrfs_scrub_cancel(fs_info);

commit 22365979ab15f8500254cb90037b0b4c17554739
Merge: 6c0f568e84a3 3a9508b0221d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 5 15:14:43 2015 -0700

    Merge branch 'for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "This has Jeff Mahoney's long standing trim patch that fixes corners
      where trims were missing.  Omar has some raid5/6 fixes, especially for
      using scrub and device replace when devices are missing.
    
      Zhao Lie continues cleaning and fixing things, this series fixes some
      really hard to hit corners in xfstests.  I had to pull it last merge
      window due to some deadlocks, but those are now resolved.
    
      I added support for Tejun's new blkio controllers.  It seems to work
      well for single devices, we'll expand to multi-device as well"
    
    * 'for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (47 commits)
      btrfs: fix compile when block cgroups are not enabled
      Btrfs: fix file read corruption after extent cloning and fsync
      Btrfs: check if previous transaction aborted to avoid fs corruption
      btrfs: use __GFP_NOFAIL in alloc_btrfs_bio
      btrfs: Prevent from early transaction abort
      btrfs: Remove unused arguments in tree-log.c
      btrfs: Remove useless condition in start_log_trans()
      Btrfs: add support for blkio controllers
      Btrfs: remove unused mutex from struct 'btrfs_fs_info'
      Btrfs: fix parity scrub of RAID 5/6 with missing device
      Btrfs: fix device replace of a missing RAID 5/6 device
      Btrfs: add RAID 5/6 BTRFS_RBIO_REBUILD_MISSING operation
      Btrfs: count devices correctly in readahead during RAID 5/6 replace
      Btrfs: remove misleading handling of missing device scrub
      btrfs: fix clone / extent-same deadlocks
      Btrfs: fix defrag to merge tail file extent
      Btrfs: fix warning in backref walking
      btrfs: Add WARN_ON() for double lock in btrfs_tree_lock()
      btrfs: Remove root argument in extent_data_ref_count()
      btrfs: Fix wrong comment of btrfs_alloc_tree_block()
      ...

commit 46cd28555ffaa40162290dba203daad0ff6f7abd
Merge: da2f0f74cf7d e33e17ee1098
Author: Chris Mason <clm@fb.com>
Date:   Sun Aug 9 07:35:33 2015 -0700

    Merge branch 'jeffm-discard-4.3' into for-linus-4.3

commit da2f0f74cf7d074e5a8918c8efdf6aba4a989b4a
Author: Chris Mason <clm@fb.com>
Date:   Thu Jul 2 13:57:22 2015 -0700

    Btrfs: add support for blkio controllers
    
    This attaches accounting information to bios as we submit them so the
    new blkio controllers can throttle on btrfs filesystems.
    
    Not much is required, we're just associating bios with blkcgs during clone,
    calling wbc_init_bio()/wbc_account_io() during writepages submission,
    and attaching the bios to the current context during direct IO.
    
    Finally if we are splitting bios during btrfs_map_bio, this attaches
    accounting information to the split.
    
    The end result is able to throttle nicely on single disk filesystems.  A
    little more work is required for multi-device filesystems.
    
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cd7ef34d2dce..d366dd4664d0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1033,6 +1033,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_flags |= MS_POSIXACL;
 #endif
 	sb->s_flags |= MS_I_VERSION;
+	sb->s_iflags |= SB_I_CGROUPWB;
 	err = open_ctree(sb, fs_devices, (char *)data);
 	if (err) {
 		printk(KERN_ERR "BTRFS: open_ctree failed\n");

commit f368ed6088ae9c1fbe1c897bb5f215ce5e63fa1e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jul 30 15:59:57 2015 -0700

    char: make misc_deregister a void function
    
    With well over 200+ users of this api, there are a mere 12 users that
    actually checked the return value of this function.  And all of them
    really didn't do anything with that information as the system or module
    was shutting down no matter what.
    
    So stop pretending like it matters, and just return void from
    misc_deregister().  If something goes wrong in the call, you will get a
    WARNING splat in the syslog so you know how to fix up your driver.
    Other than that, there's nothing that can go wrong.
    
    Cc: Alasdair Kergon <agk@redhat.com>
    Cc: Neil Brown <neilb@suse.com>
    Cc: Oleg Drokin <oleg.drokin@intel.com>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: "Michael S. Tsirkin" <mst@redhat.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Christine Caulfield <ccaulfie@redhat.com>
    Cc: David Teigland <teigland@redhat.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Acked-by: Joel Becker <jlbec@evilplan.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Alessandro Zummo <a.zummo@towertech.it>
    Acked-by: Mike Snitzer <snitzer@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cd7ef34d2dce..6bad63379a4c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2163,8 +2163,7 @@ static int btrfs_interface_init(void)
 
 static void btrfs_interface_exit(void)
 {
-	if (misc_deregister(&btrfs_misc) < 0)
-		printk(KERN_INFO "BTRFS: misc_deregister failed for control device\n");
+	misc_deregister(&btrfs_misc);
 }
 
 static void btrfs_print_info(void)

commit e33e17ee1098d8d751552ac11c111e1c1a3db014
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Jun 15 09:41:19 2015 -0400

    btrfs: add missing discards when unpinning extents with -o discard
    
    When we clear the dirty bits in btrfs_delete_unused_bgs for extents
    in the empty block group, it results in btrfs_finish_extent_commit being
    unable to discard the freed extents.
    
    The block group removal patch added an alternate path to forget extents
    other than btrfs_finish_extent_commit.  As a result, any extents that
    would be freed when the block group is removed aren't discarded.  In my
    test run, with a large copy of mixed sized files followed by removal, it
    left nearly 2/3 of extents undiscarded.
    
    To clean up the block groups, we add the removed block group onto a list
    that will be discarded after transaction commit.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Filipe Manana <fdmanana@suse.com>
    Tested-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a1077e0ffaa8..8da24e242896 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -69,7 +69,7 @@ static struct file_system_type btrfs_fs_type;
 
 static int btrfs_remount(struct super_block *sb, int *flags, char *data);
 
-static const char *btrfs_decode_error(int errno)
+const char *btrfs_decode_error(int errno)
 {
 	char *errstr = "unknown";
 

commit e44163e177960ee60e32a73bffdd53c3a5827406
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Jun 15 09:41:18 2015 -0400

    btrfs: explictly delete unused block groups in close_ctree and ro-remount
    
    The cleaner thread may already be sleeping by the time we enter
    close_ctree.  If that's the case, we'll skip removing any unused
    block groups queued for removal, even during a normal umount.
    They'll be cleaned up automatically at next mount, but users
    expect a umount to be a clean synchronization point, especially
    when used on thin-provisioned storage with -odiscard.  We also
    explicitly remove unused block groups in the ro-remount path
    for the same reason.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Filipe Manana <fdmanana@suse.com>
    Tested-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cd7ef34d2dce..a1077e0ffaa8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1650,6 +1650,17 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 
 		sb->s_flags |= MS_RDONLY;
 
+		/*
+		 * Setting MS_RDONLY will put the cleaner thread to
+		 * sleep at the next loop if it's already active.
+		 * If it's already asleep, we'll leave unused block
+		 * groups on disk until we're mounted read-write again
+		 * unless we clean them up here.
+		 */
+		mutex_lock(&root->fs_info->cleaner_mutex);
+		btrfs_delete_unused_bgs(fs_info);
+		mutex_unlock(&root->fs_info->cleaner_mutex);
+
 		btrfs_dev_replace_suspend_for_unmount(fs_info);
 		btrfs_scrub_cancel(fs_info);
 		btrfs_pause_balance(fs_info);

commit c8d3fe028f64054d75c72566efb9ecf3c75ee161
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon May 18 02:16:31 2015 -0700

    Btrfs: show subvol= and subvolid= in /proc/mounts
    
    Now that we're guaranteed to have a meaningful root dentry, we can just
    export seq_dentry() and use it in btrfs_show_options(). The subvolume ID
    is easy to get and can also be useful, so put that in there, too.
    
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6fa4aaf0543a..cd7ef34d2dce 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1188,6 +1188,10 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",fatal_errors=panic");
 	if (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)
 		seq_printf(seq, ",commit=%d", info->commit_interval);
+	seq_printf(seq, ",subvolid=%llu",
+		  BTRFS_I(d_inode(dentry))->root->root_key.objectid);
+	seq_puts(seq, ",subvol=");
+	seq_dentry(seq, dentry, " \t\n\\");
 	return 0;
 }
 

commit 05dbe6837b60465db6a61d1f0cabe745e20aadc9
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon May 18 02:16:30 2015 -0700

    Btrfs: unify subvol= and subvolid= mounting
    
    Currently, mounting a subvolume with subvolid= takes a different code
    path than mounting with subvol=. This isn't really a big deal except for
    the fact that mounts done with subvolid= or the default subvolume don't
    have a dentry that's connected to the dentry tree like in the subvol=
    case. To unify the code paths, when given subvolid= or using the default
    subvolume ID, translate it into a subvolume name by walking
    ROOT_BACKREFs in the root tree and INODE_REFs in the filesystem trees.
    
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3ad97953537c..6fa4aaf0543a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -836,33 +836,153 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 	return error;
 }
 
-static struct dentry *get_default_root(struct super_block *sb,
-				       u64 subvol_objectid)
+static char *get_subvol_name_from_objectid(struct btrfs_fs_info *fs_info,
+					   u64 subvol_objectid)
 {
-	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	struct btrfs_root *root = fs_info->tree_root;
-	struct btrfs_root *new_root;
-	struct btrfs_dir_item *di;
-	struct btrfs_path *path;
-	struct btrfs_key location;
-	struct inode *inode;
-	u64 dir_id;
-	int new = 0;
+	struct btrfs_root *fs_root;
+	struct btrfs_root_ref *root_ref;
+	struct btrfs_inode_ref *inode_ref;
+	struct btrfs_key key;
+	struct btrfs_path *path = NULL;
+	char *name = NULL, *ptr;
+	u64 dirid;
+	int len;
+	int ret;
+
+	path = btrfs_alloc_path();
+	if (!path) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	path->leave_spinning = 1;
+
+	name = kmalloc(PATH_MAX, GFP_NOFS);
+	if (!name) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	ptr = name + PATH_MAX - 1;
+	ptr[0] = '\0';
 
 	/*
-	 * We have a specific subvol we want to mount, just setup location and
-	 * go look up the root.
+	 * Walk up the subvolume trees in the tree of tree roots by root
+	 * backrefs until we hit the top-level subvolume.
 	 */
-	if (subvol_objectid) {
-		location.objectid = subvol_objectid;
-		location.type = BTRFS_ROOT_ITEM_KEY;
-		location.offset = (u64)-1;
-		goto find_root;
+	while (subvol_objectid != BTRFS_FS_TREE_OBJECTID) {
+		key.objectid = subvol_objectid;
+		key.type = BTRFS_ROOT_BACKREF_KEY;
+		key.offset = (u64)-1;
+
+		ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
+		if (ret < 0) {
+			goto err;
+		} else if (ret > 0) {
+			ret = btrfs_previous_item(root, path, subvol_objectid,
+						  BTRFS_ROOT_BACKREF_KEY);
+			if (ret < 0) {
+				goto err;
+			} else if (ret > 0) {
+				ret = -ENOENT;
+				goto err;
+			}
+		}
+
+		btrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);
+		subvol_objectid = key.offset;
+
+		root_ref = btrfs_item_ptr(path->nodes[0], path->slots[0],
+					  struct btrfs_root_ref);
+		len = btrfs_root_ref_name_len(path->nodes[0], root_ref);
+		ptr -= len + 1;
+		if (ptr < name) {
+			ret = -ENAMETOOLONG;
+			goto err;
+		}
+		read_extent_buffer(path->nodes[0], ptr + 1,
+				   (unsigned long)(root_ref + 1), len);
+		ptr[0] = '/';
+		dirid = btrfs_root_ref_dirid(path->nodes[0], root_ref);
+		btrfs_release_path(path);
+
+		key.objectid = subvol_objectid;
+		key.type = BTRFS_ROOT_ITEM_KEY;
+		key.offset = (u64)-1;
+		fs_root = btrfs_read_fs_root_no_name(fs_info, &key);
+		if (IS_ERR(fs_root)) {
+			ret = PTR_ERR(fs_root);
+			goto err;
+		}
+
+		/*
+		 * Walk up the filesystem tree by inode refs until we hit the
+		 * root directory.
+		 */
+		while (dirid != BTRFS_FIRST_FREE_OBJECTID) {
+			key.objectid = dirid;
+			key.type = BTRFS_INODE_REF_KEY;
+			key.offset = (u64)-1;
+
+			ret = btrfs_search_slot(NULL, fs_root, &key, path, 0, 0);
+			if (ret < 0) {
+				goto err;
+			} else if (ret > 0) {
+				ret = btrfs_previous_item(fs_root, path, dirid,
+							  BTRFS_INODE_REF_KEY);
+				if (ret < 0) {
+					goto err;
+				} else if (ret > 0) {
+					ret = -ENOENT;
+					goto err;
+				}
+			}
+
+			btrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);
+			dirid = key.offset;
+
+			inode_ref = btrfs_item_ptr(path->nodes[0],
+						   path->slots[0],
+						   struct btrfs_inode_ref);
+			len = btrfs_inode_ref_name_len(path->nodes[0],
+						       inode_ref);
+			ptr -= len + 1;
+			if (ptr < name) {
+				ret = -ENAMETOOLONG;
+				goto err;
+			}
+			read_extent_buffer(path->nodes[0], ptr + 1,
+					   (unsigned long)(inode_ref + 1), len);
+			ptr[0] = '/';
+			btrfs_release_path(path);
+		}
 	}
 
+	btrfs_free_path(path);
+	if (ptr == name + PATH_MAX - 1) {
+		name[0] = '/';
+		name[1] = '\0';
+	} else {
+		memmove(name, ptr, name + PATH_MAX - ptr);
+	}
+	return name;
+
+err:
+	btrfs_free_path(path);
+	kfree(name);
+	return ERR_PTR(ret);
+}
+
+static int get_default_subvol_objectid(struct btrfs_fs_info *fs_info, u64 *objectid)
+{
+	struct btrfs_root *root = fs_info->tree_root;
+	struct btrfs_dir_item *di;
+	struct btrfs_path *path;
+	struct btrfs_key location;
+	u64 dir_id;
+
 	path = btrfs_alloc_path();
 	if (!path)
-		return ERR_PTR(-ENOMEM);
+		return -ENOMEM;
 	path->leave_spinning = 1;
 
 	/*
@@ -874,58 +994,23 @@ static struct dentry *get_default_root(struct super_block *sb,
 	di = btrfs_lookup_dir_item(NULL, root, path, dir_id, "default", 7, 0);
 	if (IS_ERR(di)) {
 		btrfs_free_path(path);
-		return ERR_CAST(di);
+		return PTR_ERR(di);
 	}
 	if (!di) {
 		/*
 		 * Ok the default dir item isn't there.  This is weird since
 		 * it's always been there, but don't freak out, just try and
-		 * mount to root most subvolume.
+		 * mount the top-level subvolume.
 		 */
 		btrfs_free_path(path);
-		dir_id = BTRFS_FIRST_FREE_OBJECTID;
-		new_root = fs_info->fs_root;
-		goto setup_root;
+		*objectid = BTRFS_FS_TREE_OBJECTID;
+		return 0;
 	}
 
 	btrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);
 	btrfs_free_path(path);
-
-find_root:
-	new_root = btrfs_read_fs_root_no_name(fs_info, &location);
-	if (IS_ERR(new_root))
-		return ERR_CAST(new_root);
-
-	if (!(sb->s_flags & MS_RDONLY)) {
-		int ret;
-		down_read(&fs_info->cleanup_work_sem);
-		ret = btrfs_orphan_cleanup(new_root);
-		up_read(&fs_info->cleanup_work_sem);
-		if (ret)
-			return ERR_PTR(ret);
-	}
-
-	dir_id = btrfs_root_dirid(&new_root->root_item);
-setup_root:
-	location.objectid = dir_id;
-	location.type = BTRFS_INODE_ITEM_KEY;
-	location.offset = 0;
-
-	inode = btrfs_iget(sb, &location, new_root, &new);
-	if (IS_ERR(inode))
-		return ERR_CAST(inode);
-
-	/*
-	 * If we're just mounting the root most subvol put the inode and return
-	 * a reference to the dentry.  We will have already gotten a reference
-	 * to the inode in btrfs_fill_super so we're good to go.
-	 */
-	if (!new && d_inode(sb->s_root) == inode) {
-		iput(inode);
-		return dget(sb->s_root);
-	}
-
-	return d_obtain_root(inode);
+	*objectid = location.objectid;
+	return 0;
 }
 
 static int btrfs_fill_super(struct super_block *sb,
@@ -1211,6 +1296,25 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 		goto out;
 	}
 
+	if (!subvol_name) {
+		if (!subvol_objectid) {
+			ret = get_default_subvol_objectid(btrfs_sb(mnt->mnt_sb),
+							  &subvol_objectid);
+			if (ret) {
+				root = ERR_PTR(ret);
+				goto out;
+			}
+		}
+		subvol_name = get_subvol_name_from_objectid(btrfs_sb(mnt->mnt_sb),
+							    subvol_objectid);
+		if (IS_ERR(subvol_name)) {
+			root = ERR_CAST(subvol_name);
+			subvol_name = NULL;
+			goto out;
+		}
+
+	}
+
 	root = mount_subtree(mnt, subvol_name);
 	/* mount_subtree() drops our reference on the vfsmount. */
 	mnt = NULL;
@@ -1227,6 +1331,11 @@ static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
 			ret = -EINVAL;
 		}
 		if (subvol_objectid && root_objectid != subvol_objectid) {
+			/*
+			 * This will also catch a race condition where a
+			 * subvolume which was passed by ID is renamed and
+			 * another subvolume is renamed over the old location.
+			 */
 			pr_err("BTRFS: subvol '%s' does not match subvolid %llu\n",
 			       subvol_name, subvol_objectid);
 			ret = -EINVAL;
@@ -1306,7 +1415,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 {
 	struct block_device *bdev = NULL;
 	struct super_block *s;
-	struct dentry *root;
 	struct btrfs_fs_devices *fs_devices = NULL;
 	struct btrfs_fs_info *fs_info = NULL;
 	struct security_mnt_opts new_sec_opts;
@@ -1326,7 +1434,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		return ERR_PTR(error);
 	}
 
-	if (subvol_name) {
+	if (subvol_name || subvol_objectid != BTRFS_FS_TREE_OBJECTID) {
 		/* mount_subvol() will free subvol_name. */
 		return mount_subvol(subvol_name, subvol_objectid, flags,
 				    device_name, data);
@@ -1395,23 +1503,19 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);
 	}
-
-	root = !error ? get_default_root(s, subvol_objectid) : ERR_PTR(error);
-	if (IS_ERR(root)) {
+	if (error) {
 		deactivate_locked_super(s);
-		error = PTR_ERR(root);
 		goto error_sec_opts;
 	}
 
 	fs_info = btrfs_sb(s);
 	error = setup_security_options(fs_info, s, &new_sec_opts);
 	if (error) {
-		dput(root);
 		deactivate_locked_super(s);
 		goto error_sec_opts;
 	}
 
-	return root;
+	return dget(s->s_root);
 
 error_close_devices:
 	btrfs_close_devices(fs_devices);

commit bb289b7be62db84b9630ce00367444c810cada2c
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon May 18 02:16:29 2015 -0700

    Btrfs: fail on mismatched subvol and subvolid mount options
    
    There's nothing to stop a user from passing both subvol= and subvolid=
    to mount, but if they don't refer to the same subvolume, someone is
    going to be surprised at some point. Error out on this case, but allow
    users to pass in both if they do match (which they could, for example,
    get out of /proc/mounts).
    
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index dd89dd353c4a..3ad97953537c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1167,8 +1167,9 @@ static char *setup_root_args(char *args)
 	return buf;
 }
 
-static struct dentry *mount_subvol(const char *subvol_name, int flags,
-				   const char *device_name, char *data)
+static struct dentry *mount_subvol(const char *subvol_name, u64 subvol_objectid,
+				   int flags, const char *device_name,
+				   char *data)
 {
 	struct dentry *root;
 	struct vfsmount *mnt = NULL;
@@ -1214,12 +1215,27 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 	/* mount_subtree() drops our reference on the vfsmount. */
 	mnt = NULL;
 
-	if (!IS_ERR(root) && !is_subvolume_inode(d_inode(root))) {
+	if (!IS_ERR(root)) {
 		struct super_block *s = root->d_sb;
-		dput(root);
-		root = ERR_PTR(-EINVAL);
-		deactivate_locked_super(s);
-		pr_err("BTRFS: '%s' is not a valid subvolume\n", subvol_name);
+		struct inode *root_inode = d_inode(root);
+		u64 root_objectid = BTRFS_I(root_inode)->root->root_key.objectid;
+
+		ret = 0;
+		if (!is_subvolume_inode(root_inode)) {
+			pr_err("BTRFS: '%s' is not a valid subvolume\n",
+			       subvol_name);
+			ret = -EINVAL;
+		}
+		if (subvol_objectid && root_objectid != subvol_objectid) {
+			pr_err("BTRFS: subvol '%s' does not match subvolid %llu\n",
+			       subvol_name, subvol_objectid);
+			ret = -EINVAL;
+		}
+		if (ret) {
+			dput(root);
+			root = ERR_PTR(ret);
+			deactivate_locked_super(s);
+		}
 	}
 
 out:
@@ -1312,7 +1328,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 	if (subvol_name) {
 		/* mount_subvol() will free subvol_name. */
-		return mount_subvol(subvol_name, flags, device_name, data);
+		return mount_subvol(subvol_name, subvol_objectid, flags,
+				    device_name, data);
 	}
 
 	security_init_mnt_opts(&new_sec_opts);

commit fa3306595071ae03e181c2336d0dcd8f5e3cf9b0
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon May 18 02:16:28 2015 -0700

    Btrfs: clean up error handling in mount_subvol()
    
    In preparation for new functionality in mount_subvol(), give it
    ownership of subvol_name and tidy up the error paths.
    
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1c57c0d0dc41..dd89dd353c4a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1171,55 +1171,61 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 				   const char *device_name, char *data)
 {
 	struct dentry *root;
-	struct vfsmount *mnt;
+	struct vfsmount *mnt = NULL;
 	char *newargs;
+	int ret;
 
 	newargs = setup_root_args(data);
-	if (!newargs)
-		return ERR_PTR(-ENOMEM);
-	mnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,
-			     newargs);
+	if (!newargs) {
+		root = ERR_PTR(-ENOMEM);
+		goto out;
+	}
 
-	if (PTR_RET(mnt) == -EBUSY) {
+	mnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name, newargs);
+	if (PTR_ERR_OR_ZERO(mnt) == -EBUSY) {
 		if (flags & MS_RDONLY) {
-			mnt = vfs_kern_mount(&btrfs_fs_type, flags & ~MS_RDONLY, device_name,
-					     newargs);
+			mnt = vfs_kern_mount(&btrfs_fs_type, flags & ~MS_RDONLY,
+					     device_name, newargs);
 		} else {
-			int r;
-			mnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY, device_name,
-					     newargs);
+			mnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY,
+					     device_name, newargs);
 			if (IS_ERR(mnt)) {
-				kfree(newargs);
-				return ERR_CAST(mnt);
+				root = ERR_CAST(mnt);
+				mnt = NULL;
+				goto out;
 			}
 
 			down_write(&mnt->mnt_sb->s_umount);
-			r = btrfs_remount(mnt->mnt_sb, &flags, NULL);
+			ret = btrfs_remount(mnt->mnt_sb, &flags, NULL);
 			up_write(&mnt->mnt_sb->s_umount);
-			if (r < 0) {
-				/* FIXME: release vfsmount mnt ??*/
-				kfree(newargs);
-				return ERR_PTR(r);
+			if (ret < 0) {
+				root = ERR_PTR(ret);
+				goto out;
 			}
 		}
 	}
-
-	kfree(newargs);
-
-	if (IS_ERR(mnt))
-		return ERR_CAST(mnt);
+	if (IS_ERR(mnt)) {
+		root = ERR_CAST(mnt);
+		mnt = NULL;
+		goto out;
+	}
 
 	root = mount_subtree(mnt, subvol_name);
+	/* mount_subtree() drops our reference on the vfsmount. */
+	mnt = NULL;
 
 	if (!IS_ERR(root) && !is_subvolume_inode(d_inode(root))) {
 		struct super_block *s = root->d_sb;
 		dput(root);
 		root = ERR_PTR(-EINVAL);
 		deactivate_locked_super(s);
-		printk(KERN_ERR "BTRFS: '%s' is not a valid subvolume\n",
-				subvol_name);
+		pr_err("BTRFS: '%s' is not a valid subvolume\n", subvol_name);
 	}
 
+out:
+	mntput(mnt);
+	kfree(newargs);
+	kfree(subvol_name);
 	return root;
 }
 
@@ -1305,9 +1311,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	}
 
 	if (subvol_name) {
-		root = mount_subvol(subvol_name, flags, device_name, data);
-		kfree(subvol_name);
-		return root;
+		/* mount_subvol() will free subvol_name. */
+		return mount_subvol(subvol_name, flags, device_name, data);
 	}
 
 	security_init_mnt_opts(&new_sec_opts);

commit e6e4dbe894ef29bd4aa05a7702e0cded1943dd10
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon May 18 02:16:27 2015 -0700

    Btrfs: remove all subvol options before mounting top-level
    
    Currently, setup_root_args() substitutes 's/subvol=[^,]*/subvolid=0/'.
    But, this means that if the user passes both a subvol and subvolid for
    some reason, we won't actually mount the top-level when we recursively
    mount. For example, consider:
    
    mkfs.btrfs -f /dev/sdb
    mount /dev/sdb /mnt
    btrfs subvol create /mnt/subvol1 # subvolid=257
    btrfs subvol create /mnt/subvol2 # subvolid=258
    umount /mnt
    mount -osubvol=/subvol1,subvolid=258 /dev/sdb /mnt
    
    In the final mount, subvol=/subvol1,subvolid=258 becomes
    subvolid=0,subvolid=258, and the last option takes precedence, so we
    mount subvol2 and try to look up subvol1 inside of it, which fails.
    
    So, instead, do a thorough scan through the argument list and remove any
    subvol= and subvolid= options, then append subvolid=0 to the end. This
    implicitly makes subvol= take precedence over subvolid=, but we're about
    to add a stricter check for that. This also makes setup_root_args() more
    generic, which we'll need soon.
    
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 93f2edf6b603..1c57c0d0dc41 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1133,52 +1133,36 @@ static inline int is_subvolume_inode(struct inode *inode)
 }
 
 /*
- * This will strip out the subvol=%s argument for an argument string and add
- * subvolid=0 to make sure we get the actual tree root for path walking to the
- * subvol we want.
+ * This will add subvolid=0 to the argument string while removing any subvol=
+ * and subvolid= arguments to make sure we get the top-level root for path
+ * walking to the subvol we want.
  */
 static char *setup_root_args(char *args)
 {
-	unsigned len = strlen(args) + 2 + 1;
-	char *src, *dst, *buf;
+	char *buf, *dst, *sep;
 
-	/*
-	 * We need the same args as before, but with this substitution:
-	 * s!subvol=[^,]+!subvolid=0!
-	 *
-	 * Since the replacement string is up to 2 bytes longer than the
-	 * original, allocate strlen(args) + 2 + 1 bytes.
-	 */
-
-	src = strstr(args, "subvol=");
-	/* This shouldn't happen, but just in case.. */
-	if (!src)
-		return NULL;
+	if (!args)
+		return kstrdup("subvolid=0", GFP_NOFS);
 
-	buf = dst = kmalloc(len, GFP_NOFS);
+	/* The worst case is that we add ",subvolid=0" to the end. */
+	buf = dst = kmalloc(strlen(args) + strlen(",subvolid=0") + 1, GFP_NOFS);
 	if (!buf)
 		return NULL;
 
-	/*
-	 * If the subvol= arg is not at the start of the string,
-	 * copy whatever precedes it into buf.
-	 */
-	if (src != args) {
-		*src++ = '\0';
-		strcpy(buf, args);
-		dst += strlen(args);
+	while (1) {
+		sep = strchrnul(args, ',');
+		if (!strstarts(args, "subvol=") &&
+		    !strstarts(args, "subvolid=")) {
+			memcpy(dst, args, sep - args);
+			dst += sep - args;
+			*dst++ = ',';
+		}
+		if (*sep)
+			args = sep + 1;
+		else
+			break;
 	}
-
 	strcpy(dst, "subvolid=0");
-	dst += strlen("subvolid=0");
-
-	/*
-	 * If there is a "," after the original subvol=... string,
-	 * copy that suffix into our buffer.  Otherwise, we're done.
-	 */
-	src = strchr(src, ',');
-	if (src)
-		strcpy(dst, src);
 
 	return buf;
 }

commit 773cd04ec1911abb33cf9538b65f55b76cad5d92
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon May 18 02:16:26 2015 -0700

    Btrfs: lock superblock before remounting for rw subvol
    
    Since commit 0723a0473fb4 ("btrfs: allow mounting btrfs subvolumes with
    different ro/rw options"), when mounting a subvolume read/write when
    another subvolume has previously been mounted read-only, we first do a
    remount. However, this should be done with the superblock locked, as per
    sync_filesystem():
    
            /*
             * We need to be protected against the filesystem going from
             * r/o to r/w or vice versa.
             */
            WARN_ON(!rwsem_is_locked(&sb->s_umount));
    
    This WARN_ON can easily be hit with:
    
    mkfs.btrfs -f /dev/vdb
    mount /dev/vdb /mnt
    btrfs subvol create /mnt/vol1
    btrfs subvol create /mnt/vol2
    umount /mnt
    mount -oro,subvol=/vol1 /dev/vdb /mnt
    mount -orw,subvol=/vol2 /dev/vdb /mnt2
    
    Fixes: 0723a0473fb4 ("btrfs: allow mounting btrfs subvolumes with different ro/rw options")
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c761d8e068e8..93f2edf6b603 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1209,7 +1209,9 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 				return ERR_CAST(mnt);
 			}
 
+			down_write(&mnt->mnt_sb->s_umount);
 			r = btrfs_remount(mnt->mnt_sb, &flags, NULL);
+			up_write(&mnt->mnt_sb->s_umount);
 			if (r < 0) {
 				/* FIXME: release vfsmount mnt ??*/
 				kfree(newargs);

commit c0d19e2b9a521bbdc33049ad92c94b517afda1f0
Author: David Sterba <dsterba@suse.cz>
Date:   Fri Apr 24 19:11:57 2015 +0200

    btrfs: add 'cold' compiler annotations to all error handling functions
    
    The annotated functios will be placed into .text.unlikely section. The
    annotation also hints compiler to move the code out of the hot paths,
    and may implicitly mark if-statement leading to that block as unlikely.
    
    This is a heuristic, the impact on the generated code is not
    significant.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3c72eea12714..c761d8e068e8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -135,6 +135,7 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
  * __btrfs_std_error decodes expected errors from the caller and
  * invokes the approciate error response.
  */
+__cold
 void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		       unsigned int line, int errno, const char *fmt, ...)
 {
@@ -247,6 +248,7 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
  * We'll complete the cleanup in btrfs_end_transaction and
  * btrfs_commit_transaction.
  */
+__cold
 void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 			       struct btrfs_root *root, const char *function,
 			       unsigned int line, int errno)
@@ -273,6 +275,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
  * __btrfs_panic decodes unexpected, fatal errors from the caller,
  * issues an alert, and either panics or BUGs, depending on mount options.
  */
+__cold
 void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 		   unsigned int line, int errno, const char *fmt, ...)
 {

commit 1a9a8a71ed1d457d4f03284ebfd3e40fe1e217ac
Author: David Sterba <dsterba@suse.cz>
Date:   Fri Apr 24 19:11:54 2015 +0200

    btrfs: report exact callsite where transaction abort occurs
    
    WARN is called from a single location and all bugreports say that's in
    super.c __btrfs_abort_transaction. This is slightly confusing as we'd
    rather want to know the exact callsite. Whereas this information is
    printed in the syslog below the stacktrace, this requires further look
    and we usually see only the headline from WARNING.
    
    Moving the WARN into the macro has to inline some code and increases
    code by a few kilobytes:
    
      text    data     bss     dec     hex filename
    835481   20305   14120  869906   d4612 btrfs.ko.before
    842883   20305   14120  877308   d62fc btrfs.ko.after
    
    The delta is +7k (130+ calls), measured on 3.19 x86_64, distro config.
    The increase is not small and could lead to worse icache use. The code
    is on error/exit paths that can be recognized by compiler as cold and
    moved out of the way so the impact is speculated to be low, if
    measurable at all.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9e66f5e724db..3c72eea12714 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -251,14 +251,6 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 			       struct btrfs_root *root, const char *function,
 			       unsigned int line, int errno)
 {
-	/*
-	 * Report first abort since mount
-	 */
-	if (!test_and_set_bit(BTRFS_FS_STATE_TRANS_ABORTED,
-				&root->fs_info->fs_state)) {
-		WARN(1, KERN_DEBUG "BTRFS: Transaction aborted (error %d)\n",
-				errno);
-	}
 	trans->aborted = errno;
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */

commit 9ec3a646fe09970f801ab15e0f1694060b9f19af
Merge: c8b3fd0ce313 3cab989afd8d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 26 15:48:49 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull fourth vfs update from Al Viro:
     "d_inode() annotations from David Howells (sat in for-next since before
      the beginning of merge window) + four assorted fixes"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      RCU pathwalk breakage when running into a symlink overmounting something
      fix I_DIO_WAKEUP definition
      direct-io: only inc/dec inode->i_dio_count for file systems
      fs/9p: fix readdir()
      VFS: assorted d_backing_inode() annotations
      VFS: fs/inode.c helpers: d_inode() annotations
      VFS: fs/cachefiles: d_backing_inode() annotations
      VFS: fs library helpers: d_inode() annotations
      VFS: assorted weird filesystems: d_inode() annotations
      VFS: normal filesystems (and lustre): d_inode() annotations
      VFS: security/: d_inode() annotations
      VFS: security/: d_backing_inode() annotations
      VFS: net/: d_inode() annotations
      VFS: net/unix: d_backing_inode() annotations
      VFS: kernel/: d_inode() annotations
      VFS: audit: d_backing_inode() annotations
      VFS: Fix up some ->d_inode accesses in the chelsio driver
      VFS: Cachefiles should perform fs modifications on the top layer only
      VFS: AF_UNIX sockets should call mknod on the top layer only

commit 2b0143b5c986be1ce8408b3aadc4709e0a94429d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Mar 17 22:25:59 2015 +0000

    VFS: normal filesystems (and lustre): d_inode() annotations
    
    that's the bulk of filesystem drivers dealing with inodes of their own
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 05fef198ff94..68ee619fff45 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -916,7 +916,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 	 * a reference to the dentry.  We will have already gotten a reference
 	 * to the inode in btrfs_fill_super so we're good to go.
 	 */
-	if (!new && sb->s_root->d_inode == inode) {
+	if (!new && d_inode(sb->s_root) == inode) {
 		iput(inode);
 		return dget(sb->s_root);
 	}
@@ -1221,7 +1221,7 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 
 	root = mount_subtree(mnt, subvol_name);
 
-	if (!IS_ERR(root) && !is_subvolume_inode(root->d_inode)) {
+	if (!IS_ERR(root) && !is_subvolume_inode(d_inode(root))) {
 		struct super_block *s = root->d_sb;
 		dput(root);
 		root = ERR_PTR(-EINVAL);
@@ -1886,8 +1886,8 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);
 	buf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);
 	/* Mask in the root object ID too, to disambiguate subvols */
-	buf->f_fsid.val[0] ^= BTRFS_I(dentry->d_inode)->root->objectid >> 32;
-	buf->f_fsid.val[1] ^= BTRFS_I(dentry->d_inode)->root->objectid;
+	buf->f_fsid.val[0] ^= BTRFS_I(d_inode(dentry))->root->objectid >> 32;
+	buf->f_fsid.val[1] ^= BTRFS_I(d_inode(dentry))->root->objectid;
 
 	return 0;
 }

commit 727b9784b6085c99c2f836bf4fcc2848dc9cf904
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Mar 20 14:02:09 2015 -0400

    btrfs: cleanup orphans while looking up default subvolume
    
    Orphans in the fs tree are cleaned up via open_ctree and subvolume
    orphans are cleaned via btrfs_lookup_dentry -- except when a default
    subvolume is in use.  The name for the default subvolume uses a manual
    lookup that doesn't trigger orphan cleanup and needs to trigger it
    manually as well. This doesn't apply to the remount case since the
    subvolumes are cleaned up by walking the root radix tree.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index eb67ca44ad51..f2c9f9db3b19 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -901,6 +901,15 @@ static struct dentry *get_default_root(struct super_block *sb,
 	if (IS_ERR(new_root))
 		return ERR_CAST(new_root);
 
+	if (!(sb->s_flags & MS_RDONLY)) {
+		int ret;
+		down_read(&fs_info->cleanup_work_sem);
+		ret = btrfs_orphan_cleanup(new_root);
+		up_read(&fs_info->cleanup_work_sem);
+		if (ret)
+			return ERR_PTR(ret);
+	}
+
 	dir_id = btrfs_root_dirid(&new_root->root_item);
 setup_root:
 	location.objectid = dir_id;

commit d8620958296e4fa61afde421f1de16a5c2234b28
Author: Tom Van Braeckel <tomvanbraeckel@gmail.com>
Date:   Tue Mar 24 16:35:49 2015 +0100

    btrfs: explicitly set control file's private_data
    
    The private_data member of the Btrfs control device file
    (/dev/btrfs-control) is used to hold the current transaction and needs
    to be initialized to NULL to signify that no transaction is in progress.
    
    We explicitly set the control file's private_data to NULL to be
    independent of whatever value the misc subsystem initializes it to.
    
    Backstory:
    ----------
    
    The misc subsystem (which is used by /dev/btrfs-control) initializes
    a file's private_data to point to the misc device when a driver has
    registered a custom open file operation and initializes it to NULL
    when a custom open file operation has *not* been provided.
    
    This subtle quirk is confusing, to the point where kernel code registers
    *empty* file open operations to have private_data point to the misc
    device structure.
    
    And it leads to bugs, where the addition or removal of a custom open
    file operation surprisingly changes the initial contents of a file's
    private_data structure.
    
    To simplify things in the misc subsystem, a patch [1] has been proposed
    to *always* set private_data to point to the misc device instead of
    only doing this when a custom open file operation has been registered.
    
    But before we can fix this in the misc subsystem itself, we need to
    modify the (few) drivers that rely on this very subtle behavior.
    
    [1] https://lkml.org/lkml/2014/12/4/939
    
    Signed-off-by: Martin Kepplinger <martink@posteo.de>
    Signed-off-by: Tom Van Braeckel <tomvanbraeckel@gmail.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index db7d7b803a61..eb67ca44ad51 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1908,6 +1908,17 @@ static struct file_system_type btrfs_fs_type = {
 };
 MODULE_ALIAS_FS("btrfs");
 
+static int btrfs_control_open(struct inode *inode, struct file *file)
+{
+	/*
+	 * The control file's private_data is used to hold the
+	 * transaction when it is started and is used to keep
+	 * track of whether a transaction is already in progress.
+	 */
+	file->private_data = NULL;
+	return 0;
+}
+
 /*
  * used by btrfsctl to scan devices when no FS is mounted
  */
@@ -2009,6 +2020,7 @@ static const struct super_operations btrfs_super_ops = {
 };
 
 static const struct file_operations btrfs_ctl_fops = {
+	.open = btrfs_control_open,
 	.unlocked_ioctl	 = btrfs_control_ioctl,
 	.compat_ioctl = btrfs_control_ioctl,
 	.owner	 = THIS_MODULE,

commit 9deed229fa8a83bb5cd713b2d2a8e5c022a4b45b
Merge: bc465aa9d045 258ece02126a
Author: Chris Mason <clm@fb.com>
Date:   Wed Mar 25 10:43:16 2015 -0700

    Merge branch 'cleanups-for-4.1-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus-4.1

commit f8c269d7223f6b63cc5936eb191bc3b170d24342
Author: David Sterba <dsterba@suse.cz>
Date:   Fri Jan 16 17:21:12 2015 +0100

    btrfs: cleanup 64bit/32bit divs, compile time constants
    
    Switch to div_u64 if the divisor is a numeric constant or sum of
    sizeof()s. We can remove a few instances of do_div that has the hidden
    semtantics of changing the 1st argument.
    
    Small power-of-two divisors are converted to bitshifts, large values are
    kept intact for clarity.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 100a0442c413..530a0baa7c71 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1704,7 +1704,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 		avail_space = device->total_bytes - device->bytes_used;
 
 		/* align with stripe_len */
-		do_div(avail_space, BTRFS_STRIPE_LEN);
+		avail_space = div_u64(avail_space, BTRFS_STRIPE_LEN);
 		avail_space *= BTRFS_STRIPE_LEN;
 
 		/*

commit 2b9fb532d4168e8974fe49709e2c4c8d5352a64c
Merge: 4533f6e27a36 a742994aa2e2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 19 14:36:00 2015 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "This pull is mostly cleanups and fixes:
    
       - The raid5/6 cleanups from Zhao Lei fixup some long standing warts
         in the code and add improvements on top of the scrubbing support
         from 3.19.
    
       - Josef has round one of our ENOSPC fixes coming from large btrfs
         clusters here at FB.
    
       - Dave Sterba continues a long series of cleanups (thanks Dave), and
         Filipe continues hammering on corner cases in fsync and others
    
      This all was held up a little trying to track down a use-after-free in
      btrfs raid5/6.  It's not clear yet if this is just made easier to
      trigger with this pull or if its a new bug from the raid5/6 cleanups.
      Dave Sterba is the only one to trigger it so far, but he has a
      consistent way to reproduce, so we'll get it nailed shortly"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (68 commits)
      Btrfs: don't remove extents and xattrs when logging new names
      Btrfs: fix fsync data loss after adding hard link to inode
      Btrfs: fix BUG_ON in btrfs_orphan_add() when delete unused block group
      Btrfs: account for large extents with enospc
      Btrfs: don't set and clear delalloc for O_DIRECT writes
      Btrfs: only adjust outstanding_extents when we do a short write
      btrfs: Fix out-of-space bug
      Btrfs: scrub, fix sleep in atomic context
      Btrfs: fix scheduler warning when syncing log
      Btrfs: Remove unnecessary placeholder in btrfs_err_code
      btrfs: cleanup init for list in free-space-cache
      btrfs: delete chunk allocation attemp when setting block group ro
      btrfs: clear bio reference after submit_one_bio()
      Btrfs: fix scrub race leading to use-after-free
      Btrfs: add missing cleanup on sysfs init failure
      Btrfs: fix race between transaction commit and empty block group removal
      btrfs: add more checks to btrfs_read_sys_array
      btrfs: cleanup, rename a few variables in btrfs_read_sys_array
      btrfs: add checks for sys_chunk_array sizes
      btrfs: more superblock checks, lower bounds on devices and sectorsize/nodesize
      ...

commit 730a78c741df4eaa24589015191f03c2d1240091
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Jan 20 19:05:37 2015 +0100

    btrfs: remove a no-op unfreeze superbock callback
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 60f7cbe815e9..100a0442c413 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1948,11 +1948,6 @@ static int btrfs_freeze(struct super_block *sb)
 	return btrfs_commit_transaction(trans, root);
 }
 
-static int btrfs_unfreeze(struct super_block *sb)
-{
-	return 0;
-}
-
 static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(root->d_sb);
@@ -2001,7 +1996,6 @@ static const struct super_operations btrfs_super_ops = {
 	.statfs		= btrfs_statfs,
 	.remount_fs	= btrfs_remount,
 	.freeze_fs	= btrfs_freeze,
-	.unfreeze_fs	= btrfs_unfreeze,
 };
 
 static const struct file_operations btrfs_ctl_fops = {

commit a53f4f8e9c8ebe6c9ee3b34c368913aae9876e22
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 19 15:42:41 2015 +0800

    btrfs: Don't call btrfs_start_transaction() on frozen fs to avoid deadlock.
    
    Commit 6b5fe46dfa52 (btrfs: do commit in sync_fs if there are pending
    changes) will call btrfs_start_transaction() in sync_fs(), to handle
    some operations needed to be done in next transaction.
    
    However this can cause deadlock if the filesystem is frozen, with the
    following sys_r+w output:
    [  143.255932] Call Trace:
    [  143.255936]  [<ffffffff816c0e09>] schedule+0x29/0x70
    [  143.255939]  [<ffffffff811cb7f3>] __sb_start_write+0xb3/0x100
    [  143.255971]  [<ffffffffa040ec06>] start_transaction+0x2e6/0x5a0
    [btrfs]
    [  143.255992]  [<ffffffffa040f1eb>] btrfs_start_transaction+0x1b/0x20
    [btrfs]
    [  143.256003]  [<ffffffffa03dc0ba>] btrfs_sync_fs+0xca/0xd0 [btrfs]
    [  143.256007]  [<ffffffff811f7be0>] sync_fs_one_sb+0x20/0x30
    [  143.256011]  [<ffffffff811cbd01>] iterate_supers+0xe1/0xf0
    [  143.256014]  [<ffffffff811f7d75>] sys_sync+0x55/0x90
    [  143.256017]  [<ffffffff816c49d2>] system_call_fastpath+0x12/0x17
    [  143.256111] Call Trace:
    [  143.256114]  [<ffffffff816c0e09>] schedule+0x29/0x70
    [  143.256119]  [<ffffffff816c3405>] rwsem_down_write_failed+0x1c5/0x2d0
    [  143.256123]  [<ffffffff8133f013>] call_rwsem_down_write_failed+0x13/0x20
    [  143.256131]  [<ffffffff811caae8>] thaw_super+0x28/0xc0
    [  143.256135]  [<ffffffff811db3e5>] do_vfs_ioctl+0x3f5/0x540
    [  143.256187]  [<ffffffff811db5c1>] SyS_ioctl+0x91/0xb0
    [  143.256213]  [<ffffffff816c49d2>] system_call_fastpath+0x12/0x17
    
    The reason is like the following:
    (Holding s_umount)
    VFS sync_fs staff:
    |- btrfs_sync_fs()
       |- btrfs_start_transaction()
          |- sb_start_intwrite()
          (Waiting thaw_fs to unfreeze)
                                            VFS thaw_fs staff:
                                            thaw_fs()
                                            (Waiting sync_fs to release
                                             s_umount)
    
    So deadlock happens.
    This can be easily triggered by fstest/generic/068 with inode_cache
    mount option.
    
    The fix is to check if the fs is frozen, if the fs is frozen, just
    return and waiting for the next transaction.
    
    Cc: David Sterba <dsterba@suse.cz>
    Reported-by: Gui Hecheng <guihc.fnst@cn.fujitsu.com>
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    [enhanced comment, changed to SB_FREEZE_WRITE]
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c86fb5438454..6f49b2872a64 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1000,6 +1000,16 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 			 */
 			if (fs_info->pending_changes == 0)
 				return 0;
+			/*
+			 * A non-blocking test if the fs is frozen. We must not
+			 * start a new transaction here otherwise a deadlock
+			 * happens. The pending operations are delayed to the
+			 * next commit after thawing.
+			 */
+			if (__sb_start_write(sb, SB_FREEZE_WRITE, false))
+				__sb_end_write(sb, SB_FREEZE_WRITE);
+			else
+				return 0;
 			trans = btrfs_start_transaction(root, 0);
 		}
 		if (IS_ERR(trans))

commit 98bd5c547ef2300f915fc1adce5b6f25c195d4d4
Author: David Sterba <dsterba@suse.cz>
Date:   Mon Jan 19 14:21:02 2015 +0100

    btrfs: sync ioctl, handle errors after transaction start
    
    The version merged to 3.19 did not handle errors from start_trancaction
    and could pass an invalid pointer to commit_transaction.
    
    Fixes: 6b5fe46dfa52441f ("btrfs: do commit in sync_fs if there are pending changes")
    Reported-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 60f7cbe815e9..c86fb5438454 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1001,9 +1001,9 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 			if (fs_info->pending_changes == 0)
 				return 0;
 			trans = btrfs_start_transaction(root, 0);
-		} else {
-			return PTR_ERR(trans);
 		}
+		if (IS_ERR(trans))
+			return PTR_ERR(trans);
 	}
 	return btrfs_commit_transaction(trans, root);
 }

commit c92f6be34c501406daf5e61f3569a1813f985393
Author: Filipe Manana <fdmanana@suse.com>
Date:   Wed Nov 26 15:28:55 2014 +0000

    Btrfs: make btrfs_abort_transaction consider existence of new block groups
    
    If the transaction handle doesn't have used blocks but has created new block
    groups make sure we turn the fs into readonly mode too. This is because the
    new block groups didn't get all their metadata persisted into the chunk and
    device trees, and therefore if a subsequent transaction starts, allocates
    space from the new block groups, writes data or metadata into that space,
    commits successfully and then after we unmount and mount the filesystem
    again, the same space can be allocated again for a new block group,
    resulting in file data or metadata corruption.
    
    Example where we don't abort the transaction when we fail to finish the
    chunk allocation (add items to the chunk and device trees) and later a
    future transaction where the block group is removed fails because it can't
    find the chunk item in the chunk tree:
    
    [25230.404300] WARNING: CPU: 0 PID: 7721 at fs/btrfs/super.c:260 __btrfs_abort_transaction+0x50/0xfc [btrfs]()
    [25230.404301] BTRFS: Transaction aborted (error -28)
    [25230.404302] Modules linked in: btrfs dm_flakey nls_utf8 fuse xor raid6_pq ntfs vfat msdos fat xfs crc32c_generic libcrc32c ext3 jbd ext2 dm_mod nfsd auth_rpcgss oid_registry nfs_acl nfs lockd fscache sunrpc loop psmouse i2c_piix4 i2ccore parport_pc parport processor button pcspkr serio_raw thermal_sys evdev microcode ext4 crc16 jbd2 mbcache sr_mod cdrom ata_generic sg sd_mod crc_t10dif crct10dif_generic crct10dif_common virtio_scsi floppy e1000 ata_piix libata virtio_pci virtio_ring scsi_mod virtio [last unloaded: btrfs]
    [25230.404325] CPU: 0 PID: 7721 Comm: xfs_io Not tainted 3.17.0-rc5-btrfs-next-1+ #1
    [25230.404326] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
    [25230.404328]  0000000000000000 ffff88004581bb08 ffffffff813e7a13 ffff88004581bb50
    [25230.404330]  ffff88004581bb40 ffffffff810423aa ffffffffa049386a 00000000ffffffe4
    [25230.404332]  ffffffffa05214c0 000000000000240c ffff88010fc8f800 ffff88004581bba8
    [25230.404334] Call Trace:
    [25230.404338]  [<ffffffff813e7a13>] dump_stack+0x45/0x56
    [25230.404342]  [<ffffffff810423aa>] warn_slowpath_common+0x7f/0x98
    [25230.404351]  [<ffffffffa049386a>] ? __btrfs_abort_transaction+0x50/0xfc [btrfs]
    [25230.404353]  [<ffffffff8104240b>] warn_slowpath_fmt+0x48/0x50
    [25230.404362]  [<ffffffffa049386a>] __btrfs_abort_transaction+0x50/0xfc [btrfs]
    [25230.404374]  [<ffffffffa04a8c43>] btrfs_create_pending_block_groups+0x10c/0x135 [btrfs]
    [25230.404387]  [<ffffffffa04b77fd>] __btrfs_end_transaction+0x7e/0x2de [btrfs]
    [25230.404398]  [<ffffffffa04b7a6d>] btrfs_end_transaction+0x10/0x12 [btrfs]
    [25230.404408]  [<ffffffffa04a3d64>] btrfs_check_data_free_space+0x111/0x1f0 [btrfs]
    [25230.404421]  [<ffffffffa04c53bd>] __btrfs_buffered_write+0x160/0x48d [btrfs]
    [25230.404425]  [<ffffffff811a9268>] ? cap_inode_need_killpriv+0x2d/0x37
    [25230.404429]  [<ffffffff810f6501>] ? get_page+0x1a/0x2b
    [25230.404441]  [<ffffffffa04c7c95>] btrfs_file_write_iter+0x321/0x42f [btrfs]
    [25230.404443]  [<ffffffff8110f5d9>] ? handle_mm_fault+0x7f3/0x846
    [25230.404446]  [<ffffffff813e98c5>] ? mutex_unlock+0x16/0x18
    [25230.404449]  [<ffffffff81138d68>] new_sync_write+0x7c/0xa0
    [25230.404450]  [<ffffffff81139401>] vfs_write+0xb0/0x112
    [25230.404452]  [<ffffffff81139c9d>] SyS_pwrite64+0x66/0x84
    [25230.404454]  [<ffffffff813ebf52>] system_call_fastpath+0x16/0x1b
    [25230.404455] ---[ end trace 5aa5684fdf47ab38 ]---
    [25230.404458] BTRFS warning (device sdc): btrfs_create_pending_block_groups:9228: Aborting unused transaction(No space left).
    [25288.084814] BTRFS: error (device sdc) in btrfs_free_chunk:2509: errno=-2 No such entry (Failed lookup while freeing chunk.)
    
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 391ec4418460..60f7cbe815e9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -262,7 +262,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 	trans->aborted = errno;
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */
-	if (!trans->blocks_used) {
+	if (!trans->blocks_used && list_empty(&trans->new_bgs)) {
 		const char *errstr;
 
 		errstr = btrfs_decode_error(errno);

commit ad27c0dab76a7abc8809ec41ae59cf67de5ea906
Merge: b38ef71cb102 a6f69dc8018d
Author: Chris Mason <clm@fb.com>
Date:   Tue Nov 25 05:45:30 2014 -0800

    Merge branch 'dev/pending-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux into for-linus

commit 0d95c1bec906dd1ad951c9c001e798ca52baeb0f
Author: David Sterba <dsterba@suse.cz>
Date:   Fri Nov 14 15:05:06 2014 +0100

    btrfs: fix wrong accounting of raid1 data profile in statfs
    
    The sizes that are obtained from space infos are in raw units and have
    to be adjusted according to the raid factor. This was missing for
    f_bavail and df reported doubled size for raid1.
    
    Reported-by: Martin Steigerwald <Martin@lichtvoll.de>
    Fixes: ba7b6e62f420 ("btrfs: adjust statfs calculations according to raid profiles")
    CC: stable@vger.kernel.org
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index dc337d14ef5c..21c60ee2f664 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1851,7 +1851,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_bfree -= block_rsv->size >> bits;
 	spin_unlock(&block_rsv->lock);
 
-	buf->f_bavail = total_free_data;
+	buf->f_bavail = div_u64(total_free_data, factor);
 	ret = btrfs_calc_avail_data_space(fs_info->tree_root, &total_free_data);
 	if (ret)
 		return ret;

commit 7e33fd993a74b3fda39c756803ba8b24bef72df5
Author: Josef Bacik <jbacik@fb.com>
Date:   Mon Nov 3 08:56:50 2014 -0500

    Btrfs: don't take the chunk_mutex/dev_list mutex in statfs V2
    
    Our gluster boxes get several thousand statfs() calls per second, which begins
    to suck hardcore with all of the lock contention on the chunk mutex and dev list
    mutex.  We don't really need to hold these things, if we have transient
    weirdness with statfs() because of the chunk allocator we don't care, so remove
    this locking.
    
    We still need the dev_list lock if you mount with -o alloc_start however, which
    is a good argument for nuking that thing from orbit, but that's a patch for
    another day.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 54bd91ece35b..dc337d14ef5c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1644,8 +1644,20 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	int i = 0, nr_devices;
 	int ret;
 
+	/*
+	 * We aren't under the device list lock, so this is racey-ish, but good
+	 * enough for our purposes.
+	 */
 	nr_devices = fs_info->fs_devices->open_devices;
-	BUG_ON(!nr_devices);
+	if (!nr_devices) {
+		smp_mb();
+		nr_devices = fs_info->fs_devices->open_devices;
+		ASSERT(nr_devices);
+		if (!nr_devices) {
+			*free_bytes = 0;
+			return 0;
+		}
+	}
 
 	devices_info = kmalloc_array(nr_devices, sizeof(*devices_info),
 			       GFP_NOFS);
@@ -1670,11 +1682,17 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	else
 		min_stripe_size = BTRFS_STRIPE_LEN;
 
-	list_for_each_entry(device, &fs_devices->devices, dev_list) {
+	if (fs_info->alloc_start)
+		mutex_lock(&fs_devices->device_list_mutex);
+	rcu_read_lock();
+	list_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {
 		if (!device->in_fs_metadata || !device->bdev ||
 		    device->is_tgtdev_for_dev_replace)
 			continue;
 
+		if (i >= nr_devices)
+			break;
+
 		avail_space = device->total_bytes - device->bytes_used;
 
 		/* align with stripe_len */
@@ -1689,24 +1707,32 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 		skip_space = 1024 * 1024;
 
 		/* user can set the offset in fs_info->alloc_start. */
-		if (fs_info->alloc_start + BTRFS_STRIPE_LEN <=
-		    device->total_bytes)
+		if (fs_info->alloc_start &&
+		    fs_info->alloc_start + BTRFS_STRIPE_LEN <=
+		    device->total_bytes) {
+			rcu_read_unlock();
 			skip_space = max(fs_info->alloc_start, skip_space);
 
-		/*
-		 * btrfs can not use the free space in [0, skip_space - 1],
-		 * we must subtract it from the total. In order to implement
-		 * it, we account the used space in this range first.
-		 */
-		ret = btrfs_account_dev_extents_size(device, 0, skip_space - 1,
-						     &used_space);
-		if (ret) {
-			kfree(devices_info);
-			return ret;
-		}
+			/*
+			 * btrfs can not use the free space in
+			 * [0, skip_space - 1], we must subtract it from the
+			 * total. In order to implement it, we account the used
+			 * space in this range first.
+			 */
+			ret = btrfs_account_dev_extents_size(device, 0,
+							     skip_space - 1,
+							     &used_space);
+			if (ret) {
+				kfree(devices_info);
+				mutex_unlock(&fs_devices->device_list_mutex);
+				return ret;
+			}
 
-		/* calc the free space in [0, skip_space - 1] */
-		skip_space -= used_space;
+			rcu_read_lock();
+
+			/* calc the free space in [0, skip_space - 1] */
+			skip_space -= used_space;
+		}
 
 		/*
 		 * we can use the free space in [0, skip_space - 1], subtract
@@ -1725,6 +1751,9 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 
 		i++;
 	}
+	rcu_read_unlock();
+	if (fs_info->alloc_start)
+		mutex_unlock(&fs_devices->device_list_mutex);
 
 	nr_devices = i;
 
@@ -1787,8 +1816,6 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	 * holding chunk_muext to avoid allocating new chunks, holding
 	 * device_list_mutex to avoid the device being removed
 	 */
-	mutex_lock(&fs_info->fs_devices->device_list_mutex);
-	mutex_lock(&fs_info->chunk_mutex);
 	rcu_read_lock();
 	list_for_each_entry_rcu(found, head, list) {
 		if (found->flags & BTRFS_BLOCK_GROUP_DATA) {
@@ -1826,15 +1853,10 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 	buf->f_bavail = total_free_data;
 	ret = btrfs_calc_avail_data_space(fs_info->tree_root, &total_free_data);
-	if (ret) {
-		mutex_unlock(&fs_info->chunk_mutex);
-		mutex_unlock(&fs_info->fs_devices->device_list_mutex);
+	if (ret)
 		return ret;
-	}
 	buf->f_bavail += div_u64(total_free_data, factor);
 	buf->f_bavail = buf->f_bavail >> bits;
-	mutex_unlock(&fs_info->chunk_mutex);
-	mutex_unlock(&fs_info->fs_devices->device_list_mutex);
 
 	buf->f_type = BTRFS_SUPER_MAGIC;
 	buf->f_bsize = dentry->d_sb->s_blocksize;

commit 7e1876aca815029d5c3023a66a91e249eca3e533
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Feb 5 15:26:17 2014 +0100

    btrfs: switch inode_cache option handling to pending changes
    
    The pending mount option(s) now share namespace and bits with the normal
    options, and the existing one for (inode_cache) is unset unconditionally
    at each transaction commit.
    
    Introduce a separate namespace for pending changes and enhance the
    descriptions of the intended change to use separate bits for each
    action.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1da16d59e115..65c75d9e9750 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -642,11 +642,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 					     "disabling disk space caching");
 			break;
 		case Opt_inode_cache:
-			btrfs_set_and_info(root, CHANGE_INODE_CACHE,
+			btrfs_set_pending_and_info(info, INODE_MAP_CACHE,
 					   "enabling inode map caching");
 			break;
 		case Opt_noinode_cache:
-			btrfs_clear_and_info(root, CHANGE_INODE_CACHE,
+			btrfs_clear_pending_and_info(info, INODE_MAP_CACHE,
 					     "disabling inode map caching");
 			break;
 		case Opt_clear_cache:

commit 6b5fe46dfa52441f49c7432b1c1b1cb767834708
Author: David Sterba <dsterba@suse.cz>
Date:   Fri Mar 28 17:38:48 2014 +0100

    btrfs: do commit in sync_fs if there are pending changes
    
    If a pending change is requested, it's not processed unless there is a
    transaction commit about to happen, not even after sync or SYNC_FS
    ioctl. For example a remount that toggles the inode_cache option will
    not take effect after sync on a quiescent filesystem.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 54bd91ece35b..1da16d59e115 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -993,9 +993,17 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {
 		/* no transaction, don't bother */
-		if (PTR_ERR(trans) == -ENOENT)
-			return 0;
-		return PTR_ERR(trans);
+		if (PTR_ERR(trans) == -ENOENT) {
+			/*
+			 * Exit unless we have some pending changes
+			 * that need to go through commit
+			 */
+			if (fs_info->pending_changes == 0)
+				return 0;
+			trans = btrfs_start_transaction(root, 0);
+		} else {
+			return PTR_ERR(trans);
+		}
 	}
 	return btrfs_commit_transaction(trans, root);
 }

commit 5ed5f5884116e3841da626d201ef068f23232a3a
Author: Josef Bacik <jbacik@fb.com>
Date:   Wed Oct 15 17:19:59 2014 -0400

    Btrfs: properly clean up btrfs_end_io_wq_cache
    
    In one of Dave's cleanup commits he forgot to call btrfs_end_io_wq_exit on
    unload, which makes us unable to unload and then re-load the btrfs module.  This
    fixes the problem.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Reviewed-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a2b97ef10317..54bd91ece35b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2151,6 +2151,7 @@ static void __exit exit_btrfs_fs(void)
 	extent_map_exit();
 	extent_io_exit();
 	btrfs_interface_exit();
+	btrfs_end_io_wq_exit();
 	unregister_filesystem(&btrfs_fs_type);
 	btrfs_exit_sysfs();
 	btrfs_cleanup_fs_uuids();

commit a43bb39b5c710e79e921fb76341bacc418cfde78
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Wed Oct 8 10:19:08 2014 +0800

    btrfs: Fix compile error when CONFIG_SECURITY is not set.
    
    Fix the following compile error when CONFIG_SECURITY is not set:
    
    error: 'struct security_mnt_opts' has no member named 'num_mnt_opts'
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 22502848c27f..a2b97ef10317 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1248,6 +1248,7 @@ static int setup_security_options(struct btrfs_fs_info *fs_info,
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_SECURITY
 	if (!fs_info->security_opts.num_mnt_opts) {
 		/* first time security setup, copy sec_opts to fs_info */
 		memcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));
@@ -1260,6 +1261,7 @@ static int setup_security_options(struct btrfs_fs_info *fs_info,
 		 */
 		security_free_mnt_opts(sec_opts);
 	}
+#endif
 	return ret;
 }
 

commit f667aef6af626d0cdce0204bc7a2888e62076525
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Tue Sep 23 13:40:08 2014 +0800

    btrfs: Make btrfs handle security mount options internally to avoid losing security label.
    
    [BUG]
    Originally when mount btrfs with "-o subvol=" mount option, btrfs will
    lose all security lable.
    And if the btrfs fs is mounted somewhere else, due to the lost of
    security lable, SELinux will refuse to mount since the same super block
    is being mounted using different security lable.
    
    [REPRODUCER]
    With SELinux enabled:
     #mkfs -t btrfs /dev/sda5
     #mount -o context=system_u:object_r:nfs_t:s0 /dev/sda5 /mnt/btrfs
     #btrfs subvolume create /mnt/btrfs/subvol
     #mount -o subvol=subvol,context=system_u:object_r:nfs_t:s0 /dev/sda5
      /mnt/test
    
    kernel message:
    SELinux: mount invalid.  Same superblock, different security settings
    for (dev sda5, type btrfs)
    
    [REASON]
    This happens because btrfs will call vfs_kern_mount() and then
    mount_subtree() to handle subvolume name lookup.
    First mount will cut off all the security lables and when it comes to
    the second vfs_kern_mount(), it has no security label now.
    
    [FIX]
    This patch will makes btrfs behavior much more like nfs,
    which has the type flag FS_BINARY_MOUNTDATA,
    making btrfs handles the security label internally.
    So security label will be set in the real mount time and won't lose
    label when use with "subvol=" mount option.
    
    Reported-by: Eryu Guan <guaneryu@gmail.com>
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4685b9704f15..22502848c27f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1215,6 +1215,54 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 	return root;
 }
 
+static int parse_security_options(char *orig_opts,
+				  struct security_mnt_opts *sec_opts)
+{
+	char *secdata = NULL;
+	int ret = 0;
+
+	secdata = alloc_secdata();
+	if (!secdata)
+		return -ENOMEM;
+	ret = security_sb_copy_data(orig_opts, secdata);
+	if (ret) {
+		free_secdata(secdata);
+		return ret;
+	}
+	ret = security_sb_parse_opts_str(secdata, sec_opts);
+	free_secdata(secdata);
+	return ret;
+}
+
+static int setup_security_options(struct btrfs_fs_info *fs_info,
+				  struct super_block *sb,
+				  struct security_mnt_opts *sec_opts)
+{
+	int ret = 0;
+
+	/*
+	 * Call security_sb_set_mnt_opts() to check whether new sec_opts
+	 * is valid.
+	 */
+	ret = security_sb_set_mnt_opts(sb, sec_opts, 0, NULL);
+	if (ret)
+		return ret;
+
+	if (!fs_info->security_opts.num_mnt_opts) {
+		/* first time security setup, copy sec_opts to fs_info */
+		memcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));
+	} else {
+		/*
+		 * Since SELinux(the only one supports security_mnt_opts) does
+		 * NOT support changing context during remount/mount same sb,
+		 * This must be the same or part of the same security options,
+		 * just free it.
+		 */
+		security_free_mnt_opts(sec_opts);
+	}
+	return ret;
+}
+
 /*
  * Find a superblock for the given device / mount point.
  *
@@ -1229,6 +1277,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	struct dentry *root;
 	struct btrfs_fs_devices *fs_devices = NULL;
 	struct btrfs_fs_info *fs_info = NULL;
+	struct security_mnt_opts new_sec_opts;
 	fmode_t mode = FMODE_READ;
 	char *subvol_name = NULL;
 	u64 subvol_objectid = 0;
@@ -1251,9 +1300,16 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		return root;
 	}
 
+	security_init_mnt_opts(&new_sec_opts);
+	if (data) {
+		error = parse_security_options(data, &new_sec_opts);
+		if (error)
+			return ERR_PTR(error);
+	}
+
 	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
 	if (error)
-		return ERR_PTR(error);
+		goto error_sec_opts;
 
 	/*
 	 * Setup a dummy root and fs_info for test/set super.  This is because
@@ -1262,13 +1318,16 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	 * then open_ctree will properly initialize everything later.
 	 */
 	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_NOFS);
-	if (!fs_info)
-		return ERR_PTR(-ENOMEM);
+	if (!fs_info) {
+		error = -ENOMEM;
+		goto error_sec_opts;
+	}
 
 	fs_info->fs_devices = fs_devices;
 
 	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
 	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
+	security_init_mnt_opts(&fs_info->security_opts);
 	if (!fs_info->super_copy || !fs_info->super_for_commit) {
 		error = -ENOMEM;
 		goto error_fs_info;
@@ -1306,8 +1365,19 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	}
 
 	root = !error ? get_default_root(s, subvol_objectid) : ERR_PTR(error);
-	if (IS_ERR(root))
+	if (IS_ERR(root)) {
+		deactivate_locked_super(s);
+		error = PTR_ERR(root);
+		goto error_sec_opts;
+	}
+
+	fs_info = btrfs_sb(s);
+	error = setup_security_options(fs_info, s, &new_sec_opts);
+	if (error) {
+		dput(root);
 		deactivate_locked_super(s);
+		goto error_sec_opts;
+	}
 
 	return root;
 
@@ -1315,6 +1385,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	btrfs_close_devices(fs_devices);
 error_fs_info:
 	free_fs_info(fs_info);
+error_sec_opts:
+	security_free_mnt_opts(&new_sec_opts);
 	return ERR_PTR(error);
 }
 
@@ -1396,6 +1468,21 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	sync_filesystem(sb);
 	btrfs_remount_prepare(fs_info);
 
+	if (data) {
+		struct security_mnt_opts new_sec_opts;
+
+		security_init_mnt_opts(&new_sec_opts);
+		ret = parse_security_options(data, &new_sec_opts);
+		if (ret)
+			goto restore;
+		ret = setup_security_options(fs_info, sb,
+					     &new_sec_opts);
+		if (ret) {
+			security_free_mnt_opts(&new_sec_opts);
+			goto restore;
+		}
+	}
+
 	ret = btrfs_parse_options(root, data);
 	if (ret) {
 		ret = -EINVAL;
@@ -1775,7 +1862,7 @@ static struct file_system_type btrfs_fs_type = {
 	.name		= "btrfs",
 	.mount		= btrfs_mount,
 	.kill_sb	= btrfs_kill_super,
-	.fs_flags	= FS_REQUIRES_DEV,
+	.fs_flags	= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,
 };
 MODULE_ALIAS_FS("btrfs");
 

commit 97eb6b69d1e856cb5e1cf2c3d94afab643e93128
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Jul 30 00:55:42 2014 +0200

    btrfs: use slab for end_io_wq structures
    
    The structure is frequently reused.  Rename it according to the slab
    name.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b915d7704f19..4685b9704f15 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2001,10 +2001,14 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_delayed_ref;
 
-	err = btrfs_interface_init();
+	err = btrfs_end_io_wq_init();
 	if (err)
 		goto free_prelim_ref;
 
+	err = btrfs_interface_init();
+	if (err)
+		goto free_end_io_wq;
+
 	btrfs_init_lockdep();
 
 	btrfs_print_info();
@@ -2021,6 +2025,8 @@ static int __init init_btrfs_fs(void)
 
 unregister_ioctl:
 	btrfs_interface_exit();
+free_end_io_wq:
+	btrfs_end_io_wq_exit();
 free_prelim_ref:
 	btrfs_prelim_ref_exit();
 free_delayed_ref:

commit af13b4922b057b4ebc7e2315a6f666ecb65890e4
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Jul 30 00:58:37 2014 +0200

    btrfs: fix error labels in init_btrfs_fs
    
    btrfs_interface_init rarely fails but we could leak the prelim_ref slab.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b1d2a42f379d..b915d7704f19 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1999,11 +1999,11 @@ static int __init init_btrfs_fs(void)
 
 	err = btrfs_prelim_ref_init();
 	if (err)
-		goto free_prelim_ref;
+		goto free_delayed_ref;
 
 	err = btrfs_interface_init();
 	if (err)
-		goto free_delayed_ref;
+		goto free_prelim_ref;
 
 	btrfs_init_lockdep();
 

commit 95ac567af212db3293af3897ccb521efdf1dd7ff
Author: Filipe David Borba Manana <fdmanana@gmail.com>
Date:   Thu Aug 8 22:45:48 2013 +0100

    Btrfs: set default max_inline to 8KiB instead of 8MiB
    
    8MiB is way too large and likely set by mistake. This is not
    a significant issue as in practice the max amount of data
    added to an inline extent is also limited by the page cache
    and btree leaf sizes.
    
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1c6da8e00c1b..b1d2a42f379d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1014,7 +1014,7 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",nodatacow");
 	if (btrfs_test_opt(root, NOBARRIER))
 		seq_puts(seq, ",nobarrier");
-	if (info->max_inline != 8192 * 1024)
+	if (info->max_inline != BTRFS_DEFAULT_MAX_INLINE)
 		seq_printf(seq, ",max_inline=%llu", info->max_inline);
 	if (info->alloc_start != 0)
 		seq_printf(seq, ",alloc_start=%llu", info->alloc_start);

commit 143f363618558478fd7b5156c343d21e74194987
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Jul 29 17:41:08 2014 +0200

    btrfs: remove unused variable from btrfs_parse_options
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2375f94fb780..1c6da8e00c1b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -395,7 +395,6 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	int ret = 0;
 	char *compress_type;
 	bool compress_force = false;
-	bool compress = false;
 
 	cache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);
 	if (cache_gen)
@@ -473,7 +472,6 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			/* Fallthrough */
 		case Opt_compress:
 		case Opt_compress_type:
-			compress = true;
 			if (token == Opt_compress ||
 			    token == Opt_compress_force ||
 			    strcmp(args[0].from, "zlib") == 0) {
@@ -503,7 +501,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				btrfs_set_and_info(root, FORCE_COMPRESS,
 						   "force %s compression",
 						   compress_type);
-			} else if (compress) {
+			} else {
 				if (!btrfs_test_opt(root, COMPRESS))
 					btrfs_info(root->fs_info,
 						   "btrfs: use %s compression",

commit 15484377f597ca98ee84de87caa13667ea68bb14
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Sep 3 21:35:40 2014 +0800

    Btrfs: fix unprotected device list access when getting the fs information
    
    When we get the fs information, we forgot to acquire the mutex of device list,
    it might cause the problem we might access a device that was removed. Fix
    it by acquiring the device list mutex.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3f1f4e2dc78f..2375f94fb780 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1696,7 +1696,11 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;
 	int ret;
 
-	/* holding chunk_muext to avoid allocating new chunks */
+	/*
+	 * holding chunk_muext to avoid allocating new chunks, holding
+	 * device_list_mutex to avoid the device being removed
+	 */
+	mutex_lock(&fs_info->fs_devices->device_list_mutex);
 	mutex_lock(&fs_info->chunk_mutex);
 	rcu_read_lock();
 	list_for_each_entry_rcu(found, head, list) {
@@ -1737,11 +1741,13 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	ret = btrfs_calc_avail_data_space(fs_info->tree_root, &total_free_data);
 	if (ret) {
 		mutex_unlock(&fs_info->chunk_mutex);
+		mutex_unlock(&fs_info->fs_devices->device_list_mutex);
 		return ret;
 	}
 	buf->f_bavail += div_u64(total_free_data, factor);
 	buf->f_bavail = buf->f_bavail >> bits;
 	mutex_unlock(&fs_info->chunk_mutex);
+	mutex_unlock(&fs_info->fs_devices->device_list_mutex);
 
 	buf->f_type = BTRFS_SUPER_MAGIC;
 	buf->f_bsize = dentry->d_sb->s_blocksize;

commit d3982100baeb9bed8cf931545fb0522268f526e5
Author: Mark Fasheh <mfasheh@suse.de>
Date:   Thu Jul 17 12:39:00 2014 -0700

    btrfs: add trace for qgroup accounting
    
    We want this to debug qgroup changes on live systems.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.de>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d66fbd57f1b5..3f1f4e2dc78f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -60,6 +60,7 @@
 #include "backref.h"
 #include "tests/btrfs-tests.h"
 
+#include "qgroup.h"
 #define CREATE_TRACE_POINTS
 #include <trace/events/btrfs.h>
 

commit 4027e0f4c4b2df28d564560a3c65c179bebae4c8
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Mon Jun 30 10:51:25 2014 +0800

    Btrfs: clear compress-force when remounting with compress option
    
    Steps to reproduce:
     # mkfs.btrfs -f /dev/sdb
     # mount /dev/sdb /mnt -o compress-force=lzo
     # mount /dev/sdb /mnt -o remount,compress=zlib
     # cat /proc/mounts
    
    Remounting from compress-force to compress could not clear compress-force
    option. The problem is there is no way for users to clear compress-force
    option separately.
    
    Fix this problem by clearing @FORCE_COMPRESS flag when remounting to
    compress=xxx.
    
    Suggested-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Reviewed-by: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
    Tested-by: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 568ddc16119f..d66fbd57f1b5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -507,6 +507,13 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 					btrfs_info(root->fs_info,
 						   "btrfs: use %s compression",
 						   compress_type);
+				/*
+				 * If we remount from compress-force=xxx to
+				 * compress=xxx, we need clear FORCE_COMPRESS
+				 * flag, otherwise, there is no way for users
+				 * to disable forcible compression separately.
+				 */
+				btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
 			}
 			break;
 		case Opt_ssd:

commit 3abdbd780e9d75f0648b8a502c3789857b1e92ce
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Jun 4 18:10:45 2014 +0200

    btrfs: make close_ctree return void
    
    There's no user of the return value and we can get rid of the comment in
    put_super.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c4124de4435b..568ddc16119f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -307,13 +307,7 @@ void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 
 static void btrfs_put_super(struct super_block *sb)
 {
-	(void)close_ctree(btrfs_sb(sb)->tree_root);
-	/* FIXME: need to fix VFS to return error? */
-	/* AV: return it _where_?  ->put_super() can be triggered by any number
-	 * of async events, up to and including delivery of SIGKILL to the
-	 * last process that kept it busy.  Or segfault in the aforementioned
-	 * process...  Whom would you report that to?
-	 */
+	close_ctree(btrfs_sb(sb)->tree_root);
 }
 
 enum {

commit e64df3ebe8262c8203d1fe4f541e0241c3112c01
Merge: 53b95d6341c1 8d875f95da43
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 16 09:06:55 2014 -0600

    Merge branch 'for-linus2' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs updates from Chris Mason:
     "These are all fixes I'd like to get out to a broader audience.
    
      The biggest of the bunch is Mark's quota fix, which is also in the
      SUSE kernel, and makes our subvolume quotas dramatically more
      accurate.
    
      I've been running xfstests with these against your current git
      overnight, but I'm queueing up longer tests as well"
    
    * 'for-linus2' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs:
      btrfs: disable strict file flushes for renames and truncates
      Btrfs: fix csum tree corruption, duplicate and outdated checksums
      Btrfs: Fix memory corruption by ulist_add_merge() on 32bit arch
      Btrfs: fix compressed write corruption on enospc
      btrfs: correctly handle return from ulist_add
      btrfs: qgroup: account shared subtrees during snapshot delete
      Btrfs: read lock extent buffer while walking backrefs
      Btrfs: __btrfs_mod_ref should always use no_quota
      btrfs: adjust statfs calculations according to raid profiles

commit ba7b6e62f420f5a8832bc161ab0c7ba767f65b3d
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Jul 1 16:21:33 2014 +0200

    btrfs: adjust statfs calculations according to raid profiles
    
    This has been discussed in thread:
    http://thread.gmane.org/gmane.comp.file-systems.btrfs/32528
    
    and this patch implements this proposal:
    http://thread.gmane.org/gmane.comp.file-systems.btrfs/32536
    
    Works fine for "clean" raid profiles where the raid factor correction
    does the right job. Otherwise it's pessimistic and may show low space
    although there's still some left.
    
    The df nubmers are lightly wrong in case of mixed block groups, but this
    is not a major usecase and can be addressed later.
    
    The RAID56 numbers are wrong almost the same way as before and will be
    addressed separately.
    
    CC: Hugo Mills <hugo@carfax.org.uk>
    CC: cwillu <cwillu@cwillu.com>
    CC: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8e16bca69c56..18cdcd1dbe11 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1672,6 +1672,21 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	return 0;
 }
 
+/*
+ * Calculate numbers for 'df', pessimistic in case of mixed raid profiles.
+ *
+ * If there's a redundant raid level at DATA block groups, use the respective
+ * multiplier to scale the sizes.
+ *
+ * Unused device space usage is based on simulating the chunk allocator
+ * algorithm that respects the device sizes, order of allocations and the
+ * 'alloc_start' value, this is a close approximation of the actual use but
+ * there are other factors that may change the result (like a new metadata
+ * chunk).
+ *
+ * FIXME: not accurate for mixed block groups, total and free/used are ok,
+ * available appears slightly larger.
+ */
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(dentry->d_sb);
@@ -1682,6 +1697,8 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	u64 total_free_data = 0;
 	int bits = dentry->d_sb->s_blocksize_bits;
 	__be32 *fsid = (__be32 *)fs_info->fsid;
+	unsigned factor = 1;
+	struct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;
 	int ret;
 
 	/* holding chunk_muext to avoid allocating new chunks */
@@ -1689,30 +1706,52 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	rcu_read_lock();
 	list_for_each_entry_rcu(found, head, list) {
 		if (found->flags & BTRFS_BLOCK_GROUP_DATA) {
+			int i;
+
 			total_free_data += found->disk_total - found->disk_used;
 			total_free_data -=
 				btrfs_account_ro_block_groups_free_space(found);
+
+			for (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {
+				if (!list_empty(&found->block_groups[i])) {
+					switch (i) {
+					case BTRFS_RAID_DUP:
+					case BTRFS_RAID_RAID1:
+					case BTRFS_RAID_RAID10:
+						factor = 2;
+					}
+				}
+			}
 		}
 
 		total_used += found->disk_used;
 	}
+
 	rcu_read_unlock();
 
-	buf->f_namelen = BTRFS_NAME_LEN;
-	buf->f_blocks = btrfs_super_total_bytes(disk_super) >> bits;
-	buf->f_bfree = buf->f_blocks - (total_used >> bits);
-	buf->f_bsize = dentry->d_sb->s_blocksize;
-	buf->f_type = BTRFS_SUPER_MAGIC;
+	buf->f_blocks = div_u64(btrfs_super_total_bytes(disk_super), factor);
+	buf->f_blocks >>= bits;
+	buf->f_bfree = buf->f_blocks - (div_u64(total_used, factor) >> bits);
+
+	/* Account global block reserve as used, it's in logical size already */
+	spin_lock(&block_rsv->lock);
+	buf->f_bfree -= block_rsv->size >> bits;
+	spin_unlock(&block_rsv->lock);
+
 	buf->f_bavail = total_free_data;
 	ret = btrfs_calc_avail_data_space(fs_info->tree_root, &total_free_data);
 	if (ret) {
 		mutex_unlock(&fs_info->chunk_mutex);
 		return ret;
 	}
-	buf->f_bavail += total_free_data;
+	buf->f_bavail += div_u64(total_free_data, factor);
 	buf->f_bavail = buf->f_bavail >> bits;
 	mutex_unlock(&fs_info->chunk_mutex);
 
+	buf->f_type = BTRFS_SUPER_MAGIC;
+	buf->f_bsize = dentry->d_sb->s_blocksize;
+	buf->f_namelen = BTRFS_NAME_LEN;
+
 	/* We treat it as constant endianness (it doesn't matter _which_)
 	   because we want the fsid to come out the same whether mounted
 	   on a big-endian or little-endian host */

commit 1a0a397e41cb1bf70cfe45fd0eeff08c7c501ec0
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Feb 14 17:35:37 2014 -0500

    dcache: d_obtain_alias callers don't all want DISCONNECTED
    
    There are a few d_obtain_alias callers that are using it to get the
    root of a filesystem which may already have an alias somewhere else.
    
    This is not the same as the filehandle-lookup case, and none of them
    actually need DCACHE_DISCONNECTED set.
    
    It isn't really a serious problem, but it would really be clearer if we
    reserved DCACHE_DISCONNECTED for those cases where it's actually needed.
    
    In the btrfs case this was causing a spurious printk from
    nfsd/nfsfh.c:fh_verify when it found an unexpected DCACHE_DISCONNECTED
    dentry.  Josef worked around this by unsetting DCACHE_DISCONNECTED
    manually in 3a0dfa6a12e "Btrfs: unset DCACHE_DISCONNECTED when mounting
    default subvol", and this replaces that workaround.
    
    Cc: Josef Bacik <jbacik@fb.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8e16bca69c56..67b48b9a03e0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -851,7 +851,6 @@ static struct dentry *get_default_root(struct super_block *sb,
 	struct btrfs_path *path;
 	struct btrfs_key location;
 	struct inode *inode;
-	struct dentry *dentry;
 	u64 dir_id;
 	int new = 0;
 
@@ -922,13 +921,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 		return dget(sb->s_root);
 	}
 
-	dentry = d_obtain_alias(inode);
-	if (!IS_ERR(dentry)) {
-		spin_lock(&dentry->d_lock);
-		dentry->d_flags &= ~DCACHE_DISCONNECTED;
-		spin_unlock(&dentry->d_lock);
-	}
-	return dentry;
+	return d_obtain_root(inode);
 }
 
 static int btrfs_fill_super(struct super_block *sb,

commit 0aeb8a6e67cddeac1d42cf64795fde0641a1cffb
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Mon Jun 30 17:12:48 2014 +0800

    btrfs: fix null pointer dereference in btrfs_show_devname when name is null
    
    dev->name is null but missing flag is not set.
    Strictly speaking the missing flag should have been set, but there
    are more places where code just checks if name is null. For now this
    patch does the same.
    
    stack:
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000064
    IP: [<ffffffffa0228908>] btrfs_show_devname+0x58/0xf0 [btrfs]
    
    [<ffffffff81198879>] show_vfsmnt+0x39/0x130
    [<ffffffff81178056>] m_show+0x16/0x20
    [<ffffffff8117d706>] seq_read+0x296/0x390
    [<ffffffff8115aa7d>] vfs_read+0x9d/0x160
    [<ffffffff8115b549>] SyS_read+0x49/0x90
    [<ffffffff817abe52>] system_call_fastpath+0x16/0x1b
    
    reproducer:
    mkfs.btrfs -draid1 -mraid1 /dev/sdg1 /dev/sdg2
    btrfstune -S 1 /dev/sdg1
    modprobe -r btrfs && modprobe btrfs
    mount -o degraded /dev/sdg1 /btrfs
    btrfs dev add /dev/sdg3 /btrfs
    
    Signed-off-by: Anand Jain <Anand.Jain@oracle.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0927e463afca..8e16bca69c56 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1811,6 +1811,8 @@ static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 		list_for_each_entry(dev, head, dev_list) {
 			if (dev->missing)
 				continue;
+			if (!dev->name)
+				continue;
 			if (!first_dev || dev->devid < first_dev->devid)
 				first_dev = dev;
 		}

commit 2aa06a35d06a34b3109bdbf1d653de1695dc8f12
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Fri Jun 27 16:50:31 2014 -0500

    btrfs: fix nossd and ssd_spread mount option regression
    
    The commit
    
    0780253 btrfs: Cleanup the btrfs_parse_options for remount.
    
    broke ssd options quite badly; it stopped making ssd_spread
    imply ssd, and it made "nossd" unsettable.
    
    Put things back at least as well as they were before
    (though ssd mount option handling is still pretty odd:
    # mount -o "nossd,ssd_spread" works?)
    
    Reported-by: Roman Mamedov <rm@romanrm.net>
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b6ebde231de7..0927e463afca 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -522,9 +522,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_ssd_spread:
 			btrfs_set_and_info(root, SSD_SPREAD,
 					   "use spread ssd allocation scheme");
+			btrfs_set_opt(info->mount_opt, SSD);
 			break;
 		case Opt_nossd:
-			btrfs_clear_and_info(root, NOSSD,
+			btrfs_set_and_info(root, NOSSD,
 					     "not using ssd allocation scheme");
 			btrfs_clear_opt(info->mount_opt, SSD);
 			break;

commit 5f3164813b90f7dbcb5c3ab9006906222ce471b7
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Thu Jun 26 11:08:16 2014 +0800

    Btrfs: fix race between balance recovery and root deletion
    
    Balance recovery is called when RW mounting or remounting from
    RO to RW, it is called to finish roots merging.
    
    When doing balance recovery, relocation root's corresponding
    fs root(whose root refs is 0) might be destroyed by cleaner
    thread, this will make btrfs fail to mount.
    
    Fix this problem by holding @cleaner_mutex when doing balance
    recovery.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4662d92a4b73..b6ebde231de7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1467,7 +1467,9 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 			goto restore;
 
 		/* recover relocation */
+		mutex_lock(&fs_info->cleaner_mutex);
 		ret = btrfs_recover_relocation(root);
+		mutex_unlock(&fs_info->cleaner_mutex);
 		if (ret)
 			goto restore;
 

commit 351fd3532159441e810d458a5b681090ff8449fd
Author: David Sterba <dsterba@suse.cz>
Date:   Thu May 15 16:48:20 2014 +0200

    btrfs: remove stale newlines from log messages
    
    I've noticed an extra line after "use no compression", but search
    revealed much more in messages of more critical levels and rare errors.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 77fcb5706700..4662d92a4b73 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -511,7 +511,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			} else if (compress) {
 				if (!btrfs_test_opt(root, COMPRESS))
 					btrfs_info(root->fs_info,
-						   "btrfs: use %s compression\n",
+						   "btrfs: use %s compression",
 						   compress_type);
 			}
 			break;

commit 45ff35d6b9f301cbfb6b1703466ebe4431c7567f
Author: Guangliang Zhao <lucienchao@gmail.com>
Date:   Mon May 12 11:04:33 2014 +0800

    Btrfs: remove OPT_acl parse when acl disabled
    
    Even CONFIG_BTRFS_FS_POSIX_ACL is not defined, the acl still could
    been enabled using a mount option, and now fs/btrfs/acl.o is not
    built, so the mount options will appear to be supported but will
    be silently ignored.
    
    Signed-off-by: Guangliang Zhao <lucienchao@gmail.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d80a2786f563..77fcb5706700 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -580,8 +580,15 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			}
 			break;
 		case Opt_acl:
+#ifdef CONFIG_BTRFS_FS_POSIX_ACL
 			root->fs_info->sb->s_flags |= MS_POSIXACL;
 			break;
+#else
+			btrfs_err(root->fs_info,
+				"support for ACL not compiled in!");
+			ret = -EINVAL;
+			goto out;
+#endif
 		case Opt_noacl:
 			root->fs_info->sb->s_flags &= ~MS_POSIXACL;
 			break;

commit faa2dbf004e89e8f7ccd28fbe6f07c308417b8ae
Author: Josef Bacik <jbacik@fb.com>
Date:   Wed May 7 17:06:09 2014 -0400

    Btrfs: add sanity tests for new qgroup accounting code
    
    This exercises the various parts of the new qgroup accounting code.  We do some
    basic stuff and do some things with the shared refs to make sure all that code
    works.  I had to add a bunch of infrastructure because I needed to be able to
    insert items into a fake tree without having to do all the hard work myself,
    hopefully this will be usefull in the future.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8f7c03db1f8d..d80a2786f563 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1895,6 +1895,9 @@ static int btrfs_run_sanity_tests(void)
 	if (ret)
 		goto out;
 	ret = btrfs_test_inodes();
+	if (ret)
+		goto out;
+	ret = btrfs_test_qgroups();
 out:
 	btrfs_destroy_test_fs();
 	return ret;

commit 21c7e75654b77b53a4436bf28496aac11536b6ba
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Tue May 13 17:29:04 2014 -0700

    Btrfs: reclaim the reserved metadata space at background
    
    Before applying this patch, the task had to reclaim the metadata space
    by itself if the metadata space was not enough. And When the task started
    the space reclamation, all the other tasks which wanted to reserve the
    metadata space were blocked. At some cases, they would be blocked for
    a long time, it made the performance fluctuate wildly.
    
    So we introduce the background metadata space reclamation, when the space
    is about to be exhausted, we insert a reclaim work into the workqueue, the
    worker of the workqueue helps us to reclaim the reserved space at the
    background. By this way, the tasks needn't reclaim the space by themselves at
    most cases, and even if the tasks have to reclaim the space or are blocked
    for the space reclamation, they will get enough space more quickly.
    
    Here is my test result(Tested by compilebench):
     Memory:        2GB
     CPU:           2Cores * 1CPU
     Partition:     40GB(SSD)
    
    Test command:
     # compilebench -D <mnt> -m
    
    Without this patch:
     intial create total runs 30 avg 54.36 MB/s (user 0.52s sys 2.44s)
     compile total runs 30 avg 123.72 MB/s (user 0.13s sys 1.17s)
     read compiled tree total runs 3 avg 81.15 MB/s (user 0.74s sys 4.89s)
     delete compiled tree total runs 30 avg 5.32 seconds (user 0.35s sys 4.37s)
    
    With this patch:
     intial create total runs 30 avg 59.80 MB/s (user 0.52s sys 2.53s)
     compile total runs 30 avg 151.44 MB/s (user 0.13s sys 1.11s)
     read compiled tree total runs 3 avg 83.25 MB/s (user 0.76s sys 4.91s)
     delete compiled tree total runs 30 avg 5.29 seconds (user 0.34s sys 4.34s)
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9601d25a4607..8f7c03db1f8d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1413,6 +1413,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		 * this also happens on 'umount -rf' or on shutdown, when
 		 * the filesystem is busy.
 		 */
+		cancel_work_sync(&fs_info->async_reclaim_work);
 
 		/* wait for the uuid_scan task to finish */
 		down(&fs_info->uuid_tree_rescan_sem);

commit 33c0022f0e687b0161a9bb84a5671df932551e3a
Merge: 2b9d1c050d29 cfd4a535b68f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 27 13:26:28 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs fixes from Chris Mason.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs:
      Btrfs: limit the path size in send to PATH_MAX
      Btrfs: correctly set profile flags on seqlock retry
      Btrfs: use correct key when repeating search for extent item
      Btrfs: fix inode caching vs tree log
      Btrfs: fix possible memory leaks in open_ctree()
      Btrfs: avoid triggering bug_on() when we fail to start inode caching task
      Btrfs: move btrfs_{set,clear}_and_info() to ctree.h
      btrfs: replace error code from btrfs_drop_extents
      btrfs: Change the hole range to a more accurate value.
      btrfs: fix use-after-free in mount_subvol()

commit 9d89ce658718d9d21465666127a15ca2c82c4ea7
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Wed Apr 23 19:33:33 2014 +0800

    Btrfs: move btrfs_{set,clear}_and_info() to ctree.h
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 53bc3733d483..363404b9713f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -385,20 +385,6 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-#define btrfs_set_and_info(root, opt, fmt, args...)			\
-{									\
-	if (!btrfs_test_opt(root, opt))					\
-		btrfs_info(root->fs_info, fmt, ##args);			\
-	btrfs_set_opt(root->fs_info->mount_opt, opt);			\
-}
-
-#define btrfs_clear_and_info(root, opt, fmt, args...)			\
-{									\
-	if (btrfs_test_opt(root, opt))					\
-		btrfs_info(root->fs_info, fmt, ##args);			\
-	btrfs_clear_opt(root->fs_info->mount_opt, opt);			\
-}
-
 /*
  * Regular mount options parser.  Everything that is needed only when
  * reading in a new superblock is parsed here.

commit 0040e606e35a0db80fc3fac04ccc7c7176a8e2b1
Author: Christoph Jaeger <christophjaeger@linux.com>
Date:   Sat Apr 12 13:33:13 2014 +0200

    btrfs: fix use-after-free in mount_subvol()
    
    Pointer 'newargs' is used after the memory that it points to has already
    been freed.
    
    Picked up by Coverity - CID 1201425.
    
    Fixes: 0723a0473f ("btrfs: allow mounting btrfs subvolumes with
    different ro/rw options")
    Signed-off-by: Christoph Jaeger <christophjaeger@linux.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 994c40955315..53bc3733d483 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1186,7 +1186,6 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 		return ERR_PTR(-ENOMEM);
 	mnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,
 			     newargs);
-	kfree(newargs);
 
 	if (PTR_RET(mnt) == -EBUSY) {
 		if (flags & MS_RDONLY) {
@@ -1196,17 +1195,22 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 			int r;
 			mnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY, device_name,
 					     newargs);
-			if (IS_ERR(mnt))
+			if (IS_ERR(mnt)) {
+				kfree(newargs);
 				return ERR_CAST(mnt);
+			}
 
 			r = btrfs_remount(mnt->mnt_sb, &flags, NULL);
 			if (r < 0) {
 				/* FIXME: release vfsmount mnt ??*/
+				kfree(newargs);
 				return ERR_PTR(r);
 			}
 		}
 	}
 
+	kfree(newargs);
+
 	if (IS_ERR(mnt))
 		return ERR_CAST(mnt);
 

commit 3123bca71993c2346a458875488863772c1d5dc4
Merge: 582076ab1677 e4fbaee29272
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 11 14:16:53 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull second set of btrfs updates from Chris Mason:
     "The most important changes here are from Josef, fixing a btrfs
      regression in 3.14 that can cause corruptions in the extent allocation
      tree when snapshots are in use.
    
      Josef also fixed some deadlocks in send/recv and other assorted races
      when balance is running"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (23 commits)
      Btrfs: fix compile warnings on on avr32 platform
      btrfs: allow mounting btrfs subvolumes with different ro/rw options
      btrfs: export global block reserve size as space_info
      btrfs: fix crash in remount(thread_pool=) case
      Btrfs: abort the transaction when we don't find our extent ref
      Btrfs: fix EINVAL checks in btrfs_clone
      Btrfs: fix unlock in __start_delalloc_inodes()
      Btrfs: scrub raid56 stripes in the right way
      Btrfs: don't compress for a small write
      Btrfs: more efficient io tree navigation on wait_extent_bit
      Btrfs: send, build path string only once in send_hole
      btrfs: filter invalid arg for btrfs resize
      Btrfs: send, fix data corruption due to incorrect hole detection
      Btrfs: kmalloc() doesn't return an ERR_PTR
      Btrfs: fix snapshot vs nocow writting
      btrfs: Change the expanding write sequence to fix snapshot related bug.
      btrfs: make device scan less noisy
      btrfs: fix lockdep warning with reclaim lock inversion
      Btrfs: hold the commit_root_sem when getting the commit root during send
      Btrfs: remove transaction from send
      ...

commit 0723a0473fb48a1c93b113a28665b64ce5faf35a
Author: Harald Hoyer <harald@redhat.com>
Date:   Tue Nov 19 11:36:05 2013 +0100

    btrfs: allow mounting btrfs subvolumes with different ro/rw options
    
    Given the following /etc/fstab entries:
    
    /dev/sda3 /mnt/foo btrfs subvol=foo,ro 0 0
    /dev/sda3 /mnt/bar btrfs subvol=bar,rw 0 0
    
    you can't issue:
    
    $ mount /mnt/foo
    $ mount /mnt/bar
    
    You would have to do:
    
    $ mount /mnt/foo
    $ mount -o remount,rw /mnt/foo
    $ mount --bind -o remount,ro /mnt/foo
    $ mount /mnt/bar
    
    or
    
    $ mount /mnt/bar
    $ mount --rw /mnt/foo
    $ mount --bind -o remount,ro /mnt/foo
    
    With this patch you can do
    
    $ mount /mnt/foo
    $ mount /mnt/bar
    
    $ cat /proc/self/mountinfo
    49 33 0:41 /foo /mnt/foo ro,relatime shared:36 - btrfs /dev/sda3 rw,ssd,space_cache
    87 33 0:41 /bar /mnt/bar rw,relatime shared:74 - btrfs /dev/sda3 rw,ssd,space_cache
    
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d4878ddba87a..994c40955315 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -66,6 +66,8 @@
 static const struct super_operations btrfs_super_ops;
 static struct file_system_type btrfs_fs_type;
 
+static int btrfs_remount(struct super_block *sb, int *flags, char *data);
+
 static const char *btrfs_decode_error(int errno)
 {
 	char *errstr = "unknown";
@@ -1185,6 +1187,26 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 	mnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,
 			     newargs);
 	kfree(newargs);
+
+	if (PTR_RET(mnt) == -EBUSY) {
+		if (flags & MS_RDONLY) {
+			mnt = vfs_kern_mount(&btrfs_fs_type, flags & ~MS_RDONLY, device_name,
+					     newargs);
+		} else {
+			int r;
+			mnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY, device_name,
+					     newargs);
+			if (IS_ERR(mnt))
+				return ERR_CAST(mnt);
+
+			r = btrfs_remount(mnt->mnt_sb, &flags, NULL);
+			if (r < 0) {
+				/* FIXME: release vfsmount mnt ??*/
+				return ERR_PTR(r);
+			}
+		}
+	}
+
 	if (IS_ERR(mnt))
 		return ERR_CAST(mnt);
 

commit 24e7ea3bea94fe05eae5019f5f12bcdc98fc5157
Merge: 8e343c8b5c2e ad6599ab3ac9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 4 15:39:39 2014 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates from Ted Ts'o:
     "Major changes for 3.14 include support for the newly added ZERO_RANGE
      and COLLAPSE_RANGE fallocate operations, and scalability improvements
      in the jbd2 layer and in xattr handling when the extended attributes
      spill over into an external block.
    
      Other than that, the usual clean ups and minor bug fixes"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (42 commits)
      ext4: fix premature freeing of partial clusters split across leaf blocks
      ext4: remove unneeded test of ret variable
      ext4: fix comment typo
      ext4: make ext4_block_zero_page_range static
      ext4: atomically set inode->i_flags in ext4_set_inode_flags()
      ext4: optimize Hurd tests when reading/writing inodes
      ext4: kill i_version support for Hurd-castrated file systems
      ext4: each filesystem creates and uses its own mb_cache
      fs/mbcache.c: doucple the locking of local from global data
      fs/mbcache.c: change block and index hash chain to hlist_bl_node
      ext4: Introduce FALLOC_FL_ZERO_RANGE flag for fallocate
      ext4: refactor ext4_fallocate code
      ext4: Update inode i_size after the preallocation
      ext4: fix partial cluster handling for bigalloc file systems
      ext4: delete path dealloc code in ext4_ext_handle_uninitialized_extents
      ext4: only call sync_filesystm() when remounting read-only
      fs: push sync_filesystem() down to the file system's remount_fs()
      jbd2: improve error messages for inconsistent journal heads
      jbd2: minimize region locked by j_list_lock in jbd2_journal_forget()
      jbd2: minimize region locked by j_list_lock in journal_get_create_access()
      ...

commit 02b9984d640873b7b3809e63f81a0d7e13496886
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Mar 13 10:14:33 2014 -0400

    fs: push sync_filesystem() down to the file system's remount_fs()
    
    Previously, the no-op "mount -o mount /dev/xxx" operation when the
    file system is already mounted read-write causes an implied,
    unconditional syncfs().  This seems pretty stupid, and it's certainly
    documented or guaraunteed to do this, nor is it particularly useful,
    except in the case where the file system was mounted rw and is getting
    remounted read-only.
    
    However, it's possible that there might be some file systems that are
    actually depending on this behavior.  In most file systems, it's
    probably fine to only call sync_filesystem() when transitioning from
    read-write to read-only, and there are some file systems where this is
    not needed at all (for example, for a pseudo-filesystem or something
    like romfs).
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Cc: Jan Kara <jack@suse.cz>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Anders Larsen <al@alarsen.net>
    Cc: Phillip Lougher <phillip@squashfs.org.uk>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Mikulas Patocka <mikulas@artax.karlin.mff.cuni.cz>
    Cc: Petr Vandrovec <petr@vandrovec.name>
    Cc: xfs@oss.sgi.com
    Cc: linux-btrfs@vger.kernel.org
    Cc: linux-cifs@vger.kernel.org
    Cc: samba-technical@lists.samba.org
    Cc: codalist@coda.cs.cmu.edu
    Cc: linux-ext4@vger.kernel.org
    Cc: linux-f2fs-devel@lists.sourceforge.net
    Cc: fuse-devel@lists.sourceforge.net
    Cc: cluster-devel@redhat.com
    Cc: linux-mtd@lists.infradead.org
    Cc: jfs-discussion@lists.sourceforge.net
    Cc: linux-nfs@vger.kernel.org
    Cc: linux-nilfs@vger.kernel.org
    Cc: linux-ntfs-dev@lists.sourceforge.net
    Cc: ocfs2-devel@oss.oracle.com
    Cc: reiserfs-devel@vger.kernel.org

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 97cc24198554..00cd0c57b0b3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1381,6 +1381,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	unsigned int old_metadata_ratio = fs_info->metadata_ratio;
 	int ret;
 
+	sync_filesystem(sb);
 	btrfs_remount_prepare(fs_info);
 
 	ret = btrfs_parse_options(root, data);

commit a046e9c88b0f46677923864295eac7c92cd962cb
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:18 2014 +0800

    btrfs: Cleanup the old btrfs_worker.
    
    Since all the btrfs_worker is replaced with the newly created
    btrfs_workqueue, the old codes can be easily remove.
    
    Signed-off-by: Quwenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index aed1e11060a0..d4878ddba87a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1305,13 +1305,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	return ERR_PTR(error);
 }
 
-static void btrfs_set_max_workers(struct btrfs_workers *workers, int new_limit)
-{
-	spin_lock_irq(&workers->lock);
-	workers->max_workers = new_limit;
-	spin_unlock_irq(&workers->lock);
-}
-
 static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 				     int new_pool_size, int old_pool_size)
 {
@@ -1323,7 +1316,6 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	btrfs_info(fs_info, "resize thread pool %d -> %d",
 	       old_pool_size, new_pool_size);
 
-	btrfs_set_max_workers(&fs_info->generic_worker, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);

commit 0339ef2f42bcfbb2d4021ad6f38fe20580082c85
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:17 2014 +0800

    btrfs: Replace fs_info->scrub_* workqueue with btrfs_workqueue.
    
    Replace the fs_info->scrub_* with the newly created
    btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index fd07d039b2de..aed1e11060a0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1336,8 +1336,8 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	btrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->delayed_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->readahead_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->scrub_wr_completion_workers,
-			      new_pool_size);
+	btrfs_workqueue_set_max(fs_info->scrub_wr_completion_workers,
+				new_pool_size);
 }
 
 static inline void btrfs_remount_prepare(struct btrfs_fs_info *fs_info)

commit 5b3bc44e2e69d42edf40ca3785040d233ca949f4
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:15 2014 +0800

    btrfs: Replace fs_info->delayed_workers workqueue with btrfs_workqueue.
    
    Replace the fs_info->delayed_workers with the newly created
    btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2e1d6cf4dc66..fd07d039b2de 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1334,7 +1334,7 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 				new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_write_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);
-	btrfs_set_max_workers(&fs_info->delayed_workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->delayed_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->readahead_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->scrub_wr_completion_workers,
 			      new_pool_size);

commit dc6e320998fb907e4c19032d545d461bfe5040d1
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:14 2014 +0800

    btrfs: Replace fs_info->fixup_workers workqueue with btrfs_workqueue.
    
    Replace the fs_info->fixup_workers with the newly created
    btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ce9d012a77e8..2e1d6cf4dc66 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1328,7 +1328,6 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	btrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->caching_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->fixup_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_meta_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_meta_write_workers,

commit 736cfa15e89a654436d4149c109bf1ae09fc67cf
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:13 2014 +0800

    btrfs: Replace fs_info->readahead_workers workqueue with btrfs_workqueue.
    
    Replace the fs_info->readahead_workers with the newly created
    btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b84fbe04f05a..ce9d012a77e8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1336,7 +1336,7 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	btrfs_workqueue_set_max(fs_info->endio_write_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);
 	btrfs_set_max_workers(&fs_info->delayed_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->readahead_workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->readahead_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->scrub_wr_completion_workers,
 			      new_pool_size);
 }

commit e66f0bb14465371d4c86fa70cff2acc331efa1fb
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:12 2014 +0800

    btrfs: Replace fs_info->cache_workers workqueue with btrfs_workqueue.
    
    Replace the fs_info->cache_workers with the newly created
    btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d95d98d3e72c..b84fbe04f05a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1327,7 +1327,7 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	btrfs_workqueue_set_max(fs_info->workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->caching_workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->caching_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->fixup_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->endio_meta_workers, new_pool_size);

commit fccb5d86d8f52161e013025ccf3101d8fab99a32
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:10 2014 +0800

    btrfs: Replace fs_info->endio_* workqueue with btrfs_workqueue.
    
    Replace the fs_info->endio_* workqueues with the newly created
    btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9ed559ebe914..d95d98d3e72c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1329,11 +1329,12 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	btrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->caching_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->fixup_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->endio_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->endio_meta_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->endio_meta_write_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->endio_write_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->endio_freespace_worker, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->endio_workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->endio_meta_workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->endio_meta_write_workers,
+				new_pool_size);
+	btrfs_workqueue_set_max(fs_info->endio_write_workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);
 	btrfs_set_max_workers(&fs_info->delayed_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->readahead_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->scrub_wr_completion_workers,

commit a8c93d4ef6f6727764a61a2ee1c1878a755637c5
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:08 2014 +0800

    btrfs: Replace fs_info->submit_workers with btrfs_workqueue.
    
    Much like the fs_info->workers, replace the fs_info->submit_workers
    use the same btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index be0019903264..9ed559ebe914 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1326,7 +1326,7 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	btrfs_set_max_workers(&fs_info->generic_worker, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->workers, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->submit_workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->caching_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->fixup_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->endio_workers, new_pool_size);

commit afe3d24267926eb78ba863016bdd65cfe718aef5
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:07 2014 +0800

    btrfs: Replace fs_info->delalloc_workers with btrfs_workqueue
    
    Much like the fs_info->workers, replace the fs_info->delalloc_workers
    use the same btrfs_workqueue.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6f66d8a2ef38..be0019903264 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1325,7 +1325,7 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 
 	btrfs_set_max_workers(&fs_info->generic_worker, new_pool_size);
 	btrfs_workqueue_set_max(fs_info->workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->delalloc_workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->submit_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->caching_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->fixup_workers, new_pool_size);

commit 5cdc7ad337fb08f630ac3538fb10e4a75de2572d
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Fri Feb 28 10:46:06 2014 +0800

    btrfs: Replace fs_info->workers with btrfs_workqueue.
    
    Use the newly created btrfs_workqueue_struct to replace the original
    fs_info->workers
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 426b7c602653..6f66d8a2ef38 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1324,7 +1324,7 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	       old_pool_size, new_pool_size);
 
 	btrfs_set_max_workers(&fs_info->generic_worker, new_pool_size);
-	btrfs_set_max_workers(&fs_info->workers, new_pool_size);
+	btrfs_workqueue_set_max(fs_info->workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->delalloc_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->submit_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->caching_workers, new_pool_size);

commit 2c6a92b0097464e08caaa1caeb8baa9d470ab990
Author: Justin Maggard <jmaggard10@gmail.com>
Date:   Thu Feb 20 08:48:07 2014 -0800

    btrfs: wake up transaction thread upon remount
    
    Now that we can adjust the commit interval with a remount, we need
    to wake up the transaction thread or else he will continue to sleep
    until the previous transaction interval has elapsed before waking
    up.  So, if we go from a large commit interval to something smaller,
    the transaction thread will not wake up until the large interval has
    expired.  This also causes the cleaner thread to stay sleeping, since
    it gets woken up by the transaction thread.
    
    Fix it by simply waking up the transaction thread during a remount.
    
    Signed-off-by: Justin Maggard <jmaggard10@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d04db817be5c..426b7c602653 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1479,6 +1479,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		sb->s_flags &= ~MS_RDONLY;
 	}
 out:
+	wake_up_process(fs_info->transaction_kthread);
 	btrfs_remount_cleanup(fs_info, old_opts);
 	return 0;
 

commit 3a0dfa6a12e4bb64a434426ecb17d4842092db5e
Author: Josef Bacik <jbacik@fb.com>
Date:   Fri Feb 14 13:43:48 2014 -0500

    Btrfs: unset DCACHE_DISCONNECTED when mounting default subvol
    
    A user was running into errors from an NFS export of a subvolume that had a
    default subvol set.  When we mount a default subvol we will use d_obtain_alias()
    to find an existing dentry for the subvolume in the case that the root subvol
    has already been mounted, or a dummy one is allocated in the case that the root
    subvol has not already been mounted.  This allows us to connect the dentry later
    on if we wander into the path.  However if we don't ever wander into the path we
    will keep DCACHE_DISCONNECTED set for a long time, which angers NFS.  It doesn't
    appear to cause any problems but it is annoying nonetheless, so simply unset
    DCACHE_DISCONNECTED in the get_default_root case and switch btrfs_lookup() to
    use d_materialise_unique() instead which will make everything play nicely
    together and reconnect stuff if we wander into the defaul subvol path from a
    different way.  With this patch I'm no longer getting the NFS errors when
    exporting a volume that has been mounted with a default subvol set.  Thanks,
    
    cc: bfields@fieldses.org
    cc: ebiederm@xmission.com
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e73c80eec11b..d04db817be5c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -855,6 +855,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 	struct btrfs_path *path;
 	struct btrfs_key location;
 	struct inode *inode;
+	struct dentry *dentry;
 	u64 dir_id;
 	int new = 0;
 
@@ -925,7 +926,13 @@ static struct dentry *get_default_root(struct super_block *sb,
 		return dget(sb->s_root);
 	}
 
-	return d_obtain_alias(inode);
+	dentry = d_obtain_alias(inode);
+	if (!IS_ERR(dentry)) {
+		spin_lock(&dentry->d_lock);
+		dentry->d_flags &= ~DCACHE_DISCONNECTED;
+		spin_unlock(&dentry->d_lock);
+	}
+	return dentry;
 }
 
 static int btrfs_fill_super(struct super_block *sb,

commit feb5f96589302b39a2b10fc210db7c47a73e4168
Author: Mitch Harder <mitch.harder@sabayonlinux.org>
Date:   Thu Feb 13 09:13:16 2014 -0600

    Btrfs: fix max_inline mount option
    
    Currently, the only mount option for max_inline that has any effect is
    max_inline=0.  Any other value that is supplied to max_inline will be
    adjusted to a minimum of 4k.  Since max_inline has an effective maximum
    of ~3900 bytes due to page size limitations, the current behaviour
    only has meaning for max_inline=0.
    
    This patch will allow the the max_inline mount option to accept non-zero
    values as indicated in the documentation.
    
    Signed-off-by: Mitch Harder <mitch.harder@sabayonlinux.org>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 97cc24198554..e73c80eec11b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -566,7 +566,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				kfree(num);
 
 				if (info->max_inline) {
-					info->max_inline = max_t(u64,
+					info->max_inline = min_t(u64,
 						info->max_inline,
 						root->sectorsize);
 				}

commit 60efa5eb2e886852a0d5f9e1ffa7c896a1099da8
Author: Filipe David Borba Manana <fdmanana@gmail.com>
Date:   Sat Feb 1 21:27:56 2014 +0000

    Btrfs: use late_initcall instead of module_init
    
    It seems that when init_btrfs_fs() is called, crc32c/crc32c-intel might
    not always be already initialized, which results in the call to crypto_alloc_shash()
    returning -ENOENT, as experienced by Ahmet who reported this.
    
    Therefore make sure init_btrfs_fs() is called after crc32c is initialized (which
    is at initialization level 6, module_init), by using late_initcall (which is at
    initialization level 7) instead of module_init for btrfs.
    
    Reported-and-Tested-by: Ahmet Inan <ainan@mathematik.uni-freiburg.de>
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c02f63356895..97cc24198554 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1996,7 +1996,7 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_hash_exit();
 }
 
-module_init(init_btrfs_fs)
+late_initcall(init_btrfs_fs);
 module_exit(exit_btrfs_fs)
 
 MODULE_LICENSE("GPL");

commit 078025347c8ed43ff330e392476d8866ac1b297f
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 13 13:36:07 2014 +0800

    btrfs: Cleanup the btrfs_parse_options for remount.
    
    Since remount will pending the new mount options to the original mount
    options, which will make btrfs_parse_options check the old options then
    new options, causing some stupid output like "enabling XXX" following by
    "disable XXX".
    
    This patch will add extra check before every btrfs_info to skip the
    output from old options checking.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 362aef44a17b..c02f63356895 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -383,6 +383,20 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
+#define btrfs_set_and_info(root, opt, fmt, args...)			\
+{									\
+	if (!btrfs_test_opt(root, opt))					\
+		btrfs_info(root->fs_info, fmt, ##args);			\
+	btrfs_set_opt(root->fs_info->mount_opt, opt);			\
+}
+
+#define btrfs_clear_and_info(root, opt, fmt, args...)			\
+{									\
+	if (btrfs_test_opt(root, opt))					\
+		btrfs_info(root->fs_info, fmt, ##args);			\
+	btrfs_clear_opt(root->fs_info->mount_opt, opt);			\
+}
+
 /*
  * Regular mount options parser.  Everything that is needed only when
  * reading in a new superblock is parsed here.
@@ -398,6 +412,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	int ret = 0;
 	char *compress_type;
 	bool compress_force = false;
+	bool compress = false;
 
 	cache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);
 	if (cache_gen)
@@ -437,24 +452,28 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			 */
 			break;
 		case Opt_nodatasum:
-			btrfs_info(root->fs_info, "setting nodatasum");
-			btrfs_set_opt(info->mount_opt, NODATASUM);
+			btrfs_set_and_info(root, NODATASUM,
+					   "setting nodatasum");
 			break;
 		case Opt_datasum:
-			if (btrfs_test_opt(root, NODATACOW))
-				btrfs_info(root->fs_info, "setting datasum, datacow enabled");
-			else
-				btrfs_info(root->fs_info, "setting datasum");
+			if (btrfs_test_opt(root, NODATASUM)) {
+				if (btrfs_test_opt(root, NODATACOW))
+					btrfs_info(root->fs_info, "setting datasum, datacow enabled");
+				else
+					btrfs_info(root->fs_info, "setting datasum");
+			}
 			btrfs_clear_opt(info->mount_opt, NODATACOW);
 			btrfs_clear_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_nodatacow:
-			if (!btrfs_test_opt(root, COMPRESS) ||
-				!btrfs_test_opt(root, FORCE_COMPRESS)) {
+			if (!btrfs_test_opt(root, NODATACOW)) {
+				if (!btrfs_test_opt(root, COMPRESS) ||
+				    !btrfs_test_opt(root, FORCE_COMPRESS)) {
 					btrfs_info(root->fs_info,
-						"setting nodatacow, compression disabled");
-			} else {
-				btrfs_info(root->fs_info, "setting nodatacow");
+						   "setting nodatacow, compression disabled");
+				} else {
+					btrfs_info(root->fs_info, "setting nodatacow");
+				}
 			}
 			btrfs_clear_opt(info->mount_opt, COMPRESS);
 			btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
@@ -462,9 +481,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_datacow:
-			if (btrfs_test_opt(root, NODATACOW))
-				btrfs_info(root->fs_info, "setting datacow");
-			btrfs_clear_opt(info->mount_opt, NODATACOW);
+			btrfs_clear_and_info(root, NODATACOW,
+					     "setting datacow");
 			break;
 		case Opt_compress_force:
 		case Opt_compress_force_type:
@@ -472,6 +490,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			/* Fallthrough */
 		case Opt_compress:
 		case Opt_compress_type:
+			compress = true;
 			if (token == Opt_compress ||
 			    token == Opt_compress_force ||
 			    strcmp(args[0].from, "zlib") == 0) {
@@ -498,37 +517,36 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			}
 
 			if (compress_force) {
-				btrfs_set_opt(info->mount_opt, FORCE_COMPRESS);
-				btrfs_info(root->fs_info, "force %s compression",
-					compress_type);
-			} else if (btrfs_test_opt(root, COMPRESS)) {
-				pr_info("btrfs: use %s compression\n",
-					compress_type);
+				btrfs_set_and_info(root, FORCE_COMPRESS,
+						   "force %s compression",
+						   compress_type);
+			} else if (compress) {
+				if (!btrfs_test_opt(root, COMPRESS))
+					btrfs_info(root->fs_info,
+						   "btrfs: use %s compression\n",
+						   compress_type);
 			}
 			break;
 		case Opt_ssd:
-			btrfs_info(root->fs_info, "use ssd allocation scheme");
-			btrfs_set_opt(info->mount_opt, SSD);
+			btrfs_set_and_info(root, SSD,
+					   "use ssd allocation scheme");
 			break;
 		case Opt_ssd_spread:
-			btrfs_info(root->fs_info, "use spread ssd allocation scheme");
-			btrfs_set_opt(info->mount_opt, SSD);
-			btrfs_set_opt(info->mount_opt, SSD_SPREAD);
+			btrfs_set_and_info(root, SSD_SPREAD,
+					   "use spread ssd allocation scheme");
 			break;
 		case Opt_nossd:
-			btrfs_info(root->fs_info, "not using ssd allocation scheme");
-			btrfs_set_opt(info->mount_opt, NOSSD);
+			btrfs_clear_and_info(root, NOSSD,
+					     "not using ssd allocation scheme");
 			btrfs_clear_opt(info->mount_opt, SSD);
-			btrfs_clear_opt(info->mount_opt, SSD_SPREAD);
 			break;
 		case Opt_barrier:
-			if (btrfs_test_opt(root, NOBARRIER))
-				btrfs_info(root->fs_info, "turning on barriers");
-			btrfs_clear_opt(info->mount_opt, NOBARRIER);
+			btrfs_clear_and_info(root, NOBARRIER,
+					     "turning on barriers");
 			break;
 		case Opt_nobarrier:
-			btrfs_info(root->fs_info, "turning off barriers");
-			btrfs_set_opt(info->mount_opt, NOBARRIER);
+			btrfs_set_and_info(root, NOBARRIER,
+					   "turning off barriers");
 			break;
 		case Opt_thread_pool:
 			ret = match_int(&args[0], &intarg);
@@ -580,22 +598,20 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			root->fs_info->sb->s_flags &= ~MS_POSIXACL;
 			break;
 		case Opt_notreelog:
-			btrfs_info(root->fs_info, "disabling tree log");
-			btrfs_set_opt(info->mount_opt, NOTREELOG);
+			btrfs_set_and_info(root, NOTREELOG,
+					   "disabling tree log");
 			break;
 		case Opt_treelog:
-			if (btrfs_test_opt(root, NOTREELOG))
-				btrfs_info(root->fs_info, "enabling tree log");
-			btrfs_clear_opt(info->mount_opt, NOTREELOG);
+			btrfs_clear_and_info(root, NOTREELOG,
+					     "enabling tree log");
 			break;
 		case Opt_flushoncommit:
-			btrfs_info(root->fs_info, "turning on flush-on-commit");
-			btrfs_set_opt(info->mount_opt, FLUSHONCOMMIT);
+			btrfs_set_and_info(root, FLUSHONCOMMIT,
+					   "turning on flush-on-commit");
 			break;
 		case Opt_noflushoncommit:
-			if (btrfs_test_opt(root, FLUSHONCOMMIT))
-				btrfs_info(root->fs_info, "turning off flush-on-commit");
-			btrfs_clear_opt(info->mount_opt, FLUSHONCOMMIT);
+			btrfs_clear_and_info(root, FLUSHONCOMMIT,
+					     "turning off flush-on-commit");
 			break;
 		case Opt_ratio:
 			ret = match_int(&args[0], &intarg);
@@ -611,33 +627,35 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			}
 			break;
 		case Opt_discard:
-			btrfs_set_opt(info->mount_opt, DISCARD);
+			btrfs_set_and_info(root, DISCARD,
+					   "turning on discard");
 			break;
 		case Opt_nodiscard:
-			btrfs_clear_opt(info->mount_opt, DISCARD);
+			btrfs_clear_and_info(root, DISCARD,
+					     "turning off discard");
 			break;
 		case Opt_space_cache:
-			btrfs_set_opt(info->mount_opt, SPACE_CACHE);
+			btrfs_set_and_info(root, SPACE_CACHE,
+					   "enabling disk space caching");
 			break;
 		case Opt_rescan_uuid_tree:
 			btrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);
 			break;
 		case Opt_no_space_cache:
-			btrfs_info(root->fs_info, "disabling disk space caching");
-			btrfs_clear_opt(info->mount_opt, SPACE_CACHE);
+			btrfs_clear_and_info(root, SPACE_CACHE,
+					     "disabling disk space caching");
 			break;
 		case Opt_inode_cache:
-			btrfs_info(root->fs_info, "enabling inode map caching");
-			btrfs_set_opt(info->mount_opt, CHANGE_INODE_CACHE);
+			btrfs_set_and_info(root, CHANGE_INODE_CACHE,
+					   "enabling inode map caching");
 			break;
 		case Opt_noinode_cache:
-			if (btrfs_test_opt(root, CHANGE_INODE_CACHE))
-				btrfs_info(root->fs_info, "disabling inode map caching");
-			btrfs_clear_opt(info->mount_opt, CHANGE_INODE_CACHE);
+			btrfs_clear_and_info(root, CHANGE_INODE_CACHE,
+					     "disabling inode map caching");
 			break;
 		case Opt_clear_cache:
-			btrfs_info(root->fs_info, "force clearing of disk cache");
-			btrfs_set_opt(info->mount_opt, CLEAR_CACHE);
+			btrfs_set_and_info(root, CLEAR_CACHE,
+					   "force clearing of disk cache");
 			break;
 		case Opt_user_subvol_rm_allowed:
 			btrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);
@@ -649,13 +667,12 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);
 			break;
 		case Opt_defrag:
-			btrfs_info(root->fs_info, "enabling auto defrag");
-			btrfs_set_opt(info->mount_opt, AUTO_DEFRAG);
+			btrfs_set_and_info(root, AUTO_DEFRAG,
+					   "enabling auto defrag");
 			break;
 		case Opt_nodefrag:
-			if (btrfs_test_opt(root, AUTO_DEFRAG))
-				btrfs_info(root->fs_info, "disabling auto defrag");
-			btrfs_clear_opt(info->mount_opt, AUTO_DEFRAG);
+			btrfs_clear_and_info(root, AUTO_DEFRAG,
+					     "disabling auto defrag");
 			break;
 		case Opt_recovery:
 			btrfs_info(root->fs_info, "enabling auto recovery");

commit 3818aea275423236db38a2d2d0a4951bc6da2e01
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 13 13:36:06 2014 +0800

    btrfs: Add noinode_cache mount option
    
    Add noinode_cache mount option for btrfs.
    
    Since inode map cache involves all the btrfs_find_free_ino/return_ino
    things and if just trigger the mount_opt,
    an inode number get from inode map cache will not returned to inode map
    cache.
    
    To keep the find and return inode both in the same behavior,
    a new bit in mount_opt, CHANGE_INODE_CACHE, is introduced for this idea.
    CHANGE_INODE_CACHE is set/cleared in remounting, and the original
    INODE_MAP_CACHE is set/cleared according to CHANGE_INODE_CACHE after a
    success transaction.
    Since find/return inode is all done between btrfs_start_transaction and
    btrfs_commit_transaction, this will keep consistent behavior.
    
    Also noinode_cache mount option will not stop the caching_kthread.
    
    Cc: David Sterba <dsterba@suse.cz>
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f44cc6a0eb27..362aef44a17b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -327,7 +327,7 @@ enum {
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
-	Opt_datasum, Opt_treelog,
+	Opt_datasum, Opt_treelog, Opt_noinode_cache,
 	Opt_err,
 };
 
@@ -370,6 +370,7 @@ static match_table_t tokens = {
 	{Opt_defrag, "autodefrag"},
 	{Opt_nodefrag, "noautodefrag"},
 	{Opt_inode_cache, "inode_cache"},
+	{Opt_noinode_cache, "noinode_cache"},
 	{Opt_no_space_cache, "nospace_cache"},
 	{Opt_recovery, "recovery"},
 	{Opt_skip_balance, "skip_balance"},
@@ -627,7 +628,12 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			break;
 		case Opt_inode_cache:
 			btrfs_info(root->fs_info, "enabling inode map caching");
-			btrfs_set_opt(info->mount_opt, INODE_MAP_CACHE);
+			btrfs_set_opt(info->mount_opt, CHANGE_INODE_CACHE);
+			break;
+		case Opt_noinode_cache:
+			if (btrfs_test_opt(root, CHANGE_INODE_CACHE))
+				btrfs_info(root->fs_info, "disabling inode map caching");
+			btrfs_clear_opt(info->mount_opt, CHANGE_INODE_CACHE);
 			break;
 		case Opt_clear_cache:
 			btrfs_info(root->fs_info, "force clearing of disk cache");

commit 14a958e678cd77cae475b60ca46c0797b1c006a1
Author: Filipe David Borba Manana <fdmanana@gmail.com>
Date:   Sun Jan 12 02:22:46 2014 +0000

    Btrfs: fix btrfs boot when compiled as built-in
    
    After the change titled "Btrfs: add support for inode properties", if
    btrfs was built-in the kernel (i.e. not as a module), it would cause a
    kernel panic, as reported recently by Fengguang:
    
    [    2.024722] BUG: unable to handle kernel NULL pointer dereference at           (null)
    [    2.027814] IP: [<ffffffff81501594>] crc32c+0xc/0x6b
    [    2.028684] PGD 0
    [    2.028684] Oops: 0000 [#1] SMP
    [    2.028684] Modules linked in:
    [    2.028684] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.13.0-rc7-04795-ga7b57c2 #1
    [    2.028684] Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    [    2.028684] task: ffff88000edba100 ti: ffff88000edd6000 task.ti: ffff88000edd6000
    [    2.028684] RIP: 0010:[<ffffffff81501594>]  [<ffffffff81501594>] crc32c+0xc/0x6b
    [    2.028684] RSP: 0000:ffff88000edd7e58  EFLAGS: 00010246
    [    2.028684] RAX: 0000000000000000 RBX: ffffffff82295550 RCX: 0000000000000000
    [    2.028684] RDX: 0000000000000011 RSI: ffffffff81efe393 RDI: 00000000fffffffe
    [    2.028684] RBP: ffff88000edd7e60 R08: 0000000000000003 R09: 0000000000015d20
    [    2.028684] R10: ffffffff81ef225e R11: ffffffff811b0222 R12: ffffffffffffffff
    [    2.028684] R13: 0000000000000239 R14: 0000000000000000 R15: 0000000000000000
    [    2.028684] FS:  0000000000000000(0000) GS:ffff88000fa00000(0000) knlGS:0000000000000000
    [    2.028684] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [    2.028684] CR2: 0000000000000000 CR3: 000000000220c000 CR4: 00000000000006f0
    [    2.028684] Stack:
    [    2.028684]  ffffffff82295550 ffff88000edd7e80 ffffffff8238af62 ffffffff8238ac05
    [    2.028684]  0000000000000000 ffff88000edd7e98 ffffffff8238ac0f ffffffff8238ac05
    [    2.028684]  ffff88000edd7f08 ffffffff810002ba ffff88000edd7f00 ffffffff810e2404
    [    2.028684] Call Trace:
    [    2.028684]  [<ffffffff8238af62>] btrfs_props_init+0x4f/0x96
    [    2.028684]  [<ffffffff8238ac05>] ? ftrace_define_fields_btrfs_space_reservation+0x145/0x145
    [    2.028684]  [<ffffffff8238ac0f>] init_btrfs_fs+0xa/0xf0
    [    2.028684]  [<ffffffff8238ac05>] ? ftrace_define_fields_btrfs_space_reservation+0x145/0x145
    [    2.028684]  [<ffffffff810002ba>] do_one_initcall+0xa4/0x13a
    [    2.028684]  [<ffffffff810e2404>] ? parse_args+0x25f/0x33d
    [    2.028684]  [<ffffffff8234cf75>] kernel_init_freeable+0x1aa/0x230
    [    2.028684]  [<ffffffff8234c785>] ? do_early_param+0x88/0x88
    [    2.028684]  [<ffffffff819f61b5>] ? rest_init+0x89/0x89
    [    2.028684]  [<ffffffff819f61c3>] kernel_init+0xe/0x109
    
    The issue here is that the initialization function of btrfs (super.c:init_btrfs_fs)
    started using crc32c (from lib/libcrc32c.c). But when it needs to call crc32c (as
    part of the properties initialization routine), the libcrc32c is not yet initialized,
    so crc32c derreferenced a NULL pointer (lib/libcrc32c.c:tfm), causing the kernel
    panic on boot.
    
    The approach to fix this is to use crypto component directly to use its crc32c (which
    is basically what lib/libcrc32c.c is, a wrapper around crypto). This is what ext4 is
    doing as well, it uses crypto directly to get crc32c functionality.
    
    Verified this works both when btrfs is built-in and when it's loadable kernel module.
    
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 461e41cb8ca7..f44cc6a0eb27 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -48,6 +48,7 @@
 #include "transaction.h"
 #include "btrfs_inode.h"
 #include "print-tree.h"
+#include "hash.h"
 #include "props.h"
 #include "xattr.h"
 #include "volumes.h"
@@ -1866,11 +1867,15 @@ static int __init init_btrfs_fs(void)
 {
 	int err;
 
+	err = btrfs_hash_init();
+	if (err)
+		return err;
+
 	btrfs_props_init();
 
 	err = btrfs_init_sysfs();
 	if (err)
-		return err;
+		goto free_hash;
 
 	btrfs_init_compress();
 
@@ -1945,6 +1950,8 @@ static int __init init_btrfs_fs(void)
 free_compress:
 	btrfs_exit_compress();
 	btrfs_exit_sysfs();
+free_hash:
+	btrfs_hash_exit();
 	return err;
 }
 
@@ -1963,6 +1970,7 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_exit_sysfs();
 	btrfs_cleanup_fs_uuids();
 	btrfs_exit_compress();
+	btrfs_hash_exit();
 }
 
 module_init(init_btrfs_fs)

commit 63541927c8d11d2686778b1e8ec71c14b4fd53e4
Author: Filipe David Borba Manana <fdmanana@gmail.com>
Date:   Tue Jan 7 11:47:46 2014 +0000

    Btrfs: add support for inode properties
    
    This change adds infrastructure to allow for generic properties for
    inodes. Properties are name/value pairs that can be associated with
    inodes for different purposes. They are stored as xattrs with the
    prefix "btrfs."
    
    Properties can be inherited - this means when a directory inode has
    inheritable properties set, these are added to new inodes created
    under that directory. Further, subvolumes can also have properties
    associated with them, and they can be inherited from their parent
    subvolume. Naturally, directory properties have priority over subvolume
    properties (in practice a subvolume property is just a regular
    property associated with the root inode, objectid 256, of the
    subvolume's fs tree).
    
    This change also adds one specific property implementation, named
    "compression", whose values can be "lzo" or "zlib" and it's an
    inheritable property.
    
    The corresponding changes to btrfs-progs were also implemented.
    A patch with xfstests for this feature will follow once there's
    agreement on this change/feature.
    
    Further, the script at the bottom of this commit message was used to
    do some benchmarks to measure any performance penalties of this feature.
    
    Basically the tests correspond to:
    
    Test 1 - create a filesystem and mount it with compress-force=lzo,
    then sequentially create N files of 64Kb each, measure how long it took
    to create the files, unmount the filesystem, mount the filesystem and
    perform an 'ls -lha' against the test directory holding the N files, and
    report the time the command took.
    
    Test 2 - create a filesystem and don't use any compression option when
    mounting it - instead set the compression property of the subvolume's
    root to 'lzo'. Then create N files of 64Kb, and report the time it took.
    The unmount the filesystem, mount it again and perform an 'ls -lha' like
    in the former test. This means every single file ends up with a property
    (xattr) associated to it.
    
    Test 3 - same as test 2, but uses 4 properties - 3 are duplicates of the
    compression property, have no real effect other than adding more work
    when inheriting properties and taking more btree leaf space.
    
    Test 4 - same as test 3 but with 10 properties per file.
    
    Results (in seconds, and averages of 5 runs each), for different N
    numbers of files follow.
    
    * Without properties (test 1)
    
                        file creation time        ls -lha time
    10 000 files              3.49                   0.76
    100 000 files            47.19                   8.37
    1 000 000 files         518.51                 107.06
    
    * With 1 property (compression property set to lzo - test 2)
    
                        file creation time        ls -lha time
    10 000 files              3.63                    0.93
    100 000 files            48.56                    9.74
    1 000 000 files         537.72                  125.11
    
    * With 4 properties (test 3)
    
                        file creation time        ls -lha time
    10 000 files              3.94                    1.20
    100 000 files            52.14                   11.48
    1 000 000 files         572.70                  142.13
    
    * With 10 properties (test 4)
    
                        file creation time        ls -lha time
    10 000 files              4.61                    1.35
    100 000 files            58.86                   13.83
    1 000 000 files         656.01                  177.61
    
    The increased latencies with properties are essencialy because of:
    
    *) When creating an inode, we now synchronously write 1 more item
       (an xattr item) for each property inherited from the parent dir
       (or subvolume). This could be done in an asynchronous way such
       as we do for dir intex items (delayed-inode.c), which could help
       reduce the file creation latency;
    
    *) With properties, we now have larger fs trees. For this particular
       test each xattr item uses 75 bytes of leaf space in the fs tree.
       This could be less by using a new item for xattr items, instead of
       the current btrfs_dir_item, since we could cut the 'location' and
       'type' fields (saving 18 bytes) and maybe 'transid' too (saving a
       total of 26 bytes per xattr item) from the btrfs_dir_item type.
    
    Also tried batching the xattr insertions (ignoring proper hash
    collision handling, since it didn't exist) when creating files that
    inherit properties from their parent inode/subvolume, but the end
    results were (surprisingly) essentially the same.
    
    Test script:
    
    $ cat test.pl
      #!/usr/bin/perl -w
    
      use strict;
      use Time::HiRes qw(time);
      use constant NUM_FILES => 10_000;
      use constant FILE_SIZES => (64 * 1024);
      use constant DEV => '/dev/sdb4';
      use constant MNT_POINT => '/home/fdmanana/btrfs-tests/dev';
      use constant TEST_DIR => (MNT_POINT . '/testdir');
    
      system("mkfs.btrfs", "-l", "16384", "-f", DEV) == 0 or die "mkfs.btrfs failed!";
    
      # following line for testing without properties
      #system("mount", "-o", "compress-force=lzo", DEV, MNT_POINT) == 0 or die "mount failed!";
    
      # following 2 lines for testing with properties
      system("mount", DEV, MNT_POINT) == 0 or die "mount failed!";
      system("btrfs", "prop", "set", MNT_POINT, "compression", "lzo") == 0 or die "set prop failed!";
    
      system("mkdir", TEST_DIR) == 0 or die "mkdir failed!";
      my ($t1, $t2);
    
      $t1 = time();
      for (my $i = 1; $i <= NUM_FILES; $i++) {
          my $p = TEST_DIR . '/file_' . $i;
          open(my $f, '>', $p) or die "Error opening file!";
          $f->autoflush(1);
          for (my $j = 0; $j < FILE_SIZES; $j += 4096) {
              print $f ('A' x 4096) or die "Error writing to file!";
          }
          close($f);
      }
      $t2 = time();
      print "Time to create " . NUM_FILES . ": " . ($t2 - $t1) . " seconds.\n";
      system("umount", DEV) == 0 or die "umount failed!";
      system("mount", DEV, MNT_POINT) == 0 or die "mount failed!";
    
      $t1 = time();
      system("bash -c 'ls -lha " . TEST_DIR . " > /dev/null'") == 0 or die "ls failed!";
      $t2 = time();
      print "Time to ls -lha all files: " . ($t2 - $t1) . " seconds.\n";
      system("umount", DEV) == 0 or die "umount failed!";
    
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 16d7fc751ba8..461e41cb8ca7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -48,6 +48,7 @@
 #include "transaction.h"
 #include "btrfs_inode.h"
 #include "print-tree.h"
+#include "props.h"
 #include "xattr.h"
 #include "volumes.h"
 #include "export.h"
@@ -1865,6 +1866,8 @@ static int __init init_btrfs_fs(void)
 {
 	int err;
 
+	btrfs_props_init();
+
 	err = btrfs_init_sysfs();
 	if (err)
 		return err;

commit a88998f291fc707f18ee42ae45220a3a3e384c27
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:33 2014 +0800

    btrfs: Add treelog mount option.
    
    Add treelog mount option to enable tree log with
    remount option.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e84e6cb57526..16d7fc751ba8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -325,7 +325,7 @@ enum {
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
-	Opt_datasum,
+	Opt_datasum, Opt_treelog,
 	Opt_err,
 };
 
@@ -353,6 +353,7 @@ static match_table_t tokens = {
 	{Opt_acl, "acl"},
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
+	{Opt_treelog, "treelog"},
 	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_noflushoncommit, "noflushoncommit"},
 	{Opt_ratio, "metadata_ratio=%d"},
@@ -579,6 +580,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_info(root->fs_info, "disabling tree log");
 			btrfs_set_opt(info->mount_opt, NOTREELOG);
 			break;
+		case Opt_treelog:
+			if (btrfs_test_opt(root, NOTREELOG))
+				btrfs_info(root->fs_info, "enabling tree log");
+			btrfs_clear_opt(info->mount_opt, NOTREELOG);
+			break;
 		case Opt_flushoncommit:
 			btrfs_info(root->fs_info, "turning on flush-on-commit");
 			btrfs_set_opt(info->mount_opt, FLUSHONCOMMIT);

commit d399167d88ea53590d6c0850b2d5534cbd21da02
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:32 2014 +0800

    btrfs: Add datasum mount option.
    
    Add datasum mount option to enable checksum with
    remount option.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6567865a2504..e84e6cb57526 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -325,6 +325,7 @@ enum {
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
+	Opt_datasum,
 	Opt_err,
 };
 
@@ -334,6 +335,7 @@ static match_table_t tokens = {
 	{Opt_subvolid, "subvolid=%s"},
 	{Opt_device, "device=%s"},
 	{Opt_nodatasum, "nodatasum"},
+	{Opt_datasum, "datasum"},
 	{Opt_nodatacow, "nodatacow"},
 	{Opt_datacow, "datacow"},
 	{Opt_nobarrier, "nobarrier"},
@@ -434,6 +436,14 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_info(root->fs_info, "setting nodatasum");
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
+		case Opt_datasum:
+			if (btrfs_test_opt(root, NODATACOW))
+				btrfs_info(root->fs_info, "setting datasum, datacow enabled");
+			else
+				btrfs_info(root->fs_info, "setting datasum");
+			btrfs_clear_opt(info->mount_opt, NODATACOW);
+			btrfs_clear_opt(info->mount_opt, NODATASUM);
+			break;
 		case Opt_nodatacow:
 			if (!btrfs_test_opt(root, COMPRESS) ||
 				!btrfs_test_opt(root, FORCE_COMPRESS)) {

commit a258af7a3e395a1d36190c81614dca0bcb5f6012
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:31 2014 +0800

    btrfs: Add datacow mount option.
    
    Add datacow mount option to enable copy-on-write with
    remount option.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 76eecd13db19..6567865a2504 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -324,7 +324,7 @@ enum {
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
-	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl,
+	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
 	Opt_err,
 };
 
@@ -335,6 +335,7 @@ static match_table_t tokens = {
 	{Opt_device, "device=%s"},
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
+	{Opt_datacow, "datacow"},
 	{Opt_nobarrier, "nobarrier"},
 	{Opt_barrier, "barrier"},
 	{Opt_max_inline, "max_inline=%s"},
@@ -446,6 +447,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, NODATACOW);
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
+		case Opt_datacow:
+			if (btrfs_test_opt(root, NODATACOW))
+				btrfs_info(root->fs_info, "setting datacow");
+			btrfs_clear_opt(info->mount_opt, NODATACOW);
+			break;
 		case Opt_compress_force:
 		case Opt_compress_force_type:
 			compress_force = true;

commit bd0330ad2174d1a5f762eee2ee58f0148f10d575
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:30 2014 +0800

    btrfs: Add acl mount option.
    
    Add acl mount option to enable acl with remount option.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 98a682340935..76eecd13db19 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -324,7 +324,7 @@ enum {
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
-	Opt_noenospc_debug, Opt_noflushoncommit,
+	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl,
 	Opt_err,
 };
 
@@ -347,6 +347,7 @@ static match_table_t tokens = {
 	{Opt_ssd, "ssd"},
 	{Opt_ssd_spread, "ssd_spread"},
 	{Opt_nossd, "nossd"},
+	{Opt_acl, "acl"},
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
 	{Opt_flushoncommit, "flushoncommit"},
@@ -552,6 +553,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				goto out;
 			}
 			break;
+		case Opt_acl:
+			root->fs_info->sb->s_flags |= MS_POSIXACL;
+			break;
 		case Opt_noacl:
 			root->fs_info->sb->s_flags &= ~MS_POSIXACL;
 			break;

commit 2c9ee85671f66cd3ffc7067de47cc59ed6677299
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:29 2014 +0800

    btrfs: Add noflushoncommit mount option.
    
    Add noflushoncommit mount option to disable flush on commit with
    remount option.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 832540645c20..98a682340935 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -324,7 +324,7 @@ enum {
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
-	Opt_noenospc_debug,
+	Opt_noenospc_debug, Opt_noflushoncommit,
 	Opt_err,
 };
 
@@ -350,6 +350,7 @@ static match_table_t tokens = {
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
 	{Opt_flushoncommit, "flushoncommit"},
+	{Opt_noflushoncommit, "noflushoncommit"},
 	{Opt_ratio, "metadata_ratio=%d"},
 	{Opt_discard, "discard"},
 	{Opt_nodiscard, "nodiscard"},
@@ -562,6 +563,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_info(root->fs_info, "turning on flush-on-commit");
 			btrfs_set_opt(info->mount_opt, FLUSHONCOMMIT);
 			break;
+		case Opt_noflushoncommit:
+			if (btrfs_test_opt(root, FLUSHONCOMMIT))
+				btrfs_info(root->fs_info, "turning off flush-on-commit");
+			btrfs_clear_opt(info->mount_opt, FLUSHONCOMMIT);
+			break;
 		case Opt_ratio:
 			ret = match_int(&args[0], &intarg);
 			if (ret) {

commit 530362934332e4efac81d40583aa1225e64f556f
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:28 2014 +0800

    btrfs: Add noenospc_debug mount option.
    
    Add noenospc_debug mount option to disable ENOSPC debug with
    remount option.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e15377035dd5..832540645c20 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -324,6 +324,7 @@ enum {
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
+	Opt_noenospc_debug,
 	Opt_err,
 };
 
@@ -356,6 +357,7 @@ static match_table_t tokens = {
 	{Opt_clear_cache, "clear_cache"},
 	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
 	{Opt_enospc_debug, "enospc_debug"},
+	{Opt_noenospc_debug, "noenospc_debug"},
 	{Opt_subvolrootid, "subvolrootid=%d"},
 	{Opt_defrag, "autodefrag"},
 	{Opt_nodefrag, "noautodefrag"},
@@ -603,6 +605,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_enospc_debug:
 			btrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);
 			break;
+		case Opt_noenospc_debug:
+			btrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);
+			break;
 		case Opt_defrag:
 			btrfs_info(root->fs_info, "enabling auto defrag");
 			btrfs_set_opt(info->mount_opt, AUTO_DEFRAG);

commit e07a2ade4426a2cbafae4018aa7b6944bb627a6e
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:27 2014 +0800

    btrfs: Add nodiscard mount option.
    
    Add nodiscard mount option to disable discard with remount option.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 44513f3fbdc1..e15377035dd5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -323,7 +323,7 @@ enum {
 	Opt_no_space_cache, Opt_recovery, Opt_skip_balance,
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
-	Opt_commit_interval, Opt_barrier, Opt_nodefrag,
+	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
 	Opt_err,
 };
 
@@ -351,6 +351,7 @@ static match_table_t tokens = {
 	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_ratio, "metadata_ratio=%d"},
 	{Opt_discard, "discard"},
+	{Opt_nodiscard, "nodiscard"},
 	{Opt_space_cache, "space_cache"},
 	{Opt_clear_cache, "clear_cache"},
 	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
@@ -575,6 +576,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_discard:
 			btrfs_set_opt(info->mount_opt, DISCARD);
 			break;
+		case Opt_nodiscard:
+			btrfs_clear_opt(info->mount_opt, DISCARD);
+			break;
 		case Opt_space_cache:
 			btrfs_set_opt(info->mount_opt, SPACE_CACHE);
 			break;

commit fc0ca9af180b91aad2fbf2fe3b16a12e1e05a760
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:26 2014 +0800

    btrfs: Add noautodefrag mount option.
    
    Btrfs has autodefrag mount option but no pairing noautodefrag option,
    which makes it impossible to disable autodefrag without umount.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b02d25a64b2e..44513f3fbdc1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -323,7 +323,7 @@ enum {
 	Opt_no_space_cache, Opt_recovery, Opt_skip_balance,
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
-	Opt_commit_interval, Opt_barrier,
+	Opt_commit_interval, Opt_barrier, Opt_nodefrag,
 	Opt_err,
 };
 
@@ -357,6 +357,7 @@ static match_table_t tokens = {
 	{Opt_enospc_debug, "enospc_debug"},
 	{Opt_subvolrootid, "subvolrootid=%d"},
 	{Opt_defrag, "autodefrag"},
+	{Opt_nodefrag, "noautodefrag"},
 	{Opt_inode_cache, "inode_cache"},
 	{Opt_no_space_cache, "nospace_cache"},
 	{Opt_recovery, "recovery"},
@@ -602,6 +603,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_info(root->fs_info, "enabling auto defrag");
 			btrfs_set_opt(info->mount_opt, AUTO_DEFRAG);
 			break;
+		case Opt_nodefrag:
+			if (btrfs_test_opt(root, AUTO_DEFRAG))
+				btrfs_info(root->fs_info, "disabling auto defrag");
+			btrfs_clear_opt(info->mount_opt, AUTO_DEFRAG);
+			break;
 		case Opt_recovery:
 			btrfs_info(root->fs_info, "enabling auto recovery");
 			btrfs_set_opt(info->mount_opt, RECOVERY);

commit 842bef5891aaf13e2dede01d86397d810fde2dd8
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Jan 6 09:58:25 2014 +0800

    btrfs: Add "barrier" option to support "-o remount,barrier"
    
    Btrfs can be remounted without barrier, but there is no "barrier" option
    so nobody can remount btrfs back with barrier on. Only umount and
    mount again can re-enable barrier.(Quite awkward)
    
    Also the mount options in the document is also changed slightly for the
    further pairing options changes.
    
    Reported-by: Daniel Blueman <daniel@quora.org>
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Mike Fleetwood <mike.fleetwood@googlemail.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 15b6a1d4c533..b02d25a64b2e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -323,7 +323,7 @@ enum {
 	Opt_no_space_cache, Opt_recovery, Opt_skip_balance,
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
-	Opt_commit_interval,
+	Opt_commit_interval, Opt_barrier,
 	Opt_err,
 };
 
@@ -335,6 +335,7 @@ static match_table_t tokens = {
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
 	{Opt_nobarrier, "nobarrier"},
+	{Opt_barrier, "barrier"},
 	{Opt_max_inline, "max_inline=%s"},
 	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_thread_pool, "thread_pool=%d"},
@@ -494,6 +495,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_clear_opt(info->mount_opt, SSD);
 			btrfs_clear_opt(info->mount_opt, SSD_SPREAD);
 			break;
+		case Opt_barrier:
+			if (btrfs_test_opt(root, NOBARRIER))
+				btrfs_info(root->fs_info, "turning on barriers");
+			btrfs_clear_opt(info->mount_opt, NOBARRIER);
+			break;
 		case Opt_nobarrier:
 			btrfs_info(root->fs_info, "turning off barriers");
 			btrfs_set_opt(info->mount_opt, NOBARRIER);

commit efe120a067c8674a8ae21b194f0e68f098b61ee2
Author: Frank Holton <fholton@gmail.com>
Date:   Fri Dec 20 11:37:06 2013 -0500

    Btrfs: convert printk to btrfs_ and fix BTRFS prefix
    
    Convert all applicable cases of printk and pr_* to the btrfs_* macros.
    
    Fix all uses of the BTRFS prefix.
    
    Signed-off-by: Frank Holton <fholton@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d71a11d13dfa..15b6a1d4c533 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -152,11 +152,12 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		vaf.fmt = fmt;
 		vaf.va = &args;
 
-		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: errno=%d %s (%pV)\n",
+		printk(KERN_CRIT
+			"BTRFS: error (device %s) in %s:%d: errno=%d %s (%pV)\n",
 			sb->s_id, function, line, errno, errstr, &vaf);
 		va_end(args);
 	} else {
-		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: errno=%d %s\n",
+		printk(KERN_CRIT "BTRFS: error (device %s) in %s:%d: errno=%d %s\n",
 			sb->s_id, function, line, errno, errstr);
 	}
 
@@ -250,7 +251,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 	 */
 	if (!test_and_set_bit(BTRFS_FS_STATE_TRANS_ABORTED,
 				&root->fs_info->fs_state)) {
-		WARN(1, KERN_DEBUG "btrfs: Transaction aborted (error %d)\n",
+		WARN(1, KERN_DEBUG "BTRFS: Transaction aborted (error %d)\n",
 				errno);
 	}
 	trans->aborted = errno;
@@ -294,8 +295,8 @@ void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 		panic(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\n",
 			s_id, function, line, &vaf, errno, errstr);
 
-	printk(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\n",
-	       s_id, function, line, &vaf, errno, errstr);
+	btrfs_crit(fs_info, "panic in %s:%d: %pV (errno=%d %s)",
+		   function, line, &vaf, errno, errstr);
 	va_end(args);
 	/* Caller calls BUG() */
 }
@@ -409,7 +410,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_degraded:
-			printk(KERN_INFO "btrfs: allowing degraded mounts\n");
+			btrfs_info(root->fs_info, "allowing degraded mounts");
 			btrfs_set_opt(info->mount_opt, DEGRADED);
 			break;
 		case Opt_subvol:
@@ -422,15 +423,16 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			 */
 			break;
 		case Opt_nodatasum:
-			printk(KERN_INFO "btrfs: setting nodatasum\n");
+			btrfs_info(root->fs_info, "setting nodatasum");
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_nodatacow:
 			if (!btrfs_test_opt(root, COMPRESS) ||
 				!btrfs_test_opt(root, FORCE_COMPRESS)) {
-					printk(KERN_INFO "btrfs: setting nodatacow, compression disabled\n");
+					btrfs_info(root->fs_info,
+						"setting nodatacow, compression disabled");
 			} else {
-				printk(KERN_INFO "btrfs: setting nodatacow\n");
+				btrfs_info(root->fs_info, "setting nodatacow");
 			}
 			btrfs_clear_opt(info->mount_opt, COMPRESS);
 			btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
@@ -470,7 +472,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 
 			if (compress_force) {
 				btrfs_set_opt(info->mount_opt, FORCE_COMPRESS);
-				pr_info("btrfs: force %s compression\n",
+				btrfs_info(root->fs_info, "force %s compression",
 					compress_type);
 			} else if (btrfs_test_opt(root, COMPRESS)) {
 				pr_info("btrfs: use %s compression\n",
@@ -478,24 +480,22 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			}
 			break;
 		case Opt_ssd:
-			printk(KERN_INFO "btrfs: use ssd allocation scheme\n");
+			btrfs_info(root->fs_info, "use ssd allocation scheme");
 			btrfs_set_opt(info->mount_opt, SSD);
 			break;
 		case Opt_ssd_spread:
-			printk(KERN_INFO "btrfs: use spread ssd "
-			       "allocation scheme\n");
+			btrfs_info(root->fs_info, "use spread ssd allocation scheme");
 			btrfs_set_opt(info->mount_opt, SSD);
 			btrfs_set_opt(info->mount_opt, SSD_SPREAD);
 			break;
 		case Opt_nossd:
-			printk(KERN_INFO "btrfs: not using ssd allocation "
-			       "scheme\n");
+			btrfs_info(root->fs_info, "not using ssd allocation scheme");
 			btrfs_set_opt(info->mount_opt, NOSSD);
 			btrfs_clear_opt(info->mount_opt, SSD);
 			btrfs_clear_opt(info->mount_opt, SSD_SPREAD);
 			break;
 		case Opt_nobarrier:
-			printk(KERN_INFO "btrfs: turning off barriers\n");
+			btrfs_info(root->fs_info, "turning off barriers");
 			btrfs_set_opt(info->mount_opt, NOBARRIER);
 			break;
 		case Opt_thread_pool:
@@ -520,7 +520,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 						info->max_inline,
 						root->sectorsize);
 				}
-				printk(KERN_INFO "btrfs: max_inline at %llu\n",
+				btrfs_info(root->fs_info, "max_inline at %llu",
 					info->max_inline);
 			} else {
 				ret = -ENOMEM;
@@ -534,8 +534,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				info->alloc_start = memparse(num, NULL);
 				mutex_unlock(&info->chunk_mutex);
 				kfree(num);
-				printk(KERN_INFO
-					"btrfs: allocations start at %llu\n",
+				btrfs_info(root->fs_info, "allocations start at %llu",
 					info->alloc_start);
 			} else {
 				ret = -ENOMEM;
@@ -546,11 +545,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			root->fs_info->sb->s_flags &= ~MS_POSIXACL;
 			break;
 		case Opt_notreelog:
-			printk(KERN_INFO "btrfs: disabling tree log\n");
+			btrfs_info(root->fs_info, "disabling tree log");
 			btrfs_set_opt(info->mount_opt, NOTREELOG);
 			break;
 		case Opt_flushoncommit:
-			printk(KERN_INFO "btrfs: turning on flush-on-commit\n");
+			btrfs_info(root->fs_info, "turning on flush-on-commit");
 			btrfs_set_opt(info->mount_opt, FLUSHONCOMMIT);
 			break;
 		case Opt_ratio:
@@ -559,7 +558,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				goto out;
 			} else if (intarg >= 0) {
 				info->metadata_ratio = intarg;
-				printk(KERN_INFO "btrfs: metadata ratio %d\n",
+				btrfs_info(root->fs_info, "metadata ratio %d",
 				       info->metadata_ratio);
 			} else {
 				ret = -EINVAL;
@@ -576,15 +575,15 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);
 			break;
 		case Opt_no_space_cache:
-			printk(KERN_INFO "btrfs: disabling disk space caching\n");
+			btrfs_info(root->fs_info, "disabling disk space caching");
 			btrfs_clear_opt(info->mount_opt, SPACE_CACHE);
 			break;
 		case Opt_inode_cache:
-			printk(KERN_INFO "btrfs: enabling inode map caching\n");
+			btrfs_info(root->fs_info, "enabling inode map caching");
 			btrfs_set_opt(info->mount_opt, INODE_MAP_CACHE);
 			break;
 		case Opt_clear_cache:
-			printk(KERN_INFO "btrfs: force clearing of disk cache\n");
+			btrfs_info(root->fs_info, "force clearing of disk cache");
 			btrfs_set_opt(info->mount_opt, CLEAR_CACHE);
 			break;
 		case Opt_user_subvol_rm_allowed:
@@ -594,11 +593,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);
 			break;
 		case Opt_defrag:
-			printk(KERN_INFO "btrfs: enabling auto defrag\n");
+			btrfs_info(root->fs_info, "enabling auto defrag");
 			btrfs_set_opt(info->mount_opt, AUTO_DEFRAG);
 			break;
 		case Opt_recovery:
-			printk(KERN_INFO "btrfs: enabling auto recovery\n");
+			btrfs_info(root->fs_info, "enabling auto recovery");
 			btrfs_set_opt(info->mount_opt, RECOVERY);
 			break;
 		case Opt_skip_balance:
@@ -606,14 +605,14 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			break;
 #ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
 		case Opt_check_integrity_including_extent_data:
-			printk(KERN_INFO "btrfs: enabling check integrity"
-			       " including extent data\n");
+			btrfs_info(root->fs_info,
+				   "enabling check integrity including extent data");
 			btrfs_set_opt(info->mount_opt,
 				      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);
 			btrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);
 			break;
 		case Opt_check_integrity:
-			printk(KERN_INFO "btrfs: enabling check integrity\n");
+			btrfs_info(root->fs_info, "enabling check integrity");
 			btrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);
 			break;
 		case Opt_check_integrity_print_mask:
@@ -622,8 +621,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				goto out;
 			} else if (intarg >= 0) {
 				info->check_integrity_print_mask = intarg;
-				printk(KERN_INFO "btrfs:"
-				       " check_integrity_print_mask 0x%x\n",
+				btrfs_info(root->fs_info, "check_integrity_print_mask 0x%x",
 				       info->check_integrity_print_mask);
 			} else {
 				ret = -EINVAL;
@@ -634,8 +632,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_check_integrity_including_extent_data:
 		case Opt_check_integrity:
 		case Opt_check_integrity_print_mask:
-			printk(KERN_ERR "btrfs: support for check_integrity*"
-			       " not compiled in!\n");
+			btrfs_err(root->fs_info,
+				"support for check_integrity* not compiled in!");
 			ret = -EINVAL;
 			goto out;
 #endif
@@ -655,28 +653,24 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			intarg = 0;
 			ret = match_int(&args[0], &intarg);
 			if (ret < 0) {
-				printk(KERN_ERR
-					"btrfs: invalid commit interval\n");
+				btrfs_err(root->fs_info, "invalid commit interval");
 				ret = -EINVAL;
 				goto out;
 			}
 			if (intarg > 0) {
 				if (intarg > 300) {
-					printk(KERN_WARNING
-					    "btrfs: excessive commit interval %d\n",
+					btrfs_warn(root->fs_info, "excessive commit interval %d",
 							intarg);
 				}
 				info->commit_interval = intarg;
 			} else {
-				printk(KERN_INFO
-				    "btrfs: using default commit interval %ds\n",
+				btrfs_info(root->fs_info, "using default commit interval %ds",
 				    BTRFS_DEFAULT_COMMIT_INTERVAL);
 				info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;
 			}
 			break;
 		case Opt_err:
-			printk(KERN_INFO "btrfs: unrecognized mount option "
-			       "'%s'\n", p);
+			btrfs_info(root->fs_info, "unrecognized mount option '%s'", p);
 			ret = -EINVAL;
 			goto out;
 		default:
@@ -685,7 +679,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	}
 out:
 	if (!ret && btrfs_test_opt(root, SPACE_CACHE))
-		printk(KERN_INFO "btrfs: disk space caching is enabled\n");
+		btrfs_info(root->fs_info, "disk space caching is enabled");
 	kfree(orig);
 	return ret;
 }
@@ -748,7 +742,8 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 			break;
 		case Opt_subvolrootid:
 			printk(KERN_WARNING
-				"btrfs: 'subvolrootid' mount option is deprecated and has no effect\n");
+				"BTRFS: 'subvolrootid' mount option is deprecated and has "
+				"no effect\n");
 			break;
 		case Opt_device:
 			device_name = match_strdup(&args[0]);
@@ -877,7 +872,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_flags |= MS_I_VERSION;
 	err = open_ctree(sb, fs_devices, (char *)data);
 	if (err) {
-		printk("btrfs: open_ctree failed\n");
+		printk(KERN_ERR "BTRFS: open_ctree failed\n");
 		return err;
 	}
 
@@ -1115,7 +1110,7 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 		dput(root);
 		root = ERR_PTR(-EINVAL);
 		deactivate_locked_super(s);
-		printk(KERN_ERR "btrfs: '%s' is not a valid subvolume\n",
+		printk(KERN_ERR "BTRFS: '%s' is not a valid subvolume\n",
 				subvol_name);
 	}
 
@@ -1240,7 +1235,7 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 
 	fs_info->thread_pool_size = new_pool_size;
 
-	printk(KERN_INFO "btrfs: resize thread pool %d -> %d\n",
+	btrfs_info(fs_info, "resize thread pool %d -> %d",
 	       old_pool_size, new_pool_size);
 
 	btrfs_set_max_workers(&fs_info->generic_worker, new_pool_size);
@@ -1346,7 +1341,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	} else {
 		if (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {
 			btrfs_err(fs_info,
-				"Remounting read-write after error is not allowed\n");
+				"Remounting read-write after error is not allowed");
 			ret = -EINVAL;
 			goto restore;
 		}
@@ -1358,8 +1353,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (fs_info->fs_devices->missing_devices >
 		     fs_info->num_tolerated_disk_barrier_failures &&
 		    !(*flags & MS_RDONLY)) {
-			printk(KERN_WARNING
-			       "Btrfs: too many missing devices, writeable remount is not allowed\n");
+			btrfs_warn(fs_info,
+				"too many missing devices, writeable remount is not allowed");
 			ret = -EACCES;
 			goto restore;
 		}
@@ -1384,16 +1379,15 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 
 		ret = btrfs_resume_dev_replace_async(fs_info);
 		if (ret) {
-			pr_warn("btrfs: failed to resume dev_replace\n");
+			btrfs_warn(fs_info, "failed to resume dev_replace");
 			goto restore;
 		}
 
 		if (!fs_info->uuid_root) {
-			pr_info("btrfs: creating UUID tree\n");
+			btrfs_info(fs_info, "creating UUID tree");
 			ret = btrfs_create_uuid_tree(fs_info);
 			if (ret) {
-				pr_warn("btrfs: failed to create the uuid tree"
-					"%d\n", ret);
+				btrfs_warn(fs_info, "failed to create the UUID tree %d", ret);
 				goto restore;
 			}
 		}
@@ -1773,7 +1767,7 @@ static int btrfs_interface_init(void)
 static void btrfs_interface_exit(void)
 {
 	if (misc_deregister(&btrfs_misc) < 0)
-		printk(KERN_INFO "btrfs: misc_deregister failed for control device\n");
+		printk(KERN_INFO "BTRFS: misc_deregister failed for control device\n");
 }
 
 static void btrfs_print_info(void)

commit a7e252af5a819eb71c9494e62b2bfca982e92f84
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Fri Nov 22 18:47:59 2013 +0800

    Btrfs: don't clear the default compression type
    
    We met a oops caused by the wrong compression type:
    [  556.512356] BUG: unable to handle kernel NULL pointer dereference at           (null)
    [  556.512370] IP: [<ffffffff811dbaa0>] __list_del_entry+0x1/0x98
    [SNIP]
    [  556.512490]  [<ffffffff811dbb44>] ? list_del+0xd/0x2b
    [  556.512539]  [<ffffffffa05dd5ce>] find_workspace+0x97/0x175 [btrfs]
    [  556.512546]  [<ffffffff813c14b5>] ? _raw_spin_lock+0xe/0x10
    [  556.512576]  [<ffffffffa05de276>] btrfs_compress_pages+0x2d/0xa2 [btrfs]
    [  556.512601]  [<ffffffffa05af060>] compress_file_range.constprop.54+0x1f2/0x4e8 [btrfs]
    [  556.512627]  [<ffffffffa05af388>] async_cow_start+0x32/0x4d [btrfs]
    [  556.512655]  [<ffffffffa05cc7a1>] worker_loop+0x144/0x4c3 [btrfs]
    [  556.512661]  [<ffffffff81059404>] ? finish_task_switch+0x80/0xb8
    [  556.512689]  [<ffffffffa05cc65d>] ? btrfs_queue_worker+0x244/0x244 [btrfs]
    [  556.512695]  [<ffffffff8104fa4e>] kthread+0x8d/0x95
    [  556.512699]  [<ffffffff81050000>] ? bit_waitqueue+0x34/0x7d
    [  556.512704]  [<ffffffff8104f9c1>] ? __kthread_parkme+0x65/0x65
    [  556.512709]  [<ffffffff813c7eec>] ret_from_fork+0x7c/0xb0
    [  556.512713]  [<ffffffff8104f9c1>] ? __kthread_parkme+0x65/0x65
    
    Steps to reproduce:
     # mkfs.btrfs -f <dev>
     # mount -o nodatacow <dev> <mnt>
     # touch <mnt>/<file>
     # chattr =c <mnt>/<file>
     # dd if=/dev/zero of=<mnt>/<file> bs=1M count=10
    
    It is because we cleared the default compression type when setting the
    nodatacow. In fact, we needn't do it because we have used COMPRESS flag to
    indicate if we need compressed the file data or not, needn't use the
    variant -- compress_type -- in btrfs_info to do the same thing, and just
    use it to hold the default compression type. Or we would get a wrong compress
    type for a file whose own compress flag is set but the compress flag of its
    filesystem is not set.
    
    Reported-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2d8ac1bf0cf9..d71a11d13dfa 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -432,7 +432,6 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			} else {
 				printk(KERN_INFO "btrfs: setting nodatacow\n");
 			}
-			info->compress_type = BTRFS_COMPRESS_NONE;
 			btrfs_clear_opt(info->mount_opt, COMPRESS);
 			btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
 			btrfs_set_opt(info->mount_opt, NODATACOW);
@@ -461,7 +460,6 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				btrfs_set_fs_incompat(info, COMPRESS_LZO);
 			} else if (strncmp(args[0].from, "no", 2) == 0) {
 				compress_type = "no";
-				info->compress_type = BTRFS_COMPRESS_NONE;
 				btrfs_clear_opt(info->mount_opt, COMPRESS);
 				btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
 				compress_force = false;
@@ -474,9 +472,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				btrfs_set_opt(info->mount_opt, FORCE_COMPRESS);
 				pr_info("btrfs: force %s compression\n",
 					compress_type);
-			} else
+			} else if (btrfs_test_opt(root, COMPRESS)) {
 				pr_info("btrfs: use %s compression\n",
 					compress_type);
+			}
 			break;
 		case Opt_ssd:
 			printk(KERN_INFO "btrfs: use ssd allocation scheme\n");

commit b02441999efcc6152b87cd58e7970bb7843f76cf
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Mon Nov 4 23:13:25 2013 +0800

    Btrfs: don't wait for the completion of all the ordered extents
    
    It is very likely that there are lots of ordered extents in the filesytem,
    if we wait for the completion of all of them when we want to reclaim some
    space for the metadata space reservation, we would be blocked for a long
    time. The performance would drop down suddenly for a long time.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1de6d4d67431..2d8ac1bf0cf9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -920,7 +920,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_wait_all_ordered_extents(fs_info);
+	btrfs_wait_ordered_roots(fs_info, -1);
 
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {

commit d9b0d9ba04cf99abff9125b688c03e154598a644
Author: Dulshani Gunawardhana <dulshani.gunawardhana89@gmail.com>
Date:   Thu Oct 31 10:32:18 2013 +0530

    btrfs: Replace kmalloc with kmalloc_array
    
    Replace kmalloc(size * nr, ) with kmalloc_array(nr, size), thus making
    it easier to check is that the calculation doesn't wrap or return a smaller allocation
    
    Signed-off-by: Dulshani Gunawardhana <dulshani.gunawardhana89@gmail.com>
    Reviewed-by: Zach Brown <zab@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c9079db7441e..1de6d4d67431 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1470,7 +1470,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	nr_devices = fs_info->fs_devices->open_devices;
 	BUG_ON(!nr_devices);
 
-	devices_info = kmalloc(sizeof(*devices_info) * nr_devices,
+	devices_info = kmalloc_array(nr_devices, sizeof(*devices_info),
 			       GFP_NOFS);
 	if (!devices_info)
 		return -ENOMEM;

commit 8b558c5f097b636209b654f4d7775ac96054d6e3
Author: Zach Brown <zab@redhat.com>
Date:   Wed Oct 16 12:10:34 2013 -0700

    btrfs: remove fs/btrfs/compat.h
    
    fs/btrfs/compat.h only contained trivial macro wrappers of drop_nlink()
    and inc_nlink().  This doesn't belong in mainline.
    
    Signed-off-by: Zach Brown <zab@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 02f552f11829..c9079db7441e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -42,7 +42,6 @@
 #include <linux/cleancache.h>
 #include <linux/ratelimit.h>
 #include <linux/btrfs.h>
-#include "compat.h"
 #include "delayed-inode.h"
 #include "ctree.h"
 #include "disk-io.h"

commit 361c093d7f99c3f6cbb07d5c580ce778ab418c42
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Fri Oct 11 17:14:58 2013 +0200

    Btrfs: Wait for uuid-tree rebuild task on remount read-only
    
    If the user remounts the filesystem read-only while the uuid-tree
    scan and rebuild task is still running (this happens once after the
    filesystem was mounted with an old kernel, or when forced with the
    mount options), the remount should wait on the tasks completion
    before setting the filesystem read-only. Otherwise the background
    task continues to write to the filesystem which is apparently not
    what users expect.
    
    The reproducer:
    
    TEST_DEV=/dev/sdzzzzz1
    TEST_MNT=/mnt
    mkfs.btrfs -f $TEST_DEV
    mount $TEST_DEV $TEST_MNT
    for i in `seq 50000`; do btrfs subvolume create ${TEST_MNT}/$i; done
    umount $TEST_MNT
    mount $TEST_DEV $TEST_MNT -o rescan_uuid_tree
    sleep 1
    ps -elf | fgrep '[btrfs-uuid]' | grep -v grep
    mount $TEST_DEV $TEST_MNT -o ro,remount
    ps -elf | fgrep '[btrfs-uuid]' | grep -v grep
    sleep 1
    umount $TEST_MNT
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1f62c1ccab1f..02f552f11829 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1330,6 +1330,12 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		 * this also happens on 'umount -rf' or on shutdown, when
 		 * the filesystem is busy.
 		 */
+
+		/* wait for the uuid_scan task to finish */
+		down(&fs_info->uuid_tree_rescan_sem);
+		/* avoid complains from lockdep et al. */
+		up(&fs_info->uuid_tree_rescan_sem);
+
 		sb->s_flags |= MS_RDONLY;
 
 		btrfs_dev_replace_suspend_for_unmount(fs_info);

commit aaedb55bc08f384b7f57dbb3222a511baed4decf
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Oct 11 14:44:09 2013 -0400

    Btrfs: add tests for btrfs_get_extent
    
    I'm going to be removing hole extents in the near future so I wanted to make a
    sanity test for btrfs_get_extent to make sure I don't break anything in the
    meantime.  This patch just puts btrfs_get_extent through its paces by giving it
    a completely unreasonable mapping to look at and make sure it is giving us back
    maps that make sense.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 78041e34d15a..1f62c1ccab1f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1802,6 +1802,9 @@ static int btrfs_run_sanity_tests(void)
 	if (ret)
 		goto out;
 	ret = btrfs_test_extent_io();
+	if (ret)
+		goto out;
+	ret = btrfs_test_inodes();
 out:
 	btrfs_destroy_test_fs();
 	return ret;

commit 294e30fee35d3151d100cfe59e839c2dbc16a374
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Wed Oct 9 12:00:56 2013 -0400

    Btrfs: add tests for find_lock_delalloc_range
    
    So both Liu and I made huge messes of find_lock_delalloc_range trying to fix
    stuff, me first by fixing extent size, then him by fixing something I broke and
    then me again telling him to fix it a different way.  So this is obviously a
    candidate for some testing.  This patch adds a pseudo fs so we can allocate fake
    inodes for tests that need an inode or pages.  Then it addes a bunch of tests to
    make sure find_lock_delalloc_range is acting the way it is supposed to.  With
    this patch and all of our previous patches to find_lock_delalloc_range I am sure
    it is working as expected now.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0e398657d759..78041e34d15a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1791,10 +1791,20 @@ static int btrfs_run_sanity_tests(void)
 {
 	int ret;
 
-	ret = btrfs_test_free_space_cache();
+	ret = btrfs_init_test_fs();
 	if (ret)
 		return ret;
-	return btrfs_test_extent_buffer_operations();
+
+	ret = btrfs_test_free_space_cache();
+	if (ret)
+		goto out;
+	ret = btrfs_test_extent_buffer_operations();
+	if (ret)
+		goto out;
+	ret = btrfs_test_extent_io();
+out:
+	btrfs_destroy_test_fs();
+	return ret;
 }
 
 static int __init init_btrfs_fs(void)

commit 06ea65a398a2501e94beee3a425d07e1846ff25a
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Thu Sep 19 16:07:01 2013 -0400

    Btrfs: add a sanity test for btrfs_split_item
    
    While looking at somebodys corruption I became completely convinced that
    btrfs_split_item was broken, so I wrote this test to verify that it was working
    as it was supposed to.  Thankfully it appears to be working as intended, so just
    add this test to make sure nobody breaks it in the future.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e913328d0f2a..0e398657d759 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1789,7 +1789,12 @@ static void btrfs_print_info(void)
 
 static int btrfs_run_sanity_tests(void)
 {
-	return btrfs_test_free_space_cache();
+	int ret;
+
+	ret = btrfs_test_free_space_cache();
+	if (ret)
+		return ret;
+	return btrfs_test_extent_buffer_operations();
 }
 
 static int __init init_btrfs_fs(void)

commit 94aebfb2e7d83748d882992196cb05dd39ba1807
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Sep 20 22:33:20 2013 -0400

    Btrfs: create the uuid tree on remount rw
    
    Users have been complaining of the uuid tree stuff warning that there is no uuid
    root when trying to do snapshot operations.  This is because if you mount -o ro
    we will not create the uuid tree.  But then if you mount -o rw,remount we will
    still not create it and then any subsequent snapshot/subvol operations you try
    to do will fail gloriously.  Fix this by creating the uuid_root on remount rw if
    it was not already there.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6ab0df59b6c4..e913328d0f2a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1383,6 +1383,16 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 			pr_warn("btrfs: failed to resume dev_replace\n");
 			goto restore;
 		}
+
+		if (!fs_info->uuid_root) {
+			pr_info("btrfs: creating UUID tree\n");
+			ret = btrfs_create_uuid_tree(fs_info);
+			if (ret) {
+				pr_warn("btrfs: failed to create the uuid tree"
+					"%d\n", ret);
+				goto restore;
+			}
+		}
 		sb->s_flags &= ~MS_RDONLY;
 	}
 out:

commit 6ef3de9c9252b186720122d3ae7122a81d49f8ee
Author: David Sterba <dsterba@suse.cz>
Date:   Fri Sep 13 17:41:20 2013 +0200

    btrfs: refuse to remount read-write after abort
    
    It's still possible to flip the filesystem into RW mode after it's
    remounted RO due to an abort. There are lots of places that check for
    the superblock error bit and will not write data, but we should not let
    the filesystem appear read-write.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b341da3ee3ee..6ab0df59b6c4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1340,6 +1340,12 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (ret)
 			goto restore;
 	} else {
+		if (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {
+			btrfs_err(fs_info,
+				"Remounting read-write after error is not allowed\n");
+			ret = -EINVAL;
+			goto restore;
+		}
 		if (fs_info->fs_devices->rw_devices == 0) {
 			ret = -EACCES;
 			goto restore;

commit f0de181c9b48a397c5a2fbe63dcdd2a26a872695
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Tue Sep 17 10:55:51 2013 -0400

    Btrfs: kill delay_iput arg to the wait_ordered functions
    
    This is a left over of how we used to wait for ordered extents, which was to
    grab the inode and then run filemap flush on it.  However if we have an ordered
    extent then we already are holding a ref on the inode, and we just use
    btrfs_start_ordered_extent anyway, so there is no reason to have an extra ref on
    the inode to start work on the ordered extent.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 58cb83f23b1a..b341da3ee3ee 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -921,7 +921,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_wait_all_ordered_extents(fs_info, 1);
+	btrfs_wait_all_ordered_extents(fs_info);
 
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {

commit 79556c3d882a848c8faabddc487b033c4e78f7c5
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Tue Sep 3 15:25:27 2013 +0200

    btrfs: show compiled-in config features at module load time
    
    We want to know if there are debugging features compiled in, this may
    affect performance. The message is printed before the sanity checks.
    
    (This commit message is a copy of David Sterba's commit message when
    he introduced btrfs_print_info()).
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3aab10ce63e8..58cb83f23b1a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1762,6 +1762,9 @@ static void btrfs_print_info(void)
 #ifdef CONFIG_BTRFS_DEBUG
 			", debug=on"
 #endif
+#ifdef CONFIG_BTRFS_ASSERT
+			", assert=on"
+#endif
 #ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
 			", integrity-checker=on"
 #endif

commit b9e9a6cbc6d25b89d8007e5a680319e07921ead8
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Fri Aug 9 13:25:36 2013 +0800

    Btrfs: allocate prelim_ref with a slab allocater
    
    struct __prelim_ref is allocated and freed frequently when
    walking backref tree, using slab allocater can not only
    speed up allocating but also detect memory leaks.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Reviewed-by: Miao Xie <miaox@cn.fujitsu.com>
    Reviewed-by: Jan Schmidt <list.btrfs@jan-o-sch.net>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4d5d0f3eb0d8..3aab10ce63e8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -56,6 +56,7 @@
 #include "rcu-string.h"
 #include "dev-replace.h"
 #include "free-space-cache.h"
+#include "backref.h"
 #include "tests/btrfs-tests.h"
 
 #define CREATE_TRACE_POINTS
@@ -1810,6 +1811,10 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_auto_defrag;
 
+	err = btrfs_prelim_ref_init();
+	if (err)
+		goto free_prelim_ref;
+
 	err = btrfs_interface_init();
 	if (err)
 		goto free_delayed_ref;
@@ -1830,6 +1835,8 @@ static int __init init_btrfs_fs(void)
 
 unregister_ioctl:
 	btrfs_interface_exit();
+free_prelim_ref:
+	btrfs_prelim_ref_exit();
 free_delayed_ref:
 	btrfs_delayed_ref_exit();
 free_auto_defrag:
@@ -1856,6 +1863,7 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_delayed_ref_exit();
 	btrfs_auto_defrag_exit();
 	btrfs_delayed_inode_exit();
+	btrfs_prelim_ref_exit();
 	ordered_data_exit();
 	extent_map_exit();
 	extent_io_exit();

commit c1c9ff7c94e83fae89a742df74db51156869bad5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Aug 20 13:20:07 2013 +0200

    Btrfs: Remove superfluous casts from u64 to unsigned long long
    
    u64 is "unsigned long long" on all architectures now, so there's no need to
    cast it when formatting it using the "ll" length modifier.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 57090b4284fe..4d5d0f3eb0d8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -522,7 +522,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 						root->sectorsize);
 				}
 				printk(KERN_INFO "btrfs: max_inline at %llu\n",
-					(unsigned long long)info->max_inline);
+					info->max_inline);
 			} else {
 				ret = -ENOMEM;
 				goto out;
@@ -537,7 +537,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				kfree(num);
 				printk(KERN_INFO
 					"btrfs: allocations start at %llu\n",
-					(unsigned long long)info->alloc_start);
+					info->alloc_start);
 			} else {
 				ret = -ENOMEM;
 				goto out;
@@ -947,11 +947,9 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 	if (btrfs_test_opt(root, NOBARRIER))
 		seq_puts(seq, ",nobarrier");
 	if (info->max_inline != 8192 * 1024)
-		seq_printf(seq, ",max_inline=%llu",
-			   (unsigned long long)info->max_inline);
+		seq_printf(seq, ",max_inline=%llu", info->max_inline);
 	if (info->alloc_start != 0)
-		seq_printf(seq, ",alloc_start=%llu",
-			   (unsigned long long)info->alloc_start);
+		seq_printf(seq, ",alloc_start=%llu", info->alloc_start);
 	if (info->thread_pool_size !=  min_t(unsigned long,
 					     num_online_cpus() + 2, 8))
 		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);

commit f420ee1e923b931eeef5e2928791e84b1197cab3
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Thu Aug 15 17:11:24 2013 +0200

    Btrfs: add mount option to force UUID tree checking
    
    This should never be needed, but since all functions are there
    to check and rebuild the UUID tree, a mount option is added that
    allows to force this check and rebuild procedure.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1bd0bb523660..57090b4284fe 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -321,7 +321,7 @@ enum {
 	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag, Opt_inode_cache,
 	Opt_no_space_cache, Opt_recovery, Opt_skip_balance,
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
-	Opt_check_integrity_print_mask, Opt_fatal_errors,
+	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
 	Opt_commit_interval,
 	Opt_err,
 };
@@ -362,6 +362,7 @@ static match_table_t tokens = {
 	{Opt_check_integrity, "check_int"},
 	{Opt_check_integrity_including_extent_data, "check_int_data"},
 	{Opt_check_integrity_print_mask, "check_int_print_mask=%d"},
+	{Opt_rescan_uuid_tree, "rescan_uuid_tree"},
 	{Opt_fatal_errors, "fatal_errors=%s"},
 	{Opt_commit_interval, "commit=%d"},
 	{Opt_err, NULL},
@@ -572,6 +573,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_space_cache:
 			btrfs_set_opt(info->mount_opt, SPACE_CACHE);
 			break;
+		case Opt_rescan_uuid_tree:
+			btrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);
+			break;
 		case Opt_no_space_cache:
 			printk(KERN_INFO "btrfs: disabling disk space caching\n");
 			btrfs_clear_opt(info->mount_opt, SPACE_CACHE);
@@ -979,6 +983,8 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",space_cache");
 	else
 		seq_puts(seq, ",nospace_cache");
+	if (btrfs_test_opt(root, RESCAN_UUID_TREE))
+		seq_puts(seq, ",rescan_uuid_tree");
 	if (btrfs_test_opt(root, CLEAR_CACHE))
 		seq_puts(seq, ",clear_cache");
 	if (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))

commit dc11dd5d707a4157882f281c96055d6894d10c8c
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Wed Aug 14 15:05:12 2013 -0400

    Btrfs: separate out tests into their own directory
    
    The plan is to have a bunch of unit tests that run when btrfs is loaded when you
    build with the appropriate config option.  My ultimate goal is to have a test
    for every non-static function we have, but at first I'm going to focus on the
    things that cause us the most problems.  To start out with this just adds a
    tests/ directory and moves the existing free space cache tests into that
    directory and sets up all of the infrastructure.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 196790375bb3..1bd0bb523660 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -56,6 +56,7 @@
 #include "rcu-string.h"
 #include "dev-replace.h"
 #include "free-space-cache.h"
+#include "tests/btrfs-tests.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/btrfs.h>
@@ -1762,6 +1763,11 @@ static void btrfs_print_info(void)
 			"\n");
 }
 
+static int btrfs_run_sanity_tests(void)
+{
+	return btrfs_test_free_space_cache();
+}
+
 static int __init init_btrfs_fs(void)
 {
 	int err;
@@ -1804,14 +1810,17 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_delayed_ref;
 
-	err = register_filesystem(&btrfs_fs_type);
-	if (err)
-		goto unregister_ioctl;
-
 	btrfs_init_lockdep();
 
 	btrfs_print_info();
-	btrfs_test_free_space_cache();
+
+	err = btrfs_run_sanity_tests();
+	if (err)
+		goto unregister_ioctl;
+
+	err = register_filesystem(&btrfs_fs_type);
+	if (err)
+		goto unregister_ioctl;
 
 	return 0;
 

commit 8b87dc17fbc7443bf4c6c096279c35e89fb51326
Author: David Sterba <dsterba@suse.cz>
Date:   Thu Aug 1 18:14:52 2013 +0200

    btrfs: add mount option to set commit interval
    
    I'ts hardcoded to 30 seconds which is fine for most users. Higher values
    defer data being synced to permanent storage with obvious consequences
    when the system crashes. The upper bound is not forced, but a warning is
    printed if it's more than 300 seconds (5 minutes).
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2cc5b80eeae9..196790375bb3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -321,6 +321,7 @@ enum {
 	Opt_no_space_cache, Opt_recovery, Opt_skip_balance,
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
 	Opt_check_integrity_print_mask, Opt_fatal_errors,
+	Opt_commit_interval,
 	Opt_err,
 };
 
@@ -361,6 +362,7 @@ static match_table_t tokens = {
 	{Opt_check_integrity_including_extent_data, "check_int_data"},
 	{Opt_check_integrity_print_mask, "check_int_print_mask=%d"},
 	{Opt_fatal_errors, "fatal_errors=%s"},
+	{Opt_commit_interval, "commit=%d"},
 	{Opt_err, NULL},
 };
 
@@ -645,6 +647,29 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				goto out;
 			}
 			break;
+		case Opt_commit_interval:
+			intarg = 0;
+			ret = match_int(&args[0], &intarg);
+			if (ret < 0) {
+				printk(KERN_ERR
+					"btrfs: invalid commit interval\n");
+				ret = -EINVAL;
+				goto out;
+			}
+			if (intarg > 0) {
+				if (intarg > 300) {
+					printk(KERN_WARNING
+					    "btrfs: excessive commit interval %d\n",
+							intarg);
+				}
+				info->commit_interval = intarg;
+			} else {
+				printk(KERN_INFO
+				    "btrfs: using default commit interval %ds\n",
+				    BTRFS_DEFAULT_COMMIT_INTERVAL);
+				info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;
+			}
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);
@@ -981,6 +1006,8 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 				info->metadata_ratio);
 	if (btrfs_test_opt(root, PANIC_ON_FATAL_ERROR))
 		seq_puts(seq, ",fatal_errors=panic");
+	if (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)
+		seq_printf(seq, ",commit=%d", info->commit_interval);
 	return 0;
 }
 

commit 8507d216a41f37ef466b90b5e53cdb741c6e1c17
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Wed Jul 24 10:30:02 2013 +0800

    Btrfs: add missing mounting options in btrfs_show_options()
    
    Some options are missing in btrfs_show_options(), this patch
    adds them.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Reviewed-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d82391d48974..2cc5b80eeae9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -965,6 +965,20 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",inode_cache");
 	if (btrfs_test_opt(root, SKIP_BALANCE))
 		seq_puts(seq, ",skip_balance");
+	if (btrfs_test_opt(root, RECOVERY))
+		seq_puts(seq, ",recovery");
+#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
+	if (btrfs_test_opt(root, CHECK_INTEGRITY_INCLUDING_EXTENT_DATA))
+		seq_puts(seq, ",check_int_data");
+	else if (btrfs_test_opt(root, CHECK_INTEGRITY))
+		seq_puts(seq, ",check_int");
+	if (info->check_integrity_print_mask)
+		seq_printf(seq, ",check_int_print_mask=%d",
+				info->check_integrity_print_mask);
+#endif
+	if (info->metadata_ratio)
+		seq_printf(seq, ",metadata_ratio=%d",
+				info->metadata_ratio);
 	if (btrfs_test_opt(root, PANIC_ON_FATAL_ERROR))
 		seq_puts(seq, ",fatal_errors=panic");
 	return 0;

commit 1493381f2f95a7d7383eeeb490ce0da9d9a7368f
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Wed Jul 24 10:29:20 2013 +0800

    Btrfs: use u64 for subvolid when parsing mount options
    
    Although for most time, int is enough for subvolid, we should
    ensure safety in theory.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Reviewed-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cc002959493c..d82391d48974 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -327,7 +327,7 @@ enum {
 static match_table_t tokens = {
 	{Opt_degraded, "degraded"},
 	{Opt_subvol, "subvol=%s"},
-	{Opt_subvolid, "subvolid=%d"},
+	{Opt_subvolid, "subvolid=%s"},
 	{Opt_device, "device=%s"},
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
@@ -673,8 +673,8 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *device_name, *opts, *orig, *p;
+	char *num = NULL;
 	int error = 0;
-	int intarg;
 
 	if (!options)
 		return 0;
@@ -704,16 +704,14 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 			}
 			break;
 		case Opt_subvolid:
-			error = match_int(&args[0], &intarg);
-			if (!error) {
-				goto out;
-			} else if (intarg >= 0) {
+			num = match_strdup(&args[0]);
+			if (num) {
+				*subvol_objectid = memparse(num, NULL);
+				kfree(num);
 				/* we want the original fs_tree */
-				if (!intarg)
+				if (!*subvol_objectid)
 					*subvol_objectid =
 						BTRFS_FS_TREE_OBJECTID;
-				else
-					*subvol_objectid = intarg;
 			} else {
 				error = -EINVAL;
 				goto out;

commit 2c334e87f31783ca80b7ce265b25ba5489bfad1a
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Wed Jul 24 10:29:05 2013 +0800

    Btrfs: add sanity checks regarding to parsing mount options
    
    I just notice the following commands succeed:
            mount <dev> <mnt> -o thread_pool=-1
    
    This is ridiculous, only positive thread_pool makes sense,this
    patch adds sanity checks for them, and also catches the error of
    ENOMEM if allocating memory fails.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Reviewed-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8eb6191d86da..cc002959493c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -496,10 +496,15 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, NOBARRIER);
 			break;
 		case Opt_thread_pool:
-			intarg = 0;
-			match_int(&args[0], &intarg);
-			if (intarg)
+			ret = match_int(&args[0], &intarg);
+			if (ret) {
+				goto out;
+			} else if (intarg > 0) {
 				info->thread_pool_size = intarg;
+			} else {
+				ret = -EINVAL;
+				goto out;
+			}
 			break;
 		case Opt_max_inline:
 			num = match_strdup(&args[0]);
@@ -514,6 +519,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				}
 				printk(KERN_INFO "btrfs: max_inline at %llu\n",
 					(unsigned long long)info->max_inline);
+			} else {
+				ret = -ENOMEM;
+				goto out;
 			}
 			break;
 		case Opt_alloc_start:
@@ -526,6 +534,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				printk(KERN_INFO
 					"btrfs: allocations start at %llu\n",
 					(unsigned long long)info->alloc_start);
+			} else {
+				ret = -ENOMEM;
+				goto out;
 			}
 			break;
 		case Opt_noacl:
@@ -540,12 +551,16 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, FLUSHONCOMMIT);
 			break;
 		case Opt_ratio:
-			intarg = 0;
-			match_int(&args[0], &intarg);
-			if (intarg) {
+			ret = match_int(&args[0], &intarg);
+			if (ret) {
+				goto out;
+			} else if (intarg >= 0) {
 				info->metadata_ratio = intarg;
 				printk(KERN_INFO "btrfs: metadata ratio %d\n",
 				       info->metadata_ratio);
+			} else {
+				ret = -EINVAL;
+				goto out;
 			}
 			break;
 		case Opt_discard:
@@ -596,13 +611,17 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);
 			break;
 		case Opt_check_integrity_print_mask:
-			intarg = 0;
-			match_int(&args[0], &intarg);
-			if (intarg) {
+			ret = match_int(&args[0], &intarg);
+			if (ret) {
+				goto out;
+			} else if (intarg >= 0) {
 				info->check_integrity_print_mask = intarg;
 				printk(KERN_INFO "btrfs:"
 				       " check_integrity_print_mask 0x%x\n",
 				       info->check_integrity_print_mask);
+			} else {
+				ret = -EINVAL;
+				goto out;
 			}
 			break;
 #else
@@ -679,17 +698,25 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		case Opt_subvol:
 			kfree(*subvol_name);
 			*subvol_name = match_strdup(&args[0]);
+			if (!*subvol_name) {
+				error = -ENOMEM;
+				goto out;
+			}
 			break;
 		case Opt_subvolid:
-			intarg = 0;
 			error = match_int(&args[0], &intarg);
 			if (!error) {
+				goto out;
+			} else if (intarg >= 0) {
 				/* we want the original fs_tree */
 				if (!intarg)
 					*subvol_objectid =
 						BTRFS_FS_TREE_OBJECTID;
 				else
 					*subvol_objectid = intarg;
+			} else {
+				error = -EINVAL;
+				goto out;
 			}
 			break;
 		case Opt_subvolrootid:

commit 501407aab8c947911b10cf5a0e0043019d5a4f17
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Mon Jun 10 16:47:23 2013 -0400

    Btrfs: stop waiting on current trans if we aborted
    
    I hit a hang when run_delayed_refs returned an error in the beginning of
    btrfs_commit_transaction.  If we decide we need to commit the transaction in
    btrfs_end_transaction we'll set BLOCKED and start to commit, but if we get an
    error this early on we'll just exit without committing.  This is fine, except
    that anybody else who tried to start a transaction will sit in
    wait_current_trans() since we're set to BLOCKED and we never set it to something
    else and woke people up.  To fix this we want to check for trans->aborted
    everywhere we wait for the transaction state to change, and make
    btrfs_abort_transaction() wake up any waiters there may be.  All the callers
    will notice that the transaction has aborted and exit out properly.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 14d2be03f95a..8eb6191d86da 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -265,6 +265,9 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 		return;
 	}
 	ACCESS_ONCE(trans->transaction->aborted) = errno;
+	/* Wake up anybody who may be waiting on this transaction */
+	wake_up(&root->fs_info->transaction_wait);
+	wake_up(&root->fs_info->transaction_blocked_wait);
 	__btrfs_std_error(root->fs_info, function, line, errno, NULL);
 }
 /*

commit c73e293678fc3ec8ee9e5e275ee77dec98c4f2f1
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Thu May 16 11:14:33 2013 -0400

    Btrfs: do delay iput in sync_fs
    
    We get lock inversion with umount if we allow iputs from sync_fs, so use the
    delay iput flag to keep this from happening.  Thanks,
    
    Reported-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 41d81bee583d..14d2be03f95a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -862,7 +862,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_wait_all_ordered_extents(fs_info, 0);
+	btrfs_wait_all_ordered_extents(fs_info, 1);
 
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {

commit 199c2a9c3d1389db7f7a211e64f6809d352ce5f6
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed May 15 07:48:23 2013 +0000

    Btrfs: introduce per-subvolume ordered extent list
    
    The reason we introduce per-subvolume ordered extent list is the same
    as the per-subvolume delalloc inode list.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2a6a908d0017..41d81bee583d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -862,7 +862,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_wait_ordered_extents(root, 1);
+	btrfs_wait_all_ordered_extents(fs_info, 0);
 
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {

commit 3c64a1aba7cfcb04f79e76f859b3d66660275d59
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon May 13 13:53:35 2013 +0000

    Btrfs: cleanup: don't check the same thing twice
    
    btrfs_read_fs_root_no_name() already checks if btrfs_root_refs()
    is zero and returns ENOENT in this case. There is no need to do
    it again in six places.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0805dd3b856e..2a6a908d0017 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -775,9 +775,6 @@ static struct dentry *get_default_root(struct super_block *sb,
 	if (IS_ERR(new_root))
 		return ERR_CAST(new_root);
 
-	if (btrfs_root_refs(&new_root->root_item) == 0)
-		return ERR_PTR(-ENOENT);
-
 	dir_id = btrfs_root_dirid(&new_root->root_item);
 setup_root:
 	location.objectid = dir_id;

commit 85965600f50b2e57746363d0ace4ab6b2bcb9c27
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Apr 30 16:51:59 2013 +0000

    btrfs: show compiled-in config features at module load time
    
    We want to know if there are debugging features compiled in, this may
    affect performance. The message is printed before the sanity checks.
    Also kill version.h file that serves no purpose, we don't use any
    version tag for kernel module.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 107c6e23cbc0..0805dd3b856e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -51,7 +51,6 @@
 #include "print-tree.h"
 #include "xattr.h"
 #include "volumes.h"
-#include "version.h"
 #include "export.h"
 #include "compression.h"
 #include "rcu-string.h"
@@ -1685,6 +1684,18 @@ static void btrfs_interface_exit(void)
 		printk(KERN_INFO "btrfs: misc_deregister failed for control device\n");
 }
 
+static void btrfs_print_info(void)
+{
+	printk(KERN_INFO "Btrfs loaded"
+#ifdef CONFIG_BTRFS_DEBUG
+			", debug=on"
+#endif
+#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
+			", integrity-checker=on"
+#endif
+			"\n");
+}
+
 static int __init init_btrfs_fs(void)
 {
 	int err;
@@ -1733,9 +1744,9 @@ static int __init init_btrfs_fs(void)
 
 	btrfs_init_lockdep();
 
+	btrfs_print_info();
 	btrfs_test_free_space_cache();
 
-	printk(KERN_INFO "%s loaded\n", BTRFS_BUILD_VERSION);
 	return 0;
 
 unregister_ioctl:

commit e6d2960582f625ba6e676117019b62aa87425e8f
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Apr 30 16:51:58 2013 +0000

    btrfs: move ifdef around sanity checks out of init_btrfs_fs
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f0857e092a3c..107c6e23cbc0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1733,9 +1733,7 @@ static int __init init_btrfs_fs(void)
 
 	btrfs_init_lockdep();
 
-#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
 	btrfs_test_free_space_cache();
-#endif
 
 	printk(KERN_INFO "%s loaded\n", BTRFS_BUILD_VERSION);
 	return 0;

commit 061594ef171a5ba52b5786688ae766907b0bda2b
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed May 15 07:48:17 2013 +0000

    Btrfs: pause the space balance when remounting to R/O
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a4807ced23cc..f0857e092a3c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1263,6 +1263,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 
 		btrfs_dev_replace_suspend_for_unmount(fs_info);
 		btrfs_scrub_cancel(fs_info);
+		btrfs_pause_balance(fs_info);
 
 		ret = btrfs_commit_super(root);
 		if (ret)

commit 62dbd7176e196cd042c5542696981b268264fe92
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Wed Apr 17 12:16:59 2013 -0400

    Btrfs: fix lockdep warning
    
    The locking order for stuff is
    
    __sb_start_write
    ordered_mutex
    
    but with sync() we don't do __sb_start_write for some strange reason, which
    means that our iput in wait_ordered_extents could start a transaction which does
    the __sb_start_write while we're holding the ordered_mutex.  Fix this by using
    delayed iput in sync.  Thanks,
    
    Reported-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5dc54ae5ac81..a4807ced23cc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -866,7 +866,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_wait_ordered_extents(root, 0);
+	btrfs_wait_ordered_extents(root, 1);
 
 	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {

commit f42a34b2f10c411ef45f247f3000ed03ba4e80c0
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Apr 11 10:29:35 2013 +0000

    Btrfs: fix unblocked autodefraggers when remount
    
    The new mount option is set after parsing the remount arguments,
    so it is wrong that checking the autodefrag is close or not at
    btrfs_remount_prepare(). Fix it.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 88f812eddff6..5dc54ae5ac81 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1191,11 +1191,14 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 			      new_pool_size);
 }
 
-static inline void btrfs_remount_prepare(struct btrfs_fs_info *fs_info,
-					 unsigned long old_opts, int flags)
+static inline void btrfs_remount_prepare(struct btrfs_fs_info *fs_info)
 {
 	set_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);
+}
 
+static inline void btrfs_remount_begin(struct btrfs_fs_info *fs_info,
+				       unsigned long old_opts, int flags)
+{
 	if (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&
 	    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||
 	     (flags & MS_RDONLY))) {
@@ -1236,7 +1239,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	unsigned int old_metadata_ratio = fs_info->metadata_ratio;
 	int ret;
 
-	btrfs_remount_prepare(fs_info, old_opts, *flags);
+	btrfs_remount_prepare(fs_info);
 
 	ret = btrfs_parse_options(root, data);
 	if (ret) {
@@ -1244,6 +1247,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		goto restore;
 	}
 
+	btrfs_remount_begin(fs_info, old_opts, *flags);
 	btrfs_resize_thread_pool(fs_info,
 		fs_info->thread_pool_size, old_thread_pool_size);
 

commit cf79ffb5b79e8a2b587fbf218809e691bb396c98
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Mon Apr 1 11:23:58 2013 -0400

    Btrfs: fix infinite loop when we abort on mount
    
    Testing my enospc log code I managed to abort a transaction during mount, which
    put me into an infinite loop.  This is because of two things, first we don't
    reset trans_no_join if we abort during transaction commit, which will force
    anybody trying to start a transaction to just loop endlessly waiting for it to
    be set to 0.  But this is still just a symptom, the second issue is we don't set
    the fs state to error during errors on mount.  This is because we don't want to
    do the flip read only thing during mount, but we still really want to set the fs
    state to an error to keep us from even getting to the trans_no_join check.  So
    fix both of these things, make sure to reset trans_no_join if we abort during a
    commit, and make sure we set the fs state to error no matter if we're mounting
    or not.  This should keep us from getting into this infinite loop again.
    Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c3254c995fc8..88f812eddff6 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -161,10 +161,9 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 	}
 
 	/* Don't go through full error handling during mount */
-	if (sb->s_flags & MS_BORN) {
-		save_error_info(fs_info);
+	save_error_info(fs_info);
+	if (sb->s_flags & MS_BORN)
 		btrfs_handle_error(fs_info);
-	}
 }
 
 static const char * const logtypes[] = {

commit 94ef7280e8b3a5b13ba3cc515e5c198c1181176e
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Mar 20 14:29:47 2013 +0000

    btrfs: cover more error codes in btrfs_decode_error
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3c404b8e83bb..c3254c995fc8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -81,6 +81,12 @@ static const char *btrfs_decode_error(int errno)
 	case -EEXIST:
 		errstr = "Object already exists";
 		break;
+	case -ENOSPC:
+		errstr = "No space left";
+		break;
+	case -ENOENT:
+		errstr = "No such entry";
+		break;
 	}
 
 	return errstr;

commit 5e2a4b25da232a2f4ce264a4b2ae113d0b2a799c
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Mar 20 13:21:10 2013 +0000

    btrfs: deprecate subvolrootid mount option
    
    This mount option was a workaround when subvol= assumed path relative
    to the default subvolume, not the toplevel one. This was fixed long time
    ago and subvolrootid has no effect.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3fd4f2c3d529..3c404b8e83bb 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -643,7 +643,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
  */
 static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		void *holder, char **subvol_name, u64 *subvol_objectid,
-		u64 *subvol_rootid, struct btrfs_fs_devices **fs_devices)
+		struct btrfs_fs_devices **fs_devices)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *device_name, *opts, *orig, *p;
@@ -686,16 +686,8 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 			}
 			break;
 		case Opt_subvolrootid:
-			intarg = 0;
-			error = match_int(&args[0], &intarg);
-			if (!error) {
-				/* we want the original fs_tree */
-				if (!intarg)
-					*subvol_rootid =
-						BTRFS_FS_TREE_OBJECTID;
-				else
-					*subvol_rootid = intarg;
-			}
+			printk(KERN_WARNING
+				"btrfs: 'subvolrootid' mount option is deprecated and has no effect\n");
 			break;
 		case Opt_device:
 			device_name = match_strdup(&args[0]);
@@ -1073,7 +1065,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	fmode_t mode = FMODE_READ;
 	char *subvol_name = NULL;
 	u64 subvol_objectid = 0;
-	u64 subvol_rootid = 0;
 	int error = 0;
 
 	if (!(flags & MS_RDONLY))
@@ -1081,7 +1072,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 	error = btrfs_parse_early_options(data, mode, fs_type,
 					  &subvol_name, &subvol_objectid,
-					  &subvol_rootid, &fs_devices);
+					  &fs_devices);
 	if (error) {
 		kfree(subvol_name);
 		return ERR_PTR(error);

commit c2cf52eb71aeb902682e0c1fa29e4e9e4a7f4ffc
Author: Simon Kirby <sim@hostway.ca>
Date:   Tue Mar 19 22:41:23 2013 +0000

    Btrfs: Include the device in most error printk()s
    
    With more than one btrfs volume mounted, it can be very difficult to find
    out which volume is hitting an error. btrfs_error() will print this, but
    it is currently rigged as more of a fatal error handler, while many of
    the printk()s are currently for debugging and yet-unhandled cases.
    
    This patch just changes the functions where the device information is
    already available. Some cases remain where the root or fs_info is not
    passed to the function emitting the error.
    
    This may introduce some confusion with volumes backed by multiple devices
    emitting errors referring to the primary device in the set instead of the
    one on which the error occurred.
    
    Use btrfs_printk(fs_info, format, ...) rather than writing the device
    string every time, and introduce macro wrappers ala XFS for brevity.
    Since the function already cannot be used for continuations, print a
    newline as part of the btrfs_printk() message rather than at each caller.
    
    Signed-off-by: Simon Kirby <sim@hostway.ca>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7f00a91ccc10..3fd4f2c3d529 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -105,7 +105,7 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 
 	if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {
 		sb->s_flags |= MS_RDONLY;
-		printk(KERN_INFO "btrfs is forced readonly\n");
+		btrfs_info(fs_info, "forced readonly");
 		/*
 		 * Note that a running device replace operation is not
 		 * canceled here although there is no way to update
@@ -172,7 +172,7 @@ static const char * const logtypes[] = {
 	"debug",
 };
 
-void btrfs_printk(struct btrfs_fs_info *fs_info, const char *fmt, ...)
+void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 {
 	struct super_block *sb = fs_info->sb;
 	char lvl[4];
@@ -196,7 +196,7 @@ void btrfs_printk(struct btrfs_fs_info *fs_info, const char *fmt, ...)
 	vaf.fmt = fmt;
 	vaf.va = &args;
 
-	printk("%sBTRFS %s (device %s): %pV", lvl, type, sb->s_id, &vaf);
+	printk("%sBTRFS %s (device %s): %pV\n", lvl, type, sb->s_id, &vaf);
 
 	va_end(args);
 }
@@ -255,9 +255,9 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 		const char *errstr;
 
 		errstr = btrfs_decode_error(errno);
-		btrfs_printk(root->fs_info,
-			     "%s:%d: Aborting unused transaction (%s)\n",
-			     function, line, errstr);
+		btrfs_warn(root->fs_info,
+		           "%s:%d: Aborting unused transaction(%s).",
+		           function, line, errstr);
 		return;
 	}
 	ACCESS_ONCE(trans->transaction->aborted) = errno;

commit 087488109afb4cc1bbdd3557779129c34045609a
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Mar 12 14:46:08 2013 +0000

    btrfs: clean up transaction abort messages
    
    The transaction abort stacktrace is printed only once per module
    lifetime, but we'd like to see it each time it happens per mounted
    filesystem.  Introduce a fs_state flag that records it.
    
    Tweak the messages around abort:
    * add error number to the first abort
    * print the exact negative errno from btrfs_decode_error
    * clean up btrfs_decode_error and callers
    * no dots at the end of the messages
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8168ceca4754..7f00a91ccc10 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -64,9 +64,9 @@
 static const struct super_operations btrfs_super_ops;
 static struct file_system_type btrfs_fs_type;
 
-static const char *btrfs_decode_error(int errno, char nbuf[16])
+static const char *btrfs_decode_error(int errno)
 {
-	char *errstr = NULL;
+	char *errstr = "unknown";
 
 	switch (errno) {
 	case -EIO:
@@ -81,12 +81,6 @@ static const char *btrfs_decode_error(int errno, char nbuf[16])
 	case -EEXIST:
 		errstr = "Object already exists";
 		break;
-	default:
-		if (nbuf) {
-			if (snprintf(nbuf, 16, "error %d", -errno) >= 0)
-				errstr = nbuf;
-		}
-		break;
 	}
 
 	return errstr;
@@ -122,7 +116,6 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 		 * mounted writeable again, the device replace
 		 * operation continues.
 		 */
-//		WARN_ON(1);
 	}
 }
 
@@ -135,7 +128,6 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		       unsigned int line, int errno, const char *fmt, ...)
 {
 	struct super_block *sb = fs_info->sb;
-	char nbuf[16];
 	const char *errstr;
 
 	/*
@@ -145,7 +137,7 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
   		return;
 
-  	errstr = btrfs_decode_error(errno, nbuf);
+	errstr = btrfs_decode_error(errno);
 	if (fmt) {
 		struct va_format vaf;
 		va_list args;
@@ -154,12 +146,12 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		vaf.fmt = fmt;
 		vaf.va = &args;
 
-		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: %s (%pV)\n",
-			sb->s_id, function, line, errstr, &vaf);
+		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: errno=%d %s (%pV)\n",
+			sb->s_id, function, line, errno, errstr, &vaf);
 		va_end(args);
 	} else {
-		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: %s\n",
-			sb->s_id, function, line, errstr);
+		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: errno=%d %s\n",
+			sb->s_id, function, line, errno, errstr);
 	}
 
 	/* Don't go through full error handling during mount */
@@ -248,17 +240,23 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 			       struct btrfs_root *root, const char *function,
 			       unsigned int line, int errno)
 {
-	WARN_ONCE(1, KERN_DEBUG "btrfs: Transaction aborted\n");
+	/*
+	 * Report first abort since mount
+	 */
+	if (!test_and_set_bit(BTRFS_FS_STATE_TRANS_ABORTED,
+				&root->fs_info->fs_state)) {
+		WARN(1, KERN_DEBUG "btrfs: Transaction aborted (error %d)\n",
+				errno);
+	}
 	trans->aborted = errno;
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */
 	if (!trans->blocks_used) {
-		char nbuf[16];
 		const char *errstr;
 
-		errstr = btrfs_decode_error(errno, nbuf);
+		errstr = btrfs_decode_error(errno);
 		btrfs_printk(root->fs_info,
-			     "%s:%d: Aborting unused transaction(%s).\n",
+			     "%s:%d: Aborting unused transaction (%s)\n",
 			     function, line, errstr);
 		return;
 	}
@@ -272,7 +270,6 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 		   unsigned int line, int errno, const char *fmt, ...)
 {
-	char nbuf[16];
 	char *s_id = "<unknown>";
 	const char *errstr;
 	struct va_format vaf = { .fmt = fmt };
@@ -284,13 +281,13 @@ void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 	va_start(args, fmt);
 	vaf.va = &args;
 
-	errstr = btrfs_decode_error(errno, nbuf);
+	errstr = btrfs_decode_error(errno);
 	if (fs_info && (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR))
-		panic(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (%s)\n",
-			s_id, function, line, &vaf, errstr);
+		panic(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\n",
+			s_id, function, line, &vaf, errno, errstr);
 
-	printk(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (%s)\n",
-	       s_id, function, line, &vaf, errstr);
+	printk(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\n",
+	       s_id, function, line, &vaf, errno, errstr);
 	va_end(args);
 	/* Caller calls BUG() */
 }

commit bbece8a3f00a02bbfc63531651fd70ef56c5e916
Author: David Sterba <dsterba@suse.cz>
Date:   Mon Mar 11 17:07:45 2013 +0000

    btrfs: merge save_error_info helpers into one
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 714ae479de2e..8168ceca4754 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -92,7 +92,7 @@ static const char *btrfs_decode_error(int errno, char nbuf[16])
 	return errstr;
 }
 
-static void __save_error_info(struct btrfs_fs_info *fs_info)
+static void save_error_info(struct btrfs_fs_info *fs_info)
 {
 	/*
 	 * today we only save the error info into ram.  Long term we'll
@@ -101,11 +101,6 @@ static void __save_error_info(struct btrfs_fs_info *fs_info)
 	set_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);
 }
 
-static void save_error_info(struct btrfs_fs_info *fs_info)
-{
-	__save_error_info(fs_info);
-}
-
 /* btrfs handle error by forcing the filesystem readonly */
 static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 {

commit 74255aa07d292385ca3a4a4e8f0bc492d9bdd116
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Mar 15 09:47:08 2013 -0400

    Btrfs: add some free space cache tests
    
    We keep hitting bugs in the tree log replay because btrfs_remove_free_space
    doesn't account for some corner case.  So add a bunch of tests to try and fully
    test btrfs_remove_free_space since the only time it is called is during tree log
    replay.  These tests all finish successfully, so as we find more of these bugs
    we need to add to these tests to make sure we don't regress in fixing things.
    I've hidden the tests behind a Kconfig option, but they take no time to run so
    all btrfs developers should have this turned on all the time.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f6b88595f858..714ae479de2e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -56,6 +56,7 @@
 #include "compression.h"
 #include "rcu-string.h"
 #include "dev-replace.h"
+#include "free-space-cache.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/btrfs.h>
@@ -1739,6 +1740,10 @@ static int __init init_btrfs_fs(void)
 
 	btrfs_init_lockdep();
 
+#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
+	btrfs_test_free_space_cache();
+#endif
+
 	printk(KERN_INFO "%s loaded\n", BTRFS_BUILD_VERSION);
 	return 0;
 

commit 7f78e0351394052e1a6293e175825eb5c7869507
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Mar 2 19:39:14 2013 -0800

    fs: Limit sys_mount to only request filesystem modules.
    
    Modify the request_module to prefix the file system type with "fs-"
    and add aliases to all of the filesystems that can be built as modules
    to match.
    
    A common practice is to build all of the kernel code and leave code
    that is not commonly needed as modules, with the result that many
    users are exposed to any bug anywhere in the kernel.
    
    Looking for filesystems with a fs- prefix limits the pool of possible
    modules that can be loaded by mount to just filesystems trivially
    making things safer with no real cost.
    
    Using aliases means user space can control the policy of which
    filesystem modules are auto-loaded by editing /etc/modprobe.d/*.conf
    with blacklist and alias directives.  Allowing simple, safe,
    well understood work-arounds to known problematic software.
    
    This also addresses a rare but unfortunate problem where the filesystem
    name is not the same as it's module name and module auto-loading
    would not work.  While writing this patch I saw a handful of such
    cases.  The most significant being autofs that lives in the module
    autofs4.
    
    This is relevant to user namespaces because we can reach the request
    module in get_fs_type() without having any special permissions, and
    people get uncomfortable when a user specified string (in this case
    the filesystem type) goes all of the way to request_module.
    
    After having looked at this issue I don't think there is any
    particular reason to perform any filtering or permission checks beyond
    making it clear in the module request that we want a filesystem
    module.  The common pattern in the kernel is to call request_module()
    without regards to the users permissions.  In general all a filesystem
    module does once loaded is call register_filesystem() and go to sleep.
    Which means there is not much attack surface exposed by loading a
    filesytem module unless the filesystem is mounted.  In a user
    namespace filesystems are not mounted unless .fs_flags = FS_USERNS_MOUNT,
    which most filesystems do not set today.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Reported-by: Kees Cook <keescook@google.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 68a29a1ea068..f6b88595f858 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1558,6 +1558,7 @@ static struct file_system_type btrfs_fs_type = {
 	.kill_sb	= btrfs_kill_super,
 	.fs_flags	= FS_REQUIRES_DEV,
 };
+MODULE_ALIAS_FS("btrfs");
 
 /*
  * used by btrfsctl to scan devices when no FS is mounted

commit dc81cdc58ad2f413b96b9004f8d681e5dc554473
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Feb 20 23:32:52 2013 -0700

    Btrfs: fix remount vs autodefrag
    
    If we remount the fs to close the auto defragment or make the fs R/O,
    we should stop the auto defragment.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index db1ba9a2ed64..68a29a1ea068 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1202,6 +1202,38 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 			      new_pool_size);
 }
 
+static inline void btrfs_remount_prepare(struct btrfs_fs_info *fs_info,
+					 unsigned long old_opts, int flags)
+{
+	set_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);
+
+	if (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&
+	    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||
+	     (flags & MS_RDONLY))) {
+		/* wait for any defraggers to finish */
+		wait_event(fs_info->transaction_wait,
+			   (atomic_read(&fs_info->defrag_running) == 0));
+		if (flags & MS_RDONLY)
+			sync_filesystem(fs_info->sb);
+	}
+}
+
+static inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,
+					 unsigned long old_opts)
+{
+	/*
+	 * We need cleanup all defragable inodes if the autodefragment is
+	 * close or the fs is R/O.
+	 */
+	if (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&
+	    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||
+	     (fs_info->sb->s_flags & MS_RDONLY))) {
+		btrfs_cleanup_defrag_inodes(fs_info);
+	}
+
+	clear_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);
+}
+
 static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
@@ -1215,6 +1247,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	unsigned int old_metadata_ratio = fs_info->metadata_ratio;
 	int ret;
 
+	btrfs_remount_prepare(fs_info, old_opts, *flags);
+
 	ret = btrfs_parse_options(root, data);
 	if (ret) {
 		ret = -EINVAL;
@@ -1225,7 +1259,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		fs_info->thread_pool_size, old_thread_pool_size);
 
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
-		return 0;
+		goto out;
 
 	if (*flags & MS_RDONLY) {
 		/*
@@ -1280,7 +1314,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		}
 		sb->s_flags &= ~MS_RDONLY;
 	}
-
+out:
+	btrfs_remount_cleanup(fs_info, old_opts);
 	return 0;
 
 restore:
@@ -1297,6 +1332,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	btrfs_resize_thread_pool(fs_info,
 		old_thread_pool_size, fs_info->thread_pool_size);
 	fs_info->metadata_ratio = old_metadata_ratio;
+	btrfs_remount_cleanup(fs_info, old_opts);
 	return ret;
 }
 

commit d4edf39bd5db443151efc993dac67ec9d6b5b8c1
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Feb 20 09:17:06 2013 +0000

    Btrfs: fix uncompleted transaction
    
    In some cases, we need commit the current transaction, but don't want
    to start a new one if there is no running transaction, so we introduce
    the function - btrfs_attach_transaction(), which can catch the current
    transaction, and return -ENOENT if there is no running transaction.
    
    But no running transaction doesn't mean the current transction completely,
    because we removed the running transaction before it completes. In some
    cases, it doesn't matter. But in some special cases, such as freeze fs, we
    hope the transaction is fully on disk, it will introduce some bugs, for
    example, we may feeze the fs and dump the data in the disk, if the transction
    doesn't complete, we would dump inconsistent data. So we need fix the above
    problem for those cases.
    
    We fixes this problem by introducing a function:
            btrfs_attach_transaction_barrier()
    if we hope all the transaction is fully on the disk, even they are not
    running, we can use this function.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e0ea1278377a..db1ba9a2ed64 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -878,7 +878,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 
 	btrfs_wait_ordered_extents(root, 0);
 
-	trans = btrfs_attach_transaction(root);
+	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {
 		/* no transaction, don't bother */
 		if (PTR_ERR(trans) == -ENOENT)
@@ -1563,7 +1563,7 @@ static int btrfs_freeze(struct super_block *sb)
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root = btrfs_sb(sb)->tree_root;
 
-	trans = btrfs_attach_transaction(root);
+	trans = btrfs_attach_transaction_barrier(root);
 	if (IS_ERR(trans)) {
 		/* no transaction, don't bother */
 		if (PTR_ERR(trans) == -ENOENT)

commit 37252a66f34940421942725ca75d12e6008682dc
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Jan 31 00:54:58 2013 +0000

    btrfs: fix varargs in __btrfs_std_error
    
    __btrfs_std_error didn't always properly call va_end,
    and might call va_start even if fmt was NULL.
    
    Move all the varargs handling into the block where we
    have fmt.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 976f6aac102e..e0ea1278377a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -141,8 +141,6 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 	struct super_block *sb = fs_info->sb;
 	char nbuf[16];
 	const char *errstr;
-	va_list args;
-	va_start(args, fmt);
 
 	/*
 	 * Special case: if the error is EROFS, and we're already
@@ -153,13 +151,16 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 
   	errstr = btrfs_decode_error(errno, nbuf);
 	if (fmt) {
-		struct va_format vaf = {
-			.fmt = fmt,
-			.va = &args,
-		};
+		struct va_format vaf;
+		va_list args;
+
+		va_start(args, fmt);
+		vaf.fmt = fmt;
+		vaf.va = &args;
 
 		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: %s (%pV)\n",
 			sb->s_id, function, line, errstr, &vaf);
+		va_end(args);
 	} else {
 		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: %s\n",
 			sb->s_id, function, line, errstr);
@@ -170,7 +171,6 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		save_error_info(fs_info);
 		btrfs_handle_error(fs_info);
 	}
-	va_end(args);
 }
 
 static const char * const logtypes[] = {

commit 1c697d4acc2e10b2a65b22abba2687a2897ecd74
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Jan 31 00:54:56 2013 +0000

    btrfs: annotate intentional switch case fallthroughs
    
    This keeps static checkers happy.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 06537d217419..976f6aac102e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -437,6 +437,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_compress_force:
 		case Opt_compress_force_type:
 			compress_force = true;
+			/* Fallthrough */
 		case Opt_compress:
 		case Opt_compress_type:
 			if (token == Opt_compress ||

commit aa43a17c21cf35329b1a495dd6876798dd8b016b
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Jan 31 00:54:55 2013 +0000

    btrfs: handle null fs_info in btrfs_panic()
    
    At least backref_tree_panic() can apparently pass
    in a null fs_info, so handle that in __btrfs_panic
    to get the message out on the console.
    
    The btrfs_panic macro also uses fs_info, but that's
    largely pointless; it's testing to see if
    BTRFS_MOUNT_PANIC_ON_FATAL_ERROR is not set.
    But if it *were* set, __btrfs_panic() would have,
    well, paniced and we wouldn't be here, testing it!
    So just BUG() at this point.
    
    And since we only use fs_info once now, just use it
    directly.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index fd6a07c30ee9..06537d217419 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -289,7 +289,7 @@ void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 	vaf.va = &args;
 
 	errstr = btrfs_decode_error(errno, nbuf);
-	if (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR)
+	if (fs_info && (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR))
 		panic(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (%s)\n",
 			s_id, function, line, &vaf, errstr);
 

commit 5a01604783c23f28bd4212e839e79277193f974f
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Jan 31 00:54:54 2013 +0000

    btrfs: remove unused fs_info from btrfs_decode_error()
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4152f9ea34f5..fd6a07c30ee9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -63,8 +63,7 @@
 static const struct super_operations btrfs_super_ops;
 static struct file_system_type btrfs_fs_type;
 
-static const char *btrfs_decode_error(struct btrfs_fs_info *fs_info, int errno,
-				      char nbuf[16])
+static const char *btrfs_decode_error(int errno, char nbuf[16])
 {
 	char *errstr = NULL;
 
@@ -152,7 +151,7 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
   		return;
 
-  	errstr = btrfs_decode_error(fs_info, errno, nbuf);
+  	errstr = btrfs_decode_error(errno, nbuf);
 	if (fmt) {
 		struct va_format vaf = {
 			.fmt = fmt,
@@ -261,7 +260,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 		char nbuf[16];
 		const char *errstr;
 
-		errstr = btrfs_decode_error(root->fs_info, errno, nbuf);
+		errstr = btrfs_decode_error(errno, nbuf);
 		btrfs_printk(root->fs_info,
 			     "%s:%d: Aborting unused transaction(%s).\n",
 			     function, line, errstr);
@@ -289,7 +288,7 @@ void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 	va_start(args, fmt);
 	vaf.va = &args;
 
-	errstr = btrfs_decode_error(fs_info, errno, nbuf);
+	errstr = btrfs_decode_error(errno, nbuf);
 	if (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR)
 		panic(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (%s)\n",
 			s_id, function, line, &vaf, errstr);

commit 87533c475187c1420794a2e164bc67a7974f1327
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Tue Jan 29 10:14:48 2013 +0000

    Btrfs: use bit operation for ->fs_state
    
    There is no lock to protect fs_info->fs_state, it will introduce
    some problems, such as the value may be covered by the other task
    when several tasks modify it. For example:
            Task0 - CPU0            Task1 - CPU1
            mov %fs_state rax
            or $0x1 rax
                                    mov %fs_state rax
                                    or $0x2 rax
            mov rax %fs_state
                                    mov rax %fs_state
    The expected value is 3, but in fact, it is 2.
    
    Though this problem doesn't happen now (because there is only one
    flag currently), the code is error prone, if we add other flags,
    the above problem will happen to a certainty.
    
    Now we use bit operation for it to fix the above problem.
    In this way, we can make the code more robust and be easy to
    add new flags.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index eda330df45a4..4152f9ea34f5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -98,7 +98,7 @@ static void __save_error_info(struct btrfs_fs_info *fs_info)
 	 * today we only save the error info into ram.  Long term we'll
 	 * also send it down to the disk
 	 */
-	fs_info->fs_state = BTRFS_SUPER_FLAG_ERROR;
+	set_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);
 }
 
 static void save_error_info(struct btrfs_fs_info *fs_info)
@@ -114,7 +114,7 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 	if (sb->s_flags & MS_RDONLY)
 		return;
 
-	if (fs_info->fs_state & BTRFS_SUPER_FLAG_ERROR) {
+	if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {
 		sb->s_flags |= MS_RDONLY;
 		printk(KERN_INFO "btrfs is forced readonly\n");
 		/*

commit c018daecead7a46a575e2a1397fea850b83396c8
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Tue Jan 29 10:07:33 2013 +0000

    Btrfs: protect fs_info->alloc_start
    
    fs_info->alloc_start is a 64bits variant, can be accessed by
    multi-task, but it is not protected strictly, it can be changed
    while we are accessing it. On 32bit machine, we will get wrong
    value because we access it by two instructions.(In fact, it is
    also possible that the same problem happens on the 64bit machine,
    because the compiler may split the 64bit operation into two 32bit
    operation.)
    
    For example:
    Assuming -> alloc_start is 0x0000 0000 0001 0000 at the beginning,
    then we remount and set ->alloc_start to 0x0000 0100 0000 0000.
            Task0                   Task1
                                    load high 32 bits
            set high 32 bits
            set low 32 bits
                                    load low 32 bits
    
    Task1 will get 0.
    
    This patch fixes this problem by using two locks to protect it
            fs_info->chunk_mutex
            sb->s_umount
    On the read side, we just need get one of these two locks, and on
    the write side, we must lock all of them.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6846ededfe95..eda330df45a4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -519,7 +519,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_alloc_start:
 			num = match_strdup(&args[0]);
 			if (num) {
+				mutex_lock(&info->chunk_mutex);
 				info->alloc_start = memparse(num, NULL);
+				mutex_unlock(&info->chunk_mutex);
 				kfree(num);
 				printk(KERN_INFO
 					"btrfs: allocations start at %llu\n",
@@ -1289,7 +1291,9 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	fs_info->mount_opt = old_opts;
 	fs_info->compress_type = old_compress_type;
 	fs_info->max_inline = old_max_inline;
+	mutex_lock(&fs_info->chunk_mutex);
 	fs_info->alloc_start = old_alloc_start;
+	mutex_unlock(&fs_info->chunk_mutex);
 	btrfs_resize_thread_pool(fs_info,
 		old_thread_pool_size, fs_info->thread_pool_size);
 	fs_info->metadata_ratio = old_metadata_ratio;

commit 55e301fd57a6239ec14b91a1cf2e70b3dd135194
Author: Filipe Brandenburger <filbranden@google.com>
Date:   Tue Jan 29 06:04:50 2013 +0000

    Btrfs: move fs/btrfs/ioctl.h to include/uapi/linux/btrfs.h
    
    The header file will then be installed under /usr/include/linux so that
    userspace applications can refer to Btrfs ioctls by name and use the same
    structs used internally in the kernel.
    
    Signed-off-by: Filipe Brandenburger <filbranden@google.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 67b373bf3ff9..6846ededfe95 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -41,13 +41,13 @@
 #include <linux/slab.h>
 #include <linux/cleancache.h>
 #include <linux/ratelimit.h>
+#include <linux/btrfs.h>
 #include "compat.h"
 #include "delayed-inode.h"
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
 #include "btrfs_inode.h"
-#include "ioctl.h"
 #include "print-tree.h"
 #include "xattr.h"
 #include "volumes.h"

commit 78a6184a3ff9041280ee56273c01e5679a831b39
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Nov 21 02:21:28 2012 +0000

    Btrfs: use slabs for delayed reference allocation
    
    The delayed reference allocation is in the fast path of the IO, so use slabs
    to improve the speed of the allocation.
    
    And besides that, it can do check for leaked objects when the module is removed.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d8982e9601d3..67b373bf3ff9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1684,10 +1684,14 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_delayed_inode;
 
-	err = btrfs_interface_init();
+	err = btrfs_delayed_ref_init();
 	if (err)
 		goto free_auto_defrag;
 
+	err = btrfs_interface_init();
+	if (err)
+		goto free_delayed_ref;
+
 	err = register_filesystem(&btrfs_fs_type);
 	if (err)
 		goto unregister_ioctl;
@@ -1699,6 +1703,8 @@ static int __init init_btrfs_fs(void)
 
 unregister_ioctl:
 	btrfs_interface_exit();
+free_delayed_ref:
+	btrfs_delayed_ref_exit();
 free_auto_defrag:
 	btrfs_auto_defrag_exit();
 free_delayed_inode:
@@ -1720,6 +1726,7 @@ static int __init init_btrfs_fs(void)
 static void __exit exit_btrfs_fs(void)
 {
 	btrfs_destroy_cachep();
+	btrfs_delayed_ref_exit();
 	btrfs_auto_defrag_exit();
 	btrfs_delayed_inode_exit();
 	ordered_data_exit();

commit 8d25a086eb104297e3ba1fdd180b04cfaaa84797
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Tue Jan 15 06:27:25 2013 +0000

    Btrfs: Add ACCESS_ONCE() to transaction->abort accesses
    
    We may access and update transaction->aborted on the different CPUs without
    lock, so we need ACCESS_ONCE() wrapper to prevent the compiler from creating
    unsolicited accesses and make sure we can get the right value.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 99545df1b86c..d8982e9601d3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -267,7 +267,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 			     function, line, errstr);
 		return;
 	}
-	trans->transaction->aborted = errno;
+	ACCESS_ONCE(trans->transaction->aborted) = errno;
 	__btrfs_std_error(root->fs_info, function, line, errno, NULL);
 }
 /*

commit 9247f3170b2c3d648707c93bbebcd763fac17c06
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Mon Nov 26 09:24:43 2012 +0000

    Btrfs: use slabs for auto defrag allocation
    
    The auto defrag allocation is in the fast path of the IO, so use slabs
    to improve the speed of the allocation.
    
    And besides that, it can do check for leaked objects when the module is removed.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index def4f24b58df..99545df1b86c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1680,10 +1680,14 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_ordered_data;
 
-	err = btrfs_interface_init();
+	err = btrfs_auto_defrag_init();
 	if (err)
 		goto free_delayed_inode;
 
+	err = btrfs_interface_init();
+	if (err)
+		goto free_auto_defrag;
+
 	err = register_filesystem(&btrfs_fs_type);
 	if (err)
 		goto unregister_ioctl;
@@ -1695,6 +1699,8 @@ static int __init init_btrfs_fs(void)
 
 unregister_ioctl:
 	btrfs_interface_exit();
+free_auto_defrag:
+	btrfs_auto_defrag_exit();
 free_delayed_inode:
 	btrfs_delayed_inode_exit();
 free_ordered_data:
@@ -1714,6 +1720,7 @@ static int __init init_btrfs_fs(void)
 static void __exit exit_btrfs_fs(void)
 {
 	btrfs_destroy_cachep();
+	btrfs_auto_defrag_exit();
 	btrfs_delayed_inode_exit();
 	ordered_data_exit();
 	extent_map_exit();

commit 8dabb7420f014ab0f9f04afae8ae046c0f48b270
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Tue Nov 6 13:15:27 2012 +0100

    Btrfs: change core code of btrfs to support the device replace operations
    
    This commit contains all the essential changes to the core code
    of Btrfs for support of the device replace procedure.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ad4380684b9b..def4f24b58df 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -55,6 +55,7 @@
 #include "export.h"
 #include "compression.h"
 #include "rcu-string.h"
+#include "dev-replace.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/btrfs.h>
@@ -1225,8 +1226,15 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		return 0;
 
 	if (*flags & MS_RDONLY) {
+		/*
+		 * this also happens on 'umount -rf' or on shutdown, when
+		 * the filesystem is busy.
+		 */
 		sb->s_flags |= MS_RDONLY;
 
+		btrfs_dev_replace_suspend_for_unmount(fs_info);
+		btrfs_scrub_cancel(fs_info);
+
 		ret = btrfs_commit_super(root);
 		if (ret)
 			goto restore;
@@ -1263,6 +1271,11 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (ret)
 			goto restore;
 
+		ret = btrfs_resume_dev_replace_async(fs_info);
+		if (ret) {
+			pr_warn("btrfs: failed to resume dev_replace\n");
+			goto restore;
+		}
 		sb->s_flags &= ~MS_RDONLY;
 	}
 

commit ff023aac31198e88507d626825379b28ea481d4d
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Tue Nov 6 11:43:11 2012 +0100

    Btrfs: add code to scrub to copy read data to another disk
    
    The device replace procedure makes use of the scrub code. The scrub
    code is the most efficient code to read the allocated data of a disk,
    i.e. it reads sequentially in order to avoid disk head movements, it
    skips unallocated blocks, it uses read ahead mechanisms, and it
    contains all the code to detect and repair defects.
    This commit adds code to scrub to allow the scrub code to copy read
    data to another disk.
    One goal is to be able to perform as fast as possible. Therefore the
    write requests are collected until huge bios are built, and the
    write process is decoupled from the read process with some kind of
    flow control, of course, in order to limit the allocated memory.
    The best performance on spinning disks could by reached when the
    head movements are avoided as much as possible. Therefore a single
    worker is used to interface the read process with the write process.
    The regular scrub operation works as fast as before, it is not
    negatively influenced and actually it is more or less unchanged.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 837ad2d27853..ad4380684b9b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1195,7 +1195,8 @@ static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
 	btrfs_set_max_workers(&fs_info->endio_freespace_worker, new_pool_size);
 	btrfs_set_max_workers(&fs_info->delayed_workers, new_pool_size);
 	btrfs_set_max_workers(&fs_info->readahead_workers, new_pool_size);
-	btrfs_set_max_workers(&fs_info->scrub_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->scrub_wr_completion_workers,
+			      new_pool_size);
 }
 
 static int btrfs_remount(struct super_block *sb, int *flags, char *data)

commit 63a212abc2315972b245f93cb11ae3acf3c0b513
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 18:29:28 2012 +0100

    Btrfs: disallow some operations on the device replace target device
    
    This patch adds some code to disallow operations on the device that
    is used as the target for the device replace operation.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ef2415896b06..837ad2d27853 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1354,7 +1354,8 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 		min_stripe_size = BTRFS_STRIPE_LEN;
 
 	list_for_each_entry(device, &fs_devices->devices, dev_list) {
-		if (!device->in_fs_metadata || !device->bdev)
+		if (!device->in_fs_metadata || !device->bdev ||
+		    device->is_tgtdev_for_dev_replace)
 			continue;
 
 		avail_space = device->total_bytes - device->bytes_used;

commit 1acd6831d98779c88cd57f0a5826d6df0b09f3fa
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 17:11:06 2012 +0100

    Btrfs: avoid risk of a deadlock in btrfs_handle_error
    
    Remove the attempt to cancel a running scrub or device replace
    operation in btrfs_handle_error() because it adds the risk of
    a deadlock. The only penalty of not canceling the operation is
    that some I/O remains active until the procedure completes.
    This is basically the same thing that happens to other tasks
    that are running in user mode context, they are not affected
    or stopped in btrfs_handle_error(), these tasks just need to
    handle write errors correctly.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a1a6c296ddcd..ef2415896b06 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -116,7 +116,16 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 	if (fs_info->fs_state & BTRFS_SUPER_FLAG_ERROR) {
 		sb->s_flags |= MS_RDONLY;
 		printk(KERN_INFO "btrfs is forced readonly\n");
-		btrfs_scrub_cancel(fs_info);
+		/*
+		 * Note that a running device replace operation is not
+		 * canceled here although there is no way to update
+		 * the progress. It would add the risk of a deadlock,
+		 * therefore the canceling is ommited. The only penalty
+		 * is that some I/O remains active until the procedure
+		 * completes. The next time when the filesystem is
+		 * mounted writeable again, the device replace
+		 * operation continues.
+		 */
 //		WARN_ON(1);
 	}
 }

commit aa1b8cd409f05e1489ec77ff219eff6ed4b801b8
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Mon Nov 5 17:03:39 2012 +0100

    Btrfs: pass fs_info instead of root
    
    A small number of functions that are used in a device replace
    procedure when the operation is resumed at mount time are unable
    to pass the same root pointer that would be used in the regular
    (ioctl) context. And since the root pointer is not required, only
    the fs_info is, the root pointer argument is replaced with the
    fs_info pointer argument.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index acd2df85bed5..a1a6c296ddcd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -116,7 +116,7 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 	if (fs_info->fs_state & BTRFS_SUPER_FLAG_ERROR) {
 		sb->s_flags |= MS_RDONLY;
 		printk(KERN_INFO "btrfs is forced readonly\n");
-		__btrfs_scrub_cancel(fs_info);
+		btrfs_scrub_cancel(fs_info);
 //		WARN_ON(1);
 	}
 }

commit 292fd7fc39aa06668f3a8db546714e727120cb3e
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Tue Oct 30 17:16:16 2012 +0000

    Btrfs: don't allow degraded mount if too many devices are missing
    
    The current behavior is to allow mounting or remounting a filesystem
    writeable in degraded mode if at least one writeable device is
    present.
    The next failed write access to a missing device which is above
    the tolerance of the configured level of redundancy results in an
    read-only enforcement. Even without this, the next time
    barrier_all_devices() is called and more devices are missing than
    tolerable, the switch to read-only mode takes place.
    
    In order to behave predictably and to provide proper feedback to
    the user at mount time, this patch compares the number of missing
    devices with the number of devices that are tolerated to be missing
    according to the configured RAID level. If more devices are missing
    than tolerated, e.g. if two devices are missing in case of RAID1,
    only a read-only mount and remount is allowed.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 915ac14c2064..acd2df85bed5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1226,6 +1226,15 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 			goto restore;
 		}
 
+		if (fs_info->fs_devices->missing_devices >
+		     fs_info->num_tolerated_disk_barrier_failures &&
+		    !(*flags & MS_RDONLY)) {
+			printk(KERN_WARNING
+			       "Btrfs: too many missing devices, writeable remount is not allowed\n");
+			ret = -EACCES;
+			goto restore;
+		}
+
 		if (btrfs_super_log_root(fs_info->super_copy) != 0) {
 			ret = -EINVAL;
 			goto restore;

commit bedb2cca7252d08c6ca3085826e30f65bdc3b54b
Author: Andrei Popa <andrei.popa@i-neo.ro>
Date:   Thu Sep 20 08:42:11 2012 -0600

    Btrfs: make compress and nodatacow mount options mutually exclusive
    
    If a filesystem is mounted with compression and then remounted by adding nodatacow,
    the compression is disabled but the compress flag is still visible.
    Also, if a filesystem is mounted with nodatacow and then remounted with compression,
    nodatacow flag is still present but it's not active.
    This patch:
    - removes compress flags and notifies that the compression has been disabled if the
      filesystem is mounted with nodatacow
    - removes nodatacow and nodatasum flags if mounted with compress.
    
    Signed-off-by: Andrei Popa <andrei.popa@i-neo.ro>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0fadcdba8ce4..915ac14c2064 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -413,7 +413,15 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_nodatacow:
-			printk(KERN_INFO "btrfs: setting nodatacow\n");
+			if (!btrfs_test_opt(root, COMPRESS) ||
+				!btrfs_test_opt(root, FORCE_COMPRESS)) {
+					printk(KERN_INFO "btrfs: setting nodatacow, compression disabled\n");
+			} else {
+				printk(KERN_INFO "btrfs: setting nodatacow\n");
+			}
+			info->compress_type = BTRFS_COMPRESS_NONE;
+			btrfs_clear_opt(info->mount_opt, COMPRESS);
+			btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
 			btrfs_set_opt(info->mount_opt, NODATACOW);
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
@@ -428,10 +436,14 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				compress_type = "zlib";
 				info->compress_type = BTRFS_COMPRESS_ZLIB;
 				btrfs_set_opt(info->mount_opt, COMPRESS);
+				btrfs_clear_opt(info->mount_opt, NODATACOW);
+				btrfs_clear_opt(info->mount_opt, NODATASUM);
 			} else if (strcmp(args[0].from, "lzo") == 0) {
 				compress_type = "lzo";
 				info->compress_type = BTRFS_COMPRESS_LZO;
 				btrfs_set_opt(info->mount_opt, COMPRESS);
+				btrfs_clear_opt(info->mount_opt, NODATACOW);
+				btrfs_clear_opt(info->mount_opt, NODATASUM);
 				btrfs_set_fs_incompat(info, COMPRESS_LZO);
 			} else if (strncmp(args[0].from, "no", 2) == 0) {
 				compress_type = "no";

commit 489406626c42c0176fddae2182d33be2cfb9840c
Author: Daniel J Blueman <daniel@quora.org>
Date:   Mon May 7 06:35:38 2012 -0600

    btrfs: fix message printing
    
    Fix various messages to include newline and module prefix.
    
    Signed-off-by: Daniel J Blueman <daniel@quora.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f8b803f30ed8..0fadcdba8ce4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -243,7 +243,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 			       struct btrfs_root *root, const char *function,
 			       unsigned int line, int errno)
 {
-	WARN_ONCE(1, KERN_DEBUG "btrfs: Transaction aborted");
+	WARN_ONCE(1, KERN_DEBUG "btrfs: Transaction aborted\n");
 	trans->aborted = errno;
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */
@@ -549,11 +549,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);
 			break;
 		case Opt_defrag:
-			printk(KERN_INFO "btrfs: enabling auto defrag");
+			printk(KERN_INFO "btrfs: enabling auto defrag\n");
 			btrfs_set_opt(info->mount_opt, AUTO_DEFRAG);
 			break;
 		case Opt_recovery:
-			printk(KERN_INFO "btrfs: enabling auto recovery");
+			printk(KERN_INFO "btrfs: enabling auto recovery\n");
 			btrfs_set_opt(info->mount_opt, RECOVERY);
 			break;
 		case Opt_skip_balance:
@@ -1602,7 +1602,7 @@ static int btrfs_interface_init(void)
 static void btrfs_interface_exit(void)
 {
 	if (misc_deregister(&btrfs_misc) < 0)
-		printk(KERN_INFO "misc_deregister failed for control device");
+		printk(KERN_INFO "btrfs: misc_deregister failed for control device\n");
 }
 
 static int __init init_btrfs_fs(void)

commit 354aa0fb6d5b97b262e056f7ad7bfc88d7ce0004
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Sep 20 01:54:00 2012 -0600

    Btrfs: fix orphan transaction on the freezed filesystem
    
    With the following debug patch:
    
     static int btrfs_freeze(struct super_block *sb)
     {
    +       struct btrfs_fs_info *fs_info = btrfs_sb(sb);
    +       struct btrfs_transaction *trans;
    +
    +       spin_lock(&fs_info->trans_lock);
    +       trans = fs_info->running_transaction;
    +       if (trans) {
    +               printk("Transid %llu, use_count %d, num_writer %d\n",
    +                       trans->transid, atomic_read(&trans->use_count),
    +                       atomic_read(&trans->num_writers));
    +       }
    +       spin_unlock(&fs_info->trans_lock);
            return 0;
     }
    
    I found there was a orphan transaction after the freeze operation was done.
    
    It is because the transaction may not be committed when the transaction handle
    end even though it is the last handle of the current transaction. This design
    avoid committing the transaction frequently, but also introduce the above
    problem.
    
    So I add btrfs_attach_transaction() which can catch the current transaction
    and commit it. If there is no transaction, it will return ENOENT, and do not
    anything.
    
    This function also can be used to instead of btrfs_join_transaction_freeze()
    because it don't increase the writer counter and don't start a new transaction,
    so it also can fix the deadlock between sync and freeze.
    
    Besides that, it is used to instead of btrfs_join_transaction() in
    transaction_kthread(), because if there is no transaction, the transaction
    kthread needn't anything.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index fb260bbf59c6..f8b803f30ed8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -854,10 +854,10 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 
 	btrfs_wait_ordered_extents(root, 0);
 
-	trans = btrfs_join_transaction_freeze(root);
+	trans = btrfs_attach_transaction(root);
 	if (IS_ERR(trans)) {
-		/* Frozen, don't bother */
-		if (PTR_ERR(trans) == -EPERM)
+		/* no transaction, don't bother */
+		if (PTR_ERR(trans) == -ENOENT)
 			return 0;
 		return PTR_ERR(trans);
 	}
@@ -1511,7 +1511,17 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 
 static int btrfs_freeze(struct super_block *sb)
 {
-	return 0;
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *root = btrfs_sb(sb)->tree_root;
+
+	trans = btrfs_attach_transaction(root);
+	if (IS_ERR(trans)) {
+		/* no transaction, don't bother */
+		if (PTR_ERR(trans) == -ENOENT)
+			return 0;
+		return PTR_ERR(trans);
+	}
+	return btrfs_commit_transaction(trans, root);
 }
 
 static int btrfs_unfreeze(struct super_block *sb)

commit 926ced123bd6651b30a07f65a2a8a0b26154cd58
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Sep 14 13:58:59 2012 -0400

    Btrfs: don't do anything in our ->freeze_fs and ->unfreeze_fs
    
    We do not need to do anything special to freeze or unfreeze, it's all taken
    care of by the generic work, and what we currently have is wrong anyway
    since we shouldn't be returnning to userspace with mutexes held anyway.
    Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5aa3b8182d96..fb260bbf59c6 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1511,17 +1511,11 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 
 static int btrfs_freeze(struct super_block *sb)
 {
-	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
-	mutex_lock(&fs_info->transaction_kthread_mutex);
-	mutex_lock(&fs_info->cleaner_mutex);
 	return 0;
 }
 
 static int btrfs_unfreeze(struct super_block *sb)
 {
-	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
-	mutex_unlock(&fs_info->cleaner_mutex);
-	mutex_unlock(&fs_info->transaction_kthread_mutex);
 	return 0;
 }
 

commit 6bbe3a9c805fcb8cd8d396dafd32078181a7cdd5
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Fri Sep 14 02:58:07 2012 -0600

    Btrfs: kill obsolete arguments in btrfs_wait_ordered_extents
    
    nocow_only is now an obsolete argument.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 903ab2d7068a..5aa3b8182d96 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -852,7 +852,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_wait_ordered_extents(root, 0, 0);
+	btrfs_wait_ordered_extents(root, 0);
 
 	trans = btrfs_join_transaction_freeze(root);
 	if (IS_ERR(trans)) {

commit 60376ce4a8396bc5cd777be05b6a9bf044520f42
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Sep 14 10:34:40 2012 -0400

    Btrfs: fix race in sync and freeze again
    
    I screwed this up, there is a race between checking if there is a running
    transaction and actually starting a transaction in sync where we could race
    with a freezer and get ourselves into trouble.  To fix this we need to make
    a new join type to only do the try lock on the freeze stuff.  If it fails
    we'll return EPERM and just return from sync.  This fixes a hang Liu Bo
    reported when running xfstest 68 in a loop.  Thanks,
    
    Reported-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 867e8e799dea..903ab2d7068a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -854,16 +854,13 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 
 	btrfs_wait_ordered_extents(root, 0, 0);
 
-	spin_lock(&fs_info->trans_lock);
-	if (!fs_info->running_transaction) {
-		spin_unlock(&fs_info->trans_lock);
-		return 0;
-	}
-	spin_unlock(&fs_info->trans_lock);
-
-	trans = btrfs_join_transaction(root);
-	if (IS_ERR(trans))
+	trans = btrfs_join_transaction_freeze(root);
+	if (IS_ERR(trans)) {
+		/* Frozen, don't bother */
+		if (PTR_ERR(trans) == -EPERM)
+			return 0;
 		return PTR_ERR(trans);
+	}
 	return btrfs_commit_transaction(trans, root);
 }
 

commit 69ce977a179750915e04fcc12bfbe33e6c8f5132
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Sep 6 04:04:44 2012 -0600

    Btrfs: output more information when aborting a unused transaction handle
    
    Though we dump the stack information when aborting a unused transaction
    handle, we don't know the correct place where we decide to abort the
    transaction handle if one function has several place where the transaction
    abort function is invoked and jumps to the same place after this call.
    And beside that we also don't know the reason why we jump to abort
    the current handle. So I modify the transaction abort function and make
    it output the function name, line and error information.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 06ff1dd0f9b7..867e8e799dea 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -248,7 +248,13 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */
 	if (!trans->blocks_used) {
-		btrfs_printk(root->fs_info, "Aborting unused transaction.\n");
+		char nbuf[16];
+		const char *errstr;
+
+		errstr = btrfs_decode_error(root->fs_info, errno, nbuf);
+		btrfs_printk(root->fs_info,
+			     "%s:%d: Aborting unused transaction(%s).\n",
+			     function, line, errstr);
 		return;
 	}
 	trans->transaction->aborted = errno;

commit 6352b91da1a2108bb8cc5115e8714f90d706f15f
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Thu Sep 6 04:01:51 2012 -0600

    Btrfs: use a slab for ordered extents allocation
    
    The ordered extent allocation is in the fast path of the IO, so use a slab
    to improve the speed of the allocation.
    
     "Size of the struct is 280, so this will fall into the size-512 bucket,
      giving 8 objects per page, while own slab will pack 14 objects into a page.
    
      Another benefit I see is to check for leaked objects when the module is
      removed (and the cache destroy takes place)."
                                                    -- David Sterba
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 83d6f9f9c220..06ff1dd0f9b7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1620,10 +1620,14 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_extent_io;
 
-	err = btrfs_delayed_inode_init();
+	err = ordered_data_init();
 	if (err)
 		goto free_extent_map;
 
+	err = btrfs_delayed_inode_init();
+	if (err)
+		goto free_ordered_data;
+
 	err = btrfs_interface_init();
 	if (err)
 		goto free_delayed_inode;
@@ -1641,6 +1645,8 @@ static int __init init_btrfs_fs(void)
 	btrfs_interface_exit();
 free_delayed_inode:
 	btrfs_delayed_inode_exit();
+free_ordered_data:
+	ordered_data_exit();
 free_extent_map:
 	extent_map_exit();
 free_extent_io:
@@ -1657,6 +1663,7 @@ static void __exit exit_btrfs_fs(void)
 {
 	btrfs_destroy_cachep();
 	btrfs_delayed_inode_exit();
+	ordered_data_exit();
 	extent_map_exit();
 	extent_io_exit();
 	btrfs_interface_exit();

commit 318e15101993c0fdc3f23f24ac61fc7769d27e68
Merge: a7ccbcf33070 256dd1bb3750
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 29 11:36:22 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs fixes from Chris Mason:
     "I've split out the big send/receive update from my last pull request
      and now have just the fixes in my for-linus branch.  The send/recv
      branch will wander over to linux-next shortly though.
    
      The largest patches in this pull are Josef's patches to fix DIO
      locking problems and his patch to fix a crash during balance.  They
      are both well tested.
    
      The rest are smaller fixes that we've had queued.  The last rc came
      out while I was hacking new and exciting ways to recover from a
      misplaced rm -rf on my dev box, so these missed rc3."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (25 commits)
      Btrfs: fix that repair code is spuriously executed for transid failures
      Btrfs: fix ordered extent leak when failing to start a transaction
      Btrfs: fix a dio write regression
      Btrfs: fix deadlock with freeze and sync V2
      Btrfs: revert checksum error statistic which can cause a BUG()
      Btrfs: remove superblock writing after fatal error
      Btrfs: allow delayed refs to be merged
      Btrfs: fix enospc problems when deleting a subvol
      Btrfs: fix wrong mtime and ctime when creating snapshots
      Btrfs: fix race in run_clustered_refs
      Btrfs: don't run __tree_mod_log_free_eb on leaves
      Btrfs: increase the size of the free space cache
      Btrfs: barrier before waitqueue_active
      Btrfs: fix deadlock in wait_for_more_refs
      btrfs: fix second lock in btrfs_delete_delayed_items()
      Btrfs: don't allocate a seperate csums array for direct reads
      Btrfs: do not strdup non existent strings
      Btrfs: do not use missing devices when showing devname
      Btrfs: fix that error value is changed by mistake
      Btrfs: lock extents as we map them in DIO
      ...

commit bd7de2c9a449e26a5493d918618eb20ae60d56bd
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Aug 24 12:53:03 2012 -0600

    Btrfs: fix deadlock with freeze and sync V2
    
    We can deadlock with freeze right now because we unconditionally start a
    transaction in our ->sync_fs() call.  To fix this just check and see if we
    have a running transaction to commit.  This saves us from the deadlock
    because at this point we'll have the umount sem for the sb so we're safe
    from freezes coming in after we've done our check.  With this patch the
    freeze xfstests no longer deadlocks.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2e06f124f284..073c2368f459 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -813,7 +813,6 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	struct btrfs_trans_handle *trans;
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	struct btrfs_root *root = fs_info->tree_root;
-	int ret;
 
 	trace_btrfs_sync_fs(wait);
 
@@ -824,11 +823,17 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 
 	btrfs_wait_ordered_extents(root, 0, 0);
 
-	trans = btrfs_start_transaction(root, 0);
+	spin_lock(&fs_info->trans_lock);
+	if (!fs_info->running_transaction) {
+		spin_unlock(&fs_info->trans_lock);
+		return 0;
+	}
+	spin_unlock(&fs_info->trans_lock);
+
+	trans = btrfs_join_transaction(root);
 	if (IS_ERR(trans))
 		return PTR_ERR(trans);
-	ret = btrfs_commit_transaction(trans, root);
-	return ret;
+	return btrfs_commit_transaction(trans, root);
 }
 
 static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)

commit aa9ddcd4b5557102fa25695c11904f249b4dec49
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Thu Aug 2 10:22:20 2012 -0400

    Btrfs: do not use missing devices when showing devname
    
    If you do the following
    
    mkfs.btrfs /dev/sdb /dev/sdc
    rmmod btrfs
    dd if=/dev/zero of=/dev/sdb bs=1M count=1
    mount -o degraded /dev/sdc /mnt/btrfs-test
    
    the box will panic trying to deref the name for the missing dev since it is
    the lower numbered devid.  So fix show_devname to not use missing devices.
    Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 75ee2c7791f0..2e06f124f284 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1505,6 +1505,8 @@ static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 	while (cur_devices) {
 		head = &cur_devices->devices;
 		list_for_each_entry(dev, head, dev_list) {
+			if (dev->missing)
+				continue;
 			if (!first_dev || dev->devid < first_dev->devid)
 				first_dev = dev;
 		}

commit 34eaadaf22b0dd453288c6b115e0c823a0fb74d5
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Jul 25 18:12:05 2012 +0300

    btrfs: nuke write_super from comments
    
    The '->write_super' superblock method is gone, and this patch removes all the
    references to 'write_super' from btrfs.
    
    Cc: Chris Mason <chris.mason@fusionio.com>
    Cc: linux-btrfs@vger.kernel.org
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8c6e61d6eed5..f2eb24c477a3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -100,10 +100,6 @@ static void __save_error_info(struct btrfs_fs_info *fs_info)
 	fs_info->fs_state = BTRFS_SUPER_FLAG_ERROR;
 }
 
-/* NOTE:
- *	We move write_super stuff at umount in order to avoid deadlock
- *	for umount hold all lock.
- */
 static void save_error_info(struct btrfs_fs_info *fs_info)
 {
 	__save_error_info(fs_info);

commit 533574c6bc30cf526cc1c41bde050c854a945efb
Author: Joe Perches <joe@perches.com>
Date:   Mon Jul 30 14:40:13 2012 -0700

    btrfs: use printk_get_level and printk_skip_level, add __printf, fix fallout
    
    Use the generic printk_get_level() to search a message for a kern_level.
    
    Add __printf to verify format and arguments.  Fix a few messages that
    had mismatches in format and arguments.  Add #ifdef CONFIG_PRINTK blocks
    to shrink the object size a bit when not using printk.
    
    [akpm@linux-foundation.org: whitespace tweak]
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Chris Mason <chris.mason@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index fa61ef59cd61..8c6e61d6eed5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -125,6 +125,7 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 	}
 }
 
+#ifdef CONFIG_PRINTK
 /*
  * __btrfs_std_error decodes expected errors from the caller and
  * invokes the approciate error response.
@@ -167,7 +168,7 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 	va_end(args);
 }
 
-const char *logtypes[] = {
+static const char * const logtypes[] = {
 	"emergency",
 	"alert",
 	"critical",
@@ -185,22 +186,50 @@ void btrfs_printk(struct btrfs_fs_info *fs_info, const char *fmt, ...)
 	struct va_format vaf;
 	va_list args;
 	const char *type = logtypes[4];
+	int kern_level;
 
 	va_start(args, fmt);
 
-	if (fmt[0] == '<' && isdigit(fmt[1]) && fmt[2] == '>') {
-		memcpy(lvl, fmt, 3);
-		lvl[3] = '\0';
-		fmt += 3;
-		type = logtypes[fmt[1] - '0'];
+	kern_level = printk_get_level(fmt);
+	if (kern_level) {
+		size_t size = printk_skip_level(fmt) - fmt;
+		memcpy(lvl, fmt,  size);
+		lvl[size] = '\0';
+		fmt += size;
+		type = logtypes[kern_level - '0'];
 	} else
 		*lvl = '\0';
 
 	vaf.fmt = fmt;
 	vaf.va = &args;
+
 	printk("%sBTRFS %s (device %s): %pV", lvl, type, sb->s_id, &vaf);
+
+	va_end(args);
 }
 
+#else
+
+void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
+		       unsigned int line, int errno, const char *fmt, ...)
+{
+	struct super_block *sb = fs_info->sb;
+
+	/*
+	 * Special case: if the error is EROFS, and we're already
+	 * under MS_RDONLY, then it is safe here.
+	 */
+	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
+		return;
+
+	/* Don't go through full error handling during mount */
+	if (sb->s_flags & MS_BORN) {
+		save_error_info(fs_info);
+		btrfs_handle_error(fs_info);
+	}
+}
+#endif
+
 /*
  * We only mark the transaction aborted and then set the file system read-only.
  * This will prevent new transactions from starting or trying to join this

commit e2aed8dfa50bb061747eeb14e6af099554a03b76
Merge: 476525004ac7 b24baf6917a3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 26 14:48:55 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull large btrfs update from Chris Mason:
     "This pull request is very large, and the two main features in here
      have been under testing/devel for quite a while.
    
      We have subvolume quotas from the strato developers.  This enables
      full tracking of how many blocks are allocated to each subvolume (and
      all snapshots) and you can set limits on a per-subvolume basis.  You
      can also create quota groups and toss multiple subvolumes into a big
      group.  It's everything you need to be a web hosting company and give
      each user their own subvolume.
    
      The userland side of the quotas is being refreshed, they'll send out
      details on where to grab it soon.
    
      Next is the kernel side of btrfs send/receive from Alexander Block.
      This leverages the same infrastructure as the quota code to figure out
      relationships between blocks and their owners.  It can then compute
      the difference between two snapshots and sends the diffs in a neutral
      format into userland.
    
      The basic model:
    
            create a snapshot
            send that snapshot as the initial backup
            make changes
            create a second snapshot
            send the incremental as a backup
            delete the first snapshot
            (use the second snapshot for the next incremental)
    
      The receive portion is all in userland, and in the 'next' branch of my
      btrfs-progs repo.
    
      There's still some work to do in terms of optimizing the send side
      from kernel to userland.  The really important part is figuring out
      how two snapshots are different, and this is where we are
      concentrating right now.  The initial send of a dataset is a little
      slower than tar, but the incremental sends are dramatically faster
      than what rsync can do.
    
      On top of all of that, we have a nice queue of fixes, cleanups and
      optimizations."
    
    Fix up trivial modify/del conflict in fs/btrfs/ioctl.c
    
    Also fix up semantic conflict in fs/btrfs/send.c: the interface to
    dentry_open() changed in commit 765927b2d508 ("switch dentry_open() to
    struct path, make it grab references itself"), and since it now grabs
    whatever references it needs, we should no longer do the mntget() on the
    mnt (and we need to dput() the dentry reference we took).
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (65 commits)
      Btrfs: uninit variable fixes in send/receive
      Btrfs: introduce BTRFS_IOC_SEND for btrfs send/receive
      Btrfs: add btrfs_compare_trees function
      Btrfs: introduce subvol uuids and times
      Btrfs: make iref_to_path non static
      Btrfs: add a barrier before a waitqueue_active check
      Btrfs: call the ordered free operation without any locks held
      Btrfs: Check INCOMPAT flags on remount and add helper function
      Btrfs: add helper for tree enumeration
      btrfs: allow cross-subvolume file clone
      Btrfs: improve multi-thread buffer read
      Btrfs: make btrfs's allocation smoothly with preallocation
      Btrfs: lock the transition from dirty to writeback for an eb
      Btrfs: fix potential race in extent buffer freeing
      Btrfs: don't return true in releasepage unless we actually freed the eb
      Btrfs: suppress printk() if all device I/O stats are zero
      Btrfs: remove unwanted printk() for btrfs device I/O stats
      Btrfs: rewrite BTRFS_SETGET_FUNCS
      Btrfs: zero unused bytes in inode item
      Btrfs: kill free_space pointer from inode structure
      ...
    
    Conflicts:
            fs/btrfs/ioctl.c

commit 2b0ce2c2909368d124a78a88e5c7106fdcba6221
Author: Mitch Harder <mitch.harder@sabayonlinux.org>
Date:   Tue Jul 24 11:58:43 2012 -0600

    Btrfs: Check INCOMPAT flags on remount and add helper function
    
    In support of the recently added capability to remount with lzo
    compression, provide a helper function to check the compression
    INCOMPAT flags when remounting with lzo compression, and set
    the flags if necessary.
    
    Also, implement the new helper function when defragmenting with
    explicit lzo compression and when setting the default subvolume.
    
    Signed-off-by: Mitch Harder <mitch.harder@sabayonlinux.org>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 26da344231ac..75ee2c7791f0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -401,6 +401,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				compress_type = "lzo";
 				info->compress_type = BTRFS_COMPRESS_LZO;
 				btrfs_set_opt(info->mount_opt, COMPRESS);
+				btrfs_set_fs_incompat(info, COMPRESS_LZO);
 			} else if (strncmp(args[0].from, "no", 2) == 0) {
 				compress_type = "no";
 				info->compress_type = BTRFS_COMPRESS_NONE;

commit 02db0844beffc1c4e99d750be58ffb3ed95d6d62
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Thu Jun 21 16:03:58 2012 -0400

    Btrfs: add DEVICE_READY ioctl
    
    This will be used in conjunction with btrfs device ready <dev>.  This is
    needed for initrd's to have a nice and lightweight way to tell if all of the
    devices needed for a file system are in the cache currently.  This keeps
    them from having to do mount+sleep loops waiting for devices to show up.
    Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 88a2d2bb2d75..26da344231ac 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1462,6 +1462,13 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
 					    &btrfs_fs_type, &fs_devices);
 		break;
+	case BTRFS_IOC_DEVICES_READY:
+		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
+					    &btrfs_fs_type, &fs_devices);
+		if (ret)
+			break;
+		ret = !(fs_devices->num_devices == fs_devices->total_devices);
+		break;
 	}
 
 	kfree(vol);

commit 063849eafda03edf6872a3728b4a98dcc86290c7
Author: Arnd Hannemann <arnd@arndnet.de>
Date:   Mon Apr 16 15:27:51 2012 +0200

    Btrfs: allow mount -o remount,compress=no
    
    Btrfs allows to turn on compression on a mounted and used filesystem
    by issuing mount -o remount,compress=lzo.
    This patch allows to turn compression off again
    while the filesystem is mounted. As suggested by David Sterba
    if the compress-force option was set, it is implicitly cleared
    if compression is turned off.
    
    Tested-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Arnd Hannemann <arnd@arndnet.de>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ddc2efdda1ab..88a2d2bb2d75 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -396,15 +396,22 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			    strcmp(args[0].from, "zlib") == 0) {
 				compress_type = "zlib";
 				info->compress_type = BTRFS_COMPRESS_ZLIB;
+				btrfs_set_opt(info->mount_opt, COMPRESS);
 			} else if (strcmp(args[0].from, "lzo") == 0) {
 				compress_type = "lzo";
 				info->compress_type = BTRFS_COMPRESS_LZO;
+				btrfs_set_opt(info->mount_opt, COMPRESS);
+			} else if (strncmp(args[0].from, "no", 2) == 0) {
+				compress_type = "no";
+				info->compress_type = BTRFS_COMPRESS_NONE;
+				btrfs_clear_opt(info->mount_opt, COMPRESS);
+				btrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);
+				compress_force = false;
 			} else {
 				ret = -EINVAL;
 				goto out;
 			}
 
-			btrfs_set_opt(info->mount_opt, COMPRESS);
 			if (compress_force) {
 				btrfs_set_opt(info->mount_opt, FORCE_COMPRESS);
 				pr_info("btrfs: force %s compression\n",

commit c5c3c5f31e6af2d12b154251a7f23b7f4add6b1d
Author: Josef Bacik <josef@redhat.com>
Date:   Thu Apr 5 14:42:44 2012 -0400

    Btrfs: remove ->dirty_inode
    
    We do all of our inode updating when we change it, and now that we do
    ->update_time we don't need ->dirty_inode for atime updates anymore, so just
    remove it.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e23991574fdf..ddc2efdda1ab 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1477,16 +1477,6 @@ static int btrfs_unfreeze(struct super_block *sb)
 	return 0;
 }
 
-static void btrfs_fs_dirty_inode(struct inode *inode, int flags)
-{
-	int ret;
-
-	ret = btrfs_dirty_inode(inode);
-	if (ret)
-		printk_ratelimited(KERN_ERR "btrfs: fail to dirty inode %Lu "
-				   "error %d\n", btrfs_ino(inode), ret);
-}
-
 static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(root->d_sb);
@@ -1526,7 +1516,6 @@ static const struct super_operations btrfs_super_ops = {
 	.show_options	= btrfs_show_options,
 	.show_devname	= btrfs_show_devname,
 	.write_inode	= btrfs_write_inode,
-	.dirty_inode	= btrfs_fs_dirty_inode,
 	.alloc_inode	= btrfs_alloc_inode,
 	.destroy_inode	= btrfs_destroy_inode,
 	.statfs		= btrfs_statfs,

commit 9249e17fe094d853d1ef7475dd559a2cc7e23d42
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jun 25 12:55:37 2012 +0100

    VFS: Pass mount flags to sget()
    
    Pass mount flags to sget() so that it can use them in initialising a new
    superblock before the set function is called.  They could also be passed to the
    compare function.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e23991574fdf..b19d75567728 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1068,7 +1068,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	}
 
 	bdev = fs_devices->latest_bdev;
-	s = sget(fs_type, btrfs_test_super, btrfs_set_super, fs_info);
+	s = sget(fs_type, btrfs_test_super, btrfs_set_super, flags | MS_NOSEC,
+		 fs_info);
 	if (IS_ERR(s)) {
 		error = PTR_ERR(s);
 		goto error_close_devices;
@@ -1082,7 +1083,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	} else {
 		char b[BDEVNAME_SIZE];
 
-		s->s_flags = flags | MS_NOSEC;
 		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
 		btrfs_sb(s)->bdev_holder = fs_type;
 		error = btrfs_fill_super(s, fs_devices, data,

commit 2b6ba629b5aac51e7099efbb43e2b403213aa7fb
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Fri Jun 22 12:24:13 2012 -0600

    Btrfs: resume balance on rw (re)mounts properly
    
    This introduces btrfs_resume_balance_async(), which, given that
    restriper state was recovered earlier by btrfs_recover_balance(),
    resumes balance in btrfs-balance kthread.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0eb9a4da069e..e23991574fdf 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1187,6 +1187,10 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (ret)
 			goto restore;
 
+		ret = btrfs_resume_balance_async(fs_info);
+		if (ret)
+			goto restore;
+
 		sb->s_flags &= ~MS_RDONLY;
 	}
 

commit 9c5085c147989d48dfe74194b48affc23f376650
Author: Josef Bacik <josef@redhat.com>
Date:   Tue Jun 5 14:13:12 2012 -0400

    Btrfs: implement ->show_devname
    
    Because btrfs can remove the device that was mounted we need to have a
    ->show_devname so that in this case we can print out some other device in
    the file system to /proc/mount.  So if there are multiple devices in a btrfs
    file system we will just print the device with the lowest devid that we can
    find.  This will make everything consistent and deal with device removal
    properly.  The drawback is if you mount with a device that is higher than
    the lowest devicd it won't show up as the mounted device in /proc/mounts,
    but this is a small price to pay. This was inspired by Miao Xie's patch.
    Thanks,
    
    Reviewed-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 96eb9fef7bd2..0eb9a4da069e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -54,6 +54,7 @@
 #include "version.h"
 #include "export.h"
 #include "compression.h"
+#include "rcu-string.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/btrfs.h>
@@ -1482,12 +1483,44 @@ static void btrfs_fs_dirty_inode(struct inode *inode, int flags)
 				   "error %d\n", btrfs_ino(inode), ret);
 }
 
+static int btrfs_show_devname(struct seq_file *m, struct dentry *root)
+{
+	struct btrfs_fs_info *fs_info = btrfs_sb(root->d_sb);
+	struct btrfs_fs_devices *cur_devices;
+	struct btrfs_device *dev, *first_dev = NULL;
+	struct list_head *head;
+	struct rcu_string *name;
+
+	mutex_lock(&fs_info->fs_devices->device_list_mutex);
+	cur_devices = fs_info->fs_devices;
+	while (cur_devices) {
+		head = &cur_devices->devices;
+		list_for_each_entry(dev, head, dev_list) {
+			if (!first_dev || dev->devid < first_dev->devid)
+				first_dev = dev;
+		}
+		cur_devices = cur_devices->seed;
+	}
+
+	if (first_dev) {
+		rcu_read_lock();
+		name = rcu_dereference(first_dev->name);
+		seq_escape(m, name->str, " \t\n\\");
+		rcu_read_unlock();
+	} else {
+		WARN_ON(1);
+	}
+	mutex_unlock(&fs_info->fs_devices->device_list_mutex);
+	return 0;
+}
+
 static const struct super_operations btrfs_super_ops = {
 	.drop_inode	= btrfs_drop_inode,
 	.evict_inode	= btrfs_evict_inode,
 	.put_super	= btrfs_put_super,
 	.sync_fs	= btrfs_sync_fs,
 	.show_options	= btrfs_show_options,
+	.show_devname	= btrfs_show_devname,
 	.write_inode	= btrfs_write_inode,
 	.dirty_inode	= btrfs_fs_dirty_inode,
 	.alloc_inode	= btrfs_alloc_inode,

commit f60d16a8923201bb27ad7c09016abab2818cf8ce
Author: Jim Meyering <meyering@redhat.com>
Date:   Wed Apr 25 21:24:17 2012 +0200

    Btrfs: avoid buffer overrun in mount option handling
    
    There is an off-by-one error: allocating room for a maximal result
    string but without room for a trailing NUL.  That, can lead to
    returning a transformed string that is not NUL-terminated, and
    then to a caller reading beyond end of the malloc'd buffer.
    
    Rewrite to s/kzalloc/kmalloc/, remove unwarranted use of strncpy
    (the result is guaranteed to fit), remove dead strlen at end, and
    change a few variable names and comments.
    
    Reviewed-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Jim Meyering <meyering@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 46b26650415f..96eb9fef7bd2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -923,63 +923,48 @@ static inline int is_subvolume_inode(struct inode *inode)
  */
 static char *setup_root_args(char *args)
 {
-	unsigned copied = 0;
-	unsigned len = strlen(args) + 2;
-	char *pos;
-	char *ret;
+	unsigned len = strlen(args) + 2 + 1;
+	char *src, *dst, *buf;
 
 	/*
-	 * We need the same args as before, but minus
+	 * We need the same args as before, but with this substitution:
+	 * s!subvol=[^,]+!subvolid=0!
 	 *
-	 * subvol=a
-	 *
-	 * and add
-	 *
-	 * subvolid=0
-	 *
-	 * which is a difference of 2 characters, so we allocate strlen(args) +
-	 * 2 characters.
+	 * Since the replacement string is up to 2 bytes longer than the
+	 * original, allocate strlen(args) + 2 + 1 bytes.
 	 */
-	ret = kzalloc(len * sizeof(char), GFP_NOFS);
-	if (!ret)
-		return NULL;
-	pos = strstr(args, "subvol=");
 
+	src = strstr(args, "subvol=");
 	/* This shouldn't happen, but just in case.. */
-	if (!pos) {
-		kfree(ret);
+	if (!src)
+		return NULL;
+
+	buf = dst = kmalloc(len, GFP_NOFS);
+	if (!buf)
 		return NULL;
-	}
 
 	/*
-	 * The subvol=<> arg is not at the front of the string, copy everybody
-	 * up to that into ret.
+	 * If the subvol= arg is not at the start of the string,
+	 * copy whatever precedes it into buf.
 	 */
-	if (pos != args) {
-		*pos = '\0';
-		strcpy(ret, args);
-		copied += strlen(args);
-		pos++;
+	if (src != args) {
+		*src++ = '\0';
+		strcpy(buf, args);
+		dst += strlen(args);
 	}
 
-	strncpy(ret + copied, "subvolid=0", len - copied);
-
-	/* Length of subvolid=0 */
-	copied += 10;
+	strcpy(dst, "subvolid=0");
+	dst += strlen("subvolid=0");
 
 	/*
-	 * If there is no , after the subvol= option then we know there's no
-	 * other options and we can just return.
+	 * If there is a "," after the original subvol=... string,
+	 * copy that suffix into our buffer.  Otherwise, we're done.
 	 */
-	pos = strchr(pos, ',');
-	if (!pos)
-		return ret;
+	src = strchr(src, ',');
+	if (src)
+		strcpy(dst, src);
 
-	/* Copy the rest of the arguments into our buffer */
-	strncpy(ret + copied, pos, len - copied);
-	copied += strlen(pos);
-
-	return ret;
+	return buf;
 }
 
 static struct dentry *mount_subvol(const char *subvol_name, int flags,

commit f07c9a79f06cd33b1c9c2c4eacb60bafa7e3f310
Author: Jim Meyering <jim@meyering.net>
Date:   Thu Apr 26 18:35:12 2012 +0200

    Btrfs: avoid buffer overrun in btrfs_printk
    
    The buffer read-overrun would be triggered by a printk format
    starting with <N>, where N is a single digit.  NUL-terminate
    after strncpy.  Use memcpy, not strncpy, since we know the
    string we're copying fits in the destination buffer and
    contains no NUL byte.
    
    Signed-off-by: Jim Meyering <meyering@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2cd32175753d..46b26650415f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -188,7 +188,8 @@ void btrfs_printk(struct btrfs_fs_info *fs_info, const char *fmt, ...)
 	va_start(args, fmt);
 
 	if (fmt[0] == '<' && isdigit(fmt[1]) && fmt[2] == '>') {
-		strncpy(lvl, fmt, 3);
+		memcpy(lvl, fmt, 3);
+		lvl[3] = '\0';
 		fmt += 3;
 		type = logtypes[fmt[1] - '0'];
 	} else

commit 0d2450abfa359ff94a2bee64a7daeba68c346c81
Author: Sergei Trofimovich <slyfox@gentoo.org>
Date:   Tue Apr 24 22:59:16 2012 +0300

    btrfs: allow changing 'thread_pool' size at remount time
    
    Changing 'mount -oremount,thread_pool=2 /' didn't make any effect:
    
    maximum amount of worker threads is specified in 2 places:
    - in 'strict btrfs_fs_info::thread_pool_size'
    - in each worker struct: 'struct btrfs_workers::max_workers'
    
    'mount -oremount' updated only 'btrfs_fs_info::thread_pool_size'.
    
    Fix it by pushing new maximum value to all created worker structures
    as well.
    
    Cc: Josef Bacik <josef@redhat.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Reviewed-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index bd6d143cea85..2cd32175753d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -435,11 +435,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_thread_pool:
 			intarg = 0;
 			match_int(&args[0], &intarg);
-			if (intarg) {
+			if (intarg)
 				info->thread_pool_size = intarg;
-				printk(KERN_INFO "btrfs: thread pool %d\n",
-				       info->thread_pool_size);
-			}
 			break;
 		case Opt_max_inline:
 			num = match_strdup(&args[0]);
@@ -1118,6 +1115,40 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	return ERR_PTR(error);
 }
 
+static void btrfs_set_max_workers(struct btrfs_workers *workers, int new_limit)
+{
+	spin_lock_irq(&workers->lock);
+	workers->max_workers = new_limit;
+	spin_unlock_irq(&workers->lock);
+}
+
+static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,
+				     int new_pool_size, int old_pool_size)
+{
+	if (new_pool_size == old_pool_size)
+		return;
+
+	fs_info->thread_pool_size = new_pool_size;
+
+	printk(KERN_INFO "btrfs: resize thread pool %d -> %d\n",
+	       old_pool_size, new_pool_size);
+
+	btrfs_set_max_workers(&fs_info->generic_worker, new_pool_size);
+	btrfs_set_max_workers(&fs_info->workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->delalloc_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->submit_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->caching_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->fixup_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->endio_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->endio_meta_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->endio_meta_write_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->endio_write_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->endio_freespace_worker, new_pool_size);
+	btrfs_set_max_workers(&fs_info->delayed_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->readahead_workers, new_pool_size);
+	btrfs_set_max_workers(&fs_info->scrub_workers, new_pool_size);
+}
+
 static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
@@ -1137,6 +1168,9 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		goto restore;
 	}
 
+	btrfs_resize_thread_pool(fs_info,
+		fs_info->thread_pool_size, old_thread_pool_size);
+
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
 		return 0;
 
@@ -1180,7 +1214,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	fs_info->compress_type = old_compress_type;
 	fs_info->max_inline = old_max_inline;
 	fs_info->alloc_start = old_alloc_start;
-	fs_info->thread_pool_size = old_thread_pool_size;
+	btrfs_resize_thread_pool(fs_info,
+		old_thread_pool_size, fs_info->thread_pool_size);
 	fs_info->metadata_ratio = old_metadata_ratio;
 	return ret;
 }

commit 0c4d2d95d06e920e0c61707e62c7fffc9c57f63a
Author: Josef Bacik <josef@redhat.com>
Date:   Thu Apr 5 15:03:02 2012 -0400

    Btrfs: use i_version instead of our own sequence
    
    We've been keeping around the inode sequence number in hopes that somebody
    would use it, but nobody uses it and people actually use i_version which
    serves the same purpose, so use i_version where we used the incore inode's
    sequence number and that way the sequence is updated properly across the
    board, and not just in file write.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c5f8fca4195f..bd6d143cea85 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -769,7 +769,7 @@ static int btrfs_fill_super(struct super_block *sb,
 #ifdef CONFIG_BTRFS_FS_POSIX_ACL
 	sb->s_flags |= MS_POSIXACL;
 #endif
-
+	sb->s_flags |= MS_I_VERSION;
 	err = open_ctree(sb, fs_devices, (char *)data);
 	if (err) {
 		printk("btrfs: open_ctree failed\n");

commit f7b006931751f029620ad2f8310ac7a1484fbdb4
Merge: b990f9b3cb06 dc7fdde39e49
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 28 09:30:07 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs fixes from Chris Mason:
     "This has our collection of bug fixes.  I missed the last rc because I
      thought our patches were making NFS crash during my xfs test runs.
      Turns out it was an NFS client bug fixed by someone else while I tried
      to bisect it.
    
      All of these fixes are small, but some are fairly high impact.  The
      biggest are fixes for our mount -o remount handling, a deadlock due to
      GFP_KERNEL allocations in readdir, and a RAID10 error handling bug.
    
      This was tested against both 3.3 and Linus' master as of this morning."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (26 commits)
      Btrfs: reduce lock contention during extent insertion
      Btrfs: avoid deadlocks from GFP_KERNEL allocations during btrfs_real_readdir
      Btrfs: Fix space checking during fs resize
      Btrfs: fix block_rsv and space_info lock ordering
      Btrfs: Prevent root_list corruption
      Btrfs: fix repair code for RAID10
      Btrfs: do not start delalloc inodes during sync
      Btrfs: fix that check_int_data mount option was ignored
      Btrfs: don't count CRC or header errors twice while scrubbing
      Btrfs: fix btrfs_ioctl_dev_info() crash on missing device
      btrfs: don't return EINTR
      Btrfs: double unlock bug in error handling
      Btrfs: always store the mirror we read the eb from
      fs/btrfs/volumes.c: add missing free_fs_devices
      btrfs: fix early abort in 'remount'
      Btrfs: fix max chunk size check in chunk allocator
      Btrfs: add missing read locks in backref.c
      Btrfs: don't call free_extent_buffer twice in iterate_irefs
      Btrfs: Make free_ipath() deal gracefully with NULL pointers
      Btrfs: avoid possible use-after-free in clear_extent_bit()
      ...

commit 996d282c7ff470f150a467eb4815b90159d04c47
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Apr 23 20:35:03 2012 -0400

    Btrfs: do not start delalloc inodes during sync
    
    btrfs_start_delalloc_inodes will just walk the list of delalloc inodes and
    start writing them out, but it doesn't splice the list or anything so as
    long as somebody is doing work on the box you could end up in this section
    _forever_.  So just remove it, it's not needed anyway since sync will start
    writeback on all inodes anyway, all we need to do is wait for ordered
    extents and then we can commit the transaction.  In my horrible torture test
    sync goes from taking 4 minutes to about 1.5 minutes.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 43aa2dd0bc7d..f267718cbd1a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -819,7 +819,6 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_start_delalloc_inodes(root, 0);
 	btrfs_wait_ordered_extents(root, 0, 0);
 
 	trans = btrfs_start_transaction(root, 0);

commit 8a3db1849e9e2563727ea2dc32737502e0096641
Author: Sergei Trofimovich <slyfox@gentoo.org>
Date:   Mon Apr 16 06:44:37 2012 +0300

    btrfs: fix early abort in 'remount'
    
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Josef Bacik <josef@redhat.com>
    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 84571d7da12e..43aa2dd0bc7d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1152,13 +1152,15 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (ret)
 			goto restore;
 	} else {
-		if (fs_info->fs_devices->rw_devices == 0)
+		if (fs_info->fs_devices->rw_devices == 0) {
 			ret = -EACCES;
 			goto restore;
+		}
 
-		if (btrfs_super_log_root(fs_info->super_copy) != 0)
+		if (btrfs_super_log_root(fs_info->super_copy) != 0) {
 			ret = -EINVAL;
 			goto restore;
+		}
 
 		ret = btrfs_cleanup_fs_roots(fs_info);
 		if (ret)

commit 9613bebb223dea3179c265dc31e1bb41ae39f321
Merge: 40380f1c7841 bc3f116fec19
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 30 12:44:29 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    Pull btrfs fixes and features from Chris Mason:
     "We've merged in the error handling patches from SuSE.  These are
      already shipping in the sles kernel, and they give btrfs the ability
      to abort transactions and go readonly on errors.  It involves a lot of
      churn as they clarify BUG_ONs, and remove the ones we now properly
      deal with.
    
      Josef reworked the way our metadata interacts with the page cache.
      page->private now points to the btrfs extent_buffer object, which
      makes everything faster.  He changed it so we write an whole extent
      buffer at a time instead of allowing individual pages to go down,,
      which will be important for the raid5/6 code (for the 3.5 merge
      window ;)
    
      Josef also made us more aggressive about dropping pages for metadata
      blocks that were freed due to COW.  Overall, our metadata caching is
      much faster now.
    
      We've integrated my patch for metadata bigger than the page size.
      This allows metadata blocks up to 64KB in size.  In practice 16K and
      32K seem to work best.  For workloads with lots of metadata, this cuts
      down the size of the extent allocation tree dramatically and fragments
      much less.
    
      Scrub was updated to support the larger block sizes, which ended up
      being a fairly large change (thanks Stefan Behrens).
    
      We also have an assortment of fixes and updates, especially to the
      balancing code (Ilya Dryomov), the back ref walker (Jan Schmidt) and
      the defragging code (Liu Bo)."
    
    Fixed up trivial conflicts in fs/btrfs/scrub.c that were just due to
    removal of the second argument to k[un]map_atomic() in commit
    7ac687d9e047.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (75 commits)
      Btrfs: update the checks for mixed block groups with big metadata blocks
      Btrfs: update to the right index of defragment
      Btrfs: do not bother to defrag an extent if it is a big real extent
      Btrfs: add a check to decide if we should defrag the range
      Btrfs: fix recursive defragment with autodefrag option
      Btrfs: fix the mismatch of page->mapping
      Btrfs: fix race between direct io and autodefrag
      Btrfs: fix deadlock during allocating chunks
      Btrfs: show useful info in space reservation tracepoint
      Btrfs: don't use crc items bigger than 4KB
      Btrfs: flush out and clean up any block device pages during mount
      btrfs: disallow unequal data/metadata blocksize for mixed block groups
      Btrfs: enhance superblock sanity checks
      Btrfs: change scrub to support big blocks
      Btrfs: minor cleanup in scrub
      Btrfs: introduce common define for max number of mirrors
      Btrfs: fix infinite loop in btrfs_shrink_device()
      Btrfs: fix memory leak in resolver code
      Btrfs: allow dup for data chunks in mixed mode
      Btrfs: validate target profiles only if we are going to use them
      ...

commit 98961a7e431735c791dbaaf0337029e219a5db5a
Merge: 1c691b330a19 7a3ae2f8c8c8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 28 20:33:40 2012 -0400

    Merge git://git.jan-o-sch.net/btrfs-unstable into for-linus
    
    Conflicts:
            fs/btrfs/transaction.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit e565d4b962948e70f37f417603caf131a773621b
Author: Jan Schmidt <list.btrfs@jan-o-sch.net>
Date:   Fri Mar 23 17:14:20 2012 +0100

    Btrfs: actually call btrfs_init_lockdep
    
    btrfs_init_lockdep only makes our lockdep class names look prettier, thus
    it did never hurt we forgot to actually call it. This turns our lockdep
    identifier strings from lockdep auto-set #[id] into really pretty
    "btrfs-fs-01" or "btrfs-csum-03".
    
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 61717a4eb14f..5239003d453e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1404,6 +1404,8 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto unregister_ioctl;
 
+	btrfs_init_lockdep();
+
 	printk(KERN_INFO "%s loaded\n", BTRFS_BUILD_VERSION);
 	return 0;
 

commit 79787eaab46121d4713ed03c8fc63b9ec3eaec76
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Mar 12 16:03:00 2012 +0100

    btrfs: replace many BUG_ONs with proper error handling
    
     btrfs currently handles most errors with BUG_ON. This patch is a work-in-
     progress but aims to handle most errors other than internal logic
     errors and ENOMEM more gracefully.
    
     This iteration prevents most crashes but can run into lockups with
     the page lock on occasion when the timing "works out."
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0517bd70b04c..9db64165123a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -216,7 +216,7 @@ void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 			       struct btrfs_root *root, const char *function,
 			       unsigned int line, int errno)
 {
-	WARN_ON_ONCE(1);
+	WARN_ONCE(1, KERN_DEBUG "btrfs: Transaction aborted");
 	trans->aborted = errno;
 	/* Nothing used. The other threads that have joined this
 	 * transaction may be able to continue. */

commit 49b25e0540904be0bf558b84475c69d72e4de66e
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Mar 1 17:24:58 2012 +0100

    btrfs: enhance transaction abort infrastructure
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7fe69eef7607..0517bd70b04c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -119,6 +119,8 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
 	if (fs_info->fs_state & BTRFS_SUPER_FLAG_ERROR) {
 		sb->s_flags |= MS_RDONLY;
 		printk(KERN_INFO "btrfs is forced readonly\n");
+		__btrfs_scrub_cancel(fs_info);
+//		WARN_ON(1);
 	}
 }
 
@@ -197,6 +199,34 @@ void btrfs_printk(struct btrfs_fs_info *fs_info, const char *fmt, ...)
 	printk("%sBTRFS %s (device %s): %pV", lvl, type, sb->s_id, &vaf);
 }
 
+/*
+ * We only mark the transaction aborted and then set the file system read-only.
+ * This will prevent new transactions from starting or trying to join this
+ * one.
+ *
+ * This means that error recovery at the call site is limited to freeing
+ * any local memory allocations and passing the error code up without
+ * further cleanup. The transaction should complete as it normally would
+ * in the call path but will return -EIO.
+ *
+ * We'll complete the cleanup in btrfs_end_transaction and
+ * btrfs_commit_transaction.
+ */
+void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
+			       struct btrfs_root *root, const char *function,
+			       unsigned int line, int errno)
+{
+	WARN_ON_ONCE(1);
+	trans->aborted = errno;
+	/* Nothing used. The other threads that have joined this
+	 * transaction may be able to continue. */
+	if (!trans->blocks_used) {
+		btrfs_printk(root->fs_info, "Aborting unused transaction.\n");
+		return;
+	}
+	trans->transaction->aborted = errno;
+	__btrfs_std_error(root->fs_info, function, line, errno, NULL);
+}
 /*
  * __btrfs_panic decodes unexpected, fatal errors from the caller,
  * issues an alert, and either panics or BUGs, depending on mount options.
@@ -295,6 +325,7 @@ static match_table_t tokens = {
 /*
  * Regular mount options parser.  Everything that is needed only when
  * reading in a new superblock is parsed here.
+ * XXX JDM: This needs to be cleaned up for remount.
  */
 int btrfs_parse_options(struct btrfs_root *root, char *options)
 {
@@ -1096,11 +1127,20 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 {
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	struct btrfs_root *root = fs_info->tree_root;
+	unsigned old_flags = sb->s_flags;
+	unsigned long old_opts = fs_info->mount_opt;
+	unsigned long old_compress_type = fs_info->compress_type;
+	u64 old_max_inline = fs_info->max_inline;
+	u64 old_alloc_start = fs_info->alloc_start;
+	int old_thread_pool_size = fs_info->thread_pool_size;
+	unsigned int old_metadata_ratio = fs_info->metadata_ratio;
 	int ret;
 
 	ret = btrfs_parse_options(root, data);
-	if (ret)
-		return -EINVAL;
+	if (ret) {
+		ret = -EINVAL;
+		goto restore;
+	}
 
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
 		return 0;
@@ -1108,26 +1148,44 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	if (*flags & MS_RDONLY) {
 		sb->s_flags |= MS_RDONLY;
 
-		ret =  btrfs_commit_super(root);
-		WARN_ON(ret);
+		ret = btrfs_commit_super(root);
+		if (ret)
+			goto restore;
 	} else {
 		if (fs_info->fs_devices->rw_devices == 0)
-			return -EACCES;
+			ret = -EACCES;
+			goto restore;
 
 		if (btrfs_super_log_root(fs_info->super_copy) != 0)
-			return -EINVAL;
+			ret = -EINVAL;
+			goto restore;
 
 		ret = btrfs_cleanup_fs_roots(fs_info);
-		WARN_ON(ret);
+		if (ret)
+			goto restore;
 
 		/* recover relocation */
 		ret = btrfs_recover_relocation(root);
-		WARN_ON(ret);
+		if (ret)
+			goto restore;
 
 		sb->s_flags &= ~MS_RDONLY;
 	}
 
 	return 0;
+
+restore:
+	/* We've hit an error - don't reset MS_RDONLY */
+	if (sb->s_flags & MS_RDONLY)
+		old_flags |= MS_RDONLY;
+	sb->s_flags = old_flags;
+	fs_info->mount_opt = old_opts;
+	fs_info->compress_type = old_compress_type;
+	fs_info->max_inline = old_max_inline;
+	fs_info->alloc_start = old_alloc_start;
+	fs_info->thread_pool_size = old_thread_pool_size;
+	fs_info->metadata_ratio = old_metadata_ratio;
+	return ret;
 }
 
 /* Used to sort the devices by max_avail(descending sort) */

commit 4da35113426d16673aa1fb0613c14ca2e419e7fd
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Mar 1 14:57:30 2012 +0100

    btrfs: add varargs to btrfs_error
    
     btrfs currently handles most errors with BUG_ON. This patch is a work-in-
     progress but aims to handle most errors other than internal logic
     errors and ENOMEM more gracefully.
    
     This iteration prevents most crashes but can run into lockups with
     the page lock on occasion when the timing "works out."
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ae7963b2d527..7fe69eef7607 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -127,25 +127,74 @@ static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
  * invokes the approciate error response.
  */
 void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
-		     unsigned int line, int errno)
+		       unsigned int line, int errno, const char *fmt, ...)
 {
 	struct super_block *sb = fs_info->sb;
 	char nbuf[16];
 	const char *errstr;
+	va_list args;
+	va_start(args, fmt);
 
 	/*
 	 * Special case: if the error is EROFS, and we're already
 	 * under MS_RDONLY, then it is safe here.
 	 */
 	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
-		return;
+  		return;
 
-	errstr = btrfs_decode_error(fs_info, errno, nbuf);
-	printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: %s\n",
-		sb->s_id, function, line, errstr);
-	save_error_info(fs_info);
+  	errstr = btrfs_decode_error(fs_info, errno, nbuf);
+	if (fmt) {
+		struct va_format vaf = {
+			.fmt = fmt,
+			.va = &args,
+		};
+
+		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: %s (%pV)\n",
+			sb->s_id, function, line, errstr, &vaf);
+	} else {
+		printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: %s\n",
+			sb->s_id, function, line, errstr);
+	}
+
+	/* Don't go through full error handling during mount */
+	if (sb->s_flags & MS_BORN) {
+		save_error_info(fs_info);
+		btrfs_handle_error(fs_info);
+	}
+	va_end(args);
+}
 
-	btrfs_handle_error(fs_info);
+const char *logtypes[] = {
+	"emergency",
+	"alert",
+	"critical",
+	"error",
+	"warning",
+	"notice",
+	"info",
+	"debug",
+};
+
+void btrfs_printk(struct btrfs_fs_info *fs_info, const char *fmt, ...)
+{
+	struct super_block *sb = fs_info->sb;
+	char lvl[4];
+	struct va_format vaf;
+	va_list args;
+	const char *type = logtypes[4];
+
+	va_start(args, fmt);
+
+	if (fmt[0] == '<' && isdigit(fmt[1]) && fmt[2] == '>') {
+		strncpy(lvl, fmt, 3);
+		fmt += 3;
+		type = logtypes[fmt[1] - '0'];
+	} else
+		*lvl = '\0';
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+	printk("%sBTRFS %s (device %s): %pV", lvl, type, sb->s_id, &vaf);
 }
 
 /*

commit 143bede527b054a271053f41bfaca2b57baa9408
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Thu Mar 1 14:56:26 2012 +0100

    btrfs: return void in functions without error conditions
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9774e38a0532..ae7963b2d527 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1408,9 +1408,7 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		return err;
 
-	err = btrfs_init_compress();
-	if (err)
-		goto free_sysfs;
+	btrfs_init_compress();
 
 	err = btrfs_init_cachep();
 	if (err)
@@ -1451,7 +1449,6 @@ static int __init init_btrfs_fs(void)
 	btrfs_destroy_cachep();
 free_compress:
 	btrfs_exit_compress();
-free_sysfs:
 	btrfs_exit_sysfs();
 	return err;
 }

commit 8c3429300181be44b30f9f017d53dc717da56caa
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Oct 3 23:22:31 2011 -0400

    btrfs: Add btrfs_panic()
    
    As part of the effort to eliminate BUG_ON as an error handling
    technique, we need to determine which errors are actual logic errors,
    which are on-disk corruption, and which are normal runtime errors
    e.g. -ENOMEM.
    
    Annotating these error cases is helpful to understand and report them.
    
    This patch adds a btrfs_panic() routine that will either panic
    or BUG depending on the new -ofatal_errors={panic,bug} mount option.
    Since there are still so many BUG_ONs, it defaults to BUG for now but I
    expect that to change once the error handling effort has made
    significant progress.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3ce97b217cbe..9774e38a0532 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -76,6 +76,9 @@ static const char *btrfs_decode_error(struct btrfs_fs_info *fs_info, int errno,
 	case -EROFS:
 		errstr = "Readonly filesystem";
 		break;
+	case -EEXIST:
+		errstr = "Object already exists";
+		break;
 	default:
 		if (nbuf) {
 			if (snprintf(nbuf, 16, "error %d", -errno) >= 0)
@@ -145,6 +148,36 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 	btrfs_handle_error(fs_info);
 }
 
+/*
+ * __btrfs_panic decodes unexpected, fatal errors from the caller,
+ * issues an alert, and either panics or BUGs, depending on mount options.
+ */
+void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
+		   unsigned int line, int errno, const char *fmt, ...)
+{
+	char nbuf[16];
+	char *s_id = "<unknown>";
+	const char *errstr;
+	struct va_format vaf = { .fmt = fmt };
+	va_list args;
+
+	if (fs_info)
+		s_id = fs_info->sb->s_id;
+
+	va_start(args, fmt);
+	vaf.va = &args;
+
+	errstr = btrfs_decode_error(fs_info, errno, nbuf);
+	if (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR)
+		panic(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (%s)\n",
+			s_id, function, line, &vaf, errstr);
+
+	printk(KERN_CRIT "BTRFS panic (device %s) in %s:%d: %pV (%s)\n",
+	       s_id, function, line, &vaf, errstr);
+	va_end(args);
+	/* Caller calls BUG() */
+}
+
 static void btrfs_put_super(struct super_block *sb)
 {
 	(void)close_ctree(btrfs_sb(sb)->tree_root);
@@ -166,7 +199,7 @@ enum {
 	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag, Opt_inode_cache,
 	Opt_no_space_cache, Opt_recovery, Opt_skip_balance,
 	Opt_check_integrity, Opt_check_integrity_including_extent_data,
-	Opt_check_integrity_print_mask,
+	Opt_check_integrity_print_mask, Opt_fatal_errors,
 	Opt_err,
 };
 
@@ -206,6 +239,7 @@ static match_table_t tokens = {
 	{Opt_check_integrity, "check_int"},
 	{Opt_check_integrity_including_extent_data, "check_int_data"},
 	{Opt_check_integrity_print_mask, "check_int_print_mask=%d"},
+	{Opt_fatal_errors, "fatal_errors=%s"},
 	{Opt_err, NULL},
 };
 
@@ -438,6 +472,18 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			ret = -EINVAL;
 			goto out;
 #endif
+		case Opt_fatal_errors:
+			if (strcmp(args[0].from, "panic") == 0)
+				btrfs_set_opt(info->mount_opt,
+					      PANIC_ON_FATAL_ERROR);
+			else if (strcmp(args[0].from, "bug") == 0)
+				btrfs_clear_opt(info->mount_opt,
+					      PANIC_ON_FATAL_ERROR);
+			else {
+				ret = -EINVAL;
+				goto out;
+			}
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);
@@ -766,6 +812,8 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 		seq_puts(seq, ",inode_cache");
 	if (btrfs_test_opt(root, SKIP_BALANCE))
 		seq_puts(seq, ",skip_balance");
+	if (btrfs_test_opt(root, PANIC_ON_FATAL_ERROR))
+		seq_puts(seq, ",fatal_errors=panic");
 	return 0;
 }
 

commit 48fde701aff662559b38d9a609574068f22d00fe
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jan 8 22:15:13 2012 -0500

    switch open-coded instances of d_make_root() to new helper
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3ce97b217cbe..81df3fec6a6d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -629,7 +629,6 @@ static int btrfs_fill_super(struct super_block *sb,
 			    void *data, int silent)
 {
 	struct inode *inode;
-	struct dentry *root_dentry;
 	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	struct btrfs_key key;
 	int err;
@@ -660,15 +659,12 @@ static int btrfs_fill_super(struct super_block *sb,
 		goto fail_close;
 	}
 
-	root_dentry = d_alloc_root(inode);
-	if (!root_dentry) {
-		iput(inode);
+	sb->s_root = d_make_root(inode);
+	if (!sb->s_root) {
 		err = -ENOMEM;
 		goto fail_close;
 	}
 
-	sb->s_root = root_dentry;
-
 	save_mount_options(sb, data);
 	cleancache_init_fs(sb);
 	sb->s_flags |= MS_ACTIVE;

commit d65773b22b749252b2805dcf96bdeb951a9481d8
Merge: f9156c7288e2 f84a8bd60e3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 17 15:52:51 2012 -0800

    Merge branch 'btrfs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    * 'btrfs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      btrfs: take allocation of ->tree_root into open_ctree()
      btrfs: let ->s_fs_info point to fs_info, not root...
      btrfs: consolidate failure exits in btrfs_mount() a bit
      btrfs: make free_fs_info() call ->kill_sb() unconditional
      btrfs: merge free_fs_info() calls on fill_super failures
      btrfs: kill pointless reassignment of ->s_fs_info in btrfs_fill_super()
      btrfs: make open_ctree() return int
      btrfs: sanitizing ->fs_info, part 5
      btrfs: sanitizing ->fs_info, part 4
      btrfs: sanitizing ->fs_info, part 3
      btrfs: sanitizing ->fs_info, part 2
      btrfs: sanitizing ->fs_info, part 1
      btrfs: fix a deadlock in btrfs_scan_one_device()
      btrfs: fix mount/umount race
      btrfs: get ->kill_sb() of its own
      btrfs: preparation to fixing mount/umount race

commit f9156c7288e2d11501ded4d7fe6d9a3a41ee4057
Merge: 67175b855bfd 96bdc7dc61fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 17 15:49:54 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs: (62 commits)
      Btrfs: use larger system chunks
      Btrfs: add a delalloc mutex to inodes for delalloc reservations
      Btrfs: space leak tracepoints
      Btrfs: protect orphan block rsv with spin_lock
      Btrfs: add allocator tracepoints
      Btrfs: don't call btrfs_throttle in file write
      Btrfs: release space on error in page_mkwrite
      Btrfs: fix btrfsck error 400 when truncating a compressed
      Btrfs: do not use btrfs_end_transaction_throttle everywhere
      Btrfs: add balance progress reporting
      Btrfs: allow for resuming restriper after it was paused
      Btrfs: allow for canceling restriper
      Btrfs: allow for pausing restriper
      Btrfs: add skip_balance mount option
      Btrfs: recover balance on mount
      Btrfs: save balance parameters to disk
      Btrfs: soft profile changing mode (aka soft convert)
      Btrfs: implement online profile changing
      Btrfs: do not reduce profile in do_chunk_alloc()
      Btrfs: virtual address space subset filter
      ...
    
    Fix up trivial conflict in fs/btrfs/ioctl.c due to the use of the new
    mnt_drop_write_file() helper.

commit c126dea771be1b3c370c0ffc4a09e6a82d492a49
Merge: 9785dbdf265d 21adbd5cbb53
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 16 15:27:58 2012 -0500

    Merge branch 'integrity-check-patch-v2' of git://btrfs.giantdisaster.de/git/btrfs into integration
    
    Conflicts:
            fs/btrfs/ctree.h
            fs/btrfs/super.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 27263e28321db438bc43dc0c0be432ce91526224
Merge: 64e05503ab5c 19a39dce3b9b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 16 15:26:02 2012 -0500

    Merge branch 'restriper' of git://github.com/idryomov/btrfs-unstable into integration

commit 9555c6c180600b40f6e86bd4dc53bf47e06ed663
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Jan 16 22:04:48 2012 +0200

    Btrfs: add skip_balance mount option
    
    Since restriper kthread starts involuntarily on mount and can suck cpu
    and memory bandwidth add a mount option to forcefully skip it.  The
    restriper in that case hangs around in paused state and can be resumed
    from userspace when it's convenient.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 34a8b6112ea4..063b521e3ded 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -164,8 +164,9 @@ enum {
 	Opt_compress_type, Opt_compress_force, Opt_compress_force_type,
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
 	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
-	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag,
-	Opt_inode_cache, Opt_no_space_cache, Opt_recovery, Opt_err,
+	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag, Opt_inode_cache,
+	Opt_no_space_cache, Opt_recovery, Opt_skip_balance,
+	Opt_err,
 };
 
 static match_table_t tokens = {
@@ -200,6 +201,7 @@ static match_table_t tokens = {
 	{Opt_inode_cache, "inode_cache"},
 	{Opt_no_space_cache, "nospace_cache"},
 	{Opt_recovery, "recovery"},
+	{Opt_skip_balance, "skip_balance"},
 	{Opt_err, NULL},
 };
 
@@ -398,6 +400,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: enabling auto recovery");
 			btrfs_set_opt(info->mount_opt, RECOVERY);
 			break;
+		case Opt_skip_balance:
+			btrfs_set_opt(info->mount_opt, SKIP_BALANCE);
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);
@@ -723,6 +728,8 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_puts(seq, ",autodefrag");
 	if (btrfs_test_opt(root, INODE_MAP_CACHE))
 		seq_puts(seq, ",inode_cache");
+	if (btrfs_test_opt(root, SKIP_BALANCE))
+		seq_puts(seq, ",skip_balance");
 	return 0;
 }
 

commit f84a8bd60e3ee49eacc9ba824babf149ba3dad7e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 15:57:57 2011 -0500

    btrfs: take allocation of ->tree_root into open_ctree()
    
    now that we don't need it for sget() anymore...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 305adf6dc09a..044652ee7ef5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -899,11 +899,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (!fs_info)
 		return ERR_PTR(-ENOMEM);
 
-	fs_info->tree_root = btrfs_alloc_root(fs_info);
-	if (!fs_info->tree_root) {
-		error = -ENOMEM;
-		goto error_fs_info;
-	}
 	fs_info->fs_devices = fs_devices;
 
 	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);

commit 815745cf3e46681241ad8025602ffbf2a452d514
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 15:40:49 2011 -0500

    btrfs: let ->s_fs_info point to fs_info, not root...
    
    the latter can be obtained from the former (by looking as ->tree_root)
    just as cheaply as we currently are doing the other way round.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 15c8ae571e40..305adf6dc09a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -147,7 +147,7 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 
 static void btrfs_put_super(struct super_block *sb)
 {
-	(void)close_ctree(btrfs_sb(sb));
+	(void)close_ctree(btrfs_sb(sb)->tree_root);
 	/* FIXME: need to fix VFS to return error? */
 	/* AV: return it _where_?  ->put_super() can be triggered by any number
 	 * of async events, up to and including delivery of SIGKILL to the
@@ -500,7 +500,8 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 static struct dentry *get_default_root(struct super_block *sb,
 				       u64 subvol_objectid)
 {
-	struct btrfs_root *root = sb->s_fs_info;
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
+	struct btrfs_root *root = fs_info->tree_root;
 	struct btrfs_root *new_root;
 	struct btrfs_dir_item *di;
 	struct btrfs_path *path;
@@ -530,7 +531,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 	 * will mount by default if we haven't been given a specific subvolume
 	 * to mount.
 	 */
-	dir_id = btrfs_super_root_dir(root->fs_info->super_copy);
+	dir_id = btrfs_super_root_dir(fs_info->super_copy);
 	di = btrfs_lookup_dir_item(NULL, root, path, dir_id, "default", 7, 0);
 	if (IS_ERR(di)) {
 		btrfs_free_path(path);
@@ -544,7 +545,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 		 */
 		btrfs_free_path(path);
 		dir_id = BTRFS_FIRST_FREE_OBJECTID;
-		new_root = root->fs_info->fs_root;
+		new_root = fs_info->fs_root;
 		goto setup_root;
 	}
 
@@ -552,7 +553,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 	btrfs_free_path(path);
 
 find_root:
-	new_root = btrfs_read_fs_root_no_name(root->fs_info, &location);
+	new_root = btrfs_read_fs_root_no_name(fs_info, &location);
 	if (IS_ERR(new_root))
 		return ERR_CAST(new_root);
 
@@ -588,8 +589,7 @@ static int btrfs_fill_super(struct super_block *sb,
 {
 	struct inode *inode;
 	struct dentry *root_dentry;
-	struct btrfs_root *tree_root = sb->s_fs_info;
-	struct btrfs_fs_info *fs_info = tree_root->fs_info;
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	struct btrfs_key key;
 	int err;
 
@@ -634,20 +634,21 @@ static int btrfs_fill_super(struct super_block *sb,
 	return 0;
 
 fail_close:
-	close_ctree(tree_root);
+	close_ctree(fs_info->tree_root);
 	return err;
 }
 
 int btrfs_sync_fs(struct super_block *sb, int wait)
 {
 	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = btrfs_sb(sb);
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
+	struct btrfs_root *root = fs_info->tree_root;
 	int ret;
 
 	trace_btrfs_sync_fs(wait);
 
 	if (!wait) {
-		filemap_flush(root->fs_info->btree_inode->i_mapping);
+		filemap_flush(fs_info->btree_inode->i_mapping);
 		return 0;
 	}
 
@@ -663,8 +664,8 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 
 static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 {
-	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
-	struct btrfs_fs_info *info = root->fs_info;
+	struct btrfs_fs_info *info = btrfs_sb(dentry->d_sb);
+	struct btrfs_root *root = info->tree_root;
 	char *compress_type;
 
 	if (btrfs_test_opt(root, DEGRADED))
@@ -727,10 +728,10 @@ static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 
 static int btrfs_test_super(struct super_block *s, void *data)
 {
-	struct btrfs_root *test_root = data;
-	struct btrfs_root *root = btrfs_sb(s);
+	struct btrfs_fs_info *p = data;
+	struct btrfs_fs_info *fs_info = btrfs_sb(s);
 
-	return root->fs_info->fs_devices == test_root->fs_info->fs_devices;
+	return fs_info->fs_devices == p->fs_devices;
 }
 
 static int btrfs_set_super(struct super_block *s, void *data)
@@ -922,8 +923,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	}
 
 	bdev = fs_devices->latest_bdev;
-	s = sget(fs_type, btrfs_test_super, btrfs_set_super,
-		 fs_info->tree_root);
+	s = sget(fs_type, btrfs_test_super, btrfs_set_super, fs_info);
 	if (IS_ERR(s)) {
 		error = PTR_ERR(s);
 		goto error_close_devices;
@@ -939,7 +939,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 		s->s_flags = flags | MS_NOSEC;
 		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
-		btrfs_sb(s)->fs_info->bdev_holder = fs_type;
+		btrfs_sb(s)->bdev_holder = fs_type;
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);
 	}
@@ -959,7 +959,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 {
-	struct btrfs_root *root = btrfs_sb(sb);
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
+	struct btrfs_root *root = fs_info->tree_root;
 	int ret;
 
 	ret = btrfs_parse_options(root, data);
@@ -975,13 +976,13 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		ret =  btrfs_commit_super(root);
 		WARN_ON(ret);
 	} else {
-		if (root->fs_info->fs_devices->rw_devices == 0)
+		if (fs_info->fs_devices->rw_devices == 0)
 			return -EACCES;
 
-		if (btrfs_super_log_root(root->fs_info->super_copy) != 0)
+		if (btrfs_super_log_root(fs_info->super_copy) != 0)
 			return -EINVAL;
 
-		ret = btrfs_cleanup_fs_roots(root->fs_info);
+		ret = btrfs_cleanup_fs_roots(fs_info);
 		WARN_ON(ret);
 
 		/* recover relocation */
@@ -1150,18 +1151,18 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
-	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
-	struct btrfs_super_block *disk_super = root->fs_info->super_copy;
-	struct list_head *head = &root->fs_info->space_info;
+	struct btrfs_fs_info *fs_info = btrfs_sb(dentry->d_sb);
+	struct btrfs_super_block *disk_super = fs_info->super_copy;
+	struct list_head *head = &fs_info->space_info;
 	struct btrfs_space_info *found;
 	u64 total_used = 0;
 	u64 total_free_data = 0;
 	int bits = dentry->d_sb->s_blocksize_bits;
-	__be32 *fsid = (__be32 *)root->fs_info->fsid;
+	__be32 *fsid = (__be32 *)fs_info->fsid;
 	int ret;
 
 	/* holding chunk_muext to avoid allocating new chunks */
-	mutex_lock(&root->fs_info->chunk_mutex);
+	mutex_lock(&fs_info->chunk_mutex);
 	rcu_read_lock();
 	list_for_each_entry_rcu(found, head, list) {
 		if (found->flags & BTRFS_BLOCK_GROUP_DATA) {
@@ -1180,14 +1181,14 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_type = BTRFS_SUPER_MAGIC;
 	buf->f_bavail = total_free_data;
-	ret = btrfs_calc_avail_data_space(root, &total_free_data);
+	ret = btrfs_calc_avail_data_space(fs_info->tree_root, &total_free_data);
 	if (ret) {
-		mutex_unlock(&root->fs_info->chunk_mutex);
+		mutex_unlock(&fs_info->chunk_mutex);
 		return ret;
 	}
 	buf->f_bavail += total_free_data;
 	buf->f_bavail = buf->f_bavail >> bits;
-	mutex_unlock(&root->fs_info->chunk_mutex);
+	mutex_unlock(&fs_info->chunk_mutex);
 
 	/* We treat it as constant endianness (it doesn't matter _which_)
 	   because we want the fsid to come out the same whether mounted
@@ -1203,7 +1204,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 static void btrfs_kill_super(struct super_block *sb)
 {
-	struct btrfs_fs_info *fs_info = btrfs_sb(sb)->fs_info;
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
 	kill_anon_super(sb);
 	free_fs_info(fs_info);
 }
@@ -1246,17 +1247,17 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 
 static int btrfs_freeze(struct super_block *sb)
 {
-	struct btrfs_root *root = btrfs_sb(sb);
-	mutex_lock(&root->fs_info->transaction_kthread_mutex);
-	mutex_lock(&root->fs_info->cleaner_mutex);
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
+	mutex_lock(&fs_info->transaction_kthread_mutex);
+	mutex_lock(&fs_info->cleaner_mutex);
 	return 0;
 }
 
 static int btrfs_unfreeze(struct super_block *sb)
 {
-	struct btrfs_root *root = btrfs_sb(sb);
-	mutex_unlock(&root->fs_info->cleaner_mutex);
-	mutex_unlock(&root->fs_info->transaction_kthread_mutex);
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb);
+	mutex_unlock(&fs_info->cleaner_mutex);
+	mutex_unlock(&fs_info->transaction_kthread_mutex);
 	return 0;
 }
 

commit 59553edf110e5576d91be9dd5bd53d110e0d0290
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 01:56:28 2011 -0500

    btrfs: consolidate failure exits in btrfs_mount() a bit
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f628a6a79ca6..15c8ae571e40 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -630,6 +630,7 @@ static int btrfs_fill_super(struct super_block *sb,
 
 	save_mount_options(sb, data);
 	cleancache_init_fs(sb);
+	sb->s_flags |= MS_ACTIVE;
 	return 0;
 
 fail_close:
@@ -929,14 +930,10 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	}
 
 	if (s->s_root) {
-		if ((flags ^ s->s_flags) & MS_RDONLY) {
-			deactivate_locked_super(s);
-			error = -EBUSY;
-			goto error_close_devices;
-		}
-
 		btrfs_close_devices(fs_devices);
 		free_fs_info(fs_info);
+		if ((flags ^ s->s_flags) & MS_RDONLY)
+			error = -EBUSY;
 	} else {
 		char b[BDEVNAME_SIZE];
 
@@ -945,19 +942,11 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		btrfs_sb(s)->fs_info->bdev_holder = fs_type;
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);
-		if (error) {
-			deactivate_locked_super(s);
-			return ERR_PTR(error);
-		}
-
-		s->s_flags |= MS_ACTIVE;
 	}
 
-	root = get_default_root(s, subvol_objectid);
-	if (IS_ERR(root)) {
+	root = !error ? get_default_root(s, subvol_objectid) : ERR_PTR(error);
+	if (IS_ERR(root))
 		deactivate_locked_super(s);
-		return root;
-	}
 
 	return root;
 

commit d22ca7de770e2a683eac000ba4db5a95e2f4c969
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 01:46:50 2011 -0500

    btrfs: make free_fs_info() call ->kill_sb() unconditional
    
    ... and don't bother with it after btrfs_fill_super() failure -
    ->kill_sb() (unlike ->put_super()) will be called even if we
    have not got non-NULL ->s_root.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8901b6c85260..f628a6a79ca6 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -946,7 +946,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);
 		if (error) {
-			free_fs_info(fs_info);
 			deactivate_locked_super(s);
 			return ERR_PTR(error);
 		}
@@ -1215,12 +1214,9 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 static void btrfs_kill_super(struct super_block *sb)
 {
-	struct btrfs_fs_info *fs_info = NULL;
-	if (sb->s_root)
-		fs_info = btrfs_sb(sb)->fs_info;
+	struct btrfs_fs_info *fs_info = btrfs_sb(sb)->fs_info;
 	kill_anon_super(sb);
-	if (fs_info)
-		free_fs_info(fs_info);
+	free_fs_info(fs_info);
 }
 
 static struct file_system_type btrfs_fs_type = {

commit be7e0950def403e90b5295ff2192c39967bf2aec
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 01:40:05 2011 -0500

    btrfs: merge free_fs_info() calls on fill_super failures
    
    ... all the way up into btrfs_mount().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a381f9f9b0c2..8901b6c85260 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -634,7 +634,6 @@ static int btrfs_fill_super(struct super_block *sb,
 
 fail_close:
 	close_ctree(tree_root);
-	free_fs_info(fs_info);
 	return err;
 }
 
@@ -947,6 +946,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);
 		if (error) {
+			free_fs_info(fs_info);
 			deactivate_locked_super(s);
 			return ERR_PTR(error);
 		}

commit 29db78aa0ac82319b764b87a1c5030d74523e296
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 01:12:38 2011 -0500

    btrfs: kill pointless reassignment of ->s_fs_info in btrfs_fill_super()
    
    We do not (fortunately) modify ->s_fs_info of superblock on the fly in
    btrfs_fill_super(); apparent assignment is a no-op.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 56e007fd6702..a381f9f9b0c2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -588,8 +588,8 @@ static int btrfs_fill_super(struct super_block *sb,
 {
 	struct inode *inode;
 	struct dentry *root_dentry;
-	struct btrfs_root *tree_root;
-	struct btrfs_fs_info *fs_info;
+	struct btrfs_root *tree_root = sb->s_fs_info;
+	struct btrfs_fs_info *fs_info = tree_root->fs_info;
 	struct btrfs_key key;
 	int err;
 
@@ -609,9 +609,6 @@ static int btrfs_fill_super(struct super_block *sb,
 		printk("btrfs: open_ctree failed\n");
 		return err;
 	}
-	tree_root = sb->s_fs_info;
-	fs_info = tree_root->fs_info;
-	sb->s_fs_info = tree_root;
 
 	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
 	key.type = BTRFS_INODE_ITEM_KEY;

commit ad2b2c802be2d3e8ed8364fef5ffaddabe448219
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 01:10:02 2011 -0500

    btrfs: make open_ctree() return int
    
    It returns either ERR_PTR(-ve) or sb->s_fs_info.  The latter can
    be found by caller just as well, TYVM, no need to return it.  Just
    return -ve or 0...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e9f876a1655b..56e007fd6702 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -604,12 +604,12 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_flags |= MS_POSIXACL;
 #endif
 
-	tree_root = open_ctree(sb, fs_devices, (char *)data);
-
-	if (IS_ERR(tree_root)) {
+	err = open_ctree(sb, fs_devices, (char *)data);
+	if (err) {
 		printk("btrfs: open_ctree failed\n");
-		return PTR_ERR(tree_root);
+		return err;
 	}
+	tree_root = sb->s_fs_info;
 	fs_info = tree_root->fs_info;
 	sb->s_fs_info = tree_root;
 

commit 6f07e42ee6fcc252a210781d7262f4051e9fd8f6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 00:46:16 2011 -0500

    btrfs: sanitizing ->fs_info, part 4
    
    A new helper: btrfs_alloc_root(fs_info); allocates btrfs_root
    and sets ->fs_info.  All places allocating the suckers converted
    to it.  At that point we *never* reassign ->fs_info of btrfs_root;
    it's set before anyone sees the address of newly allocated
    struct btrfs_root and never assigned anywhere else.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b9fd62a0fca2..e9f876a1655b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -901,12 +901,11 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (!fs_info)
 		return ERR_PTR(-ENOMEM);
 
-	fs_info->tree_root = kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
+	fs_info->tree_root = btrfs_alloc_root(fs_info);
 	if (!fs_info->tree_root) {
 		error = -ENOMEM;
 		goto error_fs_info;
 	}
-	fs_info->tree_root->fs_info = fs_info;
 	fs_info->fs_devices = fs_devices;
 
 	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);

commit 6de1d09d9677dce7a04ef485d426821159ab7de9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 01:29:09 2011 -0500

    btrfs: fix mount/umount race
    
    Do *NOT* skip doomed superblocks in btrfs_test_super(); we want
    sget() to wait for their shutdown to complete.  Since we don't
    mutilate ->s_fs_info in ->put_super() anymore (or free what it
    used to point to until the superblock is past being findable
    by sget()), we can just DTRT there and report a match.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index eca48624a4f0..b9fd62a0fca2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -733,20 +733,15 @@ static int btrfs_test_super(struct super_block *s, void *data)
 	struct btrfs_root *test_root = data;
 	struct btrfs_root *root = btrfs_sb(s);
 
-	/*
-	 * If this super block is going away, return false as it
-	 * can't match as an existing super block.
-	 */
-	if (!atomic_read(&s->s_active))
-		return 0;
 	return root->fs_info->fs_devices == test_root->fs_info->fs_devices;
 }
 
 static int btrfs_set_super(struct super_block *s, void *data)
 {
-	s->s_fs_info = data;
-
-	return set_anon_super(s, data);
+	int err = set_anon_super(s, data);
+	if (!err)
+		s->s_fs_info = data;
+	return err;
 }
 
 /*

commit aea52e19dd2085617dd7d247afb76a90cf2ea40c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 01:22:46 2011 -0500

    btrfs: get ->kill_sb() of its own
    
    ... and move free_fs_info() to that, out of ->put_super().  Do NOT
    set ->s_fs_info to NULL in the latter; we need it for sget() to
    be able to see and wait for fs in the middle of umount if we get a
    mount/umount race.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a3f435e58987..eca48624a4f0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -147,14 +147,13 @@ void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 
 static void btrfs_put_super(struct super_block *sb)
 {
-	struct btrfs_root *root = btrfs_sb(sb);
-	int ret;
-
-	ret = close_ctree(root);
-	free_fs_info(root->fs_info);
-	sb->s_fs_info = NULL;
-
-	(void)ret; /* FIXME: need to fix VFS to return error? */
+	(void)close_ctree(btrfs_sb(sb));
+	/* FIXME: need to fix VFS to return error? */
+	/* AV: return it _where_?  ->put_super() can be triggered by any number
+	 * of async events, up to and including delivery of SIGKILL to the
+	 * last process that kept it busy.  Or segfault in the aforementioned
+	 * process...  Whom would you report that to?
+	 */
 }
 
 enum {
@@ -1223,11 +1222,21 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
+static void btrfs_kill_super(struct super_block *sb)
+{
+	struct btrfs_fs_info *fs_info = NULL;
+	if (sb->s_root)
+		fs_info = btrfs_sb(sb)->fs_info;
+	kill_anon_super(sb);
+	if (fs_info)
+		free_fs_info(fs_info);
+}
+
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
 	.mount		= btrfs_mount,
-	.kill_sb	= kill_anon_super,
+	.kill_sb	= btrfs_kill_super,
 	.fs_flags	= FS_REQUIRES_DEV,
 };
 

commit 98c7089c769048f941bd5c5285287f8fc301f8b1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 17 01:00:31 2011 -0500

    btrfs: preparation to fixing mount/umount race
    
    We need fs_info and root to live until the moment when the victim
    superblock leaves the list, so we need to postpone free_fs_info()
    until after ->put_super().  The call is buried in close_ctree(),
    though, so we need to lift it into the callers (including
    btrfs_put_super()) first.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ae488aa1966a..a3f435e58987 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -151,6 +151,7 @@ static void btrfs_put_super(struct super_block *sb)
 	int ret;
 
 	ret = close_ctree(root);
+	free_fs_info(root->fs_info);
 	sb->s_fs_info = NULL;
 
 	(void)ret; /* FIXME: need to fix VFS to return error? */
@@ -589,6 +590,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	struct inode *inode;
 	struct dentry *root_dentry;
 	struct btrfs_root *tree_root;
+	struct btrfs_fs_info *fs_info;
 	struct btrfs_key key;
 	int err;
 
@@ -609,12 +611,13 @@ static int btrfs_fill_super(struct super_block *sb,
 		printk("btrfs: open_ctree failed\n");
 		return PTR_ERR(tree_root);
 	}
+	fs_info = tree_root->fs_info;
 	sb->s_fs_info = tree_root;
 
 	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
 	key.type = BTRFS_INODE_ITEM_KEY;
 	key.offset = 0;
-	inode = btrfs_iget(sb, &key, tree_root->fs_info->fs_root, NULL);
+	inode = btrfs_iget(sb, &key, fs_info->fs_root, NULL);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
 		goto fail_close;
@@ -635,6 +638,7 @@ static int btrfs_fill_super(struct super_block *sb,
 
 fail_close:
 	close_ctree(tree_root);
+	free_fs_info(fs_info);
 	return err;
 }
 

commit 34c80b1d93e6e20ca9dea0baf583a5b5510d92d4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 21:32:45 2011 -0500

    vfs: switch ->show_options() to struct dentry *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index dc62d3cc68fd..ae488aa1966a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -661,9 +661,9 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	return ret;
 }
 
-static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
+static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)
 {
-	struct btrfs_root *root = btrfs_sb(vfs->mnt_sb);
+	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
 	struct btrfs_fs_info *info = root->fs_info;
 	char *compress_type;
 

commit e407699ef56ed948739dd57a5578ba8cb5bd81b2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 24 20:14:54 2011 -0500

    btrfs, nfs, apparmor: don't pull mnt_namespace.h for no reason...
    
    it's not needed anymore; we used to, back when we had to do
    mount_subtree() by hand, complete with put_mnt_ns() in it.
    No more...  Apparmor didn't need it since the __d_path() fix.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 200f63bc6675..dc62d3cc68fd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -40,7 +40,6 @@
 #include <linux/magic.h>
 #include <linux/slab.h>
 #include <linux/cleancache.h>
-#include <linux/mnt_namespace.h>
 #include <linux/ratelimit.h>
 #include "compat.h"
 #include "delayed-inode.h"

commit 21adbd5cbb5344a3fca6bb7ddb2ab6cb03c44546
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Wed Nov 9 13:44:05 2011 +0100

    Btrfs: integrate integrity check module into btrfs
    
    This is the last part of the patch series. It modifies the btrfs
    code to use the integrity check module if configured to do so
    with the define BTRFS_FS_CHECK_INTEGRITY. If this define is not set,
    the only effective change is that code is added that handles the
    mount option to activate the integrity check. If the mount option is
    set and the define BTRFS_FS_CHECK_INTEGRITY is not set, that code
    complains in the log and the mount fails with EINVAL.
    
    Add the mount option to activate the usage of the integrity check
    code.
    Add invocation of btrfs integrity check code init and cleanup
    function on mount and umount, respectively.
    Add hook to call btrfs integrity check code version of
    submit_bh/submit_bio.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 34a8b6112ea4..22a2015f1d7b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -165,7 +165,10 @@ enum {
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
 	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
 	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag,
-	Opt_inode_cache, Opt_no_space_cache, Opt_recovery, Opt_err,
+	Opt_inode_cache, Opt_no_space_cache, Opt_recovery,
+	Opt_check_integrity, Opt_check_integrity_including_extent_data,
+	Opt_check_integrity_print_mask,
+	Opt_err,
 };
 
 static match_table_t tokens = {
@@ -200,6 +203,9 @@ static match_table_t tokens = {
 	{Opt_inode_cache, "inode_cache"},
 	{Opt_no_space_cache, "nospace_cache"},
 	{Opt_recovery, "recovery"},
+	{Opt_check_integrity, "check_int"},
+	{Opt_check_integrity_including_extent_data, "check_int_data"},
+	{Opt_check_integrity_print_mask, "check_int_print_mask=%d"},
 	{Opt_err, NULL},
 };
 
@@ -398,6 +404,37 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: enabling auto recovery");
 			btrfs_set_opt(info->mount_opt, RECOVERY);
 			break;
+#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
+		case Opt_check_integrity_including_extent_data:
+			printk(KERN_INFO "btrfs: enabling check integrity"
+			       " including extent data\n");
+			btrfs_set_opt(info->mount_opt,
+				      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);
+			btrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);
+			break;
+		case Opt_check_integrity:
+			printk(KERN_INFO "btrfs: enabling check integrity\n");
+			btrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);
+			break;
+		case Opt_check_integrity_print_mask:
+			intarg = 0;
+			match_int(&args[0], &intarg);
+			if (intarg) {
+				info->check_integrity_print_mask = intarg;
+				printk(KERN_INFO "btrfs:"
+				       " check_integrity_print_mask 0x%x\n",
+				       info->check_integrity_print_mask);
+			}
+			break;
+#else
+		case Opt_check_integrity_including_extent_data:
+		case Opt_check_integrity:
+		case Opt_check_integrity_print_mask:
+			printk(KERN_ERR "btrfs: support for check_integrity*"
+			       " not compiled in!\n");
+			ret = -EINVAL;
+			goto out;
+#endif
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);

commit c9a7fe9672612c0b595633d2945f52257ad92b20
Merge: 2cfab8d74ebf d85c8a6f1bc0 142349f541d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 12:15:50 2011 -0800

    Merge branches 'for-linus' and 'for-linus-3.2' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs:
      Btrfs: unplug every once and a while
      Btrfs: deal with NULL srv_rsv in the delalloc inode reservation code
      Btrfs: only set cache_generation if we setup the block group
      Btrfs: don't panic if orphan item already exists
      Btrfs: fix leaked space in truncate
      Btrfs: fix how we do delalloc reservations and how we free reservations on error
      Btrfs: deal with enospc from dirtying inodes properly
      Btrfs: fix num_workers_starting bug and other bugs in async thread
      BTRFS: Establish i_ops before calling d_instantiate
      Btrfs: add a cond_resched() into the worker loop
      Btrfs: fix ctime update of on-disk inode
      btrfs: keep orphans for subvolume deletion
      Btrfs: fix inaccurate available space on raid0 profile
      Btrfs: fix wrong disk space information of the files
      Btrfs: fix wrong i_size when truncating a file to a larger size
      Btrfs: fix btrfs_end_bio to deal with write errors to a single mirror
    
    * 'for-linus-3.2' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs:
      btrfs: lower the dirty balance poll interval

commit 567a45e917343c952806bb9f5c19aab0139bd519
Merge: e755d9ab387c e65cbb94e036
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Dec 15 13:43:49 2011 -0500

    Merge branch 'for-chris' of http://git.kernel.org/pub/scm/linux/kernel/git/josef/btrfs-work into integration
    
    Conflicts:
            fs/btrfs/inode.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 22c44fe65adacd20a174f3f54686509ee94ef7be
Author: Josef Bacik <josef@redhat.com>
Date:   Wed Nov 30 10:45:38 2011 -0500

    Btrfs: deal with enospc from dirtying inodes properly
    
    Now that we're properly keeping track of delayed inode space we've been getting
    a lot of warnings out of btrfs_dirty_inode() when running xfstest 83.  This is
    because a bunch of people call mark_inode_dirty, which is void so we can't
    return ENOSPC.  This needs to be fixed in a few areas
    
    1) file_update_time - this updates the mtime and such when writing to a file,
    which will call mark_inode_dirty.  So copy file_update_time into btrfs so we can
    call btrfs_dirty_inode directly and return an error if we get one appropriately.
    
    2) fix symlinks to use btrfs_setattr for ->setattr.  For some reason we weren't
    setting ->setattr for symlinks, even though we should have been.  This catches
    one of the cases where we were getting errors in mark_inode_dirty.
    
    3) Fix btrfs_setattr and btrfs_setsize to call btrfs_dirty_inode directly
    instead of mark_inode_dirty.  This lets us return errors properly for truncate
    and chown/anything related to setattr.
    
    4) Add a new btrfs_fs_dirty_inode which will just call btrfs_dirty_inode and
    print an error if we have one.  The only remaining user we can't control for
    this is touch_atime(), but we don't really want to keep people from walking
    down the tree if we don't have space to save the atime update, so just complain
    but don't worry about it.
    
    With this patch xfstests 83 complains a handful of times instead of hundreds of
    times.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1a3ce9e0b495..05b40457e26c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -41,6 +41,7 @@
 #include <linux/slab.h>
 #include <linux/cleancache.h>
 #include <linux/mnt_namespace.h>
+#include <linux/ratelimit.h>
 #include "compat.h"
 #include "delayed-inode.h"
 #include "ctree.h"
@@ -1290,6 +1291,16 @@ static int btrfs_unfreeze(struct super_block *sb)
 	return 0;
 }
 
+static void btrfs_fs_dirty_inode(struct inode *inode, int flags)
+{
+	int ret;
+
+	ret = btrfs_dirty_inode(inode);
+	if (ret)
+		printk_ratelimited(KERN_ERR "btrfs: fail to dirty inode %Lu "
+				   "error %d\n", btrfs_ino(inode), ret);
+}
+
 static const struct super_operations btrfs_super_ops = {
 	.drop_inode	= btrfs_drop_inode,
 	.evict_inode	= btrfs_evict_inode,
@@ -1297,7 +1308,7 @@ static const struct super_operations btrfs_super_ops = {
 	.sync_fs	= btrfs_sync_fs,
 	.show_options	= btrfs_show_options,
 	.write_inode	= btrfs_write_inode,
-	.dirty_inode	= btrfs_dirty_inode,
+	.dirty_inode	= btrfs_fs_dirty_inode,
 	.alloc_inode	= btrfs_alloc_inode,
 	.destroy_inode	= btrfs_destroy_inode,
 	.statfs		= btrfs_statfs,

commit 39fb26c398ddf8d7794a85e896cfe1a42e55524b
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Dec 14 20:12:02 2011 -0500

    Btrfs: fix inaccurate available space on raid0 profile
    
    When we use raid0 as the data profile, df command may show us a very
    inaccurate value of the available space, which may be much less than the
    real one. It may make the users puzzled. Fix it by changing the calculation
    of the available space, and making it be more similar to a fake chunk
    allocation.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1a3ce9e0b495..41495dce4db0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1079,7 +1079,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	u64 avail_space;
 	u64 used_space;
 	u64 min_stripe_size;
-	int min_stripes = 1;
+	int min_stripes = 1, num_stripes = 1;
 	int i = 0, nr_devices;
 	int ret;
 
@@ -1093,12 +1093,16 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 
 	/* calc min stripe number for data space alloction */
 	type = btrfs_get_alloc_profile(root, 1);
-	if (type & BTRFS_BLOCK_GROUP_RAID0)
+	if (type & BTRFS_BLOCK_GROUP_RAID0) {
 		min_stripes = 2;
-	else if (type & BTRFS_BLOCK_GROUP_RAID1)
+		num_stripes = nr_devices;
+	} else if (type & BTRFS_BLOCK_GROUP_RAID1) {
 		min_stripes = 2;
-	else if (type & BTRFS_BLOCK_GROUP_RAID10)
+		num_stripes = 2;
+	} else if (type & BTRFS_BLOCK_GROUP_RAID10) {
 		min_stripes = 4;
+		num_stripes = 4;
+	}
 
 	if (type & BTRFS_BLOCK_GROUP_DUP)
 		min_stripe_size = 2 * BTRFS_STRIPE_LEN;
@@ -1167,13 +1171,16 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	i = nr_devices - 1;
 	avail_space = 0;
 	while (nr_devices >= min_stripes) {
+		if (num_stripes > nr_devices)
+			num_stripes = nr_devices;
+
 		if (devices_info[i].max_avail >= min_stripe_size) {
 			int j;
 			u64 alloc_size;
 
-			avail_space += devices_info[i].max_avail * min_stripes;
+			avail_space += devices_info[i].max_avail * num_stripes;
 			alloc_size = devices_info[i].max_avail;
-			for (j = i + 1 - min_stripes; j <= i; j++)
+			for (j = i + 1 - num_stripes; j <= i; j++)
 				devices_info[j].max_avail -= alloc_size;
 		}
 		i--;

commit b930c26416c4ea6855726fd977145ccea9afbdda
Merge: 11d814a20166 f4a8e6563ea5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 1 08:28:53 2011 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/linux-btrfs:
      Btrfs: fix meta data raid-repair merge problem
      Btrfs: skip allocation attempt from empty cluster
      Btrfs: skip block groups without enough space for a cluster
      Btrfs: start search for new cluster at the beginning
      Btrfs: reset cluster's max_size when creating bitmap
      Btrfs: initialize new bitmaps' list
      Btrfs: fix oops when calling statfs on readonly device
      Btrfs: Don't error on resizing FS to same size
      Btrfs: fix deadlock on metadata reservation when evicting a inode
      Fix URL of btrfs-progs git repository in docs
      btrfs scrub: handle -ENOMEM from init_ipath()

commit b772a86ea6d932ac29d5e50e67c977653c832f8a
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Mon Nov 28 16:43:00 2011 +0800

    Btrfs: fix oops when calling statfs on readonly device
    
    To reproduce this bug:
    
      # dd if=/dev/zero of=img bs=1M count=256
      # mkfs.btrfs img
      # losetup -r /dev/loop1 img
      # mount /dev/loop1 /mnt
      OOPS!!
    
    It triggered BUG_ON(!nr_devices) in btrfs_calc_avail_data_space().
    
    To fix this, instead of checking write-only devices, we check all open
    deivces:
    
      # df -h /dev/loop1
      Filesystem            Size  Used Avail Use% Mounted on
      /dev/loop1            250M   28K  238M   1% /mnt
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8bd9d6d0e07a..1a3ce9e0b495 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1083,7 +1083,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	int i = 0, nr_devices;
 	int ret;
 
-	nr_devices = fs_info->fs_devices->rw_devices;
+	nr_devices = fs_info->fs_devices->open_devices;
 	BUG_ON(!nr_devices);
 
 	devices_info = kmalloc(sizeof(*devices_info) * nr_devices,
@@ -1105,8 +1105,8 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 	else
 		min_stripe_size = BTRFS_STRIPE_LEN;
 
-	list_for_each_entry(device, &fs_devices->alloc_list, dev_alloc_list) {
-		if (!device->in_fs_metadata)
+	list_for_each_entry(device, &fs_devices->devices, dev_list) {
+		if (!device->in_fs_metadata || !device->bdev)
 			continue;
 
 		avail_space = device->total_bytes - device->bytes_used;

commit ea441d1104cf1efb471fa81bc91e9fd1e6ae29fd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 16 21:43:59 2011 -0500

    new helper: mount_subtree()
    
    takes vfsmount and relative path, does lookup within that vfsmount
    (possibly triggering automounts) and returns the result as root
    of subtree suitable for return by ->mount() (i.e. a reference to
    dentry and an active reference to its superblock grabbed, superblock
    locked exclusive).
    
    btrfs and nfs switched to it instead of open-coding the sucker.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cfbedd7755b0..17ee7fc5e64e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -825,13 +825,9 @@ static char *setup_root_args(char *args)
 static struct dentry *mount_subvol(const char *subvol_name, int flags,
 				   const char *device_name, char *data)
 {
-	struct super_block *s;
 	struct dentry *root;
 	struct vfsmount *mnt;
-	struct mnt_namespace *ns_private;
 	char *newargs;
-	struct path path;
-	int error;
 
 	newargs = setup_root_args(data);
 	if (!newargs)
@@ -842,36 +838,17 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 	if (IS_ERR(mnt))
 		return ERR_CAST(mnt);
 
-	ns_private = create_mnt_ns(mnt);
-	if (IS_ERR(ns_private))
-		return ERR_CAST(ns_private);
-
-	/*
-	 * This will trigger the automount of the subvol so we can just
-	 * drop the mnt we have here and return the dentry that we
-	 * found.
-	 */
-	error = vfs_path_lookup(mnt->mnt_root, mnt, subvol_name,
-				LOOKUP_FOLLOW, &path);
-	put_mnt_ns(ns_private);
-	if (error)
-		return ERR_PTR(error);
+	root = mount_subtree(mnt, subvol_name);
 
-	if (!is_subvolume_inode(path.dentry->d_inode)) {
-		path_put(&path);
-		error = -EINVAL;
+	if (!IS_ERR(root) && !is_subvolume_inode(root->d_inode)) {
+		struct super_block *s = root->d_sb;
+		dput(root);
+		root = ERR_PTR(-EINVAL);
+		deactivate_locked_super(s);
 		printk(KERN_ERR "btrfs: '%s' is not a valid subvolume\n",
 				subvol_name);
-		return ERR_PTR(-EINVAL);
 	}
 
-	/* Get a ref to the sb and the dentry we found and return it */
-	s = path.mnt->mnt_sb;
-	atomic_inc(&s->s_active);
-	root = dget(path.dentry);
-	path_put(&path);
-	down_write(&s->s_umount);
-
 	return root;
 }
 

commit c13344958780b4046305ee6235d686c846535529
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 16 16:12:14 2011 -0500

    switch create_mnt_ns() to saner calling conventions, fix double mntput() in nfs
    
    Life is much saner if create_mnt_ns(mnt) drops mnt in case of error...
    Switch it to such calling conventions, switch callers, fix double mntput() in
    fs/nfs/super.c one.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 969a7747e889..cfbedd7755b0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -843,10 +843,8 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 		return ERR_CAST(mnt);
 
 	ns_private = create_mnt_ns(mnt);
-	if (IS_ERR(ns_private)) {
-		mntput(mnt);
+	if (IS_ERR(ns_private))
 		return ERR_CAST(ns_private);
-	}
 
 	/*
 	 * This will trigger the automount of the subvol so we can just

commit 8d514bbf37eecf0a3e309284728637816a36764b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 16 16:06:09 2011 -0500

    btrfs: fix double mntput() in mount_subvol()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8bd9d6d0e07a..969a7747e889 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -861,7 +861,6 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 
 	if (!is_subvolume_inode(path.dentry->d_inode)) {
 		path_put(&path);
-		mntput(mnt);
 		error = -EINVAL;
 		printk(KERN_ERR "btrfs: '%s' is not a valid subvolume\n",
 				subvol_name);

commit 8965593e41dd2d0e2a2f1e6f245336005ea94a2c
Author: David Sterba <dsterba@suse.cz>
Date:   Fri Nov 11 10:14:57 2011 -0500

    btrfs: rename the option to nospace_cache
    
    Rename no_space_cache option to nospace_cache to be more consistent with
    the rest, where the simple prefix 'no' is used to negate an option.
    
    The option has been introduced during the -rc1 cycle and there are has not been
    widely used, so it's safe.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 629281c65ff5..8bd9d6d0e07a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -197,7 +197,7 @@ static match_table_t tokens = {
 	{Opt_subvolrootid, "subvolrootid=%d"},
 	{Opt_defrag, "autodefrag"},
 	{Opt_inode_cache, "inode_cache"},
-	{Opt_no_space_cache, "no_space_cache"},
+	{Opt_no_space_cache, "nospace_cache"},
 	{Opt_recovery, "recovery"},
 	{Opt_err, NULL},
 };
@@ -711,7 +711,7 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 	if (btrfs_test_opt(root, SPACE_CACHE))
 		seq_puts(seq, ",space_cache");
 	else
-		seq_puts(seq, ",no_space_cache");
+		seq_puts(seq, ",nospace_cache");
 	if (btrfs_test_opt(root, CLEAR_CACHE))
 		seq_puts(seq, ",clear_cache");
 	if (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))

commit 04d21a244fdf79d0ac892eaaa9a46b682467277c
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Wed Nov 9 14:41:22 2011 +0200

    Btrfs: rework error handling in btrfs_mount()
    
    Commits 6c41761f and 45ea6095 introduced the possibility of NULL pointer
    dereference on error paths, also we would leave all devices busy and
    leak fs_info with all sub-structures on error when trying to mount an
    already mounted fs to a different directory.
    
    Fix this by doing all allocations before trying to open any of the
    devices, adjust error path for mount-already-mounted-fs case.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 58e9492230ce..629281c65ff5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -891,7 +891,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	struct super_block *s;
 	struct dentry *root;
 	struct btrfs_fs_devices *fs_devices = NULL;
-	struct btrfs_root *tree_root = NULL;
 	struct btrfs_fs_info *fs_info = NULL;
 	fmode_t mode = FMODE_READ;
 	char *subvol_name = NULL;
@@ -920,15 +919,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (error)
 		return ERR_PTR(error);
 
-	error = btrfs_open_devices(fs_devices, mode, fs_type);
-	if (error)
-		return ERR_PTR(error);
-
-	if (!(flags & MS_RDONLY) && fs_devices->rw_devices == 0) {
-		error = -EACCES;
-		goto error_close_devices;
-	}
-
 	/*
 	 * Setup a dummy root and fs_info for test/set super.  This is because
 	 * we don't actually fill this stuff out until open_ctree, but we need
@@ -936,28 +926,36 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	 * then open_ctree will properly initialize everything later.
 	 */
 	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_NOFS);
-	if (!fs_info) {
-		error = -ENOMEM;
-		goto error_close_devices;
-	}
-	tree_root = kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
-	if (!tree_root) {
+	if (!fs_info)
+		return ERR_PTR(-ENOMEM);
+
+	fs_info->tree_root = kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
+	if (!fs_info->tree_root) {
 		error = -ENOMEM;
-		goto error_close_devices;
+		goto error_fs_info;
 	}
-	fs_info->tree_root = tree_root;
+	fs_info->tree_root->fs_info = fs_info;
 	fs_info->fs_devices = fs_devices;
-	tree_root->fs_info = fs_info;
 
 	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
 	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
 	if (!fs_info->super_copy || !fs_info->super_for_commit) {
 		error = -ENOMEM;
+		goto error_fs_info;
+	}
+
+	error = btrfs_open_devices(fs_devices, mode, fs_type);
+	if (error)
+		goto error_fs_info;
+
+	if (!(flags & MS_RDONLY) && fs_devices->rw_devices == 0) {
+		error = -EACCES;
 		goto error_close_devices;
 	}
 
 	bdev = fs_devices->latest_bdev;
-	s = sget(fs_type, btrfs_test_super, btrfs_set_super, tree_root);
+	s = sget(fs_type, btrfs_test_super, btrfs_set_super,
+		 fs_info->tree_root);
 	if (IS_ERR(s)) {
 		error = PTR_ERR(s);
 		goto error_close_devices;
@@ -966,7 +964,8 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (s->s_root) {
 		if ((flags ^ s->s_flags) & MS_RDONLY) {
 			deactivate_locked_super(s);
-			return ERR_PTR(-EBUSY);
+			error = -EBUSY;
+			goto error_close_devices;
 		}
 
 		btrfs_close_devices(fs_devices);
@@ -997,6 +996,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 error_close_devices:
 	btrfs_close_devices(fs_devices);
+error_fs_info:
 	free_fs_info(fs_info);
 	return ERR_PTR(error);
 }

commit f23c8af8ca2789eeb0ab9ea90c214f9694d96cc5
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Tue Nov 8 19:15:05 2011 +0200

    Btrfs: fix subvol_name leak on error in btrfs_mount()
    
    btrfs_parse_early_options() can fail due to error while scanning devices
    (-o device= option), but still strdup() subvol_name string:
    
    mount -o subvol=SUBV,device=BAD_DEVICE <dev> <mnt>
    
    So free subvol_name string on error.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6befcaf253bd..58e9492230ce 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -905,8 +905,10 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	error = btrfs_parse_early_options(data, mode, fs_type,
 					  &subvol_name, &subvol_objectid,
 					  &subvol_rootid, &fs_devices);
-	if (error)
+	if (error) {
+		kfree(subvol_name);
 		return ERR_PTR(error);
+	}
 
 	if (subvol_name) {
 		root = mount_subvol(subvol_name, flags, device_name, data);

commit a90e8b6fb80db43b029e1e76205452afa8bdc77a
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Tue Nov 8 16:47:55 2011 +0200

    Btrfs: fix memory leak in btrfs_parse_early_options()
    
    Don't leak subvol_name string in case multiple subvol= options are
    given.  "The lastest option is effective" behavior (consistent with
    subvolid= and subvolrootid= options) is preserved.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index dcd5aef6b614..6befcaf253bd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -448,6 +448,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_subvol:
+			kfree(*subvol_name);
 			*subvol_name = match_strdup(&args[0]);
 			break;
 		case Opt_subvolid:

commit 45ea6095c8f0d6caad5658306416a5d254f1205e
Author: slyich@gmail.com <slyich@gmail.com>
Date:   Mon Nov 7 16:08:01 2011 -0500

    btrfs: fix double-free 'tree_root' in 'btrfs_mount()'
    
    On error path 'tree_root' is treed in 'free_fs_info()'.
    No need to free it explicitely. Noticed by SLUB in debug mode:
    
    Complete reproducer under usermode linux (discovered on real
    machine):
    
        bdev=/dev/ubda
        btr_root=/btr
        /mkfs.btrfs $bdev
        mount $bdev $btr_root
        mkdir $btr_root/subvols/
        cd $btr_root/subvols/
        /btrfs su cr foo
        /btrfs su cr bar
        mount $bdev -osubvol=subvols/foo $btr_root/subvols/bar
        umount $btr_root/subvols/bar
    
    which gives
    
    device fsid 4d55aa28-45b1-474b-b4ec-da912322195e devid 1 transid 7 /dev/ubda
    =============================================================================
    BUG kmalloc-2048: Object already free
    -----------------------------------------------------------------------------
    
    INFO: Allocated in btrfs_mount+0x389/0x7f0 age=0 cpu=0 pid=277
    INFO: Freed in btrfs_mount+0x51c/0x7f0 age=0 cpu=0 pid=277
    INFO: Slab 0x0000000062886200 objects=15 used=9 fp=0x0000000070b4d2d0 flags=0x4081
    INFO: Object 0x0000000070b4d2d0 @offset=21200 fp=0x0000000070b4a968
    ...
    Call Trace:
    70b31948:  [<6008c522>] print_trailer+0xe2/0x130
    70b31978:  [<6008c5aa>] object_err+0x3a/0x50
    70b319a8:  [<6008e242>] free_debug_processing+0x142/0x2a0
    70b319e0:  [<600ebf6f>] btrfs_mount+0x55f/0x7f0
    70b319f8:  [<6008e5c1>] __slab_free+0x221/0x2d0
    
    Signed-off-by: Sergei Trofimovich <slyfox@gentoo.org>
    Cc: Arne Jansen <sensille@gmx.net>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 57080dffdfc6..dcd5aef6b614 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -933,8 +933,12 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	 * then open_ctree will properly initialize everything later.
 	 */
 	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_NOFS);
+	if (!fs_info) {
+		error = -ENOMEM;
+		goto error_close_devices;
+	}
 	tree_root = kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
-	if (!fs_info || !tree_root) {
+	if (!tree_root) {
 		error = -ENOMEM;
 		goto error_close_devices;
 	}
@@ -964,7 +968,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 		btrfs_close_devices(fs_devices);
 		free_fs_info(fs_info);
-		kfree(tree_root);
 	} else {
 		char b[BDEVNAME_SIZE];
 
@@ -992,7 +995,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 error_close_devices:
 	btrfs_close_devices(fs_devices);
 	free_fs_info(fs_info);
-	kfree(tree_root);
 	return ERR_PTR(error);
 }
 

commit af31f5e5b84b5bf2bcec464153a5130b170b2770
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Nov 3 15:17:42 2011 -0400

    Btrfs: add a log of past tree roots
    
    This takes some of the free space in the btrfs super block
    to record information about most of the roots in the last four
    commits.
    
    It also adds a -o recovery to use the root history log when
    we're not able to read the tree of tree roots, the extent
    tree root, the device tree root or the csum root.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f7e9de724ef2..57080dffdfc6 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -164,7 +164,7 @@ enum {
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
 	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
 	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag,
-	Opt_inode_cache, Opt_no_space_cache, Opt_err,
+	Opt_inode_cache, Opt_no_space_cache, Opt_recovery, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -198,6 +198,7 @@ static match_table_t tokens = {
 	{Opt_defrag, "autodefrag"},
 	{Opt_inode_cache, "inode_cache"},
 	{Opt_no_space_cache, "no_space_cache"},
+	{Opt_recovery, "recovery"},
 	{Opt_err, NULL},
 };
 
@@ -392,6 +393,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: enabling auto defrag");
 			btrfs_set_opt(info->mount_opt, AUTO_DEFRAG);
 			break;
+		case Opt_recovery:
+			printk(KERN_INFO "btrfs: enabling auto recovery");
+			btrfs_set_opt(info->mount_opt, RECOVERY);
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);

commit 6c41761fc6efe1503103a1afe03a6635c0b5d4ec
Author: David Sterba <dsterba@suse.cz>
Date:   Wed Apr 13 15:41:04 2011 +0200

    btrfs: separate superblock items out of fs_info
    
    fs_info has now ~9kb, more than fits into one page. This will cause
    mount failure when memory is too fragmented. Top space consumers are
    super block structures super_copy and super_for_commit, ~2.8kb each.
    Allocate them dynamically. fs_info will be ~3.5kb. (measured on x86_64)
    
    Add a wrapper for freeing fs_info and all of it's dynamically allocated
    members.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5429b1fa0bfc..f7e9de724ef2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -216,7 +216,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	char *compress_type;
 	bool compress_force = false;
 
-	cache_gen = btrfs_super_cache_generation(&root->fs_info->super_copy);
+	cache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);
 	if (cache_gen)
 		btrfs_set_opt(info->mount_opt, SPACE_CACHE);
 
@@ -524,7 +524,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 	 * will mount by default if we haven't been given a specific subvolume
 	 * to mount.
 	 */
-	dir_id = btrfs_super_root_dir(&root->fs_info->super_copy);
+	dir_id = btrfs_super_root_dir(root->fs_info->super_copy);
 	di = btrfs_lookup_dir_item(NULL, root, path, dir_id, "default", 7, 0);
 	if (IS_ERR(di)) {
 		btrfs_free_path(path);
@@ -937,6 +937,13 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	fs_info->fs_devices = fs_devices;
 	tree_root->fs_info = fs_info;
 
+	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
+	fs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
+	if (!fs_info->super_copy || !fs_info->super_for_commit) {
+		error = -ENOMEM;
+		goto error_close_devices;
+	}
+
 	bdev = fs_devices->latest_bdev;
 	s = sget(fs_type, btrfs_test_super, btrfs_set_super, tree_root);
 	if (IS_ERR(s)) {
@@ -951,7 +958,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		}
 
 		btrfs_close_devices(fs_devices);
-		kfree(fs_info);
+		free_fs_info(fs_info);
 		kfree(tree_root);
 	} else {
 		char b[BDEVNAME_SIZE];
@@ -979,7 +986,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 error_close_devices:
 	btrfs_close_devices(fs_devices);
-	kfree(fs_info);
+	free_fs_info(fs_info);
 	kfree(tree_root);
 	return ERR_PTR(error);
 }
@@ -1005,7 +1012,7 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (root->fs_info->fs_devices->rw_devices == 0)
 			return -EACCES;
 
-		if (btrfs_super_log_root(&root->fs_info->super_copy) != 0)
+		if (btrfs_super_log_root(root->fs_info->super_copy) != 0)
 			return -EINVAL;
 
 		ret = btrfs_cleanup_fs_roots(root->fs_info);
@@ -1171,7 +1178,7 @@ static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
-	struct btrfs_super_block *disk_super = &root->fs_info->super_copy;
+	struct btrfs_super_block *disk_super = root->fs_info->super_copy;
 	struct list_head *head = &root->fs_info->space_info;
 	struct btrfs_space_info *found;
 	u64 total_used = 0;

commit f9d9ef62cd3ecbd6cbb7957a253c1e81f69d5586
Author: David Sterba <dsterba@suse.cz>
Date:   Thu Sep 29 13:11:33 2011 +0200

    btrfs: do not allow mounting non-subvolumes via subvol option
    
    There's a missing test whether the path passed to subvol=path option
    during mount is a real subvolume, allowing any directory located in
    default subovlume to be passed and accepted for mount.
    
    (current btrfs progs prevent this early)
    $ btrfs subvol snapshot . p1-snap
    ERROR: '.' is not a subvolume
    
    (with "is subvolume?" test bypassed)
    $ btrfs subvol snapshot . p1-snap
    Create a snapshot of '.' in './p1-snap'
    
    $ btrfs subvol list -p .
    ID 258 parent 5 top level 5 path subvol
    ID 259 parent 5 top level 5 path subvol1
    ID 260 parent 5 top level 5 path default-subvol1
    ID 262 parent 5 top level 5 path p1/p1-snapshot
    ID 263 parent 259 top level 5 path subvol1/subvol1-snap
    
    The problem I see is that this makes a false impression of snapshotting the
    given subvolume but in fact snapshots the default one: a user expects outcome
    like ID 263 but in fact gets ID 262 .
    
    This patch makes mount fail with EINVAL with a message in syslog.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 29eecbb6ec3a..5429b1fa0bfc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -740,6 +740,16 @@ static int btrfs_set_super(struct super_block *s, void *data)
 	return set_anon_super(s, data);
 }
 
+/*
+ * subvolumes are identified by ino 256
+ */
+static inline int is_subvolume_inode(struct inode *inode)
+{
+	if (inode && inode->i_ino == BTRFS_FIRST_FREE_OBJECTID)
+		return 1;
+	return 0;
+}
+
 /*
  * This will strip out the subvol=%s argument for an argument string and add
  * subvolid=0 to make sure we get the actual tree root for path walking to the
@@ -843,6 +853,15 @@ static struct dentry *mount_subvol(const char *subvol_name, int flags,
 	if (error)
 		return ERR_PTR(error);
 
+	if (!is_subvolume_inode(path.dentry->d_inode)) {
+		path_put(&path);
+		mntput(mnt);
+		error = -EINVAL;
+		printk(KERN_ERR "btrfs: '%s' is not a valid subvolume\n",
+				subvol_name);
+		return ERR_PTR(-EINVAL);
+	}
+
 	/* Get a ref to the sb and the dentry we found and return it */
 	s = path.mnt->mnt_sb;
 	atomic_inc(&s->s_active);

commit 5f524444c351e145a5f7e28253594688a421bfe8
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Thu Oct 13 00:20:43 2011 +0300

    Btrfs: fix a bug when opening seed devices
    
    Initialize fs_info->bdev_holder a bit earlier to be able to pass a
    correct holder id to blkdev_get() when opening seed devices with O_EXCL.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 09ce951666ea..29eecbb6ec3a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -939,6 +939,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 		s->s_flags = flags | MS_NOSEC;
 		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
+		btrfs_sb(s)->fs_info->bdev_holder = fs_type;
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);
 		if (error) {
@@ -946,7 +947,6 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 			return ERR_PTR(error);
 		}
 
-		btrfs_sb(s)->fs_info->bdev_holder = fs_type;
 		s->s_flags |= MS_ACTIVE;
 	}
 

commit 83c8c9bde0add721f7509aa446455183b040b931
Author: Jeff Liu <jeff.liu@oracle.com>
Date:   Wed Sep 14 14:11:21 2011 +0800

    btrfs: trivial fix, a potential memory leak in btrfs_parse_early_options()
    
    Signed-off-by: Jie Liu <jeff.liu@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 266d1f35465d..09ce951666ea 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -419,7 +419,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		u64 *subvol_rootid, struct btrfs_fs_devices **fs_devices)
 {
 	substring_t args[MAX_OPT_ARGS];
-	char *opts, *orig, *p;
+	char *device_name, *opts, *orig, *p;
 	int error = 0;
 	int intarg;
 
@@ -470,8 +470,14 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 			}
 			break;
 		case Opt_device:
-			error = btrfs_scan_one_device(match_strdup(&args[0]),
+			device_name = match_strdup(&args[0]);
+			if (!device_name) {
+				error = -ENOMEM;
+				goto out;
+			}
+			error = btrfs_scan_one_device(device_name,
 					flags, holder, fs_devices);
+			kfree(device_name);
 			if (error)
 				goto out;
 			break;

commit 73bc187680f94bed498f8a669103cad290e41180
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Oct 3 14:07:49 2011 -0400

    Btrfs: introduce mount option no_space_cache
    
    Some users have requested this and I've found I needed a way to disable cache
    loading without actually clearing the cache, so introduce the no_space_cache
    option.  Before we check the super blocks cache generation field and if it was
    populated we always turned space caching on.  Now we check this and set the
    space cache option on, and then parse the mount options so that if we want it
    off it get's turned off.  Then we check the mount option all the places we do
    the caching work instead of checking the super's cache generation.  This makes
    things more consistent and lets us turn space caching off.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 934789f7fd33..266d1f35465d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -164,7 +164,7 @@ enum {
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
 	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
 	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag,
-	Opt_inode_cache, Opt_err,
+	Opt_inode_cache, Opt_no_space_cache, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -197,6 +197,7 @@ static match_table_t tokens = {
 	{Opt_subvolrootid, "subvolrootid=%d"},
 	{Opt_defrag, "autodefrag"},
 	{Opt_inode_cache, "inode_cache"},
+	{Opt_no_space_cache, "no_space_cache"},
 	{Opt_err, NULL},
 };
 
@@ -208,14 +209,19 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 {
 	struct btrfs_fs_info *info = root->fs_info;
 	substring_t args[MAX_OPT_ARGS];
-	char *p, *num, *orig;
+	char *p, *num, *orig = NULL;
+	u64 cache_gen;
 	int intarg;
 	int ret = 0;
 	char *compress_type;
 	bool compress_force = false;
 
+	cache_gen = btrfs_super_cache_generation(&root->fs_info->super_copy);
+	if (cache_gen)
+		btrfs_set_opt(info->mount_opt, SPACE_CACHE);
+
 	if (!options)
-		return 0;
+		goto out;
 
 	/*
 	 * strsep changes the string, duplicate it because parse_options
@@ -362,9 +368,12 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, DISCARD);
 			break;
 		case Opt_space_cache:
-			printk(KERN_INFO "btrfs: enabling disk space caching\n");
 			btrfs_set_opt(info->mount_opt, SPACE_CACHE);
 			break;
+		case Opt_no_space_cache:
+			printk(KERN_INFO "btrfs: disabling disk space caching\n");
+			btrfs_clear_opt(info->mount_opt, SPACE_CACHE);
+			break;
 		case Opt_inode_cache:
 			printk(KERN_INFO "btrfs: enabling inode map caching\n");
 			btrfs_set_opt(info->mount_opt, INODE_MAP_CACHE);
@@ -393,6 +402,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		}
 	}
 out:
+	if (!ret && btrfs_test_opt(root, SPACE_CACHE))
+		printk(KERN_INFO "btrfs: disk space caching is enabled\n");
 	kfree(orig);
 	return ret;
 }
@@ -687,6 +698,8 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_puts(seq, ",noacl");
 	if (btrfs_test_opt(root, SPACE_CACHE))
 		seq_puts(seq, ",space_cache");
+	else
+		seq_puts(seq, ",no_space_cache");
 	if (btrfs_test_opt(root, CLEAR_CACHE))
 		seq_puts(seq, ",clear_cache");
 	if (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))

commit 830c4adbd04a79f806d4fa579546f36a71b727c1
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Jul 25 15:55:42 2011 -0400

    Btrfs: fix how we mount subvol=<whatever>
    
    We've only been able to mount with subvol=<whatever> where whatever was a subvol
    within whatever root we had as the default.  This allows us to mount -o
    subvol=path/to/subvol/you/want relative from the normal fs_tree root.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 244fa46c50b8..934789f7fd33 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -40,6 +40,7 @@
 #include <linux/magic.h>
 #include <linux/slab.h>
 #include <linux/cleancache.h>
+#include <linux/mnt_namespace.h>
 #include "compat.h"
 #include "delayed-inode.h"
 #include "ctree.h"
@@ -58,6 +59,7 @@
 #include <trace/events/btrfs.h>
 
 static const struct super_operations btrfs_super_ops;
+static struct file_system_type btrfs_fs_type;
 
 static const char *btrfs_decode_error(struct btrfs_fs_info *fs_info, int errno,
 				      char nbuf[16])
@@ -411,7 +413,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 	int intarg;
 
 	if (!options)
-		goto out;
+		return 0;
 
 	/*
 	 * strsep changes the string, duplicate it because parse_options
@@ -460,26 +462,15 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 			error = btrfs_scan_one_device(match_strdup(&args[0]),
 					flags, holder, fs_devices);
 			if (error)
-				goto out_free_opts;
+				goto out;
 			break;
 		default:
 			break;
 		}
 	}
 
- out_free_opts:
+out:
 	kfree(orig);
- out:
-	/*
-	 * If no subvolume name is specified we use the default one.  Allocate
-	 * a copy of the string "." here so that code later in the
-	 * mount path doesn't care if it's the default volume or another one.
-	 */
-	if (!*subvol_name) {
-		*subvol_name = kstrdup(".", GFP_KERNEL);
-		if (!*subvol_name)
-			return -ENOMEM;
-	}
 	return error;
 }
 
@@ -730,6 +721,118 @@ static int btrfs_set_super(struct super_block *s, void *data)
 	return set_anon_super(s, data);
 }
 
+/*
+ * This will strip out the subvol=%s argument for an argument string and add
+ * subvolid=0 to make sure we get the actual tree root for path walking to the
+ * subvol we want.
+ */
+static char *setup_root_args(char *args)
+{
+	unsigned copied = 0;
+	unsigned len = strlen(args) + 2;
+	char *pos;
+	char *ret;
+
+	/*
+	 * We need the same args as before, but minus
+	 *
+	 * subvol=a
+	 *
+	 * and add
+	 *
+	 * subvolid=0
+	 *
+	 * which is a difference of 2 characters, so we allocate strlen(args) +
+	 * 2 characters.
+	 */
+	ret = kzalloc(len * sizeof(char), GFP_NOFS);
+	if (!ret)
+		return NULL;
+	pos = strstr(args, "subvol=");
+
+	/* This shouldn't happen, but just in case.. */
+	if (!pos) {
+		kfree(ret);
+		return NULL;
+	}
+
+	/*
+	 * The subvol=<> arg is not at the front of the string, copy everybody
+	 * up to that into ret.
+	 */
+	if (pos != args) {
+		*pos = '\0';
+		strcpy(ret, args);
+		copied += strlen(args);
+		pos++;
+	}
+
+	strncpy(ret + copied, "subvolid=0", len - copied);
+
+	/* Length of subvolid=0 */
+	copied += 10;
+
+	/*
+	 * If there is no , after the subvol= option then we know there's no
+	 * other options and we can just return.
+	 */
+	pos = strchr(pos, ',');
+	if (!pos)
+		return ret;
+
+	/* Copy the rest of the arguments into our buffer */
+	strncpy(ret + copied, pos, len - copied);
+	copied += strlen(pos);
+
+	return ret;
+}
+
+static struct dentry *mount_subvol(const char *subvol_name, int flags,
+				   const char *device_name, char *data)
+{
+	struct super_block *s;
+	struct dentry *root;
+	struct vfsmount *mnt;
+	struct mnt_namespace *ns_private;
+	char *newargs;
+	struct path path;
+	int error;
+
+	newargs = setup_root_args(data);
+	if (!newargs)
+		return ERR_PTR(-ENOMEM);
+	mnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,
+			     newargs);
+	kfree(newargs);
+	if (IS_ERR(mnt))
+		return ERR_CAST(mnt);
+
+	ns_private = create_mnt_ns(mnt);
+	if (IS_ERR(ns_private)) {
+		mntput(mnt);
+		return ERR_CAST(ns_private);
+	}
+
+	/*
+	 * This will trigger the automount of the subvol so we can just
+	 * drop the mnt we have here and return the dentry that we
+	 * found.
+	 */
+	error = vfs_path_lookup(mnt->mnt_root, mnt, subvol_name,
+				LOOKUP_FOLLOW, &path);
+	put_mnt_ns(ns_private);
+	if (error)
+		return ERR_PTR(error);
+
+	/* Get a ref to the sb and the dentry we found and return it */
+	s = path.mnt->mnt_sb;
+	atomic_inc(&s->s_active);
+	root = dget(path.dentry);
+	path_put(&path);
+	down_write(&s->s_umount);
+
+	return root;
+}
 
 /*
  * Find a superblock for the given device / mount point.
@@ -761,13 +864,19 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (error)
 		return ERR_PTR(error);
 
+	if (subvol_name) {
+		root = mount_subvol(subvol_name, flags, device_name, data);
+		kfree(subvol_name);
+		return root;
+	}
+
 	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
 	if (error)
-		goto error_free_subvol_name;
+		return ERR_PTR(error);
 
 	error = btrfs_open_devices(fs_devices, mode, fs_type);
 	if (error)
-		goto error_free_subvol_name;
+		return ERR_PTR(error);
 
 	if (!(flags & MS_RDONLY) && fs_devices->rw_devices == 0) {
 		error = -EACCES;
@@ -792,14 +901,15 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 	bdev = fs_devices->latest_bdev;
 	s = sget(fs_type, btrfs_test_super, btrfs_set_super, tree_root);
-	if (IS_ERR(s))
-		goto error_s;
+	if (IS_ERR(s)) {
+		error = PTR_ERR(s);
+		goto error_close_devices;
+	}
 
 	if (s->s_root) {
 		if ((flags ^ s->s_flags) & MS_RDONLY) {
 			deactivate_locked_super(s);
-			error = -EBUSY;
-			goto error_close_devices;
+			return ERR_PTR(-EBUSY);
 		}
 
 		btrfs_close_devices(fs_devices);
@@ -814,64 +924,25 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 					 flags & MS_SILENT ? 1 : 0);
 		if (error) {
 			deactivate_locked_super(s);
-			goto error_free_subvol_name;
+			return ERR_PTR(error);
 		}
 
 		btrfs_sb(s)->fs_info->bdev_holder = fs_type;
 		s->s_flags |= MS_ACTIVE;
 	}
 
-	/* if they gave us a subvolume name bind mount into that */
-	if (strcmp(subvol_name, ".")) {
-		struct dentry *new_root;
-
-		root = get_default_root(s, subvol_rootid);
-		if (IS_ERR(root)) {
-			error = PTR_ERR(root);
-			deactivate_locked_super(s);
-			goto error_free_subvol_name;
-		}
-
-		mutex_lock(&root->d_inode->i_mutex);
-		new_root = lookup_one_len(subvol_name, root,
-				      strlen(subvol_name));
-		mutex_unlock(&root->d_inode->i_mutex);
-
-		if (IS_ERR(new_root)) {
-			dput(root);
-			deactivate_locked_super(s);
-			error = PTR_ERR(new_root);
-			goto error_free_subvol_name;
-		}
-		if (!new_root->d_inode) {
-			dput(root);
-			dput(new_root);
-			deactivate_locked_super(s);
-			error = -ENXIO;
-			goto error_free_subvol_name;
-		}
-		dput(root);
-		root = new_root;
-	} else {
-		root = get_default_root(s, subvol_objectid);
-		if (IS_ERR(root)) {
-			error = PTR_ERR(root);
-			deactivate_locked_super(s);
-			goto error_free_subvol_name;
-		}
+	root = get_default_root(s, subvol_objectid);
+	if (IS_ERR(root)) {
+		deactivate_locked_super(s);
+		return root;
 	}
 
-	kfree(subvol_name);
 	return root;
 
-error_s:
-	error = PTR_ERR(s);
 error_close_devices:
 	btrfs_close_devices(fs_devices);
 	kfree(fs_info);
 	kfree(tree_root);
-error_free_subvol_name:
-	kfree(subvol_name);
 	return ERR_PTR(error);
 }
 

commit ba5b8958dabbd7890a6929af1ffc0d87187765dc
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Jul 25 15:40:35 2011 -0400

    Btrfs: use d_obtain_alias when mounting subvol/subvolid
    
    Currently what we do is just wrong.  We either
    
    1) Alloc a new "root" dentry with sb->s_root as it's parent which is just wrong
    as we could walk into this subvol later on via another path and hilarity could
    ensue.  Also we don't check the return value of d_splice_alias which isn't good
    either.
    
    or
    
    2) Do a d_find_alias() which we could have lost our dentry from cache at this
    point and found nothing.
    
    So use d_obtain_alias().  In the case that we already have the inode/dentry in
    cache we will get the correct dentry.  If not we will get a disconnected dentry
    tree so if we walk into it later on everything will be connected up properly.
    Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 15634d4648d7..244fa46c50b8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -492,7 +492,6 @@ static struct dentry *get_default_root(struct super_block *sb,
 	struct btrfs_path *path;
 	struct btrfs_key location;
 	struct inode *inode;
-	struct dentry *dentry;
 	u64 dir_id;
 	int new = 0;
 
@@ -566,29 +565,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 		return dget(sb->s_root);
 	}
 
-	if (new) {
-		const struct qstr name = { .name = "/", .len = 1 };
-
-		/*
-		 * New inode, we need to make the dentry a sibling of s_root so
-		 * everything gets cleaned up properly on unmount.
-		 */
-		dentry = d_alloc(sb->s_root, &name);
-		if (!dentry) {
-			iput(inode);
-			return ERR_PTR(-ENOMEM);
-		}
-		d_splice_alias(inode, dentry);
-	} else {
-		/*
-		 * We found the inode in cache, just find a dentry for it and
-		 * put the reference to the inode we just got.
-		 */
-		dentry = d_find_alias(inode);
-		iput(inode);
-	}
-
-	return dentry;
+	return d_obtain_alias(inode);
 }
 
 static int btrfs_fill_super(struct super_block *sb,

commit 1acc9309eb2674533944f48dbaaa53e7750e3947
Merge: c2d197e82b62 149e2d76b488
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 8 23:25:45 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      btrfs: fix oops when doing space balance
      Btrfs: don't panic if we get an error while balancing V2
      btrfs: add missing options displayed in mount output

commit 0942caa373c676dca614ea8352ac77e0270aba73
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Jun 28 15:10:37 2011 +0000

    btrfs: add missing options displayed in mount output
    
    There are three missed mount options settable by user which are not
    currently displayed in mount output.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3559d0b3518a..5746081199ee 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -721,6 +721,12 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_puts(seq, ",clear_cache");
 	if (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))
 		seq_puts(seq, ",user_subvol_rm_allowed");
+	if (btrfs_test_opt(root, ENOSPC_DEBUG))
+		seq_puts(seq, ",enospc_debug");
+	if (btrfs_test_opt(root, AUTO_DEFRAG))
+		seq_puts(seq, ",autodefrag");
+	if (btrfs_test_opt(root, INODE_MAP_CACHE))
+		seq_puts(seq, ",inode_cache");
 	return 0;
 }
 

commit 8397345172aa5cdcbc133977af9d525f45b874ea
Merge: 59c5f46fbe01 e6bc45d65df8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 7 18:36:59 2011 -0700

    Merge branch 'for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      vfs: make unlink() and rmdir() return ENOENT in preference to EROFS
      lmLogOpen() broken failure exit
      usb: remove bad dput after dentry_unhash
      more conservative S_NOSEC handling

commit e6ece70732b905742ad91a7b5489e0ca1362c0cd
Merge: 23c79d31a3dd aa0467d8d2a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 5 06:17:23 2011 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (25 commits)
      btrfs: fix uninitialized variable warning
      btrfs: add helper for fs_info->closing
      Btrfs: add mount -o inode_cache
      btrfs: scrub: add explicit plugging
      btrfs: use btrfs_ino to access inode number
      Btrfs: don't save the inode cache if we are deleting this root
      btrfs: false BUG_ON when degraded
      Btrfs: don't save the inode cache in non-FS roots
      Btrfs: make sure we don't overflow the free space cache crc page
      Btrfs: fix uninit variable in the delayed inode code
      btrfs: scrub: don't reuse bios and pages
      Btrfs: leave spinning on lookup and map the leaf
      Btrfs: check for duplicate entries in the free space cache
      Btrfs: don't try to allocate from a block group that doesn't have enough space
      Btrfs: don't always do readahead
      Btrfs: try not to sleep as much when doing slow caching
      Btrfs: kill BTRFS_I(inode)->block_group
      Btrfs: don't look at the extent buffer level 3 times in a row
      Btrfs: map the node block when looking for readahead targets
      Btrfs: set range_start to the right start in count_range_bits
      ...

commit 4b9465cb9e3859186eefa1ca3b990a5849386320
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jun 3 09:36:29 2011 -0400

    Btrfs: add mount -o inode_cache
    
    This makes the inode map cache default to off until we
    fix the overflow problem when the free space crcs don't fit
    inside a single page.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 28e3cb2607ff..3559d0b3518a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -160,7 +160,8 @@ enum {
 	Opt_compress_type, Opt_compress_force, Opt_compress_force_type,
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
 	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
-	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag, Opt_err,
+	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag,
+	Opt_inode_cache, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -192,6 +193,7 @@ static match_table_t tokens = {
 	{Opt_enospc_debug, "enospc_debug"},
 	{Opt_subvolrootid, "subvolrootid=%d"},
 	{Opt_defrag, "autodefrag"},
+	{Opt_inode_cache, "inode_cache"},
 	{Opt_err, NULL},
 };
 
@@ -360,6 +362,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: enabling disk space caching\n");
 			btrfs_set_opt(info->mount_opt, SPACE_CACHE);
 			break;
+		case Opt_inode_cache:
+			printk(KERN_INFO "btrfs: enabling inode map caching\n");
+			btrfs_set_opt(info->mount_opt, INODE_MAP_CACHE);
+			break;
 		case Opt_clear_cache:
 			printk(KERN_INFO "btrfs: force clearing of disk cache\n");
 			btrfs_set_opt(info->mount_opt, CLEAR_CACHE);

commit 9e1f1de02c2275d7172e18dc4e7c2065777611bf
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 3 18:24:58 2011 -0400

    more conservative S_NOSEC handling
    
    Caching "we have already removed suid/caps" was overenthusiastic as merged.
    On network filesystems we might have had suid/caps set on another client,
    silently picked by this client on revalidate, all of that *without* clearing
    the S_NOSEC flag.
    
    AFAICS, the only reasonably sane way to deal with that is
            * new superblock flag; unless set, S_NOSEC is not going to be set.
            * local block filesystems set it in their ->mount() (more accurately,
    mount_bdev() does, so does btrfs ->mount(), users of mount_bdev() other than
    local block ones clear it)
            * if any network filesystem (or a cluster one) wants to use S_NOSEC,
    it'll need to set MS_NOSEC in sb->s_flags *AND* take care to clear S_NOSEC when
    inode attribute changes are picked from other clients.
    
    It's not an earth-shattering hole (anybody that can set suid on another client
    will almost certainly be able to write to the file before doing that anyway),
    but it's a bug that needs fixing.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9b2e7e5bc3ef..d158b672a2d2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -819,7 +819,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	} else {
 		char b[BDEVNAME_SIZE];
 
-		s->s_flags = flags;
+		s->s_flags = flags | MS_NOSEC;
 		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);

commit a0c3061093c8b49facef95dc09a618c6e0d17cb5
Merge: 10799db60cbc 174ba50915b0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 27 13:57:12 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (58 commits)
      Btrfs: use the device_list_mutex during write_dev_supers
      Btrfs: setup free ino caching in a more asynchronous way
      btrfs scrub: don't coalesce pages that are logically discontiguous
      Btrfs: return -ENOMEM in clear_extent_bit
      Btrfs: add mount -o auto_defrag
      Btrfs: using rcu lock in the reader side of devices list
      Btrfs: drop unnecessary device lock
      Btrfs: fix the race between remove dev and alloc chunk
      Btrfs: fix the race between reading and updating devices
      Btrfs: fix bh leak on __btrfs_open_devices path
      Btrfs: fix unsafe usage of merge_state
      Btrfs: allocate extent state and check the result properly
      fs/btrfs: Add missing btrfs_free_path
      Btrfs: check return value of btrfs_inc_extent_ref()
      Btrfs: return error to caller if read_one_inode() fails
      Btrfs: BUG_ON is deleted from the caller of btrfs_truncate_item & btrfs_extend_item
      Btrfs: return error code to caller when btrfs_del_item fails
      Btrfs: return error code to caller when btrfs_previous_item fails
      btrfs: fix typo 'testeing' -> 'testing'
      btrfs: typo: 'btrfS' -> 'btrfs'
      ...

commit 4cb5300bc839b8a943eb19c9f27f25470e22d0ca
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue May 24 15:35:30 2011 -0400

    Btrfs: add mount -o auto_defrag
    
    This will detect small random writes into files and
    queue the up for an auto defrag process.  It isn't well suited to
    database workloads yet, but works for smaller files such as rpm, sqlite
    or bdb databases.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index cd0c7cd2c8fb..28e3cb2607ff 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -160,7 +160,7 @@ enum {
 	Opt_compress_type, Opt_compress_force, Opt_compress_force_type,
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
 	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
-	Opt_enospc_debug, Opt_subvolrootid, Opt_err,
+	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -191,6 +191,7 @@ static match_table_t tokens = {
 	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
 	{Opt_enospc_debug, "enospc_debug"},
 	{Opt_subvolrootid, "subvolrootid=%d"},
+	{Opt_defrag, "autodefrag"},
 	{Opt_err, NULL},
 };
 
@@ -369,6 +370,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_enospc_debug:
 			btrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);
 			break;
+		case Opt_defrag:
+			printk(KERN_INFO "btrfs: enabling auto defrag");
+			btrfs_set_opt(info->mount_opt, AUTO_DEFRAG);
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);

commit 90a887c9a2e25bcb1fc658fad59dfbc6fb792734
Author: Dan Magenheimer <dan.magenheimer@oracle.com>
Date:   Thu May 26 10:01:56 2011 -0600

    btrfs: add cleancache support
    
    This sixth patch of eight in this cleancache series "opts-in"
    cleancache for btrfs.  Filesystems must explicitly enable
    cleancache by calling cleancache_init_fs anytime an instance
    of the filesystem is mounted.  Btrfs uses its own readpage
    which must be hooked, but all other cleancache hooks are in
    the VFS layer including the matching cleancache_flush_fs hook
    which must be called on unmount.
    
    Details and a FAQ can be found in Documentation/vm/cleancache.txt
    
    [v6-v8: no changes]
    [v5: jeremy@goop.org: simplify init hook and any future fs init changes]
    Signed-off-by: Dan Magenheimer <dan.magenheimer@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>
    Reviewed-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: Rik Van Riel <riel@redhat.com>
    Cc: Jan Beulich <JBeulich@novell.com>
    Cc: Andreas Dilger <adilger@sun.com>
    Cc: Ted Ts'o <tytso@mit.edu>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <joel.becker@oracle.com>
    Cc: Nitin Gupta <ngupta@vflare.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0ac712efcdf2..be4ffa12f3ef 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -39,6 +39,7 @@
 #include <linux/miscdevice.h>
 #include <linux/magic.h>
 #include <linux/slab.h>
+#include <linux/cleancache.h>
 #include "compat.h"
 #include "ctree.h"
 #include "disk-io.h"
@@ -624,6 +625,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_root = root_dentry;
 
 	save_mount_options(sb, data);
+	cleancache_init_fs(sb);
 	return 0;
 
 fail_close:

commit d6c0cb379c5198487e4ac124728cbb2346d63b1f
Merge: 8e531cdfeb75 1f78160ce1b1
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon May 23 14:37:47 2011 -0400

    Merge branch 'cleanups_and_fixes' into inode_numbers
    
    Conflicts:
            fs/btrfs/tree-log.c
            fs/btrfs/volumes.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit b083916638eee513be501f53b42a4be0b9851db0
Author: Julia Lawall <julia@diku.dk>
Date:   Sat May 14 07:10:51 2011 +0000

    fs/btrfs: Add missing btrfs_free_path
    
    Btrfs_alloc_path should be matched with btrfs_free_path in error-handling code.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r exists@
    local idexpression struct btrfs_path * x;
    expression ra,rb;
    position p1,p2;
    @@
    
    x = btrfs_alloc_path@p1(...)
    ...  when != btrfs_free_path(x,...)
         when != if (...) { ... btrfs_free_path(x,...) ...}
         when != x = ra
    if(...) { ... when != x = rb
         when forall
         when != btrfs_free_path(x,...)
     \(return <+...x...+>; \| return@p2...; \) }
    
    @script:python@
    p1 << r.p1;
    p2 << r.p2;
    @@
    
    cocci.print_main("alloc",p1)
    cocci.print_secs("return",p2)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0ac712efcdf2..46d7eed7e965 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -506,8 +506,10 @@ static struct dentry *get_default_root(struct super_block *sb,
 	 */
 	dir_id = btrfs_super_root_dir(&root->fs_info->super_copy);
 	di = btrfs_lookup_dir_item(NULL, root, path, dir_id, "default", 7, 0);
-	if (IS_ERR(di))
+	if (IS_ERR(di)) {
+		btrfs_free_path(path);
 		return ERR_CAST(di);
+	}
 	if (!di) {
 		/*
 		 * Ok the default dir item isn't there.  This is weird since

commit aa2dfb372a2a647beedac163ce6f8b0fcbefac29
Merge: 945d8962ceee 73c5de005153
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun May 22 12:36:34 2011 -0400

    Merge branch 'allocator' of git://git.kernel.org/pub/scm/linux/kernel/git/arne/btrfs-unstable-arne into inode_numbers
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 945d8962ceee6bb273365d0bdf42f763225b290f
Merge: 0d0ca30f1809 4ea028859bbd
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun May 22 12:33:42 2011 -0400

    Merge branch 'cleanups' of git://repo.or.cz/linux-2.6/btrfs-unstable into inode_numbers
    
    Conflicts:
            fs/btrfs/extent-tree.c
            fs/btrfs/free-space-cache.c
            fs/btrfs/inode.c
            fs/btrfs/tree-log.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 16cdcec736cd214350cdb591bf1091f8beedefa0
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Fri Apr 22 18:12:22 2011 +0800

    btrfs: implement delayed inode items operation
    
    Changelog V5 -> V6:
    - Fix oom when the memory load is high, by storing the delayed nodes into the
      root's radix tree, and letting btrfs inodes go.
    
    Changelog V4 -> V5:
    - Fix the race on adding the delayed node to the inode, which is spotted by
      Chris Mason.
    - Merge Chris Mason's incremental patch into this patch.
    - Fix deadlock between readdir() and memory fault, which is reported by
      Itaru Kitayama.
    
    Changelog V3 -> V4:
    - Fix nested lock, which is reported by Itaru Kitayama, by updating space cache
      inode in time.
    
    Changelog V2 -> V3:
    - Fix the race between the delayed worker and the task which does delayed items
      balance, which is reported by Tsutomu Itoh.
    - Modify the patch address David Sterba's comment.
    - Fix the bug of the cpu recursion spinlock, reported by Chris Mason
    
    Changelog V1 -> V2:
    - break up the global rb-tree, use a list to manage the delayed nodes,
      which is created for every directory and file, and used to manage the
      delayed directory name index items and the delayed inode item.
    - introduce a worker to deal with the delayed nodes.
    
    Compare with Ext3/4, the performance of file creation and deletion on btrfs
    is very poor. the reason is that btrfs must do a lot of b+ tree insertions,
    such as inode item, directory name item, directory name index and so on.
    
    If we can do some delayed b+ tree insertion or deletion, we can improve the
    performance, so we made this patch which implemented delayed directory name
    index insertion/deletion and delayed inode update.
    
    Implementation:
    - introduce a delayed root object into the filesystem, that use two lists to
      manage the delayed nodes which are created for every file/directory.
      One is used to manage all the delayed nodes that have delayed items. And the
      other is used to manage the delayed nodes which is waiting to be dealt with
      by the work thread.
    - Every delayed node has two rb-tree, one is used to manage the directory name
      index which is going to be inserted into b+ tree, and the other is used to
      manage the directory name index which is going to be deleted from b+ tree.
    - introduce a worker to deal with the delayed operation. This worker is used
      to deal with the works of the delayed directory name index items insertion
      and deletion and the delayed inode update.
      When the delayed items is beyond the lower limit, we create works for some
      delayed nodes and insert them into the work queue of the worker, and then
      go back.
      When the delayed items is beyond the upper bound, we create works for all
      the delayed nodes that haven't been dealt with, and insert them into the work
      queue of the worker, and then wait for that the untreated items is below some
      threshold value.
    - When we want to insert a directory name index into b+ tree, we just add the
      information into the delayed inserting rb-tree.
      And then we check the number of the delayed items and do delayed items
      balance. (The balance policy is above.)
    - When we want to delete a directory name index from the b+ tree, we search it
      in the inserting rb-tree at first. If we look it up, just drop it. If not,
      add the key of it into the delayed deleting rb-tree.
      Similar to the delayed inserting rb-tree, we also check the number of the
      delayed items and do delayed items balance.
      (The same to inserting manipulation)
    - When we want to update the metadata of some inode, we cached the data of the
      inode into the delayed node. the worker will flush it into the b+ tree after
      dealing with the delayed insertion and deletion.
    - We will move the delayed node to the tail of the list after we access the
      delayed node, By this way, we can cache more delayed items and merge more
      inode updates.
    - If we want to commit transaction, we will deal with all the delayed node.
    - the delayed node will be freed when we free the btrfs inode.
    - Before we log the inode items, we commit all the directory name index items
      and the delayed inode update.
    
    I did a quick test by the benchmark tool[1] and found we can improve the
    performance of file creation by ~15%, and file deletion by ~20%.
    
    Before applying this patch:
    Create files:
            Total files: 50000
            Total time: 1.096108
            Average time: 0.000022
    Delete files:
            Total files: 50000
            Total time: 1.510403
            Average time: 0.000030
    
    After applying this patch:
    Create files:
            Total files: 50000
            Total time: 0.932899
            Average time: 0.000019
    Delete files:
            Total files: 50000
            Total time: 1.215732
            Average time: 0.000024
    
    [1] http://marc.info/?l=linux-btrfs&m=128212635122920&q=p3
    
    Many thanks for Kitayama-san's help!
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Reviewed-by: David Sterba <dave@jikos.cz>
    Tested-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Tested-by: Itaru Kitayama <kitayama@cl.bb4u.ne.jp>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0ac712efcdf2..cc5a2a8a5acb 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -40,6 +40,7 @@
 #include <linux/magic.h>
 #include <linux/slab.h>
 #include "compat.h"
+#include "delayed-inode.h"
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -1206,10 +1207,14 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_extent_io;
 
-	err = btrfs_interface_init();
+	err = btrfs_delayed_inode_init();
 	if (err)
 		goto free_extent_map;
 
+	err = btrfs_interface_init();
+	if (err)
+		goto free_delayed_inode;
+
 	err = register_filesystem(&btrfs_fs_type);
 	if (err)
 		goto unregister_ioctl;
@@ -1219,6 +1224,8 @@ static int __init init_btrfs_fs(void)
 
 unregister_ioctl:
 	btrfs_interface_exit();
+free_delayed_inode:
+	btrfs_delayed_inode_exit();
 free_extent_map:
 	extent_map_exit();
 free_extent_io:
@@ -1235,6 +1242,7 @@ static int __init init_btrfs_fs(void)
 static void __exit exit_btrfs_fs(void)
 {
 	btrfs_destroy_cachep();
+	btrfs_delayed_inode_exit();
 	extent_map_exit();
 	extent_io_exit();
 	btrfs_interface_exit();

commit bcd53741cc2af4342ac3ff6983bddc4a1b63b9b4
Author: Arne Jansen <sensille@gmx.net>
Date:   Tue Apr 12 10:43:21 2011 +0200

    btrfs: move btrfs_cmp_device_free_bytes to super.c
    
    this function won't be used here anymore, so move it super.c where it is
    used for df-calculation

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0ac712efcdf2..32fe8b33cc1c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -913,6 +913,32 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	return 0;
 }
 
+/* Used to sort the devices by max_avail(descending sort) */
+static int btrfs_cmp_device_free_bytes(const void *dev_info1,
+				       const void *dev_info2)
+{
+	if (((struct btrfs_device_info *)dev_info1)->max_avail >
+	    ((struct btrfs_device_info *)dev_info2)->max_avail)
+		return -1;
+	else if (((struct btrfs_device_info *)dev_info1)->max_avail <
+		 ((struct btrfs_device_info *)dev_info2)->max_avail)
+		return 1;
+	else
+	return 0;
+}
+
+/*
+ * sort the devices by max_avail, in which max free extent size of each device
+ * is stored.(Descending Sort)
+ */
+static inline void btrfs_descending_sort_devices(
+					struct btrfs_device_info *devices,
+					size_t nr_devices)
+{
+	sort(devices, nr_devices, sizeof(struct btrfs_device_info),
+	     btrfs_cmp_device_free_bytes, NULL);
+}
+
 /*
  * The helper to calc the free space on the devices that can be used to store
  * file data.

commit 306e16ce13c0f3d4fc071b45803b5b83c2606011
Author: David Sterba <dsterba@suse.cz>
Date:   Tue Apr 19 14:29:38 2011 +0200

    btrfs: rename variables clashing with global function names
    
    reported by gcc -Wshadow:
    page_index, page_offset, new_inode, dev_name
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0ac712efcdf2..3e28521643fb 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -739,7 +739,7 @@ static int btrfs_set_super(struct super_block *s, void *data)
  *	  for multiple device setup.  Make sure to keep it in sync.
  */
 static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
-		const char *dev_name, void *data)
+		const char *device_name, void *data)
 {
 	struct block_device *bdev = NULL;
 	struct super_block *s;
@@ -762,7 +762,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	if (error)
 		return ERR_PTR(error);
 
-	error = btrfs_scan_one_device(dev_name, mode, fs_type, &fs_devices);
+	error = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);
 	if (error)
 		goto error_free_subvol_name;
 

commit e15d0542426f063dc53b4c51bdfc11e0bbe4d298
Author: Xin Zhong <xin.zhong@intel.com>
Date:   Wed Apr 6 07:33:51 2011 +0000

    Btrfs: fix subvolume mount by name problem when default mount subvolume is set
    
    We create two subvolumes (meego_root and meego_home) in
    btrfs root directory. And set meego_root as default mount
    subvolume. After we remount btrfs, meego_root is mounted
    to top directory by default. Then when we try to mount
    meego_home (subvol=meego_home) to a subdirectory, it failed.
    The problem is when default mount subvolume is set to
    meego_root, we search meego_home in meego_root but can not find
    it. So the solution is to add a new mount option (subvolrootid)
    to specify subvol id of root and search subvol name in it. For
    our case, now we can use "-o subvolrootid=0,subvol=meego_home)
    to mount meego_home.
    
    Detail information can be found in meego bugzilla:
    https://bugs.meego.com/show_bug.cgi?id=15055
    
    Signed-off-by: Zhong, Xin <xin.zhong@intel.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 58e7de9cc90c..0ac712efcdf2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -159,7 +159,7 @@ enum {
 	Opt_compress_type, Opt_compress_force, Opt_compress_force_type,
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
 	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
-	Opt_enospc_debug, Opt_err,
+	Opt_enospc_debug, Opt_subvolrootid, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -189,6 +189,7 @@ static match_table_t tokens = {
 	{Opt_clear_cache, "clear_cache"},
 	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
 	{Opt_enospc_debug, "enospc_debug"},
+	{Opt_subvolrootid, "subvolrootid=%d"},
 	{Opt_err, NULL},
 };
 
@@ -232,6 +233,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			break;
 		case Opt_subvol:
 		case Opt_subvolid:
+		case Opt_subvolrootid:
 		case Opt_device:
 			/*
 			 * These are parsed by btrfs_parse_early_options
@@ -388,7 +390,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
  */
 static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		void *holder, char **subvol_name, u64 *subvol_objectid,
-		struct btrfs_fs_devices **fs_devices)
+		u64 *subvol_rootid, struct btrfs_fs_devices **fs_devices)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *opts, *orig, *p;
@@ -429,6 +431,18 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 					*subvol_objectid = intarg;
 			}
 			break;
+		case Opt_subvolrootid:
+			intarg = 0;
+			error = match_int(&args[0], &intarg);
+			if (!error) {
+				/* we want the original fs_tree */
+				if (!intarg)
+					*subvol_rootid =
+						BTRFS_FS_TREE_OBJECTID;
+				else
+					*subvol_rootid = intarg;
+			}
+			break;
 		case Opt_device:
 			error = btrfs_scan_one_device(match_strdup(&args[0]),
 					flags, holder, fs_devices);
@@ -736,6 +750,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 	fmode_t mode = FMODE_READ;
 	char *subvol_name = NULL;
 	u64 subvol_objectid = 0;
+	u64 subvol_rootid = 0;
 	int error = 0;
 
 	if (!(flags & MS_RDONLY))
@@ -743,7 +758,7 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 
 	error = btrfs_parse_early_options(data, mode, fs_type,
 					  &subvol_name, &subvol_objectid,
-					  &fs_devices);
+					  &subvol_rootid, &fs_devices);
 	if (error)
 		return ERR_PTR(error);
 
@@ -807,15 +822,17 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		s->s_flags |= MS_ACTIVE;
 	}
 
-	root = get_default_root(s, subvol_objectid);
-	if (IS_ERR(root)) {
-		error = PTR_ERR(root);
-		deactivate_locked_super(s);
-		goto error_free_subvol_name;
-	}
 	/* if they gave us a subvolume name bind mount into that */
 	if (strcmp(subvol_name, ".")) {
 		struct dentry *new_root;
+
+		root = get_default_root(s, subvol_rootid);
+		if (IS_ERR(root)) {
+			error = PTR_ERR(root);
+			deactivate_locked_super(s);
+			goto error_free_subvol_name;
+		}
+
 		mutex_lock(&root->d_inode->i_mutex);
 		new_root = lookup_one_len(subvol_name, root,
 				      strlen(subvol_name));
@@ -836,6 +853,13 @@ static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
 		}
 		dput(root);
 		root = new_root;
+	} else {
+		root = get_default_root(s, subvol_objectid);
+		if (IS_ERR(root)) {
+			error = PTR_ERR(root);
+			deactivate_locked_super(s);
+			goto error_free_subvol_name;
+		}
 	}
 
 	kfree(subvol_name);

commit 200da64e0b039f873f0f20481e6a7d056e7cc6c9
Author: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
Date:   Thu Mar 31 00:44:29 2011 +0000

    Btrfs: fix /proc/mounts info.
    
    Some mount options are not displayed by /proc/mounts.
    This patch displays the option such as compress_type by /proc/mounts.
    
    Ex.
      [before]
        $ mount | grep sdc2
        /dev/sdc2 on /test12 type btrfs (rw,space_cache,compress=lzo)
        $ cat /proc/mounts | grep sdc2
        /dev/sdc2 /test12 btrfs rw,relatime,compress 0 0
    
      [after]
        $ mount | grep sdc2
        /dev/sdc2 on /test12 type btrfs (rw,space_cache,compress=lzo)
        $ cat /proc/mounts | grep sdc2
        /dev/sdc2 /test12 btrfs rw,relatime,compress=lzo,space_cache 0 0
    
    Signed-off-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2edfc039f098..58e7de9cc90c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -644,6 +644,7 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 {
 	struct btrfs_root *root = btrfs_sb(vfs->mnt_sb);
 	struct btrfs_fs_info *info = root->fs_info;
+	char *compress_type;
 
 	if (btrfs_test_opt(root, DEGRADED))
 		seq_puts(seq, ",degraded");
@@ -662,8 +663,16 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 	if (info->thread_pool_size !=  min_t(unsigned long,
 					     num_online_cpus() + 2, 8))
 		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);
-	if (btrfs_test_opt(root, COMPRESS))
-		seq_puts(seq, ",compress");
+	if (btrfs_test_opt(root, COMPRESS)) {
+		if (info->compress_type == BTRFS_COMPRESS_ZLIB)
+			compress_type = "zlib";
+		else
+			compress_type = "lzo";
+		if (btrfs_test_opt(root, FORCE_COMPRESS))
+			seq_printf(seq, ",compress-force=%s", compress_type);
+		else
+			seq_printf(seq, ",compress=%s", compress_type);
+	}
 	if (btrfs_test_opt(root, NOSSD))
 		seq_puts(seq, ",nossd");
 	if (btrfs_test_opt(root, SSD_SPREAD))
@@ -678,6 +687,12 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_puts(seq, ",discard");
 	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
 		seq_puts(seq, ",noacl");
+	if (btrfs_test_opt(root, SPACE_CACHE))
+		seq_puts(seq, ",space_cache");
+	if (btrfs_test_opt(root, CLEAR_CACHE))
+		seq_puts(seq, ",clear_cache");
+	if (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))
+		seq_puts(seq, ",user_subvol_rm_allowed");
 	return 0;
 }
 

commit 1abe9b8a138c9988ba8f7bfded6453649a31541f
Author: liubo <liubo2009@cn.fujitsu.com>
Date:   Thu Mar 24 11:18:59 2011 +0000

    Btrfs: add initial tracepoint support for btrfs
    
    Tracepoints can provide insight into why btrfs hits bugs and be greatly
    helpful for debugging, e.g
                  dd-7822  [000]  2121.641088: btrfs_inode_request: root = 5(FS_TREE), gen = 4, ino = 256, blocks = 8, disk_i_size = 0, last_trans = 8, logged_trans = 0
                  dd-7822  [000]  2121.641100: btrfs_inode_new: root = 5(FS_TREE), gen = 8, ino = 257, blocks = 0, disk_i_size = 0, last_trans = 0, logged_trans = 0
     btrfs-transacti-7804  [001]  2146.935420: btrfs_cow_block: root = 2(EXTENT_TREE), refs = 2, orig_buf = 29368320 (orig_level = 0), cow_buf = 29388800 (cow_level = 0)
     btrfs-transacti-7804  [001]  2146.935473: btrfs_cow_block: root = 1(ROOT_TREE), refs = 2, orig_buf = 29364224 (orig_level = 0), cow_buf = 29392896 (cow_level = 0)
     btrfs-transacti-7804  [001]  2146.972221: btrfs_transaction_commit: root = 1(ROOT_TREE), gen = 8
       flush-btrfs-2-7821  [001]  2155.824210: btrfs_chunk_alloc: root = 3(CHUNK_TREE), offset = 1103101952, size = 1073741824, num_stripes = 1, sub_stripes = 0, type = DATA
       flush-btrfs-2-7821  [001]  2155.824241: btrfs_cow_block: root = 2(EXTENT_TREE), refs = 2, orig_buf = 29388800 (orig_level = 0), cow_buf = 29396992 (cow_level = 0)
       flush-btrfs-2-7821  [001]  2155.824255: btrfs_cow_block: root = 4(DEV_TREE), refs = 2, orig_buf = 29372416 (orig_level = 0), cow_buf = 29401088 (cow_level = 0)
       flush-btrfs-2-7821  [000]  2155.824329: btrfs_cow_block: root = 3(CHUNK_TREE), refs = 2, orig_buf = 20971520 (orig_level = 0), cow_buf = 20975616 (cow_level = 0)
     btrfs-endio-wri-7800  [001]  2155.898019: btrfs_cow_block: root = 5(FS_TREE), refs = 2, orig_buf = 29384704 (orig_level = 0), cow_buf = 29405184 (cow_level = 0)
     btrfs-endio-wri-7800  [001]  2155.898043: btrfs_cow_block: root = 7(CSUM_TREE), refs = 2, orig_buf = 29376512 (orig_level = 0), cow_buf = 29409280 (cow_level = 0)
    
    Here is what I have added:
    
    1) ordere_extent:
            btrfs_ordered_extent_add
            btrfs_ordered_extent_remove
            btrfs_ordered_extent_start
            btrfs_ordered_extent_put
    
    These provide critical information to understand how ordered_extents are
    updated.
    
    2) extent_map:
            btrfs_get_extent
    
    extent_map is used in both read and write cases, and it is useful for tracking
    how btrfs specific IO is running.
    
    3) writepage:
            __extent_writepage
            btrfs_writepage_end_io_hook
    
    Pages are cirtical resourses and produce a lot of corner cases during writeback,
    so it is valuable to know how page is written to disk.
    
    4) inode:
            btrfs_inode_new
            btrfs_inode_request
            btrfs_inode_evict
    
    These can show where and when a inode is created, when a inode is evicted.
    
    5) sync:
            btrfs_sync_file
            btrfs_sync_fs
    
    These show sync arguments.
    
    6) transaction:
            btrfs_transaction_commit
    
    In transaction based filesystem, it will be useful to know the generation and
    who does commit.
    
    7) back reference and cow:
            btrfs_delayed_tree_ref
            btrfs_delayed_data_ref
            btrfs_delayed_ref_head
            btrfs_cow_block
    
    Btrfs natively supports back references, these tracepoints are helpful on
    understanding btrfs's COW mechanism.
    
    8) chunk:
            btrfs_chunk_alloc
            btrfs_chunk_free
    
    Chunk is a link between physical offset and logical offset, and stands for space
    infomation in btrfs, and these are helpful on tracing space things.
    
    9) reserved_extent:
            btrfs_reserved_extent_alloc
            btrfs_reserved_extent_free
    
    These can show how btrfs uses its space.
    
    Signed-off-by: Liu Bo <liubo2009@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d39a9895d932..2edfc039f098 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -52,6 +52,9 @@
 #include "export.h"
 #include "compression.h"
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/btrfs.h>
+
 static const struct super_operations btrfs_super_ops;
 
 static const char *btrfs_decode_error(struct btrfs_fs_info *fs_info, int errno,
@@ -620,6 +623,8 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	struct btrfs_root *root = btrfs_sb(sb);
 	int ret;
 
+	trace_btrfs_sync_fs(wait);
+
 	if (!wait) {
 		filemap_flush(root->fs_info->btree_inode->i_mapping);
 		return 0;

commit 4660ba63f1c4e07c20a435e084f12ba48a82bd2b
Merge: 958ede7f1b72 ec29ed5b407d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 25 14:03:39 2011 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: fix fiemap bugs with delalloc
      Btrfs: set FMODE_EXCL in btrfs_device->mode
      Btrfs: make btrfs_rm_device() fail gracefully
      Btrfs: Avoid accessing unmapped kernel address
      Btrfs: Fix BTRFS_IOC_SUBVOL_SETFLAGS ioctl
      Btrfs: allow balance to explicitly allocate chunks as it relocates
      Btrfs: put ENOSPC debugging under a mount option

commit 91435650c233b93e0da389db74f4b2c11c5ad2d4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Feb 16 13:10:41 2011 -0500

    Btrfs: put ENOSPC debugging under a mount option
    
    ENOSPC in btrfs is getting to the point where the extra debugging isn't
    required.  I've put it under mount -o enospc_debug just in case someone
    is having difficult problems.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0209b5fc772c..db0a827252bd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -155,7 +155,8 @@ enum {
 	Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl, Opt_compress,
 	Opt_compress_type, Opt_compress_force, Opt_compress_force_type,
 	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
-	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed, Opt_err,
+	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
+	Opt_enospc_debug, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -184,6 +185,7 @@ static match_table_t tokens = {
 	{Opt_space_cache, "space_cache"},
 	{Opt_clear_cache, "clear_cache"},
 	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
+	{Opt_enospc_debug, "enospc_debug"},
 	{Opt_err, NULL},
 };
 
@@ -358,6 +360,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_user_subvol_rm_allowed:
 			btrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);
 			break;
+		case Opt_enospc_debug:
+			btrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);

commit cb5520f02c010e3cb974b9ac06f30aafa2eebc38
Merge: eee4da2cef8e 3a90983dbdcb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 7 14:06:18 2011 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (33 commits)
      Btrfs: Fix page count calculation
      btrfs: Drop __exit attribute on btrfs_exit_compress
      btrfs: cleanup error handling in btrfs_unlink_inode()
      Btrfs: exclude super blocks when we read in block groups
      Btrfs: make sure search_bitmap finds something in remove_from_bitmap
      btrfs: fix return value check of btrfs_start_transaction()
      btrfs: checking NULL or not in some functions
      Btrfs: avoid uninit variable warnings in ordered-data.c
      Btrfs: catch errors from btrfs_sync_log
      Btrfs: make shrink_delalloc a little friendlier
      Btrfs: handle no memory properly in prepare_pages
      Btrfs: do error checking in btrfs_del_csums
      Btrfs: use the global block reserve if we cannot reserve space
      Btrfs: do not release more reserved bytes to the global_block_rsv than we need
      Btrfs: fix check_path_shared so it returns the right value
      btrfs: check return value of btrfs_start_ioctl_transaction() properly
      btrfs: fix return value check of btrfs_join_transaction()
      fs/btrfs/inode.c: Add missing IS_ERR test
      btrfs: fix missing break in switch phrase
      btrfs: fix several uncheck memory allocations
      ...

commit 98d5dc13e7e74b77ca3b4c3cbded9f48d2dbbbb7
Author: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
Date:   Thu Jan 20 06:19:37 2011 +0000

    btrfs: fix return value check of btrfs_start_transaction()
    
    The error check of btrfs_start_transaction() is added, and the mistake
    of the error check on several places is corrected.
    
    Signed-off-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f4e45fdded30..0209b5fc772c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -623,6 +623,8 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	btrfs_wait_ordered_extents(root, 0, 0);
 
 	trans = btrfs_start_transaction(root, 0);
+	if (IS_ERR(trans))
+		return PTR_ERR(trans);
 	ret = btrfs_commit_transaction(trans, root);
 	return ret;
 }

commit eab49bec41136460b12ac0fbeceeb88386d538c7
Merge: acce952b0263 4d728ec7aefd
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jan 28 16:24:59 2011 -0500

    Merge branch 'bug-fixes' of git://repo.or.cz/linux-btrfs-devel into btrfs-38

commit 3f3d0bc0df041236fad4ffa82188a6e4ef9af75e
Author: Tero Roponen <tero.roponen@gmail.com>
Date:   Mon Dec 27 16:43:13 2010 +0800

    Btrfs: Free correct pointer after using strsep
    
    We must save and free the original kstrdup()'ed pointer
    because strsep() modifies its first argument.
    
    Signed-off-by: Tero Roponen <tero.roponen@gmail.com>
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f50253c2279d..78ee681465af 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -277,7 +277,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		struct btrfs_fs_devices **fs_devices)
 {
 	substring_t args[MAX_OPT_ARGS];
-	char *opts, *p;
+	char *opts, *orig, *p;
 	int error = 0;
 	int intarg;
 
@@ -291,6 +291,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 	opts = kstrdup(options, GFP_KERNEL);
 	if (!opts)
 		return -ENOMEM;
+	orig = opts;
 
 	while ((p = strsep(&opts, ",")) != NULL) {
 		int token;
@@ -326,7 +327,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 	}
 
  out_free_opts:
-	kfree(opts);
+	kfree(orig);
  out:
 	/*
 	 * If no subvolume name is specified we use the default one.  Allocate

commit bdc924bb4cdac92b945945c3149ab8191c92d75d
Author: Ian Kent <raven@themaw.net>
Date:   Mon Dec 27 16:33:15 2010 +0800

    Btrfs: Fix memory leak on finding existing super
    
    We missed a memory deallocation in commit 450ba0ea.
    
    If an existing super block is found at mount and there is no
    error condition then the pre-allocated tree_root and fs_info
    are no not used and are not freeded.
    
    Signed-off-by: Ian Kent <raven@themaw.net>
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 61bd79abb805..f50253c2279d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -654,6 +654,8 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		}
 
 		btrfs_close_devices(fs_devices);
+		kfree(fs_info);
+		kfree(tree_root);
 	} else {
 		char b[BDEVNAME_SIZE];
 

commit eee2a817df7c5a6e569f353f8be78cc1b3604bb6
Merge: 83896fb5e515 acce952b0263
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 17 14:43:43 2011 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (25 commits)
      Btrfs: forced readonly mounts on errors
      btrfs: Require CAP_SYS_ADMIN for filesystem rebalance
      Btrfs: don't warn if we get ENOSPC in btrfs_block_rsv_check
      btrfs: Fix memory leak in btrfs_read_fs_root_no_radix()
      btrfs: check NULL or not
      btrfs: Don't pass NULL ptr to func that may deref it.
      btrfs: mount failure return value fix
      btrfs: Mem leak in btrfs_get_acl()
      btrfs: fix wrong free space information of btrfs
      btrfs: make the chunk allocator utilize the devices better
      btrfs: restructure find_free_dev_extent()
      btrfs: fix wrong calculation of stripe size
      btrfs: try to reclaim some space when chunk allocation fails
      btrfs: fix wrong data space statistics
      fs/btrfs: Fix build of ctree
      Btrfs: fix off by one while setting block groups readonly
      Btrfs: Add BTRFS_IOC_SUBVOL_GETFLAGS/SETFLAGS ioctls
      Btrfs: Add readonly snapshots support
      Btrfs: Refactor btrfs_ioctl_snap_create()
      btrfs: Extract duplicate decompress code
      ...

commit acce952b0263825da32cf10489413dec78053347
Author: liubo <liubo2009@cn.fujitsu.com>
Date:   Thu Jan 6 19:30:25 2011 +0800

    Btrfs: forced readonly mounts on errors
    
    This patch comes from "Forced readonly mounts on errors" ideas.
    
    As we know, this is the first step in being more fault tolerant of disk
    corruptions instead of just using BUG() statements.
    
    The major content:
    - add a framework for generating errors that should result in filesystems
      going readonly.
    - keep FS state in disk super block.
    - make sure that all of resource will be freed and released at umount time.
    - make sure that fter FS is forced readonly on error, there will be no more
      disk change before FS is corrected. For this, we should stop write operation.
    
    After this patch is applied, the conversion from BUG() to such a framework can
    happen incrementally.
    
    Signed-off-by: Liu Bo <liubo2009@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2963376e77f4..52e903b0a293 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -54,6 +54,90 @@
 
 static const struct super_operations btrfs_super_ops;
 
+static const char *btrfs_decode_error(struct btrfs_fs_info *fs_info, int errno,
+				      char nbuf[16])
+{
+	char *errstr = NULL;
+
+	switch (errno) {
+	case -EIO:
+		errstr = "IO failure";
+		break;
+	case -ENOMEM:
+		errstr = "Out of memory";
+		break;
+	case -EROFS:
+		errstr = "Readonly filesystem";
+		break;
+	default:
+		if (nbuf) {
+			if (snprintf(nbuf, 16, "error %d", -errno) >= 0)
+				errstr = nbuf;
+		}
+		break;
+	}
+
+	return errstr;
+}
+
+static void __save_error_info(struct btrfs_fs_info *fs_info)
+{
+	/*
+	 * today we only save the error info into ram.  Long term we'll
+	 * also send it down to the disk
+	 */
+	fs_info->fs_state = BTRFS_SUPER_FLAG_ERROR;
+}
+
+/* NOTE:
+ *	We move write_super stuff at umount in order to avoid deadlock
+ *	for umount hold all lock.
+ */
+static void save_error_info(struct btrfs_fs_info *fs_info)
+{
+	__save_error_info(fs_info);
+}
+
+/* btrfs handle error by forcing the filesystem readonly */
+static void btrfs_handle_error(struct btrfs_fs_info *fs_info)
+{
+	struct super_block *sb = fs_info->sb;
+
+	if (sb->s_flags & MS_RDONLY)
+		return;
+
+	if (fs_info->fs_state & BTRFS_SUPER_FLAG_ERROR) {
+		sb->s_flags |= MS_RDONLY;
+		printk(KERN_INFO "btrfs is forced readonly\n");
+	}
+}
+
+/*
+ * __btrfs_std_error decodes expected errors from the caller and
+ * invokes the approciate error response.
+ */
+void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
+		     unsigned int line, int errno)
+{
+	struct super_block *sb = fs_info->sb;
+	char nbuf[16];
+	const char *errstr;
+
+	/*
+	 * Special case: if the error is EROFS, and we're already
+	 * under MS_RDONLY, then it is safe here.
+	 */
+	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
+		return;
+
+	errstr = btrfs_decode_error(fs_info, errno, nbuf);
+	printk(KERN_CRIT "BTRFS error (device %s) in %s:%d: %s\n",
+		sb->s_id, function, line, errstr);
+	save_error_info(fs_info);
+
+	btrfs_handle_error(fs_info);
+}
+
 static void btrfs_put_super(struct super_block *sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);

commit 6d07bcec969af335d4e35b3921131b7929bd634e
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Jan 5 10:07:31 2011 +0000

    btrfs: fix wrong free space information of btrfs
    
    When we store data by raid profile in btrfs with two or more different size
    disks, df command shows there is some free space in the filesystem, but the
    user can not write any data in fact, df command shows the wrong free space
    information of btrfs.
    
     # mkfs.btrfs -d raid1 /dev/sda9 /dev/sda10
     # btrfs-show
     Label: none  uuid: a95cd49e-6e33-45b8-8741-a36153ce4b64
            Total devices 2 FS bytes used 28.00KB
            devid    1 size 5.01GB used 2.03GB path /dev/sda9
            devid    2 size 10.00GB used 2.01GB path /dev/sda10
     # btrfs device scan /dev/sda9 /dev/sda10
     # mount /dev/sda9 /mnt
     # dd if=/dev/zero of=tmpfile0 bs=4K count=9999999999
       (fill the filesystem)
     # sync
     # df -TH
     Filesystem     Type    Size    Used    Avail   Use%    Mounted on
     /dev/sda9      btrfs   17G     8.6G    5.4G    62%     /mnt
     # btrfs-show
     Label: none  uuid: a95cd49e-6e33-45b8-8741-a36153ce4b64
            Total devices 2 FS bytes used 3.99GB
            devid    1 size 5.01GB used 5.01GB path /dev/sda9
            devid    2 size 10.00GB used 4.99GB path /dev/sda10
    
    It is because btrfs cannot allocate chunks when one of the pairing disks has
    no space, the free space on the other disks can not be used for ever, and should
    be subtracted from the total space, but btrfs doesn't subtract this space from
    the total. It is strange to the user.
    
    This patch fixes it by calcing the free space that can be used to allocate
    chunks.
    
    Implementation:
    1. get all the devices free space, and align them by stripe length.
    2. sort the devices by the free space.
    3. check the free space of the devices,
       3.1. if it is not zero, and then check the number of the devices that has
            more free space than this device,
            if the number of the devices is beyond the min stripe number, the free
            space can be used, and add into total free space.
            if the number of the devices is below the min stripe number, we can not
            use the free space, the check ends.
       3.2. if the free space is zero, check the next devices, goto 3.1
    
    This implementation is just likely fake chunk allocation.
    
    After appling this patch, df can show correct space information:
     # df -TH
     Filesystem     Type    Size    Used    Avail   Use%    Mounted on
     /dev/sda9      btrfs   17G     8.6G    0       100%    /mnt
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index caa5bcc62f16..2963376e77f4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -777,6 +777,127 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	return 0;
 }
 
+/*
+ * The helper to calc the free space on the devices that can be used to store
+ * file data.
+ */
+static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)
+{
+	struct btrfs_fs_info *fs_info = root->fs_info;
+	struct btrfs_device_info *devices_info;
+	struct btrfs_fs_devices *fs_devices = fs_info->fs_devices;
+	struct btrfs_device *device;
+	u64 skip_space;
+	u64 type;
+	u64 avail_space;
+	u64 used_space;
+	u64 min_stripe_size;
+	int min_stripes = 1;
+	int i = 0, nr_devices;
+	int ret;
+
+	nr_devices = fs_info->fs_devices->rw_devices;
+	BUG_ON(!nr_devices);
+
+	devices_info = kmalloc(sizeof(*devices_info) * nr_devices,
+			       GFP_NOFS);
+	if (!devices_info)
+		return -ENOMEM;
+
+	/* calc min stripe number for data space alloction */
+	type = btrfs_get_alloc_profile(root, 1);
+	if (type & BTRFS_BLOCK_GROUP_RAID0)
+		min_stripes = 2;
+	else if (type & BTRFS_BLOCK_GROUP_RAID1)
+		min_stripes = 2;
+	else if (type & BTRFS_BLOCK_GROUP_RAID10)
+		min_stripes = 4;
+
+	if (type & BTRFS_BLOCK_GROUP_DUP)
+		min_stripe_size = 2 * BTRFS_STRIPE_LEN;
+	else
+		min_stripe_size = BTRFS_STRIPE_LEN;
+
+	list_for_each_entry(device, &fs_devices->alloc_list, dev_alloc_list) {
+		if (!device->in_fs_metadata)
+			continue;
+
+		avail_space = device->total_bytes - device->bytes_used;
+
+		/* align with stripe_len */
+		do_div(avail_space, BTRFS_STRIPE_LEN);
+		avail_space *= BTRFS_STRIPE_LEN;
+
+		/*
+		 * In order to avoid overwritting the superblock on the drive,
+		 * btrfs starts at an offset of at least 1MB when doing chunk
+		 * allocation.
+		 */
+		skip_space = 1024 * 1024;
+
+		/* user can set the offset in fs_info->alloc_start. */
+		if (fs_info->alloc_start + BTRFS_STRIPE_LEN <=
+		    device->total_bytes)
+			skip_space = max(fs_info->alloc_start, skip_space);
+
+		/*
+		 * btrfs can not use the free space in [0, skip_space - 1],
+		 * we must subtract it from the total. In order to implement
+		 * it, we account the used space in this range first.
+		 */
+		ret = btrfs_account_dev_extents_size(device, 0, skip_space - 1,
+						     &used_space);
+		if (ret) {
+			kfree(devices_info);
+			return ret;
+		}
+
+		/* calc the free space in [0, skip_space - 1] */
+		skip_space -= used_space;
+
+		/*
+		 * we can use the free space in [0, skip_space - 1], subtract
+		 * it from the total.
+		 */
+		if (avail_space && avail_space >= skip_space)
+			avail_space -= skip_space;
+		else
+			avail_space = 0;
+
+		if (avail_space < min_stripe_size)
+			continue;
+
+		devices_info[i].dev = device;
+		devices_info[i].max_avail = avail_space;
+
+		i++;
+	}
+
+	nr_devices = i;
+
+	btrfs_descending_sort_devices(devices_info, nr_devices);
+
+	i = nr_devices - 1;
+	avail_space = 0;
+	while (nr_devices >= min_stripes) {
+		if (devices_info[i].max_avail >= min_stripe_size) {
+			int j;
+			u64 alloc_size;
+
+			avail_space += devices_info[i].max_avail * min_stripes;
+			alloc_size = devices_info[i].max_avail;
+			for (j = i + 1 - min_stripes; j <= i; j++)
+				devices_info[j].max_avail -= alloc_size;
+		}
+		i--;
+		nr_devices--;
+	}
+
+	kfree(devices_info);
+	*free_bytes = avail_space;
+	return 0;
+}
+
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
@@ -784,16 +905,21 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct list_head *head = &root->fs_info->space_info;
 	struct btrfs_space_info *found;
 	u64 total_used = 0;
-	u64 total_used_data = 0;
+	u64 total_free_data = 0;
 	int bits = dentry->d_sb->s_blocksize_bits;
 	__be32 *fsid = (__be32 *)root->fs_info->fsid;
+	int ret;
 
+	/* holding chunk_muext to avoid allocating new chunks */
+	mutex_lock(&root->fs_info->chunk_mutex);
 	rcu_read_lock();
 	list_for_each_entry_rcu(found, head, list) {
-		if (found->flags & BTRFS_BLOCK_GROUP_DATA)
-			total_used_data += found->disk_used;
-		else
-			total_used_data += found->disk_total;
+		if (found->flags & BTRFS_BLOCK_GROUP_DATA) {
+			total_free_data += found->disk_total - found->disk_used;
+			total_free_data -=
+				btrfs_account_ro_block_groups_free_space(found);
+		}
+
 		total_used += found->disk_used;
 	}
 	rcu_read_unlock();
@@ -801,9 +927,17 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_namelen = BTRFS_NAME_LEN;
 	buf->f_blocks = btrfs_super_total_bytes(disk_super) >> bits;
 	buf->f_bfree = buf->f_blocks - (total_used >> bits);
-	buf->f_bavail = buf->f_blocks - (total_used_data >> bits);
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_type = BTRFS_SUPER_MAGIC;
+	buf->f_bavail = total_free_data;
+	ret = btrfs_calc_avail_data_space(root, &total_free_data);
+	if (ret) {
+		mutex_unlock(&root->fs_info->chunk_mutex);
+		return ret;
+	}
+	buf->f_bavail += total_free_data;
+	buf->f_bavail = buf->f_bavail >> bits;
+	mutex_unlock(&root->fs_info->chunk_mutex);
 
 	/* We treat it as constant endianness (it doesn't matter _which_)
 	   because we want the fsid to come out the same whether mounted

commit 299a08b1c34f9397797946a0fa215c5fd145c5cf
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Jan 5 10:07:15 2011 +0000

    btrfs: fix wrong data space statistics
    
    Josef has implemented mixed data/metadata chunks, we must add those chunks'
    space just like data chunks.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Reviewed-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a1a76b2a61f9..caa5bcc62f16 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -790,11 +790,10 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(found, head, list) {
-		if (found->flags & (BTRFS_BLOCK_GROUP_METADATA |
-				    BTRFS_BLOCK_GROUP_SYSTEM))
-			total_used_data += found->disk_total;
-		else
+		if (found->flags & BTRFS_BLOCK_GROUP_DATA)
 			total_used_data += found->disk_used;
+		else
+			total_used_data += found->disk_total;
 		total_used += found->disk_used;
 	}
 	rcu_read_unlock();

commit af53d29ac13a97304d44343dc3b26154ca595268
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 20 10:56:06 2010 -0500

    switch btrfs, close races
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 883c6fa1367e..22acdaa78ce1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -460,6 +460,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	sb->s_magic = BTRFS_SUPER_MAGIC;
 	sb->s_op = &btrfs_super_ops;
+	sb->s_d_op = &btrfs_dentry_operations;
 	sb->s_export_op = &btrfs_export_ops;
 	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;

commit a6fa6fae40ec336c7df6155255ae64ebef43a8bc
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Mon Oct 25 15:12:26 2010 +0800

    btrfs: Add lzo compression support
    
    Lzo is a much faster compression algorithm than gzib, so would allow
    more users to enable transparent compression, and some users can
    choose from compression ratio and speed for different applications
    
    Usage:
    
     # mount -t btrfs -o compress[=<zlib,lzo>] dev /mnt
    or
     # mount -t btrfs -o compress-force[=<zlib,lzo>] dev /mnt
    
    "-o compress" without argument is still allowed for compatability.
    
    Compatibility:
    
    If we mount a filesystem with lzo compression, it will not be able be
    mounted in old kernels. One reason is, otherwise btrfs will directly
    dump compressed data, which sits in inline extent, to user.
    
    Performance:
    
    The test copied a linux source tarball (~400M) from an ext4 partition
    to the btrfs partition, and then extracted it.
    
    (time in second)
               lzo        zlib        nocompress
    copy:      10.6       21.7        14.9
    extract:   70.1       94.4        66.6
    
    (data size in MB)
               lzo        zlib        nocompress
    copy:      185.87     108.69      394.49
    extract:   193.80     132.36      381.21
    
    Changelog:
    
    v1 -> v2:
    - Select LZO_COMPRESS and LZO_DECOMPRESS in btrfs Kconfig.
    - Add incompability flag.
    - Fix error handling in compress code.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f348f2b93164..a1a76b2a61f9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -168,6 +168,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			    strcmp(args[0].from, "zlib") == 0) {
 				compress_type = "zlib";
 				info->compress_type = BTRFS_COMPRESS_ZLIB;
+			} else if (strcmp(args[0].from, "lzo") == 0) {
+				compress_type = "lzo";
+				info->compress_type = BTRFS_COMPRESS_LZO;
 			} else {
 				ret = -EINVAL;
 				goto out;

commit 261507a02ccba9afda919852263b6bc1581ce1ef
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri Dec 17 14:21:50 2010 +0800

    btrfs: Allow to add new compression algorithm
    
    Make the code aware of compression type, instead of always assuming
    zlib compression.
    
    Also make the zlib workspace function as common code for all
    compression types.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 61bd79abb805..f348f2b93164 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -69,9 +69,9 @@ enum {
 	Opt_degraded, Opt_subvol, Opt_subvolid, Opt_device, Opt_nodatasum,
 	Opt_nodatacow, Opt_max_inline, Opt_alloc_start, Opt_nobarrier, Opt_ssd,
 	Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl, Opt_compress,
-	Opt_compress_force, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
-	Opt_discard, Opt_space_cache, Opt_clear_cache, Opt_err,
-	Opt_user_subvol_rm_allowed,
+	Opt_compress_type, Opt_compress_force, Opt_compress_force_type,
+	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_discard,
+	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -86,7 +86,9 @@ static match_table_t tokens = {
 	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_thread_pool, "thread_pool=%d"},
 	{Opt_compress, "compress"},
+	{Opt_compress_type, "compress=%s"},
 	{Opt_compress_force, "compress-force"},
+	{Opt_compress_force_type, "compress-force=%s"},
 	{Opt_ssd, "ssd"},
 	{Opt_ssd_spread, "ssd_spread"},
 	{Opt_nossd, "nossd"},
@@ -112,6 +114,8 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	char *p, *num, *orig;
 	int intarg;
 	int ret = 0;
+	char *compress_type;
+	bool compress_force = false;
 
 	if (!options)
 		return 0;
@@ -154,14 +158,29 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, NODATACOW);
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
-		case Opt_compress:
-			printk(KERN_INFO "btrfs: use compression\n");
-			btrfs_set_opt(info->mount_opt, COMPRESS);
-			break;
 		case Opt_compress_force:
-			printk(KERN_INFO "btrfs: forcing compression\n");
-			btrfs_set_opt(info->mount_opt, FORCE_COMPRESS);
+		case Opt_compress_force_type:
+			compress_force = true;
+		case Opt_compress:
+		case Opt_compress_type:
+			if (token == Opt_compress ||
+			    token == Opt_compress_force ||
+			    strcmp(args[0].from, "zlib") == 0) {
+				compress_type = "zlib";
+				info->compress_type = BTRFS_COMPRESS_ZLIB;
+			} else {
+				ret = -EINVAL;
+				goto out;
+			}
+
 			btrfs_set_opt(info->mount_opt, COMPRESS);
+			if (compress_force) {
+				btrfs_set_opt(info->mount_opt, FORCE_COMPRESS);
+				pr_info("btrfs: force %s compression\n",
+					compress_type);
+			} else
+				pr_info("btrfs: use %s compression\n",
+					compress_type);
 			break;
 		case Opt_ssd:
 			printk(KERN_INFO "btrfs: use ssd allocation scheme\n");
@@ -898,10 +917,14 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		return err;
 
-	err = btrfs_init_cachep();
+	err = btrfs_init_compress();
 	if (err)
 		goto free_sysfs;
 
+	err = btrfs_init_cachep();
+	if (err)
+		goto free_compress;
+
 	err = extent_io_init();
 	if (err)
 		goto free_cachep;
@@ -929,6 +952,8 @@ static int __init init_btrfs_fs(void)
 	extent_io_exit();
 free_cachep:
 	btrfs_destroy_cachep();
+free_compress:
+	btrfs_exit_compress();
 free_sysfs:
 	btrfs_exit_sysfs();
 	return err;
@@ -943,7 +968,7 @@ static void __exit exit_btrfs_fs(void)
 	unregister_filesystem(&btrfs_fs_type);
 	btrfs_exit_sysfs();
 	btrfs_cleanup_fs_uuids();
-	btrfs_zlib_exit();
+	btrfs_exit_compress();
 }
 
 module_init(init_btrfs_fs)

commit e13cf63f2bbd38721af557f0205da994ea068427
Merge: 073f21ae1319 83a50de97fe9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 14 11:08:13 2010 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: prevent RAID level downgrades when space is low
      Btrfs: account for missing devices in RAID allocation profiles
      Btrfs: EIO when we fail to read tree roots
      Btrfs: fix compiler warnings
      Btrfs: Make async snapshot ioctl more generic
      Btrfs: pwrite blocked when writing from the mmaped buffer of the same page
      Btrfs: Fix a crash when mounting a subvolume
      Btrfs: fix sync subvol/snapshot creation
      Btrfs: Fix page leak in compressed writeback path
      Btrfs: do not BUG if we fail to remove the orphan item for dead snapshots
      Btrfs: fixup return code for btrfs_del_orphan_item
      Btrfs: do not do fast caching if we are allocating blocks for tree_root
      Btrfs: deal with space cache errors better
      Btrfs: fix use after free in O_DIRECT

commit f106e82caaa0d943e47cacc184f5b40d538e0044
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Tue Dec 7 01:51:26 2010 +0000

    Btrfs: Fix a crash when mounting a subvolume
    
    We should drop dentry before deactivating the superblock, otherwise
    we can hit this bug:
    
    BUG: Dentry f349a690{i=100,n=/} still in use (1) [unmount of btrfs loop1]
    ...
    
    Steps to reproduce the bug:
    
      # mount /dev/loop1 /mnt
      # mkdir save
      # btrfs subvolume snapshot /mnt save/snap1
      # umount /mnt
      # mount -o subvol=save/snap1 /dev/loop1 /mnt
      (crash)
    
    Reported-by: Michael Niederle <mniederle@gmx.at>
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 47bf67cbe6bf..61bd79abb805 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -685,9 +685,9 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		mutex_unlock(&root->d_inode->i_mutex);
 
 		if (IS_ERR(new_root)) {
+			dput(root);
 			deactivate_locked_super(s);
 			error = PTR_ERR(new_root);
-			dput(root);
 			goto error_free_subvol_name;
 		}
 		if (!new_root->d_inode) {

commit aa3fc52546b847f590d86a093afd863ff9081628
Merge: 555bdaefd52c 5a92bc88cef2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 29 14:11:08 2010 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (24 commits)
      Btrfs: don't use migrate page without CONFIG_MIGRATION
      Btrfs: deal with DIO bios that span more than one ordered extent
      Btrfs: setup blank root and fs_info for mount time
      Btrfs: fix fiemap
      Btrfs - fix race between btrfs_get_sb() and umount
      Btrfs: update inode ctime when using links
      Btrfs: make sure new inode size is ok in fallocate
      Btrfs: fix typo in fallocate to make it honor actual size
      Btrfs: avoid NULL pointer deref in try_release_extent_buffer
      Btrfs: make btrfs_add_nondir take parent inode as an argument
      Btrfs: hold i_mutex when calling btrfs_log_dentry_safe
      Btrfs: use dget_parent where we can UPDATED
      Btrfs: fix more ESTALE problems with NFS
      Btrfs: handle NFS lookups properly
      btrfs: make 1-bit signed fileds unsigned
      btrfs: Show device attr correctly for symlinks
      btrfs: Set file size correctly in file clone
      btrfs: Check if dest_offset is block-size aligned before cloning file
      Btrfs: handle the space_cache option properly
      btrfs: Fix early enospc because 'unused' calculated with wrong sign.
      ...

commit 450ba0ea06b6ed3612d27f2b7127a9de4160f285
Author: Josef Bacik <josef@redhat.com>
Date:   Fri Nov 19 14:59:15 2010 -0500

    Btrfs: setup blank root and fs_info for mount time
    
    There is a problem with how we use sget, it searches through the list of supers
    attached to the fs_type looking for a super with the same fs_devices as what
    we're trying to mount.  This depends on sb->s_fs_info being filled, but we don't
    fill that in until we get to btrfs_fill_super, so we could hit supers on the
    fs_type super list that have a null s_fs_info.  In order to fix that we need to
    go ahead and setup a blank root with a blank fs_info to hold fs_devices, that
    way our test will work out right and then we can set s_fs_info in
    btrfs_set_super, and then open_ctree will simply use our pre-allocated root and
    fs_info when setting everything up.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 141fb317d3bc..47bf67cbe6bf 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -563,7 +563,7 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 
 static int btrfs_test_super(struct super_block *s, void *data)
 {
-	struct btrfs_fs_devices *test_fs_devices = data;
+	struct btrfs_root *test_root = data;
 	struct btrfs_root *root = btrfs_sb(s);
 
 	/*
@@ -572,9 +572,17 @@ static int btrfs_test_super(struct super_block *s, void *data)
 	 */
 	if (!atomic_read(&s->s_active))
 		return 0;
-	return root->fs_info->fs_devices == test_fs_devices;
+	return root->fs_info->fs_devices == test_root->fs_info->fs_devices;
 }
 
+static int btrfs_set_super(struct super_block *s, void *data)
+{
+	s->s_fs_info = data;
+
+	return set_anon_super(s, data);
+}
+
+
 /*
  * Find a superblock for the given device / mount point.
  *
@@ -588,6 +596,8 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	struct super_block *s;
 	struct dentry *root;
 	struct btrfs_fs_devices *fs_devices = NULL;
+	struct btrfs_root *tree_root = NULL;
+	struct btrfs_fs_info *fs_info = NULL;
 	fmode_t mode = FMODE_READ;
 	char *subvol_name = NULL;
 	u64 subvol_objectid = 0;
@@ -615,8 +625,24 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		goto error_close_devices;
 	}
 
+	/*
+	 * Setup a dummy root and fs_info for test/set super.  This is because
+	 * we don't actually fill this stuff out until open_ctree, but we need
+	 * it for searching for existing supers, so this lets us do that and
+	 * then open_ctree will properly initialize everything later.
+	 */
+	fs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_NOFS);
+	tree_root = kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
+	if (!fs_info || !tree_root) {
+		error = -ENOMEM;
+		goto error_close_devices;
+	}
+	fs_info->tree_root = tree_root;
+	fs_info->fs_devices = fs_devices;
+	tree_root->fs_info = fs_info;
+
 	bdev = fs_devices->latest_bdev;
-	s = sget(fs_type, btrfs_test_super, set_anon_super, fs_devices);
+	s = sget(fs_type, btrfs_test_super, btrfs_set_super, tree_root);
 	if (IS_ERR(s))
 		goto error_s;
 
@@ -685,6 +711,8 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	error = PTR_ERR(s);
 error_close_devices:
 	btrfs_close_devices(fs_devices);
+	kfree(fs_info);
+	kfree(tree_root);
 error_free_subvol_name:
 	kfree(subvol_name);
 	return error;

commit 619c8c763928841b1112e1d417f88bc1d44daecb
Author: Ian Kent <raven@themaw.net>
Date:   Mon Nov 22 02:21:38 2010 +0000

    Btrfs - fix race between btrfs_get_sb() and umount
    
    When mounting a btrfs file system btrfs_test_super() may attempt to
    use sb->s_fs_info, the btrfs root, of a super block that is going away
    and that has had the btrfs root set to NULL in its ->put_super(). But
    if the super block is going away it cannot be an existing super block
    so we can return false in this case.
    
    Signed-off-by: Ian Kent <raven@themaw.net>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 66e4612a7916..141fb317d3bc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -566,6 +566,12 @@ static int btrfs_test_super(struct super_block *s, void *data)
 	struct btrfs_fs_devices *test_fs_devices = data;
 	struct btrfs_root *root = btrfs_sb(s);
 
+	/*
+	 * If this super block is going away, return false as it
+	 * can't match as an existing super block.
+	 */
+	if (!atomic_read(&s->s_active))
+		return 0;
 	return root->fs_info->fs_devices == test_fs_devices;
 }
 

commit 0de90876c6cb774d4a424dafc1fc9ec50071b81b
Author: Josef Bacik <josef@redhat.com>
Date:   Fri Nov 19 13:40:41 2010 +0000

    Btrfs: handle the space_cache option properly
    
    When I added the clear_cache option I screwed up and took the break out of
    the space_cache case statement, so whenever you mount with space_cache you also
    get clear_cache, which does you no good if you say set space_cache in fstab so
    it always gets set.  This patch adds the break back in properly.
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 718b10de2049..66e4612a7916 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -244,6 +244,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_space_cache:
 			printk(KERN_INFO "btrfs: enabling disk space caching\n");
 			btrfs_set_opt(info->mount_opt, SPACE_CACHE);
+			break;
 		case Opt_clear_cache:
 			printk(KERN_INFO "btrfs: force clearing of disk cache\n");
 			btrfs_set_opt(info->mount_opt, CLEAR_CACHE);

commit 925d169f5b86fe57e2f5264ea574cce9a89b719d
Merge: cdf01dd5443d 6418c96107a2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 30 09:05:48 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (39 commits)
      Btrfs: deal with errors from updating the tree log
      Btrfs: allow subvol deletion by unprivileged user with -o user_subvol_rm_allowed
      Btrfs: make SNAP_DESTROY async
      Btrfs: add SNAP_CREATE_ASYNC ioctl
      Btrfs: add START_SYNC, WAIT_SYNC ioctls
      Btrfs: async transaction commit
      Btrfs: fix deadlock in btrfs_commit_transaction
      Btrfs: fix lockdep warning on clone ioctl
      Btrfs: fix clone ioctl where range is adjacent to extent
      Btrfs: fix delalloc checks in clone ioctl
      Btrfs: drop unused variable in block_alloc_rsv
      Btrfs: cleanup warnings from gcc 4.6 (nonbugs)
      Btrfs: Fix variables set but not read (bugs found by gcc 4.6)
      Btrfs: Use ERR_CAST helpers
      Btrfs: use memdup_user helpers
      Btrfs: fix raid code for removing missing drives
      Btrfs: Switch the extent buffer rbtree into a radix tree
      Btrfs: restructure try_release_extent_buffer()
      Btrfs: use the flusher threads for delalloc throttling
      Btrfs: tune the chunk allocation to 5% of the FS as metadata
      ...
    
    Fix up trivial conflicts in fs/btrfs/super.c and fs/fs-writeback.c, and
    remove use of INIT_RCU_HEAD in fs/btrfs/extent_io.c (that init macro was
    useless and removed in commit 5e8067adfdba: "rcu head remove init")

commit 4260f7c7516f4c209cf0ca34fda99cc9a0847772
Author: Sage Weil <sage@newdream.net>
Date:   Fri Oct 29 15:46:43 2010 -0400

    Btrfs: allow subvol deletion by unprivileged user with -o user_subvol_rm_allowed
    
    Add a mount option user_subvol_rm_allowed that allows users to delete a
    (potentially non-empty!) subvol when they would otherwise we allowed to do
    an rmdir(2).  We duplicate the may_delete() checks from the core VFS code
    to implement identical security checks (minus the directory size check).
    We additionally require that the user has write+exec permission on the
    subvol root inode.
    
    Signed-off-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0002e6d1a16f..718b10de2049 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -71,6 +71,7 @@ enum {
 	Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl, Opt_compress,
 	Opt_compress_force, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
 	Opt_discard, Opt_space_cache, Opt_clear_cache, Opt_err,
+	Opt_user_subvol_rm_allowed,
 };
 
 static match_table_t tokens = {
@@ -96,6 +97,7 @@ static match_table_t tokens = {
 	{Opt_discard, "discard"},
 	{Opt_space_cache, "space_cache"},
 	{Opt_clear_cache, "clear_cache"},
+	{Opt_user_subvol_rm_allowed, "user_subvol_rm_allowed"},
 	{Opt_err, NULL},
 };
 
@@ -246,6 +248,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: force clearing of disk cache\n");
 			btrfs_set_opt(info->mount_opt, CLEAR_CACHE);
 			break;
+		case Opt_user_subvol_rm_allowed:
+			btrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);

commit 559af8211433b8c0b20e6c43c61409cb9c9c2996
Author: Andi Kleen <andi@firstfloor.org>
Date:   Fri Oct 29 15:14:37 2010 -0400

    Btrfs: cleanup warnings from gcc 4.6 (nonbugs)
    
    These are all the cases where a variable is set, but not read which are
    not bugs as far as I can see, but simply leftovers.
    
    Still needs more review.
    
    Found by gcc 4.6's new warnings
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d7fb2733d028..0002e6d1a16f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -61,6 +61,8 @@ static void btrfs_put_super(struct super_block *sb)
 
 	ret = close_ctree(root);
 	sb->s_fs_info = NULL;
+
+	(void)ret; /* FIXME: need to fix VFS to return error? */
 }
 
 enum {
@@ -445,7 +447,6 @@ static int btrfs_fill_super(struct super_block *sb,
 {
 	struct inode *inode;
 	struct dentry *root_dentry;
-	struct btrfs_super_block *disk_super;
 	struct btrfs_root *tree_root;
 	struct btrfs_key key;
 	int err;
@@ -467,7 +468,6 @@ static int btrfs_fill_super(struct super_block *sb,
 		return PTR_ERR(tree_root);
 	}
 	sb->s_fs_info = tree_root;
-	disk_super = &tree_root->fs_info->super_copy;
 
 	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
 	key.type = BTRFS_INODE_ITEM_KEY;
@@ -580,7 +580,6 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	char *subvol_name = NULL;
 	u64 subvol_objectid = 0;
 	int error = 0;
-	int found = 0;
 
 	if (!(flags & MS_RDONLY))
 		mode |= FMODE_WRITE;
@@ -616,7 +615,6 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 			goto error_close_devices;
 		}
 
-		found = 1;
 		btrfs_close_devices(fs_devices);
 	} else {
 		char b[BDEVNAME_SIZE];

commit d0b678cb0a26783ab7238784f1e7e608e5caafa3
Author: Julia Lawall <julia@diku.dk>
Date:   Fri Oct 29 15:14:23 2010 -0400

    Btrfs: Use ERR_CAST helpers
    
    Use ERR_CAST(x) rather than ERR_PTR(PTR_ERR(x)).  The former makes more
    clear what is the purpose of the operation, which otherwise looks like a
    no-op.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    type T;
    T x;
    identifier f;
    @@
    
    T f (...) { <+...
    - ERR_PTR(PTR_ERR(x))
    + x
     ...+> }
    
    @@
    expression x;
    @@
    
    - ERR_PTR(PTR_ERR(x))
    + ERR_CAST(x)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Cc: Chris Mason <chris.mason@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 65b62daa3f80..d7fb2733d028 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -389,7 +389,7 @@ static struct dentry *get_default_root(struct super_block *sb,
 find_root:
 	new_root = btrfs_read_fs_root_no_name(root->fs_info, &location);
 	if (IS_ERR(new_root))
-		return ERR_PTR(PTR_ERR(new_root));
+		return ERR_CAST(new_root);
 
 	if (btrfs_root_refs(&new_root->root_item) == 0)
 		return ERR_PTR(-ENOENT);

commit 6b5b817f103450444f3f658a498f435d92a197e5
Merge: 8216ef866df1 e9bb7f10d361
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Oct 29 09:27:49 2010 -0400

    Merge branch 'bug-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/josef/btrfs-work
    
    Conflicts:
            fs/btrfs/extent-tree.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 88c2ba3b069f1e0f4694124d02985fa7620a19f1
Author: Josef Bacik <josef@redhat.com>
Date:   Tue Sep 21 14:21:34 2010 -0400

    Btrfs: Add a clear_cache mount option
    
    If something goes wrong with the free space cache we need a way to make sure
    it's not loaded on mount and that it's cleared for everybody.  When you pass the
    clear_cache option it will make it so all block groups are setup to be cleared,
    which keeps them from being loaded and then they will be truncated when the
    transaction is committed.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5c23eb8d6ba3..5f56213908e7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -68,7 +68,7 @@ enum {
 	Opt_nodatacow, Opt_max_inline, Opt_alloc_start, Opt_nobarrier, Opt_ssd,
 	Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl, Opt_compress,
 	Opt_compress_force, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
-	Opt_discard, Opt_space_cache, Opt_err,
+	Opt_discard, Opt_space_cache, Opt_clear_cache, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -93,6 +93,7 @@ static match_table_t tokens = {
 	{Opt_ratio, "metadata_ratio=%d"},
 	{Opt_discard, "discard"},
 	{Opt_space_cache, "space_cache"},
+	{Opt_clear_cache, "clear_cache"},
 	{Opt_err, NULL},
 };
 
@@ -239,6 +240,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_space_cache:
 			printk(KERN_INFO "btrfs: enabling disk space caching\n");
 			btrfs_set_opt(info->mount_opt, SPACE_CACHE);
+		case Opt_clear_cache:
+			printk(KERN_INFO "btrfs: force clearing of disk cache\n");
+			btrfs_set_opt(info->mount_opt, CLEAR_CACHE);
 			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "

commit 061dbc6b9010bc1a30ef9a1da5469aefa83abd7f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 26 16:21:33 2010 +0400

    convert btrfs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 144f8a5730f5..ebe46c628748 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -560,8 +560,8 @@ static int btrfs_test_super(struct super_block *s, void *data)
  * Note:  This is based on get_sb_bdev from fs/super.c with a few additions
  *	  for multiple device setup.  Make sure to keep it in sync.
  */
-static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
-		const char *dev_name, void *data, struct vfsmount *mnt)
+static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,
+		const char *dev_name, void *data)
 {
 	struct block_device *bdev = NULL;
 	struct super_block *s;
@@ -580,7 +580,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 					  &subvol_name, &subvol_objectid,
 					  &fs_devices);
 	if (error)
-		return error;
+		return ERR_PTR(error);
 
 	error = btrfs_scan_one_device(dev_name, mode, fs_type, &fs_devices);
 	if (error)
@@ -656,11 +656,8 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		root = new_root;
 	}
 
-	mnt->mnt_sb = s;
-	mnt->mnt_root = root;
-
 	kfree(subvol_name);
-	return 0;
+	return root;
 
 error_s:
 	error = PTR_ERR(s);
@@ -669,7 +666,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 error_free_subvol_name:
 	kfree(subvol_name);
 error:
-	return error;
+	return ERR_PTR(error);
 }
 
 static int btrfs_remount(struct super_block *sb, int *flags, char *data)
@@ -746,7 +743,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
-	.get_sb		= btrfs_get_sb,
+	.mount		= btrfs_mount,
 	.kill_sb	= kill_anon_super,
 	.fs_flags	= FS_REQUIRES_DEV,
 };

commit 0af3d00bad38d3bb9912a60928ad0669f17bdb76
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Jun 21 14:48:16 2010 -0400

    Btrfs: create special free space cache inode
    
    In order to save free space cache, we need an inode to hold the data, and we
    need a special item to point at the right inode for the right block group.  So
    first, create a special item that will point to the right inode, and the number
    of extent entries we will have and the number of bitmaps we will have.  We
    truncate and pre-allocate space everytime to make sure it's uptodate.
    
    This feature will be turned on as soon as you mount with -o space_cache, however
    it is safe to boot into old kernels, they will just generate the cache the old
    fashion way.  When you boot back into a newer kernel we will notice that we
    modified and not the cache and automatically discard the cache.
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1776dbd8dc98..5c23eb8d6ba3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -68,7 +68,7 @@ enum {
 	Opt_nodatacow, Opt_max_inline, Opt_alloc_start, Opt_nobarrier, Opt_ssd,
 	Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl, Opt_compress,
 	Opt_compress_force, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
-	Opt_discard, Opt_err,
+	Opt_discard, Opt_space_cache, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -92,6 +92,7 @@ static match_table_t tokens = {
 	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_ratio, "metadata_ratio=%d"},
 	{Opt_discard, "discard"},
+	{Opt_space_cache, "space_cache"},
 	{Opt_err, NULL},
 };
 
@@ -235,6 +236,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_discard:
 			btrfs_set_opt(info->mount_opt, DISCARD);
 			break;
+		case Opt_space_cache:
+			printk(KERN_INFO "btrfs: enabling disk space caching\n");
+			btrfs_set_opt(info->mount_opt, SPACE_CACHE);
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);

commit 0e78340f3c1fc603e8016c8ac304766bcc65506e
Author: Josef Bacik <josef@redhat.com>
Date:   Fri Oct 22 15:26:53 2010 -0400

    Btrfs: fix error handling in btrfs_get_sb
    
    If we failed to find the root subvol id, or the subvol=<name>, we would
    deactivate the locked super and close the devices.  The problem is at this point
    we have gotten the SB all setup, which includes setting super_operations, so
    when we'd deactiveate the super, we'd do a close_ctree() which closes the
    devices, so we'd end up closing the devices twice.  So if you do something like
    this
    
    mount /dev/sda1 /mnt/test1
    mount /dev/sda1 /mnt/test2 -o subvol=xxx
    umount /mnt/test1
    
    it would blow up (if subvol xxx doesn't exist).  This patch fixes that problem.
    Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index afab6ca14d03..d1867cda92a7 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -629,7 +629,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	if (IS_ERR(root)) {
 		error = PTR_ERR(root);
 		deactivate_locked_super(s);
-		goto error;
+		goto error_free_subvol_name;
 	}
 	/* if they gave us a subvolume name bind mount into that */
 	if (strcmp(subvol_name, ".")) {
@@ -643,14 +643,14 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 			deactivate_locked_super(s);
 			error = PTR_ERR(new_root);
 			dput(root);
-			goto error_close_devices;
+			goto error_free_subvol_name;
 		}
 		if (!new_root->d_inode) {
 			dput(root);
 			dput(new_root);
 			deactivate_locked_super(s);
 			error = -ENXIO;
-			goto error_close_devices;
+			goto error_free_subvol_name;
 		}
 		dput(root);
 		root = new_root;
@@ -668,7 +668,6 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	btrfs_close_devices(fs_devices);
 error_free_subvol_name:
 	kfree(subvol_name);
-error:
 	return error;
 }
 

commit 89a55897a2fbbceb94480952784004bf23911d38
Author: Josef Bacik <josef@redhat.com>
Date:   Thu Oct 14 14:52:27 2010 -0400

    Btrfs: fix df regression
    
    The new ENOSPC stuff breaks out the raid types which breaks the way we were
    reporting df to the system.  This fixes it back so that Available is the total
    space available to data and used is the actual bytes used by the filesystem.
    This means that Available is Total - data used - all of the metadata space.
    Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f2393b390318..afab6ca14d03 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -716,18 +716,25 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct list_head *head = &root->fs_info->space_info;
 	struct btrfs_space_info *found;
 	u64 total_used = 0;
+	u64 total_used_data = 0;
 	int bits = dentry->d_sb->s_blocksize_bits;
 	__be32 *fsid = (__be32 *)root->fs_info->fsid;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(found, head, list)
+	list_for_each_entry_rcu(found, head, list) {
+		if (found->flags & (BTRFS_BLOCK_GROUP_METADATA |
+				    BTRFS_BLOCK_GROUP_SYSTEM))
+			total_used_data += found->disk_total;
+		else
+			total_used_data += found->disk_used;
 		total_used += found->disk_used;
+	}
 	rcu_read_unlock();
 
 	buf->f_namelen = BTRFS_NAME_LEN;
 	buf->f_blocks = btrfs_super_total_bytes(disk_super) >> bits;
 	buf->f_bfree = buf->f_blocks - (total_used >> bits);
-	buf->f_bavail = buf->f_bfree;
+	buf->f_bavail = buf->f_blocks - (total_used_data >> bits);
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_type = BTRFS_SUPER_MAGIC;
 

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1776dbd8dc98..144f8a5730f5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -815,6 +815,7 @@ static const struct file_operations btrfs_ctl_fops = {
 	.unlocked_ioctl	 = btrfs_control_ioctl,
 	.compat_ioctl = btrfs_control_ioctl,
 	.owner	 = THIS_MODULE,
+	.llseek = noop_llseek,
 };
 
 static struct miscdevice btrfs_misc = {

commit bd55597520a2eaa0d71dd7683513a14bfd1bdf5c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 11:35:40 2010 -0400

    convert btrfs to ->evict_inode()
    
    NB: do we want btrfs_wait_ordered_range() on eviction of
    inodes with positive i_nlink on subvolume with zero root_refs?
    If not, btrfs_evict_inode() can be simplified by unconditionally
    bailing out in case of i_nlink > 0 in the very beginning...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f2393b390318..1776dbd8dc98 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -797,7 +797,7 @@ static int btrfs_unfreeze(struct super_block *sb)
 
 static const struct super_operations btrfs_super_ops = {
 	.drop_inode	= btrfs_drop_inode,
-	.delete_inode	= btrfs_delete_inode,
+	.evict_inode	= btrfs_evict_inode,
 	.put_super	= btrfs_put_super,
 	.sync_fs	= btrfs_sync_fs,
 	.show_options	= btrfs_show_options,

commit b25b550bb153626df6a48eb8583e923e3dfcf64a
Merge: eda054770e5c 6f902af400b2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 11 14:18:47 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: The file argument for fsync() is never null
      Btrfs: handle ERR_PTR from posix_acl_from_xattr()
      Btrfs: avoid BUG when dropping root and reference in same transaction
      Btrfs: prohibit a operation of changing acl's mask when noacl mount option used
      Btrfs: should add a permission check for setfacl
      Btrfs: btrfs_lookup_dir_item() can return ERR_PTR
      Btrfs: btrfs_read_fs_root_no_name() returns ERR_PTRs
      Btrfs: unwind after btrfs_start_transaction() errors
      Btrfs: btrfs_iget() returns ERR_PTR
      Btrfs: handle kzalloc() failure in open_ctree()
      Btrfs: handle error returns from btrfs_lookup_dir_item()
      Btrfs: Fix BUG_ON for fs converted from extN
      Btrfs: Fix null dereference in relocation.c
      Btrfs: fix remap_file_pages error
      Btrfs: uninitialized data is check_path_shared()
      Btrfs: fix fallocate regression
      Btrfs: fix loop device on top of btrfs

commit 4cbd1149fbcc351bdf08ab749867d157905d0d35
Author: Dan Carpenter <error27@gmail.com>
Date:   Sat May 29 09:42:19 2010 +0000

    Btrfs: btrfs_iget() returns ERR_PTR
    
    btrfs_iget() returns an ERR_PTR() on failure and not null.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9ea711430466..859ddaab5e02 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -392,8 +392,8 @@ static struct dentry *get_default_root(struct super_block *sb,
 	location.offset = 0;
 
 	inode = btrfs_iget(sb, &location, new_root, &new);
-	if (!inode)
-		return ERR_PTR(-ENOMEM);
+	if (IS_ERR(inode))
+		return ERR_CAST(inode);
 
 	/*
 	 * If we're just mounting the root most subvol put the inode and return

commit fb4f6f910ca6f58564c31a680ef88940d8192713
Author: Dan Carpenter <error27@gmail.com>
Date:   Sat May 29 09:40:57 2010 +0000

    Btrfs: handle error returns from btrfs_lookup_dir_item()
    
    If btrfs_lookup_dir_item() fails, we should can just let the mount fail
    with an error.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 574285c8cbd4..9ea711430466 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -360,6 +360,8 @@ static struct dentry *get_default_root(struct super_block *sb,
 	 */
 	dir_id = btrfs_super_root_dir(&root->fs_info->super_copy);
 	di = btrfs_lookup_dir_item(NULL, root, path, dir_id, "default", 7, 0);
+	if (IS_ERR(di))
+		return ERR_CAST(di);
 	if (!di) {
 		/*
 		 * Ok the default dir item isn't there.  This is weird since

commit 105a048a4f35f7a74c7cc20b36dd83658b6ec232
Merge: 00b9b0af5887 9aeead73782c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 27 10:43:44 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (27 commits)
      Btrfs: add more error checking to btrfs_dirty_inode
      Btrfs: allow unaligned DIO
      Btrfs: drop verbose enospc printk
      Btrfs: Fix block generation verification race
      Btrfs: fix preallocation and nodatacow checks in O_DIRECT
      Btrfs: avoid ENOSPC errors in btrfs_dirty_inode
      Btrfs: move O_DIRECT space reservation to btrfs_direct_IO
      Btrfs: rework O_DIRECT enospc handling
      Btrfs: use async helpers for DIO write checksumming
      Btrfs: don't walk around with task->state != TASK_RUNNING
      Btrfs: do aio_write instead of write
      Btrfs: add basic DIO read/write support
      direct-io: do not merge logically non-contiguous requests
      direct-io: add a hook for the fs to provide its own submit_bio function
      fs: allow short direct-io reads to be completed via buffered IO
      Btrfs: Metadata ENOSPC handling for balance
      Btrfs: Pre-allocate space for data relocation
      Btrfs: Metadata ENOSPC handling for tree log
      Btrfs: Metadata reservation for orphan inodes
      Btrfs: Introduce global metadata reservation
      ...

commit 578454ff7eab61d13a26b568f99a89a2c9edc881
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu May 20 18:07:20 2010 +0200

    driver core: add devname module aliases to allow module on-demand auto-loading
    
    This adds:
      alias: devname:<name>
    to some common kernel modules, which will allow the on-demand loading
    of the kernel module when the device node is accessed.
    
    Ideally all these modules would be compiled-in, but distros seems too
    much in love with their modularization that we need to cover the common
    cases with this new facility. It will allow us to remove a bunch of pretty
    useless init scripts and modprobes from init scripts.
    
    The static device node aliases will be carried in the module itself. The
    program depmod will extract this information to a file in the module directory:
      $ cat /lib/modules/2.6.34-00650-g537b60d-dirty/modules.devname
      # Device nodes to trigger on-demand module loading.
      microcode cpu/microcode c10:184
      fuse fuse c10:229
      ppp_generic ppp c108:0
      tun net/tun c10:200
      dm_mod mapper/control c10:235
    
    Udev will pick up the depmod created file on startup and create all the
    static device nodes which the kernel modules specify, so that these modules
    get automatically loaded when the device node is accessed:
      $ /sbin/udevd --debug
      ...
      static_dev_create_from_modules: mknod '/dev/cpu/microcode' c10:184
      static_dev_create_from_modules: mknod '/dev/fuse' c10:229
      static_dev_create_from_modules: mknod '/dev/ppp' c108:0
      static_dev_create_from_modules: mknod '/dev/net/tun' c10:200
      static_dev_create_from_modules: mknod '/dev/mapper/control' c10:235
      udev_rules_apply_static_dev_perms: chmod '/dev/net/tun' 0666
      udev_rules_apply_static_dev_perms: chmod '/dev/fuse' 0666
    
    A few device nodes are switched to statically allocated numbers, to allow
    the static nodes to work. This might also useful for systems which still run
    a plain static /dev, which is completely unsafe to use with any dynamic minor
    numbers.
    
    Note:
    The devname aliases must be limited to the *common* and *single*instance*
    device nodes, like the misc devices, and never be used for conceptually limited
    systems like the loop devices, which should rather get fixed properly and get a
    control node for losetup to talk to, instead of creating a random number of
    device nodes in advance, regardless if they are ever used.
    
    This facility is to hide the mess distros are creating with too modualized
    kernels, and just to hide that these modules are not compiled-in, and not to
    paper-over broken concepts. Thanks! :)
    
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Alasdair G Kergon <agk@redhat.com>
    Cc: Tigran Aivazian <tigran@aivazian.fsnet.co.uk>
    Cc: Ian Kent <raven@themaw.net>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1866dff0538e..2909a03e5230 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -832,11 +832,14 @@ static const struct file_operations btrfs_ctl_fops = {
 };
 
 static struct miscdevice btrfs_misc = {
-	.minor		= MISC_DYNAMIC_MINOR,
+	.minor		= BTRFS_MINOR,
 	.name		= "btrfs-control",
 	.fops		= &btrfs_ctl_fops
 };
 
+MODULE_ALIAS_MISCDEV(BTRFS_MINOR);
+MODULE_ALIAS("devname:btrfs-control");
+
 static int btrfs_interface_init(void)
 {
 	return misc_register(&btrfs_misc);

commit d68fc57b7e3245cfacf2e3b47acfed1946a11786
Author: Yan, Zheng <zheng.yan@oracle.com>
Date:   Sun May 16 10:49:58 2010 -0400

    Btrfs: Metadata reservation for orphan inodes
    
    reserve metadata space for handling orphan inodes
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 38d91c7e8db2..574285c8cbd4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -694,11 +694,11 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (btrfs_super_log_root(&root->fs_info->super_copy) != 0)
 			return -EINVAL;
 
-		/* recover relocation */
-		ret = btrfs_recover_relocation(root);
+		ret = btrfs_cleanup_fs_roots(root->fs_info);
 		WARN_ON(ret);
 
-		ret = btrfs_cleanup_fs_roots(root->fs_info);
+		/* recover relocation */
+		ret = btrfs_recover_relocation(root);
 		WARN_ON(ret);
 
 		sb->s_flags &= ~MS_RDONLY;

commit a22285a6a32390195235171b89d157ed1a1fe932
Author: Yan, Zheng <zheng.yan@oracle.com>
Date:   Sun May 16 10:48:46 2010 -0400

    Btrfs: Integrate metadata reservation with start_transaction
    
    Besides simplify the code, this change makes sure all metadata
    reservation for normal metadata operations are released after
    committing transaction.
    
    Changes since V1:
    
    Add code that check if unlink and rmdir will free space.
    
    Add ENOSPC handling for clone ioctl.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 55265c24ab96..38d91c7e8db2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -498,7 +498,7 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	btrfs_start_delalloc_inodes(root, 0);
 	btrfs_wait_ordered_extents(root, 0, 0);
 
-	trans = btrfs_start_transaction(root, 1);
+	trans = btrfs_start_transaction(root, 0);
 	ret = btrfs_commit_transaction(trans, root);
 	return ret;
 }

commit b742bb82f1676d50103ade0ba89bfb79debabe73
Author: Yan, Zheng <zheng.yan@oracle.com>
Date:   Sun May 16 10:46:24 2010 -0400

    Btrfs: Link block groups of different raid types
    
    The size of reserved space is stored in space_info. If block groups
    of different raid types are linked to separate space_info, changing
    allocation profile will corrupt reserved space accounting.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1866dff0538e..55265c24ab96 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -714,34 +714,18 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct list_head *head = &root->fs_info->space_info;
 	struct btrfs_space_info *found;
 	u64 total_used = 0;
-	u64 data_used = 0;
 	int bits = dentry->d_sb->s_blocksize_bits;
 	__be32 *fsid = (__be32 *)root->fs_info->fsid;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(found, head, list) {
-		if (found->flags & (BTRFS_BLOCK_GROUP_DUP|
-				    BTRFS_BLOCK_GROUP_RAID10|
-				    BTRFS_BLOCK_GROUP_RAID1)) {
-			total_used += found->bytes_used;
-			if (found->flags & BTRFS_BLOCK_GROUP_DATA)
-				data_used += found->bytes_used;
-			else
-				data_used += found->total_bytes;
-		}
-
-		total_used += found->bytes_used;
-		if (found->flags & BTRFS_BLOCK_GROUP_DATA)
-			data_used += found->bytes_used;
-		else
-			data_used += found->total_bytes;
-	}
+	list_for_each_entry_rcu(found, head, list)
+		total_used += found->disk_used;
 	rcu_read_unlock();
 
 	buf->f_namelen = BTRFS_NAME_LEN;
 	buf->f_blocks = btrfs_super_total_bytes(disk_super) >> bits;
 	buf->f_bfree = buf->f_blocks - (total_used >> bits);
-	buf->f_bavail = buf->f_blocks - (data_used >> bits);
+	buf->f_bavail = buf->f_bfree;
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_type = BTRFS_SUPER_MAGIC;
 

commit 795d580baec0d5386b83a8b557df47c20810e86b
Merge: 449cedf099b2 109f6aef5fc4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 5 13:21:15 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: add check for changed leaves in setup_leaf_for_split
      Btrfs: create snapshot references in same commit as snapshot
      Btrfs: fix small race with delalloc flushing waitqueue's
      Btrfs: use add_to_page_cache_lru, use __page_cache_alloc
      Btrfs: fix chunk allocate size calculation
      Btrfs: kill max_extent mount option
      Btrfs: fail to mount if we have problems reading the block groups
      Btrfs: check btrfs_get_extent return for IS_ERR()
      Btrfs: handle kmalloc() failure in inode lookup ioctl
      Btrfs: dereferencing freed memory
      Btrfs: Simplify num_stripes's calculation logical for __btrfs_alloc_chunk()
      Btrfs: Add error handle for btrfs_search_slot() in btrfs_read_chunk_tree()
      Btrfs: Remove unnecessary finish_wait() in wait_current_trans()
      Btrfs: add NULL check for do_walk_down()
      Btrfs: remove duplicate include in ioctl.c
    
    Fix trivial conflict in fs/btrfs/compression.c due to slab.h include
    cleanups.

commit 287a0ab91d25ca982f895a76402e5893b47ed7a6
Author: Josef Bacik <josef@redhat.com>
Date:   Fri Mar 19 18:07:23 2010 +0000

    Btrfs: kill max_extent mount option
    
    As Yan pointed out, theres not much reason for all this complicated math to
    account for file extents being split up into max_extent chunks, since they are
    likely to all end up in the same leaf anyway.  Since there isn't much reason to
    use max_extent, just remove the option altogether so we have one less thing we
    need to test.
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9ac612e6ca60..d11b12fc086b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -64,10 +64,9 @@ static void btrfs_put_super(struct super_block *sb)
 
 enum {
 	Opt_degraded, Opt_subvol, Opt_subvolid, Opt_device, Opt_nodatasum,
-	Opt_nodatacow, Opt_max_extent, Opt_max_inline, Opt_alloc_start,
-	Opt_nobarrier, Opt_ssd, Opt_nossd, Opt_ssd_spread, Opt_thread_pool,
-	Opt_noacl, Opt_compress, Opt_compress_force, Opt_notreelog, Opt_ratio,
-	Opt_flushoncommit,
+	Opt_nodatacow, Opt_max_inline, Opt_alloc_start, Opt_nobarrier, Opt_ssd,
+	Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl, Opt_compress,
+	Opt_compress_force, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
 	Opt_discard, Opt_err,
 };
 
@@ -79,7 +78,6 @@ static match_table_t tokens = {
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
 	{Opt_nobarrier, "nobarrier"},
-	{Opt_max_extent, "max_extent=%s"},
 	{Opt_max_inline, "max_inline=%s"},
 	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_thread_pool, "thread_pool=%d"},
@@ -188,18 +186,6 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				       info->thread_pool_size);
 			}
 			break;
-		case Opt_max_extent:
-			num = match_strdup(&args[0]);
-			if (num) {
-				info->max_extent = memparse(num, NULL);
-				kfree(num);
-
-				info->max_extent = max_t(u64,
-					info->max_extent, root->sectorsize);
-				printk(KERN_INFO "btrfs: max_extent at %llu\n",
-				       (unsigned long long)info->max_extent);
-			}
-			break;
 		case Opt_max_inline:
 			num = match_strdup(&args[0]);
 			if (num) {
@@ -529,9 +515,6 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_puts(seq, ",nodatacow");
 	if (btrfs_test_opt(root, NOBARRIER))
 		seq_puts(seq, ",nobarrier");
-	if (info->max_extent != (u64)-1)
-		seq_printf(seq, ",max_extent=%llu",
-			   (unsigned long long)info->max_extent);
 	if (info->max_inline != 8192 * 1024)
 		seq_printf(seq, ",max_inline=%llu",
 			   (unsigned long long)info->max_inline);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9ac612e6ca60..693a664318fe 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -38,6 +38,7 @@
 #include <linux/namei.h>
 #include <linux/miscdevice.h>
 #include <linux/magic.h>
+#include <linux/slab.h>
 #include "compat.h"
 #include "ctree.h"
 #include "disk-io.h"

commit 91748467a5c5884e44ad5cf58630c0c28474f1f6
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sun Feb 28 10:59:11 2010 +0000

    btrfs: use memparse
    
    Use memparse() instead of its own private implementation.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: linux-btrfs@vger.kernel.org
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ff3dd55f294d..9ac612e6ca60 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -96,31 +96,6 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-u64 btrfs_parse_size(char *str)
-{
-	u64 res;
-	int mult = 1;
-	char *end;
-	char last;
-
-	res = simple_strtoul(str, &end, 10);
-
-	last = end[0];
-	if (isalpha(last)) {
-		last = tolower(last);
-		switch (last) {
-		case 'g':
-			mult *= 1024;
-		case 'm':
-			mult *= 1024;
-		case 'k':
-			mult *= 1024;
-		}
-		res = res * mult;
-	}
-	return res;
-}
-
 /*
  * Regular mount options parser.  Everything that is needed only when
  * reading in a new superblock is parsed here.
@@ -216,7 +191,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_max_extent:
 			num = match_strdup(&args[0]);
 			if (num) {
-				info->max_extent = btrfs_parse_size(num);
+				info->max_extent = memparse(num, NULL);
 				kfree(num);
 
 				info->max_extent = max_t(u64,
@@ -228,7 +203,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_max_inline:
 			num = match_strdup(&args[0]);
 			if (num) {
-				info->max_inline = btrfs_parse_size(num);
+				info->max_inline = memparse(num, NULL);
 				kfree(num);
 
 				if (info->max_inline) {
@@ -243,7 +218,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_alloc_start:
 			num = match_strdup(&args[0]);
 			if (num) {
-				info->alloc_start = btrfs_parse_size(num);
+				info->alloc_start = memparse(num, NULL);
 				kfree(num);
 				printk(KERN_INFO
 					"btrfs: allocations start at %llu\n",

commit bd4d10888990f7e3f8029205d27eb155202d6969
Author: Josef Bacik <josef@redhat.com>
Date:   Fri Mar 5 21:59:21 2010 +0000

    Btrfs: make df be a little bit more understandable
    
    The way we report df usage is way confusing for everybody, including some other
    utilities (bacula for one).  So this patch makes df a little bit more
    understandable.  First we make used actually count the total amount of used
    space in all space info's.  This will give us a real view of how much disk space
    is in use.  Second, for blocks available, only count data space.  This makes
    things like bacula work because it says 0 when you can no longer write anymore
    data to the disk.  I think this is a nice compromise, since you will end up with
    something like the following
    
    [root@alpha ~]# df -h
    Filesystem            Size  Used Avail Use% Mounted on
    /dev/mapper/VolGroup-lv_root
                          148G   30G  111G  21% /
    /dev/sda1             194M  116M   68M  64% /boot
    tmpfs                 985M   12K  985M   1% /dev/shm
    /dev/mapper/VolGroup-LogVol02
                          145G  140G     0 100% /mnt/btrfs-test
    
    Compare this with btrfsctl -i output
    
    [root@alpha btrfs-progs-unstable]# ./btrfsctl -i /mnt/btrfs-test/
    Metadata, DUP: total=4.62GB, used=2.46GB
    System, DUP: total=8.00MB, used=24.00KB
    Data: total=134.80GB, used=134.80GB
    Metadata: total=8.00MB, used=0.00
    System: total=4.00MB, used=0.00
    operation complete
    
    This way we show that there is no more data space to be used, but we have
    another 5GB of space left for metadata.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9771eb8694b6..ff3dd55f294d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -752,14 +752,37 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
 	struct btrfs_super_block *disk_super = &root->fs_info->super_copy;
+	struct list_head *head = &root->fs_info->space_info;
+	struct btrfs_space_info *found;
+	u64 total_used = 0;
+	u64 data_used = 0;
 	int bits = dentry->d_sb->s_blocksize_bits;
 	__be32 *fsid = (__be32 *)root->fs_info->fsid;
 
+	rcu_read_lock();
+	list_for_each_entry_rcu(found, head, list) {
+		if (found->flags & (BTRFS_BLOCK_GROUP_DUP|
+				    BTRFS_BLOCK_GROUP_RAID10|
+				    BTRFS_BLOCK_GROUP_RAID1)) {
+			total_used += found->bytes_used;
+			if (found->flags & BTRFS_BLOCK_GROUP_DATA)
+				data_used += found->bytes_used;
+			else
+				data_used += found->total_bytes;
+		}
+
+		total_used += found->bytes_used;
+		if (found->flags & BTRFS_BLOCK_GROUP_DATA)
+			data_used += found->bytes_used;
+		else
+			data_used += found->total_bytes;
+	}
+	rcu_read_unlock();
+
 	buf->f_namelen = BTRFS_NAME_LEN;
 	buf->f_blocks = btrfs_super_total_bytes(disk_super) >> bits;
-	buf->f_bfree = buf->f_blocks -
-		(btrfs_super_bytes_used(disk_super) >> bits);
-	buf->f_bavail = buf->f_bfree;
+	buf->f_bfree = buf->f_blocks - (total_used >> bits);
+	buf->f_bavail = buf->f_blocks - (data_used >> bits);
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_type = BTRFS_SUPER_MAGIC;
 

commit 4849f01d153be0f52b8191ee1be0ce492aa96811
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Dec 14 19:18:38 2009 +0000

    Btrfs: make subvolid=0 mount the original default root
    
    Since theres not a good way to make sure the user sees the original default root
    tree id, and not to mention it's 5 so is way different than any other volume,
    just make subvol=0 mount the original default root.  This makes it a bit easier
    for users to handle in the long run.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f878337cee6f..9771eb8694b6 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -325,9 +325,15 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 			break;
 		case Opt_subvolid:
 			intarg = 0;
-			match_int(&args[0], &intarg);
-			if (intarg)
-				*subvol_objectid = intarg;
+			error = match_int(&args[0], &intarg);
+			if (!error) {
+				/* we want the original fs_tree */
+				if (!intarg)
+					*subvol_objectid =
+						BTRFS_FS_TREE_OBJECTID;
+				else
+					*subvol_objectid = intarg;
+			}
 			break;
 		case Opt_device:
 			error = btrfs_scan_one_device(match_strdup(&args[0]),

commit 73f73415caddbc01d9f10c03e0a677d5b3d11569
Author: Josef Bacik <josef@redhat.com>
Date:   Fri Dec 4 17:38:27 2009 +0000

    Btrfs: change how we mount subvolumes
    
    This work is in preperation for being able to set a different root as the
    default mounting root.
    
    There is currently a problem with how we mount subvolumes.  We cannot currently
    mount a subvolume of a subvolume, you can only mount subvolumes/snapshots of the
    default subvolume.  So say you take a snapshot of the default subvolume and call
    it snap1, and then take a snapshot of snap1 and call it snap2, so now you have
    
    /
    /snap1
    /snap1/snap2
    
    as your available volumes.  Currently you can only mount / and /snap1,
    you cannot mount /snap1/snap2.  To fix this problem instead of passing
    subvolid=<name> you must pass in subvolid=<treeid>, where <treeid> is
    the tree id that gets spit out via the subvolume listing you get from
    the subvolume listing patches (btrfs filesystem list).  This allows us
    to mount /, /snap1 and /snap1/snap2 as the root volume.
    
    In addition to the above, we also now read the default dir item in the
    tree root to get the root key that it points to.  For now this just
    points at what has always been the default subvolme, but later on I plan
    to change it to point at whatever root you want to be the new default
    root, so you can just set the default mount and not have to mount with
    -o subvolid=<treeid>.  I tested this out with the above scenario and it
    worked perfectly.  Thanks,
    
    mount -o subvol operates inside the selected subvolid.  For example:
    
    mount -o subvol=snap1,subvolid=256 /dev/xxx /mnt
    
    /mnt will have the snap1 directory for the subvolume with id
    256.
    
    mount -o subvol=snap /dev/xxx /mnt
    
    /mnt will be the snap directory of whatever the default subvolume
    is.
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f8b4521de907..f878337cee6f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -63,10 +63,10 @@ static void btrfs_put_super(struct super_block *sb)
 }
 
 enum {
-	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
-	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
-	Opt_ssd, Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl,
-	Opt_compress, Opt_compress_force, Opt_notreelog, Opt_ratio,
+	Opt_degraded, Opt_subvol, Opt_subvolid, Opt_device, Opt_nodatasum,
+	Opt_nodatacow, Opt_max_extent, Opt_max_inline, Opt_alloc_start,
+	Opt_nobarrier, Opt_ssd, Opt_nossd, Opt_ssd_spread, Opt_thread_pool,
+	Opt_noacl, Opt_compress, Opt_compress_force, Opt_notreelog, Opt_ratio,
 	Opt_flushoncommit,
 	Opt_discard, Opt_err,
 };
@@ -74,6 +74,7 @@ enum {
 static match_table_t tokens = {
 	{Opt_degraded, "degraded"},
 	{Opt_subvol, "subvol=%s"},
+	{Opt_subvolid, "subvolid=%d"},
 	{Opt_device, "device=%s"},
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
@@ -157,6 +158,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, DEGRADED);
 			break;
 		case Opt_subvol:
+		case Opt_subvolid:
 		case Opt_device:
 			/*
 			 * These are parsed by btrfs_parse_early_options
@@ -292,12 +294,13 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
  * only when we need to allocate a new super block.
  */
 static int btrfs_parse_early_options(const char *options, fmode_t flags,
-		void *holder, char **subvol_name,
+		void *holder, char **subvol_name, u64 *subvol_objectid,
 		struct btrfs_fs_devices **fs_devices)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *opts, *p;
 	int error = 0;
+	int intarg;
 
 	if (!options)
 		goto out;
@@ -320,6 +323,12 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		case Opt_subvol:
 			*subvol_name = match_strdup(&args[0]);
 			break;
+		case Opt_subvolid:
+			intarg = 0;
+			match_int(&args[0], &intarg);
+			if (intarg)
+				*subvol_objectid = intarg;
+			break;
 		case Opt_device:
 			error = btrfs_scan_one_device(match_strdup(&args[0]),
 					flags, holder, fs_devices);
@@ -347,6 +356,110 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 	return error;
 }
 
+static struct dentry *get_default_root(struct super_block *sb,
+				       u64 subvol_objectid)
+{
+	struct btrfs_root *root = sb->s_fs_info;
+	struct btrfs_root *new_root;
+	struct btrfs_dir_item *di;
+	struct btrfs_path *path;
+	struct btrfs_key location;
+	struct inode *inode;
+	struct dentry *dentry;
+	u64 dir_id;
+	int new = 0;
+
+	/*
+	 * We have a specific subvol we want to mount, just setup location and
+	 * go look up the root.
+	 */
+	if (subvol_objectid) {
+		location.objectid = subvol_objectid;
+		location.type = BTRFS_ROOT_ITEM_KEY;
+		location.offset = (u64)-1;
+		goto find_root;
+	}
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return ERR_PTR(-ENOMEM);
+	path->leave_spinning = 1;
+
+	/*
+	 * Find the "default" dir item which points to the root item that we
+	 * will mount by default if we haven't been given a specific subvolume
+	 * to mount.
+	 */
+	dir_id = btrfs_super_root_dir(&root->fs_info->super_copy);
+	di = btrfs_lookup_dir_item(NULL, root, path, dir_id, "default", 7, 0);
+	if (!di) {
+		/*
+		 * Ok the default dir item isn't there.  This is weird since
+		 * it's always been there, but don't freak out, just try and
+		 * mount to root most subvolume.
+		 */
+		btrfs_free_path(path);
+		dir_id = BTRFS_FIRST_FREE_OBJECTID;
+		new_root = root->fs_info->fs_root;
+		goto setup_root;
+	}
+
+	btrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);
+	btrfs_free_path(path);
+
+find_root:
+	new_root = btrfs_read_fs_root_no_name(root->fs_info, &location);
+	if (IS_ERR(new_root))
+		return ERR_PTR(PTR_ERR(new_root));
+
+	if (btrfs_root_refs(&new_root->root_item) == 0)
+		return ERR_PTR(-ENOENT);
+
+	dir_id = btrfs_root_dirid(&new_root->root_item);
+setup_root:
+	location.objectid = dir_id;
+	location.type = BTRFS_INODE_ITEM_KEY;
+	location.offset = 0;
+
+	inode = btrfs_iget(sb, &location, new_root, &new);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+
+	/*
+	 * If we're just mounting the root most subvol put the inode and return
+	 * a reference to the dentry.  We will have already gotten a reference
+	 * to the inode in btrfs_fill_super so we're good to go.
+	 */
+	if (!new && sb->s_root->d_inode == inode) {
+		iput(inode);
+		return dget(sb->s_root);
+	}
+
+	if (new) {
+		const struct qstr name = { .name = "/", .len = 1 };
+
+		/*
+		 * New inode, we need to make the dentry a sibling of s_root so
+		 * everything gets cleaned up properly on unmount.
+		 */
+		dentry = d_alloc(sb->s_root, &name);
+		if (!dentry) {
+			iput(inode);
+			return ERR_PTR(-ENOMEM);
+		}
+		d_splice_alias(inode, dentry);
+	} else {
+		/*
+		 * We found the inode in cache, just find a dentry for it and
+		 * put the reference to the inode we just got.
+		 */
+		dentry = d_find_alias(inode);
+		iput(inode);
+	}
+
+	return dentry;
+}
+
 static int btrfs_fill_super(struct super_block *sb,
 			    struct btrfs_fs_devices *fs_devices,
 			    void *data, int silent)
@@ -380,7 +493,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
 	key.type = BTRFS_INODE_ITEM_KEY;
 	key.offset = 0;
-	inode = btrfs_iget(sb, &key, tree_root->fs_info->fs_root);
+	inode = btrfs_iget(sb, &key, tree_root->fs_info->fs_root, NULL);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
 		goto fail_close;
@@ -392,12 +505,6 @@ static int btrfs_fill_super(struct super_block *sb,
 		err = -ENOMEM;
 		goto fail_close;
 	}
-#if 0
-	/* this does the super kobj at the same time */
-	err = btrfs_sysfs_add_super(tree_root->fs_info);
-	if (err)
-		goto fail_close;
-#endif
 
 	sb->s_root = root_dentry;
 
@@ -489,19 +596,22 @@ static int btrfs_test_super(struct super_block *s, void *data)
 static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		const char *dev_name, void *data, struct vfsmount *mnt)
 {
-	char *subvol_name = NULL;
 	struct block_device *bdev = NULL;
 	struct super_block *s;
 	struct dentry *root;
 	struct btrfs_fs_devices *fs_devices = NULL;
 	fmode_t mode = FMODE_READ;
+	char *subvol_name = NULL;
+	u64 subvol_objectid = 0;
 	int error = 0;
+	int found = 0;
 
 	if (!(flags & MS_RDONLY))
 		mode |= FMODE_WRITE;
 
 	error = btrfs_parse_early_options(data, mode, fs_type,
-					  &subvol_name, &fs_devices);
+					  &subvol_name, &subvol_objectid,
+					  &fs_devices);
 	if (error)
 		return error;
 
@@ -530,6 +640,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 			goto error_close_devices;
 		}
 
+		found = 1;
 		btrfs_close_devices(fs_devices);
 	} else {
 		char b[BDEVNAME_SIZE];
@@ -547,25 +658,35 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		s->s_flags |= MS_ACTIVE;
 	}
 
-	if (!strcmp(subvol_name, "."))
-		root = dget(s->s_root);
-	else {
-		mutex_lock(&s->s_root->d_inode->i_mutex);
-		root = lookup_one_len(subvol_name, s->s_root,
+	root = get_default_root(s, subvol_objectid);
+	if (IS_ERR(root)) {
+		error = PTR_ERR(root);
+		deactivate_locked_super(s);
+		goto error;
+	}
+	/* if they gave us a subvolume name bind mount into that */
+	if (strcmp(subvol_name, ".")) {
+		struct dentry *new_root;
+		mutex_lock(&root->d_inode->i_mutex);
+		new_root = lookup_one_len(subvol_name, root,
 				      strlen(subvol_name));
-		mutex_unlock(&s->s_root->d_inode->i_mutex);
+		mutex_unlock(&root->d_inode->i_mutex);
 
-		if (IS_ERR(root)) {
+		if (IS_ERR(new_root)) {
 			deactivate_locked_super(s);
-			error = PTR_ERR(root);
-			goto error_free_subvol_name;
+			error = PTR_ERR(new_root);
+			dput(root);
+			goto error_close_devices;
 		}
-		if (!root->d_inode) {
+		if (!new_root->d_inode) {
 			dput(root);
+			dput(new_root);
 			deactivate_locked_super(s);
 			error = -ENXIO;
-			goto error_free_subvol_name;
+			goto error_close_devices;
 		}
+		dput(root);
+		root = new_root;
 	}
 
 	mnt->mnt_sb = s;
@@ -580,6 +701,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	btrfs_close_devices(fs_devices);
 error_free_subvol_name:
 	kfree(subvol_name);
+error:
 	return error;
 }
 

commit da495ecc0fb096b383754952a1c152147bc95b52
Author: Josef Bacik <josef@redhat.com>
Date:   Thu Feb 25 20:38:35 2010 +0000

    Btrfs: kfree correct pointer during mount option parsing
    
    We kstrdup the options string, but then strsep screws with the pointer,
    so when we kfree() it, we're not giving it the right pointer.
    
    Tested-by: Andy Lutomirski <luto@mit.edu>
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8a1ea6e64575..f8b4521de907 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -128,7 +128,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 {
 	struct btrfs_fs_info *info = root->fs_info;
 	substring_t args[MAX_OPT_ARGS];
-	char *p, *num;
+	char *p, *num, *orig;
 	int intarg;
 	int ret = 0;
 
@@ -143,6 +143,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	if (!options)
 		return -ENOMEM;
 
+	orig = options;
 
 	while ((p = strsep(&options, ",")) != NULL) {
 		int token;
@@ -280,7 +281,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		}
 	}
 out:
-	kfree(options);
+	kfree(orig);
 	return ret;
 }
 

commit a555f810af6d63ea5960abaed88e150ad95c3011
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Jan 28 16:18:15 2010 -0500

    Btrfs: Add mount -o compress-force
    
    The default btrfs mount -o compress mode will quickly back off
    compressing a file if it notices that compression does not reduce the
    size of the data being written.  This can save considerable CPU because
    all future writes to the file go through uncompressed.
    
    But some files are both very large and have mixed data stored in
    them.  In that case, we want to add the ability to always try
    compressing data before writing it.
    
    This commit adds mount -o compress-force.  A later commit will add
    a new inode flag that does the same thing.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3f9b45704fcd..8a1ea6e64575 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -66,7 +66,8 @@ enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
 	Opt_ssd, Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl,
-	Opt_compress, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
+	Opt_compress, Opt_compress_force, Opt_notreelog, Opt_ratio,
+	Opt_flushoncommit,
 	Opt_discard, Opt_err,
 };
 
@@ -82,6 +83,7 @@ static match_table_t tokens = {
 	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_thread_pool, "thread_pool=%d"},
 	{Opt_compress, "compress"},
+	{Opt_compress_force, "compress-force"},
 	{Opt_ssd, "ssd"},
 	{Opt_ssd_spread, "ssd_spread"},
 	{Opt_nossd, "nossd"},
@@ -173,6 +175,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: use compression\n");
 			btrfs_set_opt(info->mount_opt, COMPRESS);
 			break;
+		case Opt_compress_force:
+			printk(KERN_INFO "btrfs: forcing compression\n");
+			btrfs_set_opt(info->mount_opt, FORCE_COMPRESS);
+			btrfs_set_opt(info->mount_opt, COMPRESS);
+			break;
 		case Opt_ssd:
 			printk(KERN_INFO "btrfs: use ssd allocation scheme\n");
 			btrfs_set_opt(info->mount_opt, SSD);

commit 20a5239a5d0f340e29827a6a2d28a138001c44b8
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Dec 14 22:01:12 2009 +0000

    Btrfs: Show discard option in /proc/mounts
    
    Christoph's patch e244a0aeb6a599c19a7c802cda6e2d67c847b154 doesn't display
    the discard option in /proc/mounts, leading to some confusion for me.
    Here's the missing bit.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 193d920e54eb..3f9b45704fcd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -457,6 +457,8 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_puts(seq, ",notreelog");
 	if (btrfs_test_opt(root, FLUSHONCOMMIT))
 		seq_puts(seq, ",flushoncommit");
+	if (btrfs_test_opt(root, DISCARD))
+		seq_puts(seq, ",discard");
 	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
 		seq_puts(seq, ",noacl");
 	return 0;

commit a7a3f7cadd9bdee569243f7ead9550aa16b60e07
Author: Sage Weil <sage@newdream.net>
Date:   Sat Nov 7 06:19:16 2009 +0000

    Btrfs: fail mount on bad mount options
    
    We shouldn't silently ignore unrecognized options.
    
    Signed-off-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 270cc96b9a43..193d920e54eb 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -128,6 +128,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	substring_t args[MAX_OPT_ARGS];
 	char *p, *num;
 	int intarg;
+	int ret = 0;
 
 	if (!options)
 		return 0;
@@ -262,12 +263,18 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_discard:
 			btrfs_set_opt(info->mount_opt, DISCARD);
 			break;
+		case Opt_err:
+			printk(KERN_INFO "btrfs: unrecognized mount option "
+			       "'%s'\n", p);
+			ret = -EINVAL;
+			goto out;
 		default:
 			break;
 		}
 	}
+out:
 	kfree(options);
-	return 0;
+	return ret;
 }
 
 /*

commit 24bbcf0442ee04660a5a030efdbb6d03f1c275cb
Author: Yan, Zheng <zheng.yan@oracle.com>
Date:   Thu Nov 12 09:36:34 2009 +0000

    Btrfs: Add delayed iput
    
    iput() can trigger new transactions if we are dropping the
    final reference, so calling it in btrfs_commit_transaction
    may end up deadlock. This patch adds delayed iput to avoid
    the issue.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 752a5463bf53..270cc96b9a43 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -405,8 +405,8 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 
-	btrfs_start_delalloc_inodes(root);
-	btrfs_wait_ordered_extents(root, 0);
+	btrfs_start_delalloc_inodes(root, 0);
+	btrfs_wait_ordered_extents(root, 0, 0);
 
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);

commit dcbeb0bec5f2695c3ff53f174efb8e03c209f3f3
Merge: 2b650df2cea9 444528b3e614
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 15 15:06:37 2009 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: always pin metadata in discard mode
      Btrfs: enable discard support
      Btrfs: add -o discard option
      Btrfs: properly wait log writers during log sync
      Btrfs: fix possible ENOSPC problems with truncate
      Btrfs: fix btrfs acl #ifdef checks
      Btrfs: streamline tree-log btree block writeout
      Btrfs: avoid tree log commit when there are no changes
      Btrfs: only write one super copy during fsync

commit e244a0aeb6a599c19a7c802cda6e2d67c847b154
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 14 09:24:59 2009 -0400

    Btrfs: add -o discard option
    
    Enable discard by default is not a good idea given the the trim speed
    of SSD prototypes we've seen, and the carecteristics for many high-end
    arrays.  Turn of discards by default and require the -o discard option
    to enable them on.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3fbbf0761ac2..939b68f0612d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -66,7 +66,8 @@ enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
 	Opt_ssd, Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl,
-	Opt_compress, Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_err,
+	Opt_compress, Opt_notreelog, Opt_ratio, Opt_flushoncommit,
+	Opt_discard, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -88,6 +89,7 @@ static match_table_t tokens = {
 	{Opt_notreelog, "notreelog"},
 	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_ratio, "metadata_ratio=%d"},
+	{Opt_discard, "discard"},
 	{Opt_err, NULL},
 };
 
@@ -257,6 +259,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				       info->metadata_ratio);
 			}
 			break;
+		case Opt_discard:
+			btrfs_set_opt(info->mount_opt, DISCARD);
+			break;
 		default:
 			break;
 		}

commit 0eda294dfc980c1cbe4f8a0564bf543f86a01ddb
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Oct 13 13:50:18 2009 -0400

    Btrfs: fix btrfs acl #ifdef checks
    
    The btrfs acl code was #ifdefing for a define
    that didn't exist.  This correctly matches it
    to the values used by the Kconfig file.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e0a64328080c..3fbbf0761ac2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -344,7 +344,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_export_op = &btrfs_export_ops;
 	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;
-#ifdef CONFIG_BTRFS_POSIX_ACL
+#ifdef CONFIG_BTRFS_FS_POSIX_ACL
 	sb->s_flags |= MS_POSIXACL;
 #endif
 

commit 25472b880c69c0daa485c4f80a6550437ed1149f
Merge: 17d857be649a ab93dbecfba7
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Oct 1 12:58:13 2009 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable into for-linus

commit 49cf6f4529b7945ef51b8e39f0bac630726f8c96
Author: Chris Ball <cjb@laptop.org>
Date:   Tue Sep 29 13:51:04 2009 -0400

    Btrfs: Fix setting umask when POSIX ACLs are not enabled
    
    We currently set sb->s_flags |= MS_POSIXACL unconditionally, which is
    incorrect -- it tells the VFS that it shouldn't set umask because we
    will, yet we don't set it ourselves if we aren't using POSIX ACLs, so
    the umask ends up ignored.
    
    Signed-off-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0242c8babae9..e0a64328080c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -344,7 +344,9 @@ static int btrfs_fill_super(struct super_block *sb,
 	sb->s_export_op = &btrfs_export_ops;
 	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;
+#ifdef CONFIG_BTRFS_POSIX_ACL
 	sb->s_flags |= MS_POSIXACL;
+#endif
 
 	tree_root = open_ctree(sb, fs_devices, (char *)data);
 

commit 54bcf382daf08c1396edb8b81e650b58930ccaef
Merge: 94a8d5caba74 c65ddb52dc41
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Sep 24 10:00:58 2009 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable into for-linus
    
    Conflicts:
            fs/btrfs/super.c

commit b87221de6a4934eda856475a0065688d12973a04
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 21 17:01:09 2009 -0700

    const: mark remaining super_operations const
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6d6d06cb6dfc..2db17cd66fc5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -51,7 +51,7 @@
 #include "export.h"
 #include "compression.h"
 
-static struct super_operations btrfs_super_ops;
+static const struct super_operations btrfs_super_ops;
 
 static void btrfs_put_super(struct super_block *sb)
 {
@@ -675,7 +675,7 @@ static int btrfs_unfreeze(struct super_block *sb)
 	return 0;
 }
 
-static struct super_operations btrfs_super_ops = {
+static const struct super_operations btrfs_super_ops = {
 	.delete_inode	= btrfs_delete_inode,
 	.put_super	= btrfs_put_super,
 	.sync_fs	= btrfs_sync_fs,

commit 76dda93c6ae2c1dc3e6cde34569d6aca26b0c918
Author: Yan, Zheng <zheng.yan@oracle.com>
Date:   Mon Sep 21 16:00:26 2009 -0400

    Btrfs: add snapshot/subvolume destroy ioctl
    
    This patch adds snapshot/subvolume destroy ioctl.  A subvolume that isn't being
    used and doesn't contains links to other subvolumes can be destroyed.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6d6d06cb6dfc..0242c8babae9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -676,6 +676,7 @@ static int btrfs_unfreeze(struct super_block *sb)
 }
 
 static struct super_operations btrfs_super_ops = {
+	.drop_inode	= btrfs_drop_inode,
 	.delete_inode	= btrfs_delete_inode,
 	.put_super	= btrfs_put_super,
 	.sync_fs	= btrfs_sync_fs,

commit 405f55712dfe464b3240d7816cc4fe4174831be2
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Jul 11 22:08:37 2009 +0400

    headers: smp_lock.h redux
    
    * Remove smp_lock.h from files which don't need it (including some headers!)
    * Add smp_lock.h to files which do need it
    * Make smp_lock.h include conditional in hardirq.h
      It's needed only for one kernel_locked() usage which is under CONFIG_PREEMPT
    
      This will make hardirq.h inclusion cheaper for every PREEMPT=n config
      (which includes allmodconfig/allyesconfig, BTW)
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9f179d4832d5..6d6d06cb6dfc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -26,7 +26,6 @@
 #include <linux/init.h>
 #include <linux/seq_file.h>
 #include <linux/string.h>
-#include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
 #include <linux/mount.h>
 #include <linux/mpage.h>

commit 5af7926ff33b68b3ba46531471c6e0564b285efc
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 5 15:41:25 2009 +0200

    enforce ->sync_fs is only called for rw superblock
    
    Make sure a superblock really is writeable by checking MS_RDONLY
    under s_umount.  sync_filesystems needed some re-arragement for
    that, but all but one sync_filesystem caller had the correct locking
    already so that we could add that check there.  cachefiles grew
    s_umount locking.
    
    I've also added a WARN_ON to sync_filesystem to assert this for
    future callers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 52d84522c2c2..9f179d4832d5 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -394,9 +394,6 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	struct btrfs_root *root = btrfs_sb(sb);
 	int ret;
 
-	if (sb->s_flags & MS_RDONLY)
-		return 0;
-
 	if (!wait) {
 		filemap_flush(root->fs_info->btree_inode->i_mapping);
 		return 0;

commit 59d697b70285c348c01cfc2695c3469ba71d7539
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Apr 27 09:46:41 2009 -0400

    btrfs: remove ->write_super and stop maintaining ->s_dirt
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 708ac06b953b..52d84522c2c2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -397,7 +397,6 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	if (sb->s_flags & MS_RDONLY)
 		return 0;
 
-	sb->s_dirt = 0;
 	if (!wait) {
 		filemap_flush(root->fs_info->btree_inode->i_mapping);
 		return 0;
@@ -408,7 +407,6 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);
-	sb->s_dirt = 0;
 	return ret;
 }
 
@@ -454,11 +452,6 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 	return 0;
 }
 
-static void btrfs_write_super(struct super_block *sb)
-{
-	sb->s_dirt = 0;
-}
-
 static int btrfs_test_super(struct super_block *s, void *data)
 {
 	struct btrfs_fs_devices *test_fs_devices = data;
@@ -689,7 +682,6 @@ static int btrfs_unfreeze(struct super_block *sb)
 static struct super_operations btrfs_super_ops = {
 	.delete_inode	= btrfs_delete_inode,
 	.put_super	= btrfs_put_super,
-	.write_super	= btrfs_write_super,
 	.sync_fs	= btrfs_sync_fs,
 	.show_options	= btrfs_show_options,
 	.write_inode	= btrfs_write_inode,

commit 067c28adc53807514ac0c6ebb6af3243cbd071fa
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Jun 11 09:30:13 2009 -0400

    Btrfs: fix -o nodatasum printk spelling
    
    It was printing nodatacsum, which was not the correct option name.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3427db28f6fe..708ac06b953b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -159,7 +159,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			 */
 			break;
 		case Opt_nodatasum:
-			printk(KERN_INFO "btrfs: setting nodatacsum\n");
+			printk(KERN_INFO "btrfs: setting nodatasum\n");
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_nodatacow:

commit c289811cc096c57ff35550ee8132793a4f9b5b59
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 10 09:51:32 2009 -0400

    Btrfs: autodetect SSD devices
    
    During mount, btrfs will check the queue nonrot flag
    for all the devices found in the FS.  If they are all
    non-rotating, SSD mode is enabled by default.
    
    If the FS was mounted with -o nossd, the non-rotating
    flag is ignored.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7f5b2889949a..3427db28f6fe 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -184,6 +184,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_nossd:
 			printk(KERN_INFO "btrfs: not using ssd allocation "
 			       "scheme\n");
+			btrfs_set_opt(info->mount_opt, NOSSD);
 			btrfs_clear_opt(info->mount_opt, SSD);
 			btrfs_clear_opt(info->mount_opt, SSD_SPREAD);
 			break;
@@ -438,6 +439,8 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);
 	if (btrfs_test_opt(root, COMPRESS))
 		seq_puts(seq, ",compress");
+	if (btrfs_test_opt(root, NOSSD))
+		seq_puts(seq, ",nossd");
 	if (btrfs_test_opt(root, SSD_SPREAD))
 		seq_puts(seq, ",ssd_spread");
 	else if (btrfs_test_opt(root, SSD))

commit 451d7585a8bb1b9bec0d676ce3dece1923164e55
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jun 9 20:28:34 2009 -0400

    Btrfs: add mount -o ssd_spread to spread allocations out
    
    Some SSDs perform best when reusing block numbers often, while
    others perform much better when clustering strictly allocates
    big chunks of unused space.
    
    The default mount -o ssd will find rough groupings of blocks
    where there are a bunch of free blocks that might have some
    allocated blocks mixed in.
    
    mount -o ssd_spread will make sure there are no allocated blocks
    mixed in.  It should perform better on lower end SSDs.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 22855a18eb48..7f5b2889949a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -66,8 +66,8 @@ static void btrfs_put_super(struct super_block *sb)
 enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
-	Opt_ssd, Opt_nossd, Opt_thread_pool, Opt_noacl,  Opt_compress,
-	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_err,
+	Opt_ssd, Opt_nossd, Opt_ssd_spread, Opt_thread_pool, Opt_noacl,
+	Opt_compress, Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -83,6 +83,7 @@ static match_table_t tokens = {
 	{Opt_thread_pool, "thread_pool=%d"},
 	{Opt_compress, "compress"},
 	{Opt_ssd, "ssd"},
+	{Opt_ssd_spread, "ssd_spread"},
 	{Opt_nossd, "nossd"},
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
@@ -174,9 +175,17 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: use ssd allocation scheme\n");
 			btrfs_set_opt(info->mount_opt, SSD);
 			break;
+		case Opt_ssd_spread:
+			printk(KERN_INFO "btrfs: use spread ssd "
+			       "allocation scheme\n");
+			btrfs_set_opt(info->mount_opt, SSD);
+			btrfs_set_opt(info->mount_opt, SSD_SPREAD);
+			break;
 		case Opt_nossd:
-			printk(KERN_INFO "btrfs: not using ssd allocation scheme\n");
+			printk(KERN_INFO "btrfs: not using ssd allocation "
+			       "scheme\n");
 			btrfs_clear_opt(info->mount_opt, SSD);
+			btrfs_clear_opt(info->mount_opt, SSD_SPREAD);
 			break;
 		case Opt_nobarrier:
 			printk(KERN_INFO "btrfs: turning off barriers\n");
@@ -429,7 +438,9 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);
 	if (btrfs_test_opt(root, COMPRESS))
 		seq_puts(seq, ",compress");
-	if (btrfs_test_opt(root, SSD))
+	if (btrfs_test_opt(root, SSD_SPREAD))
+		seq_puts(seq, ",ssd_spread");
+	else if (btrfs_test_opt(root, SSD))
 		seq_puts(seq, ",ssd");
 	if (btrfs_test_opt(root, NOTREELOG))
 		seq_puts(seq, ",notreelog");

commit 3b30c22f64a6bb297719c60e494af1d26563f584
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jun 9 16:42:22 2009 -0400

    Btrfs: Add mount -o nossd
    
    This allows you to turn off the ssd mode via remount.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e9ef8c3307fe..22855a18eb48 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -66,8 +66,8 @@ static void btrfs_put_super(struct super_block *sb)
 enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
-	Opt_ssd, Opt_thread_pool, Opt_noacl,  Opt_compress, Opt_notreelog,
-	Opt_ratio, Opt_flushoncommit, Opt_err,
+	Opt_ssd, Opt_nossd, Opt_thread_pool, Opt_noacl,  Opt_compress,
+	Opt_notreelog, Opt_ratio, Opt_flushoncommit, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -83,6 +83,7 @@ static match_table_t tokens = {
 	{Opt_thread_pool, "thread_pool=%d"},
 	{Opt_compress, "compress"},
 	{Opt_ssd, "ssd"},
+	{Opt_nossd, "nossd"},
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
 	{Opt_flushoncommit, "flushoncommit"},
@@ -173,6 +174,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: use ssd allocation scheme\n");
 			btrfs_set_opt(info->mount_opt, SSD);
 			break;
+		case Opt_nossd:
+			printk(KERN_INFO "btrfs: not using ssd allocation scheme\n");
+			btrfs_clear_opt(info->mount_opt, SSD);
+			break;
 		case Opt_nobarrier:
 			printk(KERN_INFO "btrfs: turning off barriers\n");
 			btrfs_set_opt(info->mount_opt, NOBARRIER);

commit 5d4f98a28c7d334091c1b7744f48a1acdd2a4ae0
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Wed Jun 10 10:45:14 2009 -0400

    Btrfs: Mixed back reference  (FORWARD ROLLING FORMAT CHANGE)
    
    This commit introduces a new kind of back reference for btrfs metadata.
    Once a filesystem has been mounted with this commit, IT WILL NO LONGER
    BE MOUNTABLE BY OLDER KERNELS.
    
    When a tree block in subvolume tree is cow'd, the reference counts of all
    extents it points to are increased by one.  At transaction commit time,
    the old root of the subvolume is recorded in a "dead root" data structure,
    and the btree it points to is later walked, dropping reference counts
    and freeing any blocks where the reference count goes to 0.
    
    The increments done during cow and decrements done after commit cancel out,
    and the walk is a very expensive way to go about freeing the blocks that
    are no longer referenced by the new btree root.  This commit reduces the
    transaction overhead by avoiding the need for dead root records.
    
    When a non-shared tree block is cow'd, we free the old block at once, and the
    new block inherits old block's references. When a tree block with reference
    count > 1 is cow'd, we increase the reference counts of all extents
    the new block points to by one, and decrease the old block's reference count by
    one.
    
    This dead tree avoidance code removes the need to modify the reference
    counts of lower level extents when a non-shared tree block is cow'd.
    But we still need to update back ref for all pointers in the block.
    This is because the location of the block is recorded in the back ref
    item.
    
    We can solve this by introducing a new type of back ref. The new
    back ref provides information about pointer's key, level and in which
    tree the pointer lives. This information allow us to find the pointer
    by searching the tree. The shortcoming of the new back ref is that it
    only works for pointers in tree blocks referenced by their owner trees.
    
    This is mostly a problem for snapshots, where resolving one of these
    fuzzy back references would be O(number_of_snapshots) and quite slow.
    The solution used here is to use the fuzzy back references in the common
    case where a given tree block is only referenced by one root,
    and use the full back references when multiple roots have a reference
    on a given block.
    
    This commit adds per subvolume red-black tree to keep trace of cached
    inodes. The red-black tree helps the balancing code to find cached
    inodes whose inode numbers within a given range.
    
    This commit improves the balancing code by introducing several data
    structures to keep the state of balancing. The most important one
    is the back ref cache. It caches how the upper level tree blocks are
    referenced. This greatly reduce the overhead of checking back ref.
    
    The improved balancing code scales significantly better with a large
    number of snapshots.
    
    This is a very large commit and was written in a number of
    pieces.  But, they depend heavily on the disk format change and were
    squashed together to make sure git bisect didn't end up in a
    bad state wrt space balancing or the format change.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2ff7cd2db25f..e9ef8c3307fe 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -52,7 +52,6 @@
 #include "export.h"
 #include "compression.h"
 
-
 static struct super_operations btrfs_super_ops;
 
 static void btrfs_put_super(struct super_block *sb)
@@ -322,7 +321,7 @@ static int btrfs_fill_super(struct super_block *sb,
 	struct dentry *root_dentry;
 	struct btrfs_super_block *disk_super;
 	struct btrfs_root *tree_root;
-	struct btrfs_inode *bi;
+	struct btrfs_key key;
 	int err;
 
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
@@ -341,23 +340,15 @@ static int btrfs_fill_super(struct super_block *sb,
 	}
 	sb->s_fs_info = tree_root;
 	disk_super = &tree_root->fs_info->super_copy;
-	inode = btrfs_iget_locked(sb, BTRFS_FIRST_FREE_OBJECTID,
-				  tree_root->fs_info->fs_root);
-	bi = BTRFS_I(inode);
-	bi->location.objectid = inode->i_ino;
-	bi->location.offset = 0;
-	bi->root = tree_root->fs_info->fs_root;
-
-	btrfs_set_key_type(&bi->location, BTRFS_INODE_ITEM_KEY);
 
-	if (!inode) {
-		err = -ENOMEM;
+	key.objectid = BTRFS_FIRST_FREE_OBJECTID;
+	key.type = BTRFS_INODE_ITEM_KEY;
+	key.offset = 0;
+	inode = btrfs_iget(sb, &key, tree_root->fs_info->fs_root);
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
 		goto fail_close;
 	}
-	if (inode->i_state & I_NEW) {
-		btrfs_read_locked_inode(inode);
-		unlock_new_inode(inode);
-	}
 
 	root_dentry = d_alloc_root(inode);
 	if (!root_dentry) {
@@ -584,7 +575,8 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		if (btrfs_super_log_root(&root->fs_info->super_copy) != 0)
 			return -EINVAL;
 
-		ret = btrfs_cleanup_reloc_trees(root);
+		/* recover relocation */
+		ret = btrfs_recover_relocation(root);
 		WARN_ON(ret);
 
 		ret = btrfs_cleanup_fs_roots(root->fs_info);

commit 5732c468495effd3089c1c893f3eba9a8a1d373c
Merge: 45d447406a19 9f55684c2d98
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 14 19:18:44 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: Spelling fix in btrfs_lookup_first_block_group comments
      Btrfs: make show_options result match actual option names
      Btrfs: remove outdated comment in btrfs_ioctl_resize()
      Btrfs: remove some WARN_ONs in the IO failure path
      Btrfs: Don't loop forever on metadata IO failures
      Btrfs: init inode ordered_data_close flag properly

commit 6b65c5c61bf86086817a5ed786c8f45755ac83b3
Author: Sage Weil <sage@newdream.net>
Date:   Thu May 14 13:52:21 2009 -0400

    Btrfs: make show_options result match actual option names
    
    The notreelog and flushoncommit mount options were being printed slightly
    differently.
    
    Signed-off-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index bf0e84c75607..e99510bfbffd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -436,9 +436,9 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 	if (btrfs_test_opt(root, SSD))
 		seq_puts(seq, ",ssd");
 	if (btrfs_test_opt(root, NOTREELOG))
-		seq_puts(seq, ",no-treelog");
+		seq_puts(seq, ",notreelog");
 	if (btrfs_test_opt(root, FLUSHONCOMMIT))
-		seq_puts(seq, ",flush-on-commit");
+		seq_puts(seq, ",flushoncommit");
 	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
 		seq_puts(seq, ",noacl");
 	return 0;

commit 6f5bbff9a1b7d6864a495763448a363bbfa96324
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 6 01:34:22 2009 -0400

    Convert obvious places to deactivate_locked_super()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3536bdb2d7cb..6dfae5b28f59 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -502,8 +502,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 
 	if (s->s_root) {
 		if ((flags ^ s->s_flags) & MS_RDONLY) {
-			up_write(&s->s_umount);
-			deactivate_super(s);
+			deactivate_locked_super(s);
 			error = -EBUSY;
 			goto error_close_devices;
 		}
@@ -517,8 +516,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);
 		if (error) {
-			up_write(&s->s_umount);
-			deactivate_super(s);
+			deactivate_locked_super(s);
 			goto error_free_subvol_name;
 		}
 
@@ -535,15 +533,13 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		mutex_unlock(&s->s_root->d_inode->i_mutex);
 
 		if (IS_ERR(root)) {
-			up_write(&s->s_umount);
-			deactivate_super(s);
+			deactivate_locked_super(s);
 			error = PTR_ERR(root);
 			goto error_free_subvol_name;
 		}
 		if (!root->d_inode) {
 			dput(root);
-			up_write(&s->s_umount);
-			deactivate_super(s);
+			deactivate_locked_super(s);
 			error = -ENXIO;
 			goto error_free_subvol_name;
 		}

commit 4ebf66233798347a73b01da5d30d5d2c0ef39f56
Merge: 14b6084daa61 46a53cca826e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 27 11:16:33 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: look for acls during btrfs_read_locked_inode
      Btrfs: fix acl caching
      Btrfs: Fix a bunch of printk() warnings.
      Btrfs: Fix a trivial warning using max() of u64 vs ULL.
      Btrfs: remove unused btrfs_bit_radix slab
      Btrfs: ratelimit IO error printks
      Btrfs: remove #if 0 code
      Btrfs: When shrinking, only update disk size on success
      Btrfs: fix deadlocks and stalls on dead root removal
      Btrfs: fix fallocate deadlock on inode extent lock
      Btrfs: kill btrfs_cache_create
      Btrfs: don't export symbols
      Btrfs: simplify makefile
      Btrfs: try to keep a healthy ratio of metadata vs data block groups

commit 21380931eb4da4e29ac663d0221581282cbba208
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Apr 21 12:38:29 2009 -0700

    Btrfs: Fix a bunch of printk() warnings.
    
    Just happened to notice a bunch of %llu vs u64 warnings.  Here's a patch
    to cast them all.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 30c9a8ca2a54..bf0e84c75607 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -196,7 +196,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				info->max_extent = max_t(u64,
 					info->max_extent, root->sectorsize);
 				printk(KERN_INFO "btrfs: max_extent at %llu\n",
-				       info->max_extent);
+				       (unsigned long long)info->max_extent);
 			}
 			break;
 		case Opt_max_inline:
@@ -211,7 +211,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 						root->sectorsize);
 				}
 				printk(KERN_INFO "btrfs: max_inline at %llu\n",
-					info->max_inline);
+					(unsigned long long)info->max_inline);
 			}
 			break;
 		case Opt_alloc_start:
@@ -221,7 +221,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				kfree(num);
 				printk(KERN_INFO
 					"btrfs: allocations start at %llu\n",
-					info->alloc_start);
+					(unsigned long long)info->alloc_start);
 			}
 			break;
 		case Opt_noacl:
@@ -420,11 +420,14 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 	if (btrfs_test_opt(root, NOBARRIER))
 		seq_puts(seq, ",nobarrier");
 	if (info->max_extent != (u64)-1)
-		seq_printf(seq, ",max_extent=%llu", info->max_extent);
+		seq_printf(seq, ",max_extent=%llu",
+			   (unsigned long long)info->max_extent);
 	if (info->max_inline != 8192 * 1024)
-		seq_printf(seq, ",max_inline=%llu", info->max_inline);
+		seq_printf(seq, ",max_inline=%llu",
+			   (unsigned long long)info->max_inline);
 	if (info->alloc_start != 0)
-		seq_printf(seq, ",alloc_start=%llu", info->alloc_start);
+		seq_printf(seq, ",alloc_start=%llu",
+			   (unsigned long long)info->alloc_start);
 	if (info->thread_pool_size !=  min_t(unsigned long,
 					     num_online_cpus() + 2, 8))
 		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);

commit 97e728d4353f38c87bf0804cdfd79a9b13fc2c3e
Author: Josef Bacik <jbacik@redhat.com>
Date:   Tue Apr 21 17:40:57 2009 -0400

    Btrfs: try to keep a healthy ratio of metadata vs data block groups
    
    This patch makes the chunk allocator keep a good ratio of metadata vs data
    block groups.  By default for every 8 data block groups, we'll allocate 1
    metadata chunk, or about 12% of the disk will be allocated for metadata.  This
    can be changed by specifying the metadata_ratio mount option.
    
    This is simply the number of data block groups that have to be allocated to
    force a metadata chunk allocation.  By making sure we allocate metadata chunks
    more often, we are less likely to get into situations where the whole disk
    has been allocated as data block groups.
    
    Signed-off-by: Josef Bacik <jbacik@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9744af9d71e9..30c9a8ca2a54 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -68,7 +68,7 @@ enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
 	Opt_ssd, Opt_thread_pool, Opt_noacl,  Opt_compress, Opt_notreelog,
-	Opt_flushoncommit, Opt_err,
+	Opt_ratio, Opt_flushoncommit, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -87,6 +87,7 @@ static match_table_t tokens = {
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
 	{Opt_flushoncommit, "flushoncommit"},
+	{Opt_ratio, "metadata_ratio=%d"},
 	{Opt_err, NULL},
 };
 
@@ -234,6 +235,15 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: turning on flush-on-commit\n");
 			btrfs_set_opt(info->mount_opt, FLUSHONCOMMIT);
 			break;
+		case Opt_ratio:
+			intarg = 0;
+			match_int(&args[0], &intarg);
+			if (intarg) {
+				info->metadata_ratio = intarg;
+				printk(KERN_INFO "btrfs: metadata ratio %d\n",
+				       info->metadata_ratio);
+			}
+			break;
 		default:
 			break;
 		}

commit dae7b665cf6d6e6e733f1c9c16cf55547dd37e33
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Wed Apr 8 15:06:54 2009 +0800

    btrfs: use memdup_user()
    
    Remove open-coded memdup_user().
    
    Note this changes some GFP_NOFS to GFP_KERNEL, since copy_from_user() may
    cause pagefault, it's pointless to pass GFP_NOFS to kmalloc().
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9744af9d71e9..a7acfe639a44 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -635,14 +635,9 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	vol = kmalloc(sizeof(*vol), GFP_KERNEL);
-	if (!vol)
-		return -ENOMEM;
-
-	if (copy_from_user(vol, (void __user *)arg, sizeof(*vol))) {
-		ret = -EFAULT;
-		goto out;
-	}
+	vol = memdup_user((void __user *)arg, sizeof(*vol));
+	if (IS_ERR(vol))
+		return PTR_ERR(vol);
 
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:
@@ -650,7 +645,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 					    &btrfs_fs_type, &fs_devices);
 		break;
 	}
-out:
+
 	kfree(vol);
 	return ret;
 }

commit dccae99995089641fbac452ebc7f0cab18751ddb
Author: Sage Weil <sage@newdream.net>
Date:   Thu Apr 2 16:59:01 2009 -0400

    Btrfs: add flushoncommit mount option
    
    The 'flushoncommit' mount option forces any data dirtied by a write in a
    prior transaction to commit as part of the current commit.  This makes
    the committed state a fully consistent view of the file system from the
    application's perspective (i.e., it includes all completed file system
    operations).  This was previously the behavior only when a snapshot is
    created.
    
    This is used by Ceph to ensure that completed writes make it to the
    platter along with the metadata operations they are bound to (by
    BTRFS_IOC_TRANS_{START,END}).
    
    Signed-off-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3baa2c109e55..9744af9d71e9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -68,7 +68,7 @@ enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
 	Opt_ssd, Opt_thread_pool, Opt_noacl,  Opt_compress, Opt_notreelog,
-	Opt_err,
+	Opt_flushoncommit, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -86,6 +86,7 @@ static match_table_t tokens = {
 	{Opt_ssd, "ssd"},
 	{Opt_noacl, "noacl"},
 	{Opt_notreelog, "notreelog"},
+	{Opt_flushoncommit, "flushoncommit"},
 	{Opt_err, NULL},
 };
 
@@ -229,6 +230,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: disabling tree log\n");
 			btrfs_set_opt(info->mount_opt, NOTREELOG);
 			break;
+		case Opt_flushoncommit:
+			printk(KERN_INFO "btrfs: turning on flush-on-commit\n");
+			btrfs_set_opt(info->mount_opt, FLUSHONCOMMIT);
+			break;
 		default:
 			break;
 		}
@@ -370,9 +375,8 @@ static int btrfs_fill_super(struct super_block *sb,
 int btrfs_sync_fs(struct super_block *sb, int wait)
 {
 	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root;
+	struct btrfs_root *root = btrfs_sb(sb);
 	int ret;
-	root = btrfs_sb(sb);
 
 	if (sb->s_flags & MS_RDONLY)
 		return 0;
@@ -419,7 +423,9 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 	if (btrfs_test_opt(root, SSD))
 		seq_puts(seq, ",ssd");
 	if (btrfs_test_opt(root, NOTREELOG))
-		seq_puts(seq, ",notreelog");
+		seq_puts(seq, ",no-treelog");
+	if (btrfs_test_opt(root, FLUSHONCOMMIT))
+		seq_puts(seq, ",flush-on-commit");
 	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
 		seq_puts(seq, ",noacl");
 	return 0;

commit 3a5e14048a0a81276d284cbda441507a17e26147
Author: Sage Weil <sage@newdream.net>
Date:   Thu Apr 2 16:49:40 2009 -0400

    Btrfs: notreelog mount option
    
    Add a 'notreelog' mount option to disable the tree log (used by fsync,
    O_SYNC writes).  This is much slower, but the tree logging produces
    inconsistent views into the FS for ceph.
    
    Signed-off-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2ceb40b794a8..3baa2c109e55 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -67,7 +67,8 @@ static void btrfs_put_super(struct super_block *sb)
 enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
-	Opt_ssd, Opt_thread_pool, Opt_noacl,  Opt_compress, Opt_err,
+	Opt_ssd, Opt_thread_pool, Opt_noacl,  Opt_compress, Opt_notreelog,
+	Opt_err,
 };
 
 static match_table_t tokens = {
@@ -84,6 +85,7 @@ static match_table_t tokens = {
 	{Opt_compress, "compress"},
 	{Opt_ssd, "ssd"},
 	{Opt_noacl, "noacl"},
+	{Opt_notreelog, "notreelog"},
 	{Opt_err, NULL},
 };
 
@@ -223,6 +225,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 		case Opt_noacl:
 			root->fs_info->sb->s_flags &= ~MS_POSIXACL;
 			break;
+		case Opt_notreelog:
+			printk(KERN_INFO "btrfs: disabling tree log\n");
+			btrfs_set_opt(info->mount_opt, NOTREELOG);
+			break;
 		default:
 			break;
 		}
@@ -412,6 +418,8 @@ static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 		seq_puts(seq, ",compress");
 	if (btrfs_test_opt(root, SSD))
 		seq_puts(seq, ",ssd");
+	if (btrfs_test_opt(root, NOTREELOG))
+		seq_puts(seq, ",notreelog");
 	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
 		seq_puts(seq, ",noacl");
 	return 0;

commit a9572a15a854bd40453a6b7b4dd9d29132f64c64
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Apr 2 16:46:06 2009 -0400

    Btrfs: introduce btrfs_show_options
    
    btrfs options can change at times other than mount, yet /proc/mounts shows the
    options string used when the fs was mounted (an example would be when btrfs
    determines that barriers aren't useful and turns them off.)  This patch
    instead outputs the actual options in use by btrfs.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 19a4daf03ccb..2ceb40b794a8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -24,6 +24,7 @@
 #include <linux/highmem.h>
 #include <linux/time.h>
 #include <linux/init.h>
+#include <linux/seq_file.h>
 #include <linux/string.h>
 #include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
@@ -385,6 +386,37 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	return ret;
 }
 
+static int btrfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
+{
+	struct btrfs_root *root = btrfs_sb(vfs->mnt_sb);
+	struct btrfs_fs_info *info = root->fs_info;
+
+	if (btrfs_test_opt(root, DEGRADED))
+		seq_puts(seq, ",degraded");
+	if (btrfs_test_opt(root, NODATASUM))
+		seq_puts(seq, ",nodatasum");
+	if (btrfs_test_opt(root, NODATACOW))
+		seq_puts(seq, ",nodatacow");
+	if (btrfs_test_opt(root, NOBARRIER))
+		seq_puts(seq, ",nobarrier");
+	if (info->max_extent != (u64)-1)
+		seq_printf(seq, ",max_extent=%llu", info->max_extent);
+	if (info->max_inline != 8192 * 1024)
+		seq_printf(seq, ",max_inline=%llu", info->max_inline);
+	if (info->alloc_start != 0)
+		seq_printf(seq, ",alloc_start=%llu", info->alloc_start);
+	if (info->thread_pool_size !=  min_t(unsigned long,
+					     num_online_cpus() + 2, 8))
+		seq_printf(seq, ",thread_pool=%d", info->thread_pool_size);
+	if (btrfs_test_opt(root, COMPRESS))
+		seq_puts(seq, ",compress");
+	if (btrfs_test_opt(root, SSD))
+		seq_puts(seq, ",ssd");
+	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
+		seq_puts(seq, ",noacl");
+	return 0;
+}
+
 static void btrfs_write_super(struct super_block *sb)
 {
 	sb->s_dirt = 0;
@@ -630,7 +662,7 @@ static struct super_operations btrfs_super_ops = {
 	.put_super	= btrfs_put_super,
 	.write_super	= btrfs_write_super,
 	.sync_fs	= btrfs_sync_fs,
-	.show_options	= generic_show_options,
+	.show_options	= btrfs_show_options,
 	.write_inode	= btrfs_write_inode,
 	.dirty_inode	= btrfs_dirty_inode,
 	.alloc_inode	= btrfs_alloc_inode,

commit e1df36d2f18254d0690a0fbe036cece74ec311b8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Feb 12 09:45:08 2009 -0500

    Btrfs: don't clean old snapshots on sync(1)
    
    Cleaning old snapshots can make sync(1) somewhat slow, and some users
    and applications still use it in a global fsync kind of workload.
    
    This patch changes btrfs not to clean old snapshots during sync, which is
    safe from a FS consistency point of view.  The major downside is that it
    makes it difficult to tell when old snapshots have been reaped and
    the space they were using has been reclaimed.  A new ioctl will be added
    for this purpose instead.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 66b8341e2dba..19a4daf03ccb 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -379,7 +379,6 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	btrfs_start_delalloc_inodes(root);
 	btrfs_wait_ordered_extents(root, 0);
 
-	btrfs_clean_old_snapshots(root);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);
 	sb->s_dirt = 0;

commit b288052e1779261ae80138074989ef50358c4e58
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Feb 12 09:37:35 2009 -0500

    Btrfs: process mount options on mount -o remount,
    
    Btrfs wasn't parsing any new mount options during remount, making it
    difficult to set mount options on a root drive.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f3fd7e2cbc38..66b8341e2dba 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -511,6 +511,10 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 	struct btrfs_root *root = btrfs_sb(sb);
 	int ret;
 
+	ret = btrfs_parse_options(root, data);
+	if (ret)
+		return -EINVAL;
+
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
 		return 0;
 

commit e4f722fa42537bcb0ff14322a57dc3870d093cab
Merge: 18e352e4a734 a717531942f4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jan 28 20:29:43 2009 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    Fix fs/btrfs/super.c conflict around #includes

commit 7eaebe7d503c3ef240ac7b3efc5433fe647c0298
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Wed Jan 21 10:49:16 2009 -0500

    Btrfs: removed unused #include <version.h>'s
    
    Removed unused #include <version.h>'s in btrfs
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 795b6246bcdf..4c0b7569ba52 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -37,7 +37,6 @@
 #include <linux/ctype.h>
 #include <linux/namei.h>
 #include <linux/miscdevice.h>
-#include <linux/version.h>
 #include "compat.h"
 #include "ctree.h"
 #include "disk-io.h"

commit 19d00cc196a3a66fd074f62b39d219f743b92338
Author: Wang Cong <xiyou.wangcong@gmail.com>
Date:   Wed Jan 21 10:49:16 2009 -0500

    Btrfs: cleanup fs/btrfs/super.c::btrfs_control_ioctl()
    
    - Remove the unused local variable 'len';
    - Check return value of kmalloc().
    
    Signed-off-by: Wang Cong <wangcong@zeuux.org>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 92c9b543deff..795b6246bcdf 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -583,17 +583,18 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	struct btrfs_ioctl_vol_args *vol;
 	struct btrfs_fs_devices *fs_devices;
 	int ret = -ENOTTY;
-	int len;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	vol = kmalloc(sizeof(*vol), GFP_KERNEL);
+	if (!vol)
+		return -ENOMEM;
+
 	if (copy_from_user(vol, (void __user *)arg, sizeof(*vol))) {
 		ret = -EFAULT;
 		goto out;
 	}
-	len = strnlen(vol->name, BTRFS_PATH_NAME_MAX);
 
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:

commit 4b48d9d44ebe0e8c31b4fe3b7480941576fff613
Merge: b762666cc7c9 c071fcfdb60e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 16 09:32:33 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: fix ioctl arg size (userland incompatible change!)
      Btrfs: Clear the device->running_pending flag before bailing on congestion

commit c071fcfdb60e7abbe95e02460005d6bca165bf24
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jan 16 11:59:08 2009 -0500

    Btrfs: fix ioctl arg size (userland incompatible change!)
    
    The structure used to send device in btrfs ioctl calls was not
    properly aligned, and so 32 bit ioctls would not work properly on
    64 bit kernels.
    
    We could fix this with compat ioctls, but we're just one byte away
    and it doesn't make sense at this stage to carry about the compat ioctls
    forever at this stage in the project.
    
    This patch brings the ioctl arg up to an evenly aligned 4k.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b4c101d9322c..92c9b543deff 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -582,7 +582,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 {
 	struct btrfs_ioctl_vol_args *vol;
 	struct btrfs_fs_devices *fs_devices;
-	int ret = 0;
+	int ret = -ENOTTY;
 	int len;
 
 	if (!capable(CAP_SYS_ADMIN))
@@ -594,6 +594,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 		goto out;
 	}
 	len = strnlen(vol->name, BTRFS_PATH_NAME_MAX);
+
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:
 		ret = btrfs_scan_one_device(vol->name, FMODE_READ,

commit 1bcbf31337391a2f54ef6c1e8871c2de5944a7dc
Author: Qinghuang Feng <qhfeng.kernel@gmail.com>
Date:   Thu Jan 15 13:51:03 2009 -0800

    btrfs & squashfs: Move btrfs and squashfsto's magic number to <linux/magic.h>
    
    Use the standard magic.h for btrfs and squashfs.
    
    Signed-off-by: Qinghuang Feng <qhfeng.kernel@gmail.com>
    Cc: Phillip Lougher <phillip@lougher.demon.co.uk>
    Cc: Chris Mason <chris.mason@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0a14b495532f..7256cf242eb0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -38,6 +38,7 @@
 #include <linux/namei.h>
 #include <linux/miscdevice.h>
 #include <linux/version.h>
+#include <linux/magic.h>
 #include "compat.h"
 #include "ctree.h"
 #include "disk-io.h"
@@ -51,7 +52,6 @@
 #include "export.h"
 #include "compression.h"
 
-#define BTRFS_SUPER_MAGIC 0x9123683E
 
 static struct super_operations btrfs_super_ops;
 

commit 0176260fc30842e358cf34afa7dcd9413db44822
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 10 06:09:52 2009 -0800

    btrfs: fix for write_super_lockfs/unlockfs error handling
    
    Commit c4be0c1dc4cdc37b175579be1460f15ac6495e9a added the ability for
    write_super_lockfs to return errors, and renamed them to match.  But
    btrfs didn't get converted.
    
    Do the minimal conversion to make it compile again.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b4c101d9322c..0a14b495532f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -605,18 +605,20 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	return ret;
 }
 
-static void btrfs_write_super_lockfs(struct super_block *sb)
+static int btrfs_freeze(struct super_block *sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
 	mutex_lock(&root->fs_info->transaction_kthread_mutex);
 	mutex_lock(&root->fs_info->cleaner_mutex);
+	return 0;
 }
 
-static void btrfs_unlockfs(struct super_block *sb)
+static int btrfs_unfreeze(struct super_block *sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
 	mutex_unlock(&root->fs_info->cleaner_mutex);
 	mutex_unlock(&root->fs_info->transaction_kthread_mutex);
+	return 0;
 }
 
 static struct super_operations btrfs_super_ops = {
@@ -631,8 +633,8 @@ static struct super_operations btrfs_super_ops = {
 	.destroy_inode	= btrfs_destroy_inode,
 	.statfs		= btrfs_statfs,
 	.remount_fs	= btrfs_remount,
-	.write_super_lockfs = btrfs_write_super_lockfs,
-	.unlockfs	= btrfs_unlockfs,
+	.freeze_fs	= btrfs_freeze,
+	.unfreeze_fs	= btrfs_unfreeze,
 };
 
 static const struct file_operations btrfs_ctl_fops = {

commit d397712bcc6a759a560fd247e6053ecae091f958
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 5 21:25:51 2009 -0500

    Btrfs: Fix checkpatch.pl warnings
    
    There were many, most are fixed now.  struct-funcs.c generates some warnings
    but these are bogus.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ccdcb7bb7ad8..b4c101d9322c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -55,18 +55,12 @@
 
 static struct super_operations btrfs_super_ops;
 
-static void btrfs_put_super (struct super_block * sb)
+static void btrfs_put_super(struct super_block *sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
 	int ret;
 
 	ret = close_ctree(root);
-	if (ret) {
-		printk("close ctree returns %d\n", ret);
-	}
-#if 0
-	btrfs_sysfs_del_super(root->fs_info);
-#endif
 	sb->s_fs_info = NULL;
 }
 
@@ -299,12 +293,12 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags,
 	return error;
 }
 
-static int btrfs_fill_super(struct super_block * sb,
+static int btrfs_fill_super(struct super_block *sb,
 			    struct btrfs_fs_devices *fs_devices,
-			    void * data, int silent)
+			    void *data, int silent)
 {
-	struct inode * inode;
-	struct dentry * root_dentry;
+	struct inode *inode;
+	struct dentry *root_dentry;
 	struct btrfs_super_block *disk_super;
 	struct btrfs_root *tree_root;
 	struct btrfs_inode *bi;
@@ -479,8 +473,10 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		root = dget(s->s_root);
 	else {
 		mutex_lock(&s->s_root->d_inode->i_mutex);
-		root = lookup_one_len(subvol_name, s->s_root, strlen(subvol_name));
+		root = lookup_one_len(subvol_name, s->s_root,
+				      strlen(subvol_name));
 		mutex_unlock(&s->s_root->d_inode->i_mutex);
+
 		if (IS_ERR(root)) {
 			up_write(&s->s_umount);
 			deactivate_super(s);
@@ -557,8 +553,9 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_bavail = buf->f_bfree;
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_type = BTRFS_SUPER_MAGIC;
+
 	/* We treat it as constant endianness (it doesn't matter _which_)
-	   because we want the fsid to come out the same whether mounted 
+	   because we want the fsid to come out the same whether mounted
 	   on a big-endian or little-endian host */
 	buf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);
 	buf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);
@@ -658,7 +655,7 @@ static int btrfs_interface_init(void)
 static void btrfs_interface_exit(void)
 {
 	if (misc_deregister(&btrfs_misc) < 0)
-		printk("misc_deregister failed for control device");
+		printk(KERN_INFO "misc_deregister failed for control device");
 }
 
 static int __init init_btrfs_fs(void)

commit 1f48366084a7b046bcb7741ed4e607774f96e3da
Author: Shen Feng <shen@cn.fujitsu.com>
Date:   Mon Jan 5 15:43:42 2009 -0500

    Btrfs: fix a memory leak in btrfs_get_sb
    
    subvol_name should be freed if error occurs.
    
    Signed-off-by: Shen Feng <shen@cn.fujitsu.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3814238d6eba..ccdcb7bb7ad8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -429,7 +429,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	error = btrfs_parse_early_options(data, mode, fs_type,
 					  &subvol_name, &fs_devices);
 	if (error)
-		goto error;
+		return error;
 
 	error = btrfs_scan_one_device(dev_name, mode, fs_type, &fs_devices);
 	if (error)
@@ -468,7 +468,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		if (error) {
 			up_write(&s->s_umount);
 			deactivate_super(s);
-			goto error;
+			goto error_free_subvol_name;
 		}
 
 		btrfs_sb(s)->fs_info->bdev_holder = fs_type;
@@ -485,14 +485,14 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 			up_write(&s->s_umount);
 			deactivate_super(s);
 			error = PTR_ERR(root);
-			goto error;
+			goto error_free_subvol_name;
 		}
 		if (!root->d_inode) {
 			dput(root);
 			up_write(&s->s_umount);
 			deactivate_super(s);
 			error = -ENXIO;
-			goto error;
+			goto error_free_subvol_name;
 		}
 	}
 
@@ -508,7 +508,6 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	btrfs_close_devices(fs_devices);
 error_free_subvol_name:
 	kfree(subvol_name);
-error:
 	return error;
 }
 

commit e441d54de4fd97dd381f3e73636f5ba51ff4c7d9
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 5 16:57:23 2009 -0500

    Btrfs: add permission checks to the ioctls
    
    Only root can add/remove devices
    Only root can defrag subtrees
    Only files open for writing can be defragged
    Only files open for writing can be the destination for a clone
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 84c3b66564d0..3814238d6eba 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -589,6 +589,9 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	int ret = 0;
 	int len;
 
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
 	vol = kmalloc(sizeof(*vol), GFP_KERNEL);
 	if (copy_from_user(vol, (void __user *)arg, sizeof(*vol))) {
 		ret = -EFAULT;

commit e4404d6e8da678d852b7f767f665f8edf76c9e9f
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Fri Dec 12 10:03:26 2008 -0500

    Btrfs: shared seed device
    
    This patch makes seed device possible to be shared by
    multiple mounted file systems. The sharing is achieved
    by cloning seed device's btrfs_fs_devices structure.
    Thanks you,
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 09908f25fca9..84c3b66564d0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -58,14 +58,15 @@ static struct super_operations btrfs_super_ops;
 static void btrfs_put_super (struct super_block * sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
-	struct btrfs_fs_info *fs = root->fs_info;
 	int ret;
 
 	ret = close_ctree(root);
 	if (ret) {
 		printk("close ctree returns %d\n", ret);
 	}
-	btrfs_sysfs_del_super(fs);
+#if 0
+	btrfs_sysfs_del_super(root->fs_info);
+#endif
 	sb->s_fs_info = NULL;
 }
 
@@ -349,11 +350,12 @@ static int btrfs_fill_super(struct super_block * sb,
 		err = -ENOMEM;
 		goto fail_close;
 	}
-
+#if 0
 	/* this does the super kobj at the same time */
 	err = btrfs_sysfs_add_super(tree_root->fs_info);
 	if (err)
 		goto fail_close;
+#endif
 
 	sb->s_root = root_dentry;
 

commit 97288f2c71e46965a2010baea10548fcb5f3af73
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Dec 2 06:36:09 2008 -0500

    Btrfs: corret fmode_t annotations
    
    Make sure to propagate fmode_t properly and use the right constants for
    it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 93a21c77064a..09908f25fca9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -242,7 +242,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
  * All other options will be parsed on much later in the mount process and
  * only when we need to allocate a new super block.
  */
-static int btrfs_parse_early_options(const char *options, int flags,
+static int btrfs_parse_early_options(const char *options, fmode_t flags,
 		void *holder, char **subvol_name,
 		struct btrfs_fs_devices **fs_devices)
 {
@@ -418,18 +418,22 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	struct super_block *s;
 	struct dentry *root;
 	struct btrfs_fs_devices *fs_devices = NULL;
+	fmode_t mode = FMODE_READ;
 	int error = 0;
 
-	error = btrfs_parse_early_options(data, flags, fs_type,
+	if (!(flags & MS_RDONLY))
+		mode |= FMODE_WRITE;
+
+	error = btrfs_parse_early_options(data, mode, fs_type,
 					  &subvol_name, &fs_devices);
 	if (error)
 		goto error;
 
-	error = btrfs_scan_one_device(dev_name, flags, fs_type, &fs_devices);
+	error = btrfs_scan_one_device(dev_name, mode, fs_type, &fs_devices);
 	if (error)
 		goto error_free_subvol_name;
 
-	error = btrfs_open_devices(fs_devices, flags, fs_type);
+	error = btrfs_open_devices(fs_devices, mode, fs_type);
 	if (error)
 		goto error_free_subvol_name;
 
@@ -591,7 +595,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	len = strnlen(vol->name, BTRFS_PATH_NAME_MAX);
 	switch (cmd) {
 	case BTRFS_IOC_SCAN_DEV:
-		ret = btrfs_scan_one_device(vol->name, MS_RDONLY,
+		ret = btrfs_scan_one_device(vol->name, FMODE_READ,
 					    &btrfs_fs_type, &fs_devices);
 		break;
 	}

commit b2950863c61bc24cf0f63bc05947d9d50663c4c0
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Dec 2 09:54:17 2008 -0500

    Btrfs: make things static and include the right headers
    
    Shut up various sparse warnings about symbols that should be either
    static or have their declarations in scope.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1975ea273dc3..93a21c77064a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -647,7 +647,7 @@ static int btrfs_interface_init(void)
 	return misc_register(&btrfs_misc);
 }
 
-void btrfs_interface_exit(void)
+static void btrfs_interface_exit(void)
 {
 	if (misc_deregister(&btrfs_misc) < 0)
 		printk("misc_deregister failed for control device");

commit 4b4e25f2a6ddb070bab7f7dd2bd2926fb8db9e04
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Nov 20 10:22:27 2008 -0500

    Btrfs: compat code fixes
    
    The btrfs git kernel trees is used to build a standalone tree for
    compiling against older kernels.  This commit makes the standalone tree
    work with 2.6.27
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 77c5eff3e209..1975ea273dc3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -37,6 +37,8 @@
 #include <linux/ctype.h>
 #include <linux/namei.h>
 #include <linux/miscdevice.h>
+#include <linux/version.h>
+#include "compat.h"
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"

commit 3de4586c5278a28107030c336956381f69ff7a9d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Nov 17 21:02:50 2008 -0500

    Btrfs: Allow subvolumes and snapshots anywhere in the directory tree
    
    Before, all snapshots and subvolumes lived in a single flat directory.  This
    was awkward and confusing because the single flat directory was only writable
    with the ioctls.
    
    This commit changes the ioctls to create subvols and snapshots at any
    point in the directory tree.  This requires making separate ioctls for
    snapshot and subvol creation instead of a combining them into one.
    
    The subvol ioctl does:
    
    btrfsctl -S subvol_name parent_dir
    
    After the ioctl is done subvol_name lives inside parent_dir.
    
    The snapshot ioctl does:
    
    btrfsctl -s path_for_snapshot root_to_snapshot
    
    path_for_snapshot can be an absolute or relative path.  btrfsctl breaks it up
    into directory and basename components.
    
    root_to_snapshot can be any file or directory in the FS.  The snapshot
    is taken of the entire root where that file lives.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 92393cc60d08..77c5eff3e209 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -285,11 +285,11 @@ static int btrfs_parse_early_options(const char *options, int flags,
  out:
 	/*
 	 * If no subvolume name is specified we use the default one.  Allocate
-	 * a copy of the string "default" here so that code later in the
+	 * a copy of the string "." here so that code later in the
 	 * mount path doesn't care if it's the default volume or another one.
 	 */
 	if (!*subvol_name) {
-		*subvol_name = kstrdup("default", GFP_KERNEL);
+		*subvol_name = kstrdup(".", GFP_KERNEL);
 		if (!*subvol_name)
 			return -ENOMEM;
 	}
@@ -323,12 +323,12 @@ static int btrfs_fill_super(struct super_block * sb,
 	}
 	sb->s_fs_info = tree_root;
 	disk_super = &tree_root->fs_info->super_copy;
-	inode = btrfs_iget_locked(sb, btrfs_super_root_dir(disk_super),
-				  tree_root);
+	inode = btrfs_iget_locked(sb, BTRFS_FIRST_FREE_OBJECTID,
+				  tree_root->fs_info->fs_root);
 	bi = BTRFS_I(inode);
 	bi->location.objectid = inode->i_ino;
 	bi->location.offset = 0;
-	bi->root = tree_root;
+	bi->root = tree_root->fs_info->fs_root;
 
 	btrfs_set_key_type(&bi->location, BTRFS_INODE_ITEM_KEY);
 

commit 2b82032c34ec40515d3c45c36cd1961f37977de8
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Mon Nov 17 21:11:30 2008 -0500

    Btrfs: Seed device support
    
    Seed device is a special btrfs with SEEDING super flag
    set and can only be mounted in read-only mode. Seed
    devices allow people to create new btrfs on top of it.
    
    The new FS contains the same contents as the seed device,
    but it can be mounted in read-write mode.
    
    This patch does the following:
    
    1) split code in btrfs_alloc_chunk into two parts. The first part does makes
    the newly allocated chunk usable, but does not do any operation that modifies
    the chunk tree. The second part does the the chunk tree modifications. This
    division is for the bootstrap step of adding storage to the seed device.
    
    2) Update device management code to handle seed device.
    The basic idea is: For an FS grown from seed devices, its
    seed devices are put into a list. Seed devices are
    opened on demand at mounting time. If any seed device is
    missing or has been changed, btrfs kernel module will
    refuse to mount the FS.
    
    3) make btrfs_find_block_group not return NULL when all
    block groups are read-only.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 04a3bf816509..92393cc60d08 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -431,6 +431,11 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	if (error)
 		goto error_free_subvol_name;
 
+	if (!(flags & MS_RDONLY) && fs_devices->rw_devices == 0) {
+		error = -EACCES;
+		goto error_close_devices;
+	}
+
 	bdev = fs_devices->latest_bdev;
 	s = sget(fs_type, btrfs_test_super, set_anon_super, fs_devices);
 	if (IS_ERR(s))
@@ -444,6 +449,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 			goto error_close_devices;
 		}
 
+		btrfs_close_devices(fs_devices);
 	} else {
 		char b[BDEVNAME_SIZE];
 
@@ -512,6 +518,9 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		ret =  btrfs_commit_super(root);
 		WARN_ON(ret);
 	} else {
+		if (root->fs_info->fs_devices->rw_devices == 0)
+			return -EACCES;
+
 		if (btrfs_super_log_root(&root->fs_info->super_copy) != 0)
 			return -EINVAL;
 

commit c146afad2c7fea6a366d4945c1bab9b03880f526
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Wed Nov 12 14:34:12 2008 -0500

    Btrfs: mount ro and remount support
    
    This patch adds mount ro and remount support. The main
    changes in patch are: adding btrfs_remount and related
    helper function; splitting the transaction related code
    out of close_ctree into btrfs_commit_super; updating
    allocator to properly handle read only block group.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ab9d5e89ed13..04a3bf816509 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -370,6 +370,9 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 	int ret;
 	root = btrfs_sb(sb);
 
+	if (sb->s_flags & MS_RDONLY)
+		return 0;
+
 	sb->s_dirt = 0;
 	if (!wait) {
 		filemap_flush(root->fs_info->btree_inode->i_mapping);
@@ -438,7 +441,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 			up_write(&s->s_umount);
 			deactivate_super(s);
 			error = -EBUSY;
-			goto error_bdev;
+			goto error_close_devices;
 		}
 
 	} else {
@@ -487,7 +490,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 
 error_s:
 	error = PTR_ERR(s);
-error_bdev:
+error_close_devices:
 	btrfs_close_devices(fs_devices);
 error_free_subvol_name:
 	kfree(subvol_name);
@@ -495,6 +498,35 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	return error;
 }
 
+static int btrfs_remount(struct super_block *sb, int *flags, char *data)
+{
+	struct btrfs_root *root = btrfs_sb(sb);
+	int ret;
+
+	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
+		return 0;
+
+	if (*flags & MS_RDONLY) {
+		sb->s_flags |= MS_RDONLY;
+
+		ret =  btrfs_commit_super(root);
+		WARN_ON(ret);
+	} else {
+		if (btrfs_super_log_root(&root->fs_info->super_copy) != 0)
+			return -EINVAL;
+
+		ret = btrfs_cleanup_reloc_trees(root);
+		WARN_ON(ret);
+
+		ret = btrfs_cleanup_fs_roots(root->fs_info);
+		WARN_ON(ret);
+
+		sb->s_flags &= ~MS_RDONLY;
+	}
+
+	return 0;
+}
+
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
@@ -582,6 +614,7 @@ static struct super_operations btrfs_super_ops = {
 	.alloc_inode	= btrfs_alloc_inode,
 	.destroy_inode	= btrfs_destroy_inode,
 	.statfs		= btrfs_statfs,
+	.remount_fs	= btrfs_remount,
 	.write_super_lockfs = btrfs_write_super_lockfs,
 	.unlockfs	= btrfs_unlockfs,
 };

commit 771ed689d2cd53439e28e095bc38fbe40a71429e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Nov 6 22:02:51 2008 -0500

    Btrfs: Optimize compressed writeback and reads
    
    When reading compressed extents, try to put pages into the page cache
    for any pages covered by the compressed extent that readpages didn't already
    preload.
    
    Add an async work queue to handle transformations at delayed allocation processing
    time.  Right now this is just compression.  The workflow is:
    
    1) Find offsets in the file marked for delayed allocation
    2) Lock the pages
    3) Lock the state bits
    4) Call the async delalloc code
    
    The async delalloc code clears the state lock bits and delalloc bits.  It is
    important this happens before the range goes into the work queue because
    otherwise it might deadlock with other work queue items that try to lock
    those extent bits.
    
    The file pages are compressed, and if the compression doesn't work the
    pages are written back directly.
    
    An ordered work queue is used to make sure the inodes are written in the same
    order that pdflush or writepages sent them down.
    
    This changes extent_write_cache_pages to let the writepage function
    update the wbc nr_written count.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 431fdf144b58..ab9d5e89ed13 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -375,6 +375,10 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		filemap_flush(root->fs_info->btree_inode->i_mapping);
 		return 0;
 	}
+
+	btrfs_start_delalloc_inodes(root);
+	btrfs_wait_ordered_extents(root, 0);
+
 	btrfs_clean_old_snapshots(root);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);

commit c8b978188c9a0fd3d535c13debd19d522b726f1f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Oct 29 14:49:59 2008 -0400

    Btrfs: Add zlib compression support
    
    This is a large change for adding compression on reading and writing,
    both for inline and regular extents.  It does some fairly large
    surgery to the writeback paths.
    
    Compression is off by default and enabled by mount -o compress.  Even
    when the -o compress mount option is not used, it is possible to read
    compressed extents off the disk.
    
    If compression for a given set of pages fails to make them smaller, the
    file is flagged to avoid future compression attempts later.
    
    * While finding delalloc extents, the pages are locked before being sent down
    to the delalloc handler.  This allows the delalloc handler to do complex things
    such as cleaning the pages, marking them writeback and starting IO on their
    behalf.
    
    * Inline extents are inserted at delalloc time now.  This allows us to compress
    the data before inserting the inline extent, and it allows us to insert
    an inline extent that spans multiple pages.
    
    * All of the in-memory extent representations (extent_map.c, ordered-data.c etc)
    are changed to record both an in-memory size and an on disk size, as well
    as a flag for compression.
    
    From a disk format point of view, the extent pointers in the file are changed
    to record the on disk size of a given extent and some encoding flags.
    Space in the disk format is allocated for compression encoding, as well
    as encryption and a generic 'other' field.  Neither the encryption or the
    'other' field are currently used.
    
    In order to limit the amount of data read for a single random read in the
    file, the size of a compressed extent is limited to 128k.  This is a
    software only limit, the disk format supports u64 sized compressed extents.
    
    In order to limit the ram consumed while processing extents, the uncompressed
    size of a compressed extent is limited to 256k.  This is a software only limit
    and will be subject to tuning later.
    
    Checksumming is still done on compressed extents, and it is done on the
    uncompressed version of the data.  This way additional encodings can be
    layered on without having to figure out which encoding to checksum.
    
    Compression happens at delalloc time, which is basically singled threaded because
    it is usually done by a single pdflush thread.  This makes it tricky to
    spread the compression load across all the cpus on the box.  We'll have to
    look at parallel pdflush walks of dirty inodes at a later time.
    
    Decompression is hooked into readpages and it does spread across CPUs nicely.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2e6039825b7b..431fdf144b58 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -47,6 +47,7 @@
 #include "volumes.h"
 #include "version.h"
 #include "export.h"
+#include "compression.h"
 
 #define BTRFS_SUPER_MAGIC 0x9123683E
 
@@ -69,7 +70,7 @@ static void btrfs_put_super (struct super_block * sb)
 enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
-	Opt_ssd, Opt_thread_pool, Opt_noacl,  Opt_err,
+	Opt_ssd, Opt_thread_pool, Opt_noacl,  Opt_compress, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -83,6 +84,7 @@ static match_table_t tokens = {
 	{Opt_max_inline, "max_inline=%s"},
 	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_thread_pool, "thread_pool=%d"},
+	{Opt_compress, "compress"},
 	{Opt_ssd, "ssd"},
 	{Opt_noacl, "noacl"},
 	{Opt_err, NULL},
@@ -163,6 +165,10 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, NODATACOW);
 			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
+		case Opt_compress:
+			printk(KERN_INFO "btrfs: use compression\n");
+			btrfs_set_opt(info->mount_opt, COMPRESS);
+			break;
 		case Opt_ssd:
 			printk(KERN_INFO "btrfs: use ssd allocation scheme\n");
 			btrfs_set_opt(info->mount_opt, SSD);
@@ -622,6 +628,7 @@ static int __init init_btrfs_fs(void)
 	err = btrfs_interface_init();
 	if (err)
 		goto free_extent_map;
+
 	err = register_filesystem(&btrfs_fs_type);
 	if (err)
 		goto unregister_ioctl;
@@ -651,6 +658,7 @@ static void __exit exit_btrfs_fs(void)
 	unregister_filesystem(&btrfs_fs_type);
 	btrfs_exit_sysfs();
 	btrfs_cleanup_fs_uuids();
+	btrfs_zlib_exit();
 }
 
 module_init(init_btrfs_fs)

commit d352ac68148b69937d39ca5d48bcc4478e118dbf
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Sep 29 15:18:18 2008 -0400

    Btrfs: add and improve comments
    
    This improves the comments at the top of many functions.  It didn't
    dive into the guts of functions because I was trying to
    avoid merging problems with the new allocator and back reference work.
    
    extent-tree.c and volumes.c were both skipped, and there is definitely
    more work todo in cleaning and commenting the code.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8399d6d05d63..2e6039825b7b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -519,6 +519,9 @@ static struct file_system_type btrfs_fs_type = {
 	.fs_flags	= FS_REQUIRES_DEV,
 };
 
+/*
+ * used by btrfsctl to scan devices when no FS is mounted
+ */
 static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg)
 {

commit 2b1f55b0f0d0d1a66470ef4ea2696cd5dd741a12
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Sep 24 11:48:04 2008 -0400

    Remove Btrfs compat code for older kernels
    
    Btrfs had compatibility code for kernels back to 2.6.18.  These have
    been removed, and will be maintained in a separate backport
    git tree from now on.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f7b3eac7ac6d..8399d6d05d63 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -349,10 +349,7 @@ static int btrfs_fill_super(struct super_block * sb,
 
 	sb->s_root = root_dentry;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
 	save_mount_options(sb, data);
-#endif
-
 	return 0;
 
 fail_close:
@@ -566,11 +563,7 @@ static struct super_operations btrfs_super_ops = {
 	.put_super	= btrfs_put_super,
 	.write_super	= btrfs_write_super,
 	.sync_fs	= btrfs_sync_fs,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
-	.read_inode     = btrfs_read_locked_inode,
-#else
 	.show_options	= generic_show_options,
-#endif
 	.write_inode	= btrfs_write_inode,
 	.dirty_inode	= btrfs_dirty_inode,
 	.alloc_inode	= btrfs_alloc_inode,

commit 76fcef19c40328499a2f6d59d76b72fd03d2cc82
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Tue Aug 19 16:49:35 2008 +0100

    Btrfs: Reinstate '-osubvol=.' option to mount entire tree
    
    Date: Tue, 19 Aug 2008 16:49:35 +0100
    This disappeared when I removed the special case for '.' in btrfs_lookup()
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 55f4d00fda3a..f7b3eac7ac6d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -451,21 +451,25 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		s->s_flags |= MS_ACTIVE;
 	}
 
-	mutex_lock(&s->s_root->d_inode->i_mutex);
-	root = lookup_one_len(subvol_name, s->s_root, strlen(subvol_name));
-	mutex_unlock(&s->s_root->d_inode->i_mutex);
-	if (IS_ERR(root)) {
-		up_write(&s->s_umount);
-		deactivate_super(s);
-		error = PTR_ERR(root);
-		goto error;
-	}
-	if (!root->d_inode) {
-		dput(root);
-		up_write(&s->s_umount);
-		deactivate_super(s);
-		error = -ENXIO;
-		goto error;
+	if (!strcmp(subvol_name, "."))
+		root = dget(s->s_root);
+	else {
+		mutex_lock(&s->s_root->d_inode->i_mutex);
+		root = lookup_one_len(subvol_name, s->s_root, strlen(subvol_name));
+		mutex_unlock(&s->s_root->d_inode->i_mutex);
+		if (IS_ERR(root)) {
+			up_write(&s->s_umount);
+			deactivate_super(s);
+			error = PTR_ERR(root);
+			goto error;
+		}
+		if (!root->d_inode) {
+			dput(root);
+			up_write(&s->s_umount);
+			deactivate_super(s);
+			error = -ENXIO;
+			goto error;
+		}
 	}
 
 	mnt->mnt_sb = s;

commit 32d48fa1af1fe066a6a4798e6f5a50ac6a3ce4a3
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Aug 18 13:10:20 2008 +0100

    Mask root object ID into f_fsid in btrfs_statfs()
    
    Date: Mon, 18 Aug 2008 13:10:20 +0100
    This means that subvolumes get a different fsid, and NFS exporting them
    works properly.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6446ab73f35a..55f4d00fda3a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -503,6 +503,10 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	   on a big-endian or little-endian host */
 	buf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);
 	buf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);
+	/* Mask in the root object ID too, to disambiguate subvols */
+	buf->f_fsid.val[0] ^= BTRFS_I(dentry->d_inode)->root->objectid >> 32;
+	buf->f_fsid.val[1] ^= BTRFS_I(dentry->d_inode)->root->objectid;
+
 	return 0;
 }
 

commit 9d03632e26e1a0a9e4a632cf426a7c0566768a7d
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Aug 18 12:01:52 2008 +0100

    Fill f_fsid field in btrfs_statfs()
    
    Date: Mon, 18 Aug 2008 12:01:52 +0100
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e830e0ed409a..6446ab73f35a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -489,6 +489,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
 	struct btrfs_super_block *disk_super = &root->fs_info->super_copy;
 	int bits = dentry->d_sb->s_blocksize_bits;
+	__be32 *fsid = (__be32 *)root->fs_info->fsid;
 
 	buf->f_namelen = BTRFS_NAME_LEN;
 	buf->f_blocks = btrfs_super_total_bytes(disk_super) >> bits;
@@ -497,6 +498,11 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_bavail = buf->f_bfree;
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_type = BTRFS_SUPER_MAGIC;
+	/* We treat it as constant endianness (it doesn't matter _which_)
+	   because we want the fsid to come out the same whether mounted 
+	   on a big-endian or little-endian host */
+	buf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);
+	buf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);
 	return 0;
 }
 

commit be6e8dc0ba84029997075a1ec77b4ddb863cbe15
Author: Balaji Rao <balajirrao@gmail.com>
Date:   Mon Jul 21 02:01:56 2008 +0530

    NFS support for btrfs - v3
    
    Date: Mon, 21 Jul 2008 02:01:56 +0530
    Here's an implementation of NFS support for btrfs. It relies on the
    fixes which are going in to 2.6.28 for the NFS readdir/lookup deadlock.
    
    This uses the btrfs_iget helper introduced previously.
    
    [dwmw2: Tidy up a little, switch to d_obtain_alias() w/compat routine,
            change fh_type, store parent's root object ID where needed,
            fix some get_parent() and fs_to_dentry() bugs]
    
    Signed-off-by: Balaji Rao <balajirrao@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index eb4b357d05e1..e830e0ed409a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -46,6 +46,7 @@
 #include "xattr.h"
 #include "volumes.h"
 #include "version.h"
+#include "export.h"
 
 #define BTRFS_SUPER_MAGIC 0x9123683E
 
@@ -303,6 +304,7 @@ static int btrfs_fill_super(struct super_block * sb,
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	sb->s_magic = BTRFS_SUPER_MAGIC;
 	sb->s_op = &btrfs_super_ops;
+	sb->s_export_op = &btrfs_export_ops;
 	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;
 	sb->s_flags |= MS_POSIXACL;

commit b48652c101cce7a54379a49cc0cf854cec2c94e2
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Mon Aug 4 23:23:47 2008 -0400

    Btrfs: Various small fixes.
    
    This trivial patch contains two locking fixes and a off by one fix.
    
    ---
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a6a418b6894b..eb4b357d05e1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -449,7 +449,9 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		s->s_flags |= MS_ACTIVE;
 	}
 
+	mutex_lock(&s->s_root->d_inode->i_mutex);
 	root = lookup_one_len(subvol_name, s->s_root, strlen(subvol_name));
+	mutex_unlock(&s->s_root->d_inode->i_mutex);
 	if (IS_ERR(root)) {
 		up_write(&s->s_umount);
 		deactivate_super(s);

commit 33268eaf0b3db5e2bd12c0ada81a8e8f87a46d68
Author: Josef Bacik <jbacik@redhat.com>
Date:   Thu Jul 24 12:16:36 2008 -0400

    Btrfs: Add ACL support
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4cb6aac5122e..a6a418b6894b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -68,7 +68,7 @@ static void btrfs_put_super (struct super_block * sb)
 enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
-	Opt_ssd, Opt_thread_pool, Opt_err,
+	Opt_ssd, Opt_thread_pool, Opt_noacl,  Opt_err,
 };
 
 static match_table_t tokens = {
@@ -83,7 +83,8 @@ static match_table_t tokens = {
 	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_thread_pool, "thread_pool=%d"},
 	{Opt_ssd, "ssd"},
-	{Opt_err, NULL}
+	{Opt_noacl, "noacl"},
+	{Opt_err, NULL},
 };
 
 u64 btrfs_parse_size(char *str)
@@ -215,6 +216,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 					info->alloc_start);
 			}
 			break;
+		case Opt_noacl:
+			root->fs_info->sb->s_flags &= ~MS_POSIXACL;
+			break;
 		default:
 			break;
 		}
@@ -301,6 +305,7 @@ static int btrfs_fill_super(struct super_block * sb,
 	sb->s_op = &btrfs_super_ops;
 	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;
+	sb->s_flags |= MS_POSIXACL;
 
 	tree_root = open_ctree(sb, fs_devices, (char *)data);
 

commit b3c3da71ed88c06bc18a4d8919c6e4af3b933566
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jul 23 12:12:13 2008 -0400

    Btrfs: Add version strings on module load
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5e28cf5c2e85..4cb6aac5122e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -45,6 +45,7 @@
 #include "print-tree.h"
 #include "xattr.h"
 #include "volumes.h"
+#include "version.h"
 
 #define BTRFS_SUPER_MAGIC 0x9123683E
 
@@ -605,6 +606,8 @@ static int __init init_btrfs_fs(void)
 	err = register_filesystem(&btrfs_fs_type);
 	if (err)
 		goto unregister_ioctl;
+
+	printk(KERN_INFO "%s loaded\n", BTRFS_BUILD_VERSION);
 	return 0;
 
 unregister_ioctl:

commit 3f157a2fd2ad731e1ed9964fecdc5f459f04a4a4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 25 16:01:31 2008 -0400

    Btrfs: Online btree defragmentation fixes
    
    The btree defragger wasn't making forward progress because the new key wasn't
    being saved by the btrfs_search_forward function.
    
    This also disables the automatic btree defrag, it wasn't scaling well to
    huge filesystems.  The auto-defrag needs to be done differently.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 726d6871fa13..5e28cf5c2e85 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -365,7 +365,6 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 	btrfs_clean_old_snapshots(root);
-	btrfs_defrag_dirty_roots(root->fs_info);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);
 	sb->s_dirt = 0;

commit a74a4b97b61beede185b4b3ad359d7d378b0d312
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 25 16:01:31 2008 -0400

    Btrfs: Replace the transaction work queue with kthreads
    
    This creates one kthread for commits and one kthread for
    deleting old snapshots.  All the work queues are removed.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b61ded7a20c9..726d6871fa13 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -340,7 +340,6 @@ static int btrfs_fill_super(struct super_block * sb,
 		goto fail_close;
 
 	sb->s_root = root_dentry;
-	btrfs_transaction_queue_work(tree_root, HZ * 30);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
 	save_mount_options(sb, data);
@@ -416,9 +415,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 		goto error_free_subvol_name;
 
 	bdev = fs_devices->latest_bdev;
-	btrfs_lock_volumes();
 	s = sget(fs_type, btrfs_test_super, set_anon_super, fs_devices);
-	btrfs_unlock_volumes();
 	if (IS_ERR(s))
 		goto error_s;
 
@@ -530,13 +527,15 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 static void btrfs_write_super_lockfs(struct super_block *sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
-	btrfs_transaction_flush_work(root);
+	mutex_lock(&root->fs_info->transaction_kthread_mutex);
+	mutex_lock(&root->fs_info->cleaner_mutex);
 }
 
 static void btrfs_unlockfs(struct super_block *sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
-	btrfs_transaction_queue_work(root, HZ * 30);
+	mutex_unlock(&root->fs_info->cleaner_mutex);
+	mutex_unlock(&root->fs_info->transaction_kthread_mutex);
 }
 
 static struct super_operations btrfs_super_ops = {
@@ -589,10 +588,9 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		return err;
 
-	btrfs_init_transaction_sys();
 	err = btrfs_init_cachep();
 	if (err)
-		goto free_transaction_sys;
+		goto free_sysfs;
 
 	err = extent_io_init();
 	if (err)
@@ -618,15 +616,13 @@ static int __init init_btrfs_fs(void)
 	extent_io_exit();
 free_cachep:
 	btrfs_destroy_cachep();
-free_transaction_sys:
-	btrfs_exit_transaction_sys();
+free_sysfs:
 	btrfs_exit_sysfs();
 	return err;
 }
 
 static void __exit exit_btrfs_fs(void)
 {
-	btrfs_exit_transaction_sys();
 	btrfs_destroy_cachep();
 	extent_map_exit();
 	extent_io_exit();

commit a213501153fd66e2359e091b1612841305ba6551
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 25 16:01:30 2008 -0400

    Btrfs: Replace the big fs_mutex with a collection of other locks
    
    Extent alloctions are still protected by a large alloc_mutex.
    Objectid allocations are covered by a objectid mutex
    Other btree operations are protected by a lock on individual btree nodes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 196d0e280b19..b61ded7a20c9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -366,12 +366,10 @@ int btrfs_sync_fs(struct super_block *sb, int wait)
 		return 0;
 	}
 	btrfs_clean_old_snapshots(root);
-	mutex_lock(&root->fs_info->fs_mutex);
 	btrfs_defrag_dirty_roots(root->fs_info);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);
 	sb->s_dirt = 0;
-	mutex_unlock(&root->fs_info->fs_mutex);
 	return ret;
 }
 

commit 4543df7ecc8ae4928c1e51d6e7dc188d650abee4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 11 21:47:56 2008 -0400

    Btrfs: Add a mount option to control worker thread pool size
    
    mount -o thread_pool_size changes the default, which is
    min(num_cpus + 2, 8).  Larger thread pools would make more sense on
    very large disk arrays.
    
    This mount option controls the max size of each thread pool.  There
    are multiple thread pools, so the total worker count will be larger
    than the mount option.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f3274befd46a..196d0e280b19 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -67,7 +67,7 @@ static void btrfs_put_super (struct super_block * sb)
 enum {
 	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
-	Opt_ssd, Opt_err,
+	Opt_ssd, Opt_thread_pool, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -80,6 +80,7 @@ static match_table_t tokens = {
 	{Opt_max_extent, "max_extent=%s"},
 	{Opt_max_inline, "max_inline=%s"},
 	{Opt_alloc_start, "alloc_start=%s"},
+	{Opt_thread_pool, "thread_pool=%d"},
 	{Opt_ssd, "ssd"},
 	{Opt_err, NULL}
 };
@@ -118,6 +119,7 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 	struct btrfs_fs_info *info = root->fs_info;
 	substring_t args[MAX_OPT_ARGS];
 	char *p, *num;
+	int intarg;
 
 	if (!options)
 		return 0;
@@ -166,6 +168,15 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			printk(KERN_INFO "btrfs: turning off barriers\n");
 			btrfs_set_opt(info->mount_opt, NOBARRIER);
 			break;
+		case Opt_thread_pool:
+			intarg = 0;
+			match_int(&args[0], &intarg);
+			if (intarg) {
+				info->thread_pool_size = intarg;
+				printk(KERN_INFO "btrfs: thread pool %d\n",
+				       info->thread_pool_size);
+			}
+			break;
 		case Opt_max_extent:
 			num = match_strdup(&args[0]);
 			if (num) {

commit 15ada040d7cd68d7853938a92b116292cc16a2f3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jun 11 16:51:38 2008 -0400

    Btrfs: Fix mount -o max_inline=0
    
    max_inline=0 used to force the max_inline size to one sector instead.  Now
    it properly disables inline data items, while still being able to read
    any that happen to exist on disk.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 346932e546ba..f3274befd46a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -184,8 +184,11 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 				info->max_inline = btrfs_parse_size(num);
 				kfree(num);
 
-				info->max_inline = max_t(u64,
-					info->max_inline, root->sectorsize);
+				if (info->max_inline) {
+					info->max_inline = max_t(u64,
+						info->max_inline,
+						root->sectorsize);
+				}
 				printk(KERN_INFO "btrfs: max_inline at %llu\n",
 					info->max_inline);
 			}

commit 43e570b08a6c6b1d75f218566a6240542a386fd9
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jun 10 10:40:46 2008 -0400

    btrfs: allow scanning multiple devices during mount
    
    Allows to specify one or multiple device=/dev/foo options during mount
    so that ioctls on the control device can be avoided.  Especially useful
    when trying to mount a multi-device setup as root.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 288300fa5848..346932e546ba 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -65,7 +65,7 @@ static void btrfs_put_super (struct super_block * sb)
 }
 
 enum {
-	Opt_degraded, Opt_subvol, Opt_nodatasum, Opt_nodatacow,
+	Opt_degraded, Opt_subvol, Opt_device, Opt_nodatasum, Opt_nodatacow,
 	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
 	Opt_ssd, Opt_err,
 };
@@ -73,6 +73,7 @@ enum {
 static match_table_t tokens = {
 	{Opt_degraded, "degraded"},
 	{Opt_subvol, "subvol=%s"},
+	{Opt_device, "device=%s"},
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
 	{Opt_nobarrier, "nobarrier"},
@@ -142,8 +143,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
 			btrfs_set_opt(info->mount_opt, DEGRADED);
 			break;
 		case Opt_subvol:
+		case Opt_device:
 			/*
-			 * This one is parsed by btrfs_parse_early_options
+			 * These are parsed by btrfs_parse_early_options
 			 * and can be happily ignored here.
 			 */
 			break;
@@ -212,8 +214,9 @@ int btrfs_parse_options(struct btrfs_root *root, char *options)
  * All other options will be parsed on much later in the mount process and
  * only when we need to allocate a new super block.
  */
-static int btrfs_parse_early_options(const char *options,
-			char **subvol_name)
+static int btrfs_parse_early_options(const char *options, int flags,
+		void *holder, char **subvol_name,
+		struct btrfs_fs_devices **fs_devices)
 {
 	substring_t args[MAX_OPT_ARGS];
 	char *opts, *p;
@@ -240,11 +243,18 @@ static int btrfs_parse_early_options(const char *options,
 		case Opt_subvol:
 			*subvol_name = match_strdup(&args[0]);
 			break;
+		case Opt_device:
+			error = btrfs_scan_one_device(match_strdup(&args[0]),
+					flags, holder, fs_devices);
+			if (error)
+				goto out_free_opts;
+			break;
 		default:
 			break;
 		}
 	}
 
+ out_free_opts:
 	kfree(opts);
  out:
 	/*
@@ -380,7 +390,8 @@ static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
 	struct btrfs_fs_devices *fs_devices = NULL;
 	int error = 0;
 
-	error = btrfs_parse_early_options(data, &subvol_name);
+	error = btrfs_parse_early_options(data, flags, fs_type,
+					  &subvol_name, &fs_devices);
 	if (error)
 		goto error;
 

commit edf24abe51493ccda384644d487fe2f796ac21c8
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jun 10 10:40:29 2008 -0400

    btrfs: sanity mount option parsing and early mount code
    
    Also adds lots of comments to describe what's going on here.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 39bb86945ed0..288300fa5848 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -108,15 +108,18 @@ u64 btrfs_parse_size(char *str)
 	return res;
 }
 
-int btrfs_parse_options(char *options, struct btrfs_root *root,
-			char **subvol_name)
+/*
+ * Regular mount options parser.  Everything that is needed only when
+ * reading in a new superblock is parsed here.
+ */
+int btrfs_parse_options(struct btrfs_root *root, char *options)
 {
-	char * p;
-	struct btrfs_fs_info *info = NULL;
+	struct btrfs_fs_info *info = root->fs_info;
 	substring_t args[MAX_OPT_ARGS];
+	char *p, *num;
 
 	if (!options)
-		return 1;
+		return 0;
 
 	/*
 	 * strsep changes the string, duplicate it because parse_options
@@ -126,10 +129,8 @@ int btrfs_parse_options(char *options, struct btrfs_root *root,
 	if (!options)
 		return -ENOMEM;
 
-	if (root)
-		info = root->fs_info;
 
-	while ((p = strsep (&options, ",")) != NULL) {
+	while ((p = strsep(&options, ",")) != NULL) {
 		int token;
 		if (!*p)
 			continue;
@@ -137,83 +138,64 @@ int btrfs_parse_options(char *options, struct btrfs_root *root,
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_degraded:
-			if (info) {
-				printk("btrfs: allowing degraded mounts\n");
-				btrfs_set_opt(info->mount_opt, DEGRADED);
-			}
+			printk(KERN_INFO "btrfs: allowing degraded mounts\n");
+			btrfs_set_opt(info->mount_opt, DEGRADED);
 			break;
 		case Opt_subvol:
-			if (subvol_name) {
-				*subvol_name = match_strdup(&args[0]);
-			}
+			/*
+			 * This one is parsed by btrfs_parse_early_options
+			 * and can be happily ignored here.
+			 */
 			break;
 		case Opt_nodatasum:
-			if (info) {
-				printk("btrfs: setting nodatacsum\n");
-				btrfs_set_opt(info->mount_opt, NODATASUM);
-			}
+			printk(KERN_INFO "btrfs: setting nodatacsum\n");
+			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_nodatacow:
-			if (info) {
-				printk("btrfs: setting nodatacow\n");
-				btrfs_set_opt(info->mount_opt, NODATACOW);
-				btrfs_set_opt(info->mount_opt, NODATASUM);
-			}
+			printk(KERN_INFO "btrfs: setting nodatacow\n");
+			btrfs_set_opt(info->mount_opt, NODATACOW);
+			btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
 		case Opt_ssd:
-			if (info) {
-				printk("btrfs: use ssd allocation scheme\n");
-				btrfs_set_opt(info->mount_opt, SSD);
-			}
+			printk(KERN_INFO "btrfs: use ssd allocation scheme\n");
+			btrfs_set_opt(info->mount_opt, SSD);
 			break;
 		case Opt_nobarrier:
-			if (info) {
-				printk("btrfs: turning off barriers\n");
-				btrfs_set_opt(info->mount_opt, NOBARRIER);
-			}
+			printk(KERN_INFO "btrfs: turning off barriers\n");
+			btrfs_set_opt(info->mount_opt, NOBARRIER);
 			break;
 		case Opt_max_extent:
-			if (info) {
-				char *num = match_strdup(&args[0]);
-				if (num) {
-					info->max_extent =
-						btrfs_parse_size(num);
-					kfree(num);
-
-					info->max_extent = max_t(u64,
-							 info->max_extent,
-							 root->sectorsize);
-					printk("btrfs: max_extent at %Lu\n",
-					       info->max_extent);
-				}
+			num = match_strdup(&args[0]);
+			if (num) {
+				info->max_extent = btrfs_parse_size(num);
+				kfree(num);
+
+				info->max_extent = max_t(u64,
+					info->max_extent, root->sectorsize);
+				printk(KERN_INFO "btrfs: max_extent at %llu\n",
+				       info->max_extent);
 			}
 			break;
 		case Opt_max_inline:
-			if (info) {
-				char *num = match_strdup(&args[0]);
-				if (num) {
-					info->max_inline =
-						btrfs_parse_size(num);
-					kfree(num);
-
-					info->max_inline = max_t(u64,
-							 info->max_inline,
-							 root->sectorsize);
-					printk("btrfs: max_inline at %Lu\n",
-					       info->max_inline);
-				}
+			num = match_strdup(&args[0]);
+			if (num) {
+				info->max_inline = btrfs_parse_size(num);
+				kfree(num);
+
+				info->max_inline = max_t(u64,
+					info->max_inline, root->sectorsize);
+				printk(KERN_INFO "btrfs: max_inline at %llu\n",
+					info->max_inline);
 			}
 			break;
 		case Opt_alloc_start:
-			if (info) {
-				char *num = match_strdup(&args[0]);
-				if (num) {
-					info->alloc_start =
-						btrfs_parse_size(num);
-					kfree(num);
-					printk("btrfs: allocations start at "
-					       "%Lu\n", info->alloc_start);
-				}
+			num = match_strdup(&args[0]);
+			if (num) {
+				info->alloc_start = btrfs_parse_size(num);
+				kfree(num);
+				printk(KERN_INFO
+					"btrfs: allocations start at %llu\n",
+					info->alloc_start);
 			}
 			break;
 		default:
@@ -221,7 +203,61 @@ int btrfs_parse_options(char *options, struct btrfs_root *root,
 		}
 	}
 	kfree(options);
-	return 1;
+	return 0;
+}
+
+/*
+ * Parse mount options that are required early in the mount process.
+ *
+ * All other options will be parsed on much later in the mount process and
+ * only when we need to allocate a new super block.
+ */
+static int btrfs_parse_early_options(const char *options,
+			char **subvol_name)
+{
+	substring_t args[MAX_OPT_ARGS];
+	char *opts, *p;
+	int error = 0;
+
+	if (!options)
+		goto out;
+
+	/*
+	 * strsep changes the string, duplicate it because parse_options
+	 * gets called twice
+	 */
+	opts = kstrdup(options, GFP_KERNEL);
+	if (!opts)
+		return -ENOMEM;
+
+	while ((p = strsep(&opts, ",")) != NULL) {
+		int token;
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_subvol:
+			*subvol_name = match_strdup(&args[0]);
+			break;
+		default:
+			break;
+		}
+	}
+
+	kfree(opts);
+ out:
+	/*
+	 * If no subvolume name is specified we use the default one.  Allocate
+	 * a copy of the string "default" here so that code later in the
+	 * mount path doesn't care if it's the default volume or another one.
+	 */
+	if (!*subvol_name) {
+		*subvol_name = kstrdup("default", GFP_KERNEL);
+		if (!*subvol_name)
+			return -ENOMEM;
+	}
+	return error;
 }
 
 static int btrfs_fill_super(struct super_block * sb,
@@ -328,23 +364,33 @@ static int btrfs_test_super(struct super_block *s, void *data)
 	return root->fs_info->fs_devices == test_fs_devices;
 }
 
-int btrfs_get_sb_bdev(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data,
-	struct vfsmount *mnt, const char *subvol)
+/*
+ * Find a superblock for the given device / mount point.
+ *
+ * Note:  This is based on get_sb_bdev from fs/super.c with a few additions
+ *	  for multiple device setup.  Make sure to keep it in sync.
+ */
+static int btrfs_get_sb(struct file_system_type *fs_type, int flags,
+		const char *dev_name, void *data, struct vfsmount *mnt)
 {
+	char *subvol_name = NULL;
 	struct block_device *bdev = NULL;
 	struct super_block *s;
 	struct dentry *root;
 	struct btrfs_fs_devices *fs_devices = NULL;
 	int error = 0;
 
+	error = btrfs_parse_early_options(data, &subvol_name);
+	if (error)
+		goto error;
+
 	error = btrfs_scan_one_device(dev_name, flags, fs_type, &fs_devices);
 	if (error)
-		return error;
+		goto error_free_subvol_name;
 
 	error = btrfs_open_devices(fs_devices, flags, fs_type);
 	if (error)
-		return error;
+		goto error_free_subvol_name;
 
 	bdev = fs_devices->latest_bdev;
 	btrfs_lock_volumes();
@@ -378,51 +424,36 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 		s->s_flags |= MS_ACTIVE;
 	}
 
-	if (subvol) {
-		root = lookup_one_len(subvol, s->s_root, strlen(subvol));
-		if (IS_ERR(root)) {
-			up_write(&s->s_umount);
-			deactivate_super(s);
-			error = PTR_ERR(root);
-			goto error;
-		}
-		if (!root->d_inode) {
-			dput(root);
-			up_write(&s->s_umount);
-			deactivate_super(s);
-			error = -ENXIO;
-			goto error;
-		}
-	} else {
-		root = dget(s->s_root);
+	root = lookup_one_len(subvol_name, s->s_root, strlen(subvol_name));
+	if (IS_ERR(root)) {
+		up_write(&s->s_umount);
+		deactivate_super(s);
+		error = PTR_ERR(root);
+		goto error;
+	}
+	if (!root->d_inode) {
+		dput(root);
+		up_write(&s->s_umount);
+		deactivate_super(s);
+		error = -ENXIO;
+		goto error;
 	}
 
 	mnt->mnt_sb = s;
 	mnt->mnt_root = root;
+
+	kfree(subvol_name);
 	return 0;
 
 error_s:
 	error = PTR_ERR(s);
 error_bdev:
 	btrfs_close_devices(fs_devices);
+error_free_subvol_name:
+	kfree(subvol_name);
 error:
 	return error;
 }
-/* end copy & paste */
-
-static int btrfs_get_sb(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
-{
-	int ret;
-	char *subvol_name = NULL;
-
-	btrfs_parse_options((char *)data, NULL, &subvol_name);
-	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data, mnt,
-			subvol_name ? subvol_name : "default");
-	if (subvol_name)
-		kfree(subvol_name);
-	return ret;
-}
 
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {

commit 6bf13c0cc833bf5ba013d6aa60379484bf48c4e6
Author: Sage Weil <sage@newdream.net>
Date:   Tue Jun 10 10:07:39 2008 -0400

    Btrfs: transaction ioctls
    
    These ioctls let a user application hold a transaction open while it
    performs a series of operations.  A final ioctl does a sync on the fs
    (closing the current transaction).  This is the main requirement for
    Ceph's OSD to be able to keep the data it's storing in a btrfs volume
    consistent, and AFAICS it works just fine.  The application would do
    something like
    
            fd = ::open("some/file", O_RDONLY);
            ::ioctl(fd, BTRFS_IOC_TRANS_START);
            /* do a bunch of stuff */
            ::ioctl(fd, BTRFS_IOC_TRANS_END);
    or just
            ::close(fd);
    
    And to ensure it commits to disk,
    
            ::ioctl(fd, BTRFS_IOC_SYNC);
    
    When a transaction is held open, the trans_handle is attached to the
    struct file (via private_data) so that it will get cleaned up if the
    process dies unexpectedly.  A held transaction is also ended on fsync() to
    avoid a deadlock.
    
    A misbehaving application could also deliberately hold a transaction open,
    effectively locking up the FS, so it may make sense to restrict something
    like this to root or something.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 77f44494e229..39bb86945ed0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -293,7 +293,7 @@ static int btrfs_fill_super(struct super_block * sb,
 	return err;
 }
 
-static int btrfs_sync_fs(struct super_block *sb, int wait)
+int btrfs_sync_fs(struct super_block *sb, int wait)
 {
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root;

commit f819d837eea9829ed6c356fb88cdd0a170cbd947
Author: Linda Knippers <linda.knippers@hp.com>
Date:   Mon Jun 9 22:17:11 2008 -0400

    btrfsctl -A error code fixup
    
    Send the error back to userland if the ioctl fails
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 05029656e42e..77f44494e229 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -453,7 +453,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 {
 	struct btrfs_ioctl_vol_args *vol;
 	struct btrfs_fs_devices *fs_devices;
-	int ret;
+	int ret = 0;
 	int len;
 
 	vol = kmalloc(sizeof(*vol), GFP_KERNEL);
@@ -470,7 +470,7 @@ static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
 	}
 out:
 	kfree(vol);
-	return 0;
+	return ret;
 }
 
 static void btrfs_write_super_lockfs(struct super_block *sb)

commit e1b81e6761bd8419146d4bbe0aadd8b2d348a01c
Author: Mingming <cmm@us.ibm.com>
Date:   Tue May 27 10:55:43 2008 -0400

    btrfs delete ordered inode handling fix
    
    Use btrfs_release_file instead of a put_inode call
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 273a5b511f50..05029656e42e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -487,7 +487,6 @@ static void btrfs_unlockfs(struct super_block *sb)
 
 static struct super_operations btrfs_super_ops = {
 	.delete_inode	= btrfs_delete_inode,
-	.put_inode	= btrfs_put_inode,
 	.put_super	= btrfs_put_super,
 	.write_super	= btrfs_write_super,
 	.sync_fs	= btrfs_sync_fs,

commit dfe25020689bb2d318782d2c9c7141203583fc70
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue May 13 13:46:40 2008 -0400

    Btrfs: Add mount -o degraded to allow mounts to continue with missing devices
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 020e5a83e31f..273a5b511f50 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -65,11 +65,13 @@ static void btrfs_put_super (struct super_block * sb)
 }
 
 enum {
-	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_max_extent,
-	Opt_max_inline, Opt_alloc_start, Opt_nobarrier, Opt_ssd, Opt_err,
+	Opt_degraded, Opt_subvol, Opt_nodatasum, Opt_nodatacow,
+	Opt_max_extent, Opt_max_inline, Opt_alloc_start, Opt_nobarrier,
+	Opt_ssd, Opt_err,
 };
 
 static match_table_t tokens = {
+	{Opt_degraded, "degraded"},
 	{Opt_subvol, "subvol=%s"},
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
@@ -106,9 +108,8 @@ u64 btrfs_parse_size(char *str)
 	return res;
 }
 
-static int parse_options (char * options,
-			  struct btrfs_root *root,
-			  char **subvol_name)
+int btrfs_parse_options(char *options, struct btrfs_root *root,
+			char **subvol_name)
 {
 	char * p;
 	struct btrfs_fs_info *info = NULL;
@@ -135,6 +136,12 @@ static int parse_options (char * options,
 
 		token = match_token(p, tokens, args);
 		switch (token) {
+		case Opt_degraded:
+			if (info) {
+				printk("btrfs: allowing degraded mounts\n");
+				btrfs_set_opt(info->mount_opt, DEGRADED);
+			}
+			break;
 		case Opt_subvol:
 			if (subvol_name) {
 				*subvol_name = match_strdup(&args[0]);
@@ -234,7 +241,7 @@ static int btrfs_fill_super(struct super_block * sb,
 	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;
 
-	tree_root = open_ctree(sb, fs_devices);
+	tree_root = open_ctree(sb, fs_devices, (char *)data);
 
 	if (IS_ERR(tree_root)) {
 		printk("btrfs: open_ctree failed\n");
@@ -267,8 +274,6 @@ static int btrfs_fill_super(struct super_block * sb,
 		goto fail_close;
 	}
 
-	parse_options((char *)data, tree_root, NULL);
-
 	/* this does the super kobj at the same time */
 	err = btrfs_sysfs_add_super(tree_root->fs_info);
 	if (err)
@@ -341,7 +346,7 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 	if (error)
 		return error;
 
-	bdev = fs_devices->lowest_bdev;
+	bdev = fs_devices->latest_bdev;
 	btrfs_lock_volumes();
 	s = sget(fs_type, btrfs_test_super, set_anon_super, fs_devices);
 	btrfs_unlock_volumes();
@@ -411,7 +416,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 	int ret;
 	char *subvol_name = NULL;
 
-	parse_options((char *)data, NULL, &subvol_name);
+	btrfs_parse_options((char *)data, NULL, &subvol_name);
 	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data, mnt,
 			subvol_name ? subvol_name : "default");
 	if (subvol_name)

commit a061fc8da7b990faa41ca503e66faef3ecdeead0
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed May 7 11:43:44 2008 -0400

    Btrfs: Add support for online device removal
    
    This required a few structural changes to the code that manages bdev pointers:
    
    The VFS super block now gets an anon-bdev instead of a pointer to the
    lowest bdev.  This allows us to avoid swapping the super block bdev pointer
    around at run time.
    
    The code to read in the super block no longer goes through the extent
    buffer interface.  Things got ugly keeping the mapping constant.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7153dfaa3404..020e5a83e31f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -315,24 +315,12 @@ static void btrfs_write_super(struct super_block *sb)
 	sb->s_dirt = 0;
 }
 
-/*
- * This is almost a copy of get_sb_bdev in fs/super.c.
- * We need the local copy to allow direct mounting of
- * subvolumes, but this could be easily integrated back
- * into the generic version.  --hch
- */
-
-/* start copy & paste */
-static int set_bdev_super(struct super_block *s, void *data)
+static int btrfs_test_super(struct super_block *s, void *data)
 {
-	s->s_bdev = data;
-	s->s_dev = s->s_bdev->bd_dev;
-	return 0;
-}
+	struct btrfs_fs_devices *test_fs_devices = data;
+	struct btrfs_root *root = btrfs_sb(s);
 
-static int test_bdev_super(struct super_block *s, void *data)
-{
-	return (void *)s->s_bdev == data;
+	return root->fs_info->fs_devices == test_fs_devices;
 }
 
 int btrfs_get_sb_bdev(struct file_system_type *fs_type,
@@ -354,14 +342,9 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 		return error;
 
 	bdev = fs_devices->lowest_bdev;
-	/*
-	 * once the super is inserted into the list by sget, s_umount
-	 * will protect the lockfs code from trying to start a snapshot
-	 * while we are mounting
-	 */
-	down(&bdev->bd_mount_sem);
-	s = sget(fs_type, test_bdev_super, set_bdev_super, bdev);
-	up(&bdev->bd_mount_sem);
+	btrfs_lock_volumes();
+	s = sget(fs_type, btrfs_test_super, set_anon_super, fs_devices);
+	btrfs_unlock_volumes();
 	if (IS_ERR(s))
 		goto error_s;
 
@@ -373,13 +356,11 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 			goto error_bdev;
 		}
 
-		close_bdev_excl(bdev);
 	} else {
 		char b[BDEVNAME_SIZE];
 
 		s->s_flags = flags;
 		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
-		sb_set_blocksize(s, block_size(bdev));
 		error = btrfs_fill_super(s, fs_devices, data,
 					 flags & MS_SILENT ? 1 : 0);
 		if (error) {
@@ -458,7 +439,7 @@ static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
 	.get_sb		= btrfs_get_sb,
-	.kill_sb	= kill_block_super,
+	.kill_sb	= kill_anon_super,
 	.fs_flags	= FS_REQUIRES_DEV,
 };
 

commit 788f20eb5affef584e75ea84bb80a4c3352a2c0e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 28 15:29:42 2008 -0400

    Btrfs: Add new ioctl to add devices
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 892864906880..7153dfaa3404 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -388,6 +388,7 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 			goto error;
 		}
 
+		btrfs_sb(s)->fs_info->bdev_holder = fs_type;
 		s->s_flags |= MS_ACTIVE;
 	}
 

commit e58ca0203d32869a01540a293df40ddc480dc378
Author: Yan <yanzheng@21cn.com>
Date:   Tue Apr 1 11:21:34 2008 -0400

    Fix btrfs_fill_super to return -EINVAL when no FS found
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9624923a33dc..892864906880 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -236,9 +236,9 @@ static int btrfs_fill_super(struct super_block * sb,
 
 	tree_root = open_ctree(sb, fs_devices);
 
-	if (!tree_root || IS_ERR(tree_root)) {
+	if (IS_ERR(tree_root)) {
 		printk("btrfs: open_ctree failed\n");
-		return -EIO;
+		return PTR_ERR(tree_root);
 	}
 	sb->s_fs_info = tree_root;
 	disk_super = &tree_root->fs_info->super_copy;

commit 8a4b83cc8bd75fca29ac68615896d9e92820e7c2
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:02:07 2008 -0400

    Btrfs: Add support for device scanning and detection ioctls
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 67ed216df475..9624923a33dc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -44,6 +44,7 @@
 #include "ioctl.h"
 #include "print-tree.h"
 #include "xattr.h"
+#include "volumes.h"
 
 #define BTRFS_SUPER_MAGIC 0x9123683E
 
@@ -216,7 +217,9 @@ static int parse_options (char * options,
 	return 1;
 }
 
-static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
+static int btrfs_fill_super(struct super_block * sb,
+			    struct btrfs_fs_devices *fs_devices,
+			    void * data, int silent)
 {
 	struct inode * inode;
 	struct dentry * root_dentry;
@@ -231,7 +234,7 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;
 
-	tree_root = open_ctree(sb);
+	tree_root = open_ctree(sb, fs_devices);
 
 	if (!tree_root || IS_ERR(tree_root)) {
 		printk("btrfs: open_ctree failed\n");
@@ -334,18 +337,23 @@ static int test_bdev_super(struct super_block *s, void *data)
 
 int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
-	int (*fill_super)(struct super_block *, void *, int),
 	struct vfsmount *mnt, const char *subvol)
 {
 	struct block_device *bdev = NULL;
 	struct super_block *s;
 	struct dentry *root;
+	struct btrfs_fs_devices *fs_devices = NULL;
 	int error = 0;
 
-	bdev = open_bdev_excl(dev_name, flags, fs_type);
-	if (IS_ERR(bdev))
-		return PTR_ERR(bdev);
+	error = btrfs_scan_one_device(dev_name, flags, fs_type, &fs_devices);
+	if (error)
+		return error;
 
+	error = btrfs_open_devices(fs_devices, flags, fs_type);
+	if (error)
+		return error;
+
+	bdev = fs_devices->lowest_bdev;
 	/*
 	 * once the super is inserted into the list by sget, s_umount
 	 * will protect the lockfs code from trying to start a snapshot
@@ -372,7 +380,8 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 		s->s_flags = flags;
 		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
 		sb_set_blocksize(s, block_size(bdev));
-		error = fill_super(s, data, flags & MS_SILENT ? 1 : 0);
+		error = btrfs_fill_super(s, fs_devices, data,
+					 flags & MS_SILENT ? 1 : 0);
 		if (error) {
 			up_write(&s->s_umount);
 			deactivate_super(s);
@@ -408,7 +417,7 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 error_s:
 	error = PTR_ERR(s);
 error_bdev:
-	close_bdev_excl(bdev);
+	btrfs_close_devices(fs_devices);
 error:
 	return error;
 }
@@ -421,8 +430,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 	char *subvol_name = NULL;
 
 	parse_options((char *)data, NULL, &subvol_name);
-	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data,
-			btrfs_fill_super, mnt,
+	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data, mnt,
 			subvol_name ? subvol_name : "default");
 	if (subvol_name)
 		kfree(subvol_name);
@@ -445,13 +453,6 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
-static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
-				unsigned long arg)
-{
-	printk("btrfs control ioctl %d\n", cmd);
-	return 0;
-}
-
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
@@ -460,6 +461,31 @@ static struct file_system_type btrfs_fs_type = {
 	.fs_flags	= FS_REQUIRES_DEV,
 };
 
+static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
+				unsigned long arg)
+{
+	struct btrfs_ioctl_vol_args *vol;
+	struct btrfs_fs_devices *fs_devices;
+	int ret;
+	int len;
+
+	vol = kmalloc(sizeof(*vol), GFP_KERNEL);
+	if (copy_from_user(vol, (void __user *)arg, sizeof(*vol))) {
+		ret = -EFAULT;
+		goto out;
+	}
+	len = strnlen(vol->name, BTRFS_PATH_NAME_MAX);
+	switch (cmd) {
+	case BTRFS_IOC_SCAN_DEV:
+		ret = btrfs_scan_one_device(vol->name, MS_RDONLY,
+					    &btrfs_fs_type, &fs_devices);
+		break;
+	}
+out:
+	kfree(vol);
+	return 0;
+}
+
 static void btrfs_write_super_lockfs(struct super_block *sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
@@ -567,6 +593,7 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_interface_exit();
 	unregister_filesystem(&btrfs_fs_type);
 	btrfs_exit_sysfs();
+	btrfs_cleanup_fs_uuids();
 }
 
 module_init(init_btrfs_fs)

commit a9218f6b00ada101c9772ee9c44af04fa5125d2a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 24 15:02:04 2008 -0400

    Add /dev/btrfs-control for device scanning ioctls
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4423a91206a1..67ed216df475 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -36,6 +36,7 @@
 #include <linux/parser.h>
 #include <linux/ctype.h>
 #include <linux/namei.h>
+#include <linux/miscdevice.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -444,6 +445,13 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
+static long btrfs_control_ioctl(struct file *file, unsigned int cmd,
+				unsigned long arg)
+{
+	printk("btrfs control ioctl %d\n", cmd);
+	return 0;
+}
+
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
@@ -451,6 +459,7 @@ static struct file_system_type btrfs_fs_type = {
 	.kill_sb	= kill_block_super,
 	.fs_flags	= FS_REQUIRES_DEV,
 };
+
 static void btrfs_write_super_lockfs(struct super_block *sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
@@ -482,6 +491,30 @@ static struct super_operations btrfs_super_ops = {
 	.write_super_lockfs = btrfs_write_super_lockfs,
 	.unlockfs	= btrfs_unlockfs,
 };
+
+static const struct file_operations btrfs_ctl_fops = {
+	.unlocked_ioctl	 = btrfs_control_ioctl,
+	.compat_ioctl = btrfs_control_ioctl,
+	.owner	 = THIS_MODULE,
+};
+
+static struct miscdevice btrfs_misc = {
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= "btrfs-control",
+	.fops		= &btrfs_ctl_fops
+};
+
+static int btrfs_interface_init(void)
+{
+	return misc_register(&btrfs_misc);
+}
+
+void btrfs_interface_exit(void)
+{
+	if (misc_deregister(&btrfs_misc) < 0)
+		printk("misc_deregister failed for control device");
+}
+
 static int __init init_btrfs_fs(void)
 {
 	int err;
@@ -503,11 +536,16 @@ static int __init init_btrfs_fs(void)
 	if (err)
 		goto free_extent_io;
 
-	err = register_filesystem(&btrfs_fs_type);
+	err = btrfs_interface_init();
 	if (err)
 		goto free_extent_map;
+	err = register_filesystem(&btrfs_fs_type);
+	if (err)
+		goto unregister_ioctl;
 	return 0;
 
+unregister_ioctl:
+	btrfs_interface_exit();
 free_extent_map:
 	extent_map_exit();
 free_extent_io:
@@ -526,6 +564,7 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_destroy_cachep();
 	extent_map_exit();
 	extent_io_exit();
+	btrfs_interface_exit();
 	unregister_filesystem(&btrfs_fs_type);
 	btrfs_exit_sysfs();
 }

commit 6885f308b557020efce6ef9c1fcc96adaabecbb6
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Feb 20 16:11:05 2008 -0500

    Btrfs: Misc 2.6.25 updates
    
    Remove the btrfs read_inode method, and use save_mount_options
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a46300c4753a..4423a91206a1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -272,6 +272,11 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 
 	sb->s_root = root_dentry;
 	btrfs_transaction_queue_work(tree_root, HZ * 30);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+	save_mount_options(sb, data);
+#endif
+
 	return 0;
 
 fail_close:
@@ -462,9 +467,13 @@ static struct super_operations btrfs_super_ops = {
 	.delete_inode	= btrfs_delete_inode,
 	.put_inode	= btrfs_put_inode,
 	.put_super	= btrfs_put_super,
-	.read_inode	= btrfs_read_locked_inode,
 	.write_super	= btrfs_write_super,
 	.sync_fs	= btrfs_sync_fs,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+	.read_inode     = btrfs_read_locked_inode,
+#else
+	.show_options	= generic_show_options,
+#endif
 	.write_inode	= btrfs_write_inode,
 	.dirty_inode	= btrfs_dirty_inode,
 	.alloc_inode	= btrfs_alloc_inode,

commit 6f568d35a045dbb8a13fe71bfc32e85e39a986cb
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jan 29 16:03:38 2008 -0500

    Btrfs: mount -o max_inline=size to control the maximum inline extent size
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f8a1016600b1..a46300c4753a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -64,7 +64,7 @@ static void btrfs_put_super (struct super_block * sb)
 
 enum {
 	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_max_extent,
-	Opt_alloc_start, Opt_nobarrier, Opt_ssd, Opt_err,
+	Opt_max_inline, Opt_alloc_start, Opt_nobarrier, Opt_ssd, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -73,6 +73,7 @@ static match_table_t tokens = {
 	{Opt_nodatacow, "nodatacow"},
 	{Opt_nobarrier, "nobarrier"},
 	{Opt_max_extent, "max_extent=%s"},
+	{Opt_max_inline, "max_inline=%s"},
 	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_ssd, "ssd"},
 	{Opt_err, NULL}
@@ -178,6 +179,22 @@ static int parse_options (char * options,
 				}
 			}
 			break;
+		case Opt_max_inline:
+			if (info) {
+				char *num = match_strdup(&args[0]);
+				if (num) {
+					info->max_inline =
+						btrfs_parse_size(num);
+					kfree(num);
+
+					info->max_inline = max_t(u64,
+							 info->max_inline,
+							 root->sectorsize);
+					printk("btrfs: max_inline at %Lu\n",
+					       info->max_inline);
+				}
+			}
+			break;
 		case Opt_alloc_start:
 			if (info) {
 				char *num = match_strdup(&args[0]);

commit d1310b2e0cd98eb1348553e69b73827b436dca7b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Jan 24 16:13:08 2008 -0500

    Btrfs: Split the extent_map code into two parts
    
    There is now extent_map for mapping offsets in the file to disk and
    extent_io for state tracking, IO submission and extent_bufers.
    
    The new extent_map code shifts from [start,end] pairs to [start,len], and
    pushes the locking out into the caller.  This allows a few performance
    optimizations and is easier to use.
    
    A number of extent_map usage bugs were fixed, mostly with failing
    to remove extent_map entries when changing the file.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8b52c69fda2e..f8a1016600b1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -468,10 +468,15 @@ static int __init init_btrfs_fs(void)
 	err = btrfs_init_cachep();
 	if (err)
 		goto free_transaction_sys;
-	err = extent_map_init();
+
+	err = extent_io_init();
 	if (err)
 		goto free_cachep;
 
+	err = extent_map_init();
+	if (err)
+		goto free_extent_io;
+
 	err = register_filesystem(&btrfs_fs_type);
 	if (err)
 		goto free_extent_map;
@@ -479,6 +484,8 @@ static int __init init_btrfs_fs(void)
 
 free_extent_map:
 	extent_map_exit();
+free_extent_io:
+	extent_io_exit();
 free_cachep:
 	btrfs_destroy_cachep();
 free_transaction_sys:
@@ -492,6 +499,7 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_exit_transaction_sys();
 	btrfs_destroy_cachep();
 	extent_map_exit();
+	extent_io_exit();
 	unregister_filesystem(&btrfs_fs_type);
 	btrfs_exit_sysfs();
 }

commit ed0dab6b86cee64e9072107f65fa40629f162b38
Author: Yan <yanzheng@21cn.com>
Date:   Tue Jan 22 12:46:56 2008 -0500

    Btrfs: Add basic lockfs calls
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b6982f0133cf..8b52c69fda2e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -429,6 +429,17 @@ static struct file_system_type btrfs_fs_type = {
 	.kill_sb	= kill_block_super,
 	.fs_flags	= FS_REQUIRES_DEV,
 };
+static void btrfs_write_super_lockfs(struct super_block *sb)
+{
+	struct btrfs_root *root = btrfs_sb(sb);
+	btrfs_transaction_flush_work(root);
+}
+
+static void btrfs_unlockfs(struct super_block *sb)
+{
+	struct btrfs_root *root = btrfs_sb(sb);
+	btrfs_transaction_queue_work(root, HZ * 30);
+}
 
 static struct super_operations btrfs_super_ops = {
 	.delete_inode	= btrfs_delete_inode,
@@ -442,8 +453,9 @@ static struct super_operations btrfs_super_ops = {
 	.alloc_inode	= btrfs_alloc_inode,
 	.destroy_inode	= btrfs_destroy_inode,
 	.statfs		= btrfs_statfs,
+	.write_super_lockfs = btrfs_write_super_lockfs,
+	.unlockfs	= btrfs_unlockfs,
 };
-
 static int __init init_btrfs_fs(void)
 {
 	int err;

commit e18e4809b10e6c9efb5fe10c1ddcb4ebb690d517
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jan 18 10:54:22 2008 -0500

    Btrfs: Add mount -o ssd, which includes optimizations for seek free storage
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e506de3168bc..b6982f0133cf 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -64,7 +64,7 @@ static void btrfs_put_super (struct super_block * sb)
 
 enum {
 	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_max_extent,
-	Opt_alloc_start, Opt_nobarrier, Opt_err,
+	Opt_alloc_start, Opt_nobarrier, Opt_ssd, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -74,6 +74,7 @@ static match_table_t tokens = {
 	{Opt_nobarrier, "nobarrier"},
 	{Opt_max_extent, "max_extent=%s"},
 	{Opt_alloc_start, "alloc_start=%s"},
+	{Opt_ssd, "ssd"},
 	{Opt_err, NULL}
 };
 
@@ -149,6 +150,12 @@ static int parse_options (char * options,
 				btrfs_set_opt(info->mount_opt, NODATASUM);
 			}
 			break;
+		case Opt_ssd:
+			if (info) {
+				printk("btrfs: use ssd allocation scheme\n");
+				btrfs_set_opt(info->mount_opt, SSD);
+			}
+			break;
 		case Opt_nobarrier:
 			if (info) {
 				printk("btrfs: turning off barriers\n");

commit 2da98f003f4788b0a72c5f87bc55b061f65f30fa
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jan 16 11:44:43 2008 -0500

    Btrfs: Run igrab on data=ordered inodes to prevent deadlocks during writeout
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4deea393ca94..e506de3168bc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -425,7 +425,7 @@ static struct file_system_type btrfs_fs_type = {
 
 static struct super_operations btrfs_super_ops = {
 	.delete_inode	= btrfs_delete_inode,
-	.drop_inode	= btrfs_drop_inode,
+	.put_inode	= btrfs_put_inode,
 	.put_super	= btrfs_put_super,
 	.read_inode	= btrfs_read_locked_inode,
 	.write_super	= btrfs_write_super,

commit 61295eb8665e723e77af91d0a1e655a4bd28344f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jan 14 16:24:38 2008 -0500

    Btrfs: Add drop inode func to avoid data=ordered deadlock
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9ab4086d463c..4deea393ca94 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -425,6 +425,7 @@ static struct file_system_type btrfs_fs_type = {
 
 static struct super_operations btrfs_super_ops = {
 	.delete_inode	= btrfs_delete_inode,
+	.drop_inode	= btrfs_drop_inode,
 	.put_super	= btrfs_put_super,
 	.read_inode	= btrfs_read_locked_inode,
 	.write_super	= btrfs_write_super,

commit 21ad10cf3e9c1ef42e725e5c3a593c49f779a16b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jan 9 09:23:21 2008 -0500

    Btrfs: Add flush barriers on commit
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f1b56eb77b1d..9ab4086d463c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -64,13 +64,14 @@ static void btrfs_put_super (struct super_block * sb)
 
 enum {
 	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_max_extent,
-	Opt_alloc_start, Opt_err,
+	Opt_alloc_start, Opt_nobarrier, Opt_err,
 };
 
 static match_table_t tokens = {
 	{Opt_subvol, "subvol=%s"},
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
+	{Opt_nobarrier, "nobarrier"},
 	{Opt_max_extent, "max_extent=%s"},
 	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_err, NULL}
@@ -148,6 +149,12 @@ static int parse_options (char * options,
 				btrfs_set_opt(info->mount_opt, NODATASUM);
 			}
 			break;
+		case Opt_nobarrier:
+			if (info) {
+				printk("btrfs: turning off barriers\n");
+				btrfs_set_opt(info->mount_opt, NOBARRIER);
+			}
+			break;
 		case Opt_max_extent:
 			if (info) {
 				char *num = match_strdup(&args[0]);

commit 8f662a76c6af8eb367fa519e9bb9766040d9cea8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Jan 2 10:01:11 2008 -0500

    Btrfs: Add readahead to the online shrinker, and a mount -o alloc_start= for testing
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3bbd7f665694..f1b56eb77b1d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -63,7 +63,8 @@ static void btrfs_put_super (struct super_block * sb)
 }
 
 enum {
-	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_max_extent, Opt_err,
+	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_max_extent,
+	Opt_alloc_start, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -71,6 +72,7 @@ static match_table_t tokens = {
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
 	{Opt_max_extent, "max_extent=%s"},
+	{Opt_alloc_start, "alloc_start=%s"},
 	{Opt_err, NULL}
 };
 
@@ -162,6 +164,18 @@ static int parse_options (char * options,
 				}
 			}
 			break;
+		case Opt_alloc_start:
+			if (info) {
+				char *num = match_strdup(&args[0]);
+				if (num) {
+					info->alloc_start =
+						btrfs_parse_size(num);
+					kfree(num);
+					printk("btrfs: allocations start at "
+					       "%Lu\n", info->alloc_start);
+				}
+			}
+			break;
 		default:
 			break;
 		}

commit edbd8d4efe4ddaf29a175ae504e2c9a05a96ebee
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Dec 21 16:27:24 2007 -0500

    Btrfs: Support for online FS resize (grow and shrink)
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7cab680418a1..3bbd7f665694 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -74,9 +74,9 @@ static match_table_t tokens = {
 	{Opt_err, NULL}
 };
 
-static unsigned long parse_size(char *str)
+u64 btrfs_parse_size(char *str)
 {
-	unsigned long res;
+	u64 res;
 	int mult = 1;
 	char *end;
 	char last;
@@ -150,7 +150,8 @@ static int parse_options (char * options,
 			if (info) {
 				char *num = match_strdup(&args[0]);
 				if (num) {
-					info->max_extent = parse_size(num);
+					info->max_extent =
+						btrfs_parse_size(num);
 					kfree(num);
 
 					info->max_extent = max_t(u64,

commit 6da6abae027e2dbc59bca5f4168b0760f25068c7
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Dec 18 16:15:09 2007 -0500

    Btrfs: Back port to 2.6.18-el kernels
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b7323914bf5a..7cab680418a1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -35,6 +35,7 @@
 #include <linux/compat.h>
 #include <linux/parser.h>
 #include <linux/ctype.h>
+#include <linux/namei.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"

commit c59f8951d48c5eb000926935f3ab063d8181d1ee
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Dec 17 20:14:04 2007 -0500

    Btrfs: Add mount option to enforce a max extent size
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2116728d1f98..b7323914bf5a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -34,6 +34,7 @@
 #include <linux/statfs.h>
 #include <linux/compat.h>
 #include <linux/parser.h>
+#include <linux/ctype.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -61,16 +62,42 @@ static void btrfs_put_super (struct super_block * sb)
 }
 
 enum {
-	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_err,
+	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_max_extent, Opt_err,
 };
 
 static match_table_t tokens = {
 	{Opt_subvol, "subvol=%s"},
 	{Opt_nodatasum, "nodatasum"},
 	{Opt_nodatacow, "nodatacow"},
+	{Opt_max_extent, "max_extent=%s"},
 	{Opt_err, NULL}
 };
 
+static unsigned long parse_size(char *str)
+{
+	unsigned long res;
+	int mult = 1;
+	char *end;
+	char last;
+
+	res = simple_strtoul(str, &end, 10);
+
+	last = end[0];
+	if (isalpha(last)) {
+		last = tolower(last);
+		switch (last) {
+		case 'g':
+			mult *= 1024;
+		case 'm':
+			mult *= 1024;
+		case 'k':
+			mult *= 1024;
+		}
+		res = res * mult;
+	}
+	return res;
+}
+
 static int parse_options (char * options,
 			  struct btrfs_root *root,
 			  char **subvol_name)
@@ -118,6 +145,21 @@ static int parse_options (char * options,
 				btrfs_set_opt(info->mount_opt, NODATASUM);
 			}
 			break;
+		case Opt_max_extent:
+			if (info) {
+				char *num = match_strdup(&args[0]);
+				if (num) {
+					info->max_extent = parse_size(num);
+					kfree(num);
+
+					info->max_extent = max_t(u64,
+							 info->max_extent,
+							 root->sectorsize);
+					printk("btrfs: max_extent at %Lu\n",
+					       info->max_extent);
+				}
+			}
+			break;
 		default:
 			break;
 		}
@@ -329,6 +371,8 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data,
 			btrfs_fill_super, mnt,
 			subvol_name ? subvol_name : "default");
+	if (subvol_name)
+		kfree(subvol_name);
 	return ret;
 }
 

commit be20aa9dbadc8c06283784ee12bbc0d97dea3418
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Dec 17 20:14:01 2007 -0500

    Btrfs: Add mount option to turn off data cow
    
    A number of workloads do not require copy on write data or checksumming.
    mount -o nodatasum to disable checksums and -o nodatacow to disable
    both copy on write and checksumming.
    
    In nodatacow mode, copy on write is still performed when a given extent
    is under snapshot.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ad4f280ec777..2116728d1f98 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -61,12 +61,13 @@ static void btrfs_put_super (struct super_block * sb)
 }
 
 enum {
-	Opt_subvol, Opt_nodatasum, Opt_err,
+	Opt_subvol, Opt_nodatasum, Opt_nodatacow, Opt_err,
 };
 
 static match_table_t tokens = {
 	{Opt_subvol, "subvol=%s"},
 	{Opt_nodatasum, "nodatasum"},
+	{Opt_nodatacow, "nodatacow"},
 	{Opt_err, NULL}
 };
 
@@ -78,12 +79,20 @@ static int parse_options (char * options,
 	struct btrfs_fs_info *info = NULL;
 	substring_t args[MAX_OPT_ARGS];
 
-	if (root)
-		info = root->fs_info;
-
 	if (!options)
 		return 1;
 
+	/*
+	 * strsep changes the string, duplicate it because parse_options
+	 * gets called twice
+	 */
+	options = kstrdup(options, GFP_NOFS);
+	if (!options)
+		return -ENOMEM;
+
+	if (root)
+		info = root->fs_info;
+
 	while ((p = strsep (&options, ",")) != NULL) {
 		int token;
 		if (!*p)
@@ -92,17 +101,28 @@ static int parse_options (char * options,
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_subvol:
-			if (subvol_name)
+			if (subvol_name) {
 				*subvol_name = match_strdup(&args[0]);
+			}
 			break;
 		case Opt_nodatasum:
-			if (root)
+			if (info) {
+				printk("btrfs: setting nodatacsum\n");
 				btrfs_set_opt(info->mount_opt, NODATASUM);
+			}
+			break;
+		case Opt_nodatacow:
+			if (info) {
+				printk("btrfs: setting nodatacow\n");
+				btrfs_set_opt(info->mount_opt, NODATACOW);
+				btrfs_set_opt(info->mount_opt, NODATASUM);
+			}
 			break;
 		default:
-			return 0;
+			break;
 		}
 	}
+	kfree(options);
 	return 1;
 }
 

commit b6cda9bcb4df7544c67fc3548a53bc1607d59f46
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Dec 14 15:30:32 2007 -0500

    Btrfs: Add mount -o nodatasum to turn of file data checksumming
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ffa02872c4d6..ad4f280ec777 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -61,11 +61,12 @@ static void btrfs_put_super (struct super_block * sb)
 }
 
 enum {
-	Opt_subvol, Opt_err,
+	Opt_subvol, Opt_nodatasum, Opt_err,
 };
 
 static match_table_t tokens = {
 	{Opt_subvol, "subvol=%s"},
+	{Opt_nodatasum, "nodatasum"},
 	{Opt_err, NULL}
 };
 
@@ -74,7 +75,12 @@ static int parse_options (char * options,
 			  char **subvol_name)
 {
 	char * p;
+	struct btrfs_fs_info *info = NULL;
 	substring_t args[MAX_OPT_ARGS];
+
+	if (root)
+		info = root->fs_info;
+
 	if (!options)
 		return 1;
 
@@ -86,7 +92,12 @@ static int parse_options (char * options,
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_subvol:
-			*subvol_name = match_strdup(&args[0]);
+			if (subvol_name)
+				*subvol_name = match_strdup(&args[0]);
+			break;
+		case Opt_nodatasum:
+			if (root)
+				btrfs_set_opt(info->mount_opt, NODATASUM);
 			break;
 		default:
 			return 0;
@@ -143,6 +154,8 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 		goto fail_close;
 	}
 
+	parse_options((char *)data, tree_root, NULL);
+
 	/* this does the super kobj at the same time */
 	err = btrfs_sysfs_add_super(tree_root->fs_info);
 	if (err)

commit 2f4cbe6442d3be7b5e4cf1607a5ab33995fe2d25
Author: Wyatt Banks <wyatt@banksresearch.com>
Date:   Mon Nov 19 10:22:33 2007 -0500

    Btrfs: Return value checking in module init
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c46bc3911798..ffa02872c4d6 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -347,9 +347,24 @@ static int __init init_btrfs_fs(void)
 	btrfs_init_transaction_sys();
 	err = btrfs_init_cachep();
 	if (err)
-		return err;
-	extent_map_init();
-	return register_filesystem(&btrfs_fs_type);
+		goto free_transaction_sys;
+	err = extent_map_init();
+	if (err)
+		goto free_cachep;
+
+	err = register_filesystem(&btrfs_fs_type);
+	if (err)
+		goto free_extent_map;
+	return 0;
+
+free_extent_map:
+	extent_map_exit();
+free_cachep:
+	btrfs_destroy_cachep();
+free_transaction_sys:
+	btrfs_exit_transaction_sys();
+	btrfs_exit_sysfs();
+	return err;
 }
 
 static void __exit exit_btrfs_fs(void)

commit 5103e947b9b7ac18ddb21a04ee3486e94c6504d7
Author: Josef Bacik <jbacik@redhat.com>
Date:   Fri Nov 16 11:45:54 2007 -0500

    xattr support for btrfs
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f94aa1f97a0a..c46bc3911798 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -40,6 +40,7 @@
 #include "btrfs_inode.h"
 #include "ioctl.h"
 #include "print-tree.h"
+#include "xattr.h"
 
 #define BTRFS_SUPER_MAGIC 0x9123683E
 
@@ -106,6 +107,7 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	sb->s_magic = BTRFS_SUPER_MAGIC;
 	sb->s_op = &btrfs_super_ops;
+	sb->s_xattr = btrfs_xattr_handlers;
 	sb->s_time_gran = 1;
 
 	tree_root = open_ctree(sb);

commit 3326d1b07c0cb6a2ff5b835b7a2cffa54124d074
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:18:25 2007 -0400

    Btrfs: Allow tails larger than one page
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5c4370f3a5b8..f94aa1f97a0a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -280,7 +280,6 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 error_bdev:
 	close_bdev_excl(bdev);
 error:
-printk("get_sb failed\n");
 	return error;
 }
 /* end copy & paste */
@@ -295,7 +294,6 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data,
 			btrfs_fill_super, mnt,
 			subvol_name ? subvol_name : "default");
-printk("btrfs_get_sb returns %d\n", ret);
 	return ret;
 }
 

commit db94535db75e67fab12ccbb7f5ee548e33fed891
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:15:53 2007 -0400

    Btrfs: Allow tree blocks larger than the page size
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 39a1435c68f1..5c4370f3a5b8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -303,10 +303,12 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
 	struct btrfs_super_block *disk_super = &root->fs_info->super_copy;
+	int bits = dentry->d_sb->s_blocksize_bits;
 
 	buf->f_namelen = BTRFS_NAME_LEN;
-	buf->f_blocks = btrfs_super_total_blocks(disk_super);
-	buf->f_bfree = buf->f_blocks - btrfs_super_blocks_used(disk_super);
+	buf->f_blocks = btrfs_super_total_bytes(disk_super) >> bits;
+	buf->f_bfree = buf->f_blocks -
+		(btrfs_super_bytes_used(disk_super) >> bits);
 	buf->f_bavail = buf->f_bfree;
 	buf->f_bsize = dentry->d_sb->s_blocksize;
 	buf->f_type = BTRFS_SUPER_MAGIC;

commit 5f39d397dfbe140a14edecd4e73c34ce23c4f9ee
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:14:19 2007 -0400

    Btrfs: Create extent_buffer interface for large blocksizes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 66a01cbbbea1..39a1435c68f1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -41,7 +41,7 @@
 #include "ioctl.h"
 #include "print-tree.h"
 
-#define BTRFS_SUPER_MAGIC 0x9123682E
+#define BTRFS_SUPER_MAGIC 0x9123683E
 
 static struct super_operations btrfs_super_ops;
 
@@ -115,13 +115,12 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 		return -EIO;
 	}
 	sb->s_fs_info = tree_root;
-	disk_super = tree_root->fs_info->disk_super;
+	disk_super = &tree_root->fs_info->super_copy;
 	inode = btrfs_iget_locked(sb, btrfs_super_root_dir(disk_super),
 				  tree_root);
 	bi = BTRFS_I(inode);
 	bi->location.objectid = inode->i_ino;
 	bi->location.offset = 0;
-	bi->location.flags = 0;
 	bi->root = tree_root;
 
 	btrfs_set_key_type(&bi->location, BTRFS_INODE_ITEM_KEY);
@@ -281,6 +280,7 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 error_bdev:
 	close_bdev_excl(bdev);
 error:
+printk("get_sb failed\n");
 	return error;
 }
 /* end copy & paste */
@@ -295,6 +295,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data,
 			btrfs_fill_super, mnt,
 			subvol_name ? subvol_name : "default");
+printk("btrfs_get_sb returns %d\n", ret);
 	return ret;
 }
 

commit 95e0528919cb0c7635b37496e0ad1c41e4c0dd7c
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Aug 29 09:11:44 2007 -0400

    Btrfs: Use mount -o subvol to select the subvol directory instead of dev:
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8a94be1a773b..66a01cbbbea1 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -33,6 +33,7 @@
 #include <linux/writeback.h>
 #include <linux/statfs.h>
 #include <linux/compat.h>
+#include <linux/parser.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -58,6 +59,41 @@ static void btrfs_put_super (struct super_block * sb)
 	sb->s_fs_info = NULL;
 }
 
+enum {
+	Opt_subvol, Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_subvol, "subvol=%s"},
+	{Opt_err, NULL}
+};
+
+static int parse_options (char * options,
+			  struct btrfs_root *root,
+			  char **subvol_name)
+{
+	char * p;
+	substring_t args[MAX_OPT_ARGS];
+	if (!options)
+		return 1;
+
+	while ((p = strsep (&options, ",")) != NULL) {
+		int token;
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_subvol:
+			*subvol_name = match_strdup(&args[0]);
+			break;
+		default:
+			return 0;
+		}
+	}
+	return 1;
+}
+
 static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 {
 	struct inode * inode;
@@ -250,22 +286,15 @@ int btrfs_get_sb_bdev(struct file_system_type *fs_type,
 /* end copy & paste */
 
 static int btrfs_get_sb(struct file_system_type *fs_type,
-	int flags, const char *identifier, void *data, struct vfsmount *mnt)
+	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
 	int ret;
-	char *_identifier = kstrdup(identifier, GFP_KERNEL);
-	char *subvol_name;
-	const char *dev_name;
-
-	subvol_name = _identifier;
-	dev_name = strsep(&subvol_name, ":");
-	if (!dev_name)
-		return -ENOMEM;
+	char *subvol_name = NULL;
 
+	parse_options((char *)data, NULL, &subvol_name);
 	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data,
 			btrfs_fill_super, mnt,
 			subvol_name ? subvol_name : "default");
-	kfree(_identifier);
 	return ret;
 }
 

commit 4b82d6e4a592016ac75e756ca519923e0fc18f00
Author: Yan <yanzheng@21cn.com>
Date:   Wed Aug 29 09:11:44 2007 -0400

    Btrfs: Add mount into directory support
    
    Modified form of original patch from Christoph Hellwig to make btrfs
    mount into the default subvolume by default.
    
    mount /dev/somedevice:subvolumename to get other subvolumes or
    mount /dev/somedevice:. to get the root
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a68101ae1a3b..8a94be1a773b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -16,6 +16,7 @@
  * Boston, MA 021110-1307, USA.
  */
 
+#include <linux/blkdev.h>
 #include <linux/module.h>
 #include <linux/buffer_head.h>
 #include <linux/fs.h>
@@ -26,6 +27,7 @@
 #include <linux/string.h>
 #include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
+#include <linux/mount.h>
 #include <linux/mpage.h>
 #include <linux/swap.h>
 #include <linux/writeback.h>
@@ -145,11 +147,126 @@ static void btrfs_write_super(struct super_block *sb)
 	sb->s_dirt = 0;
 }
 
+/*
+ * This is almost a copy of get_sb_bdev in fs/super.c.
+ * We need the local copy to allow direct mounting of
+ * subvolumes, but this could be easily integrated back
+ * into the generic version.  --hch
+ */
+
+/* start copy & paste */
+static int set_bdev_super(struct super_block *s, void *data)
+{
+	s->s_bdev = data;
+	s->s_dev = s->s_bdev->bd_dev;
+	return 0;
+}
+
+static int test_bdev_super(struct super_block *s, void *data)
+{
+	return (void *)s->s_bdev == data;
+}
+
+int btrfs_get_sb_bdev(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data,
+	int (*fill_super)(struct super_block *, void *, int),
+	struct vfsmount *mnt, const char *subvol)
+{
+	struct block_device *bdev = NULL;
+	struct super_block *s;
+	struct dentry *root;
+	int error = 0;
+
+	bdev = open_bdev_excl(dev_name, flags, fs_type);
+	if (IS_ERR(bdev))
+		return PTR_ERR(bdev);
+
+	/*
+	 * once the super is inserted into the list by sget, s_umount
+	 * will protect the lockfs code from trying to start a snapshot
+	 * while we are mounting
+	 */
+	down(&bdev->bd_mount_sem);
+	s = sget(fs_type, test_bdev_super, set_bdev_super, bdev);
+	up(&bdev->bd_mount_sem);
+	if (IS_ERR(s))
+		goto error_s;
+
+	if (s->s_root) {
+		if ((flags ^ s->s_flags) & MS_RDONLY) {
+			up_write(&s->s_umount);
+			deactivate_super(s);
+			error = -EBUSY;
+			goto error_bdev;
+		}
+
+		close_bdev_excl(bdev);
+	} else {
+		char b[BDEVNAME_SIZE];
+
+		s->s_flags = flags;
+		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
+		sb_set_blocksize(s, block_size(bdev));
+		error = fill_super(s, data, flags & MS_SILENT ? 1 : 0);
+		if (error) {
+			up_write(&s->s_umount);
+			deactivate_super(s);
+			goto error;
+		}
+
+		s->s_flags |= MS_ACTIVE;
+	}
+
+	if (subvol) {
+		root = lookup_one_len(subvol, s->s_root, strlen(subvol));
+		if (IS_ERR(root)) {
+			up_write(&s->s_umount);
+			deactivate_super(s);
+			error = PTR_ERR(root);
+			goto error;
+		}
+		if (!root->d_inode) {
+			dput(root);
+			up_write(&s->s_umount);
+			deactivate_super(s);
+			error = -ENXIO;
+			goto error;
+		}
+	} else {
+		root = dget(s->s_root);
+	}
+
+	mnt->mnt_sb = s;
+	mnt->mnt_root = root;
+	return 0;
+
+error_s:
+	error = PTR_ERR(s);
+error_bdev:
+	close_bdev_excl(bdev);
+error:
+	return error;
+}
+/* end copy & paste */
+
 static int btrfs_get_sb(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
+	int flags, const char *identifier, void *data, struct vfsmount *mnt)
 {
-	return get_sb_bdev(fs_type, flags, dev_name, data,
-			   btrfs_fill_super, mnt);
+	int ret;
+	char *_identifier = kstrdup(identifier, GFP_KERNEL);
+	char *subvol_name;
+	const char *dev_name;
+
+	subvol_name = _identifier;
+	dev_name = strsep(&subvol_name, ":");
+	if (!dev_name)
+		return -ENOMEM;
+
+	ret = btrfs_get_sb_bdev(fs_type, flags, dev_name, data,
+			btrfs_fill_super, mnt,
+			subvol_name ? subvol_name : "default");
+	kfree(_identifier);
+	return ret;
 }
 
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)

commit 58176a9604c5db1784d2c979aea472b3be40b6f0
Author: Josef Bacik <jbacik@redhat.com>
Date:   Wed Aug 29 15:47:34 2007 -0400

    Btrfs: Add per-root block accounting and sysfs entries
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7da95538745f..a68101ae1a3b 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -45,12 +45,14 @@ static struct super_operations btrfs_super_ops;
 static void btrfs_put_super (struct super_block * sb)
 {
 	struct btrfs_root *root = btrfs_sb(sb);
+	struct btrfs_fs_info *fs = root->fs_info;
 	int ret;
 
 	ret = close_ctree(root);
 	if (ret) {
 		printk("close ctree returns %d\n", ret);
 	}
+	btrfs_sysfs_del_super(fs);
 	sb->s_fs_info = NULL;
 }
 
@@ -101,6 +103,12 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 		err = -ENOMEM;
 		goto fail_close;
 	}
+
+	/* this does the super kobj at the same time */
+	err = btrfs_sysfs_add_super(tree_root->fs_info);
+	if (err)
+		goto fail_close;
+
 	sb->s_root = root_dentry;
 	btrfs_transaction_queue_work(tree_root, HZ * 30);
 	return 0;
@@ -182,6 +190,11 @@ static struct super_operations btrfs_super_ops = {
 static int __init init_btrfs_fs(void)
 {
 	int err;
+
+	err = btrfs_init_sysfs();
+	if (err)
+		return err;
+
 	btrfs_init_transaction_sys();
 	err = btrfs_init_cachep();
 	if (err)
@@ -196,6 +209,7 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_destroy_cachep();
 	extent_map_exit();
 	unregister_filesystem(&btrfs_fs_type);
+	btrfs_exit_sysfs();
 }
 
 module_init(init_btrfs_fs)

commit b888db2bd7b67f190b32934e6a86181f262ac3ec
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Aug 27 16:49:44 2007 -0400

    Btrfs: Add delayed allocation to the extent based page tree code
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7b7c32c73a2c..7da95538745f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -83,6 +83,7 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	bi->location.offset = 0;
 	bi->location.flags = 0;
 	bi->root = tree_root;
+
 	btrfs_set_key_type(&bi->location, BTRFS_INODE_ITEM_KEY);
 
 	if (!inode) {

commit a52d9a8033c454cd9b4697cfafb467509fc1693f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Aug 27 16:49:44 2007 -0400

    Btrfs: Extent based page cache code.  This uses an rbtree of extents and tests
    instead of buffer heads.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 74f3de47423c..7b7c32c73a2c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -185,6 +185,7 @@ static int __init init_btrfs_fs(void)
 	err = btrfs_init_cachep();
 	if (err)
 		return err;
+	extent_map_init();
 	return register_filesystem(&btrfs_fs_type);
 }
 
@@ -192,6 +193,7 @@ static void __exit exit_btrfs_fs(void)
 {
 	btrfs_exit_transaction_sys();
 	btrfs_destroy_cachep();
+	extent_map_exit();
 	unregister_filesystem(&btrfs_fs_type);
 }
 

commit e9d0b13b5bbb58c9b840e407a8d181442f799966
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Aug 10 14:06:19 2007 -0400

    Btrfs: Btree defrag on the extent-mapping tree as well
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2e797d5fb281..74f3de47423c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -121,7 +121,9 @@ static int btrfs_sync_fs(struct super_block *sb, int wait)
 		filemap_flush(root->fs_info->btree_inode->i_mapping);
 		return 0;
 	}
+	btrfs_clean_old_snapshots(root);
 	mutex_lock(&root->fs_info->fs_mutex);
+	btrfs_defrag_dirty_roots(root->fs_info);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);
 	sb->s_dirt = 0;

commit 4b52dff6d371b9b93bc99f64c32831ea9a8ec3ac
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jun 26 10:06:50 2007 -0400

    Btrfs: Fix super block updates during transaction commit
    
    The super block written during commit was not consistent with the state of
    the trees.  This change adds an in-memory copy of the super so that we can
    make sure to write out consistent data during a commit.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c11ecf500202..2e797d5fb281 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -144,7 +144,7 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
-	struct btrfs_super_block *disk_super = root->fs_info->disk_super;
+	struct btrfs_super_block *disk_super = &root->fs_info->super_copy;
 
 	buf->f_namelen = BTRFS_NAME_LEN;
 	buf->f_blocks = btrfs_super_total_blocks(disk_super);

commit 54aa1f4dfdacd60a19c4471220b24e581be6f774
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jun 22 14:16:25 2007 -0400

    Btrfs: Audit callers and return codes to make sure -ENOSPC gets up the stack
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ef8ad18b275c..c11ecf500202 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -125,9 +125,8 @@ static int btrfs_sync_fs(struct super_block *sb, int wait)
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);
 	sb->s_dirt = 0;
-	BUG_ON(ret);
 	mutex_unlock(&root->fs_info->fs_mutex);
-	return 0;
+	return ret;
 }
 
 static void btrfs_write_super(struct super_block *sb)

commit 6cbd55707802b98843f953d1ae6d8f5bcd9a76c0
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jun 12 09:07:21 2007 -0400

    Btrfs: add GPLv2
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 94b3535a2a11..ef8ad18b275c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1,3 +1,21 @@
+/*
+ * Copyright (C) 2007 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
 #include <linux/module.h>
 #include <linux/buffer_head.h>
 #include <linux/fs.h>

commit 39279cc3d2704cfbf9c35dcb5bdd392159ae4625
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jun 12 06:35:45 2007 -0400

    Btrfs: split up super.c
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9749090cfbb8..94b3535a2a11 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -20,2686 +20,101 @@
 #include "ioctl.h"
 #include "print-tree.h"
 
-struct btrfs_iget_args {
-	u64 ino;
-	struct btrfs_root *root;
-};
-
-#define BTRFS_SUPER_MAGIC 0x9123682E
-
-static struct inode_operations btrfs_dir_inode_operations;
-static struct inode_operations btrfs_symlink_inode_operations;
-static struct inode_operations btrfs_dir_ro_inode_operations;
-static struct super_operations btrfs_super_ops;
-static struct file_operations btrfs_dir_file_operations;
-static struct inode_operations btrfs_file_inode_operations;
-static struct address_space_operations btrfs_aops;
-static struct address_space_operations btrfs_symlink_aops;
-static struct file_operations btrfs_file_operations;
-
-static int drop_extents(struct btrfs_trans_handle *trans,
-			  struct btrfs_root *root,
-			  struct inode *inode,
-			  u64 start, u64 end, u64 *hint_block);
-static int btrfs_get_block(struct inode *inode, sector_t iblock,
-			   struct buffer_head *result, int create);
-
-
-#define S_SHIFT 12
-static unsigned char btrfs_type_by_mode[S_IFMT >> S_SHIFT] = {
-	[S_IFREG >> S_SHIFT]	= BTRFS_FT_REG_FILE,
-	[S_IFDIR >> S_SHIFT]	= BTRFS_FT_DIR,
-	[S_IFCHR >> S_SHIFT]	= BTRFS_FT_CHRDEV,
-	[S_IFBLK >> S_SHIFT]	= BTRFS_FT_BLKDEV,
-	[S_IFIFO >> S_SHIFT]	= BTRFS_FT_FIFO,
-	[S_IFSOCK >> S_SHIFT]	= BTRFS_FT_SOCK,
-	[S_IFLNK >> S_SHIFT]	= BTRFS_FT_SYMLINK,
-};
-
-static void btrfs_read_locked_inode(struct inode *inode)
-{
-	struct btrfs_path *path;
-	struct btrfs_inode_item *inode_item;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct btrfs_key location;
-	u64 alloc_group_block;
-	int ret;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	mutex_lock(&root->fs_info->fs_mutex);
-
-	memcpy(&location, &BTRFS_I(inode)->location, sizeof(location));
-	ret = btrfs_lookup_inode(NULL, root, path, &location, 0);
-	if (ret) {
-		btrfs_free_path(path);
-		goto make_bad;
-	}
-	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-				  path->slots[0],
-				  struct btrfs_inode_item);
-
-	inode->i_mode = btrfs_inode_mode(inode_item);
-	inode->i_nlink = btrfs_inode_nlink(inode_item);
-	inode->i_uid = btrfs_inode_uid(inode_item);
-	inode->i_gid = btrfs_inode_gid(inode_item);
-	inode->i_size = btrfs_inode_size(inode_item);
-	inode->i_atime.tv_sec = btrfs_timespec_sec(&inode_item->atime);
-	inode->i_atime.tv_nsec = btrfs_timespec_nsec(&inode_item->atime);
-	inode->i_mtime.tv_sec = btrfs_timespec_sec(&inode_item->mtime);
-	inode->i_mtime.tv_nsec = btrfs_timespec_nsec(&inode_item->mtime);
-	inode->i_ctime.tv_sec = btrfs_timespec_sec(&inode_item->ctime);
-	inode->i_ctime.tv_nsec = btrfs_timespec_nsec(&inode_item->ctime);
-	inode->i_blocks = btrfs_inode_nblocks(inode_item);
-	inode->i_generation = btrfs_inode_generation(inode_item);
-	alloc_group_block = btrfs_inode_block_group(inode_item);
-	BTRFS_I(inode)->block_group = btrfs_lookup_block_group(root->fs_info,
-						       alloc_group_block);
-
-	btrfs_free_path(path);
-	inode_item = NULL;
-
-	mutex_unlock(&root->fs_info->fs_mutex);
-
-	switch (inode->i_mode & S_IFMT) {
-#if 0
-	default:
-		init_special_inode(inode, inode->i_mode,
-				   btrfs_inode_rdev(inode_item));
-		break;
-#endif
-	case S_IFREG:
-		inode->i_mapping->a_ops = &btrfs_aops;
-		inode->i_fop = &btrfs_file_operations;
-		inode->i_op = &btrfs_file_inode_operations;
-		break;
-	case S_IFDIR:
-		inode->i_fop = &btrfs_dir_file_operations;
-		if (root == root->fs_info->tree_root)
-			inode->i_op = &btrfs_dir_ro_inode_operations;
-		else
-			inode->i_op = &btrfs_dir_inode_operations;
-		break;
-	case S_IFLNK:
-		inode->i_op = &btrfs_symlink_inode_operations;
-		inode->i_mapping->a_ops = &btrfs_symlink_aops;
-		break;
-	}
-	return;
-
-make_bad:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	make_bad_inode(inode);
-}
-
-static void fill_inode_item(struct btrfs_inode_item *item,
-			    struct inode *inode)
-{
-	btrfs_set_inode_uid(item, inode->i_uid);
-	btrfs_set_inode_gid(item, inode->i_gid);
-	btrfs_set_inode_size(item, inode->i_size);
-	btrfs_set_inode_mode(item, inode->i_mode);
-	btrfs_set_inode_nlink(item, inode->i_nlink);
-	btrfs_set_timespec_sec(&item->atime, inode->i_atime.tv_sec);
-	btrfs_set_timespec_nsec(&item->atime, inode->i_atime.tv_nsec);
-	btrfs_set_timespec_sec(&item->mtime, inode->i_mtime.tv_sec);
-	btrfs_set_timespec_nsec(&item->mtime, inode->i_mtime.tv_nsec);
-	btrfs_set_timespec_sec(&item->ctime, inode->i_ctime.tv_sec);
-	btrfs_set_timespec_nsec(&item->ctime, inode->i_ctime.tv_nsec);
-	btrfs_set_inode_nblocks(item, inode->i_blocks);
-	btrfs_set_inode_generation(item, inode->i_generation);
-	btrfs_set_inode_block_group(item,
-				    BTRFS_I(inode)->block_group->key.objectid);
-}
-
-static int btrfs_update_inode(struct btrfs_trans_handle *trans,
-			      struct btrfs_root *root,
-			      struct inode *inode)
-{
-	struct btrfs_inode_item *inode_item;
-	struct btrfs_path *path;
-	int ret;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	ret = btrfs_lookup_inode(trans, root, path,
-				 &BTRFS_I(inode)->location, 1);
-	if (ret) {
-		if (ret > 0)
-			ret = -ENOENT;
-		goto failed;
-	}
-
-	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-				  path->slots[0],
-				  struct btrfs_inode_item);
-
-	fill_inode_item(inode_item, inode);
-	btrfs_mark_buffer_dirty(path->nodes[0]);
-	ret = 0;
-failed:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
-	return ret;
-}
-
-
-static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
-			      struct btrfs_root *root,
-			      struct inode *dir,
-			      struct dentry *dentry)
-{
-	struct btrfs_path *path;
-	const char *name = dentry->d_name.name;
-	int name_len = dentry->d_name.len;
-	int ret = 0;
-	u64 objectid;
-	struct btrfs_dir_item *di;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	di = btrfs_lookup_dir_item(trans, root, path, dir->i_ino,
-				    name, name_len, -1);
-	if (IS_ERR(di)) {
-		ret = PTR_ERR(di);
-		goto err;
-	}
-	if (!di) {
-		ret = -ENOENT;
-		goto err;
-	}
-	objectid = btrfs_disk_key_objectid(&di->location);
-	ret = btrfs_delete_one_dir_name(trans, root, path, di);
-	BUG_ON(ret);
-	btrfs_release_path(root, path);
-
-	di = btrfs_lookup_dir_index_item(trans, root, path, dir->i_ino,
-					 objectid, name, name_len, -1);
-	if (IS_ERR(di)) {
-		ret = PTR_ERR(di);
-		goto err;
-	}
-	if (!di) {
-		ret = -ENOENT;
-		goto err;
-	}
-	ret = btrfs_delete_one_dir_name(trans, root, path, di);
-	BUG_ON(ret);
-
-	dentry->d_inode->i_ctime = dir->i_ctime;
-err:
-	btrfs_free_path(path);
-	if (!ret) {
-		dir->i_size -= name_len * 2;
-		btrfs_update_inode(trans, root, dir);
-		drop_nlink(dentry->d_inode);
-		btrfs_update_inode(trans, root, dentry->d_inode);
-		dir->i_sb->s_dirt = 1;
-	}
-	return ret;
-}
-
-static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
-{
-	struct btrfs_root *root;
-	struct btrfs_trans_handle *trans;
-	int ret;
-
-	root = BTRFS_I(dir)->root;
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, dir);
-	ret = btrfs_unlink_trans(trans, root, dir, dentry);
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	btrfs_btree_balance_dirty(root);
-	return ret;
-}
-
-static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
-{
-	struct inode *inode = dentry->d_inode;
-	int err;
-	int ret;
-	struct btrfs_root *root = BTRFS_I(dir)->root;
-	struct btrfs_path *path;
-	struct btrfs_key key;
-	struct btrfs_trans_handle *trans;
-	struct btrfs_key found_key;
-	int found_type;
-	struct btrfs_leaf *leaf;
-	char *goodnames = "..";
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, dir);
-	key.objectid = inode->i_ino;
-	key.offset = (u64)-1;
-	key.flags = (u32)-1;
-	while(1) {
-		ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
-		if (ret < 0) {
-			err = ret;
-			goto out;
-		}
-		BUG_ON(ret == 0);
-		if (path->slots[0] == 0) {
-			err = -ENOENT;
-			goto out;
-		}
-		path->slots[0]--;
-		leaf = btrfs_buffer_leaf(path->nodes[0]);
-		btrfs_disk_key_to_cpu(&found_key,
-				      &leaf->items[path->slots[0]].key);
-		found_type = btrfs_key_type(&found_key);
-		if (found_key.objectid != inode->i_ino) {
-			err = -ENOENT;
-			goto out;
-		}
-		if ((found_type != BTRFS_DIR_ITEM_KEY &&
-		     found_type != BTRFS_DIR_INDEX_KEY) ||
-	            (!btrfs_match_dir_item_name(root, path, goodnames, 2) &&
-	            !btrfs_match_dir_item_name(root, path, goodnames, 1))) {
-			err = -ENOTEMPTY;
-			goto out;
-		}
-		ret = btrfs_del_item(trans, root, path);
-		BUG_ON(ret);
-
-		if (found_type == BTRFS_DIR_ITEM_KEY && found_key.offset == 1)
-			break;
-		btrfs_release_path(root, path);
-	}
-	ret = 0;
-	btrfs_release_path(root, path);
-
-	/* now the directory is empty */
-	err = btrfs_unlink_trans(trans, root, dir, dentry);
-	if (!err) {
-		inode->i_size = 0;
-	}
-out:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	ret = btrfs_end_transaction(trans, root);
-	btrfs_btree_balance_dirty(root);
-	if (ret && !err)
-		err = ret;
-	return err;
-}
-
-static int btrfs_free_inode(struct btrfs_trans_handle *trans,
-			    struct btrfs_root *root,
-			    struct inode *inode)
-{
-	struct btrfs_path *path;
-	int ret;
-
-	clear_inode(inode);
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	ret = btrfs_lookup_inode(trans, root, path,
-				 &BTRFS_I(inode)->location, -1);
-	BUG_ON(ret);
-	ret = btrfs_del_item(trans, root, path);
-	BUG_ON(ret);
-	btrfs_free_path(path);
-	return ret;
-}
-
-static void reada_truncate(struct btrfs_root *root, struct btrfs_path *path,
-			   u64 objectid)
-{
-	struct btrfs_node *node;
-	int i;
-	int nritems;
-	u64 item_objectid;
-	u64 blocknr;
-	int slot;
-	int ret;
-
-	if (!path->nodes[1])
-		return;
-	node = btrfs_buffer_node(path->nodes[1]);
-	slot = path->slots[1];
-	if (slot == 0)
-		return;
-	nritems = btrfs_header_nritems(&node->header);
-	for (i = slot - 1; i >= 0; i--) {
-		item_objectid = btrfs_disk_key_objectid(&node->ptrs[i].key);
-		if (item_objectid != objectid)
-			break;
-		blocknr = btrfs_node_blockptr(node, i);
-		ret = readahead_tree_block(root, blocknr);
-		if (ret)
-			break;
-	}
-}
-
-static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
-				   struct btrfs_root *root,
-				   struct inode *inode)
-{
-	int ret;
-	struct btrfs_path *path;
-	struct btrfs_key key;
-	struct btrfs_disk_key *found_key;
-	u32 found_type;
-	struct btrfs_leaf *leaf;
-	struct btrfs_file_extent_item *fi;
-	u64 extent_start = 0;
-	u64 extent_num_blocks = 0;
-	u64 item_end = 0;
-	int found_extent;
-	int del_item;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	/* FIXME, add redo link to tree so we don't leak on crash */
-	key.objectid = inode->i_ino;
-	key.offset = (u64)-1;
-	key.flags = (u32)-1;
-	while(1) {
-		btrfs_init_path(path);
-		fi = NULL;
-		ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
-		if (ret < 0) {
-			goto error;
-		}
-		if (ret > 0) {
-			BUG_ON(path->slots[0] == 0);
-			path->slots[0]--;
-		}
-		reada_truncate(root, path, inode->i_ino);
-		leaf = btrfs_buffer_leaf(path->nodes[0]);
-		found_key = &leaf->items[path->slots[0]].key;
-		found_type = btrfs_disk_key_type(found_key);
-		if (btrfs_disk_key_objectid(found_key) != inode->i_ino)
-			break;
-		if (found_type != BTRFS_CSUM_ITEM_KEY &&
-		    found_type != BTRFS_DIR_ITEM_KEY &&
-		    found_type != BTRFS_DIR_INDEX_KEY &&
-		    found_type != BTRFS_EXTENT_DATA_KEY)
-			break;
-		item_end = btrfs_disk_key_offset(found_key);
-		if (found_type == BTRFS_EXTENT_DATA_KEY) {
-			fi = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-					    path->slots[0],
-					    struct btrfs_file_extent_item);
-			if (btrfs_file_extent_type(fi) !=
-			    BTRFS_FILE_EXTENT_INLINE) {
-				item_end += btrfs_file_extent_num_blocks(fi) <<
-						inode->i_blkbits;
-			}
-		}
-		if (found_type == BTRFS_CSUM_ITEM_KEY) {
-			ret = btrfs_csum_truncate(trans, root, path,
-						  inode->i_size);
-			BUG_ON(ret);
-		}
-		if (item_end < inode->i_size) {
-			if (found_type) {
-				btrfs_set_key_type(&key, found_type - 1);
-				continue;
-			}
-			break;
-		}
-		if (btrfs_disk_key_offset(found_key) >= inode->i_size)
-			del_item = 1;
-		else
-			del_item = 0;
-		found_extent = 0;
-
-		if (found_type == BTRFS_EXTENT_DATA_KEY &&
-			   btrfs_file_extent_type(fi) !=
-			   BTRFS_FILE_EXTENT_INLINE) {
-			u64 num_dec;
-			if (!del_item) {
-				u64 orig_num_blocks =
-					btrfs_file_extent_num_blocks(fi);
-				extent_num_blocks = inode->i_size -
-					btrfs_disk_key_offset(found_key) +
-					root->blocksize - 1;
-				extent_num_blocks >>= inode->i_blkbits;
-				btrfs_set_file_extent_num_blocks(fi,
-							 extent_num_blocks);
-				inode->i_blocks -= (orig_num_blocks -
-					extent_num_blocks) << 3;
-				mark_buffer_dirty(path->nodes[0]);
-			} else {
-				extent_start =
-					btrfs_file_extent_disk_blocknr(fi);
-				extent_num_blocks =
-					btrfs_file_extent_disk_num_blocks(fi);
-				/* FIXME blocksize != 4096 */
-				num_dec = btrfs_file_extent_num_blocks(fi) << 3;
-				if (extent_start != 0) {
-					found_extent = 1;
-					inode->i_blocks -= num_dec;
-				}
-			}
-		}
-		if (del_item) {
-			ret = btrfs_del_item(trans, root, path);
-			BUG_ON(ret);
-		} else {
-			break;
-		}
-		btrfs_release_path(root, path);
-		if (found_extent) {
-			ret = btrfs_free_extent(trans, root, extent_start,
-						extent_num_blocks, 0);
-			BUG_ON(ret);
-		}
-	}
-	ret = 0;
-error:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
-	inode->i_sb->s_dirt = 1;
-	return ret;
-}
-
-static int btrfs_truncate_page(struct address_space *mapping, loff_t from)
-{
-	struct inode *inode = mapping->host;
-	unsigned blocksize = 1 << inode->i_blkbits;
-	pgoff_t index = from >> PAGE_CACHE_SHIFT;
-	unsigned offset = from & (PAGE_CACHE_SIZE-1);
-	struct page *page;
-	char *kaddr;
-	int ret = 0;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	u64 alloc_hint;
-	struct btrfs_key ins;
-	struct btrfs_trans_handle *trans;
-
-	if ((offset & (blocksize - 1)) == 0)
-		goto out;
-
-	ret = -ENOMEM;
-	page = grab_cache_page(mapping, index);
-	if (!page)
-		goto out;
-
-	if (!PageUptodate(page)) {
-		ret = mpage_readpage(page, btrfs_get_block);
-		lock_page(page);
-		if (!PageUptodate(page)) {
-			ret = -EIO;
-			goto out;
-		}
-	}
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, inode);
-
-	ret = drop_extents(trans, root, inode, page->index << PAGE_CACHE_SHIFT,
-			   (page->index + 1) << PAGE_CACHE_SHIFT, &alloc_hint);
-	BUG_ON(ret);
-	ret = btrfs_alloc_extent(trans, root, inode->i_ino, 1,
-				 alloc_hint, (u64)-1, &ins, 1);
-	BUG_ON(ret);
-	ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
-				       page->index << PAGE_CACHE_SHIFT,
-				       ins.objectid, 1, 1);
-	BUG_ON(ret);
-	SetPageChecked(page);
-	kaddr = kmap(page);
-	memset(kaddr + offset, 0, PAGE_CACHE_SIZE - offset);
-	flush_dcache_page(page);
-	btrfs_csum_file_block(trans, root, inode->i_ino,
-			      page->index << PAGE_CACHE_SHIFT,
-			      kaddr, PAGE_CACHE_SIZE);
-	kunmap(page);
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-
-	set_page_dirty(page);
-	unlock_page(page);
-	page_cache_release(page);
-out:
-	return ret;
-}
-
-static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)
-{
-	struct inode *inode = dentry->d_inode;
-	int err;
-
-	err = inode_change_ok(inode, attr);
-	if (err)
-		return err;
-
-	if (S_ISREG(inode->i_mode) &&
-	    attr->ia_valid & ATTR_SIZE && attr->ia_size > inode->i_size) {
-		struct btrfs_trans_handle *trans;
-		struct btrfs_root *root = BTRFS_I(inode)->root;
-		u64 mask = root->blocksize - 1;
-		u64 pos = (inode->i_size + mask) & ~mask;
-		u64 hole_size;
-
-		if (attr->ia_size <= pos)
-			goto out;
-
-		btrfs_truncate_page(inode->i_mapping, inode->i_size);
-
-		hole_size = (attr->ia_size - pos + mask) & ~mask;
-		hole_size >>= inode->i_blkbits;
-
-		mutex_lock(&root->fs_info->fs_mutex);
-		trans = btrfs_start_transaction(root, 1);
-		btrfs_set_trans_block_group(trans, inode);
-		err = btrfs_insert_file_extent(trans, root, inode->i_ino,
-					       pos, 0, 0, hole_size);
-		BUG_ON(err);
-		btrfs_end_transaction(trans, root);
-		mutex_unlock(&root->fs_info->fs_mutex);
-	}
-out:
-	err = inode_setattr(inode, attr);
-
-	return err;
-}
-static void btrfs_delete_inode(struct inode *inode)
-{
-	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	int ret;
-
-	truncate_inode_pages(&inode->i_data, 0);
-	if (is_bad_inode(inode)) {
-		goto no_delete;
-	}
-	inode->i_size = 0;
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, inode);
-	ret = btrfs_truncate_in_trans(trans, root, inode);
-	BUG_ON(ret);
-	btrfs_free_inode(trans, root, inode);
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	btrfs_btree_balance_dirty(root);
-	return;
-no_delete:
-	clear_inode(inode);
-}
-
-static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
-			       struct btrfs_key *location)
-{
-	const char *name = dentry->d_name.name;
-	int namelen = dentry->d_name.len;
-	struct btrfs_dir_item *di;
-	struct btrfs_path *path;
-	struct btrfs_root *root = BTRFS_I(dir)->root;
-	int ret;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	di = btrfs_lookup_dir_item(NULL, root, path, dir->i_ino, name,
-				    namelen, 0);
-	if (!di || IS_ERR(di)) {
-		location->objectid = 0;
-		ret = 0;
-		goto out;
-	}
-	btrfs_disk_key_to_cpu(location, &di->location);
-out:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
-	return ret;
-}
-
-static int fixup_tree_root_location(struct btrfs_root *root,
-			     struct btrfs_key *location,
-			     struct btrfs_root **sub_root)
-{
-	struct btrfs_path *path;
-	struct btrfs_root_item *ri;
-
-	if (btrfs_key_type(location) != BTRFS_ROOT_ITEM_KEY)
-		return 0;
-	if (location->objectid == BTRFS_ROOT_TREE_OBJECTID)
-		return 0;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	mutex_lock(&root->fs_info->fs_mutex);
-
-	*sub_root = btrfs_read_fs_root(root->fs_info, location);
-	if (IS_ERR(*sub_root))
-		return PTR_ERR(*sub_root);
-
-	ri = &(*sub_root)->root_item;
-	location->objectid = btrfs_root_dirid(ri);
-	location->flags = 0;
-	btrfs_set_key_type(location, BTRFS_INODE_ITEM_KEY);
-	location->offset = 0;
-
-	btrfs_free_path(path);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	return 0;
-}
-
-static int btrfs_init_locked_inode(struct inode *inode, void *p)
-{
-	struct btrfs_iget_args *args = p;
-	inode->i_ino = args->ino;
-	BTRFS_I(inode)->root = args->root;
-	return 0;
-}
-
-static int btrfs_find_actor(struct inode *inode, void *opaque)
-{
-	struct btrfs_iget_args *args = opaque;
-	return (args->ino == inode->i_ino &&
-		args->root == BTRFS_I(inode)->root);
-}
-
-static struct inode *btrfs_iget_locked(struct super_block *s, u64 objectid,
-				       struct btrfs_root *root)
-{
-	struct inode *inode;
-	struct btrfs_iget_args args;
-	args.ino = objectid;
-	args.root = root;
-
-	inode = iget5_locked(s, objectid, btrfs_find_actor,
-			     btrfs_init_locked_inode,
-			     (void *)&args);
-	return inode;
-}
-
-static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
-				   struct nameidata *nd)
-{
-	struct inode * inode;
-	struct btrfs_inode *bi = BTRFS_I(dir);
-	struct btrfs_root *root = bi->root;
-	struct btrfs_root *sub_root = root;
-	struct btrfs_key location;
-	int ret;
-
-	if (dentry->d_name.len > BTRFS_NAME_LEN)
-		return ERR_PTR(-ENAMETOOLONG);
-	mutex_lock(&root->fs_info->fs_mutex);
-	ret = btrfs_inode_by_name(dir, dentry, &location);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	if (ret < 0)
-		return ERR_PTR(ret);
-	inode = NULL;
-	if (location.objectid) {
-		ret = fixup_tree_root_location(root, &location, &sub_root);
-		if (ret < 0)
-			return ERR_PTR(ret);
-		if (ret > 0)
-			return ERR_PTR(-ENOENT);
-		inode = btrfs_iget_locked(dir->i_sb, location.objectid,
-					  sub_root);
-		if (!inode)
-			return ERR_PTR(-EACCES);
-		if (inode->i_state & I_NEW) {
-			if (sub_root != root) {
-printk("adding new root for inode %lu root %p (found %p)\n", inode->i_ino, sub_root, BTRFS_I(inode)->root);
-				igrab(inode);
-				sub_root->inode = inode;
-			}
-			BTRFS_I(inode)->root = sub_root;
-			memcpy(&BTRFS_I(inode)->location, &location,
-			       sizeof(location));
-			btrfs_read_locked_inode(inode);
-			unlock_new_inode(inode);
-		}
-	}
-	return d_splice_alias(inode, dentry);
-}
-
-static void reada_leaves(struct btrfs_root *root, struct btrfs_path *path,
-			 u64 objectid)
-{
-	struct btrfs_node *node;
-	int i;
-	u32 nritems;
-	u64 item_objectid;
-	u64 blocknr;
-	int slot;
-	int ret;
-
-	if (!path->nodes[1])
-		return;
-	node = btrfs_buffer_node(path->nodes[1]);
-	slot = path->slots[1];
-	nritems = btrfs_header_nritems(&node->header);
-	for (i = slot + 1; i < nritems; i++) {
-		item_objectid = btrfs_disk_key_objectid(&node->ptrs[i].key);
-		if (item_objectid != objectid)
-			break;
-		blocknr = btrfs_node_blockptr(node, i);
-		ret = readahead_tree_block(root, blocknr);
-		if (ret)
-			break;
-	}
-}
-static unsigned char btrfs_filetype_table[] = {
-	DT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK
-};
-
-static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
-{
-	struct inode *inode = filp->f_path.dentry->d_inode;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct btrfs_item *item;
-	struct btrfs_dir_item *di;
-	struct btrfs_key key;
-	struct btrfs_path *path;
-	int ret;
-	u32 nritems;
-	struct btrfs_leaf *leaf;
-	int slot;
-	int advance;
-	unsigned char d_type;
-	int over = 0;
-	u32 di_cur;
-	u32 di_total;
-	u32 di_len;
-	int key_type = BTRFS_DIR_INDEX_KEY;
-
-	/* FIXME, use a real flag for deciding about the key type */
-	if (root->fs_info->tree_root == root)
-		key_type = BTRFS_DIR_ITEM_KEY;
-	mutex_lock(&root->fs_info->fs_mutex);
-	key.objectid = inode->i_ino;
-	key.flags = 0;
-	btrfs_set_key_type(&key, key_type);
-	key.offset = filp->f_pos;
-	path = btrfs_alloc_path();
-	btrfs_init_path(path);
-	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
-	if (ret < 0)
-		goto err;
-	advance = 0;
-	reada_leaves(root, path, inode->i_ino);
-	while(1) {
-		leaf = btrfs_buffer_leaf(path->nodes[0]);
-		nritems = btrfs_header_nritems(&leaf->header);
-		slot = path->slots[0];
-		if (advance || slot >= nritems) {
-			if (slot >= nritems -1) {
-				reada_leaves(root, path, inode->i_ino);
-				ret = btrfs_next_leaf(root, path);
-				if (ret)
-					break;
-				leaf = btrfs_buffer_leaf(path->nodes[0]);
-				nritems = btrfs_header_nritems(&leaf->header);
-				slot = path->slots[0];
-			} else {
-				slot++;
-				path->slots[0]++;
-			}
-		}
-		advance = 1;
-		item = leaf->items + slot;
-		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
-			break;
-		if (btrfs_disk_key_type(&item->key) != key_type)
-			break;
-		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)
-			continue;
-		filp->f_pos = btrfs_disk_key_offset(&item->key);
-		advance = 1;
-		di = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);
-		di_cur = 0;
-		di_total = btrfs_item_size(leaf->items + slot);
-		while(di_cur < di_total) {
-			d_type = btrfs_filetype_table[btrfs_dir_type(di)];
-			over = filldir(dirent, (const char *)(di + 1),
-				       btrfs_dir_name_len(di),
-				       btrfs_disk_key_offset(&item->key),
-				       btrfs_disk_key_objectid(&di->location),
-				       d_type);
-			if (over)
-				goto nopos;
-			di_len = btrfs_dir_name_len(di) + sizeof(*di);
-			di_cur += di_len;
-			di = (struct btrfs_dir_item *)((char *)di + di_len);
-		}
-	}
-	filp->f_pos++;
-nopos:
-	ret = 0;
-err:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	return ret;
-}
-
-static void btrfs_put_super (struct super_block * sb)
-{
-	struct btrfs_root *root = btrfs_sb(sb);
-	int ret;
-
-	ret = close_ctree(root);
-	if (ret) {
-		printk("close ctree returns %d\n", ret);
-	}
-	sb->s_fs_info = NULL;
-}
-
-static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
-{
-	struct inode * inode;
-	struct dentry * root_dentry;
-	struct btrfs_super_block *disk_super;
-	struct btrfs_root *tree_root;
-	struct btrfs_inode *bi;
-
-	sb->s_maxbytes = MAX_LFS_FILESIZE;
-	sb->s_magic = BTRFS_SUPER_MAGIC;
-	sb->s_op = &btrfs_super_ops;
-	sb->s_time_gran = 1;
-
-	tree_root = open_ctree(sb);
-
-	if (!tree_root) {
-		printk("btrfs: open_ctree failed\n");
-		return -EIO;
-	}
-	sb->s_fs_info = tree_root;
-	disk_super = tree_root->fs_info->disk_super;
-	printk("read in super total blocks %Lu root %Lu\n",
-	       btrfs_super_total_blocks(disk_super),
-	       btrfs_super_root_dir(disk_super));
-
-	inode = btrfs_iget_locked(sb, btrfs_super_root_dir(disk_super),
-				  tree_root);
-	bi = BTRFS_I(inode);
-	bi->location.objectid = inode->i_ino;
-	bi->location.offset = 0;
-	bi->location.flags = 0;
-	bi->root = tree_root;
-	btrfs_set_key_type(&bi->location, BTRFS_INODE_ITEM_KEY);
-
-	if (!inode)
-		return -ENOMEM;
-	if (inode->i_state & I_NEW) {
-		btrfs_read_locked_inode(inode);
-		unlock_new_inode(inode);
-	}
-
-	root_dentry = d_alloc_root(inode);
-	if (!root_dentry) {
-		iput(inode);
-		return -ENOMEM;
-	}
-	sb->s_root = root_dentry;
-	btrfs_transaction_queue_work(tree_root, HZ * 30);
-	return 0;
-}
-
-static int btrfs_write_inode(struct inode *inode, int wait)
-{
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct btrfs_trans_handle *trans;
-	int ret = 0;
-
-	if (wait) {
-		mutex_lock(&root->fs_info->fs_mutex);
-		trans = btrfs_start_transaction(root, 1);
-		btrfs_set_trans_block_group(trans, inode);
-		ret = btrfs_commit_transaction(trans, root);
-		mutex_unlock(&root->fs_info->fs_mutex);
-	}
-	return ret;
-}
-
-static void btrfs_dirty_inode(struct inode *inode)
-{
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct btrfs_trans_handle *trans;
-
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, inode);
-	btrfs_update_inode(trans, root, inode);
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	btrfs_btree_balance_dirty(root);
-}
-
-static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
-				     struct btrfs_root *root,
-				     u64 objectid,
-				     struct btrfs_block_group_cache *group,
-				     int mode)
-{
-	struct inode *inode;
-	struct btrfs_inode_item inode_item;
-	struct btrfs_key *location;
-	int ret;
-	int owner;
-
-	inode = new_inode(root->fs_info->sb);
-	if (!inode)
-		return ERR_PTR(-ENOMEM);
-
-	BTRFS_I(inode)->root = root;
-	if (mode & S_IFDIR)
-		owner = 0;
-	else
-		owner = 1;
-	group = btrfs_find_block_group(root, group, 0, 0, owner);
-	BTRFS_I(inode)->block_group = group;
-
-	inode->i_uid = current->fsuid;
-	inode->i_gid = current->fsgid;
-	inode->i_mode = mode;
-	inode->i_ino = objectid;
-	inode->i_blocks = 0;
-	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
-	fill_inode_item(&inode_item, inode);
-	location = &BTRFS_I(inode)->location;
-	location->objectid = objectid;
-	location->flags = 0;
-	location->offset = 0;
-	btrfs_set_key_type(location, BTRFS_INODE_ITEM_KEY);
-
-	ret = btrfs_insert_inode(trans, root, objectid, &inode_item);
-	BUG_ON(ret);
-
-	insert_inode_hash(inode);
-	return inode;
-}
-
-static inline u8 btrfs_inode_type(struct inode *inode)
-{
-	return btrfs_type_by_mode[(inode->i_mode & S_IFMT) >> S_SHIFT];
-}
-
-static int btrfs_add_link(struct btrfs_trans_handle *trans,
-			    struct dentry *dentry, struct inode *inode)
-{
-	int ret;
-	struct btrfs_key key;
-	struct btrfs_root *root = BTRFS_I(dentry->d_parent->d_inode)->root;
-	key.objectid = inode->i_ino;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
-	key.offset = 0;
-
-	ret = btrfs_insert_dir_item(trans, root,
-				    dentry->d_name.name, dentry->d_name.len,
-				    dentry->d_parent->d_inode->i_ino,
-				    &key, btrfs_inode_type(inode));
-	if (ret == 0) {
-		dentry->d_parent->d_inode->i_size += dentry->d_name.len * 2;
-		ret = btrfs_update_inode(trans, root,
-					 dentry->d_parent->d_inode);
-	}
-	return ret;
-}
-
-static int btrfs_add_nondir(struct btrfs_trans_handle *trans,
-			    struct dentry *dentry, struct inode *inode)
-{
-	int err = btrfs_add_link(trans, dentry, inode);
-	if (!err) {
-		d_instantiate(dentry, inode);
-		return 0;
-	}
-	if (err > 0)
-		err = -EEXIST;
-	return err;
-}
-
-static int btrfs_create(struct inode *dir, struct dentry *dentry,
-			int mode, struct nameidata *nd)
-{
-	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = BTRFS_I(dir)->root;
-	struct inode *inode;
-	int err;
-	int drop_inode = 0;
-	u64 objectid;
-
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, dir);
-
-	err = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
-	if (err) {
-		err = -ENOSPC;
-		goto out_unlock;
-	}
-
-	inode = btrfs_new_inode(trans, root, objectid,
-				BTRFS_I(dir)->block_group, mode);
-	err = PTR_ERR(inode);
-	if (IS_ERR(inode))
-		goto out_unlock;
-
-	btrfs_set_trans_block_group(trans, inode);
-	err = btrfs_add_nondir(trans, dentry, inode);
-	if (err)
-		drop_inode = 1;
-	else {
-		inode->i_mapping->a_ops = &btrfs_aops;
-		inode->i_fop = &btrfs_file_operations;
-		inode->i_op = &btrfs_file_inode_operations;
-	}
-	dir->i_sb->s_dirt = 1;
-	btrfs_update_inode_block_group(trans, inode);
-	btrfs_update_inode_block_group(trans, dir);
-out_unlock:
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-
-	if (drop_inode) {
-		inode_dec_link_count(inode);
-		iput(inode);
-	}
-	btrfs_btree_balance_dirty(root);
-	return err;
-}
-
-static int btrfs_link(struct dentry *old_dentry, struct inode *dir,
-		      struct dentry *dentry)
-{
-	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = BTRFS_I(dir)->root;
-	struct inode *inode = old_dentry->d_inode;
-	int err;
-	int drop_inode = 0;
-
-	if (inode->i_nlink == 0)
-		return -ENOENT;
-
-	inc_nlink(inode);
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, dir);
-	atomic_inc(&inode->i_count);
-	err = btrfs_add_nondir(trans, dentry, inode);
-	if (err)
-		drop_inode = 1;
-	dir->i_sb->s_dirt = 1;
-	btrfs_update_inode_block_group(trans, dir);
-	btrfs_update_inode(trans, root, inode);
-
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-
-	if (drop_inode) {
-		inode_dec_link_count(inode);
-		iput(inode);
-	}
-	btrfs_btree_balance_dirty(root);
-	return err;
-}
-
-static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
-				struct btrfs_root *root,
-				u64 objectid, u64 dirid)
-{
-	int ret;
-	char buf[2];
-	struct btrfs_key key;
-
-	buf[0] = '.';
-	buf[1] = '.';
-
-	key.objectid = objectid;
-	key.offset = 0;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
-
-	ret = btrfs_insert_dir_item(trans, root, buf, 1, objectid,
-				    &key, BTRFS_FT_DIR);
-	if (ret)
-		goto error;
-	key.objectid = dirid;
-	ret = btrfs_insert_dir_item(trans, root, buf, 2, objectid,
-				    &key, BTRFS_FT_DIR);
-	if (ret)
-		goto error;
-error:
-	return ret;
-}
-
-static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
-{
-	struct inode *inode;
-	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = BTRFS_I(dir)->root;
-	int err = 0;
-	int drop_on_err = 0;
-	u64 objectid;
-
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, dir);
-	if (IS_ERR(trans)) {
-		err = PTR_ERR(trans);
-		goto out_unlock;
-	}
-
-	err = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
-	if (err) {
-		err = -ENOSPC;
-		goto out_unlock;
-	}
-
-	inode = btrfs_new_inode(trans, root, objectid,
-				BTRFS_I(dir)->block_group, S_IFDIR | mode);
-	if (IS_ERR(inode)) {
-		err = PTR_ERR(inode);
-		goto out_fail;
-	}
-	drop_on_err = 1;
-	inode->i_op = &btrfs_dir_inode_operations;
-	inode->i_fop = &btrfs_dir_file_operations;
-	btrfs_set_trans_block_group(trans, inode);
-
-	err = btrfs_make_empty_dir(trans, root, inode->i_ino, dir->i_ino);
-	if (err)
-		goto out_fail;
-
-	inode->i_size = 6;
-	err = btrfs_update_inode(trans, root, inode);
-	if (err)
-		goto out_fail;
-	err = btrfs_add_link(trans, dentry, inode);
-	if (err)
-		goto out_fail;
-	d_instantiate(dentry, inode);
-	drop_on_err = 0;
-	dir->i_sb->s_dirt = 1;
-	btrfs_update_inode_block_group(trans, inode);
-	btrfs_update_inode_block_group(trans, dir);
-
-out_fail:
-	btrfs_end_transaction(trans, root);
-out_unlock:
-	mutex_unlock(&root->fs_info->fs_mutex);
-	if (drop_on_err)
-		iput(inode);
-	btrfs_btree_balance_dirty(root);
-	return err;
-}
-
-static int btrfs_sync_file(struct file *file,
-			   struct dentry *dentry, int datasync)
-{
-	struct inode *inode = dentry->d_inode;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	int ret;
-	struct btrfs_trans_handle *trans;
-
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	if (!trans) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	ret = btrfs_commit_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-out:
-	return ret > 0 ? EIO : ret;
-}
-
-static int btrfs_sync_fs(struct super_block *sb, int wait)
-{
-	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root;
-	int ret;
-	root = btrfs_sb(sb);
-
-	sb->s_dirt = 0;
-	if (!wait) {
-		filemap_flush(root->fs_info->btree_inode->i_mapping);
-		return 0;
-	}
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	ret = btrfs_commit_transaction(trans, root);
-	sb->s_dirt = 0;
-	BUG_ON(ret);
-printk("btrfs sync_fs\n");
-	mutex_unlock(&root->fs_info->fs_mutex);
-	return 0;
-}
-
-#define BTRFS_GET_BLOCK_NO_CREATE 0
-#define BTRFS_GET_BLOCK_CREATE 1
-#define BTRFS_GET_BLOCK_NO_DIRECT 2
-
-static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
-			   struct buffer_head *result, int create)
-{
-	int ret;
-	int err = 0;
-	u64 blocknr;
-	u64 extent_start = 0;
-	u64 extent_end = 0;
-	u64 objectid = inode->i_ino;
-	u32 found_type;
-	u64 alloc_hint = 0;
-	struct btrfs_path *path;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct btrfs_file_extent_item *item;
-	struct btrfs_leaf *leaf;
-	struct btrfs_disk_key *found_key;
-	struct btrfs_trans_handle *trans = NULL;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	if (create & BTRFS_GET_BLOCK_CREATE) {
-		WARN_ON(1);
-		/* this almost but not quite works */
-		trans = btrfs_start_transaction(root, 1);
-		if (!trans) {
-			err = -ENOMEM;
-			goto out;
-		}
-		ret = drop_extents(trans, root, inode,
-				   iblock << inode->i_blkbits,
-				   (iblock + 1) << inode->i_blkbits,
-				   &alloc_hint);
-		BUG_ON(ret);
-	}
-
-	ret = btrfs_lookup_file_extent(NULL, root, path,
-				       inode->i_ino,
-				       iblock << inode->i_blkbits, 0);
-	if (ret < 0) {
-		err = ret;
-		goto out;
-	}
-
-	if (ret != 0) {
-		if (path->slots[0] == 0) {
-			btrfs_release_path(root, path);
-			goto not_found;
-		}
-		path->slots[0]--;
-	}
-
-	item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
-			      struct btrfs_file_extent_item);
-	leaf = btrfs_buffer_leaf(path->nodes[0]);
-	blocknr = btrfs_file_extent_disk_blocknr(item);
-	blocknr += btrfs_file_extent_offset(item);
-
-	/* are we inside the extent that was found? */
-	found_key = &leaf->items[path->slots[0]].key;
-	found_type = btrfs_disk_key_type(found_key);
-	if (btrfs_disk_key_objectid(found_key) != objectid ||
-	    found_type != BTRFS_EXTENT_DATA_KEY) {
-		extent_end = 0;
-		extent_start = 0;
-		goto not_found;
-	}
-	found_type = btrfs_file_extent_type(item);
-	extent_start = btrfs_disk_key_offset(&leaf->items[path->slots[0]].key);
-	if (found_type == BTRFS_FILE_EXTENT_REG) {
-		extent_start = extent_start >> inode->i_blkbits;
-		extent_end = extent_start + btrfs_file_extent_num_blocks(item);
-		err = 0;
-		if (btrfs_file_extent_disk_blocknr(item) == 0)
-			goto out;
-		if (iblock >= extent_start && iblock < extent_end) {
-			btrfs_map_bh_to_logical(root, result, blocknr +
-						iblock - extent_start);
-			goto out;
-		}
-	} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {
-		char *ptr;
-		char *map;
-		u32 size;
-
-		if (create & BTRFS_GET_BLOCK_NO_DIRECT) {
-			err = -EINVAL;
-			goto out;
-		}
-		size = btrfs_file_extent_inline_len(leaf->items +
-						    path->slots[0]);
-		extent_end = (extent_start + size) >> inode->i_blkbits;
-		extent_start >>= inode->i_blkbits;
-		if (iblock < extent_start || iblock > extent_end) {
-			goto not_found;
-		}
-		ptr = btrfs_file_extent_inline_start(item);
-		map = kmap(result->b_page);
-		memcpy(map, ptr, size);
-		memset(map + size, 0, PAGE_CACHE_SIZE - size);
-		flush_dcache_page(result->b_page);
-		kunmap(result->b_page);
-		set_buffer_uptodate(result);
-		SetPageChecked(result->b_page);
-		btrfs_map_bh_to_logical(root, result, 0);
-	}
-not_found:
-	if (create & BTRFS_GET_BLOCK_CREATE) {
-		struct btrfs_key ins;
-		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
-					 1, alloc_hint, (u64)-1,
-					 &ins, 1);
-		BUG_ON(ret);
-		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
-					       iblock << inode->i_blkbits,
-					       ins.objectid, ins.offset,
-					       ins.offset);
-		BUG_ON(ret);
-		SetPageChecked(result->b_page);
-		btrfs_map_bh_to_logical(root, result, ins.objectid);
-	}
-out:
-	if (trans)
-		err = btrfs_end_transaction(trans, root);
-	btrfs_free_path(path);
-	return err;
-}
-
-static int btrfs_get_block(struct inode *inode, sector_t iblock,
-			   struct buffer_head *result, int create)
-{
-	int err;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	mutex_lock(&root->fs_info->fs_mutex);
-	err = btrfs_get_block_lock(inode, iblock, result, create);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	return err;
-}
-
-static int btrfs_get_block_bmap(struct inode *inode, sector_t iblock,
-			   struct buffer_head *result, int create)
-{
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	mutex_lock(&root->fs_info->fs_mutex);
-	btrfs_get_block_lock(inode, iblock, result, BTRFS_GET_BLOCK_NO_DIRECT);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	return 0;
-}
-
-static sector_t btrfs_bmap(struct address_space *as, sector_t block)
-{
-	return generic_block_bmap(as, block, btrfs_get_block_bmap);
-}
-
-static int btrfs_prepare_write(struct file *file, struct page *page,
-			       unsigned from, unsigned to)
-{
-	return block_prepare_write(page, from, to, btrfs_get_block);
-}
-
-static void btrfs_write_super(struct super_block *sb)
-{
-	sb->s_dirt = 0;
-}
-
-static int btrfs_readpage(struct file *file, struct page *page)
-{
-	return mpage_readpage(page, btrfs_get_block);
-}
-
-/*
- * While block_write_full_page is writing back the dirty buffers under
- * the page lock, whoever dirtied the buffers may decide to clean them
- * again at any time.  We handle that by only looking at the buffer
- * state inside lock_buffer().
- *
- * If block_write_full_page() is called for regular writeback
- * (wbc->sync_mode == WB_SYNC_NONE) then it will redirty a page which has a
- * locked buffer.   This only can happen if someone has written the buffer
- * directly, with submit_bh().  At the address_space level PageWriteback
- * prevents this contention from occurring.
- */
-static int __btrfs_write_full_page(struct inode *inode, struct page *page,
-				   struct writeback_control *wbc)
-{
-	int err;
-	sector_t block;
-	sector_t last_block;
-	struct buffer_head *bh, *head;
-	const unsigned blocksize = 1 << inode->i_blkbits;
-	int nr_underway = 0;
-
-	BUG_ON(!PageLocked(page));
-
-	last_block = (i_size_read(inode) - 1) >> inode->i_blkbits;
-
-	if (!page_has_buffers(page)) {
-		create_empty_buffers(page, blocksize,
-					(1 << BH_Dirty)|(1 << BH_Uptodate));
-	}
-
-	/*
-	 * Be very careful.  We have no exclusion from __set_page_dirty_buffers
-	 * here, and the (potentially unmapped) buffers may become dirty at
-	 * any time.  If a buffer becomes dirty here after we've inspected it
-	 * then we just miss that fact, and the page stays dirty.
-	 *
-	 * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;
-	 * handle that here by just cleaning them.
-	 */
-
-	block = (sector_t)page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
-	head = page_buffers(page);
-	bh = head;
-
-	/*
-	 * Get all the dirty buffers mapped to disk addresses and
-	 * handle any aliases from the underlying blockdev's mapping.
-	 */
-	do {
-		if (block > last_block) {
-			/*
-			 * mapped buffers outside i_size will occur, because
-			 * this page can be outside i_size when there is a
-			 * truncate in progress.
-			 */
-			/*
-			 * The buffer was zeroed by block_write_full_page()
-			 */
-			clear_buffer_dirty(bh);
-			set_buffer_uptodate(bh);
-		} else if (!buffer_mapped(bh) && buffer_dirty(bh)) {
-			WARN_ON(bh->b_size != blocksize);
-			err = btrfs_get_block(inode, block, bh, 0);
-			if (err) {
-printk("writepage going to recovery err %d\n", err);
-				goto recover;
-			}
-			if (buffer_new(bh)) {
-				/* blockdev mappings never come here */
-				clear_buffer_new(bh);
-			}
-		}
-		bh = bh->b_this_page;
-		block++;
-	} while (bh != head);
-
-	do {
-		if (!buffer_mapped(bh))
-			continue;
-		/*
-		 * If it's a fully non-blocking write attempt and we cannot
-		 * lock the buffer then redirty the page.  Note that this can
-		 * potentially cause a busy-wait loop from pdflush and kswapd
-		 * activity, but those code paths have their own higher-level
-		 * throttling.
-		 */
-		if (wbc->sync_mode != WB_SYNC_NONE || !wbc->nonblocking) {
-			lock_buffer(bh);
-		} else if (test_set_buffer_locked(bh)) {
-			redirty_page_for_writepage(wbc, page);
-			continue;
-		}
-		if (test_clear_buffer_dirty(bh) && bh->b_blocknr != 0) {
-			mark_buffer_async_write(bh);
-		} else {
-			unlock_buffer(bh);
-		}
-	} while ((bh = bh->b_this_page) != head);
-
-	/*
-	 * The page and its buffers are protected by PageWriteback(), so we can
-	 * drop the bh refcounts early.
-	 */
-	BUG_ON(PageWriteback(page));
-	set_page_writeback(page);
-
-	do {
-		struct buffer_head *next = bh->b_this_page;
-		if (buffer_async_write(bh)) {
-			submit_bh(WRITE, bh);
-			nr_underway++;
-		}
-		bh = next;
-	} while (bh != head);
-	unlock_page(page);
-
-	err = 0;
-done:
-	if (nr_underway == 0) {
-		/*
-		 * The page was marked dirty, but the buffers were
-		 * clean.  Someone wrote them back by hand with
-		 * ll_rw_block/submit_bh.  A rare case.
-		 */
-		int uptodate = 1;
-		do {
-			if (!buffer_uptodate(bh)) {
-				uptodate = 0;
-				break;
-			}
-			bh = bh->b_this_page;
-		} while (bh != head);
-		if (uptodate)
-			SetPageUptodate(page);
-		end_page_writeback(page);
-	}
-	return err;
-
-recover:
-	/*
-	 * ENOSPC, or some other error.  We may already have added some
-	 * blocks to the file, so we need to write these out to avoid
-	 * exposing stale data.
-	 * The page is currently locked and not marked for writeback
-	 */
-	bh = head;
-	/* Recovery: lock and submit the mapped buffers */
-	do {
-		if (buffer_mapped(bh) && buffer_dirty(bh)) {
-			lock_buffer(bh);
-			mark_buffer_async_write(bh);
-		} else {
-			/*
-			 * The buffer may have been set dirty during
-			 * attachment to a dirty page.
-			 */
-			clear_buffer_dirty(bh);
-		}
-	} while ((bh = bh->b_this_page) != head);
-	SetPageError(page);
-	BUG_ON(PageWriteback(page));
-	set_page_writeback(page);
-	do {
-		struct buffer_head *next = bh->b_this_page;
-		if (buffer_async_write(bh)) {
-			clear_buffer_dirty(bh);
-			submit_bh(WRITE, bh);
-			nr_underway++;
-		}
-		bh = next;
-	} while (bh != head);
-	unlock_page(page);
-	goto done;
-}
-
-/*
- * The generic ->writepage function for buffer-backed address_spaces
- */
-static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
-{
-	struct inode * const inode = page->mapping->host;
-	loff_t i_size = i_size_read(inode);
-	const pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;
-	unsigned offset;
-	void *kaddr;
-
-	/* Is the page fully inside i_size? */
-	if (page->index < end_index)
-		return __btrfs_write_full_page(inode, page, wbc);
-
-	/* Is the page fully outside i_size? (truncate in progress) */
-	offset = i_size & (PAGE_CACHE_SIZE-1);
-	if (page->index >= end_index+1 || !offset) {
-		/*
-		 * The page may have dirty, unmapped buffers.  For example,
-		 * they may have been added in ext3_writepage().  Make them
-		 * freeable here, so the page does not leak.
-		 */
-		block_invalidatepage(page, 0);
-		unlock_page(page);
-		return 0; /* don't care */
-	}
-
-	/*
-	 * The page straddles i_size.  It must be zeroed out on each and every
-	 * writepage invokation because it may be mmapped.  "A file is mapped
-	 * in multiples of the page size.  For a file that is not a multiple of
-	 * the  page size, the remaining memory is zeroed when mapped, and
-	 * writes to that region are not written out to the file."
-	 */
-	kaddr = kmap_atomic(page, KM_USER0);
-	memset(kaddr + offset, 0, PAGE_CACHE_SIZE - offset);
-	flush_dcache_page(page);
-	kunmap_atomic(kaddr, KM_USER0);
-	return __btrfs_write_full_page(inode, page, wbc);
-}
-
-static void btrfs_truncate(struct inode *inode)
-{
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	int ret;
-	struct btrfs_trans_handle *trans;
-
-	if (!S_ISREG(inode->i_mode))
-		return;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return;
-
-	btrfs_truncate_page(inode->i_mapping, inode->i_size);
-
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, inode);
-
-	/* FIXME, add redo link to tree so we don't leak on crash */
-	ret = btrfs_truncate_in_trans(trans, root, inode);
-	BUG_ON(ret);
-	btrfs_update_inode(trans, root, inode);
-	ret = btrfs_end_transaction(trans, root);
-	BUG_ON(ret);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	btrfs_btree_balance_dirty(root);
-}
-
-static int btrfs_commit_write(struct file *file, struct page *page,
-			      unsigned from, unsigned to)
-{
-	struct inode *inode = page->mapping->host;
-	struct buffer_head *bh;
-	loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
-
-	SetPageUptodate(page);
-	bh = page_buffers(page);
-	set_buffer_uptodate(bh);
-	if (buffer_mapped(bh) && bh->b_blocknr != 0) {
-		set_page_dirty(page);
-	}
-	if (pos > inode->i_size) {
-		i_size_write(inode, pos);
-		mark_inode_dirty(inode);
-	}
-	return 0;
-}
-
-static int btrfs_copy_from_user(loff_t pos, int num_pages, int write_bytes,
-				struct page **prepared_pages,
-				const char __user * buf)
-{
-	long page_fault = 0;
-	int i;
-	int offset = pos & (PAGE_CACHE_SIZE - 1);
-
-	for (i = 0; i < num_pages && write_bytes > 0; i++, offset = 0) {
-		size_t count = min_t(size_t,
-				     PAGE_CACHE_SIZE - offset, write_bytes);
-		struct page *page = prepared_pages[i];
-		fault_in_pages_readable(buf, count);
-
-		/* Copy data from userspace to the current page */
-		kmap(page);
-		page_fault = __copy_from_user(page_address(page) + offset,
-					      buf, count);
-		/* Flush processor's dcache for this page */
-		flush_dcache_page(page);
-		kunmap(page);
-		buf += count;
-		write_bytes -= count;
-
-		if (page_fault)
-			break;
-	}
-	return page_fault ? -EFAULT : 0;
-}
-
-static void btrfs_drop_pages(struct page **pages, size_t num_pages)
-{
-	size_t i;
-	for (i = 0; i < num_pages; i++) {
-		if (!pages[i])
-			break;
-		unlock_page(pages[i]);
-		mark_page_accessed(pages[i]);
-		page_cache_release(pages[i]);
-	}
-}
-static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
-				   struct btrfs_root *root,
-				   struct file *file,
-				   struct page **pages,
-				   size_t num_pages,
-				   loff_t pos,
-				   size_t write_bytes)
-{
-	int i;
-	int offset;
-	int err = 0;
-	int ret;
-	int this_write;
-	struct inode *inode = file->f_path.dentry->d_inode;
-	struct buffer_head *bh;
-	struct btrfs_file_extent_item *ei;
-
-	for (i = 0; i < num_pages; i++) {
-		offset = pos & (PAGE_CACHE_SIZE -1);
-		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
-		/* FIXME, one block at a time */
-
-		mutex_lock(&root->fs_info->fs_mutex);
-		trans = btrfs_start_transaction(root, 1);
-		btrfs_set_trans_block_group(trans, inode);
-
-		bh = page_buffers(pages[i]);
-		if (buffer_mapped(bh) && bh->b_blocknr == 0) {
-			struct btrfs_key key;
-			struct btrfs_path *path;
-			char *ptr;
-			u32 datasize;
-
-			path = btrfs_alloc_path();
-			BUG_ON(!path);
-			key.objectid = inode->i_ino;
-			key.offset = pages[i]->index << PAGE_CACHE_SHIFT;
-			key.flags = 0;
-			btrfs_set_key_type(&key, BTRFS_EXTENT_DATA_KEY);
-			BUG_ON(write_bytes >= PAGE_CACHE_SIZE);
-			datasize = offset +
-				btrfs_file_extent_calc_inline_size(write_bytes);
-			ret = btrfs_insert_empty_item(trans, root, path, &key,
-						      datasize);
-			BUG_ON(ret);
-			ei = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-			       path->slots[0], struct btrfs_file_extent_item);
-			btrfs_set_file_extent_generation(ei, trans->transid);
-			btrfs_set_file_extent_type(ei,
-						   BTRFS_FILE_EXTENT_INLINE);
-			ptr = btrfs_file_extent_inline_start(ei);
-			btrfs_memcpy(root, path->nodes[0]->b_data,
-				     ptr, bh->b_data, offset + write_bytes);
-			mark_buffer_dirty(path->nodes[0]);
-			btrfs_free_path(path);
-		} else if (buffer_mapped(bh)) {
-			btrfs_csum_file_block(trans, root, inode->i_ino,
-				      pages[i]->index << PAGE_CACHE_SHIFT,
-				      kmap(pages[i]), PAGE_CACHE_SIZE);
-			kunmap(pages[i]);
-		}
-		SetPageChecked(pages[i]);
-		// btrfs_update_inode_block_group(trans, inode);
-		ret = btrfs_end_transaction(trans, root);
-		BUG_ON(ret);
-		mutex_unlock(&root->fs_info->fs_mutex);
+#define BTRFS_SUPER_MAGIC 0x9123682E
 
-		ret = btrfs_commit_write(file, pages[i], offset,
-					 offset + this_write);
-		pos += this_write;
-		if (ret) {
-			err = ret;
-			goto failed;
-		}
-		WARN_ON(this_write > write_bytes);
-		write_bytes -= this_write;
-	}
-failed:
-	return err;
-}
+static struct super_operations btrfs_super_ops;
 
-static int drop_extents(struct btrfs_trans_handle *trans,
-			  struct btrfs_root *root,
-			  struct inode *inode,
-			  u64 start, u64 end, u64 *hint_block)
+static void btrfs_put_super (struct super_block * sb)
 {
+	struct btrfs_root *root = btrfs_sb(sb);
 	int ret;
-	struct btrfs_key key;
-	struct btrfs_leaf *leaf;
-	int slot;
-	struct btrfs_file_extent_item *extent;
-	u64 extent_end = 0;
-	int keep;
-	struct btrfs_file_extent_item old;
-	struct btrfs_path *path;
-	u64 search_start = start;
-	int bookend;
-	int found_type;
-	int found_extent;
-	int found_inline;
-
-	path = btrfs_alloc_path();
-	if (!path)
-		return -ENOMEM;
-	while(1) {
-		btrfs_release_path(root, path);
-		ret = btrfs_lookup_file_extent(trans, root, path, inode->i_ino,
-					       search_start, -1);
-		if (ret < 0)
-			goto out;
-		if (ret > 0) {
-			if (path->slots[0] == 0) {
-				ret = 0;
-				goto out;
-			}
-			path->slots[0]--;
-		}
-		keep = 0;
-		bookend = 0;
-		found_extent = 0;
-		found_inline = 0;
-		extent = NULL;
-		leaf = btrfs_buffer_leaf(path->nodes[0]);
-		slot = path->slots[0];
-		btrfs_disk_key_to_cpu(&key, &leaf->items[slot].key);
-		if (key.offset >= end || key.objectid != inode->i_ino) {
-			ret = 0;
-			goto out;
-		}
-		if (btrfs_key_type(&key) != BTRFS_EXTENT_DATA_KEY) {
-			ret = 0;
-			goto out;
-		}
-		extent = btrfs_item_ptr(leaf, slot,
-					struct btrfs_file_extent_item);
-		found_type = btrfs_file_extent_type(extent);
-		if (found_type == BTRFS_FILE_EXTENT_REG) {
-			extent_end = key.offset +
-				(btrfs_file_extent_num_blocks(extent) <<
-				 inode->i_blkbits);
-			found_extent = 1;
-		} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {
-			found_inline = 1;
-			extent_end = key.offset +
-			     btrfs_file_extent_inline_len(leaf->items + slot);
-		}
-
-		if (!found_extent && !found_inline) {
-			ret = 0;
-			goto out;
-		}
-
-		if (search_start >= extent_end) {
-			ret = 0;
-			goto out;
-		}
-
-		if (found_inline) {
-			u64 mask = root->blocksize - 1;
-			search_start = (extent_end + mask) & ~mask;
-		} else
-			search_start = extent_end;
 
-		if (end < extent_end && end >= key.offset) {
-			if (found_extent) {
-				u64 disk_blocknr =
-					btrfs_file_extent_disk_blocknr(extent);
-				u64 disk_num_blocks =
-				      btrfs_file_extent_disk_num_blocks(extent);
-				memcpy(&old, extent, sizeof(old));
-				if (disk_blocknr != 0) {
-					ret = btrfs_inc_extent_ref(trans, root,
-					         disk_blocknr, disk_num_blocks);
-					BUG_ON(ret);
-				}
-			}
-			WARN_ON(found_inline);
-			bookend = 1;
-		}
-
-		if (start > key.offset) {
-			u64 new_num;
-			u64 old_num;
-			/* truncate existing extent */
-			keep = 1;
-			WARN_ON(start & (root->blocksize - 1));
-			if (found_extent) {
-				new_num = (start - key.offset) >>
-					inode->i_blkbits;
-				old_num = btrfs_file_extent_num_blocks(extent);
-				*hint_block =
-					btrfs_file_extent_disk_blocknr(extent);
-				if (btrfs_file_extent_disk_blocknr(extent)) {
-					inode->i_blocks -=
-						(old_num - new_num) << 3;
-				}
-				btrfs_set_file_extent_num_blocks(extent,
-								 new_num);
-				mark_buffer_dirty(path->nodes[0]);
-			} else {
-				WARN_ON(1);
-			}
-		}
-		if (!keep) {
-			u64 disk_blocknr = 0;
-			u64 disk_num_blocks = 0;
-			u64 extent_num_blocks = 0;
-			if (found_extent) {
-				disk_blocknr =
-				      btrfs_file_extent_disk_blocknr(extent);
-				disk_num_blocks =
-				      btrfs_file_extent_disk_num_blocks(extent);
-				extent_num_blocks =
-				      btrfs_file_extent_num_blocks(extent);
-				*hint_block =
-					btrfs_file_extent_disk_blocknr(extent);
-			}
-			ret = btrfs_del_item(trans, root, path);
-			BUG_ON(ret);
-			btrfs_release_path(root, path);
-			extent = NULL;
-			if (found_extent && disk_blocknr != 0) {
-				inode->i_blocks -= extent_num_blocks << 3;
-				ret = btrfs_free_extent(trans, root,
-							disk_blocknr,
-							disk_num_blocks, 0);
-			}
-
-			BUG_ON(ret);
-			if (!bookend && search_start >= end) {
-				ret = 0;
-				goto out;
-			}
-			if (!bookend)
-				continue;
-		}
-		if (bookend && found_extent) {
-			/* create bookend */
-			struct btrfs_key ins;
-			ins.objectid = inode->i_ino;
-			ins.offset = end;
-			ins.flags = 0;
-			btrfs_set_key_type(&ins, BTRFS_EXTENT_DATA_KEY);
-
-			btrfs_release_path(root, path);
-			ret = btrfs_insert_empty_item(trans, root, path, &ins,
-						      sizeof(*extent));
-			BUG_ON(ret);
-			extent = btrfs_item_ptr(
-				    btrfs_buffer_leaf(path->nodes[0]),
-				    path->slots[0],
-				    struct btrfs_file_extent_item);
-			btrfs_set_file_extent_disk_blocknr(extent,
-				    btrfs_file_extent_disk_blocknr(&old));
-			btrfs_set_file_extent_disk_num_blocks(extent,
-				    btrfs_file_extent_disk_num_blocks(&old));
-
-			btrfs_set_file_extent_offset(extent,
-				    btrfs_file_extent_offset(&old) +
-				    ((end - key.offset) >> inode->i_blkbits));
-			WARN_ON(btrfs_file_extent_num_blocks(&old) <
-				(extent_end - end) >> inode->i_blkbits);
-			btrfs_set_file_extent_num_blocks(extent,
-				    (extent_end - end) >> inode->i_blkbits);
-
-			btrfs_set_file_extent_type(extent,
-						   BTRFS_FILE_EXTENT_REG);
-			btrfs_set_file_extent_generation(extent,
-				    btrfs_file_extent_generation(&old));
-			btrfs_mark_buffer_dirty(path->nodes[0]);
-			if (btrfs_file_extent_disk_blocknr(&old) != 0) {
-				inode->i_blocks +=
-				      btrfs_file_extent_num_blocks(extent) << 3;
-			}
-			ret = 0;
-			goto out;
-		}
-	}
-out:
-	btrfs_free_path(path);
-	return ret;
-}
-
-static int prepare_pages(struct btrfs_root *root,
-			 struct file *file,
-			 struct page **pages,
-			 size_t num_pages,
-			 loff_t pos,
-			 unsigned long first_index,
-			 unsigned long last_index,
-			 size_t write_bytes,
-			 u64 alloc_extent_start)
-{
-	int i;
-	unsigned long index = pos >> PAGE_CACHE_SHIFT;
-	struct inode *inode = file->f_path.dentry->d_inode;
-	int offset;
-	int err = 0;
-	int this_write;
-	struct buffer_head *bh;
-	struct buffer_head *head;
-	loff_t isize = i_size_read(inode);
-
-	memset(pages, 0, num_pages * sizeof(struct page *));
-
-	for (i = 0; i < num_pages; i++) {
-		pages[i] = grab_cache_page(inode->i_mapping, index + i);
-		if (!pages[i]) {
-			err = -ENOMEM;
-			goto failed_release;
-		}
-		cancel_dirty_page(pages[i], PAGE_CACHE_SIZE);
-		wait_on_page_writeback(pages[i]);
-		offset = pos & (PAGE_CACHE_SIZE -1);
-		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
-		if (!page_has_buffers(pages[i])) {
-			create_empty_buffers(pages[i],
-					     root->fs_info->sb->s_blocksize,
-					     (1 << BH_Uptodate));
-		}
-		head = page_buffers(pages[i]);
-		bh = head;
-		do {
-			err = btrfs_map_bh_to_logical(root, bh,
-						      alloc_extent_start);
-			BUG_ON(err);
-			if (err)
-				goto failed_truncate;
-			bh = bh->b_this_page;
-			if (alloc_extent_start)
-				alloc_extent_start++;
-		} while (bh != head);
-		pos += this_write;
-		WARN_ON(this_write > write_bytes);
-		write_bytes -= this_write;
+	ret = close_ctree(root);
+	if (ret) {
+		printk("close ctree returns %d\n", ret);
 	}
-	return 0;
-
-failed_release:
-	btrfs_drop_pages(pages, num_pages);
-	return err;
-
-failed_truncate:
-	btrfs_drop_pages(pages, num_pages);
-	if (pos > isize)
-		vmtruncate(inode, isize);
-	return err;
+	sb->s_fs_info = NULL;
 }
 
-static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
-				size_t count, loff_t *ppos)
+static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 {
-	loff_t pos;
-	size_t num_written = 0;
-	int err = 0;
-	int ret = 0;
-	struct inode *inode = file->f_path.dentry->d_inode;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct page *pages[8];
-	struct page *pinned[2];
-	unsigned long first_index;
-	unsigned long last_index;
-	u64 start_pos;
-	u64 num_blocks;
-	u64 alloc_extent_start;
-	u64 hint_block;
-	struct btrfs_trans_handle *trans;
-	struct btrfs_key ins;
-	pinned[0] = NULL;
-	pinned[1] = NULL;
-	if (file->f_flags & O_DIRECT)
-		return -EINVAL;
-	pos = *ppos;
-	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
-	current->backing_dev_info = inode->i_mapping->backing_dev_info;
-	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
-	if (err)
-		goto out;
-	if (count == 0)
-		goto out;
-	err = remove_suid(file->f_path.dentry);
-	if (err)
-		goto out;
-	file_update_time(file);
+	struct inode * inode;
+	struct dentry * root_dentry;
+	struct btrfs_super_block *disk_super;
+	struct btrfs_root *tree_root;
+	struct btrfs_inode *bi;
+	int err;
 
-	start_pos = pos & ~((u64)PAGE_CACHE_SIZE - 1);
-	num_blocks = (count + pos - start_pos + root->blocksize - 1) >>
-			inode->i_blkbits;
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+	sb->s_magic = BTRFS_SUPER_MAGIC;
+	sb->s_op = &btrfs_super_ops;
+	sb->s_time_gran = 1;
 
-	mutex_lock(&inode->i_mutex);
-	first_index = pos >> PAGE_CACHE_SHIFT;
-	last_index = (pos + count) >> PAGE_CACHE_SHIFT;
+	tree_root = open_ctree(sb);
 
-	if ((pos & (PAGE_CACHE_SIZE - 1))) {
-		pinned[0] = grab_cache_page(inode->i_mapping, first_index);
-		if (!PageUptodate(pinned[0])) {
-			ret = mpage_readpage(pinned[0], btrfs_get_block);
-			BUG_ON(ret);
-			wait_on_page_locked(pinned[0]);
-		} else {
-			unlock_page(pinned[0]);
-		}
-	}
-	if ((pos + count) & (PAGE_CACHE_SIZE - 1)) {
-		pinned[1] = grab_cache_page(inode->i_mapping, last_index);
-		if (!PageUptodate(pinned[1])) {
-			ret = mpage_readpage(pinned[1], btrfs_get_block);
-			BUG_ON(ret);
-			wait_on_page_locked(pinned[1]);
-		} else {
-			unlock_page(pinned[1]);
-		}
+	if (!tree_root || IS_ERR(tree_root)) {
+		printk("btrfs: open_ctree failed\n");
+		return -EIO;
 	}
+	sb->s_fs_info = tree_root;
+	disk_super = tree_root->fs_info->disk_super;
+	inode = btrfs_iget_locked(sb, btrfs_super_root_dir(disk_super),
+				  tree_root);
+	bi = BTRFS_I(inode);
+	bi->location.objectid = inode->i_ino;
+	bi->location.offset = 0;
+	bi->location.flags = 0;
+	bi->root = tree_root;
+	btrfs_set_key_type(&bi->location, BTRFS_INODE_ITEM_KEY);
 
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	if (!trans) {
+	if (!inode) {
 		err = -ENOMEM;
-		mutex_unlock(&root->fs_info->fs_mutex);
-		goto out_unlock;
-	}
-	btrfs_set_trans_block_group(trans, inode);
-	/* FIXME blocksize != 4096 */
-	inode->i_blocks += num_blocks << 3;
-	hint_block = 0;
-	if (start_pos < inode->i_size) {
-		/* FIXME blocksize != pagesize */
-		ret = drop_extents(trans, root, inode,
-				   start_pos,
-				   (pos + count + root->blocksize -1) &
-				   ~((u64)root->blocksize - 1), &hint_block);
-		BUG_ON(ret);
-	}
-	if (inode->i_size < start_pos) {
-		u64 last_pos_in_file;
-		u64 hole_size;
-		u64 mask = root->blocksize - 1;
-		last_pos_in_file = (inode->i_size + mask) & ~mask;
-		hole_size = (start_pos - last_pos_in_file + mask) & ~mask;
-		hole_size >>= inode->i_blkbits;
-		if (last_pos_in_file < start_pos) {
-			ret = btrfs_insert_file_extent(trans, root,
-						       inode->i_ino,
-						       last_pos_in_file,
-						       0, 0, hole_size);
-		}
-		BUG_ON(ret);
-	}
-	if (inode->i_size >= PAGE_CACHE_SIZE || pos + count < inode->i_size ||
-	    pos + count - start_pos > BTRFS_MAX_INLINE_DATA_SIZE(root)) {
-		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
-					 num_blocks, hint_block, (u64)-1,
-					 &ins, 1);
-		BUG_ON(ret);
-		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
-				       start_pos, ins.objectid, ins.offset,
-				       ins.offset);
-		BUG_ON(ret);
-	} else {
-		ins.offset = 0;
-		ins.objectid = 0;
-	}
-	BUG_ON(ret);
-	alloc_extent_start = ins.objectid;
-	// btrfs_update_inode_block_group(trans, inode);
-	ret = btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-
-	while(count > 0) {
-		size_t offset = pos & (PAGE_CACHE_SIZE - 1);
-		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
-		size_t num_pages = (write_bytes + PAGE_CACHE_SIZE - 1) >>
-					PAGE_CACHE_SHIFT;
-
-		memset(pages, 0, sizeof(pages));
-		ret = prepare_pages(root, file, pages, num_pages,
-				    pos, first_index, last_index,
-				    write_bytes, alloc_extent_start);
-		BUG_ON(ret);
-
-		/* FIXME blocks != pagesize */
-		if (alloc_extent_start)
-			alloc_extent_start += num_pages;
-		ret = btrfs_copy_from_user(pos, num_pages,
-					   write_bytes, pages, buf);
-		BUG_ON(ret);
-
-		ret = dirty_and_release_pages(NULL, root, file, pages,
-					      num_pages, pos, write_bytes);
-		BUG_ON(ret);
-		btrfs_drop_pages(pages, num_pages);
-
-		buf += write_bytes;
-		count -= write_bytes;
-		pos += write_bytes;
-		num_written += write_bytes;
-
-		balance_dirty_pages_ratelimited(inode->i_mapping);
-		btrfs_btree_balance_dirty(root);
-		cond_resched();
-	}
-out_unlock:
-	mutex_unlock(&inode->i_mutex);
-out:
-	if (pinned[0])
-		page_cache_release(pinned[0]);
-	if (pinned[1])
-		page_cache_release(pinned[1]);
-	*ppos = pos;
-	current->backing_dev_info = NULL;
-	mark_inode_dirty(inode);
-	return num_written ? num_written : err;
-}
-
-static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
-			unsigned long offset, unsigned long size)
-{
-	char *kaddr;
-	unsigned long left, count = desc->count;
-	struct inode *inode = page->mapping->host;
-
-	if (size > count)
-		size = count;
-
-	if (!PageChecked(page)) {
-		/* FIXME, do it per block */
-		struct btrfs_root *root = BTRFS_I(inode)->root;
-		int ret;
-		struct buffer_head *bh;
-
-		if (page_has_buffers(page)) {
-			bh = page_buffers(page);
-			if (!buffer_mapped(bh)) {
-				SetPageChecked(page);
-				goto checked;
-			}
-		}
-
-		ret = btrfs_csum_verify_file_block(root,
-				  page->mapping->host->i_ino,
-				  page->index << PAGE_CACHE_SHIFT,
-				  kmap(page), PAGE_CACHE_SIZE);
-		if (ret) {
-			if (ret != -ENOENT) {
-				printk("failed to verify ino %lu page %lu ret %d\n",
-				       page->mapping->host->i_ino,
-				       page->index, ret);
-				memset(page_address(page), 1, PAGE_CACHE_SIZE);
-				flush_dcache_page(page);
-			}
-		}
-		SetPageChecked(page);
-		kunmap(page);
-	}
-checked:
-	/*
-	 * Faults on the destination of a read are common, so do it before
-	 * taking the kmap.
-	 */
-	if (!fault_in_pages_writeable(desc->arg.buf, size)) {
-		kaddr = kmap_atomic(page, KM_USER0);
-		left = __copy_to_user_inatomic(desc->arg.buf,
-						kaddr + offset, size);
-		kunmap_atomic(kaddr, KM_USER0);
-		if (left == 0)
-			goto success;
-	}
-
-	/* Do it the slow way */
-	kaddr = kmap(page);
-	left = __copy_to_user(desc->arg.buf, kaddr + offset, size);
-	kunmap(page);
-
-	if (left) {
-		size -= left;
-		desc->error = -EFAULT;
+		goto fail_close;
 	}
-success:
-	desc->count = count - size;
-	desc->written += size;
-	desc->arg.buf += size;
-	return size;
-}
-
-/**
- * btrfs_file_aio_read - filesystem read routine
- * @iocb:	kernel I/O control block
- * @iov:	io vector request
- * @nr_segs:	number of segments in the iovec
- * @pos:	current file position
- */
-static ssize_t btrfs_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
-				   unsigned long nr_segs, loff_t pos)
-{
-	struct file *filp = iocb->ki_filp;
-	ssize_t retval;
-	unsigned long seg;
-	size_t count;
-	loff_t *ppos = &iocb->ki_pos;
-
-	count = 0;
-	for (seg = 0; seg < nr_segs; seg++) {
-		const struct iovec *iv = &iov[seg];
-
-		/*
-		 * If any segment has a negative length, or the cumulative
-		 * length ever wraps negative then return -EINVAL.
-		 */
-		count += iv->iov_len;
-		if (unlikely((ssize_t)(count|iv->iov_len) < 0))
-			return -EINVAL;
-		if (access_ok(VERIFY_WRITE, iv->iov_base, iv->iov_len))
-			continue;
-		if (seg == 0)
-			return -EFAULT;
-		nr_segs = seg;
-		count -= iv->iov_len;	/* This segment is no good */
-		break;
+	if (inode->i_state & I_NEW) {
+		btrfs_read_locked_inode(inode);
+		unlock_new_inode(inode);
 	}
-	retval = 0;
-	if (count) {
-		for (seg = 0; seg < nr_segs; seg++) {
-			read_descriptor_t desc;
 
-			desc.written = 0;
-			desc.arg.buf = iov[seg].iov_base;
-			desc.count = iov[seg].iov_len;
-			if (desc.count == 0)
-				continue;
-			desc.error = 0;
-			do_generic_file_read(filp, ppos, &desc,
-					     btrfs_read_actor);
-			retval += desc.written;
-			if (desc.error) {
-				retval = retval ?: desc.error;
-				break;
-			}
-		}
+	root_dentry = d_alloc_root(inode);
+	if (!root_dentry) {
+		iput(inode);
+		err = -ENOMEM;
+		goto fail_close;
 	}
-	return retval;
-}
-
-static int create_subvol(struct btrfs_root *root, char *name, int namelen)
-{
-	struct btrfs_trans_handle *trans;
-	struct btrfs_key key;
-	struct btrfs_root_item root_item;
-	struct btrfs_inode_item *inode_item;
-	struct buffer_head *subvol;
-	struct btrfs_leaf *leaf;
-	struct btrfs_root *new_root;
-	struct inode *inode;
-	struct inode *dir;
-	int ret;
-	u64 objectid;
-	u64 new_dirid = BTRFS_FIRST_FREE_OBJECTID;
-
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	BUG_ON(!trans);
-
-	subvol = btrfs_alloc_free_block(trans, root, 0);
-	if (subvol == NULL)
-		return -ENOSPC;
-	leaf = btrfs_buffer_leaf(subvol);
-	btrfs_set_header_nritems(&leaf->header, 0);
-	btrfs_set_header_level(&leaf->header, 0);
-	btrfs_set_header_blocknr(&leaf->header, bh_blocknr(subvol));
-	btrfs_set_header_generation(&leaf->header, trans->transid);
-	btrfs_set_header_owner(&leaf->header, root->root_key.objectid);
-	memcpy(leaf->header.fsid, root->fs_info->disk_super->fsid,
-	       sizeof(leaf->header.fsid));
-	mark_buffer_dirty(subvol);
-
-	inode_item = &root_item.inode;
-	memset(inode_item, 0, sizeof(*inode_item));
-	btrfs_set_inode_generation(inode_item, 1);
-	btrfs_set_inode_size(inode_item, 3);
-	btrfs_set_inode_nlink(inode_item, 1);
-	btrfs_set_inode_nblocks(inode_item, 1);
-	btrfs_set_inode_mode(inode_item, S_IFDIR | 0755);
-
-	btrfs_set_root_blocknr(&root_item, bh_blocknr(subvol));
-	btrfs_set_root_refs(&root_item, 1);
-	brelse(subvol);
-	subvol = NULL;
-
-	ret = btrfs_find_free_objectid(trans, root->fs_info->tree_root,
-				       0, &objectid);
-	BUG_ON(ret);
-
-	btrfs_set_root_dirid(&root_item, new_dirid);
-
-	key.objectid = objectid;
-	key.offset = 1;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_ROOT_ITEM_KEY);
-	ret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,
-				&root_item);
-	BUG_ON(ret);
-
-	/*
-	 * insert the directory item
-	 */
-	key.offset = (u64)-1;
-	dir = root->fs_info->sb->s_root->d_inode;
-	ret = btrfs_insert_dir_item(trans, root->fs_info->tree_root,
-				    name, namelen, dir->i_ino, &key,
-				    BTRFS_FT_DIR);
-	BUG_ON(ret);
-
-	ret = btrfs_commit_transaction(trans, root);
-	BUG_ON(ret);
-
-	new_root = btrfs_read_fs_root(root->fs_info, &key);
-	BUG_ON(!new_root);
-
-	trans = btrfs_start_transaction(new_root, 1);
-	BUG_ON(!trans);
-
-	inode = btrfs_new_inode(trans, new_root, new_dirid,
-				BTRFS_I(dir)->block_group, S_IFDIR | 0700);
-	inode->i_op = &btrfs_dir_inode_operations;
-	inode->i_fop = &btrfs_dir_file_operations;
-
-	ret = btrfs_make_empty_dir(trans, new_root, new_dirid, new_dirid);
-	BUG_ON(ret);
-
-	inode->i_nlink = 1;
-	inode->i_size = 6;
-	ret = btrfs_update_inode(trans, new_root, inode);
-	BUG_ON(ret);
-
-	ret = btrfs_commit_transaction(trans, new_root);
-	BUG_ON(ret);
-
-	iput(inode);
-
-	mutex_unlock(&root->fs_info->fs_mutex);
-	btrfs_btree_balance_dirty(root);
+	sb->s_root = root_dentry;
+	btrfs_transaction_queue_work(tree_root, HZ * 30);
 	return 0;
+
+fail_close:
+	close_ctree(tree_root);
+	return err;
 }
 
-static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
+static int btrfs_sync_fs(struct super_block *sb, int wait)
 {
 	struct btrfs_trans_handle *trans;
-	struct btrfs_key key;
-	struct btrfs_root_item new_root_item;
+	struct btrfs_root *root;
 	int ret;
-	u64 objectid;
-
-	if (!root->ref_cows)
-		return -EINVAL;
+	root = btrfs_sb(sb);
 
+	sb->s_dirt = 0;
+	if (!wait) {
+		filemap_flush(root->fs_info->btree_inode->i_mapping);
+		return 0;
+	}
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
-	BUG_ON(!trans);
-
-	ret = btrfs_update_inode(trans, root, root->inode);
-	BUG_ON(ret);
-
-	ret = btrfs_find_free_objectid(trans, root->fs_info->tree_root,
-				       0, &objectid);
-	BUG_ON(ret);
-
-	memcpy(&new_root_item, &root->root_item,
-	       sizeof(new_root_item));
-
-	key.objectid = objectid;
-	key.offset = 1;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_ROOT_ITEM_KEY);
-	btrfs_set_root_blocknr(&new_root_item, bh_blocknr(root->node));
-
-	ret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,
-				&new_root_item);
-	BUG_ON(ret);
-
-	/*
-	 * insert the directory item
-	 */
-	key.offset = (u64)-1;
-	ret = btrfs_insert_dir_item(trans, root->fs_info->tree_root,
-				    name, namelen,
-				    root->fs_info->sb->s_root->d_inode->i_ino,
-				    &key, BTRFS_FT_DIR);
-
-	BUG_ON(ret);
-
-	ret = btrfs_inc_root_ref(trans, root);
-	BUG_ON(ret);
-
 	ret = btrfs_commit_transaction(trans, root);
+	sb->s_dirt = 0;
 	BUG_ON(ret);
 	mutex_unlock(&root->fs_info->fs_mutex);
-	btrfs_btree_balance_dirty(root);
-	return 0;
-}
-
-static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
-		       cmd, unsigned long arg)
-{
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct btrfs_ioctl_vol_args vol_args;
-	int ret = 0;
-	struct btrfs_dir_item *di;
-	int namelen;
-	struct btrfs_path *path;
-	u64 root_dirid;
-
-	switch (cmd) {
-	case BTRFS_IOC_SNAP_CREATE:
-		if (copy_from_user(&vol_args,
-				   (struct btrfs_ioctl_vol_args __user *)arg,
-				   sizeof(vol_args)))
-			return -EFAULT;
-		namelen = strlen(vol_args.name);
-		if (namelen > BTRFS_VOL_NAME_MAX)
-			return -EINVAL;
-		path = btrfs_alloc_path();
-		if (!path)
-			return -ENOMEM;
-		root_dirid = root->fs_info->sb->s_root->d_inode->i_ino,
-		mutex_lock(&root->fs_info->fs_mutex);
-		di = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root,
-				    path, root_dirid,
-				    vol_args.name, namelen, 0);
-		mutex_unlock(&root->fs_info->fs_mutex);
-		btrfs_free_path(path);
-		if (di && !IS_ERR(di))
-			return -EEXIST;
-
-		if (root == root->fs_info->tree_root)
-			ret = create_subvol(root, vol_args.name, namelen);
-		else
-			ret = create_snapshot(root, vol_args.name, namelen);
-		WARN_ON(ret);
-		break;
-	default:
-		return -ENOTTY;
-	}
-	return ret;
-}
-
-#ifdef CONFIG_COMPAT
-static long btrfs_compat_ioctl(struct file *file, unsigned int cmd,
-			       unsigned long arg)
-{
-	struct inode *inode = file->f_path.dentry->d_inode;
-	int ret;
-	lock_kernel();
-	ret = btrfs_ioctl(inode, file, cmd, (unsigned long) compat_ptr(arg));
-	unlock_kernel();
-	return ret;
-
-}
-#endif
-
-static struct kmem_cache *btrfs_inode_cachep;
-struct kmem_cache *btrfs_trans_handle_cachep;
-struct kmem_cache *btrfs_transaction_cachep;
-struct kmem_cache *btrfs_bit_radix_cachep;
-struct kmem_cache *btrfs_path_cachep;
-
-/*
- * Called inside transaction, so use GFP_NOFS
- */
-static struct inode *btrfs_alloc_inode(struct super_block *sb)
-{
-	struct btrfs_inode *ei;
-
-	ei = kmem_cache_alloc(btrfs_inode_cachep, GFP_NOFS);
-	if (!ei)
-		return NULL;
-	return &ei->vfs_inode;
-}
-
-static void btrfs_destroy_inode(struct inode *inode)
-{
-	WARN_ON(!list_empty(&inode->i_dentry));
-	WARN_ON(inode->i_data.nrpages);
-
-	kmem_cache_free(btrfs_inode_cachep, BTRFS_I(inode));
-}
-
-static void init_once(void * foo, struct kmem_cache * cachep,
-		      unsigned long flags)
-{
-	struct btrfs_inode *ei = (struct btrfs_inode *) foo;
-
-	if ((flags & (SLAB_CTOR_CONSTRUCTOR)) ==
-	    SLAB_CTOR_CONSTRUCTOR) {
-		inode_init_once(&ei->vfs_inode);
-	}
-}
-
-static int init_inodecache(void)
-{
-	btrfs_inode_cachep = kmem_cache_create("btrfs_inode_cache",
-					     sizeof(struct btrfs_inode),
-					     0, (SLAB_RECLAIM_ACCOUNT|
-						SLAB_MEM_SPREAD),
-					     init_once, NULL);
-	btrfs_trans_handle_cachep = kmem_cache_create("btrfs_trans_handle_cache",
-					     sizeof(struct btrfs_trans_handle),
-					     0, (SLAB_RECLAIM_ACCOUNT|
-						SLAB_MEM_SPREAD),
-					     NULL, NULL);
-	btrfs_transaction_cachep = kmem_cache_create("btrfs_transaction_cache",
-					     sizeof(struct btrfs_transaction),
-					     0, (SLAB_RECLAIM_ACCOUNT|
-						SLAB_MEM_SPREAD),
-					     NULL, NULL);
-	btrfs_path_cachep = kmem_cache_create("btrfs_path_cache",
-					     sizeof(struct btrfs_transaction),
-					     0, (SLAB_RECLAIM_ACCOUNT|
-						SLAB_MEM_SPREAD),
-					     NULL, NULL);
-	btrfs_bit_radix_cachep = kmem_cache_create("btrfs_radix",
-					     256,
-					     0, (SLAB_RECLAIM_ACCOUNT|
-						SLAB_MEM_SPREAD |
-						SLAB_DESTROY_BY_RCU),
-					     NULL, NULL);
-	if (btrfs_inode_cachep == NULL || btrfs_trans_handle_cachep == NULL ||
-	    btrfs_transaction_cachep == NULL || btrfs_bit_radix_cachep == NULL)
-		return -ENOMEM;
 	return 0;
 }
 
-static void destroy_inodecache(void)
+static void btrfs_write_super(struct super_block *sb)
 {
-	kmem_cache_destroy(btrfs_inode_cachep);
-	kmem_cache_destroy(btrfs_trans_handle_cachep);
-	kmem_cache_destroy(btrfs_transaction_cachep);
-	kmem_cache_destroy(btrfs_bit_radix_cachep);
-	kmem_cache_destroy(btrfs_path_cachep);
+	sb->s_dirt = 0;
 }
 
 static int btrfs_get_sb(struct file_system_type *fs_type,
@@ -2709,15 +124,6 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 			   btrfs_fill_super, mnt);
 }
 
-static int btrfs_getattr(struct vfsmount *mnt,
-			 struct dentry *dentry, struct kstat *stat)
-{
-	struct inode *inode = dentry->d_inode;
-	generic_fillattr(inode, stat);
-	stat->blksize = 256 * 1024;
-	return 0;
-}
-
 static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
@@ -2732,197 +138,6 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
-static int btrfs_rename(struct inode * old_dir, struct dentry *old_dentry,
-			   struct inode * new_dir,struct dentry *new_dentry)
-{
-	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = BTRFS_I(old_dir)->root;
-	struct inode *new_inode = new_dentry->d_inode;
-	struct inode *old_inode = old_dentry->d_inode;
-	struct timespec ctime = CURRENT_TIME;
-	struct btrfs_path *path;
-	struct btrfs_dir_item *di;
-	int ret;
-
-	if (S_ISDIR(old_inode->i_mode) && new_inode &&
-	    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE) {
-		return -ENOTEMPTY;
-	}
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, new_dir);
-	path = btrfs_alloc_path();
-	if (!path) {
-		ret = -ENOMEM;
-		goto out_fail;
-	}
-
-	old_dentry->d_inode->i_nlink++;
-	old_dir->i_ctime = old_dir->i_mtime = ctime;
-	new_dir->i_ctime = new_dir->i_mtime = ctime;
-	old_inode->i_ctime = ctime;
-	if (S_ISDIR(old_inode->i_mode) && old_dir != new_dir) {
-		struct btrfs_key *location = &BTRFS_I(new_dir)->location;
-		u64 old_parent_oid;
-		di = btrfs_lookup_dir_item(trans, root, path, old_inode->i_ino,
-					   "..", 2, -1);
-		if (IS_ERR(di)) {
-			ret = PTR_ERR(di);
-			goto out_fail;
-		}
-		if (!di) {
-			ret = -ENOENT;
-			goto out_fail;
-		}
-		old_parent_oid = btrfs_disk_key_objectid(&di->location);
-		ret = btrfs_del_item(trans, root, path);
-		if (ret) {
-			ret = -EIO;
-			goto out_fail;
-		}
-		btrfs_release_path(root, path);
-
-		di = btrfs_lookup_dir_index_item(trans, root, path,
-						 old_inode->i_ino,
-						 old_parent_oid,
-						 "..", 2, -1);
-		if (IS_ERR(di)) {
-			ret = PTR_ERR(di);
-			goto out_fail;
-		}
-		if (!di) {
-			ret = -ENOENT;
-			goto out_fail;
-		}
-		ret = btrfs_del_item(trans, root, path);
-		if (ret) {
-			ret = -EIO;
-			goto out_fail;
-		}
-		btrfs_release_path(root, path);
-
-		ret = btrfs_insert_dir_item(trans, root, "..", 2,
-					    old_inode->i_ino, location,
-					    BTRFS_FT_DIR);
-		if (ret)
-			goto out_fail;
-	}
-
-
-	ret = btrfs_unlink_trans(trans, root, old_dir, old_dentry);
-	if (ret)
-		goto out_fail;
-
-	if (new_inode) {
-		new_inode->i_ctime = CURRENT_TIME;
-		ret = btrfs_unlink_trans(trans, root, new_dir, new_dentry);
-		if (ret)
-			goto out_fail;
-		if (S_ISDIR(new_inode->i_mode))
-			clear_nlink(new_inode);
-		else
-			drop_nlink(new_inode);
-		btrfs_update_inode(trans, root, new_inode);
-	}
-	ret = btrfs_add_link(trans, new_dentry, old_inode);
-	if (ret)
-		goto out_fail;
-
-out_fail:
-	btrfs_free_path(path);
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	return ret;
-}
-
-static int btrfs_symlink(struct inode *dir, struct dentry *dentry,
-			 const char *symname)
-{
-	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = BTRFS_I(dir)->root;
-	struct btrfs_path *path;
-	struct btrfs_key key;
-	struct inode *inode;
-	int err;
-	int drop_inode = 0;
-	u64 objectid;
-	int name_len;
-	int datasize;
-	char *ptr;
-	struct btrfs_file_extent_item *ei;
-
-	name_len = strlen(symname) + 1;
-	if (name_len > BTRFS_MAX_INLINE_DATA_SIZE(root))
-		return -ENAMETOOLONG;
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	btrfs_set_trans_block_group(trans, dir);
-
-	err = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
-	if (err) {
-		err = -ENOSPC;
-		goto out_unlock;
-	}
-
-	inode = btrfs_new_inode(trans, root, objectid,
-				BTRFS_I(dir)->block_group, S_IFLNK|S_IRWXUGO);
-	err = PTR_ERR(inode);
-	if (IS_ERR(inode))
-		goto out_unlock;
-
-	btrfs_set_trans_block_group(trans, inode);
-	err = btrfs_add_nondir(trans, dentry, inode);
-	if (err)
-		drop_inode = 1;
-	else {
-		inode->i_mapping->a_ops = &btrfs_aops;
-		inode->i_fop = &btrfs_file_operations;
-		inode->i_op = &btrfs_file_inode_operations;
-	}
-	dir->i_sb->s_dirt = 1;
-	btrfs_update_inode_block_group(trans, inode);
-	btrfs_update_inode_block_group(trans, dir);
-	if (drop_inode)
-		goto out_unlock;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	key.objectid = inode->i_ino;
-	key.offset = 0;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_EXTENT_DATA_KEY);
-	datasize = btrfs_file_extent_calc_inline_size(name_len);
-	err = btrfs_insert_empty_item(trans, root, path, &key,
-				      datasize);
-	BUG_ON(err);
-	ei = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-	       path->slots[0], struct btrfs_file_extent_item);
-	btrfs_set_file_extent_generation(ei, trans->transid);
-	btrfs_set_file_extent_type(ei,
-				   BTRFS_FILE_EXTENT_INLINE);
-	ptr = btrfs_file_extent_inline_start(ei);
-	btrfs_memcpy(root, path->nodes[0]->b_data,
-		     ptr, symname, name_len);
-	mark_buffer_dirty(path->nodes[0]);
-	btrfs_free_path(path);
-	inode->i_op = &btrfs_symlink_inode_operations;
-	inode->i_mapping->a_ops = &btrfs_symlink_aops;
-	inode->i_size = name_len - 1;
-	btrfs_update_inode(trans, root, inode);
-	err = 0;
-
-out_unlock:
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
-
-	if (drop_inode) {
-		inode_dec_link_count(inode);
-		iput(inode);
-	}
-	btrfs_btree_balance_dirty(root);
-	return err;
-}
-
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
@@ -2944,91 +159,21 @@ static struct super_operations btrfs_super_ops = {
 	.statfs		= btrfs_statfs,
 };
 
-static struct inode_operations btrfs_dir_inode_operations = {
-	.lookup		= btrfs_lookup,
-	.create		= btrfs_create,
-	.unlink		= btrfs_unlink,
-	.link		= btrfs_link,
-	.mkdir		= btrfs_mkdir,
-	.rmdir		= btrfs_rmdir,
-	.rename		= btrfs_rename,
-	.symlink	= btrfs_symlink,
-	.setattr	= btrfs_setattr,
-};
-
-static struct inode_operations btrfs_dir_ro_inode_operations = {
-	.lookup		= btrfs_lookup,
-};
-
-static struct file_operations btrfs_dir_file_operations = {
-	.llseek		= generic_file_llseek,
-	.read		= generic_read_dir,
-	.readdir	= btrfs_readdir,
-	.ioctl		= btrfs_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= btrfs_compat_ioctl,
-#endif
-};
-
-static struct address_space_operations btrfs_aops = {
-	.readpage	= btrfs_readpage,
-	.writepage	= btrfs_writepage,
-	.sync_page	= block_sync_page,
-	.prepare_write	= btrfs_prepare_write,
-	.commit_write	= btrfs_commit_write,
-	.bmap		= btrfs_bmap,
-};
-
-static struct address_space_operations btrfs_symlink_aops = {
-	.readpage	= btrfs_readpage,
-	.writepage	= btrfs_writepage,
-};
-
-static struct inode_operations btrfs_file_inode_operations = {
-	.truncate	= btrfs_truncate,
-	.getattr	= btrfs_getattr,
-	.setattr	= btrfs_setattr,
-};
-
-static struct file_operations btrfs_file_operations = {
-	.llseek		= generic_file_llseek,
-	.read		= do_sync_read,
-	.aio_read       = btrfs_file_aio_read,
-	.write		= btrfs_file_write,
-	.mmap		= generic_file_mmap,
-	.open		= generic_file_open,
-	.ioctl		= btrfs_ioctl,
-	.fsync		= btrfs_sync_file,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= btrfs_compat_ioctl,
-#endif
-};
-
-static struct inode_operations btrfs_symlink_inode_operations = {
-	.readlink	= generic_readlink,
-	.follow_link	= page_follow_link_light,
-	.put_link	= page_put_link,
-};
-
 static int __init init_btrfs_fs(void)
 {
 	int err;
-	printk("btrfs loaded!\n");
 	btrfs_init_transaction_sys();
-	err = init_inodecache();
+	err = btrfs_init_cachep();
 	if (err)
 		return err;
 	return register_filesystem(&btrfs_fs_type);
-	destroy_inodecache();
-	return err;
 }
 
 static void __exit exit_btrfs_fs(void)
 {
 	btrfs_exit_transaction_sys();
-	destroy_inodecache();
+	btrfs_destroy_cachep();
 	unregister_filesystem(&btrfs_fs_type);
-	printk("btrfs unloaded\n");
 }
 
 module_init(init_btrfs_fs)

commit 5276aedab0baacfb3c5483208b8be85a8416bd5f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Jun 11 21:33:38 2007 -0400

    Btrfs: fix oops after block group lookup
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2b24a5a2be63..9749090cfbb8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -62,7 +62,6 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	struct btrfs_inode_item *inode_item;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_key location;
-	struct btrfs_block_group_cache *alloc_group;
 	u64 alloc_group_block;
 	int ret;
 
@@ -95,11 +94,8 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	inode->i_blocks = btrfs_inode_nblocks(inode_item);
 	inode->i_generation = btrfs_inode_generation(inode_item);
 	alloc_group_block = btrfs_inode_block_group(inode_item);
-	ret = radix_tree_gang_lookup(&root->fs_info->block_group_radix,
-				     (void **)&alloc_group,
-				     alloc_group_block, 1);
-	BUG_ON(!ret);
-	BTRFS_I(inode)->block_group = alloc_group;
+	BTRFS_I(inode)->block_group = btrfs_lookup_block_group(root->fs_info,
+						       alloc_group_block);
 
 	btrfs_free_path(path);
 	inode_item = NULL;

commit 0cf6c620176a294bdf1bedddc492f6ae857e0019
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sat Jun 9 09:22:25 2007 -0400

    Btrfs: remove device tree
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5864917953a4..2b24a5a2be63 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2566,83 +2566,6 @@ static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 	return 0;
 }
 
-static int add_disk(struct btrfs_root *root, char *name, int namelen)
-{
-	struct block_device *bdev;
-	struct btrfs_path *path;
-	struct super_block *sb = root->fs_info->sb;
-	struct btrfs_root *dev_root = root->fs_info->dev_root;
-	struct btrfs_trans_handle *trans;
-	struct btrfs_device_item *dev_item;
-	struct btrfs_key key;
-	u16 item_size;
-	u64 num_blocks;
-	u64 new_blocks;
-	u64 device_id;
-	int ret;
-
-printk("adding disk %s\n", name);
-	path = btrfs_alloc_path();
-	if (!path)
-		return -ENOMEM;
-	num_blocks = btrfs_super_total_blocks(root->fs_info->disk_super);
-	bdev = open_bdev_excl(name, O_RDWR, sb);
-	if (IS_ERR(bdev)) {
-		ret = PTR_ERR(bdev);
-printk("open bdev excl failed ret %d\n", ret);
-		goto out_nolock;
-	}
-	set_blocksize(bdev, sb->s_blocksize);
-	new_blocks = bdev->bd_inode->i_size >> sb->s_blocksize_bits;
-	key.objectid = num_blocks;
-	key.offset = new_blocks;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_DEV_ITEM_KEY);
-
-	mutex_lock(&dev_root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(dev_root, 1);
-	item_size = sizeof(*dev_item) + namelen;
-printk("insert empty on %Lu %Lu %u size %d\n", num_blocks, new_blocks, key.flags, item_size);
-	ret = btrfs_insert_empty_item(trans, dev_root, path, &key, item_size);
-	if (ret) {
-printk("insert failed %d\n", ret);
-		close_bdev_excl(bdev);
-		if (ret > 0)
-			ret = -EEXIST;
-		goto out;
-	}
-	dev_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-				  path->slots[0], struct btrfs_device_item);
-	btrfs_set_device_pathlen(dev_item, namelen);
-	memcpy(dev_item + 1, name, namelen);
-
-	device_id = btrfs_super_last_device_id(root->fs_info->disk_super) + 1;
-	btrfs_set_super_last_device_id(root->fs_info->disk_super, device_id);
-	btrfs_set_device_id(dev_item, device_id);
-	mark_buffer_dirty(path->nodes[0]);
-
-	ret = btrfs_insert_dev_radix(root, bdev, device_id, num_blocks,
-				     new_blocks);
-
-	if (!ret) {
-		btrfs_set_super_total_blocks(root->fs_info->disk_super,
-					     num_blocks + new_blocks);
-		i_size_write(root->fs_info->btree_inode,
-			     (num_blocks + new_blocks) <<
-			     root->fs_info->btree_inode->i_blkbits);
-	}
-
-out:
-	ret = btrfs_commit_transaction(trans, dev_root);
-	BUG_ON(ret);
-	mutex_unlock(&root->fs_info->fs_mutex);
-out_nolock:
-	btrfs_free_path(path);
-	btrfs_btree_balance_dirty(root);
-
-	return ret;
-}
-
 static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 		       cmd, unsigned long arg)
 {
@@ -2682,17 +2605,6 @@ static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 			ret = create_snapshot(root, vol_args.name, namelen);
 		WARN_ON(ret);
 		break;
-	case BTRFS_IOC_ADD_DISK:
-		if (copy_from_user(&vol_args,
-				   (struct btrfs_ioctl_vol_args __user *)arg,
-				   sizeof(vol_args)))
-			return -EFAULT;
-		namelen = strlen(vol_args.name);
-		if (namelen > BTRFS_VOL_NAME_MAX)
-			return -EINVAL;
-		vol_args.name[namelen] = '\0';
-		ret = add_disk(root, vol_args.name, namelen);
-		break;
 	default:
 		return -ENOTTY;
 	}

commit 08607c1b182b3b8b54d7141a0c012cda17d201e6
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jun 8 15:33:54 2007 -0400

    Btrfs: add compat ioctl
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b58b4cf66766..5864917953a4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -12,6 +12,7 @@
 #include <linux/swap.h>
 #include <linux/writeback.h>
 #include <linux/statfs.h>
+#include <linux/compat.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -950,7 +951,7 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 		return -ENOMEM;
 	}
 	sb->s_root = root_dentry;
-
+	btrfs_transaction_queue_work(tree_root, HZ * 30);
 	return 0;
 }
 
@@ -1452,7 +1453,7 @@ static int btrfs_prepare_write(struct file *file, struct page *page,
 
 static void btrfs_write_super(struct super_block *sb)
 {
-	btrfs_sync_fs(sb, 1);
+	sb->s_dirt = 0;
 }
 
 static int btrfs_readpage(struct file *file, struct page *page)
@@ -2698,6 +2699,20 @@ static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 	return ret;
 }
 
+#ifdef CONFIG_COMPAT
+static long btrfs_compat_ioctl(struct file *file, unsigned int cmd,
+			       unsigned long arg)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	int ret;
+	lock_kernel();
+	ret = btrfs_ioctl(inode, file, cmd, (unsigned long) compat_ptr(arg));
+	unlock_kernel();
+	return ret;
+
+}
+#endif
+
 static struct kmem_cache *btrfs_inode_cachep;
 struct kmem_cache *btrfs_trans_handle_cachep;
 struct kmem_cache *btrfs_transaction_cachep;
@@ -3042,6 +3057,9 @@ static struct file_operations btrfs_dir_file_operations = {
 	.read		= generic_read_dir,
 	.readdir	= btrfs_readdir,
 	.ioctl		= btrfs_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= btrfs_compat_ioctl,
+#endif
 };
 
 static struct address_space_operations btrfs_aops = {
@@ -3073,6 +3091,9 @@ static struct file_operations btrfs_file_operations = {
 	.open		= generic_file_open,
 	.ioctl		= btrfs_ioctl,
 	.fsync		= btrfs_sync_file,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= btrfs_compat_ioctl,
+#endif
 };
 
 static struct inode_operations btrfs_symlink_inode_operations = {
@@ -3085,6 +3106,7 @@ static int __init init_btrfs_fs(void)
 {
 	int err;
 	printk("btrfs loaded!\n");
+	btrfs_init_transaction_sys();
 	err = init_inodecache();
 	if (err)
 		return err;
@@ -3095,6 +3117,7 @@ static int __init init_btrfs_fs(void)
 
 static void __exit exit_btrfs_fs(void)
 {
+	btrfs_exit_transaction_sys();
 	destroy_inodecache();
 	unregister_filesystem(&btrfs_fs_type);
 	printk("btrfs unloaded\n");

commit fabb568183de7996257080260d3537fa75b3667e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Jun 7 22:13:21 2007 -0400

    Btrfs: d_type optimization
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0eb64d6eaf9d..b58b4cf66766 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -43,6 +43,18 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 static int btrfs_get_block(struct inode *inode, sector_t iblock,
 			   struct buffer_head *result, int create);
 
+
+#define S_SHIFT 12
+static unsigned char btrfs_type_by_mode[S_IFMT >> S_SHIFT] = {
+	[S_IFREG >> S_SHIFT]	= BTRFS_FT_REG_FILE,
+	[S_IFDIR >> S_SHIFT]	= BTRFS_FT_DIR,
+	[S_IFCHR >> S_SHIFT]	= BTRFS_FT_CHRDEV,
+	[S_IFBLK >> S_SHIFT]	= BTRFS_FT_BLKDEV,
+	[S_IFIFO >> S_SHIFT]	= BTRFS_FT_FIFO,
+	[S_IFSOCK >> S_SHIFT]	= BTRFS_FT_SOCK,
+	[S_IFLNK >> S_SHIFT]	= BTRFS_FT_SYMLINK,
+};
+
 static void btrfs_read_locked_inode(struct inode *inode)
 {
 	struct btrfs_path *path;
@@ -785,6 +797,9 @@ static void reada_leaves(struct btrfs_root *root, struct btrfs_path *path,
 			break;
 	}
 }
+static unsigned char btrfs_filetype_table[] = {
+	DT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK
+};
 
 static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
@@ -799,7 +814,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	struct btrfs_leaf *leaf;
 	int slot;
 	int advance;
-	unsigned char d_type = DT_UNKNOWN;
+	unsigned char d_type;
 	int over = 0;
 	u32 di_cur;
 	u32 di_total;
@@ -853,6 +868,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		di_cur = 0;
 		di_total = btrfs_item_size(leaf->items + slot);
 		while(di_cur < di_total) {
+			d_type = btrfs_filetype_table[btrfs_dir_type(di)];
 			over = filldir(dirent, (const char *)(di + 1),
 				       btrfs_dir_name_len(di),
 				       btrfs_disk_key_offset(&item->key),
@@ -1012,6 +1028,11 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	return inode;
 }
 
+static inline u8 btrfs_inode_type(struct inode *inode)
+{
+	return btrfs_type_by_mode[(inode->i_mode & S_IFMT) >> S_SHIFT];
+}
+
 static int btrfs_add_link(struct btrfs_trans_handle *trans,
 			    struct dentry *dentry, struct inode *inode)
 {
@@ -1026,7 +1047,7 @@ static int btrfs_add_link(struct btrfs_trans_handle *trans,
 	ret = btrfs_insert_dir_item(trans, root,
 				    dentry->d_name.name, dentry->d_name.len,
 				    dentry->d_parent->d_inode->i_ino,
-				    &key, 0);
+				    &key, btrfs_inode_type(inode));
 	if (ret == 0) {
 		dentry->d_parent->d_inode->i_size += dentry->d_name.len * 2;
 		ret = btrfs_update_inode(trans, root,
@@ -1150,12 +1171,12 @@ static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
 	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
 
 	ret = btrfs_insert_dir_item(trans, root, buf, 1, objectid,
-				    &key, 1);
+				    &key, BTRFS_FT_DIR);
 	if (ret)
 		goto error;
 	key.objectid = dirid;
 	ret = btrfs_insert_dir_item(trans, root, buf, 2, objectid,
-				    &key, 1);
+				    &key, BTRFS_FT_DIR);
 	if (ret)
 		goto error;
 error:
@@ -1265,6 +1286,10 @@ printk("btrfs sync_fs\n");
 	return 0;
 }
 
+#define BTRFS_GET_BLOCK_NO_CREATE 0
+#define BTRFS_GET_BLOCK_CREATE 1
+#define BTRFS_GET_BLOCK_NO_DIRECT 2
+
 static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 			   struct buffer_head *result, int create)
 {
@@ -1286,7 +1311,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	btrfs_init_path(path);
-	if (create) {
+	if (create & BTRFS_GET_BLOCK_CREATE) {
 		WARN_ON(1);
 		/* this almost but not quite works */
 		trans = btrfs_start_transaction(root, 1);
@@ -1349,6 +1374,11 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 		char *ptr;
 		char *map;
 		u32 size;
+
+		if (create & BTRFS_GET_BLOCK_NO_DIRECT) {
+			err = -EINVAL;
+			goto out;
+		}
 		size = btrfs_file_extent_inline_len(leaf->items +
 						    path->slots[0]);
 		extent_end = (extent_start + size) >> inode->i_blkbits;
@@ -1367,7 +1397,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 		btrfs_map_bh_to_logical(root, result, 0);
 	}
 not_found:
-	if (create) {
+	if (create & BTRFS_GET_BLOCK_CREATE) {
 		struct btrfs_key ins;
 		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
 					 1, alloc_hint, (u64)-1,
@@ -1399,6 +1429,21 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 	return err;
 }
 
+static int btrfs_get_block_bmap(struct inode *inode, sector_t iblock,
+			   struct buffer_head *result, int create)
+{
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+	mutex_lock(&root->fs_info->fs_mutex);
+	btrfs_get_block_lock(inode, iblock, result, BTRFS_GET_BLOCK_NO_DIRECT);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return 0;
+}
+
+static sector_t btrfs_bmap(struct address_space *as, sector_t block)
+{
+	return generic_block_bmap(as, block, btrfs_get_block_bmap);
+}
+
 static int btrfs_prepare_write(struct file *file, struct page *page,
 			       unsigned from, unsigned to)
 {
@@ -2428,7 +2473,8 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	key.offset = (u64)-1;
 	dir = root->fs_info->sb->s_root->d_inode;
 	ret = btrfs_insert_dir_item(trans, root->fs_info->tree_root,
-				    name, namelen, dir->i_ino, &key, 0);
+				    name, namelen, dir->i_ino, &key,
+				    BTRFS_FT_DIR);
 	BUG_ON(ret);
 
 	ret = btrfs_commit_transaction(trans, root);
@@ -2505,7 +2551,7 @@ static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 	ret = btrfs_insert_dir_item(trans, root->fs_info->tree_root,
 				    name, namelen,
 				    root->fs_info->sb->s_root->d_inode->i_ino,
-				    &key, 0);
+				    &key, BTRFS_FT_DIR);
 
 	BUG_ON(ret);
 
@@ -2833,7 +2879,8 @@ static int btrfs_rename(struct inode * old_dir, struct dentry *old_dentry,
 		btrfs_release_path(root, path);
 
 		ret = btrfs_insert_dir_item(trans, root, "..", 2,
-					    old_inode->i_ino, location, 0);
+					    old_inode->i_ino, location,
+					    BTRFS_FT_DIR);
 		if (ret)
 			goto out_fail;
 	}
@@ -3003,6 +3050,7 @@ static struct address_space_operations btrfs_aops = {
 	.sync_page	= block_sync_page,
 	.prepare_write	= btrfs_prepare_write,
 	.commit_write	= btrfs_commit_write,
+	.bmap		= btrfs_bmap,
 };
 
 static struct address_space_operations btrfs_symlink_aops = {

commit 1de037a43edf67f3a9f66dd197195b3c08febb16
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue May 29 15:17:08 2007 -0400

    Btrfs: fixup various fsx failures
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5b87c4e9d491..0eb64d6eaf9d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -36,6 +36,13 @@ static struct address_space_operations btrfs_aops;
 static struct address_space_operations btrfs_symlink_aops;
 static struct file_operations btrfs_file_operations;
 
+static int drop_extents(struct btrfs_trans_handle *trans,
+			  struct btrfs_root *root,
+			  struct inode *inode,
+			  u64 start, u64 end, u64 *hint_block);
+static int btrfs_get_block(struct inode *inode, sector_t iblock,
+			   struct buffer_head *result, int create);
+
 static void btrfs_read_locked_inode(struct inode *inode)
 {
 	struct btrfs_path *path;
@@ -381,10 +388,12 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	struct btrfs_disk_key *found_key;
 	u32 found_type;
 	struct btrfs_leaf *leaf;
-	struct btrfs_file_extent_item *fi = NULL;
+	struct btrfs_file_extent_item *fi;
 	u64 extent_start = 0;
 	u64 extent_num_blocks = 0;
+	u64 item_end = 0;
 	int found_extent;
+	int del_item;
 
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
@@ -394,6 +403,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	key.flags = (u32)-1;
 	while(1) {
 		btrfs_init_path(path);
+		fi = NULL;
 		ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
 		if (ret < 0) {
 			goto error;
@@ -413,16 +423,52 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 		    found_type != BTRFS_DIR_INDEX_KEY &&
 		    found_type != BTRFS_EXTENT_DATA_KEY)
 			break;
-		if (btrfs_disk_key_offset(found_key) < inode->i_size)
-			break;
-		found_extent = 0;
-		if (btrfs_disk_key_type(found_key) == BTRFS_EXTENT_DATA_KEY) {
+		item_end = btrfs_disk_key_offset(found_key);
+		if (found_type == BTRFS_EXTENT_DATA_KEY) {
 			fi = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
 					    path->slots[0],
 					    struct btrfs_file_extent_item);
 			if (btrfs_file_extent_type(fi) !=
 			    BTRFS_FILE_EXTENT_INLINE) {
-				u64 num_dec;
+				item_end += btrfs_file_extent_num_blocks(fi) <<
+						inode->i_blkbits;
+			}
+		}
+		if (found_type == BTRFS_CSUM_ITEM_KEY) {
+			ret = btrfs_csum_truncate(trans, root, path,
+						  inode->i_size);
+			BUG_ON(ret);
+		}
+		if (item_end < inode->i_size) {
+			if (found_type) {
+				btrfs_set_key_type(&key, found_type - 1);
+				continue;
+			}
+			break;
+		}
+		if (btrfs_disk_key_offset(found_key) >= inode->i_size)
+			del_item = 1;
+		else
+			del_item = 0;
+		found_extent = 0;
+
+		if (found_type == BTRFS_EXTENT_DATA_KEY &&
+			   btrfs_file_extent_type(fi) !=
+			   BTRFS_FILE_EXTENT_INLINE) {
+			u64 num_dec;
+			if (!del_item) {
+				u64 orig_num_blocks =
+					btrfs_file_extent_num_blocks(fi);
+				extent_num_blocks = inode->i_size -
+					btrfs_disk_key_offset(found_key) +
+					root->blocksize - 1;
+				extent_num_blocks >>= inode->i_blkbits;
+				btrfs_set_file_extent_num_blocks(fi,
+							 extent_num_blocks);
+				inode->i_blocks -= (orig_num_blocks -
+					extent_num_blocks) << 3;
+				mark_buffer_dirty(path->nodes[0]);
+			} else {
 				extent_start =
 					btrfs_file_extent_disk_blocknr(fi);
 				extent_num_blocks =
@@ -435,8 +481,12 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 				}
 			}
 		}
-		ret = btrfs_del_item(trans, root, path);
-		BUG_ON(ret);
+		if (del_item) {
+			ret = btrfs_del_item(trans, root, path);
+			BUG_ON(ret);
+		} else {
+			break;
+		}
 		btrfs_release_path(root, path);
 		if (found_extent) {
 			ret = btrfs_free_extent(trans, root, extent_start,
@@ -452,6 +502,68 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	return ret;
 }
 
+static int btrfs_truncate_page(struct address_space *mapping, loff_t from)
+{
+	struct inode *inode = mapping->host;
+	unsigned blocksize = 1 << inode->i_blkbits;
+	pgoff_t index = from >> PAGE_CACHE_SHIFT;
+	unsigned offset = from & (PAGE_CACHE_SIZE-1);
+	struct page *page;
+	char *kaddr;
+	int ret = 0;
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+	u64 alloc_hint;
+	struct btrfs_key ins;
+	struct btrfs_trans_handle *trans;
+
+	if ((offset & (blocksize - 1)) == 0)
+		goto out;
+
+	ret = -ENOMEM;
+	page = grab_cache_page(mapping, index);
+	if (!page)
+		goto out;
+
+	if (!PageUptodate(page)) {
+		ret = mpage_readpage(page, btrfs_get_block);
+		lock_page(page);
+		if (!PageUptodate(page)) {
+			ret = -EIO;
+			goto out;
+		}
+	}
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, inode);
+
+	ret = drop_extents(trans, root, inode, page->index << PAGE_CACHE_SHIFT,
+			   (page->index + 1) << PAGE_CACHE_SHIFT, &alloc_hint);
+	BUG_ON(ret);
+	ret = btrfs_alloc_extent(trans, root, inode->i_ino, 1,
+				 alloc_hint, (u64)-1, &ins, 1);
+	BUG_ON(ret);
+	ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
+				       page->index << PAGE_CACHE_SHIFT,
+				       ins.objectid, 1, 1);
+	BUG_ON(ret);
+	SetPageChecked(page);
+	kaddr = kmap(page);
+	memset(kaddr + offset, 0, PAGE_CACHE_SIZE - offset);
+	flush_dcache_page(page);
+	btrfs_csum_file_block(trans, root, inode->i_ino,
+			      page->index << PAGE_CACHE_SHIFT,
+			      kaddr, PAGE_CACHE_SIZE);
+	kunmap(page);
+	btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+
+	set_page_dirty(page);
+	unlock_page(page);
+	page_cache_release(page);
+out:
+	return ret;
+}
+
 static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = dentry->d_inode;
@@ -469,8 +581,11 @@ static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)
 		u64 pos = (inode->i_size + mask) & ~mask;
 		u64 hole_size;
 
-		if (attr->ia_size < pos)
+		if (attr->ia_size <= pos)
 			goto out;
+
+		btrfs_truncate_page(inode->i_mapping, inode->i_size);
+
 		hole_size = (attr->ia_size - pos + mask) & ~mask;
 		hole_size >>= inode->i_blkbits;
 
@@ -483,10 +598,9 @@ static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)
 		btrfs_end_transaction(trans, root);
 		mutex_unlock(&root->fs_info->fs_mutex);
 	}
-
+out:
 	err = inode_setattr(inode, attr);
 
-out:
 	return err;
 }
 static void btrfs_delete_inode(struct inode *inode)
@@ -1161,17 +1275,30 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	u64 extent_end = 0;
 	u64 objectid = inode->i_ino;
 	u32 found_type;
+	u64 alloc_hint = 0;
 	struct btrfs_path *path;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_file_extent_item *item;
 	struct btrfs_leaf *leaf;
 	struct btrfs_disk_key *found_key;
+	struct btrfs_trans_handle *trans = NULL;
 
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	btrfs_init_path(path);
 	if (create) {
 		WARN_ON(1);
+		/* this almost but not quite works */
+		trans = btrfs_start_transaction(root, 1);
+		if (!trans) {
+			err = -ENOMEM;
+			goto out;
+		}
+		ret = drop_extents(trans, root, inode,
+				   iblock << inode->i_blkbits,
+				   (iblock + 1) << inode->i_blkbits,
+				   &alloc_hint);
+		BUG_ON(ret);
 	}
 
 	ret = btrfs_lookup_file_extent(NULL, root, path,
@@ -1185,7 +1312,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	if (ret != 0) {
 		if (path->slots[0] == 0) {
 			btrfs_release_path(root, path);
-			goto out;
+			goto not_found;
 		}
 		path->slots[0]--;
 	}
@@ -1203,7 +1330,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	    found_type != BTRFS_EXTENT_DATA_KEY) {
 		extent_end = 0;
 		extent_start = 0;
-		goto out;
+		goto not_found;
 	}
 	found_type = btrfs_file_extent_type(item);
 	extent_start = btrfs_disk_key_offset(&leaf->items[path->slots[0]].key);
@@ -1211,7 +1338,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 		extent_start = extent_start >> inode->i_blkbits;
 		extent_end = extent_start + btrfs_file_extent_num_blocks(item);
 		err = 0;
-		if (blocknr == 0)
+		if (btrfs_file_extent_disk_blocknr(item) == 0)
 			goto out;
 		if (iblock >= extent_start && iblock < extent_end) {
 			btrfs_map_bh_to_logical(root, result, blocknr +
@@ -1227,7 +1354,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 		extent_end = (extent_start + size) >> inode->i_blkbits;
 		extent_start >>= inode->i_blkbits;
 		if (iblock < extent_start || iblock > extent_end) {
-			goto out;
+			goto not_found;
 		}
 		ptr = btrfs_file_extent_inline_start(item);
 		map = kmap(result->b_page);
@@ -1239,7 +1366,24 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 		SetPageChecked(result->b_page);
 		btrfs_map_bh_to_logical(root, result, 0);
 	}
+not_found:
+	if (create) {
+		struct btrfs_key ins;
+		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
+					 1, alloc_hint, (u64)-1,
+					 &ins, 1);
+		BUG_ON(ret);
+		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
+					       iblock << inode->i_blkbits,
+					       ins.objectid, ins.offset,
+					       ins.offset);
+		BUG_ON(ret);
+		SetPageChecked(result->b_page);
+		btrfs_map_bh_to_logical(root, result, ins.objectid);
+	}
 out:
+	if (trans)
+		err = btrfs_end_transaction(trans, root);
 	btrfs_free_path(path);
 	return err;
 }
@@ -1258,7 +1402,7 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 static int btrfs_prepare_write(struct file *file, struct page *page,
 			       unsigned from, unsigned to)
 {
-	return nobh_prepare_write(page, from, to, btrfs_get_block);
+	return block_prepare_write(page, from, to, btrfs_get_block);
 }
 
 static void btrfs_write_super(struct super_block *sb)
@@ -1500,12 +1644,13 @@ static void btrfs_truncate(struct inode *inode)
 	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
 		return;
 
-	nobh_truncate_page(inode->i_mapping, inode->i_size);
+	btrfs_truncate_page(inode->i_mapping, inode->i_size);
 
-	/* FIXME, add redo link to tree so we don't leak on crash */
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	btrfs_set_trans_block_group(trans, inode);
+
+	/* FIXME, add redo link to tree so we don't leak on crash */
 	ret = btrfs_truncate_in_trans(trans, root, inode);
 	BUG_ON(ret);
 	btrfs_update_inode(trans, root, inode);
@@ -1515,10 +1660,6 @@ static void btrfs_truncate(struct inode *inode)
 	btrfs_btree_balance_dirty(root);
 }
 
-/*
- * Make sure any changes to nobh_commit_write() are reflected in
- * nobh_truncate_page(), since it doesn't call commit_write().
- */
 static int btrfs_commit_write(struct file *file, struct page *page,
 			      unsigned from, unsigned to)
 {
@@ -1528,6 +1669,7 @@ static int btrfs_commit_write(struct file *file, struct page *page,
 
 	SetPageUptodate(page);
 	bh = page_buffers(page);
+	set_buffer_uptodate(bh);
 	if (buffer_mapped(bh) && bh->b_blocknr != 0) {
 		set_page_dirty(page);
 	}
@@ -1972,8 +2114,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	first_index = pos >> PAGE_CACHE_SHIFT;
 	last_index = (pos + count) >> PAGE_CACHE_SHIFT;
 
-	if ((first_index << PAGE_CACHE_SHIFT) < inode->i_size &&
-	    (pos & (PAGE_CACHE_SIZE - 1))) {
+	if ((pos & (PAGE_CACHE_SIZE - 1))) {
 		pinned[0] = grab_cache_page(inode->i_mapping, first_index);
 		if (!PageUptodate(pinned[0])) {
 			ret = mpage_readpage(pinned[0], btrfs_get_block);
@@ -1983,10 +2124,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 			unlock_page(pinned[0]);
 		}
 	}
-	if (first_index != last_index &&
-	    (last_index << PAGE_CACHE_SHIFT) < inode->i_size &&
-	    pos + count < inode->i_size &&
-	    (count & (PAGE_CACHE_SIZE - 1))) {
+	if ((pos + count) & (PAGE_CACHE_SIZE - 1)) {
 		pinned[1] = grab_cache_page(inode->i_mapping, last_index);
 		if (!PageUptodate(pinned[1])) {
 			ret = mpage_readpage(pinned[1], btrfs_get_block);
@@ -2110,23 +2248,34 @@ static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
 	if (!PageChecked(page)) {
 		/* FIXME, do it per block */
 		struct btrfs_root *root = BTRFS_I(inode)->root;
+		int ret;
+		struct buffer_head *bh;
+
+		if (page_has_buffers(page)) {
+			bh = page_buffers(page);
+			if (!buffer_mapped(bh)) {
+				SetPageChecked(page);
+				goto checked;
+			}
+		}
 
-		int ret = btrfs_csum_verify_file_block(root,
+		ret = btrfs_csum_verify_file_block(root,
 				  page->mapping->host->i_ino,
 				  page->index << PAGE_CACHE_SHIFT,
 				  kmap(page), PAGE_CACHE_SIZE);
 		if (ret) {
 			if (ret != -ENOENT) {
-				printk("failed to verify ino %lu page %lu\n",
+				printk("failed to verify ino %lu page %lu ret %d\n",
 				       page->mapping->host->i_ino,
-				       page->index);
-				memset(page_address(page), 0, PAGE_CACHE_SIZE);
+				       page->index, ret);
+				memset(page_address(page), 1, PAGE_CACHE_SIZE);
 				flush_dcache_page(page);
 			}
 		}
 		SetPageChecked(page);
 		kunmap(page);
 	}
+checked:
 	/*
 	 * Faults on the destination of a read are common, so do it before
 	 * taking the kmap.

commit 3a686375629da5d2e2ad019265b66ef113c87455
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu May 24 13:35:57 2007 -0400

    Btrfs: sparse files!
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c1a0adde9b1c..5b87c4e9d491 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -17,6 +17,7 @@
 #include "transaction.h"
 #include "btrfs_inode.h"
 #include "ioctl.h"
+#include "print-tree.h"
 
 struct btrfs_iget_args {
 	u64 ino;
@@ -421,14 +422,17 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 					    struct btrfs_file_extent_item);
 			if (btrfs_file_extent_type(fi) !=
 			    BTRFS_FILE_EXTENT_INLINE) {
+				u64 num_dec;
 				extent_start =
 					btrfs_file_extent_disk_blocknr(fi);
 				extent_num_blocks =
 					btrfs_file_extent_disk_num_blocks(fi);
 				/* FIXME blocksize != 4096 */
-				inode->i_blocks -=
-					btrfs_file_extent_num_blocks(fi) << 3;
-				found_extent = 1;
+				num_dec = btrfs_file_extent_num_blocks(fi) << 3;
+				if (extent_start != 0) {
+					found_extent = 1;
+					inode->i_blocks -= num_dec;
+				}
 			}
 		}
 		ret = btrfs_del_item(trans, root, path);
@@ -448,6 +452,43 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	return ret;
 }
 
+static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int err;
+
+	err = inode_change_ok(inode, attr);
+	if (err)
+		return err;
+
+	if (S_ISREG(inode->i_mode) &&
+	    attr->ia_valid & ATTR_SIZE && attr->ia_size > inode->i_size) {
+		struct btrfs_trans_handle *trans;
+		struct btrfs_root *root = BTRFS_I(inode)->root;
+		u64 mask = root->blocksize - 1;
+		u64 pos = (inode->i_size + mask) & ~mask;
+		u64 hole_size;
+
+		if (attr->ia_size < pos)
+			goto out;
+		hole_size = (attr->ia_size - pos + mask) & ~mask;
+		hole_size >>= inode->i_blkbits;
+
+		mutex_lock(&root->fs_info->fs_mutex);
+		trans = btrfs_start_transaction(root, 1);
+		btrfs_set_trans_block_group(trans, inode);
+		err = btrfs_insert_file_extent(trans, root, inode->i_ino,
+					       pos, 0, 0, hole_size);
+		BUG_ON(err);
+		btrfs_end_transaction(trans, root);
+		mutex_unlock(&root->fs_info->fs_mutex);
+	}
+
+	err = inode_setattr(inode, attr);
+
+out:
+	return err;
+}
 static void btrfs_delete_inode(struct inode *inode)
 {
 	struct btrfs_trans_handle *trans;
@@ -1169,8 +1210,10 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	if (found_type == BTRFS_FILE_EXTENT_REG) {
 		extent_start = extent_start >> inode->i_blkbits;
 		extent_end = extent_start + btrfs_file_extent_num_blocks(item);
+		err = 0;
+		if (blocknr == 0)
+			goto out;
 		if (iblock >= extent_start && iblock < extent_end) {
-			err = 0;
 			btrfs_map_bh_to_logical(root, result, blocknr +
 						iblock - extent_start);
 			goto out;
@@ -1591,7 +1634,7 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 				     ptr, bh->b_data, offset + write_bytes);
 			mark_buffer_dirty(path->nodes[0]);
 			btrfs_free_path(path);
-		} else {
+		} else if (buffer_mapped(bh)) {
 			btrfs_csum_file_block(trans, root, inode->i_ino,
 				      pages[i]->index << PAGE_CACHE_SHIFT,
 				      kmap(pages[i]), PAGE_CACHE_SIZE);
@@ -1693,15 +1736,24 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			goto out;
 		}
 
-		search_start = extent_end;
+		if (found_inline) {
+			u64 mask = root->blocksize - 1;
+			search_start = (extent_end + mask) & ~mask;
+		} else
+			search_start = extent_end;
 
 		if (end < extent_end && end >= key.offset) {
 			if (found_extent) {
+				u64 disk_blocknr =
+					btrfs_file_extent_disk_blocknr(extent);
+				u64 disk_num_blocks =
+				      btrfs_file_extent_disk_num_blocks(extent);
 				memcpy(&old, extent, sizeof(old));
-				ret = btrfs_inc_extent_ref(trans, root,
-				      btrfs_file_extent_disk_blocknr(&old),
-				      btrfs_file_extent_disk_num_blocks(&old));
-				BUG_ON(ret);
+				if (disk_blocknr != 0) {
+					ret = btrfs_inc_extent_ref(trans, root,
+					         disk_blocknr, disk_num_blocks);
+					BUG_ON(ret);
+				}
 			}
 			WARN_ON(found_inline);
 			bookend = 1;
@@ -1719,7 +1771,10 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 				old_num = btrfs_file_extent_num_blocks(extent);
 				*hint_block =
 					btrfs_file_extent_disk_blocknr(extent);
-				inode->i_blocks -= (old_num - new_num) << 3;
+				if (btrfs_file_extent_disk_blocknr(extent)) {
+					inode->i_blocks -=
+						(old_num - new_num) << 3;
+				}
 				btrfs_set_file_extent_num_blocks(extent,
 								 new_num);
 				mark_buffer_dirty(path->nodes[0]);
@@ -1745,7 +1800,7 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			BUG_ON(ret);
 			btrfs_release_path(root, path);
 			extent = NULL;
-			if (found_extent) {
+			if (found_extent && disk_blocknr != 0) {
 				inode->i_blocks -= extent_num_blocks << 3;
 				ret = btrfs_free_extent(trans, root,
 							disk_blocknr,
@@ -1785,18 +1840,19 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 				    btrfs_file_extent_offset(&old) +
 				    ((end - key.offset) >> inode->i_blkbits));
 			WARN_ON(btrfs_file_extent_num_blocks(&old) <
-				(end - key.offset) >> inode->i_blkbits);
+				(extent_end - end) >> inode->i_blkbits);
 			btrfs_set_file_extent_num_blocks(extent,
-				    btrfs_file_extent_num_blocks(&old) -
-				    ((end - key.offset) >> inode->i_blkbits));
+				    (extent_end - end) >> inode->i_blkbits);
 
 			btrfs_set_file_extent_type(extent,
 						   BTRFS_FILE_EXTENT_REG);
 			btrfs_set_file_extent_generation(extent,
 				    btrfs_file_extent_generation(&old));
 			btrfs_mark_buffer_dirty(path->nodes[0]);
-			inode->i_blocks +=
-				btrfs_file_extent_num_blocks(extent) << 3;
+			if (btrfs_file_extent_disk_blocknr(&old) != 0) {
+				inode->i_blocks +=
+				      btrfs_file_extent_num_blocks(extent) << 3;
+			}
 			ret = 0;
 			goto out;
 		}
@@ -1960,6 +2016,21 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 				   ~((u64)root->blocksize - 1), &hint_block);
 		BUG_ON(ret);
 	}
+	if (inode->i_size < start_pos) {
+		u64 last_pos_in_file;
+		u64 hole_size;
+		u64 mask = root->blocksize - 1;
+		last_pos_in_file = (inode->i_size + mask) & ~mask;
+		hole_size = (start_pos - last_pos_in_file + mask) & ~mask;
+		hole_size >>= inode->i_blkbits;
+		if (last_pos_in_file < start_pos) {
+			ret = btrfs_insert_file_extent(trans, root,
+						       inode->i_ino,
+						       last_pos_in_file,
+						       0, 0, hole_size);
+		}
+		BUG_ON(ret);
+	}
 	if (inode->i_size >= PAGE_CACHE_SIZE || pos + count < inode->i_size ||
 	    pos + count - start_pos > BTRFS_MAX_INLINE_DATA_SIZE(root)) {
 		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
@@ -1967,7 +2038,8 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 					 &ins, 1);
 		BUG_ON(ret);
 		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
-				       start_pos, ins.objectid, ins.offset);
+				       start_pos, ins.objectid, ins.offset,
+				       ins.offset);
 		BUG_ON(ret);
 	} else {
 		ins.offset = 0;
@@ -2044,10 +2116,13 @@ static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
 				  page->index << PAGE_CACHE_SHIFT,
 				  kmap(page), PAGE_CACHE_SIZE);
 		if (ret) {
-			printk("failed to verify ino %lu page %lu\n",
-			       page->mapping->host->i_ino,
-			       page->index);
-			memset(page_address(page), 0, PAGE_CACHE_SIZE);
+			if (ret != -ENOENT) {
+				printk("failed to verify ino %lu page %lu\n",
+				       page->mapping->host->i_ino,
+				       page->index);
+				memset(page_address(page), 0, PAGE_CACHE_SIZE);
+				flush_dcache_page(page);
+			}
 		}
 		SetPageChecked(page);
 		kunmap(page);
@@ -2759,6 +2834,7 @@ static struct inode_operations btrfs_dir_inode_operations = {
 	.rmdir		= btrfs_rmdir,
 	.rename		= btrfs_rename,
 	.symlink	= btrfs_symlink,
+	.setattr	= btrfs_setattr,
 };
 
 static struct inode_operations btrfs_dir_ro_inode_operations = {
@@ -2788,6 +2864,7 @@ static struct address_space_operations btrfs_symlink_aops = {
 static struct inode_operations btrfs_file_inode_operations = {
 	.truncate	= btrfs_truncate,
 	.getattr	= btrfs_getattr,
+	.setattr	= btrfs_setattr,
 };
 
 static struct file_operations btrfs_file_operations = {

commit 2b8d99a723a3186a69b5bd941a272dbecae9205b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu May 24 08:34:10 2007 -0400

    Btrfs: symlinks and hard links
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f49cad603ee8..c1a0adde9b1c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -26,11 +26,13 @@ struct btrfs_iget_args {
 #define BTRFS_SUPER_MAGIC 0x9123682E
 
 static struct inode_operations btrfs_dir_inode_operations;
+static struct inode_operations btrfs_symlink_inode_operations;
 static struct inode_operations btrfs_dir_ro_inode_operations;
 static struct super_operations btrfs_super_ops;
 static struct file_operations btrfs_dir_file_operations;
 static struct inode_operations btrfs_file_inode_operations;
 static struct address_space_operations btrfs_aops;
+static struct address_space_operations btrfs_symlink_aops;
 static struct file_operations btrfs_file_operations;
 
 static void btrfs_read_locked_inode(struct inode *inode)
@@ -103,7 +105,8 @@ static void btrfs_read_locked_inode(struct inode *inode)
 			inode->i_op = &btrfs_dir_inode_operations;
 		break;
 	case S_IFLNK:
-		// inode->i_op = &page_symlink_inode_operations;
+		inode->i_op = &btrfs_symlink_inode_operations;
+		inode->i_mapping->a_ops = &btrfs_symlink_aops;
 		break;
 	}
 	return;
@@ -940,6 +943,41 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 	return err;
 }
 
+static int btrfs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *root = BTRFS_I(dir)->root;
+	struct inode *inode = old_dentry->d_inode;
+	int err;
+	int drop_inode = 0;
+
+	if (inode->i_nlink == 0)
+		return -ENOENT;
+
+	inc_nlink(inode);
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, dir);
+	atomic_inc(&inode->i_count);
+	err = btrfs_add_nondir(trans, dentry, inode);
+	if (err)
+		drop_inode = 1;
+	dir->i_sb->s_dirt = 1;
+	btrfs_update_inode_block_group(trans, dir);
+	btrfs_update_inode(trans, root, inode);
+
+	btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+
+	if (drop_inode) {
+		inode_dec_link_count(inode);
+		iput(inode);
+	}
+	btrfs_btree_balance_dirty(root);
+	return err;
+}
+
 static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
 				struct btrfs_root *root,
 				u64 objectid, u64 dirid)
@@ -2577,33 +2615,25 @@ static int btrfs_rename(struct inode * old_dir, struct dentry *old_dentry,
 	}
 
 
-	ret = btrfs_add_link(trans, new_dentry, old_inode);
-	if (ret == -EEXIST && new_inode)
-		ret = 0;
-	else if (ret)
-		goto out_fail;
-
 	ret = btrfs_unlink_trans(trans, root, old_dir, old_dentry);
 	if (ret)
 		goto out_fail;
 
 	if (new_inode) {
 		new_inode->i_ctime = CURRENT_TIME;
-		di = btrfs_lookup_dir_index_item(trans, root, path,
-						 new_dir->i_ino,
-						 new_inode->i_ino,
-						 new_dentry->d_name.name,
-						 new_dentry->d_name.len, -1);
-		if (di && !IS_ERR(di)) {
-			btrfs_del_item(trans, root, path);
-			btrfs_release_path(root, path);
-		}
+		ret = btrfs_unlink_trans(trans, root, new_dir, new_dentry);
+		if (ret)
+			goto out_fail;
 		if (S_ISDIR(new_inode->i_mode))
 			clear_nlink(new_inode);
 		else
 			drop_nlink(new_inode);
 		btrfs_update_inode(trans, root, new_inode);
 	}
+	ret = btrfs_add_link(trans, new_dentry, old_inode);
+	if (ret)
+		goto out_fail;
+
 out_fail:
 	btrfs_free_path(path);
 	btrfs_end_transaction(trans, root);
@@ -2611,6 +2641,94 @@ static int btrfs_rename(struct inode * old_dir, struct dentry *old_dentry,
 	return ret;
 }
 
+static int btrfs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *root = BTRFS_I(dir)->root;
+	struct btrfs_path *path;
+	struct btrfs_key key;
+	struct inode *inode;
+	int err;
+	int drop_inode = 0;
+	u64 objectid;
+	int name_len;
+	int datasize;
+	char *ptr;
+	struct btrfs_file_extent_item *ei;
+
+	name_len = strlen(symname) + 1;
+	if (name_len > BTRFS_MAX_INLINE_DATA_SIZE(root))
+		return -ENAMETOOLONG;
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, dir);
+
+	err = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
+	if (err) {
+		err = -ENOSPC;
+		goto out_unlock;
+	}
+
+	inode = btrfs_new_inode(trans, root, objectid,
+				BTRFS_I(dir)->block_group, S_IFLNK|S_IRWXUGO);
+	err = PTR_ERR(inode);
+	if (IS_ERR(inode))
+		goto out_unlock;
+
+	btrfs_set_trans_block_group(trans, inode);
+	err = btrfs_add_nondir(trans, dentry, inode);
+	if (err)
+		drop_inode = 1;
+	else {
+		inode->i_mapping->a_ops = &btrfs_aops;
+		inode->i_fop = &btrfs_file_operations;
+		inode->i_op = &btrfs_file_inode_operations;
+	}
+	dir->i_sb->s_dirt = 1;
+	btrfs_update_inode_block_group(trans, inode);
+	btrfs_update_inode_block_group(trans, dir);
+	if (drop_inode)
+		goto out_unlock;
+
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	key.objectid = inode->i_ino;
+	key.offset = 0;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_EXTENT_DATA_KEY);
+	datasize = btrfs_file_extent_calc_inline_size(name_len);
+	err = btrfs_insert_empty_item(trans, root, path, &key,
+				      datasize);
+	BUG_ON(err);
+	ei = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+	       path->slots[0], struct btrfs_file_extent_item);
+	btrfs_set_file_extent_generation(ei, trans->transid);
+	btrfs_set_file_extent_type(ei,
+				   BTRFS_FILE_EXTENT_INLINE);
+	ptr = btrfs_file_extent_inline_start(ei);
+	btrfs_memcpy(root, path->nodes[0]->b_data,
+		     ptr, symname, name_len);
+	mark_buffer_dirty(path->nodes[0]);
+	btrfs_free_path(path);
+	inode->i_op = &btrfs_symlink_inode_operations;
+	inode->i_mapping->a_ops = &btrfs_symlink_aops;
+	inode->i_size = name_len - 1;
+	btrfs_update_inode(trans, root, inode);
+	err = 0;
+
+out_unlock:
+	btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+
+	if (drop_inode) {
+		inode_dec_link_count(inode);
+		iput(inode);
+	}
+	btrfs_btree_balance_dirty(root);
+	return err;
+}
+
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
@@ -2636,9 +2754,11 @@ static struct inode_operations btrfs_dir_inode_operations = {
 	.lookup		= btrfs_lookup,
 	.create		= btrfs_create,
 	.unlink		= btrfs_unlink,
+	.link		= btrfs_link,
 	.mkdir		= btrfs_mkdir,
 	.rmdir		= btrfs_rmdir,
 	.rename		= btrfs_rename,
+	.symlink	= btrfs_symlink,
 };
 
 static struct inode_operations btrfs_dir_ro_inode_operations = {
@@ -2660,6 +2780,11 @@ static struct address_space_operations btrfs_aops = {
 	.commit_write	= btrfs_commit_write,
 };
 
+static struct address_space_operations btrfs_symlink_aops = {
+	.readpage	= btrfs_readpage,
+	.writepage	= btrfs_writepage,
+};
+
 static struct inode_operations btrfs_file_inode_operations = {
 	.truncate	= btrfs_truncate,
 	.getattr	= btrfs_getattr,
@@ -2676,6 +2801,12 @@ static struct file_operations btrfs_file_operations = {
 	.fsync		= btrfs_sync_file,
 };
 
+static struct inode_operations btrfs_symlink_inode_operations = {
+	.readlink	= generic_readlink,
+	.follow_link	= page_follow_link_light,
+	.put_link	= page_put_link,
+};
+
 static int __init init_btrfs_fs(void)
 {
 	int err;

commit e06afa839e726959be2166bec4cb85c117e213f1
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed May 23 15:44:28 2007 -0400

    Btrfs: rename
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0220c82841ad..f49cad603ee8 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -375,6 +375,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	struct btrfs_path *path;
 	struct btrfs_key key;
 	struct btrfs_disk_key *found_key;
+	u32 found_type;
 	struct btrfs_leaf *leaf;
 	struct btrfs_file_extent_item *fi = NULL;
 	u64 extent_start = 0;
@@ -386,12 +387,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	/* FIXME, add redo link to tree so we don't leak on crash */
 	key.objectid = inode->i_ino;
 	key.offset = (u64)-1;
-	key.flags = 0;
-	/*
-	 * use BTRFS_CSUM_ITEM_KEY because it is larger than inline keys
-	 * or extent data
-	 */
-	btrfs_set_key_type(&key, BTRFS_CSUM_ITEM_KEY);
+	key.flags = (u32)-1;
 	while(1) {
 		btrfs_init_path(path);
 		ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
@@ -405,10 +401,13 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 		reada_truncate(root, path, inode->i_ino);
 		leaf = btrfs_buffer_leaf(path->nodes[0]);
 		found_key = &leaf->items[path->slots[0]].key;
+		found_type = btrfs_disk_key_type(found_key);
 		if (btrfs_disk_key_objectid(found_key) != inode->i_ino)
 			break;
-		if (btrfs_disk_key_type(found_key) != BTRFS_CSUM_ITEM_KEY &&
-		    btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY)
+		if (found_type != BTRFS_CSUM_ITEM_KEY &&
+		    found_type != BTRFS_DIR_ITEM_KEY &&
+		    found_type != BTRFS_DIR_INDEX_KEY &&
+		    found_type != BTRFS_EXTENT_DATA_KEY)
 			break;
 		if (btrfs_disk_key_offset(found_key) < inode->i_size)
 			break;
@@ -460,10 +459,8 @@ static void btrfs_delete_inode(struct inode *inode)
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	btrfs_set_trans_block_group(trans, inode);
-	if (S_ISREG(inode->i_mode)) {
-		ret = btrfs_truncate_in_trans(trans, root, inode);
-		BUG_ON(ret);
-	}
+	ret = btrfs_truncate_in_trans(trans, root, inode);
+	BUG_ON(ret);
 	btrfs_free_inode(trans, root, inode);
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
@@ -2504,6 +2501,116 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
+static int btrfs_rename(struct inode * old_dir, struct dentry *old_dentry,
+			   struct inode * new_dir,struct dentry *new_dentry)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *root = BTRFS_I(old_dir)->root;
+	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = old_dentry->d_inode;
+	struct timespec ctime = CURRENT_TIME;
+	struct btrfs_path *path;
+	struct btrfs_dir_item *di;
+	int ret;
+
+	if (S_ISDIR(old_inode->i_mode) && new_inode &&
+	    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE) {
+		return -ENOTEMPTY;
+	}
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, new_dir);
+	path = btrfs_alloc_path();
+	if (!path) {
+		ret = -ENOMEM;
+		goto out_fail;
+	}
+
+	old_dentry->d_inode->i_nlink++;
+	old_dir->i_ctime = old_dir->i_mtime = ctime;
+	new_dir->i_ctime = new_dir->i_mtime = ctime;
+	old_inode->i_ctime = ctime;
+	if (S_ISDIR(old_inode->i_mode) && old_dir != new_dir) {
+		struct btrfs_key *location = &BTRFS_I(new_dir)->location;
+		u64 old_parent_oid;
+		di = btrfs_lookup_dir_item(trans, root, path, old_inode->i_ino,
+					   "..", 2, -1);
+		if (IS_ERR(di)) {
+			ret = PTR_ERR(di);
+			goto out_fail;
+		}
+		if (!di) {
+			ret = -ENOENT;
+			goto out_fail;
+		}
+		old_parent_oid = btrfs_disk_key_objectid(&di->location);
+		ret = btrfs_del_item(trans, root, path);
+		if (ret) {
+			ret = -EIO;
+			goto out_fail;
+		}
+		btrfs_release_path(root, path);
+
+		di = btrfs_lookup_dir_index_item(trans, root, path,
+						 old_inode->i_ino,
+						 old_parent_oid,
+						 "..", 2, -1);
+		if (IS_ERR(di)) {
+			ret = PTR_ERR(di);
+			goto out_fail;
+		}
+		if (!di) {
+			ret = -ENOENT;
+			goto out_fail;
+		}
+		ret = btrfs_del_item(trans, root, path);
+		if (ret) {
+			ret = -EIO;
+			goto out_fail;
+		}
+		btrfs_release_path(root, path);
+
+		ret = btrfs_insert_dir_item(trans, root, "..", 2,
+					    old_inode->i_ino, location, 0);
+		if (ret)
+			goto out_fail;
+	}
+
+
+	ret = btrfs_add_link(trans, new_dentry, old_inode);
+	if (ret == -EEXIST && new_inode)
+		ret = 0;
+	else if (ret)
+		goto out_fail;
+
+	ret = btrfs_unlink_trans(trans, root, old_dir, old_dentry);
+	if (ret)
+		goto out_fail;
+
+	if (new_inode) {
+		new_inode->i_ctime = CURRENT_TIME;
+		di = btrfs_lookup_dir_index_item(trans, root, path,
+						 new_dir->i_ino,
+						 new_inode->i_ino,
+						 new_dentry->d_name.name,
+						 new_dentry->d_name.len, -1);
+		if (di && !IS_ERR(di)) {
+			btrfs_del_item(trans, root, path);
+			btrfs_release_path(root, path);
+		}
+		if (S_ISDIR(new_inode->i_mode))
+			clear_nlink(new_inode);
+		else
+			drop_nlink(new_inode);
+		btrfs_update_inode(trans, root, new_inode);
+	}
+out_fail:
+	btrfs_free_path(path);
+	btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return ret;
+}
+
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
@@ -2531,6 +2638,7 @@ static struct inode_operations btrfs_dir_inode_operations = {
 	.unlink		= btrfs_unlink,
 	.mkdir		= btrfs_mkdir,
 	.rmdir		= btrfs_rmdir,
+	.rename		= btrfs_rename,
 };
 
 static struct inode_operations btrfs_dir_ro_inode_operations = {

commit f9f3c6b666f717510b67036c314ec915b9059eaa
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon May 21 14:05:12 2007 -0400

    Btrfs: 2.6.21-git fixes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0f79490123cf..0220c82841ad 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -18,24 +18,11 @@
 #include "btrfs_inode.h"
 #include "ioctl.h"
 
-static void btrfs_fsinfo_release(struct kobject *obj)
-{
-	struct btrfs_fs_info *fsinfo = container_of(obj,
-					    struct btrfs_fs_info, kobj);
-	kfree(fsinfo);
-}
-
-static struct kobj_type btrfs_fsinfo_ktype = {
-	.release = btrfs_fsinfo_release,
-};
-
 struct btrfs_iget_args {
 	u64 ino;
 	struct btrfs_root *root;
 };
 
-decl_subsys(btrfs, &btrfs_fsinfo_ktype, NULL);
-
 #define BTRFS_SUPER_MAGIC 0x9123682E
 
 static struct inode_operations btrfs_dir_inode_operations;
@@ -2438,7 +2425,7 @@ static void init_once(void * foo, struct kmem_cache * cachep,
 {
 	struct btrfs_inode *ei = (struct btrfs_inode *) foo;
 
-	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+	if ((flags & (SLAB_CTOR_CONSTRUCTOR)) ==
 	    SLAB_CTOR_CONSTRUCTOR) {
 		inode_init_once(&ei->vfs_inode);
 	}
@@ -2588,12 +2575,7 @@ static int __init init_btrfs_fs(void)
 	err = init_inodecache();
 	if (err)
 		return err;
-	kset_set_kset_s(&btrfs_subsys, fs_subsys);
-	err = subsystem_register(&btrfs_subsys);
-	if (err)
-		goto out;
 	return register_filesystem(&btrfs_fs_type);
-out:
 	destroy_inodecache();
 	return err;
 }
@@ -2602,7 +2584,6 @@ static void __exit exit_btrfs_fs(void)
 {
 	destroy_inodecache();
 	unregister_filesystem(&btrfs_fs_type);
-	subsystem_unregister(&btrfs_subsys);
 	printk("btrfs unloaded\n");
 }
 

commit de428b63b16f9c74a24228a517713e8c65f79475
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri May 18 13:28:27 2007 -0400

    Btrfs: allocator optimizations, truncate readahead
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index eaa48f09d1c4..0f79490123cf 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -351,6 +351,35 @@ static int btrfs_free_inode(struct btrfs_trans_handle *trans,
 	return ret;
 }
 
+static void reada_truncate(struct btrfs_root *root, struct btrfs_path *path,
+			   u64 objectid)
+{
+	struct btrfs_node *node;
+	int i;
+	int nritems;
+	u64 item_objectid;
+	u64 blocknr;
+	int slot;
+	int ret;
+
+	if (!path->nodes[1])
+		return;
+	node = btrfs_buffer_node(path->nodes[1]);
+	slot = path->slots[1];
+	if (slot == 0)
+		return;
+	nritems = btrfs_header_nritems(&node->header);
+	for (i = slot - 1; i >= 0; i--) {
+		item_objectid = btrfs_disk_key_objectid(&node->ptrs[i].key);
+		if (item_objectid != objectid)
+			break;
+		blocknr = btrfs_node_blockptr(node, i);
+		ret = readahead_tree_block(root, blocknr);
+		if (ret)
+			break;
+	}
+}
+
 static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 				   struct btrfs_root *root,
 				   struct inode *inode)
@@ -386,6 +415,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 			BUG_ON(path->slots[0] == 0);
 			path->slots[0]--;
 		}
+		reada_truncate(root, path, inode->i_ino);
 		leaf = btrfs_buffer_leaf(path->nodes[0]);
 		found_key = &leaf->items[path->slots[0]].key;
 		if (btrfs_disk_key_objectid(found_key) != inode->i_ino)
@@ -587,28 +617,30 @@ printk("adding new root for inode %lu root %p (found %p)\n", inode->i_ino, sub_r
 	return d_splice_alias(inode, dentry);
 }
 
-static void reada_leaves(struct btrfs_root *root, struct btrfs_path *path)
+static void reada_leaves(struct btrfs_root *root, struct btrfs_path *path,
+			 u64 objectid)
 {
 	struct btrfs_node *node;
 	int i;
-	int nritems;
-	u64 objectid;
+	u32 nritems;
 	u64 item_objectid;
 	u64 blocknr;
 	int slot;
+	int ret;
 
 	if (!path->nodes[1])
 		return;
 	node = btrfs_buffer_node(path->nodes[1]);
 	slot = path->slots[1];
-	objectid = btrfs_disk_key_objectid(&node->ptrs[slot].key);
 	nritems = btrfs_header_nritems(&node->header);
-	for (i = slot; i < nritems; i++) {
+	for (i = slot + 1; i < nritems; i++) {
 		item_objectid = btrfs_disk_key_objectid(&node->ptrs[i].key);
 		if (item_objectid != objectid)
 			break;
 		blocknr = btrfs_node_blockptr(node, i);
-		readahead_tree_block(root, blocknr);
+		ret = readahead_tree_block(root, blocknr);
+		if (ret)
+			break;
 	}
 }
 
@@ -646,21 +678,20 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	if (ret < 0)
 		goto err;
 	advance = 0;
-	reada_leaves(root, path);
+	reada_leaves(root, path, inode->i_ino);
 	while(1) {
 		leaf = btrfs_buffer_leaf(path->nodes[0]);
 		nritems = btrfs_header_nritems(&leaf->header);
 		slot = path->slots[0];
 		if (advance || slot >= nritems) {
 			if (slot >= nritems -1) {
+				reada_leaves(root, path, inode->i_ino);
 				ret = btrfs_next_leaf(root, path);
 				if (ret)
 					break;
 				leaf = btrfs_buffer_leaf(path->nodes[0]);
 				nritems = btrfs_header_nritems(&leaf->header);
 				slot = path->slots[0];
-				if (path->slots[1] == 0)
-					reada_leaves(root, path);
 			} else {
 				slot++;
 				path->slots[0]++;
@@ -805,13 +836,18 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	struct btrfs_inode_item inode_item;
 	struct btrfs_key *location;
 	int ret;
+	int owner;
 
 	inode = new_inode(root->fs_info->sb);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
 
 	BTRFS_I(inode)->root = root;
-	group = btrfs_find_block_group(root, group, 0, 0);
+	if (mode & S_IFDIR)
+		owner = 0;
+	else
+		owner = 1;
+	group = btrfs_find_block_group(root, group, 0, 0, owner);
 	BTRFS_I(inode)->block_group = group;
 
 	inode->i_uid = current->fsuid;
@@ -1562,7 +1598,7 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 static int drop_extents(struct btrfs_trans_handle *trans,
 			  struct btrfs_root *root,
 			  struct inode *inode,
-			  u64 start, u64 end)
+			  u64 start, u64 end, u64 *hint_block)
 {
 	int ret;
 	struct btrfs_key key;
@@ -1659,17 +1695,14 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 				new_num = (start - key.offset) >>
 					inode->i_blkbits;
 				old_num = btrfs_file_extent_num_blocks(extent);
+				*hint_block =
+					btrfs_file_extent_disk_blocknr(extent);
 				inode->i_blocks -= (old_num - new_num) << 3;
 				btrfs_set_file_extent_num_blocks(extent,
 								 new_num);
 				mark_buffer_dirty(path->nodes[0]);
 			} else {
 				WARN_ON(1);
-				/*
-				ret = btrfs_truncate_item(trans, root, path,
-							  start - key.offset);
-				BUG_ON(ret);
-				*/
 			}
 		}
 		if (!keep) {
@@ -1683,6 +1716,8 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 				      btrfs_file_extent_disk_num_blocks(extent);
 				extent_num_blocks =
 				      btrfs_file_extent_num_blocks(extent);
+				*hint_block =
+					btrfs_file_extent_disk_blocknr(extent);
 			}
 			ret = btrfs_del_item(trans, root, path);
 			BUG_ON(ret);
@@ -1831,6 +1866,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	u64 start_pos;
 	u64 num_blocks;
 	u64 alloc_extent_start;
+	u64 hint_block;
 	struct btrfs_trans_handle *trans;
 	struct btrfs_key ins;
 	pinned[0] = NULL;
@@ -1871,6 +1907,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	}
 	if (first_index != last_index &&
 	    (last_index << PAGE_CACHE_SHIFT) < inode->i_size &&
+	    pos + count < inode->i_size &&
 	    (count & (PAGE_CACHE_SIZE - 1))) {
 		pinned[1] = grab_cache_page(inode->i_mapping, last_index);
 		if (!PageUptodate(pinned[1])) {
@@ -1892,18 +1929,20 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	btrfs_set_trans_block_group(trans, inode);
 	/* FIXME blocksize != 4096 */
 	inode->i_blocks += num_blocks << 3;
+	hint_block = 0;
 	if (start_pos < inode->i_size) {
 		/* FIXME blocksize != pagesize */
 		ret = drop_extents(trans, root, inode,
 				   start_pos,
 				   (pos + count + root->blocksize -1) &
-				   ~((u64)root->blocksize - 1));
+				   ~((u64)root->blocksize - 1), &hint_block);
 		BUG_ON(ret);
 	}
 	if (inode->i_size >= PAGE_CACHE_SIZE || pos + count < inode->i_size ||
 	    pos + count - start_pos > BTRFS_MAX_INLINE_DATA_SIZE(root)) {
 		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
-					 num_blocks, 1, (u64)-1, &ins, 1);
+					 num_blocks, hint_block, (u64)-1,
+					 &ins, 1);
 		BUG_ON(ret);
 		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
 				       start_pos, ins.objectid, ins.offset);
@@ -2455,7 +2494,6 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 			   btrfs_fill_super, mnt);
 }
 
-
 static int btrfs_getattr(struct vfsmount *mnt,
 			 struct dentry *dentry, struct kstat *stat)
 {

commit 098f59c2512426926722a96f82af127bd91fb5e4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri May 11 11:33:21 2007 -0400

    Btrfs: patch queue: fix corruption when splitting large items
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4c2870e2d12f..eaa48f09d1c4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1529,7 +1529,8 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 			btrfs_set_file_extent_type(ei,
 						   BTRFS_FILE_EXTENT_INLINE);
 			ptr = btrfs_file_extent_inline_start(ei);
-			memcpy(ptr, bh->b_data, offset + write_bytes);
+			btrfs_memcpy(root, path->nodes[0]->b_data,
+				     ptr, bh->b_data, offset + write_bytes);
 			mark_buffer_dirty(path->nodes[0]);
 			btrfs_free_path(path);
 		} else {
@@ -1686,9 +1687,9 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			ret = btrfs_del_item(trans, root, path);
 			BUG_ON(ret);
 			btrfs_release_path(root, path);
+			extent = NULL;
 			if (found_extent) {
-				inode->i_blocks -=
-				btrfs_file_extent_num_blocks(extent) << 3;
+				inode->i_blocks -= extent_num_blocks << 3;
 				ret = btrfs_free_extent(trans, root,
 							disk_blocknr,
 							disk_num_blocks, 0);
@@ -1832,7 +1833,6 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	u64 alloc_extent_start;
 	struct btrfs_trans_handle *trans;
 	struct btrfs_key ins;
-
 	pinned[0] = NULL;
 	pinned[1] = NULL;
 	if (file->f_flags & O_DIRECT)

commit e37c9e6921207cf503634b06bee37ecb7904408d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed May 9 20:13:14 2007 -0400

    Btrfs: many allocator fixes, pretty solid
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d5ac0d8ee3c9..4c2870e2d12f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1539,7 +1539,7 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 			kunmap(pages[i]);
 		}
 		SetPageChecked(pages[i]);
-		btrfs_update_inode_block_group(trans, inode);
+		// btrfs_update_inode_block_group(trans, inode);
 		ret = btrfs_end_transaction(trans, root);
 		BUG_ON(ret);
 		mutex_unlock(&root->fs_info->fs_mutex);
@@ -1914,7 +1914,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	}
 	BUG_ON(ret);
 	alloc_extent_start = ins.objectid;
-	btrfs_update_inode_block_group(trans, inode);
+	// btrfs_update_inode_block_group(trans, inode);
 	ret = btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
 

commit be74417553f4b2ee46be2088007a674ef2f02330
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun May 6 10:15:01 2007 -0400

    Btrfs: more allocator enhancements
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 23ba4e979fc9..d5ac0d8ee3c9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -811,7 +811,7 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 		return ERR_PTR(-ENOMEM);
 
 	BTRFS_I(inode)->root = root;
-	group = btrfs_find_block_group(root, group, 0);
+	group = btrfs_find_block_group(root, group, 0, 0);
 	BTRFS_I(inode)->block_group = group;
 
 	inode->i_uid = current->fsuid;

commit be08c1b9f8e679d45e086728445ac36cf250e92e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu May 3 09:06:49 2007 -0400

    Btrfs: early metadata/data split
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 130a1d3d9f5f..23ba4e979fc9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1903,7 +1903,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	if (inode->i_size >= PAGE_CACHE_SIZE || pos + count < inode->i_size ||
 	    pos + count - start_pos > BTRFS_MAX_INLINE_DATA_SIZE(root)) {
 		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
-					 num_blocks, 1, (u64)-1, &ins);
+					 num_blocks, 1, (u64)-1, &ins, 1);
 		BUG_ON(ret);
 		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
 				       start_pos, ins.objectid, ins.offset);

commit 35b7e476107e3d54f03384e0f2fa3dfd68933353
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed May 2 15:53:43 2007 -0400

    Btrfs: fix page cache memory leak
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a29a781b86c2..130a1d3d9f5f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -18,14 +18,14 @@
 #include "btrfs_inode.h"
 #include "ioctl.h"
 
-void btrfs_fsinfo_release(struct kobject *obj)
+static void btrfs_fsinfo_release(struct kobject *obj)
 {
 	struct btrfs_fs_info *fsinfo = container_of(obj,
 					    struct btrfs_fs_info, kobj);
 	kfree(fsinfo);
 }
 
-struct kobj_type btrfs_fsinfo_ktype = {
+static struct kobj_type btrfs_fsinfo_ktype = {
 	.release = btrfs_fsinfo_release,
 };
 
@@ -148,7 +148,6 @@ static void fill_inode_item(struct btrfs_inode_item *item,
 				    BTRFS_I(inode)->block_group->key.objectid);
 }
 
-
 static int btrfs_update_inode(struct btrfs_trans_handle *trans,
 			      struct btrfs_root *root,
 			      struct inode *inode)
@@ -251,6 +250,7 @@ static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
 	ret = btrfs_unlink_trans(trans, root, dir, dentry);
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
+	btrfs_btree_balance_dirty(root);
 	return ret;
 }
 
@@ -324,6 +324,7 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 	btrfs_free_path(path);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	ret = btrfs_end_transaction(trans, root);
+	btrfs_btree_balance_dirty(root);
 	if (ret && !err)
 		err = ret;
 	return err;
@@ -449,6 +450,7 @@ static void btrfs_delete_inode(struct inode *inode)
 	btrfs_free_inode(trans, root, inode);
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
+	btrfs_btree_balance_dirty(root);
 	return;
 no_delete:
 	clear_inode(inode);
@@ -481,7 +483,7 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 	return ret;
 }
 
-int fixup_tree_root_location(struct btrfs_root *root,
+static int fixup_tree_root_location(struct btrfs_root *root,
 			     struct btrfs_key *location,
 			     struct btrfs_root **sub_root)
 {
@@ -512,7 +514,7 @@ int fixup_tree_root_location(struct btrfs_root *root,
 	return 0;
 }
 
-int btrfs_init_locked_inode(struct inode *inode, void *p)
+static int btrfs_init_locked_inode(struct inode *inode, void *p)
 {
 	struct btrfs_iget_args *args = p;
 	inode->i_ino = args->ino;
@@ -520,15 +522,15 @@ int btrfs_init_locked_inode(struct inode *inode, void *p)
 	return 0;
 }
 
-int btrfs_find_actor(struct inode *inode, void *opaque)
+static int btrfs_find_actor(struct inode *inode, void *opaque)
 {
 	struct btrfs_iget_args *args = opaque;
 	return (args->ino == inode->i_ino &&
 		args->root == BTRFS_I(inode)->root);
 }
 
-struct inode *btrfs_iget_locked(struct super_block *s, u64 objectid,
-				struct btrfs_root *root)
+static struct inode *btrfs_iget_locked(struct super_block *s, u64 objectid,
+				       struct btrfs_root *root)
 {
 	struct inode *inode;
 	struct btrfs_iget_args args;
@@ -790,6 +792,7 @@ static void btrfs_dirty_inode(struct inode *inode)
 	btrfs_update_inode(trans, root, inode);
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
+	btrfs_btree_balance_dirty(root);
 }
 
 static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
@@ -913,6 +916,7 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 		inode_dec_link_count(inode);
 		iput(inode);
 	}
+	btrfs_btree_balance_dirty(root);
 	return err;
 }
 
@@ -1002,6 +1006,7 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 	mutex_unlock(&root->fs_info->fs_mutex);
 	if (drop_on_err)
 		iput(inode);
+	btrfs_btree_balance_dirty(root);
 	return err;
 }
 
@@ -1099,7 +1104,6 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	    found_type != BTRFS_EXTENT_DATA_KEY) {
 		extent_end = 0;
 		extent_start = 0;
-		btrfs_release_path(root, path);
 		goto out;
 	}
 	found_type = btrfs_file_extent_type(item);
@@ -1135,7 +1139,6 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 		btrfs_map_bh_to_logical(root, result, 0);
 	}
 out:
-	btrfs_release_path(root, path);
 	btrfs_free_path(path);
 	return err;
 }
@@ -1231,13 +1234,13 @@ static int __btrfs_write_full_page(struct inode *inode, struct page *page,
 		} else if (!buffer_mapped(bh) && buffer_dirty(bh)) {
 			WARN_ON(bh->b_size != blocksize);
 			err = btrfs_get_block(inode, block, bh, 0);
-			if (err)
+			if (err) {
+printk("writepage going to recovery err %d\n", err);
 				goto recover;
+			}
 			if (buffer_new(bh)) {
 				/* blockdev mappings never come here */
 				clear_buffer_new(bh);
-				unmap_underlying_metadata(bh->b_bdev,
-							bh->b_blocknr);
 			}
 		}
 		bh = bh->b_this_page;
@@ -1303,11 +1306,6 @@ static int __btrfs_write_full_page(struct inode *inode, struct page *page,
 		if (uptodate)
 			SetPageUptodate(page);
 		end_page_writeback(page);
-		/*
-		 * The page and buffer_heads can be released at any time from
-		 * here on.
-		 */
-		wbc->pages_skipped++;	/* We didn't write this page */
 	}
 	return err;
 
@@ -1409,10 +1407,11 @@ static void btrfs_truncate(struct inode *inode)
 	btrfs_set_trans_block_group(trans, inode);
 	ret = btrfs_truncate_in_trans(trans, root, inode);
 	BUG_ON(ret);
+	btrfs_update_inode(trans, root, inode);
 	ret = btrfs_end_transaction(trans, root);
 	BUG_ON(ret);
 	mutex_unlock(&root->fs_info->fs_mutex);
-	mark_inode_dirty(inode);
+	btrfs_btree_balance_dirty(root);
 }
 
 /*
@@ -1777,10 +1776,15 @@ static int prepare_pages(struct btrfs_root *root,
 			err = -ENOMEM;
 			goto failed_release;
 		}
+		cancel_dirty_page(pages[i], PAGE_CACHE_SIZE);
+		wait_on_page_writeback(pages[i]);
 		offset = pos & (PAGE_CACHE_SIZE -1);
 		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
-		create_empty_buffers(pages[i], root->fs_info->sb->s_blocksize,
-				     (1 << BH_Uptodate));
+		if (!page_has_buffers(pages[i])) {
+			create_empty_buffers(pages[i],
+					     root->fs_info->sb->s_blocksize,
+					     (1 << BH_Uptodate));
+		}
 		head = page_buffers(pages[i]);
 		bh = head;
 		do {
@@ -1820,7 +1824,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct page *pages[8];
-	struct page *pinned[2] = { NULL, NULL };
+	struct page *pinned[2];
 	unsigned long first_index;
 	unsigned long last_index;
 	u64 start_pos;
@@ -1829,6 +1833,8 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	struct btrfs_trans_handle *trans;
 	struct btrfs_key ins;
 
+	pinned[0] = NULL;
+	pinned[1] = NULL;
 	if (file->f_flags & O_DIRECT)
 		return -EINVAL;
 	pos = *ppos;
@@ -1858,6 +1864,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		if (!PageUptodate(pinned[0])) {
 			ret = mpage_readpage(pinned[0], btrfs_get_block);
 			BUG_ON(ret);
+			wait_on_page_locked(pinned[0]);
 		} else {
 			unlock_page(pinned[0]);
 		}
@@ -1869,6 +1876,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		if (!PageUptodate(pinned[1])) {
 			ret = mpage_readpage(pinned[1], btrfs_get_block);
 			BUG_ON(ret);
+			wait_on_page_locked(pinned[1]);
 		} else {
 			unlock_page(pinned[1]);
 		}
@@ -1940,6 +1948,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		num_written += write_bytes;
 
 		balance_dirty_pages_ratelimited(inode->i_mapping);
+		btrfs_btree_balance_dirty(root);
 		cond_resched();
 	}
 out_unlock:
@@ -2165,6 +2174,7 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	iput(inode);
 
 	mutex_unlock(&root->fs_info->fs_mutex);
+	btrfs_btree_balance_dirty(root);
 	return 0;
 }
 
@@ -2220,6 +2230,7 @@ static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 	ret = btrfs_commit_transaction(trans, root);
 	BUG_ON(ret);
 	mutex_unlock(&root->fs_info->fs_mutex);
+	btrfs_btree_balance_dirty(root);
 	return 0;
 }
 
@@ -2295,6 +2306,7 @@ printk("insert failed %d\n", ret);
 	mutex_unlock(&root->fs_info->fs_mutex);
 out_nolock:
 	btrfs_free_path(path);
+	btrfs_btree_balance_dirty(root);
 
 	return ret;
 }

commit 090d18753c7fb73f7d846c3a89a50cd35136d144
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue May 1 08:53:32 2007 -0400

    Btrfs: directory readahead
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7ecbe7c86186..a29a781b86c2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -585,6 +585,31 @@ printk("adding new root for inode %lu root %p (found %p)\n", inode->i_ino, sub_r
 	return d_splice_alias(inode, dentry);
 }
 
+static void reada_leaves(struct btrfs_root *root, struct btrfs_path *path)
+{
+	struct btrfs_node *node;
+	int i;
+	int nritems;
+	u64 objectid;
+	u64 item_objectid;
+	u64 blocknr;
+	int slot;
+
+	if (!path->nodes[1])
+		return;
+	node = btrfs_buffer_node(path->nodes[1]);
+	slot = path->slots[1];
+	objectid = btrfs_disk_key_objectid(&node->ptrs[slot].key);
+	nritems = btrfs_header_nritems(&node->header);
+	for (i = slot; i < nritems; i++) {
+		item_objectid = btrfs_disk_key_objectid(&node->ptrs[i].key);
+		if (item_objectid != objectid)
+			break;
+		blocknr = btrfs_node_blockptr(node, i);
+		readahead_tree_block(root, blocknr);
+	}
+}
+
 static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct inode *inode = filp->f_path.dentry->d_inode;
@@ -619,6 +644,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	if (ret < 0)
 		goto err;
 	advance = 0;
+	reada_leaves(root, path);
 	while(1) {
 		leaf = btrfs_buffer_leaf(path->nodes[0]);
 		nritems = btrfs_header_nritems(&leaf->header);
@@ -631,6 +657,8 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 				leaf = btrfs_buffer_leaf(path->nodes[0]);
 				nritems = btrfs_header_nritems(&leaf->header);
 				slot = path->slots[0];
+				if (path->slots[1] == 0)
+					reada_leaves(root, path);
 			} else {
 				slot++;
 				path->slots[0]++;

commit 31f3c99b73483f7b738a886c552050cbd6128ff3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 30 15:25:45 2007 -0400

    Btrfs: allocator improvements, inode block groups
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1890e8648dbd..7ecbe7c86186 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -52,6 +52,8 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	struct btrfs_inode_item *inode_item;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_key location;
+	struct btrfs_block_group_cache *alloc_group;
+	u64 alloc_group_block;
 	int ret;
 
 	path = btrfs_alloc_path();
@@ -82,6 +84,12 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	inode->i_ctime.tv_nsec = btrfs_timespec_nsec(&inode_item->ctime);
 	inode->i_blocks = btrfs_inode_nblocks(inode_item);
 	inode->i_generation = btrfs_inode_generation(inode_item);
+	alloc_group_block = btrfs_inode_block_group(inode_item);
+	ret = radix_tree_gang_lookup(&root->fs_info->block_group_radix,
+				     (void **)&alloc_group,
+				     alloc_group_block, 1);
+	BUG_ON(!ret);
+	BTRFS_I(inode)->block_group = alloc_group;
 
 	btrfs_free_path(path);
 	inode_item = NULL;
@@ -136,6 +144,8 @@ static void fill_inode_item(struct btrfs_inode_item *item,
 	btrfs_set_timespec_nsec(&item->ctime, inode->i_ctime.tv_nsec);
 	btrfs_set_inode_nblocks(item, inode->i_blocks);
 	btrfs_set_inode_generation(item, inode->i_generation);
+	btrfs_set_inode_block_group(item,
+				    BTRFS_I(inode)->block_group->key.objectid);
 }
 
 
@@ -237,6 +247,7 @@ static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
 	root = BTRFS_I(dir)->root;
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, dir);
 	ret = btrfs_unlink_trans(trans, root, dir, dentry);
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
@@ -262,6 +273,7 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 	btrfs_init_path(path);
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, dir);
 	key.objectid = inode->i_ino;
 	key.offset = (u64)-1;
 	key.flags = (u32)-1;
@@ -429,6 +441,7 @@ static void btrfs_delete_inode(struct inode *inode)
 	inode->i_size = 0;
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, inode);
 	if (S_ISREG(inode->i_mode)) {
 		ret = btrfs_truncate_in_trans(trans, root, inode);
 		BUG_ON(ret);
@@ -731,6 +744,7 @@ static int btrfs_write_inode(struct inode *inode, int wait)
 	if (wait) {
 		mutex_lock(&root->fs_info->fs_mutex);
 		trans = btrfs_start_transaction(root, 1);
+		btrfs_set_trans_block_group(trans, inode);
 		ret = btrfs_commit_transaction(trans, root);
 		mutex_unlock(&root->fs_info->fs_mutex);
 	}
@@ -744,6 +758,7 @@ static void btrfs_dirty_inode(struct inode *inode)
 
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, inode);
 	btrfs_update_inode(trans, root, inode);
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
@@ -751,7 +766,9 @@ static void btrfs_dirty_inode(struct inode *inode)
 
 static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 				     struct btrfs_root *root,
-				     u64 objectid, int mode)
+				     u64 objectid,
+				     struct btrfs_block_group_cache *group,
+				     int mode)
 {
 	struct inode *inode;
 	struct btrfs_inode_item inode_item;
@@ -763,6 +780,8 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 		return ERR_PTR(-ENOMEM);
 
 	BTRFS_I(inode)->root = root;
+	group = btrfs_find_block_group(root, group, 0);
+	BTRFS_I(inode)->block_group = group;
 
 	inode->i_uid = current->fsuid;
 	inode->i_gid = current->fsgid;
@@ -832,6 +851,7 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, dir);
 
 	err = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
 	if (err) {
@@ -839,11 +859,13 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 		goto out_unlock;
 	}
 
-	inode = btrfs_new_inode(trans, root, objectid, mode);
+	inode = btrfs_new_inode(trans, root, objectid,
+				BTRFS_I(dir)->block_group, mode);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_unlock;
-	// FIXME mark the inode dirty
+
+	btrfs_set_trans_block_group(trans, inode);
 	err = btrfs_add_nondir(trans, dentry, inode);
 	if (err)
 		drop_inode = 1;
@@ -853,6 +875,8 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 		inode->i_op = &btrfs_file_inode_operations;
 	}
 	dir->i_sb->s_dirt = 1;
+	btrfs_update_inode_block_group(trans, inode);
+	btrfs_update_inode_block_group(trans, dir);
 out_unlock:
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
@@ -904,6 +928,7 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, dir);
 	if (IS_ERR(trans)) {
 		err = PTR_ERR(trans);
 		goto out_unlock;
@@ -915,7 +940,8 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 		goto out_unlock;
 	}
 
-	inode = btrfs_new_inode(trans, root, objectid, S_IFDIR | mode);
+	inode = btrfs_new_inode(trans, root, objectid,
+				BTRFS_I(dir)->block_group, S_IFDIR | mode);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
 		goto out_fail;
@@ -923,6 +949,7 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 	drop_on_err = 1;
 	inode->i_op = &btrfs_dir_inode_operations;
 	inode->i_fop = &btrfs_dir_file_operations;
+	btrfs_set_trans_block_group(trans, inode);
 
 	err = btrfs_make_empty_dir(trans, root, inode->i_ino, dir->i_ino);
 	if (err)
@@ -938,6 +965,8 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 	d_instantiate(dentry, inode);
 	drop_on_err = 0;
 	dir->i_sb->s_dirt = 1;
+	btrfs_update_inode_block_group(trans, inode);
+	btrfs_update_inode_block_group(trans, dir);
 
 out_fail:
 	btrfs_end_transaction(trans, root);
@@ -1349,6 +1378,7 @@ static void btrfs_truncate(struct inode *inode)
 	/* FIXME, add redo link to tree so we don't leak on crash */
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
+	btrfs_set_trans_block_group(trans, inode);
 	ret = btrfs_truncate_in_trans(trans, root, inode);
 	BUG_ON(ret);
 	ret = btrfs_end_transaction(trans, root);
@@ -1445,6 +1475,7 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 
 		mutex_lock(&root->fs_info->fs_mutex);
 		trans = btrfs_start_transaction(root, 1);
+		btrfs_set_trans_block_group(trans, inode);
 
 		bh = page_buffers(pages[i]);
 		if (buffer_mapped(bh) && bh->b_blocknr == 0) {
@@ -1481,6 +1512,7 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 			kunmap(pages[i]);
 		}
 		SetPageChecked(pages[i]);
+		btrfs_update_inode_block_group(trans, inode);
 		ret = btrfs_end_transaction(trans, root);
 		BUG_ON(ret);
 		mutex_unlock(&root->fs_info->fs_mutex);
@@ -1821,6 +1853,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		mutex_unlock(&root->fs_info->fs_mutex);
 		goto out_unlock;
 	}
+	btrfs_set_trans_block_group(trans, inode);
 	/* FIXME blocksize != 4096 */
 	inode->i_blocks += num_blocks << 3;
 	if (start_pos < inode->i_size) {
@@ -1845,6 +1878,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	}
 	BUG_ON(ret);
 	alloc_extent_start = ins.objectid;
+	btrfs_update_inode_block_group(trans, inode);
 	ret = btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
 
@@ -2017,6 +2051,7 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	struct btrfs_leaf *leaf;
 	struct btrfs_root *new_root;
 	struct inode *inode;
+	struct inode *dir;
 	int ret;
 	u64 objectid;
 	u64 new_dirid = BTRFS_FIRST_FREE_OBJECTID;
@@ -2025,7 +2060,7 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	trans = btrfs_start_transaction(root, 1);
 	BUG_ON(!trans);
 
-	subvol = btrfs_alloc_free_block(trans, root);
+	subvol = btrfs_alloc_free_block(trans, root, 0);
 	if (subvol == NULL)
 		return -ENOSPC;
 	leaf = btrfs_buffer_leaf(subvol);
@@ -2069,10 +2104,9 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	 * insert the directory item
 	 */
 	key.offset = (u64)-1;
+	dir = root->fs_info->sb->s_root->d_inode;
 	ret = btrfs_insert_dir_item(trans, root->fs_info->tree_root,
-				    name, namelen,
-				    root->fs_info->sb->s_root->d_inode->i_ino,
-				    &key, 0);
+				    name, namelen, dir->i_ino, &key, 0);
 	BUG_ON(ret);
 
 	ret = btrfs_commit_transaction(trans, root);
@@ -2084,7 +2118,8 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	trans = btrfs_start_transaction(new_root, 1);
 	BUG_ON(!trans);
 
-	inode = btrfs_new_inode(trans, new_root, new_dirid, S_IFDIR | 0700);
+	inode = btrfs_new_inode(trans, new_root, new_dirid,
+				BTRFS_I(dir)->block_group, S_IFDIR | 0700);
 	inode->i_op = &btrfs_dir_inode_operations;
 	inode->i_fop = &btrfs_dir_file_operations;
 

commit 7c4452b9a6ca7aabe37ea2e43d443110bdc08cd8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sat Apr 28 09:29:35 2007 -0400

    Btrfs: smarter transaction writeback
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a10e902d3102..1890e8648dbd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -980,7 +980,6 @@ static int btrfs_sync_fs(struct super_block *sb, int wait)
 		filemap_flush(root->fs_info->btree_inode->i_mapping);
 		return 0;
 	}
-	filemap_write_and_wait(root->fs_info->btree_inode->i_mapping);
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);

commit cd1bc4653dc37f6390f4d6df4f987044c64f700b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Apr 27 10:08:34 2007 -0400

    Btrfs: more block allocator work
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index edcebf79b04a..a10e902d3102 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -223,6 +223,7 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 		btrfs_update_inode(trans, root, dir);
 		drop_nlink(dentry->d_inode);
 		btrfs_update_inode(trans, root, dentry->d_inode);
+		dir->i_sb->s_dirt = 1;
 	}
 	return ret;
 }
@@ -411,6 +412,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 error:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
+	inode->i_sb->s_dirt = 1;
 	return ret;
 }
 
@@ -935,6 +937,7 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 		goto out_fail;
 	d_instantiate(dentry, inode);
 	drop_on_err = 0;
+	dir->i_sb->s_dirt = 1;
 
 out_fail:
 	btrfs_end_transaction(trans, root);

commit 9078a3e1e4e489dddc636c7bb8780349d4298743
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 26 16:46:15 2007 -0400

    Btrfs: start of block group code
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 5bbccbc7e3cc..edcebf79b04a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -377,7 +377,6 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 		if (btrfs_disk_key_objectid(found_key) != inode->i_ino)
 			break;
 		if (btrfs_disk_key_type(found_key) != BTRFS_CSUM_ITEM_KEY &&
-		    btrfs_disk_key_type(found_key) != BTRFS_INLINE_DATA_KEY &&
 		    btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY)
 			break;
 		if (btrfs_disk_key_offset(found_key) < inode->i_size)

commit f68cad0f9eb3c3cc100635bd0ea191ee093cf887
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 24 12:44:26 2007 -0400

    Btrfs: fixup dirty_inode related deadlocks
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c076474c8bff..5bbccbc7e3cc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -120,6 +120,58 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	make_bad_inode(inode);
 }
 
+static void fill_inode_item(struct btrfs_inode_item *item,
+			    struct inode *inode)
+{
+	btrfs_set_inode_uid(item, inode->i_uid);
+	btrfs_set_inode_gid(item, inode->i_gid);
+	btrfs_set_inode_size(item, inode->i_size);
+	btrfs_set_inode_mode(item, inode->i_mode);
+	btrfs_set_inode_nlink(item, inode->i_nlink);
+	btrfs_set_timespec_sec(&item->atime, inode->i_atime.tv_sec);
+	btrfs_set_timespec_nsec(&item->atime, inode->i_atime.tv_nsec);
+	btrfs_set_timespec_sec(&item->mtime, inode->i_mtime.tv_sec);
+	btrfs_set_timespec_nsec(&item->mtime, inode->i_mtime.tv_nsec);
+	btrfs_set_timespec_sec(&item->ctime, inode->i_ctime.tv_sec);
+	btrfs_set_timespec_nsec(&item->ctime, inode->i_ctime.tv_nsec);
+	btrfs_set_inode_nblocks(item, inode->i_blocks);
+	btrfs_set_inode_generation(item, inode->i_generation);
+}
+
+
+static int btrfs_update_inode(struct btrfs_trans_handle *trans,
+			      struct btrfs_root *root,
+			      struct inode *inode)
+{
+	struct btrfs_inode_item *inode_item;
+	struct btrfs_path *path;
+	int ret;
+
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
+	ret = btrfs_lookup_inode(trans, root, path,
+				 &BTRFS_I(inode)->location, 1);
+	if (ret) {
+		if (ret > 0)
+			ret = -ENOENT;
+		goto failed;
+	}
+
+	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+				  path->slots[0],
+				  struct btrfs_inode_item);
+
+	fill_inode_item(inode_item, inode);
+	btrfs_mark_buffer_dirty(path->nodes[0]);
+	ret = 0;
+failed:
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
+	return ret;
+}
+
+
 static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 			      struct btrfs_root *root,
 			      struct inode *dir,
@@ -166,10 +218,11 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 	dentry->d_inode->i_ctime = dir->i_ctime;
 err:
 	btrfs_free_path(path);
-	if (ret == 0) {
-		inode_dec_link_count(dentry->d_inode);
+	if (!ret) {
 		dir->i_size -= name_len * 2;
-		mark_inode_dirty(dir);
+		btrfs_update_inode(trans, root, dir);
+		drop_nlink(dentry->d_inode);
+		btrfs_update_inode(trans, root, dentry->d_inode);
 	}
 	return ret;
 }
@@ -668,56 +721,6 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	return 0;
 }
 
-static void fill_inode_item(struct btrfs_inode_item *item,
-			    struct inode *inode)
-{
-	btrfs_set_inode_uid(item, inode->i_uid);
-	btrfs_set_inode_gid(item, inode->i_gid);
-	btrfs_set_inode_size(item, inode->i_size);
-	btrfs_set_inode_mode(item, inode->i_mode);
-	btrfs_set_inode_nlink(item, inode->i_nlink);
-	btrfs_set_timespec_sec(&item->atime, inode->i_atime.tv_sec);
-	btrfs_set_timespec_nsec(&item->atime, inode->i_atime.tv_nsec);
-	btrfs_set_timespec_sec(&item->mtime, inode->i_mtime.tv_sec);
-	btrfs_set_timespec_nsec(&item->mtime, inode->i_mtime.tv_nsec);
-	btrfs_set_timespec_sec(&item->ctime, inode->i_ctime.tv_sec);
-	btrfs_set_timespec_nsec(&item->ctime, inode->i_ctime.tv_nsec);
-	btrfs_set_inode_nblocks(item, inode->i_blocks);
-	btrfs_set_inode_generation(item, inode->i_generation);
-}
-
-static int btrfs_update_inode(struct btrfs_trans_handle *trans,
-			      struct btrfs_root *root,
-			      struct inode *inode)
-{
-	struct btrfs_inode_item *inode_item;
-	struct btrfs_path *path;
-	int ret;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	btrfs_init_path(path);
-	ret = btrfs_lookup_inode(trans, root, path,
-				 &BTRFS_I(inode)->location, 1);
-	if (ret) {
-		if (ret > 0)
-			ret = -ENOENT;
-		goto failed;
-	}
-
-	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-				  path->slots[0],
-				  struct btrfs_inode_item);
-
-	fill_inode_item(inode_item, inode);
-	btrfs_mark_buffer_dirty(path->nodes[0]);
-	ret = 0;
-failed:
-	btrfs_release_path(root, path);
-	btrfs_free_path(path);
-	return ret;
-}
-
 static int btrfs_write_inode(struct inode *inode, int wait)
 {
 	struct btrfs_root *root = BTRFS_I(inode)->root;

commit c62a1920ced752e86f57ab1d4ad0ec65012bce4d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 24 12:07:39 2007 -0400

    Btrfs: get rid of the extent_item type field
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 43f081593c45..c076474c8bff 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1830,8 +1830,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	if (inode->i_size >= PAGE_CACHE_SIZE || pos + count < inode->i_size ||
 	    pos + count - start_pos > BTRFS_MAX_INLINE_DATA_SIZE(root)) {
 		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
-					 BTRFS_EXTENT_FILE, num_blocks, 1,
-					 (u64)-1, &ins);
+					 num_blocks, 1, (u64)-1, &ins);
 		BUG_ON(ret);
 		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
 				       start_pos, ins.objectid, ins.offset);

commit b51338628f604d9b4ed3c776839a484a30e12fb7
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 24 11:52:22 2007 -0400

    Btrfs: add dirty_inode call
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6940a907654d..43f081593c45 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -722,17 +722,27 @@ static int btrfs_write_inode(struct inode *inode, int wait)
 {
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_trans_handle *trans;
-	int ret;
+	int ret = 0;
+
+	if (wait) {
+		mutex_lock(&root->fs_info->fs_mutex);
+		trans = btrfs_start_transaction(root, 1);
+		ret = btrfs_commit_transaction(trans, root);
+		mutex_unlock(&root->fs_info->fs_mutex);
+	}
+	return ret;
+}
+
+static void btrfs_dirty_inode(struct inode *inode)
+{
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+	struct btrfs_trans_handle *trans;
 
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
-	ret = btrfs_update_inode(trans, root, inode);
-	if (wait)
-		btrfs_commit_transaction(trans, root);
-	else
-		btrfs_end_transaction(trans, root);
+	btrfs_update_inode(trans, root, inode);
+	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
-	return ret;
 }
 
 static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
@@ -2390,6 +2400,7 @@ static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_type = BTRFS_SUPER_MAGIC;
 	return 0;
 }
+
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
@@ -2405,6 +2416,7 @@ static struct super_operations btrfs_super_ops = {
 	.write_super	= btrfs_write_super,
 	.sync_fs	= btrfs_sync_fs,
 	.write_inode	= btrfs_write_inode,
+	.dirty_inode	= btrfs_dirty_inode,
 	.alloc_inode	= btrfs_alloc_inode,
 	.destroy_inode	= btrfs_destroy_inode,
 	.statfs		= btrfs_statfs,

commit 5e82849e63723afe720d4b325d04a989f6247cce
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 23 19:10:49 2007 -0400

    Btrfs: new subvolume oops fix
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index eba239cce212..6940a907654d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -2013,6 +2013,8 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	BUG_ON(!trans);
 
 	subvol = btrfs_alloc_free_block(trans, root);
+	if (subvol == NULL)
+		return -ENOSPC;
 	leaf = btrfs_buffer_leaf(subvol);
 	btrfs_set_header_nritems(&leaf->header, 0);
 	btrfs_set_header_level(&leaf->header, 0);
@@ -2022,8 +2024,6 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	memcpy(leaf->header.fsid, root->fs_info->disk_super->fsid,
 	       sizeof(leaf->header.fsid));
 	mark_buffer_dirty(subvol);
-	brelse(subvol);
-	subvol = NULL;
 
 	inode_item = &root_item.inode;
 	memset(inode_item, 0, sizeof(*inode_item));
@@ -2035,6 +2035,8 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 
 	btrfs_set_root_blocknr(&root_item, bh_blocknr(subvol));
 	btrfs_set_root_refs(&root_item, 1);
+	brelse(subvol);
+	subvol = NULL;
 
 	ret = btrfs_find_free_objectid(trans, root->fs_info->tree_root,
 				       0, &objectid);

commit 4d775673091d43b39fa9d086071009f98dec289e
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Apr 20 20:23:12 2007 -0400

    Btrfs: add owner and type fields to the extents aand block headers
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f99c764a59db..eba239cce212 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1819,8 +1819,9 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	}
 	if (inode->i_size >= PAGE_CACHE_SIZE || pos + count < inode->i_size ||
 	    pos + count - start_pos > BTRFS_MAX_INLINE_DATA_SIZE(root)) {
-		ret = btrfs_alloc_extent(trans, root, num_blocks, 1,
-				 (u64)-1, &ins);
+		ret = btrfs_alloc_extent(trans, root, inode->i_ino,
+					 BTRFS_EXTENT_FILE, num_blocks, 1,
+					 (u64)-1, &ins);
 		BUG_ON(ret);
 		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
 				       start_pos, ins.objectid, ins.offset);
@@ -2017,8 +2018,12 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	btrfs_set_header_level(&leaf->header, 0);
 	btrfs_set_header_blocknr(&leaf->header, bh_blocknr(subvol));
 	btrfs_set_header_generation(&leaf->header, trans->transid);
+	btrfs_set_header_owner(&leaf->header, root->root_key.objectid);
 	memcpy(leaf->header.fsid, root->fs_info->disk_super->fsid,
 	       sizeof(leaf->header.fsid));
+	mark_buffer_dirty(subvol);
+	brelse(subvol);
+	subvol = NULL;
 
 	inode_item = &root_item.inode;
 	memset(inode_item, 0, sizeof(*inode_item));
@@ -2031,10 +2036,6 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	btrfs_set_root_blocknr(&root_item, bh_blocknr(subvol));
 	btrfs_set_root_refs(&root_item, 1);
 
-	mark_buffer_dirty(subvol);
-	brelse(subvol);
-	subvol = NULL;
-
 	ret = btrfs_find_free_objectid(trans, root->fs_info->tree_root,
 				       0, &objectid);
 	BUG_ON(ret);

commit 8fd17795b2261ecb1bad2a6df09ef14c4957a3fb
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 19 21:01:03 2007 -0400

    Btrfs: early fsync support
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index dff2db0d1dc2..f99c764a59db 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -11,6 +11,7 @@
 #include <linux/mpage.h>
 #include <linux/swap.h>
 #include <linux/writeback.h>
+#include <linux/statfs.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -932,6 +933,26 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 	return err;
 }
 
+static int btrfs_sync_file(struct file *file,
+			   struct dentry *dentry, int datasync)
+{
+	struct inode *inode = dentry->d_inode;
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+	int ret;
+	struct btrfs_trans_handle *trans;
+
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	if (!trans) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ret = btrfs_commit_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+out:
+	return ret > 0 ? EIO : ret;
+}
+
 static int btrfs_sync_fs(struct super_block *sb, int wait)
 {
 	struct btrfs_trans_handle *trans;
@@ -2353,6 +2374,19 @@ static int btrfs_getattr(struct vfsmount *mnt,
 	return 0;
 }
 
+static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct btrfs_root *root = btrfs_sb(dentry->d_sb);
+	struct btrfs_super_block *disk_super = root->fs_info->disk_super;
+
+	buf->f_namelen = BTRFS_NAME_LEN;
+	buf->f_blocks = btrfs_super_total_blocks(disk_super);
+	buf->f_bfree = buf->f_blocks - btrfs_super_blocks_used(disk_super);
+	buf->f_bavail = buf->f_bfree;
+	buf->f_bsize = dentry->d_sb->s_blocksize;
+	buf->f_type = BTRFS_SUPER_MAGIC;
+	return 0;
+}
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
@@ -2362,7 +2396,6 @@ static struct file_system_type btrfs_fs_type = {
 };
 
 static struct super_operations btrfs_super_ops = {
-	.statfs		= simple_statfs,
 	.delete_inode	= btrfs_delete_inode,
 	.put_super	= btrfs_put_super,
 	.read_inode	= btrfs_read_locked_inode,
@@ -2371,6 +2404,7 @@ static struct super_operations btrfs_super_ops = {
 	.write_inode	= btrfs_write_inode,
 	.alloc_inode	= btrfs_alloc_inode,
 	.destroy_inode	= btrfs_destroy_inode,
+	.statfs		= btrfs_statfs,
 };
 
 static struct inode_operations btrfs_dir_inode_operations = {
@@ -2413,6 +2447,7 @@ static struct file_operations btrfs_file_operations = {
 	.mmap		= generic_file_mmap,
 	.open		= generic_file_open,
 	.ioctl		= btrfs_ioctl,
+	.fsync		= btrfs_sync_file,
 };
 
 static int __init init_btrfs_fs(void)

commit 7e38180e207c8707691c12395e990a5d583c5e71
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 19 15:36:27 2007 -0400

    Btrfs: directory inode index is back
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 1b286bb26f12..dff2db0d1dc2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -127,32 +127,43 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 	struct btrfs_path *path;
 	const char *name = dentry->d_name.name;
 	int name_len = dentry->d_name.len;
-	int ret;
+	int ret = 0;
 	u64 objectid;
 	struct btrfs_dir_item *di;
 
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	btrfs_init_path(path);
-	ret = btrfs_lookup_dir_item(trans, root, path, dir->i_ino,
+	di = btrfs_lookup_dir_item(trans, root, path, dir->i_ino,
 				    name, name_len, -1);
-	if (ret < 0)
+	if (IS_ERR(di)) {
+		ret = PTR_ERR(di);
 		goto err;
-	if (ret > 0) {
+	}
+	if (!di) {
 		ret = -ENOENT;
 		goto err;
 	}
-	di = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
-			    struct btrfs_dir_item);
 	objectid = btrfs_disk_key_objectid(&di->location);
+	ret = btrfs_delete_one_dir_name(trans, root, path, di);
+	BUG_ON(ret);
+	btrfs_release_path(root, path);
 
-	ret = btrfs_del_item(trans, root, path);
+	di = btrfs_lookup_dir_index_item(trans, root, path, dir->i_ino,
+					 objectid, name, name_len, -1);
+	if (IS_ERR(di)) {
+		ret = PTR_ERR(di);
+		goto err;
+	}
+	if (!di) {
+		ret = -ENOENT;
+		goto err;
+	}
+	ret = btrfs_delete_one_dir_name(trans, root, path, di);
 	BUG_ON(ret);
 
-	btrfs_release_path(root, path);
 	dentry->d_inode->i_ctime = dir->i_ctime;
 err:
-	btrfs_release_path(root, path);
 	btrfs_free_path(path);
 	if (ret == 0) {
 		inode_dec_link_count(dentry->d_inode);
@@ -388,15 +399,13 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	btrfs_init_path(path);
-	ret = btrfs_lookup_dir_item(NULL, root, path, dir->i_ino, name,
+	di = btrfs_lookup_dir_item(NULL, root, path, dir->i_ino, name,
 				    namelen, 0);
-	if (ret || !btrfs_match_dir_item_name(root, path, name, namelen)) {
+	if (!di || IS_ERR(di)) {
 		location->objectid = 0;
 		ret = 0;
 		goto out;
 	}
-	di = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
-			    struct btrfs_dir_item);
 	btrfs_disk_key_to_cpu(location, &di->location);
 out:
 	btrfs_release_path(root, path);
@@ -523,7 +532,10 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	int advance;
 	unsigned char d_type = DT_UNKNOWN;
 	int over = 0;
-	int key_type = BTRFS_DIR_ITEM_KEY;
+	u32 di_cur;
+	u32 di_total;
+	u32 di_len;
+	int key_type = BTRFS_DIR_INDEX_KEY;
 
 	/* FIXME, use a real flag for deciding about the key type */
 	if (root->fs_info->tree_root == root)
@@ -567,12 +579,20 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		filp->f_pos = btrfs_disk_key_offset(&item->key);
 		advance = 1;
 		di = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);
-		over = filldir(dirent, (const char *)(di + 1),
-			       btrfs_dir_name_len(di),
-			       btrfs_disk_key_offset(&item->key),
-			       btrfs_disk_key_objectid(&di->location), d_type);
-		if (over)
-			goto nopos;
+		di_cur = 0;
+		di_total = btrfs_item_size(leaf->items + slot);
+		while(di_cur < di_total) {
+			over = filldir(dirent, (const char *)(di + 1),
+				       btrfs_dir_name_len(di),
+				       btrfs_disk_key_offset(&item->key),
+				       btrfs_disk_key_objectid(&di->location),
+				       d_type);
+			if (over)
+				goto nopos;
+			di_len = btrfs_dir_name_len(di) + sizeof(*di);
+			di_cur += di_len;
+			di = (struct btrfs_dir_item *)((char *)di + di_len);
+		}
 	}
 	filp->f_pos++;
 nopos:
@@ -935,75 +955,6 @@ printk("btrfs sync_fs\n");
 	return 0;
 }
 
-#if 0
-static int btrfs_get_block_inline(struct inode *inode, sector_t iblock,
-			   struct buffer_head *result, int create)
-{
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
-	struct btrfs_path *path;
-	struct btrfs_key key;
-	struct btrfs_leaf *leaf;
-	int num_bytes = result->b_size;
-	int item_size;
-	int ret;
-	u64 pos;
-	char *ptr;
-	int copy_size;
-	int err = 0;
-	char *safe_ptr;
-	char *data_ptr;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-
-	WARN_ON(create);
-	if (create) {
-		return 0;
-	}
-	pos = iblock << inode->i_blkbits;
-	key.objectid = inode->i_ino;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_INLINE_DATA_KEY);
-	ptr = kmap(result->b_page);
-	safe_ptr = ptr;
-	ptr += (pos & (PAGE_CACHE_SIZE -1));
-again:
-	key.offset = pos;
-	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
-	if (ret) {
-		if (ret < 0)
-			err = ret;
-		else
-			err = 0;
-		goto out;
-	}
-	leaf = btrfs_buffer_leaf(path->nodes[0]);
-	item_size = btrfs_item_size(leaf->items + path->slots[0]);
-	copy_size = min(num_bytes, item_size);
-	data_ptr = btrfs_item_ptr(leaf, path->slots[0], char);
-	WARN_ON(safe_ptr + PAGE_CACHE_SIZE < ptr + copy_size);
-	memcpy(ptr, data_ptr, copy_size);
-	pos += copy_size;
-	num_bytes -= copy_size;
-	WARN_ON(num_bytes < 0);
-	ptr += copy_size;
-	btrfs_release_path(root, path);
-	if (num_bytes != 0) {
-		if (pos >= i_size_read(inode))
-			memset(ptr, 0, num_bytes);
-		else
-			goto again;
-	}
-	set_buffer_uptodate(result);
-	map_bh(result, inode->i_sb, 0);
-	err = 0;
-out:
-	btrfs_free_path(path);
-	kunmap(result->b_page);
-	return err;
-}
-#endif
-
 static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 			   struct buffer_head *result, int create)
 {
@@ -1907,174 +1858,6 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	return num_written ? num_written : err;
 }
 
-#if 0
-static ssize_t inline_one_page(struct btrfs_root *root, struct inode *inode,
-			   struct page *page, loff_t pos,
-			   size_t offset, size_t write_bytes)
-{
-	struct btrfs_path *path;
-	struct btrfs_trans_handle *trans;
-	struct btrfs_key key;
-	struct btrfs_leaf *leaf;
-	struct btrfs_key found_key;
-	int ret;
-	size_t copy_size = 0;
-	char *dst = NULL;
-	int err = 0;
-	size_t num_written = 0;
-
-	path = btrfs_alloc_path();
-	BUG_ON(!path);
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-	key.objectid = inode->i_ino;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_INLINE_DATA_KEY);
-
-again:
-	key.offset = pos;
-	ret = btrfs_search_slot(trans, root, &key, path, 0, 1);
-	if (ret < 0) {
-		err = ret;
-		goto out;
-	}
-	if (ret == 0) {
-		leaf = btrfs_buffer_leaf(path->nodes[0]);
-		btrfs_disk_key_to_cpu(&found_key,
-				      &leaf->items[path->slots[0]].key);
-		copy_size = btrfs_item_size(leaf->items + path->slots[0]);
-		dst = btrfs_item_ptr(leaf, path->slots[0], char);
-		copy_size = min(write_bytes, copy_size);
-		goto copyit;
-	} else {
-		int slot = path->slots[0];
-		if (slot > 0) {
-			slot--;
-		}
-		// FIXME find max key
-		leaf = btrfs_buffer_leaf(path->nodes[0]);
-		btrfs_disk_key_to_cpu(&found_key,
-				      &leaf->items[slot].key);
-		if (found_key.objectid != inode->i_ino)
-			goto insert;
-		if (btrfs_key_type(&found_key) != BTRFS_INLINE_DATA_KEY)
-			goto insert;
-		copy_size = btrfs_item_size(leaf->items + slot);
-		if (found_key.offset + copy_size <= pos)
-			goto insert;
-		dst = btrfs_item_ptr(leaf, path->slots[0], char);
-		dst += pos - found_key.offset;
-		copy_size = copy_size - (pos - found_key.offset);
-		BUG_ON(copy_size < 0);
-		copy_size = min(write_bytes, copy_size);
-		WARN_ON(copy_size == 0);
-		goto copyit;
-	}
-insert:
-	btrfs_release_path(root, path);
-	copy_size = min(write_bytes,
-			(size_t)BTRFS_LEAF_DATA_SIZE(root) -
-			sizeof(struct btrfs_item) * 4);
-	ret = btrfs_insert_empty_item(trans, root, path, &key, copy_size);
-	BUG_ON(ret);
-	dst = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-			     path->slots[0], char);
-copyit:
-	WARN_ON(copy_size == 0);
-	WARN_ON(dst + copy_size >
-		btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-						 path->slots[0], char) +
-		btrfs_item_size(btrfs_buffer_leaf(path->nodes[0])->items +
-						  path->slots[0]));
-	btrfs_memcpy(root, path->nodes[0]->b_data, dst,
-		     page_address(page) + offset, copy_size);
-	mark_buffer_dirty(path->nodes[0]);
-	btrfs_release_path(root, path);
-	pos += copy_size;
-	offset += copy_size;
-	num_written += copy_size;
-	write_bytes -= copy_size;
-	if (write_bytes)
-		goto again;
-out:
-	btrfs_free_path(path);
-	ret = btrfs_end_transaction(trans, root);
-	BUG_ON(ret);
-	mutex_unlock(&root->fs_info->fs_mutex);
-	return num_written ? num_written : err;
-}
-
-static ssize_t btrfs_file_inline_write(struct file *file,
-				       const char __user *buf,
-				       size_t count, loff_t *ppos)
-{
-	loff_t pos;
-	size_t num_written = 0;
-	int err = 0;
-	int ret = 0;
-	struct inode *inode = file->f_path.dentry->d_inode;
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-	unsigned long page_index;
-
-	if (file->f_flags & O_DIRECT)
-		return -EINVAL;
-	pos = *ppos;
-
-	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
-	current->backing_dev_info = inode->i_mapping->backing_dev_info;
-	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
-	if (err)
-		goto out;
-	if (count == 0)
-		goto out;
-	err = remove_suid(file->f_path.dentry);
-	if (err)
-		goto out;
-	file_update_time(file);
-	mutex_lock(&inode->i_mutex);
-	while(count > 0) {
-		size_t offset = pos & (PAGE_CACHE_SIZE - 1);
-		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
-		struct page *page;
-
-		page_index = pos >> PAGE_CACHE_SHIFT;
-		page = grab_cache_page(inode->i_mapping, page_index);
-		if (!PageUptodate(page)) {
-			ret = mpage_readpage(page, btrfs_get_block);
-			BUG_ON(ret);
-			lock_page(page);
-		}
-		ret = btrfs_copy_from_user(pos, 1,
-					   write_bytes, &page, buf);
-		BUG_ON(ret);
-		write_bytes = inline_one_page(root, inode, page, pos,
-				      offset, write_bytes);
-		SetPageUptodate(page);
-		if (write_bytes > 0 && pos + write_bytes > inode->i_size) {
-			i_size_write(inode, pos + write_bytes);
-			mark_inode_dirty(inode);
-		}
-		page_cache_release(page);
-		unlock_page(page);
-		if (write_bytes < 0)
-			goto out_unlock;
-		buf += write_bytes;
-		count -= write_bytes;
-		pos += write_bytes;
-		num_written += write_bytes;
-
-		balance_dirty_pages_ratelimited(inode->i_mapping);
-		cond_resched();
-	}
-out_unlock:
-	mutex_unlock(&inode->i_mutex);
-out:
-	*ppos = pos;
-	current->backing_dev_info = NULL;
-	return num_written ? num_written : err;
-}
-#endif
-
 static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
 			unsigned long offset, unsigned long size)
 {
@@ -2422,6 +2205,7 @@ static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_ioctl_vol_args vol_args;
 	int ret = 0;
+	struct btrfs_dir_item *di;
 	int namelen;
 	struct btrfs_path *path;
 	u64 root_dirid;
@@ -2440,12 +2224,12 @@ static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 			return -ENOMEM;
 		root_dirid = root->fs_info->sb->s_root->d_inode->i_ino,
 		mutex_lock(&root->fs_info->fs_mutex);
-		ret = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root,
+		di = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root,
 				    path, root_dirid,
 				    vol_args.name, namelen, 0);
 		mutex_unlock(&root->fs_info->fs_mutex);
 		btrfs_free_path(path);
-		if (ret == 0)
+		if (di && !IS_ERR(di))
 			return -EEXIST;
 
 		if (root == root->fs_info->tree_root)

commit 236454dfffb64a95ee01c50a215153f5de61c475
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 19 13:37:44 2007 -0400

    Btrfs: many file_write fixes, inline data
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 583cd87a62e2..1b286bb26f12 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -317,19 +317,22 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 			break;
 		if (btrfs_disk_key_offset(found_key) < inode->i_size)
 			break;
+		found_extent = 0;
 		if (btrfs_disk_key_type(found_key) == BTRFS_EXTENT_DATA_KEY) {
 			fi = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
 					    path->slots[0],
 					    struct btrfs_file_extent_item);
-			extent_start = btrfs_file_extent_disk_blocknr(fi);
-			extent_num_blocks =
-				btrfs_file_extent_disk_num_blocks(fi);
-			/* FIXME blocksize != 4096 */
-			inode->i_blocks -=
-				btrfs_file_extent_num_blocks(fi) << 3;
-			found_extent = 1;
-		} else {
-			found_extent = 0;
+			if (btrfs_file_extent_type(fi) !=
+			    BTRFS_FILE_EXTENT_INLINE) {
+				extent_start =
+					btrfs_file_extent_disk_blocknr(fi);
+				extent_num_blocks =
+					btrfs_file_extent_disk_num_blocks(fi);
+				/* FIXME blocksize != 4096 */
+				inode->i_blocks -=
+					btrfs_file_extent_num_blocks(fi) << 3;
+				found_extent = 1;
+			}
 		}
 		ret = btrfs_del_item(trans, root, path);
 		BUG_ON(ret);
@@ -1010,9 +1013,9 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	u64 extent_start = 0;
 	u64 extent_end = 0;
 	u64 objectid = inode->i_ino;
+	u32 found_type;
 	struct btrfs_path *path;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct btrfs_trans_handle *trans = NULL;
 	struct btrfs_file_extent_item *item;
 	struct btrfs_leaf *leaf;
 	struct btrfs_disk_key *found_key;
@@ -1021,13 +1024,12 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	BUG_ON(!path);
 	btrfs_init_path(path);
 	if (create) {
-		trans = btrfs_start_transaction(root, 1);
 		WARN_ON(1);
 	}
 
-	ret = btrfs_lookup_file_extent(trans, root, path,
+	ret = btrfs_lookup_file_extent(NULL, root, path,
 				       inode->i_ino,
-				       iblock << inode->i_blkbits, create);
+				       iblock << inode->i_blkbits, 0);
 	if (ret < 0) {
 		err = ret;
 		goto out;
@@ -1036,7 +1038,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	if (ret != 0) {
 		if (path->slots[0] == 0) {
 			btrfs_release_path(root, path);
-			goto allocate;
+			goto out;
 		}
 		path->slots[0]--;
 	}
@@ -1047,73 +1049,51 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	blocknr = btrfs_file_extent_disk_blocknr(item);
 	blocknr += btrfs_file_extent_offset(item);
 
-	/* exact match found, use it, FIXME, deal with extents
-	 * other than the page size
-	 */
-	if (0 && ret == 0) {
-		err = 0;
-		if (create &&
-		    btrfs_file_extent_generation(item) != trans->transid) {
-			struct btrfs_key ins;
-			ret = btrfs_alloc_extent(trans, root, 1,
-						 blocknr, (u64)-1, &ins);
-			BUG_ON(ret);
-			btrfs_set_file_extent_disk_blocknr(item, ins.objectid);
-			mark_buffer_dirty(path->nodes[0]);
-			ret = btrfs_free_extent(trans, root,
-						blocknr, 1, 0);
-			BUG_ON(ret);
-			blocknr = ins.objectid;
-
-		}
-		btrfs_map_bh_to_logical(root, result, blocknr);
-		goto out;
-	}
-
 	/* are we inside the extent that was found? */
 	found_key = &leaf->items[path->slots[0]].key;
+	found_type = btrfs_disk_key_type(found_key);
 	if (btrfs_disk_key_objectid(found_key) != objectid ||
-	    btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY) {
+	    found_type != BTRFS_EXTENT_DATA_KEY) {
 		extent_end = 0;
 		extent_start = 0;
 		btrfs_release_path(root, path);
-		goto allocate;
-	}
-
-	extent_start = btrfs_disk_key_offset(&leaf->items[path->slots[0]].key);
-	extent_start = extent_start >> inode->i_blkbits;
-	extent_end = extent_start + btrfs_file_extent_num_blocks(item);
-	if (iblock >= extent_start && iblock < extent_end) {
-		err = 0;
-		btrfs_map_bh_to_logical(root, result, blocknr + iblock -
-					extent_start);
-		goto out;
-	}
-allocate:
-	/* ok, create a new extent */
-	if (!create) {
-		err = 0;
 		goto out;
 	}
-#if 0
-	ret = btrfs_alloc_file_extent(trans, root, objectid,
-				      iblock << inode->i_blkbits,
-				      1, extent_end, &blocknr);
-	if (ret) {
-		err = ret;
-		goto out;
+	found_type = btrfs_file_extent_type(item);
+	extent_start = btrfs_disk_key_offset(&leaf->items[path->slots[0]].key);
+	if (found_type == BTRFS_FILE_EXTENT_REG) {
+		extent_start = extent_start >> inode->i_blkbits;
+		extent_end = extent_start + btrfs_file_extent_num_blocks(item);
+		if (iblock >= extent_start && iblock < extent_end) {
+			err = 0;
+			btrfs_map_bh_to_logical(root, result, blocknr +
+						iblock - extent_start);
+			goto out;
+		}
+	} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {
+		char *ptr;
+		char *map;
+		u32 size;
+		size = btrfs_file_extent_inline_len(leaf->items +
+						    path->slots[0]);
+		extent_end = (extent_start + size) >> inode->i_blkbits;
+		extent_start >>= inode->i_blkbits;
+		if (iblock < extent_start || iblock > extent_end) {
+			goto out;
+		}
+		ptr = btrfs_file_extent_inline_start(item);
+		map = kmap(result->b_page);
+		memcpy(map, ptr, size);
+		memset(map + size, 0, PAGE_CACHE_SIZE - size);
+		flush_dcache_page(result->b_page);
+		kunmap(result->b_page);
+		set_buffer_uptodate(result);
+		SetPageChecked(result->b_page);
+		btrfs_map_bh_to_logical(root, result, 0);
 	}
-	inode->i_blocks += inode->i_sb->s_blocksize >> 9;
-	set_buffer_new(result);
-	map_bh(result, inode->i_sb, blocknr);
-
-	btrfs_map_bh_to_logical(root, result, blocknr);
-#endif
 out:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
-	if (trans)
-		btrfs_end_transaction(trans, root);
 	return err;
 }
 
@@ -1124,7 +1104,6 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	mutex_lock(&root->fs_info->fs_mutex);
 	err = btrfs_get_block_lock(inode, iblock, result, create);
-	// err = btrfs_get_block_inline(inode, iblock, result, create);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	return err;
 }
@@ -1134,11 +1113,6 @@ static int btrfs_prepare_write(struct file *file, struct page *page,
 {
 	return nobh_prepare_write(page, from, to, btrfs_get_block);
 }
-static int btrfs_commit_write(struct file *file, struct page *page,
-			       unsigned from, unsigned to)
-{
-	return nobh_commit_write(file, page, from, to);
-}
 
 static void btrfs_write_super(struct super_block *sb)
 {
@@ -1150,9 +1124,227 @@ static int btrfs_readpage(struct file *file, struct page *page)
 	return mpage_readpage(page, btrfs_get_block);
 }
 
+/*
+ * While block_write_full_page is writing back the dirty buffers under
+ * the page lock, whoever dirtied the buffers may decide to clean them
+ * again at any time.  We handle that by only looking at the buffer
+ * state inside lock_buffer().
+ *
+ * If block_write_full_page() is called for regular writeback
+ * (wbc->sync_mode == WB_SYNC_NONE) then it will redirty a page which has a
+ * locked buffer.   This only can happen if someone has written the buffer
+ * directly, with submit_bh().  At the address_space level PageWriteback
+ * prevents this contention from occurring.
+ */
+static int __btrfs_write_full_page(struct inode *inode, struct page *page,
+				   struct writeback_control *wbc)
+{
+	int err;
+	sector_t block;
+	sector_t last_block;
+	struct buffer_head *bh, *head;
+	const unsigned blocksize = 1 << inode->i_blkbits;
+	int nr_underway = 0;
+
+	BUG_ON(!PageLocked(page));
+
+	last_block = (i_size_read(inode) - 1) >> inode->i_blkbits;
+
+	if (!page_has_buffers(page)) {
+		create_empty_buffers(page, blocksize,
+					(1 << BH_Dirty)|(1 << BH_Uptodate));
+	}
+
+	/*
+	 * Be very careful.  We have no exclusion from __set_page_dirty_buffers
+	 * here, and the (potentially unmapped) buffers may become dirty at
+	 * any time.  If a buffer becomes dirty here after we've inspected it
+	 * then we just miss that fact, and the page stays dirty.
+	 *
+	 * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;
+	 * handle that here by just cleaning them.
+	 */
+
+	block = (sector_t)page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
+	head = page_buffers(page);
+	bh = head;
+
+	/*
+	 * Get all the dirty buffers mapped to disk addresses and
+	 * handle any aliases from the underlying blockdev's mapping.
+	 */
+	do {
+		if (block > last_block) {
+			/*
+			 * mapped buffers outside i_size will occur, because
+			 * this page can be outside i_size when there is a
+			 * truncate in progress.
+			 */
+			/*
+			 * The buffer was zeroed by block_write_full_page()
+			 */
+			clear_buffer_dirty(bh);
+			set_buffer_uptodate(bh);
+		} else if (!buffer_mapped(bh) && buffer_dirty(bh)) {
+			WARN_ON(bh->b_size != blocksize);
+			err = btrfs_get_block(inode, block, bh, 0);
+			if (err)
+				goto recover;
+			if (buffer_new(bh)) {
+				/* blockdev mappings never come here */
+				clear_buffer_new(bh);
+				unmap_underlying_metadata(bh->b_bdev,
+							bh->b_blocknr);
+			}
+		}
+		bh = bh->b_this_page;
+		block++;
+	} while (bh != head);
+
+	do {
+		if (!buffer_mapped(bh))
+			continue;
+		/*
+		 * If it's a fully non-blocking write attempt and we cannot
+		 * lock the buffer then redirty the page.  Note that this can
+		 * potentially cause a busy-wait loop from pdflush and kswapd
+		 * activity, but those code paths have their own higher-level
+		 * throttling.
+		 */
+		if (wbc->sync_mode != WB_SYNC_NONE || !wbc->nonblocking) {
+			lock_buffer(bh);
+		} else if (test_set_buffer_locked(bh)) {
+			redirty_page_for_writepage(wbc, page);
+			continue;
+		}
+		if (test_clear_buffer_dirty(bh) && bh->b_blocknr != 0) {
+			mark_buffer_async_write(bh);
+		} else {
+			unlock_buffer(bh);
+		}
+	} while ((bh = bh->b_this_page) != head);
+
+	/*
+	 * The page and its buffers are protected by PageWriteback(), so we can
+	 * drop the bh refcounts early.
+	 */
+	BUG_ON(PageWriteback(page));
+	set_page_writeback(page);
+
+	do {
+		struct buffer_head *next = bh->b_this_page;
+		if (buffer_async_write(bh)) {
+			submit_bh(WRITE, bh);
+			nr_underway++;
+		}
+		bh = next;
+	} while (bh != head);
+	unlock_page(page);
+
+	err = 0;
+done:
+	if (nr_underway == 0) {
+		/*
+		 * The page was marked dirty, but the buffers were
+		 * clean.  Someone wrote them back by hand with
+		 * ll_rw_block/submit_bh.  A rare case.
+		 */
+		int uptodate = 1;
+		do {
+			if (!buffer_uptodate(bh)) {
+				uptodate = 0;
+				break;
+			}
+			bh = bh->b_this_page;
+		} while (bh != head);
+		if (uptodate)
+			SetPageUptodate(page);
+		end_page_writeback(page);
+		/*
+		 * The page and buffer_heads can be released at any time from
+		 * here on.
+		 */
+		wbc->pages_skipped++;	/* We didn't write this page */
+	}
+	return err;
+
+recover:
+	/*
+	 * ENOSPC, or some other error.  We may already have added some
+	 * blocks to the file, so we need to write these out to avoid
+	 * exposing stale data.
+	 * The page is currently locked and not marked for writeback
+	 */
+	bh = head;
+	/* Recovery: lock and submit the mapped buffers */
+	do {
+		if (buffer_mapped(bh) && buffer_dirty(bh)) {
+			lock_buffer(bh);
+			mark_buffer_async_write(bh);
+		} else {
+			/*
+			 * The buffer may have been set dirty during
+			 * attachment to a dirty page.
+			 */
+			clear_buffer_dirty(bh);
+		}
+	} while ((bh = bh->b_this_page) != head);
+	SetPageError(page);
+	BUG_ON(PageWriteback(page));
+	set_page_writeback(page);
+	do {
+		struct buffer_head *next = bh->b_this_page;
+		if (buffer_async_write(bh)) {
+			clear_buffer_dirty(bh);
+			submit_bh(WRITE, bh);
+			nr_underway++;
+		}
+		bh = next;
+	} while (bh != head);
+	unlock_page(page);
+	goto done;
+}
+
+/*
+ * The generic ->writepage function for buffer-backed address_spaces
+ */
 static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 {
-	return nobh_writepage(page, btrfs_get_block, wbc);
+	struct inode * const inode = page->mapping->host;
+	loff_t i_size = i_size_read(inode);
+	const pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;
+	unsigned offset;
+	void *kaddr;
+
+	/* Is the page fully inside i_size? */
+	if (page->index < end_index)
+		return __btrfs_write_full_page(inode, page, wbc);
+
+	/* Is the page fully outside i_size? (truncate in progress) */
+	offset = i_size & (PAGE_CACHE_SIZE-1);
+	if (page->index >= end_index+1 || !offset) {
+		/*
+		 * The page may have dirty, unmapped buffers.  For example,
+		 * they may have been added in ext3_writepage().  Make them
+		 * freeable here, so the page does not leak.
+		 */
+		block_invalidatepage(page, 0);
+		unlock_page(page);
+		return 0; /* don't care */
+	}
+
+	/*
+	 * The page straddles i_size.  It must be zeroed out on each and every
+	 * writepage invokation because it may be mmapped.  "A file is mapped
+	 * in multiples of the page size.  For a file that is not a multiple of
+	 * the  page size, the remaining memory is zeroed when mapped, and
+	 * writes to that region are not written out to the file."
+	 */
+	kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + offset, 0, PAGE_CACHE_SIZE - offset);
+	flush_dcache_page(page);
+	kunmap_atomic(kaddr, KM_USER0);
+	return __btrfs_write_full_page(inode, page, wbc);
 }
 
 static void btrfs_truncate(struct inode *inode)
@@ -1179,6 +1371,29 @@ static void btrfs_truncate(struct inode *inode)
 	mark_inode_dirty(inode);
 }
 
+/*
+ * Make sure any changes to nobh_commit_write() are reflected in
+ * nobh_truncate_page(), since it doesn't call commit_write().
+ */
+static int btrfs_commit_write(struct file *file, struct page *page,
+			      unsigned from, unsigned to)
+{
+	struct inode *inode = page->mapping->host;
+	struct buffer_head *bh;
+	loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
+
+	SetPageUptodate(page);
+	bh = page_buffers(page);
+	if (buffer_mapped(bh) && bh->b_blocknr != 0) {
+		set_page_dirty(page);
+	}
+	if (pos > inode->i_size) {
+		i_size_write(inode, pos);
+		mark_inode_dirty(inode);
+	}
+	return 0;
+}
+
 static int btrfs_copy_from_user(loff_t pos, int num_pages, int write_bytes,
 				struct page **prepared_pages,
 				const char __user * buf)
@@ -1234,6 +1449,8 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 	int ret;
 	int this_write;
 	struct inode *inode = file->f_path.dentry->d_inode;
+	struct buffer_head *bh;
+	struct btrfs_file_extent_item *ei;
 
 	for (i = 0; i < num_pages; i++) {
 		offset = pos & (PAGE_CACHE_SIZE -1);
@@ -1242,16 +1459,47 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 
 		mutex_lock(&root->fs_info->fs_mutex);
 		trans = btrfs_start_transaction(root, 1);
-		btrfs_csum_file_block(trans, root, inode->i_ino,
+
+		bh = page_buffers(pages[i]);
+		if (buffer_mapped(bh) && bh->b_blocknr == 0) {
+			struct btrfs_key key;
+			struct btrfs_path *path;
+			char *ptr;
+			u32 datasize;
+
+			path = btrfs_alloc_path();
+			BUG_ON(!path);
+			key.objectid = inode->i_ino;
+			key.offset = pages[i]->index << PAGE_CACHE_SHIFT;
+			key.flags = 0;
+			btrfs_set_key_type(&key, BTRFS_EXTENT_DATA_KEY);
+			BUG_ON(write_bytes >= PAGE_CACHE_SIZE);
+			datasize = offset +
+				btrfs_file_extent_calc_inline_size(write_bytes);
+			ret = btrfs_insert_empty_item(trans, root, path, &key,
+						      datasize);
+			BUG_ON(ret);
+			ei = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+			       path->slots[0], struct btrfs_file_extent_item);
+			btrfs_set_file_extent_generation(ei, trans->transid);
+			btrfs_set_file_extent_type(ei,
+						   BTRFS_FILE_EXTENT_INLINE);
+			ptr = btrfs_file_extent_inline_start(ei);
+			memcpy(ptr, bh->b_data, offset + write_bytes);
+			mark_buffer_dirty(path->nodes[0]);
+			btrfs_free_path(path);
+		} else {
+			btrfs_csum_file_block(trans, root, inode->i_ino,
 				      pages[i]->index << PAGE_CACHE_SHIFT,
 				      kmap(pages[i]), PAGE_CACHE_SIZE);
-		kunmap(pages[i]);
+			kunmap(pages[i]);
+		}
 		SetPageChecked(pages[i]);
 		ret = btrfs_end_transaction(trans, root);
 		BUG_ON(ret);
 		mutex_unlock(&root->fs_info->fs_mutex);
 
-		ret = nobh_commit_write(file, pages[i], offset,
+		ret = btrfs_commit_write(file, pages[i], offset,
 					 offset + this_write);
 		pos += this_write;
 		if (ret) {
@@ -1275,12 +1523,16 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 	struct btrfs_leaf *leaf;
 	int slot;
 	struct btrfs_file_extent_item *extent;
-	u64 extent_end;
+	u64 extent_end = 0;
 	int keep;
 	struct btrfs_file_extent_item old;
 	struct btrfs_path *path;
 	u64 search_start = start;
 	int bookend;
+	int found_type;
+	int found_extent;
+	int found_inline;
+
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
@@ -1292,37 +1544,62 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			goto out;
 		if (ret > 0) {
 			if (path->slots[0] == 0) {
-				ret = -ENOENT;
+				ret = 0;
 				goto out;
 			}
 			path->slots[0]--;
 		}
 		keep = 0;
 		bookend = 0;
+		found_extent = 0;
+		found_inline = 0;
+		extent = NULL;
 		leaf = btrfs_buffer_leaf(path->nodes[0]);
 		slot = path->slots[0];
 		btrfs_disk_key_to_cpu(&key, &leaf->items[slot].key);
-		extent = btrfs_item_ptr(leaf, slot,
-					struct btrfs_file_extent_item);
-		extent_end = key.offset +
-			(btrfs_file_extent_num_blocks(extent) <<
-			 inode->i_blkbits);
 		if (key.offset >= end || key.objectid != inode->i_ino) {
 			ret = 0;
 			goto out;
 		}
-		if (btrfs_key_type(&key) != BTRFS_EXTENT_DATA_KEY)
+		if (btrfs_key_type(&key) != BTRFS_EXTENT_DATA_KEY) {
+			ret = 0;
+			goto out;
+		}
+		extent = btrfs_item_ptr(leaf, slot,
+					struct btrfs_file_extent_item);
+		found_type = btrfs_file_extent_type(extent);
+		if (found_type == BTRFS_FILE_EXTENT_REG) {
+			extent_end = key.offset +
+				(btrfs_file_extent_num_blocks(extent) <<
+				 inode->i_blkbits);
+			found_extent = 1;
+		} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {
+			found_inline = 1;
+			extent_end = key.offset +
+			     btrfs_file_extent_inline_len(leaf->items + slot);
+		}
+
+		if (!found_extent && !found_inline) {
+			ret = 0;
 			goto out;
-		if (search_start >= extent_end)
+		}
+
+		if (search_start >= extent_end) {
+			ret = 0;
 			goto out;
+		}
+
 		search_start = extent_end;
 
 		if (end < extent_end && end >= key.offset) {
-			memcpy(&old, extent, sizeof(old));
-			ret = btrfs_inc_extent_ref(trans, root,
-				   btrfs_file_extent_disk_blocknr(&old),
-				   btrfs_file_extent_disk_num_blocks(&old));
-			BUG_ON(ret);
+			if (found_extent) {
+				memcpy(&old, extent, sizeof(old));
+				ret = btrfs_inc_extent_ref(trans, root,
+				      btrfs_file_extent_disk_blocknr(&old),
+				      btrfs_file_extent_disk_num_blocks(&old));
+				BUG_ON(ret);
+			}
+			WARN_ON(found_inline);
 			bookend = 1;
 		}
 
@@ -1332,25 +1609,45 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			/* truncate existing extent */
 			keep = 1;
 			WARN_ON(start & (root->blocksize - 1));
-			new_num = (start - key.offset) >> inode->i_blkbits;
-			old_num = btrfs_file_extent_num_blocks(extent);
-			inode->i_blocks -= (old_num - new_num) << 3;
-			btrfs_set_file_extent_num_blocks(extent, new_num);
-			mark_buffer_dirty(path->nodes[0]);
+			if (found_extent) {
+				new_num = (start - key.offset) >>
+					inode->i_blkbits;
+				old_num = btrfs_file_extent_num_blocks(extent);
+				inode->i_blocks -= (old_num - new_num) << 3;
+				btrfs_set_file_extent_num_blocks(extent,
+								 new_num);
+				mark_buffer_dirty(path->nodes[0]);
+			} else {
+				WARN_ON(1);
+				/*
+				ret = btrfs_truncate_item(trans, root, path,
+							  start - key.offset);
+				BUG_ON(ret);
+				*/
+			}
 		}
 		if (!keep) {
-			u64 disk_blocknr;
-			u64 disk_num_blocks;
-			disk_blocknr = btrfs_file_extent_disk_blocknr(extent);
-			disk_num_blocks =
-				btrfs_file_extent_disk_num_blocks(extent);
+			u64 disk_blocknr = 0;
+			u64 disk_num_blocks = 0;
+			u64 extent_num_blocks = 0;
+			if (found_extent) {
+				disk_blocknr =
+				      btrfs_file_extent_disk_blocknr(extent);
+				disk_num_blocks =
+				      btrfs_file_extent_disk_num_blocks(extent);
+				extent_num_blocks =
+				      btrfs_file_extent_num_blocks(extent);
+			}
 			ret = btrfs_del_item(trans, root, path);
 			BUG_ON(ret);
-			inode->i_blocks -=
-				btrfs_file_extent_num_blocks(extent) << 3;
 			btrfs_release_path(root, path);
-			ret = btrfs_free_extent(trans, root, disk_blocknr,
-						disk_num_blocks, 0);
+			if (found_extent) {
+				inode->i_blocks -=
+				btrfs_file_extent_num_blocks(extent) << 3;
+				ret = btrfs_free_extent(trans, root,
+							disk_blocknr,
+							disk_num_blocks, 0);
+			}
 
 			BUG_ON(ret);
 			if (!bookend && search_start >= end) {
@@ -1360,7 +1657,7 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			if (!bookend)
 				continue;
 		}
-		if (bookend) {
+		if (bookend && found_extent) {
 			/* create bookend */
 			struct btrfs_key ins;
 			ins.objectid = inode->i_ino;
@@ -1390,6 +1687,8 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 				    btrfs_file_extent_num_blocks(&old) -
 				    ((end - key.offset) >> inode->i_blkbits));
 
+			btrfs_set_file_extent_type(extent,
+						   BTRFS_FILE_EXTENT_REG);
 			btrfs_set_file_extent_generation(extent,
 				    btrfs_file_extent_generation(&old));
 			btrfs_mark_buffer_dirty(path->nodes[0]);
@@ -1445,7 +1744,8 @@ static int prepare_pages(struct btrfs_root *root,
 			if (err)
 				goto failed_truncate;
 			bh = bh->b_this_page;
-			alloc_extent_start++;
+			if (alloc_extent_start)
+				alloc_extent_start++;
 		} while (bh != head);
 		pos += this_write;
 		WARN_ON(this_write > write_bytes);
@@ -1543,12 +1843,20 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 				   start_pos,
 				   (pos + count + root->blocksize -1) &
 				   ~((u64)root->blocksize - 1));
+		BUG_ON(ret);
 	}
-	ret = btrfs_alloc_extent(trans, root, num_blocks, 1,
+	if (inode->i_size >= PAGE_CACHE_SIZE || pos + count < inode->i_size ||
+	    pos + count - start_pos > BTRFS_MAX_INLINE_DATA_SIZE(root)) {
+		ret = btrfs_alloc_extent(trans, root, num_blocks, 1,
 				 (u64)-1, &ins);
-	BUG_ON(ret);
-	ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
+		BUG_ON(ret);
+		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
 				       start_pos, ins.objectid, ins.offset);
+		BUG_ON(ret);
+	} else {
+		ins.offset = 0;
+		ins.objectid = 0;
+	}
 	BUG_ON(ret);
 	alloc_extent_start = ins.objectid;
 	ret = btrfs_end_transaction(trans, root);
@@ -1567,7 +1875,8 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		BUG_ON(ret);
 
 		/* FIXME blocks != pagesize */
-		alloc_extent_start += num_pages;
+		if (alloc_extent_start)
+			alloc_extent_start += num_pages;
 		ret = btrfs_copy_from_user(pos, num_pages,
 					   write_bytes, pages, buf);
 		BUG_ON(ret);
@@ -1779,10 +2088,11 @@ static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
 	if (!PageChecked(page)) {
 		/* FIXME, do it per block */
 		struct btrfs_root *root = BTRFS_I(inode)->root;
+
 		int ret = btrfs_csum_verify_file_block(root,
-					  page->mapping->host->i_ino,
-					  page->index << PAGE_CACHE_SHIFT,
-					  kmap(page), PAGE_CACHE_SIZE);
+				  page->mapping->host->i_ino,
+				  page->index << PAGE_CACHE_SHIFT,
+				  kmap(page), PAGE_CACHE_SIZE);
 		if (ret) {
 			printk("failed to verify ino %lu page %lu\n",
 			       page->mapping->host->i_ino,
@@ -2249,6 +2559,16 @@ static int btrfs_get_sb(struct file_system_type *fs_type,
 			   btrfs_fill_super, mnt);
 }
 
+
+static int btrfs_getattr(struct vfsmount *mnt,
+			 struct dentry *dentry, struct kstat *stat)
+{
+	struct inode *inode = dentry->d_inode;
+	generic_fillattr(inode, stat);
+	stat->blksize = 256 * 1024;
+	return 0;
+}
+
 static struct file_system_type btrfs_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "btrfs",
@@ -2298,6 +2618,7 @@ static struct address_space_operations btrfs_aops = {
 
 static struct inode_operations btrfs_file_inode_operations = {
 	.truncate	= btrfs_truncate,
+	.getattr	= btrfs_getattr,
 };
 
 static struct file_operations btrfs_file_operations = {

commit a429e51371eee3c989160c003ee40bc3947c6a76
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 18 16:15:28 2007 -0400

    Btrfs: working file_write, reorganized key flags
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b2a2220d1352..583cd87a62e2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -150,11 +150,6 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 	BUG_ON(ret);
 
 	btrfs_release_path(root, path);
-	ret = btrfs_lookup_dir_index_item(trans, root, path, dir->i_ino,
-					  objectid, -1);
-	BUG_ON(ret);
-	ret = btrfs_del_item(trans, root, path);
-	BUG_ON(ret);
 	dentry->d_inode->i_ctime = dir->i_ctime;
 err:
 	btrfs_release_path(root, path);
@@ -329,8 +324,9 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 			extent_start = btrfs_file_extent_disk_blocknr(fi);
 			extent_num_blocks =
 				btrfs_file_extent_disk_num_blocks(fi);
+			/* FIXME blocksize != 4096 */
 			inode->i_blocks -=
-				btrfs_file_extent_num_blocks(fi) >> 9;
+				btrfs_file_extent_num_blocks(fi) << 3;
 			found_extent = 1;
 		} else {
 			found_extent = 0;
@@ -562,7 +558,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
 			break;
 		if (btrfs_disk_key_type(&item->key) != key_type)
-			continue;
+			break;
 		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)
 			continue;
 		filp->f_pos = btrfs_disk_key_offset(&item->key);
@@ -1285,29 +1281,27 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 	struct btrfs_path *path;
 	u64 search_start = start;
 	int bookend;
-
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
-search_again:
-	ret = btrfs_lookup_file_extent(trans, root, path, inode->i_ino,
-				       search_start, -1);
-	if (ret < 0)
-		goto out;
-	if (ret > 0) {
-		if (path->slots[0] == 0) {
-			ret = -ENOENT;
+	while(1) {
+		btrfs_release_path(root, path);
+		ret = btrfs_lookup_file_extent(trans, root, path, inode->i_ino,
+					       search_start, -1);
+		if (ret < 0)
 			goto out;
+		if (ret > 0) {
+			if (path->slots[0] == 0) {
+				ret = -ENOENT;
+				goto out;
+			}
+			path->slots[0]--;
 		}
-		path->slots[0]--;
-	}
-	while(1) {
 		keep = 0;
 		bookend = 0;
 		leaf = btrfs_buffer_leaf(path->nodes[0]);
 		slot = path->slots[0];
 		btrfs_disk_key_to_cpu(&key, &leaf->items[slot].key);
-
 		extent = btrfs_item_ptr(leaf, slot,
 					struct btrfs_file_extent_item);
 		extent_end = key.offset +
@@ -1318,7 +1312,10 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			goto out;
 		}
 		if (btrfs_key_type(&key) != BTRFS_EXTENT_DATA_KEY)
-			goto next_leaf;
+			goto out;
+		if (search_start >= extent_end)
+			goto out;
+		search_start = extent_end;
 
 		if (end < extent_end && end >= key.offset) {
 			memcpy(&old, extent, sizeof(old));
@@ -1331,10 +1328,13 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 
 		if (start > key.offset) {
 			u64 new_num;
+			u64 old_num;
 			/* truncate existing extent */
 			keep = 1;
 			WARN_ON(start & (root->blocksize - 1));
 			new_num = (start - key.offset) >> inode->i_blkbits;
+			old_num = btrfs_file_extent_num_blocks(extent);
+			inode->i_blocks -= (old_num - new_num) << 3;
 			btrfs_set_file_extent_num_blocks(extent, new_num);
 			mark_buffer_dirty(path->nodes[0]);
 		}
@@ -1344,13 +1344,11 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			disk_blocknr = btrfs_file_extent_disk_blocknr(extent);
 			disk_num_blocks =
 				btrfs_file_extent_disk_num_blocks(extent);
-			search_start = key.offset +
-				(btrfs_file_extent_num_blocks(extent) <<
-				inode->i_blkbits);
 			ret = btrfs_del_item(trans, root, path);
 			BUG_ON(ret);
+			inode->i_blocks -=
+				btrfs_file_extent_num_blocks(extent) << 3;
 			btrfs_release_path(root, path);
-
 			ret = btrfs_free_extent(trans, root, disk_blocknr,
 						disk_num_blocks, 0);
 
@@ -1360,7 +1358,7 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 				goto out;
 			}
 			if (!bookend)
-				goto search_again;
+				continue;
 		}
 		if (bookend) {
 			/* create bookend */
@@ -1395,21 +1393,12 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 			btrfs_set_file_extent_generation(extent,
 				    btrfs_file_extent_generation(&old));
 			btrfs_mark_buffer_dirty(path->nodes[0]);
+			inode->i_blocks +=
+				btrfs_file_extent_num_blocks(extent) << 3;
 			ret = 0;
 			goto out;
 		}
-next_leaf:
-		if (slot >= btrfs_header_nritems(&leaf->header) - 1) {
-			ret = btrfs_next_leaf(root, path);
-			if (ret) {
-				ret = 0;
-				goto out;
-			}
-		} else {
-			path->slots[0]++;
-		}
 	}
-
 out:
 	btrfs_free_path(path);
 	return ret;
@@ -1445,15 +1434,6 @@ static int prepare_pages(struct btrfs_root *root,
 		}
 		offset = pos & (PAGE_CACHE_SIZE -1);
 		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
-#if 0
-		if ((pages[i]->index == first_index ||
-		    pages[i]->index == last_index) && pos < isize &&
-		    !PageUptodate(pages[i])) {
-			ret = mpage_readpage(pages[i], btrfs_get_block);
-			BUG_ON(ret);
-			lock_page(pages[i]);
-		}
-#endif
 		create_empty_buffers(pages[i], root->fs_info->sb->s_blocksize,
 				     (1 << BH_Uptodate));
 		head = page_buffers(pages[i]);
@@ -1494,6 +1474,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct page *pages[8];
+	struct page *pinned[2] = { NULL, NULL };
 	unsigned long first_index;
 	unsigned long last_index;
 	u64 start_pos;
@@ -1505,14 +1486,6 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	if (file->f_flags & O_DIRECT)
 		return -EINVAL;
 	pos = *ppos;
-
-	start_pos = pos & ~(root->blocksize - 1);
-	/* FIXME */
-	if (start_pos != pos)
-		return -EINVAL;
-	num_blocks = (count + pos - start_pos + root->blocksize - 1) >>
-			inode->i_blkbits;
-
 	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
 	current->backing_dev_info = inode->i_mapping->backing_dev_info;
 	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
@@ -1524,10 +1497,37 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	if (err)
 		goto out;
 	file_update_time(file);
+
+	start_pos = pos & ~((u64)PAGE_CACHE_SIZE - 1);
+	num_blocks = (count + pos - start_pos + root->blocksize - 1) >>
+			inode->i_blkbits;
+
 	mutex_lock(&inode->i_mutex);
 	first_index = pos >> PAGE_CACHE_SHIFT;
 	last_index = (pos + count) >> PAGE_CACHE_SHIFT;
 
+	if ((first_index << PAGE_CACHE_SHIFT) < inode->i_size &&
+	    (pos & (PAGE_CACHE_SIZE - 1))) {
+		pinned[0] = grab_cache_page(inode->i_mapping, first_index);
+		if (!PageUptodate(pinned[0])) {
+			ret = mpage_readpage(pinned[0], btrfs_get_block);
+			BUG_ON(ret);
+		} else {
+			unlock_page(pinned[0]);
+		}
+	}
+	if (first_index != last_index &&
+	    (last_index << PAGE_CACHE_SHIFT) < inode->i_size &&
+	    (count & (PAGE_CACHE_SIZE - 1))) {
+		pinned[1] = grab_cache_page(inode->i_mapping, last_index);
+		if (!PageUptodate(pinned[1])) {
+			ret = mpage_readpage(pinned[1], btrfs_get_block);
+			BUG_ON(ret);
+		} else {
+			unlock_page(pinned[1]);
+		}
+	}
+
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	if (!trans) {
@@ -1535,11 +1535,14 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		mutex_unlock(&root->fs_info->fs_mutex);
 		goto out_unlock;
 	}
+	/* FIXME blocksize != 4096 */
+	inode->i_blocks += num_blocks << 3;
 	if (start_pos < inode->i_size) {
+		/* FIXME blocksize != pagesize */
 		ret = drop_extents(trans, root, inode,
 				   start_pos,
 				   (pos + count + root->blocksize -1) &
-				   ~(root->blocksize - 1));
+				   ~((u64)root->blocksize - 1));
 	}
 	ret = btrfs_alloc_extent(trans, root, num_blocks, 1,
 				 (u64)-1, &ins);
@@ -1585,8 +1588,13 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 out_unlock:
 	mutex_unlock(&inode->i_mutex);
 out:
+	if (pinned[0])
+		page_cache_release(pinned[0]);
+	if (pinned[1])
+		page_cache_release(pinned[1]);
 	*ppos = pos;
 	current->backing_dev_info = NULL;
+	mark_inode_dirty(inode);
 	return num_written ? num_written : err;
 }
 

commit 70b2befd0c8a4064715d8b340270650cc9d15af8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 17 15:39:32 2007 -0400

    Btrfs: rework csums and extent item ordering
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6a56416147e6..b2a2220d1352 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -524,7 +524,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	int advance;
 	unsigned char d_type = DT_UNKNOWN;
 	int over = 0;
-	int key_type = BTRFS_DIR_INDEX_KEY;
+	int key_type = BTRFS_DIR_ITEM_KEY;
 
 	/* FIXME, use a real flag for deciding about the key type */
 	if (root->fs_info->tree_root == root)
@@ -561,9 +561,6 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		item = leaf->items + slot;
 		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
 			break;
-		if (key_type == BTRFS_DIR_INDEX_KEY &&
-		    btrfs_disk_key_offset(&item->key) > root->highest_inode)
-			break;
 		if (btrfs_disk_key_type(&item->key) != key_type)
 			continue;
 		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)
@@ -1119,7 +1116,6 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 out:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
-printk("mapping iblock %lu to %lu\n", iblock, result->b_blocknr);
 	if (trans)
 		btrfs_end_transaction(trans, root);
 	return err;
@@ -1233,7 +1229,6 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 				   struct file *file,
 				   struct page **pages,
 				   size_t num_pages,
-				   u64 extent_offset,
 				   loff_t pos,
 				   size_t write_bytes)
 {
@@ -1253,7 +1248,6 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 		trans = btrfs_start_transaction(root, 1);
 		btrfs_csum_file_block(trans, root, inode->i_ino,
 				      pages[i]->index << PAGE_CACHE_SHIFT,
-				      extent_offset,
 				      kmap(pages[i]), PAGE_CACHE_SIZE);
 		kunmap(pages[i]);
 		SetPageChecked(pages[i]);
@@ -1275,86 +1269,6 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 	return err;
 }
 
-static int drop_csums(struct btrfs_trans_handle *trans,
-			  struct btrfs_root *root,
-			  struct inode *inode,
-			  u64 start, u64 end)
-{
-	struct btrfs_path *path;
-	struct btrfs_leaf *leaf;
-	struct btrfs_key key;
-	int slot;
-	struct btrfs_csum_item *item;
-	char *old_block = NULL;
-	u64 cur = start;
-	u64 found_end;
-	u64 num_csums;
-	u64 item_size;
-	int ret;
-
-	path = btrfs_alloc_path();
-	if (!path)
-		return -ENOMEM;
-	while(cur < end) {
-		item = btrfs_lookup_csum(trans, root, path,
-					 inode->i_ino, cur, 1);
-		if (IS_ERR(item)) {
-			cur += root->blocksize;
-			continue;
-		}
-		leaf = btrfs_buffer_leaf(path->nodes[0]);
-		slot = path->slots[0];
-		btrfs_disk_key_to_cpu(&key, &leaf->items[slot].key);
-		item_size = btrfs_item_size(leaf->items + slot);
-		num_csums = item_size / sizeof(struct btrfs_csum_item);
-		found_end = key.offset + (num_csums << inode->i_blkbits);
-		cur = found_end;
-
-		if (found_end > end) {
-			char *src;
-			old_block = kmalloc(root->blocksize, GFP_NOFS);
-			src = btrfs_item_ptr(leaf, slot, char);
-			memcpy(old_block, src, item_size);
-		}
-		if (key.offset < start) {
-			u64 new_size = (start - key.offset) >>
-					inode->i_blkbits;
-			new_size *= sizeof(struct btrfs_csum_item);
-			ret = btrfs_truncate_item(trans, root, path, new_size);
-			BUG_ON(ret);
-		} else {
-			btrfs_del_item(trans, root, path);
-		}
-		btrfs_release_path(root, path);
-		if (found_end > end) {
-			char *dst;
-			int i;
-			int new_size;
-
-			num_csums = (found_end - end) >> inode->i_blkbits;
-			new_size = num_csums * sizeof(struct btrfs_csum_item);
-			key.offset = end;
-			ret = btrfs_insert_empty_item(trans, root, path,
-						      &key, new_size);
-			BUG_ON(ret);
-			dst = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-					     path->slots[0], char);
-			memcpy(dst, old_block + item_size - new_size,
-			       new_size);
-			item = (struct btrfs_csum_item *)dst;
-			for (i = 0; i < num_csums; i++) {
-				btrfs_set_csum_extent_offset(item, end);
-				item++;
-			}
-			mark_buffer_dirty(path->nodes[0]);
-			kfree(old_block);
-			break;
-		}
-	}
-	btrfs_free_path(path);
-	return 0;
-}
-
 static int drop_extents(struct btrfs_trans_handle *trans,
 			  struct btrfs_root *root,
 			  struct inode *inode,
@@ -1376,12 +1290,16 @@ static int drop_extents(struct btrfs_trans_handle *trans,
 	if (!path)
 		return -ENOMEM;
 search_again:
-printk("drop extent inode %lu start %Lu end %Lu\n", inode->i_ino, start, end);
 	ret = btrfs_lookup_file_extent(trans, root, path, inode->i_ino,
 				       search_start, -1);
-	if (ret != 0) {
-printk("lookup failed\n");
+	if (ret < 0)
 		goto out;
+	if (ret > 0) {
+		if (path->slots[0] == 0) {
+			ret = -ENOENT;
+			goto out;
+		}
+		path->slots[0]--;
 	}
 	while(1) {
 		keep = 0;
@@ -1390,14 +1308,11 @@ printk("lookup failed\n");
 		slot = path->slots[0];
 		btrfs_disk_key_to_cpu(&key, &leaf->items[slot].key);
 
-printk("found key %Lu %Lu %u\n", key.objectid, key.offset, key.flags);
-
 		extent = btrfs_item_ptr(leaf, slot,
 					struct btrfs_file_extent_item);
 		extent_end = key.offset +
 			(btrfs_file_extent_num_blocks(extent) <<
 			 inode->i_blkbits);
-printk("extent end is %Lu\n", extent_end);
 		if (key.offset >= end || key.objectid != inode->i_ino) {
 			ret = 0;
 			goto out;
@@ -1420,16 +1335,12 @@ printk("extent end is %Lu\n", extent_end);
 			keep = 1;
 			WARN_ON(start & (root->blocksize - 1));
 			new_num = (start - key.offset) >> inode->i_blkbits;
-printk("truncating existing extent, was %Lu ", btrfs_file_extent_num_blocks(extent));
 			btrfs_set_file_extent_num_blocks(extent, new_num);
-printk("now %Lu\n", btrfs_file_extent_num_blocks(extent));
-
 			mark_buffer_dirty(path->nodes[0]);
 		}
 		if (!keep) {
 			u64 disk_blocknr;
 			u64 disk_num_blocks;
-printk("del old\n");
 			disk_blocknr = btrfs_file_extent_disk_blocknr(extent);
 			disk_num_blocks =
 				btrfs_file_extent_disk_num_blocks(extent);
@@ -1454,15 +1365,12 @@ printk("del old\n");
 		if (bookend) {
 			/* create bookend */
 			struct btrfs_key ins;
-printk("bookend! extent end %Lu\n", extent_end);
 			ins.objectid = inode->i_ino;
 			ins.offset = end;
 			ins.flags = 0;
 			btrfs_set_key_type(&ins, BTRFS_EXTENT_DATA_KEY);
 
 			btrfs_release_path(root, path);
-			ret = drop_csums(trans, root, inode, start, end);
-			BUG_ON(ret);
 			ret = btrfs_insert_empty_item(trans, root, path, &ins,
 						      sizeof(*extent));
 			BUG_ON(ret);
@@ -1486,10 +1394,9 @@ printk("bookend! extent end %Lu\n", extent_end);
 
 			btrfs_set_file_extent_generation(extent,
 				    btrfs_file_extent_generation(&old));
-printk("new bookend at offset %Lu, file_extent_offset %Lu, file_extent_num_blocks %Lu\n", end, btrfs_file_extent_offset(extent), btrfs_file_extent_num_blocks(extent));
 			btrfs_mark_buffer_dirty(path->nodes[0]);
 			ret = 0;
-			goto out_nocsum;
+			goto out;
 		}
 next_leaf:
 		if (slot >= btrfs_header_nritems(&leaf->header) - 1) {
@@ -1504,10 +1411,6 @@ printk("new bookend at offset %Lu, file_extent_offset %Lu, file_extent_num_block
 	}
 
 out:
-	ret = drop_csums(trans, root, inode, start, end);
-	BUG_ON(ret);
-
-out_nocsum:
 	btrfs_free_path(path);
 	return ret;
 }
@@ -1556,7 +1459,6 @@ static int prepare_pages(struct btrfs_root *root,
 		head = page_buffers(pages[i]);
 		bh = head;
 		do {
-printk("mapping page %lu to block %Lu\n", pages[i]->index, alloc_extent_start);
 			err = btrfs_map_bh_to_logical(root, bh,
 						      alloc_extent_start);
 			BUG_ON(err);
@@ -1597,7 +1499,6 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	u64 start_pos;
 	u64 num_blocks;
 	u64 alloc_extent_start;
-	u64 orig_extent_start;
 	struct btrfs_trans_handle *trans;
 	struct btrfs_key ins;
 
@@ -1640,7 +1541,6 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 				   (pos + count + root->blocksize -1) &
 				   ~(root->blocksize - 1));
 	}
-	orig_extent_start = start_pos;
 	ret = btrfs_alloc_extent(trans, root, num_blocks, 1,
 				 (u64)-1, &ins);
 	BUG_ON(ret);
@@ -1656,7 +1556,6 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
 		size_t num_pages = (write_bytes + PAGE_CACHE_SIZE - 1) >>
 					PAGE_CACHE_SHIFT;
-printk("num_pages is %lu\n", num_pages);
 
 		memset(pages, 0, sizeof(pages));
 		ret = prepare_pages(root, file, pages, num_pages,
@@ -1670,10 +1569,8 @@ printk("num_pages is %lu\n", num_pages);
 					   write_bytes, pages, buf);
 		BUG_ON(ret);
 
-printk("2num_pages is %lu\n", num_pages);
 		ret = dirty_and_release_pages(NULL, root, file, pages,
-					      num_pages, orig_extent_start,
-					      pos, write_bytes);
+					      num_pages, pos, write_bytes);
 		BUG_ON(ret);
 		btrfs_drop_pages(pages, num_pages);
 

commit b18c6685810af8e6763760711aece31ccc7a8ea8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 17 13:26:50 2007 -0400

    Btrfs: progress on file_write
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ec689992fdf4..6a56416147e6 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1089,7 +1089,6 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 
 	extent_start = btrfs_disk_key_offset(&leaf->items[path->slots[0]].key);
 	extent_start = extent_start >> inode->i_blkbits;
-	extent_start += btrfs_file_extent_offset(item);
 	extent_end = extent_start + btrfs_file_extent_num_blocks(item);
 	if (iblock >= extent_start && iblock < extent_end) {
 		err = 0;
@@ -1103,6 +1102,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 		err = 0;
 		goto out;
 	}
+#if 0
 	ret = btrfs_alloc_file_extent(trans, root, objectid,
 				      iblock << inode->i_blkbits,
 				      1, extent_end, &blocknr);
@@ -1115,9 +1115,11 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	map_bh(result, inode->i_sb, blocknr);
 
 	btrfs_map_bh_to_logical(root, result, blocknr);
+#endif
 out:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
+printk("mapping iblock %lu to %lu\n", iblock, result->b_blocknr);
 	if (trans)
 		btrfs_end_transaction(trans, root);
 	return err;
@@ -1273,8 +1275,244 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 	return err;
 }
 
-static int prepare_pages(struct btrfs_trans_handle *trans,
-			 struct btrfs_root *root,
+static int drop_csums(struct btrfs_trans_handle *trans,
+			  struct btrfs_root *root,
+			  struct inode *inode,
+			  u64 start, u64 end)
+{
+	struct btrfs_path *path;
+	struct btrfs_leaf *leaf;
+	struct btrfs_key key;
+	int slot;
+	struct btrfs_csum_item *item;
+	char *old_block = NULL;
+	u64 cur = start;
+	u64 found_end;
+	u64 num_csums;
+	u64 item_size;
+	int ret;
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+	while(cur < end) {
+		item = btrfs_lookup_csum(trans, root, path,
+					 inode->i_ino, cur, 1);
+		if (IS_ERR(item)) {
+			cur += root->blocksize;
+			continue;
+		}
+		leaf = btrfs_buffer_leaf(path->nodes[0]);
+		slot = path->slots[0];
+		btrfs_disk_key_to_cpu(&key, &leaf->items[slot].key);
+		item_size = btrfs_item_size(leaf->items + slot);
+		num_csums = item_size / sizeof(struct btrfs_csum_item);
+		found_end = key.offset + (num_csums << inode->i_blkbits);
+		cur = found_end;
+
+		if (found_end > end) {
+			char *src;
+			old_block = kmalloc(root->blocksize, GFP_NOFS);
+			src = btrfs_item_ptr(leaf, slot, char);
+			memcpy(old_block, src, item_size);
+		}
+		if (key.offset < start) {
+			u64 new_size = (start - key.offset) >>
+					inode->i_blkbits;
+			new_size *= sizeof(struct btrfs_csum_item);
+			ret = btrfs_truncate_item(trans, root, path, new_size);
+			BUG_ON(ret);
+		} else {
+			btrfs_del_item(trans, root, path);
+		}
+		btrfs_release_path(root, path);
+		if (found_end > end) {
+			char *dst;
+			int i;
+			int new_size;
+
+			num_csums = (found_end - end) >> inode->i_blkbits;
+			new_size = num_csums * sizeof(struct btrfs_csum_item);
+			key.offset = end;
+			ret = btrfs_insert_empty_item(trans, root, path,
+						      &key, new_size);
+			BUG_ON(ret);
+			dst = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+					     path->slots[0], char);
+			memcpy(dst, old_block + item_size - new_size,
+			       new_size);
+			item = (struct btrfs_csum_item *)dst;
+			for (i = 0; i < num_csums; i++) {
+				btrfs_set_csum_extent_offset(item, end);
+				item++;
+			}
+			mark_buffer_dirty(path->nodes[0]);
+			kfree(old_block);
+			break;
+		}
+	}
+	btrfs_free_path(path);
+	return 0;
+}
+
+static int drop_extents(struct btrfs_trans_handle *trans,
+			  struct btrfs_root *root,
+			  struct inode *inode,
+			  u64 start, u64 end)
+{
+	int ret;
+	struct btrfs_key key;
+	struct btrfs_leaf *leaf;
+	int slot;
+	struct btrfs_file_extent_item *extent;
+	u64 extent_end;
+	int keep;
+	struct btrfs_file_extent_item old;
+	struct btrfs_path *path;
+	u64 search_start = start;
+	int bookend;
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+search_again:
+printk("drop extent inode %lu start %Lu end %Lu\n", inode->i_ino, start, end);
+	ret = btrfs_lookup_file_extent(trans, root, path, inode->i_ino,
+				       search_start, -1);
+	if (ret != 0) {
+printk("lookup failed\n");
+		goto out;
+	}
+	while(1) {
+		keep = 0;
+		bookend = 0;
+		leaf = btrfs_buffer_leaf(path->nodes[0]);
+		slot = path->slots[0];
+		btrfs_disk_key_to_cpu(&key, &leaf->items[slot].key);
+
+printk("found key %Lu %Lu %u\n", key.objectid, key.offset, key.flags);
+
+		extent = btrfs_item_ptr(leaf, slot,
+					struct btrfs_file_extent_item);
+		extent_end = key.offset +
+			(btrfs_file_extent_num_blocks(extent) <<
+			 inode->i_blkbits);
+printk("extent end is %Lu\n", extent_end);
+		if (key.offset >= end || key.objectid != inode->i_ino) {
+			ret = 0;
+			goto out;
+		}
+		if (btrfs_key_type(&key) != BTRFS_EXTENT_DATA_KEY)
+			goto next_leaf;
+
+		if (end < extent_end && end >= key.offset) {
+			memcpy(&old, extent, sizeof(old));
+			ret = btrfs_inc_extent_ref(trans, root,
+				   btrfs_file_extent_disk_blocknr(&old),
+				   btrfs_file_extent_disk_num_blocks(&old));
+			BUG_ON(ret);
+			bookend = 1;
+		}
+
+		if (start > key.offset) {
+			u64 new_num;
+			/* truncate existing extent */
+			keep = 1;
+			WARN_ON(start & (root->blocksize - 1));
+			new_num = (start - key.offset) >> inode->i_blkbits;
+printk("truncating existing extent, was %Lu ", btrfs_file_extent_num_blocks(extent));
+			btrfs_set_file_extent_num_blocks(extent, new_num);
+printk("now %Lu\n", btrfs_file_extent_num_blocks(extent));
+
+			mark_buffer_dirty(path->nodes[0]);
+		}
+		if (!keep) {
+			u64 disk_blocknr;
+			u64 disk_num_blocks;
+printk("del old\n");
+			disk_blocknr = btrfs_file_extent_disk_blocknr(extent);
+			disk_num_blocks =
+				btrfs_file_extent_disk_num_blocks(extent);
+			search_start = key.offset +
+				(btrfs_file_extent_num_blocks(extent) <<
+				inode->i_blkbits);
+			ret = btrfs_del_item(trans, root, path);
+			BUG_ON(ret);
+			btrfs_release_path(root, path);
+
+			ret = btrfs_free_extent(trans, root, disk_blocknr,
+						disk_num_blocks, 0);
+
+			BUG_ON(ret);
+			if (!bookend && search_start >= end) {
+				ret = 0;
+				goto out;
+			}
+			if (!bookend)
+				goto search_again;
+		}
+		if (bookend) {
+			/* create bookend */
+			struct btrfs_key ins;
+printk("bookend! extent end %Lu\n", extent_end);
+			ins.objectid = inode->i_ino;
+			ins.offset = end;
+			ins.flags = 0;
+			btrfs_set_key_type(&ins, BTRFS_EXTENT_DATA_KEY);
+
+			btrfs_release_path(root, path);
+			ret = drop_csums(trans, root, inode, start, end);
+			BUG_ON(ret);
+			ret = btrfs_insert_empty_item(trans, root, path, &ins,
+						      sizeof(*extent));
+			BUG_ON(ret);
+			extent = btrfs_item_ptr(
+				    btrfs_buffer_leaf(path->nodes[0]),
+				    path->slots[0],
+				    struct btrfs_file_extent_item);
+			btrfs_set_file_extent_disk_blocknr(extent,
+				    btrfs_file_extent_disk_blocknr(&old));
+			btrfs_set_file_extent_disk_num_blocks(extent,
+				    btrfs_file_extent_disk_num_blocks(&old));
+
+			btrfs_set_file_extent_offset(extent,
+				    btrfs_file_extent_offset(&old) +
+				    ((end - key.offset) >> inode->i_blkbits));
+			WARN_ON(btrfs_file_extent_num_blocks(&old) <
+				(end - key.offset) >> inode->i_blkbits);
+			btrfs_set_file_extent_num_blocks(extent,
+				    btrfs_file_extent_num_blocks(&old) -
+				    ((end - key.offset) >> inode->i_blkbits));
+
+			btrfs_set_file_extent_generation(extent,
+				    btrfs_file_extent_generation(&old));
+printk("new bookend at offset %Lu, file_extent_offset %Lu, file_extent_num_blocks %Lu\n", end, btrfs_file_extent_offset(extent), btrfs_file_extent_num_blocks(extent));
+			btrfs_mark_buffer_dirty(path->nodes[0]);
+			ret = 0;
+			goto out_nocsum;
+		}
+next_leaf:
+		if (slot >= btrfs_header_nritems(&leaf->header) - 1) {
+			ret = btrfs_next_leaf(root, path);
+			if (ret) {
+				ret = 0;
+				goto out;
+			}
+		} else {
+			path->slots[0]++;
+		}
+	}
+
+out:
+	ret = drop_csums(trans, root, inode, start, end);
+	BUG_ON(ret);
+
+out_nocsum:
+	btrfs_free_path(path);
+	return ret;
+}
+
+static int prepare_pages(struct btrfs_root *root,
 			 struct file *file,
 			 struct page **pages,
 			 size_t num_pages,
@@ -1289,7 +1527,6 @@ static int prepare_pages(struct btrfs_trans_handle *trans,
 	struct inode *inode = file->f_path.dentry->d_inode;
 	int offset;
 	int err = 0;
-	int ret;
 	int this_write;
 	struct buffer_head *bh;
 	struct buffer_head *head;
@@ -1305,18 +1542,21 @@ static int prepare_pages(struct btrfs_trans_handle *trans,
 		}
 		offset = pos & (PAGE_CACHE_SIZE -1);
 		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
-		if (!PageUptodate(pages[i]) &&
-		   (pages[i]->index == first_index ||
-		    pages[i]->index == last_index) && pos < isize) {
+#if 0
+		if ((pages[i]->index == first_index ||
+		    pages[i]->index == last_index) && pos < isize &&
+		    !PageUptodate(pages[i])) {
 			ret = mpage_readpage(pages[i], btrfs_get_block);
 			BUG_ON(ret);
 			lock_page(pages[i]);
 		}
+#endif
 		create_empty_buffers(pages[i], root->fs_info->sb->s_blocksize,
 				     (1 << BH_Uptodate));
 		head = page_buffers(pages[i]);
 		bh = head;
 		do {
+printk("mapping page %lu to block %Lu\n", pages[i]->index, alloc_extent_start);
 			err = btrfs_map_bh_to_logical(root, bh,
 						      alloc_extent_start);
 			BUG_ON(err);
@@ -1351,7 +1591,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	int ret = 0;
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
-	struct page *pages[1];
+	struct page *pages[8];
 	unsigned long first_index;
 	unsigned long last_index;
 	u64 start_pos;
@@ -1359,6 +1599,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	u64 alloc_extent_start;
 	u64 orig_extent_start;
 	struct btrfs_trans_handle *trans;
+	struct btrfs_key ins;
 
 	if (file->f_flags & O_DIRECT)
 		return -EINVAL;
@@ -1390,16 +1631,24 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	trans = btrfs_start_transaction(root, 1);
 	if (!trans) {
 		err = -ENOMEM;
+		mutex_unlock(&root->fs_info->fs_mutex);
 		goto out_unlock;
 	}
-	ret = btrfs_alloc_file_extent(trans, root, inode->i_ino,
-				      start_pos, num_blocks, 1,
-				      &alloc_extent_start);
-	BUG_ON(ret);
-
+	if (start_pos < inode->i_size) {
+		ret = drop_extents(trans, root, inode,
+				   start_pos,
+				   (pos + count + root->blocksize -1) &
+				   ~(root->blocksize - 1));
+	}
 	orig_extent_start = start_pos;
-	ret = btrfs_end_transaction(trans, root);
+	ret = btrfs_alloc_extent(trans, root, num_blocks, 1,
+				 (u64)-1, &ins);
+	BUG_ON(ret);
+	ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
+				       start_pos, ins.objectid, ins.offset);
 	BUG_ON(ret);
+	alloc_extent_start = ins.objectid;
+	ret = btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
 
 	while(count > 0) {
@@ -1407,16 +1656,21 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
 		size_t num_pages = (write_bytes + PAGE_CACHE_SIZE - 1) >>
 					PAGE_CACHE_SHIFT;
-		ret = prepare_pages(NULL, root, file, pages, num_pages,
+printk("num_pages is %lu\n", num_pages);
+
+		memset(pages, 0, sizeof(pages));
+		ret = prepare_pages(root, file, pages, num_pages,
 				    pos, first_index, last_index,
 				    write_bytes, alloc_extent_start);
 		BUG_ON(ret);
+
 		/* FIXME blocks != pagesize */
 		alloc_extent_start += num_pages;
 		ret = btrfs_copy_from_user(pos, num_pages,
 					   write_bytes, pages, buf);
 		BUG_ON(ret);
 
+printk("2num_pages is %lu\n", num_pages);
 		ret = dirty_and_release_pages(NULL, root, file, pages,
 					      num_pages, orig_extent_start,
 					      pos, write_bytes);

commit 6567e837df07e43bffc08ac40858af8133a007bf
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 16 09:22:45 2007 -0400

    Btrfs: early work to file_write in big extents
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8dcf600e39ef..ec689992fdf4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1027,8 +1027,10 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	btrfs_init_path(path);
-	if (create)
+	if (create) {
 		trans = btrfs_start_transaction(root, 1);
+		WARN_ON(1);
+	}
 
 	ret = btrfs_lookup_file_extent(trans, root, path,
 				       inode->i_ino,
@@ -1055,9 +1057,8 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	/* exact match found, use it, FIXME, deal with extents
 	 * other than the page size
 	 */
-	if (ret == 0) {
+	if (0 && ret == 0) {
 		err = 0;
-		BUG_ON(btrfs_file_extent_disk_num_blocks(item) != 1);
 		if (create &&
 		    btrfs_file_extent_generation(item) != trans->transid) {
 			struct btrfs_key ins;
@@ -1072,7 +1073,6 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 			blocknr = ins.objectid;
 
 		}
-		map_bh(result, inode->i_sb, blocknr);
 		btrfs_map_bh_to_logical(root, result, blocknr);
 		goto out;
 	}
@@ -1231,6 +1231,7 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 				   struct file *file,
 				   struct page **pages,
 				   size_t num_pages,
+				   u64 extent_offset,
 				   loff_t pos,
 				   size_t write_bytes)
 {
@@ -1250,6 +1251,7 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 		trans = btrfs_start_transaction(root, 1);
 		btrfs_csum_file_block(trans, root, inode->i_ino,
 				      pages[i]->index << PAGE_CACHE_SHIFT,
+				      extent_offset,
 				      kmap(pages[i]), PAGE_CACHE_SIZE);
 		kunmap(pages[i]);
 		SetPageChecked(pages[i]);
@@ -1279,7 +1281,8 @@ static int prepare_pages(struct btrfs_trans_handle *trans,
 			 loff_t pos,
 			 unsigned long first_index,
 			 unsigned long last_index,
-			 size_t write_bytes)
+			 size_t write_bytes,
+			 u64 alloc_extent_start)
 {
 	int i;
 	unsigned long index = pos >> PAGE_CACHE_SHIFT;
@@ -1288,6 +1291,8 @@ static int prepare_pages(struct btrfs_trans_handle *trans,
 	int err = 0;
 	int ret;
 	int this_write;
+	struct buffer_head *bh;
+	struct buffer_head *head;
 	loff_t isize = i_size_read(inode);
 
 	memset(pages, 0, num_pages * sizeof(struct page *));
@@ -1307,14 +1312,20 @@ static int prepare_pages(struct btrfs_trans_handle *trans,
 			BUG_ON(ret);
 			lock_page(pages[i]);
 		}
-		ret = nobh_prepare_write(pages[i], offset,
-					 offset + this_write,
-					 btrfs_get_block);
+		create_empty_buffers(pages[i], root->fs_info->sb->s_blocksize,
+				     (1 << BH_Uptodate));
+		head = page_buffers(pages[i]);
+		bh = head;
+		do {
+			err = btrfs_map_bh_to_logical(root, bh,
+						      alloc_extent_start);
+			BUG_ON(err);
+			if (err)
+				goto failed_truncate;
+			bh = bh->b_this_page;
+			alloc_extent_start++;
+		} while (bh != head);
 		pos += this_write;
-		if (ret) {
-			err = ret;
-			goto failed_truncate;
-		}
 		WARN_ON(this_write > write_bytes);
 		write_bytes -= this_write;
 	}
@@ -1343,11 +1354,23 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	struct page *pages[1];
 	unsigned long first_index;
 	unsigned long last_index;
+	u64 start_pos;
+	u64 num_blocks;
+	u64 alloc_extent_start;
+	u64 orig_extent_start;
+	struct btrfs_trans_handle *trans;
 
 	if (file->f_flags & O_DIRECT)
 		return -EINVAL;
 	pos = *ppos;
 
+	start_pos = pos & ~(root->blocksize - 1);
+	/* FIXME */
+	if (start_pos != pos)
+		return -EINVAL;
+	num_blocks = (count + pos - start_pos + root->blocksize - 1) >>
+			inode->i_blkbits;
+
 	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
 	current->backing_dev_info = inode->i_mapping->backing_dev_info;
 	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
@@ -1362,20 +1385,41 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	mutex_lock(&inode->i_mutex);
 	first_index = pos >> PAGE_CACHE_SHIFT;
 	last_index = (pos + count) >> PAGE_CACHE_SHIFT;
+
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	if (!trans) {
+		err = -ENOMEM;
+		goto out_unlock;
+	}
+	ret = btrfs_alloc_file_extent(trans, root, inode->i_ino,
+				      start_pos, num_blocks, 1,
+				      &alloc_extent_start);
+	BUG_ON(ret);
+
+	orig_extent_start = start_pos;
+	ret = btrfs_end_transaction(trans, root);
+	BUG_ON(ret);
+	mutex_unlock(&root->fs_info->fs_mutex);
+
 	while(count > 0) {
 		size_t offset = pos & (PAGE_CACHE_SIZE - 1);
 		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
 		size_t num_pages = (write_bytes + PAGE_CACHE_SIZE - 1) >>
 					PAGE_CACHE_SHIFT;
 		ret = prepare_pages(NULL, root, file, pages, num_pages,
-				    pos, first_index, last_index, write_bytes);
+				    pos, first_index, last_index,
+				    write_bytes, alloc_extent_start);
 		BUG_ON(ret);
+		/* FIXME blocks != pagesize */
+		alloc_extent_start += num_pages;
 		ret = btrfs_copy_from_user(pos, num_pages,
 					   write_bytes, pages, buf);
 		BUG_ON(ret);
 
 		ret = dirty_and_release_pages(NULL, root, file, pages,
-					      num_pages, pos, write_bytes);
+					      num_pages, orig_extent_start,
+					      pos, write_bytes);
 		BUG_ON(ret);
 		btrfs_drop_pages(pages, num_pages);
 
@@ -1387,6 +1431,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		balance_dirty_pages_ratelimited(inode->i_mapping);
 		cond_resched();
 	}
+out_unlock:
 	mutex_unlock(&inode->i_mutex);
 out:
 	*ppos = pos;
@@ -1806,8 +1851,6 @@ static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 				&new_root_item);
 	BUG_ON(ret);
 
-printk("adding snapshot name %.*s root %Lu %Lu %u\n", namelen, name, key.objectid, key.offset, key.flags);
-
 	/*
 	 * insert the directory item
 	 */

commit b4100d64241fed93a3f821ddf59d11ab4443a3ba
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 12 12:14:00 2007 -0400

    Btrfs: add a device id to device items
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c46d7eafcf62..8dcf600e39ef 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1840,7 +1840,9 @@ static int add_disk(struct btrfs_root *root, char *name, int namelen)
 	u16 item_size;
 	u64 num_blocks;
 	u64 new_blocks;
+	u64 device_id;
 	int ret;
+
 printk("adding disk %s\n", name);
 	path = btrfs_alloc_path();
 	if (!path)
@@ -1875,9 +1877,14 @@ printk("insert failed %d\n", ret);
 				  path->slots[0], struct btrfs_device_item);
 	btrfs_set_device_pathlen(dev_item, namelen);
 	memcpy(dev_item + 1, name, namelen);
+
+	device_id = btrfs_super_last_device_id(root->fs_info->disk_super) + 1;
+	btrfs_set_super_last_device_id(root->fs_info->disk_super, device_id);
+	btrfs_set_device_id(dev_item, device_id);
 	mark_buffer_dirty(path->nodes[0]);
 
-	ret = btrfs_insert_dev_radix(root, bdev, num_blocks, new_blocks);
+	ret = btrfs_insert_dev_radix(root, bdev, device_id, num_blocks,
+				     new_blocks);
 
 	if (!ret) {
 		btrfs_set_super_total_blocks(root->fs_info->disk_super,

commit 8352d8a473ac84bf7a1c69690b626946d744ca58
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 12 10:43:05 2007 -0400

    Btrfs: add disk ioctl, mostly working
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4ff0cc1efb13..c46d7eafcf62 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1073,6 +1073,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 
 		}
 		map_bh(result, inode->i_sb, blocknr);
+		btrfs_map_bh_to_logical(root, result, blocknr);
 		goto out;
 	}
 
@@ -1092,7 +1093,8 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	extent_end = extent_start + btrfs_file_extent_num_blocks(item);
 	if (iblock >= extent_start && iblock < extent_end) {
 		err = 0;
-		map_bh(result, inode->i_sb, blocknr + iblock - extent_start);
+		btrfs_map_bh_to_logical(root, result, blocknr + iblock -
+					extent_start);
 		goto out;
 	}
 allocate:
@@ -1112,6 +1114,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	set_buffer_new(result);
 	map_bh(result, inode->i_sb, blocknr);
 
+	btrfs_map_bh_to_logical(root, result, blocknr);
 out:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
@@ -1153,12 +1156,6 @@ static int btrfs_readpage(struct file *file, struct page *page)
 	return mpage_readpage(page, btrfs_get_block);
 }
 
-static int btrfs_readpages(struct file *file, struct address_space *mapping,
-			   struct list_head *pages, unsigned nr_pages)
-{
-	return mpage_readpages(mapping, pages, nr_pages, btrfs_get_block);
-}
-
 static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 {
 	return nobh_writepage(page, btrfs_get_block, wbc);
@@ -1831,12 +1828,81 @@ printk("adding snapshot name %.*s root %Lu %Lu %u\n", namelen, name, key.objecti
 	return 0;
 }
 
+static int add_disk(struct btrfs_root *root, char *name, int namelen)
+{
+	struct block_device *bdev;
+	struct btrfs_path *path;
+	struct super_block *sb = root->fs_info->sb;
+	struct btrfs_root *dev_root = root->fs_info->dev_root;
+	struct btrfs_trans_handle *trans;
+	struct btrfs_device_item *dev_item;
+	struct btrfs_key key;
+	u16 item_size;
+	u64 num_blocks;
+	u64 new_blocks;
+	int ret;
+printk("adding disk %s\n", name);
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+	num_blocks = btrfs_super_total_blocks(root->fs_info->disk_super);
+	bdev = open_bdev_excl(name, O_RDWR, sb);
+	if (IS_ERR(bdev)) {
+		ret = PTR_ERR(bdev);
+printk("open bdev excl failed ret %d\n", ret);
+		goto out_nolock;
+	}
+	set_blocksize(bdev, sb->s_blocksize);
+	new_blocks = bdev->bd_inode->i_size >> sb->s_blocksize_bits;
+	key.objectid = num_blocks;
+	key.offset = new_blocks;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_DEV_ITEM_KEY);
+
+	mutex_lock(&dev_root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(dev_root, 1);
+	item_size = sizeof(*dev_item) + namelen;
+printk("insert empty on %Lu %Lu %u size %d\n", num_blocks, new_blocks, key.flags, item_size);
+	ret = btrfs_insert_empty_item(trans, dev_root, path, &key, item_size);
+	if (ret) {
+printk("insert failed %d\n", ret);
+		close_bdev_excl(bdev);
+		if (ret > 0)
+			ret = -EEXIST;
+		goto out;
+	}
+	dev_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+				  path->slots[0], struct btrfs_device_item);
+	btrfs_set_device_pathlen(dev_item, namelen);
+	memcpy(dev_item + 1, name, namelen);
+	mark_buffer_dirty(path->nodes[0]);
+
+	ret = btrfs_insert_dev_radix(root, bdev, num_blocks, new_blocks);
+
+	if (!ret) {
+		btrfs_set_super_total_blocks(root->fs_info->disk_super,
+					     num_blocks + new_blocks);
+		i_size_write(root->fs_info->btree_inode,
+			     (num_blocks + new_blocks) <<
+			     root->fs_info->btree_inode->i_blkbits);
+	}
+
+out:
+	ret = btrfs_commit_transaction(trans, dev_root);
+	BUG_ON(ret);
+	mutex_unlock(&root->fs_info->fs_mutex);
+out_nolock:
+	btrfs_free_path(path);
+
+	return ret;
+}
+
 static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 		       cmd, unsigned long arg)
 {
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_ioctl_vol_args vol_args;
-	int ret;
+	int ret = 0;
 	int namelen;
 	struct btrfs_path *path;
 	u64 root_dirid;
@@ -1869,10 +1935,21 @@ static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 			ret = create_snapshot(root, vol_args.name, namelen);
 		WARN_ON(ret);
 		break;
+	case BTRFS_IOC_ADD_DISK:
+		if (copy_from_user(&vol_args,
+				   (struct btrfs_ioctl_vol_args __user *)arg,
+				   sizeof(vol_args)))
+			return -EFAULT;
+		namelen = strlen(vol_args.name);
+		if (namelen > BTRFS_VOL_NAME_MAX)
+			return -EINVAL;
+		vol_args.name[namelen] = '\0';
+		ret = add_disk(root, vol_args.name, namelen);
+		break;
 	default:
 		return -ENOTTY;
 	}
-	return 0;
+	return ret;
 }
 
 static struct kmem_cache *btrfs_inode_cachep;
@@ -2004,7 +2081,6 @@ static struct file_operations btrfs_dir_file_operations = {
 
 static struct address_space_operations btrfs_aops = {
 	.readpage	= btrfs_readpage,
-	.readpages	= btrfs_readpages,
 	.writepage	= btrfs_writepage,
 	.sync_page	= block_sync_page,
 	.prepare_write	= btrfs_prepare_write,

commit 7eccb903a817e890c947ba4bc90c6a9af9b4219a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 11 15:53:25 2007 -0400

    Btrfs: create a logical->phsyical block number mapping scheme
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2972aaa9eb7e..4ff0cc1efb13 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1700,7 +1700,7 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	leaf = btrfs_buffer_leaf(subvol);
 	btrfs_set_header_nritems(&leaf->header, 0);
 	btrfs_set_header_level(&leaf->header, 0);
-	btrfs_set_header_blocknr(&leaf->header, subvol->b_blocknr);
+	btrfs_set_header_blocknr(&leaf->header, bh_blocknr(subvol));
 	btrfs_set_header_generation(&leaf->header, trans->transid);
 	memcpy(leaf->header.fsid, root->fs_info->disk_super->fsid,
 	       sizeof(leaf->header.fsid));
@@ -1713,7 +1713,7 @@ static int create_subvol(struct btrfs_root *root, char *name, int namelen)
 	btrfs_set_inode_nblocks(inode_item, 1);
 	btrfs_set_inode_mode(inode_item, S_IFDIR | 0755);
 
-	btrfs_set_root_blocknr(&root_item, subvol->b_blocknr);
+	btrfs_set_root_blocknr(&root_item, bh_blocknr(subvol));
 	btrfs_set_root_refs(&root_item, 1);
 
 	mark_buffer_dirty(subvol);
@@ -1803,7 +1803,7 @@ static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 	key.offset = 1;
 	key.flags = 0;
 	btrfs_set_key_type(&key, BTRFS_ROOT_ITEM_KEY);
-	btrfs_set_root_blocknr(&new_root_item, root->node->b_blocknr);
+	btrfs_set_root_blocknr(&new_root_item, bh_blocknr(root->node));
 
 	ret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,
 				&new_root_item);

commit 2d13d8d065cc7bbee6b1ad6ee3fe965d66badfe6
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 20:07:20 2007 -0400

    Btrfs: detect duplicate subvol names
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 84abdde4e301..2972aaa9eb7e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1853,13 +1853,13 @@ static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 		path = btrfs_alloc_path();
 		if (!path)
 			return -ENOMEM;
-		root_dirid = btrfs_root_dirid(
-				      &root->fs_info->tree_root->root_item);
+		root_dirid = root->fs_info->sb->s_root->d_inode->i_ino,
 		mutex_lock(&root->fs_info->fs_mutex);
 		ret = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root,
 				    path, root_dirid,
 				    vol_args.name, namelen, 0);
 		mutex_unlock(&root->fs_info->fs_mutex);
+		btrfs_free_path(path);
 		if (ret == 0)
 			return -EEXIST;
 

commit 2619ba1f0ff9540a9d84683310a1e350b5efde3d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 16:58:11 2007 -0400

    Btrfs: subvolumes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index b93d790e7484..84abdde4e301 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -495,10 +495,6 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 			return ERR_PTR(-EACCES);
 		if (inode->i_state & I_NEW) {
 			if (sub_root != root) {
-				ret = radix_tree_insert(
-						&root->fs_info->fs_roots_radix,
-						(unsigned long)sub_root,
-						sub_root);
 printk("adding new root for inode %lu root %p (found %p)\n", inode->i_ino, sub_root, BTRFS_I(inode)->root);
 				igrab(inode);
 				sub_root->inode = inode;
@@ -723,22 +719,19 @@ static int btrfs_write_inode(struct inode *inode, int wait)
 }
 
 static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
-				     struct inode *dir, int mode)
+				     struct btrfs_root *root,
+				     u64 objectid, int mode)
 {
 	struct inode *inode;
 	struct btrfs_inode_item inode_item;
-	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_key *location;
 	int ret;
-	u64 objectid;
 
-	inode = new_inode(dir->i_sb);
+	inode = new_inode(root->fs_info->sb);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
 
-	BTRFS_I(inode)->root = BTRFS_I(dir)->root;
-	ret = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
-	BUG_ON(ret);
+	BTRFS_I(inode)->root = root;
 
 	inode->i_uid = current->fsuid;
 	inode->i_gid = current->fsgid;
@@ -804,10 +797,18 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 	struct inode *inode;
 	int err;
 	int drop_inode = 0;
+	u64 objectid;
 
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
-	inode = btrfs_new_inode(trans, dir, mode);
+
+	err = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
+	if (err) {
+		err = -ENOSPC;
+		goto out_unlock;
+	}
+
+	inode = btrfs_new_inode(trans, root, objectid, mode);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_unlock;
@@ -833,9 +834,9 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 }
 
 static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
-				struct inode *inode, struct inode *dir)
+				struct btrfs_root *root,
+				u64 objectid, u64 dirid)
 {
-	struct btrfs_root *root = BTRFS_I(dir)->root;
 	int ret;
 	char buf[2];
 	struct btrfs_key key;
@@ -843,22 +844,20 @@ static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
 	buf[0] = '.';
 	buf[1] = '.';
 
-	key.objectid = inode->i_ino;
+	key.objectid = objectid;
 	key.offset = 0;
 	key.flags = 0;
 	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
 
-	ret = btrfs_insert_dir_item(trans, root, buf, 1, inode->i_ino,
+	ret = btrfs_insert_dir_item(trans, root, buf, 1, objectid,
 				    &key, 1);
 	if (ret)
 		goto error;
-	key.objectid = dir->i_ino;
-	ret = btrfs_insert_dir_item(trans, root, buf, 2, inode->i_ino,
+	key.objectid = dirid;
+	ret = btrfs_insert_dir_item(trans, root, buf, 2, objectid,
 				    &key, 1);
 	if (ret)
 		goto error;
-	inode->i_size = 6;
-	ret = btrfs_update_inode(trans, root, inode);
 error:
 	return ret;
 }
@@ -870,6 +869,7 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	int err = 0;
 	int drop_on_err = 0;
+	u64 objectid;
 
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
@@ -877,7 +877,14 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 		err = PTR_ERR(trans);
 		goto out_unlock;
 	}
-	inode = btrfs_new_inode(trans, dir, S_IFDIR | mode);
+
+	err = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
+	if (err) {
+		err = -ENOSPC;
+		goto out_unlock;
+	}
+
+	inode = btrfs_new_inode(trans, root, objectid, S_IFDIR | mode);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
 		goto out_fail;
@@ -886,7 +893,12 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 	inode->i_op = &btrfs_dir_inode_operations;
 	inode->i_fop = &btrfs_dir_file_operations;
 
-	err = btrfs_make_empty_dir(trans, inode, dir);
+	err = btrfs_make_empty_dir(trans, root, inode->i_ino, dir->i_ino);
+	if (err)
+		goto out_fail;
+
+	inode->i_size = 6;
+	err = btrfs_update_inode(trans, root, inode);
 	if (err)
 		goto out_fail;
 	err = btrfs_add_link(trans, dentry, inode);
@@ -1666,6 +1678,102 @@ static ssize_t btrfs_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
 	return retval;
 }
 
+static int create_subvol(struct btrfs_root *root, char *name, int namelen)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_key key;
+	struct btrfs_root_item root_item;
+	struct btrfs_inode_item *inode_item;
+	struct buffer_head *subvol;
+	struct btrfs_leaf *leaf;
+	struct btrfs_root *new_root;
+	struct inode *inode;
+	int ret;
+	u64 objectid;
+	u64 new_dirid = BTRFS_FIRST_FREE_OBJECTID;
+
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	BUG_ON(!trans);
+
+	subvol = btrfs_alloc_free_block(trans, root);
+	leaf = btrfs_buffer_leaf(subvol);
+	btrfs_set_header_nritems(&leaf->header, 0);
+	btrfs_set_header_level(&leaf->header, 0);
+	btrfs_set_header_blocknr(&leaf->header, subvol->b_blocknr);
+	btrfs_set_header_generation(&leaf->header, trans->transid);
+	memcpy(leaf->header.fsid, root->fs_info->disk_super->fsid,
+	       sizeof(leaf->header.fsid));
+
+	inode_item = &root_item.inode;
+	memset(inode_item, 0, sizeof(*inode_item));
+	btrfs_set_inode_generation(inode_item, 1);
+	btrfs_set_inode_size(inode_item, 3);
+	btrfs_set_inode_nlink(inode_item, 1);
+	btrfs_set_inode_nblocks(inode_item, 1);
+	btrfs_set_inode_mode(inode_item, S_IFDIR | 0755);
+
+	btrfs_set_root_blocknr(&root_item, subvol->b_blocknr);
+	btrfs_set_root_refs(&root_item, 1);
+
+	mark_buffer_dirty(subvol);
+	brelse(subvol);
+	subvol = NULL;
+
+	ret = btrfs_find_free_objectid(trans, root->fs_info->tree_root,
+				       0, &objectid);
+	BUG_ON(ret);
+
+	btrfs_set_root_dirid(&root_item, new_dirid);
+
+	key.objectid = objectid;
+	key.offset = 1;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_ROOT_ITEM_KEY);
+	ret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,
+				&root_item);
+	BUG_ON(ret);
+
+	/*
+	 * insert the directory item
+	 */
+	key.offset = (u64)-1;
+	ret = btrfs_insert_dir_item(trans, root->fs_info->tree_root,
+				    name, namelen,
+				    root->fs_info->sb->s_root->d_inode->i_ino,
+				    &key, 0);
+	BUG_ON(ret);
+
+	ret = btrfs_commit_transaction(trans, root);
+	BUG_ON(ret);
+
+	new_root = btrfs_read_fs_root(root->fs_info, &key);
+	BUG_ON(!new_root);
+
+	trans = btrfs_start_transaction(new_root, 1);
+	BUG_ON(!trans);
+
+	inode = btrfs_new_inode(trans, new_root, new_dirid, S_IFDIR | 0700);
+	inode->i_op = &btrfs_dir_inode_operations;
+	inode->i_fop = &btrfs_dir_file_operations;
+
+	ret = btrfs_make_empty_dir(trans, new_root, new_dirid, new_dirid);
+	BUG_ON(ret);
+
+	inode->i_nlink = 1;
+	inode->i_size = 6;
+	ret = btrfs_update_inode(trans, new_root, inode);
+	BUG_ON(ret);
+
+	ret = btrfs_commit_transaction(trans, new_root);
+	BUG_ON(ret);
+
+	iput(inode);
+
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return 0;
+}
+
 static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 {
 	struct btrfs_trans_handle *trans;
@@ -1674,6 +1782,9 @@ static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 	int ret;
 	u64 objectid;
 
+	if (!root->ref_cows)
+		return -EINVAL;
+
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	BUG_ON(!trans);
@@ -1685,7 +1796,6 @@ static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 				       0, &objectid);
 	BUG_ON(ret);
 
-	memset(&new_root_item, 0, sizeof(new_root_item));
 	memcpy(&new_root_item, &root->root_item,
 	       sizeof(new_root_item));
 
@@ -1728,9 +1838,9 @@ static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 	struct btrfs_ioctl_vol_args vol_args;
 	int ret;
 	int namelen;
+	struct btrfs_path *path;
+	u64 root_dirid;
 
-	if (!root->ref_cows)
-		return -EINVAL;
 	switch (cmd) {
 	case BTRFS_IOC_SNAP_CREATE:
 		if (copy_from_user(&vol_args,
@@ -1740,7 +1850,23 @@ static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
 		namelen = strlen(vol_args.name);
 		if (namelen > BTRFS_VOL_NAME_MAX)
 			return -EINVAL;
-		ret = create_snapshot(root, vol_args.name, namelen);
+		path = btrfs_alloc_path();
+		if (!path)
+			return -ENOMEM;
+		root_dirid = btrfs_root_dirid(
+				      &root->fs_info->tree_root->root_item);
+		mutex_lock(&root->fs_info->fs_mutex);
+		ret = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root,
+				    path, root_dirid,
+				    vol_args.name, namelen, 0);
+		mutex_unlock(&root->fs_info->fs_mutex);
+		if (ret == 0)
+			return -EEXIST;
+
+		if (root == root->fs_info->tree_root)
+			ret = create_subvol(root, vol_args.name, namelen);
+		else
+			ret = create_snapshot(root, vol_args.name, namelen);
 		WARN_ON(ret);
 		break;
 	default:

commit 2932f3ec94ff0212313b8187064f93bcb76ce411
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 14:22:02 2007 -0400

    Btrfs: when forced to cow for file_write, get the page uptodate first
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a3183972f310..b93d790e7484 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1268,6 +1268,8 @@ static int prepare_pages(struct btrfs_trans_handle *trans,
 			 struct page **pages,
 			 size_t num_pages,
 			 loff_t pos,
+			 unsigned long first_index,
+			 unsigned long last_index,
 			 size_t write_bytes)
 {
 	int i;
@@ -1289,6 +1291,13 @@ static int prepare_pages(struct btrfs_trans_handle *trans,
 		}
 		offset = pos & (PAGE_CACHE_SIZE -1);
 		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
+		if (!PageUptodate(pages[i]) &&
+		   (pages[i]->index == first_index ||
+		    pages[i]->index == last_index) && pos < isize) {
+			ret = mpage_readpage(pages[i], btrfs_get_block);
+			BUG_ON(ret);
+			lock_page(pages[i]);
+		}
 		ret = nobh_prepare_write(pages[i], offset,
 					 offset + this_write,
 					 btrfs_get_block);
@@ -1323,6 +1332,8 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct page *pages[1];
+	unsigned long first_index;
+	unsigned long last_index;
 
 	if (file->f_flags & O_DIRECT)
 		return -EINVAL;
@@ -1340,13 +1351,15 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		goto out;
 	file_update_time(file);
 	mutex_lock(&inode->i_mutex);
+	first_index = pos >> PAGE_CACHE_SHIFT;
+	last_index = (pos + count) >> PAGE_CACHE_SHIFT;
 	while(count > 0) {
 		size_t offset = pos & (PAGE_CACHE_SIZE - 1);
 		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
 		size_t num_pages = (write_bytes + PAGE_CACHE_SIZE - 1) >>
 					PAGE_CACHE_SHIFT;
 		ret = prepare_pages(NULL, root, file, pages, num_pages,
-				    pos, write_bytes);
+				    pos, first_index, last_index, write_bytes);
 		BUG_ON(ret);
 		ret = btrfs_copy_from_user(pos, num_pages,
 					   write_bytes, pages, buf);

commit 79b2cb1fa6430501907cb1384abbddf074833e45
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 13:51:41 2007 -0400

    Btrfs: only cow in get_block when create==1
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 91aa1b4c50af..a3183972f310 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1020,7 +1020,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 
 	ret = btrfs_lookup_file_extent(trans, root, path,
 				       inode->i_ino,
-				       iblock << inode->i_blkbits, 1);
+				       iblock << inode->i_blkbits, create);
 	if (ret < 0) {
 		err = ret;
 		goto out;
@@ -1046,7 +1046,8 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	if (ret == 0) {
 		err = 0;
 		BUG_ON(btrfs_file_extent_disk_num_blocks(item) != 1);
-		if (btrfs_file_extent_generation(item) != trans->transid) {
+		if (create &&
+		    btrfs_file_extent_generation(item) != trans->transid) {
 			struct btrfs_key ins;
 			ret = btrfs_alloc_extent(trans, root, 1,
 						 blocknr, (u64)-1, &ins);

commit 48ddc6f44b5a167c00573b6012727d674e9c667a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 13:20:21 2007 -0400

    Btrfs: cow file extents before writing
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3e8bfb0e5d7e..91aa1b4c50af 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1020,7 +1020,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 
 	ret = btrfs_lookup_file_extent(trans, root, path,
 				       inode->i_ino,
-				       iblock << inode->i_blkbits, 0);
+				       iblock << inode->i_blkbits, 1);
 	if (ret < 0) {
 		err = ret;
 		goto out;
@@ -1040,9 +1040,25 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	blocknr = btrfs_file_extent_disk_blocknr(item);
 	blocknr += btrfs_file_extent_offset(item);
 
-	/* exact match found, use it */
+	/* exact match found, use it, FIXME, deal with extents
+	 * other than the page size
+	 */
 	if (ret == 0) {
 		err = 0;
+		BUG_ON(btrfs_file_extent_disk_num_blocks(item) != 1);
+		if (btrfs_file_extent_generation(item) != trans->transid) {
+			struct btrfs_key ins;
+			ret = btrfs_alloc_extent(trans, root, 1,
+						 blocknr, (u64)-1, &ins);
+			BUG_ON(ret);
+			btrfs_set_file_extent_disk_blocknr(item, ins.objectid);
+			mark_buffer_dirty(path->nodes[0]);
+			ret = btrfs_free_extent(trans, root,
+						blocknr, 1, 0);
+			BUG_ON(ret);
+			blocknr = ins.objectid;
+
+		}
 		map_bh(result, inode->i_sb, blocknr);
 		goto out;
 	}

commit 1b05da2ee6217e7d55460d04335813fec25be4ca
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 12:13:09 2007 -0400

    Btrfs: drop the inode map tree
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index bbe5cabcb42e..3e8bfb0e5d7e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -45,14 +45,6 @@ static struct inode_operations btrfs_file_inode_operations;
 static struct address_space_operations btrfs_aops;
 static struct file_operations btrfs_file_operations;
 
-static int check_inode(struct inode *inode)
-{
-	struct btrfs_inode *ei = BTRFS_I(inode);
-	WARN_ON(ei->magic != 0xDEADBEEF);
-	WARN_ON(ei->magic2 != 0xDEADBEAF);
-	return 0;
-}
-
 static void btrfs_read_locked_inode(struct inode *inode)
 {
 	struct btrfs_path *path;
@@ -66,15 +58,12 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	btrfs_init_path(path);
 	mutex_lock(&root->fs_info->fs_mutex);
 
-	check_inode(inode);
-
 	memcpy(&location, &BTRFS_I(inode)->location, sizeof(location));
 	ret = btrfs_lookup_inode(NULL, root, path, &location, 0);
 	if (ret) {
 		btrfs_free_path(path);
 		goto make_bad;
 	}
-	check_inode(inode);
 	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
 				  path->slots[0],
 				  struct btrfs_inode_item);
@@ -97,7 +86,7 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	inode_item = NULL;
 
 	mutex_unlock(&root->fs_info->fs_mutex);
-	check_inode(inode);
+
 	switch (inode->i_mode & S_IFMT) {
 #if 0
 	default:
@@ -121,7 +110,6 @@ static void btrfs_read_locked_inode(struct inode *inode)
 		// inode->i_op = &page_symlink_inode_operations;
 		break;
 	}
-	check_inode(inode);
 	return;
 
 make_bad:
@@ -272,10 +260,7 @@ static int btrfs_free_inode(struct btrfs_trans_handle *trans,
 			    struct btrfs_root *root,
 			    struct inode *inode)
 {
-	u64 objectid = inode->i_ino;
 	struct btrfs_path *path;
-	struct btrfs_inode_map_item *map;
-	struct btrfs_key stat_data_key;
 	int ret;
 
 	clear_inode(inode);
@@ -283,26 +268,11 @@ static int btrfs_free_inode(struct btrfs_trans_handle *trans,
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	btrfs_init_path(path);
-	ret = btrfs_lookup_inode_map(trans, root, path, objectid, -1);
-	if (ret) {
-		if (ret > 0)
-			ret = -ENOENT;
-		goto error;
-	}
-	map = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
-			    struct btrfs_inode_map_item);
-	btrfs_disk_key_to_cpu(&stat_data_key, &map->key);
-	ret = btrfs_del_item(trans, root->fs_info->inode_root, path);
-	BUG_ON(ret);
-	btrfs_release_path(root, path);
-
 	ret = btrfs_lookup_inode(trans, root, path,
 				 &BTRFS_I(inode)->location, -1);
 	BUG_ON(ret);
 	ret = btrfs_del_item(trans, root, path);
 	BUG_ON(ret);
-error:
-	btrfs_release_path(root, path);
 	btrfs_free_path(path);
 	return ret;
 }
@@ -432,7 +402,6 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 out:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
-	check_inode(dir);
 	return ret;
 }
 
@@ -540,9 +509,7 @@ printk("adding new root for inode %lu root %p (found %p)\n", inode->i_ino, sub_r
 			btrfs_read_locked_inode(inode);
 			unlock_new_inode(inode);
 		}
-		check_inode(inode);
 	}
-	check_inode(dir);
 	return d_splice_alias(inode, dentry);
 }
 
@@ -566,7 +533,6 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	/* FIXME, use a real flag for deciding about the key type */
 	if (root->fs_info->tree_root == root)
 		key_type = BTRFS_DIR_ITEM_KEY;
-
 	mutex_lock(&root->fs_info->fs_mutex);
 	key.objectid = inode->i_ino;
 	key.flags = 0;
@@ -575,9 +541,8 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	path = btrfs_alloc_path();
 	btrfs_init_path(path);
 	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
-	if (ret < 0) {
+	if (ret < 0)
 		goto err;
-	}
 	advance = 0;
 	while(1) {
 		leaf = btrfs_buffer_leaf(path->nodes[0]);
@@ -601,8 +566,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
 			break;
 		if (key_type == BTRFS_DIR_INDEX_KEY &&
-		    btrfs_disk_key_offset(&item->key) >
-		    root->fs_info->highest_inode)
+		    btrfs_disk_key_offset(&item->key) > root->highest_inode)
 			break;
 		if (btrfs_disk_key_type(&item->key) != key_type)
 			continue;
@@ -707,7 +671,6 @@ static void fill_inode_item(struct btrfs_inode_item *item,
 	btrfs_set_timespec_nsec(&item->ctime, inode->i_ctime.tv_nsec);
 	btrfs_set_inode_nblocks(item, inode->i_blocks);
 	btrfs_set_inode_generation(item, inode->i_generation);
-	check_inode(inode);
 }
 
 static int btrfs_update_inode(struct btrfs_trans_handle *trans,
@@ -721,7 +684,6 @@ static int btrfs_update_inode(struct btrfs_trans_handle *trans,
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
 	btrfs_init_path(path);
-
 	ret = btrfs_lookup_inode(trans, root, path,
 				 &BTRFS_I(inode)->location, 1);
 	if (ret) {
@@ -736,11 +698,11 @@ static int btrfs_update_inode(struct btrfs_trans_handle *trans,
 
 	fill_inode_item(inode_item, inode);
 	btrfs_mark_buffer_dirty(path->nodes[0]);
+	ret = 0;
 failed:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
-	check_inode(inode);
-	return 0;
+	return ret;
 }
 
 static int btrfs_write_inode(struct inode *inode, int wait)
@@ -757,7 +719,6 @@ static int btrfs_write_inode(struct inode *inode, int wait)
 	else
 		btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
-	check_inode(inode);
 	return ret;
 }
 
@@ -767,7 +728,7 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	struct inode *inode;
 	struct btrfs_inode_item inode_item;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
-	struct btrfs_key *key;
+	struct btrfs_key *location;
 	int ret;
 	u64 objectid;
 
@@ -776,8 +737,6 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 		return ERR_PTR(-ENOMEM);
 
 	BTRFS_I(inode)->root = BTRFS_I(dir)->root;
-	key = &BTRFS_I(inode)->location;
-	check_inode(inode);
 	ret = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
 	BUG_ON(ret);
 
@@ -788,20 +747,16 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	fill_inode_item(&inode_item, inode);
-
-	key->objectid = objectid;
-	key->flags = 0;
-	key->offset = 0;
-	btrfs_set_key_type(key, BTRFS_INODE_ITEM_KEY);
-	ret = btrfs_insert_inode_map(trans, root, objectid, key);
-	BUG_ON(ret);
+	location = &BTRFS_I(inode)->location;
+	location->objectid = objectid;
+	location->flags = 0;
+	location->offset = 0;
+	btrfs_set_key_type(location, BTRFS_INODE_ITEM_KEY);
 
 	ret = btrfs_insert_inode(trans, root, objectid, &inode_item);
 	BUG_ON(ret);
 
 	insert_inode_hash(inode);
-	check_inode(inode);
-	check_inode(dir);
 	return inode;
 }
 
@@ -825,8 +780,6 @@ static int btrfs_add_link(struct btrfs_trans_handle *trans,
 		ret = btrfs_update_inode(trans, root,
 					 dentry->d_parent->d_inode);
 	}
-	check_inode(inode);
-	check_inode(dentry->d_parent->d_inode);
 	return ret;
 }
 
@@ -840,7 +793,6 @@ static int btrfs_add_nondir(struct btrfs_trans_handle *trans,
 	}
 	if (err > 0)
 		err = -EEXIST;
-	check_inode(inode);
 	return err;
 }
 
@@ -872,8 +824,6 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 out_unlock:
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
-	check_inode(inode);
-	check_inode(dir);
 
 	if (drop_inode) {
 		inode_dec_link_count(inode);
@@ -1701,20 +1651,14 @@ static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
 	ret = btrfs_update_inode(trans, root, root->inode);
 	BUG_ON(ret);
 
-	ret = btrfs_find_free_objectid(trans, root, 0, &objectid);
+	ret = btrfs_find_free_objectid(trans, root->fs_info->tree_root,
+				       0, &objectid);
 	BUG_ON(ret);
 
 	memset(&new_root_item, 0, sizeof(new_root_item));
 	memcpy(&new_root_item, &root->root_item,
 	       sizeof(new_root_item));
 
-	key.objectid = objectid;
-	key.flags = 0;
-	key.offset = 0;
-	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
-	ret = btrfs_insert_inode_map(trans, root, objectid, &key);
-	BUG_ON(ret);
-
 	key.objectid = objectid;
 	key.offset = 1;
 	key.flags = 0;
@@ -1791,21 +1735,14 @@ static struct inode *btrfs_alloc_inode(struct super_block *sb)
 	ei = kmem_cache_alloc(btrfs_inode_cachep, GFP_NOFS);
 	if (!ei)
 		return NULL;
-	ei->magic = 0xDEADBEEF;
-	ei->magic2 = 0xDEADBEAF;
 	return &ei->vfs_inode;
 }
 
 static void btrfs_destroy_inode(struct inode *inode)
 {
-	struct btrfs_inode *ei = BTRFS_I(inode);
-	WARN_ON(ei->magic != 0xDEADBEEF);
-	WARN_ON(ei->magic2 != 0xDEADBEAF);
 	WARN_ON(!list_empty(&inode->i_dentry));
 	WARN_ON(inode->i_data.nrpages);
 
-	ei->magic = 0;
-	ei->magic2 = 0;
 	kmem_cache_free(btrfs_inode_cachep, BTRFS_I(inode));
 }
 

commit c5739bba5260a59cebd20a51a55080592c8d3b07
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Apr 10 09:27:04 2007 -0400

    Btrfs: snapshot progress
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 3c9236ca889c..bbe5cabcb42e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -15,6 +15,7 @@
 #include "disk-io.h"
 #include "transaction.h"
 #include "btrfs_inode.h"
+#include "ioctl.h"
 
 void btrfs_fsinfo_release(struct kobject *obj)
 {
@@ -27,6 +28,11 @@ struct kobj_type btrfs_fsinfo_ktype = {
 	.release = btrfs_fsinfo_release,
 };
 
+struct btrfs_iget_args {
+	u64 ino;
+	struct btrfs_root *root;
+};
+
 decl_subsys(btrfs, &btrfs_fsinfo_ktype, NULL);
 
 #define BTRFS_SUPER_MAGIC 0x9123682E
@@ -461,6 +467,34 @@ int fixup_tree_root_location(struct btrfs_root *root,
 	return 0;
 }
 
+int btrfs_init_locked_inode(struct inode *inode, void *p)
+{
+	struct btrfs_iget_args *args = p;
+	inode->i_ino = args->ino;
+	BTRFS_I(inode)->root = args->root;
+	return 0;
+}
+
+int btrfs_find_actor(struct inode *inode, void *opaque)
+{
+	struct btrfs_iget_args *args = opaque;
+	return (args->ino == inode->i_ino &&
+		args->root == BTRFS_I(inode)->root);
+}
+
+struct inode *btrfs_iget_locked(struct super_block *s, u64 objectid,
+				struct btrfs_root *root)
+{
+	struct inode *inode;
+	struct btrfs_iget_args args;
+	args.ino = objectid;
+	args.root = root;
+
+	inode = iget5_locked(s, objectid, btrfs_find_actor,
+			     btrfs_init_locked_inode,
+			     (void *)&args);
+	return inode;
+}
 
 static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 				   struct nameidata *nd)
@@ -486,7 +520,8 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 			return ERR_PTR(ret);
 		if (ret > 0)
 			return ERR_PTR(-ENOENT);
-		inode = iget_locked(dir->i_sb, location.objectid);
+		inode = btrfs_iget_locked(dir->i_sb, location.objectid,
+					  sub_root);
 		if (!inode)
 			return ERR_PTR(-EACCES);
 		if (inode->i_state & I_NEW) {
@@ -495,7 +530,7 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 						&root->fs_info->fs_roots_radix,
 						(unsigned long)sub_root,
 						sub_root);
-printk("adding new root for inode %lu\n", inode->i_ino);
+printk("adding new root for inode %lu root %p (found %p)\n", inode->i_ino, sub_root, BTRFS_I(inode)->root);
 				igrab(inode);
 				sub_root->inode = inode;
 			}
@@ -630,7 +665,8 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	       btrfs_super_total_blocks(disk_super),
 	       btrfs_super_root_dir(disk_super));
 
-	inode = iget_locked(sb, btrfs_super_root_dir(disk_super));
+	inode = btrfs_iget_locked(sb, btrfs_super_root_dir(disk_super),
+				  tree_root);
 	bi = BTRFS_I(inode);
 	bi->location.objectid = inode->i_ino;
 	bi->location.offset = 0;
@@ -750,7 +786,7 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	inode->i_mode = mode;
 	inode->i_ino = objectid;
 	inode->i_blocks = 0;
-	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
+	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	fill_inode_item(&inode_item, inode);
 
 	key->objectid = objectid;
@@ -1650,6 +1686,95 @@ static ssize_t btrfs_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
 	return retval;
 }
 
+static int create_snapshot(struct btrfs_root *root, char *name, int namelen)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_key key;
+	struct btrfs_root_item new_root_item;
+	int ret;
+	u64 objectid;
+
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	BUG_ON(!trans);
+
+	ret = btrfs_update_inode(trans, root, root->inode);
+	BUG_ON(ret);
+
+	ret = btrfs_find_free_objectid(trans, root, 0, &objectid);
+	BUG_ON(ret);
+
+	memset(&new_root_item, 0, sizeof(new_root_item));
+	memcpy(&new_root_item, &root->root_item,
+	       sizeof(new_root_item));
+
+	key.objectid = objectid;
+	key.flags = 0;
+	key.offset = 0;
+	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
+	ret = btrfs_insert_inode_map(trans, root, objectid, &key);
+	BUG_ON(ret);
+
+	key.objectid = objectid;
+	key.offset = 1;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_ROOT_ITEM_KEY);
+	btrfs_set_root_blocknr(&new_root_item, root->node->b_blocknr);
+
+	ret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,
+				&new_root_item);
+	BUG_ON(ret);
+
+printk("adding snapshot name %.*s root %Lu %Lu %u\n", namelen, name, key.objectid, key.offset, key.flags);
+
+	/*
+	 * insert the directory item
+	 */
+	key.offset = (u64)-1;
+	ret = btrfs_insert_dir_item(trans, root->fs_info->tree_root,
+				    name, namelen,
+				    root->fs_info->sb->s_root->d_inode->i_ino,
+				    &key, 0);
+
+	BUG_ON(ret);
+
+	ret = btrfs_inc_root_ref(trans, root);
+	BUG_ON(ret);
+
+	ret = btrfs_commit_transaction(trans, root);
+	BUG_ON(ret);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return 0;
+}
+
+static int btrfs_ioctl(struct inode *inode, struct file *filp, unsigned int
+		       cmd, unsigned long arg)
+{
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+	struct btrfs_ioctl_vol_args vol_args;
+	int ret;
+	int namelen;
+
+	if (!root->ref_cows)
+		return -EINVAL;
+	switch (cmd) {
+	case BTRFS_IOC_SNAP_CREATE:
+		if (copy_from_user(&vol_args,
+				   (struct btrfs_ioctl_vol_args __user *)arg,
+				   sizeof(vol_args)))
+			return -EFAULT;
+		namelen = strlen(vol_args.name);
+		if (namelen > BTRFS_VOL_NAME_MAX)
+			return -EINVAL;
+		ret = create_snapshot(root, vol_args.name, namelen);
+		WARN_ON(ret);
+		break;
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
+
 static struct kmem_cache *btrfs_inode_cachep;
 struct kmem_cache *btrfs_trans_handle_cachep;
 struct kmem_cache *btrfs_transaction_cachep;
@@ -1781,6 +1906,7 @@ static struct file_operations btrfs_dir_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= generic_read_dir,
 	.readdir	= btrfs_readdir,
+	.ioctl		= btrfs_ioctl,
 };
 
 static struct address_space_operations btrfs_aops = {
@@ -1803,6 +1929,7 @@ static struct file_operations btrfs_file_operations = {
 	.write		= btrfs_file_write,
 	.mmap		= generic_file_mmap,
 	.open		= generic_file_open,
+	.ioctl		= btrfs_ioctl,
 };
 
 static int __init init_btrfs_fs(void)

commit 0f7d52f4431c530b4f39c524448c688bb7754de5
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 9 10:42:37 2007 -0400

    Btrfs: groundwork for subvolume and snapshot roots
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 66d9fb2288c3..3c9236ca889c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -436,7 +436,6 @@ int fixup_tree_root_location(struct btrfs_root *root,
 {
 	struct btrfs_path *path;
 	struct btrfs_root_item *ri;
-	int ret;
 
 	if (btrfs_key_type(location) != BTRFS_ROOT_ITEM_KEY)
 		return 0;
@@ -447,22 +446,19 @@ int fixup_tree_root_location(struct btrfs_root *root,
 	BUG_ON(!path);
 	mutex_lock(&root->fs_info->fs_mutex);
 
-	ret = btrfs_lookup_inode(NULL, root, path, location, 0);
-	if (ret)
-		goto out;
-	ri = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
-			  path->slots[0],
-			  struct btrfs_root_item);
+	*sub_root = btrfs_read_fs_root(root->fs_info, location);
+	if (IS_ERR(*sub_root))
+		return PTR_ERR(*sub_root);
+
+	ri = &(*sub_root)->root_item;
 	location->objectid = btrfs_root_dirid(ri);
 	location->flags = 0;
 	btrfs_set_key_type(location, BTRFS_INODE_ITEM_KEY);
 	location->offset = 0;
-	/* FIXME properly select the root */
-	*sub_root = root->fs_info->fs_root;
-out:
+
 	btrfs_free_path(path);
 	mutex_unlock(&root->fs_info->fs_mutex);
-	return ret;
+	return 0;
 }
 
 
@@ -494,6 +490,15 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 		if (!inode)
 			return ERR_PTR(-EACCES);
 		if (inode->i_state & I_NEW) {
+			if (sub_root != root) {
+				ret = radix_tree_insert(
+						&root->fs_info->fs_roots_radix,
+						(unsigned long)sub_root,
+						sub_root);
+printk("adding new root for inode %lu\n", inode->i_ino);
+				igrab(inode);
+				sub_root->inode = inode;
+			}
 			BTRFS_I(inode)->root = sub_root;
 			memcpy(&BTRFS_I(inode)->location, &location,
 			       sizeof(location));
@@ -605,7 +610,7 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	struct inode * inode;
 	struct dentry * root_dentry;
 	struct btrfs_super_block *disk_super;
-	struct btrfs_root *root;
+	struct btrfs_root *tree_root;
 	struct btrfs_inode *bi;
 
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
@@ -613,14 +618,14 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	sb->s_op = &btrfs_super_ops;
 	sb->s_time_gran = 1;
 
-	root = open_ctree(sb);
+	tree_root = open_ctree(sb);
 
-	if (!root) {
+	if (!tree_root) {
 		printk("btrfs: open_ctree failed\n");
 		return -EIO;
 	}
-	sb->s_fs_info = root;
-	disk_super = root->fs_info->disk_super;
+	sb->s_fs_info = tree_root;
+	disk_super = tree_root->fs_info->disk_super;
 	printk("read in super total blocks %Lu root %Lu\n",
 	       btrfs_super_total_blocks(disk_super),
 	       btrfs_super_root_dir(disk_super));
@@ -630,7 +635,7 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	bi->location.objectid = inode->i_ino;
 	bi->location.offset = 0;
 	bi->location.flags = 0;
-	bi->root = root->fs_info->tree_root;
+	bi->root = tree_root;
 	btrfs_set_key_type(&bi->location, BTRFS_INODE_ITEM_KEY);
 
 	if (!inode)

commit d6e4a428eb8f92bbb3537ccabadfb1195efb432b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Apr 6 15:37:36 2007 -0400

    Btrfs: start of support for many FS volumes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 32224ffdcecd..66d9fb2288c3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -16,9 +16,23 @@
 #include "transaction.h"
 #include "btrfs_inode.h"
 
+void btrfs_fsinfo_release(struct kobject *obj)
+{
+	struct btrfs_fs_info *fsinfo = container_of(obj,
+					    struct btrfs_fs_info, kobj);
+	kfree(fsinfo);
+}
+
+struct kobj_type btrfs_fsinfo_ktype = {
+	.release = btrfs_fsinfo_release,
+};
+
+decl_subsys(btrfs, &btrfs_fsinfo_ktype, NULL);
+
 #define BTRFS_SUPER_MAGIC 0x9123682E
 
 static struct inode_operations btrfs_dir_inode_operations;
+static struct inode_operations btrfs_dir_ro_inode_operations;
 static struct super_operations btrfs_super_ops;
 static struct file_operations btrfs_dir_file_operations;
 static struct inode_operations btrfs_file_inode_operations;
@@ -37,7 +51,8 @@ static void btrfs_read_locked_inode(struct inode *inode)
 {
 	struct btrfs_path *path;
 	struct btrfs_inode_item *inode_item;
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+	struct btrfs_key location;
 	int ret;
 
 	path = btrfs_alloc_path();
@@ -46,13 +61,12 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	mutex_lock(&root->fs_info->fs_mutex);
 
 	check_inode(inode);
-	ret = btrfs_lookup_inode(NULL, root, path, inode->i_ino, 0);
+
+	memcpy(&location, &BTRFS_I(inode)->location, sizeof(location));
+	ret = btrfs_lookup_inode(NULL, root, path, &location, 0);
 	if (ret) {
-		btrfs_release_path(root, path);
 		btrfs_free_path(path);
-		mutex_unlock(&root->fs_info->fs_mutex);
-		make_bad_inode(inode);
-		return;
+		goto make_bad;
 	}
 	check_inode(inode);
 	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
@@ -73,7 +87,6 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	inode->i_blocks = btrfs_inode_nblocks(inode_item);
 	inode->i_generation = btrfs_inode_generation(inode_item);
 
-	btrfs_release_path(root, path);
 	btrfs_free_path(path);
 	inode_item = NULL;
 
@@ -92,8 +105,11 @@ static void btrfs_read_locked_inode(struct inode *inode)
 		inode->i_op = &btrfs_file_inode_operations;
 		break;
 	case S_IFDIR:
-		inode->i_op = &btrfs_dir_inode_operations;
 		inode->i_fop = &btrfs_dir_file_operations;
+		if (root == root->fs_info->tree_root)
+			inode->i_op = &btrfs_dir_ro_inode_operations;
+		else
+			inode->i_op = &btrfs_dir_inode_operations;
 		break;
 	case S_IFLNK:
 		// inode->i_op = &page_symlink_inode_operations;
@@ -101,6 +117,12 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	}
 	check_inode(inode);
 	return;
+
+make_bad:
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	make_bad_inode(inode);
 }
 
 static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
@@ -128,7 +150,7 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 	}
 	di = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
 			    struct btrfs_dir_item);
-	objectid = btrfs_dir_objectid(di);
+	objectid = btrfs_disk_key_objectid(&di->location);
 
 	ret = btrfs_del_item(trans, root, path);
 	BUG_ON(ret);
@@ -157,7 +179,7 @@ static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
 	struct btrfs_trans_handle *trans;
 	int ret;
 
-	root = btrfs_sb(dir->i_sb);
+	root = BTRFS_I(dir)->root;
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_unlink_trans(trans, root, dir, dentry);
@@ -171,7 +193,7 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 	struct inode *inode = dentry->d_inode;
 	int err;
 	int ret;
-	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_path *path;
 	struct btrfs_key key;
 	struct btrfs_trans_handle *trans;
@@ -268,7 +290,8 @@ static int btrfs_free_inode(struct btrfs_trans_handle *trans,
 	BUG_ON(ret);
 	btrfs_release_path(root, path);
 
-	ret = btrfs_lookup_inode(trans, root, path, objectid, -1);
+	ret = btrfs_lookup_inode(trans, root, path,
+				 &BTRFS_I(inode)->location, -1);
 	BUG_ON(ret);
 	ret = btrfs_del_item(trans, root, path);
 	BUG_ON(ret);
@@ -355,7 +378,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 static void btrfs_delete_inode(struct inode *inode)
 {
 	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
 	int ret;
 
 	truncate_inode_pages(&inode->i_data, 0);
@@ -378,13 +401,13 @@ static void btrfs_delete_inode(struct inode *inode)
 }
 
 static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
-			      ino_t *ino)
+			       struct btrfs_key *location)
 {
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct btrfs_dir_item *di;
 	struct btrfs_path *path;
-	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	struct btrfs_root *root = BTRFS_I(dir)->root;
 	int ret;
 
 	path = btrfs_alloc_path();
@@ -393,13 +416,13 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 	ret = btrfs_lookup_dir_item(NULL, root, path, dir->i_ino, name,
 				    namelen, 0);
 	if (ret || !btrfs_match_dir_item_name(root, path, name, namelen)) {
-		*ino = 0;
+		location->objectid = 0;
 		ret = 0;
 		goto out;
 	}
 	di = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
 			    struct btrfs_dir_item);
-	*ino = btrfs_dir_objectid(di);
+	btrfs_disk_key_to_cpu(location, &di->location);
 out:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
@@ -407,26 +430,76 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 	return ret;
 }
 
+int fixup_tree_root_location(struct btrfs_root *root,
+			     struct btrfs_key *location,
+			     struct btrfs_root **sub_root)
+{
+	struct btrfs_path *path;
+	struct btrfs_root_item *ri;
+	int ret;
+
+	if (btrfs_key_type(location) != BTRFS_ROOT_ITEM_KEY)
+		return 0;
+	if (location->objectid == BTRFS_ROOT_TREE_OBJECTID)
+		return 0;
+
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	mutex_lock(&root->fs_info->fs_mutex);
+
+	ret = btrfs_lookup_inode(NULL, root, path, location, 0);
+	if (ret)
+		goto out;
+	ri = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+			  path->slots[0],
+			  struct btrfs_root_item);
+	location->objectid = btrfs_root_dirid(ri);
+	location->flags = 0;
+	btrfs_set_key_type(location, BTRFS_INODE_ITEM_KEY);
+	location->offset = 0;
+	/* FIXME properly select the root */
+	*sub_root = root->fs_info->fs_root;
+out:
+	btrfs_free_path(path);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return ret;
+}
+
+
 static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 				   struct nameidata *nd)
 {
 	struct inode * inode;
-	struct btrfs_root *root = btrfs_sb(dir->i_sb);
-	ino_t ino;
+	struct btrfs_inode *bi = BTRFS_I(dir);
+	struct btrfs_root *root = bi->root;
+	struct btrfs_root *sub_root = root;
+	struct btrfs_key location;
 	int ret;
 
 	if (dentry->d_name.len > BTRFS_NAME_LEN)
 		return ERR_PTR(-ENAMETOOLONG);
 	mutex_lock(&root->fs_info->fs_mutex);
-	ret = btrfs_inode_by_name(dir, dentry, &ino);
+	ret = btrfs_inode_by_name(dir, dentry, &location);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	if (ret < 0)
 		return ERR_PTR(ret);
 	inode = NULL;
-	if (ino) {
-		inode = iget(dir->i_sb, ino);
+	if (location.objectid) {
+		ret = fixup_tree_root_location(root, &location, &sub_root);
+		if (ret < 0)
+			return ERR_PTR(ret);
+		if (ret > 0)
+			return ERR_PTR(-ENOENT);
+		inode = iget_locked(dir->i_sb, location.objectid);
 		if (!inode)
 			return ERR_PTR(-EACCES);
+		if (inode->i_state & I_NEW) {
+			BTRFS_I(inode)->root = sub_root;
+			memcpy(&BTRFS_I(inode)->location, &location,
+			       sizeof(location));
+			btrfs_read_locked_inode(inode);
+			unlock_new_inode(inode);
+		}
 		check_inode(inode);
 	}
 	check_inode(dir);
@@ -436,7 +509,7 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct inode *inode = filp->f_path.dentry->d_inode;
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_item *item;
 	struct btrfs_dir_item *di;
 	struct btrfs_key key;
@@ -448,11 +521,16 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	int advance;
 	unsigned char d_type = DT_UNKNOWN;
 	int over = 0;
+	int key_type = BTRFS_DIR_INDEX_KEY;
+
+	/* FIXME, use a real flag for deciding about the key type */
+	if (root->fs_info->tree_root == root)
+		key_type = BTRFS_DIR_ITEM_KEY;
 
 	mutex_lock(&root->fs_info->fs_mutex);
 	key.objectid = inode->i_ino;
 	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_DIR_INDEX_KEY);
+	btrfs_set_key_type(&key, key_type);
 	key.offset = filp->f_pos;
 	path = btrfs_alloc_path();
 	btrfs_init_path(path);
@@ -482,10 +560,11 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		item = leaf->items + slot;
 		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
 			break;
-		if (btrfs_disk_key_offset(&item->key) >
+		if (key_type == BTRFS_DIR_INDEX_KEY &&
+		    btrfs_disk_key_offset(&item->key) >
 		    root->fs_info->highest_inode)
 			break;
-		if (btrfs_disk_key_type(&item->key) != BTRFS_DIR_INDEX_KEY)
+		if (btrfs_disk_key_type(&item->key) != key_type)
 			continue;
 		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)
 			continue;
@@ -495,7 +574,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		over = filldir(dirent, (const char *)(di + 1),
 			       btrfs_dir_name_len(di),
 			       btrfs_disk_key_offset(&item->key),
-			       btrfs_dir_objectid(di), d_type);
+			       btrfs_disk_key_objectid(&di->location), d_type);
 		if (over)
 			goto nopos;
 	}
@@ -527,6 +606,7 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	struct dentry * root_dentry;
 	struct btrfs_super_block *disk_super;
 	struct btrfs_root *root;
+	struct btrfs_inode *bi;
 
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	sb->s_magic = BTRFS_SUPER_MAGIC;
@@ -546,6 +626,13 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	       btrfs_super_root_dir(disk_super));
 
 	inode = iget_locked(sb, btrfs_super_root_dir(disk_super));
+	bi = BTRFS_I(inode);
+	bi->location.objectid = inode->i_ino;
+	bi->location.offset = 0;
+	bi->location.flags = 0;
+	bi->root = root->fs_info->tree_root;
+	btrfs_set_key_type(&bi->location, BTRFS_INODE_ITEM_KEY);
+
 	if (!inode)
 		return -ENOMEM;
 	if (inode->i_state & I_NEW) {
@@ -594,7 +681,8 @@ static int btrfs_update_inode(struct btrfs_trans_handle *trans,
 	BUG_ON(!path);
 	btrfs_init_path(path);
 
-	ret = btrfs_lookup_inode(trans, root, path, inode->i_ino, 1);
+	ret = btrfs_lookup_inode(trans, root, path,
+				 &BTRFS_I(inode)->location, 1);
 	if (ret) {
 		if (ret > 0)
 			ret = -ENOENT;
@@ -616,7 +704,7 @@ static int btrfs_update_inode(struct btrfs_trans_handle *trans,
 
 static int btrfs_write_inode(struct inode *inode, int wait)
 {
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_trans_handle *trans;
 	int ret;
 
@@ -637,8 +725,8 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 {
 	struct inode *inode;
 	struct btrfs_inode_item inode_item;
-	struct btrfs_root *root = btrfs_sb(dir->i_sb);
-	struct btrfs_key key;
+	struct btrfs_root *root = BTRFS_I(dir)->root;
+	struct btrfs_key *key;
 	int ret;
 	u64 objectid;
 
@@ -646,6 +734,8 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
 
+	BTRFS_I(inode)->root = BTRFS_I(dir)->root;
+	key = &BTRFS_I(inode)->location;
 	check_inode(inode);
 	ret = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
 	BUG_ON(ret);
@@ -658,11 +748,11 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
 	fill_inode_item(&inode_item, inode);
 
-	key.objectid = objectid;
-	key.flags = 0;
-	key.offset = 0;
-	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
-	ret = btrfs_insert_inode_map(trans, root, objectid, &key);
+	key->objectid = objectid;
+	key->flags = 0;
+	key->offset = 0;
+	btrfs_set_key_type(key, BTRFS_INODE_ITEM_KEY);
+	ret = btrfs_insert_inode_map(trans, root, objectid, key);
 	BUG_ON(ret);
 
 	ret = btrfs_insert_inode(trans, root, objectid, &inode_item);
@@ -678,13 +768,20 @@ static int btrfs_add_link(struct btrfs_trans_handle *trans,
 			    struct dentry *dentry, struct inode *inode)
 {
 	int ret;
-	ret = btrfs_insert_dir_item(trans, btrfs_sb(inode->i_sb),
+	struct btrfs_key key;
+	struct btrfs_root *root = BTRFS_I(dentry->d_parent->d_inode)->root;
+	key.objectid = inode->i_ino;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
+	key.offset = 0;
+
+	ret = btrfs_insert_dir_item(trans, root,
 				    dentry->d_name.name, dentry->d_name.len,
 				    dentry->d_parent->d_inode->i_ino,
-				    inode->i_ino, 0);
+				    &key, 0);
 	if (ret == 0) {
 		dentry->d_parent->d_inode->i_size += dentry->d_name.len * 2;
-		ret = btrfs_update_inode(trans, btrfs_sb(inode->i_sb),
+		ret = btrfs_update_inode(trans, root,
 					 dentry->d_parent->d_inode);
 	}
 	check_inode(inode);
@@ -710,7 +807,7 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 			int mode, struct nameidata *nd)
 {
 	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct inode *inode;
 	int err;
 	int drop_inode = 0;
@@ -747,18 +844,26 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
 				struct inode *inode, struct inode *dir)
 {
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(dir)->root;
 	int ret;
 	char buf[2];
+	struct btrfs_key key;
+
 	buf[0] = '.';
 	buf[1] = '.';
 
+	key.objectid = inode->i_ino;
+	key.offset = 0;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
+
 	ret = btrfs_insert_dir_item(trans, root, buf, 1, inode->i_ino,
-				    inode->i_ino, 1);
+				    &key, 1);
 	if (ret)
 		goto error;
+	key.objectid = dir->i_ino;
 	ret = btrfs_insert_dir_item(trans, root, buf, 2, inode->i_ino,
-				    dir->i_ino, 1);
+				    &key, 1);
 	if (ret)
 		goto error;
 	inode->i_size = 6;
@@ -771,7 +876,7 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	struct inode *inode;
 	struct btrfs_trans_handle *trans;
-	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	struct btrfs_root *root = BTRFS_I(dir)->root;
 	int err = 0;
 	int drop_on_err = 0;
 
@@ -910,7 +1015,7 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	u64 extent_end = 0;
 	u64 objectid = inode->i_ino;
 	struct btrfs_path *path;
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_trans_handle *trans = NULL;
 	struct btrfs_file_extent_item *item;
 	struct btrfs_leaf *leaf;
@@ -999,7 +1104,7 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 			   struct buffer_head *result, int create)
 {
 	int err;
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
 	mutex_lock(&root->fs_info->fs_mutex);
 	err = btrfs_get_block_lock(inode, iblock, result, create);
 	// err = btrfs_get_block_inline(inode, iblock, result, create);
@@ -1041,7 +1146,7 @@ static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 
 static void btrfs_truncate(struct inode *inode)
 {
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
 	int ret;
 	struct btrfs_trans_handle *trans;
 
@@ -1208,7 +1313,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	int err = 0;
 	int ret = 0;
 	struct inode *inode = file->f_path.dentry->d_inode;
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct page *pages[1];
 
 	if (file->f_flags & O_DIRECT)
@@ -1365,7 +1470,7 @@ static ssize_t btrfs_file_inline_write(struct file *file,
 	int err = 0;
 	int ret = 0;
 	struct inode *inode = file->f_path.dentry->d_inode;
-	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
 	unsigned long page_index;
 
 	if (file->f_flags & O_DIRECT)
@@ -1432,13 +1537,14 @@ static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
 {
 	char *kaddr;
 	unsigned long left, count = desc->count;
+	struct inode *inode = page->mapping->host;
 
 	if (size > count)
 		size = count;
 
 	if (!PageChecked(page)) {
 		/* FIXME, do it per block */
-		struct btrfs_root *root = btrfs_sb(page->mapping->host->i_sb);
+		struct btrfs_root *root = BTRFS_I(inode)->root;
 		int ret = btrfs_csum_verify_file_block(root,
 					  page->mapping->host->i_ino,
 					  page->index << PAGE_CACHE_SHIFT,
@@ -1662,6 +1768,10 @@ static struct inode_operations btrfs_dir_inode_operations = {
 	.rmdir		= btrfs_rmdir,
 };
 
+static struct inode_operations btrfs_dir_ro_inode_operations = {
+	.lookup		= btrfs_lookup,
+};
+
 static struct file_operations btrfs_dir_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= generic_read_dir,
@@ -1697,13 +1807,21 @@ static int __init init_btrfs_fs(void)
 	err = init_inodecache();
 	if (err)
 		return err;
+	kset_set_kset_s(&btrfs_subsys, fs_subsys);
+	err = subsystem_register(&btrfs_subsys);
+	if (err)
+		goto out;
 	return register_filesystem(&btrfs_fs_type);
+out:
+	destroy_inodecache();
+	return err;
 }
 
 static void __exit exit_btrfs_fs(void)
 {
 	destroy_inodecache();
 	unregister_filesystem(&btrfs_fs_type);
+	subsystem_unregister(&btrfs_subsys);
 	printk("btrfs unloaded\n");
 }
 

commit 3eb0314dc1053b1ae617dcc8d6d93f776c5baa31
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 5 14:28:50 2007 -0400

    Btrfs: uuids
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d4ee78046b86..32224ffdcecd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -483,10 +483,8 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
 			break;
 		if (btrfs_disk_key_offset(&item->key) >
-		    root->fs_info->highest_inode) {
-printk("stopping at highest inode %Lu\n", root->fs_info->highest_inode);
+		    root->fs_info->highest_inode)
 			break;
-		}
 		if (btrfs_disk_key_type(&item->key) != BTRFS_DIR_INDEX_KEY)
 			continue;
 		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)

commit 5be6f7f174146d91039a27ebb2f1b4ac599172b3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 5 13:35:25 2007 -0400

    Btrfs: dirindex optimizations
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4fd2b168b2c4..d4ee78046b86 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -482,6 +482,11 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		item = leaf->items + slot;
 		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
 			break;
+		if (btrfs_disk_key_offset(&item->key) >
+		    root->fs_info->highest_inode) {
+printk("stopping at highest inode %Lu\n", root->fs_info->highest_inode);
+			break;
+		}
 		if (btrfs_disk_key_type(&item->key) != BTRFS_DIR_INDEX_KEY)
 			continue;
 		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)

commit 7fcde0e3298c00ee18e2ae7f01c67f99133ef7be
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 5 12:13:21 2007 -0400

    Btrfs: finish off inode indexing in dirs, add overflows
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index d776b29a1676..4fd2b168b2c4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -486,19 +486,18 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 			continue;
 		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)
 			continue;
-
+		filp->f_pos = btrfs_disk_key_offset(&item->key);
 		advance = 1;
 		di = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);
 		over = filldir(dirent, (const char *)(di + 1),
 			       btrfs_dir_name_len(di),
 			       btrfs_disk_key_offset(&item->key),
 			       btrfs_dir_objectid(di), d_type);
-		if (over) {
-			filp->f_pos = btrfs_disk_key_offset(&item->key);
-			break;
-		}
-		filp->f_pos = btrfs_disk_key_offset(&item->key) + 1;
+		if (over)
+			goto nopos;
 	}
+	filp->f_pos++;
+nopos:
 	ret = 0;
 err:
 	btrfs_release_path(root, path);

commit 5f26f772e5c4e833ffcb0599f54deda466d2a3e5
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Apr 5 10:38:44 2007 -0400

    Btrfs: more inode indexed directory work
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4b042460e875..d776b29a1676 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -130,6 +130,13 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 			    struct btrfs_dir_item);
 	objectid = btrfs_dir_objectid(di);
 
+	ret = btrfs_del_item(trans, root, path);
+	BUG_ON(ret);
+
+	btrfs_release_path(root, path);
+	ret = btrfs_lookup_dir_index_item(trans, root, path, dir->i_ino,
+					  objectid, -1);
+	BUG_ON(ret);
 	ret = btrfs_del_item(trans, root, path);
 	BUG_ON(ret);
 	dentry->d_inode->i_ctime = dir->i_ctime;
@@ -138,7 +145,7 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 	btrfs_free_path(path);
 	if (ret == 0) {
 		inode_dec_link_count(dentry->d_inode);
-		dir->i_size -= name_len;
+		dir->i_size -= name_len * 2;
 		mark_inode_dirty(dir);
 	}
 	return ret;
@@ -168,8 +175,10 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 	struct btrfs_path *path;
 	struct btrfs_key key;
 	struct btrfs_trans_handle *trans;
-	struct btrfs_disk_key *found_key;
+	struct btrfs_key found_key;
+	int found_type;
 	struct btrfs_leaf *leaf;
+	char *goodnames = "..";
 
 	path = btrfs_alloc_path();
 	BUG_ON(!path);
@@ -178,46 +187,42 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 	trans = btrfs_start_transaction(root, 1);
 	key.objectid = inode->i_ino;
 	key.offset = (u64)-1;
-	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);
-	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
-	if (ret < 0) {
-		err = ret;
-		goto out;
-	}
+	key.flags = (u32)-1;
+	while(1) {
+		ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
+		if (ret < 0) {
+			err = ret;
+			goto out;
+		}
+		BUG_ON(ret == 0);
+		if (path->slots[0] == 0) {
+			err = -ENOENT;
+			goto out;
+		}
+		path->slots[0]--;
+		leaf = btrfs_buffer_leaf(path->nodes[0]);
+		btrfs_disk_key_to_cpu(&found_key,
+				      &leaf->items[path->slots[0]].key);
+		found_type = btrfs_key_type(&found_key);
+		if (found_key.objectid != inode->i_ino) {
+			err = -ENOENT;
+			goto out;
+		}
+		if ((found_type != BTRFS_DIR_ITEM_KEY &&
+		     found_type != BTRFS_DIR_INDEX_KEY) ||
+	            (!btrfs_match_dir_item_name(root, path, goodnames, 2) &&
+	            !btrfs_match_dir_item_name(root, path, goodnames, 1))) {
+			err = -ENOTEMPTY;
+			goto out;
+		}
+		ret = btrfs_del_item(trans, root, path);
+		BUG_ON(ret);
 
-	BUG_ON(ret == 0);
-	BUG_ON(path->slots[0] == 0);
-	path->slots[0]--;
-	leaf = btrfs_buffer_leaf(path->nodes[0]);
-	found_key = &leaf->items[path->slots[0]].key;
-	if (btrfs_disk_key_objectid(found_key) != inode->i_ino) {
-		err = -ENOENT;
-		goto out;
-	}
-	if (btrfs_disk_key_type(found_key) != BTRFS_DIR_ITEM_KEY ||
-	    btrfs_disk_key_offset(found_key) != 2) {
-		err = -ENOTEMPTY;
-		goto out;
-	}
-	ret = btrfs_del_item(trans, root, path);
-	BUG_ON(ret);
-	btrfs_release_path(root, path);
-	key.offset = 1;
-	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
-	if (ret < 0) {
-		err = ret;
-		goto out;
-	}
-	if (ret > 0) {
-		err = -ENOTEMPTY;
-		goto out;
-	}
-	ret = btrfs_del_item(trans, root, path);
-	if (ret) {
-		err = ret;
-		goto out;
+		if (found_type == BTRFS_DIR_ITEM_KEY && found_key.offset == 1)
+			break;
+		btrfs_release_path(root, path);
 	}
+	ret = 0;
 	btrfs_release_path(root, path);
 
 	/* now the directory is empty */
@@ -676,7 +681,7 @@ static int btrfs_add_link(struct btrfs_trans_handle *trans,
 				    dentry->d_parent->d_inode->i_ino,
 				    inode->i_ino, 0);
 	if (ret == 0) {
-		dentry->d_parent->d_inode->i_size += dentry->d_name.len;
+		dentry->d_parent->d_inode->i_size += dentry->d_name.len * 2;
 		ret = btrfs_update_inode(trans, btrfs_sb(inode->i_sb),
 					 dentry->d_parent->d_inode);
 	}
@@ -754,7 +759,7 @@ static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
 				    dir->i_ino, 1);
 	if (ret)
 		goto error;
-	inode->i_size = 3;
+	inode->i_size = 6;
 	ret = btrfs_update_inode(trans, root, inode);
 error:
 	return ret;
@@ -915,7 +920,6 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	if (create)
 		trans = btrfs_start_transaction(root, 1);
 
-
 	ret = btrfs_lookup_file_extent(trans, root, path,
 				       inode->i_ino,
 				       iblock << inode->i_blkbits, 0);

commit bae45de03c4d54a9893dedf8a015beb2608b896a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 4 21:22:22 2007 -0400

    Btrfs: add dir inode index
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 822243650ae9..4b042460e875 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -447,7 +447,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	mutex_lock(&root->fs_info->fs_mutex);
 	key.objectid = inode->i_ino;
 	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);
+	btrfs_set_key_type(&key, BTRFS_DIR_INDEX_KEY);
 	key.offset = filp->f_pos;
 	path = btrfs_alloc_path();
 	btrfs_init_path(path);
@@ -477,7 +477,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		item = leaf->items + slot;
 		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
 			break;
-		if (btrfs_disk_key_type(&item->key) != BTRFS_DIR_ITEM_KEY)
+		if (btrfs_disk_key_type(&item->key) != BTRFS_DIR_INDEX_KEY)
 			continue;
 		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)
 			continue;

commit e8f05c4508aed906146919f2efa89242a7f90a8b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 4 14:30:09 2007 -0400

    Btrfs: disable inline data code for now
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0afb6cece82c..822243650ae9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -824,6 +824,7 @@ printk("btrfs sync_fs\n");
 	return 0;
 }
 
+#if 0
 static int btrfs_get_block_inline(struct inode *inode, sector_t iblock,
 			   struct buffer_head *result, int create)
 {
@@ -890,6 +891,7 @@ static int btrfs_get_block_inline(struct inode *inode, sector_t iblock,
 	kunmap(result->b_page);
 	return err;
 }
+#endif
 
 static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 			   struct buffer_head *result, int create)
@@ -993,8 +995,8 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 	int err;
 	struct btrfs_root *root = btrfs_sb(inode->i_sb);
 	mutex_lock(&root->fs_info->fs_mutex);
-	// err = btrfs_get_block_lock(inode, iblock, result, create);
-	err = btrfs_get_block_inline(inode, iblock, result, create);
+	err = btrfs_get_block_lock(inode, iblock, result, create);
+	// err = btrfs_get_block_inline(inode, iblock, result, create);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	return err;
 }
@@ -1002,13 +1004,11 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 static int btrfs_prepare_write(struct file *file, struct page *page,
 			       unsigned from, unsigned to)
 {
-	WARN_ON(1);
 	return nobh_prepare_write(page, from, to, btrfs_get_block);
 }
 static int btrfs_commit_write(struct file *file, struct page *page,
 			       unsigned from, unsigned to)
 {
-	WARN_ON(1);
 	return nobh_commit_write(file, page, from, to);
 }
 
@@ -1044,7 +1044,7 @@ static void btrfs_truncate(struct inode *inode)
 	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
 		return;
 
-	// nobh_truncate_page(inode->i_mapping, inode->i_size);
+	nobh_truncate_page(inode->i_mapping, inode->i_size);
 
 	/* FIXME, add redo link to tree so we don't leak on crash */
 	mutex_lock(&root->fs_info->fs_mutex);
@@ -1253,6 +1253,7 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	return num_written ? num_written : err;
 }
 
+#if 0
 static ssize_t inline_one_page(struct btrfs_root *root, struct inode *inode,
 			   struct page *page, loff_t pos,
 			   size_t offset, size_t write_bytes)
@@ -1418,6 +1419,7 @@ static ssize_t btrfs_file_inline_write(struct file *file,
 	current->backing_dev_info = NULL;
 	return num_written ? num_written : err;
 }
+#endif
 
 static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
 			unsigned long offset, unsigned long size)
@@ -1662,7 +1664,7 @@ static struct file_operations btrfs_dir_file_operations = {
 
 static struct address_space_operations btrfs_aops = {
 	.readpage	= btrfs_readpage,
-	// .readpages	= btrfs_readpages,
+	.readpages	= btrfs_readpages,
 	.writepage	= btrfs_writepage,
 	.sync_page	= block_sync_page,
 	.prepare_write	= btrfs_prepare_write,
@@ -1676,8 +1678,8 @@ static struct inode_operations btrfs_file_inode_operations = {
 static struct file_operations btrfs_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
-	.aio_read       = generic_file_aio_read,
-	.write		= btrfs_file_inline_write,
+	.aio_read       = btrfs_file_aio_read,
+	.write		= btrfs_file_write,
 	.mmap		= generic_file_mmap,
 	.open		= generic_file_open,
 };

commit d4dbff953e1f6f4079126c0404cc24f2ef14e925
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 4 14:08:15 2007 -0400

    Btrfs: support for items bigger than 1/2 the blocksize
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 68127b8462ab..0afb6cece82c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -136,8 +136,11 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 err:
 	btrfs_release_path(root, path);
 	btrfs_free_path(path);
-	if (ret == 0)
+	if (ret == 0) {
 		inode_dec_link_count(dentry->d_inode);
+		dir->i_size -= name_len;
+		mark_inode_dirty(dir);
+	}
 	return ret;
 }
 
@@ -290,6 +293,10 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	key.objectid = inode->i_ino;
 	key.offset = (u64)-1;
 	key.flags = 0;
+	/*
+	 * use BTRFS_CSUM_ITEM_KEY because it is larger than inline keys
+	 * or extent data
+	 */
 	btrfs_set_key_type(&key, BTRFS_CSUM_ITEM_KEY);
 	while(1) {
 		btrfs_init_path(path);
@@ -306,6 +313,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 		if (btrfs_disk_key_objectid(found_key) != inode->i_ino)
 			break;
 		if (btrfs_disk_key_type(found_key) != BTRFS_CSUM_ITEM_KEY &&
+		    btrfs_disk_key_type(found_key) != BTRFS_INLINE_DATA_KEY &&
 		    btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY)
 			break;
 		if (btrfs_disk_key_offset(found_key) < inode->i_size)
@@ -1036,7 +1044,7 @@ static void btrfs_truncate(struct inode *inode)
 	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
 		return;
 
-	nobh_truncate_page(inode->i_mapping, inode->i_size);
+	// nobh_truncate_page(inode->i_mapping, inode->i_size);
 
 	/* FIXME, add redo link to tree so we don't leak on crash */
 	mutex_lock(&root->fs_info->fs_mutex);
@@ -1309,7 +1317,9 @@ static ssize_t inline_one_page(struct btrfs_root *root, struct inode *inode,
 	}
 insert:
 	btrfs_release_path(root, path);
-	copy_size = min(write_bytes, (size_t)512);
+	copy_size = min(write_bytes,
+			(size_t)BTRFS_LEAF_DATA_SIZE(root) -
+			sizeof(struct btrfs_item) * 4);
 	ret = btrfs_insert_empty_item(trans, root, path, &key, copy_size);
 	BUG_ON(ret);
 	dst = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),

commit df24a2b9c9bcef3348e4b1a8f206cd484a248d36
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Apr 4 09:36:31 2007 -0400

    Btrfs: early inline file data code
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index fbc26eafc58c..68127b8462ab 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -816,6 +816,73 @@ printk("btrfs sync_fs\n");
 	return 0;
 }
 
+static int btrfs_get_block_inline(struct inode *inode, sector_t iblock,
+			   struct buffer_head *result, int create)
+{
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_path *path;
+	struct btrfs_key key;
+	struct btrfs_leaf *leaf;
+	int num_bytes = result->b_size;
+	int item_size;
+	int ret;
+	u64 pos;
+	char *ptr;
+	int copy_size;
+	int err = 0;
+	char *safe_ptr;
+	char *data_ptr;
+
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+
+	WARN_ON(create);
+	if (create) {
+		return 0;
+	}
+	pos = iblock << inode->i_blkbits;
+	key.objectid = inode->i_ino;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_INLINE_DATA_KEY);
+	ptr = kmap(result->b_page);
+	safe_ptr = ptr;
+	ptr += (pos & (PAGE_CACHE_SIZE -1));
+again:
+	key.offset = pos;
+	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
+	if (ret) {
+		if (ret < 0)
+			err = ret;
+		else
+			err = 0;
+		goto out;
+	}
+	leaf = btrfs_buffer_leaf(path->nodes[0]);
+	item_size = btrfs_item_size(leaf->items + path->slots[0]);
+	copy_size = min(num_bytes, item_size);
+	data_ptr = btrfs_item_ptr(leaf, path->slots[0], char);
+	WARN_ON(safe_ptr + PAGE_CACHE_SIZE < ptr + copy_size);
+	memcpy(ptr, data_ptr, copy_size);
+	pos += copy_size;
+	num_bytes -= copy_size;
+	WARN_ON(num_bytes < 0);
+	ptr += copy_size;
+	btrfs_release_path(root, path);
+	if (num_bytes != 0) {
+		if (pos >= i_size_read(inode))
+			memset(ptr, 0, num_bytes);
+		else
+			goto again;
+	}
+	set_buffer_uptodate(result);
+	map_bh(result, inode->i_sb, 0);
+	err = 0;
+out:
+	btrfs_free_path(path);
+	kunmap(result->b_page);
+	return err;
+}
+
 static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 			   struct buffer_head *result, int create)
 {
@@ -918,7 +985,8 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 	int err;
 	struct btrfs_root *root = btrfs_sb(inode->i_sb);
 	mutex_lock(&root->fs_info->fs_mutex);
-	err = btrfs_get_block_lock(inode, iblock, result, create);
+	// err = btrfs_get_block_lock(inode, iblock, result, create);
+	err = btrfs_get_block_inline(inode, iblock, result, create);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	return err;
 }
@@ -1177,6 +1245,170 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	return num_written ? num_written : err;
 }
 
+static ssize_t inline_one_page(struct btrfs_root *root, struct inode *inode,
+			   struct page *page, loff_t pos,
+			   size_t offset, size_t write_bytes)
+{
+	struct btrfs_path *path;
+	struct btrfs_trans_handle *trans;
+	struct btrfs_key key;
+	struct btrfs_leaf *leaf;
+	struct btrfs_key found_key;
+	int ret;
+	size_t copy_size = 0;
+	char *dst = NULL;
+	int err = 0;
+	size_t num_written = 0;
+
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	key.objectid = inode->i_ino;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_INLINE_DATA_KEY);
+
+again:
+	key.offset = pos;
+	ret = btrfs_search_slot(trans, root, &key, path, 0, 1);
+	if (ret < 0) {
+		err = ret;
+		goto out;
+	}
+	if (ret == 0) {
+		leaf = btrfs_buffer_leaf(path->nodes[0]);
+		btrfs_disk_key_to_cpu(&found_key,
+				      &leaf->items[path->slots[0]].key);
+		copy_size = btrfs_item_size(leaf->items + path->slots[0]);
+		dst = btrfs_item_ptr(leaf, path->slots[0], char);
+		copy_size = min(write_bytes, copy_size);
+		goto copyit;
+	} else {
+		int slot = path->slots[0];
+		if (slot > 0) {
+			slot--;
+		}
+		// FIXME find max key
+		leaf = btrfs_buffer_leaf(path->nodes[0]);
+		btrfs_disk_key_to_cpu(&found_key,
+				      &leaf->items[slot].key);
+		if (found_key.objectid != inode->i_ino)
+			goto insert;
+		if (btrfs_key_type(&found_key) != BTRFS_INLINE_DATA_KEY)
+			goto insert;
+		copy_size = btrfs_item_size(leaf->items + slot);
+		if (found_key.offset + copy_size <= pos)
+			goto insert;
+		dst = btrfs_item_ptr(leaf, path->slots[0], char);
+		dst += pos - found_key.offset;
+		copy_size = copy_size - (pos - found_key.offset);
+		BUG_ON(copy_size < 0);
+		copy_size = min(write_bytes, copy_size);
+		WARN_ON(copy_size == 0);
+		goto copyit;
+	}
+insert:
+	btrfs_release_path(root, path);
+	copy_size = min(write_bytes, (size_t)512);
+	ret = btrfs_insert_empty_item(trans, root, path, &key, copy_size);
+	BUG_ON(ret);
+	dst = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+			     path->slots[0], char);
+copyit:
+	WARN_ON(copy_size == 0);
+	WARN_ON(dst + copy_size >
+		btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+						 path->slots[0], char) +
+		btrfs_item_size(btrfs_buffer_leaf(path->nodes[0])->items +
+						  path->slots[0]));
+	btrfs_memcpy(root, path->nodes[0]->b_data, dst,
+		     page_address(page) + offset, copy_size);
+	mark_buffer_dirty(path->nodes[0]);
+	btrfs_release_path(root, path);
+	pos += copy_size;
+	offset += copy_size;
+	num_written += copy_size;
+	write_bytes -= copy_size;
+	if (write_bytes)
+		goto again;
+out:
+	btrfs_free_path(path);
+	ret = btrfs_end_transaction(trans, root);
+	BUG_ON(ret);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return num_written ? num_written : err;
+}
+
+static ssize_t btrfs_file_inline_write(struct file *file,
+				       const char __user *buf,
+				       size_t count, loff_t *ppos)
+{
+	loff_t pos;
+	size_t num_written = 0;
+	int err = 0;
+	int ret = 0;
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	unsigned long page_index;
+
+	if (file->f_flags & O_DIRECT)
+		return -EINVAL;
+	pos = *ppos;
+
+	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
+	current->backing_dev_info = inode->i_mapping->backing_dev_info;
+	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
+	if (err)
+		goto out;
+	if (count == 0)
+		goto out;
+	err = remove_suid(file->f_path.dentry);
+	if (err)
+		goto out;
+	file_update_time(file);
+	mutex_lock(&inode->i_mutex);
+	while(count > 0) {
+		size_t offset = pos & (PAGE_CACHE_SIZE - 1);
+		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
+		struct page *page;
+
+		page_index = pos >> PAGE_CACHE_SHIFT;
+		page = grab_cache_page(inode->i_mapping, page_index);
+		if (!PageUptodate(page)) {
+			ret = mpage_readpage(page, btrfs_get_block);
+			BUG_ON(ret);
+			lock_page(page);
+		}
+		ret = btrfs_copy_from_user(pos, 1,
+					   write_bytes, &page, buf);
+		BUG_ON(ret);
+		write_bytes = inline_one_page(root, inode, page, pos,
+				      offset, write_bytes);
+		SetPageUptodate(page);
+		if (write_bytes > 0 && pos + write_bytes > inode->i_size) {
+			i_size_write(inode, pos + write_bytes);
+			mark_inode_dirty(inode);
+		}
+		page_cache_release(page);
+		unlock_page(page);
+		if (write_bytes < 0)
+			goto out_unlock;
+		buf += write_bytes;
+		count -= write_bytes;
+		pos += write_bytes;
+		num_written += write_bytes;
+
+		balance_dirty_pages_ratelimited(inode->i_mapping);
+		cond_resched();
+	}
+out_unlock:
+	mutex_unlock(&inode->i_mutex);
+out:
+	*ppos = pos;
+	current->backing_dev_info = NULL;
+	return num_written ? num_written : err;
+}
+
 static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
 			unsigned long offset, unsigned long size)
 {
@@ -1420,7 +1652,7 @@ static struct file_operations btrfs_dir_file_operations = {
 
 static struct address_space_operations btrfs_aops = {
 	.readpage	= btrfs_readpage,
-	.readpages	= btrfs_readpages,
+	// .readpages	= btrfs_readpages,
 	.writepage	= btrfs_writepage,
 	.sync_page	= block_sync_page,
 	.prepare_write	= btrfs_prepare_write,
@@ -1434,8 +1666,8 @@ static struct inode_operations btrfs_file_inode_operations = {
 static struct file_operations btrfs_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
-	.aio_read       = btrfs_file_aio_read,
-	.write		= btrfs_file_write,
+	.aio_read       = generic_file_aio_read,
+	.write		= btrfs_file_inline_write,
 	.mmap		= generic_file_mmap,
 	.open		= generic_file_open,
 };

commit 2da566edd8ce32ae2952b863ee634bcc2e7d63c1
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 2 15:43:21 2007 -0400

    Btrfs: csum_verify_file_block locking fix
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 9fd87f5edbc9..fbc26eafc58c 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1316,7 +1316,6 @@ static void btrfs_destroy_inode(struct inode *inode)
 	WARN_ON(ei->magic != 0xDEADBEEF);
 	WARN_ON(ei->magic2 != 0xDEADBEAF);
 	WARN_ON(!list_empty(&inode->i_dentry));
-	WARN_ON(inode->i_ino == 1);
 	WARN_ON(inode->i_data.nrpages);
 
 	ei->magic = 0;

commit 7cfcc17e7f2334a0503331264c1340de4e564c85
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 2 14:53:59 2007 -0400

    Btrfs: corruptions fixed
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index c260fcad17b3..9fd87f5edbc9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -49,6 +49,7 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	ret = btrfs_lookup_inode(NULL, root, path, inode->i_ino, 0);
 	if (ret) {
 		btrfs_release_path(root, path);
+		btrfs_free_path(path);
 		mutex_unlock(&root->fs_info->fs_mutex);
 		make_bad_inode(inode);
 		return;
@@ -215,7 +216,6 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 		goto out;
 	}
 	btrfs_release_path(root, path);
-	btrfs_free_path(path);
 
 	/* now the directory is empty */
 	err = btrfs_unlink_trans(trans, root, dir, dentry);
@@ -223,6 +223,8 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 		inode->i_size = 0;
 	}
 out:
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	ret = btrfs_end_transaction(trans, root);
 	if (ret && !err)
@@ -800,11 +802,10 @@ static int btrfs_sync_fs(struct super_block *sb, int wait)
 
 	sb->s_dirt = 0;
 	if (!wait) {
-		// filemap_flush(root->fs_info->btree_inode->i_mapping);
-		filemap_flush(root->fs_info->sb->s_bdev->bd_inode->i_mapping);
+		filemap_flush(root->fs_info->btree_inode->i_mapping);
 		return 0;
 	}
-	filemap_write_and_wait(root->fs_info->sb->s_bdev->bd_inode->i_mapping);
+	filemap_write_and_wait(root->fs_info->btree_inode->i_mapping);
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);

commit 5caf2a002901f0fde475371c4bf1c553b51884af
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 2 11:20:42 2007 -0400

    Btrfs: dynamic allocation of path struct
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6969b672b570..c260fcad17b3 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -35,25 +35,27 @@ static int check_inode(struct inode *inode)
 
 static void btrfs_read_locked_inode(struct inode *inode)
 {
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	struct btrfs_inode_item *inode_item;
 	struct btrfs_root *root = btrfs_sb(inode->i_sb);
 	int ret;
 
-	btrfs_init_path(&path);
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
 	mutex_lock(&root->fs_info->fs_mutex);
 
 	check_inode(inode);
-	ret = btrfs_lookup_inode(NULL, root, &path, inode->i_ino, 0);
+	ret = btrfs_lookup_inode(NULL, root, path, inode->i_ino, 0);
 	if (ret) {
-		btrfs_release_path(root, &path);
+		btrfs_release_path(root, path);
 		mutex_unlock(&root->fs_info->fs_mutex);
 		make_bad_inode(inode);
 		return;
 	}
 	check_inode(inode);
-	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
-				  path.slots[0],
+	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+				  path->slots[0],
 				  struct btrfs_inode_item);
 
 	inode->i_mode = btrfs_inode_mode(inode_item);
@@ -69,7 +71,11 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	inode->i_ctime.tv_nsec = btrfs_timespec_nsec(&inode_item->ctime);
 	inode->i_blocks = btrfs_inode_nblocks(inode_item);
 	inode->i_generation = btrfs_inode_generation(inode_item);
-	btrfs_release_path(root, &path);
+
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
+	inode_item = NULL;
+
 	mutex_unlock(&root->fs_info->fs_mutex);
 	check_inode(inode);
 	switch (inode->i_mode & S_IFMT) {
@@ -101,15 +107,17 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 			      struct inode *dir,
 			      struct dentry *dentry)
 {
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	const char *name = dentry->d_name.name;
 	int name_len = dentry->d_name.len;
 	int ret;
 	u64 objectid;
 	struct btrfs_dir_item *di;
 
-	btrfs_init_path(&path);
-	ret = btrfs_lookup_dir_item(trans, root, &path, dir->i_ino,
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
+	ret = btrfs_lookup_dir_item(trans, root, path, dir->i_ino,
 				    name, name_len, -1);
 	if (ret < 0)
 		goto err;
@@ -117,15 +125,16 @@ static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
 		ret = -ENOENT;
 		goto err;
 	}
-	di = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
+	di = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
 			    struct btrfs_dir_item);
 	objectid = btrfs_dir_objectid(di);
 
-	ret = btrfs_del_item(trans, root, &path);
+	ret = btrfs_del_item(trans, root, path);
 	BUG_ON(ret);
 	dentry->d_inode->i_ctime = dir->i_ctime;
 err:
-	btrfs_release_path(root, &path);
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	if (ret == 0)
 		inode_dec_link_count(dentry->d_inode);
 	return ret;
@@ -152,30 +161,32 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 	int err;
 	int ret;
 	struct btrfs_root *root = btrfs_sb(dir->i_sb);
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	struct btrfs_key key;
 	struct btrfs_trans_handle *trans;
 	struct btrfs_disk_key *found_key;
 	struct btrfs_leaf *leaf;
 
-	btrfs_init_path(&path);
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	key.objectid = inode->i_ino;
 	key.offset = (u64)-1;
 	key.flags = 0;
 	btrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);
-	ret = btrfs_search_slot(trans, root, &key, &path, -1, 1);
+	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
 	if (ret < 0) {
 		err = ret;
 		goto out;
 	}
 
 	BUG_ON(ret == 0);
-	BUG_ON(path.slots[0] == 0);
-	path.slots[0]--;
-	leaf = btrfs_buffer_leaf(path.nodes[0]);
-	found_key = &leaf->items[path.slots[0]].key;
+	BUG_ON(path->slots[0] == 0);
+	path->slots[0]--;
+	leaf = btrfs_buffer_leaf(path->nodes[0]);
+	found_key = &leaf->items[path->slots[0]].key;
 	if (btrfs_disk_key_objectid(found_key) != inode->i_ino) {
 		err = -ENOENT;
 		goto out;
@@ -185,11 +196,11 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 		err = -ENOTEMPTY;
 		goto out;
 	}
-	ret = btrfs_del_item(trans, root, &path);
+	ret = btrfs_del_item(trans, root, path);
 	BUG_ON(ret);
-	btrfs_release_path(root, &path);
+	btrfs_release_path(root, path);
 	key.offset = 1;
-	ret = btrfs_search_slot(trans, root, &key, &path, -1, 1);
+	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
 	if (ret < 0) {
 		err = ret;
 		goto out;
@@ -198,12 +209,13 @@ static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 		err = -ENOTEMPTY;
 		goto out;
 	}
-	ret = btrfs_del_item(trans, root, &path);
+	ret = btrfs_del_item(trans, root, path);
 	if (ret) {
 		err = ret;
 		goto out;
 	}
-	btrfs_release_path(root, &path);
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 
 	/* now the directory is empty */
 	err = btrfs_unlink_trans(trans, root, dir, dentry);
@@ -223,33 +235,36 @@ static int btrfs_free_inode(struct btrfs_trans_handle *trans,
 			    struct inode *inode)
 {
 	u64 objectid = inode->i_ino;
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	struct btrfs_inode_map_item *map;
 	struct btrfs_key stat_data_key;
 	int ret;
+
 	clear_inode(inode);
-	btrfs_init_path(&path);
-	ret = btrfs_lookup_inode_map(trans, root, &path, objectid, -1);
+
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
+	ret = btrfs_lookup_inode_map(trans, root, path, objectid, -1);
 	if (ret) {
 		if (ret > 0)
 			ret = -ENOENT;
-		btrfs_release_path(root, &path);
 		goto error;
 	}
-	map = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
+	map = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
 			    struct btrfs_inode_map_item);
 	btrfs_disk_key_to_cpu(&stat_data_key, &map->key);
-	ret = btrfs_del_item(trans, root->fs_info->inode_root, &path);
+	ret = btrfs_del_item(trans, root->fs_info->inode_root, path);
 	BUG_ON(ret);
-	btrfs_release_path(root, &path);
-	btrfs_init_path(&path);
+	btrfs_release_path(root, path);
 
-	ret = btrfs_lookup_inode(trans, root, &path, objectid, -1);
+	ret = btrfs_lookup_inode(trans, root, path, objectid, -1);
 	BUG_ON(ret);
-	ret = btrfs_del_item(trans, root, &path);
+	ret = btrfs_del_item(trans, root, path);
 	BUG_ON(ret);
-	btrfs_release_path(root, &path);
 error:
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	return ret;
 }
 
@@ -258,7 +273,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 				   struct inode *inode)
 {
 	int ret;
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	struct btrfs_key key;
 	struct btrfs_disk_key *found_key;
 	struct btrfs_leaf *leaf;
@@ -267,24 +282,25 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	u64 extent_num_blocks = 0;
 	int found_extent;
 
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
 	/* FIXME, add redo link to tree so we don't leak on crash */
 	key.objectid = inode->i_ino;
 	key.offset = (u64)-1;
 	key.flags = 0;
 	btrfs_set_key_type(&key, BTRFS_CSUM_ITEM_KEY);
 	while(1) {
-		btrfs_init_path(&path);
-		ret = btrfs_search_slot(trans, root, &key, &path, -1, 1);
+		btrfs_init_path(path);
+		ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
 		if (ret < 0) {
-			btrfs_release_path(root, &path);
 			goto error;
 		}
 		if (ret > 0) {
-			BUG_ON(path.slots[0] == 0);
-			path.slots[0]--;
+			BUG_ON(path->slots[0] == 0);
+			path->slots[0]--;
 		}
-		leaf = btrfs_buffer_leaf(path.nodes[0]);
-		found_key = &leaf->items[path.slots[0]].key;
+		leaf = btrfs_buffer_leaf(path->nodes[0]);
+		found_key = &leaf->items[path->slots[0]].key;
 		if (btrfs_disk_key_objectid(found_key) != inode->i_ino)
 			break;
 		if (btrfs_disk_key_type(found_key) != BTRFS_CSUM_ITEM_KEY &&
@@ -293,8 +309,8 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 		if (btrfs_disk_key_offset(found_key) < inode->i_size)
 			break;
 		if (btrfs_disk_key_type(found_key) == BTRFS_EXTENT_DATA_KEY) {
-			fi = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
-					    path.slots[0],
+			fi = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+					    path->slots[0],
 					    struct btrfs_file_extent_item);
 			extent_start = btrfs_file_extent_disk_blocknr(fi);
 			extent_num_blocks =
@@ -305,18 +321,19 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 		} else {
 			found_extent = 0;
 		}
-		ret = btrfs_del_item(trans, root, &path);
+		ret = btrfs_del_item(trans, root, path);
 		BUG_ON(ret);
-		btrfs_release_path(root, &path);
+		btrfs_release_path(root, path);
 		if (found_extent) {
 			ret = btrfs_free_extent(trans, root, extent_start,
 						extent_num_blocks, 0);
 			BUG_ON(ret);
 		}
 	}
-	btrfs_release_path(root, &path);
 	ret = 0;
 error:
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	return ret;
 }
 
@@ -351,23 +368,26 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct btrfs_dir_item *di;
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	struct btrfs_root *root = btrfs_sb(dir->i_sb);
 	int ret;
 
-	btrfs_init_path(&path);
-	ret = btrfs_lookup_dir_item(NULL, root, &path, dir->i_ino, name,
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
+	ret = btrfs_lookup_dir_item(NULL, root, path, dir->i_ino, name,
 				    namelen, 0);
-	if (ret || !btrfs_match_dir_item_name(root, &path, name, namelen)) {
+	if (ret || !btrfs_match_dir_item_name(root, path, name, namelen)) {
 		*ino = 0;
 		ret = 0;
 		goto out;
 	}
-	di = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
+	di = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
 			    struct btrfs_dir_item);
 	*ino = btrfs_dir_objectid(di);
 out:
-	btrfs_release_path(root, &path);
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	check_inode(dir);
 	return ret;
 }
@@ -405,7 +425,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	struct btrfs_item *item;
 	struct btrfs_dir_item *di;
 	struct btrfs_key key;
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	int ret;
 	u32 nritems;
 	struct btrfs_leaf *leaf;
@@ -419,27 +439,28 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	key.flags = 0;
 	btrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);
 	key.offset = filp->f_pos;
-	btrfs_init_path(&path);
-	ret = btrfs_search_slot(NULL, root, &key, &path, 0, 0);
+	path = btrfs_alloc_path();
+	btrfs_init_path(path);
+	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
 	if (ret < 0) {
 		goto err;
 	}
 	advance = 0;
 	while(1) {
-		leaf = btrfs_buffer_leaf(path.nodes[0]);
+		leaf = btrfs_buffer_leaf(path->nodes[0]);
 		nritems = btrfs_header_nritems(&leaf->header);
-		slot = path.slots[0];
+		slot = path->slots[0];
 		if (advance || slot >= nritems) {
 			if (slot >= nritems -1) {
-				ret = btrfs_next_leaf(root, &path);
+				ret = btrfs_next_leaf(root, path);
 				if (ret)
 					break;
-				leaf = btrfs_buffer_leaf(path.nodes[0]);
+				leaf = btrfs_buffer_leaf(path->nodes[0]);
 				nritems = btrfs_header_nritems(&leaf->header);
-				slot = path.slots[0];
+				slot = path->slots[0];
 			} else {
 				slot++;
-				path.slots[0]++;
+				path->slots[0]++;
 			}
 		}
 		advance = 1;
@@ -465,7 +486,8 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	}
 	ret = 0;
 err:
-	btrfs_release_path(root, &path);
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	return ret;
 }
@@ -548,26 +570,29 @@ static int btrfs_update_inode(struct btrfs_trans_handle *trans,
 			      struct inode *inode)
 {
 	struct btrfs_inode_item *inode_item;
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	int ret;
 
-	btrfs_init_path(&path);
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
 
-	ret = btrfs_lookup_inode(trans, root, &path, inode->i_ino, 1);
+	ret = btrfs_lookup_inode(trans, root, path, inode->i_ino, 1);
 	if (ret) {
 		if (ret > 0)
 			ret = -ENOENT;
 		goto failed;
 	}
 
-	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
-				  path.slots[0],
+	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]),
+				  path->slots[0],
 				  struct btrfs_inode_item);
 
 	fill_inode_item(inode_item, inode);
-	btrfs_mark_buffer_dirty(path.nodes[0]);
+	btrfs_mark_buffer_dirty(path->nodes[0]);
 failed:
-	btrfs_release_path(root, &path);
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	check_inode(inode);
 	return 0;
 }
@@ -799,38 +824,39 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	u64 extent_start = 0;
 	u64 extent_end = 0;
 	u64 objectid = inode->i_ino;
-	struct btrfs_path path;
+	struct btrfs_path *path;
 	struct btrfs_root *root = btrfs_sb(inode->i_sb);
 	struct btrfs_trans_handle *trans = NULL;
 	struct btrfs_file_extent_item *item;
 	struct btrfs_leaf *leaf;
 	struct btrfs_disk_key *found_key;
 
-	btrfs_init_path(&path);
+	path = btrfs_alloc_path();
+	BUG_ON(!path);
+	btrfs_init_path(path);
 	if (create)
 		trans = btrfs_start_transaction(root, 1);
 
 
-	ret = btrfs_lookup_file_extent(trans, root, &path,
+	ret = btrfs_lookup_file_extent(trans, root, path,
 				       inode->i_ino,
 				       iblock << inode->i_blkbits, 0);
 	if (ret < 0) {
-		btrfs_release_path(root, &path);
 		err = ret;
 		goto out;
 	}
 
 	if (ret != 0) {
-		if (path.slots[0] == 0) {
-			btrfs_release_path(root, &path);
+		if (path->slots[0] == 0) {
+			btrfs_release_path(root, path);
 			goto allocate;
 		}
-		path.slots[0]--;
+		path->slots[0]--;
 	}
 
-	item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
+	item = btrfs_item_ptr(btrfs_buffer_leaf(path->nodes[0]), path->slots[0],
 			      struct btrfs_file_extent_item);
-	leaf = btrfs_buffer_leaf(path.nodes[0]);
+	leaf = btrfs_buffer_leaf(path->nodes[0]);
 	blocknr = btrfs_file_extent_disk_blocknr(item);
 	blocknr += btrfs_file_extent_offset(item);
 
@@ -838,25 +864,23 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	if (ret == 0) {
 		err = 0;
 		map_bh(result, inode->i_sb, blocknr);
-		btrfs_release_path(root, &path);
 		goto out;
 	}
 
 	/* are we inside the extent that was found? */
-	found_key = &leaf->items[path.slots[0]].key;
+	found_key = &leaf->items[path->slots[0]].key;
 	if (btrfs_disk_key_objectid(found_key) != objectid ||
 	    btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY) {
 		extent_end = 0;
 		extent_start = 0;
-		btrfs_release_path(root, &path);
+		btrfs_release_path(root, path);
 		goto allocate;
 	}
 
-	extent_start = btrfs_disk_key_offset(&leaf->items[path.slots[0]].key);
+	extent_start = btrfs_disk_key_offset(&leaf->items[path->slots[0]].key);
 	extent_start = extent_start >> inode->i_blkbits;
 	extent_start += btrfs_file_extent_offset(item);
 	extent_end = extent_start + btrfs_file_extent_num_blocks(item);
-	btrfs_release_path(root, &path);
 	if (iblock >= extent_start && iblock < extent_end) {
 		err = 0;
 		map_bh(result, inode->i_sb, blocknr + iblock - extent_start);
@@ -880,6 +904,8 @@ static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 	map_bh(result, inode->i_sb, blocknr);
 
 out:
+	btrfs_release_path(root, path);
+	btrfs_free_path(path);
 	if (trans)
 		btrfs_end_transaction(trans, root);
 	return err;

commit 2c90e5d658424bc71b111eb5a972240d5d06fe86
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Apr 2 10:50:19 2007 -0400

    Btrfs: still corruption hunting
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 894a70bf26d2..6969b672b570 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -14,6 +14,7 @@
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
+#include "btrfs_inode.h"
 
 #define BTRFS_SUPER_MAGIC 0x9123682E
 
@@ -24,6 +25,14 @@ static struct inode_operations btrfs_file_inode_operations;
 static struct address_space_operations btrfs_aops;
 static struct file_operations btrfs_file_operations;
 
+static int check_inode(struct inode *inode)
+{
+	struct btrfs_inode *ei = BTRFS_I(inode);
+	WARN_ON(ei->magic != 0xDEADBEEF);
+	WARN_ON(ei->magic2 != 0xDEADBEAF);
+	return 0;
+}
+
 static void btrfs_read_locked_inode(struct inode *inode)
 {
 	struct btrfs_path path;
@@ -34,6 +43,7 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	btrfs_init_path(&path);
 	mutex_lock(&root->fs_info->fs_mutex);
 
+	check_inode(inode);
 	ret = btrfs_lookup_inode(NULL, root, &path, inode->i_ino, 0);
 	if (ret) {
 		btrfs_release_path(root, &path);
@@ -41,6 +51,7 @@ static void btrfs_read_locked_inode(struct inode *inode)
 		make_bad_inode(inode);
 		return;
 	}
+	check_inode(inode);
 	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
 				  path.slots[0],
 				  struct btrfs_inode_item);
@@ -60,6 +71,7 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	inode->i_generation = btrfs_inode_generation(inode_item);
 	btrfs_release_path(root, &path);
 	mutex_unlock(&root->fs_info->fs_mutex);
+	check_inode(inode);
 	switch (inode->i_mode & S_IFMT) {
 #if 0
 	default:
@@ -80,6 +92,7 @@ static void btrfs_read_locked_inode(struct inode *inode)
 		// inode->i_op = &page_symlink_inode_operations;
 		break;
 	}
+	check_inode(inode);
 	return;
 }
 
@@ -347,6 +360,7 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 				    namelen, 0);
 	if (ret || !btrfs_match_dir_item_name(root, &path, name, namelen)) {
 		*ino = 0;
+		ret = 0;
 		goto out;
 	}
 	di = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
@@ -354,6 +368,7 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 	*ino = btrfs_dir_objectid(di);
 out:
 	btrfs_release_path(root, &path);
+	check_inode(dir);
 	return ret;
 }
 
@@ -367,7 +382,6 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 
 	if (dentry->d_name.len > BTRFS_NAME_LEN)
 		return ERR_PTR(-ENAMETOOLONG);
-
 	mutex_lock(&root->fs_info->fs_mutex);
 	ret = btrfs_inode_by_name(dir, dentry, &ino);
 	mutex_unlock(&root->fs_info->fs_mutex);
@@ -378,7 +392,9 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 		inode = iget(dir->i_sb, ino);
 		if (!inode)
 			return ERR_PTR(-EACCES);
+		check_inode(inode);
 	}
+	check_inode(dir);
 	return d_splice_alias(inode, dentry);
 }
 
@@ -471,23 +487,14 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	struct inode * inode;
 	struct dentry * root_dentry;
 	struct btrfs_super_block *disk_super;
-	struct buffer_head *bh;
 	struct btrfs_root *root;
 
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
-	sb->s_blocksize = PAGE_CACHE_SIZE;
-	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = BTRFS_SUPER_MAGIC;
 	sb->s_op = &btrfs_super_ops;
 	sb->s_time_gran = 1;
 
-	bh = sb_bread(sb, BTRFS_SUPER_INFO_OFFSET / sb->s_blocksize);
-	if (!bh) {
-		printk("btrfs: unable to read on disk super\n");
-		return -EIO;
-	}
-	disk_super = (struct btrfs_super_block *)bh->b_data;
-	root = open_ctree(sb, bh, disk_super);
+	root = open_ctree(sb);
 
 	if (!root) {
 		printk("btrfs: open_ctree failed\n");
@@ -533,6 +540,7 @@ static void fill_inode_item(struct btrfs_inode_item *item,
 	btrfs_set_timespec_nsec(&item->ctime, inode->i_ctime.tv_nsec);
 	btrfs_set_inode_nblocks(item, inode->i_blocks);
 	btrfs_set_inode_generation(item, inode->i_generation);
+	check_inode(inode);
 }
 
 static int btrfs_update_inode(struct btrfs_trans_handle *trans,
@@ -560,6 +568,7 @@ static int btrfs_update_inode(struct btrfs_trans_handle *trans,
 	btrfs_mark_buffer_dirty(path.nodes[0]);
 failed:
 	btrfs_release_path(root, &path);
+	check_inode(inode);
 	return 0;
 }
 
@@ -577,6 +586,7 @@ static int btrfs_write_inode(struct inode *inode, int wait)
 	else
 		btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
+	check_inode(inode);
 	return ret;
 }
 
@@ -594,6 +604,7 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
 
+	check_inode(inode);
 	ret = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
 	BUG_ON(ret);
 
@@ -616,6 +627,8 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	BUG_ON(ret);
 
 	insert_inode_hash(inode);
+	check_inode(inode);
+	check_inode(dir);
 	return inode;
 }
 
@@ -632,7 +645,8 @@ static int btrfs_add_link(struct btrfs_trans_handle *trans,
 		ret = btrfs_update_inode(trans, btrfs_sb(inode->i_sb),
 					 dentry->d_parent->d_inode);
 	}
-
+	check_inode(inode);
+	check_inode(dentry->d_parent->d_inode);
 	return ret;
 }
 
@@ -644,6 +658,9 @@ static int btrfs_add_nondir(struct btrfs_trans_handle *trans,
 		d_instantiate(dentry, inode);
 		return 0;
 	}
+	if (err > 0)
+		err = -EEXIST;
+	check_inode(inode);
 	return err;
 }
 
@@ -675,6 +692,9 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 out_unlock:
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
+	check_inode(inode);
+	check_inode(dir);
+
 	if (drop_inode) {
 		inode_dec_link_count(inode);
 		iput(inode);
@@ -755,11 +775,11 @@ static int btrfs_sync_fs(struct super_block *sb, int wait)
 
 	sb->s_dirt = 0;
 	if (!wait) {
-		filemap_flush(root->fs_info->btree_inode->i_mapping);
+		// filemap_flush(root->fs_info->btree_inode->i_mapping);
+		filemap_flush(root->fs_info->sb->s_bdev->bd_inode->i_mapping);
 		return 0;
 	}
-	filemap_write_and_wait(root->fs_info->btree_inode->i_mapping);
-
+	filemap_write_and_wait(root->fs_info->sb->s_bdev->bd_inode->i_mapping);
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);
@@ -1242,6 +1262,95 @@ static ssize_t btrfs_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
 	return retval;
 }
 
+static struct kmem_cache *btrfs_inode_cachep;
+struct kmem_cache *btrfs_trans_handle_cachep;
+struct kmem_cache *btrfs_transaction_cachep;
+struct kmem_cache *btrfs_bit_radix_cachep;
+struct kmem_cache *btrfs_path_cachep;
+
+/*
+ * Called inside transaction, so use GFP_NOFS
+ */
+static struct inode *btrfs_alloc_inode(struct super_block *sb)
+{
+	struct btrfs_inode *ei;
+
+	ei = kmem_cache_alloc(btrfs_inode_cachep, GFP_NOFS);
+	if (!ei)
+		return NULL;
+	ei->magic = 0xDEADBEEF;
+	ei->magic2 = 0xDEADBEAF;
+	return &ei->vfs_inode;
+}
+
+static void btrfs_destroy_inode(struct inode *inode)
+{
+	struct btrfs_inode *ei = BTRFS_I(inode);
+	WARN_ON(ei->magic != 0xDEADBEEF);
+	WARN_ON(ei->magic2 != 0xDEADBEAF);
+	WARN_ON(!list_empty(&inode->i_dentry));
+	WARN_ON(inode->i_ino == 1);
+	WARN_ON(inode->i_data.nrpages);
+
+	ei->magic = 0;
+	ei->magic2 = 0;
+	kmem_cache_free(btrfs_inode_cachep, BTRFS_I(inode));
+}
+
+static void init_once(void * foo, struct kmem_cache * cachep,
+		      unsigned long flags)
+{
+	struct btrfs_inode *ei = (struct btrfs_inode *) foo;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+	    SLAB_CTOR_CONSTRUCTOR) {
+		inode_init_once(&ei->vfs_inode);
+	}
+}
+
+static int init_inodecache(void)
+{
+	btrfs_inode_cachep = kmem_cache_create("btrfs_inode_cache",
+					     sizeof(struct btrfs_inode),
+					     0, (SLAB_RECLAIM_ACCOUNT|
+						SLAB_MEM_SPREAD),
+					     init_once, NULL);
+	btrfs_trans_handle_cachep = kmem_cache_create("btrfs_trans_handle_cache",
+					     sizeof(struct btrfs_trans_handle),
+					     0, (SLAB_RECLAIM_ACCOUNT|
+						SLAB_MEM_SPREAD),
+					     NULL, NULL);
+	btrfs_transaction_cachep = kmem_cache_create("btrfs_transaction_cache",
+					     sizeof(struct btrfs_transaction),
+					     0, (SLAB_RECLAIM_ACCOUNT|
+						SLAB_MEM_SPREAD),
+					     NULL, NULL);
+	btrfs_path_cachep = kmem_cache_create("btrfs_path_cache",
+					     sizeof(struct btrfs_transaction),
+					     0, (SLAB_RECLAIM_ACCOUNT|
+						SLAB_MEM_SPREAD),
+					     NULL, NULL);
+	btrfs_bit_radix_cachep = kmem_cache_create("btrfs_radix",
+					     256,
+					     0, (SLAB_RECLAIM_ACCOUNT|
+						SLAB_MEM_SPREAD |
+						SLAB_DESTROY_BY_RCU),
+					     NULL, NULL);
+	if (btrfs_inode_cachep == NULL || btrfs_trans_handle_cachep == NULL ||
+	    btrfs_transaction_cachep == NULL || btrfs_bit_radix_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+static void destroy_inodecache(void)
+{
+	kmem_cache_destroy(btrfs_inode_cachep);
+	kmem_cache_destroy(btrfs_trans_handle_cachep);
+	kmem_cache_destroy(btrfs_transaction_cachep);
+	kmem_cache_destroy(btrfs_bit_radix_cachep);
+	kmem_cache_destroy(btrfs_path_cachep);
+}
+
 static int btrfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
@@ -1265,6 +1374,8 @@ static struct super_operations btrfs_super_ops = {
 	.write_super	= btrfs_write_super,
 	.sync_fs	= btrfs_sync_fs,
 	.write_inode	= btrfs_write_inode,
+	.alloc_inode	= btrfs_alloc_inode,
+	.destroy_inode	= btrfs_destroy_inode,
 };
 
 static struct inode_operations btrfs_dir_inode_operations = {
@@ -1305,12 +1416,17 @@ static struct file_operations btrfs_file_operations = {
 
 static int __init init_btrfs_fs(void)
 {
+	int err;
 	printk("btrfs loaded!\n");
+	err = init_inodecache();
+	if (err)
+		return err;
 	return register_filesystem(&btrfs_fs_type);
 }
 
 static void __exit exit_btrfs_fs(void)
 {
+	destroy_inodecache();
 	unregister_filesystem(&btrfs_fs_type);
 	printk("btrfs unloaded\n");
 }

commit d6025579531b7ea170ba283b171ff7a6bf7d0e12
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 30 14:27:56 2007 -0400

    Btrfs: corruption hunt continues
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ab5419eea93a..894a70bf26d2 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -557,7 +557,7 @@ static int btrfs_update_inode(struct btrfs_trans_handle *trans,
 				  struct btrfs_inode_item);
 
 	fill_inode_item(inode_item, inode);
-	mark_buffer_dirty(path.nodes[0]);
+	btrfs_mark_buffer_dirty(path.nodes[0]);
 failed:
 	btrfs_release_path(root, &path);
 	return 0;

commit 22b0ebda6c63a1ad66b6a9e806bd226a4a03a049
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 30 08:47:31 2007 -0400

    Btrfs: hunting slab corruption
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 04428137d75f..ab5419eea93a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -361,13 +361,16 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 				   struct nameidata *nd)
 {
 	struct inode * inode;
+	struct btrfs_root *root = btrfs_sb(dir->i_sb);
 	ino_t ino;
 	int ret;
 
 	if (dentry->d_name.len > BTRFS_NAME_LEN)
 		return ERR_PTR(-ENAMETOOLONG);
 
+	mutex_lock(&root->fs_info->fs_mutex);
 	ret = btrfs_inode_by_name(dir, dentry, &ino);
+	mutex_unlock(&root->fs_info->fs_mutex);
 	if (ret < 0)
 		return ERR_PTR(ret);
 	inode = NULL;
@@ -395,6 +398,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	unsigned char d_type = DT_UNKNOWN;
 	int over = 0;
 
+	mutex_lock(&root->fs_info->fs_mutex);
 	key.objectid = inode->i_ino;
 	key.flags = 0;
 	btrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);
@@ -446,6 +450,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	ret = 0;
 err:
 	btrfs_release_path(root, &path);
+	mutex_unlock(&root->fs_info->fs_mutex);
 	return ret;
 }
 
@@ -667,8 +672,8 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 		inode->i_op = &btrfs_file_inode_operations;
 	}
 	dir->i_sb->s_dirt = 1;
-	btrfs_end_transaction(trans, root);
 out_unlock:
+	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	if (drop_inode) {
 		inode_dec_link_count(inode);

commit f254e52c1ce550fdaa0d31f5e068f0d67c2485d4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Mar 29 15:15:27 2007 -0400

    Btrfs: verify csums on read
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 7914b31f5bcd..04428137d75f 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -249,15 +249,16 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 	struct btrfs_key key;
 	struct btrfs_disk_key *found_key;
 	struct btrfs_leaf *leaf;
-	struct btrfs_file_extent_item *fi;
-	u64 extent_start;
-	u64 extent_num_blocks;
+	struct btrfs_file_extent_item *fi = NULL;
+	u64 extent_start = 0;
+	u64 extent_num_blocks = 0;
+	int found_extent;
 
 	/* FIXME, add redo link to tree so we don't leak on crash */
 	key.objectid = inode->i_ino;
 	key.offset = (u64)-1;
 	key.flags = 0;
-	btrfs_set_key_type(&key, BTRFS_EXTENT_DATA_KEY);
+	btrfs_set_key_type(&key, BTRFS_CSUM_ITEM_KEY);
 	while(1) {
 		btrfs_init_path(&path);
 		ret = btrfs_search_slot(trans, root, &key, &path, -1, 1);
@@ -273,25 +274,32 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 		found_key = &leaf->items[path.slots[0]].key;
 		if (btrfs_disk_key_objectid(found_key) != inode->i_ino)
 			break;
-		if (btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY)
+		if (btrfs_disk_key_type(found_key) != BTRFS_CSUM_ITEM_KEY &&
+		    btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY)
 			break;
 		if (btrfs_disk_key_offset(found_key) < inode->i_size)
 			break;
-		fi = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
-				    path.slots[0],
-				    struct btrfs_file_extent_item);
-		extent_start = btrfs_file_extent_disk_blocknr(fi);
-		extent_num_blocks = btrfs_file_extent_disk_num_blocks(fi);
-		key.offset = btrfs_disk_key_offset(found_key) - 1;
+		if (btrfs_disk_key_type(found_key) == BTRFS_EXTENT_DATA_KEY) {
+			fi = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
+					    path.slots[0],
+					    struct btrfs_file_extent_item);
+			extent_start = btrfs_file_extent_disk_blocknr(fi);
+			extent_num_blocks =
+				btrfs_file_extent_disk_num_blocks(fi);
+			inode->i_blocks -=
+				btrfs_file_extent_num_blocks(fi) >> 9;
+			found_extent = 1;
+		} else {
+			found_extent = 0;
+		}
 		ret = btrfs_del_item(trans, root, &path);
 		BUG_ON(ret);
-		inode->i_blocks -= btrfs_file_extent_num_blocks(fi) >> 9;
 		btrfs_release_path(root, &path);
-		ret = btrfs_free_extent(trans, root, extent_start,
-					extent_num_blocks, 0);
-		BUG_ON(ret);
-		if (key.offset + 1 == 0)
-			break;
+		if (found_extent) {
+			ret = btrfs_free_extent(trans, root, extent_start,
+						extent_num_blocks, 0);
+			BUG_ON(ret);
+		}
 	}
 	btrfs_release_path(root, &path);
 	ret = 0;
@@ -975,10 +983,24 @@ static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
 	int err = 0;
 	int ret;
 	int this_write;
+	struct inode *inode = file->f_path.dentry->d_inode;
 
 	for (i = 0; i < num_pages; i++) {
 		offset = pos & (PAGE_CACHE_SIZE -1);
 		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
+		/* FIXME, one block at a time */
+
+		mutex_lock(&root->fs_info->fs_mutex);
+		trans = btrfs_start_transaction(root, 1);
+		btrfs_csum_file_block(trans, root, inode->i_ino,
+				      pages[i]->index << PAGE_CACHE_SHIFT,
+				      kmap(pages[i]), PAGE_CACHE_SIZE);
+		kunmap(pages[i]);
+		SetPageChecked(pages[i]);
+		ret = btrfs_end_transaction(trans, root);
+		BUG_ON(ret);
+		mutex_unlock(&root->fs_info->fs_mutex);
+
 		ret = nobh_commit_write(file, pages[i], offset,
 					 offset + this_write);
 		pos += this_write;
@@ -1022,7 +1044,7 @@ static int prepare_pages(struct btrfs_trans_handle *trans,
 		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
 		ret = nobh_prepare_write(pages[i], offset,
 					 offset + this_write,
-					 btrfs_get_block_lock);
+					 btrfs_get_block);
 		pos += this_write;
 		if (ret) {
 			err = ret;
@@ -1051,7 +1073,6 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	size_t num_written = 0;
 	int err = 0;
 	int ret = 0;
-	struct btrfs_trans_handle *trans;
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct btrfs_root *root = btrfs_sb(inode->i_sb);
 	struct page *pages[1];
@@ -1077,25 +1098,18 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
 		size_t num_pages = (write_bytes + PAGE_CACHE_SIZE - 1) >>
 					PAGE_CACHE_SHIFT;
-		mutex_lock(&root->fs_info->fs_mutex);
-		trans = btrfs_start_transaction(root, 1);
-
-		ret = prepare_pages(trans, root, file, pages, num_pages,
+		ret = prepare_pages(NULL, root, file, pages, num_pages,
 				    pos, write_bytes);
 		BUG_ON(ret);
 		ret = btrfs_copy_from_user(pos, num_pages,
 					   write_bytes, pages, buf);
 		BUG_ON(ret);
 
-		mutex_unlock(&root->fs_info->fs_mutex);
-
-		ret = dirty_and_release_pages(trans, root, file, pages,
+		ret = dirty_and_release_pages(NULL, root, file, pages,
 					      num_pages, pos, write_bytes);
 		BUG_ON(ret);
 		btrfs_drop_pages(pages, num_pages);
 
-		ret = btrfs_end_transaction(trans, root);
-
 		buf += write_bytes;
 		count -= write_bytes;
 		pos += write_bytes;
@@ -1111,6 +1125,118 @@ static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
 	return num_written ? num_written : err;
 }
 
+static int btrfs_read_actor(read_descriptor_t *desc, struct page *page,
+			unsigned long offset, unsigned long size)
+{
+	char *kaddr;
+	unsigned long left, count = desc->count;
+
+	if (size > count)
+		size = count;
+
+	if (!PageChecked(page)) {
+		/* FIXME, do it per block */
+		struct btrfs_root *root = btrfs_sb(page->mapping->host->i_sb);
+		int ret = btrfs_csum_verify_file_block(root,
+					  page->mapping->host->i_ino,
+					  page->index << PAGE_CACHE_SHIFT,
+					  kmap(page), PAGE_CACHE_SIZE);
+		if (ret) {
+			printk("failed to verify ino %lu page %lu\n",
+			       page->mapping->host->i_ino,
+			       page->index);
+			memset(page_address(page), 0, PAGE_CACHE_SIZE);
+		}
+		SetPageChecked(page);
+		kunmap(page);
+	}
+	/*
+	 * Faults on the destination of a read are common, so do it before
+	 * taking the kmap.
+	 */
+	if (!fault_in_pages_writeable(desc->arg.buf, size)) {
+		kaddr = kmap_atomic(page, KM_USER0);
+		left = __copy_to_user_inatomic(desc->arg.buf,
+						kaddr + offset, size);
+		kunmap_atomic(kaddr, KM_USER0);
+		if (left == 0)
+			goto success;
+	}
+
+	/* Do it the slow way */
+	kaddr = kmap(page);
+	left = __copy_to_user(desc->arg.buf, kaddr + offset, size);
+	kunmap(page);
+
+	if (left) {
+		size -= left;
+		desc->error = -EFAULT;
+	}
+success:
+	desc->count = count - size;
+	desc->written += size;
+	desc->arg.buf += size;
+	return size;
+}
+
+/**
+ * btrfs_file_aio_read - filesystem read routine
+ * @iocb:	kernel I/O control block
+ * @iov:	io vector request
+ * @nr_segs:	number of segments in the iovec
+ * @pos:	current file position
+ */
+static ssize_t btrfs_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
+				   unsigned long nr_segs, loff_t pos)
+{
+	struct file *filp = iocb->ki_filp;
+	ssize_t retval;
+	unsigned long seg;
+	size_t count;
+	loff_t *ppos = &iocb->ki_pos;
+
+	count = 0;
+	for (seg = 0; seg < nr_segs; seg++) {
+		const struct iovec *iv = &iov[seg];
+
+		/*
+		 * If any segment has a negative length, or the cumulative
+		 * length ever wraps negative then return -EINVAL.
+		 */
+		count += iv->iov_len;
+		if (unlikely((ssize_t)(count|iv->iov_len) < 0))
+			return -EINVAL;
+		if (access_ok(VERIFY_WRITE, iv->iov_base, iv->iov_len))
+			continue;
+		if (seg == 0)
+			return -EFAULT;
+		nr_segs = seg;
+		count -= iv->iov_len;	/* This segment is no good */
+		break;
+	}
+	retval = 0;
+	if (count) {
+		for (seg = 0; seg < nr_segs; seg++) {
+			read_descriptor_t desc;
+
+			desc.written = 0;
+			desc.arg.buf = iov[seg].iov_base;
+			desc.count = iov[seg].iov_len;
+			if (desc.count == 0)
+				continue;
+			desc.error = 0;
+			do_generic_file_read(filp, ppos, &desc,
+					     btrfs_read_actor);
+			retval += desc.written;
+			if (desc.error) {
+				retval = retval ?: desc.error;
+				break;
+			}
+		}
+	}
+	return retval;
+}
+
 static int btrfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
@@ -1166,7 +1292,7 @@ static struct inode_operations btrfs_file_inode_operations = {
 static struct file_operations btrfs_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
-	.aio_read       = generic_file_aio_read,
+	.aio_read       = btrfs_file_aio_read,
 	.write		= btrfs_file_write,
 	.mmap		= generic_file_mmap,
 	.open		= generic_file_open,

commit 75dfe3960e602e63ea42ac7a2a0520832b189ffa
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Mar 29 11:56:46 2007 -0400

    btrfs_file_write -- first pass
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 151c1002d74e..7914b31f5bcd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -9,6 +9,8 @@
 #include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
 #include <linux/mpage.h>
+#include <linux/swap.h>
+#include <linux/writeback.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -755,7 +757,7 @@ printk("btrfs sync_fs\n");
 	return 0;
 }
 
-static int btrfs_get_block(struct inode *inode, sector_t iblock,
+static int btrfs_get_block_lock(struct inode *inode, sector_t iblock,
 			   struct buffer_head *result, int create)
 {
 	int ret;
@@ -772,7 +774,6 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 	struct btrfs_disk_key *found_key;
 
 	btrfs_init_path(&path);
-	mutex_lock(&root->fs_info->fs_mutex);
 	if (create)
 		trans = btrfs_start_transaction(root, 1);
 
@@ -848,6 +849,16 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 out:
 	if (trans)
 		btrfs_end_transaction(trans, root);
+	return err;
+}
+
+static int btrfs_get_block(struct inode *inode, sector_t iblock,
+			   struct buffer_head *result, int create)
+{
+	int err;
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	mutex_lock(&root->fs_info->fs_mutex);
+	err = btrfs_get_block_lock(inode, iblock, result, create);
 	mutex_unlock(&root->fs_info->fs_mutex);
 	return err;
 }
@@ -855,8 +866,15 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 static int btrfs_prepare_write(struct file *file, struct page *page,
 			       unsigned from, unsigned to)
 {
+	WARN_ON(1);
 	return nobh_prepare_write(page, from, to, btrfs_get_block);
 }
+static int btrfs_commit_write(struct file *file, struct page *page,
+			       unsigned from, unsigned to)
+{
+	WARN_ON(1);
+	return nobh_commit_write(file, page, from, to);
+}
 
 static void btrfs_write_super(struct super_block *sb)
 {
@@ -903,6 +921,196 @@ static void btrfs_truncate(struct inode *inode)
 	mark_inode_dirty(inode);
 }
 
+static int btrfs_copy_from_user(loff_t pos, int num_pages, int write_bytes,
+				struct page **prepared_pages,
+				const char __user * buf)
+{
+	long page_fault = 0;
+	int i;
+	int offset = pos & (PAGE_CACHE_SIZE - 1);
+
+	for (i = 0; i < num_pages && write_bytes > 0; i++, offset = 0) {
+		size_t count = min_t(size_t,
+				     PAGE_CACHE_SIZE - offset, write_bytes);
+		struct page *page = prepared_pages[i];
+		fault_in_pages_readable(buf, count);
+
+		/* Copy data from userspace to the current page */
+		kmap(page);
+		page_fault = __copy_from_user(page_address(page) + offset,
+					      buf, count);
+		/* Flush processor's dcache for this page */
+		flush_dcache_page(page);
+		kunmap(page);
+		buf += count;
+		write_bytes -= count;
+
+		if (page_fault)
+			break;
+	}
+	return page_fault ? -EFAULT : 0;
+}
+
+static void btrfs_drop_pages(struct page **pages, size_t num_pages)
+{
+	size_t i;
+	for (i = 0; i < num_pages; i++) {
+		if (!pages[i])
+			break;
+		unlock_page(pages[i]);
+		mark_page_accessed(pages[i]);
+		page_cache_release(pages[i]);
+	}
+}
+static int dirty_and_release_pages(struct btrfs_trans_handle *trans,
+				   struct btrfs_root *root,
+				   struct file *file,
+				   struct page **pages,
+				   size_t num_pages,
+				   loff_t pos,
+				   size_t write_bytes)
+{
+	int i;
+	int offset;
+	int err = 0;
+	int ret;
+	int this_write;
+
+	for (i = 0; i < num_pages; i++) {
+		offset = pos & (PAGE_CACHE_SIZE -1);
+		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
+		ret = nobh_commit_write(file, pages[i], offset,
+					 offset + this_write);
+		pos += this_write;
+		if (ret) {
+			err = ret;
+			goto failed;
+		}
+		WARN_ON(this_write > write_bytes);
+		write_bytes -= this_write;
+	}
+failed:
+	return err;
+}
+
+static int prepare_pages(struct btrfs_trans_handle *trans,
+			 struct btrfs_root *root,
+			 struct file *file,
+			 struct page **pages,
+			 size_t num_pages,
+			 loff_t pos,
+			 size_t write_bytes)
+{
+	int i;
+	unsigned long index = pos >> PAGE_CACHE_SHIFT;
+	struct inode *inode = file->f_path.dentry->d_inode;
+	int offset;
+	int err = 0;
+	int ret;
+	int this_write;
+	loff_t isize = i_size_read(inode);
+
+	memset(pages, 0, num_pages * sizeof(struct page *));
+
+	for (i = 0; i < num_pages; i++) {
+		pages[i] = grab_cache_page(inode->i_mapping, index + i);
+		if (!pages[i]) {
+			err = -ENOMEM;
+			goto failed_release;
+		}
+		offset = pos & (PAGE_CACHE_SIZE -1);
+		this_write = min(PAGE_CACHE_SIZE - offset, write_bytes);
+		ret = nobh_prepare_write(pages[i], offset,
+					 offset + this_write,
+					 btrfs_get_block_lock);
+		pos += this_write;
+		if (ret) {
+			err = ret;
+			goto failed_truncate;
+		}
+		WARN_ON(this_write > write_bytes);
+		write_bytes -= this_write;
+	}
+	return 0;
+
+failed_release:
+	btrfs_drop_pages(pages, num_pages);
+	return err;
+
+failed_truncate:
+	btrfs_drop_pages(pages, num_pages);
+	if (pos > isize)
+		vmtruncate(inode, isize);
+	return err;
+}
+
+static ssize_t btrfs_file_write(struct file *file, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	loff_t pos;
+	size_t num_written = 0;
+	int err = 0;
+	int ret = 0;
+	struct btrfs_trans_handle *trans;
+	struct inode *inode = file->f_path.dentry->d_inode;
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct page *pages[1];
+
+	if (file->f_flags & O_DIRECT)
+		return -EINVAL;
+	pos = *ppos;
+
+	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
+	current->backing_dev_info = inode->i_mapping->backing_dev_info;
+	err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));
+	if (err)
+		goto out;
+	if (count == 0)
+		goto out;
+	err = remove_suid(file->f_path.dentry);
+	if (err)
+		goto out;
+	file_update_time(file);
+	mutex_lock(&inode->i_mutex);
+	while(count > 0) {
+		size_t offset = pos & (PAGE_CACHE_SIZE - 1);
+		size_t write_bytes = min(count, PAGE_CACHE_SIZE - offset);
+		size_t num_pages = (write_bytes + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT;
+		mutex_lock(&root->fs_info->fs_mutex);
+		trans = btrfs_start_transaction(root, 1);
+
+		ret = prepare_pages(trans, root, file, pages, num_pages,
+				    pos, write_bytes);
+		BUG_ON(ret);
+		ret = btrfs_copy_from_user(pos, num_pages,
+					   write_bytes, pages, buf);
+		BUG_ON(ret);
+
+		mutex_unlock(&root->fs_info->fs_mutex);
+
+		ret = dirty_and_release_pages(trans, root, file, pages,
+					      num_pages, pos, write_bytes);
+		BUG_ON(ret);
+		btrfs_drop_pages(pages, num_pages);
+
+		ret = btrfs_end_transaction(trans, root);
+
+		buf += write_bytes;
+		count -= write_bytes;
+		pos += write_bytes;
+		num_written += write_bytes;
+
+		balance_dirty_pages_ratelimited(inode->i_mapping);
+		cond_resched();
+	}
+	mutex_unlock(&inode->i_mutex);
+out:
+	*ppos = pos;
+	current->backing_dev_info = NULL;
+	return num_written ? num_written : err;
+}
+
 static int btrfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
@@ -948,7 +1156,7 @@ static struct address_space_operations btrfs_aops = {
 	.writepage	= btrfs_writepage,
 	.sync_page	= block_sync_page,
 	.prepare_write	= btrfs_prepare_write,
-	.commit_write	= nobh_commit_write,
+	.commit_write	= btrfs_commit_write,
 };
 
 static struct inode_operations btrfs_file_inode_operations = {
@@ -958,14 +1166,10 @@ static struct inode_operations btrfs_file_inode_operations = {
 static struct file_operations btrfs_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
-	.write		= do_sync_write,
-	.aio_read	= generic_file_aio_read,
-	.aio_write	= generic_file_aio_write,
+	.aio_read       = generic_file_aio_read,
+	.write		= btrfs_file_write,
 	.mmap		= generic_file_mmap,
 	.open		= generic_file_open,
-	.sendfile	= generic_file_sendfile,
-	.splice_read	= generic_file_splice_read,
-	.splice_write	= generic_file_splice_write,
 };
 
 static int __init init_btrfs_fs(void)

commit 87cbda5c1f54aba67b1e318a4a4824c9e9f16324
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 28 19:44:27 2007 -0400

    Btrfs: sha256 csums on metadata
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8f07f462236a..151c1002d74e 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -473,13 +473,13 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	}
 	disk_super = (struct btrfs_super_block *)bh->b_data;
 	root = open_ctree(sb, bh, disk_super);
-	sb->s_fs_info = root;
-	disk_super = root->fs_info->disk_super;
 
 	if (!root) {
 		printk("btrfs: open_ctree failed\n");
 		return -EIO;
 	}
+	sb->s_fs_info = root;
+	disk_super = root->fs_info->disk_super;
 	printk("read in super total blocks %Lu root %Lu\n",
 	       btrfs_super_total_blocks(disk_super),
 	       btrfs_super_root_dir(disk_super));

commit d98237b3ede7ab98892f7fa62201a13694c526e2
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 28 13:57:48 2007 -0400

    Btrfs: use a btree inode instead of sb_getblk
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 67659b6ce962..8f07f462236a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -474,6 +474,8 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	disk_super = (struct btrfs_super_block *)bh->b_data;
 	root = open_ctree(sb, bh, disk_super);
 	sb->s_fs_info = root;
+	disk_super = root->fs_info->disk_super;
+
 	if (!root) {
 		printk("btrfs: open_ctree failed\n");
 		return -EIO;
@@ -734,15 +736,15 @@ static int btrfs_sync_fs(struct super_block *sb, int wait)
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root;
 	int ret;
+	root = btrfs_sb(sb);
 
 	sb->s_dirt = 0;
 	if (!wait) {
-		filemap_flush(sb->s_bdev->bd_inode->i_mapping);
+		filemap_flush(root->fs_info->btree_inode->i_mapping);
 		return 0;
 	}
-	filemap_write_and_wait(sb->s_bdev->bd_inode->i_mapping);
+	filemap_write_and_wait(root->fs_info->btree_inode->i_mapping);
 
-	root = btrfs_sb(sb);
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);

commit 5f443fd280c76a2170259cebaa4108c9daad6e1b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 27 13:42:32 2007 -0400

    btrfs_rmdir
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f2f08189903d..67659b6ce962 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -81,11 +81,12 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	return;
 }
 
-static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
+static int btrfs_unlink_trans(struct btrfs_trans_handle *trans,
+			      struct btrfs_root *root,
+			      struct inode *dir,
+			      struct dentry *dentry)
 {
 	struct btrfs_path path;
-	struct btrfs_root *root;
-	struct btrfs_trans_handle *trans;
 	const char *name = dentry->d_name.name;
 	int name_len = dentry->d_name.len;
 	int ret;
@@ -93,10 +94,6 @@ static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
 	struct btrfs_dir_item *di;
 
 	btrfs_init_path(&path);
-	root = btrfs_sb(dir->i_sb);
-	mutex_lock(&root->fs_info->fs_mutex);
-	trans = btrfs_start_transaction(root, 1);
-
 	ret = btrfs_lookup_dir_item(trans, root, &path, dir->i_ino,
 				    name, name_len, -1);
 	if (ret < 0)
@@ -114,13 +111,98 @@ static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
 	dentry->d_inode->i_ctime = dir->i_ctime;
 err:
 	btrfs_release_path(root, &path);
-	btrfs_end_transaction(trans, root);
-	mutex_unlock(&root->fs_info->fs_mutex);
 	if (ret == 0)
 		inode_dec_link_count(dentry->d_inode);
 	return ret;
 }
 
+static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct btrfs_root *root;
+	struct btrfs_trans_handle *trans;
+	int ret;
+
+	root = btrfs_sb(dir->i_sb);
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	ret = btrfs_unlink_trans(trans, root, dir, dentry);
+	btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return ret;
+}
+
+static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	int err;
+	int ret;
+	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	struct btrfs_path path;
+	struct btrfs_key key;
+	struct btrfs_trans_handle *trans;
+	struct btrfs_disk_key *found_key;
+	struct btrfs_leaf *leaf;
+
+	btrfs_init_path(&path);
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	key.objectid = inode->i_ino;
+	key.offset = (u64)-1;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);
+	ret = btrfs_search_slot(trans, root, &key, &path, -1, 1);
+	if (ret < 0) {
+		err = ret;
+		goto out;
+	}
+
+	BUG_ON(ret == 0);
+	BUG_ON(path.slots[0] == 0);
+	path.slots[0]--;
+	leaf = btrfs_buffer_leaf(path.nodes[0]);
+	found_key = &leaf->items[path.slots[0]].key;
+	if (btrfs_disk_key_objectid(found_key) != inode->i_ino) {
+		err = -ENOENT;
+		goto out;
+	}
+	if (btrfs_disk_key_type(found_key) != BTRFS_DIR_ITEM_KEY ||
+	    btrfs_disk_key_offset(found_key) != 2) {
+		err = -ENOTEMPTY;
+		goto out;
+	}
+	ret = btrfs_del_item(trans, root, &path);
+	BUG_ON(ret);
+	btrfs_release_path(root, &path);
+	key.offset = 1;
+	ret = btrfs_search_slot(trans, root, &key, &path, -1, 1);
+	if (ret < 0) {
+		err = ret;
+		goto out;
+	}
+	if (ret > 0) {
+		err = -ENOTEMPTY;
+		goto out;
+	}
+	ret = btrfs_del_item(trans, root, &path);
+	if (ret) {
+		err = ret;
+		goto out;
+	}
+	btrfs_release_path(root, &path);
+
+	/* now the directory is empty */
+	err = btrfs_unlink_trans(trans, root, dir, dentry);
+	if (!err) {
+		inode->i_size = 0;
+	}
+out:
+	mutex_unlock(&root->fs_info->fs_mutex);
+	ret = btrfs_end_transaction(trans, root);
+	if (ret && !err)
+		err = ret;
+	return err;
+}
+
 static int btrfs_free_inode(struct btrfs_trans_handle *trans,
 			    struct btrfs_root *root,
 			    struct inode *inode)
@@ -191,9 +273,6 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 			break;
 		if (btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY)
 			break;
-		if (btrfs_disk_key_offset(found_key) < inode->i_size)
-			break;
-		/* FIXME: add extent truncation */
 		if (btrfs_disk_key_offset(found_key) < inode->i_size)
 			break;
 		fi = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
@@ -209,7 +288,7 @@ static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
 		ret = btrfs_free_extent(trans, root, extent_start,
 					extent_num_blocks, 0);
 		BUG_ON(ret);
-		if (btrfs_disk_key_offset(found_key) == 0)
+		if (key.offset + 1 == 0)
 			break;
 	}
 	btrfs_release_path(root, &path);
@@ -852,6 +931,7 @@ static struct inode_operations btrfs_dir_inode_operations = {
 	.create		= btrfs_create,
 	.unlink		= btrfs_unlink,
 	.mkdir		= btrfs_mkdir,
+	.rmdir		= btrfs_rmdir,
 };
 
 static struct file_operations btrfs_dir_file_operations = {

commit 9773a788681db1f5c2701b7433737fdca61a14ba
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 27 11:26:26 2007 -0400

    Btrfs: byte offsets for file keys
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index fd3d9d616ff9..f2f08189903d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -697,7 +697,8 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 
 
 	ret = btrfs_lookup_file_extent(trans, root, &path,
-				       inode->i_ino, iblock, 1, 0);
+				       inode->i_ino,
+				       iblock << inode->i_blkbits, 0);
 	if (ret < 0) {
 		btrfs_release_path(root, &path);
 		err = ret;
@@ -737,6 +738,7 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 	}
 
 	extent_start = btrfs_disk_key_offset(&leaf->items[path.slots[0]].key);
+	extent_start = extent_start >> inode->i_blkbits;
 	extent_start += btrfs_file_extent_offset(item);
 	extent_end = extent_start + btrfs_file_extent_num_blocks(item);
 	btrfs_release_path(root, &path);
@@ -751,7 +753,8 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 		err = 0;
 		goto out;
 	}
-	ret = btrfs_alloc_file_extent(trans, root, objectid, iblock,
+	ret = btrfs_alloc_file_extent(trans, root, objectid,
+				      iblock << inode->i_blkbits,
 				      1, extent_end, &blocknr);
 	if (ret) {
 		err = ret;

commit f4b9aa8d3b877d0a6044a6d6d9a44b29cab9e265
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 27 11:05:53 2007 -0400

    btrfs_truncate
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 487da5a213c0..fd3d9d616ff9 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -28,11 +28,15 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	struct btrfs_inode_item *inode_item;
 	struct btrfs_root *root = btrfs_sb(inode->i_sb);
 	int ret;
+
 	btrfs_init_path(&path);
+	mutex_lock(&root->fs_info->fs_mutex);
+
 	ret = btrfs_lookup_inode(NULL, root, &path, inode->i_ino, 0);
 	if (ret) {
-		make_bad_inode(inode);
 		btrfs_release_path(root, &path);
+		mutex_unlock(&root->fs_info->fs_mutex);
+		make_bad_inode(inode);
 		return;
 	}
 	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
@@ -53,6 +57,7 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	inode->i_blocks = btrfs_inode_nblocks(inode_item);
 	inode->i_generation = btrfs_inode_generation(inode_item);
 	btrfs_release_path(root, &path);
+	mutex_unlock(&root->fs_info->fs_mutex);
 	switch (inode->i_mode & S_IFMT) {
 #if 0
 	default:
@@ -151,20 +156,85 @@ static int btrfs_free_inode(struct btrfs_trans_handle *trans,
 	return ret;
 }
 
+static int btrfs_truncate_in_trans(struct btrfs_trans_handle *trans,
+				   struct btrfs_root *root,
+				   struct inode *inode)
+{
+	int ret;
+	struct btrfs_path path;
+	struct btrfs_key key;
+	struct btrfs_disk_key *found_key;
+	struct btrfs_leaf *leaf;
+	struct btrfs_file_extent_item *fi;
+	u64 extent_start;
+	u64 extent_num_blocks;
+
+	/* FIXME, add redo link to tree so we don't leak on crash */
+	key.objectid = inode->i_ino;
+	key.offset = (u64)-1;
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_EXTENT_DATA_KEY);
+	while(1) {
+		btrfs_init_path(&path);
+		ret = btrfs_search_slot(trans, root, &key, &path, -1, 1);
+		if (ret < 0) {
+			btrfs_release_path(root, &path);
+			goto error;
+		}
+		if (ret > 0) {
+			BUG_ON(path.slots[0] == 0);
+			path.slots[0]--;
+		}
+		leaf = btrfs_buffer_leaf(path.nodes[0]);
+		found_key = &leaf->items[path.slots[0]].key;
+		if (btrfs_disk_key_objectid(found_key) != inode->i_ino)
+			break;
+		if (btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY)
+			break;
+		if (btrfs_disk_key_offset(found_key) < inode->i_size)
+			break;
+		/* FIXME: add extent truncation */
+		if (btrfs_disk_key_offset(found_key) < inode->i_size)
+			break;
+		fi = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
+				    path.slots[0],
+				    struct btrfs_file_extent_item);
+		extent_start = btrfs_file_extent_disk_blocknr(fi);
+		extent_num_blocks = btrfs_file_extent_disk_num_blocks(fi);
+		key.offset = btrfs_disk_key_offset(found_key) - 1;
+		ret = btrfs_del_item(trans, root, &path);
+		BUG_ON(ret);
+		inode->i_blocks -= btrfs_file_extent_num_blocks(fi) >> 9;
+		btrfs_release_path(root, &path);
+		ret = btrfs_free_extent(trans, root, extent_start,
+					extent_num_blocks, 0);
+		BUG_ON(ret);
+		if (btrfs_disk_key_offset(found_key) == 0)
+			break;
+	}
+	btrfs_release_path(root, &path);
+	ret = 0;
+error:
+	return ret;
+}
+
 static void btrfs_delete_inode(struct inode *inode)
 {
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	int ret;
+
 	truncate_inode_pages(&inode->i_data, 0);
 	if (is_bad_inode(inode)) {
 		goto no_delete;
 	}
 	inode->i_size = 0;
-	if (inode->i_blocks)
-		WARN_ON(1);
-
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
+	if (S_ISREG(inode->i_mode)) {
+		ret = btrfs_truncate_in_trans(trans, root, inode);
+		BUG_ON(ret);
+	}
 	btrfs_free_inode(trans, root, inode);
 	btrfs_end_transaction(trans, root);
 	mutex_unlock(&root->fs_info->fs_mutex);
@@ -173,7 +243,6 @@ static void btrfs_delete_inode(struct inode *inode)
 	clear_inode(inode);
 }
 
-
 static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 			      ino_t *ino)
 {
@@ -688,6 +757,8 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 		err = ret;
 		goto out;
 	}
+	inode->i_blocks += inode->i_sb->s_blocksize >> 9;
+	set_buffer_new(result);
 	map_bh(result, inode->i_sb, blocknr);
 
 out:
@@ -724,6 +795,30 @@ static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 	return nobh_writepage(page, btrfs_get_block, wbc);
 }
 
+static void btrfs_truncate(struct inode *inode)
+{
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	int ret;
+	struct btrfs_trans_handle *trans;
+
+	if (!S_ISREG(inode->i_mode))
+		return;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return;
+
+	nobh_truncate_page(inode->i_mapping, inode->i_size);
+
+	/* FIXME, add redo link to tree so we don't leak on crash */
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	ret = btrfs_truncate_in_trans(trans, root, inode);
+	BUG_ON(ret);
+	ret = btrfs_end_transaction(trans, root);
+	BUG_ON(ret);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	mark_inode_dirty(inode);
+}
+
 static int btrfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
@@ -772,7 +867,7 @@ static struct address_space_operations btrfs_aops = {
 };
 
 static struct inode_operations btrfs_file_inode_operations = {
-	.truncate	= NULL,
+	.truncate	= btrfs_truncate,
 };
 
 static struct file_operations btrfs_file_operations = {

commit 6407bf6d7c449cbfb0a39d985194e265eda3baf4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Mar 27 06:33:00 2007 -0400

    Btrfs: reference counts on data extents
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 2c2883f2856d..487da5a213c0 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -700,7 +700,7 @@ static int btrfs_get_block(struct inode *inode, sector_t iblock,
 static int btrfs_prepare_write(struct file *file, struct page *page,
 			       unsigned from, unsigned to)
 {
-	return block_prepare_write(page, from, to, btrfs_get_block);
+	return nobh_prepare_write(page, from, to, btrfs_get_block);
 }
 
 static void btrfs_write_super(struct super_block *sb)
@@ -721,7 +721,7 @@ static int btrfs_readpages(struct file *file, struct address_space *mapping,
 
 static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 {
-	return block_write_full_page(page, btrfs_get_block, wbc);
+	return nobh_writepage(page, btrfs_get_block, wbc);
 }
 
 static int btrfs_get_sb(struct file_system_type *fs_type,
@@ -768,7 +768,7 @@ static struct address_space_operations btrfs_aops = {
 	.writepage	= btrfs_writepage,
 	.sync_page	= block_sync_page,
 	.prepare_write	= btrfs_prepare_write,
-	.commit_write	= generic_commit_write,
+	.commit_write	= nobh_commit_write,
 };
 
 static struct inode_operations btrfs_file_inode_operations = {

commit dee26a9f7aab7ffe1193cd1415b23a69426acc9f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 26 16:00:06 2007 -0400

    btrfs_get_block, file read/write
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 905b093a85fe..2c2883f2856d 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -8,6 +8,7 @@
 #include <linux/string.h>
 #include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
+#include <linux/mpage.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -17,6 +18,9 @@
 static struct inode_operations btrfs_dir_inode_operations;
 static struct super_operations btrfs_super_ops;
 static struct file_operations btrfs_dir_file_operations;
+static struct inode_operations btrfs_file_inode_operations;
+static struct address_space_operations btrfs_aops;
+static struct file_operations btrfs_file_operations;
 
 static void btrfs_read_locked_inode(struct inode *inode)
 {
@@ -57,6 +61,9 @@ static void btrfs_read_locked_inode(struct inode *inode)
 		break;
 #endif
 	case S_IFREG:
+		inode->i_mapping->a_ops = &btrfs_aops;
+		inode->i_fop = &btrfs_file_operations;
+		inode->i_op = &btrfs_file_inode_operations;
 		break;
 	case S_IFDIR:
 		inode->i_op = &btrfs_dir_inode_operations;
@@ -214,35 +221,6 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 	return d_splice_alias(inode, dentry);
 }
 
-static void reada_leaves(struct btrfs_root *root, struct btrfs_path *path)
-{
-	struct buffer_head *bh;
-	struct btrfs_node *node;
-	int i;
-	int nritems;
-	u64 objectid;
-	u64 item_objectid;
-	u64 blocknr;
-	int slot;
-
-	if (!path->nodes[1])
-		return;
-	node = btrfs_buffer_node(path->nodes[1]);
-	slot = path->slots[1];
-	objectid = btrfs_disk_key_objectid(&node->ptrs[slot].key);
-	nritems = btrfs_header_nritems(&node->header);
-	for (i = slot; i < nritems; i++) {
-		item_objectid = btrfs_disk_key_objectid(&node->ptrs[i].key);
-		if (item_objectid != objectid)
-			break;
-		blocknr = btrfs_node_blockptr(node, i);
-		bh = sb_getblk(root->fs_info->sb, blocknr);
-		ll_rw_block(READ, 1, &bh);
-		brelse(bh);
-	}
-
-}
-
 static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct inode *inode = filp->f_path.dentry->d_inode;
@@ -269,21 +247,18 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		goto err;
 	}
 	advance = 0;
-	reada_leaves(root, &path);
 	while(1) {
 		leaf = btrfs_buffer_leaf(path.nodes[0]);
 		nritems = btrfs_header_nritems(&leaf->header);
 		slot = path.slots[0];
-		if (advance) {
-			if (slot == nritems -1) {
+		if (advance || slot >= nritems) {
+			if (slot >= nritems -1) {
 				ret = btrfs_next_leaf(root, &path);
 				if (ret)
 					break;
 				leaf = btrfs_buffer_leaf(path.nodes[0]);
 				nritems = btrfs_header_nritems(&leaf->header);
 				slot = path.slots[0];
-				if (path.nodes[1] && path.slots[1] == 0)
-					reada_leaves(root, &path);
 			} else {
 				slot++;
 				path.slots[0]++;
@@ -297,6 +272,8 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 			continue;
 		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)
 			continue;
+
+		advance = 1;
 		di = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);
 		over = filldir(dirent, (const char *)(di + 1),
 			       btrfs_dir_name_len(di),
@@ -524,6 +501,11 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 	err = btrfs_add_nondir(trans, dentry, inode);
 	if (err)
 		drop_inode = 1;
+	else {
+		inode->i_mapping->a_ops = &btrfs_aops;
+		inode->i_fop = &btrfs_file_operations;
+		inode->i_op = &btrfs_file_inode_operations;
+	}
 	dir->i_sb->s_dirt = 1;
 	btrfs_end_transaction(trans, root);
 out_unlock:
@@ -623,11 +605,124 @@ printk("btrfs sync_fs\n");
 	return 0;
 }
 
+static int btrfs_get_block(struct inode *inode, sector_t iblock,
+			   struct buffer_head *result, int create)
+{
+	int ret;
+	int err = 0;
+	u64 blocknr;
+	u64 extent_start = 0;
+	u64 extent_end = 0;
+	u64 objectid = inode->i_ino;
+	struct btrfs_path path;
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_trans_handle *trans = NULL;
+	struct btrfs_file_extent_item *item;
+	struct btrfs_leaf *leaf;
+	struct btrfs_disk_key *found_key;
+
+	btrfs_init_path(&path);
+	mutex_lock(&root->fs_info->fs_mutex);
+	if (create)
+		trans = btrfs_start_transaction(root, 1);
+
+
+	ret = btrfs_lookup_file_extent(trans, root, &path,
+				       inode->i_ino, iblock, 1, 0);
+	if (ret < 0) {
+		btrfs_release_path(root, &path);
+		err = ret;
+		goto out;
+	}
+
+	if (ret != 0) {
+		if (path.slots[0] == 0) {
+			btrfs_release_path(root, &path);
+			goto allocate;
+		}
+		path.slots[0]--;
+	}
+
+	item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
+			      struct btrfs_file_extent_item);
+	leaf = btrfs_buffer_leaf(path.nodes[0]);
+	blocknr = btrfs_file_extent_disk_blocknr(item);
+	blocknr += btrfs_file_extent_offset(item);
+
+	/* exact match found, use it */
+	if (ret == 0) {
+		err = 0;
+		map_bh(result, inode->i_sb, blocknr);
+		btrfs_release_path(root, &path);
+		goto out;
+	}
+
+	/* are we inside the extent that was found? */
+	found_key = &leaf->items[path.slots[0]].key;
+	if (btrfs_disk_key_objectid(found_key) != objectid ||
+	    btrfs_disk_key_type(found_key) != BTRFS_EXTENT_DATA_KEY) {
+		extent_end = 0;
+		extent_start = 0;
+		btrfs_release_path(root, &path);
+		goto allocate;
+	}
+
+	extent_start = btrfs_disk_key_offset(&leaf->items[path.slots[0]].key);
+	extent_start += btrfs_file_extent_offset(item);
+	extent_end = extent_start + btrfs_file_extent_num_blocks(item);
+	btrfs_release_path(root, &path);
+	if (iblock >= extent_start && iblock < extent_end) {
+		err = 0;
+		map_bh(result, inode->i_sb, blocknr + iblock - extent_start);
+		goto out;
+	}
+allocate:
+	/* ok, create a new extent */
+	if (!create) {
+		err = 0;
+		goto out;
+	}
+	ret = btrfs_alloc_file_extent(trans, root, objectid, iblock,
+				      1, extent_end, &blocknr);
+	if (ret) {
+		err = ret;
+		goto out;
+	}
+	map_bh(result, inode->i_sb, blocknr);
+
+out:
+	if (trans)
+		btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return err;
+}
+
+static int btrfs_prepare_write(struct file *file, struct page *page,
+			       unsigned from, unsigned to)
+{
+	return block_prepare_write(page, from, to, btrfs_get_block);
+}
+
 static void btrfs_write_super(struct super_block *sb)
 {
 	btrfs_sync_fs(sb, 1);
 }
 
+static int btrfs_readpage(struct file *file, struct page *page)
+{
+	return mpage_readpage(page, btrfs_get_block);
+}
+
+static int btrfs_readpages(struct file *file, struct address_space *mapping,
+			   struct list_head *pages, unsigned nr_pages)
+{
+	return mpage_readpages(mapping, pages, nr_pages, btrfs_get_block);
+}
+
+static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	return block_write_full_page(page, btrfs_get_block, wbc);
+}
 
 static int btrfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
@@ -667,6 +762,31 @@ static struct file_operations btrfs_dir_file_operations = {
 	.readdir	= btrfs_readdir,
 };
 
+static struct address_space_operations btrfs_aops = {
+	.readpage	= btrfs_readpage,
+	.readpages	= btrfs_readpages,
+	.writepage	= btrfs_writepage,
+	.sync_page	= block_sync_page,
+	.prepare_write	= btrfs_prepare_write,
+	.commit_write	= generic_commit_write,
+};
+
+static struct inode_operations btrfs_file_inode_operations = {
+	.truncate	= NULL,
+};
+
+static struct file_operations btrfs_file_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= do_sync_read,
+	.write		= do_sync_write,
+	.aio_read	= generic_file_aio_read,
+	.aio_write	= generic_file_aio_write,
+	.mmap		= generic_file_mmap,
+	.open		= generic_file_open,
+	.sendfile	= generic_file_sendfile,
+	.splice_read	= generic_file_splice_read,
+	.splice_write	= generic_file_splice_write,
+};
 
 static int __init init_btrfs_fs(void)
 {

commit 4730a4bc5bf3861d2cb40999374b3ac0ee2a1e0d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Mar 26 12:00:39 2007 -0400

    btrfs_dirty_inode
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 820d21ee4afd..905b093a85fe 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -242,6 +242,7 @@ static void reada_leaves(struct btrfs_root *root, struct btrfs_path *path)
 	}
 
 }
+
 static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct inode *inode = filp->f_path.dentry->d_inode;
@@ -392,6 +393,51 @@ static void fill_inode_item(struct btrfs_inode_item *item,
 	btrfs_set_inode_generation(item, inode->i_generation);
 }
 
+static int btrfs_update_inode(struct btrfs_trans_handle *trans,
+			      struct btrfs_root *root,
+			      struct inode *inode)
+{
+	struct btrfs_inode_item *inode_item;
+	struct btrfs_path path;
+	int ret;
+
+	btrfs_init_path(&path);
+
+	ret = btrfs_lookup_inode(trans, root, &path, inode->i_ino, 1);
+	if (ret) {
+		if (ret > 0)
+			ret = -ENOENT;
+		goto failed;
+	}
+
+	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
+				  path.slots[0],
+				  struct btrfs_inode_item);
+
+	fill_inode_item(inode_item, inode);
+	mark_buffer_dirty(path.nodes[0]);
+failed:
+	btrfs_release_path(root, &path);
+	return 0;
+}
+
+static int btrfs_write_inode(struct inode *inode, int wait)
+{
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_trans_handle *trans;
+	int ret;
+
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	ret = btrfs_update_inode(trans, root, inode);
+	if (wait)
+		btrfs_commit_transaction(trans, root);
+	else
+		btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return ret;
+}
+
 static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 				     struct inode *dir, int mode)
 {
@@ -415,9 +461,6 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	inode->i_ino = objectid;
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
-	/* FIXME do this on link */
-	if (mode & S_IFDIR)
-		inode->i_size = 3;
 	fill_inode_item(&inode_item, inode);
 
 	key.objectid = objectid;
@@ -431,7 +474,6 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	BUG_ON(ret);
 
 	insert_inode_hash(inode);
-	// FIXME mark_inode_dirty(inode)
 	return inode;
 }
 
@@ -443,6 +485,12 @@ static int btrfs_add_link(struct btrfs_trans_handle *trans,
 				    dentry->d_name.name, dentry->d_name.len,
 				    dentry->d_parent->d_inode->i_ino,
 				    inode->i_ino, 0);
+	if (ret == 0) {
+		dentry->d_parent->d_inode->i_size += dentry->d_name.len;
+		ret = btrfs_update_inode(trans, btrfs_sb(inode->i_sb),
+					 dentry->d_parent->d_inode);
+	}
+
 	return ret;
 }
 
@@ -502,6 +550,10 @@ static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
 		goto error;
 	ret = btrfs_insert_dir_item(trans, root, buf, 2, inode->i_ino,
 				    dir->i_ino, 1);
+	if (ret)
+		goto error;
+	inode->i_size = 3;
+	ret = btrfs_update_inode(trans, root, inode);
 error:
 	return ret;
 }
@@ -536,7 +588,6 @@ static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 	if (err)
 		goto out_fail;
 	d_instantiate(dentry, inode);
-	mark_inode_dirty(inode);
 	drop_on_err = 0;
 
 out_fail:
@@ -600,6 +651,7 @@ static struct super_operations btrfs_super_ops = {
 	.read_inode	= btrfs_read_locked_inode,
 	.write_super	= btrfs_write_super,
 	.sync_fs	= btrfs_sync_fs,
+	.write_inode	= btrfs_write_inode,
 };
 
 static struct inode_operations btrfs_dir_inode_operations = {

commit f7922033efe957f79ae57f6026e93c8148e7f7ed
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun Mar 25 20:17:36 2007 -0400

    btrfs_mkdir
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index e76fcd80db6a..820d21ee4afd 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -18,124 +18,6 @@ static struct inode_operations btrfs_dir_inode_operations;
 static struct super_operations btrfs_super_ops;
 static struct file_operations btrfs_dir_file_operations;
 
-#if 0
-/* some random number */
-
-static struct super_operations ramfs_ops;
-
-static struct backing_dev_info ramfs_backing_dev_info = {
-	.ra_pages	= 0,	/* No readahead */
-	.capabilities	= BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK |
-			  BDI_CAP_MAP_DIRECT | BDI_CAP_MAP_COPY |
-			  BDI_CAP_READ_MAP | BDI_CAP_WRITE_MAP | BDI_CAP_EXEC_MAP,
-};
-
-struct inode *ramfs_get_inode(struct super_block *sb, int mode, dev_t dev)
-{
-	struct inode * inode = new_inode(sb);
-
-	if (inode) {
-		inode->i_mode = mode;
-		inode->i_uid = current->fsuid;
-		inode->i_gid = current->fsgid;
-		inode->i_blocks = 0;
-		inode->i_mapping->a_ops = &ramfs_aops;
-		inode->i_mapping->backing_dev_info = &ramfs_backing_dev_info;
-		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-		switch (mode & S_IFMT) {
-		default:
-			init_special_inode(inode, mode, dev);
-			break;
-		case S_IFREG:
-			inode->i_op = &ramfs_file_inode_operations;
-			inode->i_fop = &ramfs_file_operations;
-			break;
-		case S_IFDIR:
-			inode->i_op = &ramfs_dir_inode_operations;
-			inode->i_fop = &simple_dir_operations;
-
-			/* directory inodes start off with i_nlink == 2 (for "." entry) */
-			inc_nlink(inode);
-			break;
-		case S_IFLNK:
-			inode->i_op = &page_symlink_inode_operations;
-			break;
-		}
-	}
-	return inode;
-}
-
-/*
- * File creation. Allocate an inode, and we're done..
- */
-/* SMP-safe */
-static int
-ramfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
-{
-	struct inode * inode = ramfs_get_inode(dir->i_sb, mode, dev);
-	int error = -ENOSPC;
-
-	if (inode) {
-		if (dir->i_mode & S_ISGID) {
-			inode->i_gid = dir->i_gid;
-			if (S_ISDIR(mode))
-				inode->i_mode |= S_ISGID;
-		}
-		d_instantiate(dentry, inode);
-		dget(dentry);	/* Extra count - pin the dentry in core */
-		error = 0;
-		dir->i_mtime = dir->i_ctime = CURRENT_TIME;
-	}
-	return error;
-}
-
-static int ramfs_mkdir(struct inode * dir, struct dentry * dentry, int mode)
-{
-	int retval = ramfs_mknod(dir, dentry, mode | S_IFDIR, 0);
-	if (!retval)
-		inc_nlink(dir);
-	return retval;
-}
-
-static int ramfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
-{
-	return ramfs_mknod(dir, dentry, mode | S_IFREG, 0);
-}
-
-static int ramfs_symlink(struct inode * dir, struct dentry *dentry, const char * symname)
-{
-	struct inode *inode;
-	int error = -ENOSPC;
-
-	inode = ramfs_get_inode(dir->i_sb, S_IFLNK|S_IRWXUGO, 0);
-	if (inode) {
-		int l = strlen(symname)+1;
-		error = page_symlink(inode, symname, l);
-		if (!error) {
-			if (dir->i_mode & S_ISGID)
-				inode->i_gid = dir->i_gid;
-			d_instantiate(dentry, inode);
-			dget(dentry);
-			dir->i_mtime = dir->i_ctime = CURRENT_TIME;
-		} else
-			iput(inode);
-	}
-	return error;
-}
-
-static struct inode_operations ramfs_dir_inode_operations = {
-	.create		= ramfs_create,
-	.lookup		= simple_lookup,
-	.link		= simple_link,
-	.unlink		= simple_unlink,
-	.symlink	= ramfs_symlink,
-	.mkdir		= ramfs_mkdir,
-	.rmdir		= simple_rmdir,
-	.mknod		= ramfs_mknod,
-	.rename		= simple_rename,
-};
-#endif
-
 static void btrfs_read_locked_inode(struct inode *inode)
 {
 	struct btrfs_path path;
@@ -533,9 +415,11 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	inode->i_ino = objectid;
 	inode->i_blocks = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
+	/* FIXME do this on link */
+	if (mode & S_IFDIR)
+		inode->i_size = 3;
 	fill_inode_item(&inode_item, inode);
 
-
 	key.objectid = objectid;
 	key.flags = 0;
 	key.offset = 0;
@@ -603,6 +487,67 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 	return err;
 }
 
+static int btrfs_make_empty_dir(struct btrfs_trans_handle *trans,
+				struct inode *inode, struct inode *dir)
+{
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	int ret;
+	char buf[2];
+	buf[0] = '.';
+	buf[1] = '.';
+
+	ret = btrfs_insert_dir_item(trans, root, buf, 1, inode->i_ino,
+				    inode->i_ino, 1);
+	if (ret)
+		goto error;
+	ret = btrfs_insert_dir_item(trans, root, buf, 2, inode->i_ino,
+				    dir->i_ino, 1);
+error:
+	return ret;
+}
+
+static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct inode *inode;
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	int err = 0;
+	int drop_on_err = 0;
+
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	if (IS_ERR(trans)) {
+		err = PTR_ERR(trans);
+		goto out_unlock;
+	}
+	inode = btrfs_new_inode(trans, dir, S_IFDIR | mode);
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
+		goto out_fail;
+	}
+	drop_on_err = 1;
+	inode->i_op = &btrfs_dir_inode_operations;
+	inode->i_fop = &btrfs_dir_file_operations;
+
+	err = btrfs_make_empty_dir(trans, inode, dir);
+	if (err)
+		goto out_fail;
+	err = btrfs_add_link(trans, dentry, inode);
+	if (err)
+		goto out_fail;
+	d_instantiate(dentry, inode);
+	mark_inode_dirty(inode);
+	drop_on_err = 0;
+
+out_fail:
+	btrfs_end_transaction(trans, root);
+out_unlock:
+	mutex_unlock(&root->fs_info->fs_mutex);
+	if (drop_on_err)
+		iput(inode);
+	return err;
+}
+
 static int btrfs_sync_fs(struct super_block *sb, int wait)
 {
 	struct btrfs_trans_handle *trans;
@@ -661,6 +606,7 @@ static struct inode_operations btrfs_dir_inode_operations = {
 	.lookup		= btrfs_lookup,
 	.create		= btrfs_create,
 	.unlink		= btrfs_unlink,
+	.mkdir		= btrfs_mkdir,
 };
 
 static struct file_operations btrfs_dir_file_operations = {

commit dcea79152cfb7cf244bdd9c23f4291831ffd6adf
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun Mar 25 14:03:08 2007 -0400

    Btrfs: very simple readdir readahead
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f96bd92155cc..e76fcd80db6a 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -332,6 +332,34 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 	return d_splice_alias(inode, dentry);
 }
 
+static void reada_leaves(struct btrfs_root *root, struct btrfs_path *path)
+{
+	struct buffer_head *bh;
+	struct btrfs_node *node;
+	int i;
+	int nritems;
+	u64 objectid;
+	u64 item_objectid;
+	u64 blocknr;
+	int slot;
+
+	if (!path->nodes[1])
+		return;
+	node = btrfs_buffer_node(path->nodes[1]);
+	slot = path->slots[1];
+	objectid = btrfs_disk_key_objectid(&node->ptrs[slot].key);
+	nritems = btrfs_header_nritems(&node->header);
+	for (i = slot; i < nritems; i++) {
+		item_objectid = btrfs_disk_key_objectid(&node->ptrs[i].key);
+		if (item_objectid != objectid)
+			break;
+		blocknr = btrfs_node_blockptr(node, i);
+		bh = sb_getblk(root->fs_info->sb, blocknr);
+		ll_rw_block(READ, 1, &bh);
+		brelse(bh);
+	}
+
+}
 static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct inode *inode = filp->f_path.dentry->d_inode;
@@ -358,6 +386,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		goto err;
 	}
 	advance = 0;
+	reada_leaves(root, &path);
 	while(1) {
 		leaf = btrfs_buffer_leaf(path.nodes[0]);
 		nritems = btrfs_header_nritems(&leaf->header);
@@ -370,13 +399,8 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 				leaf = btrfs_buffer_leaf(path.nodes[0]);
 				nritems = btrfs_header_nritems(&leaf->header);
 				slot = path.slots[0];
-#if 0
-				page_cache_readahead(
-				     inode->i_sb->s_bdev->bd_inode->i_mapping,
-				     &filp->f_ra, filp,
-				     path.nodes[0]->b_blocknr >>
-				     (PAGE_CACHE_SHIFT - inode->i_blkbits), 1);
-#endif
+				if (path.nodes[1] && path.slots[1] == 0)
+					reada_leaves(root, &path);
 			} else {
 				slot++;
 				path.slots[0]++;

commit 134e97313491c3a3d6bc3eca3b7c9c64408cbd08
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun Mar 25 13:44:56 2007 -0400

    Btrfs: unlink and delete_inode
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 094a66c267b4..f96bd92155cc 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -187,6 +187,104 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	return;
 }
 
+static int btrfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct btrfs_path path;
+	struct btrfs_root *root;
+	struct btrfs_trans_handle *trans;
+	const char *name = dentry->d_name.name;
+	int name_len = dentry->d_name.len;
+	int ret;
+	u64 objectid;
+	struct btrfs_dir_item *di;
+
+	btrfs_init_path(&path);
+	root = btrfs_sb(dir->i_sb);
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+
+	ret = btrfs_lookup_dir_item(trans, root, &path, dir->i_ino,
+				    name, name_len, -1);
+	if (ret < 0)
+		goto err;
+	if (ret > 0) {
+		ret = -ENOENT;
+		goto err;
+	}
+	di = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
+			    struct btrfs_dir_item);
+	objectid = btrfs_dir_objectid(di);
+
+	ret = btrfs_del_item(trans, root, &path);
+	BUG_ON(ret);
+	dentry->d_inode->i_ctime = dir->i_ctime;
+err:
+	btrfs_release_path(root, &path);
+	btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	if (ret == 0)
+		inode_dec_link_count(dentry->d_inode);
+	return ret;
+}
+
+static int btrfs_free_inode(struct btrfs_trans_handle *trans,
+			    struct btrfs_root *root,
+			    struct inode *inode)
+{
+	u64 objectid = inode->i_ino;
+	struct btrfs_path path;
+	struct btrfs_inode_map_item *map;
+	struct btrfs_key stat_data_key;
+	int ret;
+	clear_inode(inode);
+	btrfs_init_path(&path);
+	ret = btrfs_lookup_inode_map(trans, root, &path, objectid, -1);
+	if (ret) {
+		if (ret > 0)
+			ret = -ENOENT;
+		btrfs_release_path(root, &path);
+		goto error;
+	}
+	map = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
+			    struct btrfs_inode_map_item);
+	btrfs_disk_key_to_cpu(&stat_data_key, &map->key);
+	ret = btrfs_del_item(trans, root->fs_info->inode_root, &path);
+	BUG_ON(ret);
+	btrfs_release_path(root, &path);
+	btrfs_init_path(&path);
+
+	ret = btrfs_lookup_inode(trans, root, &path, objectid, -1);
+	BUG_ON(ret);
+	ret = btrfs_del_item(trans, root, &path);
+	BUG_ON(ret);
+	btrfs_release_path(root, &path);
+error:
+	return ret;
+}
+
+static void btrfs_delete_inode(struct inode *inode)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	truncate_inode_pages(&inode->i_data, 0);
+	if (is_bad_inode(inode)) {
+		goto no_delete;
+	}
+	inode->i_size = 0;
+	if (inode->i_blocks)
+		WARN_ON(1);
+
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 1);
+	btrfs_free_inode(trans, root, inode);
+	btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+	return;
+no_delete:
+	clear_inode(inode);
+}
+
+
 static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 			      ino_t *ino)
 {
@@ -272,6 +370,13 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 				leaf = btrfs_buffer_leaf(path.nodes[0]);
 				nritems = btrfs_header_nritems(&leaf->header);
 				slot = path.slots[0];
+#if 0
+				page_cache_readahead(
+				     inode->i_sb->s_bdev->bd_inode->i_mapping,
+				     &filp->f_ra, filp,
+				     path.nodes[0]->b_blocknr >>
+				     (PAGE_CACHE_SHIFT - inode->i_blkbits), 1);
+#endif
 			} else {
 				slot++;
 				path.slots[0]++;
@@ -441,8 +546,6 @@ static int btrfs_add_nondir(struct btrfs_trans_handle *trans,
 		d_instantiate(dentry, inode);
 		return 0;
 	}
-	inode_dec_link_count(inode);
-	iput(inode);
 	return err;
 }
 
@@ -453,6 +556,7 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 	struct btrfs_root *root = btrfs_sb(dir->i_sb);
 	struct inode *inode;
 	int err;
+	int drop_inode = 0;
 
 	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
@@ -462,10 +566,16 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 		goto out_unlock;
 	// FIXME mark the inode dirty
 	err = btrfs_add_nondir(trans, dentry, inode);
+	if (err)
+		drop_inode = 1;
 	dir->i_sb->s_dirt = 1;
 	btrfs_end_transaction(trans, root);
 out_unlock:
 	mutex_unlock(&root->fs_info->fs_mutex);
+	if (drop_inode) {
+		inode_dec_link_count(inode);
+		iput(inode);
+	}
 	return err;
 }
 
@@ -516,7 +626,7 @@ static struct file_system_type btrfs_fs_type = {
 
 static struct super_operations btrfs_super_ops = {
 	.statfs		= simple_statfs,
-	.drop_inode	= generic_delete_inode,
+	.delete_inode	= btrfs_delete_inode,
 	.put_super	= btrfs_put_super,
 	.read_inode	= btrfs_read_locked_inode,
 	.write_super	= btrfs_write_super,
@@ -526,6 +636,7 @@ static struct super_operations btrfs_super_ops = {
 static struct inode_operations btrfs_dir_inode_operations = {
 	.lookup		= btrfs_lookup,
 	.create		= btrfs_create,
+	.unlink		= btrfs_unlink,
 };
 
 static struct file_operations btrfs_dir_file_operations = {

commit 78fae27ebf5bd35fb9b2e4213e486635eacfc0ad
Author: Chris Mason <chris.mason@oracle.com>
Date:   Sun Mar 25 11:35:08 2007 -0400

    Btrfs: leak fixes, pinning fixes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 0ca1080e0198..094a66c267b4 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -146,6 +146,7 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	ret = btrfs_lookup_inode(NULL, root, &path, inode->i_ino, 0);
 	if (ret) {
 		make_bad_inode(inode);
+		btrfs_release_path(root, &path);
 		return;
 	}
 	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),

commit d561c025ee3a0aee53a225bedce0ee35fe12f335
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 23 19:47:49 2007 -0400

    Btrfs: very minimal locking
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index a2db05594695..0ca1080e0198 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -453,25 +453,21 @@ static int btrfs_create(struct inode *dir, struct dentry *dentry,
 	struct inode *inode;
 	int err;
 
+	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	inode = btrfs_new_inode(trans, dir, mode);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
-		return err;
+		goto out_unlock;
 	// FIXME mark the inode dirty
 	err = btrfs_add_nondir(trans, dentry, inode);
 	dir->i_sb->s_dirt = 1;
 	btrfs_end_transaction(trans, root);
+out_unlock:
+	mutex_unlock(&root->fs_info->fs_mutex);
 	return err;
 }
 
-static void btrfs_write_super(struct super_block *sb)
-{
-	sb->s_dirt = 0;
-printk("btrfs write_super!\n");
-	filemap_flush(sb->s_bdev->bd_inode->i_mapping);
-}
-
 static int btrfs_sync_fs(struct super_block *sb, int wait)
 {
 	struct btrfs_trans_handle *trans;
@@ -479,17 +475,29 @@ static int btrfs_sync_fs(struct super_block *sb, int wait)
 	int ret;
 
 	sb->s_dirt = 0;
-	return 0;
+	if (!wait) {
+		filemap_flush(sb->s_bdev->bd_inode->i_mapping);
+		return 0;
+	}
+	filemap_write_and_wait(sb->s_bdev->bd_inode->i_mapping);
 
 	root = btrfs_sb(sb);
+	mutex_lock(&root->fs_info->fs_mutex);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);
 	sb->s_dirt = 0;
 	BUG_ON(ret);
 printk("btrfs sync_fs\n");
+	mutex_unlock(&root->fs_info->fs_mutex);
 	return 0;
 }
 
+static void btrfs_write_super(struct super_block *sb)
+{
+	btrfs_sync_fs(sb, 1);
+}
+
+
 static int btrfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {

commit 7f5c15160e1436a53d01f9190db11c2a3a4d788a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 23 15:56:19 2007 -0400

    Add generation number to btrfs_header, readdir fixes, hash collision fixes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 8970e9a82156..a2db05594695 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -199,7 +199,7 @@ static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
 	btrfs_init_path(&path);
 	ret = btrfs_lookup_dir_item(NULL, root, &path, dir->i_ino, name,
 				    namelen, 0);
-	if (ret) {
+	if (ret || !btrfs_match_dir_item_name(root, &path, name, namelen)) {
 		*ino = 0;
 		goto out;
 	}
@@ -247,7 +247,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	int slot;
 	int advance;
 	unsigned char d_type = DT_UNKNOWN;
-	int over;
+	int over = 0;
 
 	key.objectid = inode->i_ino;
 	key.flags = 0;
@@ -258,7 +258,7 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	if (ret < 0) {
 		goto err;
 	}
-	advance = filp->f_pos > 0 && ret != 0;
+	advance = 0;
 	while(1) {
 		leaf = btrfs_buffer_leaf(path.nodes[0]);
 		nritems = btrfs_header_nritems(&leaf->header);
@@ -282,13 +282,17 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 			break;
 		if (btrfs_disk_key_type(&item->key) != BTRFS_DIR_ITEM_KEY)
 			continue;
+		if (btrfs_disk_key_offset(&item->key) < filp->f_pos)
+			continue;
 		di = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);
 		over = filldir(dirent, (const char *)(di + 1),
 			       btrfs_dir_name_len(di),
 			       btrfs_disk_key_offset(&item->key),
 			       btrfs_dir_objectid(di), d_type);
-		if (over)
+		if (over) {
+			filp->f_pos = btrfs_disk_key_offset(&item->key);
 			break;
+		}
 		filp->f_pos = btrfs_disk_key_offset(&item->key) + 1;
 	}
 	ret = 0;
@@ -425,7 +429,6 @@ static int btrfs_add_link(struct btrfs_trans_handle *trans,
 				    dentry->d_name.name, dentry->d_name.len,
 				    dentry->d_parent->d_inode->i_ino,
 				    inode->i_ino, 0);
-	BUG_ON(ret);
 	return ret;
 }
 
@@ -466,6 +469,7 @@ static void btrfs_write_super(struct super_block *sb)
 {
 	sb->s_dirt = 0;
 printk("btrfs write_super!\n");
+	filemap_flush(sb->s_bdev->bd_inode->i_mapping);
 }
 
 static int btrfs_sync_fs(struct super_block *sb, int wait)

commit df2ce34c8801af8e00c7f82435fcb1e4b45a2759
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 23 11:00:45 2007 -0400

    Btrfs: properly set new buffers for new blocks up to date
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 6080a8133d71..8970e9a82156 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -473,7 +473,10 @@ static int btrfs_sync_fs(struct super_block *sb, int wait)
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root;
 	int ret;
+
 	sb->s_dirt = 0;
+	return 0;
+
 	root = btrfs_sb(sb);
 	trans = btrfs_start_transaction(root, 1);
 	ret = btrfs_commit_transaction(trans, root);

commit d571976292839cec05a2820b08f7629b145ed157
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Mar 23 10:01:08 2007 -0400

    btrfs_create, btrfs_write_super, btrfs_sync_fs
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 620430825840..6080a8133d71 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -10,6 +10,7 @@
 #include <linux/backing-dev.h>
 #include "ctree.h"
 #include "disk-io.h"
+#include "transaction.h"
 
 #define BTRFS_SUPER_MAGIC 0x9123682E
 
@@ -357,6 +358,131 @@ static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 	return 0;
 }
 
+static void fill_inode_item(struct btrfs_inode_item *item,
+			    struct inode *inode)
+{
+	btrfs_set_inode_uid(item, inode->i_uid);
+	btrfs_set_inode_gid(item, inode->i_gid);
+	btrfs_set_inode_size(item, inode->i_size);
+	btrfs_set_inode_mode(item, inode->i_mode);
+	btrfs_set_inode_nlink(item, inode->i_nlink);
+	btrfs_set_timespec_sec(&item->atime, inode->i_atime.tv_sec);
+	btrfs_set_timespec_nsec(&item->atime, inode->i_atime.tv_nsec);
+	btrfs_set_timespec_sec(&item->mtime, inode->i_mtime.tv_sec);
+	btrfs_set_timespec_nsec(&item->mtime, inode->i_mtime.tv_nsec);
+	btrfs_set_timespec_sec(&item->ctime, inode->i_ctime.tv_sec);
+	btrfs_set_timespec_nsec(&item->ctime, inode->i_ctime.tv_nsec);
+	btrfs_set_inode_nblocks(item, inode->i_blocks);
+	btrfs_set_inode_generation(item, inode->i_generation);
+}
+
+static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
+				     struct inode *dir, int mode)
+{
+	struct inode *inode;
+	struct btrfs_inode_item inode_item;
+	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	struct btrfs_key key;
+	int ret;
+	u64 objectid;
+
+	inode = new_inode(dir->i_sb);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+
+	ret = btrfs_find_free_objectid(trans, root, dir->i_ino, &objectid);
+	BUG_ON(ret);
+
+	inode->i_uid = current->fsuid;
+	inode->i_gid = current->fsgid;
+	inode->i_mode = mode;
+	inode->i_ino = objectid;
+	inode->i_blocks = 0;
+	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
+	fill_inode_item(&inode_item, inode);
+
+
+	key.objectid = objectid;
+	key.flags = 0;
+	key.offset = 0;
+	btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
+	ret = btrfs_insert_inode_map(trans, root, objectid, &key);
+	BUG_ON(ret);
+
+	ret = btrfs_insert_inode(trans, root, objectid, &inode_item);
+	BUG_ON(ret);
+
+	insert_inode_hash(inode);
+	// FIXME mark_inode_dirty(inode)
+	return inode;
+}
+
+static int btrfs_add_link(struct btrfs_trans_handle *trans,
+			    struct dentry *dentry, struct inode *inode)
+{
+	int ret;
+	ret = btrfs_insert_dir_item(trans, btrfs_sb(inode->i_sb),
+				    dentry->d_name.name, dentry->d_name.len,
+				    dentry->d_parent->d_inode->i_ino,
+				    inode->i_ino, 0);
+	BUG_ON(ret);
+	return ret;
+}
+
+static int btrfs_add_nondir(struct btrfs_trans_handle *trans,
+			    struct dentry *dentry, struct inode *inode)
+{
+	int err = btrfs_add_link(trans, dentry, inode);
+	if (!err) {
+		d_instantiate(dentry, inode);
+		return 0;
+	}
+	inode_dec_link_count(inode);
+	iput(inode);
+	return err;
+}
+
+static int btrfs_create(struct inode *dir, struct dentry *dentry,
+			int mode, struct nameidata *nd)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	struct inode *inode;
+	int err;
+
+	trans = btrfs_start_transaction(root, 1);
+	inode = btrfs_new_inode(trans, dir, mode);
+	err = PTR_ERR(inode);
+	if (IS_ERR(inode))
+		return err;
+	// FIXME mark the inode dirty
+	err = btrfs_add_nondir(trans, dentry, inode);
+	dir->i_sb->s_dirt = 1;
+	btrfs_end_transaction(trans, root);
+	return err;
+}
+
+static void btrfs_write_super(struct super_block *sb)
+{
+	sb->s_dirt = 0;
+printk("btrfs write_super!\n");
+}
+
+static int btrfs_sync_fs(struct super_block *sb, int wait)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_root *root;
+	int ret;
+	sb->s_dirt = 0;
+	root = btrfs_sb(sb);
+	trans = btrfs_start_transaction(root, 1);
+	ret = btrfs_commit_transaction(trans, root);
+	sb->s_dirt = 0;
+	BUG_ON(ret);
+printk("btrfs sync_fs\n");
+	return 0;
+}
+
 static int btrfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
@@ -377,10 +503,13 @@ static struct super_operations btrfs_super_ops = {
 	.drop_inode	= generic_delete_inode,
 	.put_super	= btrfs_put_super,
 	.read_inode	= btrfs_read_locked_inode,
+	.write_super	= btrfs_write_super,
+	.sync_fs	= btrfs_sync_fs,
 };
 
 static struct inode_operations btrfs_dir_inode_operations = {
 	.lookup		= btrfs_lookup,
+	.create		= btrfs_create,
 };
 
 static struct file_operations btrfs_dir_file_operations = {

commit 79154b1b5bcf87903db7ff16a30b360b78d6fe4f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Mar 22 15:59:16 2007 -0400

    Btrfs: transaction rework
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index ccc056aad692..620430825840 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -141,7 +141,6 @@ static void btrfs_read_locked_inode(struct inode *inode)
 	struct btrfs_inode_item *inode_item;
 	struct btrfs_root *root = btrfs_sb(inode->i_sb);
 	int ret;
-printk("read locked inode %lu\n", inode->i_ino);
 	btrfs_init_path(&path);
 	ret = btrfs_lookup_inode(NULL, root, &path, inode->i_ino, 0);
 	if (ret) {
@@ -152,7 +151,6 @@ printk("read locked inode %lu\n", inode->i_ino);
 				  path.slots[0],
 				  struct btrfs_inode_item);
 
-printk("found locked inode %lu\n", inode->i_ino);
 	inode->i_mode = btrfs_inode_mode(inode_item);
 	inode->i_nlink = btrfs_inode_nlink(inode_item);
 	inode->i_uid = btrfs_inode_uid(inode_item);
@@ -166,7 +164,6 @@ printk("found locked inode %lu\n", inode->i_ino);
 	inode->i_ctime.tv_nsec = btrfs_timespec_nsec(&inode_item->ctime);
 	inode->i_blocks = btrfs_inode_nblocks(inode_item);
 	inode->i_generation = btrfs_inode_generation(inode_item);
-printk("about to release\n");
 	btrfs_release_path(root, &path);
 	switch (inode->i_mode & S_IFMT) {
 #if 0
@@ -176,19 +173,15 @@ printk("about to release\n");
 		break;
 #endif
 	case S_IFREG:
-printk("inode %lu now a file\n", inode->i_ino);
 		break;
 	case S_IFDIR:
-printk("inode %lu now a directory\n", inode->i_ino);
 		inode->i_op = &btrfs_dir_inode_operations;
 		inode->i_fop = &btrfs_dir_file_operations;
 		break;
 	case S_IFLNK:
-printk("inode %lu now a link\n", inode->i_ino);
 		// inode->i_op = &page_symlink_inode_operations;
 		break;
 	}
-printk("returning!\n");
 	return;
 }
 
@@ -232,7 +225,6 @@ static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 		return ERR_PTR(ret);
 	inode = NULL;
 	if (ino) {
-printk("lookup on %.*s returns %lu\n", dentry->d_name.len, dentry->d_name.name, ino);
 		inode = iget(dir->i_sb, ino);
 		if (!inode)
 			return ERR_PTR(-EACCES);
@@ -257,7 +249,6 @@ static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	int over;
 
 	key.objectid = inode->i_ino;
-printk("readdir on dir %Lu pos %Lu\n", key.objectid, filp->f_pos);
 	key.flags = 0;
 	btrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);
 	key.offset = filp->f_pos;
@@ -266,15 +257,12 @@ printk("readdir on dir %Lu pos %Lu\n", key.objectid, filp->f_pos);
 	if (ret < 0) {
 		goto err;
 	}
-printk("first ret %d\n", ret);
 	advance = filp->f_pos > 0 && ret != 0;
 	while(1) {
 		leaf = btrfs_buffer_leaf(path.nodes[0]);
 		nritems = btrfs_header_nritems(&leaf->header);
 		slot = path.slots[0];
-printk("leaf %Lu nritems %lu slot %d\n", path.nodes[0]->b_blocknr, nritems, slot);
 		if (advance) {
-printk("advancing!\n");
 			if (slot == nritems -1) {
 				ret = btrfs_next_leaf(root, &path);
 				if (ret)
@@ -282,7 +270,6 @@ printk("advancing!\n");
 				leaf = btrfs_buffer_leaf(path.nodes[0]);
 				nritems = btrfs_header_nritems(&leaf->header);
 				slot = path.slots[0];
-printk("2leaf %Lu nritems %lu slot %d\n", path.nodes[0]->b_blocknr, nritems, slot);
 			} else {
 				slot++;
 				path.slots[0]++;
@@ -290,15 +277,11 @@ printk("2leaf %Lu nritems %lu slot %d\n", path.nodes[0]->b_blocknr, nritems, slo
 		}
 		advance = 1;
 		item = leaf->items + slot;
-printk("item key %Lu %u %Lu\n", btrfs_disk_key_objectid(&item->key),
-       btrfs_disk_key_flags(&item->key), btrfs_disk_key_offset(&item->key));
 		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
 			break;
 		if (btrfs_disk_key_type(&item->key) != BTRFS_DIR_ITEM_KEY)
 			continue;
 		di = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);
-printk("filldir name %.*s, objectid %Lu\n", btrfs_dir_name_len(di),
-       (const char *)(di + 1), btrfs_dir_objectid(di));
 		over = filldir(dirent, (const char *)(di + 1),
 			       btrfs_dir_name_len(di),
 			       btrfs_disk_key_offset(&item->key),
@@ -307,7 +290,6 @@ printk("filldir name %.*s, objectid %Lu\n", btrfs_dir_name_len(di),
 			break;
 		filp->f_pos = btrfs_disk_key_offset(&item->key) + 1;
 	}
-printk("filldir all done\n");
 	ret = 0;
 err:
 	btrfs_release_path(root, &path);

commit e20d96d64f9cf9288ffecc9ad4714e91c3b97ca8
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Mar 22 12:13:20 2007 -0400

    Mountable btrfs, with readdir
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 4ae76044aeab..ccc056aad692 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1,4 +1,5 @@
 #include <linux/module.h>
+#include <linux/buffer_head.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 #include <linux/highmem.h>
@@ -8,13 +9,18 @@
 #include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
 #include "ctree.h"
+#include "disk-io.h"
 
 #define BTRFS_SUPER_MAGIC 0x9123682E
+
+static struct inode_operations btrfs_dir_inode_operations;
+static struct super_operations btrfs_super_ops;
+static struct file_operations btrfs_dir_file_operations;
+
 #if 0
 /* some random number */
 
 static struct super_operations ramfs_ops;
-static struct inode_operations ramfs_dir_inode_operations;
 
 static struct backing_dev_info ramfs_backing_dev_info = {
 	.ra_pages	= 0,	/* No readahead */
@@ -129,46 +135,243 @@ static struct inode_operations ramfs_dir_inode_operations = {
 };
 #endif
 
-struct inode *btrfs_get_inode(struct super_block *sb, int mode, dev_t dev)
+static void btrfs_read_locked_inode(struct inode *inode)
 {
-	struct inode * inode = new_inode(sb);
+	struct btrfs_path path;
+	struct btrfs_inode_item *inode_item;
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	int ret;
+printk("read locked inode %lu\n", inode->i_ino);
+	btrfs_init_path(&path);
+	ret = btrfs_lookup_inode(NULL, root, &path, inode->i_ino, 0);
+	if (ret) {
+		make_bad_inode(inode);
+		return;
+	}
+	inode_item = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]),
+				  path.slots[0],
+				  struct btrfs_inode_item);
 
-	if (inode) {
-		inode->i_mode = mode;
-		inode->i_uid = current->fsuid;
-		inode->i_gid = current->fsgid;
-		inode->i_blocks = 0;
-		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+printk("found locked inode %lu\n", inode->i_ino);
+	inode->i_mode = btrfs_inode_mode(inode_item);
+	inode->i_nlink = btrfs_inode_nlink(inode_item);
+	inode->i_uid = btrfs_inode_uid(inode_item);
+	inode->i_gid = btrfs_inode_gid(inode_item);
+	inode->i_size = btrfs_inode_size(inode_item);
+	inode->i_atime.tv_sec = btrfs_timespec_sec(&inode_item->atime);
+	inode->i_atime.tv_nsec = btrfs_timespec_nsec(&inode_item->atime);
+	inode->i_mtime.tv_sec = btrfs_timespec_sec(&inode_item->mtime);
+	inode->i_mtime.tv_nsec = btrfs_timespec_nsec(&inode_item->mtime);
+	inode->i_ctime.tv_sec = btrfs_timespec_sec(&inode_item->ctime);
+	inode->i_ctime.tv_nsec = btrfs_timespec_nsec(&inode_item->ctime);
+	inode->i_blocks = btrfs_inode_nblocks(inode_item);
+	inode->i_generation = btrfs_inode_generation(inode_item);
+printk("about to release\n");
+	btrfs_release_path(root, &path);
+	switch (inode->i_mode & S_IFMT) {
+#if 0
+	default:
+		init_special_inode(inode, inode->i_mode,
+				   btrfs_inode_rdev(inode_item));
+		break;
+#endif
+	case S_IFREG:
+printk("inode %lu now a file\n", inode->i_ino);
+		break;
+	case S_IFDIR:
+printk("inode %lu now a directory\n", inode->i_ino);
+		inode->i_op = &btrfs_dir_inode_operations;
+		inode->i_fop = &btrfs_dir_file_operations;
+		break;
+	case S_IFLNK:
+printk("inode %lu now a link\n", inode->i_ino);
+		// inode->i_op = &page_symlink_inode_operations;
+		break;
 	}
-	return inode;
+printk("returning!\n");
+	return;
 }
 
-static struct super_operations btrfs_ops = {
-	.statfs		= simple_statfs,
-	.drop_inode	= generic_delete_inode,
-};
+static int btrfs_inode_by_name(struct inode *dir, struct dentry *dentry,
+			      ino_t *ino)
+{
+	const char *name = dentry->d_name.name;
+	int namelen = dentry->d_name.len;
+	struct btrfs_dir_item *di;
+	struct btrfs_path path;
+	struct btrfs_root *root = btrfs_sb(dir->i_sb);
+	int ret;
+
+	btrfs_init_path(&path);
+	ret = btrfs_lookup_dir_item(NULL, root, &path, dir->i_ino, name,
+				    namelen, 0);
+	if (ret) {
+		*ino = 0;
+		goto out;
+	}
+	di = btrfs_item_ptr(btrfs_buffer_leaf(path.nodes[0]), path.slots[0],
+			    struct btrfs_dir_item);
+	*ino = btrfs_dir_objectid(di);
+out:
+	btrfs_release_path(root, &path);
+	return ret;
+}
+
+static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *nd)
+{
+	struct inode * inode;
+	ino_t ino;
+	int ret;
+
+	if (dentry->d_name.len > BTRFS_NAME_LEN)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	ret = btrfs_inode_by_name(dir, dentry, &ino);
+	if (ret < 0)
+		return ERR_PTR(ret);
+	inode = NULL;
+	if (ino) {
+printk("lookup on %.*s returns %lu\n", dentry->d_name.len, dentry->d_name.name, ino);
+		inode = iget(dir->i_sb, ino);
+		if (!inode)
+			return ERR_PTR(-EACCES);
+	}
+	return d_splice_alias(inode, dentry);
+}
+
+static int btrfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct btrfs_root *root = btrfs_sb(inode->i_sb);
+	struct btrfs_item *item;
+	struct btrfs_dir_item *di;
+	struct btrfs_key key;
+	struct btrfs_path path;
+	int ret;
+	u32 nritems;
+	struct btrfs_leaf *leaf;
+	int slot;
+	int advance;
+	unsigned char d_type = DT_UNKNOWN;
+	int over;
+
+	key.objectid = inode->i_ino;
+printk("readdir on dir %Lu pos %Lu\n", key.objectid, filp->f_pos);
+	key.flags = 0;
+	btrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);
+	key.offset = filp->f_pos;
+	btrfs_init_path(&path);
+	ret = btrfs_search_slot(NULL, root, &key, &path, 0, 0);
+	if (ret < 0) {
+		goto err;
+	}
+printk("first ret %d\n", ret);
+	advance = filp->f_pos > 0 && ret != 0;
+	while(1) {
+		leaf = btrfs_buffer_leaf(path.nodes[0]);
+		nritems = btrfs_header_nritems(&leaf->header);
+		slot = path.slots[0];
+printk("leaf %Lu nritems %lu slot %d\n", path.nodes[0]->b_blocknr, nritems, slot);
+		if (advance) {
+printk("advancing!\n");
+			if (slot == nritems -1) {
+				ret = btrfs_next_leaf(root, &path);
+				if (ret)
+					break;
+				leaf = btrfs_buffer_leaf(path.nodes[0]);
+				nritems = btrfs_header_nritems(&leaf->header);
+				slot = path.slots[0];
+printk("2leaf %Lu nritems %lu slot %d\n", path.nodes[0]->b_blocknr, nritems, slot);
+			} else {
+				slot++;
+				path.slots[0]++;
+			}
+		}
+		advance = 1;
+		item = leaf->items + slot;
+printk("item key %Lu %u %Lu\n", btrfs_disk_key_objectid(&item->key),
+       btrfs_disk_key_flags(&item->key), btrfs_disk_key_offset(&item->key));
+		if (btrfs_disk_key_objectid(&item->key) != key.objectid)
+			break;
+		if (btrfs_disk_key_type(&item->key) != BTRFS_DIR_ITEM_KEY)
+			continue;
+		di = btrfs_item_ptr(leaf, slot, struct btrfs_dir_item);
+printk("filldir name %.*s, objectid %Lu\n", btrfs_dir_name_len(di),
+       (const char *)(di + 1), btrfs_dir_objectid(di));
+		over = filldir(dirent, (const char *)(di + 1),
+			       btrfs_dir_name_len(di),
+			       btrfs_disk_key_offset(&item->key),
+			       btrfs_dir_objectid(di), d_type);
+		if (over)
+			break;
+		filp->f_pos = btrfs_disk_key_offset(&item->key) + 1;
+	}
+printk("filldir all done\n");
+	ret = 0;
+err:
+	btrfs_release_path(root, &path);
+	return ret;
+}
+
+static void btrfs_put_super (struct super_block * sb)
+{
+	struct btrfs_root *root = btrfs_sb(sb);
+	int ret;
+
+	ret = close_ctree(root);
+	if (ret) {
+		printk("close ctree returns %d\n", ret);
+	}
+	sb->s_fs_info = NULL;
+}
 
 static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
 {
 	struct inode * inode;
-	struct dentry * root;
+	struct dentry * root_dentry;
+	struct btrfs_super_block *disk_super;
+	struct buffer_head *bh;
+	struct btrfs_root *root;
 
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = BTRFS_SUPER_MAGIC;
-	sb->s_op = &btrfs_ops;
+	sb->s_op = &btrfs_super_ops;
 	sb->s_time_gran = 1;
-	inode = btrfs_get_inode(sb, S_IFDIR | 0755, 0);
+
+	bh = sb_bread(sb, BTRFS_SUPER_INFO_OFFSET / sb->s_blocksize);
+	if (!bh) {
+		printk("btrfs: unable to read on disk super\n");
+		return -EIO;
+	}
+	disk_super = (struct btrfs_super_block *)bh->b_data;
+	root = open_ctree(sb, bh, disk_super);
+	sb->s_fs_info = root;
+	if (!root) {
+		printk("btrfs: open_ctree failed\n");
+		return -EIO;
+	}
+	printk("read in super total blocks %Lu root %Lu\n",
+	       btrfs_super_total_blocks(disk_super),
+	       btrfs_super_root_dir(disk_super));
+
+	inode = iget_locked(sb, btrfs_super_root_dir(disk_super));
 	if (!inode)
 		return -ENOMEM;
+	if (inode->i_state & I_NEW) {
+		btrfs_read_locked_inode(inode);
+		unlock_new_inode(inode);
+	}
 
-	root = d_alloc_root(inode);
-	if (!root) {
+	root_dentry = d_alloc_root(inode);
+	if (!root_dentry) {
 		iput(inode);
 		return -ENOMEM;
 	}
-	sb->s_root = root;
+	sb->s_root = root_dentry;
+
 	return 0;
 }
 
@@ -187,6 +390,24 @@ static struct file_system_type btrfs_fs_type = {
 	.fs_flags	= FS_REQUIRES_DEV,
 };
 
+static struct super_operations btrfs_super_ops = {
+	.statfs		= simple_statfs,
+	.drop_inode	= generic_delete_inode,
+	.put_super	= btrfs_put_super,
+	.read_inode	= btrfs_read_locked_inode,
+};
+
+static struct inode_operations btrfs_dir_inode_operations = {
+	.lookup		= btrfs_lookup,
+};
+
+static struct file_operations btrfs_dir_file_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= generic_read_dir,
+	.readdir	= btrfs_readdir,
+};
+
+
 static int __init init_btrfs_fs(void)
 {
 	printk("btrfs loaded!\n");

commit 2e635a278354a1a7951e16cfea4c247d6d0e7c99
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Mar 21 11:12:56 2007 -0400

    Btrfs: initial move to kernel module land
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
new file mode 100644
index 000000000000..4ae76044aeab
--- /dev/null
+++ b/fs/btrfs/super.c
@@ -0,0 +1,205 @@
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/time.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
+#include "ctree.h"
+
+#define BTRFS_SUPER_MAGIC 0x9123682E
+#if 0
+/* some random number */
+
+static struct super_operations ramfs_ops;
+static struct inode_operations ramfs_dir_inode_operations;
+
+static struct backing_dev_info ramfs_backing_dev_info = {
+	.ra_pages	= 0,	/* No readahead */
+	.capabilities	= BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK |
+			  BDI_CAP_MAP_DIRECT | BDI_CAP_MAP_COPY |
+			  BDI_CAP_READ_MAP | BDI_CAP_WRITE_MAP | BDI_CAP_EXEC_MAP,
+};
+
+struct inode *ramfs_get_inode(struct super_block *sb, int mode, dev_t dev)
+{
+	struct inode * inode = new_inode(sb);
+
+	if (inode) {
+		inode->i_mode = mode;
+		inode->i_uid = current->fsuid;
+		inode->i_gid = current->fsgid;
+		inode->i_blocks = 0;
+		inode->i_mapping->a_ops = &ramfs_aops;
+		inode->i_mapping->backing_dev_info = &ramfs_backing_dev_info;
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		switch (mode & S_IFMT) {
+		default:
+			init_special_inode(inode, mode, dev);
+			break;
+		case S_IFREG:
+			inode->i_op = &ramfs_file_inode_operations;
+			inode->i_fop = &ramfs_file_operations;
+			break;
+		case S_IFDIR:
+			inode->i_op = &ramfs_dir_inode_operations;
+			inode->i_fop = &simple_dir_operations;
+
+			/* directory inodes start off with i_nlink == 2 (for "." entry) */
+			inc_nlink(inode);
+			break;
+		case S_IFLNK:
+			inode->i_op = &page_symlink_inode_operations;
+			break;
+		}
+	}
+	return inode;
+}
+
+/*
+ * File creation. Allocate an inode, and we're done..
+ */
+/* SMP-safe */
+static int
+ramfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	struct inode * inode = ramfs_get_inode(dir->i_sb, mode, dev);
+	int error = -ENOSPC;
+
+	if (inode) {
+		if (dir->i_mode & S_ISGID) {
+			inode->i_gid = dir->i_gid;
+			if (S_ISDIR(mode))
+				inode->i_mode |= S_ISGID;
+		}
+		d_instantiate(dentry, inode);
+		dget(dentry);	/* Extra count - pin the dentry in core */
+		error = 0;
+		dir->i_mtime = dir->i_ctime = CURRENT_TIME;
+	}
+	return error;
+}
+
+static int ramfs_mkdir(struct inode * dir, struct dentry * dentry, int mode)
+{
+	int retval = ramfs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	if (!retval)
+		inc_nlink(dir);
+	return retval;
+}
+
+static int ramfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+{
+	return ramfs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int ramfs_symlink(struct inode * dir, struct dentry *dentry, const char * symname)
+{
+	struct inode *inode;
+	int error = -ENOSPC;
+
+	inode = ramfs_get_inode(dir->i_sb, S_IFLNK|S_IRWXUGO, 0);
+	if (inode) {
+		int l = strlen(symname)+1;
+		error = page_symlink(inode, symname, l);
+		if (!error) {
+			if (dir->i_mode & S_ISGID)
+				inode->i_gid = dir->i_gid;
+			d_instantiate(dentry, inode);
+			dget(dentry);
+			dir->i_mtime = dir->i_ctime = CURRENT_TIME;
+		} else
+			iput(inode);
+	}
+	return error;
+}
+
+static struct inode_operations ramfs_dir_inode_operations = {
+	.create		= ramfs_create,
+	.lookup		= simple_lookup,
+	.link		= simple_link,
+	.unlink		= simple_unlink,
+	.symlink	= ramfs_symlink,
+	.mkdir		= ramfs_mkdir,
+	.rmdir		= simple_rmdir,
+	.mknod		= ramfs_mknod,
+	.rename		= simple_rename,
+};
+#endif
+
+struct inode *btrfs_get_inode(struct super_block *sb, int mode, dev_t dev)
+{
+	struct inode * inode = new_inode(sb);
+
+	if (inode) {
+		inode->i_mode = mode;
+		inode->i_uid = current->fsuid;
+		inode->i_gid = current->fsgid;
+		inode->i_blocks = 0;
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	}
+	return inode;
+}
+
+static struct super_operations btrfs_ops = {
+	.statfs		= simple_statfs,
+	.drop_inode	= generic_delete_inode,
+};
+
+static int btrfs_fill_super(struct super_block * sb, void * data, int silent)
+{
+	struct inode * inode;
+	struct dentry * root;
+
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = BTRFS_SUPER_MAGIC;
+	sb->s_op = &btrfs_ops;
+	sb->s_time_gran = 1;
+	inode = btrfs_get_inode(sb, S_IFDIR | 0755, 0);
+	if (!inode)
+		return -ENOMEM;
+
+	root = d_alloc_root(inode);
+	if (!root) {
+		iput(inode);
+		return -ENOMEM;
+	}
+	sb->s_root = root;
+	return 0;
+}
+
+static int btrfs_get_sb(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data,
+			   btrfs_fill_super, mnt);
+}
+
+static struct file_system_type btrfs_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "btrfs",
+	.get_sb		= btrfs_get_sb,
+	.kill_sb	= kill_block_super,
+	.fs_flags	= FS_REQUIRES_DEV,
+};
+
+static int __init init_btrfs_fs(void)
+{
+	printk("btrfs loaded!\n");
+	return register_filesystem(&btrfs_fs_type);
+}
+
+static void __exit exit_btrfs_fs(void)
+{
+	unregister_filesystem(&btrfs_fs_type);
+	printk("btrfs unloaded\n");
+}
+
+module_init(init_btrfs_fs)
+module_exit(exit_btrfs_fs)
+
+MODULE_LICENSE("GPL");
