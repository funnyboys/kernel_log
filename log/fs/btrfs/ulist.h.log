commit 9888c3402c8567a977de37f61e9dd87792723064
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 3 19:16:55 2018 +0200

    btrfs: replace GPL boilerplate by SPDX -- headers
    
    Remove GPL boilerplate text (long, short, one-line) and keep the rest,
    ie. personal, company or original source copyright statements. Add the
    SPDX header.
    
    Unify the include protection macros to match the file names.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 53c913632733..02fda0a2d4ce 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -1,12 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (C) 2011 STRATO AG
  * written by Arne Jansen <sensille@gmx.net>
- * Distributed under the GNU GPL license version 2.
- *
  */
 
-#ifndef __ULIST__
-#define __ULIST__
+#ifndef BTRFS_ULIST_H
+#define BTRFS_ULIST_H
 
 #include <linux/list.h>
 #include <linux/rbtree.h>

commit 6655bc3de1078f8343263b8d822d0aa2236d86b4
Author: David Sterba <dsterba@suse.com>
Date:   Wed Feb 15 16:47:36 2017 +0100

    btrfs: ulist: rename ulist_fini to ulist_release
    
    Change the name so it matches the naming we already use eg. for
    btrfs_path.
    
    Suggested-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 1a4130443d7e..53c913632733 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -44,7 +44,7 @@ struct ulist {
 };
 
 void ulist_init(struct ulist *ulist);
-void ulist_fini(struct ulist *ulist);
+void ulist_release(struct ulist *ulist);
 void ulist_reinit(struct ulist *ulist);
 struct ulist *ulist_alloc(gfp_t gfp_mask);
 void ulist_free(struct ulist *ulist);

commit 9d037933861805799db4edfd075412a39e2549f4
Author: David Sterba <dsterba@suse.com>
Date:   Mon Feb 13 13:40:16 2017 +0100

    btrfs: ulist: make the finalization function public
    
    Make ulist_fini externally visible so the ulist API is complete.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 007b22fff3f9..1a4130443d7e 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -44,6 +44,7 @@ struct ulist {
 };
 
 void ulist_init(struct ulist *ulist);
+void ulist_fini(struct ulist *ulist);
 void ulist_reinit(struct ulist *ulist);
 struct ulist *ulist_alloc(gfp_t gfp_mask);
 void ulist_free(struct ulist *ulist);

commit 66bbc1c0c0b283600abd187bf8c8c25ab7549307
Author: David Sterba <dsterba@suse.com>
Date:   Thu Feb 9 16:47:43 2017 +0100

    btrfs: remove unused ulist members
    
    Commit "btrfs: ulist: Add ulist_del() function" (d4b804045924d7f8)
    removed some debugging code but left the structure defintions.
    
    Reviewed-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index a01a2c45825f..007b22fff3f9 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -19,9 +19,6 @@
  *
  */
 struct ulist_iterator {
-#ifdef CONFIG_BTRFS_DEBUG
-	int i;
-#endif
 	struct list_head *cur_list;  /* hint to start search */
 };
 
@@ -32,10 +29,6 @@ struct ulist_node {
 	u64 val;		/* value to store */
 	u64 aux;		/* auxiliary value saved along with the val */
 
-#ifdef CONFIG_BTRFS_DEBUG
-	int seqnum;		/* sequence number this node is added */
-#endif
-
 	struct list_head list;  /* used to link node */
 	struct rb_node rb_node;	/* used to speed up search */
 };

commit d4b804045924d7f8d2ea988be22c4b9e6492ec11
Author: Qu Wenruo <quwenruo@cn.fujitsu.com>
Date:   Mon Apr 20 09:26:02 2015 +0800

    btrfs: ulist: Add ulist_del() function.
    
    This function will delete unode with given (val,aux) pair.
    And with this patch, seqnum for debug usage doesn't have any meaning
    now, so remove them.
    
    This is used by later patches to skip snapshot root.
    
    Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 4c29db604bbe..a01a2c45825f 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -57,6 +57,7 @@ void ulist_free(struct ulist *ulist);
 int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask);
 int ulist_add_merge(struct ulist *ulist, u64 val, u64 aux,
 		    u64 *old_aux, gfp_t gfp_mask);
+int ulist_del(struct ulist *ulist, u64 val, u64 aux);
 
 /* just like ulist_add_merge() but take a pointer for the aux data */
 static inline int ulist_add_merge_ptr(struct ulist *ulist, u64 val, void *aux,

commit 4eb1f66dce6c4dc28dd90a7ffbe6b2b1cb08aa4e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 28 10:57:04 2014 +0200

    Btrfs: Fix memory corruption by ulist_add_merge() on 32bit arch
    
    We've got bug reports that btrfs crashes when quota is enabled on
    32bit kernel, typically with the Oops like below:
     BUG: unable to handle kernel NULL pointer dereference at 00000004
     IP: [<f9234590>] find_parent_nodes+0x360/0x1380 [btrfs]
     *pde = 00000000
     Oops: 0000 [#1] SMP
     CPU: 0 PID: 151 Comm: kworker/u8:2 Tainted: G S      W 3.15.2-1.gd43d97e-default #1
     Workqueue: btrfs-qgroup-rescan normal_work_helper [btrfs]
     task: f1478130 ti: f147c000 task.ti: f147c000
     EIP: 0060:[<f9234590>] EFLAGS: 00010213 CPU: 0
     EIP is at find_parent_nodes+0x360/0x1380 [btrfs]
     EAX: f147dda8 EBX: f147ddb0 ECX: 00000011 EDX: 00000000
     ESI: 00000000 EDI: f147dda4 EBP: f147ddf8 ESP: f147dd38
      DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
     CR0: 8005003b CR2: 00000004 CR3: 00bf3000 CR4: 00000690
     Stack:
      00000000 00000000 f147dda4 00000050 00000001 00000000 00000001 00000050
      00000001 00000000 d3059000 00000001 00000022 000000a8 00000000 00000000
      00000000 000000a1 00000000 00000000 00000001 00000000 00000000 11800000
     Call Trace:
      [<f923564d>] __btrfs_find_all_roots+0x9d/0xf0 [btrfs]
      [<f9237bb1>] btrfs_qgroup_rescan_worker+0x401/0x760 [btrfs]
      [<f9206148>] normal_work_helper+0xc8/0x270 [btrfs]
      [<c025e38b>] process_one_work+0x11b/0x390
      [<c025eea1>] worker_thread+0x101/0x340
      [<c026432b>] kthread+0x9b/0xb0
      [<c0712a71>] ret_from_kernel_thread+0x21/0x30
      [<c0264290>] kthread_create_on_node+0x110/0x110
    
    This indicates a NULL corruption in prefs_delayed list.  The further
    investigation and bisection pointed that the call of ulist_add_merge()
    results in the corruption.
    
    ulist_add_merge() takes u64 as aux and writes a 64bit value into
    old_aux.  The callers of this function in backref.c, however, pass a
    pointer of a pointer to old_aux.  That is, the function overwrites
    64bit value on 32bit pointer.  This caused a NULL in the adjacent
    variable, in this case, prefs_delayed.
    
    Here is a quick attempt to band-aid over this: a new function,
    ulist_add_merge_ptr() is introduced to pass/store properly a pointer
    value instead of u64.  There are still ugly void ** cast remaining
    in the callers because void ** cannot be taken implicitly.  But, it's
    safer than explicit cast to u64, anyway.
    
    Bugzilla: https://bugzilla.novell.com/show_bug.cgi?id=887046
    Cc: <stable@vger.kernel.org> [v3.11+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 7f78cbf5cf41..4c29db604bbe 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -57,6 +57,21 @@ void ulist_free(struct ulist *ulist);
 int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask);
 int ulist_add_merge(struct ulist *ulist, u64 val, u64 aux,
 		    u64 *old_aux, gfp_t gfp_mask);
+
+/* just like ulist_add_merge() but take a pointer for the aux data */
+static inline int ulist_add_merge_ptr(struct ulist *ulist, u64 val, void *aux,
+				      void **old_aux, gfp_t gfp_mask)
+{
+#if BITS_PER_LONG == 32
+	u64 old64 = (uintptr_t)*old_aux;
+	int ret = ulist_add_merge(ulist, val, (uintptr_t)aux, &old64, gfp_mask);
+	*old_aux = (void *)((uintptr_t)old64);
+	return ret;
+#else
+	return ulist_add_merge(ulist, val, (u64)aux, (u64 *)old_aux, gfp_mask);
+#endif
+}
+
 struct ulist_node *ulist_next(struct ulist *ulist,
 			      struct ulist_iterator *uiter);
 

commit 49fc647a2c558862145357f3a25892248042f6fe
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Wed Jan 29 00:25:35 2014 +0800

    Btrfs: do not export ulist functions
    
    There are not any users that use ulist except Btrfs,don't
    export them.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 2be7102d8073..7f78cbf5cf41 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -51,7 +51,6 @@ struct ulist {
 };
 
 void ulist_init(struct ulist *ulist);
-void ulist_fini(struct ulist *ulist);
 void ulist_reinit(struct ulist *ulist);
 struct ulist *ulist_alloc(gfp_t gfp_mask);
 void ulist_free(struct ulist *ulist);

commit 4c7a6f74ceeafd738b55d1c57349327f7ea8e895
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Wed Jan 29 00:25:34 2014 +0800

    Btrfs: rework ulist with list+rb_tree
    
    We are really suffering from now ulist's implementation, some developers
    gave their try, and i just gave some of my ideas for things:
    
     1. use list+rb_tree instead of arrary+rb_tree
    
     2. add cur_list to iterator rather than ulist structure.
    
     3. add seqnum into every node when they are added, this is
     used to do selfcheck when iterating node.
    
    I noticed Zach Brown's comments before, long term is to kick off
    ulist implementation, however, for now, we need at least avoid
    arrary from ulist.
    
    Cc: Liu Bo <bo.li.liu@oracle.com>
    Cc: Josef Bacik <jbacik@fb.com>
    Cc: Zach Brown <zab@redhat.com>
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index fb36731074b5..2be7102d8073 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -17,18 +17,12 @@
  * enumerating it.
  * It is possible to store an auxiliary value along with the key.
  *
- * The implementation is preliminary and can probably be sped up
- * significantly. A first step would be to store the values in an rbtree
- * as soon as ULIST_SIZE is exceeded.
  */
-
-/*
- * number of elements statically allocated inside struct ulist
- */
-#define ULIST_SIZE 16
-
 struct ulist_iterator {
+#ifdef CONFIG_BTRFS_DEBUG
 	int i;
+#endif
+	struct list_head *cur_list;  /* hint to start search */
 };
 
 /*
@@ -37,6 +31,12 @@ struct ulist_iterator {
 struct ulist_node {
 	u64 val;		/* value to store */
 	u64 aux;		/* auxiliary value saved along with the val */
+
+#ifdef CONFIG_BTRFS_DEBUG
+	int seqnum;		/* sequence number this node is added */
+#endif
+
+	struct list_head list;  /* used to link node */
 	struct rb_node rb_node;	/* used to speed up search */
 };
 
@@ -46,24 +46,8 @@ struct ulist {
 	 */
 	unsigned long nnodes;
 
-	/*
-	 * number of nodes we already have room for
-	 */
-	unsigned long nodes_alloced;
-
-	/*
-	 * pointer to the array storing the elements. The first ULIST_SIZE
-	 * elements are stored inline. In this case the it points to int_nodes.
-	 * After exceeding ULIST_SIZE, dynamic memory is allocated.
-	 */
-	struct ulist_node *nodes;
-
+	struct list_head nodes;
 	struct rb_root root;
-
-	/*
-	 * inline storage space for the first ULIST_SIZE entries
-	 */
-	struct ulist_node int_nodes[ULIST_SIZE];
 };
 
 void ulist_init(struct ulist *ulist);
@@ -77,6 +61,6 @@ int ulist_add_merge(struct ulist *ulist, u64 val, u64 aux,
 struct ulist_node *ulist_next(struct ulist *ulist,
 			      struct ulist_iterator *uiter);
 
-#define ULIST_ITER_INIT(uiter) ((uiter)->i = 0)
+#define ULIST_ITER_INIT(uiter) ((uiter)->cur_list = NULL)
 
 #endif

commit f7f82b81d2c297a5864dcfd0a205917d3e753aba
Author: Wang Shilong <wangsl-fnst@cn.fujitsu.com>
Date:   Fri Apr 12 12:12:17 2013 +0000

    Btrfs: add a rb_tree to improve performance of ulist search
    
    Walking backref tree and btrfs quota rely on ulist very much.
    This patch tries to use rb_tree to speed up search time.
    
    The original code always checks whether an element
    exists before adding a new element, however it costs O(n).
    
    I try to add a rb_tree in the ulist,this is only used to speed up
    search. I also do some measurements with quota enabled.
    
    fsstress -p 4 -n 10000
    
    Without this path:
    real    0m51.058s       2m4.745s        1m28.222s       1m5.137s
    user    0m0.035s        0m0.041s        0m0.105s        0m0.100s
    sys     0m12.009s       0m11.246s       0m10.901s       0m10.999s       0m11.287s
    
    With this path:
    real    0m55.295s       0m50.960s       1m2.214s        0m48.273s
    user    0m0.053s        0m0.095s        0m0.135s        0m0.107s
    sys     0m7.766s        0m6.013s        0m6.319s        0m6.030s        0m6.532s
    
    After applying the patch,the execute time is down by ~42%.(11.287s->6.532s)
    
    Signed-off-by: Wang Shilong <wangsl-fnst@cn.fujitsu.com>
    Reviewed-by: Miao Xie <miaox@cn.fujitsu.com>
    Reviewed-by: Jan Schmidt <list.btrfs@jan-o-sch.net>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 21a1963439c3..fb36731074b5 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -8,6 +8,9 @@
 #ifndef __ULIST__
 #define __ULIST__
 
+#include <linux/list.h>
+#include <linux/rbtree.h>
+
 /*
  * ulist is a generic data structure to hold a collection of unique u64
  * values. The only operations it supports is adding to the list and
@@ -34,6 +37,7 @@ struct ulist_iterator {
 struct ulist_node {
 	u64 val;		/* value to store */
 	u64 aux;		/* auxiliary value saved along with the val */
+	struct rb_node rb_node;	/* used to speed up search */
 };
 
 struct ulist {
@@ -54,6 +58,8 @@ struct ulist {
 	 */
 	struct ulist_node *nodes;
 
+	struct rb_root root;
+
 	/*
 	 * inline storage space for the first ULIST_SIZE entries
 	 */

commit 34d73f54e2e2227cece751f168d08d3103092992
Author: Alexander Block <ablock84@googlemail.com>
Date:   Sat Jul 28 16:18:58 2012 +0200

    Btrfs: make aux field of ulist 64 bit
    
    Btrfs send/receive uses the aux field to store inode numbers. On
    32 bit machines this may become a problem.
    
    Also fix all users of ulist_add and ulist_add_merged.
    
    Reported-by: Arne Jansen <sensille@gmx.net>
    Signed-off-by: Alexander Block <ablock84@googlemail.com>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 21bdc8ec8130..21a1963439c3 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -33,7 +33,7 @@ struct ulist_iterator {
  */
 struct ulist_node {
 	u64 val;		/* value to store */
-	unsigned long aux;	/* auxiliary value saved along with the val */
+	u64 aux;		/* auxiliary value saved along with the val */
 };
 
 struct ulist {
@@ -65,10 +65,9 @@ void ulist_fini(struct ulist *ulist);
 void ulist_reinit(struct ulist *ulist);
 struct ulist *ulist_alloc(gfp_t gfp_mask);
 void ulist_free(struct ulist *ulist);
-int ulist_add(struct ulist *ulist, u64 val, unsigned long aux,
-	      gfp_t gfp_mask);
-int ulist_add_merge(struct ulist *ulist, u64 val, unsigned long aux,
-		    unsigned long *old_aux, gfp_t gfp_mask);
+int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask);
+int ulist_add_merge(struct ulist *ulist, u64 val, u64 aux,
+		    u64 *old_aux, gfp_t gfp_mask);
 struct ulist_node *ulist_next(struct ulist *ulist,
 			      struct ulist_iterator *uiter);
 

commit 1e20932a23578bb1ec59107843574e259b96193f
Merge: cfc442b69696 c31931088fd6
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu May 31 16:50:28 2012 -0400

    Merge branch 'for-chris' of git://git.jan-o-sch.net/btrfs-unstable into for-linus
    
    Conflicts:
            fs/btrfs/ulist.h
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

commit 3301958b7c1dae8f0f5ded63aa881e0b71e78464
Author: Jan Schmidt <list.btrfs@jan-o-sch.net>
Date:   Wed May 30 18:05:21 2012 +0200

    Btrfs: add inodes before dropping the extent lock in find_all_leafs
    
    We must build up the inode list with the extent lock held after following
    indirect refs.
    
    This also requires an extension to ulists, which allows to modify the stored
    aux value in case a key already exists in the list.
    
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 62d2574f775a..f1b1bf00c5a9 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -67,6 +67,8 @@ struct ulist *ulist_alloc(unsigned long gfp_mask);
 void ulist_free(struct ulist *ulist);
 int ulist_add(struct ulist *ulist, u64 val, unsigned long aux,
 	      unsigned long gfp_mask);
+int ulist_add_merge(struct ulist *ulist, u64 val, unsigned long aux,
+		    unsigned long *old_aux, unsigned long gfp_mask);
 struct ulist_node *ulist_next(struct ulist *ulist,
 			      struct ulist_iterator *uiter);
 

commit 2eec6c8102c62c540c637176271cfdb13d828d7b
Author: Daniel J Blueman <daniel@quora.org>
Date:   Thu Apr 26 00:37:14 2012 +0800

    Fix minor type issues
    
    Address some minor type issues identified by sparse checker.
    
    Signed-off-by: Daniel J Blueman <daniel@quora.org>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 2e25dec58ec0..6568c3527732 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -59,10 +59,9 @@ struct ulist {
 void ulist_init(struct ulist *ulist);
 void ulist_fini(struct ulist *ulist);
 void ulist_reinit(struct ulist *ulist);
-struct ulist *ulist_alloc(unsigned long gfp_mask);
+struct ulist *ulist_alloc(gfp_t gfp_mask);
 void ulist_free(struct ulist *ulist);
-int ulist_add(struct ulist *ulist, u64 val, unsigned long aux,
-	      unsigned long gfp_mask);
+int ulist_add(struct ulist *ulist, u64 val, unsigned long aux, gfp_t gfp_mask);
 struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_node *prev);
 
 #endif

commit cd1b413c5c863a96bfdeab8e91b1fb3a52665e42
Author: Jan Schmidt <list.btrfs@jan-o-sch.net>
Date:   Tue May 22 14:56:50 2012 +0200

    Btrfs: ulist realloc bugfix
    
    ulist_next gets the pointer to the previously returned element to find the
    next element from there. However, when we call ulist_add while iteration
    with ulist_next is in progress (ulist explicitly supports this), we can
    realloc the ulist internal memory, which makes the pointer to the previous
    element useless.
    
    Instead, we now use an iterator parameter that's independent from the
    internal pointers.
    
    Reported-by: Alexander Block <ablock84@googlemail.com>
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
index 2e25dec58ec0..62d2574f775a 100644
--- a/fs/btrfs/ulist.h
+++ b/fs/btrfs/ulist.h
@@ -24,6 +24,10 @@
  */
 #define ULIST_SIZE 16
 
+struct ulist_iterator {
+	int i;
+};
+
 /*
  * element of the list
  */
@@ -63,6 +67,9 @@ struct ulist *ulist_alloc(unsigned long gfp_mask);
 void ulist_free(struct ulist *ulist);
 int ulist_add(struct ulist *ulist, u64 val, unsigned long aux,
 	      unsigned long gfp_mask);
-struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_node *prev);
+struct ulist_node *ulist_next(struct ulist *ulist,
+			      struct ulist_iterator *uiter);
+
+#define ULIST_ITER_INIT(uiter) ((uiter)->i = 0)
 
 #endif

commit da5c81356426c476112f2b59fe64bdb1b37f079d
Author: Arne Jansen <sensille@gmx.net>
Date:   Tue Sep 13 12:29:12 2011 +0200

    Btrfs: generic data structure to build unique lists
    
    ulist is a generic data structures to hold a collection of unique u64
    values. The only operations it supports is adding to the list and
    enumerating it.
    
    It is possible to store an auxiliary value along with the key. The
    implementation is preliminary and can probably be sped up significantly.
    
    It is used by btrfs_find_all_roots() quota to translate recursions into
    iterative loops.
    
    Signed-off-by: Arne Jansen <sensille@gmx.net>
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>

diff --git a/fs/btrfs/ulist.h b/fs/btrfs/ulist.h
new file mode 100644
index 000000000000..2e25dec58ec0
--- /dev/null
+++ b/fs/btrfs/ulist.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2011 STRATO AG
+ * written by Arne Jansen <sensille@gmx.net>
+ * Distributed under the GNU GPL license version 2.
+ *
+ */
+
+#ifndef __ULIST__
+#define __ULIST__
+
+/*
+ * ulist is a generic data structure to hold a collection of unique u64
+ * values. The only operations it supports is adding to the list and
+ * enumerating it.
+ * It is possible to store an auxiliary value along with the key.
+ *
+ * The implementation is preliminary and can probably be sped up
+ * significantly. A first step would be to store the values in an rbtree
+ * as soon as ULIST_SIZE is exceeded.
+ */
+
+/*
+ * number of elements statically allocated inside struct ulist
+ */
+#define ULIST_SIZE 16
+
+/*
+ * element of the list
+ */
+struct ulist_node {
+	u64 val;		/* value to store */
+	unsigned long aux;	/* auxiliary value saved along with the val */
+};
+
+struct ulist {
+	/*
+	 * number of elements stored in list
+	 */
+	unsigned long nnodes;
+
+	/*
+	 * number of nodes we already have room for
+	 */
+	unsigned long nodes_alloced;
+
+	/*
+	 * pointer to the array storing the elements. The first ULIST_SIZE
+	 * elements are stored inline. In this case the it points to int_nodes.
+	 * After exceeding ULIST_SIZE, dynamic memory is allocated.
+	 */
+	struct ulist_node *nodes;
+
+	/*
+	 * inline storage space for the first ULIST_SIZE entries
+	 */
+	struct ulist_node int_nodes[ULIST_SIZE];
+};
+
+void ulist_init(struct ulist *ulist);
+void ulist_fini(struct ulist *ulist);
+void ulist_reinit(struct ulist *ulist);
+struct ulist *ulist_alloc(unsigned long gfp_mask);
+void ulist_free(struct ulist *ulist);
+int ulist_add(struct ulist *ulist, u64 val, unsigned long aux,
+	      unsigned long gfp_mask);
+struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_node *prev);
+
+#endif
