commit a019e9e197eaa68ffe2efeba00d685581b1a5416
Author: David Sterba <dsterba@suse.com>
Date:   Fri Aug 30 15:40:53 2019 +0200

    btrfs: remove extent_map::bdev
    
    We can now remove the bdev from extent_map. Previous patches made sure
    that bio_set_dev is correctly in all places and that we don't need to
    grab it from latest_bdev or pass it around inside the extent map.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 3eb9c596b445..8e217337dff9 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -42,15 +42,8 @@ struct extent_map {
 	u64 block_len;
 	u64 generation;
 	unsigned long flags;
-	struct {
-		struct block_device *bdev;
-
-		/*
-		 * used for chunk mappings
-		 * flags & EXTENT_FLAG_FS_MAPPING must be set
-		 */
-		struct map_lookup *map_lookup;
-	};
+	/* Used for chunk mappings, flag EXTENT_FLAG_FS_MAPPING must be set */
+	struct map_lookup *map_lookup;
 	refcount_t refs;
 	unsigned int compress_type;
 	struct list_head list;

commit c3e14909d3b399d49d8dfcf3edbcd5463a7eed6f
Author: David Sterba <dsterba@suse.com>
Date:   Fri May 10 17:48:30 2019 +0200

    btrfs: assert extent_map bdevs and lookup_map and split
    
    This is a preparatory patch for removing extent_map::bdev. There's some
    history behind the code so this is only precaution to catch if things
    break before the actual removal happens.
    
    Logically, comparing a raw low-level block device (bdev) does not make
    sense for extent maps (high-level objects). This had no effect in
    practice but was quite confusing in the code.  The lookup_map is set iff
    EXTENT_FLAG_FS_MAPPING is set.
    
    The two pointers were stored in the same bytes and used potentially in
    two meanings. Now they're split, so the asserts are in place to check
    that the condition will not change.
    
    The lookup map pointer misused bdev, this has been changed in commit
    95617d69326c ("btrfs: cleanup, stop casting for extent_map->lookup
    everywhere") to the explicit type. But the semantics hasn't changed and
    bdev was not actually used to decide if maps are mergeable.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 473f039fcd7c..3eb9c596b445 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -42,7 +42,7 @@ struct extent_map {
 	u64 block_len;
 	u64 generation;
 	unsigned long flags;
-	union {
+	struct {
 		struct block_device *bdev;
 
 		/*

commit 951e05a90469e29326715e7e3aefd4680748b4fa
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Jan 8 16:53:46 2019 +0200

    btrfs: Remove impossible condition from mergable_maps
    
    We can never have extents marked as EXTENT_MAP_DELALLOC since this
    value is only ever used by btrfs_get_extent_fiemap. In this case the
    extent map is created by btrfs_get_extent_fiemap and is never really
    published, this flag is used to return the corresponding userspace one.
    Considering this, it's pointless having a check for EXTENT_MAP_DELALLOC
    in mergable_maps. Just remove it.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index ef05a0121652..473f039fcd7c 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -9,6 +9,7 @@
 #define EXTENT_MAP_LAST_BYTE ((u64)-4)
 #define EXTENT_MAP_HOLE ((u64)-3)
 #define EXTENT_MAP_INLINE ((u64)-2)
+/* used only during fiemap calls */
 #define EXTENT_MAP_DELALLOC ((u64)-1)
 
 /* bits for the extent_map::flags field */

commit 50b5b6020fc3e2c4c67ff28bf3986a1e70bffc7d
Author: David Sterba <dsterba@suse.com>
Date:   Tue Nov 27 15:11:43 2018 +0100

    btrfs: switch EXTENT_FLAG_* to enums
    
    We can use simple enum for values that are not part of on-disk format:
    extent map flags.
    
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 31977ffd6190..ef05a0121652 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -11,13 +11,20 @@
 #define EXTENT_MAP_INLINE ((u64)-2)
 #define EXTENT_MAP_DELALLOC ((u64)-1)
 
-/* bits for the flags field */
-#define EXTENT_FLAG_PINNED 0 /* this entry not yet on disk, don't free it */
-#define EXTENT_FLAG_COMPRESSED 1
-#define EXTENT_FLAG_PREALLOC 3 /* pre-allocated extent */
-#define EXTENT_FLAG_LOGGING 4 /* Logging this extent */
-#define EXTENT_FLAG_FILLING 5 /* Filling in a preallocated extent */
-#define EXTENT_FLAG_FS_MAPPING 6 /* filesystem extent mapping type */
+/* bits for the extent_map::flags field */
+enum {
+	/* this entry not yet on disk, don't free it */
+	EXTENT_FLAG_PINNED,
+	EXTENT_FLAG_COMPRESSED,
+	/* pre-allocated extent */
+	EXTENT_FLAG_PREALLOC,
+	/* Logging this extent */
+	EXTENT_FLAG_LOGGING,
+	/* Filling in a preallocated extent */
+	EXTENT_FLAG_FILLING,
+	/* filesystem extent mapping type */
+	EXTENT_FLAG_FS_MAPPING,
+};
 
 struct extent_map {
 	struct rb_node rb_node;

commit 07e1ce096db3605f3e0c98695df66a51e2be9f05
Author: Liu Bo <bo.liu@linux.alibaba.com>
Date:   Thu Aug 23 03:51:52 2018 +0800

    Btrfs: extent_map: use rb_first_cached
    
    rb_first_cached() trades an extra pointer "leftmost" for doing the
    same job as rb_first() but in O(1).
    
    As evict_inode_truncate_pages() removes all extent mapping by always
    looking for the first rb entry, it's helpful to use rb_first_cached
    instead.
    
    For more details about the optimization see patch "Btrfs: delayed-refs:
    use rb_first_cached for href_root".
    
    Tested-by: Holger Hoffst√§tte <holger@applied-asynchrony.com>
    Signed-off-by: Liu Bo <bo.liu@linux.alibaba.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index a7ceb30449fc..31977ffd6190 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -49,7 +49,7 @@ struct extent_map {
 };
 
 struct extent_map_tree {
-	struct rb_root map;
+	struct rb_root_cached map;
 	struct list_head modified_extents;
 	rwlock_t lock;
 };

commit c1766dd7829802b3a451682234497a8539763bd1
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Thu Sep 13 11:01:15 2018 +0800

    btrfs: change remove_extent_mapping to return void
    
    remove_extent_mapping uses the variable "ret" for return value, but it
    is not modified after initialzation. Further, I find that any of the
    callers do not handle the return value and the callees are only simple
    functions so the return values does not need to be passed.
    
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 25d985e7532a..a7ceb30449fc 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -78,7 +78,7 @@ struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 len);
 int add_extent_mapping(struct extent_map_tree *tree,
 		       struct extent_map *em, int modified);
-int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em);
+void remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em);
 void replace_extent_mapping(struct extent_map_tree *tree,
 			    struct extent_map *cur,
 			    struct extent_map *new,

commit f46b24c9457143a367c6707eac82d546e2bcf280
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 3 21:45:57 2018 +0200

    btrfs: use fs_info for btrfs_handle_em_exist tracepoint
    
    We really want to know to which filesystem the extent map events belong,
    but as it cannot be reached from the extent_map pointers, we need to
    pass it down the callchain.
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 5fcb80a6ce37..25d985e7532a 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -92,7 +92,8 @@ int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len, u64 gen
 void clear_em_logging(struct extent_map_tree *tree, struct extent_map *em);
 struct extent_map *search_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 len);
-int btrfs_add_extent_mapping(struct extent_map_tree *em_tree,
+int btrfs_add_extent_mapping(struct btrfs_fs_info *fs_info,
+			     struct extent_map_tree *em_tree,
 			     struct extent_map **em_in, u64 start, u64 len);
 
 #endif

commit 9888c3402c8567a977de37f61e9dd87792723064
Author: David Sterba <dsterba@suse.com>
Date:   Tue Apr 3 19:16:55 2018 +0200

    btrfs: replace GPL boilerplate by SPDX -- headers
    
    Remove GPL boilerplate text (long, short, one-line) and keep the rest,
    ie. personal, company or original source copyright statements. Add the
    SPDX header.
    
    Unify the include protection macros to match the file names.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index f6f8ba114977..5fcb80a6ce37 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -1,6 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __EXTENTMAP__
-#define __EXTENTMAP__
+
+#ifndef BTRFS_EXTENT_MAP_H
+#define BTRFS_EXTENT_MAP_H
 
 #include <linux/rbtree.h>
 #include <linux/refcount.h>
@@ -93,4 +94,5 @@ struct extent_map *search_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 len);
 int btrfs_add_extent_mapping(struct extent_map_tree *em_tree,
 			     struct extent_map **em_in, u64 start, u64 len);
+
 #endif

commit e67c718b5b9a306bde7e966be7b4ca48fa063d73
Author: David Sterba <dsterba@suse.com>
Date:   Mon Feb 19 17:24:18 2018 +0100

    btrfs: add more __cold annotations
    
    The __cold functions are placed to a special section, as they're
    expected to be called rarely. This could help i-cache prefetches or help
    compiler to decide which branches are more/less likely to be taken
    without any other annotations needed.
    
    Though we can't add more __exit annotations, it's still possible to add
    __cold (that's also added with __exit). That way the following function
    categories are tagged:
    
    - printf wrappers, error messages
    - exit helpers
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index b29f77bc0732..f6f8ba114977 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -86,7 +86,7 @@ void replace_extent_mapping(struct extent_map_tree *tree,
 struct extent_map *alloc_extent_map(void);
 void free_extent_map(struct extent_map *em);
 int __init extent_map_init(void);
-void extent_map_exit(void);
+void __cold extent_map_exit(void);
 int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len, u64 gen);
 void clear_em_logging(struct extent_map_tree *tree, struct extent_map *em);
 struct extent_map *search_extent_mapping(struct extent_map_tree *tree,

commit c04e61b5e41b0e8ace4aa4b67685fbe68ac37a46
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Fri Jan 5 12:51:11 2018 -0700

    Btrfs: move extent map specific code to extent_map.c
    
    These helpers are extent map specific, move them to extent_map.c.
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index e9e285d45c7e..b29f77bc0732 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -91,4 +91,6 @@ int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len, u64 gen
 void clear_em_logging(struct extent_map_tree *tree, struct extent_map *em);
 struct extent_map *search_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 len);
+int btrfs_add_extent_mapping(struct extent_map_tree *em_tree,
+			     struct extent_map **em_in, u64 start, u64 len);
 #endif

commit 4a2d25cd93cbd2e5ad6c9aabd90da362b2dd9984
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Thu Nov 23 10:51:43 2017 +0200

    btrfs: Remove redundant FLAG_VACANCY
    
    Commit 9036c10208e1 ("Btrfs: update hole handling v2") added the
    FLAG_VACANCY to denote holes, however there was already a consistent way
    of flagging extents which represent hole - ->block_start =
    EXTENT_MAP_HOLE. And also the only place where this flag is checked is
    in the fiemap code, but the block_start value is also checked and every
    other place in the filesystem detects holes by using block_start
    value's. So remove the extra flag. This survived a full xfstest run.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 64365bbc9b16..e9e285d45c7e 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -13,7 +13,6 @@
 /* bits for the flags field */
 #define EXTENT_FLAG_PINNED 0 /* this entry not yet on disk, don't free it */
 #define EXTENT_FLAG_COMPRESSED 1
-#define EXTENT_FLAG_VACANCY 2 /* no file extent item found */
 #define EXTENT_FLAG_PREALLOC 3 /* pre-allocated extent */
 #define EXTENT_FLAG_LOGGING 4 /* Logging this extent */
 #define EXTENT_FLAG_FILLING 5 /* Filling in a preallocated extent */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index a67b2def5413..64365bbc9b16 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __EXTENTMAP__
 #define __EXTENTMAP__
 

commit 490b54d6fb75f6ffd0471ec58bb38a992e2b40cd
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Fri Mar 3 10:55:12 2017 +0200

    btrfs: convert extent_map.refs from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index eb8b8fae036b..a67b2def5413 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -2,6 +2,7 @@
 #define __EXTENTMAP__
 
 #include <linux/rbtree.h>
+#include <linux/refcount.h>
 
 #define EXTENT_MAP_LAST_BYTE ((u64)-4)
 #define EXTENT_MAP_HOLE ((u64)-3)
@@ -41,7 +42,7 @@ struct extent_map {
 		 */
 		struct map_lookup *map_lookup;
 	};
-	atomic_t refs;
+	refcount_t refs;
 	unsigned int compress_type;
 	struct list_head list;
 };

commit 95617d69326ce386c95e33db7aeb832b45ee9f8f
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jun 3 10:55:48 2015 -0400

    btrfs: cleanup, stop casting for extent_map->lookup everywhere
    
    Overloading extent_map->bdev to struct map_lookup * might have started out
    as a means to an end, but it's a pattern that's used all over the place
    now. Let's get rid of the casting and just add a union instead.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index b2991fd8583e..eb8b8fae036b 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -32,7 +32,15 @@ struct extent_map {
 	u64 block_len;
 	u64 generation;
 	unsigned long flags;
-	struct block_device *bdev;
+	union {
+		struct block_device *bdev;
+
+		/*
+		 * used for chunk mappings
+		 * flags & EXTENT_FLAG_FS_MAPPING must be set
+		 */
+		struct map_lookup *map_lookup;
+	};
 	atomic_t refs;
 	unsigned int compress_type;
 	struct list_head list;

commit 298a8f9cf17d2f2e1ffc41e5e247fa3695a8a76f
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Thu Jun 19 10:42:52 2014 +0800

    Btrfs: fix NULL pointer crash when running balance and scrub concurrently
    
    While running balance, scrub, fsstress concurrently we hit the
    following kernel crash:
    
    [56561.448845] BTRFS info (device sde): relocating block group 11005853696 flags 132
    [56561.524077] BUG: unable to handle kernel NULL pointer dereference at 0000000000000078
    [56561.524237] IP: [<ffffffffa038956d>] scrub_chunk.isra.12+0xdd/0x130 [btrfs]
    [56561.524297] PGD 9be28067 PUD 7f3dd067 PMD 0
    [56561.524325] Oops: 0000 [#1] SMP
    [....]
    [56561.527237] Call Trace:
    [56561.527309]  [<ffffffffa038980e>] scrub_enumerate_chunks+0x24e/0x490 [btrfs]
    [56561.527392]  [<ffffffff810abe00>] ? abort_exclusive_wait+0x50/0xb0
    [56561.527476]  [<ffffffffa038add4>] btrfs_scrub_dev+0x1a4/0x530 [btrfs]
    [56561.527561]  [<ffffffffa0368107>] btrfs_ioctl+0x13f7/0x2a90 [btrfs]
    [56561.527639]  [<ffffffff811c82f0>] do_vfs_ioctl+0x2e0/0x4c0
    [56561.527712]  [<ffffffff8109c384>] ? vtime_account_user+0x54/0x60
    [56561.527788]  [<ffffffff810f768c>] ? __audit_syscall_entry+0x9c/0xf0
    [56561.527870]  [<ffffffff811c8551>] SyS_ioctl+0x81/0xa0
    [56561.527941]  [<ffffffff815707f7>] tracesys+0xdd/0xe2
    [...]
    [56561.528304] RIP  [<ffffffffa038956d>] scrub_chunk.isra.12+0xdd/0x130 [btrfs]
    [56561.528395]  RSP <ffff88004c0f5be8>
    [56561.528454] CR2: 0000000000000078
    
    This is because in btrfs_relocate_chunk(), we will free @bdev directly while
    scrub may still hold extent mapping, and may access freed memory.
    
    Fix this problem by wrapping freeing @bdev work into free_extent_map() which
    is based on reference count.
    
    Reported-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index e7fd8a56a140..b2991fd8583e 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -15,6 +15,7 @@
 #define EXTENT_FLAG_PREALLOC 3 /* pre-allocated extent */
 #define EXTENT_FLAG_LOGGING 4 /* Logging this extent */
 #define EXTENT_FLAG_FILLING 5 /* Filling in a preallocated extent */
+#define EXTENT_FLAG_FS_MAPPING 6 /* filesystem extent mapping type */
 
 struct extent_map {
 	struct rb_node rb_node;

commit 176840b3aa3cb795ddec4fc665ffbd707abff906
Author: Filipe Manana <fdmanana@gmail.com>
Date:   Tue Feb 25 14:15:13 2014 +0000

    Btrfs: more efficient btrfs_drop_extent_cache
    
    While droping extent map structures from the extent cache that cover our
    target range, we would remove each extent map structure from the red black
    tree and then add either 1 or 2 new extent map structures if the former
    extent map covered sections outside our target range.
    
    This change simply attempts to replace the existing extent map structure
    with a new one that covers the subsection we're not interested in, instead
    of doing a red black remove operation followed by an insertion operation.
    
    The number of elements in an inode's extent map tree can get very high for large
    files under random writes. For example, while running the following test:
    
        sysbench --test=fileio --file-num=1 --file-total-size=10G \
            --file-test-mode=rndrw --num-threads=32 --file-block-size=32768 \
            --max-requests=500000 --file-rw-ratio=2 [prepare|run]
    
    I captured the following histogram capturing the number of extent_map items
    in the red black tree while that test was running:
    
        Count: 122462
        Range:  1.000 - 172231.000; Mean: 96415.831; Median: 101855.000; Stddev: 49700.981
        Percentiles:  90th: 160120.000; 95th: 166335.000; 99th: 171070.000
           1.000 -    5.231:   452 |
           5.231 -  187.392:    87 |
         187.392 -  585.911:   206 |
         585.911 - 1827.438:   623 |
        1827.438 - 5695.245:  1962 #
        5695.245 - 17744.861:  6204 ####
       17744.861 - 55283.764: 21115 ############
       55283.764 - 172231.000: 91813 #####################################################
    
    Benchmark:
    
        sysbench --test=fileio --file-num=1 --file-total-size=10G --file-test-mode=rndwr \
            --num-threads=64 --file-block-size=32768 --max-requests=0 --max-time=60 \
            --file-io-mode=sync --file-fsync-freq=0 [prepare|run]
    
    Before this change: 122.1Mb/sec
    After this change:  125.07Mb/sec
    (averages of 5 test runs)
    
    Test machine: quad core intel i5-3570K, 32Gb of ram, SSD
    
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index f0a645a14d6e..e7fd8a56a140 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -68,6 +68,10 @@ struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,
 int add_extent_mapping(struct extent_map_tree *tree,
 		       struct extent_map *em, int modified);
 int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em);
+void replace_extent_mapping(struct extent_map_tree *tree,
+			    struct extent_map *cur,
+			    struct extent_map *new,
+			    int modified);
 
 struct extent_map *alloc_extent_map(void);
 void free_extent_map(struct extent_map *em);

commit cbc0e9287d710ce7dce5f8daf667729e83316c45
Author: Filipe Manana <fdmanana@gmail.com>
Date:   Tue Feb 25 14:15:12 2014 +0000

    Btrfs: remove unneeded field / smaller extent_map structure
    
    We don't need to have an unsigned int field in the extent_map struct
    to tell us whether the extent map is in the inode's extent_map tree or
    not. We can use the rb_node struct field and the RB_CLEAR_NODE and
    RB_EMPTY_NODE macros to achieve the same task.
    
    This reduces sizeof(struct extent_map) from 152 bytes to 144 bytes (on a
    64 bits system).
    
    Signed-off-by: Filipe David Borba Manana <fdmanana@gmail.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fb.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 93fba716d7f8..f0a645a14d6e 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -33,7 +33,6 @@ struct extent_map {
 	unsigned long flags;
 	struct block_device *bdev;
 	atomic_t refs;
-	unsigned int in_tree;
 	unsigned int compress_type;
 	struct list_head list;
 };
@@ -44,6 +43,11 @@ struct extent_map_tree {
 	rwlock_t lock;
 };
 
+static inline int extent_map_in_tree(const struct extent_map *em)
+{
+	return !RB_EMPTY_NODE(&em->rb_node);
+}
+
 static inline u64 extent_map_end(struct extent_map *em)
 {
 	if (em->start + em->len < em->start)

commit e248e04e7798d234ddbeab6ee6acdec2476fe1a8
Author: Dulshani Gunawardhana <dulshani.gunawardhana89@gmail.com>
Date:   Thu Oct 31 10:31:13 2013 +0530

    btrfs: Enclose macros with complex values within parenthesis
    
    Enclose macros with complex values within parenthesis in accordance to
    checkpatch.pl.
    
    Signed-off-by: Dulshani Gunawardhana <dulshani.gunawardhana89@gmail.com>
    Reviewed-by: Zach Brown <zab@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 61adc44b7805..93fba716d7f8 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -3,10 +3,10 @@
 
 #include <linux/rbtree.h>
 
-#define EXTENT_MAP_LAST_BYTE (u64)-4
-#define EXTENT_MAP_HOLE (u64)-3
-#define EXTENT_MAP_INLINE (u64)-2
-#define EXTENT_MAP_DELALLOC (u64)-1
+#define EXTENT_MAP_LAST_BYTE ((u64)-4)
+#define EXTENT_MAP_HOLE ((u64)-3)
+#define EXTENT_MAP_INLINE ((u64)-2)
+#define EXTENT_MAP_DELALLOC ((u64)-1)
 
 /* bits for the flags field */
 #define EXTENT_FLAG_PINNED 0 /* this entry not yet on disk, don't free it */

commit 09a2a8f96e3009273bed1833b3f210e2c68728a5
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Apr 5 16:51:15 2013 -0400

    Btrfs: fix bad extent logging
    
    A user sent me a btrfs-image of a file system that was panicing on mount during
    the log recovery.  I had originally thought these problems were from a bug in
    the free space cache code, but that was just a symptom of the problem.  The
    problem is if your application does something like this
    
    [prealloc][prealloc][prealloc]
    
    the internal extent maps will merge those all together into one extent map, even
    though on disk they are 3 separate extents.  So if you go to write into one of
    these ranges the extent map will be right since we use the physical extent when
    doing the write, but when we log the extents they will use the wrong sizes for
    the remainder prealloc space.  If this doesn't happen to trip up the free space
    cache (which it won't in a lot of cases) then you will get bogus entries in your
    extent tree which will screw stuff up later.  The data and such will still work,
    but everything else is broken.  This patch fixes this by not allowing extents
    that are on the modified list to be merged.  This has the side effect that we
    are no longer adding everything to the modified list all the time, which means
    we now have to call btrfs_drop_extents every time we log an extent into the
    tree.  So this allows me to drop all this speciality code I was using to get
    around calling btrfs_drop_extents.  With this patch the testcase I've created no
    longer creates a bogus file system after replaying the log.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index b18314bc5a6e..61adc44b7805 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -62,7 +62,7 @@ void extent_map_tree_init(struct extent_map_tree *tree);
 struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 len);
 int add_extent_mapping(struct extent_map_tree *tree,
-		       struct extent_map *em);
+		       struct extent_map *em, int modified);
 int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em);
 
 struct extent_map *alloc_extent_map(void);

commit cc95bef635a649d595cf8d1cd4fcff5b6bf13023
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Thu Apr 4 14:31:27 2013 -0400

    Btrfs: log ram bytes properly
    
    When logging changed extents I was logging ram_bytes as the current length,
    which isn't correct, it's supposed to be the ram bytes of the original extent.
    This is for compression where even if we split the extent we need to know the
    ram bytes so when we uncompress the extent we know how big it will be.  This was
    still working out right with compression for some reason but I think we were
    getting lucky.  It was definitely off for prealloc which is why I noticed it,
    btrfsck was complaining about it.  With this patch btrfsck no longer complains
    after a log replay.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index c6598c89cff8..b18314bc5a6e 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -26,6 +26,7 @@ struct extent_map {
 	u64 mod_len;
 	u64 orig_start;
 	u64 orig_block_len;
+	u64 ram_bytes;
 	u64 block_start;
 	u64 block_len;
 	u64 generation;

commit 201a90389424d6771d24fc5d72f7e34cb4a8f967
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Thu Jan 24 12:02:07 2013 -0500

    Btrfs: do not allow logged extents to be merged or removed
    
    We drop the extent map tree lock while we're logging extents, so somebody
    could come in and merge another extent into this one and screw up our
    logging, or they could even remove us from the list which would keep us from
    logging the extent or freeing our ref on it, so we need to make sure to not
    clear LOGGING until after the extent is logged, and then we can merge it to
    adjacent extents.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 922943ce29e8..c6598c89cff8 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -69,6 +69,7 @@ void free_extent_map(struct extent_map *em);
 int __init extent_map_init(void);
 void extent_map_exit(void);
 int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len, u64 gen);
+void clear_em_logging(struct extent_map_tree *tree, struct extent_map *em);
 struct extent_map *search_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 len);
 #endif

commit b11e234d21e73df94099e473a080bca502b9a496
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Mon Dec 3 10:58:15 2012 -0500

    Btrfs: do not mark ems as prealloc if we are writing to them
    
    We are going to use EM's to log extents in the future, so we need to not
    mark them as prealloc if they aren't actually prealloc extents.  Instead
    mark them with FILLING so we know to ammend mod_start/mod_len and that way
    we don't confuse the extent logging code.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 99a0dcb5ba2f..922943ce29e8 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -14,6 +14,7 @@
 #define EXTENT_FLAG_VACANCY 2 /* no file extent item found */
 #define EXTENT_FLAG_PREALLOC 3 /* pre-allocated extent */
 #define EXTENT_FLAG_LOGGING 4 /* Logging this extent */
+#define EXTENT_FLAG_FILLING 5 /* Filling in a preallocated extent */
 
 struct extent_map {
 	struct rb_node rb_node;

commit b493968096944a11422c4d80fb87af537ca1cac7
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Mon Dec 3 10:31:19 2012 -0500

    Btrfs: keep track of the extents original block length
    
    If we've written to a prealloc extent we need to know the original block len
    for the extent.  We can't figure this out currently since ->block_len is
    just set to the extent length.  So introduce ->orig_block_len so that we
    know how many bytes were in the original extent for proper extent logging
    that future patches will need.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 679225555f7b..99a0dcb5ba2f 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -24,6 +24,7 @@ struct extent_map {
 	u64 mod_start;
 	u64 mod_len;
 	u64 orig_start;
+	u64 orig_block_len;
 	u64 block_start;
 	u64 block_len;
 	u64 generation;

commit ff44c6e36dc9dcc02652a1105b120bdf08cea9f7
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Sep 14 12:59:20 2012 -0400

    Btrfs: do not hold the write_lock on the extent tree while logging
    
    Dave Sterba pointed out a sleeping while atomic bug while doing fsync.  This
    is because I'm an idiot and didn't realize that rwlock's were spin locks, so
    we've been holding this thing while doing allocations and such which is not
    good.  This patch fixes this by dropping the write lock before we do
    anything heavy and re-acquire it when it is done.  We also need to take a
    ref on the em's in case their corresponding pages are evicted and mark them
    as being logged so that releasepage does not remove them and doesn't remove
    them from our local list.  Thanks,
    
    Reported-by: Dave Sterba <dave@jikos.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 8e6294b51357..679225555f7b 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -13,6 +13,7 @@
 #define EXTENT_FLAG_COMPRESSED 1
 #define EXTENT_FLAG_VACANCY 2 /* no file extent item found */
 #define EXTENT_FLAG_PREALLOC 3 /* pre-allocated extent */
+#define EXTENT_FLAG_LOGGING 4 /* Logging this extent */
 
 struct extent_map {
 	struct rb_node rb_node;

commit 4e2f84e63dc138eca91e89ccbc34f37732ce58f7
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Mon Aug 27 10:52:20 2012 -0600

    Btrfs: improve fsync by filtering extents that we want
    
    This is based on Josef's "Btrfs: turbo charge fsync".
    
    The above Josef's patch performs very good in random sync write test,
    because we won't have too much extents to merge.
    
    However, it does not performs good on the test:
    dd if=/dev/zero of=foobar bs=4k count=12500 oflag=sync
    
    The reason is when we do sequencial sync write, we need to merge the
    current extent just with the previous one, so that we can get accumulated
    extents to log:
    
    A(4k) --> AA(8k) --> AAA(12k) --> AAAA(16k) ...
    
    So we'll have to flush more and more checksum into log tree, which is the
    bottleneck according to my tests.
    
    But we can avoid this by telling fsync the real extents that are needed
    to be logged.
    
    With this, I did the above dd sync write test (size=50m),
    
             w/o (orig)   w/ (josef's)   w/ (this)
    SATA      104KB/s       109KB/s       121KB/s
    ramdisk   1.5MB/s       1.5MB/s       10.7MB/s (613%)
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 2388a60bd6e3..8e6294b51357 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -20,6 +20,8 @@ struct extent_map {
 	/* all of these are in bytes */
 	u64 start;
 	u64 len;
+	u64 mod_start;
+	u64 mod_len;
 	u64 orig_start;
 	u64 block_start;
 	u64 block_len;

commit 5dc562c541e1026df9d43913c2f6b91156e22d32
Author: Josef Bacik <jbacik@fusionio.com>
Date:   Fri Aug 17 13:14:17 2012 -0400

    Btrfs: turbo charge fsync
    
    At least for the vm workload.  Currently on fsync we will
    
    1) Truncate all items in the log tree for the given inode if they exist
    
    and
    
    2) Copy all items for a given inode into the log
    
    The problem with this is that for things like VMs you can have lots of
    extents from the fragmented writing behavior, and worst yet you may have
    only modified a few extents, not the entire thing.  This patch fixes this
    problem by tracking which transid modified our extent, and then when we do
    the tree logging we find all of the extents we've modified in our current
    transaction, sort them and commit them.  We also only truncate up to the
    xattrs of the inode and copy that stuff in normally, and then just drop any
    extents in the range we have that exist in the log already.  Here are some
    numbers of a 50 meg fio job that does random writes and fsync()s after every
    write
    
                    Original        Patched
    SATA drive      82KB/s          140KB/s
    Fusion drive    431KB/s         2532KB/s
    
    So around 2-6 times faster depending on your hardware.  There are a few
    corner cases, for example if you truncate at all we have to do it the old
    way since there is no way to be sure what is in the log is ok.  This
    probably could be done smarter, but if you write-fsync-truncate-write-fsync
    you deserve what you get.  All this work is in RAM of course so if your
    inode gets evicted from cache and you read it in and fsync it we'll do it
    the slow way if we are still in the same transaction that we last modified
    the inode in.
    
    The biggest cool part of this is that it requires no changes to the recovery
    code, so if you fsync with this patch and crash and load an old kernel, it
    will run the recovery and be a-ok.  I have tested this pretty thoroughly
    with an fsync tester and everything comes back fine, as well as xfstests.
    Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 1195f09761fe..2388a60bd6e3 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -23,15 +23,18 @@ struct extent_map {
 	u64 orig_start;
 	u64 block_start;
 	u64 block_len;
+	u64 generation;
 	unsigned long flags;
 	struct block_device *bdev;
 	atomic_t refs;
 	unsigned int in_tree;
 	unsigned int compress_type;
+	struct list_head list;
 };
 
 struct extent_map_tree {
 	struct rb_root map;
+	struct list_head modified_extents;
 	rwlock_t lock;
 };
 
@@ -60,7 +63,7 @@ struct extent_map *alloc_extent_map(void);
 void free_extent_map(struct extent_map *em);
 int __init extent_map_init(void);
 void extent_map_exit(void);
-int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len);
+int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len, u64 gen);
 struct extent_map *search_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 len);
 #endif

commit c08782dacd7a098f2b8bca7f4a57a5b402e9e1e5
Author: David Sterba <dsterba@suse.cz>
Date:   Thu Jan 26 15:01:12 2012 -0500

    btrfs: fix structs where bitfields and spinlock/atomic share 8B word
    
    On ia64, powerpc64 and sparc64 the bitfield is modified through a RMW cycle and current
    gcc rewrites the adjacent 4B word, which in case of a spinlock or atomic has
    disaterous effect.
    
    https://lkml.org/lkml/2012/2/1/220
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 33a7890b1f40..1195f09761fe 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -26,8 +26,8 @@ struct extent_map {
 	unsigned long flags;
 	struct block_device *bdev;
 	atomic_t refs;
-	unsigned int in_tree:1;
-	unsigned int compress_type:4;
+	unsigned int in_tree;
+	unsigned int compress_type;
 };
 
 struct extent_map_tree {

commit 172ddd60a662c4d8bf2809462866ddddd6431ea5
Author: David Sterba <dsterba@suse.cz>
Date:   Thu Apr 21 00:48:27 2011 +0200

    btrfs: drop gfp parameter from alloc_extent_map
    
    pass GFP_NOFS directly to kmem_cache_alloc
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 255813c51b9d..33a7890b1f40 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -56,7 +56,7 @@ int add_extent_mapping(struct extent_map_tree *tree,
 		       struct extent_map *em);
 int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em);
 
-struct extent_map *alloc_extent_map(gfp_t mask);
+struct extent_map *alloc_extent_map(void);
 void free_extent_map(struct extent_map *em);
 int __init extent_map_init(void);
 void extent_map_exit(void);

commit a8067e022ab54fde8953880a64572c3acca644dc
Author: David Sterba <dsterba@suse.cz>
Date:   Thu Apr 21 00:34:43 2011 +0200

    btrfs: drop unused parameter from extent_map_tree_init
    
    the GFP flags are not stored anywhere and all allocations are done via
    alloc_extent_map(GFP_NOFS).
    
    Signed-off-by: David Sterba <dsterba@suse.cz>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 28b44dbd1e35..255813c51b9d 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -49,7 +49,7 @@ static inline u64 extent_map_block_end(struct extent_map *em)
 	return em->block_start + em->block_len;
 }
 
-void extent_map_tree_init(struct extent_map_tree *tree, gfp_t mask);
+void extent_map_tree_init(struct extent_map_tree *tree);
 struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 len);
 int add_extent_mapping(struct extent_map_tree *tree,

commit 261507a02ccba9afda919852263b6bc1581ce1ef
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri Dec 17 14:21:50 2010 +0800

    btrfs: Allow to add new compression algorithm
    
    Make the code aware of compression type, instead of always assuming
    zlib compression.
    
    Also make the zlib workspace function as common code for all
    compression types.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index ab6d74b6e647..28b44dbd1e35 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -26,7 +26,8 @@ struct extent_map {
 	unsigned long flags;
 	struct block_device *bdev;
 	atomic_t refs;
-	int in_tree;
+	unsigned int in_tree:1;
+	unsigned int compress_type:4;
 };
 
 struct extent_map_tree {

commit b917b7c3be50435fa8257591b964934e917f2d45
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Sep 18 16:07:03 2009 -0400

    Btrfs: search for an allocation hint while filling file COW
    
    The allocator has some nice knobs for sending hints about where
    to try and allocate new blocks, but when we're doing file allocations
    we're not sending any hint at all.
    
    This commit adds a simple extent map search to see if we can
    quickly and easily find a hint for the allocator.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index d3d442f4bbbd..ab6d74b6e647 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -60,4 +60,6 @@ void free_extent_map(struct extent_map *em);
 int __init extent_map_init(void);
 void extent_map_exit(void);
 int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len);
+struct extent_map *search_extent_mapping(struct extent_map_tree *tree,
+					 u64 start, u64 len);
 #endif

commit a1ed835e1ab5795f91b198d08c43e2f56848dcf3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Sep 11 12:27:37 2009 -0400

    Btrfs: Fix extent replacment race
    
    Data COW means that whenever we write to a file, we replace any old
    extent pointers with new ones.  There was a window where a readpage
    might find the old extent pointers on disk and cache them in the
    extent_map tree in ram in the middle of a given write replacing them.
    
    Even though both the readpage and the write had their respective bytes
    in the file locked, the extent readpage inserts may cover more bytes than
    it had locked down.
    
    This commit closes the race by keeping the new extent pinned in the extent
    map tree until after the on-disk btree is properly setup with the new
    extent pointers.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 6216dfbcf9be..d3d442f4bbbd 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -59,4 +59,5 @@ struct extent_map *alloc_extent_map(gfp_t mask);
 void free_extent_map(struct extent_map *em);
 int __init extent_map_init(void);
 void extent_map_exit(void);
+int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len);
 #endif

commit 890871be854b5f5e43e7ba2475f706209906cc24
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Sep 2 16:24:52 2009 -0400

    Btrfs: switch extent_map to a rw lock
    
    There are two main users of the extent_map tree.  The
    first is regular file inodes, where it is evenly spread
    between readers and writers.
    
    The second is the chunk allocation tree, which maps blocks from
    logical addresses to phyiscal ones, and it is 99.99% reads.
    
    The mapping tree is a point of lock contention during heavy IO
    workloads, so this commit switches things to a rw lock.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index fb6eeef06bb0..6216dfbcf9be 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -31,7 +31,7 @@ struct extent_map {
 
 struct extent_map_tree {
 	struct rb_root map;
-	spinlock_t lock;
+	rwlock_t lock;
 };
 
 static inline u64 extent_map_end(struct extent_map *em)

commit ff5b7ee33d82414bf4baf299c21fb703bcc89629
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Mon Nov 10 07:34:43 2008 -0500

    Btrfs: Fix csum error for compressed data
    
    The decompress code doesn't take the logical offset in extent
    pointer into account. If the logical offset isn't zero, data
    will be decompressed into wrong pages.
    
    The solution used here is to record the starting offset of the extent
    in the file separately from the logical start of the extent_map struct.
    This allows us to avoid problems inserting overlapping extents.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index accfedaeb513..fb6eeef06bb0 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -20,6 +20,7 @@ struct extent_map {
 	/* all of these are in bytes */
 	u64 start;
 	u64 len;
+	u64 orig_start;
 	u64 block_start;
 	u64 block_len;
 	unsigned long flags;

commit d899e05215178fed903ad0e7fc1cb4d8e0cc0a88
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Thu Oct 30 14:25:28 2008 -0400

    Btrfs: Add fallocate support v2
    This patch updates btrfs-progs for fallocate support.
    
    fallocate is a little different in Btrfs because we need to tell the
    COW system that a given preallocated extent doesn't need to be
    cow'd as long as there are no snapshots of it.  This leverages the
    -o nodatacow checks.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index e693e1b4ac4a..accfedaeb513 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -12,6 +12,7 @@
 #define EXTENT_FLAG_PINNED 0 /* this entry not yet on disk, don't free it */
 #define EXTENT_FLAG_COMPRESSED 1
 #define EXTENT_FLAG_VACANCY 2 /* no file extent item found */
+#define EXTENT_FLAG_PREALLOC 3 /* pre-allocated extent */
 
 struct extent_map {
 	struct rb_node rb_node;

commit 9036c10208e1fc496cef7692ba66a78699b360dc
Author: Yan Zheng <zheng.yan@oracle.com>
Date:   Thu Oct 30 14:19:41 2008 -0400

    Btrfs: update hole handling v2
    
    This patch splits the hole insertion code out of btrfs_setattr
    into btrfs_cont_expand and updates btrfs_get_extent to properly
    handle the case that file extent items are not continuous.
    
    Signed-off-by: Yan Zheng <zheng.yan@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index abbcbeb28c79..e693e1b4ac4a 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -11,6 +11,7 @@
 /* bits for the flags field */
 #define EXTENT_FLAG_PINNED 0 /* this entry not yet on disk, don't free it */
 #define EXTENT_FLAG_COMPRESSED 1
+#define EXTENT_FLAG_VACANCY 2 /* no file extent item found */
 
 struct extent_map {
 	struct rb_node rb_node;

commit c8b978188c9a0fd3d535c13debd19d522b726f1f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Wed Oct 29 14:49:59 2008 -0400

    Btrfs: Add zlib compression support
    
    This is a large change for adding compression on reading and writing,
    both for inline and regular extents.  It does some fairly large
    surgery to the writeback paths.
    
    Compression is off by default and enabled by mount -o compress.  Even
    when the -o compress mount option is not used, it is possible to read
    compressed extents off the disk.
    
    If compression for a given set of pages fails to make them smaller, the
    file is flagged to avoid future compression attempts later.
    
    * While finding delalloc extents, the pages are locked before being sent down
    to the delalloc handler.  This allows the delalloc handler to do complex things
    such as cleaning the pages, marking them writeback and starting IO on their
    behalf.
    
    * Inline extents are inserted at delalloc time now.  This allows us to compress
    the data before inserting the inline extent, and it allows us to insert
    an inline extent that spans multiple pages.
    
    * All of the in-memory extent representations (extent_map.c, ordered-data.c etc)
    are changed to record both an in-memory size and an on disk size, as well
    as a flag for compression.
    
    From a disk format point of view, the extent pointers in the file are changed
    to record the on disk size of a given extent and some encoding flags.
    Space in the disk format is allocated for compression encoding, as well
    as encryption and a generic 'other' field.  Neither the encryption or the
    'other' field are currently used.
    
    In order to limit the amount of data read for a single random read in the
    file, the size of a compressed extent is limited to 128k.  This is a
    software only limit, the disk format supports u64 sized compressed extents.
    
    In order to limit the ram consumed while processing extents, the uncompressed
    size of a compressed extent is limited to 256k.  This is a software only limit
    and will be subject to tuning later.
    
    Checksumming is still done on compressed extents, and it is done on the
    uncompressed version of the data.  This way additional encodings can be
    layered on without having to figure out which encoding to checksum.
    
    Compression happens at delalloc time, which is basically singled threaded because
    it is usually done by a single pdflush thread.  This makes it tricky to
    spread the compression load across all the cpus on the box.  We'll have to
    look at parallel pdflush walks of dirty inodes at a later time.
    
    Decompression is hooked into readpages and it does spread across CPUs nicely.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 26ac6fe0b268..abbcbeb28c79 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -10,6 +10,7 @@
 
 /* bits for the flags field */
 #define EXTENT_FLAG_PINNED 0 /* this entry not yet on disk, don't free it */
+#define EXTENT_FLAG_COMPRESSED 1
 
 struct extent_map {
 	struct rb_node rb_node;
@@ -18,6 +19,7 @@ struct extent_map {
 	u64 start;
 	u64 len;
 	u64 block_start;
+	u64 block_len;
 	unsigned long flags;
 	struct block_device *bdev;
 	atomic_t refs;
@@ -38,9 +40,9 @@ static inline u64 extent_map_end(struct extent_map *em)
 
 static inline u64 extent_map_block_end(struct extent_map *em)
 {
-	if (em->block_start + em->len < em->block_start)
+	if (em->block_start + em->block_len < em->block_start)
 		return (u64)-1;
-	return em->block_start + em->len;
+	return em->block_start + em->block_len;
 }
 
 void extent_map_tree_init(struct extent_map_tree *tree, gfp_t mask);

commit f421950f86bf96a11fef932e167ab2e70d4c43a0
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Jul 22 11:18:09 2008 -0400

    Btrfs: Fix some data=ordered related data corruptions
    
    Stress testing was showing data checksum errors, most of which were caused
    by a lookup bug in the extent_map tree.  The tree was caching the last
    pointer returned, and searches would check the last pointer first.
    
    But, search callers also expect the search to return the very first
    matching extent in the range, which wasn't always true with the last
    pointer usage.
    
    For now, the code to cache the last return value is just removed.  It is
    easy to fix, but I think lookups are rare enough that it isn't required anymore.
    
    This commit also replaces do_sync_mapping_range with a local copy of the
    related functions.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index a3978ec27846..26ac6fe0b268 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -26,7 +26,6 @@ struct extent_map {
 
 struct extent_map_tree {
 	struct rb_root map;
-	struct extent_map *last;
 	spinlock_t lock;
 };
 

commit 7f3c74fb831fa19bafe087e817c0a5ff3883f1ea
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Jul 18 12:01:11 2008 -0400

    Btrfs: Keep extent mappings in ram until pending ordered extents are done
    
    It was possible for stale mappings from disk to be used instead of the
    new pending ordered extent.  This adds a flag to the extent map struct
    to keep it pinned until the pending ordered extent is actually on disk.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 56314217cfc0..a3978ec27846 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -8,6 +8,9 @@
 #define EXTENT_MAP_INLINE (u64)-2
 #define EXTENT_MAP_DELALLOC (u64)-1
 
+/* bits for the flags field */
+#define EXTENT_FLAG_PINNED 0 /* this entry not yet on disk, don't free it */
+
 struct extent_map {
 	struct rb_node rb_node;
 

commit d1310b2e0cd98eb1348553e69b73827b436dca7b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Jan 24 16:13:08 2008 -0500

    Btrfs: Split the extent_map code into two parts
    
    There is now extent_map for mapping offsets in the file to disk and
    extent_io for state tracking, IO submission and extent_bufers.
    
    The new extent_map code shifts from [start,end] pairs to [start,len], and
    pushes the locking out into the caller.  This allows a few performance
    optimizations and is easier to use.
    
    A number of extent_map usage bugs were fixed, mostly with failing
    to remove extent_map entries when changing the file.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index ea60f5447b5b..56314217cfc0 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -3,215 +3,53 @@
 
 #include <linux/rbtree.h>
 
+#define EXTENT_MAP_LAST_BYTE (u64)-4
 #define EXTENT_MAP_HOLE (u64)-3
 #define EXTENT_MAP_INLINE (u64)-2
 #define EXTENT_MAP_DELALLOC (u64)-1
 
-/* bits for the extent state */
-#define EXTENT_DIRTY 1
-#define EXTENT_WRITEBACK (1 << 1)
-#define EXTENT_UPTODATE (1 << 2)
-#define EXTENT_LOCKED (1 << 3)
-#define EXTENT_NEW (1 << 4)
-#define EXTENT_DELALLOC (1 << 5)
-#define EXTENT_DEFRAG (1 << 6)
-#define EXTENT_DEFRAG_DONE (1 << 7)
-#define EXTENT_BUFFER_FILLED (1 << 8)
-#define EXTENT_CSUM (1 << 9)
-#define EXTENT_IOBITS (EXTENT_LOCKED | EXTENT_WRITEBACK)
-
-/*
- * page->private values.  Every page that is controlled by the extent
- * map has page->private set to one.
- */
-#define EXTENT_PAGE_PRIVATE 1
-#define EXTENT_PAGE_PRIVATE_FIRST_PAGE 3
-
-
-struct extent_map_ops {
-	int (*fill_delalloc)(struct inode *inode, u64 start, u64 end);
-	int (*writepage_io_hook)(struct page *page, u64 start, u64 end);
-	int (*readpage_io_hook)(struct page *page, u64 start, u64 end);
-	int (*readpage_end_io_hook)(struct page *page, u64 start, u64 end);
-	void (*writepage_end_io_hook)(struct page *page, u64 start, u64 end);
-};
-
-struct extent_map_tree {
-	struct rb_root map;
-	struct rb_root state;
-	struct address_space *mapping;
-	u64 dirty_bytes;
-	rwlock_t lock;
-	struct extent_map_ops *ops;
-	spinlock_t lru_lock;
-	struct list_head buffer_lru;
-	int lru_size;
-};
-
-/* note, this must start with the same fields as fs/extent_map.c:tree_entry */
 struct extent_map {
-	u64 start;
-	u64 end; /* inclusive */
-	int in_tree;
 	struct rb_node rb_node;
-	/* block_start and block_end are in bytes */
+
+	/* all of these are in bytes */
+	u64 start;
+	u64 len;
 	u64 block_start;
-	u64 block_end; /* inclusive */
+	unsigned long flags;
 	struct block_device *bdev;
 	atomic_t refs;
-};
-
-/* note, this must start with the same fields as fs/extent_map.c:tree_entry */
-struct extent_state {
-	u64 start;
-	u64 end; /* inclusive */
 	int in_tree;
-	struct rb_node rb_node;
-	wait_queue_head_t wq;
-	atomic_t refs;
-	unsigned long state;
-
-	/* for use by the FS */
-	u64 private;
-
-	struct list_head list;
 };
 
-struct extent_buffer {
-	u64 start;
-	unsigned long len;
-	char *map_token;
-	char *kaddr;
-	unsigned long map_start;
-	unsigned long map_len;
-	struct page *first_page;
-	struct list_head lru;
-	atomic_t refs;
-	int flags;
+struct extent_map_tree {
+	struct rb_root map;
+	struct extent_map *last;
+	spinlock_t lock;
 };
 
-typedef struct extent_map *(get_extent_t)(struct inode *inode,
-					  struct page *page,
-					  size_t page_offset,
-					  u64 start, u64 end,
-					  int create);
+static inline u64 extent_map_end(struct extent_map *em)
+{
+	if (em->start + em->len < em->start)
+		return (u64)-1;
+	return em->start + em->len;
+}
+
+static inline u64 extent_map_block_end(struct extent_map *em)
+{
+	if (em->block_start + em->len < em->block_start)
+		return (u64)-1;
+	return em->block_start + em->len;
+}
 
-void extent_map_tree_init(struct extent_map_tree *tree,
-			  struct address_space *mapping, gfp_t mask);
-void extent_map_tree_empty_lru(struct extent_map_tree *tree);
+void extent_map_tree_init(struct extent_map_tree *tree, gfp_t mask);
 struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,
-					 u64 start, u64 end);
+					 u64 start, u64 len);
 int add_extent_mapping(struct extent_map_tree *tree,
 		       struct extent_map *em);
 int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em);
-int try_release_extent_mapping(struct extent_map_tree *tree, struct page *page);
-int lock_extent(struct extent_map_tree *tree, u64 start, u64 end, gfp_t mask);
-int unlock_extent(struct extent_map_tree *tree, u64 start, u64 end, gfp_t mask);
+
 struct extent_map *alloc_extent_map(gfp_t mask);
 void free_extent_map(struct extent_map *em);
-int extent_read_full_page(struct extent_map_tree *tree, struct page *page,
-			  get_extent_t *get_extent);
 int __init extent_map_init(void);
 void extent_map_exit(void);
-
-u64 count_range_bits(struct extent_map_tree *tree,
-		     u64 *start, u64 search_end,
-		     u64 max_bytes, unsigned long bits);
-
-int test_range_bit(struct extent_map_tree *tree, u64 start, u64 end,
-		   int bits, int filled);
-int clear_extent_bits(struct extent_map_tree *tree, u64 start, u64 end,
-		      int bits, gfp_t mask);
-int set_extent_bits(struct extent_map_tree *tree, u64 start, u64 end,
-		    int bits, gfp_t mask);
-int set_extent_uptodate(struct extent_map_tree *tree, u64 start, u64 end,
-			gfp_t mask);
-int set_extent_new(struct extent_map_tree *tree, u64 start, u64 end,
-		   gfp_t mask);
-int set_extent_dirty(struct extent_map_tree *tree, u64 start, u64 end,
-		     gfp_t mask);
-int clear_extent_dirty(struct extent_map_tree *tree, u64 start, u64 end,
-		       gfp_t mask);
-int set_extent_delalloc(struct extent_map_tree *tree, u64 start, u64 end,
-		     gfp_t mask);
-int find_first_extent_bit(struct extent_map_tree *tree, u64 start,
-			  u64 *start_ret, u64 *end_ret, int bits);
-int extent_invalidatepage(struct extent_map_tree *tree,
-			  struct page *page, unsigned long offset);
-int extent_write_full_page(struct extent_map_tree *tree, struct page *page,
-			  get_extent_t *get_extent,
-			  struct writeback_control *wbc);
-int extent_writepages(struct extent_map_tree *tree,
-		      struct address_space *mapping,
-		      get_extent_t *get_extent,
-		      struct writeback_control *wbc);
-int extent_readpages(struct extent_map_tree *tree,
-		     struct address_space *mapping,
-		     struct list_head *pages, unsigned nr_pages,
-		     get_extent_t get_extent);
-int extent_prepare_write(struct extent_map_tree *tree,
-			 struct inode *inode, struct page *page,
-			 unsigned from, unsigned to, get_extent_t *get_extent);
-int extent_commit_write(struct extent_map_tree *tree,
-			struct inode *inode, struct page *page,
-			unsigned from, unsigned to);
-sector_t extent_bmap(struct address_space *mapping, sector_t iblock,
-		get_extent_t *get_extent);
-int set_range_dirty(struct extent_map_tree *tree, u64 start, u64 end);
-int set_state_private(struct extent_map_tree *tree, u64 start, u64 private);
-int get_state_private(struct extent_map_tree *tree, u64 start, u64 *private);
-void set_page_extent_mapped(struct page *page);
-
-struct extent_buffer *alloc_extent_buffer(struct extent_map_tree *tree,
-					  u64 start, unsigned long len,
-					  struct page *page0,
-					  gfp_t mask);
-struct extent_buffer *find_extent_buffer(struct extent_map_tree *tree,
-					 u64 start, unsigned long len,
-					  gfp_t mask);
-void free_extent_buffer(struct extent_buffer *eb);
-int read_extent_buffer_pages(struct extent_map_tree *tree,
-			     struct extent_buffer *eb, u64 start, int wait);
-
-static inline void extent_buffer_get(struct extent_buffer *eb)
-{
-	atomic_inc(&eb->refs);
-}
-
-int memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,
-			  unsigned long start,
-			  unsigned long len);
-void read_extent_buffer(struct extent_buffer *eb, void *dst,
-			unsigned long start,
-			unsigned long len);
-void write_extent_buffer(struct extent_buffer *eb, const void *src,
-			 unsigned long start, unsigned long len);
-void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,
-			unsigned long dst_offset, unsigned long src_offset,
-			unsigned long len);
-void memcpy_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,
-			   unsigned long src_offset, unsigned long len);
-void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,
-			   unsigned long src_offset, unsigned long len);
-void memset_extent_buffer(struct extent_buffer *eb, char c,
-			  unsigned long start, unsigned long len);
-int wait_on_extent_buffer_writeback(struct extent_map_tree *tree,
-				    struct extent_buffer *eb);
-int clear_extent_buffer_dirty(struct extent_map_tree *tree,
-			      struct extent_buffer *eb);
-int set_extent_buffer_dirty(struct extent_map_tree *tree,
-			     struct extent_buffer *eb);
-int set_extent_buffer_uptodate(struct extent_map_tree *tree,
-			       struct extent_buffer *eb);
-int extent_buffer_uptodate(struct extent_map_tree *tree,
-			   struct extent_buffer *eb);
-int map_extent_buffer(struct extent_buffer *eb, unsigned long offset,
-		      unsigned long min_len, char **token, char **map,
-		      unsigned long *map_start,
-		      unsigned long *map_len, int km);
-int map_private_extent_buffer(struct extent_buffer *eb, unsigned long offset,
-		      unsigned long min_len, char **token, char **map,
-		      unsigned long *map_start,
-		      unsigned long *map_len, int km);
-void unmap_extent_buffer(struct extent_buffer *eb, char *token, int km);
 #endif

commit 1832a6d5ee3b1af61001cadba9e10da9e91af4a4
Author: Chris Mason <chris.mason@oracle.com>
Date:   Fri Dec 21 16:27:21 2007 -0500

    Btrfs: Implement basic support for -ENOSPC
    
    This is intended to prevent accidentally filling the drive.  A determined
    user can still make things oops.
    
    It includes some accounting of the current bytes under delayed allocation,
    but this will change as things get optimized
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 6e572d3e8924..ea60f5447b5b 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -115,7 +115,8 @@ int __init extent_map_init(void);
 void extent_map_exit(void);
 
 u64 count_range_bits(struct extent_map_tree *tree,
-		     u64 *start, u64 max_bytes, unsigned long bits);
+		     u64 *start, u64 search_end,
+		     u64 max_bytes, unsigned long bits);
 
 int test_range_bit(struct extent_map_tree *tree, u64 start, u64 end,
 		   int bits, int filled);

commit 17636e03f42a1a42fed3834859de4702bd655fd1
Author: Christian Hesse <list@eworm.de>
Date:   Tue Dec 11 09:25:06 2007 -0500

    Btrfs: section mismatch warnings
    
    --Boundary-00=_CcOWHFYK4T+JwSj
    Content-Type: text/plain;
      charset="iso-8859-1"
    Content-Transfer-Encoding: 7bit
    Content-Disposition: inline
    
    Hello everybody,
    
    compiling btrfs into the kernel results in section mismatch warnings. __exit
    functions are called where they are not allowed to. The attached patch fixes
    this for me. Not sure if it is correct though.
    
    Signed-off-by: Christian Hesse <mail@earthworm.de>
    --
    Regards,
    Chris
    
    --Boundary-00=_CcOWHFYK4T+JwSj
    Content-Type: text/x-diff; charset="iso-8859-1";
            name="btrfs-section_mismatches.patch"
    Content-Transfer-Encoding: 7bit
    Content-Disposition: attachment;
            filename="btrfs-section_mismatches.patch"
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 2ffc0c76338c..6e572d3e8924 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -112,7 +112,7 @@ void free_extent_map(struct extent_map *em);
 int extent_read_full_page(struct extent_map_tree *tree, struct page *page,
 			  get_extent_t *get_extent);
 int __init extent_map_init(void);
-void __exit extent_map_exit(void);
+void extent_map_exit(void);
 
 u64 count_range_bits(struct extent_map_tree *tree,
 		     u64 *start, u64 max_bytes, unsigned long bits);

commit ca6646264b7dab662d84435441164bb2a8e8885a
Author: Chris Mason <chris.mason@oracle.com>
Date:   Tue Nov 27 11:16:35 2007 -0500

    Btrfs: Add efficient dirty accounting to the extent_map tree
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 13c562f7cb6f..2ffc0c76338c 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -40,6 +40,7 @@ struct extent_map_tree {
 	struct rb_root map;
 	struct rb_root state;
 	struct address_space *mapping;
+	u64 dirty_bytes;
 	rwlock_t lock;
 	struct extent_map_ops *ops;
 	spinlock_t lru_lock;

commit 793955bca66c99defdffc857ae6eb7e8431d6bbe
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Nov 26 16:34:41 2007 -0800

    Btrfs: Limit btree writeback to prevent seeks
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 24ddc8c93461..13c562f7cb6f 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -113,6 +113,9 @@ int extent_read_full_page(struct extent_map_tree *tree, struct page *page,
 int __init extent_map_init(void);
 void __exit extent_map_exit(void);
 
+u64 count_range_bits(struct extent_map_tree *tree,
+		     u64 *start, u64 max_bytes, unsigned long bits);
+
 int test_range_bit(struct extent_map_tree *tree, u64 start, u64 end,
 		   int bits, int filled);
 int clear_extent_bits(struct extent_map_tree *tree, u64 start, u64 end,

commit 2f4cbe6442d3be7b5e4cf1607a5ab33995fe2d25
Author: Wyatt Banks <wyatt@banksresearch.com>
Date:   Mon Nov 19 10:22:33 2007 -0500

    Btrfs: Return value checking in module init
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index fbd23a72f53b..24ddc8c93461 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -110,7 +110,7 @@ struct extent_map *alloc_extent_map(gfp_t mask);
 void free_extent_map(struct extent_map *em);
 int extent_read_full_page(struct extent_map_tree *tree, struct page *page,
 			  get_extent_t *get_extent);
-void __init extent_map_init(void);
+int __init extent_map_init(void);
 void __exit extent_map_exit(void);
 
 int test_range_bit(struct extent_map_tree *tree, u64 start, u64 end,

commit 3ab2fb5a8cb003897016b6eb38ddad916226c1b2
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Nov 8 10:59:22 2007 -0500

    Btrfs: Add readpages support
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 0b0dcf19fe45..fbd23a72f53b 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -140,6 +140,10 @@ int extent_writepages(struct extent_map_tree *tree,
 		      struct address_space *mapping,
 		      get_extent_t *get_extent,
 		      struct writeback_control *wbc);
+int extent_readpages(struct extent_map_tree *tree,
+		     struct address_space *mapping,
+		     struct list_head *pages, unsigned nr_pages,
+		     get_extent_t get_extent);
 int extent_prepare_write(struct extent_map_tree *tree,
 			 struct inode *inode, struct page *page,
 			 unsigned from, unsigned to, get_extent_t *get_extent);

commit b293f02e1423f2099744f3ade23ddd83b65321fc
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Nov 1 19:45:34 2007 -0400

    Btrfs: Add writepages support
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index b6f6519f9ba3..0b0dcf19fe45 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -136,6 +136,10 @@ int extent_invalidatepage(struct extent_map_tree *tree,
 int extent_write_full_page(struct extent_map_tree *tree, struct page *page,
 			  get_extent_t *get_extent,
 			  struct writeback_control *wbc);
+int extent_writepages(struct extent_map_tree *tree,
+		      struct address_space *mapping,
+		      get_extent_t *get_extent,
+		      struct writeback_control *wbc);
 int extent_prepare_write(struct extent_map_tree *tree,
 			 struct inode *inode, struct page *page,
 			 unsigned from, unsigned to, get_extent_t *get_extent);

commit 179e29e488cc74f1e9bd67bc45f70b832740e9ec
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Nov 1 11:28:41 2007 -0400

    Btrfs: Fix a number of inline extent problems that Yan Zheng reported.
    
    The fixes do a number of things:
    
    1) Most btrfs_drop_extent callers will try to leave the inline extents in
    place.  It can truncate bytes off the beginning of the inline extent if
    required.
    
    2) writepage can now update the inline extent, allowing mmap writes to
    go directly into the inline extent.
    
    3) btrfs_truncate_in_transaction truncates inline extents
    
    4) extent_map.c fixed to not merge inline extent mappings and hole
    mappings together
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 39d78d31b6a2..b6f6519f9ba3 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -24,7 +24,6 @@
  * page->private values.  Every page that is controlled by the extent
  * map has page->private set to one.
  */
-
 #define EXTENT_PAGE_PRIVATE 1
 #define EXTENT_PAGE_PRIVATE_FIRST_PAGE 3
 

commit 19c00ddcc31ad4bdfb86b57085e06d6135b9b1d7
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:19:22 2007 -0400

    Btrfs: Add back metadata checksumming
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index f1dc28d260eb..39d78d31b6a2 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -17,8 +17,17 @@
 #define EXTENT_DEFRAG (1 << 6)
 #define EXTENT_DEFRAG_DONE (1 << 7)
 #define EXTENT_BUFFER_FILLED (1 << 8)
+#define EXTENT_CSUM (1 << 9)
 #define EXTENT_IOBITS (EXTENT_LOCKED | EXTENT_WRITEBACK)
 
+/*
+ * page->private values.  Every page that is controlled by the extent
+ * map has page->private set to one.
+ */
+
+#define EXTENT_PAGE_PRIVATE 1
+#define EXTENT_PAGE_PRIVATE_FIRST_PAGE 3
+
 
 struct extent_map_ops {
 	int (*fill_delalloc)(struct inode *inode, u64 start, u64 end);
@@ -89,7 +98,7 @@ typedef struct extent_map *(get_extent_t)(struct inode *inode,
 
 void extent_map_tree_init(struct extent_map_tree *tree,
 			  struct address_space *mapping, gfp_t mask);
-void extent_map_tree_cleanup(struct extent_map_tree *tree);
+void extent_map_tree_empty_lru(struct extent_map_tree *tree);
 struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 end);
 int add_extent_mapping(struct extent_map_tree *tree,
@@ -143,13 +152,14 @@ void set_page_extent_mapped(struct page *page);
 
 struct extent_buffer *alloc_extent_buffer(struct extent_map_tree *tree,
 					  u64 start, unsigned long len,
+					  struct page *page0,
 					  gfp_t mask);
 struct extent_buffer *find_extent_buffer(struct extent_map_tree *tree,
 					 u64 start, unsigned long len,
 					  gfp_t mask);
 void free_extent_buffer(struct extent_buffer *eb);
 int read_extent_buffer_pages(struct extent_map_tree *tree,
-			     struct extent_buffer *eb, int wait);
+			     struct extent_buffer *eb, u64 start, int wait);
 
 static inline void extent_buffer_get(struct extent_buffer *eb)
 {
@@ -187,5 +197,9 @@ int map_extent_buffer(struct extent_buffer *eb, unsigned long offset,
 		      unsigned long min_len, char **token, char **map,
 		      unsigned long *map_start,
 		      unsigned long *map_len, int km);
+int map_private_extent_buffer(struct extent_buffer *eb, unsigned long offset,
+		      unsigned long min_len, char **token, char **map,
+		      unsigned long *map_start,
+		      unsigned long *map_len, int km);
 void unmap_extent_buffer(struct extent_buffer *eb, char *token, int km);
 #endif

commit 810191ff3087e8143b41a944fcf4fd8c693f00e3
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:18:55 2007 -0400

    Btrfs: extent_map optimizations to cut down on CPU usage
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 52a8b9394fc6..f1dc28d260eb 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -75,7 +75,7 @@ struct extent_buffer {
 	char *kaddr;
 	unsigned long map_start;
 	unsigned long map_len;
-	struct page *last_page;
+	struct page *first_page;
 	struct list_head lru;
 	atomic_t refs;
 	int flags;

commit 4dc119046d0d8501afa4346472917fb05586ad9c
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:18:14 2007 -0400

    Btrfs: Add an extent buffer LRU to reduce radix tree hits
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 8409b5cbeda7..52a8b9394fc6 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -16,6 +16,7 @@
 #define EXTENT_DELALLOC (1 << 5)
 #define EXTENT_DEFRAG (1 << 6)
 #define EXTENT_DEFRAG_DONE (1 << 7)
+#define EXTENT_BUFFER_FILLED (1 << 8)
 #define EXTENT_IOBITS (EXTENT_LOCKED | EXTENT_WRITEBACK)
 
 
@@ -33,6 +34,9 @@ struct extent_map_tree {
 	struct address_space *mapping;
 	rwlock_t lock;
 	struct extent_map_ops *ops;
+	spinlock_t lru_lock;
+	struct list_head buffer_lru;
+	int lru_size;
 };
 
 /* note, this must start with the same fields as fs/extent_map.c:tree_entry */
@@ -64,20 +68,17 @@ struct extent_state {
 	struct list_head list;
 };
 
-#define EXTENT_INLINE_PAGES 32
 struct extent_buffer {
 	u64 start;
 	unsigned long len;
-	atomic_t refs;
-	int flags;
-	struct list_head list;
-	struct list_head leak_list;
-	unsigned long alloc_addr;
 	char *map_token;
 	char *kaddr;
 	unsigned long map_start;
 	unsigned long map_len;
-	struct page *pages[EXTENT_INLINE_PAGES];
+	struct page *last_page;
+	struct list_head lru;
+	atomic_t refs;
+	int flags;
 };
 
 typedef struct extent_map *(get_extent_t)(struct inode *inode,
@@ -88,6 +89,7 @@ typedef struct extent_map *(get_extent_t)(struct inode *inode,
 
 void extent_map_tree_init(struct extent_map_tree *tree,
 			  struct address_space *mapping, gfp_t mask);
+void extent_map_tree_cleanup(struct extent_map_tree *tree);
 struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,
 					 u64 start, u64 end);
 int add_extent_mapping(struct extent_map_tree *tree,

commit 6b80053d02be41886344b5007d04e345311ec0b5
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:17:34 2007 -0400

    Btrfs: Add back the online defragging code
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index d74a2b3e3b5d..8409b5cbeda7 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -14,6 +14,8 @@
 #define EXTENT_LOCKED (1 << 3)
 #define EXTENT_NEW (1 << 4)
 #define EXTENT_DELALLOC (1 << 5)
+#define EXTENT_DEFRAG (1 << 6)
+#define EXTENT_DEFRAG_DONE (1 << 7)
 #define EXTENT_IOBITS (EXTENT_LOCKED | EXTENT_WRITEBACK)
 
 

commit 09e71a326341f40111400c88aaf0498ef622824b
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:17:04 2007 -0400

    Btrfs: Use an array of pages in the extent buffers to reduce the cost of find_get_page
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 4ef8bdd68348..d74a2b3e3b5d 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -62,6 +62,7 @@ struct extent_state {
 	struct list_head list;
 };
 
+#define EXTENT_INLINE_PAGES 32
 struct extent_buffer {
 	u64 start;
 	unsigned long len;
@@ -69,13 +70,12 @@ struct extent_buffer {
 	int flags;
 	struct list_head list;
 	struct list_head leak_list;
-	struct page *first_page;
-	struct page *last_page;
 	unsigned long alloc_addr;
 	char *map_token;
 	char *kaddr;
 	unsigned long map_start;
 	unsigned long map_len;
+	struct page *pages[EXTENT_INLINE_PAGES];
 };
 
 typedef struct extent_map *(get_extent_t)(struct inode *inode,

commit db94535db75e67fab12ccbb7f5ee548e33fed891
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:15:53 2007 -0400

    Btrfs: Allow tree blocks larger than the page size
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 75dc600dc0f9..4ef8bdd68348 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -70,7 +70,12 @@ struct extent_buffer {
 	struct list_head list;
 	struct list_head leak_list;
 	struct page *first_page;
+	struct page *last_page;
 	unsigned long alloc_addr;
+	char *map_token;
+	char *kaddr;
+	unsigned long map_start;
+	unsigned long map_len;
 };
 
 typedef struct extent_map *(get_extent_t)(struct inode *inode,
@@ -147,11 +152,6 @@ static inline void extent_buffer_get(struct extent_buffer *eb)
 	atomic_inc(&eb->refs);
 }
 
-static inline u64 extent_buffer_blocknr(struct extent_buffer *eb)
-{
-	return eb->start / 4096;
-}
-
 int memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,
 			  unsigned long start,
 			  unsigned long len);

commit 1a5bc167f6707542b79a55452075525620ed43f5
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:15:26 2007 -0400

    Btrfs: Change the remaining radix trees used by extent-tree.c to extent_map trees
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 5a63b417034a..75dc600dc0f9 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -95,7 +95,9 @@ int extent_read_full_page(struct extent_map_tree *tree, struct page *page,
 			  get_extent_t *get_extent);
 void __init extent_map_init(void);
 void __exit extent_map_exit(void);
-int extent_clean_all_trees(struct extent_map_tree *tree);
+
+int test_range_bit(struct extent_map_tree *tree, u64 start, u64 end,
+		   int bits, int filled);
 int clear_extent_bits(struct extent_map_tree *tree, u64 start, u64 end,
 		      int bits, gfp_t mask);
 int set_extent_bits(struct extent_map_tree *tree, u64 start, u64 end,

commit 96b5179d0d9b6368c203856f2ad6e8e12a8b2a2c
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:15:19 2007 -0400

    Btrfs: Stop using radix trees for the block group cache
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index d100f7c1476c..5a63b417034a 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -96,6 +96,10 @@ int extent_read_full_page(struct extent_map_tree *tree, struct page *page,
 void __init extent_map_init(void);
 void __exit extent_map_exit(void);
 int extent_clean_all_trees(struct extent_map_tree *tree);
+int clear_extent_bits(struct extent_map_tree *tree, u64 start, u64 end,
+		      int bits, gfp_t mask);
+int set_extent_bits(struct extent_map_tree *tree, u64 start, u64 end,
+		    int bits, gfp_t mask);
 int set_extent_uptodate(struct extent_map_tree *tree, u64 start, u64 end,
 			gfp_t mask);
 int set_extent_new(struct extent_map_tree *tree, u64 start, u64 end,

commit f510cfecfc98759d75283823cfccf0cc0d59a4c6
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:14:48 2007 -0400

    Btrfs: Fix extent_buffer and extent_state leaks
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 3b3abf34c403..d100f7c1476c 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -68,7 +68,9 @@ struct extent_buffer {
 	atomic_t refs;
 	int flags;
 	struct list_head list;
+	struct list_head leak_list;
 	struct page *first_page;
+	unsigned long alloc_addr;
 };
 
 typedef struct extent_map *(get_extent_t)(struct inode *inode,

commit 6d36dcd48f1e4e7446d603a3df9638bd314a182d
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:14:37 2007 -0400

    Btrfs: Avoid memcpy where possible in extent_buffers
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 895789039ddd..3b3abf34c403 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -62,14 +62,13 @@ struct extent_state {
 	struct list_head list;
 };
 
-#define EXTENT_BUFFER_SIZE(nr) (sizeof(struct extent_buffer) + \
-			       (nr - 1) * sizeof(struct page *))
 struct extent_buffer {
 	u64 start;
 	unsigned long len;
 	atomic_t refs;
 	int flags;
-	struct page *pages[];
+	struct list_head list;
+	struct page *first_page;
 };
 
 typedef struct extent_map *(get_extent_t)(struct inode *inode,

commit 479965d66e320f1a095bb76027171daa675a9c72
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:14:27 2007 -0400

    Btrfs: Optimizations for the extent_buffer code
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 430b997a70f6..895789039ddd 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -173,7 +173,7 @@ int set_extent_buffer_uptodate(struct extent_map_tree *tree,
 int extent_buffer_uptodate(struct extent_map_tree *tree,
 			   struct extent_buffer *eb);
 int map_extent_buffer(struct extent_buffer *eb, unsigned long offset,
-		      char **token, char **map,
+		      unsigned long min_len, char **token, char **map,
 		      unsigned long *map_start,
 		      unsigned long *map_len, int km);
 void unmap_extent_buffer(struct extent_buffer *eb, char *token, int km);

commit 5f39d397dfbe140a14edecd4e73c34ce23c4f9ee
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Oct 15 16:14:19 2007 -0400

    Btrfs: Create extent_buffer interface for large blocksizes
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index d913ce01248d..430b997a70f6 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -3,9 +3,20 @@
 
 #include <linux/rbtree.h>
 
+#define EXTENT_MAP_HOLE (u64)-3
 #define EXTENT_MAP_INLINE (u64)-2
 #define EXTENT_MAP_DELALLOC (u64)-1
 
+/* bits for the extent state */
+#define EXTENT_DIRTY 1
+#define EXTENT_WRITEBACK (1 << 1)
+#define EXTENT_UPTODATE (1 << 2)
+#define EXTENT_LOCKED (1 << 3)
+#define EXTENT_NEW (1 << 4)
+#define EXTENT_DELALLOC (1 << 5)
+#define EXTENT_IOBITS (EXTENT_LOCKED | EXTENT_WRITEBACK)
+
+
 struct extent_map_ops {
 	int (*fill_delalloc)(struct inode *inode, u64 start, u64 end);
 	int (*writepage_io_hook)(struct page *page, u64 start, u64 end);
@@ -51,10 +62,13 @@ struct extent_state {
 	struct list_head list;
 };
 
+#define EXTENT_BUFFER_SIZE(nr) (sizeof(struct extent_buffer) + \
+			       (nr - 1) * sizeof(struct page *))
 struct extent_buffer {
 	u64 start;
-	u64 end; /* inclusive */
-	char *addr;
+	unsigned long len;
+	atomic_t refs;
+	int flags;
 	struct page *pages[];
 };
 
@@ -87,8 +101,12 @@ int set_extent_new(struct extent_map_tree *tree, u64 start, u64 end,
 		   gfp_t mask);
 int set_extent_dirty(struct extent_map_tree *tree, u64 start, u64 end,
 		     gfp_t mask);
+int clear_extent_dirty(struct extent_map_tree *tree, u64 start, u64 end,
+		       gfp_t mask);
 int set_extent_delalloc(struct extent_map_tree *tree, u64 start, u64 end,
 		     gfp_t mask);
+int find_first_extent_bit(struct extent_map_tree *tree, u64 start,
+			  u64 *start_ret, u64 *end_ret, int bits);
 int extent_invalidatepage(struct extent_map_tree *tree,
 			  struct page *page, unsigned long offset);
 int extent_write_full_page(struct extent_map_tree *tree, struct page *page,
@@ -106,4 +124,57 @@ int set_range_dirty(struct extent_map_tree *tree, u64 start, u64 end);
 int set_state_private(struct extent_map_tree *tree, u64 start, u64 private);
 int get_state_private(struct extent_map_tree *tree, u64 start, u64 *private);
 void set_page_extent_mapped(struct page *page);
+
+struct extent_buffer *alloc_extent_buffer(struct extent_map_tree *tree,
+					  u64 start, unsigned long len,
+					  gfp_t mask);
+struct extent_buffer *find_extent_buffer(struct extent_map_tree *tree,
+					 u64 start, unsigned long len,
+					  gfp_t mask);
+void free_extent_buffer(struct extent_buffer *eb);
+int read_extent_buffer_pages(struct extent_map_tree *tree,
+			     struct extent_buffer *eb, int wait);
+
+static inline void extent_buffer_get(struct extent_buffer *eb)
+{
+	atomic_inc(&eb->refs);
+}
+
+static inline u64 extent_buffer_blocknr(struct extent_buffer *eb)
+{
+	return eb->start / 4096;
+}
+
+int memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,
+			  unsigned long start,
+			  unsigned long len);
+void read_extent_buffer(struct extent_buffer *eb, void *dst,
+			unsigned long start,
+			unsigned long len);
+void write_extent_buffer(struct extent_buffer *eb, const void *src,
+			 unsigned long start, unsigned long len);
+void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,
+			unsigned long dst_offset, unsigned long src_offset,
+			unsigned long len);
+void memcpy_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,
+			   unsigned long src_offset, unsigned long len);
+void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,
+			   unsigned long src_offset, unsigned long len);
+void memset_extent_buffer(struct extent_buffer *eb, char c,
+			  unsigned long start, unsigned long len);
+int wait_on_extent_buffer_writeback(struct extent_map_tree *tree,
+				    struct extent_buffer *eb);
+int clear_extent_buffer_dirty(struct extent_map_tree *tree,
+			      struct extent_buffer *eb);
+int set_extent_buffer_dirty(struct extent_map_tree *tree,
+			     struct extent_buffer *eb);
+int set_extent_buffer_uptodate(struct extent_map_tree *tree,
+			       struct extent_buffer *eb);
+int extent_buffer_uptodate(struct extent_map_tree *tree,
+			   struct extent_buffer *eb);
+int map_extent_buffer(struct extent_buffer *eb, unsigned long offset,
+		      char **token, char **map,
+		      unsigned long *map_start,
+		      unsigned long *map_len, int km);
+void unmap_extent_buffer(struct extent_buffer *eb, char *token, int km);
 #endif

commit b3cfa35a493866cffd00952438b6c77364d42d3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 17 11:25:58 2007 -0400

    Btrfs: factor page private preparations into a helper
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 40b53ee274fb..d913ce01248d 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -105,4 +105,5 @@ sector_t extent_bmap(struct address_space *mapping, sector_t iblock,
 int set_range_dirty(struct extent_map_tree *tree, u64 start, u64 end);
 int set_state_private(struct extent_map_tree *tree, u64 start, u64 private);
 int get_state_private(struct extent_map_tree *tree, u64 start, u64 *private);
+void set_page_extent_mapped(struct page *page);
 #endif

commit 0e2752a72cb37075b24899f01e9bc6a589de3b6c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 10 20:02:33 2007 -0400

    Btrfs: [PATCH] extent_map: add writepage_end_io hook
    
    XFS updates the ondisk inode size only after the data I/O has finished,
    so it needs a hook when the writepage end_bio handler has finished.
    
    Might not be worth applying as-is as the per-page callback is very
    ineffcient.  What XFS really wants is a callback when writeout of a
    whole extent has completed.  This delayed i_size updates scheme might
    be worthwile for btrfs aswell, btw.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index da41aca74e0b..40b53ee274fb 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -11,6 +11,7 @@ struct extent_map_ops {
 	int (*writepage_io_hook)(struct page *page, u64 start, u64 end);
 	int (*readpage_io_hook)(struct page *page, u64 start, u64 end);
 	int (*readpage_end_io_hook)(struct page *page, u64 start, u64 end);
+	void (*writepage_end_io_hook)(struct page *page, u64 start, u64 end);
 };
 
 struct extent_map_tree {

commit d396c6f554d182b7bce4e2bb2acb47f80430c05f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 10 20:02:30 2007 -0400

    Btrfs: [PATCH] extent_map: provide generic bmap
    
    generic_bmap is completely trivial, while the extent to bh mapping in
    btrfs is rather complex.  So provide a extent_bmap instead that takes
    a get_extent callback and can be used by filesystem using the extent_map
    code.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 0eae6c420acb..da41aca74e0b 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -99,6 +99,8 @@ int extent_prepare_write(struct extent_map_tree *tree,
 int extent_commit_write(struct extent_map_tree *tree,
 			struct inode *inode, struct page *page,
 			unsigned from, unsigned to);
+sector_t extent_bmap(struct address_space *mapping, sector_t iblock,
+		get_extent_t *get_extent);
 int set_range_dirty(struct extent_map_tree *tree, u64 start, u64 end);
 int set_state_private(struct extent_map_tree *tree, u64 start, u64 private);
 int get_state_private(struct extent_map_tree *tree, u64 start, u64 *private);

commit 07157aacb1ecd394a5494910b5f80d7e7d407d37
Author: Chris Mason <chris.mason@oracle.com>
Date:   Thu Aug 30 08:50:51 2007 -0400

    Btrfs: Add file data csums back in via hooks in the extent map code
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index e91a2e9619ee..0eae6c420acb 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -6,12 +6,19 @@
 #define EXTENT_MAP_INLINE (u64)-2
 #define EXTENT_MAP_DELALLOC (u64)-1
 
+struct extent_map_ops {
+	int (*fill_delalloc)(struct inode *inode, u64 start, u64 end);
+	int (*writepage_io_hook)(struct page *page, u64 start, u64 end);
+	int (*readpage_io_hook)(struct page *page, u64 start, u64 end);
+	int (*readpage_end_io_hook)(struct page *page, u64 start, u64 end);
+};
+
 struct extent_map_tree {
 	struct rb_root map;
 	struct rb_root state;
 	struct address_space *mapping;
 	rwlock_t lock;
-	int (*fill_delalloc)(struct inode *inode, u64 start, u64 end);
+	struct extent_map_ops *ops;
 };
 
 /* note, this must start with the same fields as fs/extent_map.c:tree_entry */
@@ -36,6 +43,10 @@ struct extent_state {
 	wait_queue_head_t wq;
 	atomic_t refs;
 	unsigned long state;
+
+	/* for use by the FS */
+	u64 private;
+
 	struct list_head list;
 };
 
@@ -89,4 +100,6 @@ int extent_commit_write(struct extent_map_tree *tree,
 			struct inode *inode, struct page *page,
 			unsigned from, unsigned to);
 int set_range_dirty(struct extent_map_tree *tree, u64 start, u64 end);
+int set_state_private(struct extent_map_tree *tree, u64 start, u64 private);
+int get_state_private(struct extent_map_tree *tree, u64 start, u64 *private);
 #endif

commit b888db2bd7b67f190b32934e6a86181f262ac3ec
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Aug 27 16:49:44 2007 -0400

    Btrfs: Add delayed allocation to the extent based page tree code
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
index 108944aab4bd..e91a2e9619ee 100644
--- a/fs/btrfs/extent_map.h
+++ b/fs/btrfs/extent_map.h
@@ -11,6 +11,7 @@ struct extent_map_tree {
 	struct rb_root state;
 	struct address_space *mapping;
 	rwlock_t lock;
+	int (*fill_delalloc)(struct inode *inode, u64 start, u64 end);
 };
 
 /* note, this must start with the same fields as fs/extent_map.c:tree_entry */
@@ -74,6 +75,8 @@ int set_extent_new(struct extent_map_tree *tree, u64 start, u64 end,
 		   gfp_t mask);
 int set_extent_dirty(struct extent_map_tree *tree, u64 start, u64 end,
 		     gfp_t mask);
+int set_extent_delalloc(struct extent_map_tree *tree, u64 start, u64 end,
+		     gfp_t mask);
 int extent_invalidatepage(struct extent_map_tree *tree,
 			  struct page *page, unsigned long offset);
 int extent_write_full_page(struct extent_map_tree *tree, struct page *page,

commit a52d9a8033c454cd9b4697cfafb467509fc1693f
Author: Chris Mason <chris.mason@oracle.com>
Date:   Mon Aug 27 16:49:44 2007 -0400

    Btrfs: Extent based page cache code.  This uses an rbtree of extents and tests
    instead of buffer heads.
    
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/extent_map.h b/fs/btrfs/extent_map.h
new file mode 100644
index 000000000000..108944aab4bd
--- /dev/null
+++ b/fs/btrfs/extent_map.h
@@ -0,0 +1,89 @@
+#ifndef __EXTENTMAP__
+#define __EXTENTMAP__
+
+#include <linux/rbtree.h>
+
+#define EXTENT_MAP_INLINE (u64)-2
+#define EXTENT_MAP_DELALLOC (u64)-1
+
+struct extent_map_tree {
+	struct rb_root map;
+	struct rb_root state;
+	struct address_space *mapping;
+	rwlock_t lock;
+};
+
+/* note, this must start with the same fields as fs/extent_map.c:tree_entry */
+struct extent_map {
+	u64 start;
+	u64 end; /* inclusive */
+	int in_tree;
+	struct rb_node rb_node;
+	/* block_start and block_end are in bytes */
+	u64 block_start;
+	u64 block_end; /* inclusive */
+	struct block_device *bdev;
+	atomic_t refs;
+};
+
+/* note, this must start with the same fields as fs/extent_map.c:tree_entry */
+struct extent_state {
+	u64 start;
+	u64 end; /* inclusive */
+	int in_tree;
+	struct rb_node rb_node;
+	wait_queue_head_t wq;
+	atomic_t refs;
+	unsigned long state;
+	struct list_head list;
+};
+
+struct extent_buffer {
+	u64 start;
+	u64 end; /* inclusive */
+	char *addr;
+	struct page *pages[];
+};
+
+typedef struct extent_map *(get_extent_t)(struct inode *inode,
+					  struct page *page,
+					  size_t page_offset,
+					  u64 start, u64 end,
+					  int create);
+
+void extent_map_tree_init(struct extent_map_tree *tree,
+			  struct address_space *mapping, gfp_t mask);
+struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,
+					 u64 start, u64 end);
+int add_extent_mapping(struct extent_map_tree *tree,
+		       struct extent_map *em);
+int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em);
+int try_release_extent_mapping(struct extent_map_tree *tree, struct page *page);
+int lock_extent(struct extent_map_tree *tree, u64 start, u64 end, gfp_t mask);
+int unlock_extent(struct extent_map_tree *tree, u64 start, u64 end, gfp_t mask);
+struct extent_map *alloc_extent_map(gfp_t mask);
+void free_extent_map(struct extent_map *em);
+int extent_read_full_page(struct extent_map_tree *tree, struct page *page,
+			  get_extent_t *get_extent);
+void __init extent_map_init(void);
+void __exit extent_map_exit(void);
+int extent_clean_all_trees(struct extent_map_tree *tree);
+int set_extent_uptodate(struct extent_map_tree *tree, u64 start, u64 end,
+			gfp_t mask);
+int set_extent_new(struct extent_map_tree *tree, u64 start, u64 end,
+		   gfp_t mask);
+int set_extent_dirty(struct extent_map_tree *tree, u64 start, u64 end,
+		     gfp_t mask);
+int extent_invalidatepage(struct extent_map_tree *tree,
+			  struct page *page, unsigned long offset);
+int extent_write_full_page(struct extent_map_tree *tree, struct page *page,
+			  get_extent_t *get_extent,
+			  struct writeback_control *wbc);
+int extent_prepare_write(struct extent_map_tree *tree,
+			 struct inode *inode, struct page *page,
+			 unsigned from, unsigned to, get_extent_t *get_extent);
+int extent_commit_write(struct extent_map_tree *tree,
+			struct inode *inode, struct page *page,
+			unsigned from, unsigned to);
+int set_range_dirty(struct extent_map_tree *tree, u64 start, u64 end);
+#endif
