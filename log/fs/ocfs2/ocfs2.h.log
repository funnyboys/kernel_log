commit 4cd9973f9ff69e37dd0ba2bd6e6423f8179c329a
Author: Junxiao Bi <junxiao.bi@oracle.com>
Date:   Thu Jun 25 20:29:30 2020 -0700

    ocfs2: avoid inode removal while nfsd is accessing it
    
    Patch series "ocfs2: fix nfsd over ocfs2 issues", v2.
    
    This is a series of patches to fix issues on nfsd over ocfs2.  patch 1
    is to avoid inode removed while nfsd access it patch 2 & 3 is to fix a
    panic issue.
    
    This patch (of 4):
    
    When nfsd is getting file dentry using handle or parent dentry of some
    dentry, one cluster lock is used to avoid inode removed from other node,
    but it still could be removed from local node, so use a rw lock to avoid
    this.
    
    Link: http://lkml.kernel.org/r/20200616183829.87211-1-junxiao.bi@oracle.com
    Link: http://lkml.kernel.org/r/20200616183829.87211-2-junxiao.bi@oracle.com
    Signed-off-by: Junxiao Bi <junxiao.bi@oracle.com>
    Reviewed-by: Joseph Qi <joseph.qi@linux.alibaba.com>
    Cc: Changwei Ge <gechangwei@live.cn>
    Cc: Gang He <ghe@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Jun Piao <piaojun@huawei.com>
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index ee5d98516212..2dd71d626196 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -395,6 +395,7 @@ struct ocfs2_super
 	struct ocfs2_lock_res osb_super_lockres;
 	struct ocfs2_lock_res osb_rename_lockres;
 	struct ocfs2_lock_res osb_nfs_sync_lockres;
+	struct rw_semaphore nfs_sync_rwlock;
 	struct ocfs2_lock_res osb_trim_fs_lockres;
 	struct mutex obs_trim_fs_mutex;
 	struct ocfs2_dlm_debug *osb_dlm_debug;

commit 912f655d78c5d4ad05eac287f23a435924df7144
Author: Gang He <ghe@suse.com>
Date:   Mon Jun 1 21:45:29 2020 -0700

    ocfs2: mount shared volume without ha stack
    
    Usually we create and use a ocfs2 shared volume on the top of ha stack.
    For pcmk based ha stack, which includes DLM, corosync and pacemaker
    services.
    
    The customers complained they could not mount existent ocfs2 volume in
    the single node without ha stack, e.g.  single node backup/restore
    scenario.
    
    Like this case, the customers just want to access the data from the
    existent ocfs2 volume quickly, but do not want to restart or setup ha
    stack.
    
    Then, I'd like to add a mount option "nocluster", if the users use this
    option to mount a ocfs2 shared volume, the whole mount will not depend
    on the ha related services.  the command will mount the existent ocfs2
    volume directly (like local mount), for avoiding setup the ha stack.
    
    Signed-off-by: Gang He <ghe@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <jiangqi903@gmail.com>
    Cc: Changwei Ge <gechangwei@live.cn>
    Cc: Jun Piao <piaojun@huawei.com>
    Link: http://lkml.kernel.org/r/20200423053300.22661-1-ghe@suse.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 9150cfa4df7d..ee5d98516212 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -279,6 +279,7 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT = 1 << 15,  /* Journal Async Commit */
 	OCFS2_MOUNT_ERRORS_CONT = 1 << 16, /* Return EIO to the calling process on error */
 	OCFS2_MOUNT_ERRORS_ROFS = 1 << 17, /* Change filesystem to read-only on error */
+	OCFS2_MOUNT_NOCLUSTER = 1 << 18, /* No cluster aware filesystem mount */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001
@@ -673,7 +674,8 @@ static inline int ocfs2_cluster_o2cb_global_heartbeat(struct ocfs2_super *osb)
 
 static inline int ocfs2_mount_local(struct ocfs2_super *osb)
 {
-	return (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);
+	return ((osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT)
+		|| (osb->s_mount_opt & OCFS2_MOUNT_NOCLUSTER));
 }
 
 static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)

commit 5e7a3ed9f1a60f17c165e1b73df6d6aebb211266
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 23 15:33:15 2019 -0700

    ocfs2: further debugfs cleanups
    
    There is no need to check return value of debugfs_create functions, but
    the last sweep through ocfs missed a number of places where this was
    happening.  There is also no need to save the individual dentries for the
    debugfs files, as everything is can just be removed at once when the
    directory is removed.
    
    By getting rid of the file dentries for the debugfs entries, a bit of
    local memory can be saved as well.
    
    [colin.king@canonical.com: ensure ret is set to zero before returning]
      Link: http://lkml.kernel.org/r/20190807121929.28918-1-colin.king@canonical.com
    Link: http://lkml.kernel.org/r/20190731132119.GA12603@kroah.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Joseph Qi <joseph.qi@linux.alibaba.com>
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Jia Guo <guojia12@huawei.com>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Changwei Ge <gechangwei@live.cn>
    Cc: Gang He <ghe@suse.com>
    Cc: Jun Piao <piaojun@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index fddbbd60f434..9150cfa4df7d 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -223,8 +223,6 @@ struct ocfs2_orphan_scan {
 
 struct ocfs2_dlm_debug {
 	struct kref d_refcnt;
-	struct dentry *d_locking_state;
-	struct dentry *d_locking_filter;
 	u32 d_filter_secs;
 	struct list_head d_lockres_tracking;
 };
@@ -401,7 +399,6 @@ struct ocfs2_super
 	struct ocfs2_dlm_debug *osb_dlm_debug;
 
 	struct dentry *osb_debug_root;
-	struct dentry *osb_ctxt;
 
 	wait_queue_head_t recovery_event;
 

commit 5da844a2c7df642de2618fc3efe9a92eec40899d
Author: Gang He <ghe@suse.com>
Date:   Thu Jul 11 20:53:09 2019 -0700

    ocfs2: add first lock wait time in locking_state
    
    ocfs2 file system uses locking_state file under debugfs to dump each
    ocfs2 file system's dlm lock resources, but the users ever encountered
    some hang(deadlock) problems in ocfs2 file system.  I'd like to add
    first lock wait time in locking_state file, which can help the upper
    scripts detect these deadlock problems via comparing the first lock wait
    time with the current time.
    
    Link: http://lkml.kernel.org/r/20190611015414.27754-3-ghe@suse.com
    Signed-off-by: Gang He <ghe@suse.com>
    Reviewed-by: Joseph Qi <joseph.qi@linux.alibaba.com>
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Changwei Ge <gechangwei@live.cn>
    Cc: Gang He <ghe@suse.com>
    Cc: Jun Piao <piaojun@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index c7539601555b..fddbbd60f434 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -192,6 +192,7 @@ struct ocfs2_lock_res {
 #ifdef CONFIG_OCFS2_FS_STATS
 	struct ocfs2_lock_stats  l_lock_prmode;		/* PR mode stats */
 	u32                      l_lock_refresh;	/* Disk refreshes */
+	u64                      l_lock_wait;	/* First lock wait time */
 	struct ocfs2_lock_stats  l_lock_exmode;		/* EX mode stats */
 #endif
 #ifdef CONFIG_DEBUG_LOCK_ALLOC

commit 8056773ac4b42f36bae6406030218a5f12749c64
Author: Gang He <ghe@suse.com>
Date:   Thu Jul 11 20:53:05 2019 -0700

    ocfs2: add locking filter debugfs file
    
    Add locking filter debugfs file, which is used to filter lock resources
    dump from locking_state debugfs file.  We use d_filter_secs field to
    filter lock resources dump, the default d_filter_secs(0) value filters
    nothing, otherwise, only dump the last N seconds active lock resources.
    This enhancement can avoid dumping lots of old records.  The
    d_filter_secs value can be changed via locking_filter file.
    
    [akpm@linux-foundation.org: fix undefined reference to `__udivdi3']
    Link: http://lkml.kernel.org/r/20190611015414.27754-2-ghe@suse.com
    Signed-off-by: Gang He <ghe@suse.com>
    Reviewed-by: Joseph Qi <joseph.qi@linux.alibaba.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>  [build-tested]
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Changwei Ge <gechangwei@live.cn>
    Cc: Gang He <ghe@suse.com>
    Cc: Jun Piao <piaojun@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 5c111eabaa1d..c7539601555b 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -223,6 +223,8 @@ struct ocfs2_orphan_scan {
 struct ocfs2_dlm_debug {
 	struct kref d_refcnt;
 	struct dentry *d_locking_state;
+	struct dentry *d_locking_filter;
+	u32 d_filter_secs;
 	struct list_head d_lockres_tracking;
 };
 

commit 8a7f5f4c26dd4e969b5f3b30d06c54dc6a520eda
Author: Gang He <ghe@suse.com>
Date:   Thu Jul 11 20:53:02 2019 -0700

    ocfs2: add last unlock times in locking_state
    
    ocfs2 file system uses locking_state file under debugfs to dump each
    ocfs2 file system's dlm lock resources, but the dlm lock resources in
    memory are becoming more and more after the files were touched by the
    user.  it will become a bit difficult to analyze these dlm lock resource
    records in locking_state file by the upper scripts, though some files
    are not active for now, which were accessed long time ago.
    
    Then, I'd like to add last pr/ex unlock times in locking_state file for
    each dlm lock resource record, the the upper scripts can use last unlock
    time to filter inactive dlm lock resource record.
    
    Link: http://lkml.kernel.org/r/20190611015414.27754-1-ghe@suse.com
    Signed-off-by: Gang He <ghe@suse.com>
    Reviewed-by: Joseph Qi <joseph.qi@linux.alibaba.com>
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Changwei Ge <gechangwei@live.cn>
    Cc: Gang He <ghe@suse.com>
    Cc: Jun Piao <piaojun@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index a4647a646f07..5c111eabaa1d 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -150,6 +150,7 @@ struct ocfs2_lock_stats {
 
 	/* Storing max wait in usecs saves 24 bytes per inode */
 	u32		ls_max;		/* Max wait in USEC */
+	u64		ls_last;	/* Last unlock time in USEC */
 };
 #endif
 

commit 328970de0e39d596e0ef44080e7642224b29ecde
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 145
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 021110 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 84 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100844.756442981@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 1f029fbe8b8d..a4647a646f07 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* -*- mode: c; c-basic-offset: 8; -*-
  * vim: noexpandtab sw=8 ts=8 sts=0:
  *
@@ -6,21 +7,6 @@
  * Defines macros and structures used in OCFS2
  *
  * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
 #ifndef OCFS2_H

commit 5500ab4ed3b8f0749ec584d8c5e2738bc01ea52e
Author: Gang He <ghe@suse.com>
Date:   Tue Mar 5 15:41:45 2019 -0800

    ocfs2: fix the application IO timeout when fstrim is running
    
    The user reported this problem, the upper application IO was timeout
    when fstrim was running on this ocfs2 partition.  the application
    monitoring resource agent considered that this application did not work,
    then this node was fenced by the cluster brain (e.g.  pacemaker).
    
    The root cause is that fstrim thread always holds main_bm meta-file
    related locks until all the cluster groups are trimmed.  This patch will
    make fstrim thread release main_bm meta-file related locks when each
    cluster group is trimmed, this will let the current application IO has a
    chance to claim the clusters from main_bm meta-file.
    
    Link: http://lkml.kernel.org/r/20190111090014.31645-1-ghe@suse.com
    Signed-off-by: Gang He <ghe@suse.com>
    Reviewed-by: Changwei Ge <ge.changwei@h3c.com>
    Cc: Mark Fasheh <mfasheh@versity.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <joseph.qi@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 4f86ac0027b5..1f029fbe8b8d 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -407,6 +407,7 @@ struct ocfs2_super
 	struct ocfs2_lock_res osb_rename_lockres;
 	struct ocfs2_lock_res osb_nfs_sync_lockres;
 	struct ocfs2_lock_res osb_trim_fs_lockres;
+	struct mutex obs_trim_fs_mutex;
 	struct ocfs2_dlm_debug *osb_dlm_debug;
 
 	struct dentry *osb_debug_root;

commit 5f483c4abb507d068b326f24e4ea3481db9cda06
Author: Gang He <ghe@suse.com>
Date:   Thu Apr 5 16:19:29 2018 -0700

    ocfs2: add kobject for online file check
    
    Use embedded kobject mechanism for online file check feature, this will
    avoid to use a global list to save/search per-device online file check
    related data, meanwhile, reduce the code lines and make the code logic
    clear.  The changed code is based on Goldwyn Rodrigues's patches and
    ext4 fs code.
    
    Link: http://lkml.kernel.org/r/1495611866-27360-4-git-send-email-ghe@suse.com
    Signed-off-by: Gang He <ghe@suse.com>
    Cc: Mark Fasheh <mark@fasheh.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <jiangqi903@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 6867eef2e06b..4f86ac0027b5 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -50,6 +50,8 @@
 
 #include "reservations.h"
 
+#include "filecheck.h"
+
 /* Caching of metadata buffers */
 
 /* Most user visible OCFS2 inodes will have very few pieces of
@@ -472,6 +474,12 @@ struct ocfs2_super
 	 * workqueue and schedule on our own.
 	 */
 	struct workqueue_struct *ocfs2_wq;
+
+	/* sysfs directory per partition */
+	struct kset *osb_dev_kset;
+
+	/* file check related stuff */
+	struct ocfs2_filecheck_sysfs_entry osb_fc_ent;
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)

commit 4882abebccb58d68056462b66cea0d7f16169c39
Author: Gang He <ghe@suse.com>
Date:   Wed Jan 31 16:15:10 2018 -0800

    ocfs2: add trimfs dlm lock resource
    
    Introduce a new dlm lock resource, which will be used to communicate
    during fstrimming of an ocfs2 device from cluster nodes.
    
    Link: http://lkml.kernel.org/r/1513228484-2084-1-git-send-email-ghe@suse.com
    Signed-off-by: Gang He <ghe@suse.com>
    Reviewed-by: Changwei Ge <ge.changwei@h3c.com>
    Cc: Mark Fasheh <mfasheh@versity.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <jiangqi903@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 9a50f222ac97..6867eef2e06b 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -404,6 +404,7 @@ struct ocfs2_super
 	struct ocfs2_lock_res osb_super_lockres;
 	struct ocfs2_lock_res osb_rename_lockres;
 	struct ocfs2_lock_res osb_nfs_sync_lockres;
+	struct ocfs2_lock_res osb_trim_fs_lockres;
 	struct ocfs2_dlm_debug *osb_dlm_debug;
 
 	struct dentry *osb_debug_root;

commit 964f14a0d350486d17cfd24b3b7dc4f7c4bdc4d3
Author: Jun Piao <piaojun@huawei.com>
Date:   Wed Sep 6 16:19:11 2017 -0700

    ocfs2: clean up some dead code
    
    clean up some unused functions and parameters.
    
    Link: http://lkml.kernel.org/r/598A5E21.2080807@huawei.com
    Signed-off-by: Jun Piao <piaojun@huawei.com>
    Reviewed-by: Alex Chen <alex.chen@huawei.com>
    Cc: Mark Fasheh <mfasheh@versity.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <jiangqi903@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 0c39d71c67a1..9a50f222ac97 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -320,7 +320,6 @@ struct ocfs2_super
 	u64 system_dir_blkno;
 	u64 bitmap_blkno;
 	u32 bitmap_cpg;
-	u8 *uuid;
 	char *uuid_str;
 	u32 uuid_hash;
 	u8 *vol_label;
@@ -388,9 +387,8 @@ struct ocfs2_super
 	unsigned int	osb_resv_level;
 	unsigned int	osb_dir_resv_level;
 
-	/* Next three fields are for local node slot recovery during
+	/* Next two fields are for local node slot recovery during
 	 * mount. */
-	int dirty;
 	struct ocfs2_dinode *local_alloc_copy;
 	struct ocfs2_quota_recovery *quota_rec;
 

commit 439a36b8ef38657f765b80b775e2885338d72451
Author: Eric Ren <zren@suse.com>
Date:   Wed Feb 22 15:40:41 2017 -0800

    ocfs2/dlmglue: prepare tracking logic to avoid recursive cluster lock
    
    We are in the situation that we have to avoid recursive cluster locking,
    but there is no way to check if a cluster lock has been taken by a precess
    already.
    
    Mostly, we can avoid recursive locking by writing code carefully.
    However, we found that it's very hard to handle the routines that are
    invoked directly by vfs code.  For instance:
    
      const struct inode_operations ocfs2_file_iops = {
          .permission     = ocfs2_permission,
          .get_acl        = ocfs2_iop_get_acl,
          .set_acl        = ocfs2_iop_set_acl,
      };
    
    Both ocfs2_permission() and ocfs2_iop_get_acl() call ocfs2_inode_lock(PR):
    
      do_sys_open
       may_open
        inode_permission
         ocfs2_permission
          ocfs2_inode_lock() <=== first time
           generic_permission
            get_acl
             ocfs2_iop_get_acl
            ocfs2_inode_lock() <=== recursive one
    
    A deadlock will occur if a remote EX request comes in between two of
    ocfs2_inode_lock().  Briefly describe how the deadlock is formed:
    
    On one hand, OCFS2_LOCK_BLOCKED flag of this lockres is set in
    BAST(ocfs2_generic_handle_bast) when downconvert is started on behalf of
    the remote EX lock request.  Another hand, the recursive cluster lock
    (the second one) will be blocked in in __ocfs2_cluster_lock() because of
    OCFS2_LOCK_BLOCKED.  But, the downconvert never complete, why? because
    there is no chance for the first cluster lock on this node to be
    unlocked - we block ourselves in the code path.
    
    The idea to fix this issue is mostly taken from gfs2 code.
    
    1. introduce a new field: struct ocfs2_lock_res.l_holders, to keep track
       of the processes' pid who has taken the cluster lock of this lock
       resource;
    
    2. introduce a new flag for ocfs2_inode_lock_full:
       OCFS2_META_LOCK_GETBH; it means just getting back disk inode bh for
       us if we've got cluster lock.
    
    3. export a helper: ocfs2_is_locked_by_me() is used to check if we have
       got the cluster lock in the upper code path.
    
    The tracking logic should be used by some of the ocfs2 vfs's callbacks,
    to solve the recursive locking issue cuased by the fact that vfs
    routines can call into each other.
    
    The performance penalty of processing the holder list should only be
    seen at a few cases where the tracking logic is used, such as get/set
    acl.
    
    You may ask what if the first time we got a PR lock, and the second time
    we want a EX lock? fortunately, this case never happens in the real
    world, as far as I can see, including permission check,
    (get|set)_(acl|attr), and the gfs2 code also do so.
    
    [sfr@canb.auug.org.au remove some inlines]
    Link: http://lkml.kernel.org/r/20170117100948.11657-2-zren@suse.com
    Signed-off-by: Eric Ren <zren@suse.com>
    Reviewed-by: Junxiao Bi <junxiao.bi@oracle.com>
    Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Mark Fasheh <mfasheh@versity.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 7e5958b0be6b..0c39d71c67a1 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -172,6 +172,7 @@ struct ocfs2_lock_res {
 
 	struct list_head         l_blocked_list;
 	struct list_head         l_mask_waiters;
+	struct list_head	 l_holders;
 
 	unsigned long		 l_flags;
 	char                     l_name[OCFS2_LOCK_ID_MAX_LEN];

commit 395627b0718b6d4252c451c766cfc00ec155ddaf
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Mon Dec 12 16:41:23 2016 -0800

    ocfs2: use time64_t to represent orphan scan times
    
    struct timespec is not y2038 safe.  Use time64_t which is y2038 safe to
    represent orphan scan times.  time64_t is sufficient here as only the
    seconds delta times are relevant.
    
    Also use appropriate time functions that return time in time64_t format.
    Time functions now return monotonic time instead of real time as only
    delta scan times are relevant and these values are not persistent across
    reboots.
    
    The format string for the debug print is still using long as this is
    only the time elapsed since the last scan and long is sufficient to
    represent this value.
    
    Link: http://lkml.kernel.org/r/1475365138-20567-1-git-send-email-deepa.kernel@gmail.com
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Mark Fasheh <mfasheh@versity.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <jiangqi903@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index e63af7ddfe68..7e5958b0be6b 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -224,7 +224,7 @@ struct ocfs2_orphan_scan {
 	struct ocfs2_super 	*os_osb;
 	struct ocfs2_lock_res 	os_lockres;     /* lock to synchronize scans */
 	struct delayed_work 	os_orphan_scan_work;
-	struct timespec		os_scantime;  /* time this node ran the scan */
+	time64_t		os_scantime;  /* time this node ran the scan */
 	u32			os_count;      /* tracks node specific scans */
 	u32  			os_seqno;       /* tracks cluster wide scans */
 	atomic_t		os_state;              /* ACTIVE or INACTIVE */

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 6cf6538a0651..e63af7ddfe68 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -822,10 +822,10 @@ static inline unsigned int ocfs2_page_index_to_clusters(struct super_block *sb,
 	u32 clusters = pg_index;
 	unsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;
 
-	if (unlikely(PAGE_CACHE_SHIFT > cbits))
-		clusters = pg_index << (PAGE_CACHE_SHIFT - cbits);
-	else if (PAGE_CACHE_SHIFT < cbits)
-		clusters = pg_index >> (cbits - PAGE_CACHE_SHIFT);
+	if (unlikely(PAGE_SHIFT > cbits))
+		clusters = pg_index << (PAGE_SHIFT - cbits);
+	else if (PAGE_SHIFT < cbits)
+		clusters = pg_index >> (cbits - PAGE_SHIFT);
 
 	return clusters;
 }
@@ -839,10 +839,10 @@ static inline pgoff_t ocfs2_align_clusters_to_page_index(struct super_block *sb,
 	unsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;
         pgoff_t index = clusters;
 
-	if (PAGE_CACHE_SHIFT > cbits) {
-		index = (pgoff_t)clusters >> (PAGE_CACHE_SHIFT - cbits);
-	} else if (PAGE_CACHE_SHIFT < cbits) {
-		index = (pgoff_t)clusters << (cbits - PAGE_CACHE_SHIFT);
+	if (PAGE_SHIFT > cbits) {
+		index = (pgoff_t)clusters >> (PAGE_SHIFT - cbits);
+	} else if (PAGE_SHIFT < cbits) {
+		index = (pgoff_t)clusters << (cbits - PAGE_SHIFT);
 	}
 
 	return index;
@@ -853,8 +853,8 @@ static inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)
 	unsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;
 	unsigned int pages_per_cluster = 1;
 
-	if (PAGE_CACHE_SHIFT < cbits)
-		pages_per_cluster = 1 << (cbits - PAGE_CACHE_SHIFT);
+	if (PAGE_SHIFT < cbits)
+		pages_per_cluster = 1 << (cbits - PAGE_SHIFT);
 
 	return pages_per_cluster;
 }

commit 35ddf78e41852cbbd216948425a091ab9815678f
Author: jiangyiwen <jiangyiwen@huawei.com>
Date:   Fri Mar 25 14:21:32 2016 -0700

    ocfs2: fix occurring deadlock by changing ocfs2_wq from global to local
    
    This patch fixes a deadlock, as follows:
    
      Node 1                Node 2                  Node 3
    1)volume a and b are    only mount vol a        only mount vol b
      mounted
    
    2)                      start to mount b        start to mount a
    
    3)                      check hb of Node 3      check hb of Node 2
                            in vol a, qs_holds++    in vol b, qs_holds++
    
    4) -------------------- all nodes' network down --------------------
    
    5)                      progress of mount b     the same situation as
                            failed, and then call   Node 2
                            ocfs2_dismount_volume.
                            but the process is hung,
                            since there is a work
                            in ocfs2_wq cannot beo
                            completed. This work is
                            about vol a, because
                            ocfs2_wq is global wq.
                            BTW, this work which is
                            scheduled in ocfs2_wq is
                            ocfs2_orphan_scan_work,
                            and the context in this work
                            needs to take inode lock
                            of orphan_dir, because
                            lockres owner are Node 1 and
                            all nodes' nework has been down
                            at the same time, so it can't
                            get the inode lock.
    
    6)                      Why can't this node be fenced
                            when network disconnected?
                            Because the process of
                            mount is hung what caused qs_holds
                            is not equal 0.
    
    Because all works in the ocfs2_wq are relative to the super block.
    
    The solution is to change the ocfs2_wq from global to local.  In other
    words, move it into struct ocfs2_super.
    
    Signed-off-by: Yiwen Jiang <jiangyiwen@huawei.com>
    Reviewed-by: Joseph Qi <joseph.qi@huawei.com>
    Cc: Xue jiufei <xuejiufei@huawei.com>
    Cc: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 7a0126267847..6cf6538a0651 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -464,6 +464,14 @@ struct ocfs2_super
 	struct ocfs2_refcount_tree *osb_ref_tree_lru;
 
 	struct mutex system_file_mutex;
+
+	/*
+	 * OCFS2 needs to schedule several different types of work which
+	 * require cluster locking, disk I/O, recovery waits, etc. Since these
+	 * types of work tend to be heavy we avoid using the kernel events
+	 * workqueue and schedule on our own.
+	 */
+	struct workqueue_struct *ocfs2_wq;
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)

commit 7d0fb9148ab6f52006de7cce18860227594ba872
Author: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date:   Fri Sep 4 15:44:11 2015 -0700

    ocfs2: add errors=continue
    
    OCFS2 is often used in high-availaibility systems.  However, ocfs2
    converts the filesystem to read-only at the drop of the hat.  This may
    not be necessary, since turning the filesystem read-only would affect
    other running processes as well, decreasing availability.
    
    This attempt is to add errors=continue, which would return the EIO to
    the calling process and terminate furhter processing so that the
    filesystem is not corrupted further.  However, the filesystem is not
    converted to read-only.
    
    As a future plan, I intend to create a small utility or extend
    fsck.ocfs2 to fix small errors such as in the inode.  The input to the
    utility such as the inode can come from the kernel logs so we don't have
    to schedule a downtime for fixing small-enough errors.
    
    The patch changes the ocfs2_error to return an error.  The error
    returned depends on the mount option set.  If none is set, the default
    is to turn the filesystem read-only.
    
    Perhaps errors=continue is not the best option name.  Historically it is
    used for making an attempt to progress in the current process itself.
    Should we call it errors=eio? or errors=killproc? Suggestions/Comments
    welcome.
    
    Sources are available at:
      https://github.com/goldwynr/linux/tree/error-cont
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 690ddc60189b..7a0126267847 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -286,6 +286,8 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_HB_GLOBAL = 1 << 14, /* Global heartbeat */
 
 	OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT = 1 << 15,  /* Journal Async Commit */
+	OCFS2_MOUNT_ERRORS_CONT = 1 << 16, /* Return EIO to the calling process on error */
+	OCFS2_MOUNT_ERRORS_ROFS = 1 << 17, /* Change filesystem to read-only on error */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001

commit ae1f081467a147c125dfd5920e1c55f0e8ad031a
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Wed Jun 24 16:55:23 2015 -0700

    ocfs2: fix wrong check in ocfs2_direct_IO_get_blocks
    
    contig_blocks gotten from ocfs2_extent_map_get_blocks cannot be compared
    with clusters_to_alloc. So convert it to clusters first.
    
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Reviewed-by: Weiwei Wang <wangww631@huawei.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 460c6c37e683..690ddc60189b 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -717,6 +717,16 @@ static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,
 	return (u64)clusters << c_to_b_bits;
 }
 
+static inline u32 ocfs2_clusters_for_blocks(struct super_block *sb,
+		u64 blocks)
+{
+	int b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -
+			sb->s_blocksize_bits;
+
+	blocks += (1 << b_to_c_bits) - 1;
+	return (u32)(blocks >> b_to_c_bits);
+}
+
 static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,
 					   u64 blocks)
 {

commit 18d585f0f2d4c9dc7dfe6e69dcae4933d5a428c9
Author: Mark Fasheh <mfasheh@suse.de>
Date:   Thu Mar 12 16:25:46 2015 -0700

    ocfs2: make append_dio an incompat feature
    
    It turns out that making this feature ro_compat isn't quite enough to
    prevent accidental corruption on mount from older kernels.  Ocfs2 (like
    other file systems) will process orphaned inodes even when the user mounts
    in 'ro' mode.  So for the case of a filesystem not knowing the append_dio
    feature, mounting the filesystem could result in orphaned-for-dio files
    being deleted, which we clearly don't want.
    
    So instead, turn this into an incompat flag.
    
    Btw, this is kind of my fault - initially I asked that we add a flag to
    cover the feature and even suggested that we use an ro flag.  It wasn't
    until I was looking through our commits for v4.0-rc1 that I realized we
    actually want this to be incompat.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joseph Qi <joseph.qi@huawei.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 8490c64d34fe..460c6c37e683 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -502,7 +502,7 @@ static inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)
 
 static inline int ocfs2_supports_append_dio(struct ocfs2_super *osb)
 {
-	if (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_APPEND_DIO)
+	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_APPEND_DIO)
 		return 1;
 	return 0;
 }

commit 160cc266639d4213c15c103074561c1b44ffe691
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Mon Feb 16 16:00:15 2015 -0800

    ocfs2: set append dio as a ro compat feature
    
    Intruduce a bit OCFS2_FEATURE_RO_COMPAT_APPEND_DIO and check it in
    write flow. If the bit is not set, fall back to the old way.
    
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Cc: Weiwei Wang <wangww631@huawei.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Xuejiufei <xuejiufei@huawei.com>
    Cc: alex chen <alex.chen@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 7e39cd654834..8490c64d34fe 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -500,6 +500,14 @@ static inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)
 	return 0;
 }
 
+static inline int ocfs2_supports_append_dio(struct ocfs2_super *osb)
+{
+	if (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_APPEND_DIO)
+		return 1;
+	return 0;
+}
+
+
 static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)
 {
 	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)

commit 24c40b329e03dd38a1ca2225c739db67f4441343
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Mon Feb 16 16:00:00 2015 -0800

    ocfs2: implement ocfs2_direct_IO_write
    
    Implement ocfs2_direct_IO_write.  Add the inode to orphan dir first, and
    then delete it once append O_DIRECT finished.
    
    This is to make sure block allocation and inode size are consistent.
    
    [akpm@linux-foundation.org: fix it for "block: Add discard flag to blkdev_issue_zeroout() function"]
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Cc: Weiwei Wang <wangww631@huawei.com>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Xuejiufei <xuejiufei@huawei.com>
    Cc: alex chen <alex.chen@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index df9a95cbea3a..7e39cd654834 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -731,6 +731,16 @@ static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,
 	return clusters;
 }
 
+static inline unsigned int ocfs2_bytes_to_clusters(struct super_block *sb,
+		u64 bytes)
+{
+	int cl_bits = OCFS2_SB(sb)->s_clustersize_bits;
+	unsigned int clusters;
+
+	clusters = (unsigned int)(bytes >> cl_bits);
+	return clusters;
+}
+
 static inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,
 					 u64 bytes)
 {

commit ed460cffc26ba4ec663a89589d81290ca92c5010
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Mon Feb 16 15:59:57 2015 -0800

    ocfs2: add orphan recovery types in ocfs2_recover_orphans
    
    Define two orphan recovery types, which indicates if need truncate file or
    not.
    
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Cc: Weiwei Wang <wangww631@huawei.com>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Xuejiufei <xuejiufei@huawei.com>
    Cc: alex chen <alex.chen@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index fdbcbfed529e..df9a95cbea3a 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -209,6 +209,11 @@ struct ocfs2_lock_res {
 #endif
 };
 
+enum ocfs2_orphan_reco_type {
+	ORPHAN_NO_NEED_TRUNCATE = 0,
+	ORPHAN_NEED_TRUNCATE,
+};
+
 enum ocfs2_orphan_scan_state {
 	ORPHAN_SCAN_ACTIVE,
 	ORPHAN_SCAN_INACTIVE

commit 1dfeb768475dfded66bba03a1744c2e8141d3429
Author: alex chen <alex.chen@huawei.com>
Date:   Tue Feb 10 14:09:04 2015 -0800

    ocfs2: add a mount option journal_async_commit on ocfs2 filesystem
    
    Add a mount option to support JBD2 feature:
    
    JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT.  When this feature is opened, journal
    commit block can be written to disk without waiting for descriptor blocks,
    which can improve journal commit performance.  This option will enable
    'journal_checksum' internally.
    
    Using the fs_mark benchmark, using journal_async_commit shows a 50%
    improvement, the files per second go up from 215.2 to 317.5.
    
    test script:
    fs_mark  -d  /mnt/ocfs2/  -s  10240  -n  1000
    
    default:
    FSUse%        Count         Size    Files/sec     App Overhead
         0         1000        10240        215.2            17878
    
    with journal_async_commit option:
    FSUse%        Count         Size    Files/sec     App Overhead
         0         1000        10240        317.5            17881
    
    Signed-off-by: Alex Chen <alex.chen@huawei.com>
    Signed-off-by: Weiwei Wang <wangww631@huawei.comm>
    Reviewed-by: Joseph Qi <joseph.qi@huawei.com>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 7d6b7d090452..fdbcbfed529e 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -279,6 +279,8 @@ enum ocfs2_mount_options
 						     writes */
 	OCFS2_MOUNT_HB_NONE = 1 << 13, /* No heartbeat */
 	OCFS2_MOUNT_HB_GLOBAL = 1 << 14, /* Global heartbeat */
+
+	OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT = 1 << 15,  /* Journal Async Commit */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001

commit d1e78238741491d24177d99453091439c90ac70e
Author: Xue jiufei <xuejiufei@huawei.com>
Date:   Wed Dec 10 15:41:59 2014 -0800

    ocfs2: do not set OCFS2_LOCK_UPCONVERT_FINISHING if nonblocking lock can not be granted at once
    
    ocfs2_readpages() use nonblocking flag to avoid page lock inversion.  It
    will trigger cluster hang because that flag OCFS2_LOCK_UPCONVERT_FINISHING
    is not cleared if nonblocking lock cannot be granted at once.  The flag
    would prevent dc thread from downconverting.  So other nodes cannot
    acheive this lockres for ever.
    
    So we should not set OCFS2_LOCK_UPCONVERT_FINISHING when receiving ast if
    nonblocking lock had already returned.
    
    Signed-off-by: joyce.xue <xuejiufei@huawei.com>
    Reviewed-by: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index bbec539230fd..7d6b7d090452 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -144,6 +144,12 @@ enum ocfs2_unlock_action {
 						     * before the upconvert
 						     * has completed */
 
+#define OCFS2_LOCK_NONBLOCK_FINISHED (0x00001000) /* NONBLOCK cluster
+						   * lock has already
+						   * returned, do not block
+						   * dc thread from
+						   * downconverting */
+
 struct ocfs2_lock_res_ops;
 
 typedef void (*ocfs2_lock_callback)(int status, unsigned long data);

commit a9e9acaeb0a981a6dfa54b32dd756103aeefa6a7
Author: Xue jiufei <xuejiufei@huawei.com>
Date:   Wed Jun 4 16:06:13 2014 -0700

    ocfs2: fix umount hang while shutting down truncate log
    
    Revert commit 75f82eaa502c ("ocfs2: fix NULL pointer dereference when
    dismount and ocfs2rec simultaneously") because it may cause a umount
    hang while shutting down the truncate log.
    
    fix NULL pointer dereference when dismount and ocfs2rec simultaneously
    
    The situation is as followes:
    ocfs2_dismout_volume
    -> ocfs2_recovery_exit
      -> free osb->recovery_map
    -> ocfs2_truncate_shutdown
      -> lock global bitmap inode
        -> ocfs2_wait_for_recovery
              -> check whether osb->recovery_map->rm_used is zero
    
    Because osb->recovery_map is already freed, rm_used can be any other
    values, so it may yield umount hang.
    
    To prevent NULL pointer dereference while getting sys_root_inode, we use
    a osb_tl_disable flag to disable schedule osb_truncate_log_wq after
    truncate log shutdown.
    
    Signed-off-by: joyce.xue <xuejiufei@huawei.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 8d64a97a9d5e..bbec539230fd 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -422,6 +422,7 @@ struct ocfs2_super
 	struct inode			*osb_tl_inode;
 	struct buffer_head		*osb_tl_bh;
 	struct delayed_work		osb_truncate_log_wq;
+	atomic_t			osb_tl_disable;
 	/*
 	 * How many clusters in our truncate log.
 	 * It must be protected by osb_tl_inode->i_mutex.

commit 43b10a20372d9a1c08391f33f1c8bd86179ddc5f
Author: jiangyiwen <jiangyiwen@huawei.com>
Date:   Thu Apr 3 14:47:13 2014 -0700

    ocfs2: avoid system inode ref confusion by adding mutex lock
    
    The following case may lead to the same system inode ref in confusion.
    
    A thread                            B thread
    ocfs2_get_system_file_inode
    ->get_local_system_inode
    ->_ocfs2_get_system_file_inode
                                        because of *arr == NULL,
                                        ocfs2_get_system_file_inode
                                        ->get_local_system_inode
                                        ->_ocfs2_get_system_file_inode
    gets first ref thru
    _ocfs2_get_system_file_inode,
    gets second ref thru igrab and
    set *arr = inode
                                        at the moment, B thread also gets
                                        two refs, so lead to one more
                                        inode ref.
    
    So add mutex lock to avoid multi thread set two inode ref once at the
    same time.
    
    Signed-off-by: jiangyiwen <jiangyiwen@huawei.com>
    Reviewed-by: Joseph Qi <joseph.qi@huawei.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index a780e20d4fba..8d64a97a9d5e 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -446,6 +446,8 @@ struct ocfs2_super
 	/* rb tree root for refcount lock. */
 	struct rb_root	osb_rf_lock_tree;
 	struct ocfs2_refcount_tree *osb_ref_tree_lru;
+
+	struct mutex system_file_mutex;
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)

commit 8ed6b23709b346f7bfc1edab47003a205a6a9f69
Author: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date:   Thu Apr 3 14:46:59 2014 -0700

    ocfs2: revert iput deferring code in ocfs2_drop_dentry_lock
    
    The following patches are reverted in this patch because these patches
    caused performance regression in the remote unlink() calls.
    
      ea455f8ab683 - ocfs2: Push out dropping of dentry lock to ocfs2_wq
      f7b1aa69be13 - ocfs2: Fix deadlock on umount
      5fd131893793 - ocfs2: Don't oops in ocfs2_kill_sb on a failed mount
    
    Previous patches in this series removed the possible deadlocks from
    downconvert thread so the above patches shouldn't be needed anymore.
    
    The regression is caused because these patches delay the iput() in case
    of dentry unlocks.  This also delays the unlocking of the open lockres.
    The open lockresource is required to test if the inode can be wiped from
    disk or not.  When the deleting node does not get the open lock, it
    marks it as orphan (even though it is not in use by another
    node/process) and causes a journal checkpoint.  This delays operations
    following the inode eviction.  This also moves the inode to the orphaned
    inode which further causes more I/O and a lot of unneccessary orphans.
    
    The following script can be used to generate the load causing issues:
    
      declare -a create
      declare -a remove
      declare -a iterations=(1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384)
      unique="`mktemp -u XXXXX`"
      script="/tmp/idontknow-${unique}.sh"
      cat <<EOF > "${script}"
      for n in {1..8}; do mkdir -p test/dir\${n}
        eval touch test/dir\${n}/foo{1.."\$1"}
      done
      EOF
      chmod 700 "${script}"
    
      function fcreate ()
      {
        exec 2>&1 /usr/bin/time --format=%E "${script}" "$1"
      }
    
      function fremove ()
      {
        exec 2>&1 /usr/bin/time --format=%E ssh node2 "cd `pwd`; rm -Rf test*"
      }
    
      function fcp ()
      {
        exec 2>&1 /usr/bin/time --format=%E ssh node3 "cd `pwd`; cp -R test test.new"
      }
    
      echo -------------------------------------------------
      echo "| # files | create #s | copy #s | remove #s |"
      echo -------------------------------------------------
      for ((x=0; x < ${#iterations[*]} ; x++)) do
        create[$x]="`fcreate ${iterations[$x]}`"
        copy[$x]="`fcp ${iterations[$x]}`"
        remove[$x]="`fremove`"
        printf "| %8d | %9s | %9s | %9s |\n" ${iterations[$x]} ${create[$x]} ${copy[$x]} ${remove[$x]}
      done
      rm "${script}"
      echo "------------------------"
    
    Signed-off-by: Srinivas Eeda <srinivas.eeda@oracle.com>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 64c02239ba46..a780e20d4fba 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -275,19 +275,16 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_HB_GLOBAL = 1 << 14, /* Global heartbeat */
 };
 
-#define OCFS2_OSB_SOFT_RO			0x0001
-#define OCFS2_OSB_HARD_RO			0x0002
-#define OCFS2_OSB_ERROR_FS			0x0004
-#define OCFS2_OSB_DROP_DENTRY_LOCK_IMMED	0x0008
-
-#define OCFS2_DEFAULT_ATIME_QUANTUM		60
+#define OCFS2_OSB_SOFT_RO	0x0001
+#define OCFS2_OSB_HARD_RO	0x0002
+#define OCFS2_OSB_ERROR_FS	0x0004
+#define OCFS2_DEFAULT_ATIME_QUANTUM	60
 
 struct ocfs2_journal;
 struct ocfs2_slot_info;
 struct ocfs2_recovery_map;
 struct ocfs2_replay_map;
 struct ocfs2_quota_recovery;
-struct ocfs2_dentry_lock;
 struct ocfs2_super
 {
 	struct task_struct *commit_task;
@@ -415,11 +412,6 @@ struct ocfs2_super
 	struct list_head blocked_lock_list;
 	unsigned long blocked_lock_count;
 
-	/* List of dentry locks to release. Anyone can add locks to
-	 * the list, ocfs2_wq processes the list  */
-	struct ocfs2_dentry_lock *dentry_lock_list;
-	struct work_struct dentry_lock_work;
-
 	/* List of dquot structures to drop last reference to */
 	struct llist_head dquot_drop_list;
 	struct work_struct dquot_drop_work;
@@ -584,18 +576,6 @@ static inline void ocfs2_set_osb_flag(struct ocfs2_super *osb,
 	spin_unlock(&osb->osb_lock);
 }
 
-
-static inline unsigned long  ocfs2_test_osb_flag(struct ocfs2_super *osb,
-						 unsigned long flag)
-{
-	unsigned long ret;
-
-	spin_lock(&osb->osb_lock);
-	ret = osb->osb_flags & flag;
-	spin_unlock(&osb->osb_lock);
-	return ret;
-}
-
 static inline void ocfs2_set_ro_flag(struct ocfs2_super *osb,
 				     int hard)
 {

commit e3a767b60fd8a9f5e133f42f4970cff77ec43173
Author: Jan Kara <jack@suse.cz>
Date:   Thu Apr 3 14:46:56 2014 -0700

    ocfs2: implement delayed dropping of last dquot reference
    
    We cannot drop last dquot reference from downconvert thread as that
    creates the following deadlock:
    
    NODE 1                                  NODE2
    holds dentry lock for 'foo'
    holds inode lock for GLOBAL_BITMAP_SYSTEM_INODE
                                            dquot_initialize(bar)
                                              ocfs2_dquot_acquire()
                                                ocfs2_inode_lock(USER_QUOTA_SYSTEM_INODE)
                                                ...
    downconvert thread (triggered from another
    node or a different process from NODE2)
      ocfs2_dentry_post_unlock()
        ...
        iput(foo)
          ocfs2_evict_inode(foo)
            ocfs2_clear_inode(foo)
              dquot_drop(inode)
                ...
                ocfs2_dquot_release()
                  ocfs2_inode_lock(USER_QUOTA_SYSTEM_INODE)
                   - blocks
                                                finds we need more space in
                                                quota file
                                                ...
                                                ocfs2_extend_no_holes()
                                                  ocfs2_inode_lock(GLOBAL_BITMAP_SYSTEM_INODE)
                                                    - deadlocks waiting for
                                                      downconvert thread
    
    We solve the problem by postponing dropping of the last dquot reference to
    a workqueue if it happens from the downconvert thread.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Reviewed-by: Srinivas Eeda <srinivas.eeda@oracle.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 553f53cc73ae..64c02239ba46 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -30,6 +30,7 @@
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/list.h>
+#include <linux/llist.h>
 #include <linux/rbtree.h>
 #include <linux/workqueue.h>
 #include <linux/kref.h>
@@ -419,6 +420,10 @@ struct ocfs2_super
 	struct ocfs2_dentry_lock *dentry_lock_list;
 	struct work_struct dentry_lock_work;
 
+	/* List of dquot structures to drop last reference to */
+	struct llist_head dquot_drop_list;
+	struct work_struct dquot_drop_work;
+
 	wait_queue_head_t		osb_mount_event;
 
 	/* Truncate log info */

commit c74a3bdd9b529d924d1abf986079b783dd105ace
Author: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date:   Tue Jan 21 15:48:21 2014 -0800

    ocfs2: add clustername to cluster connection
    
    This is an effort of removing ocfs2_controld.pcmk and getting ocfs2 DLM
    handling up to the times with respect to DLM (>=4.0.1) and corosync
    (2.3.x).  AFAIK, cman also is being phased out for a unified corosync
    cluster stack.
    
    fs/dlm performs all the functions with respect to fencing and node
    management and provides the API's to do so for ocfs2.  For all future
    references, DLM stands for fs/dlm code.
    
    The advantages are:
     + No need to run an additional userspace daemon (ocfs2_controld)
     + No controld device handling and controld protocol
     + Shifting responsibilities of node management to DLM layer
    
    For backward compatibility, we are keeping the controld handling code.
    Once enough time has passed we can remove a significant portion of the
    code.  This was tested by using the kernel with changes on older
    unmodified tools.  The kernel used ocfs2_controld as expected, and
    displayed the appropriate warning message.
    
    This feature requires modification in the userspace ocfs2-tools.  The
    changes can be found at: https://github.com/goldwynr/ocfs2-tools branch:
    nocontrold Currently, not many checks are present in the userspace code,
    but that would change soon.
    
    This patch (of 6):
    
    Add clustername to cluster connection.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 3a903470c794..553f53cc73ae 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -387,6 +387,7 @@ struct ocfs2_super
 	u8 osb_stackflags;
 
 	char osb_cluster_stack[OCFS2_STACK_LABEL_LEN + 1];
+	char osb_cluster_name[OCFS2_CLUSTER_NAME_LEN + 1];
 	struct ocfs2_cluster_connection *cconn;
 	struct ocfs2_lock_res osb_super_lockres;
 	struct ocfs2_lock_res osb_rename_lockres;

commit 8fa9d17f93ee8eb79d595c98cef0944f6ee5de75
Author: Goldwyn Rodrigues <rgoldwyn@gmail.com>
Date:   Wed Jul 3 15:00:51 2013 -0700

    ocfs2: remove unecessary variable needs_checkpoint
    
    Code cleanup: needs_checkpoint is assigned to but never used.  Delete
    the variable.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Cc: Jeff Liu <jeff.liu@oracle.com>
    Acked-by: Joel Becker <jlbec@evilplan.org>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index d355e6e36b36..3a903470c794 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -347,7 +347,6 @@ struct ocfs2_super
 	struct task_struct *recovery_thread_task;
 	int disable_recovery;
 	wait_queue_head_t checkpoint_event;
-	atomic_t needs_checkpoint;
 	struct ocfs2_journal *journal;
 	unsigned long osb_commit_interval;
 

commit 939255798a468e1a92f03546de6e87be7b491e57
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Tue Nov 15 14:56:34 2011 -0800

    ocfs2: avoid unaligned access to dqc_bitmap
    
    The dqc_bitmap field of struct ocfs2_local_disk_chunk is 32-bit aligned,
    but not 64-bit aligned.  The dqc_bitmap is accessed by ocfs2_set_bit(),
    ocfs2_clear_bit(), ocfs2_test_bit(), or ocfs2_find_next_zero_bit().  These
    are wrapper macros for ext2_*_bit() which need to take an unsigned long
    aligned address (though some architectures are able to handle unaligned
    address correctly)
    
    So some 64bit architectures may not be able to access the dqc_bitmap
    correctly.
    
    This avoids such unaligned access by using another wrapper functions for
    ext2_*_bit().  The code is taken from fs/ext4/mballoc.c which also need to
    handle unaligned bitmap access.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Acked-by: Joel Becker <jlbec@evilplan.org>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Joel Becker <jlbec@evilplan.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index bcde467acca3..d355e6e36b36 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -849,5 +849,52 @@ static inline void _ocfs2_clear_bit(unsigned int bit, unsigned long *bitmap)
 #define ocfs2_test_bit test_bit_le
 #define ocfs2_find_next_zero_bit find_next_zero_bit_le
 #define ocfs2_find_next_bit find_next_bit_le
+
+static inline void *correct_addr_and_bit_unaligned(int *bit, void *addr)
+{
+#if BITS_PER_LONG == 64
+	*bit += ((unsigned long) addr & 7UL) << 3;
+	addr = (void *) ((unsigned long) addr & ~7UL);
+#elif BITS_PER_LONG == 32
+	*bit += ((unsigned long) addr & 3UL) << 3;
+	addr = (void *) ((unsigned long) addr & ~3UL);
+#else
+#error "how many bits you are?!"
+#endif
+	return addr;
+}
+
+static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)
+{
+	bitmap = correct_addr_and_bit_unaligned(&bit, bitmap);
+	ocfs2_set_bit(bit, bitmap);
+}
+
+static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)
+{
+	bitmap = correct_addr_and_bit_unaligned(&bit, bitmap);
+	ocfs2_clear_bit(bit, bitmap);
+}
+
+static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)
+{
+	bitmap = correct_addr_and_bit_unaligned(&bit, bitmap);
+	return ocfs2_test_bit(bit, bitmap);
+}
+
+static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,
+							int start)
+{
+	int fix = 0, ret, tmpmax;
+	bitmap = correct_addr_and_bit_unaligned(&fix, bitmap);
+	tmpmax = max + fix;
+	start += fix;
+
+	ret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;
+	if (ret > max)
+		return max;
+	return ret;
+}
+
 #endif  /* OCFS2_H */
 

commit 730e663bd82c1a10a85ff00728d34152a5a67ec8
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon May 30 21:58:05 2011 +0900

    ocfs2: use proper little-endian bitops
    
    Using __test_and_{set,clear}_bit_le() with ignoring its return value
    can be replaced with __{set,clear}_bit_le().
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: ocfs2-devel@oss.oracle.com
    Signed-off-by: Joel Becker <jlbec@evilplan.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 409285854f64..bcde467acca3 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -836,13 +836,13 @@ static inline unsigned int ocfs2_clusters_to_megabytes(struct super_block *sb,
 
 static inline void _ocfs2_set_bit(unsigned int bit, unsigned long *bitmap)
 {
-	__test_and_set_bit_le(bit, bitmap);
+	__set_bit_le(bit, bitmap);
 }
 #define ocfs2_set_bit(bit, addr) _ocfs2_set_bit((bit), (unsigned long *)(addr))
 
 static inline void _ocfs2_clear_bit(unsigned int bit, unsigned long *bitmap)
 {
-	__test_and_clear_bit_le(bit, bitmap);
+	__clear_bit_le(bit, bitmap);
 }
 #define ocfs2_clear_bit(bit, addr) _ocfs2_clear_bit((bit), (unsigned long *)(addr))
 

commit 03e4970c10151c5fb25ddd7e9a142d63c6a8d058
Merge: 1788c208aab1 272b62c1f0f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 28 13:03:31 2011 -0700

    Merge branch 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jlbec/ocfs2
    
    * 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jlbec/ocfs2: (39 commits)
      Treat writes as new when holes span across page boundaries
      fs,ocfs2: Move o2net_get_func_run_time under CONFIG_OCFS2_FS_STATS.
      ocfs2/dlm: Move kmalloc() outside the spinlock
      ocfs2: Make the left masklogs compat.
      ocfs2: Remove masklog ML_AIO.
      ocfs2: Remove masklog ML_UPTODATE.
      ocfs2: Remove masklog ML_BH_IO.
      ocfs2: Remove masklog ML_JOURNAL.
      ocfs2: Remove masklog ML_EXPORT.
      ocfs2: Remove masklog ML_DCACHE.
      ocfs2: Remove masklog ML_NAMEI.
      ocfs2: Remove mlog(0) from fs/ocfs2/dir.c
      ocfs2: remove NAMEI from symlink.c
      ocfs2: Remove masklog ML_QUOTA.
      ocfs2: Remove mlog(0) from quota_local.c.
      ocfs2: Remove masklog ML_RESERVATIONS.
      ocfs2: Remove masklog ML_XATTR.
      ocfs2: Remove masklog ML_SUPER.
      ocfs2: Remove mlog(0) from fs/ocfs2/heartbeat.c
      ocfs2: Remove mlog(0) from fs/ocfs2/slot_map.c
      ...
    
    Fix up trivial conflict in fs/ocfs2/super.c

commit c4354d0d6812ad6729ac33d3c8bc64585cfdb890
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Mar 23 16:42:08 2011 -0700

    ocfs2: use little-endian bitops
    
    As a preparation for removing ext2 non-atomic bit operations from
    asm/bitops.h.  This converts ext2 non-atomic bit operations to
    little-endian bit operations.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Acked-by: Joel Becker <joel.becker@oracle.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 51cd6898e7f1..1a97ba1ec3fc 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -831,18 +831,18 @@ static inline unsigned int ocfs2_clusters_to_megabytes(struct super_block *sb,
 
 static inline void _ocfs2_set_bit(unsigned int bit, unsigned long *bitmap)
 {
-	ext2_set_bit(bit, bitmap);
+	__test_and_set_bit_le(bit, bitmap);
 }
 #define ocfs2_set_bit(bit, addr) _ocfs2_set_bit((bit), (unsigned long *)(addr))
 
 static inline void _ocfs2_clear_bit(unsigned int bit, unsigned long *bitmap)
 {
-	ext2_clear_bit(bit, bitmap);
+	__test_and_clear_bit_le(bit, bitmap);
 }
 #define ocfs2_clear_bit(bit, addr) _ocfs2_clear_bit((bit), (unsigned long *)(addr))
 
-#define ocfs2_test_bit ext2_test_bit
-#define ocfs2_find_next_zero_bit ext2_find_next_zero_bit
-#define ocfs2_find_next_bit ext2_find_next_bit
+#define ocfs2_test_bit test_bit_le
+#define ocfs2_find_next_zero_bit find_next_zero_bit_le
+#define ocfs2_find_next_bit find_next_bit_le
 #endif  /* OCFS2_H */
 

commit 5bc970e803ad2b1f26771f39376a79dbf0f5bf64
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Tue Dec 28 23:26:03 2010 -0800

    ocfs2: Use hrtimer to track ocfs2 fs lock stats
    
    Patch makes use of the hrtimer to track times in ocfs2 lock stats.
    
    The patch is a bit involved to ensure no additional impact on the memory
    footprint. The size of ocfs2_inode_cache remains 1280 bytes on 32-bit systems.
    
    A related change was to modify the unit of the max wait time from nanosec to
    microsec allowing us to track max time larger than 4 secs. This change
    necessitated the bumping of the output version in the debugfs file,
    locking_state, from 2 to 3.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Joel Becker <jlbec@evilplan.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 51cd6898e7f1..4e3d3c1363f3 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -147,6 +147,17 @@ struct ocfs2_lock_res_ops;
 
 typedef void (*ocfs2_lock_callback)(int status, unsigned long data);
 
+#ifdef CONFIG_OCFS2_FS_STATS
+struct ocfs2_lock_stats {
+	u64		ls_total;	/* Total wait in NSEC */
+	u32		ls_gets;	/* Num acquires */
+	u32		ls_fail;	/* Num failed acquires */
+
+	/* Storing max wait in usecs saves 24 bytes per inode */
+	u32		ls_max;		/* Max wait in USEC */
+};
+#endif
+
 struct ocfs2_lock_res {
 	void                    *l_priv;
 	struct ocfs2_lock_res_ops *l_ops;
@@ -182,15 +193,9 @@ struct ocfs2_lock_res {
 	struct list_head         l_debug_list;
 
 #ifdef CONFIG_OCFS2_FS_STATS
-	unsigned long long	 l_lock_num_prmode; 	   /* PR acquires */
-	unsigned long long 	 l_lock_num_exmode; 	   /* EX acquires */
-	unsigned int		 l_lock_num_prmode_failed; /* Failed PR gets */
-	unsigned int		 l_lock_num_exmode_failed; /* Failed EX gets */
-	unsigned long long	 l_lock_total_prmode; 	   /* Tot wait for PR */
-	unsigned long long	 l_lock_total_exmode; 	   /* Tot wait for EX */
-	unsigned int		 l_lock_max_prmode; 	   /* Max wait for PR */
-	unsigned int		 l_lock_max_exmode; 	   /* Max wait for EX */
-	unsigned int		 l_lock_refresh;	   /* Disk refreshes */
+	struct ocfs2_lock_stats  l_lock_prmode;		/* PR mode stats */
+	u32                      l_lock_refresh;	/* Disk refreshes */
+	struct ocfs2_lock_stats  l_lock_exmode;		/* EX mode stats */
 #endif
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	 l_lockdep_map;

commit 50308d813bf26500fed671882469939fd19403a3
Author: Tao Ma <tao.ma@oracle.com>
Date:   Thu Nov 4 15:14:11 2010 +0800

    ocfs2: Try to free truncate log when meeting ENOSPC in write.
    
    Recently, one of our colleagues meet with a problem that if we
    write/delete a 32mb files repeatly, we will get an ENOSPC in
    the end. And the corresponding bug is 1288.
    http://oss.oracle.com/bugzilla/show_bug.cgi?id=1288
    
    The real problem is that although we have freed the clusters,
    they are in truncate log and they will be summed up so that
    we can free them once in a whole.
    
    So this patch just try to resolve it. In case we see -ENOSPC
    in ocfs2_write_begin_no_lock, we will check whether the truncate
    log has enough clusters for our need, if yes, we will try to
    flush the truncate log at that point and try again. This method
    is inspired by Mark Fasheh <mfasheh@suse.com>. Thanks.
    
    Cc: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 70dd3b1798f1..51cd6898e7f1 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -420,6 +420,11 @@ struct ocfs2_super
 	struct inode			*osb_tl_inode;
 	struct buffer_head		*osb_tl_bh;
 	struct delayed_work		osb_truncate_log_wq;
+	/*
+	 * How many clusters in our truncate log.
+	 * It must be protected by osb_tl_inode->i_mutex.
+	 */
+	unsigned int truncated_clusters;
 
 	struct ocfs2_node_map		osb_recovering_orphan_dirs;
 	unsigned int			*osb_orphan_wipes;

commit a2a2f55291918f6cf9287d7beaecc7bc007a9f1c
Author: Milton Miller <miltonm@bga.com>
Date:   Wed Nov 17 22:20:11 2010 -0600

    ocfs2: char is not always signed
    
    Commit 1c66b360fe262 (Change some lock status member in ocfs2_lock_res
    to char.)  states that these fields need to be signed due to comparision
    to -1, but only changed the type from unsigned char to char.   However, it
    is a compiler option if char is a signed or unsigned type.  Change these
    fields to signed char so the code will work with all compilers.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 1efea3615589..70dd3b1798f1 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -159,9 +159,9 @@ struct ocfs2_lock_res {
 	char                     l_name[OCFS2_LOCK_ID_MAX_LEN];
 	unsigned int             l_ro_holders;
 	unsigned int             l_ex_holders;
-	char			 l_level;
-	char			 l_requested;
-	char			 l_blocking;
+	signed char		 l_level;
+	signed char		 l_requested;
+	signed char		 l_blocking;
 
 	/* Data packed - type enum ocfs2_lock_type */
 	unsigned char            l_type;

commit 1c66b360fe26204e2aa14e45086b4a6b8890b1a2
Author: Tao Ma <tao.ma@oracle.com>
Date:   Sat Nov 13 16:22:02 2010 +0800

    ocfs2: Change some lock status member in ocfs2_lock_res to char.
    
    Commit 83fd9c7 changes l_level, l_requested and l_blocking of
    ocfs2_lock_res from int to unsigned char. But actually it is
    initially as -1(ocfs2_lock_res_init_common) which
    correspoding to 255 for unsigned char. So the whole dlm lock
    mechanism doesn't work now which means a disaster to ocfs2.
    
    Cc: Goldwyn Rodrigues <rgoldwyn@suse.de>
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index d8408217e3bd..1efea3615589 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -159,7 +159,9 @@ struct ocfs2_lock_res {
 	char                     l_name[OCFS2_LOCK_ID_MAX_LEN];
 	unsigned int             l_ro_holders;
 	unsigned int             l_ex_holders;
-	unsigned char            l_level;
+	char			 l_level;
+	char			 l_requested;
+	char			 l_blocking;
 
 	/* Data packed - type enum ocfs2_lock_type */
 	unsigned char            l_type;
@@ -169,8 +171,6 @@ struct ocfs2_lock_res {
 	unsigned char            l_action;
 	/* Data packed - enum type ocfs2_unlock_action */
 	unsigned char            l_unlock_action;
-	unsigned char            l_requested;
-	unsigned char            l_blocking;
 	unsigned int             l_pending_gen;
 
 	spinlock_t               l_lock;

commit fc3718918f13ad72827d62d36ea0f5fb55090644
Merge: 7bdb0d18bfd3 d4396eafe402
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Oct 15 13:03:09 2010 -0700

    Merge branch 'globalheartbeat-2' of git://oss.oracle.com/git/smushran/linux-2.6 into ocfs2-merge-window
    
    Conflicts:
            fs/ocfs2/ocfs2.h

commit 7bdb0d18bfd381cc5491eb95973ec5604b356c7e
Author: Tristan Ye <tristan.ye@oracle.com>
Date:   Mon Oct 11 16:46:39 2010 +0800

    ocfs2: Add a mount option "coherency=*" to handle cluster coherency for O_DIRECT writes.
    
    Currently, the default behavior of O_DIRECT writes was allowing
    concurrent writing among nodes to the same file, with no cluster
    coherency guaranteed (no EX lock held).  This can leave stale data in
    the cache for buffered reads on other nodes.
    
    The new mount option introduce a chance to choose two different
    behaviors for O_DIRECT writes:
    
        * coherency=full, as the default value, will disallow
                          concurrent O_DIRECT writes by taking
                          EX locks.
    
        * coherency=buffered, allow concurrent O_DIRECT writes
                              without EX lock among nodes, which
                              gains high performance at risk of
                              getting stale data on other nodes.
    
    Signed-off-by: Tristan Ye <tristan.ye@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 687e291d73f2..3064feef1430 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -263,6 +263,9 @@ enum ocfs2_mount_options
 						   control lists */
 	OCFS2_MOUNT_USRQUOTA = 1 << 10, /* We support user quotas */
 	OCFS2_MOUNT_GRPQUOTA = 1 << 11, /* We support group quotas */
+
+	OCFS2_MOUNT_COHERENCY_BUFFERED = 1 << 12 /* Allow concurrent O_DIRECT
+						    writes */
 };
 
 #define OCFS2_OSB_SOFT_RO			0x0001

commit 2c442719e90a44a6982c033d69df4aae4b167cfa
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Thu Oct 7 15:23:50 2010 -0700

    ocfs2: Add support for heartbeat=global mount option
    
    Adds support for heartbeat=global mount option. It ensures that the heartbeat
    mode passed matches the one enabled on disk.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index d5496a792bdb..481387b90b21 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -243,7 +243,7 @@ enum ocfs2_local_alloc_state
 
 enum ocfs2_mount_options
 {
-	OCFS2_MOUNT_HB_LOCAL   = 1 << 0, /* Heartbeat started in local mode */
+	OCFS2_MOUNT_HB_LOCAL = 1 << 0, /* Local heartbeat */
 	OCFS2_MOUNT_BARRIER = 1 << 1,	/* Use block barriers */
 	OCFS2_MOUNT_NOINTR  = 1 << 2,   /* Don't catch signals */
 	OCFS2_MOUNT_ERRORS_PANIC = 1 << 3, /* Panic on errors */
@@ -256,6 +256,8 @@ enum ocfs2_mount_options
 						   control lists */
 	OCFS2_MOUNT_USRQUOTA = 1 << 10, /* We support user quotas */
 	OCFS2_MOUNT_GRPQUOTA = 1 << 11, /* We support group quotas */
+	OCFS2_MOUNT_HB_NONE = 1 << 12, /* No heartbeat */
+	OCFS2_MOUNT_HB_GLOBAL = 1 << 13, /* Global heartbeat */
 };
 
 #define OCFS2_OSB_SOFT_RO			0x0001

commit 98f486f23bc5b6a6fa90e1a0707b7e9fe0e7f3e4
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Sat Oct 9 10:24:46 2010 -0700

    ocfs2: Add an incompat feature flag OCFS2_FEATURE_INCOMPAT_CLUSTERINFO
    
    OCFS2_FEATURE_INCOMPAT_CLUSTERINFO allows us to use sb->s_cluster_info for
    both userspace and o2cb cluster stacks. It also allows us to extend cluster
    info to include stack flags.
    
    This patch also adds stackflags to sb->s_clusterinfo. It also introduces a
    clusterinfo flag OCFS2_CLUSTER_O2CB_GLOBAL_HEARTBEAT to denote the enabled
    global heartbeat mode.
    
    This incompat flag can be set/cleared using tunefs.ocfs2 --fs-features. The
    clusterinfo flag is set/cleared using tunefs.ocfs2 --update-cluster-stack.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index c67003b6b5a2..d5496a792bdb 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -368,6 +368,8 @@ struct ocfs2_super
 	struct ocfs2_alloc_stats alloc_stats;
 	char dev_str[20];		/* "major,minor" of the device */
 
+	u8 osb_stackflags;
+
 	char osb_cluster_stack[OCFS2_STACK_LABEL_LEN + 1];
 	struct ocfs2_cluster_connection *cconn;
 	struct ocfs2_lock_res osb_super_lockres;
@@ -601,10 +603,35 @@ static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)
 	return ret;
 }
 
-static inline int ocfs2_userspace_stack(struct ocfs2_super *osb)
+static inline int ocfs2_clusterinfo_valid(struct ocfs2_super *osb)
 {
 	return (osb->s_feature_incompat &
-		OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK);
+		(OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK |
+		 OCFS2_FEATURE_INCOMPAT_CLUSTERINFO));
+}
+
+static inline int ocfs2_userspace_stack(struct ocfs2_super *osb)
+{
+	if (ocfs2_clusterinfo_valid(osb) &&
+	    memcmp(osb->osb_cluster_stack, OCFS2_CLASSIC_CLUSTER_STACK,
+		   OCFS2_STACK_LABEL_LEN))
+		return 1;
+	return 0;
+}
+
+static inline int ocfs2_o2cb_stack(struct ocfs2_super *osb)
+{
+	if (ocfs2_clusterinfo_valid(osb) &&
+	    !memcmp(osb->osb_cluster_stack, OCFS2_CLASSIC_CLUSTER_STACK,
+		   OCFS2_STACK_LABEL_LEN))
+		return 1;
+	return 0;
+}
+
+static inline int ocfs2_cluster_o2cb_global_heartbeat(struct ocfs2_super *osb)
+{
+	return ocfs2_o2cb_stack(osb) &&
+		(osb->osb_stackflags & OCFS2_CLUSTER_O2CB_GLOBAL_HEARTBEAT);
 }
 
 static inline int ocfs2_mount_local(struct ocfs2_super *osb)

commit b4d693fcc5fe99ed211addb5c6a0f8398f0b266e
Author: Tao Ma <tao.ma@oracle.com>
Date:   Mon Aug 16 16:58:21 2010 +0800

    ocfs2: Cache system inodes of other slots.
    
    Durring orphan scan, if we are slot 0, and we are replaying
    orphan_dir:0001, the general process is that for every file
    in this dir:
    1. we will iget orphan_dir:0001, since there is no inode for it.
       we will have to create an inode and read it from the disk.
    2. do the normal work, such as delete_inode and remove it from
       the dir if it is allowed.
    3. call iput orphan_dir:0001 when we are done. In this case,
       since we have no dcache for this inode, i_count will
       reach 0, and VFS will have to call clear_inode and in
       ocfs2_clear_inode we will checkpoint the inode which will let
       ocfs2_cmt and journald begin to work.
    4. We loop back to 1 for the next file.
    
    So you see, actually for every deleted file, we have to read the
    orphan dir from the disk and checkpoint the journal. It is very
    time consuming and cause a lot of journal checkpoint I/O.
    A better solution is that we can have another reference for these
    inodes in ocfs2_super. So if there is no other race among
    nodes(which will let dlmglue to checkpoint the inode), for step 3,
    clear_inode won't be called and for step 1, we may only need to
    read the inode for the 1st time. This is a big win for us.
    
    So this patch will try to cache system inodes of other slots so
    that we will have one more reference for these inodes and avoid
    the extra inode read and journal checkpoint.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 65739b3b3276..687e291d73f2 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -284,7 +284,8 @@ struct ocfs2_super
 	struct super_block *sb;
 	struct inode *root_inode;
 	struct inode *sys_root_inode;
-	struct inode *system_inodes[NUM_SYSTEM_INODES];
+	struct inode *global_system_inodes[NUM_GLOBAL_SYSTEM_INODES];
+	struct inode **local_system_inodes;
 
 	struct ocfs2_slot_info *slot_info;
 

commit 83fd9c7f65634ac440a6b9b7a63ba562f213ac60
Author: Goldwyn Rodrigues <rgoldwyn@gmail.com>
Date:   Thu Jun 10 17:21:36 2010 -0500

    Reorganize data elements to reduce struct sizes
    
    Thanks for the comments. I have incorportated them all.
    
    CONFIG_OCFS2_FS_STATS is enabled and CONFIG_DEBUG_LOCK_ALLOC is disabled.
    Statistics now look like -
    ocfs2_write_ctxt: 2144 - 2136 = 8
    ocfs2_inode_info: 1960 - 1848 = 112
    ocfs2_journal: 168 - 160 = 8
    ocfs2_lock_res: 336 - 304 = 32
    ocfs2_refcount_tree: 512 - 472 = 40
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.de>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index c67003b6b5a2..65739b3b3276 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -150,26 +150,33 @@ typedef void (*ocfs2_lock_callback)(int status, unsigned long data);
 struct ocfs2_lock_res {
 	void                    *l_priv;
 	struct ocfs2_lock_res_ops *l_ops;
-	spinlock_t               l_lock;
+
 
 	struct list_head         l_blocked_list;
 	struct list_head         l_mask_waiters;
 
-	enum ocfs2_lock_type     l_type;
 	unsigned long		 l_flags;
 	char                     l_name[OCFS2_LOCK_ID_MAX_LEN];
-	int                      l_level;
 	unsigned int             l_ro_holders;
 	unsigned int             l_ex_holders;
-	struct ocfs2_dlm_lksb    l_lksb;
+	unsigned char            l_level;
+
+	/* Data packed - type enum ocfs2_lock_type */
+	unsigned char            l_type;
 
 	/* used from AST/BAST funcs. */
-	enum ocfs2_ast_action    l_action;
-	enum ocfs2_unlock_action l_unlock_action;
-	int                      l_requested;
-	int                      l_blocking;
+	/* Data packed - enum type ocfs2_ast_action */
+	unsigned char            l_action;
+	/* Data packed - enum type ocfs2_unlock_action */
+	unsigned char            l_unlock_action;
+	unsigned char            l_requested;
+	unsigned char            l_blocking;
 	unsigned int             l_pending_gen;
 
+	spinlock_t               l_lock;
+
+	struct ocfs2_dlm_lksb    l_lksb;
+
 	wait_queue_head_t        l_event;
 
 	struct list_head         l_debug_list;

commit 4711954eaa8d30f653fda238cecf919f1ae40d6f
Author: Tao Ma <tao.ma@oracle.com>
Date:   Thu Apr 22 14:09:15 2010 +0800

    ocfs2: Some tiny bug fixes for discontiguous block allocation.
    
    The fixes include:
    1. some endian problems.
    2. we should use bit/bpc in ocfs2_block_group_grow_discontig to
       allocate clusters.
    3. set num_clusters properly in __ocfs2_claim_clusters.
    4. change name from ocfs2_supports_discontig_bh to
       ocfs2_supports_discontig_bg.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index d389f2714c96..c67003b6b5a2 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -491,7 +491,7 @@ static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)
 	return 0;
 }
 
-static inline int ocfs2_supports_discontig_bh(struct ocfs2_super *osb)
+static inline int ocfs2_supports_discontig_bg(struct ocfs2_super *osb)
 {
 	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)
 		return 1;

commit 798db35f4649eac2778381c390ed7d12de9ec767
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Apr 13 14:26:32 2010 +0800

    ocfs2: Allocate discontiguous block groups.
    
    If we cannot get a contiguous region for a block group, allocate a
    discontiguous one when the filesystem supports it.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Tao Ma <tao.ma@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index a388528f485c..d389f2714c96 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -491,6 +491,13 @@ static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)
 	return 0;
 }
 
+static inline int ocfs2_supports_discontig_bh(struct ocfs2_super *osb)
+{
+	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG)
+		return 1;
+	return 0;
+}
+
 static inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)
 {
 	if (ocfs2_supports_indexed_dirs(osb))

commit 83f92318fa33cc084e14e64dc903e605f75884c1
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Apr 5 18:17:16 2010 -0700

    ocfs2: Add dir_resv_level mount option
    
    The default behavior for directory reservations stays the same, but we add a
    mount option so people can tweak the size of directory reservations
    according to their workloads.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 09d7aee3dabe..a388528f485c 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -356,6 +356,7 @@ struct ocfs2_super
 	struct ocfs2_reservation_map	osb_la_resmap;
 
 	unsigned int	osb_resv_level;
+	unsigned int	osb_dir_resv_level;
 
 	/* Next three fields are for local node slot recovery during
 	 * mount. */

commit 6b82021b9e91cd689fdffadbcdb9a42597bbe764
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Apr 5 18:17:14 2010 -0700

    ocfs2: increase the default size of local alloc windows
    
    I have observed that the current size of 8M gives us pretty poor
    fragmentation on multi-threaded workloads which do lots of writes.
    
    Generally, I can increase the size of local alloc windows and observe a
    marked decrease in fragmentation, even up and beyond window sizes of 512
    megabytes. This makes sense for a couple reasons - larger local alloc means
    more room for reservation windows. On multi-node workloads the larger local
    alloc helps as well because we don't have to do window slides as often.
    
    Also, I removed the OCFS2_DEFAULT_LOCAL_ALLOC_SIZE constant as it is no
    longer used and the comment above it was out of date.
    
    To test fragmentation, I used a workload which launched 4 threads that did
    4k writes into a series of about 140 alternating files.
    
    With resv_level=2, and a 4k/4k file system I observed the following average
    fragmentation for various localalloc= parameters:
    
    localalloc=     avg. fragmentation
            8               48
            32              16
            64              10
            120             7
    
    On larger cluster sizes, the difference is more dramatic.
    
    The new default size top out at 256M, which we'll only get for cluster
    sizes of 32K and above.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index e98c954cf961..09d7aee3dabe 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -342,6 +342,9 @@ struct ocfs2_super
 	 */
 	unsigned int local_alloc_bits;
 	unsigned int local_alloc_default_bits;
+	/* osb_clusters_at_boot can become stale! Do not trust it to
+	 * be up to date. */
+	unsigned int osb_clusters_at_boot;
 
 	enum ocfs2_local_alloc_state local_alloc_state; /* protected
 							 * by osb_lock */

commit 73c8a80003d13be54e2309865030404441075182
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Apr 5 18:17:13 2010 -0700

    ocfs2: clean up localalloc mount option size parsing
    
    This patch pulls the local alloc sizing code into localalloc.c and provides
    a callout to it from ocfs2_fill_super(). Behavior is essentially unchanged
    except that I correctly calculate the maximum local alloc size. The old code
    in ocfs2_parse_options() calculated the max size as:
    
    ocfs2_local_alloc_size(sb) * 8
    
    which is correct, in bits. Unfortunately though the option passed in is in
    megabytes. Ultimately, this bug made no real difference - the shrink code
    would catch a too-large size and bring it down to something reasonable.
    Still, it's less than efficient as-is.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 9552560df6cd..e98c954cf961 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -768,6 +768,12 @@ static inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,
 	return megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);
 }
 
+static inline unsigned int ocfs2_clusters_to_megabytes(struct super_block *sb,
+						       unsigned int clusters)
+{
+	return clusters >> (20 - OCFS2_SB(sb)->s_clustersize_bits);
+}
+
 static inline void _ocfs2_set_bit(unsigned int bit, unsigned long *bitmap)
 {
 	ext2_set_bit(bit, bitmap);

commit d02f00cc057809d96c044cc72d5b9809d59f7d49
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Dec 7 13:10:48 2009 -0800

    ocfs2: allocation reservations
    
    This patch improves Ocfs2 allocation policy by allowing an inode to
    reserve a portion of the local alloc bitmap for itself. The reserved
    portion (allocation window) is advisory in that other allocation
    windows might steal it if the local alloc bitmap becomes
    full. Otherwise, the reservations are honored and guaranteed to be
    free. When the local alloc window is moved to a different portion of
    the bitmap, existing reservations are discarded.
    
    Reservation windows are represented internally by a red-black
    tree. Within that tree, each node represents the reservation window of
    one inode. An LRU of active reservations is also maintained. When new
    data is written, we allocate it from the inodes window. When all bits
    in a window are exhausted, we allocate a new one as close to the
    previous one as possible. Should we not find free space, an existing
    reservation is pulled off the LRU and cannibalized.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index adf5e2ebc2c4..9552560df6cd 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -47,6 +47,7 @@
 /* For struct ocfs2_blockcheck_stats */
 #include "blockcheck.h"
 
+#include "reservations.h"
 
 /* Caching of metadata buffers */
 
@@ -349,6 +350,10 @@ struct ocfs2_super
 
 	u64 la_last_gd;
 
+	struct ocfs2_reservation_map	osb_la_resmap;
+
+	unsigned int	osb_resv_level;
+
 	/* Next three fields are for local node slot recovery during
 	 * mount. */
 	int dirty;

commit b4414eea0e7b9c134262c801a87e338bf675962c
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Thu Mar 11 18:31:09 2010 -0800

    ocfs2: Clear undo bits when local alloc is freed
    
    When the local alloc file changes windows, unused bits are freed back to the
    global bitmap. By defnition, those bits can not be in use by any file. Also,
    the local alloc will never have been able to allocate those bits if they
    were part of a previous truncate. Therefore it makes sense that we should
    clear unused local alloc bits in the undo buffer so that they can be used
    immediatly.
    
    [ Modified to call it ocfs2_release_clusters() -- Joel ]
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 1238b491db90..adf5e2ebc2c4 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -763,8 +763,18 @@ static inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,
 	return megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);
 }
 
-#define ocfs2_set_bit ext2_set_bit
-#define ocfs2_clear_bit ext2_clear_bit
+static inline void _ocfs2_set_bit(unsigned int bit, unsigned long *bitmap)
+{
+	ext2_set_bit(bit, bitmap);
+}
+#define ocfs2_set_bit(bit, addr) _ocfs2_set_bit((bit), (unsigned long *)(addr))
+
+static inline void _ocfs2_clear_bit(unsigned int bit, unsigned long *bitmap)
+{
+	ext2_clear_bit(bit, bitmap);
+}
+#define ocfs2_clear_bit(bit, addr) _ocfs2_clear_bit((bit), (unsigned long *)(addr))
+
 #define ocfs2_test_bit ext2_test_bit
 #define ocfs2_find_next_zero_bit ext2_find_next_zero_bit
 #define ocfs2_find_next_bit ext2_find_next_bit

commit 9df5778ecee8b301b447fc05706792d5f447ace5
Author: Tristan Ye <tristan.ye@oracle.com>
Date:   Tue Mar 2 13:59:42 2010 +0800

    Ocfs2: Move ocfs2 ioctl definitions from ocfs2_fs.h to newly added ocfs2_ioctl.h
    
    Currently we were adding ioctl cmds/structures for ocfs2 into ocfs2_fs.h
    which was used for define ocfs2 on-disk layout. That sounds a little bit
    confusing, and it may be quickly polluted espcially when growing the
    ocfs2_info_request ioctls afterwards(it will grow i bet).
    
    As a result, such OCFS2 IOCs do need to be placed somewhere other than
    ocfs2_fs.h, a separated ocfs2_ioctl.h will be added to store such ioctl
    structures and definitions which could also be used from userspace to
    invoke ioctls call.
    
    Signed-off-by: Tristan Ye <tristan.ye@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index b27fe2489e0c..1238b491db90 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -42,6 +42,7 @@
 
 #include "ocfs2_fs.h"
 #include "ocfs2_lockid.h"
+#include "ocfs2_ioctl.h"
 
 /* For struct ocfs2_blockcheck_stats */
 #include "blockcheck.h"

commit c0e4133851ed94c73ee3d34a2f2a245fcd0a60a1
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Jan 29 14:46:44 2010 -0800

    ocfs2: Attach the connection to the lksb
    
    We're going to want it in the ast functions, so we convert union
    ocfs2_dlm_lksb to struct ocfs2_dlm_lksb and let it carry the connection.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 8857dd724f90..b27fe2489e0c 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -159,7 +159,7 @@ struct ocfs2_lock_res {
 	int                      l_level;
 	unsigned int             l_ro_holders;
 	unsigned int             l_ex_holders;
-	union ocfs2_dlm_lksb     l_lksb;
+	struct ocfs2_dlm_lksb    l_lksb;
 
 	/* used from AST/BAST funcs. */
 	enum ocfs2_ast_action    l_action;

commit b89c54282db0c8634a2d2dc200f196d571750ce5
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Mon Jan 25 14:11:06 2010 +0800

    ocfs2: add extent block stealing for ocfs2 v5
    
    This patch add extent block (metadata) stealing mechanism for
    extent allocation. This mechanism is same as the inode stealing.
    if no room in slot specific extent_alloc, we will try to
    allocate extent block from the next slot.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Acked-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 740f448041e2..8857dd724f90 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -305,7 +305,9 @@ struct ocfs2_super
 	u32 s_next_generation;
 	unsigned long osb_flags;
 	s16 s_inode_steal_slot;
+	s16 s_meta_steal_slot;
 	atomic_t s_num_inodes_stolen;
+	atomic_t s_num_meta_stolen;
 
 	unsigned long s_mount_opt;
 	unsigned int s_atime_quantum;
@@ -760,33 +762,6 @@ static inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,
 	return megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);
 }
 
-static inline void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)
-{
-	spin_lock(&osb->osb_lock);
-	osb->s_inode_steal_slot = OCFS2_INVALID_SLOT;
-	spin_unlock(&osb->osb_lock);
-	atomic_set(&osb->s_num_inodes_stolen, 0);
-}
-
-static inline void ocfs2_set_inode_steal_slot(struct ocfs2_super *osb,
-					      s16 slot)
-{
-	spin_lock(&osb->osb_lock);
-	osb->s_inode_steal_slot = slot;
-	spin_unlock(&osb->osb_lock);
-}
-
-static inline s16 ocfs2_get_inode_steal_slot(struct ocfs2_super *osb)
-{
-	s16 slot;
-
-	spin_lock(&osb->osb_lock);
-	slot = osb->s_inode_steal_slot;
-	spin_unlock(&osb->osb_lock);
-
-	return slot;
-}
-
 #define ocfs2_set_bit ext2_set_bit
 #define ocfs2_clear_bit ext2_clear_bit
 #define ocfs2_test_bit ext2_test_bit

commit a19128260107f951d1b4c421cf98b92f8092b069
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Thu Jan 21 10:50:03 2010 -0800

    ocfs2: Prevent a livelock in dlmglue
    
    There is possibility of a livelock in __ocfs2_cluster_lock(). If a node were
    to get an ast for an upconvert request, followed immediately by a bast,
    there is a small window where the fs may downconvert the lock before the
    process requesting the upconvert is able to take the lock.
    
    This patch adds a new flag to indicate that the upconvert is still in
    progress and that the dc thread should not downconvert it right now.
    
    Wengang Wang <wen.gang.wang@oracle.com> and Joel Becker
    <joel.becker@oracle.com> contributed heavily to this patch.
    
    Reported-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 9362eea7424b..740f448041e2 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -136,6 +136,10 @@ enum ocfs2_unlock_action {
 #define OCFS2_LOCK_PENDING       (0x00000400) /* This lockres is pending a
 						 call to dlm_lock.  Only
 						 exists with BUSY set. */
+#define OCFS2_LOCK_UPCONVERT_FINISHING (0x00000800) /* blocks the dc thread
+						     * from downconverting
+						     * before the upconvert
+						     * has completed */
 
 struct ocfs2_lock_res_ops;
 

commit 45e62974fb110da926e2a6c5b357c15639bdc233
Merge: 756fe285070f 8ff6af881dec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 24 12:59:11 2009 -0800

    Merge branch 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jlbec/ocfs2
    
    * 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jlbec/ocfs2:
      ocfs2/trivial: Use le16_to_cpu for a disk value in xattr.c
      ocfs2/trivial: Use proper mask for 2 places in hearbeat.c
      Ocfs2: Let ocfs2 support fiemap for symlink and fast symlink.
      Ocfs2: Should ocfs2 support fiemap for S_IFDIR inode?
      ocfs2: Use FIEMAP_EXTENT_SHARED
      fiemap: Add new extent flag FIEMAP_EXTENT_SHARED
      ocfs2: replace u8 by __u8 in ocfs2_fs.h
      ocfs2: explicit declare uninitialized var in user_cluster_connect()
      ocfs2-devel: remove redundant OCFS2_MOUNT_POSIX_ACL check in ocfs2_get_acl_nolock()
      ocfs2: return -EAGAIN instead of EAGAIN in dlm
      ocfs2/cluster: Make fence method configurable - v2
      ocfs2: Set MS_POSIXACL on remount
      ocfs2: Make acl use the default
      ocfs2: Always include ACL support

commit 7aee47b0bb9f93baecdbea205e878fe0f155f7da
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Fri Nov 6 14:50:22 2009 -0800

    ocfs2: Trivial cleanup of jbd compatibility layer removal
    
    Mainline commit 53ef99cad9878f02f27bb30bc304fc42af8bdd6e removed the
    JBD compatibility layer from OCFS2. This patch removes the last remaining
    remnants of that.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index eae404602424..d963d8638709 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -35,12 +35,7 @@
 #include <linux/kref.h>
 #include <linux/mutex.h>
 #include <linux/lockdep.h>
-#ifndef CONFIG_OCFS2_COMPAT_JBD
-# include <linux/jbd2.h>
-#else
-# include <linux/jbd.h>
-# include "ocfs2_jbd_compat.h"
-#endif
+#include <linux/jbd2.h>
 
 /* For union ocfs2_dlm_lksb */
 #include "stackglue.h"

commit 5297aad80cd3a3e62116e0a0b29116ccd8ae397d
Author: Jan Kara <jack@suse.cz>
Date:   Thu Oct 15 14:54:04 2009 +0200

    ocfs2: Make acl use the default
    
    Change acl mount options handling to match the one of XFS and BTRFS and
    hopefully it is also easier to use now. When admin does not specify any
    acl mount option, acls are enabled if and only if the filesystem has
    xattr feature enabled. If admin specifies 'acl' mount option, we fail
    the mount if the filesystem does not have xattr feature and thus acls
    cannot be enabled.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index eae404602424..35ad46cf89b3 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -250,9 +250,11 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_LOCALFLOCKS = 1 << 5, /* No cluster aware user file locks */
 	OCFS2_MOUNT_NOUSERXATTR = 1 << 6, /* No user xattr */
 	OCFS2_MOUNT_INODE64 = 1 << 7,	/* Allow inode numbers > 2^32 */
-	OCFS2_MOUNT_POSIX_ACL = 1 << 8,	/* POSIX access control lists */
-	OCFS2_MOUNT_USRQUOTA = 1 << 9, /* We support user quotas */
-	OCFS2_MOUNT_GRPQUOTA = 1 << 10, /* We support group quotas */
+	OCFS2_MOUNT_POSIX_ACL = 1 << 8,	/* Force POSIX access control lists */
+	OCFS2_MOUNT_NO_POSIX_ACL = 1 << 9,	/* Disable POSIX access
+						   control lists */
+	OCFS2_MOUNT_USRQUOTA = 1 << 10, /* We support user quotas */
+	OCFS2_MOUNT_GRPQUOTA = 1 << 11, /* We support group quotas */
 };
 
 #define OCFS2_OSB_SOFT_RO			0x0001

commit 1aa75fea64bc26bda9be9b1b20ae253d7a481877
Author: Tao Ma <tao.ma@oracle.com>
Date:   Tue Aug 18 11:28:39 2009 +0800

    ocfs2: Add functions for extents refcounted.
    
    Add function ocfs2_mark_extent_refcounted which can mark
    an extent refcounted.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index bb5357376ef5..eae404602424 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -516,6 +516,13 @@ static inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)
 	ocfs2_set_links_count(di, links);
 }
 
+static inline int ocfs2_refcount_tree(struct ocfs2_super *osb)
+{
+	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_REFCOUNT_TREE)
+		return 1;
+	return 0;
+}
+
 /* set / clear functions because cluster events can make these happen
  * in parallel so we want the transitions to be atomic. this also
  * means that any future flags osb_flags must be protected by spinlock

commit 374a263e790c4de85844283c098810a92985f623
Author: Tao Ma <tao.ma@oracle.com>
Date:   Mon Aug 24 11:13:37 2009 +0800

    ocfs2: Add refcount tree lock mechanism.
    
    Implement locking around struct ocfs2_refcount_tree.  This protects
    all read/write operations on refcount trees.  ocfs2_refcount_tree
    has its own lock and its own caching_info, protecting buffers among
    multiple nodes.
    
    User must call ocfs2_lock_refcount_tree before his operation on
    the tree and unlock it after that.
    
    ocfs2_refcount_trees are referenced by the block number of the
    refcount tree root block, So we create an rb-tree on the ocfs2_super
    to look them up.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 6688d19e4451..bb5357376ef5 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -408,6 +408,10 @@ struct ocfs2_super
 
 	/* the group we used to allocate inodes. */
 	u64				osb_inode_alloc_group;
+
+	/* rb tree root for refcount lock. */
+	struct rb_root	osb_rf_lock_tree;
+	struct ocfs2_refcount_tree *osb_ref_tree_lru;
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)

commit f2c870e3b12e38da6d9b5b17c4c8ae56a0ed68e4
Author: Tao Ma <tao.ma@oracle.com>
Date:   Tue Aug 18 11:19:26 2009 +0800

    ocfs2: Add ocfs2_read_refcount_block.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index d370262b3621..6688d19e4451 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -610,6 +610,9 @@ static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)
 #define OCFS2_IS_VALID_DX_LEAF(ptr)					\
 	(!strcmp((ptr)->dl_signature, OCFS2_DX_LEAF_SIGNATURE))
 
+#define OCFS2_IS_VALID_REFCOUNT_BLOCK(ptr)				\
+	(!strcmp((ptr)->rf_signature, OCFS2_REFCOUNT_BLOCK_SIGNATURE))
+
 static inline unsigned long ino_from_blkno(struct super_block *sb,
 					   u64 blkno)
 {

commit 0cf2f7632b1789b811ab20b611c4156e6de2b055
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Feb 12 16:41:25 2009 -0800

    ocfs2: Pass struct ocfs2_caching_info to the journal functions.
    
    The next step in divorcing metadata I/O management from struct inode is
    to pass struct ocfs2_caching_info to the journal functions.  Thus the
    journal locks a metadata cache with the cache io_lock function.  It also
    can compare ci_last_trans and ci_created_trans directly.
    
    This is a large patch because of all the places we change
    ocfs2_journal_access..(handle, inode, ...) to
    ocfs2_journal_access..(handle, INODE_CACHE(inode), ...).
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 18b5fea98c91..d370262b3621 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -91,6 +91,11 @@ struct ocfs2_caching_info {
 		struct rb_root	ci_tree;
 	} ci_cache;
 };
+/*
+ * Need this prototype here instead of in uptodate.h because journal.h
+ * uses it.
+ */
+struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci);
 
 /* this limits us to 256 nodes
  * if we need more, we can do a kmalloc for the map */
@@ -408,7 +413,8 @@ struct ocfs2_super
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)
 
 /* Useful typedef for passing around journal access functions */
-typedef int (*ocfs2_journal_access_func)(handle_t *handle, struct inode *inode,
+typedef int (*ocfs2_journal_access_func)(handle_t *handle,
+					 struct ocfs2_caching_info *ci,
 					 struct buffer_head *bh, int type);
 
 static inline int ocfs2_should_order_data(struct inode *inode)

commit 292dd27ec76b96cebcef576f330ab121f59ccf05
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Feb 12 15:41:59 2009 -0800

    ocfs2: move ip_created_trans to struct ocfs2_caching_info
    
    Similar ip_last_trans, ip_created_trans tracks the creation of a journal
    managed inode.  This specifically tracks what transaction created the
    inode.  This is so the code can know if the inode has ever been written
    to disk.
    
    This behavior is desirable for any journal managed object.  We move it
    to struct ocfs2_caching_info as ci_created_trans so that any object
    using ocfs2_caching_info can rely on this behavior.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index c9bd7ce30ba6..18b5fea98c91 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -77,6 +77,9 @@ struct ocfs2_caching_info {
 	 */
 	const struct ocfs2_caching_operations *ci_ops;
 
+	/* next two are protected by trans_inc_lock */
+	/* which transaction were we created on? Zero if none. */
+	unsigned long		ci_created_trans;
 	/* last transaction we were a part of. */
 	unsigned long		ci_last_trans;
 

commit 66fb345ddd2d343e36692da0ff66126d7a99dc1b
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Feb 12 15:24:40 2009 -0800

    ocfs2: move ip_last_trans to struct ocfs2_caching_info
    
    We have the read side of metadata caching isolated to struct
    ocfs2_caching_info, now we need the write side.  This means the journal
    functions.  The journal only does a couple of things with struct inode.
    
    This change moves the ip_last_trans field onto struct
    ocfs2_caching_info as ci_last_trans.  This field tells the journal
    whether a pending journal flush is required.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 6e54a496299e..c9bd7ce30ba6 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -77,6 +77,10 @@ struct ocfs2_caching_info {
 	 */
 	const struct ocfs2_caching_operations *ci_ops;
 
+	/* last transaction we were a part of. */
+	unsigned long		ci_last_trans;
+
+	/* Cache structures */
 	unsigned int		ci_flags;
 	unsigned int		ci_num_cached;
 	union {

commit 6e5a3d7538ad4e46a976862f593faf65750e37cc
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Feb 10 19:00:37 2009 -0800

    ocfs2: Change metadata caching locks to an operations structure.
    
    We don't really want to cart around too many new fields on the
    ocfs2_caching_info structure.  So let's wrap all our access of the
    parent object in a set of operations.  One pointer on caching_info, and
    more flexibility to boot.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index eef3bd077c10..6e54a496299e 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -68,14 +68,14 @@ enum ocfs2_caching_info_flags {
 	OCFS2_CACHE_FL_INLINE	= 1<<1,
 };
 
+struct ocfs2_caching_operations;
 struct ocfs2_caching_info {
 	/*
 	 * The parent structure provides the locks, but because the
-	 * parent structure can differ, struct ocfs2_caching_info needs
-	 * its own pointers to them.
+	 * parent structure can differ, it provides locking operations
+	 * to struct ocfs2_caching_info.
 	 */
-	spinlock_t		*ci_lock;
-	struct mutex		*ci_io_mutex;
+	const struct ocfs2_caching_operations *ci_ops;
 
 	unsigned int		ci_flags;
 	unsigned int		ci_num_cached;

commit 47460d65a483529b3bc2bf6ccf461ad45f94df83
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Feb 10 16:05:07 2009 -0800

    ocfs2: Make the ocfs2_caching_info structure self-contained.
    
    We want to use the ocfs2_caching_info structure in places that are not
    inodes.  To do that, it can no longer rely on referencing the inode
    directly.
    
    This patch moves the flags to ocfs2_caching_info->ci_flags, stores
    pointers to the parent's locks on the ocfs2_caching_info, and renames
    the constants and flags to reflect its independant state.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 39e1d5a39505..eef3bd077c10 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -51,17 +51,36 @@
 /* For struct ocfs2_blockcheck_stats */
 #include "blockcheck.h"
 
+
+/* Caching of metadata buffers */
+
 /* Most user visible OCFS2 inodes will have very few pieces of
  * metadata, but larger files (including bitmaps, etc) must be taken
  * into account when designing an access scheme. We allow a small
  * amount of inlined blocks to be stored on an array and grow the
  * structure into a rb tree when necessary. */
-#define OCFS2_INODE_MAX_CACHE_ARRAY 2
+#define OCFS2_CACHE_INFO_MAX_ARRAY 2
+
+/* Flags for ocfs2_caching_info */
+
+enum ocfs2_caching_info_flags {
+	/* Indicates that the metadata cache is using the inline array */
+	OCFS2_CACHE_FL_INLINE	= 1<<1,
+};
 
 struct ocfs2_caching_info {
+	/*
+	 * The parent structure provides the locks, but because the
+	 * parent structure can differ, struct ocfs2_caching_info needs
+	 * its own pointers to them.
+	 */
+	spinlock_t		*ci_lock;
+	struct mutex		*ci_io_mutex;
+
+	unsigned int		ci_flags;
 	unsigned int		ci_num_cached;
 	union {
-		sector_t	ci_array[OCFS2_INODE_MAX_CACHE_ARRAY];
+	sector_t	ci_array[OCFS2_CACHE_INFO_MAX_ARRAY];
 		struct rb_root	ci_tree;
 	} ci_cache;
 };

commit f7b1aa69be138ad9d7d3f31fa56f4c9407f56b6a
Author: Jan Kara <jack@suse.cz>
Date:   Mon Jul 20 12:12:36 2009 +0200

    ocfs2: Fix deadlock on umount
    
    In commit ea455f8ab68338ba69f5d3362b342c115bea8e13, we moved the dentry lock
    put process into ocfs2_wq. This causes problems during umount because ocfs2_wq
    can drop references to inodes while they are being invalidated by
    invalidate_inodes() causing all sorts of nasty things (invalidate_inodes()
    ending in an infinite loop, "Busy inodes after umount" messages etc.).
    
    We fix the problem by stopping ocfs2_wq from doing any further releasing of
    inode references on the superblock being unmounted, wait until it finishes
    the current round of releasing and finally cleaning up all the references in
    dentry_lock_list from ocfs2_put_super().
    
    The issue was tracked down by Tao Ma <tao.ma@oracle.com>.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index c9345ebb8493..39e1d5a39505 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -224,10 +224,12 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_GRPQUOTA = 1 << 10, /* We support group quotas */
 };
 
-#define OCFS2_OSB_SOFT_RO	0x0001
-#define OCFS2_OSB_HARD_RO	0x0002
-#define OCFS2_OSB_ERROR_FS	0x0004
-#define OCFS2_DEFAULT_ATIME_QUANTUM	60
+#define OCFS2_OSB_SOFT_RO			0x0001
+#define OCFS2_OSB_HARD_RO			0x0002
+#define OCFS2_OSB_ERROR_FS			0x0004
+#define OCFS2_OSB_DROP_DENTRY_LOCK_IMMED	0x0008
+
+#define OCFS2_DEFAULT_ATIME_QUANTUM		60
 
 struct ocfs2_journal;
 struct ocfs2_slot_info;
@@ -490,6 +492,18 @@ static inline void ocfs2_set_osb_flag(struct ocfs2_super *osb,
 	spin_unlock(&osb->osb_lock);
 }
 
+
+static inline unsigned long  ocfs2_test_osb_flag(struct ocfs2_super *osb,
+						 unsigned long flag)
+{
+	unsigned long ret;
+
+	spin_lock(&osb->osb_lock);
+	ret = osb->osb_flags & flag;
+	spin_unlock(&osb->osb_lock);
+	return ret;
+}
+
 static inline void ocfs2_set_ro_flag(struct ocfs2_super *osb,
 				     int hard)
 {

commit cb25797d451dc774d9dbc402a65f16a0e32199fe
Author: Jan Kara <jack@suse.cz>
Date:   Thu Jun 4 15:26:50 2009 +0200

    ocfs2: Add lockdep annotations
    
    Add lockdep support to OCFS2. The support also covers all of the cluster
    locks except for open locks, journal locks, and local quotafile locks. These
    are special because they are acquired for a node, not for a particular process
    and lockdep cannot deal with such type of locking.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 60e89503ce5a..c9345ebb8493 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -34,6 +34,7 @@
 #include <linux/workqueue.h>
 #include <linux/kref.h>
 #include <linux/mutex.h>
+#include <linux/lockdep.h>
 #ifndef CONFIG_OCFS2_COMPAT_JBD
 # include <linux/jbd2.h>
 #else
@@ -152,6 +153,9 @@ struct ocfs2_lock_res {
 	unsigned int		 l_lock_max_exmode; 	   /* Max wait for EX */
 	unsigned int		 l_lock_refresh;	   /* Disk refreshes */
 #endif
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	 l_lockdep_map;
+#endif
 };
 
 enum ocfs2_orphan_scan_state {

commit 692684e19e317a374c18e70a44d6413e51f71c11
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Fri Jun 19 16:53:17 2009 -0700

    ocfs2: Stop orphan scan as early as possible during umount
    
    Currently if the orphan scan fires a tick before the user issues the umount,
    the umount will wait for the queued orphan scan tasks to complete.
    
    This patch makes the umount stop the orphan scan as early as possible so as
    to reduce the probability of the queued tasks slowing down the umount.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 18c1d9ec1c93..60e89503ce5a 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -154,6 +154,11 @@ struct ocfs2_lock_res {
 #endif
 };
 
+enum ocfs2_orphan_scan_state {
+	ORPHAN_SCAN_ACTIVE,
+	ORPHAN_SCAN_INACTIVE
+};
+
 struct ocfs2_orphan_scan {
 	struct mutex 		os_lock;
 	struct ocfs2_super 	*os_osb;
@@ -162,6 +167,7 @@ struct ocfs2_orphan_scan {
 	struct timespec		os_scantime;  /* time this node ran the scan */
 	u32			os_count;      /* tracks node specific scans */
 	u32  			os_seqno;       /* tracks cluster wide scans */
+	atomic_t		os_state;              /* ACTIVE or INACTIVE */
 };
 
 struct ocfs2_dlm_debug {

commit 73be192b17e43b6dc4f492dab41d70ab5b9d2908
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Jan 6 14:57:08 2009 -0800

    ocfs2: Add statistics for the checksum and ecc operations.
    
    It would be nice to know how often we get checksum failures.  Even
    better, how many of them we can fix with the single bit ecc.  So, we add
    a statistics structure.  The structure can be installed into debugfs
    wherever the user wants.
    
    For ocfs2, we'll put it in the superblock-specific debugfs directory and
    pass it down from our higher-level functions.  The stats are only
    registered with debugfs when the filesystem supports metadata ecc.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index ab285be023b2..18c1d9ec1c93 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -47,6 +47,9 @@
 #include "ocfs2_fs.h"
 #include "ocfs2_lockid.h"
 
+/* For struct ocfs2_blockcheck_stats */
+#include "blockcheck.h"
+
 /* Most user visible OCFS2 inodes will have very few pieces of
  * metadata, but larger files (including bitmaps, etc) must be taken
  * into account when designing an access scheme. We allow a small
@@ -305,6 +308,7 @@ struct ocfs2_super
 	struct ocfs2_dinode *local_alloc_copy;
 	struct ocfs2_quota_recovery *quota_rec;
 
+	struct ocfs2_blockcheck_stats osb_ecc_stats;
 	struct ocfs2_alloc_stats alloc_stats;
 	char dev_str[20];		/* "major,minor" of the device */
 

commit 15633a220ffe74fc61bc8117e6a89a494011ea3d
Author: Srinivas Eeda <srinivas.eeda@oracle.com>
Date:   Wed Jun 3 17:02:56 2009 -0700

    ocfs2 patch to track delayed orphan scan timer statistics
    
    Patch to track delayed orphan scan timer statistics.
    
    Modifies ocfs2_osb_dump to print the following:
      Orphan Scan=> Local: 10  Global: 21  Last Scan: 67 seconds ago
    
    Signed-off-by: Srinivas Eeda <srinivas.eeda@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 1fde52c96d25..ab285be023b2 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -156,7 +156,9 @@ struct ocfs2_orphan_scan {
 	struct ocfs2_super 	*os_osb;
 	struct ocfs2_lock_res 	os_lockres;     /* lock to synchronize scans */
 	struct delayed_work 	os_orphan_scan_work;
-	u32  			os_seqno;       /* incremented on every scan */
+	struct timespec		os_scantime;  /* time this node ran the scan */
+	u32			os_count;      /* tracks node specific scans */
+	u32  			os_seqno;       /* tracks cluster wide scans */
 };
 
 struct ocfs2_dlm_debug {

commit 83273932fbefb6ceef9c0b82ac4d23900728f4d9
Author: Srinivas Eeda <srinivas.eeda@oracle.com>
Date:   Wed Jun 3 17:02:55 2009 -0700

    ocfs2: timer to queue scan of all orphan slots
    
    When a dentry is unlinked, the unlinking node takes an EX on the dentry lock
    before moving the dentry to the orphan directory. Other nodes that have
    this dentry in cache have a PR on the same dentry lock.  When the EX is
    requested, the other nodes flag the corresponding inode as MAYBE_ORPHANED
    during downconvert.  The inode is finally deleted when the last node to iput
    the inode sees that i_nlink==0 and the MAYBE_ORPHANED flag is set.
    
    A problem arises if a node is forced to free dentry locks because of memory
    pressure. If this happens, the node will no longer get downconvert
    notifications for the dentries that have been unlinked on another node.
    If it also happens that node is actively using the corresponding inode and
    happens to be the one performing the last iput on that inode, it will fail
    to delete the inode as it will not have the MAYBE_ORPHANED flag set.
    
    This patch fixes this shortcoming by introducing a periodic scan of the
    orphan directories to delete such inodes. Care has been taken to distribute
    the workload across the cluster so that no one node has to perform the task
    all the time.
    
    Signed-off-by: Srinivas Eeda <srinivas.eeda@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 1386281950db..1fde52c96d25 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -151,6 +151,14 @@ struct ocfs2_lock_res {
 #endif
 };
 
+struct ocfs2_orphan_scan {
+	struct mutex 		os_lock;
+	struct ocfs2_super 	*os_osb;
+	struct ocfs2_lock_res 	os_lockres;     /* lock to synchronize scans */
+	struct delayed_work 	os_orphan_scan_work;
+	u32  			os_seqno;       /* incremented on every scan */
+};
+
 struct ocfs2_dlm_debug {
 	struct kref d_refcnt;
 	struct dentry *d_locking_state;
@@ -341,6 +349,8 @@ struct ocfs2_super
 	unsigned int			*osb_orphan_wipes;
 	wait_queue_head_t		osb_wipe_event;
 
+	struct ocfs2_orphan_scan	osb_orphan_scan;
+
 	/* used to protect metaecc calculation check of xattr. */
 	spinlock_t osb_xattr_lock;
 

commit 9140db04ef185f934acf2b1b15b3dd5e6a6bfc22
Author: Srinivas Eeda <srinivas.eeda@oracle.com>
Date:   Fri Mar 6 14:21:46 2009 -0800

    ocfs2: recover orphans in offline slots during recovery and mount
    
    During recovery, a node recovers orphans in it's slot and the dead node(s). But
    if the dead nodes were holding orphans in offline slots, they will be left
    unrecovered.
    
    If the dead node is the last one to die and is holding orphans in other slots
    and is the first one to mount, then it only recovers it's own slot, which
    leaves orphans in offline slots.
    
    This patch queues complete_recovery to clean orphans for all offline slots
    during mount and node recovery.
    
    Signed-off-by: Srinivas Eeda <srinivas.eeda@oracle.com>
    Acked-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 558bd2709e01..1386281950db 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -209,6 +209,7 @@ enum ocfs2_mount_options
 struct ocfs2_journal;
 struct ocfs2_slot_info;
 struct ocfs2_recovery_map;
+struct ocfs2_replay_map;
 struct ocfs2_quota_recovery;
 struct ocfs2_dentry_lock;
 struct ocfs2_super
@@ -264,6 +265,7 @@ struct ocfs2_super
 	atomic_t vol_state;
 	struct mutex recovery_lock;
 	struct ocfs2_recovery_map *recovery_map;
+	struct ocfs2_replay_map *replay_map;
 	struct task_struct *recovery_thread_task;
 	int disable_recovery;
 	wait_queue_head_t checkpoint_event;

commit 6ca497a83e592d64e050c4d04b6dedb8c915f39a
Author: wengang wang <wen.gang.wang@oracle.com>
Date:   Fri Mar 6 21:29:10 2009 +0800

    ocfs2: fix rare stale inode errors when exporting via nfs
    
    For nfs exporting, ocfs2_get_dentry() returns the dentry for fh.
    ocfs2_get_dentry() may read from disk when the inode is not in memory,
    without any cross cluster lock. this leads to the file system loading a
    stale inode.
    
    This patch fixes above problem.
    
    Solution is that in case of inode is not in memory, we get the cluster
    lock(PR) of alloc inode where the inode in question is allocated from (this
    causes node on which deletion is done sync the alloc inode) before reading
    out the inode itsself. then we check the bitmap in the group (the inode in
    question allcated from) to see if the bit is clear. if it's clear then it's
    stale. if the bit is set, we then check generation as the existing code
    does.
    
    We have to read out the inode in question from disk first to know its alloc
    slot and allot bit. And if its not stale we read it out using ocfs2_iget().
    The second read should then be from cache.
    
    And also we have to add a per superblock nfs_sync_lock to cover the lock for
    alloc inode and that for inode in question. this is because ocfs2_get_dentry()
    and ocfs2_delete_inode() lock on them in reverse order. nfs_sync_lock is locked
    in EX mode in ocfs2_get_dentry() and in PR mode in ocfs2_delete_inode(). so
    that mutliple ocfs2_delete_inode() can run concurrently in normal case.
    
    [mfasheh@suse.com: build warning fixes and comment cleanups]
    Signed-off-by: Wengang Wang <wen.gang.wang@oracle.com>
    Acked-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index b65d19c9756d..558bd2709e01 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -300,6 +300,7 @@ struct ocfs2_super
 	struct ocfs2_cluster_connection *cconn;
 	struct ocfs2_lock_res osb_super_lockres;
 	struct ocfs2_lock_res osb_rename_lockres;
+	struct ocfs2_lock_res osb_nfs_sync_lockres;
 	struct ocfs2_dlm_debug *osb_dlm_debug;
 
 	struct dentry *osb_debug_root;

commit feb473a6e8bd19297d0f3bb377b25055c0228c0a
Author: Tao Ma <tao.ma@oracle.com>
Date:   Wed Feb 25 00:53:25 2009 +0800

    ocfs2: Optimize inode group allocation by recording last used group.
    
    In ocfs2, the block group search looks for the "emptiest" group
    to allocate from. So if the allocator has many equally(or almost
    equally) empty groups, new block group will tend to get spread
    out amongst them.
    
    So we add osb_inode_alloc_group in ocfs2_super to record the last
    used inode allocation group.
    For more details, please see
    http://oss.oracle.com/osswiki/OCFS2/DesignDocs/InodeAllocationStrategy.
    
    I have done some basic test and the results are a ten times improvement on
    some cold-cache stat workloads.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index e1844d5736c4..b65d19c9756d 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -343,6 +343,9 @@ struct ocfs2_super
 
 	unsigned int			osb_dx_mask;
 	u32				osb_dx_seed[4];
+
+	/* the group we used to allocate inodes. */
+	u64				osb_inode_alloc_group;
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)

commit 1d46dc08d33138c29c63d717807c08ab704fc773
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Thu Feb 19 13:17:05 2009 -0800

    ocfs2: fix leaf start calculation in ocfs2_dx_dir_rebalance()
    
    ocfs2_dx_dir_rebalance() is passed the block offset of a dx leaf which needs
    rebalancing. Since we rebalance an entire cluster at a time however, this
    function needs to calculate the beginning of that cluster, in blocks. The
    calculation was wrong, which would result in a read of non-leaf blocks. Fix
    the calculation by adding ocfs2_block_to_cluster_start() which is a more
    straight-forward way of determining this.
    
    Reported-by: Tristan Ye <tristan.ye@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index fa3c6d3f0bd2..e1844d5736c4 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -582,6 +582,16 @@ static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,
 	return (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;
 }
 
+static inline u64 ocfs2_block_to_cluster_start(struct super_block *sb,
+					       u64 blocks)
+{
+	int bits = OCFS2_SB(sb)->s_clustersize_bits - sb->s_blocksize_bits;
+	unsigned int clusters;
+
+	clusters = ocfs2_blocks_to_clusters(sb, blocks);
+	return (u64)clusters << bits;
+}
+
 static inline u64 ocfs2_align_bytes_to_clusters(struct super_block *sb,
 						u64 bytes)
 {

commit 198a1ca3b735986542c538e38b9499ffcaed7005
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Thu Nov 20 17:54:57 2008 -0800

    ocfs2: Increase max links count
    
    Since we've now got a directory format capable of handling a large number of
    entries, we can increase the maximum link count supported. This only gets
    increased if the directory indexing feature is turned on.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Acked-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 3749c32c2fc4..fa3c6d3f0bd2 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -408,6 +408,44 @@ static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)
 	return 0;
 }
 
+static inline unsigned int ocfs2_link_max(struct ocfs2_super *osb)
+{
+	if (ocfs2_supports_indexed_dirs(osb))
+		return OCFS2_DX_LINK_MAX;
+	return OCFS2_LINK_MAX;
+}
+
+static inline unsigned int ocfs2_read_links_count(struct ocfs2_dinode *di)
+{
+	u32 nlink = le16_to_cpu(di->i_links_count);
+	u32 hi = le16_to_cpu(di->i_links_count_hi);
+
+	if (di->i_dyn_features & cpu_to_le16(OCFS2_INDEXED_DIR_FL))
+		nlink |= (hi << OCFS2_LINKS_HI_SHIFT);
+
+	return nlink;
+}
+
+static inline void ocfs2_set_links_count(struct ocfs2_dinode *di, u32 nlink)
+{
+	u16 lo, hi;
+
+	lo = nlink;
+	hi = nlink >> OCFS2_LINKS_HI_SHIFT;
+
+	di->i_links_count = cpu_to_le16(lo);
+	di->i_links_count_hi = cpu_to_le16(hi);
+}
+
+static inline void ocfs2_add_links_count(struct ocfs2_dinode *di, int n)
+{
+	u32 links = ocfs2_read_links_count(di);
+
+	links += n;
+
+	ocfs2_set_links_count(di, links);
+}
+
 /* set / clear functions because cluster events can make these happen
  * in parallel so we want the transitions to be atomic. this also
  * means that any future flags osb_flags must be protected by spinlock

commit 9b7895efac906d66d19856194e1ba61f37e231a4
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Wed Nov 12 16:27:44 2008 -0800

    ocfs2: Add a name indexed b-tree to directory inodes
    
    This patch makes use of Ocfs2's flexible btree code to add an additional
    tree to directory inodes. The new tree stores an array of small,
    fixed-length records in each leaf block. Each record stores a hash value,
    and pointer to a block in the traditional (unindexed) directory tree where a
    dirent with the given name hash resides. Lookup exclusively uses this tree
    to find dirents, thus providing us with constant time name lookups.
    
    Some of the hashing code was copied from ext3. Unfortunately, it has lots of
    unfixed checkpatch errors. I left that as-is so that tracking changes would
    be easier.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Acked-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index a7c8369c402f..3749c32c2fc4 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -340,6 +340,9 @@ struct ocfs2_super
 
 	/* used to protect metaecc calculation check of xattr. */
 	spinlock_t osb_xattr_lock;
+
+	unsigned int			osb_dx_mask;
+	u32				osb_dx_seed[4];
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)
@@ -398,6 +401,13 @@ static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)
 	return 0;
 }
 
+static inline int ocfs2_supports_indexed_dirs(struct ocfs2_super *osb)
+{
+	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS)
+		return 1;
+	return 0;
+}
+
 /* set / clear functions because cluster events can make these happen
  * in parallel so we want the transitions to be atomic. this also
  * means that any future flags osb_flags must be protected by spinlock
@@ -478,6 +488,12 @@ static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)
 #define OCFS2_IS_VALID_DIR_TRAILER(ptr)					\
 	(!strcmp((ptr)->db_signature, OCFS2_DIR_TRAILER_SIGNATURE))
 
+#define OCFS2_IS_VALID_DX_ROOT(ptr)					\
+	(!strcmp((ptr)->dr_signature, OCFS2_DX_ROOT_SIGNATURE))
+
+#define OCFS2_IS_VALID_DX_LEAF(ptr)					\
+	(!strcmp((ptr)->dl_signature, OCFS2_DX_LEAF_SIGNATURE))
+
 static inline unsigned long ino_from_blkno(struct super_block *sb,
 					   u64 blkno)
 {

commit 59b526a30722f29e5dba6210a6e0fc34e3149b94
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Tue Dec 16 15:49:18 2008 -0800

    ocfs2: Remove debugfs file local_alloc_stats
    
    This patch removes the debugfs file local_alloc_stats as that information
    is now included in the fs_state debugfs file.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 18d8542a615e..a7c8369c402f 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -287,11 +287,6 @@ struct ocfs2_super
 
 	u64 la_last_gd;
 
-#ifdef CONFIG_OCFS2_FS_STATS
-	struct dentry *local_alloc_debug;
-	char *local_alloc_debug_buf;
-#endif
-
 	/* Next three fields are for local node slot recovery during
 	 * mount. */
 	int dirty;

commit 50397507e856455b3f5cb3d5c7c482209f9e46a0
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Wed Dec 17 14:17:43 2008 -0800

    ocfs2: Expose the file system state via debugfs
    
    This patch creates a per mount debugfs file, fs_state, which exposes
    information like, cluster stack in use, states of the downconvert, recovery
    and commit threads, number of journal txns, some allocation stats, list of
    all slots, etc.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 946d3c34b90b..18d8542a615e 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -308,6 +308,7 @@ struct ocfs2_super
 	struct ocfs2_dlm_debug *osb_dlm_debug;
 
 	struct dentry *osb_debug_root;
+	struct dentry *osb_ctxt;
 
 	wait_queue_head_t recovery_event;
 

commit c8b9cf9a7cd25ba65166116d0a958f0bc709f0a7
Author: Tao Ma <tao.ma@oracle.com>
Date:   Tue Feb 24 17:40:26 2009 -0800

    ocfs2: lock the metaecc process for xattr bucket
    
    For other metadata in ocfs2, metaecc is checked in ocfs2_read_blocks
    with io_mutex held. While for xattr bucket, it is calculated by
    the whole buckets. So we have to add a spin_lock to prevent multiple
    processes calculating metaecc.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Tested-by: Tristan Ye <tristan.ye@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 077384135f4e..946d3c34b90b 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -341,6 +341,9 @@ struct ocfs2_super
 	struct ocfs2_node_map		osb_recovering_orphan_dirs;
 	unsigned int			*osb_orphan_wipes;
 	wait_queue_head_t		osb_wipe_event;
+
+	/* used to protect metaecc calculation check of xattr. */
+	spinlock_t osb_xattr_lock;
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)

commit ea455f8ab68338ba69f5d3362b342c115bea8e13
Author: Jan Kara <jack@suse.cz>
Date:   Mon Jan 12 23:20:31 2009 +0100

    ocfs2: Push out dropping of dentry lock to ocfs2_wq
    
    Dropping of last reference to dentry lock is a complicated operation involving
    dropping of reference to inode. This can get complicated and quota code in
    particular needs to obtain some quota locks which leads to potential deadlock.
    Thus we defer dropping of inode reference to ocfs2_wq.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index ad5c24a29edd..077384135f4e 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -210,6 +210,7 @@ struct ocfs2_journal;
 struct ocfs2_slot_info;
 struct ocfs2_recovery_map;
 struct ocfs2_quota_recovery;
+struct ocfs2_dentry_lock;
 struct ocfs2_super
 {
 	struct task_struct *commit_task;
@@ -325,6 +326,11 @@ struct ocfs2_super
 	struct list_head blocked_lock_list;
 	unsigned long blocked_lock_count;
 
+	/* List of dentry locks to release. Anyone can add locks to
+	 * the list, ocfs2_wq processes the list  */
+	struct ocfs2_dentry_lock *dentry_lock_list;
+	struct work_struct dentry_lock_work;
+
 	wait_queue_head_t		osb_mount_event;
 
 	/* Truncate log info */

commit 87d35a74b15ec703910a63e0667692fb5e267be0
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Wed Dec 10 17:36:25 2008 -0800

    ocfs2: Add directory block trailers.
    
    Future ocfs2 features metaecc and indexed directories need to store a
    little bit of data in each dirblock.  For compatibility, we place this
    in a trailer at the end of the dirblock.  The trailer plays itself as an
    empty dirent, so that if the features are turned off, it can be reused
    without requiring a tunefs scan.
    
    This code adds the trailer and validates it when the block is read in.
    
    [ Mark is the original author, but I reinserted this code before his
      dir index work.  -- Joel ]
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index bad87d0a03c9..ad5c24a29edd 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -470,6 +470,9 @@ static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)
 #define OCFS2_IS_VALID_XATTR_BLOCK(ptr)					\
 	(!strcmp((ptr)->xb_signature, OCFS2_XATTR_BLOCK_SIGNATURE))
 
+#define OCFS2_IS_VALID_DIR_TRAILER(ptr)					\
+	(!strcmp((ptr)->db_signature, OCFS2_DIR_TRAILER_SIGNATURE))
+
 static inline unsigned long ino_from_blkno(struct super_block *sb,
 					   u64 blkno)
 {

commit 13723d00e374c2a6d6ccb5af6de965e89c3e1b01
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Oct 17 19:25:01 2008 -0700

    ocfs2: Use metadata-specific ocfs2_journal_access_*() functions.
    
    The per-metadata-type ocfs2_journal_access_*() functions hook up jbd2
    commit triggers and allow us to compute metadata ecc right before the
    buffers are written out.  This commit provides ecc for inodes, extent
    blocks, group descriptors, and quota blocks.  It is not safe to use
    extened attributes and metaecc at the same time yet.
    
    The ocfs2_extent_tree and ocfs2_path abstractions in alloc.c both hide
    the type of block at their root.  Before, it didn't matter, but now the
    root block must use the appropriate ocfs2_journal_access_*() function.
    To keep this abstract, the structures now have a pointer to the matching
    journal_access function and a wrapper call to call it.
    
    A few places use naked ocfs2_write_block() calls instead of adding the
    blocks to the journal.  We make sure to calculate their checksum and ecc
    before the write.
    
    Since we pass around the journal_access functions.  Let's typedef them
    in ocfs2.h.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 2bb389fe7397..bad87d0a03c9 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -339,6 +339,10 @@ struct ocfs2_super
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)
 
+/* Useful typedef for passing around journal access functions */
+typedef int (*ocfs2_journal_access_func)(handle_t *handle, struct inode *inode,
+					 struct buffer_head *bh, int type);
+
 static inline int ocfs2_should_order_data(struct inode *inode)
 {
 	if (!S_ISREG(inode->i_mode))

commit 70ad1ba7b48364d758a112df0823edc5ca6632aa
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Oct 16 17:54:25 2008 -0700

    ocfs2: Add the underlying blockcheck code.
    
    This is the code that computes crc32 and ecc for ocfs2 metadata blocks.
    There are high-level functions that check whether the filesystem has the
    ecc feature, mid-level functions that work on a single block or array of
    buffer_heads, and the low-level ecc hamming code that can handle
    multiple buffers like crc32_le().
    
    It's not hooked up to the filesystem yet.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 5c777988042f..2bb389fe7397 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -382,6 +382,13 @@ static inline int ocfs2_supports_xattr(struct ocfs2_super *osb)
 	return 0;
 }
 
+static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)
+{
+	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)
+		return 1;
+	return 0;
+}
+
 /* set / clear functions because cluster events can make these happen
  * in parallel so we want the transitions to be atomic. this also
  * means that any future flags osb_flags must be protected by spinlock
@@ -615,5 +622,6 @@ static inline s16 ocfs2_get_inode_steal_slot(struct ocfs2_super *osb)
 #define ocfs2_clear_bit ext2_clear_bit
 #define ocfs2_test_bit ext2_test_bit
 #define ocfs2_find_next_zero_bit ext2_find_next_zero_bit
+#define ocfs2_find_next_bit ext2_find_next_bit
 #endif  /* OCFS2_H */
 

commit 19ece546a418997226bd91552fbc41abcb05cea6
Author: Jan Kara <jack@suse.cz>
Date:   Thu Aug 21 20:13:17 2008 +0200

    ocfs2: Enable quota accounting on mount, disable on umount
    
    Enable quota usage tracking on mount and disable it on umount. Also
    add support for quota on and quota off quotactls and usrquota and
    grpquota mount options. Add quota features among supported ones.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 6b25b4aa7205..5c777988042f 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -161,6 +161,7 @@ enum ocfs2_vol_state
 {
 	VOLUME_INIT = 0,
 	VOLUME_MOUNTED,
+	VOLUME_MOUNTED_QUOTAS,
 	VOLUME_DISMOUNTED,
 	VOLUME_DISABLED
 };
@@ -196,6 +197,8 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_NOUSERXATTR = 1 << 6, /* No user xattr */
 	OCFS2_MOUNT_INODE64 = 1 << 7,	/* Allow inode numbers > 2^32 */
 	OCFS2_MOUNT_POSIX_ACL = 1 << 8,	/* POSIX access control lists */
+	OCFS2_MOUNT_USRQUOTA = 1 << 9, /* We support user quotas */
+	OCFS2_MOUNT_GRPQUOTA = 1 << 10, /* We support group quotas */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001

commit 2205363dce7447b8e85f1ead14387664c1a98753
Author: Jan Kara <jack@suse.cz>
Date:   Mon Oct 20 23:50:38 2008 +0200

    ocfs2: Implement quota recovery
    
    Implement functions for recovery after a crash. Functions just
    read local quota file and sync info to global quota file.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index f04b229fc757..6b25b4aa7205 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -206,6 +206,7 @@ enum ocfs2_mount_options
 struct ocfs2_journal;
 struct ocfs2_slot_info;
 struct ocfs2_recovery_map;
+struct ocfs2_quota_recovery;
 struct ocfs2_super
 {
 	struct task_struct *commit_task;
@@ -287,10 +288,11 @@ struct ocfs2_super
 	char *local_alloc_debug_buf;
 #endif
 
-	/* Next two fields are for local node slot recovery during
+	/* Next three fields are for local node slot recovery during
 	 * mount. */
 	int dirty;
 	struct ocfs2_dinode *local_alloc_copy;
+	struct ocfs2_quota_recovery *quota_rec;
 
 	struct ocfs2_alloc_stats alloc_stats;
 	char dev_str[20];		/* "major,minor" of the device */

commit 5e96581a377fc6bd76e9b112da9aeb8a7ae8bf22
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Nov 13 14:49:16 2008 -0800

    ocfs2: Wrap extent block reads in a dedicated function.
    
    We weren't consistently checking extent blocks after we read them.
    Most places checked the signature, but none checked h_blkno or
    h_fs_signature.  Create a toplevel ocfs2_read_extent_block() that does
    the read and the validation.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 82ba887afa0d..f04b229fc757 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -447,14 +447,6 @@ static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)
 #define OCFS2_IS_VALID_EXTENT_BLOCK(ptr)				\
 	(!strcmp((ptr)->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE))
 
-#define OCFS2_RO_ON_INVALID_EXTENT_BLOCK(__sb, __eb)	do {		\
-	typeof(__eb) ____eb = (__eb);					\
-	ocfs2_error((__sb), 						\
-		"Extent Block # %llu has bad signature %.*s",		\
-		(unsigned long long)le64_to_cpu((____eb)->h_blkno), 7,	\
-		(____eb)->h_signature);					\
-} while (0)
-
 #define OCFS2_IS_VALID_GROUP_DESC(ptr)					\
 	(!strcmp((ptr)->bg_signature, OCFS2_GROUP_DESC_SIGNATURE))
 

commit 4203530613280281868b3ca36c817530bca3825c
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Nov 13 14:49:15 2008 -0800

    ocfs2: Morph the haphazard OCFS2_IS_VALID_GROUP_DESC() checks.
    
    Random places in the code would check a group descriptor bh to see if it
    was valid. The previous commit unified descriptor block reads,
    validating all block reads in the same place.  Thus, these checks are no
    longer necessary.  Rather than eliminate them, however, we change them
    to BUG_ON() checks.  This ensures the assumptions remain true.  All of
    the code paths to these checks have been audited to ensure they come
    from a validated descriptor read.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 467bdb6f71e1..82ba887afa0d 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -458,13 +458,6 @@ static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)
 #define OCFS2_IS_VALID_GROUP_DESC(ptr)					\
 	(!strcmp((ptr)->bg_signature, OCFS2_GROUP_DESC_SIGNATURE))
 
-#define OCFS2_RO_ON_INVALID_GROUP_DESC(__sb, __gd)	do {		\
-	typeof(__gd) ____gd = (__gd);					\
-		ocfs2_error((__sb),					\
-		"Group Descriptor # %llu has bad signature %.*s",	\
-		(unsigned long long)le64_to_cpu((____gd)->bg_blkno), 7, \
-		(____gd)->bg_signature);				\
-} while (0)
 
 #define OCFS2_IS_VALID_XATTR_BLOCK(ptr)					\
 	(!strcmp((ptr)->xb_signature, OCFS2_XATTR_BLOCK_SIGNATURE))

commit 10995aa2451afa20b721cc7de856cae1a13dba57
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Nov 13 14:49:12 2008 -0800

    ocfs2: Morph the haphazard OCFS2_IS_VALID_DINODE() checks.
    
    Random places in the code would check a dinode bh to see if it was
    valid.  Not only did they do different levels of validation, they
    handled errors in different ways.
    
    The previous commit unified inode block reads, validating all block
    reads in the same place.  Thus, these haphazard checks are no longer
    necessary.  Rather than eliminate them, however, we change them to
    BUG_ON() checks.  This ensures the assumptions remain true.  All of the
    code paths to these checks have been audited to ensure they come from a
    validated inode read.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 25d07ff1d3cd..467bdb6f71e1 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -444,14 +444,6 @@ static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)
 #define OCFS2_IS_VALID_DINODE(ptr)					\
 	(!strcmp((ptr)->i_signature, OCFS2_INODE_SIGNATURE))
 
-#define OCFS2_RO_ON_INVALID_DINODE(__sb, __di)	do {			\
-	typeof(__di) ____di = (__di);					\
-	ocfs2_error((__sb), 						\
-		"Dinode # %llu has bad signature %.*s",			\
-		(unsigned long long)le64_to_cpu((____di)->i_blkno), 7, 	\
-		(____di)->i_signature);					\
-} while (0)
-
 #define OCFS2_IS_VALID_EXTENT_BLOCK(ptr)				\
 	(!strcmp((ptr)->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE))
 

commit 929fb014e041c6572c5e8c3686f1e32742b5b953
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Fri Nov 14 11:17:04 2008 +0800

    ocfs2: add POSIX ACL API
    
    This patch adds POSIX ACL(access control lists) APIs in ocfs2. We convert
    struct posix_acl to many ocfs2_acl_entry and regard them as an extended
    attribute entry.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 3fed9e3d8992..25d07ff1d3cd 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -195,6 +195,7 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_LOCALFLOCKS = 1 << 5, /* No cluster aware user file locks */
 	OCFS2_MOUNT_NOUSERXATTR = 1 << 6, /* No user xattr */
 	OCFS2_MOUNT_INODE64 = 1 << 7,	/* Allow inode numbers > 2^32 */
+	OCFS2_MOUNT_POSIX_ACL = 1 << 8,	/* POSIX access control lists */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001

commit 3b5da0189c93160e44b878d2c72e9552d642497c
Author: Coly Li <coyli@suse.de>
Date:   Wed Nov 5 15:16:24 2008 +0800

    ocfs2: comments typo fix
    
    This patch fixes two typos in comments of ocfs2.
    
    Signed-off-by: Coly Li <coyli@suse.de>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index fef7ece32376..3fed9e3d8992 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -85,7 +85,7 @@ enum ocfs2_unlock_action {
 };
 
 /* ocfs2_lock_res->l_flags flags. */
-#define OCFS2_LOCK_ATTACHED      (0x00000001) /* have we initialized
+#define OCFS2_LOCK_ATTACHED      (0x00000001) /* we have initialized
 					       * the lvb */
 #define OCFS2_LOCK_BUSY          (0x00000002) /* we are currently in
 					       * dlm_lock */

commit f6087fb799e097e7c9d912daa75701de9d62dc53
Author: Joel Becker <joel.becker@oracle.com>
Date:   Mon Oct 20 18:20:43 2008 -0700

    ocfs2: Check xattr block signatures properly.
    
    The xattr.c code is currently memcmp()ing naking buffer pointers.
    Create the OCFS2_IS_VALID_XATTR_BLOCK() macro to match its peers and use
    that.
    
    In addition, failed signature checks were returning -EFAULT, which is
    completely wrong.  Return -EIO.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index a21a465490c4..fef7ece32376 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -473,6 +473,9 @@ static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)
 		(____gd)->bg_signature);				\
 } while (0)
 
+#define OCFS2_IS_VALID_XATTR_BLOCK(ptr)					\
+	(!strcmp((ptr)->xb_signature, OCFS2_XATTR_BLOCK_SIGNATURE))
+
 static inline unsigned long ino_from_blkno(struct super_block *sb,
 					   u64 blkno)
 {

commit 2b4e30fbde425828b17f0e9c8f8e3fd3ecb2bc75
Author: Joel Becker <joel.becker@oracle.com>
Date:   Wed Sep 3 20:03:41 2008 -0700

    ocfs2: Switch over to JBD2.
    
    ocfs2 wants JBD2 for many reasons, not the least of which is that JBD is
    limiting our maximum filesystem size.
    
    It's a pretty trivial change.  Most functions are just renamed.  The
    only functional change is moving to Jan's inode-based ordered data mode.
    It's better, too.
    
    Because JBD2 reads and writes JBD journals, this is compatible with any
    existing filesystem.  It can even interact with JBD-based ocfs2 as long
    as the journal is formated for JBD.
    
    We provide a compatibility option so that paranoid people can still use
    JBD for the time being.  This will go away shortly.
    
    [ Moved call of ocfs2_begin_ordered_truncate() from ocfs2_delete_inode() to
      ocfs2_truncate_for_delete(). --Mark ]
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 78ae4f87e6b0..a21a465490c4 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -34,7 +34,12 @@
 #include <linux/workqueue.h>
 #include <linux/kref.h>
 #include <linux/mutex.h>
-#include <linux/jbd.h>
+#ifndef CONFIG_OCFS2_COMPAT_JBD
+# include <linux/jbd2.h>
+#else
+# include <linux/jbd.h>
+# include "ocfs2_jbd_compat.h"
+#endif
 
 /* For union ocfs2_dlm_lksb */
 #include "stackglue.h"

commit 12462f1d9f0b96389497438dc2730c6f7410be82
Author: Joel Becker <joel.becker@oracle.com>
Date:   Wed Sep 3 20:03:40 2008 -0700

    ocfs2: Add the 'inode64' mount option.
    
    Now that ocfs2 limits inode numbers to 32bits, add a mount option to
    disable the limit.  This parallels XFS.  64bit systems can handle the
    larger inode numbers.
    
    [ Added description of inode64 mount option in ocfs2.txt. --Mark ]
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 6d3c10ddf489..78ae4f87e6b0 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -189,6 +189,7 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_DATA_WRITEBACK = 1 << 4, /* No data ordering */
 	OCFS2_MOUNT_LOCALFLOCKS = 1 << 5, /* No cluster aware user file locks */
 	OCFS2_MOUNT_NOUSERXATTR = 1 << 6, /* No user xattr */
+	OCFS2_MOUNT_INODE64 = 1 << 7,	/* Allow inode numbers > 2^32 */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001

commit 8154da3d2114241cf3edb108b43e2172be86d483
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Mon Aug 18 17:11:46 2008 +0800

    ocfs2: Add incompatible flag for extended attribute
    
    This patch adds the s_incompat flag for extended attribute support. This
    helps us ensure that older versions of Ocfs2 or ocfs2-tools will not be able
    to mount a volume with xattr support.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index cae0dd4b7f75..6d3c10ddf489 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -363,6 +363,13 @@ static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)
 	return 0;
 }
 
+static inline int ocfs2_supports_xattr(struct ocfs2_super *osb)
+{
+	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_XATTR)
+		return 1;
+	return 0;
+}
+
 /* set / clear functions because cluster events can make these happen
  * in parallel so we want the transitions to be atomic. this also
  * means that any future flags osb_flags must be protected by spinlock

commit cf1d6c763fbcb115263114302485ad17e7933d87
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Mon Aug 18 17:11:00 2008 +0800

    ocfs2: Add extended attribute support
    
    This patch implements storing extended attributes both in inode or a single
    external block. We only store EA's in-inode when blocksize > 512 or that
    inode block has free space for it. When an EA's value is larger than 80
    bytes, we will store the value via b-tree outside inode or block.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index ce75ca312a2d..cae0dd4b7f75 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -188,6 +188,7 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_ERRORS_PANIC = 1 << 3, /* Panic on errors */
 	OCFS2_MOUNT_DATA_WRITEBACK = 1 << 4, /* No data ordering */
 	OCFS2_MOUNT_LOCALFLOCKS = 1 << 5, /* No cluster aware user file locks */
+	OCFS2_MOUNT_NOUSERXATTR = 1 << 6, /* No user xattr */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001
@@ -218,6 +219,7 @@ struct ocfs2_super
 	u32 bitmap_cpg;
 	u8 *uuid;
 	char *uuid_str;
+	u32 uuid_hash;
 	u8 *vol_label;
 	u64 first_cluster_group_blkno;
 	u32 fs_generation;

commit fdd77704a8b4666a32120fcd1e4a9fedaf3263d8
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Mon Aug 18 17:08:55 2008 +0800

    ocfs2: reserve inline space for extended attribute
    
    Add the structures and helper functions we want for handling inline extended
    attributes. We also update the inline-data handlers so that they properly
    function in the event that we have both inline data and inline attributes
    sharing an inode block.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 128279986d65..ce75ca312a2d 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -245,6 +245,7 @@ struct ocfs2_super
 	int s_sectsize_bits;
 	int s_clustersize;
 	int s_clustersize_bits;
+	unsigned int s_xattr_inline_size;
 
 	atomic_t vol_state;
 	struct mutex recovery_lock;

commit 9a8ff578fb430a8816dfbc73c77e5e09c6d9c343
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Tue Jul 29 18:29:18 2008 -0700

    ocfs2: track local alloc state via debugfs
    
    A per-mount debugfs file, "local_alloc" is created which when read will
    expose live state of the nodes local alloc file. Performance impact is
    minimal, only a bit of memory overhead per mount point. Still, the code is
    hidden behind CONFIG_OCFS2_FS_STATS. This feature will help us debug
    local alloc performance problems on a live system.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 4d6e200a4843..128279986d65 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -272,6 +272,11 @@ struct ocfs2_super
 
 	u64 la_last_gd;
 
+#ifdef CONFIG_OCFS2_FS_STATS
+	struct dentry *local_alloc_debug;
+	char *local_alloc_debug_buf;
+#endif
+
 	/* Next two fields are for local node slot recovery during
 	 * mount. */
 	int dirty;

commit 9c7af40b210e87f8fddd97b0badc0a352862234a
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Jul 28 18:02:53 2008 -0700

    ocfs2: throttle back local alloc when low on disk space
    
    Ocfs2's local allocator disables itself for the duration of a mount point
    when it has trouble allocating a large enough area from the primary bitmap.
    That can cause performance problems, especially for disks which were only
    temporarily full or fragmented. This patch allows for the allocator to
    shrink it's window first, before being disabled. Later, it can also be
    re-enabled so that any performance drop is minimized.
    
    To do this, we allow the value of osb->local_alloc_bits to be shrunk when
    needed. The default value is recorded in a mostly read-only variable so that
    we can re-initialize when required.
    
    Locking had to be updated so that we could protect changes to
    local_alloc_bits. Mostly this involves protecting various local alloc values
    with the osb spinlock. A new state is also added, OCFS2_LA_THROTTLED, which
    is used when the local allocator is has shrunk, but is not disabled. If the
    available space dips below 1 megabyte, the local alloc file is disabled. In
    either case, local alloc is re-enabled 30 seconds after the event, or when
    an appropriate amount of bits is seen in the primary bitmap.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 43dd42e313a1..4d6e200a4843 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -171,9 +171,13 @@ struct ocfs2_alloc_stats
 
 enum ocfs2_local_alloc_state
 {
-	OCFS2_LA_UNUSED = 0,
-	OCFS2_LA_ENABLED,
-	OCFS2_LA_DISABLED
+	OCFS2_LA_UNUSED = 0,	/* Local alloc will never be used for
+				 * this mountpoint. */
+	OCFS2_LA_ENABLED,	/* Local alloc is in use. */
+	OCFS2_LA_THROTTLED,	/* Local alloc is in use, but number
+				 * of bits has been reduced. */
+	OCFS2_LA_DISABLED	/* Local alloc has temporarily been
+				 * disabled. */
 };
 
 enum ocfs2_mount_options
@@ -252,9 +256,20 @@ struct ocfs2_super
 	struct ocfs2_journal *journal;
 	unsigned long osb_commit_interval;
 
+	struct delayed_work		la_enable_wq;
+
+	/*
+	 * Must hold local alloc i_mutex and osb->osb_lock to change
+	 * local_alloc_bits. Reads can be done under either lock.
+	 */
 	unsigned int local_alloc_bits;
-	enum ocfs2_local_alloc_state local_alloc_state;
+	unsigned int local_alloc_default_bits;
+
+	enum ocfs2_local_alloc_state local_alloc_state; /* protected
+							 * by osb_lock */
+
 	struct buffer_head *local_alloc_bh;
+
 	u64 la_last_gd;
 
 	/* Next two fields are for local node slot recovery during

commit ebcee4b5c9136096f64ee6f691a013d7c0a4bc34
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Jul 28 14:55:20 2008 -0700

    ocfs2: Track local alloc bits internally
    
    Do this instead of tracking absolute local alloc size. This avoids
    needless re-calculatiion of bits from bytes in localalloc.c. Additionally,
    the value is now in a more natural unit for internal file system bitmap
    work.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 7f625f2b1117..43dd42e313a1 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -252,7 +252,7 @@ struct ocfs2_super
 	struct ocfs2_journal *journal;
 	unsigned long osb_commit_interval;
 
-	int local_alloc_size;
+	unsigned int local_alloc_bits;
 	enum ocfs2_local_alloc_state local_alloc_state;
 	struct buffer_head *local_alloc_bh;
 	u64 la_last_gd;
@@ -554,6 +554,14 @@ static inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)
 	return pages_per_cluster;
 }
 
+static inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,
+						       unsigned int megs)
+{
+	BUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);
+
+	return megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);
+}
+
 static inline void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)
 {
 	spin_lock(&osb->osb_lock);

commit 539d8264093560b917ee3afe4c7f74e5da09d6a5
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Mon Jul 14 17:31:10 2008 -0700

    [PATCH 2/2] ocfs2: Fix race between mount and recovery
    
    As the fs recovery is asynchronous, there is a small chance that another
    node can mount (and thus recover) the slot before the recovery thread
    gets to it.
    
    If this happens, the recovery thread will block indefinitely on the
    journal/slot lock as that lock will be held for the duration of the mount
    (by design) by the node assigned to that slot.
    
    The solution implemented is to keep track of the journal replays using
    a recovery generation in the journal inode, which will be incremented by the
    thread replaying that journal. The recovery thread, before attempting the
    blocking lock on the journal/slot lock, will compare the generation on disk
    with what it has cached and skip recovery if it does not match.
    
    This bug appears to have been inadvertently introduced during the mount/umount
    vote removal by mainline commit 34d024f84345807bf44163fac84e921513dde323. In the
    mount voting scheme, the messaging would indirectly indicate that the slot
    was being recovered.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 1cb814be8ef1..7f625f2b1117 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -204,6 +204,8 @@ struct ocfs2_super
 
 	struct ocfs2_slot_info *slot_info;
 
+	u32 *slot_recovery_generations;
+
 	spinlock_t node_map_lock;
 
 	u64 root_blkno;

commit 8ddb7b004dfa1832a750e199df8bff4b75b73565
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Tue May 13 13:45:15 2008 -0700

    [PATCH 2/2] ocfs2: Instrument fs cluster locks
    
    This patch adds code to track the number of times the fs takes
    various cluster locks as well as the times associated with it.
    The information is made available to users via debugfs.
    
    This patch was originally written by Jan Kara <jack@suse.cz>.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 31692379c170..1cb814be8ef1 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -132,6 +132,18 @@ struct ocfs2_lock_res {
 	wait_queue_head_t        l_event;
 
 	struct list_head         l_debug_list;
+
+#ifdef CONFIG_OCFS2_FS_STATS
+	unsigned long long	 l_lock_num_prmode; 	   /* PR acquires */
+	unsigned long long 	 l_lock_num_exmode; 	   /* EX acquires */
+	unsigned int		 l_lock_num_prmode_failed; /* Failed PR gets */
+	unsigned int		 l_lock_num_exmode_failed; /* Failed EX gets */
+	unsigned long long	 l_lock_total_prmode; 	   /* Tot wait for PR */
+	unsigned long long	 l_lock_total_exmode; 	   /* Tot wait for EX */
+	unsigned int		 l_lock_max_prmode; 	   /* Max wait for PR */
+	unsigned int		 l_lock_max_exmode; 	   /* Max wait for EX */
+	unsigned int		 l_lock_refresh;	   /* Disk refreshes */
+#endif
 };
 
 struct ocfs2_dlm_debug {

commit 4d0ddb2ce25db2254d468233d942276ecf40bff8
Author: Tao Ma <tao.ma@oracle.com>
Date:   Wed Mar 5 16:11:46 2008 +0800

    ocfs2: Add inode stealing for ocfs2_reserve_new_inode
    
    Inode allocation is modified to look in other nodes allocators during
    extreme out of space situations. We retry our own slot when space is freed
    back to the global bitmap, or whenever we've allocated more than 1024 inodes
    from another slot.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 9ff5811345a9..31692379c170 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -208,11 +208,14 @@ struct ocfs2_super
 	u32 s_feature_incompat;
 	u32 s_feature_ro_compat;
 
-	/* Protects s_next_generaion, osb_flags. Could protect more on
-	 * osb as it's very short lived. */
+	/* Protects s_next_generation, osb_flags and s_inode_steal_slot.
+	 * Could protect more on osb as it's very short lived.
+	 */
 	spinlock_t osb_lock;
 	u32 s_next_generation;
 	unsigned long osb_flags;
+	s16 s_inode_steal_slot;
+	atomic_t s_num_inodes_stolen;
 
 	unsigned long s_mount_opt;
 	unsigned int s_atime_quantum;
@@ -537,6 +540,33 @@ static inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)
 	return pages_per_cluster;
 }
 
+static inline void ocfs2_init_inode_steal_slot(struct ocfs2_super *osb)
+{
+	spin_lock(&osb->osb_lock);
+	osb->s_inode_steal_slot = OCFS2_INVALID_SLOT;
+	spin_unlock(&osb->osb_lock);
+	atomic_set(&osb->s_num_inodes_stolen, 0);
+}
+
+static inline void ocfs2_set_inode_steal_slot(struct ocfs2_super *osb,
+					      s16 slot)
+{
+	spin_lock(&osb->osb_lock);
+	osb->s_inode_steal_slot = slot;
+	spin_unlock(&osb->osb_lock);
+}
+
+static inline s16 ocfs2_get_inode_steal_slot(struct ocfs2_super *osb)
+{
+	s16 slot;
+
+	spin_lock(&osb->osb_lock);
+	slot = osb->s_inode_steal_slot;
+	spin_unlock(&osb->osb_lock);
+
+	return slot;
+}
+
 #define ocfs2_set_bit ext2_set_bit
 #define ocfs2_clear_bit ext2_clear_bit
 #define ocfs2_test_bit ext2_test_bit

commit b61817e1166c5e19c08baf05196477cc345e1b1a
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Feb 1 15:08:23 2008 -0800

    ocfs2: Add the USERSPACE_STACK incompat bit.
    
    The filesystem gains the USERSPACE_STACK incomat bit and the
    s_cluster_info field on the superblock.  When a userspace stack is in
    use, the name of the stack is stored on-disk for mount-time
    verification.
    
    The "cluster_stack" option is added to mount(2) processing.  The mount
    process needs to pass the matching stack name.  If the passed name and
    the on-disk name do not match, the mount is failed.
    
    When using the classic o2cb stack, the incompat bit is *not* set and no
    mount option is used other than the usual heartbeat=local.  Thus, the
    filesystem is compatible with older tools.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index af929eca5412..9ff5811345a9 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -248,6 +248,7 @@ struct ocfs2_super
 	struct ocfs2_alloc_stats alloc_stats;
 	char dev_str[20];		/* "major,minor" of the device */
 
+	char osb_cluster_stack[OCFS2_STACK_LABEL_LEN + 1];
 	struct ocfs2_cluster_connection *cconn;
 	struct ocfs2_lock_res osb_super_lockres;
 	struct ocfs2_lock_res osb_rename_lockres;
@@ -368,6 +369,12 @@ static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)
 	return ret;
 }
 
+static inline int ocfs2_userspace_stack(struct ocfs2_super *osb)
+{
+	return (osb->s_feature_incompat &
+		OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK);
+}
+
 static inline int ocfs2_mount_local(struct ocfs2_super *osb)
 {
 	return (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);

commit de551246e7bc5558371c3427889a8db1b8cc60f4
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Feb 1 14:45:08 2008 -0800

    ocfs2: Remove CANCELGRANT from the view of dlmglue.
    
    o2dlm has the non-standard behavior of providing a cancel callback
    (unlock_ast) even when the cancel has failed (the locking operation
    succeeded without canceling).  This is called CANCELGRANT after the
    status code sent to the callback.  fs/dlm does not provide this
    callback, so dlmglue must be changed to live without it.
    o2dlm_unlock_ast_wrapper() in stackglue now ignores CANCELGRANT calls.
    
    Because dlmglue no longer sees CANCELGRANT, ocfs2_unlock_ast() no longer
    needs to check for it.  ocfs2_locking_ast() must catch that a cancel was
    tried and clear the cancel state.
    
    Making these changes opens up a locking race.  dlmglue uses the the
    OCFS2_LOCK_BUSY flag to ensure only one thread is calling the dlm at any
    one time.  But dlmglue must unlock the lockres before calling into the
    dlm.  In the small window of time between unlocking the lockres and
    calling the dlm, the downconvert thread can try to cancel the lock.  The
    downconvert thread is checking the OCFS2_LOCK_BUSY flag - it doesn't
    know that ocfs2_dlm_lock() has not yet been called.
    
    Because ocfs2_dlm_lock() has not yet been called, the cancel operation
    will just be a no-op.  There's nothing to cancel.  With CANCELGRANT,
    dlmglue uses the CANCELGRANT callback to clear up the cancel state.
    When it comes around again, it will retry the cancel.  Eventually, the
    first thread will have called into ocfs2_dlm_lock(), and either the
    lock or the cancel will succeed.  The downconvert thread can then do its
    downconvert.
    
    Without CANCELGRANT, there is nothing to clean up the cancellation
    state.  The downconvert thread does not know to retry its operations.
    More importantly, the original lock may be blocking on the other node
    that is trying to cancel us.  With neither able to make progress, the
    ast is never called and the cancellation state is never cleaned up that
    way.  dlmglue is deadlocked.
    
    The OCFS2_LOCK_PENDING flag is introduced to remedy this window.  It is
    set at the same time OCFS2_LOCK_BUSY is.  Thus, the downconvert thread
    can check whether the lock is cancelable.  If not, it just loops around
    to try again.  Once ocfs2_dlm_lock() is called, the thread then clears
    OCFS2_LOCK_PENDING and wakes the downconvert thread.  Now, if the
    downconvert thread finds the lock BUSY, it can safely try to cancel it.
    Whether the cancel works or not, the state will be properly set and the
    lock processing can continue.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 31dc28b48392..af929eca5412 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -98,6 +98,9 @@ enum ocfs2_unlock_action {
 					       * dropped. */
 #define OCFS2_LOCK_QUEUED        (0x00000100) /* queued for downconvert */
 #define OCFS2_LOCK_NOCACHE       (0x00000200) /* don't use a holder count */
+#define OCFS2_LOCK_PENDING       (0x00000400) /* This lockres is pending a
+						 call to dlm_lock.  Only
+						 exists with BUSY set. */
 
 struct ocfs2_lock_res_ops;
 
@@ -124,6 +127,7 @@ struct ocfs2_lock_res {
 	enum ocfs2_unlock_action l_unlock_action;
 	int                      l_requested;
 	int                      l_blocking;
+	unsigned int             l_pending_gen;
 
 	wait_queue_head_t        l_event;
 

commit 6953b4c008628b945bfe0cee97f6e78a98773859
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Jan 29 16:59:56 2008 -0800

    ocfs2: Move o2hb functionality into the stack glue.
    
    The last bit of classic stack used directly in ocfs2 code is o2hb.
    Specifically, the check for heartbeat during mount and the call to
    ocfs2_hb_ctl during unmount.
    
    We create an extra API, ocfs2_cluster_hangup(), to encapsulate the call
    to ocfs2_hb_ctl.  Other stacks will just leave hangup() empty.
    
    The check for heartbeat is moved into ocfs2_cluster_connect().  It will
    be matched by a similar check for other stacks.
    
    With this change, only stackglue.c includes cluster/ headers.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 7006abaffd47..31dc28b48392 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -36,10 +36,6 @@
 #include <linux/mutex.h>
 #include <linux/jbd.h>
 
-#include "cluster/nodemanager.h"
-#include "cluster/heartbeat.h"
-#include "cluster/tcp.h"
-
 /* For union ocfs2_dlm_lksb */
 #include "stackglue.h"
 

commit 19fdb624dc8ccb663f6e48b3a3a3fa4e4e567fc1
Author: Joel Becker <joel.becker@oracle.com>
Date:   Wed Jan 30 15:38:24 2008 -0800

    ocfs2: Abstract out node number queries.
    
    ocfs2 asks the cluster stack for the local node's node number for two
    reasons; to fill the slot map and to print it. While the slot map isn't
    necessary for userspace cluster stacks, the printing is very nice for
    debugging. Thus we add ocfs2_cluster_this_node() as a generic API to get
    this value. It is anticipated that the slot map will not be used under a
    userspace cluster stack, so validity checks of the node num only need to
    exist in the slot map code. Otherwise, it just gets used and printed as an
    opaque value.
    
    [ Fixed up some "int" versus "unsigned int" issues and made osb->node_num
      truly opaque. --Mark ]
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 664e4fe3eab5..7006abaffd47 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -218,7 +218,7 @@ struct ocfs2_super
 	unsigned int s_atime_quantum;
 
 	unsigned int max_slots;
-	s16 node_num;
+	unsigned int node_num;
 	int slot_num;
 	int preferred_slot;
 	int s_sectsize_bits;

commit 4670c46ded9a18268d1265417ff4ac72145a7917
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Feb 1 14:39:35 2008 -0800

    ocfs2: Introduce the new ocfs2_cluster_connect/disconnect() API.
    
    This step introduces a cluster stack agnostic API for initializing and
    exiting.  fs/ocfs2/dlmglue.c no longer uses o2cb/o2dlm knowledge to
    connect to the stack.  It is all handled in stackglue.c.
    
    heartbeat.c no longer needs to know how it gets called.
    ocfs2_do_node_down() is now a clean recovery trigger.
    
    The big gotcha is the ordering of initializations and de-initializations done
    underneath ocfs2_cluster_connect().  ocfs2_dlm_init() used to do all
    o2dlm initialization in one block.  Thus, the o2dlm functionality of
    ocfs2_cluster_connect() is very straightforward.  ocfs2_dlm_shutdown(),
    however, did a few things between de-registration of the eviction
    callback and actually shutting down the domain.  Now de-registration and
    shutdown of the domain are wrapped within the single
    ocfs2_cluster_disconnect() call.  I've checked the code paths to make
    sure we can safely tear down things in ocfs2_dlm_shutdown() before
    calling ocfs2_cluster_disconnect().  The filesystem has already set
    itself to ignore the callback.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 6d7c6d2d0c23..664e4fe3eab5 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -248,12 +248,10 @@ struct ocfs2_super
 	struct ocfs2_alloc_stats alloc_stats;
 	char dev_str[20];		/* "major,minor" of the device */
 
-	struct dlm_ctxt *dlm;
+	struct ocfs2_cluster_connection *cconn;
 	struct ocfs2_lock_res osb_super_lockres;
 	struct ocfs2_lock_res osb_rename_lockres;
-	struct dlm_eviction_cb osb_eviction_cb;
 	struct ocfs2_dlm_debug *osb_dlm_debug;
-	struct dlm_protocol_version osb_locking_proto;
 
 	struct dentry *osb_debug_root;
 

commit 8f2c9c1b16bf6ed0903b29c49d56fa0109a390e4
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Feb 1 12:16:57 2008 -0800

    ocfs2: Create the lock status block union.
    
    Wrap the lock status block (lksb) in a union.  Later we will add a union
    element for the fs/dlm lksb.  Create accessors for the status and lvb
    fields.
    
    Other than a debugging function, dlmglue.c does not directly reference
    the o2dlm locking path anymore.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index f78e9ed53249..6d7c6d2d0c23 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -40,7 +40,8 @@
 #include "cluster/heartbeat.h"
 #include "cluster/tcp.h"
 
-#include "dlm/dlmapi.h"
+/* For union ocfs2_dlm_lksb */
+#include "stackglue.h"
 
 #include "ocfs2_fs.h"
 #include "ocfs2_lockid.h"
@@ -120,7 +121,7 @@ struct ocfs2_lock_res {
 	int                      l_level;
 	unsigned int             l_ro_holders;
 	unsigned int             l_ex_holders;
-	struct dlm_lockstatus    l_lksb;
+	union ocfs2_dlm_lksb     l_lksb;
 
 	/* used from AST/BAST funcs. */
 	enum ocfs2_ast_action    l_action;

commit 386a2ef8576e966076c293f6496b9e3d7e3d9035
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Feb 1 12:06:54 2008 -0800

    ocfs2: New slot map format
    
    The old slot map had a few limitations:
    
    - It was limited to one block, so the maximum slot count was 255.
    - Each slot was signed 16bits, limiting node numbers to INT16_MAX.
    - An empty slot was marked by the magic 0xFFFF (-1).
    
    The new slot map format provides 32bit node numbers (UINT32_MAX), a
    separate space to mark a slot in use, and extra room to grow.  The slot
    map is now bounded by i_size, not a block.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 95f783dbe8b2..f78e9ed53249 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -374,6 +374,13 @@ static inline int ocfs2_mount_local(struct ocfs2_super *osb)
 	return (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);
 }
 
+static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)
+{
+	return (osb->s_feature_incompat &
+		OCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP);
+}
+
+
 #define OCFS2_IS_VALID_DINODE(ptr)					\
 	(!strcmp((ptr)->i_signature, OCFS2_INODE_SIGNATURE))
 

commit fc881fa0d59596c02f8707b5572567c369d4789a
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Feb 1 12:04:48 2008 -0800

    ocfs2: De-magic the in-memory slot map.
    
    The in-memory slot map uses the same magic as the on-disk one.  There is
    a special value to mark a slot as invalid.  It relies on the size of
    certain types and so on.
    
    Write a new in-memory map that keeps validity as a separate field.  Outside
    of the I/O functions, OCFS2_INVALID_SLOT now means what it is supposed to.
    It also is no longer tied to the type size.
    
    This also means that only the I/O functions refer to 16bit quantities.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index c6ed8c35de0d..95f783dbe8b2 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -216,10 +216,10 @@ struct ocfs2_super
 	unsigned long s_mount_opt;
 	unsigned int s_atime_quantum;
 
-	u16 max_slots;
+	unsigned int max_slots;
 	s16 node_num;
-	s16 slot_num;
-	s16 preferred_slot;
+	int slot_num;
+	int preferred_slot;
 	int s_sectsize_bits;
 	int s_clustersize;
 	int s_clustersize_bits;

commit 553abd046af609191a91af7289d87d477adc659f
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Feb 1 12:03:57 2008 -0800

    ocfs2: Change the recovery map to an array of node numbers.
    
    The old recovery map was a bitmap of node numbers.  This was sufficient
    for the maximum node number of 254.  Going forward, we want node numbers
    to be UINT32.  Thus, we need a new recovery map.
    
    Note that we can't keep track of slots here.  We must write down the
    node number to recovery *before* we get the locks needed to convert a
    node number into a slot number.
    
    The recovery map is now an array of unsigned ints, max_slots in size.
    It moves to journal.c with the rest of recovery.
    
    Because it needs to be initialized, we move all of recovery initialization
    into a new function, ocfs2_recovery_init().  This actually cleans up
    ocfs2_initialize_super() a little as well.  Following on, recovery cleaup
    becomes part of ocfs2_recovery_exit().
    
    A number of node map functions are rendered obsolete and are removed.
    
    Finally, waiting on recovery is wrapped in a function rather than naked
    checks on the recovery_event.  This is a cleanup from Mark.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index ee3f675a4210..c6ed8c35de0d 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -180,6 +180,7 @@ enum ocfs2_mount_options
 
 struct ocfs2_journal;
 struct ocfs2_slot_info;
+struct ocfs2_recovery_map;
 struct ocfs2_super
 {
 	struct task_struct *commit_task;
@@ -191,7 +192,6 @@ struct ocfs2_super
 	struct ocfs2_slot_info *slot_info;
 
 	spinlock_t node_map_lock;
-	struct ocfs2_node_map recovery_map;
 
 	u64 root_blkno;
 	u64 system_dir_blkno;
@@ -226,6 +226,7 @@ struct ocfs2_super
 
 	atomic_t vol_state;
 	struct mutex recovery_lock;
+	struct ocfs2_recovery_map *recovery_map;
 	struct task_struct *recovery_thread_task;
 	int disable_recovery;
 	wait_queue_head_t checkpoint_event;

commit d85b20e4b300edfd290f21fc2d790ba16d2f225b
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Feb 1 12:01:05 2008 -0800

    ocfs2: Make ocfs2_slot_info private.
    
    Just use osb_lock around the ocfs2_slot_info data.  This allows us to
    take the ocfs2_slot_info structure private in slot_info.c.  All access
    is now via accessors.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 6546cef212e3..ee3f675a4210 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -179,6 +179,7 @@ enum ocfs2_mount_options
 #define OCFS2_DEFAULT_ATIME_QUANTUM	60
 
 struct ocfs2_journal;
+struct ocfs2_slot_info;
 struct ocfs2_super
 {
 	struct task_struct *commit_task;

commit 8b5f6883683c91ad7e1af32b7ceeb604d68e2865
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Fri Feb 8 04:20:12 2008 -0800

    byteorder: move le32_add_cpu & friends from OCFS2 to core
    
    This patchset moves le*_add_cpu and be*_add_cpu functions from OCFS2 to core
    header (1st), converts ext3 filesystem to this API (2nd) and replaces XFS
    different named functions with new ones (3rd).
    
    There are many places where these functions will be useful.  Just look at:
    grep -r 'cpu_to_[ble12346]*([ble12346]*_to_cpu.*[-+]' linux-src/ Patch for
    ext3 is an example how conversions will probably look like.
    
    This patch:
    
    - move inline functions which add native byte order variable to
      little/big endian variable to core header
      * le16_add_cpu(__le16 *var, u16 val)
      * le32_add_cpu(__le32 *var, u32 val)
      * le64_add_cpu(__le64 *var, u64 val)
      * be32_add_cpu(__be32 *var, u32 val)
    - add for completeness:
      * be16_add_cpu(__be16 *var, u16 val)
      * be64_add_cpu(__be64 *var, u64 val)
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Acked-by: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: David Chinner <dgc@sgi.com>
    Cc: Timothy Shimmin <tes@sgi.com>
    Cc: <linux-ext4@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index e8b7292e0152..6546cef212e3 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -43,7 +43,6 @@
 #include "dlm/dlmapi.h"
 
 #include "ocfs2_fs.h"
-#include "endian.h"
 #include "ocfs2_lockid.h"
 
 /* Most user visible OCFS2 inodes will have very few pieces of

commit d24fbcda0c4988322949df3d759f1cfb32b32953
Author: Joel Becker <Joel.Becker@oracle.com>
Date:   Fri Jan 25 17:02:21 2008 -0800

    ocfs2: Negotiate locking protocol versions.
    
    Currently, when ocfs2 nodes connect via TCP, they advertise their
    compatibility level.  If the versions do not match, two nodes cannot speak
    to each other and they disconnect. As a result, this provides no forward or
    backwards compatibility.
    
    This patch implements a simple protocol negotiation at the dlm level by
    introducing a major/minor version number scheme for entities that
    communicate.  Specifically, o2dlm has a major/minor version for interaction
    with o2dlm on other nodes, and ocfs2 itself has a major/minor version for
    interacting with the filesystem on other nodes.
    
    This will allow rolling upgrades of ocfs2 clusters when changes to the
    locking or network protocols can be done in a backwards compatible manner.
    In those cases, only the minor number is changed and the negotatied protocol
    minor is returned from dlm join. In the far less likely event that a
    required protocol change makes backwards compatibility impossible, we simply
    bump the major number.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index d08480580470..e8b7292e0152 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -251,6 +251,7 @@ struct ocfs2_super
 	struct ocfs2_lock_res osb_rename_lockres;
 	struct dlm_eviction_cb osb_eviction_cb;
 	struct ocfs2_dlm_debug *osb_dlm_debug;
+	struct dlm_protocol_version osb_locking_proto;
 
 	struct dentry *osb_debug_root;
 

commit 7ec373cf33533af6c50828a62f6b305c2d7fa931
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Wed Jan 23 16:54:48 2008 -0800

    ocfs2: document access rules for blocked_lock_list
    
    ocfs2_super->blocked_lock_list and ocfs2_super->blocked_lock_count have some
    usage restrictions which aren't immediately obvious to anyone reading the
    code. It's a good idea to document this so that we avoid making costly
    mistakes in the future.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 22e334d125d0..d08480580470 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -262,6 +262,12 @@ struct ocfs2_super
 	unsigned long dc_wake_sequence;
 	unsigned long dc_work_sequence;
 
+	/*
+	 * Any thread can add locks to the list, but the downconvert
+	 * thread is the only one allowed to remove locks. Any change
+	 * to this rule requires updating
+	 * ocfs2_downconvert_thread_do_work().
+	 */
 	struct list_head blocked_lock_list;
 	unsigned long blocked_lock_count;
 

commit 53fc622b9e829c8e632e45ef8c14f054388759c1
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Dec 20 16:49:04 2007 -0800

    [PATCH 2/2] ocfs2: cluster aware flock()
    
    Hook up ocfs2_flock(), using the new flock lock type in dlmglue.c. A new
    mount option, "localflocks" is added so that users can revert to old
    functionality as need be.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 63c131e1cc77..22e334d125d0 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -171,6 +171,7 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_NOINTR  = 1 << 2,   /* Don't catch signals */
 	OCFS2_MOUNT_ERRORS_PANIC = 1 << 3, /* Panic on errors */
 	OCFS2_MOUNT_DATA_WRITEBACK = 1 << 4, /* No data ordering */
+	OCFS2_MOUNT_LOCALFLOCKS = 1 << 5, /* No cluster aware user file locks */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001

commit cf8e06f1a860d8680d6bb4ac8ec7d7724988e46f
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Dec 20 16:43:10 2007 -0800

    [PATCH 1/2] ocfs2: add flock lock type
    
    This adds a new dlmglue lock type which is intended to back flock()
    requests.
    
    Since these locks are driven from userspace, usage rules are much more
    liberal than the typical Ocfs2 internal cluster lock. As a result, we can't
    make use of most dlmglue features - lock caching and lock level
    optimizations in particular. Additionally, userspace is free to deadlock
    itself, so we have to deal with that in the same way as the rest of the
    kernel - by allowing a signal to abort a lock request.
    
    In order to keep ocfs2_cluster_lock() complexity down, ocfs2_file_lock()
    does it's own dlm coordination. We still use the same helper functions
    though, so duplicated code is kept to a minimum.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index d12bd7036da7..63c131e1cc77 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -101,6 +101,7 @@ enum ocfs2_unlock_action {
 					       * about to be
 					       * dropped. */
 #define OCFS2_LOCK_QUEUED        (0x00000100) /* queued for downconvert */
+#define OCFS2_LOCK_NOCACHE       (0x00000200) /* don't use a holder count */
 
 struct ocfs2_lock_res_ops;
 

commit 2fbe8d1ebe004425b4f7b8bba345623d2280be82
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Thu Dec 20 14:58:11 2007 -0800

    ocfs2: Local alloc window size changeable via mount option
    
    Local alloc is a performance optimization in ocfs2 in which a node
    takes a window of bits from the global bitmap and then uses that for
    all small local allocations. This window size is fixed to 8MB currently.
    This patch allows users to specify the window size in MB including
    disabling it by passing in 0. If the number specified is too large,
    the fs will use the default value of 8MB.
    
    mount -o localalloc=X /dev/sdX /mntpoint
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 82802f5672a1..d12bd7036da7 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -231,6 +231,7 @@ struct ocfs2_super
 	struct ocfs2_journal *journal;
 	unsigned long osb_commit_interval;
 
+	int local_alloc_size;
 	enum ocfs2_local_alloc_state local_alloc_state;
 	struct buffer_head *local_alloc_bh;
 	u64 la_last_gd;

commit d147b3d630edef1d34de6ea819787a1ac1b8603b
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Wed Nov 7 14:40:36 2007 -0800

    ocfs2: Support commit= mount option
    
    Mostly taken from ext3. This allows the user to set the jbd commit interval,
    in seconds. The default of 5 seconds stays the same, but now users can
    easily increase the commit interval. Typically, this would be increased in
    order to benefit performance at the expense of data-safety.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index f8f866144c6a..82802f5672a1 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -229,6 +229,7 @@ struct ocfs2_super
 	wait_queue_head_t checkpoint_event;
 	atomic_t needs_checkpoint;
 	struct ocfs2_journal *journal;
+	unsigned long osb_commit_interval;
 
 	enum ocfs2_local_alloc_state local_alloc_state;
 	struct buffer_head *local_alloc_bh;

commit 34d024f84345807bf44163fac84e921513dde323
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Mon Sep 24 15:56:19 2007 -0700

    ocfs2: Remove mount/unmount votes
    
    The node maps that are set/unset by these votes are no longer relevant, thus
    we can remove the mount and umount votes. Since those are the last two
    remaining votes, we can also remove the entire vote infrastructure.
    
    The vote thread has been renamed to the downconvert thread, and the small
    amount of functionality related to managing it has been moved into
    fs/ocfs2/dlmglue.c. All references to votes have been removed or updated.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 60a23e1906b0..f8f866144c6a 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -189,9 +189,7 @@ struct ocfs2_super
 	struct ocfs2_slot_info *slot_info;
 
 	spinlock_t node_map_lock;
-	struct ocfs2_node_map mounted_map;
 	struct ocfs2_node_map recovery_map;
-	struct ocfs2_node_map umount_map;
 
 	u64 root_blkno;
 	u64 system_dir_blkno;
@@ -254,28 +252,15 @@ struct ocfs2_super
 
 	wait_queue_head_t recovery_event;
 
-	spinlock_t vote_task_lock;
-	struct task_struct *vote_task;
-	wait_queue_head_t vote_event;
-	unsigned long vote_wake_sequence;
-	unsigned long vote_work_sequence;
+	spinlock_t dc_task_lock;
+	struct task_struct *dc_task;
+	wait_queue_head_t dc_event;
+	unsigned long dc_wake_sequence;
+	unsigned long dc_work_sequence;
 
 	struct list_head blocked_lock_list;
 	unsigned long blocked_lock_count;
 
-	struct list_head vote_list;
-	int vote_count;
-
-	u32 net_key;
-	spinlock_t net_response_lock;
-	unsigned int net_response_ids;
-	struct list_head net_response_list;
-
-	struct o2hb_callback_func osb_hb_up;
-	struct o2hb_callback_func osb_hb_down;
-
-	struct list_head	osb_net_handlers;
-
 	wait_queue_head_t		osb_mount_event;
 
 	/* Truncate log info */

commit 15b1e36bdb487d67ef924a37b0967453143be53a
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Sep 7 13:58:15 2007 -0700

    ocfs2: Structure updates for inline data
    
    Add the disk, network and memory structures needed to support data in inode.
    
    Struct ocfs2_inline_data is defined and embedded in ocfs2_dinode for storing
    inline data.
    
    A new inode field, i_dyn_features, is added to facilitate tracking of
    dynamic inode state. Since it will be used often, we want to mirror it on
    ocfs2_inode_info, and transfer it via the meta data lvb.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Reviewed-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 58307853fb4a..60a23e1906b0 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -319,6 +319,13 @@ static inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)
 	return 0;
 }
 
+static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)
+{
+	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)
+		return 1;
+	return 0;
+}
+
 /* set / clear functions because cluster events can make these happen
  * in parallel so we want the transitions to be atomic. this also
  * means that any future flags osb_flags must be protected by spinlock

commit 7c08d70c69150148c14f02633855f1591219c37c
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Jul 20 11:58:36 2007 -0700

    ocfs2: Fix some casting errors related to file writes
    
    ocfs2_align_clusters_to_page_index() needs to cast the clusters shift to
    pgoff_t and ocfs2_file_buffered_write() needs loff_t when calculating
    destination start for memcpy.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 5cc90a40b3c5..58307853fb4a 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -494,16 +494,16 @@ static inline unsigned int ocfs2_page_index_to_clusters(struct super_block *sb,
 /*
  * Find the 1st page index which covers the given clusters.
  */
-static inline unsigned long ocfs2_align_clusters_to_page_index(struct super_block *sb,
+static inline pgoff_t ocfs2_align_clusters_to_page_index(struct super_block *sb,
 							u32 clusters)
 {
 	unsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;
-	unsigned long index = clusters;
+        pgoff_t index = clusters;
 
 	if (PAGE_CACHE_SHIFT > cbits) {
-		index = clusters >> (PAGE_CACHE_SHIFT - cbits);
+		index = (pgoff_t)clusters >> (PAGE_CACHE_SHIFT - cbits);
 	} else if (PAGE_CACHE_SHIFT < cbits) {
-		index = clusters << (cbits - PAGE_CACHE_SHIFT);
+		index = (pgoff_t)clusters << (cbits - PAGE_CACHE_SHIFT);
 	}
 
 	return index;

commit 328d5752e1259dfb29b7e65f6c2d145fddbaa750
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Mon Jun 18 10:48:04 2007 -0700

    ocfs2: btree changes for unwritten extents
    
    Writes to a region marked as unwritten might result in a record split or
    merge. We can support splits by making minor changes to the existing insert
    code. Merges require left rotations which mostly re-use right rotation
    support functions.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 648ef8e45eaa..5cc90a40b3c5 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -306,6 +306,19 @@ static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)
 	return 0;
 }
 
+static inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)
+{
+	/*
+	 * Support for sparse files is a pre-requisite
+	 */
+	if (!ocfs2_sparse_alloc(osb))
+		return 0;
+
+	if (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)
+		return 1;
+	return 0;
+}
+
 /* set / clear functions because cluster events can make these happen
  * in parallel so we want the transitions to be atomic. this also
  * means that any future flags osb_flags must be protected by spinlock

commit baf4661a8225d3a39622b795a8db0e6aa845c1ec
Author: Sunil Mushran <Sunil.Mushran@oracle.com>
Date:   Mon Jun 18 17:00:24 2007 -0700

    ocfs2: Add "preferred slot" mount option
    
    ocfs2 will attempt to assign the node the slot# provided in the mount
    option. Failure to assign the preferred slot is not an error. This small
    feature can be useful for automated testing.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index a860633e833f..648ef8e45eaa 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -219,6 +219,7 @@ struct ocfs2_super
 	u16 max_slots;
 	s16 node_num;
 	s16 slot_num;
+	s16 preferred_slot;
 	int s_sectsize_bits;
 	int s_clustersize;
 	int s_clustersize_bits;

commit 1ca1a111b1e6be843c9ce5245dcd570312998d94
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Apr 27 16:01:25 2007 -0700

    ocfs2: fix sparse warnings in fs/ocfs2
    
    None of these are actually harmful, but the noise makes looking for real
    problems difficult.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 82cc92dcf8a6..a860633e833f 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -363,9 +363,9 @@ static inline int ocfs2_mount_local(struct ocfs2_super *osb)
 	typeof(__di) ____di = (__di);					\
 	ocfs2_error((__sb), 						\
 		"Dinode # %llu has bad signature %.*s",			\
-		(unsigned long long)(____di)->i_blkno, 7,		\
+		(unsigned long long)le64_to_cpu((____di)->i_blkno), 7, 	\
 		(____di)->i_signature);					\
-} while (0);
+} while (0)
 
 #define OCFS2_IS_VALID_EXTENT_BLOCK(ptr)				\
 	(!strcmp((ptr)->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE))
@@ -374,9 +374,9 @@ static inline int ocfs2_mount_local(struct ocfs2_super *osb)
 	typeof(__eb) ____eb = (__eb);					\
 	ocfs2_error((__sb), 						\
 		"Extent Block # %llu has bad signature %.*s",		\
-		(unsigned long long)(____eb)->h_blkno, 7,		\
+		(unsigned long long)le64_to_cpu((____eb)->h_blkno), 7,	\
 		(____eb)->h_signature);					\
-} while (0);
+} while (0)
 
 #define OCFS2_IS_VALID_GROUP_DESC(ptr)					\
 	(!strcmp((ptr)->bg_signature, OCFS2_GROUP_DESC_SIGNATURE))
@@ -385,9 +385,9 @@ static inline int ocfs2_mount_local(struct ocfs2_super *osb)
 	typeof(__gd) ____gd = (__gd);					\
 		ocfs2_error((__sb),					\
 		"Group Descriptor # %llu has bad signature %.*s",	\
-		(unsigned long long)(____gd)->bg_blkno, 7,		\
+		(unsigned long long)le64_to_cpu((____gd)->bg_blkno), 7, \
 		(____gd)->bg_signature);				\
-} while (0);
+} while (0)
 
 static inline unsigned long ino_from_blkno(struct super_block *sb,
 					   u64 blkno)

commit 60b11392f1a09433740bda3048202213daa27736
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Feb 16 11:46:50 2007 -0800

    ocfs2: zero tail of sparse files on truncate
    
    Since we don't zero on extend anymore, truncate needs to be fixed up to zero
    the part of a file between i_size and and end of it's cluster. Otherwise a
    subsequent extend could expose bad data.
    
    This introduced a new helper, which can be used in ocfs2_write().
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 2699f7cac21a..82cc92dcf8a6 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -495,6 +495,17 @@ static inline unsigned long ocfs2_align_clusters_to_page_index(struct super_bloc
 	return index;
 }
 
+static inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)
+{
+	unsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;
+	unsigned int pages_per_cluster = 1;
+
+	if (PAGE_CACHE_SHIFT < cbits)
+		pages_per_cluster = 1 << (cbits - PAGE_CACHE_SHIFT);
+
+	return pages_per_cluster;
+}
+
 #define ocfs2_set_bit ext2_set_bit
 #define ocfs2_clear_bit ext2_clear_bit
 #define ocfs2_test_bit ext2_test_bit

commit 9517bac6cc7a7aa4fee63cb38a32cb6014e264c7
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Feb 9 20:24:12 2007 -0800

    ocfs2: teach ocfs2_file_aio_write() about sparse files
    
    Unfortunately, ocfs2 can no longer make use of generic_file_aio_write_nlock()
    because allocating writes will require zeroing of pages adjacent to the I/O
    for cluster sizes greater than page size.
    
    Implement a custom file write here, which can order page locks for zeroing.
    This also has the advantage that cluster locks can easily be ordered outside
    of the page locks.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index faeb53f2eecf..2699f7cac21a 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -463,6 +463,38 @@ static inline unsigned long ocfs2_align_bytes_to_sectors(u64 bytes)
 	return (unsigned long)((bytes + 511) >> 9);
 }
 
+static inline unsigned int ocfs2_page_index_to_clusters(struct super_block *sb,
+							unsigned long pg_index)
+{
+	u32 clusters = pg_index;
+	unsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;
+
+	if (unlikely(PAGE_CACHE_SHIFT > cbits))
+		clusters = pg_index << (PAGE_CACHE_SHIFT - cbits);
+	else if (PAGE_CACHE_SHIFT < cbits)
+		clusters = pg_index >> (cbits - PAGE_CACHE_SHIFT);
+
+	return clusters;
+}
+
+/*
+ * Find the 1st page index which covers the given clusters.
+ */
+static inline unsigned long ocfs2_align_clusters_to_page_index(struct super_block *sb,
+							u32 clusters)
+{
+	unsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;
+	unsigned long index = clusters;
+
+	if (PAGE_CACHE_SHIFT > cbits) {
+		index = clusters >> (PAGE_CACHE_SHIFT - cbits);
+	} else if (PAGE_CACHE_SHIFT < cbits) {
+		index = clusters << (cbits - PAGE_CACHE_SHIFT);
+	}
+
+	return index;
+}
+
 #define ocfs2_set_bit ext2_set_bit
 #define ocfs2_clear_bit ext2_clear_bit
 #define ocfs2_test_bit ext2_test_bit

commit 363041a5f74b953ab6b705ac9c88e5eda218a24b
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Wed Jan 17 12:31:35 2007 -0800

    ocfs2: temporarily remove extent map caching
    
    The code in extent_map.c is not prepared to deal with a subtree being
    rotated between lookups. This can happen when filling holes in sparse files.
    Instead of a lengthy patch to update the code (which would likely lose the
    benefit of caching subtree roots), we remove most of the algorithms and
    implement a simple path based lookup. A less ambitious extent caching scheme
    will be added in a later patch.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index fe7e1ecafca5..faeb53f2eecf 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -46,11 +46,6 @@
 #include "endian.h"
 #include "ocfs2_lockid.h"
 
-struct ocfs2_extent_map {
-	u32		em_clusters;
-	struct rb_root	em_extents;
-};
-
 /* Most user visible OCFS2 inodes will have very few pieces of
  * metadata, but larger files (including bitmaps, etc) must be taken
  * into account when designing an access scheme. We allow a small

commit dcd0538ff4e854fa9d7f4630b359ca8fdb5cb5a8
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Tue Jan 16 11:32:23 2007 -0800

    ocfs2: sparse b-tree support
    
    Introduce tree rotations into the b-tree code. This will allow ocfs2 to
    support sparse files. Much of the added code is designed to be generic (in
    the ocfs2 sense) so that it can later be re-used to implement large
    extended attributes.
    
    This patch only adds the rotation code and does minimal updates to callers
    of the extent api.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index db8e77cd35d3..fe7e1ecafca5 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -303,6 +303,13 @@ static inline int ocfs2_should_order_data(struct inode *inode)
 	return 1;
 }
 
+static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)
+{
+	if (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)
+		return 1;
+	return 0;
+}
+
 /* set / clear functions because cluster events can make these happen
  * in parallel so we want the transitions to be atomic. this also
  * means that any future flags osb_flags must be protected by spinlock

commit c271c5c22b0a7ca45fda15f1f4d258bca36a5b94
Author: Sunil Mushran <Sunil.Mushran@oracle.com>
Date:   Tue Dec 5 17:56:35 2006 -0800

    ocfs2: local mounts
    
    This allows users to format an ocfs2 file system with a special flag,
    OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT. When the file system sees this flag, it
    will not use any cluster services, nor will it require a cluster
    configuration, thus acting like a 'local' file system.
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index b767fd7da6eb..db8e77cd35d3 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -349,6 +349,11 @@ static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)
 	return ret;
 }
 
+static inline int ocfs2_mount_local(struct ocfs2_super *osb)
+{
+	return (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);
+}
+
 #define OCFS2_IS_VALID_DINODE(ptr)					\
 	(!strcmp((ptr)->i_signature, OCFS2_INODE_SIGNATURE))
 

commit 9db73724453a9350e1c22dbe732d427e2939a5c9
Merge: 4c1ac1b49122 e62438630ca3
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 17:01:28 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            drivers/ata/libata-scsi.c
            include/linux/libata.h
    
    Futher merge of Linus's head and compilation fixups.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

commit 7f1a37e31f94b4f1c123d32ce9f69205ab2095bd
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Wed Nov 15 15:48:42 2006 +0800

    ocfs2: core atime update functions
    
    This patch adds the core routines for updating atime in ocfs2.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 553e7021b6a7..078883772bd6 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -180,6 +180,7 @@ enum ocfs2_mount_options
 #define OCFS2_OSB_SOFT_RO	0x0001
 #define OCFS2_OSB_HARD_RO	0x0002
 #define OCFS2_OSB_ERROR_FS	0x0004
+#define OCFS2_DEFAULT_ATIME_QUANTUM	60
 
 struct ocfs2_journal;
 struct ocfs2_super
@@ -218,6 +219,7 @@ struct ocfs2_super
 	unsigned long osb_flags;
 
 	unsigned long s_mount_opt;
+	unsigned int s_atime_quantum;
 
 	u16 max_slots;
 	s16 node_num;

commit 1fabe1481fac9e01bf8bffa60a2307ef379aa5de
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Mon Oct 9 18:11:45 2006 -0700

    ocfs2: Remove struct ocfs2_journal_handle in favor of handle_t
    
    This is mostly a search and replace as ocfs2_journal_handle is now no more
    than a container for a handle_t pointer.
    
    ocfs2_commit_trans() becomes very straight forward, and we remove some out
    of date comments / code.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 0462a7f4e21b..553e7021b6a7 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -34,6 +34,7 @@
 #include <linux/workqueue.h>
 #include <linux/kref.h>
 #include <linux/mutex.h>
+#include <linux/jbd.h>
 
 #include "cluster/nodemanager.h"
 #include "cluster/heartbeat.h"
@@ -181,7 +182,6 @@ enum ocfs2_mount_options
 #define OCFS2_OSB_ERROR_FS	0x0004
 
 struct ocfs2_journal;
-struct ocfs2_journal_handle;
 struct ocfs2_super
 {
 	struct task_struct *commit_task;

commit c4028958b6ecad064b1a6303a6a5906d4fe48d73
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:57:56 2006 +0000

    WorkStruct: make allyesconfig
    
    Fix up for make allyesconfig.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 0462a7f4e21b..9b1bad1d48ec 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -283,7 +283,7 @@ struct ocfs2_super
 	/* Truncate log info */
 	struct inode			*osb_tl_inode;
 	struct buffer_head		*osb_tl_bh;
-	struct work_struct		osb_truncate_log_wq;
+	struct delayed_work		osb_truncate_log_wq;
 
 	struct ocfs2_node_map		osb_recovering_orphan_dirs;
 	unsigned int			*osb_orphan_wipes;

commit 883d4cae4a2b01a05193cf2665c77b7489a8b6a0
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Mon Jun 5 16:41:00 2006 -0400

    ocfs2: allocation hints
    
    Record the most recently used allocation group on the allocation context, so
    that subsequent allocations can attempt to optimize for contiguousness.
    Local alloc especially should benefit from this as the current chain search
    tends to let it spew across the disk.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index d52100d49b6c..0462a7f4e21b 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -236,6 +236,7 @@ struct ocfs2_super
 
 	enum ocfs2_local_alloc_state local_alloc_state;
 	struct buffer_head *local_alloc_bh;
+	u64 la_last_gd;
 
 	/* Next two fields are for local node slot recovery during
 	 * mount. */

commit 101ebf256de54e78e6d3277adacf656e125a2c5a
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Tue May 2 17:54:45 2006 -0700

    ocfs2: limit cluster bitmap information saved at mount
    
    We were storing cluster count on the ocfs2_super structure, but never
    actually using it so remove that. Also, we don't want to populate the
    uptodate cache with the unlocked block read - it is technically safe as is,
    but we should change it for correctness.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index cd4a6f253d13..d52100d49b6c 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -197,7 +197,6 @@ struct ocfs2_super
 	struct ocfs2_node_map recovery_map;
 	struct ocfs2_node_map umount_map;
 
-	u32 num_clusters;
 	u64 root_blkno;
 	u64 system_dir_blkno;
 	u64 bitmap_blkno;

commit 784270435b001164054e803421a624ef1098519d
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu May 4 12:03:26 2006 -0700

    ocfs2: clean up some osb fields
    
    Get rid of osb->uuid, osb->proc_sub_dir, and osb->osb_id. Those fields were
    unused, or could easily be removed. As a result, we also no longer need
    MAX_OSB_ID or ocfs2_globals_lock.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index da1093039c01..cd4a6f253d13 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -184,7 +184,6 @@ struct ocfs2_journal;
 struct ocfs2_journal_handle;
 struct ocfs2_super
 {
-	u32 osb_id;		/* id used by the proc interface */
 	struct task_struct *commit_task;
 	struct super_block *sb;
 	struct inode *root_inode;
@@ -222,13 +221,11 @@ struct ocfs2_super
 	unsigned long s_mount_opt;
 
 	u16 max_slots;
-	u16 num_nodes;
 	s16 node_num;
 	s16 slot_num;
 	int s_sectsize_bits;
 	int s_clustersize;
 	int s_clustersize_bits;
-	struct proc_dir_entry *proc_sub_dir; /* points to /proc/fs/ocfs2/<maj_min> */
 
 	atomic_t vol_state;
 	struct mutex recovery_lock;
@@ -294,7 +291,6 @@ struct ocfs2_super
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)
-#define OCFS2_MAX_OSB_ID             65536
 
 static inline int ocfs2_should_order_data(struct inode *inode)
 {

commit b0697053f9e8de9cea3d510d9e290851ece9460b
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Mar 3 10:24:33 2006 -0800

    ocfs2: don't use MLF* in the file system
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index e89de9b6e491..da1093039c01 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -357,8 +357,8 @@ static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)
 #define OCFS2_RO_ON_INVALID_DINODE(__sb, __di)	do {			\
 	typeof(__di) ____di = (__di);					\
 	ocfs2_error((__sb), 						\
-		"Dinode # %"MLFu64" has bad signature %.*s",		\
-		(____di)->i_blkno, 7,					\
+		"Dinode # %llu has bad signature %.*s",			\
+		(unsigned long long)(____di)->i_blkno, 7,		\
 		(____di)->i_signature);					\
 } while (0);
 
@@ -368,8 +368,8 @@ static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)
 #define OCFS2_RO_ON_INVALID_EXTENT_BLOCK(__sb, __eb)	do {		\
 	typeof(__eb) ____eb = (__eb);					\
 	ocfs2_error((__sb), 						\
-		"Extent Block # %"MLFu64" has bad signature %.*s",	\
-		(____eb)->h_blkno, 7,					\
+		"Extent Block # %llu has bad signature %.*s",		\
+		(unsigned long long)(____eb)->h_blkno, 7,		\
 		(____eb)->h_signature);					\
 } while (0);
 
@@ -379,8 +379,8 @@ static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)
 #define OCFS2_RO_ON_INVALID_GROUP_DESC(__sb, __gd)	do {		\
 	typeof(__gd) ____gd = (__gd);					\
 		ocfs2_error((__sb),					\
-		"Group Descriptor # %"MLFu64" has bad signature %.*s",	\
-		(____gd)->bg_blkno, 7,					\
+		"Group Descriptor # %llu has bad signature %.*s",	\
+		(unsigned long long)(____gd)->bg_blkno, 7,		\
 		(____gd)->bg_signature);				\
 } while (0);
 

commit b4df6ed8db0c387d38292e31f00adc4cd297ed5a
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Wed Feb 22 17:35:08 2006 -0800

    [PATCH] ocfs2: fix orphan recovery deadlock
    
    Orphan dir recovery can deadlock with another process in
    ocfs2_delete_inode() in some corner cases. Fix this by tracking recovery
    state more closely and allowing it to handle inode wipes which might
    deadlock.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 19360e3d842e..e89de9b6e491 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -287,6 +287,10 @@ struct ocfs2_super
 	struct inode			*osb_tl_inode;
 	struct buffer_head		*osb_tl_bh;
 	struct work_struct		osb_truncate_log_wq;
+
+	struct ocfs2_node_map		osb_recovering_orphan_dirs;
+	unsigned int			*osb_orphan_wipes;
+	wait_queue_head_t		osb_wipe_event;
 };
 
 #define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)

commit d267a56c883b350a2fa80f1daf4636809e3f8e67
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Feb 23 13:23:39 2006 -0800

    [PATCH] ocfs2: remove unused code
    
    Remove some #ifdef'd out code which was inadvertantly introduced in our
    initial merge.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index 8d8e4779df92..19360e3d842e 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -174,9 +174,6 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_NOINTR  = 1 << 2,   /* Don't catch signals */
 	OCFS2_MOUNT_ERRORS_PANIC = 1 << 3, /* Panic on errors */
 	OCFS2_MOUNT_DATA_WRITEBACK = 1 << 4, /* No data ordering */
-#ifdef OCFS2_ORACORE_WORKAROUNDS
-	OCFS2_MOUNT_COMPAT_OCFS = 1 << 30, /* ocfs1 compatibility mode */
-#endif
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001

commit c74ec2f77a7763a4a56c6cb13ecab961e1bbb456
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Fri Jan 13 21:54:23 2006 -0800

    [PATCH] ocfs2: Semaphore to mutex conversion.
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
index f468c600cf92..8d8e4779df92 100644
--- a/fs/ocfs2/ocfs2.h
+++ b/fs/ocfs2/ocfs2.h
@@ -33,6 +33,7 @@
 #include <linux/rbtree.h>
 #include <linux/workqueue.h>
 #include <linux/kref.h>
+#include <linux/mutex.h>
 
 #include "cluster/nodemanager.h"
 #include "cluster/heartbeat.h"
@@ -233,7 +234,7 @@ struct ocfs2_super
 	struct proc_dir_entry *proc_sub_dir; /* points to /proc/fs/ocfs2/<maj_min> */
 
 	atomic_t vol_state;
-	struct semaphore recovery_lock;
+	struct mutex recovery_lock;
 	struct task_struct *recovery_thread_task;
 	int disable_recovery;
 	wait_queue_head_t checkpoint_event;

commit ccd979bdbce9fba8412beb3f1de68a9d0171b12c
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Dec 15 14:31:24 2005 -0800

    [PATCH] OCFS2: The Second Oracle Cluster Filesystem
    
    The OCFS2 file system module.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Kurt Hackel <kurt.hackel@oracle.com>

diff --git a/fs/ocfs2/ocfs2.h b/fs/ocfs2/ocfs2.h
new file mode 100644
index 000000000000..f468c600cf92
--- /dev/null
+++ b/fs/ocfs2/ocfs2.h
@@ -0,0 +1,464 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * ocfs2.h
+ *
+ * Defines macros and structures used in OCFS2
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef OCFS2_H
+#define OCFS2_H
+
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/rbtree.h>
+#include <linux/workqueue.h>
+#include <linux/kref.h>
+
+#include "cluster/nodemanager.h"
+#include "cluster/heartbeat.h"
+#include "cluster/tcp.h"
+
+#include "dlm/dlmapi.h"
+
+#include "ocfs2_fs.h"
+#include "endian.h"
+#include "ocfs2_lockid.h"
+
+struct ocfs2_extent_map {
+	u32		em_clusters;
+	struct rb_root	em_extents;
+};
+
+/* Most user visible OCFS2 inodes will have very few pieces of
+ * metadata, but larger files (including bitmaps, etc) must be taken
+ * into account when designing an access scheme. We allow a small
+ * amount of inlined blocks to be stored on an array and grow the
+ * structure into a rb tree when necessary. */
+#define OCFS2_INODE_MAX_CACHE_ARRAY 2
+
+struct ocfs2_caching_info {
+	unsigned int		ci_num_cached;
+	union {
+		sector_t	ci_array[OCFS2_INODE_MAX_CACHE_ARRAY];
+		struct rb_root	ci_tree;
+	} ci_cache;
+};
+
+/* this limits us to 256 nodes
+ * if we need more, we can do a kmalloc for the map */
+#define OCFS2_NODE_MAP_MAX_NODES    256
+struct ocfs2_node_map {
+	u16 num_nodes;
+	unsigned long map[BITS_TO_LONGS(OCFS2_NODE_MAP_MAX_NODES)];
+};
+
+enum ocfs2_ast_action {
+	OCFS2_AST_INVALID = 0,
+	OCFS2_AST_ATTACH,
+	OCFS2_AST_CONVERT,
+	OCFS2_AST_DOWNCONVERT,
+};
+
+/* actions for an unlockast function to take. */
+enum ocfs2_unlock_action {
+	OCFS2_UNLOCK_INVALID = 0,
+	OCFS2_UNLOCK_CANCEL_CONVERT,
+	OCFS2_UNLOCK_DROP_LOCK,
+};
+
+/* ocfs2_lock_res->l_flags flags. */
+#define OCFS2_LOCK_ATTACHED      (0x00000001) /* have we initialized
+					       * the lvb */
+#define OCFS2_LOCK_BUSY          (0x00000002) /* we are currently in
+					       * dlm_lock */
+#define OCFS2_LOCK_BLOCKED       (0x00000004) /* blocked waiting to
+					       * downconvert*/
+#define OCFS2_LOCK_LOCAL         (0x00000008) /* newly created inode */
+#define OCFS2_LOCK_NEEDS_REFRESH (0x00000010)
+#define OCFS2_LOCK_REFRESHING    (0x00000020)
+#define OCFS2_LOCK_INITIALIZED   (0x00000040) /* track initialization
+					       * for shutdown paths */
+#define OCFS2_LOCK_FREEING       (0x00000080) /* help dlmglue track
+					       * when to skip queueing
+					       * a lock because it's
+					       * about to be
+					       * dropped. */
+#define OCFS2_LOCK_QUEUED        (0x00000100) /* queued for downconvert */
+
+struct ocfs2_lock_res_ops;
+
+typedef void (*ocfs2_lock_callback)(int status, unsigned long data);
+
+struct ocfs2_lock_res {
+	void                    *l_priv;
+	struct ocfs2_lock_res_ops *l_ops;
+	spinlock_t               l_lock;
+
+	struct list_head         l_blocked_list;
+	struct list_head         l_mask_waiters;
+
+	enum ocfs2_lock_type     l_type;
+	unsigned long		 l_flags;
+	char                     l_name[OCFS2_LOCK_ID_MAX_LEN];
+	int                      l_level;
+	unsigned int             l_ro_holders;
+	unsigned int             l_ex_holders;
+	struct dlm_lockstatus    l_lksb;
+
+	/* used from AST/BAST funcs. */
+	enum ocfs2_ast_action    l_action;
+	enum ocfs2_unlock_action l_unlock_action;
+	int                      l_requested;
+	int                      l_blocking;
+
+	wait_queue_head_t        l_event;
+
+	struct list_head         l_debug_list;
+};
+
+struct ocfs2_dlm_debug {
+	struct kref d_refcnt;
+	struct dentry *d_locking_state;
+	struct list_head d_lockres_tracking;
+};
+
+enum ocfs2_vol_state
+{
+	VOLUME_INIT = 0,
+	VOLUME_MOUNTED,
+	VOLUME_DISMOUNTED,
+	VOLUME_DISABLED
+};
+
+struct ocfs2_alloc_stats
+{
+	atomic_t moves;
+	atomic_t local_data;
+	atomic_t bitmap_data;
+	atomic_t bg_allocs;
+	atomic_t bg_extends;
+};
+
+enum ocfs2_local_alloc_state
+{
+	OCFS2_LA_UNUSED = 0,
+	OCFS2_LA_ENABLED,
+	OCFS2_LA_DISABLED
+};
+
+enum ocfs2_mount_options
+{
+	OCFS2_MOUNT_HB_LOCAL   = 1 << 0, /* Heartbeat started in local mode */
+	OCFS2_MOUNT_BARRIER = 1 << 1,	/* Use block barriers */
+	OCFS2_MOUNT_NOINTR  = 1 << 2,   /* Don't catch signals */
+	OCFS2_MOUNT_ERRORS_PANIC = 1 << 3, /* Panic on errors */
+	OCFS2_MOUNT_DATA_WRITEBACK = 1 << 4, /* No data ordering */
+#ifdef OCFS2_ORACORE_WORKAROUNDS
+	OCFS2_MOUNT_COMPAT_OCFS = 1 << 30, /* ocfs1 compatibility mode */
+#endif
+};
+
+#define OCFS2_OSB_SOFT_RO	0x0001
+#define OCFS2_OSB_HARD_RO	0x0002
+#define OCFS2_OSB_ERROR_FS	0x0004
+
+struct ocfs2_journal;
+struct ocfs2_journal_handle;
+struct ocfs2_super
+{
+	u32 osb_id;		/* id used by the proc interface */
+	struct task_struct *commit_task;
+	struct super_block *sb;
+	struct inode *root_inode;
+	struct inode *sys_root_inode;
+	struct inode *system_inodes[NUM_SYSTEM_INODES];
+
+	struct ocfs2_slot_info *slot_info;
+
+	spinlock_t node_map_lock;
+	struct ocfs2_node_map mounted_map;
+	struct ocfs2_node_map recovery_map;
+	struct ocfs2_node_map umount_map;
+
+	u32 num_clusters;
+	u64 root_blkno;
+	u64 system_dir_blkno;
+	u64 bitmap_blkno;
+	u32 bitmap_cpg;
+	u8 *uuid;
+	char *uuid_str;
+	u8 *vol_label;
+	u64 first_cluster_group_blkno;
+	u32 fs_generation;
+
+	u32 s_feature_compat;
+	u32 s_feature_incompat;
+	u32 s_feature_ro_compat;
+
+	/* Protects s_next_generaion, osb_flags. Could protect more on
+	 * osb as it's very short lived. */
+	spinlock_t osb_lock;
+	u32 s_next_generation;
+	unsigned long osb_flags;
+
+	unsigned long s_mount_opt;
+
+	u16 max_slots;
+	u16 num_nodes;
+	s16 node_num;
+	s16 slot_num;
+	int s_sectsize_bits;
+	int s_clustersize;
+	int s_clustersize_bits;
+	struct proc_dir_entry *proc_sub_dir; /* points to /proc/fs/ocfs2/<maj_min> */
+
+	atomic_t vol_state;
+	struct semaphore recovery_lock;
+	struct task_struct *recovery_thread_task;
+	int disable_recovery;
+	wait_queue_head_t checkpoint_event;
+	atomic_t needs_checkpoint;
+	struct ocfs2_journal *journal;
+
+	enum ocfs2_local_alloc_state local_alloc_state;
+	struct buffer_head *local_alloc_bh;
+
+	/* Next two fields are for local node slot recovery during
+	 * mount. */
+	int dirty;
+	struct ocfs2_dinode *local_alloc_copy;
+
+	struct ocfs2_alloc_stats alloc_stats;
+	char dev_str[20];		/* "major,minor" of the device */
+
+	struct dlm_ctxt *dlm;
+	struct ocfs2_lock_res osb_super_lockres;
+	struct ocfs2_lock_res osb_rename_lockres;
+	struct dlm_eviction_cb osb_eviction_cb;
+	struct ocfs2_dlm_debug *osb_dlm_debug;
+
+	struct dentry *osb_debug_root;
+
+	wait_queue_head_t recovery_event;
+
+	spinlock_t vote_task_lock;
+	struct task_struct *vote_task;
+	wait_queue_head_t vote_event;
+	unsigned long vote_wake_sequence;
+	unsigned long vote_work_sequence;
+
+	struct list_head blocked_lock_list;
+	unsigned long blocked_lock_count;
+
+	struct list_head vote_list;
+	int vote_count;
+
+	u32 net_key;
+	spinlock_t net_response_lock;
+	unsigned int net_response_ids;
+	struct list_head net_response_list;
+
+	struct o2hb_callback_func osb_hb_up;
+	struct o2hb_callback_func osb_hb_down;
+
+	struct list_head	osb_net_handlers;
+
+	wait_queue_head_t		osb_mount_event;
+
+	/* Truncate log info */
+	struct inode			*osb_tl_inode;
+	struct buffer_head		*osb_tl_bh;
+	struct work_struct		osb_truncate_log_wq;
+};
+
+#define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)->s_fs_info)
+#define OCFS2_MAX_OSB_ID             65536
+
+static inline int ocfs2_should_order_data(struct inode *inode)
+{
+	if (!S_ISREG(inode->i_mode))
+		return 0;
+	if (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)
+		return 0;
+	return 1;
+}
+
+/* set / clear functions because cluster events can make these happen
+ * in parallel so we want the transitions to be atomic. this also
+ * means that any future flags osb_flags must be protected by spinlock
+ * too! */
+static inline void ocfs2_set_osb_flag(struct ocfs2_super *osb,
+				      unsigned long flag)
+{
+	spin_lock(&osb->osb_lock);
+	osb->osb_flags |= flag;
+	spin_unlock(&osb->osb_lock);
+}
+
+static inline void ocfs2_set_ro_flag(struct ocfs2_super *osb,
+				     int hard)
+{
+	spin_lock(&osb->osb_lock);
+	osb->osb_flags &= ~(OCFS2_OSB_SOFT_RO|OCFS2_OSB_HARD_RO);
+	if (hard)
+		osb->osb_flags |= OCFS2_OSB_HARD_RO;
+	else
+		osb->osb_flags |= OCFS2_OSB_SOFT_RO;
+	spin_unlock(&osb->osb_lock);
+}
+
+static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)
+{
+	int ret;
+
+	spin_lock(&osb->osb_lock);
+	ret = osb->osb_flags & OCFS2_OSB_HARD_RO;
+	spin_unlock(&osb->osb_lock);
+
+	return ret;
+}
+
+static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)
+{
+	int ret;
+
+	spin_lock(&osb->osb_lock);
+	ret = osb->osb_flags & OCFS2_OSB_SOFT_RO;
+	spin_unlock(&osb->osb_lock);
+
+	return ret;
+}
+
+#define OCFS2_IS_VALID_DINODE(ptr)					\
+	(!strcmp((ptr)->i_signature, OCFS2_INODE_SIGNATURE))
+
+#define OCFS2_RO_ON_INVALID_DINODE(__sb, __di)	do {			\
+	typeof(__di) ____di = (__di);					\
+	ocfs2_error((__sb), 						\
+		"Dinode # %"MLFu64" has bad signature %.*s",		\
+		(____di)->i_blkno, 7,					\
+		(____di)->i_signature);					\
+} while (0);
+
+#define OCFS2_IS_VALID_EXTENT_BLOCK(ptr)				\
+	(!strcmp((ptr)->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE))
+
+#define OCFS2_RO_ON_INVALID_EXTENT_BLOCK(__sb, __eb)	do {		\
+	typeof(__eb) ____eb = (__eb);					\
+	ocfs2_error((__sb), 						\
+		"Extent Block # %"MLFu64" has bad signature %.*s",	\
+		(____eb)->h_blkno, 7,					\
+		(____eb)->h_signature);					\
+} while (0);
+
+#define OCFS2_IS_VALID_GROUP_DESC(ptr)					\
+	(!strcmp((ptr)->bg_signature, OCFS2_GROUP_DESC_SIGNATURE))
+
+#define OCFS2_RO_ON_INVALID_GROUP_DESC(__sb, __gd)	do {		\
+	typeof(__gd) ____gd = (__gd);					\
+		ocfs2_error((__sb),					\
+		"Group Descriptor # %"MLFu64" has bad signature %.*s",	\
+		(____gd)->bg_blkno, 7,					\
+		(____gd)->bg_signature);				\
+} while (0);
+
+static inline unsigned long ino_from_blkno(struct super_block *sb,
+					   u64 blkno)
+{
+	return (unsigned long)(blkno & (u64)ULONG_MAX);
+}
+
+static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,
+					   u32 clusters)
+{
+	int c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -
+		sb->s_blocksize_bits;
+
+	return (u64)clusters << c_to_b_bits;
+}
+
+static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,
+					   u64 blocks)
+{
+	int b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -
+		sb->s_blocksize_bits;
+
+	return (u32)(blocks >> b_to_c_bits);
+}
+
+static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,
+						    u64 bytes)
+{
+	int cl_bits = OCFS2_SB(sb)->s_clustersize_bits;
+	unsigned int clusters;
+
+	bytes += OCFS2_SB(sb)->s_clustersize - 1;
+	/* OCFS2 just cannot have enough clusters to overflow this */
+	clusters = (unsigned int)(bytes >> cl_bits);
+
+	return clusters;
+}
+
+static inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,
+					 u64 bytes)
+{
+	bytes += sb->s_blocksize - 1;
+	return bytes >> sb->s_blocksize_bits;
+}
+
+static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,
+					  u32 clusters)
+{
+	return (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;
+}
+
+static inline u64 ocfs2_align_bytes_to_clusters(struct super_block *sb,
+						u64 bytes)
+{
+	int cl_bits = OCFS2_SB(sb)->s_clustersize_bits;
+	unsigned int clusters;
+
+	clusters = ocfs2_clusters_for_bytes(sb, bytes);
+	return (u64)clusters << cl_bits;
+}
+
+static inline u64 ocfs2_align_bytes_to_blocks(struct super_block *sb,
+					      u64 bytes)
+{
+	u64 blocks;
+
+        blocks = ocfs2_blocks_for_bytes(sb, bytes);
+	return blocks << sb->s_blocksize_bits;
+}
+
+static inline unsigned long ocfs2_align_bytes_to_sectors(u64 bytes)
+{
+	return (unsigned long)((bytes + 511) >> 9);
+}
+
+#define ocfs2_set_bit ext2_set_bit
+#define ocfs2_clear_bit ext2_clear_bit
+#define ocfs2_test_bit ext2_test_bit
+#define ocfs2_find_next_zero_bit ext2_find_next_zero_bit
+#endif  /* OCFS2_H */
+
