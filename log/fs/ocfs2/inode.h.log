commit 328970de0e39d596e0ef44080e7642224b29ecde
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 145
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 021110 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 84 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100844.756442981@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 9b955f732bca..51a4f7197987 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* -*- mode: c; c-basic-offset: 8; -*-
  * vim: noexpandtab sw=8 ts=8 sts=0:
  *
@@ -6,21 +7,6 @@
  * Function prototypes
  *
  * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
 #ifndef OCFS2_INODE_H

commit 84e40080bd6f363ddbcab75b04cb7bc742efbf12
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Wed Nov 9 14:13:09 2016 -0800

    ocfs2: convert inode refcount test to a helper
    
    Replace the open-coded inode refcount flag test with a helper function
    to reduce the potential for bugs.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 5af68fcdf9d3..9b955f732bca 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -181,4 +181,10 @@ static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_
 	return container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);
 }
 
+/* Does this inode have the reflink flag set? */
+static inline bool ocfs2_is_refcount_inode(struct inode *inode)
+{
+	return (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);
+}
+
 #endif /* OCFS2_INODE_H */

commit 48e509ece97e00b68e52d1d18e3e4b809c5b3991
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Fri Oct 7 16:57:20 2016 -0700

    ocfs2: fix undefined struct variable in inode.h
    
    The extern struct variable ocfs2_inode_cache is not defined. It meant to
    use ocfs2_inode_cachep defined in super.c, I think. Fortunately it is
    not used anywhere now, so no impact actually. Clean it up to fix this
    mistake.
    
    Link: http://lkml.kernel.org/r/57E1E49D.8050503@huawei.com
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Reviewed-by: Eric Ren <zren@suse.com>
    Cc: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 50cc55047443..5af68fcdf9d3 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -123,8 +123,6 @@ static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
 #define INODE_JOURNAL(i) (OCFS2_I(i)->ip_flags & OCFS2_INODE_JOURNAL)
 #define SET_INODE_JOURNAL(i) (OCFS2_I(i)->ip_flags |= OCFS2_INODE_JOURNAL)
 
-extern struct kmem_cache *ocfs2_inode_cache;
-
 extern const struct address_space_operations ocfs2_aops;
 extern const struct ocfs2_caching_operations ocfs2_inode_caching_ops;
 

commit 698d44b43a258006516538c27c8c4a8ab202e7d2
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Tue Jul 26 15:21:40 2016 -0700

    ocfs2: cleanup implemented prototypes
    
    Several prototypes in inode.h are just defined but not actually
    implemented and used, so remove them.
    
    Link: http://lkml.kernel.org/r/57763787.4020706@huawei.com
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index d8f3fc8d2551..50cc55047443 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -145,22 +145,15 @@ int ocfs2_drop_inode(struct inode *inode);
 struct inode *ocfs2_ilookup(struct super_block *sb, u64 feoff);
 struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, unsigned flags,
 			 int sysfile_type);
-int ocfs2_inode_init_private(struct inode *inode);
 int ocfs2_inode_revalidate(struct dentry *dentry);
 void ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,
 			  int create_ino);
-void ocfs2_read_inode(struct inode *inode);
-void ocfs2_read_inode2(struct inode *inode, void *opaque);
-ssize_t ocfs2_rw_direct(int rw, struct file *filp, char *buf,
-			size_t size, loff_t *offp);
 void ocfs2_sync_blockdev(struct super_block *sb);
 void ocfs2_refresh_inode(struct inode *inode,
 			 struct ocfs2_dinode *fe);
 int ocfs2_mark_inode_dirty(handle_t *handle,
 			   struct inode *inode,
 			   struct buffer_head *bh);
-struct buffer_head *ocfs2_bread(struct inode *inode,
-				int block, int *err, int reada);
 
 void ocfs2_set_inode_flags(struct inode *inode);
 void ocfs2_get_inode_flags(struct ocfs2_inode_info *oi);

commit e63890f38ade9497b5609ddeb7f52df0fe55ea15
Author: Ryan Ding <ryan.ding@oracle.com>
Date:   Fri Mar 25 14:21:15 2016 -0700

    ocfs2: fix ip_unaligned_aio deadlock with dio work queue
    
    In the current implementation of unaligned aio+dio, lock order behave as
    follow:
    
    in user process context:
      -> call io_submit()
        -> get i_mutex
                    <== window1
          -> get ip_unaligned_aio
            -> submit direct io to block device
        -> release i_mutex
      -> io_submit() return
    
    in dio work queue context(the work queue is created in __blockdev_direct_IO):
      -> release ip_unaligned_aio
                    <== window2
        -> get i_mutex
          -> clear unwritten flag & change i_size
        -> release i_mutex
    
    There is a limitation to the thread number of dio work queue.  256 at
    default.  If all 256 thread are in the above 'window2' stage, and there
    is a user process in the 'window1' stage, the system will became
    deadlock.  Since the user process hold i_mutex to wait ip_unaligned_aio
    lock, while there is a direct bio hold ip_unaligned_aio mutex who is
    waiting for a dio work queue thread to be schedule.  But all the dio
    work queue thread is waiting for i_mutex lock in 'window2'.
    
    This case only happened in a test which send a large number(more than
    256) of aio at one io_submit() call.
    
    My design is to remove ip_unaligned_aio lock.  Change it to a sync io
    instead.  Just like ip_unaligned_aio lock, serialize the unaligned aio
    dio.
    
    [akpm@linux-foundation.org: remove OCFS2_IOCB_UNALIGNED_IO, per Junxiao Bi]
    Signed-off-by: Ryan Ding <ryan.ding@oracle.com>
    Reviewed-by: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <joseph.qi@huawei.com>
    Cc: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 68e8cf9bda97..d8f3fc8d2551 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -43,9 +43,6 @@ struct ocfs2_inode_info
 	/* protects extended attribute changes on this inode */
 	struct rw_semaphore		ip_xattr_sem;
 
-	/* Number of outstanding AIO's which are not page aligned */
-	struct mutex			ip_unaligned_aio;
-
 	/* These fields are protected by ip_lock */
 	spinlock_t			ip_lock;
 	u32				ip_open_count;

commit 4506cfb6f8cad594ac73e0df2b2961ca10dbd25e
Author: Ryan Ding <ryan.ding@oracle.com>
Date:   Fri Mar 25 14:21:06 2016 -0700

    ocfs2: record UNWRITTEN extents when populate write desc
    
    To support direct io in ocfs2_write_begin_nolock & ocfs2_write_end_nolock.
    
    There is still one issue in the direct write procedure.
    
    phase 1: alloc extent with UNWRITTEN flag
    phase 2: submit direct data to disk, add zero page to page cache
    phase 3: clear UNWRITTEN flag when data has been written to disk
    
    When there are 2 direct write A(0~3KB),B(4~7KB) writing to the same
    cluster 0~7KB (cluster size 8KB).  Write request A arrive phase 2 first,
    it will zero the region (4~7KB).  Before request A enter to phase 3,
    request B arrive phase 2, it will zero region (0~3KB).  This is just like
    request B steps request A.
    
    To resolve this issue, we should let request B knows this cluster is already
    under zero, to prevent it from steps the previous write request.
    
    This patch will add function ocfs2_unwritten_check() to do this job.  It
    will record all clusters that are under direct write(it will be recorded
    in the 'ip_unwritten_list' member of inode info), and prevent the later
    direct write writing to the same cluster to do the zero work again.
    
    Signed-off-by: Ryan Ding <ryan.ding@oracle.com>
    Reviewed-by: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <joseph.qi@huawei.com>
    Cc: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 01635e016b3e..68e8cf9bda97 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -57,6 +57,9 @@ struct ocfs2_inode_info
 	u32				ip_flags; /* see below */
 	u32				ip_attr; /* inode attributes */
 
+	/* Record unwritten extents during direct io. */
+	struct list_head		ip_unwritten_list;
+
 	/* protected by recovery_lock. */
 	struct inode			*ip_next_orphan;
 

commit a860f6eb4c6a8bb0ca6860d9472f424bad9af9cf
Author: Gang He <ghe@suse.com>
Date:   Tue Mar 22 14:24:24 2016 -0700

    ocfs2: sysfile interfaces for online file check
    
    Implement online file check sysfile interfaces, e.g. how to create the
    related sysfile according to device name, how to display/handle file
    check request from the sysfile.
    
    Signed-off-by: Gang He <ghe@suse.com>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Joseph Qi <joseph.qi@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index aac8b86f312e..01635e016b3e 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -139,6 +139,9 @@ int ocfs2_drop_inode(struct inode *inode);
 /* Flags for ocfs2_iget() */
 #define OCFS2_FI_FLAG_SYSFILE		0x1
 #define OCFS2_FI_FLAG_ORPHAN_RECOVERY	0x2
+#define OCFS2_FI_FLAG_FILECHECK_CHK	0x4
+#define OCFS2_FI_FLAG_FILECHECK_FIX	0x8
+
 struct inode *ocfs2_ilookup(struct super_block *sb, u64 feoff);
 struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, unsigned flags,
 			 int sysfile_type);

commit 93d911fcce259a3f950ee20592beee31b855cd96
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Thu Nov 5 18:44:04 2015 -0800

    ocfs2: only take lock if dio entry when recover orphans
    
    We have no need to take inode mutex, rw and inode lock if it is not dio
    entry when recover orphans.  Optimize it by adding a flag
    OCFS2_INODE_DIO_ORPHAN_ENTRY to ocfs2_inode_info to reduce contention.
    
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Cc: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index ca3431ee7f24..aac8b86f312e 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -112,6 +112,8 @@ struct ocfs2_inode_info
 #define OCFS2_INODE_OPEN_DIRECT		0x00000020
 /* Tell the inode wipe code it's not in orphan dir */
 #define OCFS2_INODE_SKIP_ORPHAN_DIR     0x00000040
+/* Entry in orphan dir with 'dio-' prefix */
+#define OCFS2_INODE_DIO_ORPHAN_ENTRY	0x00000080
 
 static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
 {

commit 512f62acbdf1ee81ce4882c85835f5420a1c304c
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Fri Sep 4 15:43:37 2015 -0700

    ocfs2: fix race between dio and recover orphan
    
    During direct io the inode will be added to orphan first and then
    deleted from orphan.  There is a race window that the orphan entry will
    be deleted twice and thus trigger the BUG when validating
    OCFS2_DIO_ORPHANED_FL in ocfs2_del_inode_from_orphan.
    
    ocfs2_direct_IO_write
        ...
        ocfs2_add_inode_to_orphan
        >>>>>>>> race window.
                 1) another node may rm the file and then down, this node
                 take care of orphan recovery and clear flag
                 OCFS2_DIO_ORPHANED_FL.
                 2) since rw lock is unlocked, it may race with another
                 orphan recovery and append dio.
        ocfs2_del_inode_from_orphan
    
    So take inode mutex lock when recovering orphans and make rw unlock at the
    end of aio write in case of append dio.
    
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Reported-by: Yiwen Jiang <jiangyiwen@huawei.com>
    Cc: Weiwei Wang <wangww631@huawei.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 5e86b247c821..ca3431ee7f24 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -81,8 +81,6 @@ struct ocfs2_inode_info
 	tid_t i_sync_tid;
 	tid_t i_datasync_tid;
 
-	wait_queue_head_t append_dio_wq;
-
 	struct dquot *i_dquot[MAXQUOTAS];
 };
 

commit 4813962beef7586f890a645a1bda77691da4b74a
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Mon Feb 16 16:00:12 2015 -0800

    ocfs2: wait for orphan recovery first once append O_DIRECT write crash
    
    If one node has crashed with orphan entry leftover, another node which do
    append O_DIRECT write to the same file will override the
    i_dio_orphaned_slot.  Then the old entry won't be cleaned forever.  If
    this case happens, we let it wait for orphan recovery first.
    
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Cc: Weiwei Wang <wangww631@huawei.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Xuejiufei <xuejiufei@huawei.com>
    Cc: alex chen <alex.chen@huawei.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index ca3431ee7f24..5e86b247c821 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -81,6 +81,8 @@ struct ocfs2_inode_info
 	tid_t i_sync_tid;
 	tid_t i_datasync_tid;
 
+	wait_queue_head_t append_dio_wq;
+
 	struct dquot *i_dquot[MAXQUOTAS];
 };
 

commit 1c92ec678f32a4fdb9c0f7294b4d6f506b9a4b84
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 29 15:02:51 2014 +0200

    ocfs2: Convert to private i_dquot field
    
    CC: Mark Fasheh <mfasheh@suse.com>
    CC: Joel Becker <jlbec@evilplan.org>
    CC: ocfs2-devel@oss.oracle.com
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index a9b76de46047..ca3431ee7f24 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -80,6 +80,8 @@ struct ocfs2_inode_info
 	 */
 	tid_t i_sync_tid;
 	tid_t i_datasync_tid;
+
+	struct dquot *i_dquot[MAXQUOTAS];
 };
 
 /*

commit 7fa05c6e46d76378d4403669ba6ea38364f910ac
Author: Joseph Qi <joseph.qi@huawei.com>
Date:   Thu Oct 9 15:24:56 2014 -0700

    ocfs2: fix shift left operations overflow
    
    ocfs2_inode_info->ip_clusters and ocfs2_dinode->id1.bitmap1.i_total are
    defined as type u32, so the shift left operations may overflow if volume
    size is large, for example, 2TB and cluster size is 1MB.
    
    Signed-off-by: Joseph Qi <joseph.qi@huawei.com>
    Reviewed-by: Alex Chen <alex.chen@huawei.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index a6c991c0fc98..a9b76de46047 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -162,7 +162,7 @@ static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)
 {
 	int c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;
 
-	return (blkcnt_t)(OCFS2_I(inode)->ip_clusters << c_to_s_bits);
+	return (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;
 }
 
 /* Validate that a bh contains a valid inode */

commit 7bf619c1425d5f03e33c744921f6251f4d0d745f
Author: Jan Kara <jack@suse.cz>
Date:   Thu Apr 3 14:46:53 2014 -0700

    ocfs2: remove OCFS2_INODE_SKIP_DELETE flag
    
    The flag was never set, delete it.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Reviewed-by: Srinivas Eeda <srinivas.eeda@oracle.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 837e5e42af85..a6c991c0fc98 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -91,8 +91,6 @@ struct ocfs2_inode_info
 #define OCFS2_INODE_BITMAP		0x00000004
 /* This inode has been wiped from disk */
 #define OCFS2_INODE_DELETED		0x00000008
-/* Another node is deleting, so our delete is a nop */
-#define OCFS2_INODE_SKIP_DELETE		0x00000010
 /* Has the inode been orphaned on another node?
  *
  * This hints to ocfs2_drop_inode that it should clear i_nlink before
@@ -107,11 +105,11 @@ struct ocfs2_inode_info
  * rely on ocfs2_delete_inode to sort things out under the proper
  * cluster locks.
  */
-#define OCFS2_INODE_MAYBE_ORPHANED	0x00000020
+#define OCFS2_INODE_MAYBE_ORPHANED	0x00000010
 /* Does someone have the file open O_DIRECT */
-#define OCFS2_INODE_OPEN_DIRECT		0x00000040
+#define OCFS2_INODE_OPEN_DIRECT		0x00000020
 /* Tell the inode wipe code it's not in orphan dir */
-#define OCFS2_INODE_SKIP_ORPHAN_DIR     0x00000080
+#define OCFS2_INODE_SKIP_ORPHAN_DIR     0x00000040
 
 static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
 {

commit 2931cdcb49194503b19345c597b68fdcf78396f8
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Thu Apr 3 14:46:48 2014 -0700

    ocfs2: improve fsync efficiency and fix deadlock between aio_write and sync_file
    
    Currently, ocfs2_sync_file grabs i_mutex and forces the current journal
    transaction to complete.  This isn't terribly efficient, since sync_file
    really only needs to wait for the last transaction involving that inode
    to complete, and this doesn't require i_mutex.
    
    Therefore, implement the necessary bits to track the newest tid
    associated with an inode, and teach sync_file to wait for that instead
    of waiting for everything in the journal to commit.  Furthermore, only
    issue the flush request to the drive if jbd2 hasn't already done so.
    
    This also eliminates the deadlock between ocfs2_file_aio_write() and
    ocfs2_sync_file().  aio_write takes i_mutex then calls
    ocfs2_aiodio_wait() to wait for unaligned dio writes to finish.
    However, if that dio completion involves calling fsync, then we can get
    into trouble when some ocfs2_sync_file tries to take i_mutex.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 9f1580b506a5..837e5e42af85 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -73,6 +73,13 @@ struct ocfs2_inode_info
 	u32				ip_dir_lock_gen;
 
 	struct ocfs2_alloc_reservation	ip_la_data_resv;
+
+	/*
+	 * Transactions that contain inode's metadata needed to complete
+	 * fsync and fdatasync, respectively.
+	 */
+	tid_t i_sync_tid;
+	tid_t i_datasync_tid;
 };
 
 /*

commit c18ceab01240fd4c354b78d877571b729908e4a3
Author: Wengang Wang <wen.gang.wang@oracle.com>
Date:   Thu Apr 3 14:46:46 2014 -0700

    ocfs2: change ip_unaligned_aio to of type mutex from atomit_t
    
    There is a problem that waitqueue_active() may check stale data thus miss
    a wakeup of threads waiting on ip_unaligned_aio.
    
    The valid value of ip_unaligned_aio is only 0 and 1 so we can change it to
    be of type mutex thus the above prolem is avoid.  Another benifit is that
    mutex which works as FIFO is fairer than wake_up_all().
    
    Signed-off-by: Wengang Wang <wen.gang.wang@oracle.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 621fc73bf23d..9f1580b506a5 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -44,7 +44,7 @@ struct ocfs2_inode_info
 	struct rw_semaphore		ip_xattr_sem;
 
 	/* Number of outstanding AIO's which are not page aligned */
-	atomic_t			ip_unaligned_aio;
+	struct mutex			ip_unaligned_aio;
 
 	/* These fields are protected by ip_lock */
 	spinlock_t			ip_lock;

commit a27bb332c04cec8c4afd7912df0dc7890db27560
Author: Kent Overstreet <koverstreet@google.com>
Date:   Tue May 7 16:19:08 2013 -0700

    aio: don't include aio.h in sched.h
    
    Faster kernel compiles by way of fewer unnecessary includes.
    
    [akpm@linux-foundation.org: fix fallout]
    [akpm@linux-foundation.org: fix build]
    Signed-off-by: Kent Overstreet <koverstreet@google.com>
    Cc: Zach Brown <zab@redhat.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Asai Thambi S P <asamymuthupa@micron.com>
    Cc: Selvan Mani <smani@micron.com>
    Cc: Sam Bradshaw <sbradshaw@micron.com>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Benjamin LaHaise <bcrl@kvack.org>
    Reviewed-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 88924a3133fa..621fc73bf23d 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -147,8 +147,6 @@ void ocfs2_refresh_inode(struct inode *inode,
 int ocfs2_mark_inode_dirty(handle_t *handle,
 			   struct inode *inode,
 			   struct buffer_head *bh);
-int ocfs2_aio_read(struct file *file, struct kiocb *req, struct iocb *iocb);
-int ocfs2_aio_write(struct file *file, struct kiocb *req, struct iocb *iocb);
 struct buffer_head *ocfs2_bread(struct inode *inode,
 				int block, int *err, int reada);
 

commit a11f7e63c59810a81494d4c4b028af707d4c7ca4
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Wed Jun 22 14:23:38 2011 -0700

    ocfs2: serialize unaligned aio
    
    Fix a corruption that can happen when we have (two or more) outstanding
    aio's to an overlapping unaligned region.  Ext4
    (e9e3bcecf44c04b9e6b505fd8e2eb9cea58fb94d) and xfs recently had to fix
    similar issues.
    
    In our case what happens is that we can have an outstanding aio on a region
    and if a write comes in with some bytes overlapping the original aio we may
    decide to read that region into a page before continuing (typically because
    of buffered-io fallback).  Since we have no ordering guarantees with the
    aio, we can read stale or bad data into the page and then write it back out.
    
    If the i/o is page and block aligned, then we avoid this issue as there
    won't be any need to read data from disk.
    
    I took the same approach as Eric in the ext4 patch and introduced some
    serialization of unaligned async direct i/o.  I don't expect this to have an
    effect on the most common cases of AIO.  Unaligned aio will be slower
    though, but that's far more acceptable than data corruption.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Joel Becker <jlbec@evilplan.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 1c508b149b3a..88924a3133fa 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -43,6 +43,9 @@ struct ocfs2_inode_info
 	/* protects extended attribute changes on this inode */
 	struct rw_semaphore		ip_xattr_sem;
 
+	/* Number of outstanding AIO's which are not page aligned */
+	atomic_t			ip_unaligned_aio;
+
 	/* These fields are protected by ip_lock */
 	spinlock_t			ip_lock;
 	u32				ip_open_count;

commit 5e98d492406818e6a94c0ba54c61f59d40cefa4a
Author: Goldwyn Rodrigues <rgoldwyn@gmail.com>
Date:   Mon Jun 28 10:04:32 2010 -0500

    Track negative entries v3
    
    Track negative dentries by recording the generation number of the parent
    directory in d_fsdata. The generation number for the parent directory is
    recorded in the inode_info, which increments every time the lock on the
    directory is dropped.
    
    If the generation number of the parent directory and the negative dentry
    matches, there is no need to perform the revalidate, else a revalidate
    is forced. This improves performance in situations where nodes look for
    the same non-existent file multiple times.
    
    Thanks Mark for explaining the DLM sequence.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.de>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 0bc477a3aeb8..1c508b149b3a 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -67,6 +67,7 @@ struct ocfs2_inode_info
 	/* Only valid if the inode is the dir. */
 	u32				ip_last_used_slot;
 	u64				ip_last_used_group;
+	u32				ip_dir_lock_gen;
 
 	struct ocfs2_alloc_reservation	ip_la_data_resv;
 };

commit 83fd9c7f65634ac440a6b9b7a63ba562f213ac60
Author: Goldwyn Rodrigues <rgoldwyn@gmail.com>
Date:   Thu Jun 10 17:21:36 2010 -0500

    Reorganize data elements to reduce struct sizes
    
    Thanks for the comments. I have incorportated them all.
    
    CONFIG_OCFS2_FS_STATS is enabled and CONFIG_DEBUG_LOCK_ALLOC is disabled.
    Statistics now look like -
    ocfs2_write_ctxt: 2144 - 2136 = 8
    ocfs2_inode_info: 1960 - 1848 = 112
    ocfs2_journal: 168 - 160 = 8
    ocfs2_lock_res: 336 - 304 = 32
    ocfs2_refcount_tree: 512 - 472 = 40
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.de>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 6de5a869db30..0bc477a3aeb8 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -46,27 +46,24 @@ struct ocfs2_inode_info
 	/* These fields are protected by ip_lock */
 	spinlock_t			ip_lock;
 	u32				ip_open_count;
-	u32				ip_clusters;
 	struct list_head		ip_io_markers;
+	u32				ip_clusters;
 
+	u16				ip_dyn_features;
 	struct mutex			ip_io_mutex;
-
 	u32				ip_flags; /* see below */
 	u32				ip_attr; /* inode attributes */
-	u16				ip_dyn_features;
 
 	/* protected by recovery_lock. */
 	struct inode			*ip_next_orphan;
 
-	u32				ip_dir_start_lookup;
-
 	struct ocfs2_caching_info	ip_metadata_cache;
-
 	struct ocfs2_extent_map		ip_extent_map;
-
 	struct inode			vfs_inode;
 	struct jbd2_inode		ip_jinode;
 
+	u32				ip_dir_start_lookup;
+
 	/* Only valid if the inode is the dir. */
 	u32				ip_last_used_slot;
 	u64				ip_last_used_group;

commit 45321ac54316eaeeebde0b5f728a1791e500974c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 13:43:19 2010 -0400

    Make ->drop_inode() just return whether inode needs to be dropped
    
    ... and let iput_final() do the actual eviction or retention
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 975eedd7b243..6de5a869db30 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -124,7 +124,7 @@ static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)
 }
 
 void ocfs2_evict_inode(struct inode *inode);
-void ocfs2_drop_inode(struct inode *inode);
+int ocfs2_drop_inode(struct inode *inode);
 
 /* Flags for ocfs2_iget() */
 #define OCFS2_FI_FLAG_SYSFILE		0x1

commit 066d92dcbfa5842d98f6c4c671220cef50a9720f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 8 21:28:10 2010 -0400

    convert ocfs2 to ->evict_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 9f5f5fcadc45..975eedd7b243 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -123,8 +123,7 @@ static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)
 	return &OCFS2_I(inode)->ip_metadata_cache;
 }
 
-void ocfs2_clear_inode(struct inode *inode);
-void ocfs2_delete_inode(struct inode *inode);
+void ocfs2_evict_inode(struct inode *inode);
 void ocfs2_drop_inode(struct inode *inode);
 
 /* Flags for ocfs2_iget() */

commit 03e62303cf56e87337115f14842321043df2b4bb
Merge: 33cf23b0a535 18d3a98f3c1b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 21 07:20:17 2010 -0700

    Merge branch 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jlbec/ocfs2
    
    * 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jlbec/ocfs2: (47 commits)
      ocfs2: Silence a gcc warning.
      ocfs2: Don't retry xattr set in case value extension fails.
      ocfs2:dlm: avoid dlm->ast_lock lockres->spinlock dependency break
      ocfs2: Reset xattr value size after xa_cleanup_value_truncate().
      fs/ocfs2/dlm: Use kstrdup
      fs/ocfs2/dlm: Drop memory allocation cast
      Ocfs2: Optimize punching-hole code.
      Ocfs2: Make ocfs2_find_cpos_for_left_leaf() public.
      Ocfs2: Fix hole punching to correctly do CoW during cluster zeroing.
      Ocfs2: Optimize ocfs2 truncate to use ocfs2_remove_btree_range() instead.
      ocfs2: Block signals for mkdir/link/symlink/O_CREAT.
      ocfs2: Wrap signal blocking in void functions.
      ocfs2/dlm: Increase o2dlm lockres hash size
      ocfs2: Make ocfs2_extend_trans() really extend.
      ocfs2/trivial: Code cleanup for allocation reservation.
      ocfs2: make ocfs2_adjust_resv_from_alloc simple.
      ocfs2: Make nointr a default mount option
      ocfs2/dlm: Make o2dlm domain join/leave messages KERN_NOTICE
      o2net: log socket state changes
      ocfs2: print node # when tcp fails
      ...

commit 4fe370afaae49c57619bb0bedb75de7e7c168308
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Dec 7 13:15:40 2009 -0800

    ocfs2: use allocation reservations during file write
    
    Add a per-inode reservations structure and pass it through to the
    reservations code.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index ba4fe07b293c..e45edca02594 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -70,6 +70,8 @@ struct ocfs2_inode_info
 	/* Only valid if the inode is the dir. */
 	u32				ip_last_used_slot;
 	u64				ip_last_used_group;
+
+	struct ocfs2_alloc_reservation	ip_la_data_resv;
 };
 
 /*

commit d4cd1871cff68e188dadcf6d1280762522b643eb
Author: Li Dongyang <lidongyang@novell.com>
Date:   Thu Apr 22 16:11:19 2010 +0800

    ocfs2: add OCFS2_INODE_SKIP_ORPHAN_DIR flag and honor it in the inode wipe code
    
    Currently in the error path of ocfs2_symlink and ocfs2_mknod, we just call
    iput with the inode we failed with, but the inode wipe code will complain
    because we don't add the inode to orphan dir. One solution would be to lock
    the orphan dir during the entire transaction, but that's too heavy for a
    rare error path. Instead, we add a flag, OCFS2_INODE_SKIP_ORPHAN_DIR which
    tells the inode wipe code that it won't find this inode in the orphan dir.
    
    [ Merge fixes and comment style cleanups -Mark ]
    
    Signed-off-by: Li Dongyang <lidongyang@novell.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index ba4fe07b293c..0b28e1921a39 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -100,6 +100,8 @@ struct ocfs2_inode_info
 #define OCFS2_INODE_MAYBE_ORPHANED	0x00000020
 /* Does someone have the file open O_DIRECT */
 #define OCFS2_INODE_OPEN_DIRECT		0x00000040
+/* Tell the inode wipe code it's not in orphan dir */
+#define OCFS2_INODE_SKIP_ORPHAN_DIR     0x00000080
 
 static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
 {

commit 6136ca5f5f9fd38da399e9ff9380f537c1b3b901
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Feb 12 19:32:43 2009 -0800

    ocfs2: Drop struct inode from ocfs2_extent_tree_operations.
    
    We can get to the inode from the caching information.  Other parent
    types don't need it.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 67392f60629d..ba4fe07b293c 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -170,4 +170,10 @@ int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh);
 /* The same, but can be passed OCFS2_BH_* flags */
 int ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,
 				int flags);
+
+static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)
+{
+	return container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);
+}
+
 #endif /* OCFS2_INODE_H */

commit 292dd27ec76b96cebcef576f330ab121f59ccf05
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Feb 12 15:41:59 2009 -0800

    ocfs2: move ip_created_trans to struct ocfs2_caching_info
    
    Similar ip_last_trans, ip_created_trans tracks the creation of a journal
    managed inode.  This specifically tracks what transaction created the
    inode.  This is so the code can know if the inode has ever been written
    to disk.
    
    This behavior is desirable for any journal managed object.  We move it
    to struct ocfs2_caching_info as ci_created_trans so that any object
    using ocfs2_caching_info can rely on this behavior.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 2cae2514e7fb..67392f60629d 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -60,10 +60,6 @@ struct ocfs2_inode_info
 
 	u32				ip_dir_start_lookup;
 
-	/* next two are protected by trans_inc_lock */
-	/* which transaction were we created on? Zero if none. */
-	unsigned long			ip_created_trans;
-
 	struct ocfs2_caching_info	ip_metadata_cache;
 
 	struct ocfs2_extent_map		ip_extent_map;

commit 66fb345ddd2d343e36692da0ff66126d7a99dc1b
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Feb 12 15:24:40 2009 -0800

    ocfs2: move ip_last_trans to struct ocfs2_caching_info
    
    We have the read side of metadata caching isolated to struct
    ocfs2_caching_info, now we need the write side.  This means the journal
    functions.  The journal only does a couple of things with struct inode.
    
    This change moves the ip_last_trans field onto struct
    ocfs2_caching_info as ci_last_trans.  This field tells the journal
    whether a pending journal flush is required.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index b0a71b22712c..2cae2514e7fb 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -63,8 +63,6 @@ struct ocfs2_inode_info
 	/* next two are protected by trans_inc_lock */
 	/* which transaction were we created on? Zero if none. */
 	unsigned long			ip_created_trans;
-	/* last transaction we were a part of. */
-	unsigned long			ip_last_trans;
 
 	struct ocfs2_caching_info	ip_metadata_cache;
 

commit 8cb471e8f82506937fe5e2e9fb0bf90f6b1f1170
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Feb 10 20:00:41 2009 -0800

    ocfs2: Take the inode out of the metadata read/write paths.
    
    We are really passing the inode into the ocfs2_read/write_blocks()
    functions to get at the metadata cache.  This commit passes the cache
    directly into the metadata block functions, divorcing them from the
    inode.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index cd1caca545f5..b0a71b22712c 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -120,6 +120,11 @@ extern struct kmem_cache *ocfs2_inode_cache;
 extern const struct address_space_operations ocfs2_aops;
 extern const struct ocfs2_caching_operations ocfs2_inode_caching_ops;
 
+static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)
+{
+	return &OCFS2_I(inode)->ip_metadata_cache;
+}
+
 void ocfs2_clear_inode(struct inode *inode);
 void ocfs2_delete_inode(struct inode *inode);
 void ocfs2_drop_inode(struct inode *inode);

commit 6e5a3d7538ad4e46a976862f593faf65750e37cc
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Feb 10 19:00:37 2009 -0800

    ocfs2: Change metadata caching locks to an operations structure.
    
    We don't really want to cart around too many new fields on the
    ocfs2_caching_info structure.  So let's wrap all our access of the
    parent object in a set of operations.  One pointer on caching_info, and
    more flexibility to boot.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 2f5e1aa0ccbf..cd1caca545f5 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -118,6 +118,7 @@ static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
 extern struct kmem_cache *ocfs2_inode_cache;
 
 extern const struct address_space_operations ocfs2_aops;
+extern const struct ocfs2_caching_operations ocfs2_inode_caching_ops;
 
 void ocfs2_clear_inode(struct inode *inode);
 void ocfs2_delete_inode(struct inode *inode);

commit 47460d65a483529b3bc2bf6ccf461ad45f94df83
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Feb 10 16:05:07 2009 -0800

    ocfs2: Make the ocfs2_caching_info structure self-contained.
    
    We want to use the ocfs2_caching_info structure in places that are not
    inodes.  To do that, it can no longer rely on referencing the inode
    directly.
    
    This patch moves the flags to ocfs2_caching_info->ci_flags, stores
    pointers to the parent's locks on the ocfs2_caching_info, and renames
    the constants and flags to reflect its independant state.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index ea71525aad41..2f5e1aa0ccbf 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -106,8 +106,6 @@ struct ocfs2_inode_info
 #define OCFS2_INODE_MAYBE_ORPHANED	0x00000020
 /* Does someone have the file open O_DIRECT */
 #define OCFS2_INODE_OPEN_DIRECT		0x00000040
-/* Indicates that the metadata cache should be used as an array. */
-#define OCFS2_INODE_CACHE_INLINE	0x00000080
 
 static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
 {

commit 6ca497a83e592d64e050c4d04b6dedb8c915f39a
Author: wengang wang <wen.gang.wang@oracle.com>
Date:   Fri Mar 6 21:29:10 2009 +0800

    ocfs2: fix rare stale inode errors when exporting via nfs
    
    For nfs exporting, ocfs2_get_dentry() returns the dentry for fh.
    ocfs2_get_dentry() may read from disk when the inode is not in memory,
    without any cross cluster lock. this leads to the file system loading a
    stale inode.
    
    This patch fixes above problem.
    
    Solution is that in case of inode is not in memory, we get the cluster
    lock(PR) of alloc inode where the inode in question is allocated from (this
    causes node on which deletion is done sync the alloc inode) before reading
    out the inode itsself. then we check the bitmap in the group (the inode in
    question allcated from) to see if the bit is clear. if it's clear then it's
    stale. if the bit is set, we then check generation as the existing code
    does.
    
    We have to read out the inode in question from disk first to know its alloc
    slot and allot bit. And if its not stale we read it out using ocfs2_iget().
    The second read should then be from cache.
    
    And also we have to add a per superblock nfs_sync_lock to cover the lock for
    alloc inode and that for inode in question. this is because ocfs2_get_dentry()
    and ocfs2_delete_inode() lock on them in reverse order. nfs_sync_lock is locked
    in EX mode in ocfs2_get_dentry() and in PR mode in ocfs2_delete_inode(). so
    that mutliple ocfs2_delete_inode() can run concurrently in normal case.
    
    [mfasheh@suse.com: build warning fixes and comment cleanups]
    Signed-off-by: Wengang Wang <wen.gang.wang@oracle.com>
    Acked-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index e1978acbf65e..ea71525aad41 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -128,6 +128,7 @@ void ocfs2_drop_inode(struct inode *inode);
 /* Flags for ocfs2_iget() */
 #define OCFS2_FI_FLAG_SYSFILE		0x1
 #define OCFS2_FI_FLAG_ORPHAN_RECOVERY	0x2
+struct inode *ocfs2_ilookup(struct super_block *sb, u64 feoff);
 struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, unsigned flags,
 			 int sysfile_type);
 int ocfs2_inode_init_private(struct inode *inode);

commit 138211515c102807a16c02fdc15feef1f6ef8124
Author: Tao Ma <tao.ma@oracle.com>
Date:   Wed Feb 25 00:53:23 2009 +0800

    ocfs2: Optimize inode allocation by remembering last group
    
    In ocfs2, the inode block search looks for the "emptiest" inode
    group to allocate from. So if an inode alloc file has many equally
    (or almost equally) empty groups, new inodes will tend to get
    spread out amongst them, which in turn can put them all over the
    disk. This is undesirable because directory operations on conceptually
    "nearby" inodes force a large number of seeks.
    
    So we add ip_last_used_group in core directory inodes which records
    the last used allocation group. Another field named ip_last_used_slot
    is also added in case inode stealing happens. When claiming new inode,
    we passed in directory's inode so that the allocation can use this
    information.
    For more details, please see
    http://oss.oracle.com/osswiki/OCFS2/DesignDocs/InodeAllocationStrategy.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index eb3c302b38d3..e1978acbf65e 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -72,6 +72,10 @@ struct ocfs2_inode_info
 
 	struct inode			vfs_inode;
 	struct jbd2_inode		ip_jinode;
+
+	/* Only valid if the inode is the dir. */
+	u32				ip_last_used_slot;
+	u64				ip_last_used_group;
 };
 
 /*

commit 9e33d69f553aaf11377307e8d6f82deb3385e351
Author: Jan Kara <jack@suse.cz>
Date:   Mon Aug 25 19:56:50 2008 +0200

    ocfs2: Implementation of local and global quota file handling
    
    For each quota type each node has local quota file. In this file it stores
    changes users have made to disk usage via this node. Once in a while this
    information is synced to global file (and thus with other nodes) so that
    limits enforcement at least aproximately works.
    
    Global quota files contain all the information about usage and limits. It's
    mostly handled by the generic VFS code (which implements a trie of structures
    inside a quota file). We only have to provide functions to convert structures
    from on-disk format to in-memory one. We also have to provide wrappers for
    various quota functions starting transactions and acquiring necessary cluster
    locks before the actual IO is really started.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index b79c371a9d27..eb3c302b38d3 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -142,6 +142,8 @@ int ocfs2_mark_inode_dirty(handle_t *handle,
 			   struct buffer_head *bh);
 int ocfs2_aio_read(struct file *file, struct kiocb *req, struct iocb *iocb);
 int ocfs2_aio_write(struct file *file, struct kiocb *req, struct iocb *iocb);
+struct buffer_head *ocfs2_bread(struct inode *inode,
+				int block, int *err, int reada);
 
 void ocfs2_set_inode_flags(struct inode *inode);
 void ocfs2_get_inode_flags(struct ocfs2_inode_info *oi);

commit b657c95c11088d77fc1bfc9c84d940f778bf9d12
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Nov 13 14:49:11 2008 -0800

    ocfs2: Wrap inode block reads in a dedicated function.
    
    The ocfs2 code currently reads inodes off disk with a simple
    ocfs2_read_block() call.  Each place that does this has a different set
    of sanity checks it performs.  Some check only the signature.  A couple
    validate the block number (the block read vs di->i_blkno).  A couple
    others check for VALID_FL.  Only one place validates i_fs_generation.  A
    couple check nothing.  Even when an error is found, they don't all do
    the same thing.
    
    We wrap inode reading into ocfs2_read_inode_block().  This will validate
    all the above fields, going readonly if they are invalid (they never
    should be).  ocfs2_read_inode_block_full() is provided for the places
    that want to pass read_block flags.  Every caller is passing a struct
    inode with a valid ip_blkno, so we don't need a separate blkno argument
    either.
    
    We will remove the validation checks from the rest of the code in a
    later commit, as they are no longer necessary.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 2f37af9bcc4a..b79c371a9d27 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -128,8 +128,8 @@ struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, unsigned flags,
 			 int sysfile_type);
 int ocfs2_inode_init_private(struct inode *inode);
 int ocfs2_inode_revalidate(struct dentry *dentry);
-int ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,
-			 int create_ino);
+void ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,
+			  int create_ino);
 void ocfs2_read_inode(struct inode *inode);
 void ocfs2_read_inode2(struct inode *inode, void *opaque);
 ssize_t ocfs2_rw_direct(int rw, struct file *filp, char *buf,
@@ -153,4 +153,16 @@ static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)
 	return (blkcnt_t)(OCFS2_I(inode)->ip_clusters << c_to_s_bits);
 }
 
+/* Validate that a bh contains a valid inode */
+int ocfs2_validate_inode_block(struct super_block *sb,
+			       struct buffer_head *bh);
+/*
+ * Read an inode block into *bh.  If *bh is NULL, a bh will be allocated.
+ * This is a cached read.  The inode will be validated with
+ * ocfs2_validate_inode_block().
+ */
+int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh);
+/* The same, but can be passed OCFS2_BH_* flags */
+int ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,
+				int flags);
 #endif /* OCFS2_INODE_H */

commit 07446dc72cffcc6e2672d0e54061dcd1858725ba
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Oct 9 17:20:32 2008 -0700

    ocfs2: Move ocfs2_bread() into dir.c
    
    dir.c is the only place using ocfs2_bread(), so let's make it static to
    that file.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index f66e4340f178..2f37af9bcc4a 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -117,8 +117,6 @@ extern struct kmem_cache *ocfs2_inode_cache;
 
 extern const struct address_space_operations ocfs2_aops;
 
-struct buffer_head *ocfs2_bread(struct inode *inode, int block,
-				int *err, int reada);
 void ocfs2_clear_inode(struct inode *inode);
 void ocfs2_delete_inode(struct inode *inode);
 void ocfs2_drop_inode(struct inode *inode);

commit 2b4e30fbde425828b17f0e9c8f8e3fd3ecb2bc75
Author: Joel Becker <joel.becker@oracle.com>
Date:   Wed Sep 3 20:03:41 2008 -0700

    ocfs2: Switch over to JBD2.
    
    ocfs2 wants JBD2 for many reasons, not the least of which is that JBD is
    limiting our maximum filesystem size.
    
    It's a pretty trivial change.  Most functions are just renamed.  The
    only functional change is moving to Jan's inode-based ordered data mode.
    It's better, too.
    
    Because JBD2 reads and writes JBD journals, this is compatible with any
    existing filesystem.  It can even interact with JBD-based ocfs2 as long
    as the journal is formated for JBD.
    
    We provide a compatibility option so that paranoid people can still use
    JBD for the time being.  This will go away shortly.
    
    [ Moved call of ocfs2_begin_ordered_truncate() from ocfs2_delete_inode() to
      ocfs2_truncate_for_delete(). --Mark ]
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 499bc62e758b..f66e4340f178 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -71,6 +71,7 @@ struct ocfs2_inode_info
 	struct ocfs2_extent_map		ip_extent_map;
 
 	struct inode			vfs_inode;
+	struct jbd2_inode		ip_jinode;
 };
 
 /*

commit cf1d6c763fbcb115263114302485ad17e7933d87
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Mon Aug 18 17:11:00 2008 +0800

    ocfs2: Add extended attribute support
    
    This patch implements storing extended attributes both in inode or a single
    external block. We only store EA's in-inode when blocksize > 512 or that
    inode block has free space for it. When an EA's value is larger than 80
    bytes, we will store the value via b-tree outside inode or block.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 390a85596aa0..499bc62e758b 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -40,6 +40,9 @@ struct ocfs2_inode_info
 	/* protects allocation changes on this inode. */
 	struct rw_semaphore		ip_alloc_sem;
 
+	/* protects extended attribute changes on this inode */
+	struct rw_semaphore		ip_xattr_sem;
+
 	/* These fields are protected by ip_lock */
 	spinlock_t			ip_lock;
 	u32				ip_open_count;

commit 5fa0613ea58a80f69852b242337121bd39dc798e
Author: Jan Kara <jack@suse.cz>
Date:   Fri Jan 11 00:11:45 2008 +0100

    ocfs2: Silence false lockdep warnings
    
    Create separate lockdep lock classes for system file's i_mutexes. They are
    used to guard allocations and similar things and thus rank differently
    than i_mutex of a regular file or directory.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index a61c044eb7da..390a85596aa0 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -120,9 +120,10 @@ void ocfs2_delete_inode(struct inode *inode);
 void ocfs2_drop_inode(struct inode *inode);
 
 /* Flags for ocfs2_iget() */
-#define OCFS2_FI_FLAG_SYSFILE		0x4
-#define OCFS2_FI_FLAG_ORPHAN_RECOVERY	0x8
-struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, int flags);
+#define OCFS2_FI_FLAG_SYSFILE		0x1
+#define OCFS2_FI_FLAG_ORPHAN_RECOVERY	0x2
+struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, unsigned flags,
+			 int sysfile_type);
 int ocfs2_inode_init_private(struct inode *inode);
 int ocfs2_inode_revalidate(struct dentry *dentry);
 int ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,

commit e63aecb651ba73dffc62f9608ee1b7ae2a0ffd4b
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Oct 18 15:30:42 2007 -0700

    ocfs2: Rename ocfs2_meta_[un]lock
    
    Call this the "inode_lock" now, since it covers both data and meta data.
    This patch makes no functional changes.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index d1c54da687c9..a61c044eb7da 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -34,7 +34,7 @@ struct ocfs2_inode_info
 	u64			ip_blkno;
 
 	struct ocfs2_lock_res		ip_rw_lockres;
-	struct ocfs2_lock_res		ip_meta_lockres;
+	struct ocfs2_lock_res		ip_inode_lockres;
 	struct ocfs2_lock_res		ip_open_lockres;
 
 	/* protects allocation changes on this inode. */

commit c934a92d05b549dd2f25db72c5fc3cb9dcf1b611
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Oct 18 15:23:46 2007 -0700

    ocfs2: Remove data locks
    
    The meta lock now covers both meta data and data, so this just removes the
    now-redundant data lock.
    
    Combining locks saves us a round of lock mastery per inode and one less lock
    to ping between nodes during read/write.
    
    We don't lose much - since meta locks were always held before a data lock
    (and at the same level) ordered writeout mode (the default) ensured that
    flushing for the meta data lock also pushed out data anyways.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 70e881c55536..d1c54da687c9 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -35,7 +35,6 @@ struct ocfs2_inode_info
 
 	struct ocfs2_lock_res		ip_rw_lockres;
 	struct ocfs2_lock_res		ip_meta_lockres;
-	struct ocfs2_lock_res		ip_data_lockres;
 	struct ocfs2_lock_res		ip_open_lockres;
 
 	/* protects allocation changes on this inode. */

commit 15b1e36bdb487d67ef924a37b0967453143be53a
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Sep 7 13:58:15 2007 -0700

    ocfs2: Structure updates for inline data
    
    Add the disk, network and memory structures needed to support data in inode.
    
    Struct ocfs2_inline_data is defined and embedded in ocfs2_dinode for storing
    inline data.
    
    A new inode field, i_dyn_features, is added to facilitate tracking of
    dynamic inode state. Since it will be used often, we want to mirror it on
    ocfs2_inode_info, and transfer it via the meta data lvb.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Reviewed-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index a41d0817121b..70e881c55536 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -51,6 +51,7 @@ struct ocfs2_inode_info
 
 	u32				ip_flags; /* see below */
 	u32				ip_attr; /* inode attributes */
+	u16				ip_dyn_features;
 
 	/* protected by recovery_lock. */
 	struct inode			*ip_next_orphan;

commit 6e4b0d5692cd27d3c9be893a9f5939a9cafbb09f
Author: Jan Kara <jack@suse.cz>
Date:   Fri Apr 27 11:08:01 2007 -0700

    [PATCH] Copy i_flags to ocfs2 inode flags on write
    
    Propagate flags such as S_APPEND, S_IMMUTABLE, etc. from i_flags into
    ocfs2-specific ip_attr. Hence, when someone sets these flags via a different
    interface than ioctl, they are stored correctly.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 03ae075869ee..a41d0817121b 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -141,6 +141,7 @@ int ocfs2_aio_read(struct file *file, struct kiocb *req, struct iocb *iocb);
 int ocfs2_aio_write(struct file *file, struct kiocb *req, struct iocb *iocb);
 
 void ocfs2_set_inode_flags(struct inode *inode);
+void ocfs2_get_inode_flags(struct ocfs2_inode_info *oi);
 
 static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)
 {

commit 83418978827324918a8cd25ce5227312de1d4468
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Mon Apr 23 18:53:12 2007 -0700

    ocfs2: Cache extent records
    
    The extent map code was ripped out earlier because of an inability to deal
    with holes. This patch adds back a simpler caching scheme requiring far less
    code.
    
    Our old extent map caching was designed back when meta data block caching in
    Ocfs2 didn't work very well, resulting in many disk reads. These days our
    metadata caching is much better, resulting in no un-necessary disk reads. As
    a result, extent caching doesn't have to be as fancy, nor does it have to
    cache as many extents. Keeping the last 3 extents seen should be sufficient
    to give us a small performance boost on some streaming workloads.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index aa84353d0d19..03ae075869ee 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -26,6 +26,8 @@
 #ifndef OCFS2_INODE_H
 #define OCFS2_INODE_H
 
+#include "extent_map.h"
+
 /* OCFS2 Inode Private Data */
 struct ocfs2_inode_info
 {
@@ -63,6 +65,8 @@ struct ocfs2_inode_info
 
 	struct ocfs2_caching_info	ip_metadata_cache;
 
+	struct ocfs2_extent_map		ip_extent_map;
+
 	struct inode			vfs_inode;
 };
 

commit 8110b073a9135acf0a71bccfc20c0d1023f179c6
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Mar 22 16:53:23 2007 -0700

    ocfs2: Fix up i_blocks calculation to know about holes
    
    Older file systems which didn't support holes did a dumb calculation of
    i_blocks based on i_size. This is no longer accurate, so fix things up to
    take actual allocation into account.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index a9ced009cb9c..aa84353d0d19 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -138,4 +138,11 @@ int ocfs2_aio_write(struct file *file, struct kiocb *req, struct iocb *iocb);
 
 void ocfs2_set_inode_flags(struct inode *inode);
 
+static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)
+{
+	int c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;
+
+	return (blkcnt_t)(OCFS2_I(inode)->ip_clusters << c_to_s_bits);
+}
+
 #endif /* OCFS2_INODE_H */

commit 363041a5f74b953ab6b705ac9c88e5eda218a24b
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Wed Jan 17 12:31:35 2007 -0800

    ocfs2: temporarily remove extent map caching
    
    The code in extent_map.c is not prepared to deal with a subtree being
    rotated between lookups. This can happen when filling holes in sparse files.
    Instead of a lengthy patch to update the code (which would likely lose the
    benefit of caching subtree roots), we remove most of the algorithms and
    implement a simple path based lookup. A less ambitious extent caching scheme
    will be added in a later patch.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 042ae20a7132..a9ced009cb9c 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -43,7 +43,6 @@ struct ocfs2_inode_info
 	spinlock_t			ip_lock;
 	u32				ip_open_count;
 	u32				ip_clusters;
-	struct ocfs2_extent_map		ip_map;
 	struct list_head		ip_io_markers;
 
 	struct mutex			ip_io_mutex;

commit 68e2b740c4b5394680cfefccddbdb486c5866a4c
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Tue Mar 20 16:42:10 2007 -0700

    ocfs2: remove unused code
    
    Remove node messaging code that becomes unused with the delete inode vote
    removal.
    
    [Removed even more cruft which I spotted during review --Mark]
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 92d4feb34d74..042ae20a7132 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -45,7 +45,6 @@ struct ocfs2_inode_info
 	u32				ip_clusters;
 	struct ocfs2_extent_map		ip_map;
 	struct list_head		ip_io_markers;
-	int				ip_orphaned_slot;
 
 	struct mutex			ip_io_mutex;
 
@@ -118,14 +117,9 @@ void ocfs2_delete_inode(struct inode *inode);
 void ocfs2_drop_inode(struct inode *inode);
 
 /* Flags for ocfs2_iget() */
-#define OCFS2_FI_FLAG_NOWAIT	0x1
-#define OCFS2_FI_FLAG_DELETE	0x2
 #define OCFS2_FI_FLAG_SYSFILE		0x4
 #define OCFS2_FI_FLAG_ORPHAN_RECOVERY	0x8
 struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, int flags);
-struct inode *ocfs2_ilookup_for_vote(struct ocfs2_super *osb,
-				     u64 blkno,
-				     int delete_vote);
 int ocfs2_inode_init_private(struct inode *inode);
 int ocfs2_inode_revalidate(struct dentry *dentry);
 int ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,

commit 500086300e6dc5308a7328990bd50d17e075162b
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Tue Mar 20 16:01:38 2007 -0700

    ocfs2: Remove delete inode vote
    
    Ocfs2 currently does cluster-wide node messaging to check the open state of
    an inode during delete. This patch removes that mechanism in favor of an
    inode cluster lock which is taken at shared read when an inode is first read
    and dropped in clear_inode(). This allows a deleting node to test the
    liveness of an inode by attempting to take an exclusive lock.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 1a7dd2945b34..92d4feb34d74 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -34,6 +34,7 @@ struct ocfs2_inode_info
 	struct ocfs2_lock_res		ip_rw_lockres;
 	struct ocfs2_lock_res		ip_meta_lockres;
 	struct ocfs2_lock_res		ip_data_lockres;
+	struct ocfs2_lock_res		ip_open_lockres;
 
 	/* protects allocation changes on this inode. */
 	struct rw_semaphore		ip_alloc_sem;
@@ -119,8 +120,8 @@ void ocfs2_drop_inode(struct inode *inode);
 /* Flags for ocfs2_iget() */
 #define OCFS2_FI_FLAG_NOWAIT	0x1
 #define OCFS2_FI_FLAG_DELETE	0x2
-#define OCFS2_FI_FLAG_SYSFILE	0x4
-#define OCFS2_FI_FLAG_NOLOCK	0x8
+#define OCFS2_FI_FLAG_SYSFILE		0x4
+#define OCFS2_FI_FLAG_ORPHAN_RECOVERY	0x8
 struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, int flags);
 struct inode *ocfs2_ilookup_for_vote(struct ocfs2_super *osb,
 				     u64 blkno,

commit e18b890bb0881bbab6f4f1a6cd20d9c60d66b003
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:33:20 2006 -0800

    [PATCH] slab: remove kmem_cache_t
    
    Replace all uses of kmem_cache_t with struct kmem_cache.
    
    The patch was generated using the following script:
    
            #!/bin/sh
            #
            # Replace one string by another in all the kernel sources.
            #
    
            set -e
    
            for file in `find * -name "*.c" -o -name "*.h"|xargs grep -l $1`; do
                    quilt add $file
                    sed -e "1,\$s/$1/$2/g" $file >/tmp/$$
                    mv /tmp/$$ $file
                    quilt refresh
            done
    
    The script was run like this
    
            sh replace kmem_cache_t "struct kmem_cache"
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 46a378fbc40b..1a7dd2945b34 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -106,7 +106,7 @@ static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
 #define INODE_JOURNAL(i) (OCFS2_I(i)->ip_flags & OCFS2_INODE_JOURNAL)
 #define SET_INODE_JOURNAL(i) (OCFS2_I(i)->ip_flags |= OCFS2_INODE_JOURNAL)
 
-extern kmem_cache_t *ocfs2_inode_cache;
+extern struct kmem_cache *ocfs2_inode_cache;
 
 extern const struct address_space_operations ocfs2_aops;
 

commit 1fabe1481fac9e01bf8bffa60a2307ef379aa5de
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Mon Oct 9 18:11:45 2006 -0700

    ocfs2: Remove struct ocfs2_journal_handle in favor of handle_t
    
    This is mostly a search and replace as ocfs2_journal_handle is now no more
    than a container for a handle_t pointer.
    
    ocfs2_commit_trans() becomes very straight forward, and we remove some out
    of date comments / code.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 9b7354545cb4..46a378fbc40b 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -136,7 +136,7 @@ ssize_t ocfs2_rw_direct(int rw, struct file *filp, char *buf,
 void ocfs2_sync_blockdev(struct super_block *sb);
 void ocfs2_refresh_inode(struct inode *inode,
 			 struct ocfs2_dinode *fe);
-int ocfs2_mark_inode_dirty(struct ocfs2_journal_handle *handle,
+int ocfs2_mark_inode_dirty(handle_t *handle,
 			   struct inode *inode,
 			   struct buffer_head *bh);
 int ocfs2_aio_read(struct file *file, struct kiocb *req, struct iocb *iocb);

commit 02928a71ae6da6e3e205d99e1fa1a1f598ddb62d
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Oct 6 18:51:46 2006 -0700

    ocfs2: remove unused ocfs2_handle_add_inode()
    
    We can also delete the unused infrastructure which was once in place to
    support this functionality. ocfs2_inode_private loses ip_handle and
    ip_handle_list. ocfs2_journal_handle loses handle_list.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 9957810fdf85..9b7354545cb4 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -48,13 +48,6 @@ struct ocfs2_inode_info
 
 	struct mutex			ip_io_mutex;
 
-	/* Used by the journalling code to attach an inode to a
-	 * handle.  These are protected by ip_io_mutex in order to lock
-	 * out other I/O to the inode until we either commit or
-	 * abort. */
-	struct list_head		ip_handle_list;
-	struct ocfs2_journal_handle	*ip_handle;
-
 	u32				ip_flags; /* see below */
 	u32				ip_attr; /* inode attributes */
 

commit 24c19ef40474c3930597f31ae233dc06319bd881
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Sep 22 17:28:19 2006 -0700

    ocfs2: Remove i_generation from inode lock names
    
    OCFS2 puts inode meta data in the "lock value block" provided by the DLM.
    Typically, i_generation is encoded in the lock name so that a deleted inode
    on and a new one in the same block don't share the same lvb.
    
    Unfortunately, that scheme means that the read in ocfs2_read_locked_inode()
    is potentially thrown away as soon as the meta data lock is taken - we
    cannot encode the lock name without first knowing i_generation, which
    requires a disk read.
    
    This patch encodes i_generation in the inode meta data lvb, and removes the
    value from the inode meta data lock name. This way, the read can be covered
    by a lock, and at the same time we can distinguish between an up to date and
    a stale LVB.
    
    This will help cold-cache stat(2) performance in particular.
    
    Since this patch changes the protocol version, we take the opportunity to do
    a minor re-organization of two of the LVB fields.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 4d1e53992566..9957810fdf85 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -122,7 +122,13 @@ struct buffer_head *ocfs2_bread(struct inode *inode, int block,
 void ocfs2_clear_inode(struct inode *inode);
 void ocfs2_delete_inode(struct inode *inode);
 void ocfs2_drop_inode(struct inode *inode);
-struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff);
+
+/* Flags for ocfs2_iget() */
+#define OCFS2_FI_FLAG_NOWAIT	0x1
+#define OCFS2_FI_FLAG_DELETE	0x2
+#define OCFS2_FI_FLAG_SYSFILE	0x4
+#define OCFS2_FI_FLAG_NOLOCK	0x8
+struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff, int flags);
 struct inode *ocfs2_ilookup_for_vote(struct ocfs2_super *osb,
 				     u64 blkno,
 				     int delete_vote);

commit ca4d147e62df370c334898464023aa7f9126abe1
Author: Herbert Poetzl <herbert@13thfloor.at>
Date:   Mon Jul 3 17:27:12 2006 -0700

    ocfs2: add ext2 attributes
    
    Support immutable, and other attributes.
    
    Some renaming and other minor fixes done by myself.
    
    Signed-off-by: Herbert Poetzl <herbert@13thfloor.at>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 35140f6cf840..4d1e53992566 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -56,6 +56,7 @@ struct ocfs2_inode_info
 	struct ocfs2_journal_handle	*ip_handle;
 
 	u32				ip_flags; /* see below */
+	u32				ip_attr; /* inode attributes */
 
 	/* protected by recovery_lock. */
 	struct inode			*ip_next_orphan;
@@ -142,4 +143,6 @@ int ocfs2_mark_inode_dirty(struct ocfs2_journal_handle *handle,
 int ocfs2_aio_read(struct file *file, struct kiocb *req, struct iocb *iocb);
 int ocfs2_aio_write(struct file *file, struct kiocb *req, struct iocb *iocb);
 
+void ocfs2_set_inode_flags(struct inode *inode);
+
 #endif /* OCFS2_INODE_H */

commit f5e54d6e53a20cef45af7499e86164f0e0d16bb2
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jun 28 04:26:44 2006 -0700

    [PATCH] mark address_space_operations const
    
    Same as with already do with the file operations: keep them in .rodata and
    prevents people from doing runtime patching.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Steven French <sfrench@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 84c507961287..35140f6cf840 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -114,7 +114,7 @@ static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
 
 extern kmem_cache_t *ocfs2_inode_cache;
 
-extern struct address_space_operations ocfs2_aops;
+extern const struct address_space_operations ocfs2_aops;
 
 struct buffer_head *ocfs2_bread(struct inode *inode, int block,
 				int *err, int reada);

commit 251b6eccbeff4f0f8a3509769b327705e899f5dd
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Tue Jan 10 15:41:43 2006 -0800

    [OCFS2] Make ip_io_sem a mutex
    
    ip_io_sem is now ip_io_mutex.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
index 9b0177433653..84c507961287 100644
--- a/fs/ocfs2/inode.h
+++ b/fs/ocfs2/inode.h
@@ -46,10 +46,10 @@ struct ocfs2_inode_info
 	struct list_head		ip_io_markers;
 	int				ip_orphaned_slot;
 
-	struct semaphore		ip_io_sem;
+	struct mutex			ip_io_mutex;
 
 	/* Used by the journalling code to attach an inode to a
-	 * handle.  These are protected by ip_io_sem in order to lock
+	 * handle.  These are protected by ip_io_mutex in order to lock
 	 * out other I/O to the inode until we either commit or
 	 * abort. */
 	struct list_head		ip_handle_list;

commit ccd979bdbce9fba8412beb3f1de68a9d0171b12c
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Dec 15 14:31:24 2005 -0800

    [PATCH] OCFS2: The Second Oracle Cluster Filesystem
    
    The OCFS2 file system module.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Kurt Hackel <kurt.hackel@oracle.com>

diff --git a/fs/ocfs2/inode.h b/fs/ocfs2/inode.h
new file mode 100644
index 000000000000..9b0177433653
--- /dev/null
+++ b/fs/ocfs2/inode.h
@@ -0,0 +1,145 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * inode.h
+ *
+ * Function prototypes
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef OCFS2_INODE_H
+#define OCFS2_INODE_H
+
+/* OCFS2 Inode Private Data */
+struct ocfs2_inode_info
+{
+	u64			ip_blkno;
+
+	struct ocfs2_lock_res		ip_rw_lockres;
+	struct ocfs2_lock_res		ip_meta_lockres;
+	struct ocfs2_lock_res		ip_data_lockres;
+
+	/* protects allocation changes on this inode. */
+	struct rw_semaphore		ip_alloc_sem;
+
+	/* These fields are protected by ip_lock */
+	spinlock_t			ip_lock;
+	u32				ip_open_count;
+	u32				ip_clusters;
+	struct ocfs2_extent_map		ip_map;
+	struct list_head		ip_io_markers;
+	int				ip_orphaned_slot;
+
+	struct semaphore		ip_io_sem;
+
+	/* Used by the journalling code to attach an inode to a
+	 * handle.  These are protected by ip_io_sem in order to lock
+	 * out other I/O to the inode until we either commit or
+	 * abort. */
+	struct list_head		ip_handle_list;
+	struct ocfs2_journal_handle	*ip_handle;
+
+	u32				ip_flags; /* see below */
+
+	/* protected by recovery_lock. */
+	struct inode			*ip_next_orphan;
+
+	u32				ip_dir_start_lookup;
+
+	/* next two are protected by trans_inc_lock */
+	/* which transaction were we created on? Zero if none. */
+	unsigned long			ip_created_trans;
+	/* last transaction we were a part of. */
+	unsigned long			ip_last_trans;
+
+	struct ocfs2_caching_info	ip_metadata_cache;
+
+	struct inode			vfs_inode;
+};
+
+/*
+ * Flags for the ip_flags field
+ */
+/* System file inodes  */
+#define OCFS2_INODE_SYSTEM_FILE		0x00000001
+#define OCFS2_INODE_JOURNAL		0x00000002
+#define OCFS2_INODE_BITMAP		0x00000004
+/* This inode has been wiped from disk */
+#define OCFS2_INODE_DELETED		0x00000008
+/* Another node is deleting, so our delete is a nop */
+#define OCFS2_INODE_SKIP_DELETE		0x00000010
+/* Has the inode been orphaned on another node?
+ *
+ * This hints to ocfs2_drop_inode that it should clear i_nlink before
+ * continuing.
+ *
+ * We *only* set this on unlink vote from another node. If the inode
+ * was locally orphaned, then we're sure of the state and don't need
+ * to twiddle i_nlink later - it's either zero or not depending on
+ * whether our unlink succeeded. Otherwise we got this from a node
+ * whose intention was to orphan the inode, however he may have
+ * crashed, failed etc, so we let ocfs2_drop_inode zero the value and
+ * rely on ocfs2_delete_inode to sort things out under the proper
+ * cluster locks.
+ */
+#define OCFS2_INODE_MAYBE_ORPHANED	0x00000020
+/* Does someone have the file open O_DIRECT */
+#define OCFS2_INODE_OPEN_DIRECT		0x00000040
+/* Indicates that the metadata cache should be used as an array. */
+#define OCFS2_INODE_CACHE_INLINE	0x00000080
+
+static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)
+{
+	return container_of(inode, struct ocfs2_inode_info, vfs_inode);
+}
+
+#define INODE_JOURNAL(i) (OCFS2_I(i)->ip_flags & OCFS2_INODE_JOURNAL)
+#define SET_INODE_JOURNAL(i) (OCFS2_I(i)->ip_flags |= OCFS2_INODE_JOURNAL)
+
+extern kmem_cache_t *ocfs2_inode_cache;
+
+extern struct address_space_operations ocfs2_aops;
+
+struct buffer_head *ocfs2_bread(struct inode *inode, int block,
+				int *err, int reada);
+void ocfs2_clear_inode(struct inode *inode);
+void ocfs2_delete_inode(struct inode *inode);
+void ocfs2_drop_inode(struct inode *inode);
+struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 feoff);
+struct inode *ocfs2_ilookup_for_vote(struct ocfs2_super *osb,
+				     u64 blkno,
+				     int delete_vote);
+int ocfs2_inode_init_private(struct inode *inode);
+int ocfs2_inode_revalidate(struct dentry *dentry);
+int ocfs2_populate_inode(struct inode *inode, struct ocfs2_dinode *fe,
+			 int create_ino);
+void ocfs2_read_inode(struct inode *inode);
+void ocfs2_read_inode2(struct inode *inode, void *opaque);
+ssize_t ocfs2_rw_direct(int rw, struct file *filp, char *buf,
+			size_t size, loff_t *offp);
+void ocfs2_sync_blockdev(struct super_block *sb);
+void ocfs2_refresh_inode(struct inode *inode,
+			 struct ocfs2_dinode *fe);
+int ocfs2_mark_inode_dirty(struct ocfs2_journal_handle *handle,
+			   struct inode *inode,
+			   struct buffer_head *bh);
+int ocfs2_aio_read(struct file *file, struct kiocb *req, struct iocb *iocb);
+int ocfs2_aio_write(struct file *file, struct kiocb *req, struct iocb *iocb);
+
+#endif /* OCFS2_INODE_H */
