commit 328970de0e39d596e0ef44080e7642224b29ecde
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 145
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 021110 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 84 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100844.756442981@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 2d2501767c0c..f0a5d30a175d 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* -*- mode: c; c-basic-offset: 8; -*-
  * vim: noexpandtab sw=8 ts=8 sts=0:
  *
@@ -6,21 +7,6 @@
  * Defines sub allocator api
  *
  * Copyright (C) 2003, 2004 Oracle.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
 #ifndef _CHAINALLOC_H_

commit db66c71577d525c0cd65e66ff675747565783ba4
Author: Younger Liu <younger.liucn@gmail.com>
Date:   Thu Apr 3 14:47:10 2014 -0700

    ocfs2: rollback alloc_dinode counts when ocfs2_block_group_set_bits() failed
    
    After updating alloc_dinode counts in ocfs2_alloc_dinode_update_counts(),
    if ocfs2_alloc_dinode_update_bitmap() failed, there is a rare case that
    some space may be lost.
    
    So, roll back alloc_dinode counts when ocfs2_block_group_set_bits()
    failed.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Younger Liu <younger.liucn@gmail.com>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 218d8036b3e7..2d2501767c0c 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -91,6 +91,10 @@ int ocfs2_alloc_dinode_update_counts(struct inode *inode,
 			 struct buffer_head *di_bh,
 			 u32 num_bits,
 			 u16 chain);
+void ocfs2_rollback_alloc_dinode_counts(struct inode *inode,
+			 struct buffer_head *di_bh,
+			 u32 num_bits,
+			 u16 chain);
 int ocfs2_block_group_set_bits(handle_t *handle,
 			 struct inode *alloc_inode,
 			 struct ocfs2_group_desc *bg,

commit 0a2fcd8988ac682f443fd5b0a7c48154a7b42ef2
Author: Younger Liu <liuyiyang@hisense.com>
Date:   Tue Jan 21 15:48:33 2014 -0800

    ocfs2: remove redundant ocfs2_alloc_dinode_update_counts() and ocfs2_block_group_set_bits()
    
    ocfs2_alloc_dinode_update_counts() and ocfs2_block_group_set_bits() are
    already provided in suballoc.c.  So, the same functions in
    move_extents.c are not needed any more.
    
    Declare the functions in suballoc.h and remove redundant functions in
    move_extents.c.
    
    Signed-off-by: Younger Liu <liuyiyang@hisense.com>
    Cc: Younger Liu <younger.liucn@gmail.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index a36d0aa50911..218d8036b3e7 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -86,6 +86,18 @@ int ocfs2_reserve_clusters(struct ocfs2_super *osb,
 			   u32 bits_wanted,
 			   struct ocfs2_alloc_context **ac);
 
+int ocfs2_alloc_dinode_update_counts(struct inode *inode,
+			 handle_t *handle,
+			 struct buffer_head *di_bh,
+			 u32 num_bits,
+			 u16 chain);
+int ocfs2_block_group_set_bits(handle_t *handle,
+			 struct inode *alloc_inode,
+			 struct ocfs2_group_desc *bg,
+			 struct buffer_head *group_bh,
+			 unsigned int bit_off,
+			 unsigned int num_bits);
+
 int ocfs2_claim_metadata(handle_t *handle,
 			 struct ocfs2_alloc_context *ac,
 			 u32 bits_wanted,

commit 309a85b6861fedbb48a22d45e0e079d1be993b3a
Author: Xiaowei.Hu <xiaowei.hu@oracle.com>
Date:   Wed Feb 27 17:02:49 2013 -0800

    ocfs2: ac->ac_allow_chain_relink=0 won't disable group relink
    
    ocfs2_block_group_alloc_discontig() disables chain relink by setting
    ac->ac_allow_chain_relink = 0 because it grabs clusters from multiple
    cluster groups.
    
    It doesn't keep the credits for all chain relink,but
    ocfs2_claim_suballoc_bits overrides this in this call trace:
    ocfs2_block_group_claim_bits()->ocfs2_claim_clusters()->
    __ocfs2_claim_clusters()->ocfs2_claim_suballoc_bits()
    ocfs2_claim_suballoc_bits set ac->ac_allow_chain_relink = 1; then call
    ocfs2_search_chain() one time and disable it again, and then we run out
    of credits.
    
    Fix is to allow relink by default and disable it in
    ocfs2_block_group_alloc_discontig.
    
    Without this patch, End-users will run into a crash due to run out of
    credits, backtrace like this:
    
      RIP: 0010:[<ffffffffa0808b14>]  [<ffffffffa0808b14>]
      jbd2_journal_dirty_metadata+0x164/0x170 [jbd2]
      RSP: 0018:ffff8801b919b5b8  EFLAGS: 00010246
      RAX: 0000000000000000 RBX: ffff88022139ddc0 RCX: ffff880159f652d0
      RDX: ffff880178aa3000 RSI: ffff880159f652d0 RDI: ffff880087f09bf8
      RBP: ffff8801b919b5e8 R08: 0000000000000000 R09: 0000000000000000
      R10: 0000000000001e00 R11: 00000000000150b0 R12: ffff880159f652d0
      R13: ffff8801a0cae908 R14: ffff880087f09bf8 R15: ffff88018d177800
      FS:  00007fc9b0b6b6e0(0000) GS:ffff88022fd40000(0000) knlGS:0000000000000000
      CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
      CR2: 000000000040819c CR3: 0000000184017000 CR4: 00000000000006e0
      DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
      Process dd (pid: 9945, threadinfo ffff8801b919a000, task ffff880149a264c0)
      Call Trace:
        ocfs2_journal_dirty+0x2f/0x70 [ocfs2]
        ocfs2_relink_block_group+0x111/0x480 [ocfs2]
        ocfs2_search_chain+0x455/0x9a0 [ocfs2]
        ...
    
    Signed-off-by: Xiaowei.Hu <xiaowei.hu@oracle.com>
    Reviewed-by: Srinivas Eeda <srinivas.eeda@oracle.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index b8afabfeede4..a36d0aa50911 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -49,7 +49,7 @@ struct ocfs2_alloc_context {
 
 	/* these are used by the chain search */
 	u16    ac_chain;
-	int    ac_allow_chain_relink;
+	int    ac_disable_chain_relink;
 	group_search_t *ac_group_search;
 
 	u64    ac_last_group;

commit e49e27674d1dd2717ad90b21ece8f83102153315
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Fri Aug 13 15:15:17 2010 -0700

    ocfs2: allow return of new inode block location before allocation of the inode
    
    This allows code which needs to know the eventual block number of an inode
    but can't allocate it yet due to transaction or lock ordering. For example,
    ocfs2_create_inode_in_orphan() currently gives a junk blkno for preparation
    of the orphan dir because it can't yet know where the actual inode is placed
    - that code is actually in ocfs2_mknod_locked. This is a problem when the
    orphan dirs are indexed as the junk inode number will create an index entry
    which goes unused (and fails the later removal from the orphan dir).  Now
    with these interfaces, ocfs2_create_inode_in_orphan() can run the block
    group search (and get back the inode block number) *before* any actual
    allocation occurs.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Tao Ma <tao.ma@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index a017dd3ee7d9..b8afabfeede4 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -56,6 +56,9 @@ struct ocfs2_alloc_context {
 	u64    ac_max_block;  /* Highest block number to allocate. 0 is
 				 is the same as ~0 - unlimited */
 
+	int    ac_find_loc_only;  /* hack for reflink operation ordering */
+	struct ocfs2_suballoc_result *ac_find_loc_priv; /* */
+
 	struct ocfs2_alloc_reservation	*ac_resv;
 };
 
@@ -197,4 +200,22 @@ int ocfs2_lock_allocators(struct inode *inode, struct ocfs2_extent_tree *et,
 			  struct ocfs2_alloc_context **meta_ac);
 
 int ocfs2_test_inode_bit(struct ocfs2_super *osb, u64 blkno, int *res);
+
+
+
+/*
+ * The following two interfaces are for ocfs2_create_inode_in_orphan().
+ */
+int ocfs2_find_new_inode_loc(struct inode *dir,
+			     struct buffer_head *parent_fe_bh,
+			     struct ocfs2_alloc_context *ac,
+			     u64 *fe_blkno);
+
+int ocfs2_claim_new_inode_at_loc(handle_t *handle,
+				 struct inode *dir,
+				 struct ocfs2_alloc_context *ac,
+				 u64 *suballoc_loc,
+				 u16 *suballoc_bit,
+				 u64 di_blkno);
+
 #endif /* _CHAINALLOC_H_ */

commit 2b6cb576aa80611f1f6a3c88708d1e68a8d97985
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Mar 26 10:09:15 2010 +0800

    ocfs2: Set suballoc_loc on allocated metadata.
    
    Get the suballoc_loc from ocfs2_claim_new_inode() or
    ocfs2_claim_metadata().  Store it on the appropriate field of the block
    we just allocated.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 49b0b22d30cf..a017dd3ee7d9 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -86,6 +86,7 @@ int ocfs2_reserve_clusters(struct ocfs2_super *osb,
 int ocfs2_claim_metadata(handle_t *handle,
 			 struct ocfs2_alloc_context *ac,
 			 u32 bits_wanted,
+			 u64 *suballoc_loc,
 			 u16 *suballoc_bit_start,
 			 u32 *num_bits,
 			 u64 *blkno_start);
@@ -93,6 +94,7 @@ int ocfs2_claim_new_inode(handle_t *handle,
 			  struct inode *dir,
 			  struct buffer_head *parent_fe_bh,
 			  struct ocfs2_alloc_context *ac,
+			  u64 *suballoc_loc,
 			  u16 *suballoc_bit,
 			  u64 *fe_blkno);
 int ocfs2_claim_clusters(handle_t *handle,

commit 1ed9b777f77929ae961d6f9cdf828a07200ba71c
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu May 6 13:59:06 2010 +0800

    ocfs2: ocfs2_claim_*() don't need an ocfs2_super argument.
    
    They all take an ocfs2_alloc_context, which has the allocation inode.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Tao Ma <tao.ma@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index f5a22cd1640f..49b0b22d30cf 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -83,22 +83,19 @@ int ocfs2_reserve_clusters(struct ocfs2_super *osb,
 			   u32 bits_wanted,
 			   struct ocfs2_alloc_context **ac);
 
-int ocfs2_claim_metadata(struct ocfs2_super *osb,
-			 handle_t *handle,
+int ocfs2_claim_metadata(handle_t *handle,
 			 struct ocfs2_alloc_context *ac,
 			 u32 bits_wanted,
 			 u16 *suballoc_bit_start,
 			 u32 *num_bits,
 			 u64 *blkno_start);
-int ocfs2_claim_new_inode(struct ocfs2_super *osb,
-			  handle_t *handle,
+int ocfs2_claim_new_inode(handle_t *handle,
 			  struct inode *dir,
 			  struct buffer_head *parent_fe_bh,
 			  struct ocfs2_alloc_context *ac,
 			  u16 *suballoc_bit,
 			  u64 *fe_blkno);
-int ocfs2_claim_clusters(struct ocfs2_super *osb,
-			 handle_t *handle,
+int ocfs2_claim_clusters(handle_t *handle,
 			 struct ocfs2_alloc_context *ac,
 			 u32 min_clusters,
 			 u32 *cluster_start,
@@ -107,8 +104,7 @@ int ocfs2_claim_clusters(struct ocfs2_super *osb,
  * Use this variant of ocfs2_claim_clusters to specify a maxiumum
  * number of clusters smaller than the allocation reserved.
  */
-int __ocfs2_claim_clusters(struct ocfs2_super *osb,
-			   handle_t *handle,
+int __ocfs2_claim_clusters(handle_t *handle,
 			   struct ocfs2_alloc_context *ac,
 			   u32 min_clusters,
 			   u32 max_clusters,

commit 7d1fe093bf04124dcc50c5dde1765bd098464bfa
Author: Joel Becker <joel.becker@oracle.com>
Date:   Tue Apr 13 14:30:19 2010 +0800

    ocfs2: Pass suballocation results back via a structure.
    
    We're going to be adding more info to a suballocator allocation.  Rather
    than growing every function in the chain, let's pass a result structure
    around.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Tao Ma <tao.ma@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index da2f29a55ec3..f5a22cd1640f 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -26,13 +26,14 @@
 #ifndef _CHAINALLOC_H_
 #define _CHAINALLOC_H_
 
+struct ocfs2_suballoc_result;
 typedef int (group_search_t)(struct inode *,
 			     struct buffer_head *,
 			     u32,			/* bits_wanted */
 			     u32,			/* min_bits */
 			     u64,			/* max_block */
-			     u16 *,			/* *bit_off */
-			     u16 *);			/* *bits_found */
+			     struct ocfs2_suballoc_result *);
+							/* found bits */
 
 struct ocfs2_alloc_context {
 	struct inode *ac_inode;    /* which bitmap are we allocating from? */

commit d02f00cc057809d96c044cc72d5b9809d59f7d49
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Dec 7 13:10:48 2009 -0800

    ocfs2: allocation reservations
    
    This patch improves Ocfs2 allocation policy by allowing an inode to
    reserve a portion of the local alloc bitmap for itself. The reserved
    portion (allocation window) is advisory in that other allocation
    windows might steal it if the local alloc bitmap becomes
    full. Otherwise, the reservations are honored and guaranteed to be
    free. When the local alloc window is moved to a different portion of
    the bitmap, existing reservations are discarded.
    
    Reservation windows are represented internally by a red-black
    tree. Within that tree, each node represents the reservation window of
    one inode. An LRU of active reservations is also maintained. When new
    data is written, we allocate it from the inodes window. When all bits
    in a window are exhausted, we allocate a new one as close to the
    previous one as possible. Should we not find free space, an existing
    reservation is pulled off the LRU and cannibalized.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index e0f46df357e6..da2f29a55ec3 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -54,6 +54,8 @@ struct ocfs2_alloc_context {
 	u64    ac_last_group;
 	u64    ac_max_block;  /* Highest block number to allocate. 0 is
 				 is the same as ~0 - unlimited */
+
+	struct ocfs2_alloc_reservation	*ac_resv;
 };
 
 void ocfs2_init_steal_slots(struct ocfs2_super *osb);

commit b4414eea0e7b9c134262c801a87e338bf675962c
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Thu Mar 11 18:31:09 2010 -0800

    ocfs2: Clear undo bits when local alloc is freed
    
    When the local alloc file changes windows, unused bits are freed back to the
    global bitmap. By defnition, those bits can not be in use by any file. Also,
    the local alloc will never have been able to allocate those bits if they
    were part of a previous truncate. Therefore it makes sense that we should
    clear unused local alloc bits in the undo buffer so that they can be used
    immediatly.
    
    [ Modified to call it ocfs2_release_clusters() -- Joel ]
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index fa60723c43e8..e0f46df357e6 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -127,6 +127,11 @@ int ocfs2_free_clusters(handle_t *handle,
 			struct buffer_head *bitmap_bh,
 			u64 start_blk,
 			unsigned int num_clusters);
+int ocfs2_release_clusters(handle_t *handle,
+			   struct inode *bitmap_inode,
+			   struct buffer_head *bitmap_bh,
+			   u64 start_blk,
+			   unsigned int num_clusters);
 
 static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)
 {

commit b89c54282db0c8634a2d2dc200f196d571750ce5
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Mon Jan 25 14:11:06 2010 +0800

    ocfs2: add extent block stealing for ocfs2 v5
    
    This patch add extent block (metadata) stealing mechanism for
    extent allocation. This mechanism is same as the inode stealing.
    if no room in slot specific extent_alloc, we will try to
    allocate extent block from the next slot.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Acked-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 8c9a78a43164..fa60723c43e8 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -56,6 +56,7 @@ struct ocfs2_alloc_context {
 				 is the same as ~0 - unlimited */
 };
 
+void ocfs2_init_steal_slots(struct ocfs2_super *osb);
 void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac);
 static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)
 {

commit 6ca497a83e592d64e050c4d04b6dedb8c915f39a
Author: wengang wang <wen.gang.wang@oracle.com>
Date:   Fri Mar 6 21:29:10 2009 +0800

    ocfs2: fix rare stale inode errors when exporting via nfs
    
    For nfs exporting, ocfs2_get_dentry() returns the dentry for fh.
    ocfs2_get_dentry() may read from disk when the inode is not in memory,
    without any cross cluster lock. this leads to the file system loading a
    stale inode.
    
    This patch fixes above problem.
    
    Solution is that in case of inode is not in memory, we get the cluster
    lock(PR) of alloc inode where the inode in question is allocated from (this
    causes node on which deletion is done sync the alloc inode) before reading
    out the inode itsself. then we check the bitmap in the group (the inode in
    question allcated from) to see if the bit is clear. if it's clear then it's
    stale. if the bit is set, we then check generation as the existing code
    does.
    
    We have to read out the inode in question from disk first to know its alloc
    slot and allot bit. And if its not stale we read it out using ocfs2_iget().
    The second read should then be from cache.
    
    And also we have to add a per superblock nfs_sync_lock to cover the lock for
    alloc inode and that for inode in question. this is because ocfs2_get_dentry()
    and ocfs2_delete_inode() lock on them in reverse order. nfs_sync_lock is locked
    in EX mode in ocfs2_get_dentry() and in PR mode in ocfs2_delete_inode(). so
    that mutliple ocfs2_delete_inode() can run concurrently in normal case.
    
    [mfasheh@suse.com: build warning fixes and comment cleanups]
    Signed-off-by: Wengang Wang <wen.gang.wang@oracle.com>
    Acked-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index ea85a4c8b4b1..8c9a78a43164 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -188,4 +188,6 @@ int ocfs2_lock_allocators(struct inode *inode, struct ocfs2_extent_tree *et,
 			  u32 clusters_to_add, u32 extents_to_split,
 			  struct ocfs2_alloc_context **data_ac,
 			  struct ocfs2_alloc_context **meta_ac);
+
+int ocfs2_test_inode_bit(struct ocfs2_super *osb, u64 blkno, int *res);
 #endif /* _CHAINALLOC_H_ */

commit 138211515c102807a16c02fdc15feef1f6ef8124
Author: Tao Ma <tao.ma@oracle.com>
Date:   Wed Feb 25 00:53:23 2009 +0800

    ocfs2: Optimize inode allocation by remembering last group
    
    In ocfs2, the inode block search looks for the "emptiest" inode
    group to allocate from. So if an inode alloc file has many equally
    (or almost equally) empty groups, new inodes will tend to get
    spread out amongst them, which in turn can put them all over the
    disk. This is undesirable because directory operations on conceptually
    "nearby" inodes force a large number of seeks.
    
    So we add ip_last_used_group in core directory inodes which records
    the last used allocation group. Another field named ip_last_used_slot
    is also added in case inode stealing happens. When claiming new inode,
    we passed in directory's inode so that the allocation can use this
    information.
    For more details, please see
    http://oss.oracle.com/osswiki/OCFS2/DesignDocs/InodeAllocationStrategy.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index e3c13c77f9e8..ea85a4c8b4b1 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -88,6 +88,8 @@ int ocfs2_claim_metadata(struct ocfs2_super *osb,
 			 u64 *blkno_start);
 int ocfs2_claim_new_inode(struct ocfs2_super *osb,
 			  handle_t *handle,
+			  struct inode *dir,
+			  struct buffer_head *parent_fe_bh,
 			  struct ocfs2_alloc_context *ac,
 			  u16 *suballoc_bit,
 			  u64 *fe_blkno);

commit 970e4936d7d15f35d00fd15a14f5343ba78b2fc8
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Nov 13 14:49:19 2008 -0800

    ocfs2: Validate metadata only when it's read from disk.
    
    Add an optional validation hook to ocfs2_read_blocks().  Now the
    validation function is only called when a block was actually read off of
    disk.  It is not called when the buffer was in cache.
    
    We add a buffer state bit BH_NeedsValidate to flag these buffers.  It
    must always be one higher than the last JBD2 buffer state bit.
    
    The dinode, dirblock, extent_block, and xattr_block validators are
    lifted to this scheme directly.  The group_descriptor validator needs to
    be split into two pieces.  The first part only needs the gd buffer and
    is passed to ocfs2_read_block().  The second part requires the dinode as
    well, and is called every time.  It's only 3 compares, so it's tiny.
    This also allows us to clean up the non-fatal gd check used by resize.c.
    It now has no magic argument.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 43de4fd826d3..e3c13c77f9e8 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -165,16 +165,15 @@ void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac);
 u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster);
 
 /*
- * By default, ocfs2_validate_group_descriptor() calls ocfs2_error() when it
+ * By default, ocfs2_read_group_descriptor() calls ocfs2_error() when it
  * finds a problem.  A caller that wants to check a group descriptor
- * without going readonly passes a nonzero clean_error.  This is only
- * resize, really.  Everyone else should be using
- * ocfs2_read_group_descriptor().
+ * without going readonly should read the block with ocfs2_read_block[s]()
+ * and then checking it with this function.  This is only resize, really.
+ * Everyone else should be using ocfs2_read_group_descriptor().
  */
-int ocfs2_validate_group_descriptor(struct super_block *sb,
-				    struct ocfs2_dinode *di,
-				    struct buffer_head *bh,
-				    int clean_error);
+int ocfs2_check_group_descriptor(struct super_block *sb,
+				 struct ocfs2_dinode *di,
+				 struct buffer_head *bh);
 /*
  * Read a group descriptor block into *bh.  If *bh is NULL, a bh will be
  * allocated.  This is a cached read.  The descriptor will be validated with

commit 68f64d471be38631d7196b938d9809802dd467fa
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Nov 13 14:49:14 2008 -0800

    ocfs2: Wrap group descriptor reads in a dedicated function.
    
    We have a clean call for validating group descriptors, but every place
    that wants the always does a read_block()+validate() call pair.  Create
    a toplevel ocfs2_read_group_descriptor() that does the right
    thing.  This allows us to leverage the single call point later for
    fancier handling.  We also add validation of gd->bg_generation against
    the superblock and gd->bg_blkno against the block we thought we read.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 7adfcc478bdb..43de4fd826d3 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -164,23 +164,24 @@ void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac);
  * and return that block offset. */
 u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster);
 
-/* somewhat more expensive than our other checks, so use sparingly. */
 /*
  * By default, ocfs2_validate_group_descriptor() calls ocfs2_error() when it
  * finds a problem.  A caller that wants to check a group descriptor
  * without going readonly passes a nonzero clean_error.  This is only
- * resize, really.
+ * resize, really.  Everyone else should be using
+ * ocfs2_read_group_descriptor().
  */
 int ocfs2_validate_group_descriptor(struct super_block *sb,
 				    struct ocfs2_dinode *di,
-				    struct ocfs2_group_desc *gd,
+				    struct buffer_head *bh,
 				    int clean_error);
-static inline int ocfs2_check_group_descriptor(struct super_block *sb,
-					       struct ocfs2_dinode *di,
-					       struct ocfs2_group_desc *gd)
-{
-	return ocfs2_validate_group_descriptor(sb, di, gd, 0);
-}
+/*
+ * Read a group descriptor block into *bh.  If *bh is NULL, a bh will be
+ * allocated.  This is a cached read.  The descriptor will be validated with
+ * ocfs2_validate_group_descriptor().
+ */
+int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,
+				u64 gd_blkno, struct buffer_head **bh);
 
 int ocfs2_lock_allocators(struct inode *inode, struct ocfs2_extent_tree *et,
 			  u32 clusters_to_add, u32 extents_to_split,

commit 57e3e7971136003c96766346049aa73b82cab079
Author: Joel Becker <joel.becker@oracle.com>
Date:   Thu Nov 13 14:49:13 2008 -0800

    ocfs2: Consolidate validation of group descriptors.
    
    Currently the validation of group descriptors is directly duplicated so
    that one version can error the filesystem and the other (resize) can
    just report the problem.  Consolidate to one function that takes a
    boolean.  Wrap that function with the old call for the old users.
    
    This is in preparation for lifting the read+validate step into a
    single function.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 4df159d8f450..7adfcc478bdb 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -165,9 +165,23 @@ void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac);
 u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster);
 
 /* somewhat more expensive than our other checks, so use sparingly. */
-int ocfs2_check_group_descriptor(struct super_block *sb,
-				 struct ocfs2_dinode *di,
-				 struct ocfs2_group_desc *gd);
+/*
+ * By default, ocfs2_validate_group_descriptor() calls ocfs2_error() when it
+ * finds a problem.  A caller that wants to check a group descriptor
+ * without going readonly passes a nonzero clean_error.  This is only
+ * resize, really.
+ */
+int ocfs2_validate_group_descriptor(struct super_block *sb,
+				    struct ocfs2_dinode *di,
+				    struct ocfs2_group_desc *gd,
+				    int clean_error);
+static inline int ocfs2_check_group_descriptor(struct super_block *sb,
+					       struct ocfs2_dinode *di,
+					       struct ocfs2_group_desc *gd)
+{
+	return ocfs2_validate_group_descriptor(sb, di, gd, 0);
+}
+
 int ocfs2_lock_allocators(struct inode *inode, struct ocfs2_extent_tree *et,
 			  u32 clusters_to_add, u32 extents_to_split,
 			  struct ocfs2_alloc_context **data_ac,

commit 1187c968852e3c668f3b9376083851f81f6eee22
Author: Joel Becker <joel.becker@oracle.com>
Date:   Wed Sep 3 20:03:39 2008 -0700

    ocfs2: Limit inode allocation to 32bits.
    
    ocfs2 inode numbers are block numbers.  For any filesystem with less
    than 2^32 blocks, this is not a problem.  However, when ocfs2 starts
    using JDB2, it will be able to support filesystems with more than 2^32
    blocks.  This would result in inode numbers higher than 2^32.
    
    The problem is that stat(2) can't handle those numbers on 32bit
    machines.  The simple solution is to have ocfs2 allocate all inodes
    below that boundary.
    
    The suballoc code is changed to honor an optional block limit.  Only the
    inode suballocator sets that limit - all other allocations stay unlimited.
    
    The biggest trick is to grow the inode suballocator beneath that limit.
    There's no point in allocating block groups that are above the limit,
    then rejecting their elements later on.  We want to prevent the inode
    allocator from ever having block groups above the limit.  This involves
    a little gyration with the local alloc code.  If the local alloc window
    is above the limit, it signals the caller to try the global bitmap but
    does not disable the local alloc file (which can be used for other
    allocations).
    
    [ Minor cleanup - removed an ML_NOTICE comment. --Mark ]
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index dd0963695edc..4df159d8f450 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -28,10 +28,11 @@
 
 typedef int (group_search_t)(struct inode *,
 			     struct buffer_head *,
-			     u32,
-			     u32,
-			     u16 *,
-			     u16 *);
+			     u32,			/* bits_wanted */
+			     u32,			/* min_bits */
+			     u64,			/* max_block */
+			     u16 *,			/* *bit_off */
+			     u16 *);			/* *bits_found */
 
 struct ocfs2_alloc_context {
 	struct inode *ac_inode;    /* which bitmap are we allocating from? */
@@ -51,6 +52,8 @@ struct ocfs2_alloc_context {
 	group_search_t *ac_group_search;
 
 	u64    ac_last_group;
+	u64    ac_max_block;  /* Highest block number to allocate. 0 is
+				 is the same as ~0 - unlimited */
 };
 
 void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac);

commit f99b9b7ccf6a691f653cec45f36bfdd1e94769c7
Author: Joel Becker <joel.becker@oracle.com>
Date:   Wed Aug 20 19:36:33 2008 -0700

    ocfs2: Make ocfs2_extent_tree the first-class representation of a tree.
    
    We now have three different kinds of extent trees in ocfs2: inode data
    (dinode), extended attributes (xattr_tree), and extended attribute
    values (xattr_value).  There is a nice abstraction for them,
    ocfs2_extent_tree, but it is hidden in alloc.c.  All the calling
    functions have to pick amongst a varied API and pass in type bits and
    often extraneous pointers.
    
    A better way is to make ocfs2_extent_tree a first-class object.
    Everyone converts their object to an ocfs2_extent_tree() via the
    ocfs2_get_*_extent_tree() calls, then uses the ocfs2_extent_tree for all
    tree calls to alloc.c.
    
    This simplifies a lot of callers, making for readability.  It also
    provides an easy way to add additional extent tree types, as they only
    need to be defined in alloc.c with a ocfs2_get_<new>_extent_tree()
    function.
    
    Signed-off-by: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 028fd633b44e..dd0963695edc 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -165,10 +165,8 @@ u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster);
 int ocfs2_check_group_descriptor(struct super_block *sb,
 				 struct ocfs2_dinode *di,
 				 struct ocfs2_group_desc *gd);
-int ocfs2_lock_allocators(struct inode *inode, struct buffer_head *root_bh,
-			  struct ocfs2_extent_list *root_el,
+int ocfs2_lock_allocators(struct inode *inode, struct ocfs2_extent_tree *et,
 			  u32 clusters_to_add, u32 extents_to_split,
 			  struct ocfs2_alloc_context **data_ac,
-			  struct ocfs2_alloc_context **meta_ac,
-			  enum ocfs2_extent_tree_type type, void *private);
+			  struct ocfs2_alloc_context **meta_ac);
 #endif /* _CHAINALLOC_H_ */

commit cf1d6c763fbcb115263114302485ad17e7933d87
Author: Tiger Yang <tiger.yang@oracle.com>
Date:   Mon Aug 18 17:11:00 2008 +0800

    ocfs2: Add extended attribute support
    
    This patch implements storing extended attributes both in inode or a single
    external block. We only store EA's in-inode when blocksize > 512 or that
    inode block has free space for it. When an EA's value is larger than 80
    bytes, we will store the value via b-tree outside inode or block.
    
    Signed-off-by: Tiger Yang <tiger.yang@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 9e026c8afee4..028fd633b44e 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -67,6 +67,9 @@ static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)
 int ocfs2_reserve_new_metadata(struct ocfs2_super *osb,
 			       struct ocfs2_extent_list *root_el,
 			       struct ocfs2_alloc_context **ac);
+int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,
+				      int blocks,
+				      struct ocfs2_alloc_context **ac);
 int ocfs2_reserve_new_inode(struct ocfs2_super *osb,
 			    struct ocfs2_alloc_context **ac);
 int ocfs2_reserve_clusters(struct ocfs2_super *osb,

commit f56654c435c06f2b2bd5751889b1a08a3add7d6c
Author: Tao Ma <tao.ma@oracle.com>
Date:   Mon Aug 18 17:38:48 2008 +0800

    ocfs2: Add extent tree operation for xattr value btrees
    
    Add some thin wrappers around ocfs2_insert_extent() for each of the 3
    different btree types, ocfs2_inode_insert_extent(),
    ocfs2_xattr_value_insert_extent() and ocfs2_xattr_tree_insert_extent(). The
    last is for the xattr index btree, which will be used in a followup patch.
    
    All the old callers in file.c etc will call ocfs2_dinode_insert_extent(),
    while the other two handle the xattr issue. And the init of extent tree are
    handled by these functions.
    
    When storing xattr value which is too large, we will allocate some clusters
    for it and here ocfs2_extent_list and ocfs2_extent_rec will also be used. In
    order to re-use the b-tree operation code, a new parameter named "private"
    is added into ocfs2_extent_tree and it is used to indicate the root of
    ocfs2_exent_list. The reason is that we can't deduce the root from the
    buffer_head now. It may be in an inode, an ocfs2_xattr_block or even worse,
    in any place in an ocfs2_xattr_bucket.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index a3e531e62df2..9e026c8afee4 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -166,5 +166,6 @@ int ocfs2_lock_allocators(struct inode *inode, struct buffer_head *root_bh,
 			  struct ocfs2_extent_list *root_el,
 			  u32 clusters_to_add, u32 extents_to_split,
 			  struct ocfs2_alloc_context **data_ac,
-			  struct ocfs2_alloc_context **meta_ac);
+			  struct ocfs2_alloc_context **meta_ac,
+			  enum ocfs2_extent_tree_type type, void *private);
 #endif /* _CHAINALLOC_H_ */

commit e7d4cb6bc19658646357eeff134645cd9bc3479f
Author: Tao Ma <tao.ma@oracle.com>
Date:   Mon Aug 18 17:38:44 2008 +0800

    ocfs2: Abstract ocfs2_extent_tree in b-tree operations.
    
    In the old extent tree operation, we take the hypothesis that we
    are using the ocfs2_extent_list in ocfs2_dinode as the tree root.
    As xattr will also use ocfs2_extent_list to store large value
    for a xattr entry, we refactor the tree operation so that xattr
    can use it directly.
    
    The refactoring includes 4 steps:
    1. Abstract set/get of last_eb_blk and update_clusters since they may
       be stored in different location for dinode and xattr.
    2. Add a new structure named ocfs2_extent_tree to indicate the
       extent tree the operation will work on.
    3. Remove all the use of fe_bh and di, use root_bh and root_el in
       extent tree instead. So now all the fe_bh is replaced with
       et->root_bh, el with root_el accordingly.
    4. Make ocfs2_lock_allocators generic. Now it is limited to be only used
       in file extend allocation. But the whole function is useful when we want
       to store large EAs.
    
    Note: This patch doesn't touch ocfs2_commit_truncate() since it is not used
    for anything other than truncate inode data btrees.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 3f96c875bcf7..a3e531e62df2 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -162,4 +162,9 @@ u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster);
 int ocfs2_check_group_descriptor(struct super_block *sb,
 				 struct ocfs2_dinode *di,
 				 struct ocfs2_group_desc *gd);
+int ocfs2_lock_allocators(struct inode *inode, struct buffer_head *root_bh,
+			  struct ocfs2_extent_list *root_el,
+			  u32 clusters_to_add, u32 extents_to_split,
+			  struct ocfs2_alloc_context **data_ac,
+			  struct ocfs2_alloc_context **meta_ac);
 #endif /* _CHAINALLOC_H_ */

commit 811f933df1e55615fd0bb4818f31e3868a8e6e23
Author: Tao Ma <tao.ma@oracle.com>
Date:   Mon Aug 18 17:38:43 2008 +0800

    ocfs2: Use ocfs2_extent_list instead of ocfs2_dinode.
    
    ocfs2_extend_meta_needed(), ocfs2_calc_extend_credits() and
    ocfs2_reserve_new_metadata() are all useful for extent tree operations. But
    they are all limited to an inode btree because they use a struct
    ocfs2_dinode parameter. Change their parameter to struct ocfs2_extent_list
    (the part of an ocfs2_dinode they actually use) so that the xattr btree code
    can use these functions.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 40d51daf5fbc..3f96c875bcf7 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -59,8 +59,13 @@ static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)
 	return ac->ac_bits_wanted - ac->ac_bits_given;
 }
 
+/*
+ * Please note that the caller must make sure that root_el is the root
+ * of extent tree. So for an inode, it should be &fe->id2.i_list. Otherwise
+ * the result may be wrong.
+ */
 int ocfs2_reserve_new_metadata(struct ocfs2_super *osb,
-			       struct ocfs2_dinode *fe,
+			       struct ocfs2_extent_list *root_el,
 			       struct ocfs2_alloc_context **ac);
 int ocfs2_reserve_new_inode(struct ocfs2_super *osb,
 			    struct ocfs2_alloc_context **ac);

commit 9c7af40b210e87f8fddd97b0badc0a352862234a
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Mon Jul 28 18:02:53 2008 -0700

    ocfs2: throttle back local alloc when low on disk space
    
    Ocfs2's local allocator disables itself for the duration of a mount point
    when it has trouble allocating a large enough area from the primary bitmap.
    That can cause performance problems, especially for disks which were only
    temporarily full or fragmented. This patch allows for the allocator to
    shrink it's window first, before being disabled. Later, it can also be
    re-enabled so that any performance drop is minimized.
    
    To do this, we allow the value of osb->local_alloc_bits to be shrunk when
    needed. The default value is recorded in a mostly read-only variable so that
    we can re-initialize when required.
    
    Locking had to be updated so that we could protect changes to
    local_alloc_bits. Mostly this involves protecting various local alloc values
    with the osb spinlock. A new state is also added, OCFS2_LA_THROTTLED, which
    is used when the local allocator is has shrunk, but is not disabled. If the
    available space dips below 1 megabyte, the local alloc file is disabled. In
    either case, local alloc is re-enabled 30 seconds after the event, or when
    an appropriate amount of bits is seen in the primary bitmap.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 544c600662bd..40d51daf5fbc 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -147,6 +147,7 @@ static inline int ocfs2_is_cluster_bitmap(struct inode *inode)
  * apis above. */
 int ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,
 				      struct ocfs2_alloc_context *ac);
+void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac);
 
 /* given a cluster offset, calculate which block group it belongs to
  * and return that block offset. */

commit a4a4891164d4f6f383cc17e7c90828a7ca6a1146
Author: Tao Ma <tao.ma@oracle.com>
Date:   Mon Mar 3 17:12:30 2008 +0800

    ocfs2: Add ac_alloc_slot in ocfs2_alloc_context
    
    In inode stealing, we no longer restrict the allocation to
    happen in the local node. So it is neccessary for us to add
    a new member in ocfs2_alloc_context to indicate which slot
    we are using for allocation. We also modify the process of
    local alloc so that this member can be used there also.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 8799033bb459..544c600662bd 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -36,6 +36,7 @@ typedef int (group_search_t)(struct inode *,
 struct ocfs2_alloc_context {
 	struct inode *ac_inode;    /* which bitmap are we allocating from? */
 	struct buffer_head *ac_bh; /* file entry bh */
+	u32    ac_alloc_slot;   /* which slot are we allocating from? */
 	u32    ac_bits_wanted;
 	u32    ac_bits_given;
 #define OCFS2_AC_USE_LOCAL 1

commit d659072f736837e56b6433d58e5315ad1d4d5ccf
Author: Tao Ma <tao.ma@oracle.com>
Date:   Tue Dec 18 15:47:03 2007 +0800

    [PATCH 1/2] ocfs2: Add group extend for online resize
    
    This patch adds the ability for a userspace program to request an extend of
    last cluster group on an Ocfs2 file system. The request is made via ioctl,
    OCFS2_IOC_GROUP_EXTEND. This is derived from EXT3_IOC_GROUP_EXTEND, but is
    obviously Ocfs2 specific.
    
    tunefs.ocfs2 would call this for an online-resize operation if the last
    cluster group isn't full.
    
    Signed-off-by: Tao Ma <tao.ma@oracle.com>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index cafe93703095..8799033bb459 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -147,4 +147,12 @@ static inline int ocfs2_is_cluster_bitmap(struct inode *inode)
 int ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,
 				      struct ocfs2_alloc_context *ac);
 
+/* given a cluster offset, calculate which block group it belongs to
+ * and return that block offset. */
+u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster);
+
+/* somewhat more expensive than our other checks, so use sparingly. */
+int ocfs2_check_group_descriptor(struct super_block *sb,
+				 struct ocfs2_dinode *di,
+				 struct ocfs2_group_desc *gd);
 #endif /* _CHAINALLOC_H_ */

commit 415cb800375cc4e89fb5a6a454e484bd4adbffb4
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Sun Sep 16 20:10:16 2007 -0700

    ocfs2: Allow smaller allocations during large writes
    
    The ocfs2 write code loops through a page much like the block code, except
    that ocfs2 allocation units can be any size, including larger than page
    size. Typically it's equal to or larger than page size - most kernels run 4k
    pages, the minimum ocfs2 allocation (cluster) size.
    
    Some changes introduced during 2.6.23 changed the way writes to pages are
    handled, and inadvertantly broke support for > 4k page size. Instead of just
    writing one cluster at a time, we now handle the whole page in one pass.
    
    This means that multiple (small) seperate allocations might happen in the
    same pass. The allocation code howver typically optimizes by getting the
    maximum which was reserved. This triggered a BUG_ON in the extend code where
    it'd ask for a single bit (for one part of a > 4k page) and get back more
    than it asked for.
    
    Fix this by providing a variant of the high level allocation function which
    allows the caller to specify a maximum. The traditional function remains and
    just calls the new one with a maximum determined from the initial
    reservation.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index f212dc01a84b..cafe93703095 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -85,6 +85,17 @@ int ocfs2_claim_clusters(struct ocfs2_super *osb,
 			 u32 min_clusters,
 			 u32 *cluster_start,
 			 u32 *num_clusters);
+/*
+ * Use this variant of ocfs2_claim_clusters to specify a maxiumum
+ * number of clusters smaller than the allocation reserved.
+ */
+int __ocfs2_claim_clusters(struct ocfs2_super *osb,
+			   handle_t *handle,
+			   struct ocfs2_alloc_context *ac,
+			   u32 min_clusters,
+			   u32 max_clusters,
+			   u32 *cluster_start,
+			   u32 *num_clusters);
 
 int ocfs2_free_suballoc_bits(handle_t *handle,
 			     struct inode *alloc_inode,

commit 59a5e416d1ab543a5248a2b34d83202c4d55d132
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Jun 22 15:52:36 2007 -0700

    ocfs2: plug truncate into cached dealloc routines
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 7bc4819db4db..f212dc01a84b 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -96,10 +96,6 @@ int ocfs2_free_dinode(handle_t *handle,
 		      struct inode *inode_alloc_inode,
 		      struct buffer_head *inode_alloc_bh,
 		      struct ocfs2_dinode *di);
-int ocfs2_free_extent_block(handle_t *handle,
-			    struct inode *eb_alloc_inode,
-			    struct buffer_head *eb_alloc_bh,
-			    struct ocfs2_extent_block *eb);
 int ocfs2_free_clusters(handle_t *handle,
 			struct inode *bitmap_inode,
 			struct buffer_head *bitmap_bh,

commit 2b604351bc99b4e4504758cbac369b660b71de0b
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Jun 22 15:45:27 2007 -0700

    ocfs2: simplify deallocation locking
    
    Deallocation of suballocator blocks, most notably extent blocks, might
    involve multiple suballocator inodes.
    
    The locking for this can get extremely complicated, especially when the
    suballocator inodes to delete from aren't known until deep within an
    unrelated codepath.
    
    Implement a simple scheme for recording the blocks to be unlinked so that
    the actual deallocation can be done in a context which won't deadlock.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index 1a3c94cb9250..7bc4819db4db 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -86,6 +86,12 @@ int ocfs2_claim_clusters(struct ocfs2_super *osb,
 			 u32 *cluster_start,
 			 u32 *num_clusters);
 
+int ocfs2_free_suballoc_bits(handle_t *handle,
+			     struct inode *alloc_inode,
+			     struct buffer_head *alloc_bh,
+			     unsigned int start_bit,
+			     u64 bg_blkno,
+			     unsigned int count);
 int ocfs2_free_dinode(handle_t *handle,
 		      struct inode *inode_alloc_inode,
 		      struct buffer_head *inode_alloc_bh,
@@ -100,6 +106,13 @@ int ocfs2_free_clusters(handle_t *handle,
 			u64 start_blk,
 			unsigned int num_clusters);
 
+static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)
+{
+	u64 group = block - (u64) bit;
+
+	return group;
+}
+
 static inline u32 ocfs2_cluster_from_desc(struct ocfs2_super *osb,
 					  u64 bg_blkno)
 {

commit 1fabe1481fac9e01bf8bffa60a2307ef379aa5de
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Mon Oct 9 18:11:45 2006 -0700

    ocfs2: Remove struct ocfs2_journal_handle in favor of handle_t
    
    This is mostly a search and replace as ocfs2_journal_handle is now no more
    than a container for a handle_t pointer.
    
    ocfs2_commit_trans() becomes very straight forward, and we remove some out
    of date comments / code.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index e7c4b277c8d6..1a3c94cb9250 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -68,33 +68,33 @@ int ocfs2_reserve_clusters(struct ocfs2_super *osb,
 			   struct ocfs2_alloc_context **ac);
 
 int ocfs2_claim_metadata(struct ocfs2_super *osb,
-			 struct ocfs2_journal_handle *handle,
+			 handle_t *handle,
 			 struct ocfs2_alloc_context *ac,
 			 u32 bits_wanted,
 			 u16 *suballoc_bit_start,
 			 u32 *num_bits,
 			 u64 *blkno_start);
 int ocfs2_claim_new_inode(struct ocfs2_super *osb,
-			  struct ocfs2_journal_handle *handle,
+			  handle_t *handle,
 			  struct ocfs2_alloc_context *ac,
 			  u16 *suballoc_bit,
 			  u64 *fe_blkno);
 int ocfs2_claim_clusters(struct ocfs2_super *osb,
-			 struct ocfs2_journal_handle *handle,
+			 handle_t *handle,
 			 struct ocfs2_alloc_context *ac,
 			 u32 min_clusters,
 			 u32 *cluster_start,
 			 u32 *num_clusters);
 
-int ocfs2_free_dinode(struct ocfs2_journal_handle *handle,
+int ocfs2_free_dinode(handle_t *handle,
 		      struct inode *inode_alloc_inode,
 		      struct buffer_head *inode_alloc_bh,
 		      struct ocfs2_dinode *di);
-int ocfs2_free_extent_block(struct ocfs2_journal_handle *handle,
+int ocfs2_free_extent_block(handle_t *handle,
 			    struct inode *eb_alloc_inode,
 			    struct buffer_head *eb_alloc_bh,
 			    struct ocfs2_extent_block *eb);
-int ocfs2_free_clusters(struct ocfs2_journal_handle *handle,
+int ocfs2_free_clusters(handle_t *handle,
 			struct inode *bitmap_inode,
 			struct buffer_head *bitmap_bh,
 			u64 start_blk,

commit da5cbf2f9df922cfdafa39351691fa83517f1e25
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Oct 6 18:34:35 2006 -0700

    ocfs2: don't use handle for locking in allocation functions
    
    Instead we record our state on the allocation context structure which all
    callers already know about and lifetime correctly. This means the
    reservation functions don't need a handle passed in any more, and we can
    also take it off the alloc context.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index c787838d1052..e7c4b277c8d6 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -43,7 +43,6 @@ struct ocfs2_alloc_context {
 #define OCFS2_AC_USE_INODE 3
 #define OCFS2_AC_USE_META  4
 	u32    ac_which;
-	struct ocfs2_journal_handle *ac_handle;
 
 	/* these are used by the chain search */
 	u16    ac_chain;
@@ -60,14 +59,11 @@ static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)
 }
 
 int ocfs2_reserve_new_metadata(struct ocfs2_super *osb,
-			       struct ocfs2_journal_handle *handle,
 			       struct ocfs2_dinode *fe,
 			       struct ocfs2_alloc_context **ac);
 int ocfs2_reserve_new_inode(struct ocfs2_super *osb,
-			    struct ocfs2_journal_handle *handle,
 			    struct ocfs2_alloc_context **ac);
 int ocfs2_reserve_clusters(struct ocfs2_super *osb,
-			   struct ocfs2_journal_handle *handle,
 			   u32 bits_wanted,
 			   struct ocfs2_alloc_context **ac);
 

commit 883d4cae4a2b01a05193cf2665c77b7489a8b6a0
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Mon Jun 5 16:41:00 2006 -0400

    ocfs2: allocation hints
    
    Record the most recently used allocation group on the allocation context, so
    that subsequent allocations can attempt to optimize for contiguousness.
    Local alloc especially should benefit from this as the current chain search
    tends to let it spew across the disk.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
index a76c82a7ceac..c787838d1052 100644
--- a/fs/ocfs2/suballoc.h
+++ b/fs/ocfs2/suballoc.h
@@ -49,6 +49,8 @@ struct ocfs2_alloc_context {
 	u16    ac_chain;
 	int    ac_allow_chain_relink;
 	group_search_t *ac_group_search;
+
+	u64    ac_last_group;
 };
 
 void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac);

commit ccd979bdbce9fba8412beb3f1de68a9d0171b12c
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Dec 15 14:31:24 2005 -0800

    [PATCH] OCFS2: The Second Oracle Cluster Filesystem
    
    The OCFS2 file system module.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Kurt Hackel <kurt.hackel@oracle.com>

diff --git a/fs/ocfs2/suballoc.h b/fs/ocfs2/suballoc.h
new file mode 100644
index 000000000000..a76c82a7ceac
--- /dev/null
+++ b/fs/ocfs2/suballoc.h
@@ -0,0 +1,132 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * suballoc.h
+ *
+ * Defines sub allocator api
+ *
+ * Copyright (C) 2003, 2004 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef _CHAINALLOC_H_
+#define _CHAINALLOC_H_
+
+typedef int (group_search_t)(struct inode *,
+			     struct buffer_head *,
+			     u32,
+			     u32,
+			     u16 *,
+			     u16 *);
+
+struct ocfs2_alloc_context {
+	struct inode *ac_inode;    /* which bitmap are we allocating from? */
+	struct buffer_head *ac_bh; /* file entry bh */
+	u32    ac_bits_wanted;
+	u32    ac_bits_given;
+#define OCFS2_AC_USE_LOCAL 1
+#define OCFS2_AC_USE_MAIN  2
+#define OCFS2_AC_USE_INODE 3
+#define OCFS2_AC_USE_META  4
+	u32    ac_which;
+	struct ocfs2_journal_handle *ac_handle;
+
+	/* these are used by the chain search */
+	u16    ac_chain;
+	int    ac_allow_chain_relink;
+	group_search_t *ac_group_search;
+};
+
+void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac);
+static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)
+{
+	return ac->ac_bits_wanted - ac->ac_bits_given;
+}
+
+int ocfs2_reserve_new_metadata(struct ocfs2_super *osb,
+			       struct ocfs2_journal_handle *handle,
+			       struct ocfs2_dinode *fe,
+			       struct ocfs2_alloc_context **ac);
+int ocfs2_reserve_new_inode(struct ocfs2_super *osb,
+			    struct ocfs2_journal_handle *handle,
+			    struct ocfs2_alloc_context **ac);
+int ocfs2_reserve_clusters(struct ocfs2_super *osb,
+			   struct ocfs2_journal_handle *handle,
+			   u32 bits_wanted,
+			   struct ocfs2_alloc_context **ac);
+
+int ocfs2_claim_metadata(struct ocfs2_super *osb,
+			 struct ocfs2_journal_handle *handle,
+			 struct ocfs2_alloc_context *ac,
+			 u32 bits_wanted,
+			 u16 *suballoc_bit_start,
+			 u32 *num_bits,
+			 u64 *blkno_start);
+int ocfs2_claim_new_inode(struct ocfs2_super *osb,
+			  struct ocfs2_journal_handle *handle,
+			  struct ocfs2_alloc_context *ac,
+			  u16 *suballoc_bit,
+			  u64 *fe_blkno);
+int ocfs2_claim_clusters(struct ocfs2_super *osb,
+			 struct ocfs2_journal_handle *handle,
+			 struct ocfs2_alloc_context *ac,
+			 u32 min_clusters,
+			 u32 *cluster_start,
+			 u32 *num_clusters);
+
+int ocfs2_free_dinode(struct ocfs2_journal_handle *handle,
+		      struct inode *inode_alloc_inode,
+		      struct buffer_head *inode_alloc_bh,
+		      struct ocfs2_dinode *di);
+int ocfs2_free_extent_block(struct ocfs2_journal_handle *handle,
+			    struct inode *eb_alloc_inode,
+			    struct buffer_head *eb_alloc_bh,
+			    struct ocfs2_extent_block *eb);
+int ocfs2_free_clusters(struct ocfs2_journal_handle *handle,
+			struct inode *bitmap_inode,
+			struct buffer_head *bitmap_bh,
+			u64 start_blk,
+			unsigned int num_clusters);
+
+static inline u32 ocfs2_cluster_from_desc(struct ocfs2_super *osb,
+					  u64 bg_blkno)
+{
+	/* This should work for all block group descriptors as only
+	 * the 1st group descriptor of the cluster bitmap is
+	 * different. */
+
+	if (bg_blkno == osb->first_cluster_group_blkno)
+		return 0;
+
+	/* the rest of the block groups are located at the beginning
+	 * of their 1st cluster, so a direct translation just
+	 * works. */
+	return ocfs2_blocks_to_clusters(osb->sb, bg_blkno);
+}
+
+static inline int ocfs2_is_cluster_bitmap(struct inode *inode)
+{
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	return osb->bitmap_blkno == OCFS2_I(inode)->ip_blkno;
+}
+
+/* This is for local alloc ONLY. Others should use the task-specific
+ * apis above. */
+int ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,
+				      struct ocfs2_alloc_context *ac);
+
+#endif /* _CHAINALLOC_H_ */
