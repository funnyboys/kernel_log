commit 328970de0e39d596e0ef44080e7642224b29ecde
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 145
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 021110 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 84 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100844.756442981@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index 55f58892b153..3686a52ba143 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* -*- mode: c; c-basic-offset: 8; -*-
  * vim: noexpandtab sw=8 ts=8 sts=0:
  *
@@ -6,21 +7,6 @@
  * Function prototypes
  *
  * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this program; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 021110-1307, USA.
  */
 
 #ifndef OCFS2_DCACHE_H

commit 8ed6b23709b346f7bfc1edab47003a205a6a9f69
Author: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date:   Thu Apr 3 14:46:59 2014 -0700

    ocfs2: revert iput deferring code in ocfs2_drop_dentry_lock
    
    The following patches are reverted in this patch because these patches
    caused performance regression in the remote unlink() calls.
    
      ea455f8ab683 - ocfs2: Push out dropping of dentry lock to ocfs2_wq
      f7b1aa69be13 - ocfs2: Fix deadlock on umount
      5fd131893793 - ocfs2: Don't oops in ocfs2_kill_sb on a failed mount
    
    Previous patches in this series removed the possible deadlocks from
    downconvert thread so the above patches shouldn't be needed anymore.
    
    The regression is caused because these patches delay the iput() in case
    of dentry unlocks.  This also delays the unlocking of the open lockres.
    The open lockresource is required to test if the inode can be wiped from
    disk or not.  When the deleting node does not get the open lock, it
    marks it as orphan (even though it is not in use by another
    node/process) and causes a journal checkpoint.  This delays operations
    following the inode eviction.  This also moves the inode to the orphaned
    inode which further causes more I/O and a lot of unneccessary orphans.
    
    The following script can be used to generate the load causing issues:
    
      declare -a create
      declare -a remove
      declare -a iterations=(1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384)
      unique="`mktemp -u XXXXX`"
      script="/tmp/idontknow-${unique}.sh"
      cat <<EOF > "${script}"
      for n in {1..8}; do mkdir -p test/dir\${n}
        eval touch test/dir\${n}/foo{1.."\$1"}
      done
      EOF
      chmod 700 "${script}"
    
      function fcreate ()
      {
        exec 2>&1 /usr/bin/time --format=%E "${script}" "$1"
      }
    
      function fremove ()
      {
        exec 2>&1 /usr/bin/time --format=%E ssh node2 "cd `pwd`; rm -Rf test*"
      }
    
      function fcp ()
      {
        exec 2>&1 /usr/bin/time --format=%E ssh node3 "cd `pwd`; cp -R test test.new"
      }
    
      echo -------------------------------------------------
      echo "| # files | create #s | copy #s | remove #s |"
      echo -------------------------------------------------
      for ((x=0; x < ${#iterations[*]} ; x++)) do
        create[$x]="`fcreate ${iterations[$x]}`"
        copy[$x]="`fcp ${iterations[$x]}`"
        remove[$x]="`fremove`"
        printf "| %8d | %9s | %9s | %9s |\n" ${iterations[$x]} ${create[$x]} ${copy[$x]} ${remove[$x]}
      done
      rm "${script}"
      echo "------------------------"
    
    Signed-off-by: Srinivas Eeda <srinivas.eeda@oracle.com>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Mark Fasheh <mfasheh@suse.de>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index b79eff709958..55f58892b153 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -29,13 +29,8 @@
 extern const struct dentry_operations ocfs2_dentry_ops;
 
 struct ocfs2_dentry_lock {
-	/* Use count of dentry lock */
 	unsigned int		dl_count;
-	union {
-		/* Linked list of dentry locks to release */
-		struct ocfs2_dentry_lock *dl_next;
-		u64			dl_parent_blkno;
-	};
+	u64			dl_parent_blkno;
 
 	/*
 	 * The ocfs2_dentry_lock keeps an inode reference until
@@ -49,14 +44,9 @@ struct ocfs2_dentry_lock {
 int ocfs2_dentry_attach_lock(struct dentry *dentry, struct inode *inode,
 			     u64 parent_blkno);
 
-extern spinlock_t dentry_list_lock;
-
 void ocfs2_dentry_lock_put(struct ocfs2_super *osb,
 			   struct ocfs2_dentry_lock *dl);
 
-void ocfs2_drop_dl_inodes(struct work_struct *work);
-void ocfs2_drop_all_dl_inodes(struct ocfs2_super *osb);
-
 struct dentry *ocfs2_find_local_alias(struct inode *inode, u64 parent_blkno,
 				      int skip_unhashed);
 

commit 5e98d492406818e6a94c0ba54c61f59d40cefa4a
Author: Goldwyn Rodrigues <rgoldwyn@gmail.com>
Date:   Mon Jun 28 10:04:32 2010 -0500

    Track negative entries v3
    
    Track negative dentries by recording the generation number of the parent
    directory in d_fsdata. The generation number for the parent directory is
    recorded in the inode_info, which increments every time the lock on the
    directory is dropped.
    
    If the generation number of the parent directory and the negative dentry
    matches, there is no need to perform the revalidate, else a revalidate
    is forced. This improves performance in situations where nodes look for
    the same non-existent file multiple times.
    
    Thanks Mark for explaining the DLM sequence.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.de>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index f5dd1789acf1..b79eff709958 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -64,5 +64,6 @@ void ocfs2_dentry_move(struct dentry *dentry, struct dentry *target,
 		       struct inode *old_dir, struct inode *new_dir);
 
 extern spinlock_t dentry_attach_lock;
+void ocfs2_dentry_attach_gen(struct dentry *dentry);
 
 #endif /* OCFS2_DCACHE_H */

commit f7b1aa69be138ad9d7d3f31fa56f4c9407f56b6a
Author: Jan Kara <jack@suse.cz>
Date:   Mon Jul 20 12:12:36 2009 +0200

    ocfs2: Fix deadlock on umount
    
    In commit ea455f8ab68338ba69f5d3362b342c115bea8e13, we moved the dentry lock
    put process into ocfs2_wq. This causes problems during umount because ocfs2_wq
    can drop references to inodes while they are being invalidated by
    invalidate_inodes() causing all sorts of nasty things (invalidate_inodes()
    ending in an infinite loop, "Busy inodes after umount" messages etc.).
    
    We fix the problem by stopping ocfs2_wq from doing any further releasing of
    inode references on the superblock being unmounted, wait until it finishes
    the current round of releasing and finally cleaning up all the references in
    dentry_lock_list from ocfs2_put_super().
    
    The issue was tracked down by Tao Ma <tao.ma@oracle.com>.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index faa12e75f98d..f5dd1789acf1 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -49,10 +49,13 @@ struct ocfs2_dentry_lock {
 int ocfs2_dentry_attach_lock(struct dentry *dentry, struct inode *inode,
 			     u64 parent_blkno);
 
+extern spinlock_t dentry_list_lock;
+
 void ocfs2_dentry_lock_put(struct ocfs2_super *osb,
 			   struct ocfs2_dentry_lock *dl);
 
 void ocfs2_drop_dl_inodes(struct work_struct *work);
+void ocfs2_drop_all_dl_inodes(struct ocfs2_super *osb);
 
 struct dentry *ocfs2_find_local_alias(struct inode *inode, u64 parent_blkno,
 				      int skip_unhashed);

commit d8fba0ffe5e7442fc2560873ec901be6e56602a1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 20 06:00:26 2009 +0000

    constify dentry_operations: OCFS2
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index d06e16c06640..faa12e75f98d 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -26,7 +26,7 @@
 #ifndef OCFS2_DCACHE_H
 #define OCFS2_DCACHE_H
 
-extern struct dentry_operations ocfs2_dentry_ops;
+extern const struct dentry_operations ocfs2_dentry_ops;
 
 struct ocfs2_dentry_lock {
 	/* Use count of dentry lock */

commit ea455f8ab68338ba69f5d3362b342c115bea8e13
Author: Jan Kara <jack@suse.cz>
Date:   Mon Jan 12 23:20:31 2009 +0100

    ocfs2: Push out dropping of dentry lock to ocfs2_wq
    
    Dropping of last reference to dentry lock is a complicated operation involving
    dropping of reference to inode. This can get complicated and quota code in
    particular needs to obtain some quota locks which leads to potential deadlock.
    Thus we defer dropping of inode reference to ocfs2_wq.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index c091c34d9883..d06e16c06640 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -29,8 +29,13 @@
 extern struct dentry_operations ocfs2_dentry_ops;
 
 struct ocfs2_dentry_lock {
+	/* Use count of dentry lock */
 	unsigned int		dl_count;
-	u64			dl_parent_blkno;
+	union {
+		/* Linked list of dentry locks to release */
+		struct ocfs2_dentry_lock *dl_next;
+		u64			dl_parent_blkno;
+	};
 
 	/*
 	 * The ocfs2_dentry_lock keeps an inode reference until
@@ -47,6 +52,8 @@ int ocfs2_dentry_attach_lock(struct dentry *dentry, struct inode *inode,
 void ocfs2_dentry_lock_put(struct ocfs2_super *osb,
 			   struct ocfs2_dentry_lock *dl);
 
+void ocfs2_drop_dl_inodes(struct work_struct *work);
+
 struct dentry *ocfs2_find_local_alias(struct inode *inode, u64 parent_blkno,
 				      int skip_unhashed);
 

commit 0027dd5bc213bc639e09dd002a4ab56bd18317c3
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Sep 21 16:51:28 2006 -0700

    ocfs2: Remove special casing for inode creation in ocfs2_dentry_attach_lock()
    
    We can't use LKM_LOCAL for new dentry locks because an unlink and subsequent
    re-create of a name/inode pair may result in the lock still being mastered
    somewhere in the cluster.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index e53abe766cab..c091c34d9883 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -42,7 +42,7 @@ struct ocfs2_dentry_lock {
 };
 
 int ocfs2_dentry_attach_lock(struct dentry *dentry, struct inode *inode,
-			     u64 parent_blkno, int create);
+			     u64 parent_blkno);
 
 void ocfs2_dentry_lock_put(struct ocfs2_super *osb,
 			   struct ocfs2_dentry_lock *dl);

commit 80c05846f604bab6d61e9732c262420ee9f5f358
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Sep 8 14:43:18 2006 -0700

    ocfs2: Add dentry tracking API
    
    Replace the dentry vote mechanism with a cluster lock which covers a set
    of dentries. This allows us to force d_delete() only on nodes which actually
    care about an unlink.
    
    Every node that does a ->lookup() gets a read only lock on the dentry, until
    an unlink during which the unlinking node, will request an exclusive lock,
    forcing the other nodes who care about that dentry to d_delete() it. The
    effect is that we retain a very lightweight ->d_revalidate(), and at the
    same time get to make large improvements to the average case performance of
    the ocfs2 unlink and rename operations.
    
    This patch adds the higher level API and the dentry manipulation code.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index f1423c2134ee..e53abe766cab 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -41,17 +41,17 @@ struct ocfs2_dentry_lock {
 	struct ocfs2_lock_res	dl_lockres;
 };
 
-static inline void ocfs2_dentry_lock_put(struct ocfs2_super *osb,
-					 struct ocfs2_dentry_lock *dl)
-{
-}
-
-static inline struct dentry *ocfs2_find_local_alias(struct inode *inode,
-						    u64 parent_blkno,
-						    int skip_unhashed)
-{
-	return NULL;
-}
+int ocfs2_dentry_attach_lock(struct dentry *dentry, struct inode *inode,
+			     u64 parent_blkno, int create);
+
+void ocfs2_dentry_lock_put(struct ocfs2_super *osb,
+			   struct ocfs2_dentry_lock *dl);
+
+struct dentry *ocfs2_find_local_alias(struct inode *inode, u64 parent_blkno,
+				      int skip_unhashed);
+
+void ocfs2_dentry_move(struct dentry *dentry, struct dentry *target,
+		       struct inode *old_dir, struct inode *new_dir);
 
 extern spinlock_t dentry_attach_lock;
 

commit d680efe9d8fe0eb99d9dd063a4def6b362cdb40d
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Sep 8 14:14:34 2006 -0700

    ocfs2: Add new cluster lock type
    
    Replace the dentry vote mechanism with a cluster lock which covers a set
    of dentries. This allows us to force d_delete() only on nodes which actually
    care about an unlink.
    
    Every node that does a ->lookup() gets a read only lock on the dentry, until
    an unlink during which the unlinking node, will request an exclusive lock,
    forcing the other nodes who care about that dentry to d_delete() it. The
    effect is that we retain a very lightweight ->d_revalidate(), and at the
    same time get to make large improvements to the average case performance of
    the ocfs2 unlink and rename operations.
    
    This patch adds the cluster lock type which OCFS2 can attach to
    dentries.  A small number of fs/ocfs2/dcache.c functions are stubbed
    out so that this change can compile.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
index 90072771114b..f1423c2134ee 100644
--- a/fs/ocfs2/dcache.h
+++ b/fs/ocfs2/dcache.h
@@ -28,4 +28,31 @@
 
 extern struct dentry_operations ocfs2_dentry_ops;
 
+struct ocfs2_dentry_lock {
+	unsigned int		dl_count;
+	u64			dl_parent_blkno;
+
+	/*
+	 * The ocfs2_dentry_lock keeps an inode reference until
+	 * dl_lockres has been destroyed. This is usually done in
+	 * ->d_iput() anyway, so there should be minimal impact.
+	 */
+	struct inode		*dl_inode;
+	struct ocfs2_lock_res	dl_lockres;
+};
+
+static inline void ocfs2_dentry_lock_put(struct ocfs2_super *osb,
+					 struct ocfs2_dentry_lock *dl)
+{
+}
+
+static inline struct dentry *ocfs2_find_local_alias(struct inode *inode,
+						    u64 parent_blkno,
+						    int skip_unhashed)
+{
+	return NULL;
+}
+
+extern spinlock_t dentry_attach_lock;
+
 #endif /* OCFS2_DCACHE_H */

commit ccd979bdbce9fba8412beb3f1de68a9d0171b12c
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Dec 15 14:31:24 2005 -0800

    [PATCH] OCFS2: The Second Oracle Cluster Filesystem
    
    The OCFS2 file system module.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Kurt Hackel <kurt.hackel@oracle.com>

diff --git a/fs/ocfs2/dcache.h b/fs/ocfs2/dcache.h
new file mode 100644
index 000000000000..90072771114b
--- /dev/null
+++ b/fs/ocfs2/dcache.h
@@ -0,0 +1,31 @@
+/* -*- mode: c; c-basic-offset: 8; -*-
+ * vim: noexpandtab sw=8 ts=8 sts=0:
+ *
+ * dcache.h
+ *
+ * Function prototypes
+ *
+ * Copyright (C) 2002, 2004 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef OCFS2_DCACHE_H
+#define OCFS2_DCACHE_H
+
+extern struct dentry_operations ocfs2_dentry_ops;
+
+#endif /* OCFS2_DCACHE_H */
