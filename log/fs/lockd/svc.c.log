commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 3056f3a0c270..1a639e34847d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * linux/fs/lockd/svc.c
  *

commit 40373b125de6bab186e71d5ea5498bb2b845398b
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Apr 9 12:13:39 2019 -0400

    lockd: Pass the user cred from knfsd when starting the lockd server
    
    When starting up a new knfsd server, pass the user cred to the
    supporting lockd server.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 82aa0f35e43d..3056f3a0c270 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -188,9 +188,9 @@ lockd(void *vrqstp)
 
 static int create_lockd_listener(struct svc_serv *serv, const char *name,
 				 struct net *net, const int family,
-				 const unsigned short port)
+				 const unsigned short port,
+				 const struct cred *cred)
 {
-	const struct cred *cred = current_cred();
 	struct svc_xprt *xprt;
 
 	xprt = svc_find_xprt(serv, name, net, family, 0);
@@ -202,15 +202,17 @@ static int create_lockd_listener(struct svc_serv *serv, const char *name,
 }
 
 static int create_lockd_family(struct svc_serv *serv, struct net *net,
-			       const int family)
+			       const int family, const struct cred *cred)
 {
 	int err;
 
-	err = create_lockd_listener(serv, "udp", net, family, nlm_udpport);
+	err = create_lockd_listener(serv, "udp", net, family, nlm_udpport,
+			cred);
 	if (err < 0)
 		return err;
 
-	return create_lockd_listener(serv, "tcp", net, family, nlm_tcpport);
+	return create_lockd_listener(serv, "tcp", net, family, nlm_tcpport,
+			cred);
 }
 
 /*
@@ -223,16 +225,17 @@ static int create_lockd_family(struct svc_serv *serv, struct net *net,
  * Returns zero if all listeners are available; otherwise a
  * negative errno value is returned.
  */
-static int make_socks(struct svc_serv *serv, struct net *net)
+static int make_socks(struct svc_serv *serv, struct net *net,
+		const struct cred *cred)
 {
 	static int warned;
 	int err;
 
-	err = create_lockd_family(serv, net, PF_INET);
+	err = create_lockd_family(serv, net, PF_INET, cred);
 	if (err < 0)
 		goto out_err;
 
-	err = create_lockd_family(serv, net, PF_INET6);
+	err = create_lockd_family(serv, net, PF_INET6, cred);
 	if (err < 0 && err != -EAFNOSUPPORT)
 		goto out_err;
 
@@ -247,7 +250,8 @@ static int make_socks(struct svc_serv *serv, struct net *net)
 	return err;
 }
 
-static int lockd_up_net(struct svc_serv *serv, struct net *net)
+static int lockd_up_net(struct svc_serv *serv, struct net *net,
+		const struct cred *cred)
 {
 	struct lockd_net *ln = net_generic(net, lockd_net_id);
 	int error;
@@ -259,7 +263,7 @@ static int lockd_up_net(struct svc_serv *serv, struct net *net)
 	if (error)
 		goto err_bind;
 
-	error = make_socks(serv, net);
+	error = make_socks(serv, net, cred);
 	if (error < 0)
 		goto err_bind;
 	set_grace_period(net);
@@ -462,7 +466,7 @@ static struct svc_serv *lockd_create_svc(void)
 /*
  * Bring up the lockd process if it's not already up.
  */
-int lockd_up(struct net *net)
+int lockd_up(struct net *net, const struct cred *cred)
 {
 	struct svc_serv *serv;
 	int error;
@@ -475,7 +479,7 @@ int lockd_up(struct net *net)
 		goto err_create;
 	}
 
-	error = lockd_up_net(serv, net);
+	error = lockd_up_net(serv, net, cred);
 	if (error < 0) {
 		lockd_unregister_notifiers();
 		goto err_put;

commit 4df493a260d4c1844437b28009013d5dc408d0df
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Apr 9 12:13:37 2019 -0400

    SUNRPC: Cache the process user cred in the RPC server listener
    
    In order to be able to interpret uids and gids correctly in knfsd, we
    should cache the user namespace of the process that created the RPC
    server's listener. To do so, we refcount the credential of that process.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 96bb74c919f9..82aa0f35e43d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -190,12 +190,13 @@ static int create_lockd_listener(struct svc_serv *serv, const char *name,
 				 struct net *net, const int family,
 				 const unsigned short port)
 {
+	const struct cred *cred = current_cred();
 	struct svc_xprt *xprt;
 
 	xprt = svc_find_xprt(serv, name, net, family, 0);
 	if (xprt == NULL)
 		return svc_create_xprt(serv, name, net, family, port,
-						SVC_SOCK_DEFAULTS);
+						SVC_SOCK_DEFAULTS, cred);
 	svc_xprt_put(xprt);
 	return 0;
 }

commit 642ee6b209c2f4c20fe0a7ed36b429c470162eae
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Apr 9 11:46:17 2019 -0400

    SUNRPC: Allow further customisation of RPC program registration
    
    Add a callback to allow customisation of the rpcbind registration.
    When clients have the ability to turn on and off version support,
    we want to allow them to also prevent registration of those
    versions with the rpc portmapper.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 75415b21efda..96bb74c919f9 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -809,4 +809,5 @@ static struct svc_program	nlmsvc_program = {
 	.pg_stats		= &nlmsvc_stats,	/* stats table */
 	.pg_authenticate	= &lockd_authenticate,	/* export authentication */
 	.pg_init_request	= svc_generic_init_request,
+	.pg_rpcbind_set		= svc_generic_rpcbind_set,
 };

commit 8e5b67731d088e66fc6a59d9e2fc9a5e4e187303
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Apr 9 11:46:15 2019 -0400

    SUNRPC: Add a callback to initialise server requests
    
    Add a callback to help initialise server requests before they are
    processed. This will allow us to clean up the NFS server version
    support, and to make it container safe.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 346ed161756d..75415b21efda 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -807,5 +807,6 @@ static struct svc_program	nlmsvc_program = {
 	.pg_name		= "lockd",		/* service name */
 	.pg_class		= "nfsd",		/* share authentication with nfsd */
 	.pg_stats		= &nlmsvc_stats,	/* stats table */
-	.pg_authenticate = &lockd_authenticate	/* export authentication */
+	.pg_authenticate	= &lockd_authenticate,	/* export authentication */
+	.pg_init_request	= svc_generic_init_request,
 };

commit 554faf28198803cb58ff79a2c4891bc42d523438
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Feb 7 10:29:47 2018 +0000

    lockd: make nlm_ntf_refcnt and nlm_ntf_wq static
    
    The variables nlm_ntf_refcnt and nlm_ntf_wq are local to the source and
    do not need to be in global scope, so make them static.
    
    Cleans up sparse warnings:
    fs/lockd/svc.c:60:10: warning: symbol 'nlm_ntf_refcnt' was not declared.
    Should it be static?
    fs/lockd/svc.c:61:1: warning: symbol 'nlm_ntf_wq' was not declared.
    Should it be static?
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 9c36d614bf89..346ed161756d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -57,8 +57,8 @@ static struct task_struct	*nlmsvc_task;
 static struct svc_rqst		*nlmsvc_rqst;
 unsigned long			nlmsvc_timeout;
 
-atomic_t nlm_ntf_refcnt = ATOMIC_INIT(0);
-DECLARE_WAIT_QUEUE_HEAD(nlm_ntf_wq);
+static atomic_t nlm_ntf_refcnt = ATOMIC_INIT(0);
+static DECLARE_WAIT_QUEUE_HEAD(nlm_ntf_wq);
 
 unsigned int lockd_net_id;
 

commit 6b18dd1c03e07262ea0866084856b2a3c5ba8d09
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Fri Nov 10 10:19:26 2017 +0300

    race of lockd inetaddr notifiers vs nlmsvc_rqst change
    
    lockd_inet[6]addr_event use nlmsvc_rqst without taken nlmsvc_mutex,
    nlmsvc_rqst can be changed during execution of notifiers and crash the host.
    
    Patch enables access to nlmsvc_rqst only when it was correctly initialized
    and delays its cleanup until notifiers are no longer in use.
    
    Note that nlmsvc_rqst can be temporally set to ERR_PTR, so the "if
    (nlmsvc_rqst)" check in notifiers is insufficient on its own.
    
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Tested-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 4acf0ebd9802..9c36d614bf89 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -57,6 +57,9 @@ static struct task_struct	*nlmsvc_task;
 static struct svc_rqst		*nlmsvc_rqst;
 unsigned long			nlmsvc_timeout;
 
+atomic_t nlm_ntf_refcnt = ATOMIC_INIT(0);
+DECLARE_WAIT_QUEUE_HEAD(nlm_ntf_wq);
+
 unsigned int lockd_net_id;
 
 /*
@@ -293,7 +296,8 @@ static int lockd_inetaddr_event(struct notifier_block *this,
 	struct in_ifaddr *ifa = (struct in_ifaddr *)ptr;
 	struct sockaddr_in sin;
 
-	if (event != NETDEV_DOWN)
+	if ((event != NETDEV_DOWN) ||
+	    !atomic_inc_not_zero(&nlm_ntf_refcnt))
 		goto out;
 
 	if (nlmsvc_rqst) {
@@ -304,6 +308,8 @@ static int lockd_inetaddr_event(struct notifier_block *this,
 		svc_age_temp_xprts_now(nlmsvc_rqst->rq_server,
 			(struct sockaddr *)&sin);
 	}
+	atomic_dec(&nlm_ntf_refcnt);
+	wake_up(&nlm_ntf_wq);
 
 out:
 	return NOTIFY_DONE;
@@ -320,7 +326,8 @@ static int lockd_inet6addr_event(struct notifier_block *this,
 	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
 	struct sockaddr_in6 sin6;
 
-	if (event != NETDEV_DOWN)
+	if ((event != NETDEV_DOWN) ||
+	    !atomic_inc_not_zero(&nlm_ntf_refcnt))
 		goto out;
 
 	if (nlmsvc_rqst) {
@@ -332,6 +339,8 @@ static int lockd_inet6addr_event(struct notifier_block *this,
 		svc_age_temp_xprts_now(nlmsvc_rqst->rq_server,
 			(struct sockaddr *)&sin6);
 	}
+	atomic_dec(&nlm_ntf_refcnt);
+	wake_up(&nlm_ntf_wq);
 
 out:
 	return NOTIFY_DONE;
@@ -348,10 +357,12 @@ static void lockd_unregister_notifiers(void)
 #if IS_ENABLED(CONFIG_IPV6)
 	unregister_inet6addr_notifier(&lockd_inet6addr_notifier);
 #endif
+	wait_event(nlm_ntf_wq, atomic_read(&nlm_ntf_refcnt) == 0);
 }
 
 static void lockd_svc_exit_thread(void)
 {
+	atomic_dec(&nlm_ntf_refcnt);
 	lockd_unregister_notifiers();
 	svc_exit_thread(nlmsvc_rqst);
 }
@@ -376,6 +387,7 @@ static int lockd_start_svc(struct svc_serv *serv)
 		goto out_rqst;
 	}
 
+	atomic_inc(&nlm_ntf_refcnt);
 	svc_sock_update_bufs(serv);
 	serv->sv_maxconn = nlm_max_connections;
 

commit 3a2b19d1ee5633f76ae8a88da7bc039a5d1732aa
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Thu Nov 2 13:03:42 2017 +0300

    lockd: lost rollback of set_grace_period() in lockd_down_net()
    
    Commit efda760fe95ea ("lockd: fix lockd shutdown race") is incorrect,
    it removes lockd_manager and disarm grace_period_end for init_net only.
    
    If nfsd was started from another net namespace lockd_up_net() calls
    set_grace_period() that adds lockd_manager into per-netns list
    and queues grace_period_end delayed work.
    
    These action should be reverted in lockd_down_net().
    Otherwise it can lead to double list_add on after restart nfsd in netns,
    and to use-after-free if non-disarmed delayed work will be executed after netns destroy.
    
    Fixes: efda760fe95e ("lockd: fix lockd shutdown race")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index cb659ef789c0..4acf0ebd9802 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -274,6 +274,8 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)
 	if (ln->nlmsvc_users) {
 		if (--ln->nlmsvc_users == 0) {
 			nlm_shutdown_hosts_net(net);
+			cancel_delayed_work_sync(&ln->grace_period_end);
+			locks_end_grace(&ln->lockd_manager);
 			svc_shutdown_net(serv, net);
 			dprintk("%s: per-net data destroyed; net=%x\n",
 				__func__, net->ns.inum);

commit a3152f1440c762128a626d90718ba6535c81c1b4
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Mon Nov 6 16:23:24 2017 +0300

    lockd: added cleanup checks in exit_net hook
    
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index e28796bd7375..cb659ef789c0 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -677,6 +677,17 @@ static int lockd_init_net(struct net *net)
 
 static void lockd_exit_net(struct net *net)
 {
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
+
+	WARN_ONCE(!list_empty(&ln->lockd_manager.list),
+		  "net %x %s: lockd_manager.list is not empty\n",
+		  net->ns.inum, __func__);
+	WARN_ONCE(!list_empty(&ln->nsm_handles),
+		  "net %x %s: nsm_handles list is not empty\n",
+		  net->ns.inum, __func__);
+	WARN_ONCE(delayed_work_pending(&ln->grace_period_end),
+		  "net %x %s: grace_period_end was not cancelled\n",
+		  net->ns.inum, __func__);
 }
 
 static struct pernet_operations lockd_net_ops = {

commit e919b0765287f36f7e9c84aed785eddfbbd98dfa
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Wed Nov 8 08:55:55 2017 +0300

    lockd: remove net pointer from messages
    
    Publishing of net pointer is not safe,
    use net->ns.inum as net ID in debug messages
    
    [  171.757678] lockd_up_net: per-net data created; net=f00001e7
    [  171.767188] NFSD: starting 90-second grace period (net f00001e7)
    [  300.653313] lockd: nuking all hosts in net f00001e7...
    [  300.653641] lockd: host garbage collection for net f00001e7
    [  300.653968] lockd: nlmsvc_mark_resources for net f00001e7
    [  300.711483] lockd_down_net: per-net data destroyed; net=f00001e7
    [  300.711847] lockd: nuking all hosts in net 0...
    [  300.711847] lockd: host garbage collection for net 0
    [  300.711848] lockd: nlmsvc_mark_resources for net 0
    
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index a8e3777c94dc..e28796bd7375 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -259,7 +259,7 @@ static int lockd_up_net(struct svc_serv *serv, struct net *net)
 	if (error < 0)
 		goto err_bind;
 	set_grace_period(net);
-	dprintk("lockd_up_net: per-net data created; net=%p\n", net);
+	dprintk("%s: per-net data created; net=%x\n", __func__, net->ns.inum);
 	return 0;
 
 err_bind:
@@ -275,11 +275,12 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)
 		if (--ln->nlmsvc_users == 0) {
 			nlm_shutdown_hosts_net(net);
 			svc_shutdown_net(serv, net);
-			dprintk("lockd_down_net: per-net data destroyed; net=%p\n", net);
+			dprintk("%s: per-net data destroyed; net=%x\n",
+				__func__, net->ns.inum);
 		}
 	} else {
-		printk(KERN_ERR "lockd_down_net: no users! task=%p, net=%p\n",
-				nlmsvc_task, net);
+		pr_err("%s: no users! task=%p, net=%x\n",
+			__func__, nlmsvc_task, net->ns.inum);
 		BUG();
 	}
 }

commit 4dd3c2e5a4225e3df85afc6033e62ce8b09f0ed2
Merge: 07c455ee222f 22700f3c6df5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 18 11:22:04 2017 -0800

    Merge tag 'nfsd-4.15' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Lots of good bugfixes, including:
    
       -  fix a number of races in the NFSv4+ state code
    
       -  fix some shutdown crashes in multiple-network-namespace cases
    
       -  relax our 4.1 session limits; if you've an artificially low limit
          to the number of 4.1 clients that can mount simultaneously, try
          upgrading"
    
    * tag 'nfsd-4.15' of git://linux-nfs.org/~bfields/linux: (22 commits)
      SUNRPC: Improve ordering of transport processing
      nfsd: deal with revoked delegations appropriately
      svcrdma: Enqueue after setting XPT_CLOSE in completion handlers
      nfsd: use nfs->ns.inum as net ID
      rpc: remove some BUG()s
      svcrdma: Preserve CB send buffer across retransmits
      nfds: avoid gettimeofday for nfssvc_boot time
      fs, nfsd: convert nfs4_file.fi_ref from atomic_t to refcount_t
      fs, nfsd: convert nfs4_cntl_odstate.co_odcount from atomic_t to refcount_t
      fs, nfsd: convert nfs4_stid.sc_count from atomic_t to refcount_t
      lockd: double unregister of inetaddr notifiers
      nfsd4: catch some false session retries
      nfsd4: fix cached replies to solo SEQUENCE compounds
      sunrcp: make function _svc_create_xprt static
      SUNRPC: Fix tracepoint storage issues with svc_recv and svc_rqst_status
      nfsd: use ARRAY_SIZE
      nfsd: give out fewer session slots as limit approaches
      nfsd: increase DRC cache limit
      nfsd: remove unnecessary nofilehandle checks
      nfs_common: convert int to bool
      ...

commit dc3033e16c59a2c4e62b31341258a5786cbcee56
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Fri Oct 20 17:33:18 2017 +0300

    lockd: double unregister of inetaddr notifiers
    
    lockd_up() can call lockd_unregister_notifiers twice:
    inside lockd_start_svc() when it calls lockd_svc_exit_thread()
    and then in error path of lockd_up()
    
    Patch forces lockd_start_svc() to unregister notifiers in all error cases
    and removes extra unregister in error path of lockd_up().
    
    Fixes: cb7d224f82e4 "lockd: unregister notifier blocks if the service ..."
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Cc: stable@vger.kernel.org
    Reviewed-by: Jeff Layton <jlayton@kernel.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b995bdc13976..f04ecfc7ece0 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -369,6 +369,7 @@ static int lockd_start_svc(struct svc_serv *serv)
 		printk(KERN_WARNING
 			"lockd_up: svc_rqst allocation failed, error=%d\n",
 			error);
+		lockd_unregister_notifiers();
 		goto out_rqst;
 	}
 
@@ -459,13 +460,16 @@ int lockd_up(struct net *net)
 	}
 
 	error = lockd_up_net(serv, net);
-	if (error < 0)
-		goto err_net;
+	if (error < 0) {
+		lockd_unregister_notifiers();
+		goto err_put;
+	}
 
 	error = lockd_start_svc(serv);
-	if (error < 0)
-		goto err_start;
-
+	if (error < 0) {
+		lockd_down_net(serv, net);
+		goto err_put;
+	}
 	nlmsvc_users++;
 	/*
 	 * Note: svc_serv structures have an initial use count of 1,
@@ -476,12 +480,6 @@ int lockd_up(struct net *net)
 err_create:
 	mutex_unlock(&nlmsvc_mutex);
 	return error;
-
-err_start:
-	lockd_down_net(serv, net);
-err_net:
-	lockd_unregister_notifiers();
-	goto err_put;
 }
 EXPORT_SYMBOL_GPL(lockd_up);
 

commit e4dca7b7aa08b22893c45485d222b5807c1375ae
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 17 19:04:42 2017 -0700

    treewide: Fix function prototypes for module_param_call()
    
    Several function prototypes for the set/get functions defined by
    module_param_call() have a slightly wrong argument types. This fixes
    those in an effort to clean up the calls when running under type-enforced
    compiler instrumentation for CFI. This is the result of running the
    following semantic patch:
    
    @match_module_param_call_function@
    declarer name module_param_call;
    identifier _name, _set_func, _get_func;
    expression _arg, _mode;
    @@
    
     module_param_call(_name, _set_func, _get_func, _arg, _mode);
    
    @fix_set_prototype
     depends on match_module_param_call_function@
    identifier match_module_param_call_function._set_func;
    identifier _val, _param;
    type _val_type, _param_type;
    @@
    
     int _set_func(
    -_val_type _val
    +const char * _val
     ,
    -_param_type _param
    +const struct kernel_param * _param
     ) { ... }
    
    @fix_get_prototype
     depends on match_module_param_call_function@
    identifier match_module_param_call_function._get_func;
    identifier _val, _param;
    type _val_type, _param_type;
    @@
    
     int _get_func(
    -_val_type _val
    +char * _val
     ,
    -_param_type _param
    +const struct kernel_param * _param
     ) { ... }
    
    Two additional by-hand changes are included for places where the above
    Coccinelle script didn't notice them:
    
            drivers/platform/x86/thinkpad_acpi.c
            fs/lockd/svc.c
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b995bdc13976..b837fb7e290a 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -602,7 +602,7 @@ static struct ctl_table nlm_sysctl_root[] = {
  */
 
 #define param_set_min_max(name, type, which_strtol, min, max)		\
-static int param_set_##name(const char *val, struct kernel_param *kp)	\
+static int param_set_##name(const char *val, const struct kernel_param *kp) \
 {									\
 	char *endp;							\
 	__typeof__(type) num = which_strtol(val, &endp, 0);		\

commit afea5657c20b11ec9f895ac5cc33b560fb1e0276
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 1 12:00:06 2017 -0400

    sunrpc: Const-ify struct sv_serv_ops
    
    Close an attack vector by moving the arrays of per-server methods to
    read-only memory.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 726b6cecf430..b995bdc13976 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -396,7 +396,7 @@ static int lockd_start_svc(struct svc_serv *serv)
 	return error;
 }
 
-static struct svc_serv_ops lockd_sv_ops = {
+static const struct svc_serv_ops lockd_sv_ops = {
 	.svo_shutdown		= svc_rpcb_cleanup,
 	.svo_enqueue_xprt	= svc_xprt_do_enqueue,
 };

commit e9679189e34b25a1b9aa77fe37d331559d1544af
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 12 16:21:37 2017 +0200

    sunrpc: mark all struct svc_version instances as const
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index cc6abe6280bc..726b6cecf430 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -740,32 +740,32 @@ module_exit(exit_nlm);
  * Define NLM program and procedures
  */
 static unsigned int nlmsvc_version1_count[17];
-static struct svc_version	nlmsvc_version1 = {
-		.vs_vers	= 1,
-		.vs_nproc	= 17,
-		.vs_proc	= nlmsvc_procedures,
-		.vs_count	= nlmsvc_version1_count,
-		.vs_xdrsize	= NLMSVC_XDRSIZE,
+static const struct svc_version	nlmsvc_version1 = {
+	.vs_vers	= 1,
+	.vs_nproc	= 17,
+	.vs_proc	= nlmsvc_procedures,
+	.vs_count	= nlmsvc_version1_count,
+	.vs_xdrsize	= NLMSVC_XDRSIZE,
 };
 static unsigned int nlmsvc_version3_count[24];
-static struct svc_version	nlmsvc_version3 = {
-		.vs_vers	= 3,
-		.vs_nproc	= 24,
-		.vs_proc	= nlmsvc_procedures,
-		.vs_count	= nlmsvc_version3_count,
-		.vs_xdrsize	= NLMSVC_XDRSIZE,
+static const struct svc_version	nlmsvc_version3 = {
+	.vs_vers	= 3,
+	.vs_nproc	= 24,
+	.vs_proc	= nlmsvc_procedures,
+	.vs_count	= nlmsvc_version3_count,
+	.vs_xdrsize	= NLMSVC_XDRSIZE,
 };
 #ifdef CONFIG_LOCKD_V4
 static unsigned int nlmsvc_version4_count[24];
-static struct svc_version	nlmsvc_version4 = {
-		.vs_vers	= 4,
-		.vs_nproc	= 24,
-		.vs_proc	= nlmsvc_procedures4,
-		.vs_count	= nlmsvc_version4_count,
-		.vs_xdrsize	= NLMSVC_XDRSIZE,
+static const struct svc_version	nlmsvc_version4 = {
+	.vs_vers	= 4,
+	.vs_nproc	= 24,
+	.vs_proc	= nlmsvc_procedures4,
+	.vs_count	= nlmsvc_version4_count,
+	.vs_xdrsize	= NLMSVC_XDRSIZE,
 };
 #endif
-static struct svc_version *	nlmsvc_version[] = {
+static const struct svc_version *nlmsvc_version[] = {
 	[1] = &nlmsvc_version1,
 	[3] = &nlmsvc_version3,
 #ifdef CONFIG_LOCKD_V4

commit 7fd38af9cae6aef1dfd28a7d1bd214eb5ddb7d53
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 8 23:40:27 2017 +0200

    sunrpc: move pc_count out of struct svc_procinfo
    
    pc_count is the only writeable memeber of struct svc_procinfo, which is
    a good candidate to be const-ified as it contains function pointers.
    
    This patch moves it into out out struct svc_procinfo, and into a
    separate writable array that is pointed to by struct svc_version.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 5d481e8a1b5d..cc6abe6280bc 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -739,23 +739,29 @@ module_exit(exit_nlm);
 /*
  * Define NLM program and procedures
  */
+static unsigned int nlmsvc_version1_count[17];
 static struct svc_version	nlmsvc_version1 = {
 		.vs_vers	= 1,
 		.vs_nproc	= 17,
 		.vs_proc	= nlmsvc_procedures,
+		.vs_count	= nlmsvc_version1_count,
 		.vs_xdrsize	= NLMSVC_XDRSIZE,
 };
+static unsigned int nlmsvc_version3_count[24];
 static struct svc_version	nlmsvc_version3 = {
 		.vs_vers	= 3,
 		.vs_nproc	= 24,
 		.vs_proc	= nlmsvc_procedures,
+		.vs_count	= nlmsvc_version3_count,
 		.vs_xdrsize	= NLMSVC_XDRSIZE,
 };
 #ifdef CONFIG_LOCKD_V4
+static unsigned int nlmsvc_version4_count[24];
 static struct svc_version	nlmsvc_version4 = {
 		.vs_vers	= 4,
 		.vs_nproc	= 24,
 		.vs_proc	= nlmsvc_procedures4,
+		.vs_count	= nlmsvc_version4_count,
 		.vs_xdrsize	= NLMSVC_XDRSIZE,
 };
 #endif

commit efda760fe95ea15291853c8fa9235c32d319cd98
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Mar 28 21:25:08 2017 -0400

    lockd: fix lockd shutdown race
    
    As reported by David Jeffery: "a signal was sent to lockd while lockd
    was shutting down from a request to stop nfs.  The signal causes lockd
    to call restart_grace() which puts the lockd_net structure on the grace
    list.  If this signal is received at the wrong time, it will occur after
    lockd_down_net() has called locks_end_grace() but before
    lockd_down_net() stops the lockd thread.  This leads to lockd putting
    the lockd_net structure back on the grace list, then exiting without
    anything removing it from the list."
    
    So, perform the final locks_end_grace() from the the lockd thread; this
    ensures it's serialized with respect to restart_grace().
    
    Reported-by: David Jeffery <djeffery@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index e7c8b9c76e48..5d481e8a1b5d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -132,6 +132,8 @@ lockd(void *vrqstp)
 {
 	int		err = 0;
 	struct svc_rqst *rqstp = vrqstp;
+	struct net *net = &init_net;
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	/* try_to_freeze() is called from svc_recv() */
 	set_freezable();
@@ -176,6 +178,8 @@ lockd(void *vrqstp)
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
 	nlm_shutdown_hosts();
+	cancel_delayed_work_sync(&ln->grace_period_end);
+	locks_end_grace(&ln->lockd_manager);
 	return 0;
 }
 
@@ -270,8 +274,6 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)
 	if (ln->nlmsvc_users) {
 		if (--ln->nlmsvc_users == 0) {
 			nlm_shutdown_hosts_net(net);
-			cancel_delayed_work_sync(&ln->grace_period_end);
-			locks_end_grace(&ln->lockd_manager);
 			svc_shutdown_net(serv, net);
 			dprintk("lockd_down_net: per-net data destroyed; net=%p\n", net);
 		}

commit 3f07c0144132e4f59d88055ac8ff3e691a5fa2b8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:30 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/signal.h>
    
    We are going to split <linux/sched/signal.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/signal.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 7e4ea3b9f472..e7c8b9c76e48 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -17,7 +17,7 @@
 #include <linux/sysctl.h>
 #include <linux/moduleparam.h>
 
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/errno.h>
 #include <linux/in.h>
 #include <linux/uio.h>

commit c01410f7f6fd476072c9a71241938c24bed8b6f9
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Thu Jan 5 16:34:50 2017 -0500

    lockd: initialize sin6_scope_id in lockd_inet6addr_event()
    
    I noticed this was missing when I was testing with link local addresses.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 1c13dd80744f..7e4ea3b9f472 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -322,6 +322,8 @@ static int lockd_inet6addr_event(struct notifier_block *this,
 		dprintk("lockd_inet6addr_event: removed %pI6\n", &ifa->addr);
 		sin6.sin6_family = AF_INET6;
 		sin6.sin6_addr = ifa->addr;
+		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
+			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
 		svc_age_temp_xprts_now(nlmsvc_rqst->rq_server,
 			(struct sockaddr *)&sin6);
 	}

commit c7d03a00b56fc23c3a01a8353789ad257363e281
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Nov 17 04:58:21 2016 +0300

    netns: make struct pernet_operations::id unsigned int
    
    Make struct pernet_operations::id unsigned.
    
    There are 2 reasons to do so:
    
    1)
    This field is really an index into an zero based array and
    thus is unsigned entity. Using negative value is out-of-bound
    access by definition.
    
    2)
    On x86_64 unsigned 32-bit data which are mixed with pointers
    via array indexing or offsets added or subtracted to pointers
    are preffered to signed 32-bit data.
    
    "int" being used as an array index needs to be sign-extended
    to 64-bit before being used.
    
            void f(long *p, int i)
            {
                    g(p[i]);
            }
    
      roughly translates to
    
            movsx   rsi, esi
            mov     rdi, [rsi+...]
            call    g
    
    MOVSX is 3 byte instruction which isn't necessary if the variable is
    unsigned because x86_64 is zero extending by default.
    
    Now, there is net_generic() function which, you guessed it right, uses
    "int" as an array index:
    
            static inline void *net_generic(const struct net *net, int id)
            {
                    ...
                    ptr = ng->ptr[id - 1];
                    ...
            }
    
    And this function is used a lot, so those sign extensions add up.
    
    Patch snipes ~1730 bytes on allyesconfig kernel (without all junk
    messing with code generation):
    
            add/remove: 0/0 grow/shrink: 70/598 up/down: 396/-2126 (-1730)
    
    Unfortunately some functions actually grow bigger.
    This is a semmingly random artefact of code generation with register
    allocator being used differently. gcc decides that some variable
    needs to live in new r8+ registers and every access now requires REX
    prefix. Or it is shifted into r12, so [r12+0] addressing mode has to be
    used which is longer than [r8]
    
    However, overall balance is in negative direction:
    
            add/remove: 0/0 grow/shrink: 70/598 up/down: 396/-2126 (-1730)
            function                                     old     new   delta
            nfsd4_lock                                  3886    3959     +73
            tipc_link_build_proto_msg                   1096    1140     +44
            mac80211_hwsim_new_radio                    2776    2808     +32
            tipc_mon_rcv                                1032    1058     +26
            svcauth_gss_legacy_init                     1413    1429     +16
            tipc_bcbase_select_primary                   379     392     +13
            nfsd4_exchange_id                           1247    1260     +13
            nfsd4_setclientid_confirm                    782     793     +11
                    ...
            put_client_renew_locked                      494     480     -14
            ip_set_sockfn_get                            730     716     -14
            geneve_sock_add                              829     813     -16
            nfsd4_sequence_done                          721     703     -18
            nlmclnt_lookup_host                          708     686     -22
            nfsd4_lockt                                 1085    1063     -22
            nfs_get_client                              1077    1050     -27
            tcf_bpf_init                                1106    1076     -30
            nfsd4_encode_fattr                          5997    5930     -67
            Total: Before=154856051, After=154854321, chg -0.00%
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index fc4084ef4736..1c13dd80744f 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -57,7 +57,7 @@ static struct task_struct	*nlmsvc_task;
 static struct svc_rqst		*nlmsvc_rqst;
 unsigned long			nlmsvc_timeout;
 
-int lockd_net_id;
+unsigned int lockd_net_id;
 
 /*
  * These can be set at insmod time (useful for NFS as root filesystem),

commit cb7d224f82e41d82518e7f9ea271d215d4d08e6e
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Thu Jun 30 10:39:32 2016 -0400

    lockd: unregister notifier blocks if the service fails to come up completely
    
    If the lockd service fails to start up then we need to be sure that the
    notifier blocks are not registered, otherwise a subsequent start of the
    service could cause the same notifier to be registered twice, leading to
    soft lockups.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Cc: stable@vger.kernel.org
    Fixes: 0751ddf77b6a "lockd: Register callbacks on the inetaddr_chain..."
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 154a107cd376..fc4084ef4736 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -335,12 +335,17 @@ static struct notifier_block lockd_inet6addr_notifier = {
 };
 #endif
 
-static void lockd_svc_exit_thread(void)
+static void lockd_unregister_notifiers(void)
 {
 	unregister_inetaddr_notifier(&lockd_inetaddr_notifier);
 #if IS_ENABLED(CONFIG_IPV6)
 	unregister_inet6addr_notifier(&lockd_inet6addr_notifier);
 #endif
+}
+
+static void lockd_svc_exit_thread(void)
+{
+	lockd_unregister_notifiers();
 	svc_exit_thread(nlmsvc_rqst);
 }
 
@@ -462,7 +467,7 @@ int lockd_up(struct net *net)
 	 * Note: svc_serv structures have an initial use count of 1,
 	 * so we exit through here on both success and failure.
 	 */
-err_net:
+err_put:
 	svc_destroy(serv);
 err_create:
 	mutex_unlock(&nlmsvc_mutex);
@@ -470,7 +475,9 @@ int lockd_up(struct net *net)
 
 err_start:
 	lockd_down_net(serv, net);
-	goto err_net;
+err_net:
+	lockd_unregister_notifiers();
+	goto err_put;
 }
 EXPORT_SYMBOL_GPL(lockd_up);
 

commit 2a297450dd188a5d4e5e428c189b2de54f9073ba
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Dec 23 22:25:13 2015 +0100

    lockd: constify nlmsvc_binding structure
    
    The nlmsvc_binding structure is never modified, so declare it as const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b4006c720f55..154a107cd376 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -48,7 +48,7 @@
 
 static struct svc_program	nlmsvc_program;
 
-struct nlmsvc_binding *		nlmsvc_ops;
+const struct nlmsvc_binding	*nlmsvc_ops;
 EXPORT_SYMBOL_GPL(nlmsvc_ops);
 
 static DEFINE_MUTEX(nlmsvc_mutex);

commit ea44463f376236a0541288cb8d575ab6b50370d2
Author: Geliang Tang <geliangtang@163.com>
Date:   Fri Jan 1 22:06:29 2016 +0800

    lockd: use to_delayed_work
    
    Use to_delayed_work() instead of open-coding it.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 44d18ad4d364..b4006c720f55 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -94,8 +94,7 @@ static unsigned long get_lockd_grace_period(void)
 
 static void grace_ender(struct work_struct *grace)
 {
-	struct delayed_work *dwork = container_of(grace, struct delayed_work,
-						  work);
+	struct delayed_work *dwork = to_delayed_work(grace);
 	struct lockd_net *ln = container_of(dwork, struct lockd_net,
 					    grace_period_end);
 

commit 0751ddf77b6af2efe1041efb81141badd64efb65
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Fri Dec 11 16:46:00 2015 -0500

    lockd: Register callbacks on the inetaddr_chain and inet6addr_chain
    
    Register callbacks on inetaddr_chain and inet6addr_chain to trigger
    cleanup of lockd transport sockets when an ip address is deleted.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 5f31ebd96c06..44d18ad4d364 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -25,13 +25,17 @@
 #include <linux/mutex.h>
 #include <linux/kthread.h>
 #include <linux/freezer.h>
+#include <linux/inetdevice.h>
 
 #include <linux/sunrpc/types.h>
 #include <linux/sunrpc/stats.h>
 #include <linux/sunrpc/clnt.h>
 #include <linux/sunrpc/svc.h>
 #include <linux/sunrpc/svcsock.h>
+#include <linux/sunrpc/svc_xprt.h>
 #include <net/ip.h>
+#include <net/addrconf.h>
+#include <net/ipv6.h>
 #include <linux/lockd/lockd.h>
 #include <linux/nfs.h>
 
@@ -279,6 +283,68 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)
 	}
 }
 
+static int lockd_inetaddr_event(struct notifier_block *this,
+	unsigned long event, void *ptr)
+{
+	struct in_ifaddr *ifa = (struct in_ifaddr *)ptr;
+	struct sockaddr_in sin;
+
+	if (event != NETDEV_DOWN)
+		goto out;
+
+	if (nlmsvc_rqst) {
+		dprintk("lockd_inetaddr_event: removed %pI4\n",
+			&ifa->ifa_local);
+		sin.sin_family = AF_INET;
+		sin.sin_addr.s_addr = ifa->ifa_local;
+		svc_age_temp_xprts_now(nlmsvc_rqst->rq_server,
+			(struct sockaddr *)&sin);
+	}
+
+out:
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block lockd_inetaddr_notifier = {
+	.notifier_call = lockd_inetaddr_event,
+};
+
+#if IS_ENABLED(CONFIG_IPV6)
+static int lockd_inet6addr_event(struct notifier_block *this,
+	unsigned long event, void *ptr)
+{
+	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
+	struct sockaddr_in6 sin6;
+
+	if (event != NETDEV_DOWN)
+		goto out;
+
+	if (nlmsvc_rqst) {
+		dprintk("lockd_inet6addr_event: removed %pI6\n", &ifa->addr);
+		sin6.sin6_family = AF_INET6;
+		sin6.sin6_addr = ifa->addr;
+		svc_age_temp_xprts_now(nlmsvc_rqst->rq_server,
+			(struct sockaddr *)&sin6);
+	}
+
+out:
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block lockd_inet6addr_notifier = {
+	.notifier_call = lockd_inet6addr_event,
+};
+#endif
+
+static void lockd_svc_exit_thread(void)
+{
+	unregister_inetaddr_notifier(&lockd_inetaddr_notifier);
+#if IS_ENABLED(CONFIG_IPV6)
+	unregister_inet6addr_notifier(&lockd_inet6addr_notifier);
+#endif
+	svc_exit_thread(nlmsvc_rqst);
+}
+
 static int lockd_start_svc(struct svc_serv *serv)
 {
 	int error;
@@ -315,7 +381,7 @@ static int lockd_start_svc(struct svc_serv *serv)
 	return 0;
 
 out_task:
-	svc_exit_thread(nlmsvc_rqst);
+	lockd_svc_exit_thread();
 	nlmsvc_task = NULL;
 out_rqst:
 	nlmsvc_rqst = NULL;
@@ -360,6 +426,10 @@ static struct svc_serv *lockd_create_svc(void)
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		return ERR_PTR(-ENOMEM);
 	}
+	register_inetaddr_notifier(&lockd_inetaddr_notifier);
+#if IS_ENABLED(CONFIG_IPV6)
+	register_inet6addr_notifier(&lockd_inet6addr_notifier);
+#endif
 	dprintk("lockd_up: service created\n");
 	return serv;
 }
@@ -428,7 +498,7 @@ lockd_down(struct net *net)
 	}
 	kthread_stop(nlmsvc_task);
 	dprintk("lockd_down: service stopped\n");
-	svc_exit_thread(nlmsvc_rqst);
+	lockd_svc_exit_thread();
 	dprintk("lockd_down: service destroyed\n");
 	nlmsvc_task = NULL;
 	nlmsvc_rqst = NULL;

commit 0d0f4aab4e4d290138a4ae7f2ef8469e48c9a669
Author: Andrey Ryabinin <aryabinin@virtuozzo.com>
Date:   Wed Oct 7 14:39:55 2015 +0300

    lockd: get rid of reference-counted NSM RPC clients
    
    Currently we have reference-counted per-net NSM RPC client
    which created on the first monitor request and destroyed
    after the last unmonitor request. It's needed because
    RPC client need to know 'utsname()->nodename', but utsname()
    might be NULL when nsm_unmonitor() called.
    
    So instead of holding the rpc client we could just save nodename
    in struct nlm_host and pass it to the rpc_create().
    Thus ther is no need in keeping rpc client until last
    unmonitor request. We could create separate RPC clients
    for each monitor/unmonitor requests.
    
    Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 0dff13f41808..5f31ebd96c06 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -592,7 +592,6 @@ static int lockd_init_net(struct net *net)
 	INIT_DELAYED_WORK(&ln->grace_period_end, grace_ender);
 	INIT_LIST_HEAD(&ln->lockd_manager.list);
 	ln->lockd_manager.block_opens = false;
-	spin_lock_init(&ln->nsm_clnt_lock);
 	INIT_LIST_HEAD(&ln->nsm_handles);
 	return 0;
 }

commit 0ad95472bf169a3501991f8f33f5147f792a8116
Author: Andrey Ryabinin <aryabinin@virtuozzo.com>
Date:   Wed Sep 23 15:49:29 2015 +0300

    lockd: create NSM handles per net namespace
    
    Commit cb7323fffa85 ("lockd: create and use per-net NSM
     RPC clients on MON/UNMON requests") introduced per-net
    NSM RPC clients. Unfortunately this doesn't make any sense
    without per-net nsm_handle.
    
    E.g. the following scenario could happen
    Two hosts (X and Y) in different namespaces (A and B) share
    the same nsm struct.
    
    1. nsm_monitor(host_X) called => NSM rpc client created,
            nsm->sm_monitored bit set.
    2. nsm_mointor(host-Y) called => nsm->sm_monitored already set,
            we just exit. Thus in namespace B ln->nsm_clnt == NULL.
    3. host X destroyed => nsm->sm_count decremented to 1
    4. host Y destroyed => nsm_unmonitor() => nsm_mon_unmon() => NULL-ptr
            dereference of *ln->nsm_clnt
    
    So this could be fixed by making per-net nsm_handles list,
    instead of global. Thus different net namespaces will not be able
    share the same nsm_handle.
    
    Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index d678bcc3cbcb..0dff13f41808 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -593,6 +593,7 @@ static int lockd_init_net(struct net *net)
 	INIT_LIST_HEAD(&ln->lockd_manager.list);
 	ln->lockd_manager.block_opens = false;
 	spin_lock_init(&ln->nsm_clnt_lock);
+	INIT_LIST_HEAD(&ln->nsm_handles);
 	return 0;
 }
 

commit c87fb4a378f93f114b9906e180d83877cee4e7f4
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Thu Aug 6 12:47:02 2015 -0400

    lockd: NLM grace period shouldn't block NFSv4 opens
    
    NLM locks don't conflict with NFSv4 share reservations, so we're not
    going to learn anything new by watiting for them.
    
    They do conflict with NFSv4 locks and with delegations.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 530914b5c455..d678bcc3cbcb 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -591,6 +591,7 @@ static int lockd_init_net(struct net *net)
 
 	INIT_DELAYED_WORK(&ln->grace_period_end, grace_ender);
 	INIT_LIST_HEAD(&ln->lockd_manager.list);
+	ln->lockd_manager.block_opens = false;
 	spin_lock_init(&ln->nsm_clnt_lock);
 	return 0;
 }

commit b9e13cdfac70e38ade17b53810a36968c5842339
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Mon Jun 8 12:06:51 2015 -0700

    nfsd/sunrpc: turn enqueueing a svc_xprt into a svc_serv operation
    
    For now, all services use svc_xprt_do_enqueue, but once we add
    workqueue-based service support, we'll need to do something different.
    
    Signed-off-by: Shirley Ma <shirley.ma@oracle.com>
    Acked-by: Jeff Layton <jlayton@primarydata.com>
    Tested-by: Shirley Ma <shirley.ma@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 4182b2f925cd..530914b5c455 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -323,7 +323,8 @@ static int lockd_start_svc(struct svc_serv *serv)
 }
 
 static struct svc_serv_ops lockd_sv_ops = {
-	.svo_shutdown	= svc_rpcb_cleanup,
+	.svo_shutdown		= svc_rpcb_cleanup,
+	.svo_enqueue_xprt	= svc_xprt_do_enqueue,
 };
 
 static struct svc_serv *lockd_create_svc(void)

commit ea126e74353453d15fc0a181910ae1e25162f2a1
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Mon Jun 8 12:03:32 2015 -0700

    nfsd/sunrpc: add a new svc_serv_ops struct and move sv_shutdown into it
    
    In later patches we'll need to abstract out more operations on a
    per-service level, besides sv_shutdown and sv_function.
    
    Declare a new svc_serv_ops struct to hold these operations, and move
    sv_shutdown into this struct.
    
    Signed-off-by: Shirley Ma <shirley.ma@oracle.com>
    Acked-by: Jeff Layton <jlayton@primarydata.com>
    Tested-by: Shirley Ma <shirley.ma@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 55505cbe11af..4182b2f925cd 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -322,6 +322,10 @@ static int lockd_start_svc(struct svc_serv *serv)
 	return error;
 }
 
+static struct svc_serv_ops lockd_sv_ops = {
+	.svo_shutdown	= svc_rpcb_cleanup,
+};
+
 static struct svc_serv *lockd_create_svc(void)
 {
 	struct svc_serv *serv;
@@ -350,7 +354,7 @@ static struct svc_serv *lockd_create_svc(void)
 		nlm_timeout = LOCKD_DFLT_TIMEO;
 	nlmsvc_timeout = nlm_timeout * HZ;
 
-	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, svc_rpcb_cleanup);
+	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, &lockd_sv_ops);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		return ERR_PTR(-ENOMEM);

commit 06bed7d18c2c07b3e3eeadf4bd357f6e806618cc
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Jan 2 15:05:25 2015 -0500

    LOCKD: Fix a race when initialising nlmsvc_timeout
    
    This commit fixes a race whereby nlmclnt_init() first starts the lockd
    daemon, and then calls nlm_bind_host() with the expectation that
    nlmsvc_timeout has already been initialised. Unfortunately, there is no
    no synchronisation between lockd() and lockd_up() to guarantee that this
    is the case.
    
    Fix is to move the initialisation of nlmsvc_timeout into lockd_create_svc
    
    Fixes: 9a1b6bf818e74 ("LOCKD: Don't call utsname()->nodename...")
    Cc: Bruce Fields <bfields@fieldses.org>
    Cc: stable@vger.kernel.org # 3.10.x
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index e94c887da2d7..55505cbe11af 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -138,10 +138,6 @@ lockd(void *vrqstp)
 
 	dprintk("NFS locking service started (ver " LOCKD_VERSION ").\n");
 
-	if (!nlm_timeout)
-		nlm_timeout = LOCKD_DFLT_TIMEO;
-	nlmsvc_timeout = nlm_timeout * HZ;
-
 	/*
 	 * The main request loop. We don't terminate until the last
 	 * NFS mount or NFS daemon has gone away.
@@ -350,6 +346,10 @@ static struct svc_serv *lockd_create_svc(void)
 		printk(KERN_WARNING
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
+	if (!nlm_timeout)
+		nlm_timeout = LOCKD_DFLT_TIMEO;
+	nlmsvc_timeout = nlm_timeout * HZ;
+
 	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, svc_rpcb_cleanup);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");

commit 0b5707e4524eb817b7b02863887820d27b56910a
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Wed Nov 19 07:51:22 2014 -0500

    sunrpc: require svc_create callers to pass in meaningful shutdown routine
    
    Currently all svc_create callers pass in NULL for the shutdown parm,
    which then gets fixed up to be svc_rpcb_cleanup if the service uses
    rpcbind.
    
    Simplify this by instead having the the only caller that requires it
    (lockd) pass in svc_rpcb_cleanup and get rid of the special casing.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index d1bb7ecfd201..e94c887da2d7 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -350,7 +350,7 @@ static struct svc_serv *lockd_create_svc(void)
 		printk(KERN_WARNING
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
-	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, NULL);
+	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, svc_rpcb_cleanup);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		return ERR_PTR(-ENOMEM);

commit 6dea0737bc5e160efc77f4c39d393b94fd2746dc
Merge: 25641c0c8d72 34549ab09e62
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 8 12:51:44 2014 -0400

    Merge branch 'for-3.18' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Highlights:
    
       - support the NFSv4.2 SEEK operation (allowing clients to support
         SEEK_HOLE/SEEK_DATA), thanks to Anna.
       - end the grace period early in a number of cases, mitigating a
         long-standing annoyance, thanks to Jeff
       - improve SMP scalability, thanks to Trond"
    
    * 'for-3.18' of git://linux-nfs.org/~bfields/linux: (55 commits)
      nfsd: eliminate "to_delegation" define
      NFSD: Implement SEEK
      NFSD: Add generic v4.2 infrastructure
      svcrdma: advertise the correct max payload
      nfsd: introduce nfsd4_callback_ops
      nfsd: split nfsd4_callback initialization and use
      nfsd: introduce a generic nfsd4_cb
      nfsd: remove nfsd4_callback.cb_op
      nfsd: do not clear rpc_resp in nfsd4_cb_done_sequence
      nfsd: fix nfsd4_cb_recall_done error handling
      nfsd4: clarify how grace period ends
      nfsd4: stop grace_time update at end of grace period
      nfsd: skip subsequent UMH "create" operations after the first one for v4.0 clients
      nfsd: set and test NFSD4_CLIENT_STABLE bit to reduce nfsdcltrack upcalls
      nfsd: serialize nfsdcltrack upcalls for a particular client
      nfsd: pass extra info in env vars to upcalls to allow for early grace period end
      nfsd: add a v4_end_grace file to /proc/fs/nfsd
      lockd: add a /proc/fs/lockd/nlm_end_grace file
      nfsd: reject reclaim request when client has already sent RECLAIM_COMPLETE
      nfsd: remove redundant boot_time parm from grace_done client tracking op
      ...

commit d68e3c4aa416d592d79152a49af121e4ecb204e3
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Sep 12 16:40:20 2014 -0400

    lockd: add a /proc/fs/lockd/nlm_end_grace file
    
    Add a new procfile that will allow a (privileged) userland process to
    end the NLM grace period early. The basic idea here will be to have
    sm-notify write to this file, if it sent out no NOTIFY requests when
    it runs. In that situation, we can generally expect that there will be
    no reclaim requests so the grace period can be lifted early.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 266b67972305..8146cfe97d8d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -36,6 +36,7 @@
 #include <linux/nfs.h>
 
 #include "netns.h"
+#include "procfs.h"
 
 #define NLMDBG_FACILITY		NLMDBG_SVC
 #define LOCKD_BUFSIZE		(1024 + NLMSVC_XDRSIZE)
@@ -620,8 +621,15 @@ static int __init init_nlm(void)
 	err = register_pernet_subsys(&lockd_net_ops);
 	if (err)
 		goto err_pernet;
+
+	err = lockd_create_procfs();
+	if (err)
+		goto err_procfs;
+
 	return 0;
 
+err_procfs:
+	unregister_pernet_subsys(&lockd_net_ops);
 err_pernet:
 #ifdef CONFIG_SYSCTL
 	unregister_sysctl_table(nlm_sysctl_table);
@@ -634,6 +642,7 @@ static void __exit exit_nlm(void)
 {
 	/* FIXME: delete all NLM clients */
 	nlm_shutdown_hosts();
+	lockd_remove_procfs();
 	unregister_pernet_subsys(&lockd_net_ops);
 #ifdef CONFIG_SYSCTL
 	unregister_sysctl_table(nlm_sysctl_table);

commit f7790029655f79cdcee4fa7c7884e0c2795ebebe
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Sep 12 16:40:20 2014 -0400

    lockd: move lockd's grace period handling into its own module
    
    Currently, all of the grace period handling is part of lockd. Eventually
    though we'd like to be able to build v4-only servers, at which point
    we'll need to put all of this elsewhere.
    
    Move the code itself into fs/nfs_common and have it build a grace.ko
    module. Then, rejigger the Kconfig options so that both nfsd and lockd
    enable it automatically.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 09857b48d0c3..266b67972305 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -586,7 +586,7 @@ static int lockd_init_net(struct net *net)
 	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	INIT_DELAYED_WORK(&ln->grace_period_end, grace_ender);
-	INIT_LIST_HEAD(&ln->grace_list);
+	INIT_LIST_HEAD(&ln->lockd_manager.list);
 	spin_lock_init(&ln->nsm_clnt_lock);
 	return 0;
 }

commit 7c17705e77b12b20fb8afb7c1b15dcdb126c0c12
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Aug 29 16:25:50 2014 -0400

    lockd: fix rpcbind crash on lockd startup failure
    
    Nikita Yuschenko reported that booting a kernel with init=/bin/sh and
    then nfs mounting without portmap or rpcbind running using a busybox
    mount resulted in:
    
      # mount -t nfs 10.30.130.21:/opt /mnt
      svc: failed to register lockdv1 RPC service (errno 111).
      lockd_up: makesock failed, error=-111
      Unable to handle kernel paging request for data at address 0x00000030
      Faulting instruction address: 0xc055e65c
      Oops: Kernel access of bad area, sig: 11 [#1]
      MPC85xx CDS
      Modules linked in:
      CPU: 0 PID: 1338 Comm: mount Not tainted 3.10.44.cge #117
      task: cf29cea0 ti: cf35c000 task.ti: cf35c000
      NIP: c055e65c LR: c0566490 CTR: c055e648
      REGS: cf35dad0 TRAP: 0300   Not tainted  (3.10.44.cge)
      MSR: 00029000 <CE,EE,ME>  CR: 22442488  XER: 20000000
      DEAR: 00000030, ESR: 00000000
    
      GPR00: c05606f4 cf35db80 cf29cea0 cf0ded80 cf0dedb8 00000001 1dec3086
      00000000
      GPR08: 00000000 c07b1640 00000007 1dec3086 22442482 100b9758 00000000
      10090ae8
      GPR16: 00000000 000186a5 00000000 00000000 100c3018 bfa46edc 100b0000
      bfa46ef0
      GPR24: cf386ae0 c07834f0 00000000 c0565f88 00000001 cf0dedb8 00000000
      cf0ded80
      NIP [c055e65c] call_start+0x14/0x34
      LR [c0566490] __rpc_execute+0x70/0x250
      Call Trace:
      [cf35db80] [00000080] 0x80 (unreliable)
      [cf35dbb0] [c05606f4] rpc_run_task+0x9c/0xc4
      [cf35dbc0] [c0560840] rpc_call_sync+0x50/0xb8
      [cf35dbf0] [c056ee90] rpcb_register_call+0x54/0x84
      [cf35dc10] [c056f24c] rpcb_register+0xf8/0x10c
      [cf35dc70] [c0569e18] svc_unregister.isra.23+0x100/0x108
      [cf35dc90] [c0569e38] svc_rpcb_cleanup+0x18/0x30
      [cf35dca0] [c0198c5c] lockd_up+0x1dc/0x2e0
      [cf35dcd0] [c0195348] nlmclnt_init+0x2c/0xc8
      [cf35dcf0] [c015bb5c] nfs_start_lockd+0x98/0xec
      [cf35dd20] [c015ce6c] nfs_create_server+0x1e8/0x3f4
      [cf35dd90] [c0171590] nfs3_create_server+0x10/0x44
      [cf35dda0] [c016528c] nfs_try_mount+0x158/0x1e4
      [cf35de20] [c01670d0] nfs_fs_mount+0x434/0x8c8
      [cf35de70] [c00cd3bc] mount_fs+0x20/0xbc
      [cf35de90] [c00e4f88] vfs_kern_mount+0x50/0x104
      [cf35dec0] [c00e6e0c] do_mount+0x1d0/0x8e0
      [cf35df10] [c00e75ac] SyS_mount+0x90/0xd0
      [cf35df40] [c000ccf4] ret_from_syscall+0x0/0x3c
    
    The addition of svc_shutdown_net() resulted in two calls to
    svc_rpcb_cleanup(); the second is no longer necessary and crashes when
    it calls rpcb_register_call with clnt=NULL.
    
    Reported-by: Nikita Yushchenko <nyushchenko@dev.rtsoft.ru>
    Fixes: 679b033df484 "lockd: ensure we tear down any live sockets when socket creation fails during lockd_up"
    Cc: stable@vger.kernel.org
    Acked-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 8f27c93f8d2e..ec9e082f9ecd 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -253,13 +253,11 @@ static int lockd_up_net(struct svc_serv *serv, struct net *net)
 
 	error = make_socks(serv, net);
 	if (error < 0)
-		goto err_socks;
+		goto err_bind;
 	set_grace_period(net);
 	dprintk("lockd_up_net: per-net data created; net=%p\n", net);
 	return 0;
 
-err_socks:
-	svc_rpcb_cleanup(serv, net);
 err_bind:
 	ln->nlmsvc_users--;
 	return error;

commit d4e89902990e3fae1b8d2ca501d2fa5f0657c053
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Sep 2 13:58:57 2014 -0400

    lockd: Do not start the lockd thread before we've set nlmsvc_rqst->rq_task
    
    This fixes an Oopsable race when starting lockd.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Reviewed-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b416b3355807..09857b48d0c3 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -306,7 +306,7 @@ static int lockd_start_svc(struct svc_serv *serv)
 	svc_sock_update_bufs(serv);
 	serv->sv_maxconn = nlm_max_connections;
 
-	nlmsvc_task = kthread_run(lockd, nlmsvc_rqst, "%s", serv->sv_name);
+	nlmsvc_task = kthread_create(lockd, nlmsvc_rqst, "%s", serv->sv_name);
 	if (IS_ERR(nlmsvc_task)) {
 		error = PTR_ERR(nlmsvc_task);
 		printk(KERN_WARNING
@@ -314,6 +314,7 @@ static int lockd_start_svc(struct svc_serv *serv)
 		goto out_task;
 	}
 	nlmsvc_rqst->rq_task = nlmsvc_task;
+	wake_up_process(nlmsvc_task);
 
 	dprintk("lockd_up: service started\n");
 	return 0;

commit d6a7ce424f9e32b6a5589f6bb96e0d1381479d48
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Aug 3 13:03:07 2014 -0400

    lockd: Ensure that lockd_start_svc sets the server rq_task...
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 8f27c93f8d2e..b416b3355807 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -313,6 +313,8 @@ static int lockd_start_svc(struct svc_serv *serv)
 			"lockd_up: kthread_run failed, error=%d\n", error);
 		goto out_task;
 	}
+	nlmsvc_rqst->rq_task = nlmsvc_task;
+
 	dprintk("lockd_up: service started\n");
 	return 0;
 

commit 5b174fd6472b1d6b6402b30210a212f3fd770d96
Merge: 1d21b1bf53f8 48385408b455
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 10 11:50:57 2014 -0700

    Merge branch 'for-3.16' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "The largest piece is a long-overdue rewrite of the xdr code to remove
      some annoying limitations: for example, there was no way to return
      ACLs larger than 4K, and readdir results were returned only in 4k
      chunks, limiting performance on large directories.
    
      Also:
            - part of Neil Brown's work to make NFS work reliably over the
              loopback interface (so client and server can run on the same
              machine without deadlocks).  The rest of it is coming through
              other trees.
            - cleanup and bugfixes for some of the server RDMA code, from
              Steve Wise.
            - Various cleanup of NFSv4 state code in preparation for an
              overhaul of the locking, from Jeff, Trond, and Benny.
            - smaller bugfixes and cleanup from Christoph Hellwig and
              Kinglong Mee.
    
      Thanks to everyone!
    
      This summer looks likely to be busier than usual for knfsd.  Hopefully
      we won't break it too badly; testing definitely welcomed"
    
    * 'for-3.16' of git://linux-nfs.org/~bfields/linux: (100 commits)
      nfsd4: fix FREE_STATEID lockowner leak
      svcrdma: Fence LOCAL_INV work requests
      svcrdma: refactor marshalling logic
      nfsd: don't halt scanning the DRC LRU list when there's an RC_INPROG entry
      nfs4: remove unused CHANGE_SECURITY_LABEL
      nfsd4: kill READ64
      nfsd4: kill READ32
      nfsd4: simplify server xdr->next_page use
      nfsd4: hash deleg stateid only on successful nfs4_set_delegation
      nfsd4: rename recall_lock to state_lock
      nfsd: remove unneeded zeroing of fields in nfsd4_proc_compound
      nfsd: fix setting of NFS4_OO_CONFIRMED in nfsd4_open
      nfsd4: use recall_lock for delegation hashing
      nfsd: fix laundromat next-run-time calculation
      nfsd: make nfsd4_encode_fattr static
      SUNRPC/NFSD: Remove using of dprintk with KERN_WARNING
      nfsd: remove unused function nfsd_read_file
      nfsd: getattr for FATTR4_WORD0_FILES_AVAIL needs the statfs buffer
      NFSD: Error out when getting more than one fsloc/secinfo/uuid
      NFSD: Using type of uint32_t for ex_nflavors instead of int
      ...

commit 7ac9fe571d96a3c5b19d9374cf5c4e445a8690df
Author: Joe Perches <joe@perches.com>
Date:   Fri Jun 6 14:38:02 2014 -0700

    lockd: convert use of typedef ctl_table to struct ctl_table
    
    This typedef is unnecessary and should just be removed.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 6bf06a07f3e0..de051cb1f553 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -436,7 +436,7 @@ EXPORT_SYMBOL_GPL(lockd_down);
  * Sysctl parameters (same as module parameters, different interface).
  */
 
-static ctl_table nlm_sysctls[] = {
+static struct ctl_table nlm_sysctls[] = {
 	{
 		.procname	= "nlm_grace_period",
 		.data		= &nlm_grace_period,
@@ -490,7 +490,7 @@ static ctl_table nlm_sysctls[] = {
 	{ }
 };
 
-static ctl_table nlm_sysctl_dir[] = {
+static struct ctl_table nlm_sysctl_dir[] = {
 	{
 		.procname	= "nfs",
 		.mode		= 0555,
@@ -499,7 +499,7 @@ static ctl_table nlm_sysctl_dir[] = {
 	{ }
 };
 
-static ctl_table nlm_sysctl_root[] = {
+static struct ctl_table nlm_sysctl_root[] = {
 	{
 		.procname	= "fs",
 		.mode		= 0555,

commit 12dd7ecf2323c572b1d302707eada4900848dced
Author: Kees Cook <keescook@chromium.org>
Date:   Thu May 1 14:15:02 2014 -0700

    lockd: avoid warning when CONFIG_SYSCTL undefined
    
    When building without CONFIG_SYSCTL, the compiler saw an unused
    label. This moves the label into the #ifdef it is used under.
    
    fs/lockd/svc.c: In function init_nlm:
    fs/lockd/svc.c:626:1: warning: label err_sysctl defined but not used [-Wunused-label]
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 6bf06a07f3e0..2b431f7266c3 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -622,8 +622,8 @@ static int __init init_nlm(void)
 err_pernet:
 #ifdef CONFIG_SYSCTL
 	unregister_sysctl_table(nlm_sysctl_table);
-#endif
 err_sysctl:
+#endif
 	return err;
 }
 

commit 679b033df48422191c4cac52b610d9980e019f9b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Mar 25 11:55:26 2014 -0700

    lockd: ensure we tear down any live sockets when socket creation fails during lockd_up
    
    We had a Fedora ABRT report with a stack trace like this:
    
    kernel BUG at net/sunrpc/svc.c:550!
    invalid opcode: 0000 [#1] SMP
    [...]
    CPU: 2 PID: 913 Comm: rpc.nfsd Not tainted 3.13.6-200.fc20.x86_64 #1
    Hardware name: Hewlett-Packard HP ProBook 4740s/1846, BIOS 68IRR Ver. F.40 01/29/2013
    task: ffff880146b00000 ti: ffff88003f9b8000 task.ti: ffff88003f9b8000
    RIP: 0010:[<ffffffffa0305fa8>]  [<ffffffffa0305fa8>] svc_destroy+0x128/0x130 [sunrpc]
    RSP: 0018:ffff88003f9b9de0  EFLAGS: 00010206
    RAX: ffff88003f829628 RBX: ffff88003f829600 RCX: 00000000000041ee
    RDX: 0000000000000000 RSI: 0000000000000286 RDI: 0000000000000286
    RBP: ffff88003f9b9de8 R08: 0000000000017360 R09: ffff88014fa97360
    R10: ffffffff8114ce57 R11: ffffea00051c9c00 R12: ffff88003f829600
    R13: 00000000ffffff9e R14: ffffffff81cc7cc0 R15: 0000000000000000
    FS:  00007f4fde284840(0000) GS:ffff88014fa80000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f4fdf5192f8 CR3: 00000000a569a000 CR4: 00000000001407e0
    Stack:
     ffff88003f792300 ffff88003f9b9e18 ffffffffa02de02a 0000000000000000
     ffffffff81cc7cc0 ffff88003f9cb000 0000000000000008 ffff88003f9b9e60
     ffffffffa033bb35 ffffffff8131c86c ffff88003f9cb000 ffff8800a5715008
    Call Trace:
     [<ffffffffa02de02a>] lockd_up+0xaa/0x330 [lockd]
     [<ffffffffa033bb35>] nfsd_svc+0x1b5/0x2f0 [nfsd]
     [<ffffffff8131c86c>] ? simple_strtoull+0x2c/0x50
     [<ffffffffa033c630>] ? write_pool_threads+0x280/0x280 [nfsd]
     [<ffffffffa033c6bb>] write_threads+0x8b/0xf0 [nfsd]
     [<ffffffff8114efa4>] ? __get_free_pages+0x14/0x50
     [<ffffffff8114eff6>] ? get_zeroed_page+0x16/0x20
     [<ffffffff811dec51>] ? simple_transaction_get+0xb1/0xd0
     [<ffffffffa033c098>] nfsctl_transaction_write+0x48/0x80 [nfsd]
     [<ffffffff811b8b34>] vfs_write+0xb4/0x1f0
     [<ffffffff811c3f99>] ? putname+0x29/0x40
     [<ffffffff811b9569>] SyS_write+0x49/0xa0
     [<ffffffff810fc2a6>] ? __audit_syscall_exit+0x1f6/0x2a0
     [<ffffffff816962e9>] system_call_fastpath+0x16/0x1b
    Code: 31 c0 e8 82 db 37 e1 e9 2a ff ff ff 48 8b 07 8b 57 14 48 c7 c7 d5 c6 31 a0 48 8b 70 20 31 c0 e8 65 db 37 e1 e9 f4 fe ff ff 0f 0b <0f> 0b 66 0f 1f 44 00 00 0f 1f 44 00 00 55 48 89 e5 41 56 41 55
    RIP  [<ffffffffa0305fa8>] svc_destroy+0x128/0x130 [sunrpc]
     RSP <ffff88003f9b9de0>
    
    Evidently, we created some lockd sockets and then failed to create
    others. make_socks then returned an error and we tried to tear down the
    svc, but svc->sv_permsocks was not empty so we ended up tripping over
    the BUG() in svc_destroy().
    
    Fix this by ensuring that we tear down any live sockets we created when
    socket creation is going to return an error.
    
    Fixes: 786185b5f8abefa (SUNRPC: move per-net operations from...)
    Reported-by: Raphos <raphoszap@laposte.net>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 10d6c41aecad..6bf06a07f3e0 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -235,6 +235,7 @@ static int make_socks(struct svc_serv *serv, struct net *net)
 	if (warned++ == 0)
 		printk(KERN_WARNING
 			"lockd_up: makesock failed, error=%d\n", err);
+	svc_shutdown_net(serv, net);
 	return err;
 }
 

commit f170168b9a0b61ea1e647b082b38f605f1d3de3e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 3 15:04:58 2013 -0700

    drivers: avoid parsing names as kthread_run() format strings
    
    Calling kthread_run with a single name parameter causes it to be handled
    as a format string. Many callers are passing potentially dynamic string
    content, so use "%s" in those cases to avoid any potential accidents.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index a2aa97d45670..10d6c41aecad 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -305,7 +305,7 @@ static int lockd_start_svc(struct svc_serv *serv)
 	svc_sock_update_bufs(serv);
 	serv->sv_maxconn = nlm_max_connections;
 
-	nlmsvc_task = kthread_run(lockd, nlmsvc_rqst, serv->sv_name);
+	nlmsvc_task = kthread_run(lockd, nlmsvc_rqst, "%s", serv->sv_name);
 	if (IS_ERR(nlmsvc_task)) {
 		error = PTR_ERR(nlmsvc_task);
 		printk(KERN_WARNING

commit bd81ccea8558daab570d70d2c23746413f26cecf
Merge: 98260daa184c a9ca4043d074
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 13 10:53:54 2012 +0900

    Merge branch 'for-3.7' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd update from J Bruce Fields:
     "Another relatively quiet cycle.  There was some progress on my
      remaining 4.1 todo's, but a couple of them were just of the form
      "check that we do X correctly", so didn't have much affect on the
      code.
    
      Other than that, a bunch of cleanup and some bugfixes (including an
      annoying NFSv4.0 state leak and a busy-loop in the server that could
      cause it to peg the CPU without making progress)."
    
    * 'for-3.7' of git://linux-nfs.org/~bfields/linux: (46 commits)
      UAPI: (Scripted) Disintegrate include/linux/sunrpc
      UAPI: (Scripted) Disintegrate include/linux/nfsd
      nfsd4: don't allow reclaims of expired clients
      nfsd4: remove redundant callback probe
      nfsd4: expire old client earlier
      nfsd4: separate session allocation and initialization
      nfsd4: clean up session allocation
      nfsd4: minor free_session cleanup
      nfsd4: new_conn_from_crses should only allocate
      nfsd4: separate connection allocation and initialization
      nfsd4: reject bad forechannel attrs earlier
      nfsd4: enforce per-client sessions/no-sessions distinction
      nfsd4: set cl_minorversion at create time
      nfsd4: don't pin clientids to pseudoflavors
      nfsd4: fix bind_conn_to_session xdr comment
      nfsd4: cast readlink() bug argument
      NFSD: pass null terminated buf to kstrtouint()
      nfsd: remove duplicate init in nfsd4_cb_recall
      nfsd4: eliminate redundant nfs4_free_stateid
      fs/nfsd/nfs4idmap.c: adjust inconsistent IS_ERR and PTR_ERR
      ...

commit e9406db20fecbfcab646bad157b4cfdc7cadddfb
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Sep 18 13:37:12 2012 +0400

    lockd: per-net NSM client creation and destruction helpers introduced
    
    NSM RPC client can be required on NFSv3 umount, when child reaper is dying (and
    destroying it's mount namespace). It means, that current nsproxy is set to
    NULL already, but creation of RPC client requires UTS namespace for gaining
    hostname string.
    This patch introduces reference counted NFS RPC clients creation and
    destruction helpers (similar to RPCBIND RPC clients).
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 31a63f87b806..7e355870d519 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -596,6 +596,7 @@ static int lockd_init_net(struct net *net)
 
 	INIT_DELAYED_WORK(&ln->grace_period_end, grace_ender);
 	INIT_LIST_HEAD(&ln->grace_list);
+	spin_lock_init(&ln->nsm_clnt_lock);
 	return 0;
 }
 

commit 5b444cc9a4c979aa0fa185c8ddca221462a34b7a
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Aug 17 21:47:53 2012 -0400

    svcrpc: remove handling of unknown errors from svc_recv
    
    svc_recv() returns only -EINTR or -EAGAIN.  If we really want to worry
    about the case where it has a bug that causes it to return something
    else, we could stick a WARN() in svc_recv.  But it's silly to require
    every caller to have all this boilerplate to handle that case.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 31a63f87b806..e515569f0f8b 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -126,7 +126,7 @@ static void restart_grace(void)
 static int
 lockd(void *vrqstp)
 {
-	int		err = 0, preverr = 0;
+	int		err = 0;
 	struct svc_rqst *rqstp = vrqstp;
 
 	/* try_to_freeze() is called from svc_recv() */
@@ -165,21 +165,8 @@ lockd(void *vrqstp)
 		 * recvfrom routine.
 		 */
 		err = svc_recv(rqstp, timeout);
-		if (err == -EAGAIN || err == -EINTR) {
-			preverr = err;
+		if (err == -EAGAIN || err == -EINTR)
 			continue;
-		}
-		if (err < 0) {
-			if (err != preverr) {
-				printk(KERN_WARNING "%s: unexpected error "
-					"from svc_recv (%d)\n", __func__, err);
-				preverr = err;
-			}
-			schedule_timeout_interruptible(HZ);
-			continue;
-		}
-		preverr = err;
-
 		dprintk("lockd: request from %s\n",
 				svc_print_addr(rqstp, buf, sizeof(buf)));
 

commit 5630f7fa97e8dfa2b3c6e7370c1702180336e493
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:57:29 2012 +0400

    Lockd: move grace period management from lockd() to per-net functions
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 68271c206bdc..31a63f87b806 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -128,8 +128,6 @@ lockd(void *vrqstp)
 {
 	int		err = 0, preverr = 0;
 	struct svc_rqst *rqstp = vrqstp;
-	struct net *net = &init_net;
-	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	/* try_to_freeze() is called from svc_recv() */
 	set_freezable();
@@ -143,8 +141,6 @@ lockd(void *vrqstp)
 		nlm_timeout = LOCKD_DFLT_TIMEO;
 	nlmsvc_timeout = nlm_timeout * HZ;
 
-	set_grace_period(net);
-
 	/*
 	 * The main request loop. We don't terminate until the last
 	 * NFS mount or NFS daemon has gone away.
@@ -190,8 +186,6 @@ lockd(void *vrqstp)
 		svc_process(rqstp);
 	}
 	flush_signals(current);
-	cancel_delayed_work_sync(&ln->grace_period_end);
-	locks_end_grace(&ln->lockd_manager);
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
 	nlm_shutdown_hosts();
@@ -272,6 +266,7 @@ static int lockd_up_net(struct svc_serv *serv, struct net *net)
 	error = make_socks(serv, net);
 	if (error < 0)
 		goto err_socks;
+	set_grace_period(net);
 	dprintk("lockd_up_net: per-net data created; net=%p\n", net);
 	return 0;
 
@@ -289,6 +284,8 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)
 	if (ln->nlmsvc_users) {
 		if (--ln->nlmsvc_users == 0) {
 			nlm_shutdown_hosts_net(net);
+			cancel_delayed_work_sync(&ln->grace_period_end);
+			locks_end_grace(&ln->lockd_manager);
 			svc_shutdown_net(serv, net);
 			dprintk("lockd_down_net: per-net data destroyed; net=%p\n", net);
 		}

commit 5ccb0066f2d561549cc4d73d7f56b4ce3ca7a8a1
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:57:22 2012 +0400

    LockD: pass actual network namespace to grace period management functions
    
    Passed network namespace replaced hard-coded init_net
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 834dfe2ed2e9..68271c206bdc 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -97,12 +97,12 @@ static void grace_ender(struct work_struct *grace)
 	locks_end_grace(&ln->lockd_manager);
 }
 
-static void set_grace_period(void)
+static void set_grace_period(struct net *net)
 {
 	unsigned long grace_period = get_lockd_grace_period();
-	struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
-	locks_start_grace(&ln->lockd_manager);
+	locks_start_grace(net, &ln->lockd_manager);
 	cancel_delayed_work_sync(&ln->grace_period_end);
 	schedule_delayed_work(&ln->grace_period_end, grace_period);
 }
@@ -110,12 +110,13 @@ static void set_grace_period(void)
 static void restart_grace(void)
 {
 	if (nlmsvc_ops) {
-		struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
+		struct net *net = &init_net;
+		struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 		cancel_delayed_work_sync(&ln->grace_period_end);
 		locks_end_grace(&ln->lockd_manager);
 		nlmsvc_invalidate_all();
-		set_grace_period();
+		set_grace_period(net);
 	}
 }
 
@@ -127,7 +128,8 @@ lockd(void *vrqstp)
 {
 	int		err = 0, preverr = 0;
 	struct svc_rqst *rqstp = vrqstp;
-	struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
+	struct net *net = &init_net;
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	/* try_to_freeze() is called from svc_recv() */
 	set_freezable();
@@ -141,7 +143,7 @@ lockd(void *vrqstp)
 		nlm_timeout = LOCKD_DFLT_TIMEO;
 	nlmsvc_timeout = nlm_timeout * HZ;
 
-	set_grace_period();
+	set_grace_period(net);
 
 	/*
 	 * The main request loop. We don't terminate until the last

commit db9c4553412d72c6a05e0168d1d487f66e0660b3
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:57:13 2012 +0400

    LockD: manage grace list per network namespace
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index a9c436bc450c..834dfe2ed2e9 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -596,6 +596,7 @@ static int lockd_init_net(struct net *net)
 	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	INIT_DELAYED_WORK(&ln->grace_period_end, grace_ender);
+	INIT_LIST_HEAD(&ln->grace_list);
 	return 0;
 }
 

commit 08d44a35a9e71a132c8e8abb0451b7b5e5b3dfee
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:56:50 2012 +0400

    LockD: make lockd manager allocated per network namespace
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 70c417758eb9..a9c436bc450c 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -87,12 +87,14 @@ static unsigned long get_lockd_grace_period(void)
 		return nlm_timeout * 5 * HZ;
 }
 
-static struct lock_manager lockd_manager = {
-};
-
-static void grace_ender(struct work_struct *not_used)
+static void grace_ender(struct work_struct *grace)
 {
-	locks_end_grace(&lockd_manager);
+	struct delayed_work *dwork = container_of(grace, struct delayed_work,
+						  work);
+	struct lockd_net *ln = container_of(dwork, struct lockd_net,
+					    grace_period_end);
+
+	locks_end_grace(&ln->lockd_manager);
 }
 
 static void set_grace_period(void)
@@ -100,7 +102,7 @@ static void set_grace_period(void)
 	unsigned long grace_period = get_lockd_grace_period();
 	struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
 
-	locks_start_grace(&lockd_manager);
+	locks_start_grace(&ln->lockd_manager);
 	cancel_delayed_work_sync(&ln->grace_period_end);
 	schedule_delayed_work(&ln->grace_period_end, grace_period);
 }
@@ -111,7 +113,7 @@ static void restart_grace(void)
 		struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
 
 		cancel_delayed_work_sync(&ln->grace_period_end);
-		locks_end_grace(&lockd_manager);
+		locks_end_grace(&ln->lockd_manager);
 		nlmsvc_invalidate_all();
 		set_grace_period();
 	}
@@ -187,7 +189,7 @@ lockd(void *vrqstp)
 	}
 	flush_signals(current);
 	cancel_delayed_work_sync(&ln->grace_period_end);
-	locks_end_grace(&lockd_manager);
+	locks_end_grace(&ln->lockd_manager);
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
 	nlm_shutdown_hosts();

commit 66547b0251b0b62dcb637631f566410a0e1e47a8
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:56:43 2012 +0400

    LockD: manage grace period per network namespace
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 80938fda67e0..70c417758eb9 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -95,21 +95,22 @@ static void grace_ender(struct work_struct *not_used)
 	locks_end_grace(&lockd_manager);
 }
 
-static DECLARE_DELAYED_WORK(grace_period_end, grace_ender);
-
 static void set_grace_period(void)
 {
 	unsigned long grace_period = get_lockd_grace_period();
+	struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
 
 	locks_start_grace(&lockd_manager);
-	cancel_delayed_work_sync(&grace_period_end);
-	schedule_delayed_work(&grace_period_end, grace_period);
+	cancel_delayed_work_sync(&ln->grace_period_end);
+	schedule_delayed_work(&ln->grace_period_end, grace_period);
 }
 
 static void restart_grace(void)
 {
 	if (nlmsvc_ops) {
-		cancel_delayed_work_sync(&grace_period_end);
+		struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
+
+		cancel_delayed_work_sync(&ln->grace_period_end);
 		locks_end_grace(&lockd_manager);
 		nlmsvc_invalidate_all();
 		set_grace_period();
@@ -124,6 +125,7 @@ lockd(void *vrqstp)
 {
 	int		err = 0, preverr = 0;
 	struct svc_rqst *rqstp = vrqstp;
+	struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
 
 	/* try_to_freeze() is called from svc_recv() */
 	set_freezable();
@@ -184,7 +186,7 @@ lockd(void *vrqstp)
 		svc_process(rqstp);
 	}
 	flush_signals(current);
-	cancel_delayed_work_sync(&grace_period_end);
+	cancel_delayed_work_sync(&ln->grace_period_end);
 	locks_end_grace(&lockd_manager);
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
@@ -589,6 +591,9 @@ module_param(nlm_max_connections, uint, 0644);
 
 static int lockd_init_net(struct net *net)
 {
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
+
+	INIT_DELAYED_WORK(&ln->grace_period_end, grace_ender);
 	return 0;
 }
 

commit 8dbf28e495337b0c66657e3e278ae0ff175b7140
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 25 18:23:16 2012 +0400

    LockD: add debug message to start and stop functions
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b47bf7755008..80938fda67e0 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -266,6 +266,7 @@ static int lockd_up_net(struct svc_serv *serv, struct net *net)
 	error = make_socks(serv, net);
 	if (error < 0)
 		goto err_socks;
+	dprintk("lockd_up_net: per-net data created; net=%p\n", net);
 	return 0;
 
 err_socks:
@@ -283,6 +284,7 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)
 		if (--ln->nlmsvc_users == 0) {
 			nlm_shutdown_hosts_net(net);
 			svc_shutdown_net(serv, net);
+			dprintk("lockd_down_net: per-net data destroyed; net=%p\n", net);
 		}
 	} else {
 		printk(KERN_ERR "lockd_down_net: no users! task=%p, net=%p\n",
@@ -360,6 +362,7 @@ static struct svc_serv *lockd_create_svc(void)
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		return ERR_PTR(-ENOMEM);
 	}
+	dprintk("lockd_up: service created\n");
 	return serv;
 }
 
@@ -426,7 +429,9 @@ lockd_down(struct net *net)
 		BUG();
 	}
 	kthread_stop(nlmsvc_task);
+	dprintk("lockd_down: service stopped\n");
 	svc_exit_thread(nlmsvc_rqst);
+	dprintk("lockd_down: service destroyed\n");
 	nlmsvc_task = NULL;
 	nlmsvc_rqst = NULL;
 out:

commit 3d1221dfa95ca876535c5947626f3834343e8fbc
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 25 18:23:09 2012 +0400

    LockD: service start function introduced
    
    This is just a code move, which from my POV makes the code look better.
    I.e. now on start we have 3 different stages:
    1) Service creation.
    2) Service per-net data allocation.
    3) Service start.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 53cd69ef2add..b47bf7755008 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -291,6 +291,46 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)
 	}
 }
 
+static int lockd_start_svc(struct svc_serv *serv)
+{
+	int error;
+
+	if (nlmsvc_rqst)
+		return 0;
+
+	/*
+	 * Create the kernel thread and wait for it to start.
+	 */
+	nlmsvc_rqst = svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);
+	if (IS_ERR(nlmsvc_rqst)) {
+		error = PTR_ERR(nlmsvc_rqst);
+		printk(KERN_WARNING
+			"lockd_up: svc_rqst allocation failed, error=%d\n",
+			error);
+		goto out_rqst;
+	}
+
+	svc_sock_update_bufs(serv);
+	serv->sv_maxconn = nlm_max_connections;
+
+	nlmsvc_task = kthread_run(lockd, nlmsvc_rqst, serv->sv_name);
+	if (IS_ERR(nlmsvc_task)) {
+		error = PTR_ERR(nlmsvc_task);
+		printk(KERN_WARNING
+			"lockd_up: kthread_run failed, error=%d\n", error);
+		goto out_task;
+	}
+	dprintk("lockd_up: service started\n");
+	return 0;
+
+out_task:
+	svc_exit_thread(nlmsvc_rqst);
+	nlmsvc_task = NULL;
+out_rqst:
+	nlmsvc_rqst = NULL;
+	return error;
+}
+
 static struct svc_serv *lockd_create_svc(void)
 {
 	struct svc_serv *serv;
@@ -343,32 +383,9 @@ int lockd_up(struct net *net)
 	if (error < 0)
 		goto err_net;
 
-	/*
-	 * Create the kernel thread and wait for it to start.
-	 */
-	nlmsvc_rqst = svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);
-	if (IS_ERR(nlmsvc_rqst)) {
-		error = PTR_ERR(nlmsvc_rqst);
-		nlmsvc_rqst = NULL;
-		printk(KERN_WARNING
-			"lockd_up: svc_rqst allocation failed, error=%d\n",
-			error);
-		goto err_start;
-	}
-
-	svc_sock_update_bufs(serv);
-	serv->sv_maxconn = nlm_max_connections;
-
-	nlmsvc_task = kthread_run(lockd, nlmsvc_rqst, serv->sv_name);
-	if (IS_ERR(nlmsvc_task)) {
-		error = PTR_ERR(nlmsvc_task);
-		svc_exit_thread(nlmsvc_rqst);
-		nlmsvc_task = NULL;
-		nlmsvc_rqst = NULL;
-		printk(KERN_WARNING
-			"lockd_up: kthread_run failed, error=%d\n", error);
+	error = lockd_start_svc(serv);
+	if (error < 0)
 		goto err_start;
-	}
 
 	nlmsvc_users++;
 	/*

commit 7d13ec761ae45d5e401965c73d855840ff8cdd23
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 25 18:23:02 2012 +0400

    LockD: move global usage counter manipulation from error path
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index ad11ea777581..53cd69ef2add 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -329,7 +329,7 @@ static struct svc_serv *lockd_create_svc(void)
 int lockd_up(struct net *net)
 {
 	struct svc_serv *serv;
-	int		error = 0;
+	int error;
 
 	mutex_lock(&nlmsvc_mutex);
 
@@ -370,14 +370,13 @@ int lockd_up(struct net *net)
 		goto err_start;
 	}
 
+	nlmsvc_users++;
 	/*
 	 * Note: svc_serv structures have an initial use count of 1,
 	 * so we exit through here on both success and failure.
 	 */
 err_net:
 	svc_destroy(serv);
-	if (!error)
-		nlmsvc_users++;
 err_create:
 	mutex_unlock(&nlmsvc_mutex);
 	return error;

commit 24452239094a8b52f54fd4403f6e177837cecf67
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 25 18:22:54 2012 +0400

    LockD: service creation function introduced
    
    This function creates service if it doesn't exist, or increases usage
    counter if it does, and returns a pointer to it.  The usage counter will
    be droppepd by svc_destroy() later in lockd_up().
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 71c6c3122d35..ad11ea777581 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -291,21 +291,20 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)
 	}
 }
 
-/*
- * Bring up the lockd process if it's not already up.
- */
-int lockd_up(struct net *net)
+static struct svc_serv *lockd_create_svc(void)
 {
 	struct svc_serv *serv;
-	int		error = 0;
 
-	mutex_lock(&nlmsvc_mutex);
 	/*
 	 * Check whether we're already up and running.
 	 */
 	if (nlmsvc_rqst) {
-		error = lockd_up_net(nlmsvc_rqst->rq_server, net);
-		goto out;
+		/*
+		 * Note: increase service usage, because later in case of error
+		 * svc_destroy() will be called.
+		 */
+		svc_get(nlmsvc_rqst->rq_server);
+		return nlmsvc_rqst->rq_server;
 	}
 
 	/*
@@ -316,11 +315,28 @@ int lockd_up(struct net *net)
 		printk(KERN_WARNING
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
-	error = -ENOMEM;
 	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, NULL);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
-		goto out;
+		return ERR_PTR(-ENOMEM);
+	}
+	return serv;
+}
+
+/*
+ * Bring up the lockd process if it's not already up.
+ */
+int lockd_up(struct net *net)
+{
+	struct svc_serv *serv;
+	int		error = 0;
+
+	mutex_lock(&nlmsvc_mutex);
+
+	serv = lockd_create_svc();
+	if (IS_ERR(serv)) {
+		error = PTR_ERR(serv);
+		goto err_create;
 	}
 
 	error = lockd_up_net(serv, net);
@@ -360,9 +376,9 @@ int lockd_up(struct net *net)
 	 */
 err_net:
 	svc_destroy(serv);
-out:
 	if (!error)
 		nlmsvc_users++;
+err_create:
 	mutex_unlock(&nlmsvc_mutex);
 	return error;
 

commit dbf9b5d74ceae787607e3d7db626fffa8be3c03d
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 25 18:22:47 2012 +0400

    LockD: use existing per-net data function on service creation
    
    This patch also replaces svc_rpcb_setup() with svc_bind().
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 58ddc38cfccd..71c6c3122d35 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -259,9 +259,9 @@ static int lockd_up_net(struct svc_serv *serv, struct net *net)
 	if (ln->nlmsvc_users++)
 		return 0;
 
-	error = svc_rpcb_setup(serv, net);
+	error = svc_bind(serv, net);
 	if (error)
-		goto err_rpcb;
+		goto err_bind;
 
 	error = make_socks(serv, net);
 	if (error < 0)
@@ -270,7 +270,7 @@ static int lockd_up_net(struct svc_serv *serv, struct net *net)
 
 err_socks:
 	svc_rpcb_cleanup(serv, net);
-err_rpcb:
+err_bind:
 	ln->nlmsvc_users--;
 	return error;
 }
@@ -298,7 +298,6 @@ int lockd_up(struct net *net)
 {
 	struct svc_serv *serv;
 	int		error = 0;
-	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	mutex_lock(&nlmsvc_mutex);
 	/*
@@ -324,17 +323,9 @@ int lockd_up(struct net *net)
 		goto out;
 	}
 
-	error = svc_bind(serv, net);
-	if (error < 0) {
-		printk(KERN_WARNING "lockd_up: bind service failed\n");
-		goto destroy_and_out;
-	}
-
-	ln->nlmsvc_users++;
-
-	error = make_socks(serv, net);
+	error = lockd_up_net(serv, net);
 	if (error < 0)
-		goto err_start;
+		goto err_net;
 
 	/*
 	 * Create the kernel thread and wait for it to start.
@@ -367,7 +358,7 @@ int lockd_up(struct net *net)
 	 * Note: svc_serv structures have an initial use count of 1,
 	 * so we exit through here on both success and failure.
 	 */
-destroy_and_out:
+err_net:
 	svc_destroy(serv);
 out:
 	if (!error)
@@ -377,7 +368,7 @@ int lockd_up(struct net *net)
 
 err_start:
 	lockd_down_net(serv, net);
-	goto destroy_and_out;
+	goto err_net;
 }
 EXPORT_SYMBOL_GPL(lockd_up);
 

commit 4db77695bf5738bdafa83d1b58b64cbecc6f55e7
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 25 18:22:40 2012 +0400

    LockD: pass service to per-net up and down functions
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 3250f280a171..58ddc38cfccd 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -251,10 +251,9 @@ static int make_socks(struct svc_serv *serv, struct net *net)
 	return err;
 }
 
-static int lockd_up_net(struct net *net)
+static int lockd_up_net(struct svc_serv *serv, struct net *net)
 {
 	struct lockd_net *ln = net_generic(net, lockd_net_id);
-	struct svc_serv *serv = nlmsvc_rqst->rq_server;
 	int error;
 
 	if (ln->nlmsvc_users++)
@@ -276,10 +275,9 @@ static int lockd_up_net(struct net *net)
 	return error;
 }
 
-static void lockd_down_net(struct net *net)
+static void lockd_down_net(struct svc_serv *serv, struct net *net)
 {
 	struct lockd_net *ln = net_generic(net, lockd_net_id);
-	struct svc_serv *serv = nlmsvc_rqst->rq_server;
 
 	if (ln->nlmsvc_users) {
 		if (--ln->nlmsvc_users == 0) {
@@ -307,7 +305,7 @@ int lockd_up(struct net *net)
 	 * Check whether we're already up and running.
 	 */
 	if (nlmsvc_rqst) {
-		error = lockd_up_net(net);
+		error = lockd_up_net(nlmsvc_rqst->rq_server, net);
 		goto out;
 	}
 
@@ -378,7 +376,7 @@ int lockd_up(struct net *net)
 	return error;
 
 err_start:
-	lockd_down_net(net);
+	lockd_down_net(serv, net);
 	goto destroy_and_out;
 }
 EXPORT_SYMBOL_GPL(lockd_up);
@@ -390,7 +388,7 @@ void
 lockd_down(struct net *net)
 {
 	mutex_lock(&nlmsvc_mutex);
-	lockd_down_net(net);
+	lockd_down_net(nlmsvc_rqst->rq_server, net);
 	if (nlmsvc_users) {
 		if (--nlmsvc_users)
 			goto out;

commit 786185b5f8abefa6a8a16695bb4a59c164d5a071
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Fri May 4 12:49:41 2012 +0400

    SUNRPC: move per-net operations from svc_destroy()
    
    The idea is to separate service destruction and per-net operations,
    because these are two different things and the mix looks ugly.
    
    Notes:
    
    1) For NFS server this patch looks ugly (sorry for that). But these
    place will be rewritten soon during NFSd containerization.
    
    2) LockD per-net counter increase int lockd_up() was moved prior to
    make_socks() to make lockd_down_net() call safe in case of error.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b7e92ed56885..3250f280a171 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -257,7 +257,7 @@ static int lockd_up_net(struct net *net)
 	struct svc_serv *serv = nlmsvc_rqst->rq_server;
 	int error;
 
-	if (ln->nlmsvc_users)
+	if (ln->nlmsvc_users++)
 		return 0;
 
 	error = svc_rpcb_setup(serv, net);
@@ -272,6 +272,7 @@ static int lockd_up_net(struct net *net)
 err_socks:
 	svc_rpcb_cleanup(serv, net);
 err_rpcb:
+	ln->nlmsvc_users--;
 	return error;
 }
 
@@ -299,6 +300,7 @@ int lockd_up(struct net *net)
 {
 	struct svc_serv *serv;
 	int		error = 0;
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	mutex_lock(&nlmsvc_mutex);
 	/*
@@ -330,9 +332,11 @@ int lockd_up(struct net *net)
 		goto destroy_and_out;
 	}
 
+	ln->nlmsvc_users++;
+
 	error = make_socks(serv, net);
 	if (error < 0)
-		goto destroy_and_out;
+		goto err_start;
 
 	/*
 	 * Create the kernel thread and wait for it to start.
@@ -344,7 +348,7 @@ int lockd_up(struct net *net)
 		printk(KERN_WARNING
 			"lockd_up: svc_rqst allocation failed, error=%d\n",
 			error);
-		goto destroy_and_out;
+		goto err_start;
 	}
 
 	svc_sock_update_bufs(serv);
@@ -358,7 +362,7 @@ int lockd_up(struct net *net)
 		nlmsvc_rqst = NULL;
 		printk(KERN_WARNING
 			"lockd_up: kthread_run failed, error=%d\n", error);
-		goto destroy_and_out;
+		goto err_start;
 	}
 
 	/*
@@ -368,14 +372,14 @@ int lockd_up(struct net *net)
 destroy_and_out:
 	svc_destroy(serv);
 out:
-	if (!error) {
-		struct lockd_net *ln = net_generic(net, lockd_net_id);
-
-		ln->nlmsvc_users++;
+	if (!error)
 		nlmsvc_users++;
-	}
 	mutex_unlock(&nlmsvc_mutex);
 	return error;
+
+err_start:
+	lockd_down_net(net);
+	goto destroy_and_out;
 }
 EXPORT_SYMBOL_GPL(lockd_up);
 
@@ -386,11 +390,10 @@ void
 lockd_down(struct net *net)
 {
 	mutex_lock(&nlmsvc_mutex);
+	lockd_down_net(net);
 	if (nlmsvc_users) {
-		if (--nlmsvc_users) {
-			lockd_down_net(net);
+		if (--nlmsvc_users)
 			goto out;
-		}
 	} else {
 		printk(KERN_ERR "lockd_down: no users! task=%p\n",
 			nlmsvc_task);

commit 9793f7c88937e7ac07305ab1af1a519225836823
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed May 2 16:08:38 2012 +0400

    SUNRPC: new svc_bind() routine introduced
    
    This new routine is responsible for service registration in a specified
    network context.
    
    The idea is to separate service creation from per-net operations.
    
    Note also: since registering service with svc_bind() can fail, the
    service will be destroyed and during destruction it will try to
    unregister itself from rpcbind. In this case unregistration has to be
    skipped.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 1ead0750cdbb..b7e92ed56885 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -324,6 +324,12 @@ int lockd_up(struct net *net)
 		goto out;
 	}
 
+	error = svc_bind(serv, net);
+	if (error < 0) {
+		printk(KERN_WARNING "lockd_up: bind service failed\n");
+		goto destroy_and_out;
+	}
+
 	error = make_socks(serv, net);
 	if (error < 0)
 		goto destroy_and_out;

commit e3f70eadb7dddfb5a2bb9afff7abfc6ee17a29d0
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Thu Mar 29 18:54:33 2012 +0400

    Lockd: pass network namespace to creation and destruction routines
    
    v2: dereference of most probably already released nlm_host removed in
    nlmclnt_done() and reclaimer().
    
    These routines are called from locks reclaimer() kernel thread. This thread
    works in "init_net" network context and currently relays on persence on lockd
    thread and it's per-net resources. Thus lockd_up() and lockd_down() can't relay
    on current network context. So let's pass corrent one into them.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index f49b9afc4436..1ead0750cdbb 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -295,11 +295,10 @@ static void lockd_down_net(struct net *net)
 /*
  * Bring up the lockd process if it's not already up.
  */
-int lockd_up(void)
+int lockd_up(struct net *net)
 {
 	struct svc_serv *serv;
 	int		error = 0;
-	struct net *net = current->nsproxy->net_ns;
 
 	mutex_lock(&nlmsvc_mutex);
 	/*
@@ -378,12 +377,12 @@ EXPORT_SYMBOL_GPL(lockd_up);
  * Decrement the user count and bring down lockd if we're the last.
  */
 void
-lockd_down(void)
+lockd_down(struct net *net)
 {
 	mutex_lock(&nlmsvc_mutex);
 	if (nlmsvc_users) {
 		if (--nlmsvc_users) {
-			lockd_down_net(current->nsproxy->net_ns);
+			lockd_down_net(net);
 			goto out;
 		}
 	} else {

commit 1df00640c9111c881633d9b219f18e66c52599ec
Merge: ab4684d1560f 5a7c9eec9fde
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Mar 21 16:42:14 2012 -0400

    Merge nfs containerization work from Trond's tree
    
    The nfs containerization work is a prerequisite for Jeff Layton's reboot
    recovery rework.

commit de5b8e8e047534aac6bc9803f96e7257436aef9c
Author: NeilBrown <neilb@suse.de>
Date:   Tue Feb 7 15:35:42 2012 +1100

    lockd: fix arg parsing for grace_period and timeout.
    
    If you try to set grace_period or timeout via a module parameter
    to lockd, and do this on a big-endian machine where
    
       sizeof(int) != sizeof(unsigned long)
    
    it won't work.  This number given will be effectively shifted right
    by the difference in those two sizes.
    
    So cast kp->arg properly to get correct result.
    
    Cc: stable@kernel.org
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index c061b9aa7ddb..2444780f5cfa 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -440,7 +440,7 @@ static int param_set_##name(const char *val, struct kernel_param *kp)	\
 	__typeof__(type) num = which_strtol(val, &endp, 0);		\
 	if (endp == val || *endp || num < (min) || num > (max))		\
 		return -EINVAL;						\
-	*((int *) kp->arg) = num;					\
+	*((type *) kp->arg) = num;					\
 	return 0;							\
 }
 

commit 3b64739fb928c34b13db6b5adcb0d3efb19e78be
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 31 15:08:29 2012 +0400

    Lockd: shutdown NLM hosts in network namespace context
    
    Lockd now managed in network namespace context. And this patch introduces
    network namespace related NLM hosts shutdown in case of releasing per-net Lockd
    resources.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 90dec426bfd8..2774e1013b34 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -281,8 +281,10 @@ static void lockd_down_net(struct net *net)
 	struct svc_serv *serv = nlmsvc_rqst->rq_server;
 
 	if (ln->nlmsvc_users) {
-		if (--ln->nlmsvc_users == 0)
+		if (--ln->nlmsvc_users == 0) {
+			nlm_shutdown_hosts_net(net);
 			svc_shutdown_net(serv, net);
+		}
 	} else {
 		printk(KERN_ERR "lockd_down_net: no users! task=%p, net=%p\n",
 				nlmsvc_task, net);

commit bb2224df5ffe4f864f5b696199b17db1ce77bc0a
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 31 15:08:05 2012 +0400

    Lockd: per-net up and down routines introduced
    
    This patch introduces per-net Lockd initialization and destruction routines.
    The logic is the same as in global Lockd up and down routines. Probably the
    solution is not the best one. But at least it looks clear.
    So per-net "up" routine are called only in case of lockd is running already. If
    per-net resources are not allocated yet, then service is being registered with
    local portmapper and lockd sockets created.
    Per-net "down" routine is called on every lockd_down() call in case of global
    users counter is not zero.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 73c9ebf09301..90dec426bfd8 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -251,6 +251,45 @@ static int make_socks(struct svc_serv *serv, struct net *net)
 	return err;
 }
 
+static int lockd_up_net(struct net *net)
+{
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
+	struct svc_serv *serv = nlmsvc_rqst->rq_server;
+	int error;
+
+	if (ln->nlmsvc_users)
+		return 0;
+
+	error = svc_rpcb_setup(serv, net);
+	if (error)
+		goto err_rpcb;
+
+	error = make_socks(serv, net);
+	if (error < 0)
+		goto err_socks;
+	return 0;
+
+err_socks:
+	svc_rpcb_cleanup(serv, net);
+err_rpcb:
+	return error;
+}
+
+static void lockd_down_net(struct net *net)
+{
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
+	struct svc_serv *serv = nlmsvc_rqst->rq_server;
+
+	if (ln->nlmsvc_users) {
+		if (--ln->nlmsvc_users == 0)
+			svc_shutdown_net(serv, net);
+	} else {
+		printk(KERN_ERR "lockd_down_net: no users! task=%p, net=%p\n",
+				nlmsvc_task, net);
+		BUG();
+	}
+}
+
 /*
  * Bring up the lockd process if it's not already up.
  */
@@ -264,8 +303,10 @@ int lockd_up(void)
 	/*
 	 * Check whether we're already up and running.
 	 */
-	if (nlmsvc_rqst)
+	if (nlmsvc_rqst) {
+		error = lockd_up_net(net);
 		goto out;
+	}
 
 	/*
 	 * Sanity check: if there's no pid,
@@ -339,8 +380,10 @@ lockd_down(void)
 {
 	mutex_lock(&nlmsvc_mutex);
 	if (nlmsvc_users) {
-		if (--nlmsvc_users)
+		if (--nlmsvc_users) {
+			lockd_down_net(current->nsproxy->net_ns);
 			goto out;
+		}
 	} else {
 		printk(KERN_ERR "lockd_down: no users! task=%p\n",
 			nlmsvc_task);

commit a9c5d73a8d8cb37601f8c39b35b9b4128e1a5254
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 31 15:07:57 2012 +0400

    Lockd: pernet usage counter introduced
    
    Lockd is going to be shared between network namespaces - i.e. going to be able
    to handle lock requests from different network namespaces. This means, that
    network namespace related resources have to be allocated not once (like now),
    but for every network namespace context, from which service is requested to
    operate.
    This patch implements Lockd per-net users accounting. New per-net counter is
    used to determine, when per-net resources have to be freed.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index cba35984dde7..73c9ebf09301 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -35,6 +35,8 @@
 #include <linux/lockd/lockd.h>
 #include <linux/nfs.h>
 
+#include "netns.h"
+
 #define NLMDBG_FACILITY		NLMDBG_SVC
 #define LOCKD_BUFSIZE		(1024 + NLMSVC_XDRSIZE)
 #define ALLOWED_SIGS		(sigmask(SIGKILL))
@@ -50,6 +52,8 @@ static struct task_struct	*nlmsvc_task;
 static struct svc_rqst		*nlmsvc_rqst;
 unsigned long			nlmsvc_timeout;
 
+int lockd_net_id;
+
 /*
  * These can be set at insmod time (useful for NFS as root filesystem),
  * and also changed through the sysctl interface.  -- Jamie Lokier, Aug 2003
@@ -316,8 +320,12 @@ int lockd_up(void)
 destroy_and_out:
 	svc_destroy(serv);
 out:
-	if (!error)
+	if (!error) {
+		struct lockd_net *ln = net_generic(net, lockd_net_id);
+
+		ln->nlmsvc_users++;
 		nlmsvc_users++;
+	}
 	mutex_unlock(&nlmsvc_mutex);
 	return error;
 }
@@ -500,24 +508,55 @@ module_param_call(nlm_tcpport, param_set_port, param_get_int,
 module_param(nsm_use_hostnames, bool, 0644);
 module_param(nlm_max_connections, uint, 0644);
 
+static int lockd_init_net(struct net *net)
+{
+	return 0;
+}
+
+static void lockd_exit_net(struct net *net)
+{
+}
+
+static struct pernet_operations lockd_net_ops = {
+	.init = lockd_init_net,
+	.exit = lockd_exit_net,
+	.id = &lockd_net_id,
+	.size = sizeof(struct lockd_net),
+};
+
+
 /*
  * Initialising and terminating the module.
  */
 
 static int __init init_nlm(void)
 {
+	int err;
+
 #ifdef CONFIG_SYSCTL
+	err = -ENOMEM;
 	nlm_sysctl_table = register_sysctl_table(nlm_sysctl_root);
-	return nlm_sysctl_table ? 0 : -ENOMEM;
-#else
+	if (nlm_sysctl_table == NULL)
+		goto err_sysctl;
+#endif
+	err = register_pernet_subsys(&lockd_net_ops);
+	if (err)
+		goto err_pernet;
 	return 0;
+
+err_pernet:
+#ifdef CONFIG_SYSCTL
+	unregister_sysctl_table(nlm_sysctl_table);
 #endif
+err_sysctl:
+	return err;
 }
 
 static void __exit exit_nlm(void)
 {
 	/* FIXME: delete all NLM clients */
 	nlm_shutdown_hosts();
+	unregister_pernet_subsys(&lockd_net_ops);
 #ifdef CONFIG_SYSCTL
 	unregister_sysctl_table(nlm_sysctl_table);
 #endif

commit c228fa2038a33bb3b87f567482124f452e162a71
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 31 15:07:48 2012 +0400

    Lockd: create permanent lockd sockets in current network namespace
    
    This patch parametrizes Lockd permanent sockets creation routine by network
    namespace context.
    It also replaces hard-coded init_net with current network namespace context in
    Lockd sockets creation routines.
    This approach looks safe, because Lockd is created during NFS mount (or NFS
    server start) and thus socket is required exactly in current network namespace
    context. But in the same time it means, that Lockd sockets inherits first Lockd
    requester network namespace. This issue will be fixed in further patches of the
    series.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index ff379ff7761f..cba35984dde7 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -189,27 +189,29 @@ lockd(void *vrqstp)
 }
 
 static int create_lockd_listener(struct svc_serv *serv, const char *name,
-				 const int family, const unsigned short port)
+				 struct net *net, const int family,
+				 const unsigned short port)
 {
 	struct svc_xprt *xprt;
 
-	xprt = svc_find_xprt(serv, name, &init_net, family, 0);
+	xprt = svc_find_xprt(serv, name, net, family, 0);
 	if (xprt == NULL)
-		return svc_create_xprt(serv, name, &init_net, family, port,
+		return svc_create_xprt(serv, name, net, family, port,
 						SVC_SOCK_DEFAULTS);
 	svc_xprt_put(xprt);
 	return 0;
 }
 
-static int create_lockd_family(struct svc_serv *serv, const int family)
+static int create_lockd_family(struct svc_serv *serv, struct net *net,
+			       const int family)
 {
 	int err;
 
-	err = create_lockd_listener(serv, "udp", family, nlm_udpport);
+	err = create_lockd_listener(serv, "udp", net, family, nlm_udpport);
 	if (err < 0)
 		return err;
 
-	return create_lockd_listener(serv, "tcp", family, nlm_tcpport);
+	return create_lockd_listener(serv, "tcp", net, family, nlm_tcpport);
 }
 
 /*
@@ -222,16 +224,16 @@ static int create_lockd_family(struct svc_serv *serv, const int family)
  * Returns zero if all listeners are available; otherwise a
  * negative errno value is returned.
  */
-static int make_socks(struct svc_serv *serv)
+static int make_socks(struct svc_serv *serv, struct net *net)
 {
 	static int warned;
 	int err;
 
-	err = create_lockd_family(serv, PF_INET);
+	err = create_lockd_family(serv, net, PF_INET);
 	if (err < 0)
 		goto out_err;
 
-	err = create_lockd_family(serv, PF_INET6);
+	err = create_lockd_family(serv, net, PF_INET6);
 	if (err < 0 && err != -EAFNOSUPPORT)
 		goto out_err;
 
@@ -252,6 +254,7 @@ int lockd_up(void)
 {
 	struct svc_serv *serv;
 	int		error = 0;
+	struct net *net = current->nsproxy->net_ns;
 
 	mutex_lock(&nlmsvc_mutex);
 	/*
@@ -275,7 +278,7 @@ int lockd_up(void)
 		goto out;
 	}
 
-	error = make_socks(serv);
+	error = make_socks(serv, net);
 	if (error < 0)
 		goto destroy_and_out;
 

commit 4cb54ca2069903121e4c03ec427147c47bed5755
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Fri Jan 20 16:50:53 2012 +0400

    SUNRPC: search for service transports in network namespace context
    
    Service transports are parametrized by network namespace. And thus lookup of
    transport instance have to take network namespace into account.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index c061b9aa7ddb..ff379ff7761f 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -193,7 +193,7 @@ static int create_lockd_listener(struct svc_serv *serv, const char *name,
 {
 	struct svc_xprt *xprt;
 
-	xprt = svc_find_xprt(serv, name, family, 0);
+	xprt = svc_find_xprt(serv, name, &init_net, family, 0);
 	if (xprt == NULL)
 		return svc_create_xprt(serv, name, &init_net, family, port,
 						SVC_SOCK_DEFAULTS);

commit 11fd165c68b73434ca1273e21f21db5eecc90926
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Jul 28 20:04:09 2011 +0200

    sunrpc: use better NUMA affinities
    
    Use NUMA aware allocations to reduce latencies and increase throughput.
    
    sunrpc kthreads can use kthread_create_on_node() if pool_mode is
    "percpu" or "pernode", and svc_prepare_thread()/svc_init_buffer() can
    also take into account NUMA node affinity for memory allocations.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    CC: "J. Bruce Fields" <bfields@fieldses.org>
    CC: Neil Brown <neilb@suse.de>
    CC: David Miller <davem@davemloft.net>
    Reviewed-by: Greg Banks <gnb@fastmail.fm>
    [bfields@redhat.com: fix up caller nfs41_callback_up]
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index abfff9d7979d..c061b9aa7ddb 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -282,7 +282,7 @@ int lockd_up(void)
 	/*
 	 * Create the kernel thread and wait for it to start.
 	 */
-	nlmsvc_rqst = svc_prepare_thread(serv, &serv->sv_pools[0]);
+	nlmsvc_rqst = svc_prepare_thread(serv, &serv->sv_pools[0], NUMA_NO_NODE);
 	if (IS_ERR(nlmsvc_rqst)) {
 		error = PTR_ERR(nlmsvc_rqst);
 		nlmsvc_rqst = NULL;

commit 763641d81202834e9d64de2019d1edec12868f4f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Oct 26 22:55:40 2010 +0200

    lockd: push lock_flocks down
    
    lockd should use lock_flocks() instead of lock_kernel()
    to lock against posix locks accessing the i_flock list.
    
    This is a prerequisite to turning lock_flocks into a
    spinlock.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b13aabc12298..abfff9d7979d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -22,7 +22,6 @@
 #include <linux/in.h>
 #include <linux/uio.h>
 #include <linux/smp.h>
-#include <linux/smp_lock.h>
 #include <linux/mutex.h>
 #include <linux/kthread.h>
 #include <linux/freezer.h>
@@ -130,15 +129,6 @@ lockd(void *vrqstp)
 
 	dprintk("NFS locking service started (ver " LOCKD_VERSION ").\n");
 
-	/*
-	 * FIXME: it would be nice if lockd didn't spend its entire life
-	 * running under the BKL. At the very least, it would be good to
-	 * have someone clarify what it's intended to protect here. I've
-	 * seen some handwavy posts about posix locking needing to be
-	 * done under the BKL, but it's far from clear.
-	 */
-	lock_kernel();
-
 	if (!nlm_timeout)
 		nlm_timeout = LOCKD_DFLT_TIMEO;
 	nlmsvc_timeout = nlm_timeout * HZ;
@@ -195,7 +185,6 @@ lockd(void *vrqstp)
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
 	nlm_shutdown_hosts();
-	unlock_kernel();
 	return 0;
 }
 

commit fc5d00b04a3a58cac8620403dfe9f43f72578ec1
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Wed Sep 29 16:03:50 2010 +0400

    sunrpc: Add net argument to svc_create_xprt
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index f1bacf1a0391..b13aabc12298 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -206,7 +206,7 @@ static int create_lockd_listener(struct svc_serv *serv, const char *name,
 
 	xprt = svc_find_xprt(serv, name, family, 0);
 	if (xprt == NULL)
-		return svc_create_xprt(serv, name, family, port,
+		return svc_create_xprt(serv, name, &init_net, family, port,
 						SVC_SOCK_DEFAULTS);
 	svc_xprt_put(xprt);
 	return 0;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 7d150517ddf0..f1bacf1a0391 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -21,7 +21,6 @@
 #include <linux/errno.h>
 #include <linux/in.h>
 #include <linux/uio.h>
-#include <linux/slab.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/mutex.h>

commit d6783b2b6c4050df0ba0a84c6842cf5bc2212ef9
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Jan 26 14:04:04 2010 -0500

    SUNRPC: Bury "#ifdef IPV6" in svc_create_xprt()
    
    Clean up:  Bruce observed we have more or less common logic in each of
    svc_create_xprt()'s callers:  the check to create an IPv6 RPC listener
    socket only if CONFIG_IPV6 is set.  I'm about to add another case
    that does just the same.
    
    If we move the ifdefs into __svc_xpo_create(), then svc_create_xprt()
    call sites can get rid of the "#ifdef" ugliness, and can use the same
    logic with or without IPv6 support available in the kernel.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index e50cfa3d9654..7d150517ddf0 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -243,11 +243,9 @@ static int make_socks(struct svc_serv *serv)
 	if (err < 0)
 		goto out_err;
 
-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 	err = create_lockd_family(serv, PF_INET6);
 	if (err < 0 && err != -EAFNOSUPPORT)
 		goto out_err;
-#endif	/* CONFIG_IPV6 || CONFIG_IPV6_MODULE */
 
 	warned = 0;
 	return 0;

commit 6d4561110a3e9fa742aeec6717248a491dfb1878
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Nov 16 03:11:48 2009 -0800

    sysctl: Drop & in front of every proc_handler.
    
    For consistency drop & in front of every proc_handler.  Explicity
    taking the address is unnecessary and it prevents optimizations
    like stubbing the proc_handlers to NULL.
    
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 307ed4c3e1f5..e50cfa3d9654 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -375,7 +375,7 @@ static ctl_table nlm_sysctls[] = {
 		.data		= &nlm_grace_period,
 		.maxlen		= sizeof(unsigned long),
 		.mode		= 0644,
-		.proc_handler	= &proc_doulongvec_minmax,
+		.proc_handler	= proc_doulongvec_minmax,
 		.extra1		= (unsigned long *) &nlm_grace_period_min,
 		.extra2		= (unsigned long *) &nlm_grace_period_max,
 	},
@@ -384,7 +384,7 @@ static ctl_table nlm_sysctls[] = {
 		.data		= &nlm_timeout,
 		.maxlen		= sizeof(unsigned long),
 		.mode		= 0644,
-		.proc_handler	= &proc_doulongvec_minmax,
+		.proc_handler	= proc_doulongvec_minmax,
 		.extra1		= (unsigned long *) &nlm_timeout_min,
 		.extra2		= (unsigned long *) &nlm_timeout_max,
 	},
@@ -393,7 +393,7 @@ static ctl_table nlm_sysctls[] = {
 		.data		= &nlm_udpport,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_minmax,
+		.proc_handler	= proc_dointvec_minmax,
 		.extra1		= (int *) &nlm_port_min,
 		.extra2		= (int *) &nlm_port_max,
 	},
@@ -402,7 +402,7 @@ static ctl_table nlm_sysctls[] = {
 		.data		= &nlm_tcpport,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_minmax,
+		.proc_handler	= proc_dointvec_minmax,
 		.extra1		= (int *) &nlm_port_min,
 		.extra2		= (int *) &nlm_port_max,
 	},
@@ -411,14 +411,14 @@ static ctl_table nlm_sysctls[] = {
 		.data		= &nsm_use_hostnames,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= &proc_dointvec,
+		.proc_handler	= proc_dointvec,
 	},
 	{
 		.procname	= "nsm_local_state",
 		.data		= &nsm_local_state,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= &proc_dointvec,
+		.proc_handler	= proc_dointvec,
 	},
 	{ }
 };

commit ab09203e302b6e526f6930f3e460064b0f253ae9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Nov 5 14:25:10 2009 -0800

    sysctl fs: Remove dead binary sysctl support
    
    Now that sys_sysctl is a generic wrapper around /proc/sys  .ctl_name
    and .strategy members of sysctl tables are dead code.  Remove them.
    
    Cc: Jan Harkes <jaharkes@cs.cmu.edu>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 1a54ae14a192..307ed4c3e1f5 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -371,7 +371,6 @@ EXPORT_SYMBOL_GPL(lockd_down);
 
 static ctl_table nlm_sysctls[] = {
 	{
-		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nlm_grace_period",
 		.data		= &nlm_grace_period,
 		.maxlen		= sizeof(unsigned long),
@@ -381,7 +380,6 @@ static ctl_table nlm_sysctls[] = {
 		.extra2		= (unsigned long *) &nlm_grace_period_max,
 	},
 	{
-		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nlm_timeout",
 		.data		= &nlm_timeout,
 		.maxlen		= sizeof(unsigned long),
@@ -391,7 +389,6 @@ static ctl_table nlm_sysctls[] = {
 		.extra2		= (unsigned long *) &nlm_timeout_max,
 	},
 	{
-		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nlm_udpport",
 		.data		= &nlm_udpport,
 		.maxlen		= sizeof(int),
@@ -401,7 +398,6 @@ static ctl_table nlm_sysctls[] = {
 		.extra2		= (int *) &nlm_port_max,
 	},
 	{
-		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nlm_tcpport",
 		.data		= &nlm_tcpport,
 		.maxlen		= sizeof(int),
@@ -411,7 +407,6 @@ static ctl_table nlm_sysctls[] = {
 		.extra2		= (int *) &nlm_port_max,
 	},
 	{
-		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nsm_use_hostnames",
 		.data		= &nsm_use_hostnames,
 		.maxlen		= sizeof(int),
@@ -419,34 +414,31 @@ static ctl_table nlm_sysctls[] = {
 		.proc_handler	= &proc_dointvec,
 	},
 	{
-		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nsm_local_state",
 		.data		= &nsm_local_state,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
-	{ .ctl_name = 0 }
+	{ }
 };
 
 static ctl_table nlm_sysctl_dir[] = {
 	{
-		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nfs",
 		.mode		= 0555,
 		.child		= nlm_sysctls,
 	},
-	{ .ctl_name = 0 }
+	{ }
 };
 
 static ctl_table nlm_sysctl_root[] = {
 	{
-		.ctl_name	= CTL_FS,
 		.procname	= "fs",
 		.mode		= 0555,
 		.child		= nlm_sysctl_dir,
 	},
-	{ .ctl_name = 0 }
+	{ }
 };
 
 #endif	/* CONFIG_SYSCTL */

commit 89996df4b5b1a09c279f50b3fd03aa9df735f5cb
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed May 6 16:32:54 2009 -0400

    lockd: fix list corruption on lockd restart
    
    If lockd is signalled soon enough after restart then locks_start_grace()
    will try to re-add an entry to a list and trigger a lock corruption
    warning.
    
    Thanks to Wang Chen for the problem report and diagnosis.
    
    WARNING: at lib/list_debug.c:26 __list_add+0x27/0x5c()
    ...
    list_add corruption. next->prev should be prev (ef8fe958), but was ef8ff128.  (next=ef8ff128).
    ...
    Pid: 23062, comm: lockd Tainted: G        W  2.6.30-rc2 #3
    Call Trace:
    [<c042d5b5>] warn_slowpath+0x71/0xa0
    [<c0422a96>] ? update_curr+0x11d/0x125
    [<c044b12d>] ? trace_hardirqs_on_caller+0x18/0x150
    [<c044b270>] ? trace_hardirqs_on+0xb/0xd
    [<c051c61a>] ? _raw_spin_lock+0x53/0xfa
    [<c051c89f>] __list_add+0x27/0x5c
    [<ef8f6daa>] locks_start_grace+0x22/0x30 [lockd]
    [<ef8f34da>] set_grace_period+0x39/0x53 [lockd]
    [<c06b8921>] ? lock_kernel+0x1c/0x28
    [<ef8f3558>] lockd+0x64/0x164 [lockd]
    [<c044b12d>] ? trace_hardirqs_on_caller+0x18/0x150
    [<c04227b0>] ? complete+0x34/0x3e
    [<ef8f34f4>] ? lockd+0x0/0x164 [lockd]
    [<ef8f34f4>] ? lockd+0x0/0x164 [lockd]
    [<c043dd42>] kthread+0x45/0x6b
    [<c043dcfd>] ? kthread+0x0/0x6b
    [<c0403c23>] kernel_thread_helper+0x7/0x10
    
    Reported-by: Wang Chen <wangchen@cn.fujitsu.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Cc: stable@kernel.org

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index abf83881f68a..1a54ae14a192 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -104,6 +104,16 @@ static void set_grace_period(void)
 	schedule_delayed_work(&grace_period_end, grace_period);
 }
 
+static void restart_grace(void)
+{
+	if (nlmsvc_ops) {
+		cancel_delayed_work_sync(&grace_period_end);
+		locks_end_grace(&lockd_manager);
+		nlmsvc_invalidate_all();
+		set_grace_period();
+	}
+}
+
 /*
  * This is the lockd kernel thread
  */
@@ -149,10 +159,7 @@ lockd(void *vrqstp)
 
 		if (signalled()) {
 			flush_signals(current);
-			if (nlmsvc_ops) {
-				nlmsvc_invalidate_all();
-				set_grace_period();
-			}
+			restart_grace();
 			continue;
 		}
 

commit eb16e907781a9da7f272a3e8284c26bc4e4aeb9d
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Mar 18 20:47:59 2009 -0400

    lockd: Start PF_INET6 listener only if IPv6 support is available
    
    Apparently a lot of people need to disable IPv6 completely on their
    distributor-built systems, which have CONFIG_IPV6_MODULE enabled at
    build time.
    
    They do this by blacklisting the ipv6.ko module.  This causes the
    creation of the lockd service listener to fail if CONFIG_IPV6_MODULE
    is set, but the module cannot be loaded.
    
    Now that the kernel's PF_INET6 RPC listeners are completely separate
    from PF_INET listeners, we can always start PF_INET.  Then lockd can
    try to start PF_INET6, but it isn't required to be available.
    
    Note this has the added benefit that NLM callbacks from AF_INET6
    servers will never come from AF_INET remotes.  We no longer have to
    worry about matching mapped IPv4 addresses to AF_INET when comparing
    addresses.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 566932b98fd3..abf83881f68a 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -193,20 +193,30 @@ lockd(void *vrqstp)
 	return 0;
 }
 
-static int create_lockd_listener(struct svc_serv *serv, char *name,
-				 unsigned short port)
+static int create_lockd_listener(struct svc_serv *serv, const char *name,
+				 const int family, const unsigned short port)
 {
 	struct svc_xprt *xprt;
 
-	xprt = svc_find_xprt(serv, name, 0, 0);
+	xprt = svc_find_xprt(serv, name, family, 0);
 	if (xprt == NULL)
-		return svc_create_xprt(serv, name, PF_INET,
-					port, SVC_SOCK_DEFAULTS);
-
+		return svc_create_xprt(serv, name, family, port,
+						SVC_SOCK_DEFAULTS);
 	svc_xprt_put(xprt);
 	return 0;
 }
 
+static int create_lockd_family(struct svc_serv *serv, const int family)
+{
+	int err;
+
+	err = create_lockd_listener(serv, "udp", family, nlm_udpport);
+	if (err < 0)
+		return err;
+
+	return create_lockd_listener(serv, "tcp", family, nlm_tcpport);
+}
+
 /*
  * Ensure there are active UDP and TCP listeners for lockd.
  *
@@ -222,13 +232,15 @@ static int make_socks(struct svc_serv *serv)
 	static int warned;
 	int err;
 
-	err = create_lockd_listener(serv, "udp", nlm_udpport);
+	err = create_lockd_family(serv, PF_INET);
 	if (err < 0)
 		goto out_err;
 
-	err = create_lockd_listener(serv, "tcp", nlm_tcpport);
-	if (err < 0)
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	err = create_lockd_family(serv, PF_INET6);
+	if (err < 0 && err != -EAFNOSUPPORT)
 		goto out_err;
+#endif	/* CONFIG_IPV6 || CONFIG_IPV6_MODULE */
 
 	warned = 0;
 	return 0;

commit 26298caacac3e4754194b13aef377706d5de6cf6
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Mar 18 20:46:36 2009 -0400

    NFS: Revert creation of IPv6 listeners for lockd and NFSv4 callbacks
    
    We're about to convert over to using separate PF_INET and PF_INET6
    listeners, instead of a single PF_INET6 listener that also receives
    AF_INET requests and maps them to AF_INET6.
    
    Clear the way by removing the logic in lockd and the NFSv4 callback
    server that creates an AF_INET6 service listener.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index d30920038cb6..566932b98fd3 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -52,17 +52,6 @@ static struct task_struct	*nlmsvc_task;
 static struct svc_rqst		*nlmsvc_rqst;
 unsigned long			nlmsvc_timeout;
 
-/*
- * If the kernel has IPv6 support available, always listen for
- * both AF_INET and AF_INET6 requests.
- */
-#if (defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)) && \
-	defined(CONFIG_SUNRPC_REGISTER_V4)
-static const sa_family_t	nlmsvc_family = AF_INET6;
-#else	/* (CONFIG_IPV6 || CONFIG_IPV6_MODULE) && CONFIG_SUNRPC_REGISTER_V4 */
-static const sa_family_t	nlmsvc_family = AF_INET;
-#endif	/* (CONFIG_IPV6 || CONFIG_IPV6_MODULE) && CONFIG_SUNRPC_REGISTER_V4 */
-
 /*
  * These can be set at insmod time (useful for NFS as root filesystem),
  * and also changed through the sysctl interface.  -- Jamie Lokier, Aug 2003
@@ -211,7 +200,7 @@ static int create_lockd_listener(struct svc_serv *serv, char *name,
 
 	xprt = svc_find_xprt(serv, name, 0, 0);
 	if (xprt == NULL)
-		return svc_create_xprt(serv, name, nlmsvc_family,
+		return svc_create_xprt(serv, name, PF_INET,
 					port, SVC_SOCK_DEFAULTS);
 
 	svc_xprt_put(xprt);

commit 49a9072f29a1039f142ec98b44a72d7173651c02
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Mar 18 20:46:29 2009 -0400

    SUNRPC: Remove @family argument from svc_create() and svc_create_pooled()
    
    Since an RPC service listener's protocol family is specified now via
    svc_create_xprt(), it no longer needs to be passed to svc_create() or
    svc_create_pooled().  Remove that argument from the synopsis of those
    functions, and remove the sv_family field from the svc_serv struct.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 390c5593655c..d30920038cb6 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -275,7 +275,7 @@ int lockd_up(void)
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
 	error = -ENOMEM;
-	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, nlmsvc_family, NULL);
+	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, NULL);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		goto out;

commit 9652ada3fb5914a67d8422114e8a76388330fa79
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Mar 18 20:46:21 2009 -0400

    SUNRPC: Change svc_create_xprt() to take a @family argument
    
    The sv_family field is going away.  Pass a protocol family argument to
    svc_create_xprt() instead of extracting the family from the passed-in
    svc_serv struct.
    
    Again, as this is a listener socket and not an address, we make this
    new argument an "int" protocol family, instead of an "sa_family_t."
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 64f1c31b5853..390c5593655c 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -211,7 +211,8 @@ static int create_lockd_listener(struct svc_serv *serv, char *name,
 
 	xprt = svc_find_xprt(serv, name, 0, 0);
 	if (xprt == NULL)
-		return svc_create_xprt(serv, name, port, SVC_SOCK_DEFAULTS);
+		return svc_create_xprt(serv, name, nlmsvc_family,
+					port, SVC_SOCK_DEFAULTS);
 
 	svc_xprt_put(xprt);
 	return 0;

commit 0dba7c2a9ed3d4a1e58f5d94fffa9f44dbe012e6
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Dec 31 16:06:11 2008 -0500

    NLM: Clean up flow of control in make_socks() function
    
    Clean up: Use Bruce's preferred control flow style in make_socks().
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index cf3899aec375..64f1c31b5853 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -230,17 +230,23 @@ static int create_lockd_listener(struct svc_serv *serv, char *name,
 static int make_socks(struct svc_serv *serv)
 {
 	static int warned;
-	int err = 0;
+	int err;
 
 	err = create_lockd_listener(serv, "udp", nlm_udpport);
-	if (err >= 0)
-		err = create_lockd_listener(serv, "tcp", nlm_tcpport);
-	if (err >= 0) {
-		warned = 0;
-		err = 0;
-	} else if (warned++ == 0)
+	if (err < 0)
+		goto out_err;
+
+	err = create_lockd_listener(serv, "tcp", nlm_tcpport);
+	if (err < 0)
+		goto out_err;
+
+	warned = 0;
+	return 0;
+
+out_err:
+	if (warned++ == 0)
 		printk(KERN_WARNING
-		       "lockd_up: makesock failed, error=%d\n", err);
+			"lockd_up: makesock failed, error=%d\n", err);
 	return err;
 }
 

commit d3fe5ea7cf815c037c90b1f1464ffc1ab5e8601b
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Dec 31 16:06:04 2008 -0500

    NLM: Refactor make_socks() function
    
    Clean up: extract common logic in NLM's make_socks() function
    into a helper.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 3e5f9f079110..cf3899aec375 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -204,6 +204,19 @@ lockd(void *vrqstp)
 	return 0;
 }
 
+static int create_lockd_listener(struct svc_serv *serv, char *name,
+				 unsigned short port)
+{
+	struct svc_xprt *xprt;
+
+	xprt = svc_find_xprt(serv, name, 0, 0);
+	if (xprt == NULL)
+		return svc_create_xprt(serv, name, port, SVC_SOCK_DEFAULTS);
+
+	svc_xprt_put(xprt);
+	return 0;
+}
+
 /*
  * Ensure there are active UDP and TCP listeners for lockd.
  *
@@ -217,23 +230,11 @@ lockd(void *vrqstp)
 static int make_socks(struct svc_serv *serv)
 {
 	static int warned;
-	struct svc_xprt *xprt;
 	int err = 0;
 
-	xprt = svc_find_xprt(serv, "udp", 0, 0);
-	if (!xprt)
-		err = svc_create_xprt(serv, "udp", nlm_udpport,
-				      SVC_SOCK_DEFAULTS);
-	else
-		svc_xprt_put(xprt);
-	if (err >= 0) {
-		xprt = svc_find_xprt(serv, "tcp", 0, 0);
-		if (!xprt)
-			err = svc_create_xprt(serv, "tcp", nlm_tcpport,
-					      SVC_SOCK_DEFAULTS);
-		else
-			svc_xprt_put(xprt);
-	}
+	err = create_lockd_listener(serv, "udp", nlm_udpport);
+	if (err >= 0)
+		err = create_lockd_listener(serv, "tcp", nlm_tcpport);
 	if (err >= 0) {
 		warned = 0;
 		err = 0;

commit b064ec038a6180b13e5f89b6a30b42cb5ce8febc
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Dec 11 17:56:59 2008 -0500

    lockd: Enable NLM use of AF_INET6
    
    If the kernel is configured to support IPv6 and the RPC server can register
    services via rpcbindv4, we are all set to enable IPv6 support for lockd.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aime Le Rouzic <aime.le-rouzic@bull.net>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 7ac7d72e3b5f..3e5f9f079110 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -52,6 +52,17 @@ static struct task_struct	*nlmsvc_task;
 static struct svc_rqst		*nlmsvc_rqst;
 unsigned long			nlmsvc_timeout;
 
+/*
+ * If the kernel has IPv6 support available, always listen for
+ * both AF_INET and AF_INET6 requests.
+ */
+#if (defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)) && \
+	defined(CONFIG_SUNRPC_REGISTER_V4)
+static const sa_family_t	nlmsvc_family = AF_INET6;
+#else	/* (CONFIG_IPV6 || CONFIG_IPV6_MODULE) && CONFIG_SUNRPC_REGISTER_V4 */
+static const sa_family_t	nlmsvc_family = AF_INET;
+#endif	/* (CONFIG_IPV6 || CONFIG_IPV6_MODULE) && CONFIG_SUNRPC_REGISTER_V4 */
+
 /*
  * These can be set at insmod time (useful for NFS as root filesystem),
  * and also changed through the sysctl interface.  -- Jamie Lokier, Aug 2003
@@ -256,7 +267,7 @@ int lockd_up(void)
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
 	error = -ENOMEM;
-	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, AF_INET, NULL);
+	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, nlmsvc_family, NULL);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		goto out;

commit b7ba597fb964dfa44284904b3b3d74d44b8e1c42
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Dec 11 17:56:29 2008 -0500

    NSM: Move nsm_use_hostnames to mon.c
    
    Clean up.
    
    Treat the nsm_use_hostnames global variable like nsm_local_state.
    Note that the default value of nsm_use_hostnames is still zero.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 0b13392931a6..7ac7d72e3b5f 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -59,7 +59,6 @@ unsigned long			nlmsvc_timeout;
 static unsigned long		nlm_grace_period;
 static unsigned long		nlm_timeout = LOCKD_DFLT_TIMEO;
 static int			nlm_udpport, nlm_tcpport;
-int				nsm_use_hostnames = 0;
 
 /* RLIM_NOFILE defaults to 1024. That seems like a reasonable default here. */
 static unsigned int		nlm_max_connections = 1024;

commit e6765b83977f07983c7a10e6bbb19d6c7bbfc3a4
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Dec 11 17:56:14 2008 -0500

    NSM: Remove include/linux/lockd/sm_inter.h
    
    Clean up: The include/linux/lockd/sm_inter.h header is nearly empty
    now.  Remove it.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index bc3c3cb62db5..0b13392931a6 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -35,7 +35,6 @@
 #include <linux/sunrpc/svcsock.h>
 #include <net/ip.h>
 #include <linux/lockd/lockd.h>
-#include <linux/lockd/sm_inter.h>
 #include <linux/nfs.h>
 
 #define NLMDBG_FACILITY		NLMDBG_SVC

commit c72a476b4b7ecadb80185de31236edb303c1a5d0
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Oct 20 11:51:58 2008 -0400

    lockd: set svc_serv->sv_maxconn to a more reasonable value (try #3)
    
    The default method for calculating the number of connections allowed
    per RPC service arbitrarily limits single-threaded services to 80
    connections. This is too low for services like lockd and artificially
    limits the number of TCP clients that it can support.
    
    Have lockd set a default sv_maxconn value to 1024 (which is the typical
    default value for RLIMIT_NOFILE. Also add a module parameter to allow an
    admin to set this to an arbitrary value.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 252d80163d02..bc3c3cb62db5 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -62,6 +62,9 @@ static unsigned long		nlm_timeout = LOCKD_DFLT_TIMEO;
 static int			nlm_udpport, nlm_tcpport;
 int				nsm_use_hostnames = 0;
 
+/* RLIM_NOFILE defaults to 1024. That seems like a reasonable default here. */
+static unsigned int		nlm_max_connections = 1024;
+
 /*
  * Constants needed for the sysctl interface.
  */
@@ -143,6 +146,9 @@ lockd(void *vrqstp)
 		long timeout = MAX_SCHEDULE_TIMEOUT;
 		RPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);
 
+		/* update sv_maxconn if it has changed */
+		rqstp->rq_server->sv_maxconn = nlm_max_connections;
+
 		if (signalled()) {
 			flush_signals(current);
 			if (nlmsvc_ops) {
@@ -276,6 +282,7 @@ int lockd_up(void)
 	}
 
 	svc_sock_update_bufs(serv);
+	serv->sv_maxconn = nlm_max_connections;
 
 	nlmsvc_task = kthread_run(lockd, nlmsvc_rqst, serv->sv_name);
 	if (IS_ERR(nlmsvc_task)) {
@@ -485,6 +492,7 @@ module_param_call(nlm_udpport, param_set_port, param_get_int,
 module_param_call(nlm_tcpport, param_set_port, param_get_int,
 		  &nlm_tcpport, 0644);
 module_param(nsm_use_hostnames, bool, 0644);
+module_param(nlm_max_connections, uint, 0644);
 
 /*
  * Initialising and terminating the module.

commit 2de59872a7842143f4507832e7c1f5123c47feb7
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Dec 23 15:21:33 2008 -0500

    LOCKD: Make lockd_up() and lockd_down() exported GPL-only
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 56b076736b56..252d80163d02 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -45,7 +45,7 @@
 static struct svc_program	nlmsvc_program;
 
 struct nlmsvc_binding *		nlmsvc_ops;
-EXPORT_SYMBOL(nlmsvc_ops);
+EXPORT_SYMBOL_GPL(nlmsvc_ops);
 
 static DEFINE_MUTEX(nlmsvc_mutex);
 static unsigned int		nlmsvc_users;
@@ -300,7 +300,7 @@ int lockd_up(void)
 	mutex_unlock(&nlmsvc_mutex);
 	return error;
 }
-EXPORT_SYMBOL(lockd_up);
+EXPORT_SYMBOL_GPL(lockd_up);
 
 /*
  * Decrement the user count and bring down lockd if we're the last.
@@ -329,7 +329,7 @@ lockd_down(void)
 out:
 	mutex_unlock(&nlmsvc_mutex);
 }
-EXPORT_SYMBOL(lockd_down);
+EXPORT_SYMBOL_GPL(lockd_down);
 
 #ifdef CONFIG_SYSCTL
 

commit 2c5e76158fcea6e3b9536a74efa7b5e2e846d374
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Nov 20 14:36:17 2008 -0600

    nfsd: clean up grace period on early exit
    
    If nfsd was shut down before the grace period ended, we could end up
    with a freed object still on grace_list.  Thanks to Jeff Moyer for
    reporting the resulting list corruption warnings.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Tested-by: Jeff Moyer <jmoyer@redhat.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index c631a83931ce..56b076736b56 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -181,6 +181,7 @@ lockd(void *vrqstp)
 	}
 	flush_signals(current);
 	cancel_delayed_work_sync(&grace_period_end);
+	locks_end_grace(&lockd_manager);
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
 	nlm_shutdown_hosts();

commit 26a414092353590ceaa5955bcb53f863d6ea7549
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Oct 3 17:15:30 2008 -0400

    NLM: Remove "proto" argument from lockd_up()
    
    Clean up: Now that lockd_up() starts listeners for both transports, the
    "proto" argument is no longer needed.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Neil Brown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 36396fc058c5..c631a83931ce 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -230,8 +230,7 @@ static int make_socks(struct svc_serv *serv)
 /*
  * Bring up the lockd process if it's not already up.
  */
-int
-lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
+int lockd_up(void)
 {
 	struct svc_serv *serv;
 	int		error = 0;

commit 8c3916f4bdf9c8388bd70d0b399b3a43daf2087a
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Oct 3 17:15:23 2008 -0400

    NLM: Always start both UDP and TCP listeners
    
    Commit 24e36663, which first appeared in 2.6.19, changed lockd so that
    the client side starts a UDP listener only if there is a UDP NFSv2/v3
    mount.  Its description notes:
    
        This... means that lockd will *not* listen on UDP if the only
        mounts are TCP mount (and nfsd hasn't started).
    
        The latter is the only one that concerns me at all - I don't know
        if this might be a problem with some servers.
    
    Unfortunately it is a problem for Linux itself.  The rpc.statd daemon
    on Linux uses UDP for contacting the local lockd, no matter which
    protocol is used for NFS mounts.  Without a local lockd UDP listener,
    NFSv2/v3 lock recovery from Linux NFS clients always fails.
    
    Revert parts of commit 24e36663 so lockd_up() always starts both
    listeners.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Neil Brown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index f013aed11533..36396fc058c5 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -189,25 +189,28 @@ lockd(void *vrqstp)
 }
 
 /*
- * Make any sockets that are needed but not present.
- * If nlm_udpport or nlm_tcpport were set as module
- * options, make those sockets unconditionally
+ * Ensure there are active UDP and TCP listeners for lockd.
+ *
+ * Even if we have only TCP NFS mounts and/or TCP NFSDs, some
+ * local services (such as rpc.statd) still require UDP, and
+ * some NFS servers do not yet support NLM over TCP.
+ *
+ * Returns zero if all listeners are available; otherwise a
+ * negative errno value is returned.
  */
-static int make_socks(struct svc_serv *serv, int proto)
+static int make_socks(struct svc_serv *serv)
 {
 	static int warned;
 	struct svc_xprt *xprt;
 	int err = 0;
 
-	if (proto == IPPROTO_UDP || nlm_udpport) {
-		xprt = svc_find_xprt(serv, "udp", 0, 0);
-		if (!xprt)
-			err = svc_create_xprt(serv, "udp", nlm_udpport,
-					      SVC_SOCK_DEFAULTS);
-		else
-			svc_xprt_put(xprt);
-	}
-	if (err >= 0 && (proto == IPPROTO_TCP || nlm_tcpport)) {
+	xprt = svc_find_xprt(serv, "udp", 0, 0);
+	if (!xprt)
+		err = svc_create_xprt(serv, "udp", nlm_udpport,
+				      SVC_SOCK_DEFAULTS);
+	else
+		svc_xprt_put(xprt);
+	if (err >= 0) {
 		xprt = svc_find_xprt(serv, "tcp", 0, 0);
 		if (!xprt)
 			err = svc_create_xprt(serv, "tcp", nlm_tcpport,
@@ -237,11 +240,8 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 	/*
 	 * Check whether we're already up and running.
 	 */
-	if (nlmsvc_rqst) {
-		if (proto)
-			error = make_socks(nlmsvc_rqst->rq_server, proto);
+	if (nlmsvc_rqst)
 		goto out;
-	}
 
 	/*
 	 * Sanity check: if there's no pid,
@@ -258,7 +258,8 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 		goto out;
 	}
 
-	if ((error = make_socks(serv, proto)) < 0)
+	error = make_socks(serv);
+	if (error < 0)
 		goto destroy_and_out;
 
 	/*

commit af558e33bedab672f5cfd3260bce7445e353fe21
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Sep 6 12:34:25 2007 -0400

    nfsd: common grace period control
    
    Rewrite grace period code to unify management of grace period across
    lockd and nfsd.  The current code has lockd and nfsd cooperate to
    compute a grace period which is satisfactory to them both, and then
    individually enforce it.  This creates a slight race condition, since
    the enforcement is not coordinated.  It's also more complicated than
    necessary.
    
    Here instead we have lockd and nfsd each inform common code when they
    enter the grace period, and when they're ready to leave the grace
    period, and allow normal locking only after both of them are ready to
    leave.
    
    We also expect the locks_start_grace()/locks_end_grace() interface here
    to be simpler to build on for future cluster/high-availability work,
    which may require (for example) putting individual filesystems into
    grace, or enforcing grace periods across multiple cluster nodes.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index f345ef7fb8ae..f013aed11533 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -51,7 +51,6 @@ static DEFINE_MUTEX(nlmsvc_mutex);
 static unsigned int		nlmsvc_users;
 static struct task_struct	*nlmsvc_task;
 static struct svc_rqst		*nlmsvc_rqst;
-int				nlmsvc_grace_period;
 unsigned long			nlmsvc_timeout;
 
 /*
@@ -85,30 +84,21 @@ static unsigned long get_lockd_grace_period(void)
 		return nlm_timeout * 5 * HZ;
 }
 
-unsigned long get_nfs_grace_period(void)
-{
-	unsigned long lockdgrace = get_lockd_grace_period();
-	unsigned long nfsdgrace = 0;
-
-	if (nlmsvc_ops)
-		nfsdgrace = nlmsvc_ops->get_grace_period();
-
-	return max(lockdgrace, nfsdgrace);
-}
-EXPORT_SYMBOL(get_nfs_grace_period);
+static struct lock_manager lockd_manager = {
+};
 
 static void grace_ender(struct work_struct *not_used)
 {
-	nlmsvc_grace_period = 0;
+	locks_end_grace(&lockd_manager);
 }
 
 static DECLARE_DELAYED_WORK(grace_period_end, grace_ender);
 
 static void set_grace_period(void)
 {
-	unsigned long grace_period = get_nfs_grace_period() + jiffies;
+	unsigned long grace_period = get_lockd_grace_period();
 
-	nlmsvc_grace_period = 1;
+	locks_start_grace(&lockd_manager);
 	cancel_delayed_work_sync(&grace_period_end);
 	schedule_delayed_work(&grace_period_end, grace_period);
 }

commit c8ab5f2a13fb41a878863c61a1e27d78f1844b5e
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Tue Mar 18 19:00:19 2008 -0400

    lockd: don't depend on lockd main loop to end grace
    
    End lockd's grace period using schedule_delayed_work() instead of a
    check on every pass through the main loop.
    
    After a later patch, we'll depend on lockd to end its grace period even
    if it's not currently handling requests; so it shouldn't depend on being
    woken up from the main loop to do so.
    
    Also, Nakano Hiroaki (who independently produced a similar patch)
    noticed that the current behavior is buggy in the face of jiffies
    wraparound:
    
            "lockd uses time_before() to determine whether the grace period
            has expired. This would seem to be enough to avoid timer
            wrap-around issues, but, unfortunately, that is not the case.
            The time_* family of comparison functions can be safely used to
            compare jiffies relatively close in time, but they stop working
            after approximately LONG_MAX/2 ticks. nfsd can suffer this
            problem because the time_before() comparison in lockd() is not
            performed until the first request comes in, which means that if
            there is no lockd traffic for more than LONG_MAX/2 ticks we are
            screwed.
    
            "The implication of this is that once time_before() starts
            misbehaving any attempt from a NFS client to execute fcntl()
            will be received with a NLM_LCK_DENIED_GRACE_PERIOD message for
            25 days (assuming HZ=1000). In other words, the 50 seconds grace
            period could turn into a grace period of 50 days or more.
    
            "Note: This bug was analyzed independently by Oda-san
            <oda@valinux.co.jp> and myself."
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Cc: Nakano Hiroaki <nakano.hiroaki@oss.ntt.co.jp>
    Cc: Itsuro Oda <oda@valinux.co.jp>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index bdc607bb25e9..f345ef7fb8ae 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -97,15 +97,20 @@ unsigned long get_nfs_grace_period(void)
 }
 EXPORT_SYMBOL(get_nfs_grace_period);
 
-static unsigned long set_grace_period(void)
+static void grace_ender(struct work_struct *not_used)
 {
-	nlmsvc_grace_period = 1;
-	return get_nfs_grace_period() + jiffies;
+	nlmsvc_grace_period = 0;
 }
 
-static inline void clear_grace_period(void)
+static DECLARE_DELAYED_WORK(grace_period_end, grace_ender);
+
+static void set_grace_period(void)
 {
-	nlmsvc_grace_period = 0;
+	unsigned long grace_period = get_nfs_grace_period() + jiffies;
+
+	nlmsvc_grace_period = 1;
+	cancel_delayed_work_sync(&grace_period_end);
+	schedule_delayed_work(&grace_period_end, grace_period);
 }
 
 /*
@@ -116,7 +121,6 @@ lockd(void *vrqstp)
 {
 	int		err = 0, preverr = 0;
 	struct svc_rqst *rqstp = vrqstp;
-	unsigned long grace_period_expire;
 
 	/* try_to_freeze() is called from svc_recv() */
 	set_freezable();
@@ -139,7 +143,7 @@ lockd(void *vrqstp)
 		nlm_timeout = LOCKD_DFLT_TIMEO;
 	nlmsvc_timeout = nlm_timeout * HZ;
 
-	grace_period_expire = set_grace_period();
+	set_grace_period();
 
 	/*
 	 * The main request loop. We don't terminate until the last
@@ -153,16 +157,13 @@ lockd(void *vrqstp)
 			flush_signals(current);
 			if (nlmsvc_ops) {
 				nlmsvc_invalidate_all();
-				grace_period_expire = set_grace_period();
+				set_grace_period();
 			}
 			continue;
 		}
 
 		timeout = nlmsvc_retry_blocked();
 
-		if (time_before(grace_period_expire, jiffies))
-			clear_grace_period();
-
 		/*
 		 * Find a socket with data available and call its
 		 * recvfrom routine.
@@ -189,6 +190,7 @@ lockd(void *vrqstp)
 		svc_process(rqstp);
 	}
 	flush_signals(current);
+	cancel_delayed_work_sync(&grace_period_end);
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
 	nlm_shutdown_hosts();

commit 8fafa90082ab18859d97627fc454edf12f7efbff
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Jan 24 11:11:34 2008 -0500

    locks: allow lockd to process blocked locks during grace period
    
    The check here is currently harmless but unnecessary, since, as the
    comment notes, there aren't any blocked-lock callbacks to process
    during the grace period anyway.
    
    And eventually we want to allow multiple grace periods that come and go
    for different filesystems over the course of the lifetime of lockd, at
    which point this check is just going to get in the way.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 1553fecc567d..bdc607bb25e9 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -158,15 +158,9 @@ lockd(void *vrqstp)
 			continue;
 		}
 
-		/*
-		 * Retry any blocked locks that have been notified by
-		 * the VFS. Don't do this during grace period.
-		 * (Theoretically, there shouldn't even be blocked locks
-		 * during grace period).
-		 */
-		if (!nlmsvc_grace_period) {
-			timeout = nlmsvc_retry_blocked();
-		} else if (time_before(grace_period_expire, jiffies))
+		timeout = nlmsvc_retry_blocked();
+
+		if (time_before(grace_period_expire, jiffies))
 			clear_grace_period();
 
 		/*

commit e851db5b05408b89b9a9429a66814b79fabee2a1
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Jun 30 18:45:30 2008 -0400

    SUNRPC: Add address family field to svc_serv data structure
    
    Introduce and initialize an address family field in the svc_serv structure.
    
    This field will determine what family to use for the service's listener
    sockets and what families are advertised via the local rpcbind daemon.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 5bd9bf0fa9df..1553fecc567d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -266,7 +266,7 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
 	error = -ENOMEM;
-	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, NULL);
+	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, AF_INET, NULL);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		goto out;

commit abd1ec4efd82ca06127bce833ad8a4bbec8a0dcb
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Jun 11 10:03:12 2008 -0400

    lockd: close potential race with rapid lockd_up/lockd_down cycle
    
    If lockd_down is called very rapidly after lockd_up returns, then
    there is a slim chance that lockd() will never be called. kthread()
    will return before calling the function, so we'll end up never
    actually calling the cleanup functions for the thread.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 2169af4d5455..5bd9bf0fa9df 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -50,7 +50,7 @@ EXPORT_SYMBOL(nlmsvc_ops);
 static DEFINE_MUTEX(nlmsvc_mutex);
 static unsigned int		nlmsvc_users;
 static struct task_struct	*nlmsvc_task;
-static struct svc_serv		*nlmsvc_serv;
+static struct svc_rqst		*nlmsvc_rqst;
 int				nlmsvc_grace_period;
 unsigned long			nlmsvc_timeout;
 
@@ -194,20 +194,11 @@ lockd(void *vrqstp)
 
 		svc_process(rqstp);
 	}
-
 	flush_signals(current);
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
 	nlm_shutdown_hosts();
-
 	unlock_kernel();
-
-	nlmsvc_task = NULL;
-	nlmsvc_serv = NULL;
-
-	/* Exit the RPC thread */
-	svc_exit_thread(rqstp);
-
 	return 0;
 }
 
@@ -254,16 +245,15 @@ int
 lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 {
 	struct svc_serv *serv;
-	struct svc_rqst *rqstp;
 	int		error = 0;
 
 	mutex_lock(&nlmsvc_mutex);
 	/*
 	 * Check whether we're already up and running.
 	 */
-	if (nlmsvc_serv) {
+	if (nlmsvc_rqst) {
 		if (proto)
-			error = make_socks(nlmsvc_serv, proto);
+			error = make_socks(nlmsvc_rqst->rq_server, proto);
 		goto out;
 	}
 
@@ -288,9 +278,10 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 	/*
 	 * Create the kernel thread and wait for it to start.
 	 */
-	rqstp = svc_prepare_thread(serv, &serv->sv_pools[0]);
-	if (IS_ERR(rqstp)) {
-		error = PTR_ERR(rqstp);
+	nlmsvc_rqst = svc_prepare_thread(serv, &serv->sv_pools[0]);
+	if (IS_ERR(nlmsvc_rqst)) {
+		error = PTR_ERR(nlmsvc_rqst);
+		nlmsvc_rqst = NULL;
 		printk(KERN_WARNING
 			"lockd_up: svc_rqst allocation failed, error=%d\n",
 			error);
@@ -298,16 +289,15 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 	}
 
 	svc_sock_update_bufs(serv);
-	nlmsvc_serv = rqstp->rq_server;
 
-	nlmsvc_task = kthread_run(lockd, rqstp, serv->sv_name);
+	nlmsvc_task = kthread_run(lockd, nlmsvc_rqst, serv->sv_name);
 	if (IS_ERR(nlmsvc_task)) {
 		error = PTR_ERR(nlmsvc_task);
+		svc_exit_thread(nlmsvc_rqst);
 		nlmsvc_task = NULL;
-		nlmsvc_serv = NULL;
+		nlmsvc_rqst = NULL;
 		printk(KERN_WARNING
 			"lockd_up: kthread_run failed, error=%d\n", error);
-		svc_exit_thread(rqstp);
 		goto destroy_and_out;
 	}
 
@@ -346,6 +336,9 @@ lockd_down(void)
 		BUG();
 	}
 	kthread_stop(nlmsvc_task);
+	svc_exit_thread(nlmsvc_rqst);
+	nlmsvc_task = NULL;
+	nlmsvc_rqst = NULL;
 out:
 	mutex_unlock(&nlmsvc_mutex);
 }

commit 563307b2fa15d687abc54bd980b9847ebf0e3231
Merge: 10c993a6b541 233607dbbc82
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 24 11:46:16 2008 -0700

    Merge git://git.linux-nfs.org/projects/trondmy/nfs-2.6
    
    * git://git.linux-nfs.org/projects/trondmy/nfs-2.6: (80 commits)
      SUNRPC: Invalidate the RPCSEC_GSS session if the server dropped the request
      make nfs_automount_list static
      NFS: remove duplicate flags assignment from nfs_validate_mount_data
      NFS - fix potential NULL pointer dereference v2
      SUNRPC: Don't change the RPCSEC_GSS context on a credential that is in use
      SUNRPC: Fix a race in gss_refresh_upcall()
      SUNRPC: Don't disconnect more than once if retransmitting NFSv4 requests
      SUNRPC: Remove the unused export of xprt_force_disconnect
      SUNRPC: remove XS_SENDMSG_RETRY
      SUNRPC: Protect creds against early garbage collection
      NFSv4: Attempt to use machine credentials in SETCLIENTID calls
      NFSv4: Reintroduce machine creds
      NFSv4: Don't use cred->cr_ops->cr_name in nfs4_proc_setclientid()
      nfs: fix printout of multiword bitfields
      nfs: return negative error value from nfs{,4}_stat_to_errno
      NLM/lockd: Ensure client locking calls use correct credentials
      NFS: Remove the buggy lock-if-signalled case from do_setlk()
      NLM/lockd: Fix a race when cancelling a blocking lock
      NLM/lockd: Ensure that nlmclnt_cancel() returns results of the CANCEL call
      NLM: Remove the signal masking in nlmclnt_proc/nlmclnt_cancel
      ...

commit f97c650dda24e48405399aa0676e90da52408515
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Apr 8 15:40:08 2008 -0400

    NLM: don't let lockd exit on unexpected svc_recv errors (try #2)
    
    When svc_recv returns an unexpected error, lockd will print a warning
    and exit. This problematic for several reasons. In particular, it will
    cause the reference counts for the thread to be wrong, and can lead to a
    potential BUG() call.
    
    Rather than exiting on error from svc_recv, have the thread do a 1s
    sleep and then retry the loop. This is unlikely to cause any harm, and
    if the error turns out to be something temporary then it may be able to
    recover.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 66b5c98c7ff5..cf977bbcf303 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -112,7 +112,7 @@ static inline void clear_grace_period(void)
 static int
 lockd(void *vrqstp)
 {
-	int		err = 0;
+	int		err = 0, preverr = 0;
 	struct svc_rqst *rqstp = vrqstp;
 	unsigned long grace_period_expire;
 
@@ -172,14 +172,20 @@ lockd(void *vrqstp)
 		 * recvfrom routine.
 		 */
 		err = svc_recv(rqstp, timeout);
-		if (err == -EAGAIN || err == -EINTR)
+		if (err == -EAGAIN || err == -EINTR) {
+			preverr = err;
 			continue;
+		}
 		if (err < 0) {
-			printk(KERN_WARNING
-			       "lockd: terminating on error %d\n",
-			       -err);
-			break;
+			if (err != preverr) {
+				printk(KERN_WARNING "%s: unexpected error "
+					"from svc_recv (%d)\n", __func__, err);
+				preverr = err;
+			}
+			schedule_timeout_interruptible(HZ);
+			continue;
 		}
+		preverr = err;
 
 		dprintk("lockd: request from %s\n",
 				svc_print_addr(rqstp, buf, sizeof(buf)));

commit d751a7cd0695554498f25d3026ca6710dbb3698f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Feb 7 16:34:55 2008 -0500

    NLM: Convert lockd to use kthreads
    
    Have lockd_up start lockd using kthread_run. With this change,
    lockd_down now blocks until lockd actually exits, so there's no longer
    need for the waitqueue code at the end of lockd_down. This also means
    that only one lockd can be running at a time which simplifies the code
    within lockd's main loop.
    
    This also adds a check for kthread_should_stop in the main loop of
    nlmsvc_retry_blocked and after that function returns. There's no sense
    continuing to retry blocks if lockd is coming down anyway.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 1ed8bd4de941..66b5c98c7ff5 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -25,6 +25,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/mutex.h>
+#include <linux/kthread.h>
 #include <linux/freezer.h>
 
 #include <linux/sunrpc/types.h>
@@ -48,14 +49,11 @@ EXPORT_SYMBOL(nlmsvc_ops);
 
 static DEFINE_MUTEX(nlmsvc_mutex);
 static unsigned int		nlmsvc_users;
-static pid_t			nlmsvc_pid;
+static struct task_struct	*nlmsvc_task;
 static struct svc_serv		*nlmsvc_serv;
 int				nlmsvc_grace_period;
 unsigned long			nlmsvc_timeout;
 
-static DECLARE_COMPLETION(lockd_start_done);
-static DECLARE_WAIT_QUEUE_HEAD(lockd_exit);
-
 /*
  * These can be set at insmod time (useful for NFS as root filesystem),
  * and also changed through the sysctl interface.  -- Jamie Lokier, Aug 2003
@@ -111,35 +109,30 @@ static inline void clear_grace_period(void)
 /*
  * This is the lockd kernel thread
  */
-static void
-lockd(struct svc_rqst *rqstp)
+static int
+lockd(void *vrqstp)
 {
 	int		err = 0;
+	struct svc_rqst *rqstp = vrqstp;
 	unsigned long grace_period_expire;
 
-	/* Lock module and set up kernel thread */
-	/* lockd_up is waiting for us to startup, so will
-	 * be holding a reference to this module, so it
-	 * is safe to just claim another reference
-	 */
-	__module_get(THIS_MODULE);
-	lock_kernel();
-
-	/*
-	 * Let our maker know we're running.
-	 */
-	nlmsvc_pid = current->pid;
-	nlmsvc_serv = rqstp->rq_server;
-	complete(&lockd_start_done);
-
-	daemonize("lockd");
+	/* try_to_freeze() is called from svc_recv() */
 	set_freezable();
 
-	/* Process request with signals blocked, but allow SIGKILL.  */
+	/* Allow SIGKILL to tell lockd to drop all of its locks */
 	allow_signal(SIGKILL);
 
 	dprintk("NFS locking service started (ver " LOCKD_VERSION ").\n");
 
+	/*
+	 * FIXME: it would be nice if lockd didn't spend its entire life
+	 * running under the BKL. At the very least, it would be good to
+	 * have someone clarify what it's intended to protect here. I've
+	 * seen some handwavy posts about posix locking needing to be
+	 * done under the BKL, but it's far from clear.
+	 */
+	lock_kernel();
+
 	if (!nlm_timeout)
 		nlm_timeout = LOCKD_DFLT_TIMEO;
 	nlmsvc_timeout = nlm_timeout * HZ;
@@ -148,10 +141,9 @@ lockd(struct svc_rqst *rqstp)
 
 	/*
 	 * The main request loop. We don't terminate until the last
-	 * NFS mount or NFS daemon has gone away, and we've been sent a
-	 * signal, or else another process has taken over our job.
+	 * NFS mount or NFS daemon has gone away.
 	 */
-	while ((nlmsvc_users || !signalled()) && nlmsvc_pid == current->pid) {
+	while (!kthread_should_stop()) {
 		long timeout = MAX_SCHEDULE_TIMEOUT;
 		RPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);
 
@@ -161,6 +153,7 @@ lockd(struct svc_rqst *rqstp)
 				nlmsvc_invalidate_all();
 				grace_period_expire = set_grace_period();
 			}
+			continue;
 		}
 
 		/*
@@ -195,28 +188,19 @@ lockd(struct svc_rqst *rqstp)
 	}
 
 	flush_signals(current);
+	if (nlmsvc_ops)
+		nlmsvc_invalidate_all();
+	nlm_shutdown_hosts();
 
-	/*
-	 * Check whether there's a new lockd process before
-	 * shutting down the hosts and clearing the slot.
-	 */
-	if (!nlmsvc_pid || current->pid == nlmsvc_pid) {
-		if (nlmsvc_ops)
-			nlmsvc_invalidate_all();
-		nlm_shutdown_hosts();
-		nlmsvc_pid = 0;
-		nlmsvc_serv = NULL;
-	} else
-		printk(KERN_DEBUG
-			"lockd: new process, skipping host shutdown\n");
-	wake_up(&lockd_exit);
+	unlock_kernel();
+
+	nlmsvc_task = NULL;
+	nlmsvc_serv = NULL;
 
 	/* Exit the RPC thread */
 	svc_exit_thread(rqstp);
 
-	/* Release module */
-	unlock_kernel();
-	module_put_and_exit(0);
+	return 0;
 }
 
 /*
@@ -261,14 +245,15 @@ static int make_socks(struct svc_serv *serv, int proto)
 int
 lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 {
-	struct svc_serv *	serv;
-	int			error = 0;
+	struct svc_serv *serv;
+	struct svc_rqst *rqstp;
+	int		error = 0;
 
 	mutex_lock(&nlmsvc_mutex);
 	/*
 	 * Check whether we're already up and running.
 	 */
-	if (nlmsvc_pid) {
+	if (nlmsvc_serv) {
 		if (proto)
 			error = make_socks(nlmsvc_serv, proto);
 		goto out;
@@ -295,13 +280,28 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 	/*
 	 * Create the kernel thread and wait for it to start.
 	 */
-	error = svc_create_thread(lockd, serv);
-	if (error) {
+	rqstp = svc_prepare_thread(serv, &serv->sv_pools[0]);
+	if (IS_ERR(rqstp)) {
+		error = PTR_ERR(rqstp);
 		printk(KERN_WARNING
-			"lockd_up: create thread failed, error=%d\n", error);
+			"lockd_up: svc_rqst allocation failed, error=%d\n",
+			error);
+		goto destroy_and_out;
+	}
+
+	svc_sock_update_bufs(serv);
+	nlmsvc_serv = rqstp->rq_server;
+
+	nlmsvc_task = kthread_run(lockd, rqstp, serv->sv_name);
+	if (IS_ERR(nlmsvc_task)) {
+		error = PTR_ERR(nlmsvc_task);
+		nlmsvc_task = NULL;
+		nlmsvc_serv = NULL;
+		printk(KERN_WARNING
+			"lockd_up: kthread_run failed, error=%d\n", error);
+		svc_exit_thread(rqstp);
 		goto destroy_and_out;
 	}
-	wait_for_completion(&lockd_start_done);
 
 	/*
 	 * Note: svc_serv structures have an initial use count of 1,
@@ -323,37 +323,21 @@ EXPORT_SYMBOL(lockd_up);
 void
 lockd_down(void)
 {
-	static int warned;
-
 	mutex_lock(&nlmsvc_mutex);
 	if (nlmsvc_users) {
 		if (--nlmsvc_users)
 			goto out;
-	} else
-		printk(KERN_WARNING "lockd_down: no users! pid=%d\n", nlmsvc_pid);
-
-	if (!nlmsvc_pid) {
-		if (warned++ == 0)
-			printk(KERN_WARNING "lockd_down: no lockd running.\n"); 
-		goto out;
+	} else {
+		printk(KERN_ERR "lockd_down: no users! task=%p\n",
+			nlmsvc_task);
+		BUG();
 	}
-	warned = 0;
 
-	kill_proc(nlmsvc_pid, SIGKILL, 1);
-	/*
-	 * Wait for the lockd process to exit, but since we're holding
-	 * the lockd semaphore, we can't wait around forever ...
-	 */
-	clear_thread_flag(TIF_SIGPENDING);
-	interruptible_sleep_on_timeout(&lockd_exit, HZ);
-	if (nlmsvc_pid) {
-		printk(KERN_WARNING 
-			"lockd_down: lockd failed to exit, clearing pid\n");
-		nlmsvc_pid = 0;
+	if (!nlmsvc_task) {
+		printk(KERN_ERR "lockd_down: no lockd running.\n");
+		BUG();
 	}
-	spin_lock_irq(&current->sighand->siglock);
-	recalc_sigpending();
-	spin_unlock_irq(&current->sighand->siglock);
+	kthread_stop(nlmsvc_task);
 out:
 	mutex_unlock(&nlmsvc_mutex);
 }

commit 90d5b18061656993410dfd57ddb88aa5a3f34563
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Mar 14 14:18:30 2008 -0400

    NLM: LOCKD fails to load if CONFIG_SYSCTL is not set
    
    Bruce Fields says:
    "By the way, we've got another config-related nit here:
    
            http://bugzilla.linux-nfs.org/show_bug.cgi?id=156
    
    You can build lockd without CONFIG_SYSCTL set, but then the module will
    fail to load."
    
    For now, disable the sysctl registration calls in lockd if CONFIG_SYSCTL
    is not enabled.  This allows the kernel to build properly if PROC_FS or
    SYSCTL is not enabled, but an NFS client is desired.
    
    In the long run, we would like to be able to build the kernel with an
    NFS client but without lockd.  This makes sense, for example, if you want
    an NFSv4-only NFS client, as NFSv4 doesn't use NLM at all.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 1ed8bd4de941..38c2f0b1dd7d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -74,7 +74,9 @@ static const unsigned long	nlm_timeout_min = 3;
 static const unsigned long	nlm_timeout_max = 20;
 static const int		nlm_port_min = 0, nlm_port_max = 65535;
 
+#ifdef CONFIG_SYSCTL
 static struct ctl_table_header * nlm_sysctl_table;
+#endif
 
 static unsigned long get_lockd_grace_period(void)
 {
@@ -359,6 +361,8 @@ lockd_down(void)
 }
 EXPORT_SYMBOL(lockd_down);
 
+#ifdef CONFIG_SYSCTL
+
 /*
  * Sysctl parameters (same as module parameters, different interface).
  */
@@ -443,6 +447,8 @@ static ctl_table nlm_sysctl_root[] = {
 	{ .ctl_name = 0 }
 };
 
+#endif	/* CONFIG_SYSCTL */
+
 /*
  * Module (and sysfs) parameters.
  */
@@ -516,15 +522,21 @@ module_param(nsm_use_hostnames, bool, 0644);
 
 static int __init init_nlm(void)
 {
+#ifdef CONFIG_SYSCTL
 	nlm_sysctl_table = register_sysctl_table(nlm_sysctl_root);
 	return nlm_sysctl_table ? 0 : -ENOMEM;
+#else
+	return 0;
+#endif
 }
 
 static void __exit exit_nlm(void)
 {
 	/* FIXME: delete all NLM clients */
 	nlm_shutdown_hosts();
+#ifdef CONFIG_SYSCTL
 	unregister_sysctl_table(nlm_sysctl_table);
+#endif
 }
 
 module_init(init_nlm);

commit 5216a8e70e25b01cbd2915cd0442fb96deb2c262
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Feb 21 10:57:45 2008 +0300

    Wrap buffers used for rpc debug printks into RPC_IFDEBUG
    
    Sorry for the noise, but here's the v3 of this compilation fix :)
    
    There are some places, which declare the char buf[...] on the stack
    to push it later into dprintk(). Since the dprintk sometimes (if the
    CONFIG_SYSCTL=n) becomes an empty do { } while (0) stub, these buffers
    cause gcc to produce appropriate warnings.
    
    Wrap these buffers with RPC_IFDEBUG macro, as Trond proposed, to
    compile them out when not needed.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Acked-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 08226464e563..1ed8bd4de941 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -153,7 +153,7 @@ lockd(struct svc_rqst *rqstp)
 	 */
 	while ((nlmsvc_users || !signalled()) && nlmsvc_pid == current->pid) {
 		long timeout = MAX_SCHEDULE_TIMEOUT;
-		char buf[RPC_MAX_ADDRBUFLEN];
+		RPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);
 
 		if (signalled()) {
 			flush_signals(current);

commit a217813f9067b785241cb7f31956e51d2071703a
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:08:35 2007 -0600

    knfsd: Support adding transports by writing portlist file
    
    Update the write handler for the portlist file to allow creating new
    listening endpoints on a transport. The general form of the string is:
    
    <transport_name><space><port number>
    
    For example:
    
    echo "tcp 2049" > /proc/fs/nfsd/portlist
    
    This is intended to support the creation of a listening endpoint for
    RDMA transports without adding #ifdef code to the nfssvc.c file.
    
    Transports can also be removed as follows:
    
    '-'<transport_name><space><port number>
    
    For example:
    
    echo "-tcp 2049" > /proc/fs/nfsd/portlist
    
    Attempting to add a listener with an invalid transport string results
    in EPROTONOSUPPORT and a perror string of "Protocol not supported".
    
    Attempting to remove an non-existent listener (.e.g. bad proto or port)
    results in ENOTCONN and a perror string of
    "Transport endpoint is not connected"
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 470af0138bb5..08226464e563 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -227,17 +227,25 @@ lockd(struct svc_rqst *rqstp)
 static int make_socks(struct svc_serv *serv, int proto)
 {
 	static int warned;
+	struct svc_xprt *xprt;
 	int err = 0;
 
-	if (proto == IPPROTO_UDP || nlm_udpport)
-		if (!svc_find_xprt(serv, "udp", 0, 0))
+	if (proto == IPPROTO_UDP || nlm_udpport) {
+		xprt = svc_find_xprt(serv, "udp", 0, 0);
+		if (!xprt)
 			err = svc_create_xprt(serv, "udp", nlm_udpport,
 					      SVC_SOCK_DEFAULTS);
-	if (err >= 0 && (proto == IPPROTO_TCP || nlm_tcpport))
-		if (!svc_find_xprt(serv, "tcp", 0, 0))
+		else
+			svc_xprt_put(xprt);
+	}
+	if (err >= 0 && (proto == IPPROTO_TCP || nlm_tcpport)) {
+		xprt = svc_find_xprt(serv, "tcp", 0, 0);
+		if (!xprt)
 			err = svc_create_xprt(serv, "tcp", nlm_tcpport,
 					      SVC_SOCK_DEFAULTS);
-
+		else
+			svc_xprt_put(xprt);
+	}
 	if (err >= 0) {
 		warned = 0;
 		err = 0;

commit 7fcb98d58cb4d18af6386f71025fc5192f25fbca
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:08:33 2007 -0600

    svc: Add svc API that queries for a transport instance
    
    Add a new svc function that allows a service to query whether a
    transport instance has already been created. This is used in lockd
    to determine whether or not a transport needs to be created when
    a lockd instance is brought up.
    
    Specifying 0 for the address family or port is effectively a wild-card,
    and will result in matching the first transport in the service's list
    that has a matching class name.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index a8e79a907202..470af0138bb5 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -219,18 +219,6 @@ lockd(struct svc_rqst *rqstp)
 	module_put_and_exit(0);
 }
 
-static int find_xprt(struct svc_serv *serv, char *proto)
-{
-	struct svc_xprt *xprt;
-	int found = 0;
-	list_for_each_entry(xprt, &serv->sv_permsocks, xpt_list)
-		if (strcmp(xprt->xpt_class->xcl_name, proto) == 0) {
-			found = 1;
-			break;
-		}
-	return found;
-}
-
 /*
  * Make any sockets that are needed but not present.
  * If nlm_udpport or nlm_tcpport were set as module
@@ -242,11 +230,11 @@ static int make_socks(struct svc_serv *serv, int proto)
 	int err = 0;
 
 	if (proto == IPPROTO_UDP || nlm_udpport)
-		if (!find_xprt(serv, "udp"))
+		if (!svc_find_xprt(serv, "udp", 0, 0))
 			err = svc_create_xprt(serv, "udp", nlm_udpport,
 					      SVC_SOCK_DEFAULTS);
 	if (err >= 0 && (proto == IPPROTO_TCP || nlm_tcpport))
-		if (!find_xprt(serv, "tcp"))
+		if (!svc_find_xprt(serv, "tcp", 0, 0))
 			err = svc_create_xprt(serv, "tcp", nlm_tcpport,
 					      SVC_SOCK_DEFAULTS);
 

commit 7a18208383ab3f3ce4a1f4e0536acc9372523d81
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:53 2007 -0600

    svc: Make close transport independent
    
    Move sk_list and sk_ready to svc_xprt. This involves close because these
    lists are walked by svcs when closing all their transports. So I combined
    the moving of these lists to svc_xprt with making close transport independent.
    
    The svc_force_sock_close has been changed to svc_close_all and takes a list
    as an argument. This removes some svc internals knowledge from the svcs.
    
    This code races with module removal and transport addition.
    
    Thanks to Simon Holm Thgersen for a compile fix.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Cc: Simon Holm Thgersen <odie@cs.aau.dk>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 868691535115..a8e79a907202 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -221,10 +221,10 @@ lockd(struct svc_rqst *rqstp)
 
 static int find_xprt(struct svc_serv *serv, char *proto)
 {
-	struct svc_sock *svsk;
+	struct svc_xprt *xprt;
 	int found = 0;
-	list_for_each_entry(svsk, &serv->sv_permsocks, sk_list)
-		if (strcmp(svsk->sk_xprt.xpt_class->xcl_name, proto) == 0) {
+	list_for_each_entry(xprt, &serv->sv_permsocks, xpt_list)
+		if (strcmp(xprt->xpt_class->xcl_name, proto) == 0) {
 			found = 1;
 			break;
 		}

commit d7c9f1ed972b4a468dd24a2457721704dfe9ca70
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:44 2007 -0600

    svc: Change services to use new svc_create_xprt service
    
    Modify the various kernel RPC svcs to use the svc_create_xprt service.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 82e2192a0d5c..868691535115 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -219,13 +219,12 @@ lockd(struct svc_rqst *rqstp)
 	module_put_and_exit(0);
 }
 
-
-static int find_socket(struct svc_serv *serv, int proto)
+static int find_xprt(struct svc_serv *serv, char *proto)
 {
 	struct svc_sock *svsk;
 	int found = 0;
 	list_for_each_entry(svsk, &serv->sv_permsocks, sk_list)
-		if (svsk->sk_sk->sk_protocol == proto) {
+		if (strcmp(svsk->sk_xprt.xpt_class->xcl_name, proto) == 0) {
 			found = 1;
 			break;
 		}
@@ -243,13 +242,13 @@ static int make_socks(struct svc_serv *serv, int proto)
 	int err = 0;
 
 	if (proto == IPPROTO_UDP || nlm_udpport)
-		if (!find_socket(serv, IPPROTO_UDP))
-			err = svc_makesock(serv, IPPROTO_UDP, nlm_udpport,
-						SVC_SOCK_DEFAULTS);
+		if (!find_xprt(serv, "udp"))
+			err = svc_create_xprt(serv, "udp", nlm_udpport,
+					      SVC_SOCK_DEFAULTS);
 	if (err >= 0 && (proto == IPPROTO_TCP || nlm_tcpport))
-		if (!find_socket(serv, IPPROTO_TCP))
-			err = svc_makesock(serv, IPPROTO_TCP, nlm_tcpport,
-						SVC_SOCK_DEFAULTS);
+		if (!find_xprt(serv, "tcp"))
+			err = svc_create_xprt(serv, "tcp", nlm_tcpport,
+					      SVC_SOCK_DEFAULTS);
 
 	if (err >= 0) {
 		warned = 0;

commit 9a8db97e7756119689c93c431e8b8324080f5625
Author: Marc Eshel <eshel@almaden.ibm.com>
Date:   Tue Jul 17 04:04:35 2007 -0700

    knfsd: lockd: nfsd4: use same grace period for lockd and nfsd4
    
    Both lockd and (in the nfsv4 case) nfsd enforce a "grace period" after reboot,
    during which clients may reclaim locks from the previous server instance, but
    may not acquire new locks.
    
    Currently the lockd and nfsd enforce grace periods of different lengths.  This
    may cause problems when we reboot a server with both v2/v3 and v4 clients.
    For example, if the lockd grace period is shorter (as is likely the case),
    then a v3 client might acquire a new lock that conflicts with a lock already
    held (but not yet reclaimed) by a v4 client.
    
    This patch calculates a lease time that lockd and nfsd can both use.
    
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 9fcdef50aad6..82e2192a0d5c 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -76,18 +76,31 @@ static const int		nlm_port_min = 0, nlm_port_max = 65535;
 
 static struct ctl_table_header * nlm_sysctl_table;
 
-static unsigned long set_grace_period(void)
+static unsigned long get_lockd_grace_period(void)
 {
-	unsigned long grace_period;
-
 	/* Note: nlm_timeout should always be nonzero */
 	if (nlm_grace_period)
-		grace_period = ((nlm_grace_period + nlm_timeout - 1)
-				/ nlm_timeout) * nlm_timeout * HZ;
+		return roundup(nlm_grace_period, nlm_timeout) * HZ;
 	else
-		grace_period = nlm_timeout * 5 * HZ;
+		return nlm_timeout * 5 * HZ;
+}
+
+unsigned long get_nfs_grace_period(void)
+{
+	unsigned long lockdgrace = get_lockd_grace_period();
+	unsigned long nfsdgrace = 0;
+
+	if (nlmsvc_ops)
+		nfsdgrace = nlmsvc_ops->get_grace_period();
+
+	return max(lockdgrace, nfsdgrace);
+}
+EXPORT_SYMBOL(get_nfs_grace_period);
+
+static unsigned long set_grace_period(void)
+{
 	nlmsvc_grace_period = 1;
-	return grace_period + jiffies;
+	return get_nfs_grace_period() + jiffies;
 }
 
 static inline void clear_grace_period(void)

commit 831441862956fffa17b9801db37e6ea1650b0f69
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jul 17 04:03:35 2007 -0700

    Freezer: make kernel threads nonfreezable by default
    
    Currently, the freezer treats all tasks as freezable, except for the kernel
    threads that explicitly set the PF_NOFREEZE flag for themselves.  This
    approach is problematic, since it requires every kernel thread to either
    set PF_NOFREEZE explicitly, or call try_to_freeze(), even if it doesn't
    care for the freezing of tasks at all.
    
    It seems better to only require the kernel threads that want to or need to
    be frozen to use some freezer-related code and to remove any
    freezer-related code from the other (nonfreezable) kernel threads, which is
    done in this patch.
    
    The patch causes all kernel threads to be nonfreezable by default (ie.  to
    have PF_NOFREEZE set by default) and introduces the set_freezable()
    function that should be called by the freezable kernel threads in order to
    unset PF_NOFREEZE.  It also makes all of the currently freezable kernel
    threads call set_freezable(), so it shouldn't cause any (intentional)
    change of behaviour to appear.  Additionally, it updates documentation to
    describe the freezing of tasks more accurately.
    
    [akpm@linux-foundation.org: build fixes]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 26809325469c..9fcdef50aad6 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -25,6 +25,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/mutex.h>
+#include <linux/freezer.h>
 
 #include <linux/sunrpc/types.h>
 #include <linux/sunrpc/stats.h>
@@ -119,6 +120,7 @@ lockd(struct svc_rqst *rqstp)
 	complete(&lockd_start_done);
 
 	daemonize("lockd");
+	set_freezable();
 
 	/* Process request with signals blocked, but allow SIGKILL.  */
 	allow_signal(SIGKILL);

commit f61534dfd38f895b203e2aadaba04f21a992ca8c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Jun 14 17:31:58 2007 -0400

    SUNRPC: Remove redundant calls to rpciod_up()/rpciod_down()
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 126b1bf02c0e..26809325469c 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -123,9 +123,6 @@ lockd(struct svc_rqst *rqstp)
 	/* Process request with signals blocked, but allow SIGKILL.  */
 	allow_signal(SIGKILL);
 
-	/* kick rpciod */
-	rpciod_up();
-
 	dprintk("NFS locking service started (ver " LOCKD_VERSION ").\n");
 
 	if (!nlm_timeout)
@@ -202,9 +199,6 @@ lockd(struct svc_rqst *rqstp)
 	/* Exit the RPC thread */
 	svc_exit_thread(rqstp);
 
-	/* release rpciod */
-	rpciod_down();
-
 	/* Release module */
 	unlock_kernel();
 	module_put_and_exit(0);

commit 405ae7d381302468ecc803f2148a2ae40a04c999
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Sat Feb 17 19:13:42 2007 +0100

    Replace remaining references to "driverfs" with "sysfs".
    
    Globally, s/driverfs/sysfs/g.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 50cb8daba4e5..126b1bf02c0e 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -440,7 +440,7 @@ static ctl_table nlm_sysctl_root[] = {
 };
 
 /*
- * Module (and driverfs) parameters.
+ * Module (and sysfs) parameters.
  */
 
 #define param_set_min_max(name, type, which_strtol, min, max)		\

commit 0b4d414714f0d2f922d39424b0c5c82ad900a381
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 14 00:34:09 2007 -0800

    [PATCH] sysctl: remove insert_at_head from register_sysctl
    
    The semantic effect of insert_at_head is that it would allow new registered
    sysctl entries to override existing sysctl entries of the same name.  Which is
    pain for caching and the proc interface never implemented.
    
    I have done an audit and discovered that none of the current users of
    register_sysctl care as (excpet for directories) they do not register
    duplicate sysctl entries.
    
    So this patch simply removes the support for overriding existing entries in
    the sys_sysctl interface since no one uses it or cares and it makes future
    enhancments harder.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Howells <dhowells@redhat.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: "John W. Linville" <linville@tuxdriver.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Jan Kara <jack@ucw.cz>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: David Chinner <dgc@sgi.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 80fcacc1acf9..50cb8daba4e5 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -512,7 +512,7 @@ module_param(nsm_use_hostnames, bool, 0644);
 
 static int __init init_nlm(void)
 {
-	nlm_sysctl_table = register_sysctl_table(nlm_sysctl_root, 0);
+	nlm_sysctl_table = register_sysctl_table(nlm_sysctl_root);
 	return nlm_sysctl_table ? 0 : -ENOMEM;
 }
 

commit ad06e4bd62351bc569cca0f25d68c58dbd298146
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Feb 12 00:53:32 2007 -0800

    [PATCH] knfsd: SUNRPC: Add a function to format the address in an svc_rqst for printing
    
    There are loads of places where the RPC server assumes that the rq_addr fields
    contains an IPv4 address.  Top among these are error and debugging messages
    that display the server's IP address.
    
    Let's refactor the address printing into a separate function that's smart
    enough to figure out the difference between IPv4 and IPv6 addresses.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aurelien Charbon <aurelien.charbon@ext.bull.net>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 2c3d5ac4a3b6..80fcacc1acf9 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -141,6 +141,7 @@ lockd(struct svc_rqst *rqstp)
 	 */
 	while ((nlmsvc_users || !signalled()) && nlmsvc_pid == current->pid) {
 		long timeout = MAX_SCHEDULE_TIMEOUT;
+		char buf[RPC_MAX_ADDRBUFLEN];
 
 		if (signalled()) {
 			flush_signals(current);
@@ -175,11 +176,10 @@ lockd(struct svc_rqst *rqstp)
 			break;
 		}
 
-		dprintk("lockd: request from %08x\n",
-			(unsigned)ntohl(rqstp->rq_addr.sin_addr.s_addr));
+		dprintk("lockd: request from %s\n",
+				svc_print_addr(rqstp, buf, sizeof(buf)));
 
 		svc_process(rqstp);
-
 	}
 
 	flush_signals(current);

commit 482fb94e1b0c2efe8258334aa2a68d4f4a91de9c
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Feb 12 00:53:29 2007 -0800

    [PATCH] knfsd: SUNRPC: allow creating an RPC service without registering with portmapper
    
    Sometimes we need to create an RPC service but not register it with the local
    portmapper.  NFSv4 delegation callback, for example.
    
    Change the svc_makesock() API to allow optionally creating temporary or
    permanent sockets, optionally registering with the local portmapper, and make
    it return the ephemeral port of the new socket.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aurelien Charbon <aurelien.charbon@ext.bull.net>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 8ca18085e68d..2c3d5ac4a3b6 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -223,23 +223,29 @@ static int find_socket(struct svc_serv *serv, int proto)
 	return found;
 }
 
+/*
+ * Make any sockets that are needed but not present.
+ * If nlm_udpport or nlm_tcpport were set as module
+ * options, make those sockets unconditionally
+ */
 static int make_socks(struct svc_serv *serv, int proto)
 {
-	/* Make any sockets that are needed but not present.
-	 * If nlm_udpport or nlm_tcpport were set as module
-	 * options, make those sockets unconditionally
-	 */
-	static int		warned;
+	static int warned;
 	int err = 0;
+
 	if (proto == IPPROTO_UDP || nlm_udpport)
 		if (!find_socket(serv, IPPROTO_UDP))
-			err = svc_makesock(serv, IPPROTO_UDP, nlm_udpport);
-	if (err == 0 && (proto == IPPROTO_TCP || nlm_tcpport))
+			err = svc_makesock(serv, IPPROTO_UDP, nlm_udpport,
+						SVC_SOCK_DEFAULTS);
+	if (err >= 0 && (proto == IPPROTO_TCP || nlm_tcpport))
 		if (!find_socket(serv, IPPROTO_TCP))
-			err= svc_makesock(serv, IPPROTO_TCP, nlm_tcpport);
-	if (!err)
+			err = svc_makesock(serv, IPPROTO_TCP, nlm_tcpport,
+						SVC_SOCK_DEFAULTS);
+
+	if (err >= 0) {
 		warned = 0;
-	else if (warned++ == 0)
+		err = 0;
+	} else if (warned++ == 0)
 		printk(KERN_WARNING
 		       "lockd_up: makesock failed, error=%d\n", err);
 	return err;

commit 7cc13edc139108bb527b692f0548dce6bc648572
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Nov 5 23:52:13 2006 -0800

    [PATCH] sysctl: implement CTL_UNNUMBERED
    
    This patch takes the CTL_UNNUMBERD concept from NFS and makes it available to
    all new sysctl users.
    
    At the same time the sysctl binary interface maintenance documentation is
    updated to mention and to describe what is needed to successfully maintain the
    sysctl binary interface.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 634139232aaf..8ca18085e68d 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -353,9 +353,6 @@ EXPORT_SYMBOL(lockd_down);
  * Sysctl parameters (same as module parameters, different interface).
  */
 
-/* Something that isn't CTL_ANY, CTL_NONE or a value that may clash. */
-#define CTL_UNNUMBERED		-2
-
 static ctl_table nlm_sysctls[] = {
 	{
 		.ctl_name	= CTL_UNNUMBERED,

commit 460f5cac1e24e947509b6112c99c5bc9ff687b45
Author: Olaf Kirch <okir@suse.de>
Date:   Wed Oct 4 02:16:03 2006 -0700

    [PATCH] knfsd: export nsm_local_state to user space via sysctl
    
    Every NLM call includes the client's NSM state.  Currently, the Linux client
    always reports 0 - which seems not to cause any problems, but is not what the
    protocol says.
    
    This patch exposes the kernel's internal variable to user space via a sysctl,
    which can be set at system boot time by statd.
    
    Signed-off-by: Olaf Kirch <okir@suse.de>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index a3b7602cd383..634139232aaf 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -33,6 +33,7 @@
 #include <linux/sunrpc/svcsock.h>
 #include <net/ip.h>
 #include <linux/lockd/lockd.h>
+#include <linux/lockd/sm_inter.h>
 #include <linux/nfs.h>
 
 #define NLMDBG_FACILITY		NLMDBG_SVC
@@ -404,6 +405,14 @@ static ctl_table nlm_sysctls[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nsm_local_state",
+		.data		= &nsm_local_state,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 	{ .ctl_name = 0 }
 };
 

commit abd1f50094cad9dff6d68ada98b495549f52fc30
Author: Olaf Kirch <okir@suse.de>
Date:   Wed Oct 4 02:16:01 2006 -0700

    [PATCH] knfsd: lockd: optionally use hostnames for identifying peers
    
    This patch adds the nsm_use_hostnames sysctl and module param.  If set, lockd
    will use the client's name (as given in the NLM arguments) to find the NSM
    handle.  This makes recovery work when the NFS peer is multi-homed, and the
    reboot notification arrives from a different IP than the original lock calls.
    
    Signed-off-by: Olaf Kirch <okir@suse.de>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 3cc369e5693f..a3b7602cd383 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -61,6 +61,7 @@ static DECLARE_WAIT_QUEUE_HEAD(lockd_exit);
 static unsigned long		nlm_grace_period;
 static unsigned long		nlm_timeout = LOCKD_DFLT_TIMEO;
 static int			nlm_udpport, nlm_tcpport;
+int				nsm_use_hostnames = 0;
 
 /*
  * Constants needed for the sysctl interface.
@@ -395,6 +396,14 @@ static ctl_table nlm_sysctls[] = {
 		.extra1		= (int *) &nlm_port_min,
 		.extra2		= (int *) &nlm_port_max,
 	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nsm_use_hostnames",
+		.data		= &nsm_use_hostnames,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 	{ .ctl_name = 0 }
 };
 
@@ -483,6 +492,7 @@ module_param_call(nlm_udpport, param_set_port, param_get_int,
 		  &nlm_udpport, 0644);
 module_param_call(nlm_tcpport, param_set_port, param_get_int,
 		  &nlm_tcpport, 0644);
+module_param(nsm_use_hostnames, bool, 0644);
 
 /*
  * Initialising and terminating the module.

commit 4a3ae42dc312dbdffee803efaf393421b79f997a
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 2 02:17:53 2006 -0700

    [PATCH] knfsd: Correctly handle error condition from lockd_up
    
    If lockd_up fails - what should we expect?  Do we have to later call
    lockd_down?
    
    Well the nfs client thinks "no", the nfs server thinks "yes".  lockd thinks
    "yes".
    
    The only answer that really makes sense is "no" !!
    
    So:
      Make lockd_up only increment  nlmsvc_users on success.
      Make nfsd handle errors from lockd_up properly.
      Make sure lockd_up(0) never fails when lockd is running
        so that the 'reclaimer' call to lockd_up doesn't need to
        be error checked.
    
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 448768b52913..3cc369e5693f 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -253,16 +253,12 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 	int			error = 0;
 
 	mutex_lock(&nlmsvc_mutex);
-	/*
-	 * Unconditionally increment the user count ... this is
-	 * the number of clients who _want_ a lockd process.
-	 */
-	nlmsvc_users++; 
 	/*
 	 * Check whether we're already up and running.
 	 */
 	if (nlmsvc_pid) {
-		error = make_socks(nlmsvc_serv, proto);
+		if (proto)
+			error = make_socks(nlmsvc_serv, proto);
 		goto out;
 	}
 
@@ -270,7 +266,7 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 	 * Sanity check: if there's no pid,
 	 * we should be the first user ...
 	 */
-	if (nlmsvc_users > 1)
+	if (nlmsvc_users)
 		printk(KERN_WARNING
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
@@ -302,6 +298,8 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 destroy_and_out:
 	svc_destroy(serv);
 out:
+	if (!error)
+		nlmsvc_users++;
 	mutex_unlock(&nlmsvc_mutex);
 	return error;
 }

commit 7dcf91ec6698fe8564ad91bbe42740aacaa0d9ee
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 2 02:17:52 2006 -0700

    [PATCH] knfsd: Move makesock failed warning into make_socks.
    
    Thus it is printed for any path that leads to failure (make_socks is called
    from two places).
    
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index f0791cff45ac..448768b52913 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -227,15 +227,19 @@ static int make_socks(struct svc_serv *serv, int proto)
 	 * If nlm_udpport or nlm_tcpport were set as module
 	 * options, make those sockets unconditionally
 	 */
+	static int		warned;
 	int err = 0;
 	if (proto == IPPROTO_UDP || nlm_udpport)
 		if (!find_socket(serv, IPPROTO_UDP))
 			err = svc_makesock(serv, IPPROTO_UDP, nlm_udpport);
-	if (err)
-		return err;
-	if (proto == IPPROTO_TCP || nlm_tcpport)
+	if (err == 0 && (proto == IPPROTO_TCP || nlm_tcpport))
 		if (!find_socket(serv, IPPROTO_TCP))
 			err= svc_makesock(serv, IPPROTO_TCP, nlm_tcpport);
+	if (!err)
+		warned = 0;
+	else if (warned++ == 0)
+		printk(KERN_WARNING
+		       "lockd_up: makesock failed, error=%d\n", err);
 	return err;
 }
 
@@ -245,7 +249,6 @@ static int make_socks(struct svc_serv *serv, int proto)
 int
 lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 {
-	static int		warned;
 	struct svc_serv *	serv;
 	int			error = 0;
 
@@ -278,13 +281,8 @@ lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 		goto out;
 	}
 
-	if ((error = make_socks(serv, proto)) < 0) {
-		if (warned++ == 0) 
-			printk(KERN_WARNING
-				"lockd_up: makesock failed, error=%d\n", error);
+	if ((error = make_socks(serv, proto)) < 0)
 		goto destroy_and_out;
-	} 
-	warned = 0;
 
 	/*
 	 * Create the kernel thread and wait for it to start.

commit 6fb2b47fa16c81317ec282248e6cff521cca31c2
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 2 02:17:50 2006 -0700

    [PATCH] knfsd: Drop 'serv' option to svc_recv and svc_process
    
    It isn't needed as it is available in rqstp->rq_server, and dropping it allows
    some local vars to be dropped.
    
    [akpm@osdl.org: build fix]
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 8d19de6a14dc..f0791cff45ac 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -98,7 +98,6 @@ static inline void clear_grace_period(void)
 static void
 lockd(struct svc_rqst *rqstp)
 {
-	struct svc_serv	*serv = rqstp->rq_server;
 	int		err = 0;
 	unsigned long grace_period_expire;
 
@@ -114,7 +113,7 @@ lockd(struct svc_rqst *rqstp)
 	 * Let our maker know we're running.
 	 */
 	nlmsvc_pid = current->pid;
-	nlmsvc_serv = serv;
+	nlmsvc_serv = rqstp->rq_server;
 	complete(&lockd_start_done);
 
 	daemonize("lockd");
@@ -164,7 +163,7 @@ lockd(struct svc_rqst *rqstp)
 		 * Find a socket with data available and call its
 		 * recvfrom routine.
 		 */
-		err = svc_recv(serv, rqstp, timeout);
+		err = svc_recv(rqstp, timeout);
 		if (err == -EAGAIN || err == -EINTR)
 			continue;
 		if (err < 0) {
@@ -177,7 +176,7 @@ lockd(struct svc_rqst *rqstp)
 		dprintk("lockd: request from %08x\n",
 			(unsigned)ntohl(rqstp->rq_addr.sin_addr.s_addr));
 
-		svc_process(serv, rqstp);
+		svc_process(rqstp);
 
 	}
 

commit 24e36663c375df577d2dcae437713481ffd6850c
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 2 02:17:45 2006 -0700

    [PATCH] knfsd: be more selective in which sockets lockd listens on
    
    Currently lockd listens on UDP always, and TCP if CONFIG_NFSD_TCP is set.
    
    However as lockd performs services of the client as well, this is a problem.
    If CONFIG_NfSD_TCP is not set, and a tcp mount is used, the server will not be
    able to call back to lockd.
    
    So:
     - add an option to lockd_up saying which protocol is needed
     - Always open sockets for which an explicit port was given, otherwise
       only open a socket of the type required
     - Change nfsd to do one lockd_up per socket rather than one per thread.
    
    This
     - removes the dependancy on CONFIG_NFSD_TCP
     - means that lockd may open sockets other than at startup
     - means that lockd will *not* listen on UDP if the only
       mounts are TCP mount (and nfsd hasn't started).
    
    The latter is the only one that concerns me at all - I don't know if this
    might be a problem with some servers.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 13feba45030e..8d19de6a14dc 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -31,6 +31,7 @@
 #include <linux/sunrpc/clnt.h>
 #include <linux/sunrpc/svc.h>
 #include <linux/sunrpc/svcsock.h>
+#include <net/ip.h>
 #include <linux/lockd/lockd.h>
 #include <linux/nfs.h>
 
@@ -46,6 +47,7 @@ EXPORT_SYMBOL(nlmsvc_ops);
 static DEFINE_MUTEX(nlmsvc_mutex);
 static unsigned int		nlmsvc_users;
 static pid_t			nlmsvc_pid;
+static struct svc_serv		*nlmsvc_serv;
 int				nlmsvc_grace_period;
 unsigned long			nlmsvc_timeout;
 
@@ -112,6 +114,7 @@ lockd(struct svc_rqst *rqstp)
 	 * Let our maker know we're running.
 	 */
 	nlmsvc_pid = current->pid;
+	nlmsvc_serv = serv;
 	complete(&lockd_start_done);
 
 	daemonize("lockd");
@@ -189,6 +192,7 @@ lockd(struct svc_rqst *rqstp)
 			nlmsvc_invalidate_all();
 		nlm_shutdown_hosts();
 		nlmsvc_pid = 0;
+		nlmsvc_serv = NULL;
 	} else
 		printk(KERN_DEBUG
 			"lockd: new process, skipping host shutdown\n");
@@ -205,11 +209,42 @@ lockd(struct svc_rqst *rqstp)
 	module_put_and_exit(0);
 }
 
+
+static int find_socket(struct svc_serv *serv, int proto)
+{
+	struct svc_sock *svsk;
+	int found = 0;
+	list_for_each_entry(svsk, &serv->sv_permsocks, sk_list)
+		if (svsk->sk_sk->sk_protocol == proto) {
+			found = 1;
+			break;
+		}
+	return found;
+}
+
+static int make_socks(struct svc_serv *serv, int proto)
+{
+	/* Make any sockets that are needed but not present.
+	 * If nlm_udpport or nlm_tcpport were set as module
+	 * options, make those sockets unconditionally
+	 */
+	int err = 0;
+	if (proto == IPPROTO_UDP || nlm_udpport)
+		if (!find_socket(serv, IPPROTO_UDP))
+			err = svc_makesock(serv, IPPROTO_UDP, nlm_udpport);
+	if (err)
+		return err;
+	if (proto == IPPROTO_TCP || nlm_tcpport)
+		if (!find_socket(serv, IPPROTO_TCP))
+			err= svc_makesock(serv, IPPROTO_TCP, nlm_tcpport);
+	return err;
+}
+
 /*
  * Bring up the lockd process if it's not already up.
  */
 int
-lockd_up(void)
+lockd_up(int proto) /* Maybe add a 'family' option when IPv6 is supported ?? */
 {
 	static int		warned;
 	struct svc_serv *	serv;
@@ -224,8 +259,10 @@ lockd_up(void)
 	/*
 	 * Check whether we're already up and running.
 	 */
-	if (nlmsvc_pid)
+	if (nlmsvc_pid) {
+		error = make_socks(nlmsvc_serv, proto);
 		goto out;
+	}
 
 	/*
 	 * Sanity check: if there's no pid,
@@ -242,11 +279,7 @@ lockd_up(void)
 		goto out;
 	}
 
-	if ((error = svc_makesock(serv, IPPROTO_UDP, nlm_udpport)) < 0 
-#ifdef CONFIG_NFSD_TCP
-	 || (error = svc_makesock(serv, IPPROTO_TCP, nlm_tcpport)) < 0
-#endif
-		) {
+	if ((error = make_socks(serv, proto)) < 0) {
 		if (warned++ == 0) 
 			printk(KERN_WARNING
 				"lockd_up: makesock failed, error=%d\n", error);

commit bc591ccff27e6a85d3a0d6fcb16cfadcc45267a8
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 2 02:17:44 2006 -0700

    [PATCH] knfsd: add a callback for when last rpc thread finishes
    
    nfsd has some cleanup that it wants to do when the last thread exits, and
    there will shortly be some more.  So collect this all into one place and
    define a callback for an rpc service to call when the service is about to be
    destroyed.
    
    [akpm@osdl.org: cleanups, build fix]
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 9a991b52c647..13feba45030e 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -236,7 +236,7 @@ lockd_up(void)
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
 	error = -ENOMEM;
-	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE);
+	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE, NULL);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		goto out;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index fd56c8872f34..9a991b52c647 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -12,7 +12,6 @@
  * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/sysctl.h>

commit 353ab6e97b8f209dbecc9f650f1f84e3da2a7bb1
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Mar 26 01:37:12 2006 -0800

    [PATCH] sem2mutex: fs/
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Eric Van Hensbergen <ericvh@ericvh.myip.org>
    Cc: Robert Love <rml@tech9.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Dave Kleikamp <shaggy@austin.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 5e85bde6c123..fd56c8872f34 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -25,6 +25,7 @@
 #include <linux/slab.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/mutex.h>
 
 #include <linux/sunrpc/types.h>
 #include <linux/sunrpc/stats.h>
@@ -43,13 +44,13 @@ static struct svc_program	nlmsvc_program;
 struct nlmsvc_binding *		nlmsvc_ops;
 EXPORT_SYMBOL(nlmsvc_ops);
 
-static DECLARE_MUTEX(nlmsvc_sema);
+static DEFINE_MUTEX(nlmsvc_mutex);
 static unsigned int		nlmsvc_users;
 static pid_t			nlmsvc_pid;
 int				nlmsvc_grace_period;
 unsigned long			nlmsvc_timeout;
 
-static DECLARE_MUTEX_LOCKED(lockd_start);
+static DECLARE_COMPLETION(lockd_start_done);
 static DECLARE_WAIT_QUEUE_HEAD(lockd_exit);
 
 /*
@@ -112,7 +113,7 @@ lockd(struct svc_rqst *rqstp)
 	 * Let our maker know we're running.
 	 */
 	nlmsvc_pid = current->pid;
-	up(&lockd_start);
+	complete(&lockd_start_done);
 
 	daemonize("lockd");
 
@@ -215,7 +216,7 @@ lockd_up(void)
 	struct svc_serv *	serv;
 	int			error = 0;
 
-	down(&nlmsvc_sema);
+	mutex_lock(&nlmsvc_mutex);
 	/*
 	 * Unconditionally increment the user count ... this is
 	 * the number of clients who _want_ a lockd process.
@@ -263,7 +264,7 @@ lockd_up(void)
 			"lockd_up: create thread failed, error=%d\n", error);
 		goto destroy_and_out;
 	}
-	down(&lockd_start);
+	wait_for_completion(&lockd_start_done);
 
 	/*
 	 * Note: svc_serv structures have an initial use count of 1,
@@ -272,7 +273,7 @@ lockd_up(void)
 destroy_and_out:
 	svc_destroy(serv);
 out:
-	up(&nlmsvc_sema);
+	mutex_unlock(&nlmsvc_mutex);
 	return error;
 }
 EXPORT_SYMBOL(lockd_up);
@@ -285,7 +286,7 @@ lockd_down(void)
 {
 	static int warned;
 
-	down(&nlmsvc_sema);
+	mutex_lock(&nlmsvc_mutex);
 	if (nlmsvc_users) {
 		if (--nlmsvc_users)
 			goto out;
@@ -315,7 +316,7 @@ lockd_down(void)
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
 out:
-	up(&nlmsvc_sema);
+	mutex_unlock(&nlmsvc_mutex);
 }
 EXPORT_SYMBOL(lockd_down);
 

commit e8c96f8c29d89af0c13dc2819a9a00575846ca18
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Fri Mar 24 03:15:34 2006 -0800

    [PATCH] fs: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove a
    duplicate of ARRAY_SIZE.  Some trailing whitespaces are also deleted.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Dave Kleikamp <shaggy@austin.ibm.com>
    Acked-by: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Chris Mason <mason@suse.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Nathan Scott <nathans@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 71a30b416d1a..5e85bde6c123 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -509,7 +509,7 @@ static struct svc_version *	nlmsvc_version[] = {
 
 static struct svc_stat		nlmsvc_stats;
 
-#define NLM_NRVERS	(sizeof(nlmsvc_version)/sizeof(nlmsvc_version[0]))
+#define NLM_NRVERS	ARRAY_SIZE(nlmsvc_version)
 static struct svc_program	nlmsvc_program = {
 	.pg_prog		= NLM_PROGRAM,		/* program number */
 	.pg_nvers		= NLM_NRVERS,		/* number of entries in nlmsvc_version */

commit 2bd615797ef32ec06ef0ee44198a7aecc21ffd8c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jan 3 09:55:19 2006 +0100

    SUNRPC: Ensure that SIGKILL will always terminate a synchronous RPC call.
    
     ...and make sure that the "intr" flag also enables SIGHUP and SIGTERM to
     interrupt RPC calls too (as per the Solaris implementation).
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 12a857c29e25..71a30b416d1a 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -178,6 +178,8 @@ lockd(struct svc_rqst *rqstp)
 
 	}
 
+	flush_signals(current);
+
 	/*
 	 * Check whether there's a new lockd process before
 	 * shutting down the hosts and clearing the slot.
@@ -192,8 +194,6 @@ lockd(struct svc_rqst *rqstp)
 			"lockd: new process, skipping host shutdown\n");
 	wake_up(&lockd_exit);
 
-	flush_signals(current);
-
 	/* Exit the RPC thread */
 	svc_exit_thread(rqstp);
 

commit 7ee91ec14bd4def036b4084da29869382078e44b
Author: Steve Dickson <SteveD@redhat.com>
Date:   Wed Jul 13 01:10:47 2005 -0700

    [PATCH] NFS: procfs/sysctl interfaces for lockd do not work on x86_64
    
    Allow the setting of NLM timeouts and grace periods through the proc and
    sysclt interfaces on x86_64 architectures
    
    Signed-off-by: Steve Dickson <steved@redhat.com>
    Acked-by: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 6e242556b903..12a857c29e25 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -331,7 +331,7 @@ static ctl_table nlm_sysctls[] = {
 		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nlm_grace_period",
 		.data		= &nlm_grace_period,
-		.maxlen		= sizeof(int),
+		.maxlen		= sizeof(unsigned long),
 		.mode		= 0644,
 		.proc_handler	= &proc_doulongvec_minmax,
 		.extra1		= (unsigned long *) &nlm_grace_period_min,
@@ -341,7 +341,7 @@ static ctl_table nlm_sysctls[] = {
 		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "nlm_timeout",
 		.data		= &nlm_timeout,
-		.maxlen		= sizeof(int),
+		.maxlen		= sizeof(unsigned long),
 		.mode		= 0644,
 		.proc_handler	= &proc_doulongvec_minmax,
 		.extra1		= (unsigned long *) &nlm_timeout_min,

commit 46be925fa6f4796e732e16a020fa0ef9d48ea7c8
Author: NeilBrown <neilb@cse.unsw.edu.au>
Date:   Thu Jun 23 22:03:11 2005 -0700

    [PATCH] knfsd: lockd: flush signals on shutdown
    
    Silence another annoying "failed to contact portmap (errno -512)" on shutdown.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Neil Brown <neilb@cse.unsw.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index b82e470912e8..6e242556b903 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -191,7 +191,9 @@ lockd(struct svc_rqst *rqstp)
 		printk(KERN_DEBUG
 			"lockd: new process, skipping host shutdown\n");
 	wake_up(&lockd_exit);
-		
+
+	flush_signals(current);
+
 	/* Exit the RPC thread */
 	svc_exit_thread(rqstp);
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
new file mode 100644
index 000000000000..b82e470912e8
--- /dev/null
+++ b/fs/lockd/svc.c
@@ -0,0 +1,519 @@
+/*
+ * linux/fs/lockd/svc.c
+ *
+ * This is the central lockd service.
+ *
+ * FIXME: Separate the lockd NFS server functionality from the lockd NFS
+ * 	  client functionality. Oh why didn't Sun create two separate
+ *	  services in the first place?
+ *
+ * Authors:	Olaf Kirch (okir@monad.swb.de)
+ *
+ * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sysctl.h>
+#include <linux/moduleparam.h>
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/uio.h>
+#include <linux/slab.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+
+#include <linux/sunrpc/types.h>
+#include <linux/sunrpc/stats.h>
+#include <linux/sunrpc/clnt.h>
+#include <linux/sunrpc/svc.h>
+#include <linux/sunrpc/svcsock.h>
+#include <linux/lockd/lockd.h>
+#include <linux/nfs.h>
+
+#define NLMDBG_FACILITY		NLMDBG_SVC
+#define LOCKD_BUFSIZE		(1024 + NLMSVC_XDRSIZE)
+#define ALLOWED_SIGS		(sigmask(SIGKILL))
+
+static struct svc_program	nlmsvc_program;
+
+struct nlmsvc_binding *		nlmsvc_ops;
+EXPORT_SYMBOL(nlmsvc_ops);
+
+static DECLARE_MUTEX(nlmsvc_sema);
+static unsigned int		nlmsvc_users;
+static pid_t			nlmsvc_pid;
+int				nlmsvc_grace_period;
+unsigned long			nlmsvc_timeout;
+
+static DECLARE_MUTEX_LOCKED(lockd_start);
+static DECLARE_WAIT_QUEUE_HEAD(lockd_exit);
+
+/*
+ * These can be set at insmod time (useful for NFS as root filesystem),
+ * and also changed through the sysctl interface.  -- Jamie Lokier, Aug 2003
+ */
+static unsigned long		nlm_grace_period;
+static unsigned long		nlm_timeout = LOCKD_DFLT_TIMEO;
+static int			nlm_udpport, nlm_tcpport;
+
+/*
+ * Constants needed for the sysctl interface.
+ */
+static const unsigned long	nlm_grace_period_min = 0;
+static const unsigned long	nlm_grace_period_max = 240;
+static const unsigned long	nlm_timeout_min = 3;
+static const unsigned long	nlm_timeout_max = 20;
+static const int		nlm_port_min = 0, nlm_port_max = 65535;
+
+static struct ctl_table_header * nlm_sysctl_table;
+
+static unsigned long set_grace_period(void)
+{
+	unsigned long grace_period;
+
+	/* Note: nlm_timeout should always be nonzero */
+	if (nlm_grace_period)
+		grace_period = ((nlm_grace_period + nlm_timeout - 1)
+				/ nlm_timeout) * nlm_timeout * HZ;
+	else
+		grace_period = nlm_timeout * 5 * HZ;
+	nlmsvc_grace_period = 1;
+	return grace_period + jiffies;
+}
+
+static inline void clear_grace_period(void)
+{
+	nlmsvc_grace_period = 0;
+}
+
+/*
+ * This is the lockd kernel thread
+ */
+static void
+lockd(struct svc_rqst *rqstp)
+{
+	struct svc_serv	*serv = rqstp->rq_server;
+	int		err = 0;
+	unsigned long grace_period_expire;
+
+	/* Lock module and set up kernel thread */
+	/* lockd_up is waiting for us to startup, so will
+	 * be holding a reference to this module, so it
+	 * is safe to just claim another reference
+	 */
+	__module_get(THIS_MODULE);
+	lock_kernel();
+
+	/*
+	 * Let our maker know we're running.
+	 */
+	nlmsvc_pid = current->pid;
+	up(&lockd_start);
+
+	daemonize("lockd");
+
+	/* Process request with signals blocked, but allow SIGKILL.  */
+	allow_signal(SIGKILL);
+
+	/* kick rpciod */
+	rpciod_up();
+
+	dprintk("NFS locking service started (ver " LOCKD_VERSION ").\n");
+
+	if (!nlm_timeout)
+		nlm_timeout = LOCKD_DFLT_TIMEO;
+	nlmsvc_timeout = nlm_timeout * HZ;
+
+	grace_period_expire = set_grace_period();
+
+	/*
+	 * The main request loop. We don't terminate until the last
+	 * NFS mount or NFS daemon has gone away, and we've been sent a
+	 * signal, or else another process has taken over our job.
+	 */
+	while ((nlmsvc_users || !signalled()) && nlmsvc_pid == current->pid) {
+		long timeout = MAX_SCHEDULE_TIMEOUT;
+
+		if (signalled()) {
+			flush_signals(current);
+			if (nlmsvc_ops) {
+				nlmsvc_invalidate_all();
+				grace_period_expire = set_grace_period();
+			}
+		}
+
+		/*
+		 * Retry any blocked locks that have been notified by
+		 * the VFS. Don't do this during grace period.
+		 * (Theoretically, there shouldn't even be blocked locks
+		 * during grace period).
+		 */
+		if (!nlmsvc_grace_period) {
+			timeout = nlmsvc_retry_blocked();
+		} else if (time_before(grace_period_expire, jiffies))
+			clear_grace_period();
+
+		/*
+		 * Find a socket with data available and call its
+		 * recvfrom routine.
+		 */
+		err = svc_recv(serv, rqstp, timeout);
+		if (err == -EAGAIN || err == -EINTR)
+			continue;
+		if (err < 0) {
+			printk(KERN_WARNING
+			       "lockd: terminating on error %d\n",
+			       -err);
+			break;
+		}
+
+		dprintk("lockd: request from %08x\n",
+			(unsigned)ntohl(rqstp->rq_addr.sin_addr.s_addr));
+
+		svc_process(serv, rqstp);
+
+	}
+
+	/*
+	 * Check whether there's a new lockd process before
+	 * shutting down the hosts and clearing the slot.
+	 */
+	if (!nlmsvc_pid || current->pid == nlmsvc_pid) {
+		if (nlmsvc_ops)
+			nlmsvc_invalidate_all();
+		nlm_shutdown_hosts();
+		nlmsvc_pid = 0;
+	} else
+		printk(KERN_DEBUG
+			"lockd: new process, skipping host shutdown\n");
+	wake_up(&lockd_exit);
+		
+	/* Exit the RPC thread */
+	svc_exit_thread(rqstp);
+
+	/* release rpciod */
+	rpciod_down();
+
+	/* Release module */
+	unlock_kernel();
+	module_put_and_exit(0);
+}
+
+/*
+ * Bring up the lockd process if it's not already up.
+ */
+int
+lockd_up(void)
+{
+	static int		warned;
+	struct svc_serv *	serv;
+	int			error = 0;
+
+	down(&nlmsvc_sema);
+	/*
+	 * Unconditionally increment the user count ... this is
+	 * the number of clients who _want_ a lockd process.
+	 */
+	nlmsvc_users++; 
+	/*
+	 * Check whether we're already up and running.
+	 */
+	if (nlmsvc_pid)
+		goto out;
+
+	/*
+	 * Sanity check: if there's no pid,
+	 * we should be the first user ...
+	 */
+	if (nlmsvc_users > 1)
+		printk(KERN_WARNING
+			"lockd_up: no pid, %d users??\n", nlmsvc_users);
+
+	error = -ENOMEM;
+	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE);
+	if (!serv) {
+		printk(KERN_WARNING "lockd_up: create service failed\n");
+		goto out;
+	}
+
+	if ((error = svc_makesock(serv, IPPROTO_UDP, nlm_udpport)) < 0 
+#ifdef CONFIG_NFSD_TCP
+	 || (error = svc_makesock(serv, IPPROTO_TCP, nlm_tcpport)) < 0
+#endif
+		) {
+		if (warned++ == 0) 
+			printk(KERN_WARNING
+				"lockd_up: makesock failed, error=%d\n", error);
+		goto destroy_and_out;
+	} 
+	warned = 0;
+
+	/*
+	 * Create the kernel thread and wait for it to start.
+	 */
+	error = svc_create_thread(lockd, serv);
+	if (error) {
+		printk(KERN_WARNING
+			"lockd_up: create thread failed, error=%d\n", error);
+		goto destroy_and_out;
+	}
+	down(&lockd_start);
+
+	/*
+	 * Note: svc_serv structures have an initial use count of 1,
+	 * so we exit through here on both success and failure.
+	 */
+destroy_and_out:
+	svc_destroy(serv);
+out:
+	up(&nlmsvc_sema);
+	return error;
+}
+EXPORT_SYMBOL(lockd_up);
+
+/*
+ * Decrement the user count and bring down lockd if we're the last.
+ */
+void
+lockd_down(void)
+{
+	static int warned;
+
+	down(&nlmsvc_sema);
+	if (nlmsvc_users) {
+		if (--nlmsvc_users)
+			goto out;
+	} else
+		printk(KERN_WARNING "lockd_down: no users! pid=%d\n", nlmsvc_pid);
+
+	if (!nlmsvc_pid) {
+		if (warned++ == 0)
+			printk(KERN_WARNING "lockd_down: no lockd running.\n"); 
+		goto out;
+	}
+	warned = 0;
+
+	kill_proc(nlmsvc_pid, SIGKILL, 1);
+	/*
+	 * Wait for the lockd process to exit, but since we're holding
+	 * the lockd semaphore, we can't wait around forever ...
+	 */
+	clear_thread_flag(TIF_SIGPENDING);
+	interruptible_sleep_on_timeout(&lockd_exit, HZ);
+	if (nlmsvc_pid) {
+		printk(KERN_WARNING 
+			"lockd_down: lockd failed to exit, clearing pid\n");
+		nlmsvc_pid = 0;
+	}
+	spin_lock_irq(&current->sighand->siglock);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+out:
+	up(&nlmsvc_sema);
+}
+EXPORT_SYMBOL(lockd_down);
+
+/*
+ * Sysctl parameters (same as module parameters, different interface).
+ */
+
+/* Something that isn't CTL_ANY, CTL_NONE or a value that may clash. */
+#define CTL_UNNUMBERED		-2
+
+static ctl_table nlm_sysctls[] = {
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nlm_grace_period",
+		.data		= &nlm_grace_period,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_doulongvec_minmax,
+		.extra1		= (unsigned long *) &nlm_grace_period_min,
+		.extra2		= (unsigned long *) &nlm_grace_period_max,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nlm_timeout",
+		.data		= &nlm_timeout,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_doulongvec_minmax,
+		.extra1		= (unsigned long *) &nlm_timeout_min,
+		.extra2		= (unsigned long *) &nlm_timeout_max,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nlm_udpport",
+		.data		= &nlm_udpport,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= (int *) &nlm_port_min,
+		.extra2		= (int *) &nlm_port_max,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nlm_tcpport",
+		.data		= &nlm_tcpport,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= (int *) &nlm_port_min,
+		.extra2		= (int *) &nlm_port_max,
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table nlm_sysctl_dir[] = {
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nfs",
+		.mode		= 0555,
+		.child		= nlm_sysctls,
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table nlm_sysctl_root[] = {
+	{
+		.ctl_name	= CTL_FS,
+		.procname	= "fs",
+		.mode		= 0555,
+		.child		= nlm_sysctl_dir,
+	},
+	{ .ctl_name = 0 }
+};
+
+/*
+ * Module (and driverfs) parameters.
+ */
+
+#define param_set_min_max(name, type, which_strtol, min, max)		\
+static int param_set_##name(const char *val, struct kernel_param *kp)	\
+{									\
+	char *endp;							\
+	__typeof__(type) num = which_strtol(val, &endp, 0);		\
+	if (endp == val || *endp || num < (min) || num > (max))		\
+		return -EINVAL;						\
+	*((int *) kp->arg) = num;					\
+	return 0;							\
+}
+
+static inline int is_callback(u32 proc)
+{
+	return proc == NLMPROC_GRANTED
+		|| proc == NLMPROC_GRANTED_MSG
+		|| proc == NLMPROC_TEST_RES
+		|| proc == NLMPROC_LOCK_RES
+		|| proc == NLMPROC_CANCEL_RES
+		|| proc == NLMPROC_UNLOCK_RES
+		|| proc == NLMPROC_NSM_NOTIFY;
+}
+
+
+static int lockd_authenticate(struct svc_rqst *rqstp)
+{
+	rqstp->rq_client = NULL;
+	switch (rqstp->rq_authop->flavour) {
+		case RPC_AUTH_NULL:
+		case RPC_AUTH_UNIX:
+			if (rqstp->rq_proc == 0)
+				return SVC_OK;
+			if (is_callback(rqstp->rq_proc)) {
+				/* Leave it to individual procedures to
+				 * call nlmsvc_lookup_host(rqstp)
+				 */
+				return SVC_OK;
+			}
+			return svc_set_client(rqstp);
+	}
+	return SVC_DENIED;
+}
+
+
+param_set_min_max(port, int, simple_strtol, 0, 65535)
+param_set_min_max(grace_period, unsigned long, simple_strtoul,
+		  nlm_grace_period_min, nlm_grace_period_max)
+param_set_min_max(timeout, unsigned long, simple_strtoul,
+		  nlm_timeout_min, nlm_timeout_max)
+
+MODULE_AUTHOR("Olaf Kirch <okir@monad.swb.de>");
+MODULE_DESCRIPTION("NFS file locking service version " LOCKD_VERSION ".");
+MODULE_LICENSE("GPL");
+
+module_param_call(nlm_grace_period, param_set_grace_period, param_get_ulong,
+		  &nlm_grace_period, 0644);
+module_param_call(nlm_timeout, param_set_timeout, param_get_ulong,
+		  &nlm_timeout, 0644);
+module_param_call(nlm_udpport, param_set_port, param_get_int,
+		  &nlm_udpport, 0644);
+module_param_call(nlm_tcpport, param_set_port, param_get_int,
+		  &nlm_tcpport, 0644);
+
+/*
+ * Initialising and terminating the module.
+ */
+
+static int __init init_nlm(void)
+{
+	nlm_sysctl_table = register_sysctl_table(nlm_sysctl_root, 0);
+	return nlm_sysctl_table ? 0 : -ENOMEM;
+}
+
+static void __exit exit_nlm(void)
+{
+	/* FIXME: delete all NLM clients */
+	nlm_shutdown_hosts();
+	unregister_sysctl_table(nlm_sysctl_table);
+}
+
+module_init(init_nlm);
+module_exit(exit_nlm);
+
+/*
+ * Define NLM program and procedures
+ */
+static struct svc_version	nlmsvc_version1 = {
+		.vs_vers	= 1,
+		.vs_nproc	= 17,
+		.vs_proc	= nlmsvc_procedures,
+		.vs_xdrsize	= NLMSVC_XDRSIZE,
+};
+static struct svc_version	nlmsvc_version3 = {
+		.vs_vers	= 3,
+		.vs_nproc	= 24,
+		.vs_proc	= nlmsvc_procedures,
+		.vs_xdrsize	= NLMSVC_XDRSIZE,
+};
+#ifdef CONFIG_LOCKD_V4
+static struct svc_version	nlmsvc_version4 = {
+		.vs_vers	= 4,
+		.vs_nproc	= 24,
+		.vs_proc	= nlmsvc_procedures4,
+		.vs_xdrsize	= NLMSVC_XDRSIZE,
+};
+#endif
+static struct svc_version *	nlmsvc_version[] = {
+	[1] = &nlmsvc_version1,
+	[3] = &nlmsvc_version3,
+#ifdef CONFIG_LOCKD_V4
+	[4] = &nlmsvc_version4,
+#endif
+};
+
+static struct svc_stat		nlmsvc_stats;
+
+#define NLM_NRVERS	(sizeof(nlmsvc_version)/sizeof(nlmsvc_version[0]))
+static struct svc_program	nlmsvc_program = {
+	.pg_prog		= NLM_PROGRAM,		/* program number */
+	.pg_nvers		= NLM_NRVERS,		/* number of entries in nlmsvc_version */
+	.pg_vers		= nlmsvc_version,	/* version table */
+	.pg_name		= "lockd",		/* service name */
+	.pg_class		= "nfsd",		/* share authentication with nfsd */
+	.pg_stats		= &nlmsvc_stats,	/* stats table */
+	.pg_authenticate = &lockd_authenticate	/* export authentication */
+};
