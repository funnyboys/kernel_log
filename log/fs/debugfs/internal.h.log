commit 69b07ee33eb12a505d55e3e716fc7452496b9041
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Sun Apr 19 20:18:55 2020 +0530

    debugfs: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style in
    header file related to debugfs File System support.
    For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used).
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Link: https://lore.kernel.org/r/20200419144852.GA9206@nishad
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
index f0d73d86cc1a..034e6973cead 100644
--- a/fs/debugfs/internal.h
+++ b/fs/debugfs/internal.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  *  internal.h - declarations internal to debugfs
  *

commit 2b2d8788dd565cbe1ab22da6a1bc63d0934a80eb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:01:46 2017 +0100

    debugfs: Remove redundant license text
    
    Now that the SPDX tag is in all debugfs files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
index b9567541b737..f0d73d86cc1a 100644
--- a/fs/debugfs/internal.h
+++ b/fs/debugfs/internal.h
@@ -3,11 +3,6 @@
  *  internal.h - declarations internal to debugfs
  *
  *  Copyright (C) 2016 Nicolai Stange <nicstange@gmail.com>
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License version
- *	2 as published by the Free Software Foundation.
- *
  */
 
 #ifndef _DEBUGFS_INTERNAL_H_

commit 3bce94fd5f4c05337dedbe218501fb9f8789fc40
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 16:59:23 2017 +0100

    debugfs: add SPDX identifiers to all debugfs files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the debugfs files files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
index cb1e8139c398..b9567541b737 100644
--- a/fs/debugfs/internal.h
+++ b/fs/debugfs/internal.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  internal.h - declarations internal to debugfs
  *

commit 7d39bc50c47b3f8ed0e1a9d671ecb9ec02f10a2d
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Tue Oct 31 00:15:54 2017 +0100

    debugfs: defer debugfs_fsdata allocation to first usage
    
    Currently, __debugfs_create_file allocates one struct debugfs_fsdata
    instance for every file created. However, there are potentially many
    debugfs file around, most of which are never touched by userspace.
    
    Thus, defer the allocations to the first usage, i.e. to the first
    debugfs_file_get().
    
    A dentry's ->d_fsdata starts out to point to the "real", user provided
    fops. After a debugfs_fsdata instance has been allocated (and the real
    fops pointer has been moved over into its ->real_fops member),
    ->d_fsdata is changed to point to it from then on. The two cases are
    distinguished by setting BIT(0) for the real fops case.
    
    struct debugfs_fsdata's foremost purpose is to track active users and to
    make debugfs_remove() block until they are done. Since no debugfs_fsdata
    instance means no active users, make debugfs_remove() return immediately
    in this case.
    
    Take care of possible races between debugfs_file_get() and
    debugfs_remove(): either debugfs_remove() must see a debugfs_fsdata
    instance and thus wait for possible active users or debugfs_file_get() must
    see a dead dentry and return immediately.
    
    Make a dentry's ->d_release(), i.e. debugfs_release_dentry(), check whether
    ->d_fsdata is actually a debugfs_fsdata instance before kfree()ing it.
    
    Similarly, make debugfs_real_fops() check whether ->d_fsdata is actually
    a debugfs_fsdata instance before returning it, otherwise emit a warning.
    
    The set of possible error codes returned from debugfs_file_get() has grown
    from -EIO to -EIO and -ENOMEM. Make open_proxy_open() and full_proxy_open()
    pass the -ENOMEM onwards to their callers.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
index 0eea99432840..cb1e8139c398 100644
--- a/fs/debugfs/internal.h
+++ b/fs/debugfs/internal.h
@@ -25,4 +25,12 @@ struct debugfs_fsdata {
 	struct completion active_users_drained;
 };
 
+/*
+ * A dentry's ->d_fsdata either points to the real fops or to a
+ * dynamically allocated debugfs_fsdata instance.
+ * In order to distinguish between these two cases, a real fops
+ * pointer gets its lowest bit set.
+ */
+#define DEBUGFS_FSDATA_IS_REAL_FOPS_BIT BIT(0)
+
 #endif /* _DEBUGFS_INTERNAL_H_ */

commit e9117a5a4bf65d8e99f060d356a04d27a60b436d
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Tue Oct 31 00:15:48 2017 +0100

    debugfs: implement per-file removal protection
    
    Since commit 49d200deaa68 ("debugfs: prevent access to removed files'
    private data"), accesses to a file's private data are protected from
    concurrent removal by covering all file_operations with a SRCU read section
    and sychronizing with those before returning from debugfs_remove() by means
    of synchronize_srcu().
    
    As pointed out by Johannes Berg, there are debugfs files with forever
    blocking file_operations. Their corresponding SRCU read side sections would
    block any debugfs_remove() forever as well, even unrelated ones. This
    results in a livelock. Because a remover can't cancel any indefinite
    blocking within foreign files, this is a problem.
    
    Resolve this by introducing support for more granular protection on a
    per-file basis.
    
    This is implemented by introducing an  'active_users' refcount_t to the
    per-file struct debugfs_fsdata state. At file creation time, it is set to
    one and a debugfs_remove() will drop that initial reference. The new
    debugfs_file_get() and debugfs_file_put(), intended to be used in place of
    former debugfs_use_file_start() and debugfs_use_file_finish(), increment
    and decrement it respectively. Once the count drops to zero,
    debugfs_file_put() will signal a completion which is possibly being waited
    for from debugfs_remove().
    Thus, as long as there is a debugfs_file_get() not yet matched by a
    corresponding debugfs_file_put() around, debugfs_remove() will block.
    
    Actual users of debugfs_use_file_start() and -finish() will get converted
    to the new debugfs_file_get() and debugfs_file_put() by followup patches.
    
    Fixes: 49d200deaa68 ("debugfs: prevent access to removed files' private data")
    Reported-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
index 512601eed3ce..0eea99432840 100644
--- a/fs/debugfs/internal.h
+++ b/fs/debugfs/internal.h
@@ -21,6 +21,8 @@ extern const struct file_operations debugfs_full_proxy_file_operations;
 
 struct debugfs_fsdata {
 	const struct file_operations *real_fops;
+	refcount_t active_users;
+	struct completion active_users_drained;
 };
 
 #endif /* _DEBUGFS_INTERNAL_H_ */

commit 7c8d469877b16d2c1cecf101a0abb7b218db85bc
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Tue Oct 31 00:15:47 2017 +0100

    debugfs: add support for more elaborate ->d_fsdata
    
    Currently, the user provided fops, "real_fops", are stored directly into
    ->d_fsdata.
    
    In order to be able to store more per-file state and thus prepare for more
    granular file removal protection, wrap the real_fops into a dynamically
    allocated container struct, debugfs_fsdata.
    
    A struct debugfs_fsdata gets allocated at file creation and freed from the
    newly intoduced ->d_release().
    
    Finally, move the implementation of debugfs_real_fops() out of the public
    debugfs header such that struct debugfs_fsdata's declaration can be kept
    private.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
index b3e8443a1f47..512601eed3ce 100644
--- a/fs/debugfs/internal.h
+++ b/fs/debugfs/internal.h
@@ -19,4 +19,8 @@ extern const struct file_operations debugfs_noop_file_operations;
 extern const struct file_operations debugfs_open_proxy_file_operations;
 extern const struct file_operations debugfs_full_proxy_file_operations;
 
+struct debugfs_fsdata {
+	const struct file_operations *real_fops;
+};
+
 #endif /* _DEBUGFS_INTERNAL_H_ */

commit 24ef5f360f22e4408cb49d75755d27d5a21820f7
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Tue May 24 13:08:52 2016 +0200

    debugfs: remove extra debugfs_create_file_unsafe() declaration
    
    debugfs_create_file_unsafe() is declared twice in exactly the same
    manner each: once in fs/debugfs/internal.h and once in
    include/linux/debugfs.h
    
    All files that include the former also include the latter and thus,
    the declaration in fs/debugfs/internal.h is superfluous.
    
    Remove it.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
index bba52634b995..b3e8443a1f47 100644
--- a/fs/debugfs/internal.h
+++ b/fs/debugfs/internal.h
@@ -19,8 +19,4 @@ extern const struct file_operations debugfs_noop_file_operations;
 extern const struct file_operations debugfs_open_proxy_file_operations;
 extern const struct file_operations debugfs_full_proxy_file_operations;
 
-struct dentry *debugfs_create_file_unsafe(const char *name, umode_t mode,
-					struct dentry *parent, void *data,
-					const struct file_operations *fops);
-
 #endif /* _DEBUGFS_INTERNAL_H_ */

commit 49d200deaa680501f19a247b1fffb29301e51d2b
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Tue Mar 22 14:11:14 2016 +0100

    debugfs: prevent access to removed files' private data
    
    Upon return of debugfs_remove()/debugfs_remove_recursive(), it might
    still be attempted to access associated private file data through
    previously opened struct file objects. If that data has been freed by
    the caller of debugfs_remove*() in the meanwhile, the reading/writing
    process would either encounter a fault or, if the memory address in
    question has been reassigned again, unrelated data structures could get
    overwritten.
    
    However, since debugfs files are seldomly removed, usually from module
    exit handlers only, the impact is very low.
    
    Currently, there are ~1000 call sites of debugfs_create_file() spread
    throughout the whole tree and touching all of those struct file_operations
    in order to make them file removal aware by means of checking the result of
    debugfs_use_file_start() from within their methods is unfeasible.
    
    Instead, wrap the struct file_operations by a lifetime managing proxy at
    file open:
    - In debugfs_create_file(), the original fops handed in has got stashed
      away in ->d_fsdata already.
    - In debugfs_create_file(), install a proxy file_operations factory,
      debugfs_full_proxy_file_operations, at ->i_fop.
    
    This proxy factory has got an ->open() method only. It carries out some
    lifetime checks and if successful, dynamically allocates and sets up a new
    struct file_operations proxy at ->f_op. Afterwards, it forwards to the
    ->open() of the original struct file_operations in ->d_fsdata, if any.
    
    The dynamically set up proxy at ->f_op has got a lifetime managing wrapper
    set for each of the methods defined in the original struct file_operations
    in ->d_fsdata.
    
    Its ->release()er frees the proxy again and forwards to the original
    ->release(), if any.
    
    In order not to mislead the VFS layer, it is strictly necessary to leave
    those fields blank in the proxy that have been NULL in the original
    struct file_operations also, i.e. aren't supported. This is why there is a
    need for dynamically allocated proxies. The choice made not to allocate a
    proxy instance for every dentry at file creation, but for every
    struct file object instantiated thereof is justified by the expected usage
    pattern of debugfs, namely that in general very few files get opened more
    than once at a time.
    
    The wrapper methods set in the struct file_operations implement lifetime
    managing by means of the SRCU protection facilities already in place for
    debugfs:
    They set up a SRCU read side critical section and check whether the dentry
    is still alive by means of debugfs_use_file_start(). If so, they forward
    the call to the original struct file_operation stored in ->d_fsdata, still
    under the protection of the SRCU read side critical section.
    This SRCU read side critical section prevents any pending debugfs_remove()
    and friends to return to their callers. Since a file's private data must
    only be freed after the return of debugfs_remove(), the ongoing proxied
    call is guarded against any file removal race.
    
    If, on the other hand, the initial call to debugfs_use_file_start() detects
    that the dentry is dead, the wrapper simply returns -EIO and does not
    forward the call. Note that the ->poll() wrapper is special in that its
    signature does not allow for the return of arbitrary -EXXX values and thus,
    POLLHUP is returned here.
    
    In order not to pollute debugfs with wrapper definitions that aren't ever
    needed, I chose not to define a wrapper for every struct file_operations
    method possible. Instead, a wrapper is defined only for the subset of
    methods which are actually set by any debugfs users.
    Currently, these are:
    
      ->llseek()
      ->read()
      ->write()
      ->unlocked_ioctl()
      ->poll()
    
    The ->release() wrapper is special in that it does not protect the original
    ->release() in any way from dead files in order not to leak resources.
    Thus, any ->release() handed to debugfs must implement file lifetime
    management manually, if needed.
    For only 33 out of a total of 434 releasers handed in to debugfs, it could
    not be verified immediately whether they access data structures that might
    have been freed upon a debugfs_remove() return in the meanwhile.
    
    Export debugfs_use_file_start() and debugfs_use_file_finish() in order to
    allow any ->release() to manually implement file lifetime management.
    
    For a set of common cases of struct file_operations implemented by the
    debugfs_core itself, future patches will incorporate file lifetime
    management directly within those in order to allow for their unproxied
    operation. Rename the original, non-proxying "debugfs_create_file()" to
    "debugfs_create_file_unsafe()" and keep it for future internal use by
    debugfs itself. Factor out code common to both into the new
    __debugfs_create_file().
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
index c7aaa5cb6685..bba52634b995 100644
--- a/fs/debugfs/internal.h
+++ b/fs/debugfs/internal.h
@@ -13,12 +13,14 @@
 #define _DEBUGFS_INTERNAL_H_
 
 struct file_operations;
-struct srcu_struct;
 
 /* declared over in file.c */
 extern const struct file_operations debugfs_noop_file_operations;
 extern const struct file_operations debugfs_open_proxy_file_operations;
+extern const struct file_operations debugfs_full_proxy_file_operations;
 
-extern struct srcu_struct debugfs_srcu;
+struct dentry *debugfs_create_file_unsafe(const char *name, umode_t mode,
+					struct dentry *parent, void *data,
+					const struct file_operations *fops);
 
 #endif /* _DEBUGFS_INTERNAL_H_ */

commit 9fd4dcece43a53e5a9e65a973df5693702ee6401
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Tue Mar 22 14:11:13 2016 +0100

    debugfs: prevent access to possibly dead file_operations at file open
    
    Nothing prevents a dentry found by path lookup before a return of
    __debugfs_remove() to actually get opened after that return. Now, after
    the return of __debugfs_remove(), there are no guarantees whatsoever
    regarding the memory the corresponding inode's file_operations object
    had been kept in.
    
    Since __debugfs_remove() is seldomly invoked, usually from module exit
    handlers only, the race is hard to trigger and the impact is very low.
    
    A discussion of the problem outlined above as well as a suggested
    solution can be found in the (sub-)thread rooted at
    
      http://lkml.kernel.org/g/20130401203445.GA20862@ZenIV.linux.org.uk
      ("Yet another pipe related oops.")
    
    Basically, Greg KH suggests to introduce an intermediate fops and
    Al Viro points out that a pointer to the original ones may be stored in
    ->d_fsdata.
    
    Follow this line of reasoning:
    - Add SRCU as a reverse dependency of DEBUG_FS.
    - Introduce a srcu_struct object for the debugfs subsystem.
    - In debugfs_create_file(), store a pointer to the original
      file_operations object in ->d_fsdata.
    - Make debugfs_remove() and debugfs_remove_recursive() wait for a
      SRCU grace period after the dentry has been delete()'d and before they
      return to their callers.
    - Introduce an intermediate file_operations object named
      "debugfs_open_proxy_file_operations". It's ->open() functions checks,
      under the protection of a SRCU read lock, whether the dentry is still
      alive, i.e. has not been d_delete()'d and if so, tries to acquire a
      reference on the owning module.
      On success, it sets the file object's ->f_op to the original
      file_operations and forwards the ongoing open() call to the original
      ->open().
    - For clarity, rename the former debugfs_file_operations to
      debugfs_noop_file_operations -- they are in no way canonical.
    
    The choice of SRCU over "normal" RCU is justified by the fact, that the
    former may also be used to protect ->i_private data from going away
    during the execution of a file's readers and writers which may (and do)
    sleep.
    
    Finally, introduce the fs/debugfs/internal.h header containing some
    declarations internal to the debugfs implementation.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/debugfs/internal.h b/fs/debugfs/internal.h
new file mode 100644
index 000000000000..c7aaa5cb6685
--- /dev/null
+++ b/fs/debugfs/internal.h
@@ -0,0 +1,24 @@
+/*
+ *  internal.h - declarations internal to debugfs
+ *
+ *  Copyright (C) 2016 Nicolai Stange <nicstange@gmail.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License version
+ *	2 as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _DEBUGFS_INTERNAL_H_
+#define _DEBUGFS_INTERNAL_H_
+
+struct file_operations;
+struct srcu_struct;
+
+/* declared over in file.c */
+extern const struct file_operations debugfs_noop_file_operations;
+extern const struct file_operations debugfs_open_proxy_file_operations;
+
+extern struct srcu_struct debugfs_srcu;
+
+#endif /* _DEBUGFS_INTERNAL_H_ */
