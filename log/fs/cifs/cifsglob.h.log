commit 0b0430c6a10a22813e3d40c5658ae644acda4303
Author: Kenneth D'souza <kdsouza@redhat.com>
Date:   Tue Jun 9 10:12:10 2020 +0530

    cifs: Add get_security_type_str function to return sec type.
    
    This code is more organized and robust.
    
    Signed-off-by: Kenneth D'souza <kdsouza@redhat.com>
    Signed-off-by: Roberto Bergantinos Corpas <rbergant@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e133bb3e172f..fad37d61910a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -2008,6 +2008,24 @@ extern struct smb_version_values smb302_values;
 extern struct smb_version_operations smb311_operations;
 extern struct smb_version_values smb311_values;
 
+static inline char *get_security_type_str(enum securityEnum sectype)
+{
+	switch (sectype) {
+	case RawNTLMSSP:
+		return "RawNTLMSSP";
+	case Kerberos:
+		return "Kerberos";
+	case NTLMv2:
+		return "NTLMv2";
+	case NTLM:
+		return "NTLM";
+	case LANMAN:
+		return "LANMAN";
+	default:
+		return "Unknown";
+	}
+}
+
 static inline bool is_smb1_server(struct TCP_Server_Info *server)
 {
 	return strcmp(server->vals->version_string, SMB1_VERSION_STRING) == 0;

commit 8eec79540d2b9cec385707be45f6e9388b34020f
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Apr 24 15:24:05 2020 +0200

    cifs: multichannel: use pointer for binding channel
    
    Add a cifs_chan pointer in struct cifs_ses that points to the channel
    currently being bound if ses->binding is true.
    
    Previously it was always the channel past the established count.
    
    This will make reconnecting (and rebinding) a channel easier later on.
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c0cbbd0bbb1d..e133bb3e172f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1030,6 +1030,7 @@ struct cifs_ses {
 
 #define CIFS_MAX_CHANNELS 16
 	struct cifs_chan chans[CIFS_MAX_CHANNELS];
+	struct cifs_chan *binding_chan;
 	size_t chan_count;
 	size_t chan_max;
 	atomic_t chan_seq; /* round robin state */
@@ -1037,23 +1038,31 @@ struct cifs_ses {
 
 /*
  * When binding a new channel, we need to access the channel which isn't fully
- * established yet (one past the established count)
+ * established yet.
  */
 
 static inline
 struct cifs_chan *cifs_ses_binding_channel(struct cifs_ses *ses)
 {
 	if (ses->binding)
-		return &ses->chans[ses->chan_count];
+		return ses->binding_chan;
 	else
 		return NULL;
 }
 
+/*
+ * Returns the server pointer of the session. When binding a new
+ * channel this returns the last channel which isn't fully established
+ * yet.
+ *
+ * This function should be use for negprot/sess.setup codepaths. For
+ * the other requests see cifs_pick_channel().
+ */
 static inline
 struct TCP_Server_Info *cifs_ses_server(struct cifs_ses *ses)
 {
 	if (ses->binding)
-		return ses->chans[ses->chan_count].server;
+		return ses->binding_chan->server;
 	else
 		return ses->server;
 }

commit 352d96f3acc6e02099f58a24d5cabce7f8ee061f
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Sun May 31 12:38:22 2020 -0500

    cifs: multichannel: move channel selection above transport layer
    
    Move the channel (TCP_Server_Info*) selection from the tranport
    layer to higher in the call stack so that:
    
    - credit handling is done with the server that will actually be used
      to send.
      * ->wait_mtu_credit
      * ->set_credits / set_credits
      * ->add_credits / add_credits
      * add_credits_and_wake_if
    
    - potential reconnection (smb2_reconnect) done when initializing a
      request is checked and done with the server that will actually be
      used to send.
    
    To do this:
    
    - remove the cifs_pick_channel() call out of compound_send_recv()
    
    - select channel and pass it down by adding a cifs_pick_channel(ses)
      call in:
      - smb311_posix_mkdir
      - SMB2_open
      - SMB2_ioctl
      - __SMB2_close
      - query_info
      - SMB2_change_notify
      - SMB2_flush
      - smb2_async_readv  (if none provided in context param)
      - SMB2_read         (if none provided in context param)
      - smb2_async_writev (if none provided in context param)
      - SMB2_write        (if none provided in context param)
      - SMB2_query_directory
      - send_set_info
      - SMB2_oplock_break
      - SMB311_posix_qfs_info
      - SMB2_QFS_info
      - SMB2_QFS_attr
      - smb2_lockv
      - SMB2_lease_break
        - smb2_compound_op
      - smb2_set_ea
      - smb2_ioctl_query_info
      - smb2_query_dir_first
      - smb2_query_info_comound
      - smb2_query_symlink
      - cifs_writepages
      - cifs_write_from_iter
      - cifs_send_async_read
      - cifs_read
      - cifs_readpages
    
    - add TCP_Server_Info *server param argument to:
      - cifs_send_recv
      - compound_send_recv
      - SMB2_open_init
      - SMB2_query_info_init
      - SMB2_set_info_init
      - SMB2_close_init
      - SMB2_ioctl_init
      - smb2_iotcl_req_init
      - SMB2_query_directory_init
      - SMB2_notify_init
      - SMB2_flush_init
      - build_qfs_info_req
      - smb2_hdr_assemble
      - smb2_reconnect
      - fill_small_buf
      - smb2_plain_req_init
      - __smb2_plain_req_init
    
    The read/write codepath is different than the rest as it is using
    pages, io iterators and async calls. To deal with those we add a
    server pointer in the cifs_writedata/cifs_readdata/cifs_io_parms
    context struct and set it in:
    
    - cifs_writepages      (wdata)
    - cifs_write_from_iter (wdata)
    - cifs_readpages       (rdata)
    - cifs_send_async_read (rdata)
    
    The [rw]data->server pointer is eventually copied to
    cifs_io_parms->server to pass it down to SMB2_read/SMB2_write.
    If SMB2_read/SMB2_write is called from a different place that doesn't
    set the server field it will pick a channel.
    
    Some places do not pick a channel and just use ses->server or
    cifs_ses_server(ses). All cifs_ses_server(ses) calls are in codepaths
    involving negprot/sess.setup.
    
    - SMB2_negotiate         (binding channel)
    - SMB2_sess_alloc_buffer (binding channel)
    - SMB2_echo              (uses provided one)
    - SMB2_logoff            (uses master)
    - SMB2_tdis              (uses master)
    
    (list not exhaustive)
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4d261fd78fcb..c0cbbd0bbb1d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1335,6 +1335,7 @@ struct cifs_io_parms {
 	__u64 offset;
 	unsigned int length;
 	struct cifs_tcon *tcon;
+	struct TCP_Server_Info *server;
 };
 
 struct cifs_aio_ctx {
@@ -1382,6 +1383,7 @@ struct cifs_readdata {
 				struct cifs_readdata *rdata,
 				struct iov_iter *iter);
 	struct kvec			iov[2];
+	struct TCP_Server_Info		*server;
 #ifdef CONFIG_CIFS_SMB_DIRECT
 	struct smbd_mr			*mr;
 #endif
@@ -1408,6 +1410,7 @@ struct cifs_writedata {
 	pid_t				pid;
 	unsigned int			bytes;
 	int				result;
+	struct TCP_Server_Info		*server;
 #ifdef CONFIG_CIFS_SMB_DIRECT
 	struct smbd_mr			*mr;
 #endif

commit 82e9367c43890cb6a870f700c9180c7eb2035684
Author: Steve French <stfrench@microsoft.com>
Date:   Tue May 19 03:06:57 2020 -0500

    smb3: Add new parm "nodelete"
    
    In order to handle workloads where it is important to make sure that
    a buggy app did not delete content on the drive, the new mount option
    "nodelete" allows standard permission checks on the server to work,
    but prevents on the client any attempts to unlink a file or delete
    a directory on that mount point.  This can be helpful when running
    a little understood app on a network mount that contains important
    content that should not be deleted.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 39b708d9d86d..4d261fd78fcb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -562,6 +562,7 @@ struct smb_vol {
 	bool override_gid:1;
 	bool dynperm:1;
 	bool noperm:1;
+	bool nodelete:1;
 	bool mode_ace:1;
 	bool no_psx_acl:1; /* set if posix acl support should be disabled */
 	bool cifs_acl:1;
@@ -1136,6 +1137,7 @@ struct cifs_tcon {
 	bool retry:1;
 	bool nocase:1;
 	bool nohandlecache:1; /* if strange server resource prob can turn off */
+	bool nodelete:1;
 	bool seal:1;      /* transport encryption for this mounted share */
 	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */

commit d92c7ce41eb7f5d7d9f680a935d59552c5518d3c
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Apr 21 23:51:18 2020 -0500

    cifs: minor update to comments around the cifs_tcp_ses_lock mutex
    
    Update comment to note that it protects server->dstaddr
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 05dd3dea684b..39b708d9d86d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1891,7 +1891,8 @@ GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;
 /*
  * This lock protects the cifs_tcp_ses_list, the list of smb sessions per
  * tcp session, and the list of tcon's per smb session. It also protects
- * the reference counters for the server, smb session, and tcon. Finally,
+ * the reference counters for the server, smb session, and tcon. It also
+ * protects some fields in the TCP_Server_Info struct such as dstaddr. Finally,
  * changes to the tcon->tidStatus should be done while holding this lock.
  * generally the locks should be taken in order tcp_ses_lock before
  * tcon->open_file_lock and that before file->file_info_lock since the

commit 4e8aea30f7751ce7c4b158aa0c04e7744d281cc3
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Apr 9 21:42:18 2020 -0500

    smb3: enable swap on SMB3 mounts
    
    Add experimental support for allowing a swap file to be on an SMB3
    mount.  There are use cases where swapping over a secure network
    filesystem is preferable. In some cases there are no local
    block devices large enough, and network block devices can be
    hard to setup and secure.  And in some cases there are no
    local block devices at all (e.g. with the recent addition of
    remote boot over SMB3 mounts).
    
    There are various enhancements that can be added later e.g.:
    - doing a mandatory byte range lock over the swapfile (until
    the Linux VFS is modified to notify the file system that an open
    is for a swapfile, when the file can be opened "DENY_ALL" to prevent
    others from opening it).
    - pinning more buffers in the underlying transport to minimize memory
    allocations in the TCP stack under the fs
    - documenting how to create ACLs (on the server) to secure the
    swapfile (or adding additional tools to cifs-utils to make it easier)
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7448e7202e7a..05dd3dea684b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1313,6 +1313,7 @@ struct cifsFileInfo {
 	struct tcon_link *tlink;
 	unsigned int f_flags;
 	bool invalidHandle:1;	/* file closed via session abend */
+	bool swapfile:1;
 	bool oplock_break_cancelled:1;
 	unsigned int oplock_epoch; /* epoch from the lease break */
 	__u32 oplock_level; /* oplock/lease level from the lease break */

commit eda1c54f148a86f5e64d4d1d3f62d9ea7f94c17e
Author: Long Li <longli@microsoft.com>
Date:   Tue Mar 31 16:21:43 2020 -0700

    cifs: Allocate crypto structures on the fly for calculating signatures of incoming packets
    
    CIFS uses pre-allocated crypto structures to calculate signatures for both
    incoming and outgoing packets. In this way it doesn't need to allocate crypto
    structures for every packet, but it requires a lock to prevent concurrent
    access to crypto structures.
    
    Remove the lock by allocating crypto structures on the fly for
    incoming packets. At the same time, we can still use pre-allocated crypto
    structures for outgoing packets, as they are already protected by transport
    lock srv_mutex.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0d956360e984..7448e7202e7a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -426,7 +426,8 @@ struct smb_version_operations {
 	/* generate new lease key */
 	void (*new_lease_key)(struct cifs_fid *);
 	int (*generate_signingkey)(struct cifs_ses *);
-	int (*calc_signature)(struct smb_rqst *, struct TCP_Server_Info *);
+	int (*calc_signature)(struct smb_rqst *, struct TCP_Server_Info *,
+				bool allocate_crypto);
 	int (*set_integrity)(const unsigned int, struct cifs_tcon *tcon,
 			     struct cifsFileInfo *src_file);
 	int (*enum_snapshots)(const unsigned int xid, struct cifs_tcon *tcon,

commit 86f740f2aed5ea7fe1aa86dc2df0fb4ab0f71088
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Feb 21 11:19:06 2020 +0100

    cifs: fix rename() by ensuring source handle opened with DELETE bit
    
    To rename a file in SMB2 we open it with the DELETE access and do a
    special SetInfo on it. If the handle is missing the DELETE bit the
    server will fail the SetInfo with STATUS_ACCESS_DENIED.
    
    We currently try to reuse any existing opened handle we have with
    cifs_get_writable_path(). That function looks for handles with WRITE
    access but doesn't check for DELETE, making rename() fail if it finds
    a handle to reuse. Simple reproducer below.
    
    To select handles with the DELETE bit, this patch adds a flag argument
    to cifs_get_writable_path() and find_writable_file() and the existing
    'bool fsuid_only' argument is converted to a flag.
    
    The cifsFileInfo struct only stores the UNIX open mode but not the
    original SMB access flags. Since the DELETE bit is not mapped in that
    mode, this patch stores the access mask in cifs_fid on file open,
    which is accessible from cifsFileInfo.
    
    Simple reproducer:
    
            #include <stdio.h>
            #include <stdlib.h>
            #include <sys/types.h>
            #include <sys/stat.h>
            #include <fcntl.h>
            #include <unistd.h>
            #define E(s) perror(s), exit(1)
    
            int main(int argc, char *argv[])
            {
                    int fd, ret;
                    if (argc != 3) {
                            fprintf(stderr, "Usage: %s A B\n"
                            "create&open A in write mode, "
                            "rename A to B, close A\n", argv[0]);
                            return 0;
                    }
    
                    fd = openat(AT_FDCWD, argv[1], O_WRONLY|O_CREAT|O_SYNC, 0666);
                    if (fd == -1) E("openat()");
    
                    ret = rename(argv[1], argv[2]);
                    if (ret) E("rename()");
    
                    ret = close(fd);
                    if (ret) E("close()");
    
                    return ret;
            }
    
    $ gcc -o bugrename bugrename.c
    $ ./bugrename /mnt/a /mnt/b
    rename(): Permission denied
    
    Fixes: 8de9e86c67ba ("cifs: create a helper to find a writeable handle by path name")
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index de82cfa44b1a..0d956360e984 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1281,6 +1281,7 @@ struct cifs_fid {
 	__u64 volatile_fid;	/* volatile file id for smb2 */
 	__u8 lease_key[SMB2_LEASE_KEY_SIZE];	/* lease key for smb2 */
 	__u8 create_guid[16];
+	__u32 access;
 	struct cifs_pending_open *pending_open;
 	unsigned int epoch;
 #ifdef CONFIG_CIFS_DEBUG2
@@ -1741,6 +1742,12 @@ static inline bool is_retryable_error(int error)
 	return false;
 }
 
+
+/* cifs_get_writable_file() flags */
+#define FIND_WR_ANY         0
+#define FIND_WR_FSUID_ONLY  1
+#define FIND_WR_WITH_DELETE 2
+
 #define   MID_FREE 0
 #define   MID_REQUEST_ALLOCATED 1
 #define   MID_REQUEST_SUBMITTED 2

commit d26c2ddd33569667e3eeb577c4c1d966ca9192e2
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Feb 6 06:00:14 2020 -0600

    cifs: add SMB3 change notification support
    
    A commonly used SMB3 feature is change notification, allowing an
    app to be notified about changes to a directory. The SMB3
    Notify request blocks until the server detects a change to that
    directory or its contents that matches the completion flags
    that were passed in and the "watch_tree" flag (which indicates
    whether subdirectories under this directory should be also
    included).  See MS-SMB2 2.2.35 for additional detail.
    
    To use this simply pass in the following structure to ioctl:
    
     struct __attribute__((__packed__)) smb3_notify {
            uint32_t completion_filter;
            bool    watch_tree;
     } __packed;
    
     using CIFS_IOC_NOTIFY  0x4005cf09
     or equivalently _IOW(CIFS_IOCTL_MAGIC, 9, struct smb3_notify)
    
    SMB3 change notification is supported by all major servers.
    The ioctl will block until the server detects a change to that
    directory or its subdirectories (if watch_tree is set).
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Acked-by: Paulo Alcantara (SUSE) <pc@cjr.nz>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1205041fd966..de82cfa44b1a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -431,6 +431,8 @@ struct smb_version_operations {
 			     struct cifsFileInfo *src_file);
 	int (*enum_snapshots)(const unsigned int xid, struct cifs_tcon *tcon,
 			     struct cifsFileInfo *src_file, void __user *);
+	int (*notify)(const unsigned int xid, struct file *pfile,
+			     void __user *pbuf);
 	int (*query_mf_symlink)(unsigned int, struct cifs_tcon *,
 				struct cifs_sb_info *, const unsigned char *,
 				char *, unsigned int *);

commit 0f060936e490c6279dfe773d75d526d3d3d77111
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Mon Feb 3 21:46:43 2020 +0200

    SMB3: Backup intent flag missing from some more ops
    
    When "backup intent" is requested on the mount (e.g. backupuid or
    backupgid mount options), the corresponding flag was missing from
    some of the operations.
    
    Change all operations to use the macro cifs_create_options() to
    set the backup intent flag if needed.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 239338d57086..1205041fd966 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -298,7 +298,8 @@ struct smb_version_operations {
 			     const char *, struct dfs_info3_param **,
 			     unsigned int *, const struct nls_table *, int);
 	/* informational QFS call */
-	void (*qfs_tcon)(const unsigned int, struct cifs_tcon *);
+	void (*qfs_tcon)(const unsigned int, struct cifs_tcon *,
+			 struct cifs_sb_info *);
 	/* check if a path is accessible or not */
 	int (*is_path_accessible)(const unsigned int, struct cifs_tcon *,
 				  struct cifs_sb_info *, const char *);
@@ -409,7 +410,7 @@ struct smb_version_operations {
 			       struct cifsInodeInfo *);
 	/* query remote filesystem */
 	int (*queryfs)(const unsigned int, struct cifs_tcon *,
-		       struct kstatfs *);
+		       struct cifs_sb_info *, struct kstatfs *);
 	/* send mandatory brlock to the server */
 	int (*mand_lock)(const unsigned int, struct cifsFileInfo *, __u64,
 			 __u64, __u32, int, int, bool);
@@ -490,6 +491,7 @@ struct smb_version_operations {
 	/* ioctl passthrough for query_info */
 	int (*ioctl_query_info)(const unsigned int xid,
 				struct cifs_tcon *tcon,
+				struct cifs_sb_info *cifs_sb,
 				__le16 *path, int is_dir,
 				unsigned long p);
 	/* make unix special files (block, char, fifo, socket) */

commit f1f27ad74557e39f67a8331a808b860f89254f2d
Author: Vincent Whitchurch <vincent.whitchurch@axis.com>
Date:   Thu Jan 23 17:09:06 2020 +0100

    CIFS: Fix task struct use-after-free on reconnect
    
    The task which created the MID may be gone by the time cifsd attempts to
    call the callbacks on MIDs from cifs_reconnect().
    
    This leads to a use-after-free of the task struct in cifs_wake_up_task:
    
     ==================================================================
     BUG: KASAN: use-after-free in __lock_acquire+0x31a0/0x3270
     Read of size 8 at addr ffff8880103e3a68 by task cifsd/630
    
     CPU: 0 PID: 630 Comm: cifsd Not tainted 5.5.0-rc6+ #119
     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014
     Call Trace:
      dump_stack+0x8e/0xcb
      print_address_description.constprop.5+0x1d3/0x3c0
      ? __lock_acquire+0x31a0/0x3270
      __kasan_report+0x152/0x1aa
      ? __lock_acquire+0x31a0/0x3270
      ? __lock_acquire+0x31a0/0x3270
      kasan_report+0xe/0x20
      __lock_acquire+0x31a0/0x3270
      ? __wake_up_common+0x1dc/0x630
      ? _raw_spin_unlock_irqrestore+0x4c/0x60
      ? mark_held_locks+0xf0/0xf0
      ? _raw_spin_unlock_irqrestore+0x39/0x60
      ? __wake_up_common_lock+0xd5/0x130
      ? __wake_up_common+0x630/0x630
      lock_acquire+0x13f/0x330
      ? try_to_wake_up+0xa3/0x19e0
      _raw_spin_lock_irqsave+0x38/0x50
      ? try_to_wake_up+0xa3/0x19e0
      try_to_wake_up+0xa3/0x19e0
      ? cifs_compound_callback+0x178/0x210
      ? set_cpus_allowed_ptr+0x10/0x10
      cifs_reconnect+0xa1c/0x15d0
      ? generic_ip_connect+0x1860/0x1860
      ? rwlock_bug.part.0+0x90/0x90
      cifs_readv_from_socket+0x479/0x690
      cifs_read_from_socket+0x9d/0xe0
      ? cifs_readv_from_socket+0x690/0x690
      ? mempool_resize+0x690/0x690
      ? rwlock_bug.part.0+0x90/0x90
      ? memset+0x1f/0x40
      ? allocate_buffers+0xff/0x340
      cifs_demultiplex_thread+0x388/0x2a50
      ? cifs_handle_standard+0x610/0x610
      ? rcu_read_lock_held_common+0x120/0x120
      ? mark_lock+0x11b/0xc00
      ? __lock_acquire+0x14ed/0x3270
      ? __kthread_parkme+0x78/0x100
      ? lockdep_hardirqs_on+0x3e8/0x560
      ? lock_downgrade+0x6a0/0x6a0
      ? lockdep_hardirqs_on+0x3e8/0x560
      ? _raw_spin_unlock_irqrestore+0x39/0x60
      ? cifs_handle_standard+0x610/0x610
      kthread+0x2bb/0x3a0
      ? kthread_create_worker_on_cpu+0xc0/0xc0
      ret_from_fork+0x3a/0x50
    
     Allocated by task 649:
      save_stack+0x19/0x70
      __kasan_kmalloc.constprop.5+0xa6/0xf0
      kmem_cache_alloc+0x107/0x320
      copy_process+0x17bc/0x5370
      _do_fork+0x103/0xbf0
      __x64_sys_clone+0x168/0x1e0
      do_syscall_64+0x9b/0xec0
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
     Freed by task 0:
      save_stack+0x19/0x70
      __kasan_slab_free+0x11d/0x160
      kmem_cache_free+0xb5/0x3d0
      rcu_core+0x52f/0x1230
      __do_softirq+0x24d/0x962
    
     The buggy address belongs to the object at ffff8880103e32c0
      which belongs to the cache task_struct of size 6016
     The buggy address is located 1960 bytes inside of
      6016-byte region [ffff8880103e32c0, ffff8880103e4a40)
     The buggy address belongs to the page:
     page:ffffea000040f800 refcount:1 mapcount:0 mapping:ffff8880108da5c0
     index:0xffff8880103e4c00 compound_mapcount: 0
     raw: 4000000000010200 ffffea00001f2208 ffffea00001e3408 ffff8880108da5c0
     raw: ffff8880103e4c00 0000000000050003 00000001ffffffff 0000000000000000
     page dumped because: kasan: bad access detected
    
     Memory state around the buggy address:
      ffff8880103e3900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff8880103e3980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     >ffff8880103e3a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                               ^
      ffff8880103e3a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
      ffff8880103e3b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ==================================================================
    
    This can be reliably reproduced by adding the below delay to
    cifs_reconnect(), running find(1) on the mount, restarting the samba
    server while find is running, and killing find during the delay:
    
            spin_unlock(&GlobalMid_Lock);
            mutex_unlock(&server->srv_mutex);
    
     +      msleep(10000);
     +
            cifs_dbg(FYI, "%s: issuing mid callbacks\n", __func__);
            list_for_each_safe(tmp, tmp2, &retry_list) {
                    mid_entry = list_entry(tmp, struct mid_q_entry, qhead);
    
    Fix this by holding a reference to the task struct until the MID is
    freed.
    
    Signed-off-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 40705e862451..239338d57086 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1588,6 +1588,7 @@ struct mid_q_entry {
 	mid_callback_t *callback; /* call completion callback */
 	mid_handle_t *handle; /* call handle mid callback */
 	void *callback_data;	  /* general purpose pointer for callback */
+	struct task_struct *creator;
 	void *resp_buf;		/* pointer to received SMB header */
 	unsigned int resp_buf_size;
 	int mid_state;	/* wish this were enum but can not pass to wait_event */

commit 046aca3c25fd28da591f59a2dc1a01848e81e0b2
Author: Paulo Alcantara (SUSE) <pc@cjr.nz>
Date:   Wed Dec 18 18:11:37 2019 -0300

    cifs: Optimize readdir on reparse points
    
    When listing a directory with thounsands of files and most of them are
    reparse points, we simply marked all those dentries for revalidation
    and then sending additional (compounded) create/getinfo/close requests
    for each of them.
    
    Instead, upon receiving a response from an SMB2_QUERY_DIRECTORY
    (FileIdFullDirectoryInformation) command, the directory entries that
    have a file attribute of FILE_ATTRIBUTE_REPARSE_POINT will contain an
    EaSize field with a reparse tag in it, so we parse it and mark the
    dentry for revalidation only if it is a DFS or a symlink.
    
    Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ce9bac756c2a..40705e862451 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1693,6 +1693,7 @@ struct cifs_fattr {
 	struct timespec64 cf_atime;
 	struct timespec64 cf_mtime;
 	struct timespec64 cf_ctime;
+	u32             cf_cifstag;
 };
 
 static inline void free_dfs_info_param(struct dfs_info3_param *param)

commit d9191319358da13ee6a332fb9bf745f2181a612a
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Tue Dec 10 11:44:52 2019 -0800

    CIFS: Close cached root handle only if it has a lease
    
    SMB2_tdis() checks if a root handle is valid in order to decide
    whether it needs to close the handle or not. However if another
    thread has reference for the handle, it may end up with putting
    the reference twice. The extra reference that we want to put
    during the tree disconnect is the reference that has a directory
    lease. So, track the fact that we have a directory lease and
    close the handle only in that case.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fd0262ce5ad5..ce9bac756c2a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1061,7 +1061,7 @@ cap_unix(struct cifs_ses *ses)
 struct cached_fid {
 	bool is_valid:1;	/* Do we have a useable root fid */
 	bool file_all_info_is_valid:1;
-
+	bool has_lease:1;
 	struct kref refcount;
 	struct cifs_fid *fid;
 	struct mutex fid_mutex;

commit 3345bb44bacd99413a3dc0dcd9a99449d88d4dda
Author: Paulo Alcantara (SUSE) <pc@cjr.nz>
Date:   Wed Dec 4 11:25:06 2019 -0300

    cifs: Fix lookup of SMB connections on multichannel
    
    With the addition of SMB session channels, we introduced new TCP
    server pointers that have no sessions or tcons associated with them.
    
    In this case, when we started looking for TCP connections, we might
    end up picking session channel rather than the master connection,
    hence failing to get either a session or a tcon.
    
    In order to fix that, this patch introduces a new "is_channel" field
    to TCP_Server_Info structure so we can skip session channels during
    lookup of connections.
    
    Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5b976e01dd6b..fd0262ce5ad5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -777,6 +777,7 @@ struct TCP_Server_Info {
 	 */
 	int nr_targets;
 	bool noblockcnt; /* use non-blocking connect() */
+	bool is_channel; /* if a session channel */
 };
 
 struct cifs_credits {

commit 43f8a6a74ee2442b9410ed297f5d4c77e7cb5ace
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Dec 2 21:46:54 2019 -0600

    smb3: query attributes on file close
    
    Since timestamps on files on most servers can be updated at
    close, and since timestamps on our dentries default to one
    second we can have stale timestamps in some common cases
    (e.g. open, write, close, stat, wait one second, stat - will
    show different mtime for the first and second stat).
    
    The SMB2/SMB3 protocol allows querying timestamps at close
    so add the code to request timestamp and attr information
    (which is cheap for the server to provide) to be returned
    when a file is closed (it is not needed for the many
    paths that call SMB2_close that are from compounded
    query infos and close nor is it needed for some of
    the cases where a directory close immediately follows a
    directory open.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d34a4ed8c57d..5b976e01dd6b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -368,6 +368,9 @@ struct smb_version_operations {
 	/* close a file */
 	void (*close)(const unsigned int, struct cifs_tcon *,
 		      struct cifs_fid *);
+	/* close a file, returning file attributes and timestamps */
+	void (*close_getattr)(const unsigned int xid, struct cifs_tcon *tcon,
+		      struct cifsFileInfo *pfile_info);
 	/* send a flush request to the server */
 	int (*flush)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
 	/* async read from the server */

commit 1ae9a5a5515729f43b2513bba68a462f240b3e04
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Nov 21 17:26:35 2019 -0600

    smb3: dump in_send and num_waiters stats counters by default
    
    Number of requests in_send and the number of waiters on sendRecv
    are useful counters in various cases, move them from
    CONFIG_CIFS_STATS2 to be on by default especially with multichannel
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2fc3d77463d3..d34a4ed8c57d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -743,12 +743,12 @@ struct TCP_Server_Info {
 	/* Total size of this PDU. Only valid from cifs_demultiplex_thread */
 	unsigned int pdu_size;
 	unsigned int total_read; /* total amount of data read in this pass */
+	atomic_t in_send; /* requests trying to send */
+	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie   *fscache; /* client index cache cookie */
 #endif
 #ifdef CONFIG_CIFS_STATS2
-	atomic_t in_send; /* requests trying to send */
-	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
 	atomic_t num_cmds[NUMBER_OF_SMB2_COMMANDS]; /* total requests by cmd */
 	atomic_t smb2slowcmd[NUMBER_OF_SMB2_COMMANDS]; /* count resps > 1 sec */
 	__u64 time_per_cmd[NUMBER_OF_SMB2_COMMANDS]; /* total time per cmd */
@@ -1606,8 +1606,6 @@ struct close_cancelled_open {
 
 /*	Make code in transport.c a little cleaner by moving
 	update of optional stats into function below */
-#ifdef CONFIG_CIFS_STATS2
-
 static inline void cifs_in_send_inc(struct TCP_Server_Info *server)
 {
 	atomic_inc(&server->in_send);
@@ -1628,26 +1626,12 @@ static inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)
 	atomic_dec(&server->num_waiters);
 }
 
+#ifdef CONFIG_CIFS_STATS2
 static inline void cifs_save_when_sent(struct mid_q_entry *mid)
 {
 	mid->when_sent = jiffies;
 }
 #else
-static inline void cifs_in_send_inc(struct TCP_Server_Info *server)
-{
-}
-static inline void cifs_in_send_dec(struct TCP_Server_Info *server)
-{
-}
-
-static inline void cifs_num_waiters_inc(struct TCP_Server_Info *server)
-{
-}
-
-static inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)
-{
-}
-
 static inline void cifs_save_when_sent(struct mid_q_entry *mid)
 {
 }

commit 9bd4540836684013aaad6070a65d6fcdd9006625
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Tue Oct 29 16:51:19 2019 -0700

    CIFS: Properly process SMB3 lease breaks
    
    Currenly we doesn't assume that a server may break a lease
    from RWH to RW which causes us setting a wrong lease state
    on a file and thus mistakenly flushing data and byte-range
    locks and purging cached data on the client. This leads to
    performance degradation because subsequent IOs go directly
    to the server.
    
    Fix this by propagating new lease state and epoch values
    to the oplock break handler through cifsFileInfo structure
    and removing the use of cifsInodeInfo flags for that. It
    allows to avoid some races of several lease/oplock breaks
    using those flags in parallel.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9560dd58a9bf..2fc3d77463d3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -269,8 +269,9 @@ struct smb_version_operations {
 	int (*check_message)(char *, unsigned int, struct TCP_Server_Info *);
 	bool (*is_oplock_break)(char *, struct TCP_Server_Info *);
 	int (*handle_cancelled_mid)(char *, struct TCP_Server_Info *);
-	void (*downgrade_oplock)(struct TCP_Server_Info *,
-					struct cifsInodeInfo *, bool);
+	void (*downgrade_oplock)(struct TCP_Server_Info *server,
+				 struct cifsInodeInfo *cinode, __u32 oplock,
+				 unsigned int epoch, bool *purge_cache);
 	/* process transaction2 response */
 	bool (*check_trans2)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     char *, int);
@@ -1303,6 +1304,8 @@ struct cifsFileInfo {
 	unsigned int f_flags;
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
+	unsigned int oplock_epoch; /* epoch from the lease break */
+	__u32 oplock_level; /* oplock/lease level from the lease break */
 	int count;
 	spinlock_t file_info_lock; /* protects four flag/count fields above */
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
@@ -1450,7 +1453,7 @@ struct cifsInodeInfo {
 	unsigned int epoch;		/* used to track lease state changes */
 #define CIFS_INODE_PENDING_OPLOCK_BREAK   (0) /* oplock break in progress */
 #define CIFS_INODE_PENDING_WRITERS	  (1) /* Writes in progress */
-#define CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2 (2) /* Downgrade oplock to L2 */
+#define CIFS_INODE_FLAG_UNUSED		  (2) /* Unused flag */
 #define CIFS_INO_DELETE_PENDING		  (3) /* delete pending on server */
 #define CIFS_INO_INVALID_MAPPING	  (4) /* pagecache is invalid */
 #define CIFS_INO_LOCK			  (5) /* lock bit for synchronization */

commit 32546a9586aa4565035bb557e191648e022b29e8
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Sun Nov 3 13:06:37 2019 +1000

    cifs: move cifsFileInfo_put logic into a work-queue
    
    This patch moves the final part of the cifsFileInfo_put() logic where we
    need a write lock on lock_sem to be processed in a separate thread that
    holds no other locks.
    This is to prevent deadlocks like the one below:
    
    > there are 6 processes looping to while trying to down_write
    > cinode->lock_sem, 5 of them from _cifsFileInfo_put, and one from
    > cifs_new_fileinfo
    >
    > and there are 5 other processes which are blocked, several of them
    > waiting on either PG_writeback or PG_locked (which are both set), all
    > for the same page of the file
    >
    > 2 inode_lock() (inode->i_rwsem) for the file
    > 1 wait_on_page_writeback() for the page
    > 1 down_read(inode->i_rwsem) for the inode of the directory
    > 1 inode_lock()(inode->i_rwsem) for the inode of the directory
    > 1 __lock_page
    >
    >
    > so processes are blocked waiting on:
    >   page flags PG_locked and PG_writeback for one specific page
    >   inode->i_rwsem for the directory
    >   inode->i_rwsem for the file
    >   cifsInodeInflock_sem
    >
    >
    >
    > here are the more gory details (let me know if I need to provide
    > anything more/better):
    >
    > [0 00:48:22.765] [UN]  PID: 8863   TASK: ffff8c691547c5c0  CPU: 3
    > COMMAND: "reopen_file"
    >  #0 [ffff9965007e3ba8] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965007e3c38] schedule at ffffffff9b6e64df
    >  #2 [ffff9965007e3c48] rwsem_down_write_slowpath at ffffffff9af283d7
    >  #3 [ffff9965007e3cb8] legitimize_path at ffffffff9b0f975d
    >  #4 [ffff9965007e3d08] path_openat at ffffffff9b0fe55d
    >  #5 [ffff9965007e3dd8] do_filp_open at ffffffff9b100a33
    >  #6 [ffff9965007e3ee0] do_sys_open at ffffffff9b0eb2d6
    >  #7 [ffff9965007e3f38] do_syscall_64 at ffffffff9ae04315
    > * (I think legitimize_path is bogus)
    >
    > in path_openat
    >         } else {
    >                 const char *s = path_init(nd, flags);
    >                 while (!(error = link_path_walk(s, nd)) &&
    >                         (error = do_last(nd, file, op)) > 0) {  <<<<
    >
    > do_last:
    >         if (open_flag & O_CREAT)
    >                 inode_lock(dir->d_inode);  <<<<
    >         else
    > so it's trying to take inode->i_rwsem for the directory
    >
    >      DENTRY           INODE           SUPERBLK     TYPE PATH
    > ffff8c68bb8e79c0 ffff8c691158ef20 ffff8c6915bf9000 DIR  /mnt/vm1_smb/
    > inode.i_rwsem is ffff8c691158efc0
    >
    > <struct rw_semaphore 0xffff8c691158efc0>:
    >         owner: <struct task_struct 0xffff8c6914275d00> (UN -   8856 -
    > reopen_file), counter: 0x0000000000000003
    >         waitlist: 2
    >         0xffff9965007e3c90     8863   reopen_file      UN 0  1:29:22.926
    >   RWSEM_WAITING_FOR_WRITE
    >         0xffff996500393e00     9802   ls               UN 0  1:17:26.700
    >   RWSEM_WAITING_FOR_READ
    >
    >
    > the owner of the inode.i_rwsem of the directory is:
    >
    > [0 00:00:00.109] [UN]  PID: 8856   TASK: ffff8c6914275d00  CPU: 3
    > COMMAND: "reopen_file"
    >  #0 [ffff99650065b828] __schedule at ffffffff9b6e6095
    >  #1 [ffff99650065b8b8] schedule at ffffffff9b6e64df
    >  #2 [ffff99650065b8c8] schedule_timeout at ffffffff9b6e9f89
    >  #3 [ffff99650065b940] msleep at ffffffff9af573a9
    >  #4 [ffff99650065b948] _cifsFileInfo_put.cold.63 at ffffffffc0a42dd6 [cifs]
    >  #5 [ffff99650065ba38] cifs_writepage_locked at ffffffffc0a0b8f3 [cifs]
    >  #6 [ffff99650065bab0] cifs_launder_page at ffffffffc0a0bb72 [cifs]
    >  #7 [ffff99650065bb30] invalidate_inode_pages2_range at ffffffff9b04d4bd
    >  #8 [ffff99650065bcb8] cifs_invalidate_mapping at ffffffffc0a11339 [cifs]
    >  #9 [ffff99650065bcd0] cifs_revalidate_mapping at ffffffffc0a1139a [cifs]
    > #10 [ffff99650065bcf0] cifs_d_revalidate at ffffffffc0a014f6 [cifs]
    > #11 [ffff99650065bd08] path_openat at ffffffff9b0fe7f7
    > #12 [ffff99650065bdd8] do_filp_open at ffffffff9b100a33
    > #13 [ffff99650065bee0] do_sys_open at ffffffff9b0eb2d6
    > #14 [ffff99650065bf38] do_syscall_64 at ffffffff9ae04315
    >
    > cifs_launder_page is for page 0xffffd1e2c07d2480
    >
    > crash> page.index,mapping,flags 0xffffd1e2c07d2480
    >       index = 0x8
    >       mapping = 0xffff8c68f3cd0db0
    >   flags = 0xfffffc0008095
    >
    >   PAGE-FLAG       BIT  VALUE
    >   PG_locked         0  0000001
    >   PG_uptodate       2  0000004
    >   PG_lru            4  0000010
    >   PG_waiters        7  0000080
    >   PG_writeback     15  0008000
    >
    >
    > inode is ffff8c68f3cd0c40
    > inode.i_rwsem is ffff8c68f3cd0ce0
    >      DENTRY           INODE           SUPERBLK     TYPE PATH
    > ffff8c68a1f1b480 ffff8c68f3cd0c40 ffff8c6915bf9000 REG
    > /mnt/vm1_smb/testfile.8853
    >
    >
    > this process holds the inode->i_rwsem for the parent directory, is
    > laundering a page attached to the inode of the file it's opening, and in
    > _cifsFileInfo_put is trying to down_write the cifsInodeInflock_sem
    > for the file itself.
    >
    >
    > <struct rw_semaphore 0xffff8c68f3cd0ce0>:
    >         owner: <struct task_struct 0xffff8c6914272e80> (UN -   8854 -
    > reopen_file), counter: 0x0000000000000003
    >         waitlist: 1
    >         0xffff9965005dfd80     8855   reopen_file      UN 0  1:29:22.912
    >   RWSEM_WAITING_FOR_WRITE
    >
    > this is the inode.i_rwsem for the file
    >
    > the owner:
    >
    > [0 00:48:22.739] [UN]  PID: 8854   TASK: ffff8c6914272e80  CPU: 2
    > COMMAND: "reopen_file"
    >  #0 [ffff99650054fb38] __schedule at ffffffff9b6e6095
    >  #1 [ffff99650054fbc8] schedule at ffffffff9b6e64df
    >  #2 [ffff99650054fbd8] io_schedule at ffffffff9b6e68e2
    >  #3 [ffff99650054fbe8] __lock_page at ffffffff9b03c56f
    >  #4 [ffff99650054fc80] pagecache_get_page at ffffffff9b03dcdf
    >  #5 [ffff99650054fcc0] grab_cache_page_write_begin at ffffffff9b03ef4c
    >  #6 [ffff99650054fcd0] cifs_write_begin at ffffffffc0a064ec [cifs]
    >  #7 [ffff99650054fd30] generic_perform_write at ffffffff9b03bba4
    >  #8 [ffff99650054fda8] __generic_file_write_iter at ffffffff9b04060a
    >  #9 [ffff99650054fdf0] cifs_strict_writev.cold.70 at ffffffffc0a4469b [cifs]
    > #10 [ffff99650054fe48] new_sync_write at ffffffff9b0ec1dd
    > #11 [ffff99650054fed0] vfs_write at ffffffff9b0eed35
    > #12 [ffff99650054ff00] ksys_write at ffffffff9b0eefd9
    > #13 [ffff99650054ff38] do_syscall_64 at ffffffff9ae04315
    >
    > the process holds the inode->i_rwsem for the file to which it's writing,
    > and is trying to __lock_page for the same page as in the other processes
    >
    >
    > the other tasks:
    > [0 00:00:00.028] [UN]  PID: 8859   TASK: ffff8c6915479740  CPU: 2
    > COMMAND: "reopen_file"
    >  #0 [ffff9965007b39d8] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965007b3a68] schedule at ffffffff9b6e64df
    >  #2 [ffff9965007b3a78] schedule_timeout at ffffffff9b6e9f89
    >  #3 [ffff9965007b3af0] msleep at ffffffff9af573a9
    >  #4 [ffff9965007b3af8] cifs_new_fileinfo.cold.61 at ffffffffc0a42a07 [cifs]
    >  #5 [ffff9965007b3b78] cifs_open at ffffffffc0a0709d [cifs]
    >  #6 [ffff9965007b3cd8] do_dentry_open at ffffffff9b0e9b7a
    >  #7 [ffff9965007b3d08] path_openat at ffffffff9b0fe34f
    >  #8 [ffff9965007b3dd8] do_filp_open at ffffffff9b100a33
    >  #9 [ffff9965007b3ee0] do_sys_open at ffffffff9b0eb2d6
    > #10 [ffff9965007b3f38] do_syscall_64 at ffffffff9ae04315
    >
    > this is opening the file, and is trying to down_write cinode->lock_sem
    >
    >
    > [0 00:00:00.041] [UN]  PID: 8860   TASK: ffff8c691547ae80  CPU: 2
    > COMMAND: "reopen_file"
    > [0 00:00:00.057] [UN]  PID: 8861   TASK: ffff8c6915478000  CPU: 3
    > COMMAND: "reopen_file"
    > [0 00:00:00.059] [UN]  PID: 8858   TASK: ffff8c6914271740  CPU: 2
    > COMMAND: "reopen_file"
    > [0 00:00:00.109] [UN]  PID: 8862   TASK: ffff8c691547dd00  CPU: 6
    > COMMAND: "reopen_file"
    >  #0 [ffff9965007c3c78] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965007c3d08] schedule at ffffffff9b6e64df
    >  #2 [ffff9965007c3d18] schedule_timeout at ffffffff9b6e9f89
    >  #3 [ffff9965007c3d90] msleep at ffffffff9af573a9
    >  #4 [ffff9965007c3d98] _cifsFileInfo_put.cold.63 at ffffffffc0a42dd6 [cifs]
    >  #5 [ffff9965007c3e88] cifs_close at ffffffffc0a07aaf [cifs]
    >  #6 [ffff9965007c3ea0] __fput at ffffffff9b0efa6e
    >  #7 [ffff9965007c3ee8] task_work_run at ffffffff9aef1614
    >  #8 [ffff9965007c3f20] exit_to_usermode_loop at ffffffff9ae03d6f
    >  #9 [ffff9965007c3f38] do_syscall_64 at ffffffff9ae0444c
    >
    > closing the file, and trying to down_write cifsi->lock_sem
    >
    >
    > [0 00:48:22.839] [UN]  PID: 8857   TASK: ffff8c6914270000  CPU: 7
    > COMMAND: "reopen_file"
    >  #0 [ffff9965006a7cc8] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965006a7d58] schedule at ffffffff9b6e64df
    >  #2 [ffff9965006a7d68] io_schedule at ffffffff9b6e68e2
    >  #3 [ffff9965006a7d78] wait_on_page_bit at ffffffff9b03cac6
    >  #4 [ffff9965006a7e10] __filemap_fdatawait_range at ffffffff9b03b028
    >  #5 [ffff9965006a7ed8] filemap_write_and_wait at ffffffff9b040165
    >  #6 [ffff9965006a7ef0] cifs_flush at ffffffffc0a0c2fa [cifs]
    >  #7 [ffff9965006a7f10] filp_close at ffffffff9b0e93f1
    >  #8 [ffff9965006a7f30] __x64_sys_close at ffffffff9b0e9a0e
    >  #9 [ffff9965006a7f38] do_syscall_64 at ffffffff9ae04315
    >
    > in __filemap_fdatawait_range
    >                         wait_on_page_writeback(page);
    > for the same page of the file
    >
    >
    >
    > [0 00:48:22.718] [UN]  PID: 8855   TASK: ffff8c69142745c0  CPU: 7
    > COMMAND: "reopen_file"
    >  #0 [ffff9965005dfc98] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965005dfd28] schedule at ffffffff9b6e64df
    >  #2 [ffff9965005dfd38] rwsem_down_write_slowpath at ffffffff9af283d7
    >  #3 [ffff9965005dfdf0] cifs_strict_writev at ffffffffc0a0c40a [cifs]
    >  #4 [ffff9965005dfe48] new_sync_write at ffffffff9b0ec1dd
    >  #5 [ffff9965005dfed0] vfs_write at ffffffff9b0eed35
    >  #6 [ffff9965005dff00] ksys_write at ffffffff9b0eefd9
    >  #7 [ffff9965005dff38] do_syscall_64 at ffffffff9ae04315
    >
    >         inode_lock(inode);
    >
    >
    > and one 'ls' later on, to see whether the rest of the mount is available
    > (the test file is in the root, so we get blocked up on the directory
    > ->i_rwsem), so the entire mount is unavailable
    >
    > [0 00:36:26.473] [UN]  PID: 9802   TASK: ffff8c691436ae80  CPU: 4
    > COMMAND: "ls"
    >  #0 [ffff996500393d28] __schedule at ffffffff9b6e6095
    >  #1 [ffff996500393db8] schedule at ffffffff9b6e64df
    >  #2 [ffff996500393dc8] rwsem_down_read_slowpath at ffffffff9b6e9421
    >  #3 [ffff996500393e78] down_read_killable at ffffffff9b6e95e2
    >  #4 [ffff996500393e88] iterate_dir at ffffffff9b103c56
    >  #5 [ffff996500393ec8] ksys_getdents64 at ffffffff9b104b0c
    >  #6 [ffff996500393f30] __x64_sys_getdents64 at ffffffff9b104bb6
    >  #7 [ffff996500393f38] do_syscall_64 at ffffffff9ae04315
    >
    > in iterate_dir:
    >         if (shared)
    >                 res = down_read_killable(&inode->i_rwsem);  <<<<
    >         else
    >                 res = down_write_killable(&inode->i_rwsem);
    >
    
    Reported-by: Frank Sorenson <sorenson@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5254a09fcc35..9560dd58a9bf 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1308,6 +1308,7 @@ struct cifsFileInfo {
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 	struct work_struct oplock_break; /* work for oplock breaks */
+	struct work_struct put; /* work for the final part of _put */
 };
 
 struct cifs_io_parms {
@@ -1413,7 +1414,8 @@ cifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)
 }
 
 struct cifsFileInfo *cifsFileInfo_get(struct cifsFileInfo *cifs_file);
-void _cifsFileInfo_put(struct cifsFileInfo *cifs_file, bool wait_oplock_hdlr);
+void _cifsFileInfo_put(struct cifsFileInfo *cifs_file, bool wait_oplock_hdlr,
+		       bool offload);
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 
 #define CIFS_CACHE_READ_FLG	1
@@ -1953,6 +1955,7 @@ void cifs_queue_oplock_break(struct cifsFileInfo *cfile);
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;
 extern struct workqueue_struct *decrypt_wq;
+extern struct workqueue_struct *fileinfo_put_wq;
 extern struct workqueue_struct *cifsoplockd_wq;
 extern __u32 cifs_lock_secret;
 

commit d70e9fa55884760b6d6c293dbf20d8c52ce11fb7
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Sep 20 06:31:10 2019 +0200

    cifs: try opening channels after mounting
    
    After doing mount() successfully we call cifs_try_adding_channels()
    which will open as many channels as it can.
    
    Channels are closed when the master session is closed.
    
    The master connection becomes the first channel.
    
    ,-------------> global cifs_tcp_ses_list <-------------------------.
    |                                                                  |
    '- TCP_Server_Info  <-->  TCP_Server_Info  <-->  TCP_Server_Info <-'
          (master con)           (chan#1 con)         (chan#2 con)
          |      ^                    ^                    ^
          v      '--------------------|--------------------'
       cifs_ses                       |
       - chan_count = 3               |
       - chans[] ---------------------'
       - smb3signingkey[]
          (master signing key)
    
    Note how channel connections don't have sessions. That's because
    cifs_ses can only be part of one linked list (list_head are internal
    to the elements).
    
    For signing keys, each channel has its own signing key which must be
    used only after the channel has been bound. While it's binding it must
    use the master session signing key.
    
    For encryption keys, since channel connections do not have sessions
    attached we must now find matching session by looping over all sessions
    in smb2_get_enc_key().
    
    Each channel is opened like a regular server connection but at the
    session setup request step it must set the
    SMB2_SESSION_REQ_FLAG_BINDING flag and use the session id to bind to.
    
    Finally, while sending in compound_send_recv() for requests that
    aren't negprot, ses-setup or binding related, use a channel by cycling
    through the available ones (round-robin).
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6bd917b4ee1d..5254a09fcc35 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1001,6 +1001,8 @@ struct cifs_ses {
 	__u8 smb3decryptionkey[SMB3_SIGN_KEY_SIZE];
 	__u8 preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
 
+	__u8 binding_preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
+
 	/*
 	 * Network interfaces available on the server this session is
 	 * connected to.
@@ -1022,6 +1024,20 @@ struct cifs_ses {
 	atomic_t chan_seq; /* round robin state */
 };
 
+/*
+ * When binding a new channel, we need to access the channel which isn't fully
+ * established yet (one past the established count)
+ */
+
+static inline
+struct cifs_chan *cifs_ses_binding_channel(struct cifs_ses *ses)
+{
+	if (ses->binding)
+		return &ses->chans[ses->chan_count];
+	else
+		return NULL;
+}
+
 static inline
 struct TCP_Server_Info *cifs_ses_server(struct cifs_ses *ses)
 {

commit b8f7442bc46e48fb6fe5d7bc3e1ac1500ce649a9
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Mon Nov 18 21:04:08 2019 +0100

    CIFS: refactor cifs_get_inode_info()
    
    Make logic of cifs_get_inode() much clearer by moving code to sub
    functions and adding comments.
    
    Document the steps this function does.
    
    cifs_get_inode_info() gets and updates a file inode metadata from its
    file path.
    
    * If caller already has raw info data from server they can pass it.
    * If inode already exists (just need to update) caller can pass it.
    
    Step 1: get raw data from server if none was passed
    Step 2: parse raw data into intermediate internal cifs_fattr struct
    Step 3: set fattr uniqueid which is later used for inode number. This
            can sometime be done from raw data
    Step 4: tweak fattr according to mount options (file_mode, acl to mode
            bits, uid, gid, etc)
    Step 5: update or create inode from final fattr struct
    
    * add is_smb1_server() helper
    * add is_inode_cache_good() helper
    * move SMB1-backupcreds-getinfo-retry to separate func
      cifs_backup_query_path_info().
    * move set-uniqueid code to separate func cifs_set_fattr_ino()
    * don't clobber uniqueid from backup cred retry
    * fix some probable corner cases memleaks
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 478b913f6f79..6bd917b4ee1d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1967,4 +1967,10 @@ extern struct smb_version_values smb302_values;
 #define ALT_SMB311_VERSION_STRING "3.11"
 extern struct smb_version_operations smb311_operations;
 extern struct smb_version_values smb311_values;
+
+static inline bool is_smb1_server(struct TCP_Server_Info *server)
+{
+	return strcmp(server->vals->version_string, SMB1_VERSION_STRING) == 0;
+}
+
 #endif	/* _CIFS_GLOB_H */

commit f6a6bf7c4d53837767125e635e7d7d0dc48ee59e
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Sep 20 06:22:14 2019 +0200

    cifs: switch servers depending on binding state
    
    Currently a lot of the code to initialize a connection & session uses
    the cifs_ses as input. But depending on if we are opening a new session
    or a new channel we need to use different server pointers.
    
    Add a "binding" flag in cifs_ses and a helper function that returns
    the server ptr a session should use (only in the sess establishment
    code path).
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 170a4643e5cb..478b913f6f79 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -994,6 +994,7 @@ struct cifs_ses {
 	bool sign;		/* is signing required? */
 	bool need_reconnect:1; /* connection reset, uid now invalid */
 	bool domainAuto:1;
+	bool binding:1; /* are we binding the session? */
 	__u16 session_flags;
 	__u8 smb3signingkey[SMB3_SIGN_KEY_SIZE];
 	__u8 smb3encryptionkey[SMB3_SIGN_KEY_SIZE];
@@ -1021,6 +1022,15 @@ struct cifs_ses {
 	atomic_t chan_seq; /* round robin state */
 };
 
+static inline
+struct TCP_Server_Info *cifs_ses_server(struct cifs_ses *ses)
+{
+	if (ses->binding)
+		return ses->chans[ses->chan_count].server;
+	else
+		return ses->server;
+}
+
 static inline bool
 cap_unix(struct cifs_ses *ses)
 {

commit f780bd3fef17c4fda12e9c50e28e91c0e18cf448
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Sep 20 06:08:34 2019 +0200

    cifs: add server param
    
    As we get down to the transport layer, plenty of functions are passed
    the session pointer and assume the transport to use is ses->server.
    
    Instead we modify those functions to pass (ses, server) so that we
    can decouple the session from the server.
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ac3710415f80..170a4643e5cb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -230,7 +230,8 @@ struct smb_version_operations {
 	bool (*compare_fids)(struct cifsFileInfo *, struct cifsFileInfo *);
 	/* setup request: allocate mid, sign message */
 	struct mid_q_entry *(*setup_request)(struct cifs_ses *,
-						struct smb_rqst *);
+					     struct TCP_Server_Info *,
+					     struct smb_rqst *);
 	/* setup async request: allocate mid, sign message */
 	struct mid_q_entry *(*setup_async_request)(struct TCP_Server_Info *,
 						struct smb_rqst *);

commit bcc8880115bcb36bc281c7f4895a12b51569d8d4
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Sep 20 04:32:20 2019 +0200

    cifs: add multichannel mount options and data structs
    
    adds:
    - [no]multichannel to enable/disable multichannel
    - max_channels=N to control how many channels to create
    
    these options are then stored in the volume struct.
    
    - store channels and max_channels in cifs_ses
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 57453226469d..ac3710415f80 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -591,6 +591,10 @@ struct smb_vol {
 	bool resilient:1; /* noresilient not required since not fored for CA */
 	bool domainauto:1;
 	bool rdma:1;
+	bool multichannel:1;
+	bool use_client_guid:1;
+	/* reuse existing guid for multichannel */
+	u8 client_guid[SMB2_CLIENT_GUID_SIZE];
 	unsigned int bsize;
 	unsigned int rsize;
 	unsigned int wsize;
@@ -607,6 +611,7 @@ struct smb_vol {
 	__u64 snapshot_time; /* needed for timewarp tokens */
 	__u32 handle_timeout; /* persistent and durable handle timeout in ms */
 	unsigned int max_credits; /* smb3 max_credits 10 < credits < 60000 */
+	unsigned int max_channels;
 	__u16 compression; /* compression algorithm 0xFFFF default 0=disabled */
 	bool rootfs:1; /* if it's a SMB root file system */
 };
@@ -953,6 +958,11 @@ struct cifs_server_iface {
 	struct sockaddr_storage sockaddr;
 };
 
+struct cifs_chan {
+	struct TCP_Server_Info *server;
+	__u8 signkey[SMB3_SIGN_KEY_SIZE];
+};
+
 /*
  * Session structure.  One of these for each uid session with a particular host
  */
@@ -1002,6 +1012,12 @@ struct cifs_ses {
 	struct cifs_server_iface *iface_list;
 	size_t iface_count;
 	unsigned long iface_last_update; /* jiffies */
+
+#define CIFS_MAX_CHANNELS 16
+	struct cifs_chan chans[CIFS_MAX_CHANNELS];
+	size_t chan_count;
+	size_t chan_max;
+	atomic_t chan_seq; /* round robin state */
 };
 
 static inline bool

commit 87bc2376fffae6821869c988edbb45a14527b258
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Nov 14 12:32:12 2019 -0600

    smb3: add debug messages for closing unmatched open
    
    Helps distinguish between an interrupted close and a truly
    unmatched open.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5d2dd04b55a6..57453226469d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1552,6 +1552,8 @@ struct close_cancelled_open {
 	struct cifs_fid         fid;
 	struct cifs_tcon        *tcon;
 	struct work_struct      work;
+	__u64 mid;
+	__u16 cmd;
 };
 
 /*	Make code in transport.c a little cleaner by moving

commit 86a7964be7afaf3df6b64faaa10a7032d2444e51
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Thu Nov 21 11:35:13 2019 -0800

    CIFS: Fix NULL pointer dereference in mid callback
    
    There is a race between a system call processing thread
    and the demultiplex thread when mid->resp_buf becomes NULL
    and later is being accessed to get credits. It happens when
    the 1st thread wakes up before a mid callback is called in
    the 2nd one but the mid state has already been set to
    MID_RESPONSE_RECEIVED. This causes NULL pointer dereference
    in mid callback.
    
    Fix this by saving credits from the response before we
    update the mid state and then use this value in the mid
    callback rather then accessing a response buffer.
    
    Cc: Stable <stable@vger.kernel.org>
    Fixes: ee258d79159afed5 ("CIFS: Move credit processing to mid callbacks for SMB3")
    Tested-by: Frank Sorenson <sorenson@redhat.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d78bfcc19156..5d2dd04b55a6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1524,6 +1524,7 @@ struct mid_q_entry {
 	struct TCP_Server_Info *server;	/* server corresponding to this mid */
 	__u64 mid;		/* multiplex id */
 	__u16 credits;		/* number of credits consumed by this mid */
+	__u16 credits_received;	/* number of credits from the response */
 	__u32 pid;		/* process id */
 	__u32 sequence_number;  /* for CIFS signing */
 	unsigned long when_alloc;  /* when mid was created */

commit d46b0da7a33dd8c99d969834f682267a45444ab3
Author: Dave Wysochanski <dwysocha@redhat.com>
Date:   Wed Oct 23 05:02:33 2019 -0400

    cifs: Fix cifsInodeInfo lock_sem deadlock when reconnect occurs
    
    There's a deadlock that is possible and can easily be seen with
    a test where multiple readers open/read/close of the same file
    and a disruption occurs causing reconnect.  The deadlock is due
    a reader thread inside cifs_strict_readv calling down_read and
    obtaining lock_sem, and then after reconnect inside
    cifs_reopen_file calling down_read a second time.  If in
    between the two down_read calls, a down_write comes from
    another process, deadlock occurs.
    
            CPU0                    CPU1
            ----                    ----
    cifs_strict_readv()
     down_read(&cifsi->lock_sem);
                                   _cifsFileInfo_put
                                      OR
                                   cifs_new_fileinfo
                                    down_write(&cifsi->lock_sem);
    cifs_reopen_file()
     down_read(&cifsi->lock_sem);
    
    Fix the above by changing all down_write(lock_sem) calls to
    down_write_trylock(lock_sem)/msleep() loop, which in turn
    makes the second down_read call benign since it will never
    block behind the writer while holding lock_sem.
    
    Signed-off-by: Dave Wysochanski <dwysocha@redhat.com>
    Suggested-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed--by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 50dfd9049370..d78bfcc19156 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1391,6 +1391,11 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 struct cifsInodeInfo {
 	bool can_cache_brlcks;
 	struct list_head llist;	/* locks helb by this inode */
+	/*
+	 * NOTE: Some code paths call down_read(lock_sem) twice, so
+	 * we must always use use cifs_down_write() instead of down_write()
+	 * for this semaphore to avoid deadlocks.
+	 */
 	struct rw_semaphore lock_sem;	/* protect the fields above */
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;

commit d0959b080b1faa9741857ef607c90531b66e2fb8
Author: Steve French <stfrench@microsoft.com>
Date:   Sat Oct 5 10:53:58 2019 -0500

    smb3: remove noisy debug message and minor cleanup
    
    Message was intended only for developer temporary build
    In addition cleanup two minor warnings noticed by Coverity
    and a trivial change to workaround a sparse warning
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2e960e1049db..50dfd9049370 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1210,7 +1210,7 @@ struct cifs_search_info {
 	bool smallBuf:1; /* so we know which buf_release function to call */
 };
 
-#define ACL_NO_MODE	-1
+#define ACL_NO_MODE	((umode_t)(-1))
 struct cifs_open_parms {
 	struct cifs_tcon *tcon;
 	struct cifs_sb_info *cifs_sb;

commit c3ca78e2174413c136d62ebdf8039580fe72b504
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Sep 25 00:32:13 2019 -0500

    smb3: pass mode bits into create calls
    
    We need to populate an ACL (security descriptor open context)
    on file and directory correct.  This patch passes in the
    mode.  Followon patch will build the open context and the
    security descriptor (from the mode) that goes in the open
    context.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 54e204589cb9..2e960e1049db 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -331,8 +331,9 @@ struct smb_version_operations {
 			umode_t mode, struct cifs_tcon *tcon,
 			const char *full_path,
 			struct cifs_sb_info *cifs_sb);
-	int (*mkdir)(const unsigned int, struct cifs_tcon *, const char *,
-		     struct cifs_sb_info *);
+	int (*mkdir)(const unsigned int xid, struct inode *inode, umode_t mode,
+		     struct cifs_tcon *tcon, const char *name,
+		     struct cifs_sb_info *sb);
 	/* set info on created directory */
 	void (*mkdir_setinfo)(struct inode *, const char *,
 			      struct cifs_sb_info *, struct cifs_tcon *,
@@ -1209,6 +1210,7 @@ struct cifs_search_info {
 	bool smallBuf:1; /* so we know which buf_release function to call */
 };
 
+#define ACL_NO_MODE	-1
 struct cifs_open_parms {
 	struct cifs_tcon *tcon;
 	struct cifs_sb_info *cifs_sb;

commit 8eecd1c2e5bc73d33f3a544751305679dbf88eb4
Author: Paulo Alcantara (SUSE) <paulo@paulo.ac>
Date:   Tue Jul 16 19:04:50 2019 -0300

    cifs: Add support for root file systems
    
    Introduce a new CONFIG_CIFS_ROOT option to handle root file systems
    over a SMB share.
    
    In order to mount the root file system during the init process, make
    cifs.ko perform non-blocking socket operations while mounting and
    accessing it.
    
    Cc: Steve French <smfrench@gmail.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Paulo Alcantara (SUSE) <paulo@paulo.ac>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 09b60ec5de3e..54e204589cb9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -607,6 +607,7 @@ struct smb_vol {
 	__u32 handle_timeout; /* persistent and durable handle timeout in ms */
 	unsigned int max_credits; /* smb3 max_credits 10 < credits < 60000 */
 	__u16 compression; /* compression algorithm 0xFFFF default 0=disabled */
+	bool rootfs:1; /* if it's a SMB root file system */
 };
 
 /**
@@ -764,6 +765,7 @@ struct TCP_Server_Info {
 	 * reconnect.
 	 */
 	int nr_targets;
+	bool noblockcnt; /* use non-blocking connect() */
 };
 
 struct cifs_credits {

commit 3e7a02d47872081f4b6234a9f72500f1d10f060c
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Sep 11 21:46:20 2019 -0500

    smb3: allow disabling requesting leases
    
    In some cases to work around server bugs or performance
    problems it can be helpful to be able to disable requesting
    SMB2.1/SMB3 leases on a particular mount (not to all servers
    and all shares we are mounted to). Add new mount parm
    "nolease" which turns off requesting leases on directory
    or file opens.  Currently the only way to disable leases is
    globally through a module load parameter. This is more
    granular.
    
    Suggested-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ef2199913217..09b60ec5de3e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -579,6 +579,7 @@ struct smb_vol {
 	bool noblocksnd:1;
 	bool noautotune:1;
 	bool nostrictsync:1; /* do not force expensive SMBflush on every sync */
+	bool no_lease:1;     /* disable requesting leases */
 	bool fsc:1;	/* enable fscache */
 	bool mfsymlinks:1; /* use Minshall+French Symlinks */
 	bool multiuser:1;
@@ -1090,6 +1091,7 @@ struct cifs_tcon {
 	bool need_reopen_files:1; /* need to reopen tcon file handles */
 	bool use_resilient:1; /* use resilient instead of durable handles */
 	bool use_persistent:1; /* use persistent instead of durable handles */
+	bool no_lease:1;    /* Do not request leases on files or directories */
 	__le32 capabilities;
 	__u32 share_flags;
 	__u32 maximal_access;

commit 1b63f1840e787516bf2d3e5c27c2d22fe23cfb37
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Sep 9 22:57:11 2019 -0500

    smb3: display max smb3 requests in flight at any one time
    
    Displayed in /proc/fs/cifs/Stats once for each
    socket we are connected to.
    
    This allows us to find out what the maximum number of
    requests that had been in flight (at any one time). Note that
    /proc/fs/cifs/Stats can be reset if you want to look for
    maximum over a small period of time.
    
    Sample output (immediately after mount):
    
    Resources in use
    CIFS Session: 1
    Share (unique mount targets): 2
    SMB Request/Response Buffer: 1 Pool size: 5
    SMB Small Req/Resp Buffer: 1 Pool size: 30
    Operations (MIDs): 0
    
    0 session 0 share reconnects
    Total vfs operations: 5 maximum at one time: 2
    
    Max requests in flight: 2
    1) \\localhost\scratch
    SMBs: 18
    Bytes read: 0  Bytes written: 0
    ...
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6987fbc5a24a..ef2199913217 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -677,6 +677,7 @@ struct TCP_Server_Info {
 	unsigned int credits;  /* send no more requests at once */
 	unsigned int max_credits; /* can override large 32000 default at mnt */
 	unsigned int in_flight;  /* number of requests on the wire to server */
+	unsigned int max_in_flight; /* max number of requests that were on wire */
 	spinlock_t req_lock;  /* protect the two values above */
 	struct mutex srv_mutex;
 	struct task_struct *tsk;

commit 563317ec3083f7e126d7e30821ff8505ac338ee5
Author: Steve French <stfrench@microsoft.com>
Date:   Sun Sep 8 23:22:02 2019 -0500

    smb3: enable offload of decryption of large reads via mount option
    
    Disable offload of the decryption of encrypted read responses
    by default (equivalent to setting this new mount option "esize=0").
    
    Allow setting the minimum encrypted read response size that we
    will choose to offload to a worker thread - it is now configurable
    via on a new mount option "esize="
    
    Depending on which encryption mechanism (GCM vs. CCM) and
    the number of reads that will be issued in parallel and the
    performance of the network and CPU on the client, it may make
    sense to enable this since it can provide substantial benefit when
    multiple large reads are in flight at the same time.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d66106ac031a..6987fbc5a24a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -592,6 +592,7 @@ struct smb_vol {
 	unsigned int bsize;
 	unsigned int rsize;
 	unsigned int wsize;
+	unsigned int min_offload;
 	bool sockopt_tcp_nodelay:1;
 	unsigned long actimeo; /* attribute cache timeout (jiffies) */
 	struct smb_version_operations *ops;
@@ -745,6 +746,7 @@ struct TCP_Server_Info {
 #endif /* STATS2 */
 	unsigned int	max_read;
 	unsigned int	max_write;
+	unsigned int	min_offload;
 	__le16	compress_algorithm;
 	__le16	cipher_type;
 	 /* save initital negprot hash */

commit 35cf94a397280b9e27576ac1480f631bdd3e7b70
Author: Steve French <stfrench@microsoft.com>
Date:   Sat Sep 7 01:09:49 2019 -0500

    smb3: allow parallelizing decryption of reads
    
    decrypting large reads on encrypted shares can be slow (e.g. adding
    multiple milliseconds per-read on non-GCM capable servers or
    when mounting with dialects prior to SMB3.1.1) - allow parallelizing
    of read decryption by launching worker threads.
    
    Testing to Samba on localhost showed 25% improvement.
    Testing to remote server showed very large improvement when
    doing more than one 'cp' command was called at one time.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1f53dee211d8..d66106ac031a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1892,6 +1892,7 @@ void cifs_queue_oplock_break(struct cifsFileInfo *cfile);
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;
+extern struct workqueue_struct *decrypt_wq;
 extern struct workqueue_struct *cifsoplockd_wq;
 extern __u32 cifs_lock_secret;
 

commit 4f5c10f1ad45ae453822113dd0fe39ed757037fb
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Sep 3 21:18:49 2019 -0500

    smb3: allow skipping signature verification for perf sensitive configurations
    
    Add new mount option "signloosely" which enables signing but skips the
    sometimes expensive signing checks in the responses (signatures are
    calculated and sent correctly in the SMB2/SMB3 requests even with this
    mount option but skipped in the responses).  Although weaker for security
    (and also data integrity in case a packet were corrupted), this can provide
    enough of a performance benefit (calculating the signature to verify a
    packet can be expensive especially for large packets) to be useful in
    some cases.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fa5abe3a8514..1f53dee211d8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -542,6 +542,7 @@ struct smb_vol {
 	umode_t dir_mode;
 	enum securityEnum sectype; /* sectype requested via mnt opts */
 	bool sign; /* was signing requested via mnt opts? */
+	bool ignore_signature:1;
 	bool retry:1;
 	bool intr:1;
 	bool setuids:1;
@@ -681,6 +682,7 @@ struct TCP_Server_Info {
 	char server_GUID[16];
 	__u16 sec_mode;
 	bool sign; /* is signing enabled on this connection? */
+	bool ignore_signature:1; /* skip validation of signatures in SMB2/3 rsp */
 	bool session_estab; /* mark when very first sess is established */
 	int echo_credits;  /* echo reserved slots */
 	int oplock_credits;  /* oplock break reserved slots */

commit 41e033fecdc891da629113c4f8ee80500b7656d6
Author: Steve French <stfrench@microsoft.com>
Date:   Fri Aug 30 02:12:41 2019 -0500

    smb3: add mount option to allow RW caching of share accessed by only 1 client
    
    If a share is known to be only to be accessed by one client, we
    can aggressively cache writes not just reads to it.
    
    Add "cache=" option (cache=singleclient) for mounting read write shares
    (that will not be read or written to from other clients while we have
    it mounted) in order to improve performance.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3f12da7f2f7f..fa5abe3a8514 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -560,6 +560,7 @@ struct smb_vol {
 	bool direct_io:1;
 	bool strict_io:1; /* strict cache behavior */
 	bool cache_ro:1;
+	bool cache_rw:1;
 	bool remap:1;      /* set to remap seven reserved chars in filenames */
 	bool sfu_remap:1;  /* remap seven reserved chars ala SFU */
 	bool posix_paths:1; /* unset to not ask for posix pathnames. */
@@ -622,7 +623,7 @@ struct smb_vol {
 			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID | \
 			 CIFS_MOUNT_UID_FROM_ACL | CIFS_MOUNT_NO_HANDLE_CACHE | \
 			 CIFS_MOUNT_NO_DFS | CIFS_MOUNT_MODE_FROM_SID | \
-			 CIFS_MOUNT_RO_CACHE)
+			 CIFS_MOUNT_RO_CACHE | CIFS_MOUNT_RW_CACHE)
 
 /**
  * Generic VFS superblock mount flags (s_flags) to consider when
@@ -1370,7 +1371,7 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 
 #define CIFS_CACHE_READ(cinode) ((cinode->oplock & CIFS_CACHE_READ_FLG) || (CIFS_SB(cinode->vfs_inode.i_sb)->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE))
 #define CIFS_CACHE_HANDLE(cinode) (cinode->oplock & CIFS_CACHE_HANDLE_FLG)
-#define CIFS_CACHE_WRITE(cinode) (cinode->oplock & CIFS_CACHE_WRITE_FLG)
+#define CIFS_CACHE_WRITE(cinode) ((cinode->oplock & CIFS_CACHE_WRITE_FLG) || (CIFS_SB(cinode->vfs_inode.i_sb)->mnt_cifs_flags & CIFS_MOUNT_RW_CACHE))
 
 /*
  * One of these for each file inode

commit 83bbfa706dda668deb60e96df20327fc79e1716f
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Aug 27 23:58:54 2019 -0500

    smb3: add mount option to allow forced caching of read only share
    
    If a share is immutable (at least for the period that it will
    be mounted) it would be helpful to not have to revalidate
    dentries repeatedly that we know can not be changed remotely.
    
    Add "cache=" option (cache=ro) for mounting read only shares
    in order to improve performance in cases in which we know that
    the share will not be changing while it is in use.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fe610e7e3670..3f12da7f2f7f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -559,6 +559,7 @@ struct smb_vol {
 	bool server_ino:1; /* use inode numbers from server ie UniqueId */
 	bool direct_io:1;
 	bool strict_io:1; /* strict cache behavior */
+	bool cache_ro:1;
 	bool remap:1;      /* set to remap seven reserved chars in filenames */
 	bool sfu_remap:1;  /* remap seven reserved chars ala SFU */
 	bool posix_paths:1; /* unset to not ask for posix pathnames. */
@@ -620,7 +621,8 @@ struct smb_vol {
 			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO | \
 			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID | \
 			 CIFS_MOUNT_UID_FROM_ACL | CIFS_MOUNT_NO_HANDLE_CACHE | \
-			 CIFS_MOUNT_NO_DFS | CIFS_MOUNT_MODE_FROM_SID)
+			 CIFS_MOUNT_NO_DFS | CIFS_MOUNT_MODE_FROM_SID | \
+			 CIFS_MOUNT_RO_CACHE)
 
 /**
  * Generic VFS superblock mount flags (s_flags) to consider when
@@ -1366,7 +1368,7 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 #define CIFS_CACHE_RW_FLG	(CIFS_CACHE_READ_FLG | CIFS_CACHE_WRITE_FLG)
 #define CIFS_CACHE_RHW_FLG	(CIFS_CACHE_RW_FLG | CIFS_CACHE_HANDLE_FLG)
 
-#define CIFS_CACHE_READ(cinode) (cinode->oplock & CIFS_CACHE_READ_FLG)
+#define CIFS_CACHE_READ(cinode) ((cinode->oplock & CIFS_CACHE_READ_FLG) || (CIFS_SB(cinode->vfs_inode.i_sb)->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE))
 #define CIFS_CACHE_HANDLE(cinode) (cinode->oplock & CIFS_CACHE_HANDLE_FLG)
 #define CIFS_CACHE_WRITE(cinode) (cinode->oplock & CIFS_CACHE_WRITE_FLG)
 

commit 9fe5ff1c5d6a2a6c4ed4ba051a858571fdb7834c
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Jun 24 20:39:04 2019 -0500

    smb3: do not send compression info by default
    
    Since in theory a server could respond with compressed read
    responses even if not requested on read request (assuming that
    a compression negcontext is sent in negotiate protocol) - do
    not send compression information during negotiate protocol
    unless the user asks for compression explicitly (compression
    is experimental), and add a mount warning that compression
    is experimental.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a4af850cd20a..fe610e7e3670 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -601,6 +601,7 @@ struct smb_vol {
 	__u64 snapshot_time; /* needed for timewarp tokens */
 	__u32 handle_timeout; /* persistent and durable handle timeout in ms */
 	unsigned int max_credits; /* smb3 max_credits 10 < credits < 60000 */
+	__u16 compression; /* compression algorithm 0xFFFF default 0=disabled */
 };
 
 /**

commit 412094a8fb0711e9f332bed6723aa59706a4ff7e
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Jun 24 02:01:42 2019 -0500

    smb3: add new mount option to retrieve mode from special ACE
    
    There is a special ACE used by some servers to allow the mode
    bits to be stored.  This can be especially helpful in scenarios
    in which the client is trusted, and access checking on the
    client vs the POSIX mode bits is sufficient.
    
    Add mount option to allow enabling this behavior.
    Follow on patch will add support for chmod and queryinfo
    (stat) by retrieving the POSIX mode bits from the special
    ACE, SID: S-1-5-88-3
    
    See e.g.
    https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/hh509017(v=ws.10)
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 16f240911192..a4af850cd20a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -550,6 +550,7 @@ struct smb_vol {
 	bool override_gid:1;
 	bool dynperm:1;
 	bool noperm:1;
+	bool mode_ace:1;
 	bool no_psx_acl:1; /* set if posix acl support should be disabled */
 	bool cifs_acl:1;
 	bool backupuid_specified; /* mount option  backupuid  is specified */
@@ -618,7 +619,7 @@ struct smb_vol {
 			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO | \
 			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID | \
 			 CIFS_MOUNT_UID_FROM_ACL | CIFS_MOUNT_NO_HANDLE_CACHE | \
-			 CIFS_MOUNT_NO_DFS)
+			 CIFS_MOUNT_NO_DFS | CIFS_MOUNT_MODE_FROM_SID)
 
 /**
  * Generic VFS superblock mount flags (s_flags) to consider when

commit 73cf8085dc09442f17f32972d3cdec7232f1be55
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Jun 24 01:44:11 2019 -0500

    cifs: simplify code by removing CONFIG_CIFS_ACL ifdef
    
    SMB3 ACL support is needed for many use cases now and should not be
    ifdeffed out, even for SMB1 (CIFS).  Remove the CONFIG_CIFS_ACL
    ifdef so ACL support is always built into cifs.ko
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 88c98fa15f39..16f240911192 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1871,7 +1871,6 @@ extern unsigned int cifs_min_small;  /* min size of small buf pool */
 extern unsigned int cifs_max_pending; /* MAX requests at once to server*/
 extern bool disable_legacy_dialects;  /* forbid vers=1.0 and vers=2.0 mounts */
 
-#ifdef CONFIG_CIFS_ACL
 GLOBAL_EXTERN struct rb_root uidtree;
 GLOBAL_EXTERN struct rb_root gidtree;
 GLOBAL_EXTERN spinlock_t siduidlock;
@@ -1880,7 +1879,6 @@ GLOBAL_EXTERN struct rb_root siduidtree;
 GLOBAL_EXTERN struct rb_root sidgidtree;
 GLOBAL_EXTERN spinlock_t uidsidlock;
 GLOBAL_EXTERN spinlock_t gidsidlock;
-#endif /* CONFIG_CIFS_ACL */
 
 void cifs_oplock_break(struct work_struct *work);
 void cifs_queue_oplock_break(struct cifsFileInfo *cfile);

commit 6552d6a0264de505d3bb1445aecf757b1ec3873a
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Jun 24 01:19:52 2019 -0500

    cifs: Fix check for matching with existing mount
    
    If we mount the same share twice, we check the flags to see if the
    second mount matches the earlier mount, but we left some flags out.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4777b3c4a92c..88c98fa15f39 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -617,6 +617,7 @@ struct smb_vol {
 			 CIFS_MOUNT_FSCACHE | CIFS_MOUNT_MF_SYMLINKS | \
 			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO | \
 			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID | \
+			 CIFS_MOUNT_UID_FROM_ACL | CIFS_MOUNT_NO_HANDLE_CACHE | \
 			 CIFS_MOUNT_NO_DFS)
 
 /**

commit 487317c99477d00f22370625d53be3239febabbe
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed Jun 5 10:38:38 2019 +1000

    cifs: add spinlock for the openFileList to cifsInodeInfo
    
    We can not depend on the tcon->open_file_lock here since in multiuser mode
    we may have the same file/inode open via multiple different tcons.
    
    The current code is race prone and will crash if one user deletes a file
    at the same time a different user opens/create the file.
    
    To avoid this we need to have a spinlock attached to the inode and not the tcon.
    
    RHBZ:  1580165
    
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 334ff5f9c3f3..4777b3c4a92c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1377,6 +1377,7 @@ struct cifsInodeInfo {
 	struct rw_semaphore lock_sem;	/* protect the fields above */
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
+	spinlock_t	open_file_lock;	/* protects openFileList */
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
 	unsigned int oplock;		/* oplock/lease level we have */
 	unsigned int epoch;		/* used to track lease state changes */
@@ -1780,10 +1781,14 @@ require use of the stronger protocol */
  *  tcp_ses_lock protects:
  *	list operations on tcp and SMB session lists
  *  tcon->open_file_lock protects the list of open files hanging off the tcon
+ *  inode->open_file_lock protects the openFileList hanging off the inode
  *  cfile->file_info_lock protects counters and fields in cifs file struct
  *  f_owner.lock protects certain per file struct operations
  *  mapping->page_lock protects certain per page operations
  *
+ *  Note that the cifs_tcon.open_file_lock should be taken before
+ *  not after the cifsInodeInfo.open_file_lock
+ *
  *  Semaphores
  *  ----------
  *  sesSem     operations on smb session

commit dece44e381ab4a9fd1021db45ba4472e8c85becb
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed May 15 07:17:02 2019 +1000

    cifs: add support for SEEK_DATA and SEEK_HOLE
    
    Add llseek op for SEEK_DATA and SEEK_HOLE.
    Improves xfstests/285,286,436,445,448 and 490
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 33c251b408aa..334ff5f9c3f3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -497,6 +497,8 @@ struct smb_version_operations {
 	/* version specific fiemap implementation */
 	int (*fiemap)(struct cifs_tcon *tcon, struct cifsFileInfo *,
 		      struct fiemap_extent_info *, u64, u64);
+	/* version specific llseek implementation */
+	loff_t (*llseek)(struct file *, struct cifs_tcon *, loff_t, int);
 };
 
 struct smb_version_values {

commit ebaf546a5584d0a75aa61e4872771008715b8639
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed Apr 10 08:44:46 2019 +1000

    SMB3: Clean up query symlink when reparse point
    
    Two of the common symlink formats use reparse points
    (unlike mfsymlinks and also unlike the SMB1 posix
    extensions).  This is the first part of the fixes
    to allow these reparse points (NFS style and Windows
    symlinks) to be resolved properly as symlinks by the
    client.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 561f1395eddd..33c251b408aa 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -355,7 +355,8 @@ struct smb_version_operations {
 			       struct cifs_sb_info *);
 	/* query symlink target */
 	int (*query_symlink)(const unsigned int, struct cifs_tcon *,
-			     const char *, char **, struct cifs_sb_info *);
+			     struct cifs_sb_info *, const char *,
+			     char **, bool);
 	/* open a file for non-posix mounts */
 	int (*open)(const unsigned int, struct cifs_open_parms *,
 		    __u32 *, FILE_ALL_INFO *);

commit 26ea888f6282b0f5c1977d8ddb2fff1ea0238bd7
Author: Steve French <smfrench@gmail.com>
Date:   Fri Apr 26 20:36:08 2019 -0700

    Negotiate and save preferred compression algorithms
    
    New negotiate context (3) allows the server and client to
    negotiate which compression algorithms to use. Add support
    for this and save it off in the server structure.
    
    Also now displayed in /proc/fs/cifs/DebugData (see below example
    to Windows 10) where compression algoirthm "LZ77" was negotiated:
    
    Servers:
    Number of credits: 326 Dialect 0x311 COMPRESS_LZ77 signed
    1) Name: 192.168.92.17 Uses: 1 Capability: 0x300067     Session Status: 1 TCP status: 1 Instance: 1
    
    See MS-XCA and MS-SMB2 2.2.3.1 for more details.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c22ab330238c..561f1395eddd 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -734,6 +734,7 @@ struct TCP_Server_Info {
 #endif /* STATS2 */
 	unsigned int	max_read;
 	unsigned int	max_write;
+	__le16	compress_algorithm;
 	__le16	cipher_type;
 	 /* save initital negprot hash */
 	__u8	preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];

commit 392e1c5dc9cc93a8fffbd6230c12c9f38693e634
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Mon May 6 10:00:02 2019 +1000

    cifs: rename and clarify CIFS_ASYNC_OP and CIFS_NO_RESP
    
    The flags were named confusingly.
    CIFS_ASYNC_OP now just means that we will not block waiting for credits
    to become available so we thus rename this to be CIFS_NON_BLOCKING.
    
    Change CIFS_NO_RESP to CIFS_NO_RSP_BUF to clarify that we will actually get a
    response from the server but we will not get/do not want a response buffer.
    
    Delete CIFSSMBNotify. This is an SMB1 function that is not used.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 65faad3aa69a..c22ab330238c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1689,11 +1689,11 @@ static inline bool is_retryable_error(int error)
 
 /* Type of Request to SendReceive2 */
 #define   CIFS_BLOCKING_OP      1    /* operation can block */
-#define   CIFS_ASYNC_OP         2    /* do not wait for response */
+#define   CIFS_NON_BLOCKING     2    /* do not block waiting for credits */
 #define   CIFS_TIMEOUT_MASK 0x003    /* only one of above set in req */
 #define   CIFS_LOG_ERROR    0x010    /* log NT STATUS if non-zero */
 #define   CIFS_LARGE_BUF_OP 0x020    /* large request buffer */
-#define   CIFS_NO_RESP      0x040    /* no response buffer required */
+#define   CIFS_NO_RSP_BUF   0x040    /* no response buffer required */
 
 /* Type of request operation */
 #define   CIFS_ECHO_OP      0x080    /* echo request */

commit d69cb728e70c40268762182a62f5d5d6fa51c5b2
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed May 1 12:03:41 2019 +1000

    cifs: fix credits leak for SMB1 oplock breaks
    
    For SMB1 oplock breaks we would grab one credit while sending the PDU
    but we would never relese the credit back since we will never receive a
    response to this from the server. Eventuallt this would lead to a hang
    once all credits are leaked.
    
    Fix this by defining a new flag CIFS_NO_SRV_RSP which indicates that there
    is no server response to this command and thus we need to add any credits back
    immediately after sending the PDU.
    
    CC: Stable <stable@vger.kernel.org> #v5.0+
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5ffe0e538cec..65faad3aa69a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1703,6 +1703,7 @@ static inline bool is_retryable_error(int error)
 
 #define   CIFS_HAS_CREDITS 0x0400    /* already has credits */
 #define   CIFS_TRANSFORM_REQ 0x0800    /* transform request before sending */
+#define   CIFS_NO_SRV_RSP    0x1000    /* there is no server response */
 
 /* Security Flags: indicate type of session setup needed */
 #define   CIFSSEC_MAY_SIGN	0x00001

commit 2f3ebaba13cebd8badfb9aed31c0cf3cc82eb4f4
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Apr 25 16:45:29 2019 +1000

    cifs: add fiemap support
    
    Useful for improved copy performance as well as for
    applications which query allocated ranges of sparse
    files.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0dc55f4e6929..5ffe0e538cec 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -493,6 +493,9 @@ struct smb_version_operations {
 			 char *full_path,
 			 umode_t mode,
 			 dev_t device_number);
+	/* version specific fiemap implementation */
+	int (*fiemap)(struct cifs_tcon *tcon, struct cifsFileInfo *,
+		      struct fiemap_extent_info *, u64, u64);
 };
 
 struct smb_version_values {

commit d070f9dd625a68d8ed4fc1de685af06a489e6f8b
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Tue Apr 2 13:00:33 2019 +0200

    CIFS: check CIFS_MOUNT_NO_DFS when trying to reuse existing sb
    
    if we mount A then mount A again with nodfs, we shouldn't reuse the
    superblock. document the purpose of the defines as well.
    
    there are most likely more flags that needs to be added to this mask,
    in fact the logic to find them should be which flag should
    be *ignored* when trying to reuse an existing sb.
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 779ceb1f0412..0dc55f4e6929 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -596,6 +596,10 @@ struct smb_vol {
 	unsigned int max_credits; /* smb3 max_credits 10 < credits < 60000 */
 };
 
+/**
+ * CIFS superblock mount flags (mnt_cifs_flags) to consider when
+ * trying to reuse existing superblock for a new mount
+ */
 #define CIFS_MOUNT_MASK (CIFS_MOUNT_NO_PERM | CIFS_MOUNT_SET_UID | \
 			 CIFS_MOUNT_SERVER_INUM | CIFS_MOUNT_DIRECT_IO | \
 			 CIFS_MOUNT_NO_XATTR | CIFS_MOUNT_MAP_SPECIAL_CHR | \
@@ -606,8 +610,13 @@ struct smb_vol {
 			 CIFS_MOUNT_NOPOSIXBRL | CIFS_MOUNT_NOSSYNC | \
 			 CIFS_MOUNT_FSCACHE | CIFS_MOUNT_MF_SYMLINKS | \
 			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO | \
-			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID)
+			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID | \
+			 CIFS_MOUNT_NO_DFS)
 
+/**
+ * Generic VFS superblock mount flags (s_flags) to consider when
+ * trying to reuse existing superblock for a new mount
+ */
 #define CIFS_MS_MASK (SB_RDONLY | SB_MANDLOCK | SB_NOEXEC | SB_NOSUID | \
 		      SB_NODEV | SB_SYNCHRONOUS)
 

commit 433b8dd7672be1140ffbb17eacba776298bf4733
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Mar 26 13:53:21 2019 -0500

    SMB3: Track total time spent on roundtrips for each SMB3 command
    
    Also track minimum and maximum time by command in /proc/fs/cifs/Stats
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 585ad3207cb1..779ceb1f0412 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -714,7 +714,11 @@ struct TCP_Server_Info {
 #ifdef CONFIG_CIFS_STATS2
 	atomic_t in_send; /* requests trying to send */
 	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
+	atomic_t num_cmds[NUMBER_OF_SMB2_COMMANDS]; /* total requests by cmd */
 	atomic_t smb2slowcmd[NUMBER_OF_SMB2_COMMANDS]; /* count resps > 1 sec */
+	__u64 time_per_cmd[NUMBER_OF_SMB2_COMMANDS]; /* total time per cmd */
+	__u32 slowest_cmd[NUMBER_OF_SMB2_COMMANDS];
+	__u32 fastest_cmd[NUMBER_OF_SMB2_COMMANDS];
 #endif /* STATS2 */
 	unsigned int	max_read;
 	unsigned int	max_write;

commit b98749cac4a695f084a5ff076f4510b23e353ecd
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Mar 29 10:49:12 2019 +0100

    CIFS: keep FileInfo handle live during oplock break
    
    In the oplock break handler, writing pending changes from pages puts
    the FileInfo handle. If the refcount reaches zero it closes the handle
    and waits for any oplock break handler to return, thus causing a deadlock.
    
    To prevent this situation:
    
    * We add a wait flag to cifsFileInfo_put() to decide whether we should
      wait for running/pending oplock break handlers
    
    * We keep an additionnal reference of the SMB FileInfo handle so that
      for the rest of the handler putting the handle won't close it.
      - The ref is bumped everytime we queue the handler via the
        cifs_queue_oplock_break() helper.
      - The ref is decremented at the end of the handler
    
    This bug was triggered by xfstest 464.
    
    Also important fix to address the various reports of
    oops in smb2_push_mandatory_locks
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5b18d4585740..585ad3207cb1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1333,6 +1333,7 @@ cifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)
 }
 
 struct cifsFileInfo *cifsFileInfo_get(struct cifsFileInfo *cifs_file);
+void _cifsFileInfo_put(struct cifsFileInfo *cifs_file, bool wait_oplock_hdlr);
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 
 #define CIFS_CACHE_READ_FLG	1
@@ -1855,6 +1856,7 @@ GLOBAL_EXTERN spinlock_t gidsidlock;
 #endif /* CONFIG_CIFS_ACL */
 
 void cifs_oplock_break(struct work_struct *work);
+void cifs_queue_oplock_break(struct cifsFileInfo *cfile);
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;

commit ca567eb2b3f014d5be0f44c6f68b01a522f15ca4
Author: Steve French <stfrench@microsoft.com>
Date:   Fri Mar 29 16:31:07 2019 -0500

    SMB3: Allow persistent handle timeout to be configurable on mount
    
    Reconnecting after server or network failure can be improved
    (to maintain availability and protect data integrity) by allowing
    the client to choose the default persistent (or resilient)
    handle timeout in some use cases.  Today we default to 0 which lets
    the server pick the default timeout (usually 120 seconds) but this
    can be problematic for some workloads.  Add the new mount parameter
    to cifs.ko for SMB3 mounts "handletimeout" which enables the user
    to override the default handle timeout for persistent (mount
    option "persistenthandles") or resilient handles (mount option
    "resilienthandles").  Maximum allowed is 16 minutes (960000 ms).
    Units for the timeout are expressed in milliseconds. See
    section 2.2.14.2.12 and 2.2.31.3 of the MS-SMB2 protocol
    specification for more information.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 38feae812b47..5b18d4585740 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -59,6 +59,12 @@
  */
 #define CIFS_MAX_ACTIMEO (1 << 30)
 
+/*
+ * Max persistent and resilient handle timeout (milliseconds).
+ * Windows durable max was 960000 (16 minutes)
+ */
+#define SMB3_MAX_HANDLE_TIMEOUT 960000
+
 /*
  * MAX_REQ is the maximum number of requests that WE will send
  * on one socket concurrently.
@@ -586,6 +592,7 @@ struct smb_vol {
 	struct nls_table *local_nls;
 	unsigned int echo_interval; /* echo interval in secs */
 	__u64 snapshot_time; /* needed for timewarp tokens */
+	__u32 handle_timeout; /* persistent and durable handle timeout in ms */
 	unsigned int max_credits; /* smb3 max_credits 10 < credits < 60000 */
 };
 
@@ -1058,6 +1065,7 @@ struct cifs_tcon {
 	__u32 vol_serial_number;
 	__le64 vol_create_time;
 	__u64 snapshot_time; /* for timewarp tokens - timestamp of snapshot */
+	__u32 handle_timeout; /* persistent and durable handle timeout in ms */
 	__u32 ss_flags;		/* sector size flags */
 	__u32 perf_sector_size; /* best sector size for perf */
 	__u32 max_chunks;

commit c847dccfbdc198671e80cd81891ff7a255606aea
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Thu Mar 14 00:29:17 2019 -0500

    CIFS: make mknod() an smb_version_op
    
    This cleanup removes cifs specific code from SMB2/SMB3 code paths
    which is cleaner and easier to maintain as the code to handle
    special files is improved.  Below is an example creating special files
    using 'sfu' mount option over SMB3 to Windows (with this patch)
    (Note that to Samba server, support for saving dos attributes
    has to be enabled for the SFU mount option to work).
    
    In the future this will also make implementation of creating
    special files as reparse points easier (as Windows NFS server does
    for example).
    
       root@smf-Thinkpad-P51:~# stat -c "%F" /mnt2/char
       character special file
    
       root@smf-Thinkpad-P51:~# stat -c "%F" /mnt2/block
       block special file
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c4f0f4e4bc6d..38feae812b47 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -479,6 +479,14 @@ struct smb_version_operations {
 				struct cifs_tcon *tcon,
 				__le16 *path, int is_dir,
 				unsigned long p);
+	/* make unix special files (block, char, fifo, socket) */
+	int (*make_node)(unsigned int xid,
+			 struct inode *inode,
+			 struct dentry *dentry,
+			 struct cifs_tcon *tcon,
+			 char *full_path,
+			 umode_t mode,
+			 dev_t device_number);
 };
 
 struct smb_version_values {

commit 6552580286e5fdcde50206dd0263b63ab87b64fe
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Mar 13 18:21:38 2019 -0500

    cifs: minor documentation updates
    
    Also updated a comment describing use of the GlobalMid_Lock
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8b9ecf8c2986..c4f0f4e4bc6d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1738,6 +1738,7 @@ require use of the stronger protocol */
  *  GlobalMid_Lock protects:
  *	list operations on pending_mid_q and oplockQ
  *      updates to XID counters, multiplex id  and SMB sequence numbers
+ *      list operations on global DnotifyReqList
  *  tcp_ses_lock protects:
  *	list operations on tcp and SMB session lists
  *  tcon->open_file_lock protects the list of open files hanging off the tcon

commit b0f6df737a1c5d9d5ff90cc946205d8af46cc067
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Tue Mar 12 13:58:31 2019 +1000

    cifs: cache FILE_ALL_INFO for the shared root handle
    
    When we open the shared root handle also ask for FILE_ALL_INFORMATION since
    we can do this at zero cost as part of a compound.
    Cache this information as long as the lease is held and return and serve any
    future requests from cache.
    
    This allows us to serve "stat /<mountpoint>" directly from cache and avoid
    a network roundtrip.  Since clients often want to do this quite a lot
    this improve performance slightly.
    
    As an example: xfstest generic/533 performs 43 stat operations on the root
    of the share while it is run. Which are eliminated with this patch.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ddb299494cd6..8b9ecf8c2986 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -962,11 +962,14 @@ cap_unix(struct cifs_ses *ses)
 
 struct cached_fid {
 	bool is_valid:1;	/* Do we have a useable root fid */
+	bool file_all_info_is_valid:1;
+
 	struct kref refcount;
 	struct cifs_fid *fid;
 	struct mutex fid_mutex;
 	struct cifs_tcon *tcon;
 	struct work_struct lease_break;
+	struct smb2_file_all_info file_all_info;
 };
 
 /*

commit b227d215deef4f3528b8f754accef4db03539a59
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Fri Mar 8 12:58:20 2019 +1000

    cifs: wait_for_free_credits() make it possible to wait for >=1 credits
    
    Change wait_for_free_credits() to allow waiting for >=1 credits instead of just
    a single credit.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f293e052e351..ddb299494cd6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -735,13 +735,13 @@ in_flight(struct TCP_Server_Info *server)
 }
 
 static inline bool
-has_credits(struct TCP_Server_Info *server, int *credits)
+has_credits(struct TCP_Server_Info *server, int *credits, int num_credits)
 {
 	int num;
 	spin_lock(&server->req_lock);
 	num = *credits;
 	spin_unlock(&server->req_lock);
-	return num > 0;
+	return num >= num_credits;
 }
 
 static inline void

commit 9a1c67e8d5dad143d5166dac1ee6776f433dac00
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Wed Jan 23 18:15:52 2019 -0800

    CIFS: Adjust MTU credits before reopening a file
    
    Currently we adjust MTU credits before sending an IO request
    and after reopening a file. This approach doesn't allow the
    reopen routine to use existing credits that are not needed
    for IO. Reorder credit adjustment and reopening a file to
    use credits available to the client more efficiently. Also
    unwrap complex if statement into few pieces to improve
    readability.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 84ce388de89d..f293e052e351 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -457,6 +457,10 @@ struct smb_version_operations {
 	/* get mtu credits */
 	int (*wait_mtu_credits)(struct TCP_Server_Info *, unsigned int,
 				unsigned int *, struct cifs_credits *);
+	/* adjust previously taken mtu credits to request size */
+	int (*adjust_credits)(struct TCP_Server_Info *server,
+			      struct cifs_credits *credits,
+			      const unsigned int payload_size);
 	/* check if we need to issue closedir */
 	bool (*dir_needs_close)(struct cifsFileInfo *);
 	long (*fallocate)(struct file *, struct cifs_tcon *, int, loff_t,
@@ -763,6 +767,14 @@ set_credits(struct TCP_Server_Info *server, const int val)
 	server->ops->set_credits(server, val);
 }
 
+static inline int
+adjust_credits(struct TCP_Server_Info *server, struct cifs_credits *credits,
+	       const unsigned int payload_size)
+{
+	return server->ops->adjust_credits ?
+		server->ops->adjust_credits(server, credits, payload_size) : 0;
+}
+
 static inline __le64
 get_next_mid64(struct TCP_Server_Info *server)
 {

commit 34f4deb7c56c6fdc77a7e414203f0045bb6db32b
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Wed Jan 16 11:22:29 2019 -0800

    CIFS: Respect reconnect in non-MTU credits calculations
    
    Every time after a session reconnect we don't need to account for
    credits obtained in previous sessions. Make use of the recently
    added cifs_credits structure to properly calculate credits for
    non-MTU requests the same way we did for MTU ones.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4293b1f13f00..84ce388de89d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -741,12 +741,10 @@ has_credits(struct TCP_Server_Info *server, int *credits)
 }
 
 static inline void
-add_credits(struct TCP_Server_Info *server, const unsigned int add,
+add_credits(struct TCP_Server_Info *server, const struct cifs_credits *credits,
 	    const int optype)
 {
-	struct cifs_credits credits = { .value = add, .instance = 0 };
-
-	server->ops->add_credits(server, &credits, optype);
+	server->ops->add_credits(server, credits, optype);
 }
 
 static inline void

commit 335b7b62ffb69d18055f2bb6f3a029263a07c735
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Wed Jan 16 11:12:41 2019 -0800

    CIFS: Respect reconnect in MTU credits calculations
    
    Every time after a session reconnect we don't need to account for
    credits obtained in previous sessions. Introduce new struct cifs_credits
    which contains both credits value and reconnect instance of the
    time those credits were taken. Modify a routine that add credits
    back to handle the reconnect instance by assuming zero credits
    if the reconnect happened after the credits were obtained and
    before we decided to add them back due to some errors during sending.
    
    This patch fixes the MTU credits cases. The subsequent patch
    will handle non-MTU ones.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0c796a27d1eb..4293b1f13f00 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -216,6 +216,7 @@ struct cifs_io_parms;
 struct cifs_search_info;
 struct cifsInodeInfo;
 struct cifs_open_parms;
+struct cifs_credits;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, struct smb_rqst *,
@@ -230,8 +231,9 @@ struct smb_version_operations {
 	/* check response: verify signature, map error */
 	int (*check_receive)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     bool);
-	void (*add_credits)(struct TCP_Server_Info *, const unsigned int,
-			    const int);
+	void (*add_credits)(struct TCP_Server_Info *server,
+			    const struct cifs_credits *credits,
+			    const int optype);
 	void (*set_credits)(struct TCP_Server_Info *, const int);
 	int * (*get_credits_field)(struct TCP_Server_Info *, const int);
 	unsigned int (*get_credits)(struct mid_q_entry *);
@@ -454,7 +456,7 @@ struct smb_version_operations {
 	unsigned int (*wp_retry_size)(struct inode *);
 	/* get mtu credits */
 	int (*wait_mtu_credits)(struct TCP_Server_Info *, unsigned int,
-				unsigned int *, unsigned int *);
+				unsigned int *, struct cifs_credits *);
 	/* check if we need to issue closedir */
 	bool (*dir_needs_close)(struct cifsFileInfo *);
 	long (*fallocate)(struct file *, struct cifs_tcon *, int, loff_t,
@@ -713,6 +715,11 @@ struct TCP_Server_Info {
 	int nr_targets;
 };
 
+struct cifs_credits {
+	unsigned int value;
+	unsigned int instance;
+};
+
 static inline unsigned int
 in_flight(struct TCP_Server_Info *server)
 {
@@ -737,15 +744,17 @@ static inline void
 add_credits(struct TCP_Server_Info *server, const unsigned int add,
 	    const int optype)
 {
-	server->ops->add_credits(server, add, optype);
+	struct cifs_credits credits = { .value = add, .instance = 0 };
+
+	server->ops->add_credits(server, &credits, optype);
 }
 
 static inline void
-add_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,
-			const int optype)
+add_credits_and_wake_if(struct TCP_Server_Info *server,
+			const struct cifs_credits *credits, const int optype)
 {
-	if (add) {
-		server->ops->add_credits(server, add, optype);
+	if (credits->value) {
+		server->ops->add_credits(server, credits, optype);
 		wake_up(&server->request_q);
 	}
 }
@@ -1253,7 +1262,7 @@ struct cifs_readdata {
 	unsigned int			pagesz;
 	unsigned int			page_offset;
 	unsigned int			tailsz;
-	unsigned int			credits;
+	struct cifs_credits		credits;
 	unsigned int			nr_pages;
 	struct page			**pages;
 };
@@ -1279,7 +1288,7 @@ struct cifs_writedata {
 	unsigned int			pagesz;
 	unsigned int			page_offset;
 	unsigned int			tailsz;
-	unsigned int			credits;
+	struct cifs_credits		credits;
 	unsigned int			nr_pages;
 	struct page			**pages;
 };

commit 66265f134acfb202465fecfbeb61fefb66595c40
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Wed Jan 23 17:11:16 2019 -0800

    CIFS: Count SMB3 credits for malformed pending responses
    
    Even if a response is malformed, we should count credits
    granted by the server to avoid miscalculations and unnecessary
    reconnects due to client or server bugs. If the response has
    been received partially, the session will be reconnected anyway
    on the next iteration of the demultiplex thread, so counting
    credits for such cases shouldn't break things.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1b25e6e95d45..0c796a27d1eb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -385,8 +385,8 @@ struct smb_version_operations {
 			 struct cifs_fid *);
 	/* calculate a size of SMB message */
 	unsigned int (*calc_smb_size)(void *buf, struct TCP_Server_Info *ptcpi);
-	/* check for STATUS_PENDING and process it in a positive case */
-	bool (*is_status_pending)(char *, struct TCP_Server_Info *, int);
+	/* check for STATUS_PENDING and process the response if yes */
+	bool (*is_status_pending)(char *buf, struct TCP_Server_Info *server);
 	/* check for STATUS_NETWORK_SESSION_EXPIRED */
 	bool (*is_session_expired)(char *);
 	/* send oplock break response */

commit c781af7e0c1fed9f1d0e0ec31b86f5b21a8dca17
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Mon Mar 4 14:02:50 2019 -0800

    CIFS: Do not skip SMB2 message IDs on send failures
    
    When we hit failures during constructing MIDs or sending PDUs
    through the network, we end up not using message IDs assigned
    to the packet. The next SMB packet will skip those message IDs
    and continue with the next one. This behavior may lead to a server
    not granting us credits until we use the skipped IDs. Fix this by
    reverting the current ID to the original value if any errors occur
    before we push the packet through the network stack.
    
    This patch fixes the generic/310 test from the xfs-tests.
    
    Cc: <stable@vger.kernel.org> # 4.19.x
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 33264f9a9665..1b25e6e95d45 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -236,6 +236,8 @@ struct smb_version_operations {
 	int * (*get_credits_field)(struct TCP_Server_Info *, const int);
 	unsigned int (*get_credits)(struct mid_q_entry *);
 	__u64 (*get_next_mid)(struct TCP_Server_Info *);
+	void (*revert_current_mid)(struct TCP_Server_Info *server,
+				   const unsigned int val);
 	/* data offset from read response message */
 	unsigned int (*read_data_offset)(char *);
 	/*
@@ -771,6 +773,22 @@ get_next_mid(struct TCP_Server_Info *server)
 	return cpu_to_le16(mid);
 }
 
+static inline void
+revert_current_mid(struct TCP_Server_Info *server, const unsigned int val)
+{
+	if (server->ops->revert_current_mid)
+		server->ops->revert_current_mid(server, val);
+}
+
+static inline void
+revert_current_mid_from_hdr(struct TCP_Server_Info *server,
+			    const struct smb2_sync_hdr *shdr)
+{
+	unsigned int num = le16_to_cpu(shdr->CreditCharge);
+
+	return revert_current_mid(server, num > 0 ? num : 1);
+}
+
 static inline __u16
 get_mid(const struct smb_hdr *smb)
 {
@@ -1423,6 +1441,7 @@ struct mid_q_entry {
 	struct kref refcount;
 	struct TCP_Server_Info *server;	/* server corresponding to this mid */
 	__u64 mid;		/* multiplex id */
+	__u16 credits;		/* number of credits consumed by this mid */
 	__u32 pid;		/* process id */
 	__u32 sequence_number;  /* for CIFS signing */
 	unsigned long when_alloc;  /* when mid was created */

commit e8506d25f740fd058791cc12a6dfa9386ada6b96
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Feb 28 21:32:15 2019 -0600

    smb3: make default i/o size for smb3 mounts larger
    
    We negotiate rsize mounts (and it can be overridden by user) to
    typically 4MB, so using larger default I/O sizes from userspace
    (changing to 1MB default i/o size returned by stat) the
    performance is much better (and not just for long latency
    network connections) in most use cases for SMB3 than the default I/O
    size (which ends up being 128K for cp and can be even smaller for cp).
    This can be 4x slower or worse depending on network latency.
    
    By changing inode->blocksize from 32K (which was perhaps ok
    for very old SMB1/CIFS) to a larger value, 1MB (but still less than
    max size negotiated with the server which is 4MB, in order to minimize
    risk) it significantly increases performance for the
    noncached case, and slightly increases it for the cached case.
    This can be changed by the user on mount (specifying bsize=
    values from 16K to 16MB) to tune better for performance
    for applications that depend on blocksize.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 94dbdbe5be34..33264f9a9665 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -557,6 +557,7 @@ struct smb_vol {
 	bool resilient:1; /* noresilient not required since not fored for CA */
 	bool domainauto:1;
 	bool rdma:1;
+	unsigned int bsize;
 	unsigned int rsize;
 	unsigned int wsize;
 	bool sockopt_tcp_nodelay:1;

commit 9a66396f1857cc1de06f4f4771797315e1a4ea56
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Tue Jan 8 11:15:28 2019 -0800

    CIFS: Fix error paths in writeback code
    
    This patch aims to address writeback code problems related to error
    paths. In particular it respects EINTR and related error codes and
    stores and returns the first error occurred during writeback.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Acked-by: Jeff Layton <jlayton@kernel.org>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 770926877b7c..94dbdbe5be34 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1575,6 +1575,25 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 	kfree(param);
 }
 
+static inline bool is_interrupt_error(int error)
+{
+	switch (error) {
+	case -EINTR:
+	case -ERESTARTSYS:
+	case -ERESTARTNOHAND:
+	case -ERESTARTNOINTR:
+		return true;
+	}
+	return false;
+}
+
+static inline bool is_retryable_error(int error)
+{
+	if (is_interrupt_error(error) || error == -EAGAIN)
+		return true;
+	return false;
+}
+
 #define   MID_FREE 0
 #define   MID_REQUEST_ALLOCATED 1
 #define   MID_REQUEST_SUBMITTED 2

commit 8a26f0f781f56d3016b34a2217e346973d067e7b
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Thu Jan 3 16:45:27 2019 -0800

    CIFS: Fix credits calculation for cancelled requests
    
    If a request is cancelled, we can't assume that the server returns
    1 credit back. Instead we need to wait for a response and process
    the number of credits granted by the server.
    
    Create a separate mid callback for cancelled request, parse the number
    of credits in a response buffer and add them to the client's credits.
    If the didn't get a response (no response buffer available) assume
    0 credits granted. The latter most probably happens together with
    session reconnect, so the client's credits are adjusted anyway.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 01ded7038b19..770926877b7c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1438,6 +1438,7 @@ struct mid_q_entry {
 	int mid_state;	/* wish this were enum but can not pass to wait_event */
 	unsigned int mid_flags;
 	__le16 command;		/* smb command code */
+	unsigned int optype;	/* operation type */
 	bool large_buf:1;	/* if valid response, is pointer to large buf */
 	bool multiRsp:1;	/* multiple trans2 responses for one request  */
 	bool multiEnd:1;	/* both received */

commit 93d5cb517db39e8af8d1292f9e785e4983b7f708
Author: Paulo Alcantara <palcantara@suse.de>
Date:   Wed Nov 14 17:13:25 2018 -0200

    cifs: Add support for failover in cifs_reconnect()
    
    After failing to reconnect to original target, it will retry any
    target available from DFS cache.
    
    Signed-off-by: Paulo Alcantara <palcantara@suse.de>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 45feb3ff7806..01ded7038b19 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -701,6 +701,13 @@ struct TCP_Server_Info {
 	struct delayed_work reconnect; /* reconnect workqueue job */
 	struct mutex reconnect_mutex; /* prevent simultaneous reconnects */
 	unsigned long echo_interval;
+
+	/*
+	 * Number of targets available for reconnect. The more targets
+	 * the more tasks have to wait to let the demultiplex thread
+	 * reconnect.
+	 */
+	int nr_targets;
 };
 
 static inline unsigned int

commit 1c780228e9d47b966983a8bbf475dd45967bf0d5
Author: Paulo Alcantara <palcantara@suse.de>
Date:   Wed Nov 14 16:24:03 2018 -0200

    cifs: Make use of DFS cache to get new DFS referrals
    
    This patch will make use of DFS cache routines where appropriate and
    do not always request a new referral from server.
    
    Signed-off-by: Paulo Alcantara <palcantara@suse.de>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 66c487634c9e..45feb3ff7806 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1551,7 +1551,6 @@ static inline void free_dfs_info_param(struct dfs_info3_param *param)
 	if (param) {
 		kfree(param->path_name);
 		kfree(param->node_name);
-		kfree(param);
 	}
 }
 

commit 54be1f6c1c37498bba557049df646cc239fa37e3
Author: Paulo Alcantara <palcantara@suse.de>
Date:   Wed Nov 14 16:01:21 2018 -0200

    cifs: Add DFS cache routines
    
    * Add new dfs_cache.[ch] files
    
    * Add new /proc/fs/cifs/dfscache file
      - dump current cache when read
      - clear current cache when writing "0" to it
    
    * Add delayed_work to periodically refresh cache entries
    
    The new interface will be used for caching DFS referrals, as well as
    supporting client target failover.
    
    The DFS cache is a hashtable that maps UNC paths to cache entries.
    
    A cache entry contains:
    - the UNC path it is mapped on
    - how much the the UNC path the entry consumes
    - flags
    - a Time-To-Live after which the entry expires
    - a list of possible targets (linked lists of UNC paths)
    - a "hint target" pointing the last known working target or the first
      target if none were tried. This hint lets cifs.ko remember and try
      working targets first.
    
    * Looking for an entry in the cache is done with dfs_cache_find()
      - if no valid entries are found, a DFS query is made, stored in the
        cache and returned
      - the full target list can be copied and returned to avoid race
        conditions and looped on with the help with the
        dfs_cache_tgt_iterator
    
    * Updating the target hint to the next target is done with
      dfs_cache_update_tgthint()
    
    These functions have a dfs_cache_noreq_XXX() version that doesn't
    fetches referrals if no entries are found. These versions don't
    require the tcp/ses/tcon/cifs_sb parameters as a result.
    
    Expired entries cannot be used and since they have a pretty short TTL
    [1] in order for them to be useful for failover the DFS cache adds a
    delayed work called periodically to keep them fresh.
    
    Since we might not have available connections to issue the referral
    request when refreshing we need to store volume_info structs with
    credentials and other needed info to be able to connect to the right
    server.
    
    1: Windows defaults: 5mn for domain-based referrals, 30mn for regular
    links
    
    Signed-off-by: Paulo Alcantara <palcantara@suse.de>
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3b1aa12708a0..66c487634c9e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1014,6 +1014,11 @@ struct cifs_tcon {
 	struct list_head pending_opens;	/* list of incomplete opens */
 	struct cached_fid crfid; /* Cached root fid */
 	/* BB add field for back pointer to sb struct(s)? */
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	char *dfs_path;
+	int remap:2;
+	struct list_head ulist; /* cache update list */
+#endif
 };
 
 /*

commit e7b602f43719fc6173ae86d2de8f6f07c6858ddd
Author: Paulo Alcantara <palcantara@suse.de>
Date:   Wed Nov 14 15:38:51 2018 -0200

    cifs: Save TTL value when parsing DFS referrals
    
    This will be needed by DFS cache.
    
    Signed-off-by: Paulo Alcantara <palcantara@suse.de>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7b3b9313dcde..3b1aa12708a0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1508,6 +1508,7 @@ struct dfs_info3_param {
 	int ref_flag;
 	char *path_name;
 	char *node_name;
+	int ttl;
 };
 
 /*

commit 4a3b38aec5778f8eb37b2eb4701baffb1da4ccd5
Author: Kenneth D'souza <kdsouza@redhat.com>
Date:   Sat Nov 17 10:33:30 2018 +0530

    Add vers=3.0.2 as a valid option for SMBv3.0.2
    
    Technically 3.02 is not the dialect name although that is more familiar to
    many, so we should also accept the official dialect name (3.0.2 vs. 3.02)
    in vers=
    
    Signed-off-by: Kenneth D'souza <kdsouza@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 38ab0fca49e1..7b3b9313dcde 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1790,6 +1790,7 @@ extern struct smb_version_values smb3any_values;
 extern struct smb_version_operations smb30_operations;
 extern struct smb_version_values smb30_values;
 #define SMB302_VERSION_STRING	"3.02"
+#define ALT_SMB302_VERSION_STRING "3.0.2"
 /*extern struct smb_version_operations smb302_operations;*/ /* not needed yet */
 extern struct smb_version_values smb302_values;
 #define SMB311_VERSION_STRING	"3.1.1"

commit 6e6e2b86c29c6fcfa16ad9fdc7ea32027bea5d73
Author: Long Li <longli@microsoft.com>
Date:   Wed Oct 31 22:13:09 2018 +0000

    CIFS: Add support for direct I/O read
    
    With direct I/O read, we transfer the data directly from transport layer to
    the user data buffer.
    
    Change in v3: add support for kernel AIO
    
    Change in v4:
    Refactor common read code to __cifs_readv for direct and non-direct I/O.
    Retry on direct I/O failure.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d7c0443d47a4..38ab0fca49e1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1186,6 +1186,11 @@ struct cifs_aio_ctx {
 	unsigned int		len;
 	unsigned int		total_len;
 	bool			should_dirty;
+	/*
+	 * Indicates if this aio_ctx is for direct_io,
+	 * If yes, iter is a copy of the user passed iov_iter
+	 */
+	bool			direct_io;
 };
 
 struct cifs_readdata;

commit dfe33f9abc08997e56f9bdf14fe9ac7ac0e14075
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Oct 30 19:50:31 2018 -0500

    smb3: allow more detailed protocol info on open files for debugging
    
    In order to debug complex problems it is often helpful to
    have detailed information on the client and server view
    of the open file information.  Add the ability for root to
    view the list of smb3 open files and dump the persistent
    handle and other info so that it can be more easily
    correlated with server logs.
    
    Sample output from "cat /proc/fs/cifs/open_files"
    
     # Version:1
     # Format:
     # <tree id> <persistent fid> <flags> <count> <pid> <uid> <filename> <mid>
     0x5 0x800000378 0x8000 1 7704 0 some-file 0x14
     0xcb903c0c 0x84412e67 0x8000 1 7754 1001 rofile 0x1a6d
     0xcb903c0c 0x9526b767 0x8000 1 7720 1000 file 0x1a5b
     0xcb903c0c 0x9ce41a21 0x8000 1 7715 0 smallfile 0xd67
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ed1e0fcb69e3..d7c0443d47a4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1125,6 +1125,9 @@ struct cifs_fid {
 	__u8 create_guid[16];
 	struct cifs_pending_open *pending_open;
 	unsigned int epoch;
+#ifdef CONFIG_CIFS_DEBUG2
+	__u64 mid;
+#endif /* CIFS_DEBUG2 */
 	bool purge_cache;
 };
 

commit fae8044c03c3c03e06b384a6122b78a6c3a0b6a7
Author: Steve French <stfrench@microsoft.com>
Date:   Fri Oct 19 17:14:32 2018 -0500

    smb3: show number of current open files in /proc/fs/cifs/Stats
    
    To allow better debugging (for example applications with
    handle leaks, or complex reconnect scenarios) display the
    number of open files (on the client) and number of open
    server file handles for each tcon in /proc/fs/cifs/Stats.
    Note that open files on server is one larger than local
    due to handle caching (in this case of the root of
    the share).  In this example there are two local
    open files, and three (two file and one directory handle)
    open on the server.
    
    Sample output:
    
    $ cat /proc/fs/cifs/Stats
    Resources in use
    CIFS Session: 1
    Share (unique mount targets): 2
    SMB Request/Response Buffer: 1 Pool size: 5
    SMB Small Req/Resp Buffer: 1 Pool size: 30
    Operations (MIDs): 0
    
    0 session 0 share reconnects
    Total vfs operations: 36 maximum at one time: 2
    
    1) \\localhost\test
    SMBs: 69
    Bytes read: 27  Bytes written: 0
    Open files: 2 total (local), 3 open on server
    TreeConnects: 1 total 0 failed
    TreeDisconnects: 0 total 0 failed
    Creates: 19 total 0 failed
    Closes: 16 total 0 failed
    ...
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 26f497bd97df..ed1e0fcb69e3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -932,6 +932,8 @@ struct cifs_tcon {
 	struct list_head tcon_list;
 	int tc_count;
 	struct list_head rlist; /* reconnect list */
+	atomic_t num_local_opens;  /* num of all opens including disconnected */
+	atomic_t num_remote_opens; /* num of all network opens on server */
 	struct list_head openFileList;
 	spinlock_t open_file_lock; /* protects list above */
 	struct cifs_ses *ses;	/* pointer to session associated with */

commit 8d8b26e58432cb2840048b9f8aea286be6f75de5
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed Oct 17 05:47:58 2018 +1000

    cifs: add support for ioctl on directories
    
    We do not call cifs_open_file() for directories and thus we do not have a
    pSMBFile we can extract the FIDs from.
    
    Solve this by instead always using a compounded open/query/close for
    the passthrough ioctl.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 73801254cc21..26f497bd97df 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -33,6 +33,7 @@
 
 #define CIFS_MAGIC_NUMBER 0xFF534D42      /* the first four bytes of SMB PDUs */
 
+#define SMB_PATH_MAX 260
 #define CIFS_PORT 445
 #define RFC1001_PORT 139
 
@@ -467,7 +468,8 @@ struct smb_version_operations {
 	int (*next_header)(char *);
 	/* ioctl passthrough for query_info */
 	int (*ioctl_query_info)(const unsigned int xid,
-				struct cifsFileInfo *file,
+				struct cifs_tcon *tcon,
+				__le16 *path, int is_dir,
 				unsigned long p);
 };
 

commit f5b05d622a3e99e6a97a189fe500414be802a05c
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Sun Oct 7 19:19:58 2018 -0500

    cifs: add IOCTL for QUERY_INFO passthrough to userspace
    
    This allows userspace tools to query the raw info levels for cifs files
    and process the response in userspace.
    In particular this is useful for many of those data where there is no
    corresponding native data structure in linux.
    For example querying the security descriptor for a file and extract the
    SIDs.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 819ead41bbe2..73801254cc21 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -465,6 +465,10 @@ struct smb_version_operations {
 	enum securityEnum (*select_sectype)(struct TCP_Server_Info *,
 			    enum securityEnum);
 	int (*next_header)(char *);
+	/* ioctl passthrough for query_info */
+	int (*ioctl_query_info)(const unsigned int xid,
+				struct cifsFileInfo *file,
+				unsigned long p);
 };
 
 struct smb_version_values {

commit 9645759ce6b39013231f4fa312834935c93fe5bc
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Oct 4 09:24:38 2018 +1000

    cifs: OFD locks do not conflict with eachothers
    
    RHBZ 1484130
    
    Update cifs_find_fid_lock_conflict() to recognize that
    ODF locks do not conflict with eachother.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2a9c4ab3ec5c..819ead41bbe2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1074,7 +1074,8 @@ struct cifsLockInfo {
 	__u64 offset;
 	__u64 length;
 	__u32 pid;
-	__u32 type;
+	__u16 type;
+	__u16 flags;
 };
 
 /*

commit 3d621230b8a0c6616f32b86ec3f0bc3ead9eb5b8
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Sep 25 15:33:47 2018 -0500

    smb3: update default requested iosize to 4MB from 1MB for recent dialects
    
    Modern servers often support 8MB as maximum i/o size, and we see some
    performance benefits (my testing showed 1 to 13% on write paths,
    and 1 to 3% on read paths for increasing the default to 4MB). If server
    doesn't support larger i/o size, during negotiate protocol it is already
    set correctly to the server's maximum if lower than 4MB.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b2f7cbd587f9..2a9c4ab3ec5c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -799,6 +799,7 @@ compare_mid(__u16 mid, const struct smb_hdr *smb)
  * a single wsize request with a single call.
  */
 #define CIFS_DEFAULT_IOSIZE (1024 * 1024)
+#define SMB3_DEFAULT_IOSIZE (4 * 1024 * 1024)
 
 /*
  * Windows only supports a max of 60kb reads and 65535 byte writes. Default to

commit 9e1a37dad4f3b9f1d36d9fd27021bbd67fb8c85f
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Sep 19 02:38:17 2018 -0500

    smb3: track the instance of each session for debugging
    
    Each time we reconnect to the same server, bump an instance
    counter (and display in /proc/fs/cifs/DebugData) to make it
    easier to debug.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d59588e4aeb4..b2f7cbd587f9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -654,6 +654,7 @@ struct TCP_Server_Info {
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* for signing, protected by srv_mutex */
+	__u32 reconnect_instance; /* incremented on each reconnect */
 	struct session_key session_key;
 	unsigned long lstrp; /* when we got last response from this server */
 	struct cifs_secmech secmech; /* crypto sec mech functs, descriptors */

commit 00778e2294d560361e2ed4e94cc003351a2d82d9
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Sep 18 14:05:18 2018 -0500

    smb3: add way to control slow response threshold for logging and stats
    
    /proc/fs/cifs/Stats when CONFIG_CIFS_STATS2 is enabled logs 'slow'
    responses, but depending on the server you are debugging a
    one second timeout may be too fast, so allow setting it to
    a larger number of seconds via new module parameter
    
    /sys/module/cifs/parameters/slow_rsp_threshold
    
    or via modprobe:
    
    slow_rsp_threshold:Amount of time (in seconds) to wait before
    logging that a response is delayed.
    Default: 1 (if set to 0 disables msg). (uint)
    
    Recommended values are 0 (disabled) to 32767 (9 hours) with
    the default remaining as 1 second.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9dcaed031843..d59588e4aeb4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1715,6 +1715,7 @@ GLOBAL_EXTERN atomic_t bufAllocCount;    /* current number allocated  */
 #ifdef CONFIG_CIFS_STATS2
 GLOBAL_EXTERN atomic_t totBufAllocCount; /* total allocated over all time */
 GLOBAL_EXTERN atomic_t totSmBufAllocCount;
+extern unsigned int slow_rsp_threshold; /* number of secs before logging */
 #endif
 GLOBAL_EXTERN atomic_t smBufAllocCount;
 GLOBAL_EXTERN atomic_t midCount;

commit ddf83afb9f60ee58cdec30bb615eff65d00ba05e
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Aug 30 10:12:59 2018 +1000

    cifs: add a warning if we try to to dequeue a deleted mid
    
    cifs_delete_mid() is called once we are finished handling a mid and we
    expect no more work done on this mid.
    
    Needed to fix recent commit:
    commit 730928c8f4be88e9d6a027a16b1e8fa9c59fc077
    ("cifs: update smb2_queryfs() to use compounding")
    
    Add a warning if someone tries to dequeue a mid that has already been
    flagged to be deleted.
    Also change list_del() to list_del_init() so that if we have similar bugs
    resurface in the future we will not oops.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0c9ab62c3df4..9dcaed031843 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1553,6 +1553,7 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 
 /* Flags */
 #define   MID_WAIT_CANCELLED	 1 /* Cancelled while waiting for response */
+#define   MID_DELETED            2 /* Mid has been dequeued/deleted */
 
 /* Types of response buffer returned from SendReceive2 */
 #define   CIFS_NO_BUFFER        0    /* Response buffer not returned */

commit b24df3e30cbf48255db866720fb71f14bf9d2f39
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed Aug 8 15:07:45 2018 +1000

    cifs: update receive_encrypted_standard to handle compounded responses
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Paulo Alcantara <palcantara@suse.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 41803d374da0..0c9ab62c3df4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -76,6 +76,9 @@
 #define SMB_ECHO_INTERVAL_MAX 600
 #define SMB_ECHO_INTERVAL_DEFAULT 60
 
+/* maximum number of PDUs in one compound */
+#define MAX_COMPOUND 5
+
 /*
  * Default number of credits to keep available for SMB3.
  * This value is chosen somewhat arbitrarily. The Windows client
@@ -458,7 +461,7 @@ struct smb_version_operations {
 				 struct smb_rqst *, struct smb_rqst *);
 	int (*is_transform_hdr)(void *buf);
 	int (*receive_transform)(struct TCP_Server_Info *,
-				 struct mid_q_entry **);
+				 struct mid_q_entry **, char **, int *);
 	enum securityEnum (*select_sectype)(struct TCP_Server_Info *,
 			    enum securityEnum);
 	int (*next_header)(char *);

commit 468d677954c0d94fec59275d91222257fe8b4416
Author: Steve French <stfrench@microsoft.com>
Date:   Sat Aug 4 05:24:34 2018 -0500

    smb3: display stats counters for number of slow commands
    
    When CONFIG_CIFS_STATS2 is enabled keep counters for slow
    commands (ie server took longer than 1 second to respond)
    by SMB2/SMB3 command code.  This can help in diagnosing
    whether performance problems are on server (instead of
    client) and which commands are causing the problem.
    
    Sample output (the new lines contain words "slow responses ...")
    
    $ cat /proc/fs/cifs/Stats
    Resources in use
    CIFS Session: 1
    Share (unique mount targets): 2
    SMB Request/Response Buffer: 1 Pool size: 5
    SMB Small Req/Resp Buffer: 1 Pool size: 30
    Total Large 10 Small 490 Allocations
    Operations (MIDs): 0
    
    0 session 0 share reconnects
    Total vfs operations: 67 maximum at one time: 2
    4 slow responses from localhost for command 5
    1 slow responses from localhost for command 6
    1 slow responses from localhost for command 14
    1 slow responses from localhost for command 16
    
    1) \\localhost\test
    SMBs: 243
    Bytes read: 1024000  Bytes written: 104857600
    TreeConnects: 1 total 0 failed
    TreeDisconnects: 0 total 0 failed
    Creates: 40 total 0 failed
    Closes: 39 total 0 failed
    ...
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0553929e8339..41803d374da0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -680,7 +680,8 @@ struct TCP_Server_Info {
 #ifdef CONFIG_CIFS_STATS2
 	atomic_t in_send; /* requests trying to send */
 	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
-#endif
+	atomic_t smb2slowcmd[NUMBER_OF_SMB2_COMMANDS]; /* count resps > 1 sec */
+#endif /* STATS2 */
 	unsigned int	max_read;
 	unsigned int	max_write;
 	__le16	cipher_type;

commit b2c96de7fe3cd306df039c89727cb137b89d82ef
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed Aug 1 09:26:11 2018 +1000

    cifs: update init_sg, crypt_message to take an array of rqst
    
    These are used for SMB3 encryption and compounded requests.
    Update these functions and the other functions related to SMB3 encryption to
    take an array of requests.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4a3a737134ea..0553929e8339 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -454,10 +454,8 @@ struct smb_version_operations {
 	long (*fallocate)(struct file *, struct cifs_tcon *, int, loff_t,
 			  loff_t);
 	/* init transform request - used for encryption for now */
-	int (*init_transform_rq)(struct TCP_Server_Info *, struct smb_rqst *,
-				 struct smb_rqst *);
-	/* free transform request */
-	void (*free_transform_rq)(struct smb_rqst *);
+	int (*init_transform_rq)(struct TCP_Server_Info *, int num_rqst,
+				 struct smb_rqst *, struct smb_rqst *);
 	int (*is_transform_hdr)(void *buf);
 	int (*receive_transform)(struct TCP_Server_Info *,
 				 struct mid_q_entry **);
@@ -1023,6 +1021,7 @@ struct tcon_link {
 };
 
 extern struct tcon_link *cifs_sb_tlink(struct cifs_sb_info *cifs_sb);
+extern void smb3_free_compound_rqst(int num_rqst, struct smb_rqst *rqst);
 
 static inline struct cifs_tcon *
 tlink_tcon(struct tcon_link *tlink)

commit fcabb89299d79010eb923afdd26de04afcc0527f
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Jul 31 01:21:37 2018 -0500

    cifs: simple stats should always be enabled
    
    CONFIG_CIFS_STATS should always be enabled as Pavel recently
    noted.  Simple statistics are not a significant performance hit,
    and removing the ifdef simplifies the code slightly.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0e6fd5fa4eb6..4a3a737134ea 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -931,7 +931,6 @@ struct cifs_tcon {
 	__u32 tid;		/* The 4 byte tree id */
 	__u16 Flags;		/* optional support bits */
 	enum statusEnum tidStatus;
-#ifdef CONFIG_CIFS_STATS
 	atomic_t num_smbs_sent;
 	union {
 		struct {
@@ -965,7 +964,6 @@ struct cifs_tcon {
 	__u64    bytes_read;
 	__u64    bytes_written;
 	spinlock_t stat_lock;  /* protects the two fields above */
-#endif /* CONFIG_CIFS_STATS */
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
 	FILE_SYSTEM_UNIX_INFO fsUnixInfo;
@@ -1331,7 +1329,6 @@ convert_delimiter(char *path, char delim)
 		*pos = delim;
 }
 
-#ifdef CONFIG_CIFS_STATS
 #define cifs_stats_inc atomic_inc
 
 static inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,
@@ -1351,13 +1348,6 @@ static inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,
 	tcon->bytes_read += bytes;
 	spin_unlock(&tcon->stat_lock);
 }
-#else
-
-#define  cifs_stats_inc(field) do {} while (0)
-#define  cifs_stats_bytes_written(tcon, bytes) do {} while (0)
-#define  cifs_stats_bytes_read(tcon, bytes) do {} while (0)
-
-#endif
 
 
 /*

commit 9da6ec7775d2cd76df53fbf4f1f35f6d490204f5
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Tue Jul 31 08:48:22 2018 +1000

    cifs: use a refcount to protect open/closing the cached file handle
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Cc: <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8826bc0a9b15..0e6fd5fa4eb6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -907,6 +907,7 @@ cap_unix(struct cifs_ses *ses)
 
 struct cached_fid {
 	bool is_valid:1;	/* Do we have a useable root fid */
+	struct kref refcount;
 	struct cifs_fid *fid;
 	struct mutex fid_mutex;
 	struct cifs_tcon *tcon;

commit 06188fcf9c068a2a8e82ad1e2510a008373150e2
Author: Steve French <stfrench@microsoft.com>
Date:   Sun Jul 29 17:13:39 2018 -0500

    cifs: remove unused stats
    
    These timers were a good idea but weren't used in current code,
    and the idea was cifs specific.  Future patch will add similar timers
    for SMB2/SMB3, but no sense using memory for cifs timers that
    aren't used in current code.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3ec7e3063865..8826bc0a9b15 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -961,20 +961,6 @@ struct cifs_tcon {
 			atomic_t smb2_com_failed[NUMBER_OF_SMB2_COMMANDS];
 		} smb2_stats;
 	} stats;
-#ifdef CONFIG_CIFS_STATS2
-	unsigned long long time_writes;
-	unsigned long long time_reads;
-	unsigned long long time_opens;
-	unsigned long long time_deletes;
-	unsigned long long time_closes;
-	unsigned long long time_mkdirs;
-	unsigned long long time_rmdirs;
-	unsigned long long time_renames;
-	unsigned long long time_t2renames;
-	unsigned long long time_ffirst;
-	unsigned long long time_fnext;
-	unsigned long long time_fclose;
-#endif /* CONFIG_CIFS_STATS2 */
 	__u64    bytes_read;
 	__u64    bytes_written;
 	spinlock_t stat_lock;  /* protects the two fields above */

commit 0fdfef9aa7ee68ddd508aef7c98630cfc054f8d6
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Jun 28 19:30:23 2018 -0500

    smb3: simplify code by removing CONFIG_CIFS_SMB311
    
    We really, really want to be encouraging use of secure dialects,
    and SMB3.1.1 offers useful security features, and will soon
    be the recommended dialect for many use cases. Simplify the code
    by removing the CONFIG_CIFS_SMB311 ifdef so users don't disable
    it in the build, and create compatibility and/or security issues
    with modern servers - many of which have been supporting this
    dialect for multiple years.
    
    Also clarify some of the Kconfig text for cifs.ko about
    SMB3.1.1 and current supported features in the module.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b57d1e22ecb5..3ec7e3063865 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -191,9 +191,7 @@ enum smb_version {
 	Smb_21,
 	Smb_30,
 	Smb_302,
-#ifdef CONFIG_CIFS_SMB311
 	Smb_311,
-#endif /* SMB311 */
 	Smb_3any,
 	Smb_default,
 	Smb_version_err
@@ -687,12 +685,10 @@ struct TCP_Server_Info {
 #endif
 	unsigned int	max_read;
 	unsigned int	max_write;
-#ifdef CONFIG_CIFS_SMB311
 	__le16	cipher_type;
 	 /* save initital negprot hash */
 	__u8	preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
 	bool	posix_ext_supported;
-#endif /* 3.1.1 */
 	struct delayed_work reconnect; /* reconnect workqueue job */
 	struct mutex reconnect_mutex; /* prevent simultaneous reconnects */
 	unsigned long echo_interval;
@@ -886,9 +882,7 @@ struct cifs_ses {
 	__u8 smb3signingkey[SMB3_SIGN_KEY_SIZE];
 	__u8 smb3encryptionkey[SMB3_SIGN_KEY_SIZE];
 	__u8 smb3decryptionkey[SMB3_SIGN_KEY_SIZE];
-#ifdef CONFIG_CIFS_SMB311
 	__u8 preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
-#endif /* 3.1.1 */
 
 	/*
 	 * Network interfaces available on the server this session is
@@ -997,9 +991,7 @@ struct cifs_tcon {
 	bool seal:1;      /* transport encryption for this mounted share */
 	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */
-#ifdef CONFIG_CIFS_SMB311
 	bool posix_extensions; /* if true SMB3.11 posix extensions enabled */
-#endif /* CIFS_311 */
 	bool local_lease:1; /* check leases (only) on local system not remote */
 	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
 	bool broken_sparse_sup; /* if server or share does not support sparse */

commit 95390201e7d8dd1eb764a3cbd50ae538a17fcd02
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jun 19 17:27:58 2018 +0200

    cifs: use timespec64 internally
    
    In cifs, the timestamps are stored in memory in the cifs_fattr structure,
    which uses the deprecated 'timespec' structure. Now that the VFS code
    has moved on to 'timespec64', the next step is to change over the fattr
    as well.
    
    This also makes 32-bit and 64-bit systems behave the same way, and
    no longer overflow the 32-bit time_t in year 2038.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Paulo Alcantara <palcantara@suse.de>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c923c7854027..b57d1e22ecb5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1544,9 +1544,9 @@ struct cifs_fattr {
 	dev_t		cf_rdev;
 	unsigned int	cf_nlink;
 	unsigned int	cf_dtype;
-	struct timespec	cf_atime;
-	struct timespec	cf_mtime;
-	struct timespec	cf_ctime;
+	struct timespec64 cf_atime;
+	struct timespec64 cf_mtime;
+	struct timespec64 cf_ctime;
 };
 
 static inline void free_dfs_info_param(struct dfs_info3_param *param)

commit 729c0c9dd55204f0c9a823ac8a7bfa83d36c7e78
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Thu Jul 5 15:10:02 2018 +0200

    cifs: Fix stack out-of-bounds in smb{2,3}_create_lease_buf()
    
    smb{2,3}_create_lease_buf() store a lease key in the lease
    context for later usage on a lease break.
    
    In most paths, the key is currently sourced from data that
    happens to be on the stack near local variables for oplock in
    SMB2_open() callers, e.g. from open_shroot(), whereas
    smb2_open_file() properly allocates space on its stack for it.
    
    The address of those local variables holding the oplock is then
    passed to create_lease_buf handlers via SMB2_open(), and 16
    bytes near oplock are used. This causes a stack out-of-bounds
    access as reported by KASAN on SMB2.1 and SMB3 mounts (first
    out-of-bounds access is shown here):
    
    [  111.528823] BUG: KASAN: stack-out-of-bounds in smb3_create_lease_buf+0x399/0x3b0 [cifs]
    [  111.530815] Read of size 8 at addr ffff88010829f249 by task mount.cifs/985
    [  111.532838] CPU: 3 PID: 985 Comm: mount.cifs Not tainted 4.18.0-rc3+ #91
    [  111.534656] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014
    [  111.536838] Call Trace:
    [  111.537528]  dump_stack+0xc2/0x16b
    [  111.540890]  print_address_description+0x6a/0x270
    [  111.542185]  kasan_report+0x258/0x380
    [  111.544701]  smb3_create_lease_buf+0x399/0x3b0 [cifs]
    [  111.546134]  SMB2_open+0x1ef8/0x4b70 [cifs]
    [  111.575883]  open_shroot+0x339/0x550 [cifs]
    [  111.591969]  smb3_qfs_tcon+0x32c/0x1e60 [cifs]
    [  111.617405]  cifs_mount+0x4f3/0x2fc0 [cifs]
    [  111.674332]  cifs_smb3_do_mount+0x263/0xf10 [cifs]
    [  111.677915]  mount_fs+0x55/0x2b0
    [  111.679504]  vfs_kern_mount.part.22+0xaa/0x430
    [  111.684511]  do_mount+0xc40/0x2660
    [  111.698301]  ksys_mount+0x80/0xd0
    [  111.701541]  do_syscall_64+0x14e/0x4b0
    [  111.711807]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [  111.713665] RIP: 0033:0x7f372385b5fa
    [  111.715311] Code: 48 8b 0d 99 78 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 66 78 2c 00 f7 d8 64 89 01 48
    [  111.720330] RSP: 002b:00007ffff27049d8 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5
    [  111.722601] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f372385b5fa
    [  111.724842] RDX: 000055c2ecdc73b2 RSI: 000055c2ecdc73f9 RDI: 00007ffff270580f
    [  111.727083] RBP: 00007ffff2705804 R08: 000055c2ee976060 R09: 0000000000001000
    [  111.729319] R10: 0000000000000000 R11: 0000000000000206 R12: 00007f3723f4d000
    [  111.731615] R13: 000055c2ee976060 R14: 00007f3723f4f90f R15: 0000000000000000
    
    [  111.735448] The buggy address belongs to the page:
    [  111.737420] page:ffffea000420a7c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0
    [  111.739890] flags: 0x17ffffc0000000()
    [  111.741750] raw: 0017ffffc0000000 0000000000000000 dead000000000200 0000000000000000
    [  111.744216] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
    [  111.746679] page dumped because: kasan: bad access detected
    
    [  111.750482] Memory state around the buggy address:
    [  111.752562]  ffff88010829f100: 00 f2 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00 00 00
    [  111.754991]  ffff88010829f180: 00 00 f2 f2 00 00 00 00 00 00 00 00 00 00 00 00
    [  111.757401] >ffff88010829f200: 00 00 00 00 00 f1 f1 f1 f1 01 f2 f2 f2 f2 f2 f2
    [  111.759801]                                               ^
    [  111.762034]  ffff88010829f280: f2 02 f2 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00 00
    [  111.764486]  ffff88010829f300: f2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  111.766913] ==================================================================
    
    Lease keys are however already generated and stored in fid data
    on open and create paths: pass them down to the lease context
    creation handlers and use them.
    
    Suggested-by: Aurélien Aptel <aaptel@suse.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Fixes: b8c32dbb0deb ("CIFS: Request SMB2.1 leases")
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a2962fd41c6f..c923c7854027 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -423,7 +423,7 @@ struct smb_version_operations {
 	void (*set_oplock_level)(struct cifsInodeInfo *, __u32, unsigned int,
 				 bool *);
 	/* create lease context buffer for CREATE request */
-	char * (*create_lease_buf)(u8 *, u8);
+	char * (*create_lease_buf)(u8 *lease_key, u8 oplock);
 	/* parse lease context buffer and return oplock/epoch info */
 	__u8 (*parse_lease_buf)(void *buf, unsigned int *epoch, char *lkey);
 	ssize_t (*copychunk_range)(const unsigned int,

commit 696e420bb2a6624478105651d5368d45b502b324
Author: Lars Persson <lars.persson@axis.com>
Date:   Mon Jun 25 14:05:25 2018 +0200

    cifs: Fix use after free of a mid_q_entry
    
    With protocol version 2.0 mounts we have seen crashes with corrupt mid
    entries. Either the server->pending_mid_q list becomes corrupt with a
    cyclic reference in one element or a mid object fetched by the
    demultiplexer thread becomes overwritten during use.
    
    Code review identified a race between the demultiplexer thread and the
    request issuing thread. The demultiplexer thread seems to be written
    with the assumption that it is the sole user of the mid object until
    it calls the mid callback which either wakes the issuer task or
    deletes the mid.
    
    This assumption is not true because the issuer task can be woken up
    earlier by a signal. If the demultiplexer thread has proceeded as far
    as setting the mid_state to MID_RESPONSE_RECEIVED then the issuer
    thread will happily end up calling cifs_delete_mid while the
    demultiplexer thread still is using the mid object.
    
    Inserting a delay in the cifs demultiplexer thread widens the race
    window and makes reproduction of the race very easy:
    
                    if (server->large_buf)
                            buf = server->bigbuf;
    
    +               usleep_range(500, 4000);
    
                    server->lstrp = jiffies;
    
    To resolve this I think the proper solution involves putting a
    reference count on the mid object. This patch makes sure that the
    demultiplexer thread holds a reference until it has finished
    processing the transaction.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Lars Persson <larper@axis.com>
    Acked-by: Paulo Alcantara <palcantara@suse.de>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index bd78da59a4fd..a2962fd41c6f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1416,6 +1416,7 @@ typedef int (mid_handle_t)(struct TCP_Server_Info *server,
 /* one of these for every pending CIFS request to the server */
 struct mid_q_entry {
 	struct list_head qhead;	/* mids waiting on reply from this server */
+	struct kref refcount;
 	struct TCP_Server_Info *server;	/* server corresponding to this mid */
 	__u64 mid;		/* multiplex id */
 	__u32 pid;		/* process id */

commit bea851b8babe6c87c36e97c9de0dd0bea0dd5802
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Jun 14 21:56:32 2018 -0500

    smb3: Fix mode on mkdir on smb311 mounts
    
    mkdir was not passing the mode on smb3.11 mounts with posix extensions
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9dd5f1a3d64b..bd78da59a4fd 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -315,6 +315,10 @@ struct smb_version_operations {
 	/* send echo request */
 	int (*echo)(struct TCP_Server_Info *);
 	/* create directory */
+	int (*posix_mkdir)(const unsigned int xid, struct inode *inode,
+			umode_t mode, struct cifs_tcon *tcon,
+			const char *full_path,
+			struct cifs_sb_info *cifs_sb);
 	int (*mkdir)(const unsigned int, struct cifs_tcon *, const char *,
 		     struct cifs_sb_info *);
 	/* set info on created directory */

commit b6f0dd5d75f9689d57c7ea49e52c80cabb876cb4
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Thu Jun 14 15:43:18 2018 +0200

    CIFS: add iface info to struct cifs_ses
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ff280447dae5..9dd5f1a3d64b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -841,6 +841,13 @@ static inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)
 
 #endif
 
+struct cifs_server_iface {
+	size_t speed;
+	unsigned int rdma_capable : 1;
+	unsigned int rss_capable : 1;
+	struct sockaddr_storage sockaddr;
+};
+
 /*
  * Session structure.  One of these for each uid session with a particular host
  */
@@ -878,6 +885,20 @@ struct cifs_ses {
 #ifdef CONFIG_CIFS_SMB311
 	__u8 preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
 #endif /* 3.1.1 */
+
+	/*
+	 * Network interfaces available on the server this session is
+	 * connected to.
+	 *
+	 * Other channels can be opened by connecting and binding this
+	 * session to interfaces from this list.
+	 *
+	 * iface_lock should be taken when accessing any of these fields
+	 */
+	spinlock_t iface_lock;
+	struct cifs_server_iface *iface_list;
+	size_t iface_count;
+	unsigned long iface_last_update; /* jiffies */
 };
 
 static inline bool

commit e2292430c49dbbe2d54438a4c05dd937a8eeecdd
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Thu Jun 14 15:43:16 2018 +0200

    CIFS: move default port definitions to cifsglob.h
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ff71fbd619bf..ff280447dae5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -33,6 +33,9 @@
 
 #define CIFS_MAGIC_NUMBER 0xFF534D42      /* the first four bytes of SMB PDUs */
 
+#define CIFS_PORT 445
+#define RFC1001_PORT 139
+
 /*
  * The sizes of various internal tables and strings
  */

commit a93864d93977b99bda6c348a09b90a3d7ef8db3a
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Jun 14 06:48:35 2018 +1000

    cifs: add lease tracking to the cached root fid
    
    Use a read lease for the cached root fid so that we can detect
    when the content of the directory changes (via a break) at which time
    we close the handle. On next access to the root the handle will be reopened
    and cached again.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1efa2e65bc1a..ff71fbd619bf 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -883,6 +883,14 @@ cap_unix(struct cifs_ses *ses)
 	return ses->server->vals->cap_unix & ses->capabilities;
 }
 
+struct cached_fid {
+	bool is_valid:1;	/* Do we have a useable root fid */
+	struct cifs_fid *fid;
+	struct mutex fid_mutex;
+	struct cifs_tcon *tcon;
+	struct work_struct lease_break;
+};
+
 /*
  * there is one of these for each connection to a resource on a particular
  * session
@@ -987,9 +995,7 @@ struct cifs_tcon {
 	struct fscache_cookie *fscache;	/* cookie for share */
 #endif
 	struct list_head pending_opens;	/* list of incomplete opens */
-	bool valid_root_fid:1;	/* Do we have a useable root fid */
-	struct mutex prfid_mutex; /* prevents reopen race after dead ses*/
-	struct cifs_fid *prfid;	/* handle to the directory at top of share */
+	struct cached_fid crfid; /* Cached root fid */
 	/* BB add field for back pointer to sb struct(s)? */
 };
 

commit 8ddecf5fd728d3c6373394fa647d28e7c27f93a7
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Mon Jun 4 22:29:35 2018 +0200

    CIFS: Fix NULL ptr deref
    
    cifs->master_tlink is NULL against Win Server 2016 (which is
    strange.. not sure why) and is dereferenced in cifs_sb_master_tcon().
    
    move master_tlink getter to cifsglob.h so it can be used from
    smb2misc.c
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 08d1cdd96701..1efa2e65bc1a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1019,6 +1019,12 @@ tlink_tcon(struct tcon_link *tlink)
 	return tlink->tl_tcon;
 }
 
+static inline struct tcon_link *
+cifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)
+{
+	return cifs_sb->master_tlink;
+}
+
 extern void cifs_put_tlink(struct tcon_link *tlink);
 
 static inline struct tcon_link *

commit 8e7360f67e75e06f3ea144354243728fb8f54c57
Author: Long Li <longli@microsoft.com>
Date:   Wed May 30 12:47:56 2018 -0700

    CIFS: Add support for direct pages in wdata
    
    Add a function to allocate wdata without allocating pages for data
    transfer. This gives the caller an option to pass a number of pages that
    point to the data buffer to write to.
    
    wdata is reponsible for free those pages after it's done.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 781c2af609e5..08d1cdd96701 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1211,7 +1211,7 @@ struct cifs_writedata {
 	unsigned int			tailsz;
 	unsigned int			credits;
 	unsigned int			nr_pages;
-	struct page			*pages[];
+	struct page			**pages;
 };
 
 /*

commit f9f5aca115fd4a4b49cdc483084a0dc4ca316b25
Author: Long Li <longli@microsoft.com>
Date:   Wed May 30 12:47:54 2018 -0700

    CIFS: Add support for direct pages in rdata
    
    Add a function to allocate rdata without allocating pages for data
    transfer. This gives the caller an option to pass a number of pages
    that point to the data buffer.
    
    rdata is still reponsible for free those pages after it's done.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5105ac5f90f5..781c2af609e5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1185,7 +1185,7 @@ struct cifs_readdata {
 	unsigned int			tailsz;
 	unsigned int			credits;
 	unsigned int			nr_pages;
-	struct page			*pages[];
+	struct page			**pages;
 };
 
 struct cifs_writedata;

commit 8ce79ec359ad9f9d94aabf16c1ea5b8f28481c0f
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Fri Jun 1 10:53:08 2018 +1000

    cifs: update multiplex loop to handle compounded responses
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 76a579a0dd43..5105ac5f90f5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -458,7 +458,7 @@ struct smb_version_operations {
 				 struct mid_q_entry **);
 	enum securityEnum (*select_sectype)(struct TCP_Server_Info *,
 			    enum securityEnum);
-
+	int (*next_header)(char *);
 };
 
 struct smb_version_values {

commit ce558b0e17f8a6d4a57d264479d782c331266f0d
Author: Steve French <stfrench@microsoft.com>
Date:   Thu May 31 19:16:54 2018 -0500

    smb3: Add posix create context for smb3.11 posix mounts
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3e2ee7e1d85e..76a579a0dd43 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1082,6 +1082,7 @@ struct cifs_open_parms {
 	int create_options;
 	const char *path;
 	struct cifs_fid *fid;
+	umode_t mode;
 	bool reconnect:1;
 };
 

commit b326614ea2159ea5c835d320f261d05d080cd201
Author: Steve French <stfrench@microsoft.com>
Date:   Sun May 20 23:41:10 2018 -0500

    smb3: allow "posix" mount option to enable new SMB311 protocol extensions
    
    If "posix" (or synonym "unix" for backward compatibility) specified on mount,
    and server advertises support for SMB3.11 POSIX negotiate context, then
    enable the new posix extensions on the tcon.  This can be viewed by
    looking for "posix" in the mount options displayed by /proc/mounts
    for that mount (ie if posix extensions allowed by server and the
    experimental POSIX extensions also requested on the mount by specifying
    "posix" at mount time).
    
    Also add check to warn user if conflicting unix/nounix or posix/noposix specified
    on mount.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b131a395b95c..3e2ee7e1d85e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -522,6 +522,7 @@ struct smb_vol {
 	bool sfu_remap:1;  /* remap seven reserved chars ala SFU */
 	bool posix_paths:1; /* unset to not ask for posix pathnames. */
 	bool no_linux_ext:1;
+	bool linux_ext:1;
 	bool sfu_emul:1;
 	bool nullauth:1;   /* attempt to authenticate with null user */
 	bool nocase:1;     /* request case insensitive filenames */
@@ -960,6 +961,9 @@ struct cifs_tcon {
 	bool seal:1;      /* transport encryption for this mounted share */
 	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */
+#ifdef CONFIG_CIFS_SMB311
+	bool posix_extensions; /* if true SMB3.11 posix extensions enabled */
+#endif /* CIFS_311 */
 	bool local_lease:1; /* check leases (only) on local system not remote */
 	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
 	bool broken_sparse_sup; /* if server or share does not support sparse */

commit fcef0db6d630ccadaa65138b77eac5fce16a13c9
Author: Steve French <stfrench@microsoft.com>
Date:   Sat May 19 20:45:27 2018 -0500

    smb3: add support for posix negotiate context
    
    Unlike CIFS where UNIX/POSIX extensions had been negotiatable,
    SMB3 did not have POSIX extensions yet.  Add the new SMB3.11
    POSIX negotiate context to ask the server whether it can
    support POSIX (and thus whether we can send the new POSIX open
    context).
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d2ac9ced28c9..b131a395b95c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -683,6 +683,7 @@ struct TCP_Server_Info {
 	__le16	cipher_type;
 	 /* save initital negprot hash */
 	__u8	preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
+	bool	posix_ext_supported;
 #endif /* 3.1.1 */
 	struct delayed_work reconnect; /* reconnect workqueue job */
 	struct mutex reconnect_mutex; /* prevent simultaneous reconnects */

commit f92a720ee9d5d4e76a9621ce0812aef133c7b981
Author: Steve French <stfrench@microsoft.com>
Date:   Thu May 24 04:11:07 2018 -0500

    cifs: allow disabling less secure legacy dialects
    
    To improve security it may be helpful to have additional ways to restrict the
    ability to override the default dialects (SMB2.1, SMB3 and SMB3.02) on mount
    with old dialects (CIFS/SMB1 and SMB2) since vers=1.0 (CIFS/SMB1) and vers=2.0
    are weaker and less secure.
    
    Add a module parameter "disable_legacy_dialects"
    (/sys/module/cifs/parameters/disable_legacy_dialects) which can be set to
    1 (or equivalently Y) to forbid use of vers=1.0 or vers=2.0 on mount.
    
    Also cleans up a few build warnings about globals for various module parms.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d8c8700454ed..d2ac9ced28c9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1700,16 +1700,17 @@ GLOBAL_EXTERN atomic_t smBufAllocCount;
 GLOBAL_EXTERN atomic_t midCount;
 
 /* Misc globals */
-GLOBAL_EXTERN bool enable_oplocks; /* enable or disable oplocks */
-GLOBAL_EXTERN bool lookupCacheEnabled;
-GLOBAL_EXTERN unsigned int global_secflags;	/* if on, session setup sent
+extern bool enable_oplocks; /* enable or disable oplocks */
+extern bool lookupCacheEnabled;
+extern unsigned int global_secflags;	/* if on, session setup sent
 				with more secure ntlmssp2 challenge/resp */
-GLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
-GLOBAL_EXTERN bool linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/
-GLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */
-GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
-GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
-GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
+extern unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
+extern bool linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/
+extern unsigned int CIFSMaxBufSize;  /* max size not including hdr */
+extern unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
+extern unsigned int cifs_min_small;  /* min size of small buf pool */
+extern unsigned int cifs_max_pending; /* MAX requests at once to server*/
+extern bool disable_legacy_dialects;  /* forbid vers=1.0 and vers=2.0 mounts */
 
 #ifdef CONFIG_CIFS_ACL
 GLOBAL_EXTERN struct rb_root uidtree;

commit 11911b956f35868be5b3c0f686e01973a221abe6
Author: Steve French <stfrench@microsoft.com>
Date:   Thu May 24 02:09:20 2018 -0500

    cifs: make minor clarifications to module params for cifs.ko
    
    Note which ones of the module params are cifs dialect only
    (N/A for default dialect now that has moved to SMB2.1 or later)
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8d16c3e450da..d8c8700454ed 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -632,7 +632,7 @@ struct TCP_Server_Info {
 	bool oplocks:1; /* enable oplocks */
 	unsigned int maxReq;	/* Clients should submit no more */
 	/* than maxReq distinct unanswered SMBs to the server when using  */
-	/* multiplexed reads or writes */
+	/* multiplexed reads or writes (for SMB1/CIFS only, not SMB2/SMB3) */
 	unsigned int maxBuf;	/* maxBuf specifies the maximum */
 	/* message size the server can send or receive for non-raw SMBs */
 	/* maxBuf is returned by SMB NegotiateProtocol so maxBuf is only 0 */

commit 57a929a66f5a7c9363b1caa63db2bd9a3ffa6e49
Author: Long Li <longli@microsoft.com>
Date:   Wed May 30 12:47:53 2018 -0700

    CIFS: Introduce offset for the 1st page in data transfer structures
    
    When direct I/O is used, the data buffer may not always align to page
    boundaries. Introduce a page offset in transport data structures to
    describe the location of the buffer within the page.
    
    Also change the function to pass the page offset when sending data to
    transport.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4f674b75bbc8..8d16c3e450da 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -176,6 +176,7 @@ struct smb_rqst {
 	struct kvec	*rq_iov;	/* array of kvecs */
 	unsigned int	rq_nvec;	/* number of kvecs in array */
 	struct page	**rq_pages;	/* pointer to array of page ptrs */
+	unsigned int	rq_offset;	/* the offset to the 1st page */
 	unsigned int	rq_npages;	/* number pages in array */
 	unsigned int	rq_pagesz;	/* page size to use */
 	unsigned int	rq_tailsz;	/* length of last page */
@@ -1174,6 +1175,7 @@ struct cifs_readdata {
 	struct smbd_mr			*mr;
 #endif
 	unsigned int			pagesz;
+	unsigned int			page_offset;
 	unsigned int			tailsz;
 	unsigned int			credits;
 	unsigned int			nr_pages;
@@ -1199,6 +1201,7 @@ struct cifs_writedata {
 	struct smbd_mr			*mr;
 #endif
 	unsigned int			pagesz;
+	unsigned int			page_offset;
 	unsigned int			tailsz;
 	unsigned int			credits;
 	unsigned int			nr_pages;

commit 96164ab2d880c9539989bea68d4790f6fd619b1f
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Apr 26 08:10:18 2018 -0600

    cifs: store the leaseKey in the fid on SMB2_open
    
    In SMB2_open(), if we got a lease we need to store this in the fid structure
    or else we will never be able to map a lease break back to which file/fid
    it applies to.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d71585025ef6..4f674b75bbc8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -417,7 +417,7 @@ struct smb_version_operations {
 	/* create lease context buffer for CREATE request */
 	char * (*create_lease_buf)(u8 *, u8);
 	/* parse lease context buffer and return oplock/epoch info */
-	__u8 (*parse_lease_buf)(void *, unsigned int *);
+	__u8 (*parse_lease_buf)(void *buf, unsigned int *epoch, char *lkey);
 	ssize_t (*copychunk_range)(const unsigned int,
 			struct cifsFileInfo *src_file,
 			struct cifsFileInfo *target_file,

commit 9ec672bd17131fe26c966960a573a76fdb1da323
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Sun Apr 22 15:30:12 2018 -0600

    cifs: update calc_size to take a server argument
    
    and change the smb2 version to take heder_preamble_size into account
    instead of hardcoding it as 4 bytes.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0e2b145aba46..d71585025ef6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -372,7 +372,7 @@ struct smb_version_operations {
 	int (*close_dir)(const unsigned int, struct cifs_tcon *,
 			 struct cifs_fid *);
 	/* calculate a size of SMB message */
-	unsigned int (*calc_smb_size)(void *);
+	unsigned int (*calc_smb_size)(void *buf, struct TCP_Server_Info *ptcpi);
 	/* check for STATUS_PENDING and process it in a positive case */
 	bool (*is_status_pending)(char *, struct TCP_Server_Info *, int);
 	/* check for STATUS_NETWORK_SESSION_EXPIRED */

commit 14547f7d74c4a2583214693f69d45374b8028649
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Sun Apr 22 14:45:53 2018 -0600

    cifs: add server argument to the dump_detail method
    
    We need a struct TCP_Server_Info *server to this method as it calls
    calc_size. The calc_size method will soon be changed to also
    take a server argument.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6cc27f9c33a4..0e2b145aba46 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -244,7 +244,7 @@ struct smb_version_operations {
 	int (*map_error)(char *, bool);
 	/* find mid corresponding to the response message */
 	struct mid_q_entry * (*find_mid)(struct TCP_Server_Info *, char *);
-	void (*dump_detail)(void *);
+	void (*dump_detail)(void *buf, struct TCP_Server_Info *ptcp_info);
 	void (*clear_stats)(struct cifs_tcon *);
 	void (*print_stats)(struct seq_file *m, struct cifs_tcon *);
 	void (*dump_share_caps)(struct seq_file *, struct cifs_tcon *);

commit 3d4ef9a15343f038ccae17f60468569f23113312
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Apr 25 22:19:09 2018 -0500

    smb3: fix redundant opens on root
    
    In SMB2/SMB3 unlike in cifs we unnecessarily open the root of the share
    over and over again in various places during mount and path revalidation
    and also in statfs.  This patch cuts redundant traffic (opens and closes)
    by simply keeping the directory handle for the root around (and reopening
    it as needed on reconnect), so query calls don't require three round
    trips to copmlete - just one, and eases load on network, client and
    server (on mount alone, cuts network traffic by more than a third).
    
    Also add a new cifs mount parm "nohandlecache" to allow users whose
    servers might have resource constraints (eg in case they have a server
    with so many users connecting to it that this extra handle per mount
    could possibly be a resource concern).
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cb950a5fa078..6cc27f9c33a4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -525,6 +525,7 @@ struct smb_vol {
 	bool nullauth:1;   /* attempt to authenticate with null user */
 	bool nocase:1;     /* request case insensitive filenames */
 	bool nobrl:1;      /* disable sending byte range locks to srv */
+	bool nohandlecache:1; /* disable caching dir handles if srvr probs */
 	bool mand_lock:1;  /* send mandatory not posix byte range lock reqs */
 	bool seal:1;       /* request transport encryption on share */
 	bool nodfs:1;      /* Do not request DFS, even if available */
@@ -953,6 +954,7 @@ struct cifs_tcon {
 	bool print:1; /* set if connection to printer share */
 	bool retry:1;
 	bool nocase:1;
+	bool nohandlecache:1; /* if strange server resource prob can turn off */
 	bool seal:1;      /* transport encryption for this mounted share */
 	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */
@@ -979,6 +981,9 @@ struct cifs_tcon {
 	struct fscache_cookie *fscache;	/* cookie for share */
 #endif
 	struct list_head pending_opens;	/* list of incomplete opens */
+	bool valid_root_fid:1;	/* Do we have a useable root fid */
+	struct mutex prfid_mutex; /* prevents reopen race after dead ses*/
+	struct cifs_fid *prfid;	/* handle to the directory at top of share */
 	/* BB add field for back pointer to sb struct(s)? */
 };
 

commit e19b2bc0790a1c25b226815ce132c06274b1ba87
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Mon Apr 9 18:06:28 2018 +1000

    cifs: add resp_buf_size to the mid_q_entry structure
    
    and get rid of some more calls to get_rfc1002_length()
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5c1568ccd67d..cb950a5fa078 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1376,6 +1376,7 @@ struct mid_q_entry {
 	mid_handle_t *handle; /* call handle mid callback */
 	void *callback_data;	  /* general purpose pointer for callback */
 	void *resp_buf;		/* pointer to received SMB header */
+	unsigned int resp_buf_size;
 	int mid_state;	/* wish this were enum but can not pass to wait_event */
 	unsigned int mid_flags;
 	__le16 command;		/* smb command code */

commit 2e96467d9eb189b38954bcbbf1ee16762914f4cb
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Mon Apr 9 18:06:26 2018 +1000

    cifs: add pdu_size to the TCP_Server_Info structure
    
    and get rid of some get_rfc1002_length() in smb2
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 56fee0330afc..5c1568ccd67d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -665,6 +665,8 @@ struct TCP_Server_Info {
 	struct delayed_work	echo; /* echo ping workqueue job */
 	char	*smallbuf;	/* pointer to current "small" buffer */
 	char	*bigbuf;	/* pointer to current "big" buffer */
+	/* Total size of this PDU. Only valid from cifs_demultiplex_thread */
+	unsigned int pdu_size;
 	unsigned int total_read; /* total amount of data read in this pass */
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie   *fscache; /* client index cache cookie */

commit 5100d8a3fe034845926266a4e7f5bdcbb859088b
Author: Steve French <smfrench@gmail.com>
Date:   Mon Apr 9 10:47:14 2018 -0500

    SMB311: Improve checking of negotiate security contexts
    
    SMB3.11 crypto and hash contexts were not being checked strictly enough.
    Add parsing and validity checking for the security contexts in the SMB3.11
    negotiate response.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2282562e78a1..56fee0330afc 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -676,6 +676,7 @@ struct TCP_Server_Info {
 	unsigned int	max_read;
 	unsigned int	max_write;
 #ifdef CONFIG_CIFS_SMB311
+	__le16	cipher_type;
 	 /* save initital negprot hash */
 	__u8	preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
 #endif /* 3.1.1 */

commit 7ea884c77e5c97f1e0a1a422d961d27f78ca2745
Author: Steve French <stfrench@microsoft.com>
Date:   Sat Mar 31 18:13:38 2018 -0500

    smb3: Fix root directory when server returns inode number of zero
    
    Some servers return inode number zero for the root directory, which
    causes ls to display incorrect data (missing "." and "..").
    
    If the server returns zero for the inode number of the root directory,
    fake an inode number for it.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3e3f86841372..2282562e78a1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1470,6 +1470,7 @@ struct dfs_info3_param {
 #define CIFS_FATTR_NEED_REVAL		0x4
 #define CIFS_FATTR_INO_COLLISION	0x8
 #define CIFS_FATTR_UNKNOWN_NLINK	0x10
+#define CIFS_FATTR_FAKE_ROOT_INO	0x20
 
 struct cifs_fattr {
 	u32		cf_flags;

commit 93012bf984163f6616d1ab606a7cd86095c052c6
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Sat Mar 31 11:45:31 2018 +1100

    cifs: add server->vals->header_preamble_size
    
    This variable is set to 4 for all protocol versions and replaces
    the hardcoded constant 4 throughought the code.
    This will later be updated to reflect whether a response packet
    has a 4 byte length preamble or not once we start removing this
    field from the SMB2+ dialects.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c294093f04d5..3e3f86841372 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -468,6 +468,7 @@ struct smb_version_values {
 	__u32		exclusive_lock_type;
 	__u32		shared_lock_type;
 	__u32		unlock_lock_type;
+	size_t		header_preamble_size;
 	size_t		header_size;
 	size_t		max_header_size;
 	size_t		read_rsp_size;

commit 8bd68c6e47abff34e412a0c68cecb4a36bf0198b
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Feb 16 19:19:29 2018 +0100

    CIFS: implement v3.11 preauth integrity
    
    SMB3.11 clients must implement pre-authentification integrity.
    
    * new mechanism to certify requests/responses happening before Tree
      Connect.
    * supersedes VALIDATE_NEGOTIATE
    * fixes signing for SMB3.11
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 765fc2c9fd91..c294093f04d5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -675,7 +675,8 @@ struct TCP_Server_Info {
 	unsigned int	max_read;
 	unsigned int	max_write;
 #ifdef CONFIG_CIFS_SMB311
-	__u8	preauth_sha_hash[64]; /* save initital negprot hash */
+	 /* save initital negprot hash */
+	__u8	preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
 #endif /* 3.1.1 */
 	struct delayed_work reconnect; /* reconnect workqueue job */
 	struct mutex reconnect_mutex; /* prevent simultaneous reconnects */
@@ -864,7 +865,7 @@ struct cifs_ses {
 	__u8 smb3encryptionkey[SMB3_SIGN_KEY_SIZE];
 	__u8 smb3decryptionkey[SMB3_SIGN_KEY_SIZE];
 #ifdef CONFIG_CIFS_SMB311
-	__u8 preauth_sha_hash[64];
+	__u8 preauth_sha_hash[SMB2_PREAUTH_HASH_SIZE];
 #endif /* 3.1.1 */
 };
 

commit 5fcd7f3f966f37f3f9a215af4cc1597fe338d0d5
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Feb 16 19:19:28 2018 +0100

    CIFS: add sha512 secmech
    
    * prepare for SMB3.11 pre-auth integrity
    * enable sha512 when SMB311 is enabled in Kconfig
    * add sha512 as a soft dependency
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 48f7c197cd2d..765fc2c9fd91 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -130,10 +130,12 @@ struct cifs_secmech {
 	struct crypto_shash *md5; /* md5 hash function */
 	struct crypto_shash *hmacsha256; /* hmac-sha256 hash function */
 	struct crypto_shash *cmacaes; /* block-cipher based MAC function */
+	struct crypto_shash *sha512; /* sha512 hash function */
 	struct sdesc *sdeschmacmd5;  /* ctxt to generate ntlmv2 hash, CR1 */
 	struct sdesc *sdescmd5; /* ctxt to generate cifs/smb signature */
 	struct sdesc *sdeschmacsha256;  /* ctxt to generate smb2 signature */
 	struct sdesc *sdesccmacaes;  /* ctxt to generate smb3 signature */
+	struct sdesc *sdescsha512; /* ctxt to generate smb3.11 signing key */
 	struct crypto_aead *ccmaesencrypt; /* smb3 encryption aead */
 	struct crypto_aead *ccmaesdecrypt; /* smb3 decryption aead */
 };

commit b327a717e506980399464e304e363f94f95eb7a1
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Wed Jan 24 13:46:10 2018 +0100

    CIFS: make IPC a regular tcon
    
    * Remove ses->ipc_tid.
    * Make IPC$ regular tcon.
    * Add a direct pointer to it in ses->tcon_ipc.
    * Distinguish PIPE tcon from IPC tcon by adding a tcon->pipe flag. All
      IPC tcons are pipes but not all pipes are IPC.
    * All TreeConnect functions now cannot take a NULL tcon object.
    
    The IPC tcon has the same lifetime as the session it belongs to. It is
    created when the session is created and destroyed when the session is
    destroyed.
    
    Since no mounts directly refer to the IPC tcon, its refcount should
    always be set to initialisation value (1). Thus we make sure
    cifs_put_tcon() skips it.
    
    If the mount request resulting in a new session being created requires
    encryption, try to require it too for IPC.
    
    * set SERVER_NAME_LENGTH to serverName actual size
    
    The maximum length of an ipv6 string representation is defined in
    INET6_ADDRSTRLEN as 45+1 for null but lets keep what we know works.
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 678e638c1e69..48f7c197cd2d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -64,8 +64,8 @@
 #define RFC1001_NAME_LEN 15
 #define RFC1001_NAME_LEN_WITH_NULL (RFC1001_NAME_LEN + 1)
 
-/* currently length of NIP6_FMT */
-#define SERVER_NAME_LENGTH 40
+/* maximum length of ip addr as a string (including ipv6 and sctp) */
+#define SERVER_NAME_LENGTH 80
 #define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)
 
 /* echo interval in seconds */
@@ -833,12 +833,12 @@ static inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)
 struct cifs_ses {
 	struct list_head smb_ses_list;
 	struct list_head tcon_list;
+	struct cifs_tcon *tcon_ipc;
 	struct mutex session_mutex;
 	struct TCP_Server_Info *server;	/* pointer to server info */
 	int ses_count;		/* reference counter */
 	enum statusEnum status;
 	unsigned overrideSecFlg;  /* if non-zero override global sec flags */
-	__u32 ipc_tid;		/* special tid for connection to IPC share */
 	char *serverOS;		/* name of operating system underlying server */
 	char *serverNOS;	/* name of network operating system of server */
 	char *serverDomain;	/* security realm of server */
@@ -846,8 +846,7 @@ struct cifs_ses {
 	kuid_t linux_uid;	/* overriding owner of files on the mount */
 	kuid_t cred_uid;	/* owner of credentials */
 	unsigned int capabilities;
-	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for
-				TCP names - will ipv6 and sctp addresses fit? */
+	char serverName[SERVER_NAME_LEN_WITH_NULL];
 	char *user_name;	/* must not be null except during init of sess
 				   and after mount option parsing we fill it */
 	char *domainName;
@@ -942,7 +941,9 @@ struct cifs_tcon {
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
 	FILE_SYSTEM_UNIX_INFO fsUnixInfo;
-	bool ipc:1;		/* set if connection to IPC$ eg for RPC/PIPES */
+	bool ipc:1;   /* set if connection to IPC$ share (always also pipe) */
+	bool pipe:1;  /* set if connection to pipe share */
+	bool print:1; /* set if connection to printer share */
 	bool retry:1;
 	bool nocase:1;
 	bool seal:1;      /* transport encryption for this mounted share */
@@ -955,7 +956,6 @@ struct cifs_tcon {
 	bool need_reopen_files:1; /* need to reopen tcon file handles */
 	bool use_resilient:1; /* use resilient instead of durable handles */
 	bool use_persistent:1; /* use persistent instead of durable handles */
-	bool print:1;		/* set if connection to printer share */
 	__le32 capabilities;
 	__u32 share_flags;
 	__u32 maximal_access;

commit 74dcf418fe344657b0e48a5a4b75f935443fa53f
Author: Long Li <longli@microsoft.com>
Date:   Wed Nov 22 17:38:46 2017 -0700

    CIFS: SMBD: Read correct returned data length for RDMA write (SMB read) I/O
    
    This patch is for preparing upper layer doing SMB read via RDMA write.
    
    When RDMA write is used for SMB read, the returned data length is in
    DataRemaining in the response packet. Reading it properly by adding a
    parameter to specifiy where the returned data length is.
    
    Add the defition for memory registration to wdata and return the correct
    length based on if RDMA write is used.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 29b5a9bd3128..678e638c1e69 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -230,8 +230,14 @@ struct smb_version_operations {
 	__u64 (*get_next_mid)(struct TCP_Server_Info *);
 	/* data offset from read response message */
 	unsigned int (*read_data_offset)(char *);
-	/* data length from read response message */
-	unsigned int (*read_data_length)(char *);
+	/*
+	 * Data length from read response message
+	 * When in_remaining is true, the returned data length is in
+	 * message field DataRemaining for out-of-band data read (e.g through
+	 * Memory Registration RDMA write in SMBD).
+	 * Otherwise, the returned data length is in message field DataLength.
+	 */
+	unsigned int (*read_data_length)(char *, bool in_remaining);
 	/* map smb to linux error */
 	int (*map_error)(char *, bool);
 	/* find mid corresponding to the response message */
@@ -1152,6 +1158,9 @@ struct cifs_readdata {
 				struct cifs_readdata *rdata,
 				struct iov_iter *iter);
 	struct kvec			iov[2];
+#ifdef CONFIG_CIFS_SMB_DIRECT
+	struct smbd_mr			*mr;
+#endif
 	unsigned int			pagesz;
 	unsigned int			tailsz;
 	unsigned int			credits;

commit db223a590d45b5e584a430c46a778699a5825cdd
Author: Long Li <longli@microsoft.com>
Date:   Wed Nov 22 17:38:45 2017 -0700

    CIFS: SMBD: Upper layer performs SMB write via RDMA read through memory registration
    
    When sending I/O, if size is larger than rdma_readwrite_threshold we prepare
    to send SMB write packet for a RDMA read via memory registration. The actual
    I/O is done by remote peer through local RDMA hardware. Modify the relevant
    fields in the packet accordingly, and append a smbd_buffer_descriptor_v1 to
    the end of the SMB write packet.
    
    On write I/O finish, deregister the memory region if this was for a RDMA read.
    If remote invalidation is not used, the call to smbd_deregister_mr will do
    local invalidation and possibly wait. Memory region is normally deregistered
    in MID callback as soon as it's used. There are situations where the MID may
    not be created on I/O failure, under which memory region is deregistered when
    write data context is released.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 573a7bef8817..29b5a9bd3128 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1174,6 +1174,9 @@ struct cifs_writedata {
 	pid_t				pid;
 	unsigned int			bytes;
 	int				result;
+#ifdef CONFIG_CIFS_SMB_DIRECT
+	struct smbd_mr			*mr;
+#endif
 	unsigned int			pagesz;
 	unsigned int			tailsz;
 	unsigned int			credits;

commit 8339dd32fbad71834d61b9103e8884ada9bf3e1c
Author: Long Li <longli@microsoft.com>
Date:   Tue Nov 7 01:54:55 2017 -0700

    CIFS: SMBD: Add rdma mount option
    
    Add "rdma" to CIFS mount options to connect to SMB Direct.
    Add checks to validate this is used on SMB 3.X dialects.
    
    To connect to SMBDirect, use "mount.cifs -o rdma,vers=3.x".
    At the time of this patch, 3.x can be 3.0, 3.02 or 3.1.1.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Acked-by: Ronnie Sahlberg <lsahlber.redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b16583594d1a..573a7bef8817 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -532,6 +532,7 @@ struct smb_vol {
 	bool nopersistent:1;
 	bool resilient:1; /* noresilient not required since not fored for CA */
 	bool domainauto:1;
+	bool rdma:1;
 	unsigned int rsize;
 	unsigned int wsize;
 	bool sockopt_tcp_nodelay:1;
@@ -648,6 +649,10 @@ struct TCP_Server_Info {
 	bool	sec_kerberos;		/* supports plain Kerberos */
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
 	bool	large_buf;		/* is current buffer large? */
+	/* use SMBD connection instead of socket */
+	bool	rdma;
+	/* point to the SMBD connection if RDMA is used instead of socket */
+	struct smbd_connection *smbd_conn;
 	struct delayed_work	echo; /* echo ping workqueue job */
 	char	*smallbuf;	/* pointer to current "small" buffer */
 	char	*bigbuf;	/* pointer to current "big" buffer */

commit 1751e8a6cb935e555fcdbcb9ab4f0446e322ca3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 27 13:05:09 2017 -0800

    Rename superblock flags (MS_xyz -> SB_xyz)
    
    This is a pure automated search-and-replace of the internal kernel
    superblock flags.
    
    The s_flags are now called SB_*, with the names and the values for the
    moment mirroring the MS_* flags that they're equivalent to.
    
    Note how the MS_xyz flags are the ones passed to the mount system call,
    while the SB_xyz flags are what we then use in sb->s_flags.
    
    The script to do this was:
    
        # places to look in; re security/*: it generally should *not* be
        # touched (that stuff parses mount(2) arguments directly), but
        # there are two places where we really deal with superblock flags.
        FILES="drivers/mtd drivers/staging/lustre fs ipc mm \
                include/linux/fs.h include/uapi/linux/bfs_fs.h \
                security/apparmor/apparmorfs.c security/apparmor/include/lib.h"
        # the list of MS_... constants
        SYMS="RDONLY NOSUID NODEV NOEXEC SYNCHRONOUS REMOUNT MANDLOCK \
              DIRSYNC NOATIME NODIRATIME BIND MOVE REC VERBOSE SILENT \
              POSIXACL UNBINDABLE PRIVATE SLAVE SHARED RELATIME KERNMOUNT \
              I_VERSION STRICTATIME LAZYTIME SUBMOUNT NOREMOTELOCK NOSEC BORN \
              ACTIVE NOUSER"
    
        SED_PROG=
        for i in $SYMS; do SED_PROG="$SED_PROG -e s/MS_$i/SB_$i/g"; done
    
        # we want files that contain at least one of MS_...,
        # with fs/namespace.c and fs/pnode.c excluded.
        L=$(for i in $SYMS; do git grep -w -l MS_$i $FILES; done| sort|uniq|grep -v '^fs/namespace.c'|grep -v '^fs/pnode.c')
    
        for f in $L; do sed -i $f $SED_PROG; done
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e185b2853eab..b16583594d1a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -559,8 +559,8 @@ struct smb_vol {
 			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO | \
 			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID)
 
-#define CIFS_MS_MASK (MS_RDONLY | MS_MANDLOCK | MS_NOEXEC | MS_NOSUID | \
-		      MS_NODEV | MS_SYNCHRONOUS)
+#define CIFS_MS_MASK (SB_RDONLY | SB_MANDLOCK | SB_NOEXEC | SB_NOSUID | \
+		      SB_NODEV | SB_SYNCHRONOUS)
 
 struct cifs_mnt_data {
 	struct cifs_sb_info *cifs_sb;

commit 06e2290844fa408d3295ac03a1647f0798518ebe
Author: Steve French <smfrench@gmail.com>
Date:   Mon Sep 25 20:11:58 2017 -0500

    Fix encryption labels and lengths for SMB3.1.1
    
    SMB3.1.1 is most secure and recent dialect. Fixup labels and lengths
    for sMB3.1.1 signing and encryption.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index de5b2e1fcce5..e185b2853eab 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -661,7 +661,9 @@ struct TCP_Server_Info {
 #endif
 	unsigned int	max_read;
 	unsigned int	max_write;
-	__u8		preauth_hash[512];
+#ifdef CONFIG_CIFS_SMB311
+	__u8	preauth_sha_hash[64]; /* save initital negprot hash */
+#endif /* 3.1.1 */
 	struct delayed_work reconnect; /* reconnect workqueue job */
 	struct mutex reconnect_mutex; /* prevent simultaneous reconnects */
 	unsigned long echo_interval;
@@ -849,7 +851,9 @@ struct cifs_ses {
 	__u8 smb3signingkey[SMB3_SIGN_KEY_SIZE];
 	__u8 smb3encryptionkey[SMB3_SIGN_KEY_SIZE];
 	__u8 smb3decryptionkey[SMB3_SIGN_KEY_SIZE];
-	__u8 preauth_hash[512];
+#ifdef CONFIG_CIFS_SMB311
+	__u8 preauth_sha_hash[64];
+#endif /* 3.1.1 */
 };
 
 static inline bool

commit 9764c02fcbad40001fd3f63558d918e4d519bb75
Author: Steve French <smfrench@gmail.com>
Date:   Sun Sep 17 10:41:35 2017 -0500

    SMB3: Add support for multidialect negotiate (SMB2.1 and later)
    
    With the need to discourage use of less secure dialect, SMB1 (CIFS),
    we temporarily upgraded the dialect to SMB3 in 4.13, but since there
    are various servers which only support SMB2.1 (2.1 is more secure
    than CIFS/SMB1) but not optimal for a default dialect - add support
    for multidialect negotiation.  cifs.ko will now request SMB2.1
    or later (ie SMB2.1 or SMB3.0, SMB3.02) and the server will
    pick the latest most secure one it can support.
    
    In addition since we are sending multidialect negotiate, add
    support for secure negotiate to validate that a man in the
    middle didn't downgrade us.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable <stable@vger.kernel.org> # 4.13+

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 808486c29f0d..de5b2e1fcce5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -188,6 +188,8 @@ enum smb_version {
 #ifdef CONFIG_CIFS_SMB311
 	Smb_311,
 #endif /* SMB311 */
+	Smb_3any,
+	Smb_default,
 	Smb_version_err
 };
 
@@ -1701,6 +1703,10 @@ extern struct smb_version_values smb20_values;
 #define SMB21_VERSION_STRING	"2.1"
 extern struct smb_version_operations smb21_operations;
 extern struct smb_version_values smb21_values;
+#define SMBDEFAULT_VERSION_STRING "default"
+extern struct smb_version_values smbdefault_values;
+#define SMB3ANY_VERSION_STRING "3"
+extern struct smb_version_values smb3any_values;
 #define SMB30_VERSION_STRING	"3.0"
 extern struct smb_version_operations smb30_operations;
 extern struct smb_version_values smb30_values;

commit 5517554e43131f542e5f95c94c5cd9a1bb989fab
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Aug 24 11:24:56 2017 +1000

    cifs: Add support for writing attributes on SMB2+
    
    This adds support for writing extended attributes on SMB2+ shares.
    Attributes can be written using the setfattr command.
    
    RH-bz: 1110709
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 221693fe49ec..808486c29f0d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -421,7 +421,7 @@ struct smb_version_operations {
 			size_t, struct cifs_sb_info *);
 	int (*set_EA)(const unsigned int, struct cifs_tcon *, const char *,
 			const char *, const void *, const __u16,
-			const struct nls_table *, int);
+			const struct nls_table *, struct cifs_sb_info *);
 	struct cifs_ntsd * (*get_acl)(struct cifs_sb_info *, struct inode *,
 			const char *, u32 *);
 	struct cifs_ntsd * (*get_acl_by_fid)(struct cifs_sb_info *,

commit 2a38e12053b760a8f5e85030eb89512660077c15
Author: Steve French <smfrench@gmail.com>
Date:   Sat Jul 8 18:48:15 2017 -0500

    [SMB3] Remove ifdef since SMB3 (and later) now STRONGLY preferred
    
    Remove the CONFIG_CIFS_SMB2 ifdef and Kconfig option since they
    must always be on now.
    
    For various security reasons, SMB3 and later are STRONGLY preferred
    over CIFS and older dialects, and SMB3 (and later) will now be
    the default dialects so we do not want to allow them to be
    ifdeffed out.
    
    In the longer term, we may be able to make older CIFS support
    disableable in Kconfig with a new set of #ifdef, but we always
    want SMB3 and later support enabled.
    
    Signed-off-by: Steven French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fb482515a64b..221693fe49ec 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -29,9 +29,7 @@
 #include <crypto/internal/hash.h>
 #include <linux/scatterlist.h>
 #include <uapi/linux/cifs/cifs_mount.h>
-#ifdef CONFIG_CIFS_SMB2
 #include "smb2pdu.h"
-#endif
 
 #define CIFS_MAGIC_NUMBER 0xFF534D42      /* the first four bytes of SMB PDUs */
 
@@ -612,12 +610,10 @@ struct TCP_Server_Info {
 	__u16 sec_mode;
 	bool sign; /* is signing enabled on this connection? */
 	bool session_estab; /* mark when very first sess is established */
-#ifdef CONFIG_CIFS_SMB2
 	int echo_credits;  /* echo reserved slots */
 	int oplock_credits;  /* oplock break reserved slots */
 	bool echoes:1; /* enable echoes */
 	__u8 client_guid[SMB2_CLIENT_GUID_SIZE]; /* Client GUID */
-#endif
 	u16 dialect; /* dialect index that server chose */
 	bool oplocks:1; /* enable oplocks */
 	unsigned int maxReq;	/* Clients should submit no more */
@@ -661,13 +657,11 @@ struct TCP_Server_Info {
 	atomic_t in_send; /* requests trying to send */
 	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
 #endif
-#ifdef CONFIG_CIFS_SMB2
 	unsigned int	max_read;
 	unsigned int	max_write;
 	__u8		preauth_hash[512];
 	struct delayed_work reconnect; /* reconnect workqueue job */
 	struct mutex reconnect_mutex; /* prevent simultaneous reconnects */
-#endif /* CONFIG_CIFS_SMB2 */
 	unsigned long echo_interval;
 };
 
@@ -849,13 +843,11 @@ struct cifs_ses {
 	bool sign;		/* is signing required? */
 	bool need_reconnect:1; /* connection reset, uid now invalid */
 	bool domainAuto:1;
-#ifdef CONFIG_CIFS_SMB2
 	__u16 session_flags;
 	__u8 smb3signingkey[SMB3_SIGN_KEY_SIZE];
 	__u8 smb3encryptionkey[SMB3_SIGN_KEY_SIZE];
 	__u8 smb3decryptionkey[SMB3_SIGN_KEY_SIZE];
 	__u8 preauth_hash[512];
-#endif /* CONFIG_CIFS_SMB2 */
 };
 
 static inline bool
@@ -907,12 +899,10 @@ struct cifs_tcon {
 			atomic_t num_acl_get;
 			atomic_t num_acl_set;
 		} cifs_stats;
-#ifdef CONFIG_CIFS_SMB2
 		struct {
 			atomic_t smb2_com_sent[NUMBER_OF_SMB2_COMMANDS];
 			atomic_t smb2_com_failed[NUMBER_OF_SMB2_COMMANDS];
 		} smb2_stats;
-#endif /* CONFIG_CIFS_SMB2 */
 	} stats;
 #ifdef CONFIG_CIFS_STATS2
 	unsigned long long time_writes;
@@ -948,7 +938,6 @@ struct cifs_tcon {
 	bool need_reopen_files:1; /* need to reopen tcon file handles */
 	bool use_resilient:1; /* use resilient instead of durable handles */
 	bool use_persistent:1; /* use persistent instead of durable handles */
-#ifdef CONFIG_CIFS_SMB2
 	bool print:1;		/* set if connection to printer share */
 	__le32 capabilities;
 	__u32 share_flags;
@@ -961,7 +950,6 @@ struct cifs_tcon {
 	__u32 max_chunks;
 	__u32 max_bytes_chunk;
 	__u32 max_bytes_copy;
-#endif /* CONFIG_CIFS_SMB2 */
 #ifdef CONFIG_CIFS_FSCACHE
 	u64 resource_id;		/* server resource id */
 	struct fscache_cookie *fscache;	/* cookie for share */
@@ -1064,12 +1052,10 @@ struct cifs_open_parms {
 
 struct cifs_fid {
 	__u16 netfid;
-#ifdef CONFIG_CIFS_SMB2
 	__u64 persistent_fid;	/* persist file id for smb2 */
 	__u64 volatile_fid;	/* volatile file id for smb2 */
 	__u8 lease_key[SMB2_LEASE_KEY_SIZE];	/* lease key for smb2 */
 	__u8 create_guid[16];
-#endif
 	struct cifs_pending_open *pending_open;
 	unsigned int epoch;
 	bool purge_cache;
@@ -1107,10 +1093,8 @@ struct cifsFileInfo {
 
 struct cifs_io_parms {
 	__u16 netfid;
-#ifdef CONFIG_CIFS_SMB2
 	__u64 persistent_fid;	/* persist file id for smb2 */
 	__u64 volatile_fid;	/* volatile file id for smb2 */
-#endif
 	__u32 pid;
 	__u64 offset;
 	unsigned int length;
@@ -1236,9 +1220,7 @@ struct cifsInodeInfo {
 	u64  server_eof;		/* current file size on server -- protected by i_lock */
 	u64  uniqueid;			/* server inode number */
 	u64  createtime;		/* creation time on server */
-#ifdef CONFIG_CIFS_SMB2
 	__u8 lease_key[SMB2_LEASE_KEY_SIZE];	/* lease key for this inode */
-#endif
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie *fscache;
 #endif

commit 511c54a2f69195b28afb9dd119f03787b1625bb4
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Sat Jul 8 14:32:00 2017 -0700

    CIFS: Reconnect expired SMB sessions
    
    According to the MS-SMB2 spec (3.2.5.1.6) once the client receives
    STATUS_NETWORK_SESSION_EXPIRED error code from a server it should
    reconnect the current SMB session. Currently the client doesn't do
    that. This can result in subsequent client requests failing by
    the server. The patch adds an additional logic to the demultiplex
    thread to identify expired sessions and reconnect them.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index bcc7d9acad64..fb482515a64b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -367,6 +367,8 @@ struct smb_version_operations {
 	unsigned int (*calc_smb_size)(void *);
 	/* check for STATUS_PENDING and process it in a positive case */
 	bool (*is_status_pending)(char *, struct TCP_Server_Info *, int);
+	/* check for STATUS_NETWORK_SESSION_EXPIRED */
+	bool (*is_session_expired)(char *);
 	/* send oplock break response */
 	int (*oplock_response)(struct cifs_tcon *, struct cifs_fid *,
 			       struct cifsInodeInfo *);

commit 67b4c889cc835a2a6e2ff4e20544a33e37e2875d
Author: Steve French <smfrench@gmail.com>
Date:   Fri May 12 20:59:10 2017 -0500

    [CIFS] Minor cleanup of xattr query function
    
    Some minor cleanup of cifs query xattr functions (will also make
    SMB3 xattr implementation cleaner as well).
    
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8be55be70faf..bcc7d9acad64 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -418,7 +418,7 @@ struct smb_version_operations {
 	int (*validate_negotiate)(const unsigned int, struct cifs_tcon *);
 	ssize_t (*query_all_EAs)(const unsigned int, struct cifs_tcon *,
 			const unsigned char *, const unsigned char *, char *,
-			size_t, const struct nls_table *, int);
+			size_t, struct cifs_sb_info *);
 	int (*set_EA)(const unsigned int, struct cifs_tcon *, const char *,
 			const char *, const void *, const __u16,
 			const struct nls_table *, int);

commit 3998e6b87d4258a70df358296d6f1c7234012bfe
Author: Rabin Vincent <rabinv@axis.com>
Date:   Wed May 3 17:54:01 2017 +0200

    CIFS: fix oplock break deadlocks
    
    When the final cifsFileInfo_put() is called from cifsiod and an oplock
    break work is queued, lockdep complains loudly:
    
     =============================================
     [ INFO: possible recursive locking detected ]
     4.11.0+ #21 Not tainted
     ---------------------------------------------
     kworker/0:2/78 is trying to acquire lock:
      ("cifsiod"){++++.+}, at: flush_work+0x215/0x350
    
     but task is already holding lock:
      ("cifsiod"){++++.+}, at: process_one_work+0x255/0x8e0
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock("cifsiod");
       lock("cifsiod");
    
      *** DEADLOCK ***
    
      May be due to missing lock nesting notation
    
     2 locks held by kworker/0:2/78:
      #0:  ("cifsiod"){++++.+}, at: process_one_work+0x255/0x8e0
      #1:  ((&wdata->work)){+.+...}, at: process_one_work+0x255/0x8e0
    
     stack backtrace:
     CPU: 0 PID: 78 Comm: kworker/0:2 Not tainted 4.11.0+ #21
     Workqueue: cifsiod cifs_writev_complete
     Call Trace:
      dump_stack+0x85/0xc2
      __lock_acquire+0x17dd/0x2260
      ? match_held_lock+0x20/0x2b0
      ? trace_hardirqs_off_caller+0x86/0x130
      ? mark_lock+0xa6/0x920
      lock_acquire+0xcc/0x260
      ? lock_acquire+0xcc/0x260
      ? flush_work+0x215/0x350
      flush_work+0x236/0x350
      ? flush_work+0x215/0x350
      ? destroy_worker+0x170/0x170
      __cancel_work_timer+0x17d/0x210
      ? ___preempt_schedule+0x16/0x18
      cancel_work_sync+0x10/0x20
      cifsFileInfo_put+0x338/0x7f0
      cifs_writedata_release+0x2a/0x40
      ? cifs_writedata_release+0x2a/0x40
      cifs_writev_complete+0x29d/0x850
      ? preempt_count_sub+0x18/0xd0
      process_one_work+0x304/0x8e0
      worker_thread+0x9b/0x6a0
      kthread+0x1b2/0x200
      ? process_one_work+0x8e0/0x8e0
      ? kthread_create_on_node+0x40/0x40
      ret_from_fork+0x31/0x40
    
    This is a real warning.  Since the oplock is queued on the same
    workqueue this can deadlock if there is only one worker thread active
    for the workqueue (which will be the case during memory pressure when
    the rescuer thread is handling it).
    
    Furthermore, there is at least one other kind of hang possible due to
    the oplock break handling if there is only worker.  (This can be
    reproduced without introducing memory pressure by having passing 1 for
    the max_active parameter of cifsiod.) cifs_oplock_break() can wait
    indefintely in the filemap_fdatawait() while the cifs_writev_complete()
    work is blocked:
    
     sysrq: SysRq : Show Blocked State
       task                        PC stack   pid father
     kworker/0:1     D    0    16      2 0x00000000
     Workqueue: cifsiod cifs_oplock_break
     Call Trace:
      __schedule+0x562/0xf40
      ? mark_held_locks+0x4a/0xb0
      schedule+0x57/0xe0
      io_schedule+0x21/0x50
      wait_on_page_bit+0x143/0x190
      ? add_to_page_cache_lru+0x150/0x150
      __filemap_fdatawait_range+0x134/0x190
      ? do_writepages+0x51/0x70
      filemap_fdatawait_range+0x14/0x30
      filemap_fdatawait+0x3b/0x40
      cifs_oplock_break+0x651/0x710
      ? preempt_count_sub+0x18/0xd0
      process_one_work+0x304/0x8e0
      worker_thread+0x9b/0x6a0
      kthread+0x1b2/0x200
      ? process_one_work+0x8e0/0x8e0
      ? kthread_create_on_node+0x40/0x40
      ret_from_fork+0x31/0x40
     dd              D    0   683    171 0x00000000
     Call Trace:
      __schedule+0x562/0xf40
      ? mark_held_locks+0x29/0xb0
      schedule+0x57/0xe0
      io_schedule+0x21/0x50
      wait_on_page_bit+0x143/0x190
      ? add_to_page_cache_lru+0x150/0x150
      __filemap_fdatawait_range+0x134/0x190
      ? do_writepages+0x51/0x70
      filemap_fdatawait_range+0x14/0x30
      filemap_fdatawait+0x3b/0x40
      filemap_write_and_wait+0x4e/0x70
      cifs_flush+0x6a/0xb0
      filp_close+0x52/0xa0
      __close_fd+0xdc/0x150
      SyS_close+0x33/0x60
      entry_SYSCALL_64_fastpath+0x1f/0xbe
    
     Showing all locks held in the system:
     2 locks held by kworker/0:1/16:
      #0:  ("cifsiod"){.+.+.+}, at: process_one_work+0x255/0x8e0
      #1:  ((&cfile->oplock_break)){+.+.+.}, at: process_one_work+0x255/0x8e0
    
     Showing busy workqueues and worker pools:
     workqueue cifsiod: flags=0xc
       pwq 0: cpus=0 node=0 flags=0x0 nice=0 active=1/1
         in-flight: 16:cifs_oplock_break
         delayed: cifs_writev_complete, cifs_echo_request
     pool 0: cpus=0 node=0 flags=0x0 nice=0 hung=0s workers=3 idle: 750 3
    
    Fix these problems by creating a a new workqueue (with a rescuer) for
    the oplock break work.
    
    Signed-off-by: Rabin Vincent <rabinv@axis.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5c0e11a166ff..8be55be70faf 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1702,6 +1702,7 @@ void cifs_oplock_break(struct work_struct *work);
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;
+extern struct workqueue_struct *cifsoplockd_wq;
 extern __u32 cifs_lock_secret;
 
 extern mempool_t *cifs_mid_poolp;

commit c610c4b619e53494d9c512fa0333e28c732e976f
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Tue Apr 25 11:52:31 2017 -0700

    CIFS: Add asynchronous write support through kernel AIO
    
    This patch adds support to process write calls passed by io_submit()
    asynchronously. It based on the previously introduced async context
    that allows to process i/o responses in a separate thread and
    return the caller immediately for asynchronous calls.
    
    This improves writing performance of single threaded applications
    with increasing of i/o queue depth size.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9438c7cd8dc7..5c0e11a166ff 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1124,6 +1124,7 @@ struct cifs_aio_ctx {
 	struct kiocb		*iocb;
 	struct cifsFileInfo	*cfile;
 	struct bio_vec		*bv;
+	loff_t			pos;
 	unsigned int		npages;
 	ssize_t			rc;
 	unsigned int		len;
@@ -1171,6 +1172,7 @@ struct cifs_writedata {
 	enum writeback_sync_modes	sync_mode;
 	struct work_struct		work;
 	struct cifsFileInfo		*cfile;
+	struct cifs_aio_ctx		*ctx;
 	__u64				offset;
 	pid_t				pid;
 	unsigned int			bytes;

commit 6685c5e2d1acae8e7d3b63b1a205f58420ce7150
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Tue Apr 25 11:52:30 2017 -0700

    CIFS: Add asynchronous read support through kernel AIO
    
    This patch adds support to process read calls passed by io_submit()
    asynchronously. It based on the previously introduced async context
    that allows to process i/o responses in a separate thread and
    return the caller immediately for asynchronous calls.
    
    This improves reading performance of single threaded applications
    with increasing of i/o queue depth size.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index bb412261d601..9438c7cd8dc7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1140,6 +1140,7 @@ struct cifs_readdata {
 	struct completion		done;
 	struct cifsFileInfo		*cfile;
 	struct address_space		*mapping;
+	struct cifs_aio_ctx		*ctx;
 	__u64				offset;
 	unsigned int			bytes;
 	unsigned int			got_bytes;

commit ccf7f4088af2dd6733bfcbc40b488e2484345ae5
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Tue Apr 25 11:52:29 2017 -0700

    CIFS: Add asynchronous context to support kernel AIO
    
    Currently the code doesn't recognize asynchronous calls passed
    by io_submit() and processes all calls synchronously. This is not
    what kernel AIO expects. This patch introduces a new async context
    that keeps track of all issued i/o requests and moves a response
    collecting procedure to a separate thread. This allows to return
    to a caller immediately for async calls and call iocb->ki_complete()
    once all requests are completed. For sync calls the current thread
    simply waits until all requests are completed.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 37f5a41cc50c..bb412261d601 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1115,6 +1115,22 @@ struct cifs_io_parms {
 	struct cifs_tcon *tcon;
 };
 
+struct cifs_aio_ctx {
+	struct kref		refcount;
+	struct list_head	list;
+	struct mutex		aio_mutex;
+	struct completion	done;
+	struct iov_iter		iter;
+	struct kiocb		*iocb;
+	struct cifsFileInfo	*cfile;
+	struct bio_vec		*bv;
+	unsigned int		npages;
+	ssize_t			rc;
+	unsigned int		len;
+	unsigned int		total_len;
+	bool			should_dirty;
+};
+
 struct cifs_readdata;
 
 /* asynchronous read support */

commit a0918f1ce6a43ac980b42b300ec443c154970979
Author: Germano Percossi <germano.percossi@citrix.com>
Date:   Fri Apr 7 12:29:37 2017 +0100

    CIFS: remove bad_network_name flag
    
    STATUS_BAD_NETWORK_NAME can be received during node failover,
    causing the flag to be set and making the reconnect thread
    always unsuccessful, thereafter.
    
    Once the only place where it is set is removed, the remaining
    bits are rendered moot.
    
    Removing it does not prevent "mount" from failing when a non
    existent share is passed.
    
    What happens when the share really ceases to exist while the
    share is mounted is undefined now as much as it was before.
    
    Signed-off-by: Germano Percossi <germano.percossi@citrix.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d07f13a63369..37f5a41cc50c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -948,7 +948,6 @@ struct cifs_tcon {
 	bool use_persistent:1; /* use persistent instead of durable handles */
 #ifdef CONFIG_CIFS_SMB2
 	bool print:1;		/* set if connection to printer share */
-	bool bad_network_name:1; /* set if ret status STATUS_BAD_NETWORK_NAME */
 	__le32 capabilities;
 	__u32 share_flags;
 	__u32 maximal_access;

commit 620d8745b35daaf507186c26b40c7ea02aed131e
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Fri Feb 10 16:03:51 2017 +0530

    Introduce cifs_copy_file_range()
    
    The earlier changes to copy range for cifs unintentionally disabled the more
    common form of server side copy.
    
    The patch introduces the file_operations helper cifs_copy_file_range()
    which is used by the syscall copy_file_range. The new file operations
    helper allows us to perform server side copies for SMB2.0 and 2.1
    servers as well as SMB 3.0+ servers which do not support the ioctl
    FSCTL_DUPLICATE_EXTENTS_TO_FILE.
    
    The new helper uses the ioctl FSCTL_SRV_COPYCHUNK_WRITE to perform
    server side copies. The helper is called by vfs_copy_file_range() only
    once an attempt to clone the file using the ioctl
    FSCTL_DUPLICATE_EXTENTS_TO_FILE has failed.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable  <stable@vger.kernel.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 57c594827cb3..d07f13a63369 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -408,10 +408,10 @@ struct smb_version_operations {
 	char * (*create_lease_buf)(u8 *, u8);
 	/* parse lease context buffer and return oplock/epoch info */
 	__u8 (*parse_lease_buf)(void *, unsigned int *);
-	int (*copychunk_range)(const unsigned int,
+	ssize_t (*copychunk_range)(const unsigned int,
 			struct cifsFileInfo *src_file,
-			struct cifsFileInfo *target_file, u64 src_off, u64 len,
-			u64 dest_off);
+			struct cifsFileInfo *target_file,
+			u64 src_off, u64 len, u64 dest_off);
 	int (*duplicate_extents)(const unsigned int, struct cifsFileInfo *src,
 			struct cifsFileInfo *target_file, u64 src_off, u64 len,
 			u64 dest_off);

commit 312bbc5946c4b73dfc1d64c1dd5b0f9df8016587
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue Apr 4 02:12:04 2017 -0500

    SMB3: Rename clone_range to copychunk_range
    
    Server side copy is one of the most important mechanisms smb2/smb3
    supports and it was unintentionally disabled for most use cases.
    
    Renaming calls to reflect the underlying smb2 ioctl called. This is
    similar to the name duplicate_extents used for a similar ioctl which is
    also used to duplicate files by reusing fs blocks. The name change is to
    avoid confusion.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c34bdb12c8e6..57c594827cb3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -408,7 +408,8 @@ struct smb_version_operations {
 	char * (*create_lease_buf)(u8 *, u8);
 	/* parse lease context buffer and return oplock/epoch info */
 	__u8 (*parse_lease_buf)(void *, unsigned int *);
-	int (*clone_range)(const unsigned int, struct cifsFileInfo *src_file,
+	int (*copychunk_range)(const unsigned int,
+			struct cifsFileInfo *src_file,
 			struct cifsFileInfo *target_file, u64 src_off, u64 len,
 			u64 dest_off);
 	int (*duplicate_extents)(const unsigned int, struct cifsFileInfo *src,

commit 38bd49064a1ecb67baad33598e3d824448ab11ec
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Fri Mar 3 15:41:38 2017 -0800

    Handle mismatched open calls
    
    A signal can interrupt a SendReceive call which result in incoming
    responses to the call being ignored. This is a problem for calls such as
    open which results in the successful response being ignored. This
    results in an open file resource on the server.
    
    The patch looks into responses which were cancelled after being sent and
    in case of successful open closes the open fids.
    
    For this patch, the check is only done in SendReceive2()
    
    RH-bz: 1403319
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Cc: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d42dd3288647..c34bdb12c8e6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -243,6 +243,7 @@ struct smb_version_operations {
 	/* verify the message */
 	int (*check_message)(char *, unsigned int, struct TCP_Server_Info *);
 	bool (*is_oplock_break)(char *, struct TCP_Server_Info *);
+	int (*handle_cancelled_mid)(char *, struct TCP_Server_Info *);
 	void (*downgrade_oplock)(struct TCP_Server_Info *,
 					struct cifsInodeInfo *, bool);
 	/* process transaction2 response */
@@ -1343,6 +1344,7 @@ struct mid_q_entry {
 	void *callback_data;	  /* general purpose pointer for callback */
 	void *resp_buf;		/* pointer to received SMB header */
 	int mid_state;	/* wish this were enum but can not pass to wait_event */
+	unsigned int mid_flags;
 	__le16 command;		/* smb command code */
 	bool large_buf:1;	/* if valid response, is pointer to large buf */
 	bool multiRsp:1;	/* multiple trans2 responses for one request  */
@@ -1350,6 +1352,12 @@ struct mid_q_entry {
 	bool decrypted:1;	/* decrypted entry */
 };
 
+struct close_cancelled_open {
+	struct cifs_fid         fid;
+	struct cifs_tcon        *tcon;
+	struct work_struct      work;
+};
+
 /*	Make code in transport.c a little cleaner by moving
 	update of optional stats into function below */
 #ifdef CONFIG_CIFS_STATS2
@@ -1481,6 +1489,9 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 #define   MID_RESPONSE_MALFORMED 0x10
 #define   MID_SHUTDOWN		 0x20
 
+/* Flags */
+#define   MID_WAIT_CANCELLED	 1 /* Cancelled while waiting for response */
+
 /* Types of response buffer returned from SendReceive2 */
 #define   CIFS_NO_BUFFER        0    /* Response buffer not returned */
 #define   CIFS_SMALL_BUFFER     1

commit ef65aaede23f75977af56a8c330bb9be8c6e125c
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Wed Jan 18 15:35:57 2017 +0530

    smb2: Enforce sec= mount option
    
    If the security type specified using a mount option is not supported,
    the SMB2 session setup code changes the security type to RawNTLMSSP. We
    should instead fail the mount and return an error.
    
    The patch changes the code for SMB2 to make it similar to the code used
    for SMB1. Like in SMB1, we now use the global security flags to select
    the security method to be used when no security method is specified and
    to return an error when the requested auth method is not available.
    
    For SMB2, we also use ntlmv2 as a synonym for nltmssp.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Acked-by: Pavel Shilovsky <pshilov@microsoft.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index af224cda8697..d42dd3288647 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -443,6 +443,9 @@ struct smb_version_operations {
 	int (*is_transform_hdr)(void *buf);
 	int (*receive_transform)(struct TCP_Server_Info *,
 				 struct mid_q_entry **);
+	enum securityEnum (*select_sectype)(struct TCP_Server_Info *,
+			    enum securityEnum);
+
 };
 
 struct smb_version_values {

commit 7f9f6d2ec51449a20bc35359c9e190bf861b57e1
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Tue Feb 28 15:26:30 2017 +0100

    CIFS: let ses->ipc_tid hold smb2 TreeIds
    
    the TreeId field went from 2 bytes in CIFS to 4 bytes in SMB2+. this
    commit updates the size of the ipc_tid field of a cifs_ses, which was
    still using 2 bytes.
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1a90bb3e2986..af224cda8697 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -822,7 +822,7 @@ struct cifs_ses {
 	int ses_count;		/* reference counter */
 	enum statusEnum status;
 	unsigned overrideSecFlg;  /* if non-zero override global sec flags */
-	__u16 ipc_tid;		/* special tid for connection to IPC share */
+	__u32 ipc_tid;		/* special tid for connection to IPC share */
 	char *serverOS;		/* name of operating system underlying server */
 	char *serverNOS;	/* name of network operating system of server */
 	char *serverDomain;	/* security realm of server */

commit 4326ed2f6a16ae9d33e4209b540dc9a371aba840
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Thu Nov 17 15:24:46 2016 -0800

    CIFS: Decrypt and process small encrypted packets
    
    Allow to decrypt transformed packets, find a corresponding mid
    and process as usual further.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d6172c8b61bf..1a90bb3e2986 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1344,6 +1344,7 @@ struct mid_q_entry {
 	bool large_buf:1;	/* if valid response, is pointer to large buf */
 	bool multiRsp:1;	/* multiple trans2 responses for one request  */
 	bool multiEnd:1;	/* both received */
+	bool decrypted:1;	/* decrypted entry */
 };
 
 /*	Make code in transport.c a little cleaner by moving

commit d70b9104b1ca586f73aaf59426756cec3325a40e
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Thu Nov 17 16:20:18 2016 -0800

    CIFS: Add copy into pages callback for a read operation
    
    Since we have two different types of reads (pagecache and direct)
    we need to process such responses differently after decryption of
    a packet. The change allows to specify a callback that copies a read
    payload data into preallocated pages.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8a04a013a4ac..d6172c8b61bf 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1129,6 +1129,9 @@ struct cifs_readdata {
 	int (*read_into_pages)(struct TCP_Server_Info *server,
 				struct cifs_readdata *rdata,
 				unsigned int len);
+	int (*copy_into_pages)(struct TCP_Server_Info *server,
+				struct cifs_readdata *rdata,
+				struct iov_iter *iter);
 	struct kvec			iov[2];
 	unsigned int			pagesz;
 	unsigned int			tailsz;

commit 9b7c18a2d4b798963ea80f6769701dcc4c24b55e
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Wed Nov 16 14:06:17 2016 -0800

    CIFS: Add mid handle callback
    
    We need to process read responses differently because the data
    should go directly into preallocated pages. This can be done
    by specifying a mid handle callback.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 35cf62ba5416..8a04a013a4ac 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1312,6 +1312,13 @@ typedef int (mid_receive_t)(struct TCP_Server_Info *server,
  */
 typedef void (mid_callback_t)(struct mid_q_entry *mid);
 
+/*
+ * This is the protopyte for mid handle function. This is called once the mid
+ * has been recognized after decryption of the message.
+ */
+typedef int (mid_handle_t)(struct TCP_Server_Info *server,
+			    struct mid_q_entry *mid);
+
 /* one of these for every pending CIFS request to the server */
 struct mid_q_entry {
 	struct list_head qhead;	/* mids waiting on reply from this server */
@@ -1326,6 +1333,7 @@ struct mid_q_entry {
 #endif
 	mid_receive_t *receive; /* call receive callback */
 	mid_callback_t *callback; /* call completion callback */
+	mid_handle_t *handle; /* call handle mid callback */
 	void *callback_data;	  /* general purpose pointer for callback */
 	void *resp_buf;		/* pointer to received SMB header */
 	int mid_state;	/* wish this were enum but can not pass to wait_event */

commit 9bb17e0916a03ab901fb684e874d77a1e96b3d1e
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Thu Nov 17 15:24:34 2016 -0800

    CIFS: Add transform header handling callbacks
    
    We need to recognize and parse transformed packets in demultiplex
    thread to find a corresponsing mid and process it further.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 14196e00f79e..35cf62ba5416 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -440,6 +440,9 @@ struct smb_version_operations {
 				 struct smb_rqst *);
 	/* free transform request */
 	void (*free_transform_rq)(struct smb_rqst *);
+	int (*is_transform_hdr)(void *buf);
+	int (*receive_transform)(struct TCP_Server_Info *,
+				 struct mid_q_entry **);
 };
 
 struct smb_version_values {

commit 026e93dc0a3eefb0be060bcb9ecd8d7a7fd5c398
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Thu Nov 3 16:47:37 2016 -0700

    CIFS: Encrypt SMB3 requests before sending
    
    This change allows to encrypt packets if it is required by a server
    for SMB sessions or tree connections.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ff7114d27a69..14196e00f79e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -136,6 +136,8 @@ struct cifs_secmech {
 	struct sdesc *sdescmd5; /* ctxt to generate cifs/smb signature */
 	struct sdesc *sdeschmacsha256;  /* ctxt to generate smb2 signature */
 	struct sdesc *sdesccmacaes;  /* ctxt to generate smb3 signature */
+	struct crypto_aead *ccmaesencrypt; /* smb3 encryption aead */
+	struct crypto_aead *ccmaesdecrypt; /* smb3 decryption aead */
 };
 
 /* per smb session structure/fields */

commit 7fb8986e7449d0a5cebd84d059927afa423fbf85
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Mon Oct 31 13:49:30 2016 -0700

    CIFS: Add capability to transform requests before sending
    
    This will allow us to do protocol specific tranformations of packets
    before sending to the server. For SMB3 it can be used to support
    encryption.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index eb0ffac73f90..ff7114d27a69 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -433,6 +433,11 @@ struct smb_version_operations {
 	bool (*dir_needs_close)(struct cifsFileInfo *);
 	long (*fallocate)(struct file *, struct cifs_tcon *, int, loff_t,
 			  loff_t);
+	/* init transform request - used for encryption for now */
+	int (*init_transform_rq)(struct TCP_Server_Info *, struct smb_rqst *,
+				 struct smb_rqst *);
+	/* free transform request */
+	void (*free_transform_rq)(struct smb_rqst *);
 };
 
 struct smb_version_values {
@@ -1475,7 +1480,9 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 #define   CIFS_OBREAK_OP   0x0100    /* oplock break request */
 #define   CIFS_NEG_OP      0x0200    /* negotiate request */
 #define   CIFS_OP_MASK     0x0380    /* mask request type */
+
 #define   CIFS_HAS_CREDITS 0x0400    /* already has credits */
+#define   CIFS_TRANSFORM_REQ 0x0800    /* transform request before sending */
 
 /* Security Flags: indicate type of session setup needed */
 #define   CIFSSEC_MAY_SIGN	0x00001

commit 738f9de5cdb9175c19d24cfdf90b4543fc3b47bf
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Wed Nov 23 15:14:57 2016 -0800

    CIFS: Send RFC1001 length in a separate iov
    
    In order to simplify further encryption support we need to separate
    RFC1001 length and SMB2 header when sending a request. Put the length
    field in iov[0] and the rest of the packet into following iovs.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6d5fc87ba335..eb0ffac73f90 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1119,7 +1119,7 @@ struct cifs_readdata {
 	int (*read_into_pages)(struct TCP_Server_Info *server,
 				struct cifs_readdata *rdata,
 				unsigned int len);
-	struct kvec			iov;
+	struct kvec			iov[2];
 	unsigned int			pagesz;
 	unsigned int			tailsz;
 	unsigned int			credits;

commit fb2036d817584df42504910fe104f68517e8990e
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Wed Nov 23 15:08:14 2016 -0800

    CIFS: Make send_cancel take rqst as argument
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7ea8a3393936..6d5fc87ba335 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -208,7 +208,7 @@ struct cifsInodeInfo;
 struct cifs_open_parms;
 
 struct smb_version_operations {
-	int (*send_cancel)(struct TCP_Server_Info *, void *,
+	int (*send_cancel)(struct TCP_Server_Info *, struct smb_rqst *,
 			   struct mid_q_entry *);
 	bool (*compare_fids)(struct cifsFileInfo *, struct cifsFileInfo *);
 	/* setup request: allocate mid, sign message */

commit 395664439c4945e4827543e3ca80f7b74e1bf733
Author: Germano Percossi <germano.percossi@citrix.com>
Date:   Thu Dec 15 12:31:18 2016 +0530

    Fix default behaviour for empty domains and add domainauto option
    
    With commit 2b149f119 many things have been fixed/introduced.
    However, the default behaviour for RawNTLMSSP authentication
    seems to be wrong in case the domain is not passed on the command line.
    
    The main points (see below) of the patch are:
     - It alignes behaviour with Windows clients
     - It fixes backward compatibility
     - It fixes UPN
    
    I compared this behavour with the one from a Windows 10 command line
    client. When no domains are specified on the command line, I traced
    the packets and observed that the client does send an empty
    domain to the server.
    In the linux kernel case, the empty domain is replaced by the
    primary domain communicated by the SMB server.
    This means that, if the credentials are valid against the local server
    but that server is part of a domain, then the kernel module will
    ask to authenticate against that domain and we will get LOGON failure.
    
    I compared the packet trace from the smbclient when no domain is passed
    and, in that case, a default domain from the client smb.conf is taken.
    Apparently, connection succeeds anyway, because when the domain passed
    is not valid (in my case WORKGROUP), then the local one is tried and
    authentication succeeds. I tried with any kind of invalid domain and
    the result was always a connection.
    
    So, trying to interpret what to do and picking a valid domain if none
    is passed, seems the wrong thing to do.
    To this end, a new option "domainauto" has been added in case the
    user wants a mechanism for guessing.
    
    Without this patch, backward compatibility also is broken.
    With kernel 3.10, the default auth mechanism was NTLM.
    One of our testing servers accepted NTLM and, because no
    domains are passed, authentication was local.
    
    Moving to RawNTLMSSP forced us to change our command line
    to add a fake domain to pass to prevent this mechanism to kick in.
    
    For the same reasons, UPN is broken because the domain is specified
    in the username.
    The SMB server will work out the domain from the UPN and authenticate
    against the right server.
    Without the patch, though, given the domain is empty, it gets replaced
    with another domain that could be the wrong one for the authentication.
    
    Signed-off-by: Germano Percossi <germano.percossi@citrix.com>
    Acked-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 59ab5a29d256..7ea8a3393936 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -514,6 +514,7 @@ struct smb_vol {
 	bool persistent:1;
 	bool nopersistent:1;
 	bool resilient:1; /* noresilient not required since not fored for CA */
+	bool domainauto:1;
 	unsigned int rsize;
 	unsigned int wsize;
 	bool sockopt_tcp_nodelay:1;
@@ -830,6 +831,7 @@ struct cifs_ses {
 	enum securityEnum sectype; /* what security flavor was specified? */
 	bool sign;		/* is signing required? */
 	bool need_reconnect:1; /* connection reset, uid now invalid */
+	bool domainAuto:1;
 #ifdef CONFIG_CIFS_SMB2
 	__u16 session_flags;
 	__u8 smb3signingkey[SMB3_SIGN_KEY_SIZE];

commit 96a988ffeb90dba33a71c3826086fe67c897a183
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Tue Nov 29 11:31:23 2016 -0800

    CIFS: Fix a possible double locking of mutex during reconnect
    
    With the current code it is possible to lock a mutex twice when
    a subsequent reconnects are triggered. On the 1st reconnect we
    reconnect sessions and tcons and then persistent file handles.
    If the 2nd reconnect happens during the reconnecting of persistent
    file handles then the following sequence of calls is observed:
    
    cifs_reopen_file -> SMB2_open -> small_smb2_init -> smb2_reconnect
    -> cifs_reopen_persistent_file_handles -> cifs_reopen_file (again!).
    
    So, we are trying to acquire the same cfile->fh_mutex twice which
    is wrong. Fix this by moving reconnecting of persistent handles to
    the delayed work (smb2_reconnect_server) and submitting this work
    every time we reconnect tcon in SMB2 commands handling codepath.
    
    This can also lead to corruption of a temporary file list in
    cifs_reopen_persistent_file_handles() because we can recursively
    call this function twice.
    
    Cc: Stable <stable@vger.kernel.org> # v4.9+
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 89a0d7f17cc7..59ab5a29d256 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -926,6 +926,7 @@ struct cifs_tcon {
 	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
 	bool broken_sparse_sup; /* if server or share does not support sparse */
 	bool need_reconnect:1; /* connection reset, tid now invalid */
+	bool need_reopen_files:1; /* need to reopen tcon file handles */
 	bool use_resilient:1; /* use resilient instead of durable handles */
 	bool use_persistent:1; /* use persistent instead of durable handles */
 #ifdef CONFIG_CIFS_SMB2

commit 53e0e11efe9289535b060a51d4cf37c25e0d0f2b
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Fri Nov 4 11:50:31 2016 -0700

    CIFS: Fix a possible memory corruption during reconnect
    
    We can not unlock/lock cifs_tcp_ses_lock while walking through ses
    and tcon lists because it can corrupt list iterator pointers and
    a tcon structure can be released if we don't hold an extra reference.
    Fix it by moving a reconnect process to a separate delayed work
    and acquiring a reference to every tcon that needs to be reconnected.
    Also do not send an echo request on newly established connections.
    
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3e95191fcb95..89a0d7f17cc7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -647,6 +647,8 @@ struct TCP_Server_Info {
 	unsigned int	max_read;
 	unsigned int	max_write;
 	__u8		preauth_hash[512];
+	struct delayed_work reconnect; /* reconnect workqueue job */
+	struct mutex reconnect_mutex; /* prevent simultaneous reconnects */
 #endif /* CONFIG_CIFS_SMB2 */
 	unsigned long echo_interval;
 };
@@ -850,6 +852,7 @@ cap_unix(struct cifs_ses *ses)
 struct cifs_tcon {
 	struct list_head tcon_list;
 	int tc_count;
+	struct list_head rlist; /* reconnect list */
 	struct list_head openFileList;
 	spinlock_t open_file_lock; /* protects list above */
 	struct cifs_ses *ses;	/* pointer to session associated with */

commit 8b217fe7fcadd162944a88b14990b9723c27419f
Author: Steve French <smfrench@gmail.com>
Date:   Fri Nov 11 22:36:20 2016 -0600

    SMB3: parsing for new snapshot timestamp mount parm
    
    New mount option "snapshot=<time>" to allow mounting an earlier
    version of the remote volume (if such a snapshot exists on
    the server).
    
    Note that eventually specifying a snapshot time of 1 will allow
    the user to mount the oldest snapshot. A subsequent patch
    add the processing for that and another for actually specifying
    the "time warp" create context on SMB2/SMB3 open.
    
    Check to make sure SMB2 negotiated, and ensure that
    we use a different tcon if mount same share twice
    but with different snaphshot times
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1f17f6bd7a60..3e95191fcb95 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -525,6 +525,7 @@ struct smb_vol {
 	struct sockaddr_storage srcaddr; /* allow binding to a local IP */
 	struct nls_table *local_nls;
 	unsigned int echo_interval; /* echo interval in secs */
+	__u64 snapshot_time; /* needed for timewarp tokens */
 	unsigned int max_credits; /* smb3 max_credits 10 < credits < 60000 */
 };
 
@@ -932,6 +933,7 @@ struct cifs_tcon {
 	__u32 maximal_access;
 	__u32 vol_serial_number;
 	__le64 vol_create_time;
+	__u64 snapshot_time; /* for timewarp tokens - timestamp of snapshot */
 	__u32 ss_flags;		/* sector size flags */
 	__u32 perf_sector_size; /* best sector size for perf */
 	__u32 max_chunks;

commit 9593265531fa66177a0547e63abd99907ec0a687
Author: Steve French <smfrench@gmail.com>
Date:   Fri Sep 23 01:36:34 2016 -0500

    CIFS: Add new mount option to set owner uid and gid from special sids in acl
    
    Add "idsfromsid" mount option to indicate to cifs.ko that it should
    try to retrieve the uid and gid owner fields from special sids in the
    ACL if present.  This first patch just adds the parsing for the mount
    option.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by:  Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0c828d3c48c3..1f17f6bd7a60 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -478,6 +478,7 @@ struct smb_vol {
 	bool retry:1;
 	bool intr:1;
 	bool setuids:1;
+	bool setuidfromacl:1;
 	bool override_uid:1;
 	bool override_gid:1;
 	bool dynperm:1;

commit f2cca6a7c99fdeadacd0bdc37d825c4bc2b03653
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Fri Oct 7 17:26:36 2016 -0700

    CIFS: Fix persistent handles re-opening on reconnect
    
    openFileList of tcon can be changed while cifs_reopen_file() is called
    that can lead to an unexpected behavior when we return to the loop.
    Fix this by introducing a temp list for keeping all file handles that
    need to be reopen.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d9a17288baf3..0c828d3c48c3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1065,6 +1065,7 @@ struct cifsFileInfo {
 	kuid_t uid;		/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
 	struct cifs_fid fid;	/* file id from remote */
+	struct list_head rlist; /* reconnect list */
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
 	struct dentry *dentry;

commit 834170c85978b0e85805364f623393968f7a9b5e
Author: Steve French <smfrench@gmail.com>
Date:   Fri Sep 30 21:14:26 2016 -0500

    Enable previous version support
    
    Add ioctl to query previous versions of file
    
    Allows listing snapshots on files on SMB3 mounts.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cd80594f14d0..d9a17288baf3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -388,6 +388,8 @@ struct smb_version_operations {
 	int (*calc_signature)(struct smb_rqst *, struct TCP_Server_Info *);
 	int (*set_integrity)(const unsigned int, struct cifs_tcon *tcon,
 			     struct cifsFileInfo *src_file);
+	int (*enum_snapshots)(const unsigned int xid, struct cifs_tcon *tcon,
+			     struct cifsFileInfo *src_file, void __user *);
 	int (*query_mf_symlink)(unsigned int, struct cifs_tcon *,
 				struct cifs_sb_info *, const unsigned char *,
 				char *, unsigned int *);

commit 141891f4727c08829755be6c785e125d2e96c899
Author: Steve French <smfrench@gmail.com>
Date:   Fri Sep 23 00:44:16 2016 -0500

    SMB3: Add mount parameter to allow user to override max credits
    
    Add mount option "max_credits" to allow setting maximum SMB3
    credits to any value from 10 to 64000 (default is 32000).
    This can be useful to workaround servers with problems allocating
    credits, or to throttle the client to use smaller amount of
    simultaneous i/o or to workaround server performance issues.
    
    Also adds a cap, so that even if the server granted us more than
    65000 credits due to a server bug, we would not use that many.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 65f78b7a9062..cd80594f14d0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -75,6 +75,18 @@
 #define SMB_ECHO_INTERVAL_MAX 600
 #define SMB_ECHO_INTERVAL_DEFAULT 60
 
+/*
+ * Default number of credits to keep available for SMB3.
+ * This value is chosen somewhat arbitrarily. The Windows client
+ * defaults to 128 credits, the Windows server allows clients up to
+ * 512 credits (or 8K for later versions), and the NetApp server
+ * does not limit clients at all.  Choose a high enough default value
+ * such that the client shouldn't limit performance, but allow mount
+ * to override (until you approach 64K, where we limit credits to 65000
+ * to reduce possibility of seeing more server credit overflow bugs.
+ */
+#define SMB2_MAX_CREDITS_AVAILABLE 32000
+
 #include "cifspdu.h"
 
 #ifndef XATTR_DOS_ATTRIB
@@ -510,6 +522,7 @@ struct smb_vol {
 	struct sockaddr_storage srcaddr; /* allow binding to a local IP */
 	struct nls_table *local_nls;
 	unsigned int echo_interval; /* echo interval in secs */
+	unsigned int max_credits; /* smb3 max_credits 10 < credits < 60000 */
 };
 
 #define CIFS_MOUNT_MASK (CIFS_MOUNT_NO_PERM | CIFS_MOUNT_SET_UID | \
@@ -567,7 +580,8 @@ struct TCP_Server_Info {
 	bool noblocksnd;		/* use blocking sendmsg */
 	bool noautotune;		/* do not autotune send buf sizes */
 	bool tcp_nodelay;
-	int credits;  /* send no more requests at once */
+	unsigned int credits;  /* send no more requests at once */
+	unsigned int max_credits; /* can override large 32000 default at mnt */
 	unsigned int in_flight;  /* number of requests on the wire to server */
 	spinlock_t req_lock;  /* protect the two values above */
 	struct mutex srv_mutex;

commit 3afca265b5f53a0b15b79531c13858049505582d
Author: Steve French <smfrench@gmail.com>
Date:   Thu Sep 22 18:58:16 2016 -0500

    Clarify locking of cifs file and tcon structures and make more granular
    
    Remove the global file_list_lock to simplify cifs/smb3 locking and
    have spinlocks that more closely match the information they are
    protecting.
    
    Add new tcon->open_file_lock and file->file_info_lock spinlocks.
    Locks continue to follow a heirachy,
            cifs_socket --> cifs_ses --> cifs_tcon --> cifs_file
    where global tcp_ses_lock still protects socket and cifs_ses, while the
    the newer locks protect the lower level structure's information
    (tcon and cifs_file respectively).
    
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Germano Percossi <germano.percossi@citrix.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8f1d8c1e72be..65f78b7a9062 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -833,6 +833,7 @@ struct cifs_tcon {
 	struct list_head tcon_list;
 	int tc_count;
 	struct list_head openFileList;
+	spinlock_t open_file_lock; /* protects list above */
 	struct cifs_ses *ses;	/* pointer to session associated with */
 	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
@@ -889,7 +890,7 @@ struct cifs_tcon {
 #endif /* CONFIG_CIFS_STATS2 */
 	__u64    bytes_read;
 	__u64    bytes_written;
-	spinlock_t stat_lock;
+	spinlock_t stat_lock;  /* protects the two fields above */
 #endif /* CONFIG_CIFS_STATS */
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
@@ -1040,8 +1041,10 @@ struct cifs_fid_locks {
 };
 
 struct cifsFileInfo {
+	/* following two lists are protected by tcon->open_file_lock */
 	struct list_head tlist;	/* pointer to next fid owned by tcon */
 	struct list_head flist;	/* next fid (file instance) for this inode */
+	/* lock list below protected by cifsi->lock_sem */
 	struct cifs_fid_locks *llist;	/* brlocks held by this fid */
 	kuid_t uid;		/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
@@ -1049,11 +1052,12 @@ struct cifsFileInfo {
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
 	struct dentry *dentry;
-	unsigned int f_flags;
 	struct tcon_link *tlink;
+	unsigned int f_flags;
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
-	int count;		/* refcount protected by cifs_file_list_lock */
+	int count;
+	spinlock_t file_info_lock; /* protects four flag/count fields above */
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 	struct work_struct oplock_break; /* work for oplock breaks */
@@ -1120,7 +1124,7 @@ struct cifs_writedata {
 
 /*
  * Take a reference on the file private data. Must be called with
- * cifs_file_list_lock held.
+ * cfile->file_info_lock held.
  */
 static inline void
 cifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)
@@ -1514,8 +1518,10 @@ require use of the stronger protocol */
  *  GlobalMid_Lock protects:
  *	list operations on pending_mid_q and oplockQ
  *      updates to XID counters, multiplex id  and SMB sequence numbers
- *  cifs_file_list_lock protects:
- *	list operations on tcp and SMB session lists and tCon lists
+ *  tcp_ses_lock protects:
+ *	list operations on tcp and SMB session lists
+ *  tcon->open_file_lock protects the list of open files hanging off the tcon
+ *  cfile->file_info_lock protects counters and fields in cifs file struct
  *  f_owner.lock protects certain per file struct operations
  *  mapping->page_lock protects certain per page operations
  *
@@ -1547,18 +1553,12 @@ GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;
  * tcp session, and the list of tcon's per smb session. It also protects
  * the reference counters for the server, smb session, and tcon. Finally,
  * changes to the tcon->tidStatus should be done while holding this lock.
+ * generally the locks should be taken in order tcp_ses_lock before
+ * tcon->open_file_lock and that before file->file_info_lock since the
+ * structure order is cifs_socket-->cifs_ses-->cifs_tcon-->cifs_file
  */
 GLOBAL_EXTERN spinlock_t		cifs_tcp_ses_lock;
 
-/*
- * This lock protects the cifs_file->llist and cifs_file->flist
- * list operations, and updates to some flags (cifs_file->invalidHandle)
- * It will be moved to either use the tcon->stat_lock or equivalent later.
- * If cifs_tcp_ses_lock and the lock below are both needed to be held, then
- * the cifs_tcp_ses_lock must be grabbed first and released last.
- */
-GLOBAL_EXTERN spinlock_t	cifs_file_list_lock;
-
 #ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* unused temporarily */
 /* Outstanding dir notify requests */
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;

commit 3d22462ae915743f3be5bf1ab3d4a6b72c2bb6c9
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Tue May 24 06:27:44 2016 -0400

    cifs: stuff the fl_owner into "pid" field in the lock request
    
    Right now, we send the tgid cross the wire. What we really want to send
    though is a hashed fl_owner_t since samba treats this field as a generic
    lockowner.
    
    It turns out that because we enforce and release locks locally before
    they are ever sent to the server, this patch makes no difference in
    behavior. Still, setting OFD locks on the server using the process
    pid seems wrong, so I think this patch still makes sense.
    
    Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Acked-by: Pavel Shilovsky <pshilovsky@samba.org>
    Acked-by: Sachin Prabhu <sprabhu@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index bba106cdc43c..8f1d8c1e72be 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1619,6 +1619,7 @@ void cifs_oplock_break(struct work_struct *work);
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;
+extern __u32 cifs_lock_secret;
 
 extern mempool_t *cifs_mid_poolp;
 

commit 442c9ac989d71599ebc39f4ea4d5b0e64996904b
Merge: ba5a2655c270 71335664c38f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 18 10:17:56 2016 -0700

    Merge branch 'sendmsg.cifs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull cifs iovec cleanups from Al Viro.
    
    * 'sendmsg.cifs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      cifs: don't bother with kmap on read_pages side
      cifs_readv_receive: use cifs_read_from_socket()
      cifs: no need to wank with copying and advancing iovec on recvmsg side either
      cifs: quit playing games with draining iovecs
      cifs: merge the hash calculation helpers

commit ea1754a084760e68886f5b725c8eaada9cc57155
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:48 2016 +0300

    mm, fs: remove remaining PAGE_CACHE_* and page_cache_{get,release} usage
    
    Mostly direct substitution with occasional adjustment or removing
    outdated comments.
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d21da9f05bae..f2cc0b3d1af7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -714,7 +714,7 @@ compare_mid(__u16 mid, const struct smb_hdr *smb)
  *
  * Note that this might make for "interesting" allocation problems during
  * writeback however as we have to allocate an array of pointers for the
- * pages. A 16M write means ~32kb page array with PAGE_CACHE_SIZE == 4096.
+ * pages. A 16M write means ~32kb page array with PAGE_SIZE == 4096.
  *
  * For reads, there is a similar problem as we need to allocate an array
  * of kvecs to handle the receive, though that should only need to be done
@@ -733,7 +733,7 @@ compare_mid(__u16 mid, const struct smb_hdr *smb)
 
 /*
  * The default wsize is 1M. find_get_pages seems to return a maximum of 256
- * pages in a single call. With PAGE_CACHE_SIZE == 4k, this means we can fill
+ * pages in a single call. With PAGE_SIZE == 4k, this means we can fill
  * a single wsize request with a single call.
  */
 #define CIFS_DEFAULT_IOSIZE (1024 * 1024)

commit 09aab880f7c5ac31e9db18a63353b980bcb52261
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Nov 13 03:00:17 2015 -0500

    cifs: no need to wank with copying and advancing iovec on recvmsg side either
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d21da9f05bae..df03c5e7d633 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -615,8 +615,6 @@ struct TCP_Server_Info {
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
 	bool	large_buf;		/* is current buffer large? */
 	struct delayed_work	echo; /* echo ping workqueue job */
-	struct kvec *iov;	/* reusable kvec array for receives */
-	unsigned int nr_iov;	/* number of kvecs in array */
 	char	*smallbuf;	/* pointer to current "small" buffer */
 	char	*bigbuf;	/* pointer to current "big" buffer */
 	unsigned int total_read; /* total amount of data read in this pass */

commit 1404297ebf76fd91a41de215fc8c94c2619e5fdb
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Mar 17 14:22:54 2016 -0700

    lib: update single-char callers of strtobool()
    
    Some callers of strtobool() were passing a pointer to unterminated
    strings.  In preparation of adding multi-character processing to
    kstrtobool(), update the callers to not pass single-character pointers,
    and switch to using the new kstrtobool_from_user() helper where
    possible.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Amitkumar Karwar <akarwar@marvell.com>
    Cc: Nishant Sarmukadam <nishants@marvell.com>
    Cc: Kalle Valo <kvalo@codeaurora.org>
    Cc: Steve French <sfrench@samba.org>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a25b2513f146..d21da9f05bae 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1596,11 +1596,11 @@ GLOBAL_EXTERN atomic_t midCount;
 
 /* Misc globals */
 GLOBAL_EXTERN bool enable_oplocks; /* enable or disable oplocks */
-GLOBAL_EXTERN unsigned int lookupCacheEnabled;
+GLOBAL_EXTERN bool lookupCacheEnabled;
 GLOBAL_EXTERN unsigned int global_secflags;	/* if on, session setup sent
 				with more secure ntlmssp2 challenge/resp */
 GLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
-GLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/
+GLOBAL_EXTERN bool linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/
 GLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */
 GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
 GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */

commit 373512ec5c105ed09e3738196dcb257dfab65cba
Author: Steve French <smfrench@gmail.com>
Date:   Fri Dec 18 13:05:30 2015 -0600

    Prepare for encryption support (first part). Add decryption and encryption key generation. Thanks to Metze for helping with this.
    
    Reviewed-by: Stefan Metzmacher <metze@samba.org>
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9d14926531ba..a25b2513f146 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -227,7 +227,7 @@ struct smb_version_operations {
 	void (*print_stats)(struct seq_file *m, struct cifs_tcon *);
 	void (*dump_share_caps)(struct seq_file *, struct cifs_tcon *);
 	/* verify the message */
-	int (*check_message)(char *, unsigned int);
+	int (*check_message)(char *, unsigned int, struct TCP_Server_Info *);
 	bool (*is_oplock_break)(char *, struct TCP_Server_Info *);
 	void (*downgrade_oplock)(struct TCP_Server_Info *,
 					struct cifsInodeInfo *, bool);
@@ -630,6 +630,7 @@ struct TCP_Server_Info {
 #ifdef CONFIG_CIFS_SMB2
 	unsigned int	max_read;
 	unsigned int	max_write;
+	__u8		preauth_hash[512];
 #endif /* CONFIG_CIFS_SMB2 */
 	unsigned long echo_interval;
 };
@@ -813,7 +814,10 @@ struct cifs_ses {
 	bool need_reconnect:1; /* connection reset, uid now invalid */
 #ifdef CONFIG_CIFS_SMB2
 	__u16 session_flags;
-	char smb3signingkey[SMB3_SIGN_KEY_SIZE]; /* for signing smb3 packets */
+	__u8 smb3signingkey[SMB3_SIGN_KEY_SIZE];
+	__u8 smb3encryptionkey[SMB3_SIGN_KEY_SIZE];
+	__u8 smb3decryptionkey[SMB3_SIGN_KEY_SIZE];
+	__u8 preauth_hash[512];
 #endif /* CONFIG_CIFS_SMB2 */
 };
 

commit adfeb3e00e8e1b9fb4ad19eb7367e7c272d16003
Author: Steve French <smfrench@gmail.com>
Date:   Fri Dec 18 12:31:36 2015 -0600

    cifs: Make echo interval tunable
    
    Currently the echo interval is set to 60 seconds using a macro. This
    setting determines the interval at which echo requests are sent to the
    server on an idling connection. This setting also affects the time
    required for a connection to an unresponsive server to timeout.
    
    Making this setting a tunable allows users to control the echo interval
    times as well as control the time after which the connecting to an
    unresponsive server times out.
    
    To set echo interval, pass the echo_interval=n mount option.
    
    Version four of the patch.
    v2: Change MIN and MAX timeout values
    v3: Remove incorrect comment in cifs_get_tcp_session
    v4: Fix bug in setting echo_intervalw
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2b510c537a0d..9d14926531ba 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -70,8 +70,10 @@
 #define SERVER_NAME_LENGTH 40
 #define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)
 
-/* SMB echo "timeout" -- FIXME: tunable? */
-#define SMB_ECHO_INTERVAL (60 * HZ)
+/* echo interval in seconds */
+#define SMB_ECHO_INTERVAL_MIN 1
+#define SMB_ECHO_INTERVAL_MAX 600
+#define SMB_ECHO_INTERVAL_DEFAULT 60
 
 #include "cifspdu.h"
 
@@ -507,6 +509,7 @@ struct smb_vol {
 	struct sockaddr_storage dstaddr; /* destination address */
 	struct sockaddr_storage srcaddr; /* allow binding to a local IP */
 	struct nls_table *local_nls;
+	unsigned int echo_interval; /* echo interval in secs */
 };
 
 #define CIFS_MOUNT_MASK (CIFS_MOUNT_NO_PERM | CIFS_MOUNT_SET_UID | \
@@ -628,6 +631,7 @@ struct TCP_Server_Info {
 	unsigned int	max_read;
 	unsigned int	max_write;
 #endif /* CONFIG_CIFS_SMB2 */
+	unsigned long echo_interval;
 };
 
 static inline unsigned int

commit 592fafe644bf3a48b9e00e182a67d301493634fc
Author: Steve French <smfrench@gmail.com>
Date:   Tue Nov 3 10:08:53 2015 -0600

    Add resilienthandles mount parm
    
    Since many servers (Windows clients, and non-clustered servers) do not
    support persistent handles but do support resilient handles, allow
    the user to specify a mount option "resilienthandles" in order
    to get more reliable connections and less chance of data loss
    (at least when SMB2.1 or later).  Default resilient handle
    timeout (120 seconds to recent Windows server) is used.
    
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 81273fea898f..2b510c537a0d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -496,6 +496,7 @@ struct smb_vol {
 	bool nosharesock:1;
 	bool persistent:1;
 	bool nopersistent:1;
+	bool resilient:1; /* noresilient not required since not fored for CA */
 	unsigned int rsize;
 	unsigned int wsize;
 	bool sockopt_tcp_nodelay:1;
@@ -897,6 +898,7 @@ struct cifs_tcon {
 	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
 	bool broken_sparse_sup; /* if server or share does not support sparse */
 	bool need_reconnect:1; /* connection reset, tid now invalid */
+	bool use_resilient:1; /* use resilient instead of durable handles */
 	bool use_persistent:1; /* use persistent instead of durable handles */
 #ifdef CONFIG_CIFS_SMB2
 	bool print:1;		/* set if connection to printer share */

commit b56eae4df9ef922d5785ec4a15d54d9527cedb13
Author: Steve French <smfrench@gmail.com>
Date:   Tue Nov 3 09:26:27 2015 -0600

    [SMB3] Send durable handle v2 contexts when use of persistent handles required
    
    Version 2 of the patch. Thanks to Dan Carpenter and the smatch
    tool for finding a problem in the first version of this patch.
    
    CC: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 28bd477f6e57..81273fea898f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1018,6 +1018,7 @@ struct cifs_fid {
 	__u64 persistent_fid;	/* persist file id for smb2 */
 	__u64 volatile_fid;	/* volatile file id for smb2 */
 	__u8 lease_key[SMB2_LEASE_KEY_SIZE];	/* lease key for smb2 */
+	__u8 create_guid[16];
 #endif
 	struct cifs_pending_open *pending_open;
 	unsigned int epoch;

commit b618f001a20e44f691dd0e2ffea651a40a651871
Author: Steve French <smfrench@gmail.com>
Date:   Tue Nov 3 09:15:03 2015 -0600

    [SMB3] Enable checking for continuous availability and persistent handle support
    
    Validate "persistenthandles" and "nopersistenthandles" mount options against
    the support the server claims in negotiate and tree connect SMB3 responses.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1849e29099d0..28bd477f6e57 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -897,6 +897,7 @@ struct cifs_tcon {
 	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
 	bool broken_sparse_sup; /* if server or share does not support sparse */
 	bool need_reconnect:1; /* connection reset, tid now invalid */
+	bool use_persistent:1; /* use persistent instead of durable handles */
 #ifdef CONFIG_CIFS_SMB2
 	bool print:1;		/* set if connection to printer share */
 	bool bad_network_name:1; /* set if ret status STATUS_BAD_NETWORK_NAME */

commit b2a3077414fd6ff1de8972ea55e91f27bcabd913
Author: Steve French <smfrench@gmail.com>
Date:   Tue Sep 29 21:49:28 2015 -0500

    [SMB3] Add parsing for new mount option controlling persistent handles
    
    "nopersistenthandles" and "persistenthandles" mount options added.
    The former will not request persistent handles on open even when
    SMB3 negotiated and Continuous Availability share.  The latter
    will request persistent handles (as long as server notes the
    capability in protocol negotiation) even if share is not Continuous
    Availability share.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b406a32deb1f..1849e29099d0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -493,7 +493,9 @@ struct smb_vol {
 	bool mfsymlinks:1; /* use Minshall+French Symlinks */
 	bool multiuser:1;
 	bool rwpidforward:1; /* pid forward for read/write operations */
-	bool nosharesock;
+	bool nosharesock:1;
+	bool persistent:1;
+	bool nopersistent:1;
 	unsigned int rsize;
 	unsigned int wsize;
 	bool sockopt_tcp_nodelay:1;

commit b3152e2c7aa9ad0c50085738d048fbf16d01d32d
Author: Steve French <smfrench@gmail.com>
Date:   Wed Jun 24 03:17:02 2015 -0500

    Add ioctl to set integrity
    
    set integrity increases reliability of files stored on SMB3 servers.
    Add ioctl to allow setting this on files on SMB3 and later mounts.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 81194e6c7601..b406a32deb1f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -372,6 +372,8 @@ struct smb_version_operations {
 	void (*new_lease_key)(struct cifs_fid *);
 	int (*generate_signingkey)(struct cifs_ses *);
 	int (*calc_signature)(struct smb_rqst *, struct TCP_Server_Info *);
+	int (*set_integrity)(const unsigned int, struct cifs_tcon *tcon,
+			     struct cifsFileInfo *src_file);
 	int (*query_mf_symlink)(unsigned int, struct cifs_tcon *,
 				struct cifs_sb_info *, const unsigned char *,
 				char *, unsigned int *);

commit 02b1666544c08e245cb4e2253ed575f8128943d6
Author: Steve French <steve.french@primarydata.com>
Date:   Sat Jun 27 21:18:36 2015 -0700

    Add reflink copy over SMB3.11 with new FSCTL_DUPLICATE_EXTENTS
    
     Getting fantastic copy performance with cp --reflink over SMB3.11
     using the new FSCTL_DUPLICATE_EXTENTS.
    
     This FSCTL was added in the SMB3.11 dialect (testing was
     against REFS file system) so have put it as a 3.11 protocol
     specific operation ("vers=3.1.1" on the mount).  Tested at
     the SMB3 plugfest in Redmond.
    
     It depends on the new FS Attribute (BLOCK_REFCOUNTING) which
     is used to advertise support for the ability to do this ioctl
     (if you can support multiple files pointing to the same block
     than this refcounting ability or equivalent is needed to
     support the new reflink-like duplicate extent SMB3 ioctl.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a0212ec6f701..81194e6c7601 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -390,6 +390,9 @@ struct smb_version_operations {
 	int (*clone_range)(const unsigned int, struct cifsFileInfo *src_file,
 			struct cifsFileInfo *target_file, u64 src_off, u64 len,
 			u64 dest_off);
+	int (*duplicate_extents)(const unsigned int, struct cifsFileInfo *src,
+			struct cifsFileInfo *target_file, u64 src_off, u64 len,
+			u64 dest_off);
 	int (*validate_negotiate)(const unsigned int, struct cifs_tcon *);
 	ssize_t (*query_all_EAs)(const unsigned int, struct cifs_tcon *,
 			const unsigned char *, const unsigned char *, char *,

commit aab1893d5fbeb7c931e97189f54a71ab0ecbf4c7
Author: Steve French <smfrench@gmail.com>
Date:   Tue Jun 23 23:37:11 2015 -0500

    Add SMB3.11 mount option synonym for new dialect
    
    Most people think of SMB 3.1.1 as SMB version 3.11 so add synonym
    for "vers=3.1.1" of "vers=3.11" on mount.
    
    Also make sure that unlike SMB3.0 and 3.02 we don't send
    validate negotiate on mount (it is handled by negotiate contexts) -
    add list of SMB3.11 specific functions (distinct from 3.0 dialect).
    
    Signed-off-by: Steve French <steve.french@primarydata.com>w

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 71bf86e6de9a..a0212ec6f701 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1622,6 +1622,7 @@ extern struct smb_version_values smb30_values;
 /*extern struct smb_version_operations smb302_operations;*/ /* not needed yet */
 extern struct smb_version_values smb302_values;
 #define SMB311_VERSION_STRING	"3.1.1"
-/*extern struct smb_version_operations smb311_operations;*/ /* not needed yet */
+#define ALT_SMB311_VERSION_STRING "3.11"
+extern struct smb_version_operations smb311_operations;
 extern struct smb_version_values smb311_values;
 #endif	/* _CIFS_GLOB_H */

commit 5f7fbf733c9dd6b58d40fa394313a5949b696f84
Author: Steve French <steve.french@primarydata.com>
Date:   Wed Dec 17 22:52:58 2014 -0600

    Allow parsing vers=3.11 on cifs mount
    
    Parses and recognizes "vers=3.1.1" on cifs mount and allows sending
    0x0311 as a new CIFS/SMB3 dialect. Subsequent patches will add
    the new negotiate contexts and updated session setup
    
    Reviewed-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 22b289a3b1c4..71bf86e6de9a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -171,6 +171,10 @@ enum smb_version {
 	Smb_21,
 	Smb_30,
 	Smb_302,
+#ifdef CONFIG_CIFS_SMB311
+	Smb_311,
+#endif /* SMB311 */
+	Smb_version_err
 };
 
 struct mid_q_entry;
@@ -1617,4 +1621,7 @@ extern struct smb_version_values smb30_values;
 #define SMB302_VERSION_STRING	"3.02"
 /*extern struct smb_version_operations smb302_operations;*/ /* not needed yet */
 extern struct smb_version_values smb302_values;
+#define SMB311_VERSION_STRING	"3.1.1"
+/*extern struct smb_version_operations smb311_operations;*/ /* not needed yet */
+extern struct smb_version_values smb311_values;
 #endif	/* _CIFS_GLOB_H */

commit 9235d09873316d602937b5d45c431fb653f3aed8
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue Dec 9 17:37:00 2014 +0000

    Convert MessageID in smb2_hdr to LE
    
    We have encountered failures when When testing smb2 mounts on ppc64
    machines when using both Samba as well as Windows 2012.
    
    On poking around, the problem was determined to be caused by the
    high endian MessageID passed in the header for smb2. On checking the
    corresponding MID for smb1 is converted to LE before being sent on the
    wire.
    
    We have tested this patch successfully on a ppc64 machine.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6e139111fdb2..22b289a3b1c4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -661,16 +661,16 @@ set_credits(struct TCP_Server_Info *server, const int val)
 	server->ops->set_credits(server, val);
 }
 
-static inline __u64
+static inline __le64
 get_next_mid64(struct TCP_Server_Info *server)
 {
-	return server->ops->get_next_mid(server);
+	return cpu_to_le64(server->ops->get_next_mid(server));
 }
 
 static inline __le16
 get_next_mid(struct TCP_Server_Info *server)
 {
-	__u16 mid = get_next_mid64(server);
+	__u16 mid = server->ops->get_next_mid(server);
 	/*
 	 * The value in the SMB header should be little endian for easy
 	 * on-the-wire decoding.

commit 7119e220a7aed7b6e6df02ddfaa2c5f8df2e4e3d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 22 00:25:12 2014 -0400

    cifs: get rid of ->f_path.dentry->d_sb uses, add a new helper
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 02a33e529904..6e139111fdb2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1168,6 +1168,12 @@ CIFS_SB(struct super_block *sb)
 	return sb->s_fs_info;
 }
 
+static inline struct cifs_sb_info *
+CIFS_FILE_SB(struct file *file)
+{
+	return CIFS_SB(file_inode(file)->i_sb);
+}
+
 static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
 {
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)

commit 2baa2682531ff02928e2d3904800696d9e7193db
Author: Steve French <smfrench@gmail.com>
Date:   Sat Sep 27 02:19:01 2014 -0500

    Remap reserved posix characters by default (part 3/3)
    
    This is a bigger patch, but its size is mostly due to
    a single change for how we check for remapping illegal characters
    in file names - a lot of repeated, small changes to
    the way callers request converting file names.
    
    The final patch in the series does the following:
    
    1) changes default behavior for cifs to be more intuitive.
    Currently we do not map by default to seven reserved characters,
    ie those valid in POSIX but not in NTFS/CIFS/SMB3/Windows,
    unless a mount option (mapchars) is specified.  Change this
    to by default always map and map using the SFM maping
    (like the Mac uses) unless the server negotiates the CIFS Unix
    Extensions (like Samba does when mounting with the cifs protocol)
    when the remapping of the characters is unnecessary.  This should
    help SMB3 mounts in particular since Samba will likely be
    able to implement this mapping with its new "vfs_fruit" module
    as it will be doing for the Mac.
    2) if the user specifies the existing "mapchars" mount option then
    use the "SFU" (Microsoft Services for Unix, SUA) style mapping of
    the seven characters instead.
    3) if the user specifies "nomapposix" then disable SFM/MAC style mapping
    (so no character remapping would be used unless the user specifies
    "mapchars" on mount as well, as above).
    4) change all the places in the code that check for the superblock
    flag on the mount which is set by mapchars and passed in on all
    path based operation and change it to use a small function call
    instead to set the mapping type properly (and check for the
    mapping type in the cifs unicode functions)
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index dae7e3709cc6..02a33e529904 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -466,6 +466,7 @@ struct smb_vol {
 	bool direct_io:1;
 	bool strict_io:1; /* strict cache behavior */
 	bool remap:1;      /* set to remap seven reserved chars in filenames */
+	bool sfu_remap:1;  /* remap seven reserved chars ala SFU */
 	bool posix_paths:1; /* unset to not ask for posix pathnames. */
 	bool no_linux_ext:1;
 	bool sfu_emul:1;
@@ -499,6 +500,7 @@ struct smb_vol {
 #define CIFS_MOUNT_MASK (CIFS_MOUNT_NO_PERM | CIFS_MOUNT_SET_UID | \
 			 CIFS_MOUNT_SERVER_INUM | CIFS_MOUNT_DIRECT_IO | \
 			 CIFS_MOUNT_NO_XATTR | CIFS_MOUNT_MAP_SPECIAL_CHR | \
+			 CIFS_MOUNT_MAP_SFM_CHR | \
 			 CIFS_MOUNT_UNX_EMUL | CIFS_MOUNT_NO_BRL | \
 			 CIFS_MOUNT_CIFS_ACL | CIFS_MOUNT_OVERR_UID | \
 			 CIFS_MOUNT_OVERR_GID | CIFS_MOUNT_DYNPERM | \

commit db8b631d4bc4eaa9f7e13a6b0a287306cac0cb72
Author: Steve French <smfrench@gmail.com>
Date:   Mon Sep 22 05:13:55 2014 -0500

    Allow mknod and mkfifo on SMB2/SMB3 mounts
    
    The "sfu" mount option did not work on SMB2/SMB3 mounts.
    With these changes when the "sfu" mount option is passed in
    on an smb2/smb2.1/smb3 mount the client can emulate (and
    recognize) fifo and device (character and device files).
    
    In addition the "sfu" mount option should not conflict
    with "mfsymlinks" (symlink emulation) as we will never
    create "sfu" style symlinks, but using "sfu" mount option
    will allow us to recognize existing symlinks, created with
    Microsoft "Services for Unix" (SFU and SUA).
    
    To enable the "sfu" mount option for SMB2/SMB3 the calling
    syntax of the generic cifs/smb2/smb3 sync_read and sync_write
    protocol dependent function needed to be changed (we
    don't have a file struct in all cases), but this actually
    ended up simplifying the code a little.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 25b8392bfdd2..dae7e3709cc6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -323,11 +323,11 @@ struct smb_version_operations {
 	int (*async_writev)(struct cifs_writedata *,
 			    void (*release)(struct kref *));
 	/* sync read from the server */
-	int (*sync_read)(const unsigned int, struct cifsFileInfo *,
+	int (*sync_read)(const unsigned int, struct cifs_fid *,
 			 struct cifs_io_parms *, unsigned int *, char **,
 			 int *);
 	/* sync write to the server */
-	int (*sync_write)(const unsigned int, struct cifsFileInfo *,
+	int (*sync_write)(const unsigned int, struct cifs_fid *,
 			  struct cifs_io_parms *, unsigned int *, struct kvec *,
 			  unsigned long);
 	/* open dir, start readdir */

commit 1bbe4997b13de903c421c1cc78440e544b5f9064
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri Aug 22 13:32:11 2014 +0400

    CIFS: Fix wrong filename length for SMB2
    
    The existing code uses the old MAX_NAME constant. This causes
    XFS test generic/013 to fail. Fix it by replacing MAX_NAME with
    PATH_MAX that SMB1 uses. Also remove an unused MAX_NAME constant
    definition.
    
    Cc: <stable@vger.kernel.org> # v3.7+
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index dfc731b02aa9..25b8392bfdd2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -70,11 +70,6 @@
 #define SERVER_NAME_LENGTH 40
 #define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)
 
-/* used to define string lengths for reversing unicode strings */
-/*         (256+1)*2 = 514                                     */
-/*           (max path length + 1 for null) * 2 for unicode    */
-#define MAX_NAME 514
-
 /* SMB echo "timeout" -- FIXME: tunable? */
 #define SMB_ECHO_INTERVAL (60 * HZ)
 

commit 31742c5a331766bc7df6b0d525df00c6cd20d5a6
Author: Steve French <smfrench@gmail.com>
Date:   Sun Aug 17 08:38:47 2014 -0500

    enable fallocate punch hole ("fallocate -p") for SMB3
    
    Implement FALLOC_FL_PUNCH_HOLE (which does not change the file size
    fortunately so this matches the behavior of the equivalent SMB3
    fsctl call) for SMB3 mounts.  This allows "fallocate -p" to work.
    It requires that the server support setting files as sparse
    (which Windows allows).
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ce24c1fc2123..dfc731b02aa9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -411,6 +411,8 @@ struct smb_version_operations {
 				unsigned int *, unsigned int *);
 	/* check if we need to issue closedir */
 	bool (*dir_needs_close)(struct cifsFileInfo *);
+	long (*fallocate)(struct file *, struct cifs_tcon *, int, loff_t,
+			  loff_t);
 };
 
 struct smb_version_values {

commit 52755808d4525f4d5b86d112d36ffc7a46f3fb48
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Mon Aug 18 20:49:57 2014 +0400

    CIFS: Fix SMB2 readdir error handling
    
    SMB2 servers indicates the end of a directory search with
    STATUS_NO_MORE_FILE error code that is not processed now.
    This causes generic/257 xfstest to fail. Fix this by triggering
    the end of search by this error code in SMB2_query_directory.
    
    Also when negotiating CIFS protocol we tell the server to close
    the search automatically at the end and there is no need to do
    it itself. In the case of SMB2 protocol, we need to close it
    explicitly - separate close directory checks for different
    protocols.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index bc20a6ea6754..ce24c1fc2123 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -409,6 +409,8 @@ struct smb_version_operations {
 	/* get mtu credits */
 	int (*wait_mtu_credits)(struct TCP_Server_Info *, unsigned int,
 				unsigned int *, unsigned int *);
+	/* check if we need to issue closedir */
+	bool (*dir_needs_close)(struct cifsFileInfo *);
 };
 
 struct smb_version_values {

commit 3d1a3745d8ca7ccdf00905b01fd5ab42ff523a94
Author: Steve French <smfrench@gmail.com>
Date:   Mon Aug 11 21:05:25 2014 -0500

    Add sparse file support to SMB2/SMB3 mounts
    
    Many Linux filesystes make a file "sparse" when extending
    a file with ftruncate. This does work for CIFS to Samba
    (only) but not for SMB2/SMB3 (to Samba or Windows) since
    there is a "set sparse" fsctl which is supposed to be
    sent to mark a file as sparse.
    
    This patch marks a file as sparse by sending this simple
    set sparse fsctl if it is extended more than 2 pages.
    It has been tested to Windows 8.1, Samba and various
    SMB2/SMB3 servers which do support setting sparse (and
    MacOS which does not appear to support the fsctl yet).
    If a server share does not support setting a file
    as sparse, then we do not retry setting sparse on that
    share.
    
    The disk space savings for sparse files can be quite
    large (even more significant on Windows servers than Samba).
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Shirish Pargaonkar <spargaonkar@suse.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0012e1e291d4..bc20a6ea6754 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -883,6 +883,7 @@ struct cifs_tcon {
 				for this mount even if server would support */
 	bool local_lease:1; /* check leases (only) on local system not remote */
 	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
+	bool broken_sparse_sup; /* if server or share does not support sparse */
 	bool need_reconnect:1; /* connection reset, tid now invalid */
 #ifdef CONFIG_CIFS_SMB2
 	bool print:1;		/* set if connection to printer share */

commit 34a54d617785e5ecafe1605df7aa689ec193964c
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Jul 10 10:03:29 2014 +0400

    CIFS: Use separate var for the number of bytes got in async read
    
    and don't mix it with the number of bytes that was requested.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f33ff4c7b8a8..0012e1e291d4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1059,6 +1059,7 @@ struct cifs_readdata {
 	struct address_space		*mapping;
 	__u64				offset;
 	unsigned int			bytes;
+	unsigned int			got_bytes;
 	pid_t				pid;
 	int				result;
 	struct work_struct		work;

commit bed9da0213f2174719b68012bd60735a11cfe244
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Jun 25 11:28:57 2014 +0400

    CIFS: Use multicredits for SMB 2.1/3 reads
    
    If we negotiate SMB 2.1 and higher version of the protocol and
    a server supports large read buffer size, we need to consume 1
    credit per 65536 bytes. So, we need to know how many credits
    we have and obtain the required number of them before constructing
    a readdata structure in readpages and user read.
    
    Reviewed-by: Shirish Pargaonkar <spargaonkar@suse.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 54ca2b985a0d..f33ff4c7b8a8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1068,6 +1068,7 @@ struct cifs_readdata {
 	struct kvec			iov;
 	unsigned int			pagesz;
 	unsigned int			tailsz;
+	unsigned int			credits;
 	unsigned int			nr_pages;
 	struct page			*pages[];
 };

commit cb7e9eabb2b584884db0d11ae0376d31ac1cfdc1
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Jun 5 19:03:27 2014 +0400

    CIFS: Use multicredits for SMB 2.1/3 writes
    
    If we negotiate SMB 2.1 and higher version of the protocol and
    a server supports large write buffer size, we need to consume 1
    credit per 65536 bytes. So, we need to know how many credits
    we have and obtain the required number of them before constructing
    a writedata structure in writepages and iovec write.
    
    Reviewed-by: Shirish Pargaonkar <spargaonkar@suse.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8c53f2093152..54ca2b985a0d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -406,6 +406,9 @@ struct smb_version_operations {
 			int);
 	/* writepages retry size */
 	unsigned int (*wp_retry_size)(struct inode *);
+	/* get mtu credits */
+	int (*wait_mtu_credits)(struct TCP_Server_Info *, unsigned int,
+				unsigned int *, unsigned int *);
 };
 
 struct smb_version_values {
@@ -641,6 +644,16 @@ add_credits(struct TCP_Server_Info *server, const unsigned int add,
 	server->ops->add_credits(server, add, optype);
 }
 
+static inline void
+add_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,
+			const int optype)
+{
+	if (add) {
+		server->ops->add_credits(server, add, optype);
+		wake_up(&server->request_q);
+	}
+}
+
 static inline void
 set_credits(struct TCP_Server_Info *server, const int val)
 {
@@ -1075,6 +1088,7 @@ struct cifs_writedata {
 	int				result;
 	unsigned int			pagesz;
 	unsigned int			tailsz;
+	unsigned int			credits;
 	unsigned int			nr_pages;
 	struct page			*pages[];
 };
@@ -1400,6 +1414,7 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 #define   CIFS_OBREAK_OP   0x0100    /* oplock break request */
 #define   CIFS_NEG_OP      0x0200    /* negotiate request */
 #define   CIFS_OP_MASK     0x0380    /* mask request type */
+#define   CIFS_HAS_CREDITS 0x0400    /* already has credits */
 
 /* Security Flags: indicate type of session setup needed */
 #define   CIFSSEC_MAY_SIGN	0x00001

commit 7f6c50086a6f5bc0fee46548afc836070a439313
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Sun Jun 22 11:03:22 2014 +0400

    CIFS: Fix cifs_writev_requeue when wsize changes
    
    If wsize changes on reconnect we need to use new writedata structure
    that for retrying.
    
    Reviewed-by: Shirish Pargaonkar <spargaonkar@suse.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index de6aed8c78e5..8c53f2093152 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -404,6 +404,8 @@ struct smb_version_operations {
 			const struct cifs_fid *, u32 *);
 	int (*set_acl)(struct cifs_ntsd *, __u32, struct inode *, const char *,
 			int);
+	/* writepages retry size */
+	unsigned int (*wp_retry_size)(struct inode *);
 };
 
 struct smb_version_values {

commit 39552ea8120a699dbd0360848c4d949f9f0e6deb
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue May 13 00:48:12 2014 +0100

    cifs: Set client guid on per connection basis
    
    When mounting from a Windows 2012R2 server, we hit the following
    problem:
    1) Mount with any of the following versions - 2.0, 2.1 or 3.0
    2) unmount
    3) Attempt a mount again using a different SMB version >= 2.0.
    
    You end up with the following failure:
    Status code returned 0xc0000203 STATUS_USER_SESSION_DELETED
    CIFS VFS: Send error in SessSetup = -5
    CIFS VFS: cifs_mount failed w/return code = -5
    
    I cannot reproduce this issue using a Windows 2008 R2 server.
    
    This appears to be caused because we use the same client guid for the
    connection on first mount which we then disconnect and attempt to mount
    again using a different protocol version. By generating a new guid each
    time a new connection is Negotiated, we avoid hitting this problem.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 630e0f4b2c66..de6aed8c78e5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -559,6 +559,7 @@ struct TCP_Server_Info {
 	int echo_credits;  /* echo reserved slots */
 	int oplock_credits;  /* oplock break reserved slots */
 	bool echoes:1; /* enable echoes */
+	__u8 client_guid[SMB2_CLIENT_GUID_SIZE]; /* Client GUID */
 #endif
 	u16 dialect; /* dialect index that server chose */
 	bool oplocks:1; /* enable oplocks */

commit 4f73c7d342d57d065bdbc0995cb56d8d1701b0c0
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Wed Apr 30 09:31:47 2014 -0400

    cifs: fix potential races in cifs_revalidate_mapping
    
    The handling of the CIFS_INO_INVALID_MAPPING flag is racy. It's possible
    for two tasks to attempt to revalidate the mapping at the same time. The
    first sees that CIFS_INO_INVALID_MAPPING is set. It clears the flag and
    then calls invalidate_inode_pages2 to start shooting down the pagecache.
    
    While that's going on, another task checks the flag and sees that it's
    clear. It then ends up trusting the pagecache to satisfy a read when it
    shouldn't.
    
    Fix this by adding a bitlock to ensure that the clearing of the flag is
    atomic with respect to the actual cache invalidation. Also, move the
    other existing users of cifs_invalidate_mapping to use a new
    cifs_zap_mapping() function that just sets the INVALID_MAPPING bit and
    then uses the standard codepath to handle the invalidation.
    
    Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 69da55b750e7..630e0f4b2c66 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1118,6 +1118,7 @@ struct cifsInodeInfo {
 #define CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2 (2) /* Downgrade oplock to L2 */
 #define CIFS_INO_DELETE_PENDING		  (3) /* delete pending on server */
 #define CIFS_INO_INVALID_MAPPING	  (4) /* pagecache is invalid */
+#define CIFS_INO_LOCK			  (5) /* lock bit for synchronization */
 	unsigned long flags;
 	spinlock_t writers_lock;
 	unsigned int writers;		/* Number of writers on this inode */

commit aff8d5ca7a3dca0bd6f6e86c9a85bf04941262ce
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Wed Apr 30 09:31:45 2014 -0400

    cifs: convert booleans in cifsInodeInfo to a flags field
    
    In later patches, we'll need to have a bitlock, so go ahead and convert
    these bools to use atomic bitops instead.
    
    Also, clean up the initialization of the flags field. There's no need
    to unset each bit individually just after it was zeroed on allocation.
    
    Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 30f6e9251a4a..69da55b750e7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1113,12 +1113,12 @@ struct cifsInodeInfo {
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
 	unsigned int oplock;		/* oplock/lease level we have */
 	unsigned int epoch;		/* used to track lease state changes */
-	bool delete_pending;		/* DELETE_ON_CLOSE is set */
-	bool invalid_mapping;		/* pagecache is invalid */
-	unsigned long flags;
 #define CIFS_INODE_PENDING_OPLOCK_BREAK   (0) /* oplock break in progress */
 #define CIFS_INODE_PENDING_WRITERS	  (1) /* Writes in progress */
 #define CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2 (2) /* Downgrade oplock to L2 */
+#define CIFS_INO_DELETE_PENDING		  (3) /* delete pending on server */
+#define CIFS_INO_INVALID_MAPPING	  (4) /* pagecache is invalid */
+	unsigned long flags;
 	spinlock_t writers_lock;
 	unsigned int writers;		/* Number of writers on this inode */
 	unsigned long time;		/* jiffies of last update of inode */

commit c11f1df5003d534fd067f0168bfad7befffb3b5c
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue Mar 11 16:11:47 2014 +0000

    cifs: Wait for writebacks to complete before attempting write.
    
    Problem reported in Red Hat bz 1040329 for strict writes where we cache
    only when we hold oplock and write direct to the server when we don't.
    
    When we receive an oplock break, we first change the oplock value for
    the inode in cifsInodeInfo->oplock to indicate that we no longer hold
    the oplock before we enqueue a task to flush changes to the backing
    device. Once we have completed flushing the changes, we return the
    oplock to the server.
    
    There are 2 ways here where we can have data corruption
    1) While we flush changes to the backing device as part of the oplock
    break, we can have processes write to the file. These writes check for
    the oplock, find none and attempt to write directly to the server.
    These direct writes made while we are flushing from cache could be
    overwritten by data being flushed from the cache causing data
    corruption.
    2) While a thread runs in cifs_strict_writev, the machine could receive
    and process an oplock break after the thread has checked the oplock and
    found that it allows us to cache and before we have made changes to the
    cache. In that case, we end up with a dirty page in cache when we
    shouldn't have any. This will be flushed later and will overwrite all
    subsequent writes to the part of the file represented by this page.
    
    Before making any writes to the server, we need to confirm that we are
    not in the process of flushing data to the server and if we are, we
    should wait until the process is complete before we attempt the write.
    We should also wait for existing writes to complete before we process
    an oplock break request which changes oplock values.
    
    We add a version specific  downgrade_oplock() operation to allow for
    differences in the oplock values set for the different smb versions.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c0f3718b77a8..30f6e9251a4a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -228,6 +228,8 @@ struct smb_version_operations {
 	/* verify the message */
 	int (*check_message)(char *, unsigned int);
 	bool (*is_oplock_break)(char *, struct TCP_Server_Info *);
+	void (*downgrade_oplock)(struct TCP_Server_Info *,
+					struct cifsInodeInfo *, bool);
 	/* process transaction2 response */
 	bool (*check_trans2)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     char *, int);
@@ -1113,6 +1115,12 @@ struct cifsInodeInfo {
 	unsigned int epoch;		/* used to track lease state changes */
 	bool delete_pending;		/* DELETE_ON_CLOSE is set */
 	bool invalid_mapping;		/* pagecache is invalid */
+	unsigned long flags;
+#define CIFS_INODE_PENDING_OPLOCK_BREAK   (0) /* oplock break in progress */
+#define CIFS_INODE_PENDING_WRITERS	  (1) /* Writes in progress */
+#define CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2 (2) /* Downgrade oplock to L2 */
+	spinlock_t writers_lock;
+	unsigned int writers;		/* Number of writers on this inode */
 	unsigned long time;		/* jiffies of last update of inode */
 	u64  server_eof;		/* current file size on server -- protected by i_lock */
 	u64  uniqueid;			/* server inode number */

commit dca1c8d17a2feae056f9e334ea75a462ae4cb52a
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Feb 22 19:35:38 2014 -0500

    cifs: mask off top byte in get_rfc1002_length()
    
    The rfc1002 length actually includes a type byte, which we aren't
    masking off. In most cases, it's not a problem since the
    RFC1002_SESSION_MESSAGE type is 0, but when doing a RFC1002 session
    establishment, the type is non-zero and that throws off the returned
    length.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Tested-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cf32f0393369..c0f3718b77a8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -513,7 +513,7 @@ struct cifs_mnt_data {
 static inline unsigned int
 get_rfc1002_length(void *buf)
 {
-	return be32_to_cpu(*((__be32 *)buf));
+	return be32_to_cpu(*((__be32 *)buf)) & 0xffffff;
 }
 
 static inline void

commit 42eacf9e57b65ffa768af72cb7fc86cc6f6af042
Author: Steve French <smfrench@gmail.com>
Date:   Mon Feb 10 14:08:16 2014 -0600

    [CIFS] Fix cifsacl mounts over smb2 to not call cifs
    
    When mounting with smb2/smb3 (e.g. vers=2.1) and cifsacl mount option,
    it was trying to get the mode by querying the acl over the cifs
    rather than smb2 protocol.  This patch makes that protocol
    independent and makes cifsacl smb2 mounts return a more intuitive
    operation not supported error (until we add a worker function
    for smb2_get_acl).
    
    Note that a previous patch fixed getxattr/setxattr for the CIFSACL xattr
    which would unconditionally call cifs_get_acl and cifs_set_acl (even when
    mounted smb2). I made those protocol independent last week (new protocol
    version operations "get_acl" and "set_acl" but did not add an
    smb2_get_acl and smb2_set_acl yet so those now simply return EOPNOTSUPP
    which at least is better than sending cifs requests on smb2 mount)
    
    The previous patches did not fix the one remaining case though ie
    mounting with "cifsacl" when getting mode from acl would unconditionally
    end up calling "cifs_get_acl_from_fid" even for smb2 - so made that protocol
    independent but to make that protocol independent had to make sure that the callers
    were passing the protocol independent handle structure (cifs_fid) instead
    of cifs specific _u16 network file handle (ie cifs_fid instead of cifs_fid->fid)
    
    Now mount with smb2 and cifsacl mount options will return EOPNOTSUP (instead
    of timing out) and a future patch will add smb2 operations (e.g. get_smb2_acl)
    to enable this.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 86dc28c7aa5c..cf32f0393369 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -398,6 +398,8 @@ struct smb_version_operations {
 			const struct nls_table *, int);
 	struct cifs_ntsd * (*get_acl)(struct cifs_sb_info *, struct inode *,
 			const char *, u32 *);
+	struct cifs_ntsd * (*get_acl_by_fid)(struct cifs_sb_info *,
+			const struct cifs_fid *, u32 *);
 	int (*set_acl)(struct cifs_ntsd *, __u32, struct inode *, const char *,
 			int);
 };

commit 4a5c80d7b5615be8098f9d5da97d166afc318abc
Author: Steve French <smfrench@gmail.com>
Date:   Fri Feb 7 20:45:12 2014 -0600

    [CIFS] clean up page array when uncached write send fails
    
    In the event that a send fails in an uncached write, or we end up
    needing to reissue it (-EAGAIN case), we'll kfree the wdata but
    the pages currently leak.
    
    Fix this by adding a new kref release routine for uncached writedata
    that releases the pages, and have the uncached codepaths use that.
    
    [original patch by Jeff modified to fix minor formatting problems]
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d6a031ed391b..86dc28c7aa5c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -323,7 +323,8 @@ struct smb_version_operations {
 	/* async read from the server */
 	int (*async_readv)(struct cifs_readdata *);
 	/* async write to the server */
-	int (*async_writev)(struct cifs_writedata *);
+	int (*async_writev)(struct cifs_writedata *,
+			    void (*release)(struct kref *));
 	/* sync read from the server */
 	int (*sync_read)(const unsigned int, struct cifsFileInfo *,
 			 struct cifs_io_parms *, unsigned int *, char **,

commit 26c8f0d601f5d4c0d9f4bc8c5151539aae5dc26a
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Feb 7 11:04:04 2014 -0500

    cifs: use a flexarray in cifs_writedata
    
    The cifs_writedata code uses a single element trailing array, which
    just adds unneeded complexity. Use a flexarray instead.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 615e35ab7ef6..d6a031ed391b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1068,7 +1068,7 @@ struct cifs_writedata {
 	unsigned int			pagesz;
 	unsigned int			tailsz;
 	unsigned int			nr_pages;
-	struct page			*pages[1];
+	struct page			*pages[];
 };
 
 /*

commit 83e3bc23ef9ce7c03b7b4e5d3d790246ea59db3e
Author: Steve French <smfrench@gmail.com>
Date:   Sun Feb 2 23:31:47 2014 -0600

    retrieving CIFS ACLs when mounted with SMB2 fails dropping session
    
    The get/set ACL xattr support for CIFS ACLs attempts to send old
    cifs dialect protocol requests even when mounted with SMB2 or later
    dialects. Sending cifs requests on an smb2 session causes problems -
    the server drops the session due to the illegal request.
    
    This patch makes CIFS ACL operations protocol specific to fix that.
    
    Attempting to query/set CIFS ACLs for SMB2 will now return
    EOPNOTSUPP (until we add worker routines for sending query
    ACL requests via SMB2) instead of sending invalid (cifs)
    requests.
    
    A separate followon patch will be needed to fix cifs_acl_to_fattr
    (which takes a cifs specific u16 fid so can't be abstracted
    to work with SMB2 until that is changed) and will be needed
    to fix mount problems when "cifsacl" is specified on mount
    with e.g. vers=2.1
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Shirish Pargaonkar <spargaonkar@suse.com>
    CC: Stable <stable@kernel.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a245d1809ed8..615e35ab7ef6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -395,6 +395,10 @@ struct smb_version_operations {
 	int (*set_EA)(const unsigned int, struct cifs_tcon *, const char *,
 			const char *, const void *, const __u16,
 			const struct nls_table *, int);
+	struct cifs_ntsd * (*get_acl)(struct cifs_sb_info *, struct inode *,
+			const char *, u32 *);
+	int (*set_acl)(struct cifs_ntsd *, __u32, struct inode *, const char *,
+			int);
 };
 
 struct smb_version_values {

commit 666753c3ef8fc88b0ddd5be4865d0aa66428ac35
Author: Steve French <smfrench@gmail.com>
Date:   Sun Jan 26 23:53:43 2014 -0600

    [CIFS] Fix SMB2 mounts so they don't try to set or get xattrs via cifs
    
    When mounting with smb2 (or smb2.1 or smb3) we need to check to make
    sure that attempts to query or set extended attributes do not
    attempt to send the request with the older cifs protocol instead
    (eventually we also need to add the support in SMB2
    to query/set extended attributes but this patch prevents us from
    using the wrong protocol for extended attribute operations).
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 61228b7f6b67..a245d1809ed8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -389,6 +389,12 @@ struct smb_version_operations {
 			struct cifsFileInfo *target_file, u64 src_off, u64 len,
 			u64 dest_off);
 	int (*validate_negotiate)(const unsigned int, struct cifs_tcon *);
+	ssize_t (*query_all_EAs)(const unsigned int, struct cifs_tcon *,
+			const unsigned char *, const unsigned char *, char *,
+			size_t, const struct nls_table *, int);
+	int (*set_EA)(const unsigned int, struct cifs_tcon *, const char *,
+			const char *, const void *, const __u16,
+			const struct nls_table *, int);
 };
 
 struct smb_version_values {

commit cbb0aba6ff3ff5b64f094f81f4d99d2323c0afcc
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Mon Nov 25 17:09:52 2013 +0000

    cifs: Add create MFSymlinks to protocol ops struct
    
    Add a new protocol ops function create_mf_symlink and have
    create_mf_symlink() use it.
    
    This patchset moves the MFSymlink operations completely to the
    ops structure so that we only use the right protocol versions when
    querying or creating MFSymlinks.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fba4d1341f88..61228b7f6b67 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -373,6 +373,9 @@ struct smb_version_operations {
 	int (*query_mf_symlink)(unsigned int, struct cifs_tcon *,
 				struct cifs_sb_info *, const unsigned char *,
 				char *, unsigned int *);
+	int (*create_mf_symlink)(unsigned int, struct cifs_tcon *,
+				 struct cifs_sb_info *, const unsigned char *,
+				 char *, unsigned int *);
 	/* if we can do cache read operations */
 	bool (*is_read_op)(__u32);
 	/* set oplock level for the inode */

commit b5be1a1c4c57a092cb60c709a0491d4ecead3d58
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Mon Nov 25 17:09:49 2013 +0000

    cifs: Rename and cleanup open_query_close_cifs_symlink()
    
    Rename open_query_close_cifs_symlink to cifs_query_mf_symlink() to make
    the name more consistent with other protocol version specific functions.
    
    We also pass tcon as an argument to the function. This is already
    available in the calling functions and we can avoid having to make an
    unnecessary lookup.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f918a998a087..fba4d1341f88 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -370,8 +370,9 @@ struct smb_version_operations {
 	void (*new_lease_key)(struct cifs_fid *);
 	int (*generate_signingkey)(struct cifs_ses *);
 	int (*calc_signature)(struct smb_rqst *, struct TCP_Server_Info *);
-	int (*query_mf_symlink)(const unsigned char *, char *, unsigned int *,
-				struct cifs_sb_info *, unsigned int);
+	int (*query_mf_symlink)(unsigned int, struct cifs_tcon *,
+				struct cifs_sb_info *, const unsigned char *,
+				char *, unsigned int *);
 	/* if we can do cache read operations */
 	bool (*is_read_op)(__u32);
 	/* set oplock level for the inode */

commit ff1c038addc4f205d5f1ede449426c7d316c0eed
Author: Steve French <smfrench@gmail.com>
Date:   Tue Nov 19 23:44:46 2013 -0600

    Check SMB3 dialects against downgrade attacks
    
    When we are running SMB3 or SMB3.02 connections which are signed
    we need to validate the protocol negotiation information,
    to ensure that the negotiate protocol response was not tampered with.
    
    Add the missing FSCTL which is sent at mount time (immediately after
    the SMB3 Tree Connect) to validate that the capabilities match
    what we think the server sent.
    
    "Secure dialect negotiation is introduced in SMB3 to protect against
    man-in-the-middle attempt to downgrade dialect negotiation.
    The idea is to prevent an eavesdropper from downgrading the initially
    negotiated dialect and capabilities between the client and the server."
    
    For more explanation see 2.2.31.4 of MS-SMB2 or
    http://blogs.msdn.com/b/openspecification/archive/2012/06/28/smb3-secure-dialect-negotiation.aspx
    
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d9ea7ada1378..f918a998a087 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -384,6 +384,7 @@ struct smb_version_operations {
 	int (*clone_range)(const unsigned int, struct cifsFileInfo *src_file,
 			struct cifsFileInfo *target_file, u64 src_off, u64 len,
 			u64 dest_off);
+	int (*validate_negotiate)(const unsigned int, struct cifs_tcon *);
 };
 
 struct smb_version_values {

commit de9f68df675e9d8b0b6a533818a79dca6546a7ba
Author: Steve French <smfrench@gmail.com>
Date:   Fri Nov 15 11:26:24 2013 -0600

    [CIFS] Set copychunk defaults
    
    Patch 2 of the copy chunk series (the final patch will
    use these to handle copies of files larger than the chunk size.
    
    We set the same defaults that Windows and Samba expect for
    CopyChunk.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: David Disseldorp <ddiss@samba.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 50a6ca1bb521..d9ea7ada1378 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -858,6 +858,9 @@ struct cifs_tcon {
 	__le64 vol_create_time;
 	__u32 ss_flags;		/* sector size flags */
 	__u32 perf_sector_size; /* best sector size for perf */
+	__u32 max_chunks;
+	__u32 max_bytes_chunk;
+	__u32 max_bytes_copy;
 #endif /* CONFIG_CIFS_SMB2 */
 #ifdef CONFIG_CIFS_FSCACHE
 	u64 resource_id;		/* server resource id */

commit 41c1358e9181ab1ebd773905b3fa8039b61aa0e9
Author: Steve French <smfrench@gmail.com>
Date:   Thu Nov 14 00:05:36 2013 -0600

    CIFS: SMB2/SMB3 Copy offload support (refcopy) phase 1
    
    This first patch adds the ability for us to do a server side copy
    (ie fast copy offloaded to the server to perform, aka refcopy)
    
    "cp --reflink"
    
    of one file to another located on the same server.  This
    is much faster than traditional copy (which requires
    reading and writing over the network and extra
    memcpys).
    
    This first version is not going to be copy
    files larger than about 1MB (to Samba) until I add
    support for multiple chunks and for autoconfiguring
    the chunksize.
    
    It includes:
    1) processing of the ioctl
    2) marshalling and sending the SMB2/SMB3 fsctl over the network
    3) simple parsing of the response
    
    It does not include yet (these will be in followon patches to come soon):
    1) support for multiple chunks
    2) support for autoconfiguring and remembering the chunksize
    3) Support for the older style copychunk which Samba 4.1 server supports
    (because this requires write permission on the target file, which
    cp does not give you, apparently per-posix).  This may require
    a distinct tool (other than cp) and other ioctl to implement.
    
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cddb807addde..50a6ca1bb521 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -381,6 +381,9 @@ struct smb_version_operations {
 	char * (*create_lease_buf)(u8 *, u8);
 	/* parse lease context buffer and return oplock/epoch info */
 	__u8 (*parse_lease_buf)(void *, unsigned int *);
+	int (*clone_range)(const unsigned int, struct cifsFileInfo *src_file,
+			struct cifsFileInfo *target_file, u64 src_off, u64 len,
+			u64 dest_off);
 };
 
 struct smb_version_values {

commit eb85d94bdd91fb4dbea4ee465d4349cbea4eaaca
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Wed Oct 23 17:49:47 2013 +0400

    CIFS: Fix symbolic links usage
    
    Now we treat any reparse point as a symbolic link and map it to a Unix
    one that is not true in a common case due to many reparse point types
    supported by SMB servers.
    
    Distinguish reparse point types into two groups:
    1) that can be accessed directly through a reparse point
    (junctions, deduplicated files, NFS symlinks);
    2) that need to be processed manually (Windows symbolic links, DFS);
    
    and map only Windows symbolic links to Unix ones.
    
    Cc: <stable@vger.kernel.org>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Reported-and-tested-by: Joao Correia <joaomiguelcorreia@gmail.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 26b1c1dc93f6..cddb807addde 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -261,7 +261,7 @@ struct smb_version_operations {
 	/* query path data from the server */
 	int (*query_path_info)(const unsigned int, struct cifs_tcon *,
 			       struct cifs_sb_info *, const char *,
-			       FILE_ALL_INFO *, bool *);
+			       FILE_ALL_INFO *, bool *, bool *);
 	/* query file data from the server */
 	int (*query_file_info)(const unsigned int, struct cifs_tcon *,
 			       struct cifs_fid *, FILE_ALL_INFO *);

commit af6a12ea8d4bb39a87527835b943bde4215897e5
Author: Steven French <smfrench@gmail.com>
Date:   Wed Oct 9 20:55:53 2013 -0500

    Query File System Alignment
    
    In SMB3 it is now possible to query the file system
    alignment info, and the preferred (for performance)
    sector size and whether the underlying disk
    has no seek penalty (like SSD).
    
    Query this information at mount time for SMB3,
    and make it visible in /proc/fs/cifs/DebugData
    for debugging purposes.
    
    This alignment information and preferred sector
    size info will be helpful for the copy offload
    patches to setup the right chunks in the CopyChunk
    requests.   Presumably the knowledge that the
    underlying disk is SSD could also help us
    make better readahead and writebehind
    decisions (something to look at in the future).
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 670da1e55be7..26b1c1dc93f6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -853,6 +853,8 @@ struct cifs_tcon {
 	__u32 maximal_access;
 	__u32 vol_serial_number;
 	__le64 vol_create_time;
+	__u32 ss_flags;		/* sector size flags */
+	__u32 perf_sector_size; /* best sector size for perf */
 #endif /* CONFIG_CIFS_SMB2 */
 #ifdef CONFIG_CIFS_FSCACHE
 	u64 resource_id;		/* server resource id */

commit 3d378d3fd82a759d59c60d89b4559bf325d7e668
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Sat Nov 2 12:50:34 2013 -0500

    cifs: Make big endian multiplex ID sequences monotonic on the wire
    
    The multiplex identifier (MID) in the SMB header is only
    ever used by the client, in conjunction with PID, to match responses
    from the server. As such, the endianess of the MID is not important.
    However, When tracing packet sequences on the wire, protocol analyzers
    such as wireshark display MID as little endian. It is much more informative
    for the on-the-wire MID sequences to match debug information emitted by the
    CIFS driver.  Therefore, one should write and read MID in the SMB header
    assuming it is always little endian.
    
    Observed from wireshark during the protocol negotiation
    and session setup:
    
            Multiplex ID: 256
            Multiplex ID: 256
            Multiplex ID: 512
            Multiplex ID: 512
            Multiplex ID: 768
            Multiplex ID: 768
    
    After this patch on-the-wire MID values begin at 1 and increase monotonically.
    
    Introduce get_next_mid64() for the internal consumers that use the full 64 bit
    multiplex identifier.
    
    Introduce the helpers get_mid() and compare_mid() to make the endian
    translation clear.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Tim Gardner <timg@tpi.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 06e8947fc370..670da1e55be7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -622,11 +622,34 @@ set_credits(struct TCP_Server_Info *server, const int val)
 }
 
 static inline __u64
-get_next_mid(struct TCP_Server_Info *server)
+get_next_mid64(struct TCP_Server_Info *server)
 {
 	return server->ops->get_next_mid(server);
 }
 
+static inline __le16
+get_next_mid(struct TCP_Server_Info *server)
+{
+	__u16 mid = get_next_mid64(server);
+	/*
+	 * The value in the SMB header should be little endian for easy
+	 * on-the-wire decoding.
+	 */
+	return cpu_to_le16(mid);
+}
+
+static inline __u16
+get_mid(const struct smb_hdr *smb)
+{
+	return le16_to_cpu(smb->Mid);
+}
+
+static inline bool
+compare_mid(__u16 mid, const struct smb_hdr *smb)
+{
+	return mid == le16_to_cpu(smb->Mid);
+}
+
 /*
  * When the server supports very large reads and writes via POSIX extensions,
  * we can allow up to 2^24-1, minus the size of a READ/WRITE_AND_X header, not

commit 64a5cfa6db94c5abba2cafe77aca077dd1e3283b
Author: Steve French <smfrench@gmail.com>
Date:   Mon Oct 14 15:31:32 2013 -0500

    Allow setting per-file compression via SMB2/3
    
    Allow cifs/smb2/smb3 to return whether or not a file is compressed
    via lsattr, and allow SMB2/SMB3 to set the per-file compression
    flag ("chattr +c filename" on an smb3 mount).
    
    Windows users often set the compressed flag (it can be
    done from the desktop and file manager).  David Disseldorp
    has patches to Samba server to support this (at least on btrfs)
    which are complementary to this
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 52b6f6c26bfc..06e8947fc370 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -278,6 +278,8 @@ struct smb_version_operations {
 	/* set attributes */
 	int (*set_file_info)(struct inode *, const char *, FILE_BASIC_INFO *,
 			     const unsigned int);
+	int (*set_compression)(const unsigned int, struct cifs_tcon *,
+			       struct cifsFileInfo *);
 	/* check if we can send an echo or nor */
 	bool (*can_echo)(struct TCP_Server_Info *);
 	/* send echo request */

commit 74d290da476f672ad756634d12aa707375d3564d
Author: Jim McDonough <jmcd@samba.org>
Date:   Sat Sep 21 10:36:10 2013 -0500

    [CIFS] Provide sane values for nlink
    
    Since we don't get info about the number of links from the readdir
    linfo levels, stat() will return 0 for st_nlink, and in particular,
    samba re-exported shares will show directories as files (as samba is
    keying off st_nlink before evaluating how to set the dos modebits)
    when doing a dir or ls.
    
    Copy nlink to the inode, unless it wasn't provided.  Provide
    sane values if we don't have an existing one and none was provided.
    
    Signed-off-by: Jim McDonough <jmcd@samba.org>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: David Disseldorp <ddiss@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9c72be6fb0df..52b6f6c26bfc 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1268,6 +1268,7 @@ struct dfs_info3_param {
 #define CIFS_FATTR_DELETE_PENDING	0x2
 #define CIFS_FATTR_NEED_REVAL		0x4
 #define CIFS_FATTR_INO_COLLISION	0x8
+#define CIFS_FATTR_UNKNOWN_NLINK	0x10
 
 struct cifs_fattr {
 	u32		cf_flags;

commit 9ae6cf606a33b0a762798df0fb742848bcc685b5
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 16 11:23:45 2013 -0400

    cifs: stop trying to use virtual circuits
    
    Currently, we try to ensure that we use vcnum of 0 on the first
    established session on a connection and then try to use a different
    vcnum on each session after that.
    
    This is a little odd, since there's no real reason to use a different
    vcnum for each SMB session. I can only assume there was some confusion
    between SMB sessions and VCs. That's somewhat understandable since they
    both get created during SESSION_SETUP, but the documentation indicates
    that they are really orthogonal. The comment on max_vcs in particular
    looks quite misguided. An SMB session is already uniquely identified
    by the SMB UID value -- there's no need to again uniquely ID with a
    VC.
    
    Furthermore, a vcnum of 0 is a cue to the server that it should release
    any resources that were previously held by the client. This sounds like
    a good thing, until you consider that:
    
    a) it totally ignores the fact that other programs on the box (e.g.
    smbclient) might have connections established to the server. Using a
    vcnum of 0 causes them to get kicked off.
    
    b) it causes problems with NAT. If several clients are connected to the
    same server via the same NAT'ed address, whenever one connects to the
    server it kicks off all the others, which then reconnect and kick off
    the first one...ad nauseum.
    
    I don't see any reason to ignore the advice in "Implementing CIFS" which
    has a comprehensive treatment of virtual circuits. In there, it states
    "...and contrary to the specs the client should always use a VcNumber of
    one, never zero."
    
    Have the client just use a hardcoded vcnum of 1, and stop abusing the
    special behavior of vcnum 0.
    
    Reported-by: Sauron99@gmx.de <sauron99@gmx.de>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Volker Lendecke <vl@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cfa14c80ef3b..9c72be6fb0df 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -547,9 +547,6 @@ struct TCP_Server_Info {
 	unsigned int max_rw;	/* maxRw specifies the maximum */
 	/* message size the server can send or receive for */
 	/* SMB_COM_WRITE_RAW or SMB_COM_READ_RAW. */
-	unsigned int max_vcs;	/* maximum number of smb sessions, at least
-				   those that can be specified uniquely with
-				   vcnumbers */
 	unsigned int capabilities; /* selective disabling of caps by smb sess */
 	int timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u64 CurrentMid;         /* multiplex id - rotating counter */
@@ -715,7 +712,6 @@ struct cifs_ses {
 	enum statusEnum status;
 	unsigned overrideSecFlg;  /* if non-zero override global sec flags */
 	__u16 ipc_tid;		/* special tid for connection to IPC share */
-	__u16 vcnum;
 	char *serverOS;		/* name of operating system underlying server */
 	char *serverNOS;	/* name of network operating system of server */
 	char *serverDomain;	/* security realm of server */

commit 42873b0a282ac84a56e0e48c408beb62d0ad2917
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Sep 5 21:30:16 2013 +0400

    CIFS: Respect epoch value from create lease context v2
    
    that force a client to purge cache pages when a server requests it.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 38118938f0b6..cfa14c80ef3b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -373,11 +373,12 @@ struct smb_version_operations {
 	/* if we can do cache read operations */
 	bool (*is_read_op)(__u32);
 	/* set oplock level for the inode */
-	void (*set_oplock_level)(struct cifsInodeInfo *, __u32);
+	void (*set_oplock_level)(struct cifsInodeInfo *, __u32, unsigned int,
+				 bool *);
 	/* create lease context buffer for CREATE request */
 	char * (*create_lease_buf)(u8 *, u8);
-	/* parse lease context buffer and return oplock info */
-	__u8 (*parse_lease_buf)(void *);
+	/* parse lease context buffer and return oplock/epoch info */
+	__u8 (*parse_lease_buf)(void *, unsigned int *);
 };
 
 struct smb_version_values {
@@ -940,6 +941,8 @@ struct cifs_fid {
 	__u8 lease_key[SMB2_LEASE_KEY_SIZE];	/* lease key for smb2 */
 #endif
 	struct cifs_pending_open *pending_open;
+	unsigned int epoch;
+	bool purge_cache;
 };
 
 struct cifs_fid_locks {
@@ -1039,7 +1042,10 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 
 #define CIFS_CACHE_READ_FLG	1
 #define CIFS_CACHE_HANDLE_FLG	2
+#define CIFS_CACHE_RH_FLG	(CIFS_CACHE_READ_FLG | CIFS_CACHE_HANDLE_FLG)
 #define CIFS_CACHE_WRITE_FLG	4
+#define CIFS_CACHE_RW_FLG	(CIFS_CACHE_READ_FLG | CIFS_CACHE_WRITE_FLG)
+#define CIFS_CACHE_RHW_FLG	(CIFS_CACHE_RW_FLG | CIFS_CACHE_HANDLE_FLG)
 
 #define CIFS_CACHE_READ(cinode) (cinode->oplock & CIFS_CACHE_READ_FLG)
 #define CIFS_CACHE_HANDLE(cinode) (cinode->oplock & CIFS_CACHE_HANDLE_FLG)
@@ -1057,6 +1063,7 @@ struct cifsInodeInfo {
 	struct list_head openFileList;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
 	unsigned int oplock;		/* oplock/lease level we have */
+	unsigned int epoch;		/* used to track lease state changes */
 	bool delete_pending;		/* DELETE_ON_CLOSE is set */
 	bool invalid_mapping;		/* pagecache is invalid */
 	unsigned long time;		/* jiffies of last update of inode */

commit b5c7cde3fac35e33835d37be59cb4e5a0b9cf3c2
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Sep 5 20:16:45 2013 +0400

    CIFS: Move parsing lease buffer to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cb53e24ae9b2..38118938f0b6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -376,6 +376,8 @@ struct smb_version_operations {
 	void (*set_oplock_level)(struct cifsInodeInfo *, __u32);
 	/* create lease context buffer for CREATE request */
 	char * (*create_lease_buf)(u8 *, u8);
+	/* parse lease context buffer and return oplock info */
+	__u8 (*parse_lease_buf)(void *);
 };
 
 struct smb_version_values {

commit a41a28bda936ea627afbfe94a7f5cd63f23cf727
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Sep 4 13:07:41 2013 +0400

    CIFS: Move creating lease buffer to ops struct
    
    to make adding new types of lease buffers easier.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e87f89f778f4..cb53e24ae9b2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -361,11 +361,11 @@ struct smb_version_operations {
 	/* push brlocks from the cache to the server */
 	int (*push_mand_locks)(struct cifsFileInfo *);
 	/* get lease key of the inode */
-	void (*get_lease_key)(struct inode *, struct cifs_fid *fid);
+	void (*get_lease_key)(struct inode *, struct cifs_fid *);
 	/* set lease key of the inode */
-	void (*set_lease_key)(struct inode *, struct cifs_fid *fid);
+	void (*set_lease_key)(struct inode *, struct cifs_fid *);
 	/* generate new lease key */
-	void (*new_lease_key)(struct cifs_fid *fid);
+	void (*new_lease_key)(struct cifs_fid *);
 	int (*generate_signingkey)(struct cifs_ses *);
 	int (*calc_signature)(struct smb_rqst *, struct TCP_Server_Info *);
 	int (*query_mf_symlink)(const unsigned char *, char *, unsigned int *,
@@ -374,6 +374,8 @@ struct smb_version_operations {
 	bool (*is_read_op)(__u32);
 	/* set oplock level for the inode */
 	void (*set_oplock_level)(struct cifsInodeInfo *, __u32);
+	/* create lease context buffer for CREATE request */
+	char * (*create_lease_buf)(u8 *, u8);
 };
 
 struct smb_version_values {
@@ -393,6 +395,7 @@ struct smb_version_values {
 	unsigned int	cap_large_files;
 	__u16		signing_enabled;
 	__u16		signing_required;
+	size_t		create_lease_size;
 };
 
 #define HEADER_SIZE(server) (server->vals->header_size)

commit 53ef1016fd0e4bab128a24f7fe06b9cdb2afdc31
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Sep 5 16:11:28 2013 +0400

    CIFS: Store lease state itself rather than a mapped oplock value
    
    and separate smb20_operations struct.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fe739bd8246d..e87f89f778f4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -367,11 +367,13 @@ struct smb_version_operations {
 	/* generate new lease key */
 	void (*new_lease_key)(struct cifs_fid *fid);
 	int (*generate_signingkey)(struct cifs_ses *);
-	int (*calc_signature)(struct smb_rqst *rqst,
-				   struct TCP_Server_Info *server);
-	int (*query_mf_symlink)(const unsigned char *path, char *pbuf,
-			unsigned int *pbytes_read, struct cifs_sb_info *cifs_sb,
-			unsigned int xid);
+	int (*calc_signature)(struct smb_rqst *, struct TCP_Server_Info *);
+	int (*query_mf_symlink)(const unsigned char *, char *, unsigned int *,
+				struct cifs_sb_info *, unsigned int);
+	/* if we can do cache read operations */
+	bool (*is_read_op)(__u32);
+	/* set oplock level for the inode */
+	void (*set_oplock_level)(struct cifsInodeInfo *, __u32);
 };
 
 struct smb_version_values {
@@ -389,7 +391,6 @@ struct smb_version_values {
 	unsigned int	cap_unix;
 	unsigned int	cap_nt_find;
 	unsigned int	cap_large_files;
-	unsigned int	oplock_read;
 	__u16		signing_enabled;
 	__u16		signing_required;
 };
@@ -1036,6 +1037,7 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 #define CIFS_CACHE_WRITE_FLG	4
 
 #define CIFS_CACHE_READ(cinode) (cinode->oplock & CIFS_CACHE_READ_FLG)
+#define CIFS_CACHE_HANDLE(cinode) (cinode->oplock & CIFS_CACHE_HANDLE_FLG)
 #define CIFS_CACHE_WRITE(cinode) (cinode->oplock & CIFS_CACHE_WRITE_FLG)
 
 /*
@@ -1507,7 +1509,7 @@ extern mempool_t *cifs_mid_poolp;
 extern struct smb_version_operations smb1_operations;
 extern struct smb_version_values smb1_values;
 #define SMB20_VERSION_STRING	"2.0"
-/*extern struct smb_version_operations smb20_operations; */ /* not needed yet */
+extern struct smb_version_operations smb20_operations;
 extern struct smb_version_values smb20_values;
 #define SMB21_VERSION_STRING	"2.1"
 extern struct smb_version_operations smb21_operations;

commit 18cceb6a78f46b65df654e8348fa2093b91b30f6
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Sep 5 13:01:06 2013 +0400

    CIFS: Replace clientCanCache* bools with an integer
    
    that prepare the code to handle different types of SMB2 leases.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 92798f74f0c3..fe739bd8246d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1031,6 +1031,13 @@ cifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)
 struct cifsFileInfo *cifsFileInfo_get(struct cifsFileInfo *cifs_file);
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 
+#define CIFS_CACHE_READ_FLG	1
+#define CIFS_CACHE_HANDLE_FLG	2
+#define CIFS_CACHE_WRITE_FLG	4
+
+#define CIFS_CACHE_READ(cinode) (cinode->oplock & CIFS_CACHE_READ_FLG)
+#define CIFS_CACHE_WRITE(cinode) (cinode->oplock & CIFS_CACHE_WRITE_FLG)
+
 /*
  * One of these for each file inode
  */
@@ -1042,8 +1049,7 @@ struct cifsInodeInfo {
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
-	bool clientCanCacheRead;	/* read oplock */
-	bool clientCanCacheAll;		/* read and writebehind oplock */
+	unsigned int oplock;		/* oplock/lease level we have */
 	bool delete_pending;		/* DELETE_ON_CLOSE is set */
 	bool invalid_mapping;		/* pagecache is invalid */
 	unsigned long time;		/* jiffies of last update of inode */

commit 32811d242ff6f28da2ab18c90a15e32fd958e774
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Thu Aug 29 08:35:11 2013 -0500

    cifs: Start using per session key for smb2/3 for signature generation
    
        Switch smb2 code to use per session session key and smb3 code to
        use per session signing key instead of per connection key to
        generate signatures.
    
        For that, we need to find a session to fetch the session key to
        generate signature to match for every request and response packet.
    
        We also forgo checking signature for a session setup response
        from the server.
    
    Acked-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 20c7f8f4fba8..92798f74f0c3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -366,8 +366,7 @@ struct smb_version_operations {
 	void (*set_lease_key)(struct inode *, struct cifs_fid *fid);
 	/* generate new lease key */
 	void (*new_lease_key)(struct cifs_fid *fid);
-	/* The next two functions will need to be changed to per smb session */
-	void (*generate_signingkey)(struct TCP_Server_Info *server);
+	int (*generate_signingkey)(struct cifs_ses *);
 	int (*calc_signature)(struct smb_rqst *rqst,
 				   struct TCP_Server_Info *server);
 	int (*query_mf_symlink)(const unsigned char *path, char *pbuf,
@@ -548,7 +547,6 @@ struct TCP_Server_Info {
 	int timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u64 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlm, ntlmv2 etc */
-	char smb3signingkey[SMB3_SIGN_KEY_SIZE]; /* for signing smb3 packets */
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* for signing, protected by srv_mutex */
@@ -731,6 +729,7 @@ struct cifs_ses {
 	bool need_reconnect:1; /* connection reset, uid now invalid */
 #ifdef CONFIG_CIFS_SMB2
 	__u16 session_flags;
+	char smb3signingkey[SMB3_SIGN_KEY_SIZE]; /* for signing smb3 packets */
 #endif /* CONFIG_CIFS_SMB2 */
 };
 

commit 5c234aa5e33ed9037354a4c94d0d3e0350abe5eb
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Thu Aug 29 08:35:10 2013 -0500

    cifs: Add a variable specific to NTLMSSP for key exchange.
    
    Add a variable specific to NTLMSSP authentication to determine
    whether to exchange keys during negotiation and authentication phases.
    
    Since session key for smb1 is per smb connection, once a very first
    sesion is established, there is no need for key exchange during
    subsequent session setups. As a result, smb1 session setup code sets this
    variable as false.
    
    Since session key for smb2 and smb3 is per smb connection, we need to
    exchange keys to generate session key for every sesion being established.
    As a result, smb2/3 session setup code sets this variable as true.
    
    Acked-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fb186f7bae49..20c7f8f4fba8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -131,6 +131,7 @@ struct cifs_secmech {
 
 /* per smb session structure/fields */
 struct ntlmssp_auth {
+	bool sesskey_per_smbsess; /* whether session key is per smb session */
 	__u32 client_flags; /* sent by client in type 1 ntlmsssp exchange */
 	__u32 server_flags; /* sent by server in type 2 ntlmssp exchange */
 	unsigned char ciphertext[CIFS_CPHTXT_SIZE]; /* sent to server */

commit cdf1246ffbb2ddd86a875c80b7290d22b9022805
Author: Scott Lovenberg <scott.lovenberg@gmail.com>
Date:   Fri Aug 9 08:47:19 2013 -0400

    cifs: Move and expand MAX_SERVER_SIZE definition
    
    MAX_SERVER_SIZE has been moved to cifs_mount.h and renamed
    CIFS_NI_MAXHOST for clarity.  It has been expanded to 1024 as the
    previous value of 16 was very short.
    
    Signed-off-by: Scott Lovenberg <scott.lovenberg@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 633bbc5e8801..fb186f7bae49 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -42,8 +42,7 @@
 #define MAX_SES_INFO 2
 #define MAX_TCON_INFO 4
 
-#define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + CIFS_MAX_SHARE_LEN + 1)
-#define MAX_SERVER_SIZE 15
+#define MAX_TREE_SIZE (2 + CIFS_NI_MAXHOST + 1 + CIFS_MAX_SHARE_LEN + 1)
 
 #define CIFS_MIN_RCV_POOL 4
 

commit 8c3a2b4c420c5b988005b8697b7404ced076aaaa
Author: Scott Lovenberg <scott.lovenberg@gmail.com>
Date:   Fri Aug 9 08:47:17 2013 -0400

    cifs: Move string length definitions to uapi
    
    The max string length definitions for user name, domain name, password,
    and share name have been moved into their own header file in uapi so the
    mount helper can use autoconf to define them instead of keeping the
    kernel side and userland side definitions in sync manually.  The names
    have also been standardized with a "CIFS" prefix and "LEN" suffix.
    
    Signed-off-by: Scott Lovenberg <scott.lovenberg@gmail.com>
    Reviewed-by: Chen Gang <gang.chen@asianux.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ec6c3fbb29eb..633bbc5e8801 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -28,6 +28,7 @@
 #include "cifsacl.h"
 #include <crypto/internal/hash.h>
 #include <linux/scatterlist.h>
+#include <uapi/linux/cifs/cifs_mount.h>
 #ifdef CONFIG_CIFS_SMB2
 #include "smb2pdu.h"
 #endif
@@ -41,12 +42,8 @@
 #define MAX_SES_INFO 2
 #define MAX_TCON_INFO 4
 
-#define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)
+#define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + CIFS_MAX_SHARE_LEN + 1)
 #define MAX_SERVER_SIZE 15
-#define MAX_SHARE_SIZE 80
-#define CIFS_MAX_DOMAINNAME_LEN 256 /* max domain name length */
-#define MAX_USERNAME_SIZE 256	/* reasonable maximum for current servers */
-#define MAX_PASSWORD_SIZE 512	/* max for windows seems to be 256 wide chars */
 
 #define CIFS_MIN_RCV_POOL 4
 

commit b42bf88828cde60772dc08201d0a4f1a0663d7bc
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Aug 14 19:25:21 2013 +0400

    CIFS: Implement follow_link for SMB2
    
    that allows to access files through symlink created on a server.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 52ca861ed35e..ec6c3fbb29eb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -308,6 +308,9 @@ struct smb_version_operations {
 	int (*create_hardlink)(const unsigned int, struct cifs_tcon *,
 			       const char *, const char *,
 			       struct cifs_sb_info *);
+	/* query symlink target */
+	int (*query_symlink)(const unsigned int, struct cifs_tcon *,
+			     const char *, char **, struct cifs_sb_info *);
 	/* open a file for non-posix mounts */
 	int (*open)(const unsigned int, struct cifs_open_parms *,
 		    __u32 *, FILE_ALL_INFO *);

commit 1b244081af462c223cfa6a1ae881a902af64c306
Author: Steve French <smfrench@gmail.com>
Date:   Thu Jul 11 19:17:40 2013 -0500

    Do not attempt to do cifs operations reading symlinks with SMB2
    
    When use of symlinks is enabled (mounting with mfsymlinks option) to
    non-Samba servers, we always tried to use cifs, even when we
    were mounted with SMB2 or SMB3, which causes the server to drop the
    network connection.
    
    This patch separates out the protocol specific operations for cifs from
    the code which recognizes symlinks, and fixes the problem where
    with SMB2 mounts we attempt cifs operations to open and read
    symlinks.  The next patch will add support for SMB2 for opening
    and reading symlinks.  Additional followon patches will address
    the similar problem creating symlinks.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0e68893f26f3..52ca861ed35e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -370,6 +370,9 @@ struct smb_version_operations {
 	void (*generate_signingkey)(struct TCP_Server_Info *server);
 	int (*calc_signature)(struct smb_rqst *rqst,
 				   struct TCP_Server_Info *server);
+	int (*query_mf_symlink)(const unsigned char *path, char *pbuf,
+			unsigned int *pbytes_read, struct cifs_sb_info *cifs_sb,
+			unsigned int xid);
 };
 
 struct smb_version_values {

commit 057d6332b24a4497c55a761c83c823eed9e3f23b
Author: Chen Gang <gang.chen@asianux.com>
Date:   Fri Jul 19 09:01:36 2013 +0800

    cifs: extend the buffer length enought for sprintf() using
    
    For cifs_set_cifscreds() in "fs/cifs/connect.c", 'desc' buffer length
    is 'CIFSCREDS_DESC_SIZE' (56 is less than 256), and 'ses->domainName'
    length may be "255 + '\0'".
    
    The related sprintf() may cause memory overflow, so need extend related
    buffer enough to hold all things.
    
    It is also necessary to be sure of 'ses->domainName' must be less than
    256, and define the related macro instead of hard code number '256'.
    
    Signed-off-by: Chen Gang <gang.chen@asianux.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Scott Lovenberg <scott.lovenberg@gmail.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1fdc37041057..0e68893f26f3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -44,6 +44,7 @@
 #define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)
 #define MAX_SERVER_SIZE 15
 #define MAX_SHARE_SIZE 80
+#define CIFS_MAX_DOMAINNAME_LEN 256 /* max domain name length */
 #define MAX_USERNAME_SIZE 256	/* reasonable maximum for current servers */
 #define MAX_PASSWORD_SIZE 512	/* max for windows seems to be 256 wide chars */
 

commit 9cbc0b7339b0542a1d13922d2745a2636ce44853
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Jul 9 18:40:58 2013 +0400

    CIFS: Reconnect durable handles for SMB2
    
    On reconnects, we need to reopen file and then obtain all byte-range
    locks held by the client. SMB2 protocol provides feature to make
    this process atomic by reconnecting to the same file handle
    with all it's byte-range locks. This patch adds this capability
    for SMB2 shares.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steven French <steven@steven-GA-970A-DS3.(none)>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 982fdf92c791..1fdc37041057 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -920,6 +920,7 @@ struct cifs_open_parms {
 	int create_options;
 	const char *path;
 	struct cifs_fid *fid;
+	bool reconnect:1;
 };
 
 struct cifs_fid {

commit 226730b4d8adae393dc07092655cdd29d2a2ff07
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri Jul 5 12:00:30 2013 +0400

    CIFS: Introduce cifs_open_parms struct
    
    and pass it to the open() call.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steven French <steven@steven-GA-970A-DS3.(none)>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e66b08882548..982fdf92c791 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -194,6 +194,7 @@ struct cifs_writedata;
 struct cifs_io_parms;
 struct cifs_search_info;
 struct cifsInodeInfo;
+struct cifs_open_parms;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -307,9 +308,8 @@ struct smb_version_operations {
 			       const char *, const char *,
 			       struct cifs_sb_info *);
 	/* open a file for non-posix mounts */
-	int (*open)(const unsigned int, struct cifs_tcon *, const char *, int,
-		    int, int, struct cifs_fid *, __u32 *, FILE_ALL_INFO *,
-		    struct cifs_sb_info *);
+	int (*open)(const unsigned int, struct cifs_open_parms *,
+		    __u32 *, FILE_ALL_INFO *);
 	/* set fid protocol-specific info */
 	void (*set_fid)(struct cifsFileInfo *, struct cifs_fid *, __u32);
 	/* close a file */
@@ -912,6 +912,16 @@ struct cifs_search_info {
 	bool smallBuf:1; /* so we know which buf_release function to call */
 };
 
+struct cifs_open_parms {
+	struct cifs_tcon *tcon;
+	struct cifs_sb_info *cifs_sb;
+	int disposition;
+	int desired_access;
+	int create_options;
+	const char *path;
+	struct cifs_fid *fid;
+};
+
 struct cifs_fid {
 	__u16 netfid;
 #ifdef CONFIG_CIFS_SMB2

commit 50285882fdd919e2b9617fc844b4816b7833f115
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jun 27 12:45:00 2013 -0400

    cifs: fix SMB2 signing enablement in cifs_enable_signing
    
    Commit 9ddec56131 (cifs: move handling of signed connections into
    separate function) broke signing on SMB2/3 connections. While the code
    to enable signing on the connections was very similar between the two,
    the bits that get set in the sec_mode are different.
    
    Declare a couple of new smb_version_values fields and set them
    appropriately for SMB1 and SMB2/3. Then change cifs_enable_signing to
    use those instead.
    
    Reported-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Tested-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b0f077ebb590..e66b08882548 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -387,6 +387,8 @@ struct smb_version_values {
 	unsigned int	cap_nt_find;
 	unsigned int	cap_large_files;
 	unsigned int	oplock_read;
+	__u16		signing_enabled;
+	__u16		signing_required;
 };
 
 #define HEADER_SIZE(server) (server->vals->header_size)

commit e65a5cb41718e0eb17a470bc3acf2c3b2f00f1d0
Author: Steve French <smfrench@gmail.com>
Date:   Thu Jun 27 01:06:50 2013 -0500

    [CIFS] Fix build warning
    
    Fix build warning in Shirish's recent SMB3 signing patch
    which occurs when SMB2 support is disabled in Kconfig.
    
    fs/built-in.o: In function `cifs_setup_session':
    >> (.text+0xa1767): undefined reference to `generate_smb3signingkey'
    
    Pointed out by: automated 0-DAY kernel build testing backend
    Intel Open Source Technology Center
    
    CC: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2d0f524ebeee..b0f077ebb590 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -365,6 +365,8 @@ struct smb_version_operations {
 	void (*set_lease_key)(struct inode *, struct cifs_fid *fid);
 	/* generate new lease key */
 	void (*new_lease_key)(struct cifs_fid *fid);
+	/* The next two functions will need to be changed to per smb session */
+	void (*generate_signingkey)(struct TCP_Server_Info *server);
 	int (*calc_signature)(struct smb_rqst *rqst,
 				   struct TCP_Server_Info *server);
 };

commit 429b46f4fdaf9c9007b7c0fc371b94e40c3764b2
Author: Steve French <smfrench@gmail.com>
Date:   Wed Jun 26 23:45:05 2013 -0500

    [CIFS] SMB3 Signing enablement
    
    SMB3 uses a much faster method of signing (which is also better in other ways),
    AES-CMAC.  With the kernel now supporting AES-CMAC since last release, we
    are overdue to allow SMB3 signing (today only CIFS and SMB2 and SMB2.1,
    but not SMB3 and SMB3.1 can sign) - and we need this also for checking
    secure negotation and also per-share encryption (two other new SMB3 features
    which we need to implement).
    
    This patch needs some work in a few areas - for example we need to
    move signing for SMB2/SMB3 from per-socket to per-user (we may be able to
    use the "nosharesock" mount option in the interim for the multiuser case),
    and Shirish found a bug in the earlier authentication overhaul
    (setting signing flags properly) - but those can be done in followon
    patches.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9a1e37aad3b8..2d0f524ebeee 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -125,9 +125,11 @@ struct cifs_secmech {
 	struct crypto_shash *hmacmd5; /* hmac-md5 hash function */
 	struct crypto_shash *md5; /* md5 hash function */
 	struct crypto_shash *hmacsha256; /* hmac-sha256 hash function */
+	struct crypto_shash *cmacaes; /* block-cipher based MAC function */
 	struct sdesc *sdeschmacmd5;  /* ctxt to generate ntlmv2 hash, CR1 */
 	struct sdesc *sdescmd5; /* ctxt to generate cifs/smb signature */
 	struct sdesc *sdeschmacsha256;  /* ctxt to generate smb2 signature */
+	struct sdesc *sdesccmacaes;  /* ctxt to generate smb3 signature */
 };
 
 /* per smb session structure/fields */
@@ -538,6 +540,7 @@ struct TCP_Server_Info {
 	int timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u64 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlm, ntlmv2 etc */
+	char smb3signingkey[SMB3_SIGN_KEY_SIZE]; /* for signing smb3 packets */
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* for signing, protected by srv_mutex */

commit 769ee6a4024434d1960acafd7adde38538bbe3da
Author: Steve French <smfrench@gmail.com>
Date:   Wed Jun 19 14:15:30 2013 -0500

    Add ability to dipslay SMB3 share flags and capabilities for debugging
    
    SMB3 protocol adds various optional per-share capabilities (and
    SMB3.02 adds one more beyond that).  Add ability to dump
    (/proc/fs/cifs/DebugData) the share capabilities and share flags to
    improve debugging.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f13cbbeaf098..9a1e37aad3b8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -223,6 +223,7 @@ struct smb_version_operations {
 	void (*dump_detail)(void *);
 	void (*clear_stats)(struct cifs_tcon *);
 	void (*print_stats)(struct seq_file *m, struct cifs_tcon *);
+	void (*dump_share_caps)(struct seq_file *, struct cifs_tcon *);
 	/* verify the message */
 	int (*check_message)(char *, unsigned int);
 	bool (*is_oplock_break)(char *, struct TCP_Server_Info *);
@@ -809,7 +810,7 @@ struct cifs_tcon {
 #ifdef CONFIG_CIFS_SMB2
 	bool print:1;		/* set if connection to printer share */
 	bool bad_network_name:1; /* set if ret status STATUS_BAD_NETWORK_NAME */
-	__u32 capabilities;
+	__le32 capabilities;
 	__u32 share_flags;
 	__u32 maximal_access;
 	__u32 vol_serial_number;

commit 20b6d8b42e7e7c9af5046fe525d6709e10d14992
Author: Steve French <smfrench@gmail.com>
Date:   Wed Jun 12 22:48:41 2013 -0500

    Add SMB3.02 dialect support
    
    The new Windows update supports SMB3.02 dialect, a minor update to SMB3.
    This patch adds support for mounting with vers=3.02
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c3162c2f9550..f13cbbeaf098 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -175,6 +175,7 @@ enum smb_version {
 	Smb_20,
 	Smb_21,
 	Smb_30,
+	Smb_302,
 };
 
 struct mid_q_entry;
@@ -1486,4 +1487,7 @@ extern struct smb_version_values smb21_values;
 #define SMB30_VERSION_STRING	"3.0"
 extern struct smb_version_operations smb30_operations;
 extern struct smb_version_values smb30_values;
+#define SMB302_VERSION_STRING	"3.02"
+/*extern struct smb_version_operations smb302_operations;*/ /* not needed yet */
+extern struct smb_version_values smb302_values;
 #endif	/* _CIFS_GLOB_H */

commit 896a8fc25bd31a81afb35e65468484f34f1c15d6
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun May 26 07:01:01 2013 -0400

    cifs: update the default global_secflags to include "raw" NTLMv2
    
    Before this patchset, the global_secflags could only offer up a single
    sectype. With the new set though we have the ability to allow different
    sectypes since we sort out the one to use after talking to the server.
    
    Change the global_secflags to allow NTLMSSP or NTLMv2 by default. If the
    server sets the extended security bit in the Negotiate response, then
    we'll use NTLMSSP. If it doesn't then we'll use raw NTLMv2. Mounting a
    LANMAN server will still require a sec= option by default.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ad3408042ff0..c3162c2f9550 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1340,7 +1340,7 @@ require use of the stronger protocol */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
 #define   CIFSSEC_MUST_NTLMSSP	0x80080 /* raw ntlmssp with ntlmv2 */
 
-#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLMSSP)
+#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_NTLMSSP)
 #define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)
 #define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)
 /*

commit 3f618223dc0bdcbc8d510350e78ee2195ff93768
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Jun 12 19:52:14 2013 -0500

    move sectype to the cifs_ses instead of TCP_Server_Info
    
    Now that we track what sort of NEGOTIATE response was received, stop
    mandating that every session on a socket use the same type of auth.
    
    Push that decision out into the session setup code, and make the sectype
    a per-session property. This should allow us to mix multiple sectypes on
    a socket as long as they are compatible with the NEGOTIATE response.
    
    With this too, we can now eliminate the ses->secFlg field since that
    info is redundant and harder to work with than a securityEnum.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 49020ae460cf..ad3408042ff0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -401,7 +401,6 @@ struct smb_vol {
 	kgid_t backupgid;
 	umode_t file_mode;
 	umode_t dir_mode;
-	unsigned secFlg;
 	enum securityEnum sectype; /* sectype requested via mnt opts */
 	bool sign; /* was signing requested via mnt opts? */
 	bool retry:1;
@@ -519,7 +518,6 @@ struct TCP_Server_Info {
 	bool echoes:1; /* enable echoes */
 #endif
 	u16 dialect; /* dialect index that server chose */
-	enum securityEnum secType;
 	bool oplocks:1; /* enable oplocks */
 	unsigned int maxReq;	/* Clients should submit no more */
 	/* than maxReq distinct unanswered SMBs to the server when using  */

commit 38d77c50b4f4e3ea1687e119871364f1c8d2f531
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun May 26 07:01:00 2013 -0400

    cifs: track the enablement of signing in the TCP_Server_Info
    
    Currently, we determine this according to flags in the sec_mode, flags
    in the global_secflags and via other methods. That makes the semantics
    very hard to follow and there are corner cases where we don't handle
    this correctly.
    
    Add a new bool to the TCP_Server_Info that acts as a simple flag to tell
    us whether signing is enabled on this connection or not, and fix up the
    places that need to determine this to use that flag.
    
    This is a bit weird for the SMB2 case, where signing is per-session.
    SMB2 needs work in this area already though. The existing SMB2 code has
    similar logic to what we're using here, so there should be no real
    change in behavior. These changes should make it easier to implement
    per-session signing in the future though.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2f3a89a2c497..49020ae460cf 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -511,6 +511,7 @@ struct TCP_Server_Info {
 	struct task_struct *tsk;
 	char server_GUID[16];
 	__u16 sec_mode;
+	bool sign; /* is signing enabled on this connection? */
 	bool session_estab; /* mark when very first sess is established */
 #ifdef CONFIG_CIFS_SMB2
 	int echo_credits;  /* echo reserved slots */

commit 1e3cc57e474867771aba2bdf23d0c7d8fb5e4822
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Jun 10 17:12:23 2013 -0500

    add new fields to smb_vol to track the requested security flavor
    
    We have this to some degree already in secFlgs, but those get "or'ed" so
    there's no way to know what the last option requested was. Add new fields
    that will eventually supercede the secFlgs field in the cifs_ses.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 87d92e35e991..2f3a89a2c497 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -402,6 +402,8 @@ struct smb_vol {
 	umode_t file_mode;
 	umode_t dir_mode;
 	unsigned secFlg;
+	enum securityEnum sectype; /* sectype requested via mnt opts */
+	bool sign; /* was signing requested via mnt opts? */
 	bool retry:1;
 	bool intr:1;
 	bool setuids:1;

commit 28e11bd86d63ce18b481cd9f90bd5fa1b5ba746b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun May 26 07:01:00 2013 -0400

    cifs: add new fields to cifs_ses to track requested security flavor
    
    Currently we have the overrideSecFlg field, but it's quite cumbersome
    to work with. Add some new fields that will eventually supercede it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 82ba4b974894..87d92e35e991 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -712,6 +712,8 @@ struct cifs_ses {
 	char *password;
 	struct session_key auth_key;
 	struct ntlmssp_auth *ntlmssp; /* ciphertext, flags, server challenge */
+	enum securityEnum sectype; /* what security flavor was specified? */
+	bool sign;		/* is signing required? */
 	bool need_reconnect:1; /* connection reset, uid now invalid */
 #ifdef CONFIG_CIFS_SMB2
 	__u16 session_flags;

commit e598d1d8fb512c7a4d86c729cdca30e87fe7cfc9
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun May 26 07:00:59 2013 -0400

    cifs: track the flavor of the NEGOTIATE reponse
    
    Track what sort of NEGOTIATE response we get from the server, as that
    will govern what sort of authentication types this socket will support.
    
    There are three possibilities:
    
    LANMAN: server sent legacy LANMAN-type response
    
    UNENCAP: server sent a newer-style response, but extended security bit
    wasn't set. This socket will only support unencapsulated auth types.
    
    EXTENDED: server sent a newer-style response with the extended security
    bit set. This is necessary to support krb5 and ntlmssp auth types.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9f8dc3da5f3b..82ba4b974894 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -541,6 +541,10 @@ struct TCP_Server_Info {
 	struct session_key session_key;
 	unsigned long lstrp; /* when we got last response from this server */
 	struct cifs_secmech secmech; /* crypto sec mech functs, descriptors */
+#define	CIFS_NEGFLAVOR_LANMAN	0	/* wct == 13, LANMAN */
+#define	CIFS_NEGFLAVOR_UNENCAP	1	/* wct == 17, but no ext_sec */
+#define	CIFS_NEGFLAVOR_EXTENDED	2	/* wct == 17, ext_sec bit set */
+	char	negflavor;	/* NEGOTIATE response flavor */
 	/* extended security flavors that server supports */
 	bool	sec_ntlmssp;		/* supports NTLMSSP */
 	bool	sec_kerberosu2u;	/* supports U2U Kerberos */

commit 515d82ffd0fe4a87d872c655a6e19a318770ea0c
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun May 26 07:00:58 2013 -0400

    cifs: add new "Unspecified" securityEnum value
    
    Add a new securityEnum value to cover the case where a sec= option
    was not explicitly set.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index be993ec5895b..9f8dc3da5f3b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -101,11 +101,11 @@ enum statusEnum {
 };
 
 enum securityEnum {
-	LANMAN = 0,			/* Legacy LANMAN auth */
+	Unspecified = 0,	/* not specified */
+	LANMAN,			/* Legacy LANMAN auth */
 	NTLM,			/* Legacy NTLM012 auth with NTLM hash */
 	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
 	RawNTLMSSP,		/* NTLMSSP without SPNEGO, NTLMv2 hash */
-/*	NTLMSSP, */ /* can use rawNTLMSSP instead of NTLMSSP via SPNEGO */
 	Kerberos,		/* Kerberos via SPNEGO */
 };
 

commit 281e2e7d06c42ce8dfd423fa2ae5616af0e0323f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun May 26 07:00:56 2013 -0400

    cifs: remove the cifs_ses->flags field
    
    This field is completely unused:
    
    CIFS_SES_W9X is completely unused. CIFS_SES_LANMAN and CIFS_SES_OS2
    are set but never checked. CIFS_SES_NT4 is checked, but never set.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 29dd1113e40d..be993ec5895b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -692,7 +692,6 @@ struct cifs_ses {
 	enum statusEnum status;
 	unsigned overrideSecFlg;  /* if non-zero override global sec flags */
 	__u16 ipc_tid;		/* special tid for connection to IPC share */
-	__u16 flags;
 	__u16 vcnum;
 	char *serverOS;		/* name of operating system underlying server */
 	char *serverNOS;	/* name of network operating system of server */
@@ -715,15 +714,6 @@ struct cifs_ses {
 #endif /* CONFIG_CIFS_SMB2 */
 };
 
-/* no more than one of the following three session flags may be set */
-#define CIFS_SES_NT4 1
-#define CIFS_SES_OS2 2
-#define CIFS_SES_W9X 4
-/* following flag is set for old servers such as OS2 (and Win95?)
-   which do not negotiate NTLM or POSIX dialects, but instead
-   negotiate one of the older LANMAN dialects */
-#define CIFS_SES_LANMAN 8
-
 static inline bool
 cap_unix(struct cifs_ses *ses)
 {

commit 6f709494a74938f98769fba76d3a1f8b0f12b606
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri May 24 07:41:00 2013 -0400

    cifs: remove protocolEnum definition
    
    The field that held this was removed quite some time ago.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index db9f985b8c2c..29dd1113e40d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -109,12 +109,6 @@ enum securityEnum {
 	Kerberos,		/* Kerberos via SPNEGO */
 };
 
-enum protocolEnum {
-	TCP = 0,
-	SCTP
-	/* Netbios frames protocol not supported at this time */
-};
-
 struct session_key {
 	unsigned int len;
 	char *response;

commit a0b3df5cf1fc46ad885bbc5c9f56ff0f4877beb5
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri May 24 07:40:59 2013 -0400

    cifs: add a "nosharesock" mount option to force new sockets to server to be created
    
    Some servers set max_vcs to 1 and actually do enforce that limit. Add a
    new mount option to work around this behavior that forces a mount
    request to open a new socket to the server instead of reusing an
    existing one.
    
    I'd prefer to come up with a solution that doesn't require this, so
    consider this a debug patch that you can use to determine whether this
    is the real problem.
    
    Cc: Jim McDonough <jmcd@samba.org>
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4f07f6fbe494..db9f985b8c2c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -441,6 +441,7 @@ struct smb_vol {
 	bool mfsymlinks:1; /* use Minshall+French Symlinks */
 	bool multiuser:1;
 	bool rwpidforward:1; /* pid forward for read/write operations */
+	bool nosharesock;
 	unsigned int rsize;
 	unsigned int wsize;
 	bool sockopt_tcp_nodelay:1;

commit 94f2f14234178f118545a0be60a6371ddeb229b7
Merge: 8d168f71551e 139321c65c05
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 16:00:49 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace and namespace infrastructure changes from Eric W Biederman:
     "This set of changes starts with a few small enhnacements to the user
      namespace.  reboot support, allowing more arbitrary mappings, and
      support for mounting devpts, ramfs, tmpfs, and mqueuefs as just the
      user namespace root.
    
      I do my best to document that if you care about limiting your
      unprivileged users that when you have the user namespace support
      enabled you will need to enable memory control groups.
    
      There is a minor bug fix to prevent overflowing the stack if someone
      creates way too many user namespaces.
    
      The bulk of the changes are a continuation of the kuid/kgid push down
      work through the filesystems.  These changes make using uids and gids
      typesafe which ensures that these filesystems are safe to use when
      multiple user namespaces are in use.  The filesystems converted for
      3.9 are ceph, 9p, afs, ocfs2, gfs2, ncpfs, nfs, nfsd, and cifs.  The
      changes for these filesystems were a little more involved so I split
      the changes into smaller hopefully obviously correct changes.
    
      XFS is the only filesystem that remains.  I was hoping I could get
      that in this release so that user namespace support would be enabled
      with an allyesconfig or an allmodconfig but it looks like the xfs
      changes need another couple of days before it they are ready."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (93 commits)
      cifs: Enable building with user namespaces enabled.
      cifs: Convert struct cifs_ses to use a kuid_t and a kgid_t
      cifs: Convert struct cifs_sb_info to use kuids and kgids
      cifs: Modify struct smb_vol to use kuids and kgids
      cifs: Convert struct cifsFileInfo to use a kuid
      cifs: Convert struct cifs_fattr to use kuid and kgids
      cifs: Convert struct tcon_link to use a kuid.
      cifs: Modify struct cifs_unix_set_info_args to hold a kuid_t and a kgid_t
      cifs: Convert from a kuid before printing current_fsuid
      cifs: Use kuids and kgids SID to uid/gid mapping
      cifs: Pass GLOBAL_ROOT_UID and GLOBAL_ROOT_GID to keyring_alloc
      cifs: Use BUILD_BUG_ON to validate uids and gids are the same size
      cifs: Override unmappable incoming uids and gids
      nfsd: Enable building with user namespaces enabled.
      nfsd: Properly compare and initialize kuids and kgids
      nfsd: Store ex_anon_uid and ex_anon_gid as kuids and kgids
      nfsd: Modify nfsd4_cb_sec to use kuids and kgids
      nfsd: Handle kuids and kgids in the nfs4acl to posix_acl conversion
      nfsd: Convert nfsxdr to use kuids and kgids
      nfsd: Convert nfs3xdr to use kuids and kgids
      ...

commit 64ed39dd1ef284c0338799a6167b77a6d6e01982
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 6 02:30:39 2013 -0800

    cifs: Convert struct cifs_ses to use a kuid_t and a kgid_t
    
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e308e8bd0772..aaef57beba0e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -702,8 +702,8 @@ struct cifs_ses {
 	char *serverNOS;	/* name of network operating system of server */
 	char *serverDomain;	/* security realm of server */
 	__u64 Suid;		/* remote smb uid  */
-	uid_t linux_uid;        /* overriding owner of files on the mount */
-	uid_t cred_uid;		/* owner of credentials */
+	kuid_t linux_uid;	/* overriding owner of files on the mount */
+	kuid_t cred_uid;	/* owner of credentials */
 	unsigned int capabilities;
 	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for
 				TCP names - will ipv6 and sctp addresses fit? */

commit 3da46565043a3d7b9fd5c924e7de2d3e65e9d2a9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 6 01:37:39 2013 -0800

    cifs: Modify struct smb_vol to use kuids and kgids
    
    Add two helper functions get_option_uid and get_option_gid to handle
    the work of parsing uid and gids paramaters from the command line and
    making kuids and kgids out of them.
    
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 04aa74e5b348..e308e8bd0772 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -399,11 +399,11 @@ struct smb_vol {
 	char *iocharset;  /* local code page for mapping to and from Unicode */
 	char source_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* clnt nb name */
 	char target_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* srvr nb name */
-	uid_t cred_uid;
-	uid_t linux_uid;
-	gid_t linux_gid;
-	uid_t backupuid;
-	gid_t backupgid;
+	kuid_t cred_uid;
+	kuid_t linux_uid;
+	kgid_t linux_gid;
+	kuid_t backupuid;
+	kgid_t backupgid;
 	umode_t file_mode;
 	umode_t dir_mode;
 	unsigned secFlg;

commit fef59fd728366aa9bf125b8859aff84fa0bd1a36
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 6 02:23:02 2013 -0800

    cifs: Convert struct cifsFileInfo to use a kuid
    
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 98312fda0d35..04aa74e5b348 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -930,7 +930,7 @@ struct cifsFileInfo {
 	struct list_head tlist;	/* pointer to next fid owned by tcon */
 	struct list_head flist;	/* next fid (file instance) for this inode */
 	struct cifs_fid_locks *llist;	/* brlocks held by this fid */
-	unsigned int uid;	/* allows finding which FileInfo structure */
+	kuid_t uid;		/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
 	struct cifs_fid fid;	/* file id from remote */
 	/* BB add lock scope info here if needed */ ;

commit 4a2c8cf56953a6ebe3c8671433607b7f96f200d5
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 6 01:53:25 2013 -0800

    cifs: Convert struct cifs_fattr to use kuid and kgids
    
    In cifs_unix_to_basic_fattr only update the cifs_fattr with an id if
    it is valid after conversion.
    
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7993a7a07ae2..98312fda0d35 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1245,8 +1245,8 @@ struct cifs_fattr {
 	u64		cf_eof;
 	u64		cf_bytes;
 	u64		cf_createtime;
-	uid_t		cf_uid;
-	gid_t		cf_gid;
+	kuid_t		cf_uid;
+	kgid_t		cf_gid;
 	umode_t		cf_mode;
 	dev_t		cf_rdev;
 	unsigned int	cf_nlink;

commit 6d4a083205c27bc2e2a1c03dff4acf2fe457d1c4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 6 01:48:56 2013 -0800

    cifs: Convert struct tcon_link to use a kuid.
    
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index aea1eec64911..7993a7a07ae2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -837,7 +837,7 @@ struct cifs_tcon {
  */
 struct tcon_link {
 	struct rb_node		tl_rbnode;
-	uid_t			tl_uid;
+	kuid_t			tl_uid;
 	unsigned long		tl_flags;
 #define TCON_LINK_MASTER	0
 #define TCON_LINK_PENDING	1

commit 63b7d3a41ccadef971a4ffbe6662119d4275ebf9
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Mon Dec 24 14:41:19 2012 +0400

    CIFS: Don't let read only caching for mandatory byte-range locked files
    
    If we have mandatory byte-range locks on a file we can't cache reads
    because pagereading may have conflicts with these locks on the server.
    That's why we should allow level2 oplocks for files without mandatory
    locks only.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index dfab450a191e..e6899cea1c35 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -386,6 +386,7 @@ struct smb_version_values {
 	unsigned int	cap_unix;
 	unsigned int	cap_nt_find;
 	unsigned int	cap_large_files;
+	unsigned int	oplock_read;
 };
 
 #define HEADER_SIZE(server) (server->vals->header_size)

commit ca8aa29c60238720af2ca2a5caab25fa0c70067e
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Dec 21 15:05:47 2012 +0400

    Revert "CIFS: Fix write after setting a read lock for read oplock files"
    
    that solution has data races and can end up two identical writes to the
    server: when clientCanCacheAll value can be changed during the execution
    of __generic_file_aio_write.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index aea1eec64911..dfab450a191e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1030,7 +1030,6 @@ struct cifsInodeInfo {
 	bool clientCanCacheAll;		/* read and writebehind oplock */
 	bool delete_pending;		/* DELETE_ON_CLOSE is set */
 	bool invalid_mapping;		/* pagecache is invalid */
-	bool leave_pages_clean;	/* protected by i_mutex, not set pages dirty */
 	unsigned long time;		/* jiffies of last update of inode */
 	u64  server_eof;		/* current file size on server -- protected by i_lock */
 	u64  uniqueid;			/* server inode number */

commit c299dd0e2d3dd61d0048a9d9b021aa01f023ed0c
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Dec 6 22:07:52 2012 +0400

    CIFS: Fix write after setting a read lock for read oplock files
    
    If we have a read oplock and set a read lock in it, we can't write to the
    locked area - so, filemap_fdatawrite may fail with a no information for a
    userspace application even if we request a write to non-locked area. Fix
    this by populating the page cache without marking affected pages dirty
    after a successful write directly to the server.
    
    Also remove CONFIG_CIFS_SMB2 ifdefs because it's suitable for both CIFS
    and SMB2 protocols.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index dfab450a191e..aea1eec64911 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1030,6 +1030,7 @@ struct cifsInodeInfo {
 	bool clientCanCacheAll;		/* read and writebehind oplock */
 	bool delete_pending;		/* DELETE_ON_CLOSE is set */
 	bool invalid_mapping;		/* pagecache is invalid */
+	bool leave_pages_clean;	/* protected by i_mutex, not set pages dirty */
 	unsigned long time;		/* jiffies of last update of inode */
 	u64  server_eof;		/* current file size on server -- protected by i_lock */
 	u64  uniqueid;			/* server inode number */

commit 38107d45cf452761a74fe512190e23f36834d6dd
Author: Steve French <smfrench@gmail.com>
Date:   Sat Dec 8 22:08:06 2012 -0600

    Do not send SMB2 signatures for SMB3 frames
    
    Restructure code to make SMB2 vs. SMB3 signing a protocol
    specific op.  SMB3 signing (AES_CMAC) is not enabled yet,
    but this restructuring at least makes sure we don't send
    an smb2 signature on an smb3 signed connection. A followon
    patch will add AES_CMAC and enable smb3 signing.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Acked-by: Jeff Layton <jlayton@samba.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 74a07b604ffd..dfab450a191e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -367,6 +367,8 @@ struct smb_version_operations {
 	void (*set_lease_key)(struct inode *, struct cifs_fid *fid);
 	/* generate new lease key */
 	void (*new_lease_key)(struct cifs_fid *fid);
+	int (*calc_signature)(struct smb_rqst *rqst,
+				   struct TCP_Server_Info *server);
 };
 
 struct smb_version_values {
@@ -1489,6 +1491,6 @@ extern struct smb_version_values smb20_values;
 extern struct smb_version_operations smb21_operations;
 extern struct smb_version_values smb21_values;
 #define SMB30_VERSION_STRING	"3.0"
-/*extern struct smb_version_operations smb30_operations; */ /* not needed yet */
+extern struct smb_version_operations smb30_operations;
 extern struct smb_version_values smb30_values;
 #endif	/* _CIFS_GLOB_H */

commit 1cc9bd68617f2a92dcd6e4398288341d16cfb5c1
Author: Steve French <smfrench@gmail.com>
Date:   Thu Nov 29 18:07:51 2012 -0600

    make convert_delimiter use strchr instead of open-coding it
    
    Take advantage of accelerated strchr() on arches that support it.
    
    Also, no caller ever passes in a NULL pointer. Get rid of the unneeded
    NULL pointer check.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 052d85b333f3..74a07b604ffd 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1064,21 +1064,16 @@ static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
 static inline void
 convert_delimiter(char *path, char delim)
 {
-	int i;
-	char old_delim;
-
-	if (path == NULL)
-		return;
+	char old_delim, *pos;
 
 	if (delim == '/')
 		old_delim = '\\';
 	else
 		old_delim = '/';
 
-	for (i = 0; path[i] != '\0'; i++) {
-		if (path[i] == old_delim)
-			path[i] = delim;
-	}
+	pos = path;
+	while ((pos = strchr(pos, old_delim)))
+		*pos = delim;
 }
 
 #ifdef CONFIG_CIFS_STATS

commit b979aaa1777259330435c47f900833dabe9189e8
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Nov 26 11:09:55 2012 -0500

    cifs: get rid of smb_vol->UNCip and smb_vol->port
    
    Passing this around as a string is contorted and painful. Instead, just
    convert these to a sockaddr as soon as possible, since that's how we're
    going to work with it later anyway.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ac66409fb9d3..052d85b333f3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -394,7 +394,6 @@ struct smb_vol {
 	char *password;
 	char *domainname;
 	char *UNC;
-	char *UNCip;
 	char *iocharset;  /* local code page for mapping to and from Unicode */
 	char source_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* clnt nb name */
 	char target_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* srvr nb name */
@@ -442,11 +441,11 @@ struct smb_vol {
 	unsigned int rsize;
 	unsigned int wsize;
 	bool sockopt_tcp_nodelay:1;
-	unsigned short int port;
 	unsigned long actimeo; /* attribute cache timeout (jiffies) */
 	struct smb_version_operations *ops;
 	struct smb_version_values *vals;
 	char *prepath;
+	struct sockaddr_storage dstaddr; /* destination address */
 	struct sockaddr_storage srcaddr; /* allow binding to a local IP */
 	struct nls_table *local_nls;
 };

commit dd446b16edd74ca525208d924d426f786dd973f8
Author: Steve French <smfrench@gmail.com>
Date:   Wed Nov 28 23:21:06 2012 -0600

    Add SMB2.02 dialect support
    
    This patch enables optional for original SMB2 (SMB2.02) dialect
    by specifying vers=2.0 on mount.
    
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d1a93d32db81..ac66409fb9d3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -178,6 +178,7 @@ struct smb_rqst {
 
 enum smb_version {
 	Smb_1 = 1,
+	Smb_20,
 	Smb_21,
 	Smb_30,
 };

commit 6d3ea7e4975aed451fbee4dea2fef63b0de8cb4f
Author: Steve French <smfrench@gmail.com>
Date:   Wed Nov 28 22:34:41 2012 -0600

    CIFS: Make use of common cifs_build_path_to_root for CIFS and SMB2
    
    because the is no difference here. This also adds support of prefixpath
    mount option for SMB2.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2cd5ea2042ed..d1a93d32db81 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -280,9 +280,6 @@ struct smb_version_operations {
 	/* set attributes */
 	int (*set_file_info)(struct inode *, const char *, FILE_BASIC_INFO *,
 			     const unsigned int);
-	/* build a full path to the root of the mount */
-	char * (*build_path_to_root)(struct smb_vol *, struct cifs_sb_info *,
-				     struct cifs_tcon *);
 	/* check if we can send an echo or nor */
 	bool (*can_echo)(struct TCP_Server_Info *);
 	/* send echo request */
@@ -1084,15 +1081,6 @@ convert_delimiter(char *path, char delim)
 	}
 }
 
-static inline char *
-build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,
-		   struct cifs_tcon *tcon)
-{
-	if (!vol->ops->build_path_to_root)
-		return NULL;
-	return vol->ops->build_path_to_root(vol, cifs_sb, tcon);
-}
-
 #ifdef CONFIG_CIFS_STATS
 #define cifs_stats_inc atomic_inc
 

commit 81bcd8b795229c70d7244898efe282846e3b14ce
Author: Steve French <smfrench@gmail.com>
Date:   Sun Nov 25 00:07:44 2012 -0600

    default authentication needs to be at least ntlmv2 security for cifs mounts
    
    We had planned to upgrade to ntlmv2 security a few releases ago,
    and have been warning users in dmesg on mount about the impending
    upgrade, but had to make a change (to use nltmssp with ntlmv2) due
    to testing issues with some non-Windows, non-Samba servers.
    
    The approach in this patch is simpler than earlier patches,
    and changes the default authentication mechanism to ntlmv2
    password hashes (encapsulated in ntlmssp) from ntlm (ntlm is
    too weak for current use and ntlmv2 has been broadly
    supported for many, many years).
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f5af2527fc69..2cd5ea2042ed 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1362,7 +1362,7 @@ require use of the stronger protocol */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
 #define   CIFSSEC_MUST_NTLMSSP	0x80080 /* raw ntlmssp with ntlmv2 */
 
-#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_NTLMSSP)
+#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLMSSP)
 #define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)
 #define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)
 /*

commit e4aa25e7801163df058f62c617b859e9d3d4b148
Author: Steve French <smfrench@gmail.com>
Date:   Mon Oct 1 12:26:22 2012 -0500

    [CIFS] Fix SMB2 negotiation support to select only one dialect (based on vers=)
    
    Based on whether the user (on mount command) chooses:
    
    vers=3.0 (for smb3.0 support)
    vers=2.1 (for smb2.1 support)
    or (with subsequent patch, which will allow SMB2 support)
    vers=2.0 (for original smb2.02 dialect support)
    
    send only one dialect at a time during negotiate (we
    had been sending a list).
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f6f40635abca..f5af2527fc69 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -179,6 +179,7 @@ struct smb_rqst {
 enum smb_version {
 	Smb_1 = 1,
 	Smb_21,
+	Smb_30,
 };
 
 struct mid_q_entry;
@@ -372,6 +373,8 @@ struct smb_version_operations {
 
 struct smb_version_values {
 	char		*version_string;
+	__u16		protocol_id;
+	__u32		req_capabilities;
 	__u32		large_lock_type;
 	__u32		exclusive_lock_type;
 	__u32		shared_lock_type;
@@ -1496,7 +1499,13 @@ extern mempool_t *cifs_mid_poolp;
 #define SMB1_VERSION_STRING	"1.0"
 extern struct smb_version_operations smb1_operations;
 extern struct smb_version_values smb1_values;
+#define SMB20_VERSION_STRING	"2.0"
+/*extern struct smb_version_operations smb20_operations; */ /* not needed yet */
+extern struct smb_version_values smb20_values;
 #define SMB21_VERSION_STRING	"2.1"
 extern struct smb_version_operations smb21_operations;
 extern struct smb_version_values smb21_values;
+#define SMB30_VERSION_STRING	"3.0"
+/*extern struct smb_version_operations smb30_operations; */ /* not needed yet */
+extern struct smb_version_values smb30_values;
 #endif	/* _CIFS_GLOB_H */

commit 760ad0cac198356c1148cad7531c1a6138322493
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Sep 25 11:00:07 2012 +0400

    CIFS: Make ops->close return void
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a39e5b7fc844..f6f40635abca 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -316,7 +316,8 @@ struct smb_version_operations {
 	/* set fid protocol-specific info */
 	void (*set_fid)(struct cifsFileInfo *, struct cifs_fid *, __u32);
 	/* close a file */
-	int (*close)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
+	void (*close)(const unsigned int, struct cifs_tcon *,
+		      struct cifs_fid *);
 	/* send a flush request to the server */
 	int (*flush)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
 	/* async read from the server */

commit 233839b1df65a24c8b67b748fe7b18d86d0ad6d7
Author: Pavel Shilovsky <pshilovsky@etersoft.ru>
Date:   Wed Sep 19 06:22:45 2012 -0700

    CIFS: Fix fast lease break after open problem
    
    Now we walk though cifsFileInfo's list for every incoming lease
    break and look for an equivalent there. That approach misses lease
    breaks that come just after an open response - we don't have time
    to populate new cifsFileInfo structure to the list. Fix this by
    adding new list of pending opens and look for a lease there if we
    didn't find it in the list of cifsFileInfo structures.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b6ec142028e8..a39e5b7fc844 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -715,6 +715,7 @@ struct cifs_ses {
 	__u16 session_flags;
 #endif /* CONFIG_CIFS_SMB2 */
 };
+
 /* no more than one of the following three session flags may be set */
 #define CIFS_SES_NT4 1
 #define CIFS_SES_OS2 2
@@ -821,6 +822,7 @@ struct cifs_tcon {
 	u64 resource_id;		/* server resource id */
 	struct fscache_cookie *fscache;	/* cookie for share */
 #endif
+	struct list_head pending_opens;	/* list of incomplete opens */
 	/* BB add field for back pointer to sb struct(s)? */
 };
 
@@ -863,6 +865,15 @@ cifs_get_tlink(struct tcon_link *tlink)
 /* This function is always expected to succeed */
 extern struct cifs_tcon *cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb);
 
+#define CIFS_OPLOCK_NO_CHANGE 0xfe
+
+struct cifs_pending_open {
+	struct list_head olist;
+	struct tcon_link *tlink;
+	__u8 lease_key[16];
+	__u32 oplock;
+};
+
 /*
  * This info hangs off the cifsFileInfo structure, pointed to by llist.
  * This is used to track byte stream locks on the file
@@ -903,6 +914,7 @@ struct cifs_fid {
 	__u64 volatile_fid;	/* volatile file id for smb2 */
 	__u8 lease_key[SMB2_LEASE_KEY_SIZE];	/* lease key for smb2 */
 #endif
+	struct cifs_pending_open *pending_open;
 };
 
 struct cifs_fid_locks {

commit b8c32dbb0deb287a5fcb78251e4eae6c7275760d
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Sep 19 06:22:44 2012 -0700

    CIFS: Request SMB2.1 leases
    
    if server supports them and we need oplocks.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e2492e1cdb85..b6ec142028e8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -361,6 +361,12 @@ struct smb_version_operations {
 				 const unsigned int);
 	/* push brlocks from the cache to the server */
 	int (*push_mand_locks)(struct cifsFileInfo *);
+	/* get lease key of the inode */
+	void (*get_lease_key)(struct inode *, struct cifs_fid *fid);
+	/* set lease key of the inode */
+	void (*set_lease_key)(struct inode *, struct cifs_fid *fid);
+	/* generate new lease key */
+	void (*new_lease_key)(struct cifs_fid *fid);
 };
 
 struct smb_version_values {
@@ -895,6 +901,7 @@ struct cifs_fid {
 #ifdef CONFIG_CIFS_SMB2
 	__u64 persistent_fid;	/* persist file id for smb2 */
 	__u64 volatile_fid;	/* volatile file id for smb2 */
+	__u8 lease_key[SMB2_LEASE_KEY_SIZE];	/* lease key for smb2 */
 #endif
 };
 
@@ -1012,6 +1019,9 @@ struct cifsInodeInfo {
 	u64  server_eof;		/* current file size on server -- protected by i_lock */
 	u64  uniqueid;			/* server inode number */
 	u64  createtime;		/* creation time on server */
+#ifdef CONFIG_CIFS_SMB2
+	__u8 lease_key[SMB2_LEASE_KEY_SIZE];	/* lease key for this inode */
+#endif
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie *fscache;
 #endif

commit 1b4b55a1d9404f51aacf1ff19887eb911484057d
Author: Pavel Shilovsky <pshilovsky@etersoft.ru>
Date:   Wed Sep 19 06:22:44 2012 -0700

    CIFS: Turn lock mutex into rw semaphore
    
    and allow several processes to walk through the lock list and read
    can_cache_brlcks value if they are not going to modify them.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d3c72713fec4..e2492e1cdb85 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1000,7 +1000,7 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 struct cifsInodeInfo {
 	bool can_cache_brlcks;
 	struct list_head llist;	/* locks helb by this inode */
-	struct mutex lock_mutex;	/* protect the fields above */
+	struct rw_semaphore lock_sem;	/* protect the fields above */
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */

commit d39a4f710b7a7be05b6ed9d4ab8fac754c139f8a
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Sep 19 06:22:43 2012 -0700

    CIFS: Move brlock code to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b2eb577b5f3f..d3c72713fec4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -353,6 +353,14 @@ struct smb_version_operations {
 	/* query remote filesystem */
 	int (*queryfs)(const unsigned int, struct cifs_tcon *,
 		       struct kstatfs *);
+	/* send mandatory brlock to the server */
+	int (*mand_lock)(const unsigned int, struct cifsFileInfo *, __u64,
+			 __u64, __u32, int, int, bool);
+	/* unlock range of mandatory locks */
+	int (*mand_unlock_range)(struct cifsFileInfo *, struct file_lock *,
+				 const unsigned int);
+	/* push brlocks from the cache to the server */
+	int (*push_mand_locks)(struct cifsFileInfo *);
 };
 
 struct smb_version_values {

commit f45d34167c67b083b54690e349e77f59062ef0ea
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Sep 19 06:22:43 2012 -0700

    CIFS: Remove spinlock dependence in brlock processing
    
    Now we need to lock/unlock a spinlock while processing brlock ops
    on the inode. Move brlocks of a fid to a separate list and attach
    all such lists to the inode. This let us not hold a spinlock.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 004672f9e16c..b2eb577b5f3f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -890,13 +890,16 @@ struct cifs_fid {
 #endif
 };
 
+struct cifs_fid_locks {
+	struct list_head llist;
+	struct cifsFileInfo *cfile;	/* fid that owns locks */
+	struct list_head locks;		/* locks held by fid above */
+};
+
 struct cifsFileInfo {
 	struct list_head tlist;	/* pointer to next fid owned by tcon */
 	struct list_head flist;	/* next fid (file instance) for this inode */
-	struct list_head llist;	/*
-				 * brlocks held by this fid, protected by
-				 * lock_mutex from cifsInodeInfo structure
-				 */
+	struct cifs_fid_locks *llist;	/* brlocks held by this fid */
 	unsigned int uid;	/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
 	struct cifs_fid fid;	/* file id from remote */
@@ -988,11 +991,8 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 
 struct cifsInodeInfo {
 	bool can_cache_brlcks;
-	struct mutex lock_mutex;	/*
-					 * protect the field above and llist
-					 * from every cifsFileInfo structure
-					 * from openFileList
-					 */
+	struct list_head llist;	/* locks helb by this inode */
+	struct mutex lock_mutex;	/* protect the fields above */
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */

commit 1c0bd60b560cdf63a263f8ff3cebe9f99fe7a47c
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Wed Sep 19 06:22:43 2012 -0700

    CIFS: Add NTLMSSP sec type to defaults
    
    to let us negotiate SMB2 without specifying sec type explicitly.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b2bb941d8ddd..004672f9e16c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1328,7 +1328,7 @@ require use of the stronger protocol */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
 #define   CIFSSEC_MUST_NTLMSSP	0x80080 /* raw ntlmssp with ntlmv2 */
 
-#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2)
+#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_NTLMSSP)
 #define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)
 #define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)
 /*

commit 71953fc6e4ce5ac05b594d8e5866accf531aa969
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 19 06:22:42 2012 -0700

    cifs: remove kmap lock and rsize limit
    
    Now that we aren't abusing the kmap address space, there's no need for
    this lock or to impose a limit on the rsize.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 79e8b6f06021..b2bb941d8ddd 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -637,45 +637,6 @@ get_next_mid(struct TCP_Server_Info *server)
 #define CIFS_DEFAULT_NON_POSIX_RSIZE (60 * 1024)
 #define CIFS_DEFAULT_NON_POSIX_WSIZE (65536)
 
-/*
- * On hosts with high memory, we can't currently support wsize/rsize that are
- * larger than we can kmap at once. Cap the rsize/wsize at
- * LAST_PKMAP * PAGE_SIZE. We'll never be able to fill a read or write request
- * larger than that anyway.
- */
-#ifdef CONFIG_HIGHMEM
-#define CIFS_KMAP_SIZE_LIMIT   (LAST_PKMAP * PAGE_CACHE_SIZE)
-#else /* CONFIG_HIGHMEM */
-#define CIFS_KMAP_SIZE_LIMIT   (1<<24)
-#endif /* CONFIG_HIGHMEM */
-
-#ifdef CONFIG_HIGHMEM
-/*
- * On arches that have high memory, kmap address space is limited. By
- * serializing the kmap operations on those arches, we ensure that we don't
- * end up with a bunch of threads in writeback with partially mapped page
- * arrays, stuck waiting for kmap to come back. That situation prevents
- * progress and can deadlock.
- */
-
-extern struct mutex cifs_kmap_mutex;
-
-static inline void
-cifs_kmap_lock(void)
-{
-	mutex_lock(&cifs_kmap_mutex);
-}
-
-static inline void
-cifs_kmap_unlock(void)
-{
-	mutex_unlock(&cifs_kmap_mutex);
-}
-#else /* !CONFIG_HIGHMEM */
-#define cifs_kmap_lock() do { ; } while (0)
-#define cifs_kmap_unlock() do { ; } while (0)
-#endif /* CONFIG_HIGHMEM */
-
 /*
  * Macros to allow the TCP_Server_Info->net field and related code to drop out
  * when CONFIG_NET_NS isn't set.

commit 5819575ec6b82345e1a21a960d381c699a91c700
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 19 06:22:34 2012 -0700

    cifs: replace kvec array in readdata with a single kvec
    
    The array is no longer needed. We just need a single kvec to hold the
    header for signature checking.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 93e16200b2e8..79e8b6f06021 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -981,10 +981,9 @@ struct cifs_readdata {
 	int (*read_into_pages)(struct TCP_Server_Info *server,
 				struct cifs_readdata *rdata,
 				unsigned int len);
+	struct kvec			iov;
 	unsigned int			pagesz;
 	unsigned int			tailsz;
-	unsigned int			nr_iov;
-	struct kvec			*iov;
 	unsigned int			nr_pages;
 	struct page			*pages[];
 };

commit 8321fec436050b586cee448f2da0a6999e5172dd
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 19 06:22:32 2012 -0700

    cifs: convert async read code to use pages array without kmapping
    
    Replace the "marshal_iov" function with a "read_into_pages" function.
    That function will copy the read data off the socket and into the
    pages array, kmapping and reading pages one at a time.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b70863ebedf2..93e16200b2e8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -978,8 +978,11 @@ struct cifs_readdata {
 	pid_t				pid;
 	int				result;
 	struct work_struct		work;
-	int (*marshal_iov) (struct cifs_readdata *rdata,
-			    unsigned int remaining);
+	int (*read_into_pages)(struct TCP_Server_Info *server,
+				struct cifs_readdata *rdata,
+				unsigned int len);
+	unsigned int			pagesz;
+	unsigned int			tailsz;
 	unsigned int			nr_iov;
 	struct kvec			*iov;
 	unsigned int			nr_pages;

commit c5fab6f4f081afcfcd7c1d444d9b900d6ef3e50b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 19 06:22:30 2012 -0700

    cifs: turn the pages list in cifs_readdata into an array
    
    We'll need an array to put into a smb_rqst, so convert this into an array
    instead of (ab)using the lru list_head.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 737289b50ca5..b70863ebedf2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -977,12 +977,13 @@ struct cifs_readdata {
 	unsigned int			bytes;
 	pid_t				pid;
 	int				result;
-	struct list_head		pages;
 	struct work_struct		work;
 	int (*marshal_iov) (struct cifs_readdata *rdata,
 			    unsigned int remaining);
 	unsigned int			nr_iov;
 	struct kvec			*iov;
+	unsigned int			nr_pages;
+	struct page			*pages[];
 };
 
 struct cifs_writedata;

commit f4e49cd2dce2ccac6feae64fbb4e90f7d8baf370
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Sep 18 16:20:36 2012 -0700

    cifs: allocate kvec array for cifs_readdata as a separate allocation
    
    Eventually, we're going to want to append a list of pages to
    cifs_readdata instead of a list of kvecs. To prepare for that, turn
    the kvec array allocation into a separate one and just keep a
    pointer to it in the readdata.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cc70ac0bac47..737289b50ca5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -982,7 +982,7 @@ struct cifs_readdata {
 	int (*marshal_iov) (struct cifs_readdata *rdata,
 			    unsigned int remaining);
 	unsigned int			nr_iov;
-	struct kvec			iov[1];
+	struct kvec			*iov;
 };
 
 struct cifs_writedata;

commit eddb079deb4deb1259f87425094c7a586fc59313
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Sep 18 16:20:35 2012 -0700

    cifs: convert async write code to pass in data via rq_pages array
    
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a81790005e57..cc70ac0bac47 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -999,8 +999,8 @@ struct cifs_writedata {
 	pid_t				pid;
 	unsigned int			bytes;
 	int				result;
-	void (*marshal_iov) (struct kvec *iov,
-			     struct cifs_writedata *wdata);
+	unsigned int			pagesz;
+	unsigned int			tailsz;
 	unsigned int			nr_pages;
 	struct page			*pages[1];
 };

commit fec344e3f31aa911297cd3a4639432d983b1f324
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Sep 18 16:20:35 2012 -0700

    cifs: change cifs_call_async to use smb_rqst structs
    
    For now, none of the callers populate rq_pages. That will be done for
    writes in a later patch. While we're at it, change the prototype of
    setup_async_request not to need a return pointer argument. Just
    return the pointer to the mid_q_entry or an ERR_PTR.
    
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5ea50dd316c5..a81790005e57 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -201,11 +201,11 @@ struct smb_version_operations {
 			   struct mid_q_entry *);
 	bool (*compare_fids)(struct cifsFileInfo *, struct cifsFileInfo *);
 	/* setup request: allocate mid, sign message */
-	int (*setup_request)(struct cifs_ses *, struct kvec *, unsigned int,
-			     struct mid_q_entry **);
+	struct mid_q_entry *(*setup_request)(struct cifs_ses *,
+						struct smb_rqst *);
 	/* setup async request: allocate mid, sign message */
-	int (*setup_async_request)(struct TCP_Server_Info *, struct kvec *,
-				   unsigned int, struct mid_q_entry **);
+	struct mid_q_entry *(*setup_async_request)(struct TCP_Server_Info *,
+						struct smb_rqst *);
 	/* check response: verify signature, map error */
 	int (*check_receive)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     bool);

commit bf5ea0e2f29b00d4fe5f203d8e59120f797ce451
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Sep 18 16:20:34 2012 -0700

    cifs: change signing routines to deal with smb_rqst structs
    
    We need a way to represent a call to be sent on the wire that does not
    require having all of the page data kmapped. Behold the smb_rqst struct.
    This new struct represents an array of kvecs immediately followed by an
    array of pages.
    
    Convert the signing routines to use these structs under the hood and
    turn the existing functions for this into wrappers around that. For now,
    we're just changing these functions to take different args. Later, we'll
    teach them how to deal with arrays of pages.
    
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3c007fe641f9..5ea50dd316c5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -162,6 +162,20 @@ struct cifs_cred {
  *****************************************************************
  */
 
+/*
+ * A smb_rqst represents a complete request to be issued to a server. It's
+ * formed by a kvec array, followed by an array of pages. Page data is assumed
+ * to start at the beginning of the first page.
+ */
+struct smb_rqst {
+	struct kvec	*rq_iov;	/* array of kvecs */
+	unsigned int	rq_nvec;	/* number of kvecs in array */
+	struct page	**rq_pages;	/* pointer to array of page ptrs */
+	unsigned int	rq_npages;	/* number pages in array */
+	unsigned int	rq_pagesz;	/* page size to use */
+	unsigned int	rq_tailsz;	/* length of last page */
+};
+
 enum smb_version {
 	Smb_1 = 1,
 	Smb_21,

commit 76ec5e33846de386f44826f145cd725b92c23630
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:33 2012 -0700

    CIFS: Move statfs to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a95c56dc7058..3c007fe641f9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -32,6 +32,8 @@
 #include "smb2pdu.h"
 #endif
 
+#define CIFS_MAGIC_NUMBER 0xFF534D42      /* the first four bytes of SMB PDUs */
+
 /*
  * The sizes of various internal tables and strings
  */
@@ -334,6 +336,9 @@ struct smb_version_operations {
 	/* send oplock break response */
 	int (*oplock_response)(struct cifs_tcon *, struct cifs_fid *,
 			       struct cifsInodeInfo *);
+	/* query remote filesystem */
+	int (*queryfs)(const unsigned int, struct cifs_tcon *,
+		       struct kstatfs *);
 };
 
 struct smb_version_values {

commit 95a3f2f377735ed13e42d3b8039aa1d73af2c90e
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:33 2012 -0700

    CIFS: Move oplock break to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3eb59ed6904a..a95c56dc7058 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -178,6 +178,7 @@ struct cifs_readdata;
 struct cifs_writedata;
 struct cifs_io_parms;
 struct cifs_search_info;
+struct cifsInodeInfo;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -330,6 +331,9 @@ struct smb_version_operations {
 	unsigned int (*calc_smb_size)(void *);
 	/* check for STATUS_PENDING and process it in a positive case */
 	bool (*is_status_pending)(char *, struct TCP_Server_Info *, int);
+	/* send oplock break response */
+	int (*oplock_response)(struct cifs_tcon *, struct cifs_fid *,
+			       struct cifsInodeInfo *);
 };
 
 struct smb_version_values {

commit 2e44b2887882134abf353b28867b82645e9f0856
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:33 2012 -0700

    CIFS: Process oplocks for SMB2
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9adf211ca95a..3eb59ed6904a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -328,6 +328,8 @@ struct smb_version_operations {
 			 struct cifs_fid *);
 	/* calculate a size of SMB message */
 	unsigned int (*calc_smb_size)(void *);
+	/* check for STATUS_PENDING and process it in a positive case */
+	bool (*is_status_pending)(char *, struct TCP_Server_Info *, int);
 };
 
 struct smb_version_values {

commit 92fc65a74a2be1388d774f7dbf82c9adea1745cf
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:32 2012 -0700

    CIFS: Move readdir code to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index dff35830601f..9adf211ca95a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -177,6 +177,7 @@ struct cifs_fid;
 struct cifs_readdata;
 struct cifs_writedata;
 struct cifs_io_parms;
+struct cifs_search_info;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -313,6 +314,20 @@ struct smb_version_operations {
 	int (*sync_write)(const unsigned int, struct cifsFileInfo *,
 			  struct cifs_io_parms *, unsigned int *, struct kvec *,
 			  unsigned long);
+	/* open dir, start readdir */
+	int (*query_dir_first)(const unsigned int, struct cifs_tcon *,
+			       const char *, struct cifs_sb_info *,
+			       struct cifs_fid *, __u16,
+			       struct cifs_search_info *);
+	/* continue readdir */
+	int (*query_dir_next)(const unsigned int, struct cifs_tcon *,
+			      struct cifs_fid *,
+			      __u16, struct cifs_search_info *srch_inf);
+	/* close dir */
+	int (*close_dir)(const unsigned int, struct cifs_tcon *,
+			 struct cifs_fid *);
+	/* calculate a size of SMB message */
+	unsigned int (*calc_smb_size)(void *);
 };
 
 struct smb_version_values {

commit 6bdf6dbd662176c0da5c3ac8ed10ac94e7776c85
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:32 2012 -0700

    CIFS: Move set_file_info to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 803c21218633..dff35830601f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -258,6 +258,9 @@ struct smb_version_operations {
 	/* set size by file handle */
 	int (*set_file_size)(const unsigned int, struct cifs_tcon *,
 			     struct cifsFileInfo *, __u64, bool);
+	/* set attributes */
+	int (*set_file_info)(struct inode *, const char *, FILE_BASIC_INFO *,
+			     const unsigned int);
 	/* build a full path to the root of the mount */
 	char * (*build_path_to_root)(struct smb_vol *, struct cifs_sb_info *,
 				     struct cifs_tcon *);

commit d143341815bdc7c45d5289a3ab5743c838332518
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:31 2012 -0700

    CIFS: Move set_file_size to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8595d498ad80..803c21218633 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -252,6 +252,12 @@ struct smb_version_operations {
 	int (*get_srv_inum)(const unsigned int, struct cifs_tcon *,
 			    struct cifs_sb_info *, const char *,
 			    u64 *uniqueid, FILE_ALL_INFO *);
+	/* set size by path */
+	int (*set_path_size)(const unsigned int, struct cifs_tcon *,
+			     const char *, __u64, struct cifs_sb_info *, bool);
+	/* set size by file handle */
+	int (*set_file_size)(const unsigned int, struct cifs_tcon *,
+			     struct cifsFileInfo *, __u64, bool);
 	/* build a full path to the root of the mount */
 	char * (*build_path_to_root)(struct smb_vol *, struct cifs_sb_info *,
 				     struct cifs_tcon *);

commit d6e906f1b571d15ff5778a049802f6ef6f70159a
Author: Steve French <smfrench@gmail.com>
Date:   Tue Sep 18 16:20:31 2012 -0700

    CIFS: Move hardlink to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a0105c547ffd..8595d498ad80 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -278,6 +278,10 @@ struct smb_version_operations {
 	/* send rename request */
 	int (*rename)(const unsigned int, struct cifs_tcon *, const char *,
 		      const char *, struct cifs_sb_info *);
+	/* send create hardlink request */
+	int (*create_hardlink)(const unsigned int, struct cifs_tcon *,
+			       const char *, const char *,
+			       struct cifs_sb_info *);
 	/* open a file for non-posix mounts */
 	int (*open)(const unsigned int, struct cifs_tcon *, const char *, int,
 		    int, int, struct cifs_fid *, __u32 *, FILE_ALL_INFO *,

commit 8ceb984379462f94bdebef3288d569c6e1f912ea
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:30 2012 -0700

    CIFS: Move rename to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6217df707909..a0105c547ffd 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -275,6 +275,9 @@ struct smb_version_operations {
 	/* open, rename and delete file */
 	int (*rename_pending_delete)(const char *, struct dentry *,
 				     const unsigned int);
+	/* send rename request */
+	int (*rename)(const unsigned int, struct cifs_tcon *, const char *,
+		      const char *, struct cifs_sb_info *);
 	/* open a file for non-posix mounts */
 	int (*open)(const unsigned int, struct cifs_tcon *, const char *, int,
 		    int, int, struct cifs_fid *, __u32 *, FILE_ALL_INFO *,

commit 3c1bf7e48e9e463b65b1b90da4500a93dd2b27a7
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:30 2012 -0700

    CIFS: Enable signing in SMB2
    
    Use hmac-sha256 and rather than hmac-md5 that is used for CIFS/SMB.
    
    Signature field in SMB2 header is 16 bytes instead of 8 bytes.
    
    Automatically enable signing by client when requested by the server
    when signing ability is available to the client.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 48c7c83a7a99..6217df707909 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -128,8 +128,10 @@ struct sdesc {
 struct cifs_secmech {
 	struct crypto_shash *hmacmd5; /* hmac-md5 hash function */
 	struct crypto_shash *md5; /* md5 hash function */
+	struct crypto_shash *hmacsha256; /* hmac-sha256 hash function */
 	struct sdesc *sdeschmacmd5;  /* ctxt to generate ntlmv2 hash, CR1 */
 	struct sdesc *sdescmd5; /* ctxt to generate cifs/smb signature */
+	struct sdesc *sdeschmacsha256;  /* ctxt to generate smb2 signature */
 };
 
 /* per smb session structure/fields */

commit ba9ad7257ae50b8aa72a3f44da839830e065363c
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:30 2012 -0700

    CIFS: Move writepage to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5b1751d81901..48c7c83a7a99 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -291,6 +291,10 @@ struct smb_version_operations {
 	int (*sync_read)(const unsigned int, struct cifsFileInfo *,
 			 struct cifs_io_parms *, unsigned int *, char **,
 			 int *);
+	/* sync write to the server */
+	int (*sync_write)(const unsigned int, struct cifsFileInfo *,
+			  struct cifs_io_parms *, unsigned int *, struct kvec *,
+			  unsigned long);
 };
 
 struct smb_version_values {

commit f9c6e234c3ca64b8d49336908df99948518d6261
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:29 2012 -0700

    CIFS: Move readpage code to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 330f6259bb6d..5b1751d81901 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -174,6 +174,7 @@ struct smb_vol;
 struct cifs_fid;
 struct cifs_readdata;
 struct cifs_writedata;
+struct cifs_io_parms;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -286,6 +287,10 @@ struct smb_version_operations {
 	int (*async_readv)(struct cifs_readdata *);
 	/* async write to the server */
 	int (*async_writev)(struct cifs_writedata *);
+	/* sync read from the server */
+	int (*sync_read)(const unsigned int, struct cifsFileInfo *,
+			 struct cifs_io_parms *, unsigned int *, char **,
+			 int *);
 };
 
 struct smb_version_values {

commit 33319141252fd14b58cf13685156c23dcaac2527
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:29 2012 -0700

    CIFS: Add SMB2 support for cifs_iovec_write
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index aef167470654..330f6259bb6d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -582,6 +582,33 @@ get_next_mid(struct TCP_Server_Info *server)
 #define CIFS_KMAP_SIZE_LIMIT   (1<<24)
 #endif /* CONFIG_HIGHMEM */
 
+#ifdef CONFIG_HIGHMEM
+/*
+ * On arches that have high memory, kmap address space is limited. By
+ * serializing the kmap operations on those arches, we ensure that we don't
+ * end up with a bunch of threads in writeback with partially mapped page
+ * arrays, stuck waiting for kmap to come back. That situation prevents
+ * progress and can deadlock.
+ */
+
+extern struct mutex cifs_kmap_mutex;
+
+static inline void
+cifs_kmap_lock(void)
+{
+	mutex_lock(&cifs_kmap_mutex);
+}
+
+static inline void
+cifs_kmap_unlock(void)
+{
+	mutex_unlock(&cifs_kmap_mutex);
+}
+#else /* !CONFIG_HIGHMEM */
+#define cifs_kmap_lock() do { ; } while (0)
+#define cifs_kmap_unlock() do { ; } while (0)
+#endif /* CONFIG_HIGHMEM */
+
 /*
  * Macros to allow the TCP_Server_Info->net field and related code to drop out
  * when CONFIG_NET_NS isn't set.
@@ -891,6 +918,26 @@ struct cifs_readdata {
 	struct kvec			iov[1];
 };
 
+struct cifs_writedata;
+
+/* asynchronous write support */
+struct cifs_writedata {
+	struct kref			refcount;
+	struct list_head		list;
+	struct completion		done;
+	enum writeback_sync_modes	sync_mode;
+	struct work_struct		work;
+	struct cifsFileInfo		*cfile;
+	__u64				offset;
+	pid_t				pid;
+	unsigned int			bytes;
+	int				result;
+	void (*marshal_iov) (struct kvec *iov,
+			     struct cifs_writedata *wdata);
+	unsigned int			nr_pages;
+	struct page			*pages[1];
+};
+
 /*
  * Take a reference on the file private data. Must be called with
  * cifs_file_list_lock held.

commit c9de5c80d536e556568ccd45b9599870d4993b7d
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:29 2012 -0700

    CIFS: Move async write to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 93dd582bb8d1..aef167470654 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -173,6 +173,7 @@ struct cifs_fattr;
 struct smb_vol;
 struct cifs_fid;
 struct cifs_readdata;
+struct cifs_writedata;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -283,6 +284,8 @@ struct smb_version_operations {
 	int (*flush)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
 	/* async read from the server */
 	int (*async_readv)(struct cifs_readdata *);
+	/* async write to the server */
+	int (*async_writev)(struct cifs_writedata *);
 };
 
 struct smb_version_values {

commit 09a4707e7638247302c6d798061aed117141fb74
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:29 2012 -0700

    CIFS: Add SMB2 support for cifs_iovec_read
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fcf81c05635f..93dd582bb8d1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -857,12 +857,37 @@ struct cifsFileInfo {
 
 struct cifs_io_parms {
 	__u16 netfid;
+#ifdef CONFIG_CIFS_SMB2
+	__u64 persistent_fid;	/* persist file id for smb2 */
+	__u64 volatile_fid;	/* volatile file id for smb2 */
+#endif
 	__u32 pid;
 	__u64 offset;
 	unsigned int length;
 	struct cifs_tcon *tcon;
 };
 
+struct cifs_readdata;
+
+/* asynchronous read support */
+struct cifs_readdata {
+	struct kref			refcount;
+	struct list_head		list;
+	struct completion		done;
+	struct cifsFileInfo		*cfile;
+	struct address_space		*mapping;
+	__u64				offset;
+	unsigned int			bytes;
+	pid_t				pid;
+	int				result;
+	struct list_head		pages;
+	struct work_struct		work;
+	int (*marshal_iov) (struct cifs_readdata *rdata,
+			    unsigned int remaining);
+	unsigned int			nr_iov;
+	struct kvec			iov[1];
+};
+
 /*
  * Take a reference on the file private data. Must be called with
  * cifs_file_list_lock held.

commit fc9c59662e0cd37577556d0de865268baeb9b293
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:28 2012 -0700

    CIFS: Move async read to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e5cb1941e251..fcf81c05635f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -172,6 +172,7 @@ struct dfs_info3_param;
 struct cifs_fattr;
 struct smb_vol;
 struct cifs_fid;
+struct cifs_readdata;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -280,6 +281,8 @@ struct smb_version_operations {
 	int (*close)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
 	/* send a flush request to the server */
 	int (*flush)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
+	/* async read from the server */
+	int (*async_readv)(struct cifs_readdata *);
 };
 
 struct smb_version_values {

commit 24985c53d5b04a56ac7c8ae7f74b8cb807e2ed2f
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:28 2012 -0700

    CIFS: Move r/wsize negotiating to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index abb831019039..e5cb1941e251 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -213,6 +213,10 @@ struct smb_version_operations {
 	bool (*need_neg)(struct TCP_Server_Info *);
 	/* negotiate to the server */
 	int (*negotiate)(const unsigned int, struct cifs_ses *);
+	/* set negotiated write size */
+	unsigned int (*negotiate_wsize)(struct cifs_tcon *, struct smb_vol *);
+	/* set negotiated read size */
+	unsigned int (*negotiate_rsize)(struct cifs_tcon *, struct smb_vol *);
 	/* setup smb sessionn */
 	int (*sess_setup)(const unsigned int, struct cifs_ses *,
 			  const struct nls_table *);
@@ -515,6 +519,63 @@ get_next_mid(struct TCP_Server_Info *server)
 	return server->ops->get_next_mid(server);
 }
 
+/*
+ * When the server supports very large reads and writes via POSIX extensions,
+ * we can allow up to 2^24-1, minus the size of a READ/WRITE_AND_X header, not
+ * including the RFC1001 length.
+ *
+ * Note that this might make for "interesting" allocation problems during
+ * writeback however as we have to allocate an array of pointers for the
+ * pages. A 16M write means ~32kb page array with PAGE_CACHE_SIZE == 4096.
+ *
+ * For reads, there is a similar problem as we need to allocate an array
+ * of kvecs to handle the receive, though that should only need to be done
+ * once.
+ */
+#define CIFS_MAX_WSIZE ((1<<24) - 1 - sizeof(WRITE_REQ) + 4)
+#define CIFS_MAX_RSIZE ((1<<24) - sizeof(READ_RSP) + 4)
+
+/*
+ * When the server doesn't allow large posix writes, only allow a rsize/wsize
+ * of 2^17-1 minus the size of the call header. That allows for a read or
+ * write up to the maximum size described by RFC1002.
+ */
+#define CIFS_MAX_RFC1002_WSIZE ((1<<17) - 1 - sizeof(WRITE_REQ) + 4)
+#define CIFS_MAX_RFC1002_RSIZE ((1<<17) - 1 - sizeof(READ_RSP) + 4)
+
+/*
+ * The default wsize is 1M. find_get_pages seems to return a maximum of 256
+ * pages in a single call. With PAGE_CACHE_SIZE == 4k, this means we can fill
+ * a single wsize request with a single call.
+ */
+#define CIFS_DEFAULT_IOSIZE (1024 * 1024)
+
+/*
+ * Windows only supports a max of 60kb reads and 65535 byte writes. Default to
+ * those values when posix extensions aren't in force. In actuality here, we
+ * use 65536 to allow for a write that is a multiple of 4k. Most servers seem
+ * to be ok with the extra byte even though Windows doesn't send writes that
+ * are that large.
+ *
+ * Citation:
+ *
+ * http://blogs.msdn.com/b/openspecification/archive/2009/04/10/smb-maximum-transmit-buffer-size-and-performance-tuning.aspx
+ */
+#define CIFS_DEFAULT_NON_POSIX_RSIZE (60 * 1024)
+#define CIFS_DEFAULT_NON_POSIX_WSIZE (65536)
+
+/*
+ * On hosts with high memory, we can't currently support wsize/rsize that are
+ * larger than we can kmap at once. Cap the rsize/wsize at
+ * LAST_PKMAP * PAGE_SIZE. We'll never be able to fill a read or write request
+ * larger than that anyway.
+ */
+#ifdef CONFIG_HIGHMEM
+#define CIFS_KMAP_SIZE_LIMIT   (LAST_PKMAP * PAGE_CACHE_SIZE)
+#else /* CONFIG_HIGHMEM */
+#define CIFS_KMAP_SIZE_LIMIT   (1<<24)
+#endif /* CONFIG_HIGHMEM */
+
 /*
  * Macros to allow the TCP_Server_Info->net field and related code to drop out
  * when CONFIG_NET_NS isn't set.

commit 1d8c4c0009deda22b436b1f0ab9f2885863717fc
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:27 2012 -0700

    CIFS: Make flush code use ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 500ecb921b85..abb831019039 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -274,6 +274,8 @@ struct smb_version_operations {
 	void (*set_fid)(struct cifsFileInfo *, struct cifs_fid *, __u32);
 	/* close a file */
 	int (*close)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
+	/* send a flush request to the server */
+	int (*flush)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
 };
 
 struct smb_version_values {

commit 4ad6504453644f57f7b6cf9c7bfc9d1372c5ad15
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:26 2012 -0700

    CIFS: Move guery file info code to ops struct
    
    and make cifs_get_file_info(_unix) calls static.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8a69dae81d3a..500ecb921b85 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -236,6 +236,9 @@ struct smb_version_operations {
 	int (*query_path_info)(const unsigned int, struct cifs_tcon *,
 			       struct cifs_sb_info *, const char *,
 			       FILE_ALL_INFO *, bool *);
+	/* query file data from the server */
+	int (*query_file_info)(const unsigned int, struct cifs_tcon *,
+			       struct cifs_fid *, FILE_ALL_INFO *);
 	/* get server index number */
 	int (*get_srv_inum)(const unsigned int, struct cifs_tcon *,
 			    struct cifs_sb_info *, const char *,

commit f0df737ee820ec62055baf2b28e24db4fb1ad71d
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:26 2012 -0700

    CIFS: Add open/close file support for SMB2
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 39bf2f3e866a..8a69dae81d3a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -757,6 +757,10 @@ struct cifs_search_info {
 
 struct cifs_fid {
 	__u16 netfid;
+#ifdef CONFIG_CIFS_SMB2
+	__u64 persistent_fid;	/* persist file id for smb2 */
+	__u64 volatile_fid;	/* volatile file id for smb2 */
+#endif
 };
 
 struct cifsFileInfo {

commit 0ff78a221bf7839a7f20be9929433d17e868e987
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:26 2012 -0700

    CIFS: Move close code to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e649fac7d6fe..39bf2f3e866a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -269,6 +269,8 @@ struct smb_version_operations {
 		    struct cifs_sb_info *);
 	/* set fid protocol-specific info */
 	void (*set_fid)(struct cifsFileInfo *, struct cifs_fid *, __u32);
+	/* close a file */
+	int (*close)(const unsigned int, struct cifs_tcon *, struct cifs_fid *);
 };
 
 struct smb_version_values {

commit fb1214e48f735cdb68446adb77ec37aa3de60697
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:26 2012 -0700

    CIFS: Move open code to ops struct
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a2a3865dee1b..e649fac7d6fe 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -171,6 +171,7 @@ struct cifs_tcon;
 struct dfs_info3_param;
 struct cifs_fattr;
 struct smb_vol;
+struct cifs_fid;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -262,6 +263,12 @@ struct smb_version_operations {
 	/* open, rename and delete file */
 	int (*rename_pending_delete)(const char *, struct dentry *,
 				     const unsigned int);
+	/* open a file for non-posix mounts */
+	int (*open)(const unsigned int, struct cifs_tcon *, const char *, int,
+		    int, int, struct cifs_fid *, __u32 *, FILE_ALL_INFO *,
+		    struct cifs_sb_info *);
+	/* set fid protocol-specific info */
+	void (*set_fid)(struct cifsFileInfo *, struct cifs_fid *, __u32);
 };
 
 struct smb_version_values {

commit 4b4de76e35518fc0c636f628abca8c1b19ad6689
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:26 2012 -0700

    CIFS: Replace netfid with cifs_fid struct in cifsFileInfo
    
    This is help us to extend the code for future protocols that can use
    another fid mechanism (as SMB2 that has it divided into two parts:
    persistent and violatile).
    
    Also rename variables and refactor the code around the changes.
    
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 843356fa262d..a2a3865dee1b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -746,6 +746,10 @@ struct cifs_search_info {
 	bool smallBuf:1; /* so we know which buf_release function to call */
 };
 
+struct cifs_fid {
+	__u16 netfid;
+};
+
 struct cifsFileInfo {
 	struct list_head tlist;	/* pointer to next fid owned by tcon */
 	struct list_head flist;	/* next fid (file instance) for this inode */
@@ -755,7 +759,7 @@ struct cifsFileInfo {
 				 */
 	unsigned int uid;	/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
-	__u16 netfid;		/* file id from remote */
+	struct cifs_fid fid;	/* file id from remote */
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
 	struct dentry *dentry;

commit ed6875e0d6c28e4a6b44da04d6d4363b3d92d630
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:25 2012 -0700

    CIFS: Move unlink code to ops struct
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 977dc0e85ccb..843356fa262d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -256,6 +256,12 @@ struct smb_version_operations {
 	/* remove directory */
 	int (*rmdir)(const unsigned int, struct cifs_tcon *, const char *,
 		     struct cifs_sb_info *);
+	/* unlink file */
+	int (*unlink)(const unsigned int, struct cifs_tcon *, const char *,
+		      struct cifs_sb_info *);
+	/* open, rename and delete file */
+	int (*rename_pending_delete)(const char *, struct dentry *,
+				     const unsigned int);
 };
 
 struct smb_version_values {

commit f958ca5d88e6071767b10549d544b3475dfb6996
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Jul 10 16:14:18 2012 +0400

    CIFS: Move rmdir code to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 939f91aac162..977dc0e85ccb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -253,6 +253,9 @@ struct smb_version_operations {
 	void (*mkdir_setinfo)(struct inode *, const char *,
 			      struct cifs_sb_info *, struct cifs_tcon *,
 			      const unsigned int);
+	/* remove directory */
+	int (*rmdir)(const unsigned int, struct cifs_tcon *, const char *,
+		     struct cifs_sb_info *);
 };
 
 struct smb_version_values {

commit f436720e94ac53413e20c48b02d16e2ef180e166
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Sat Mar 17 11:41:12 2012 +0300

    CIFS: Separate protocol specific part from mkdir
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 497da5ce704c..939f91aac162 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -246,6 +246,13 @@ struct smb_version_operations {
 	bool (*can_echo)(struct TCP_Server_Info *);
 	/* send echo request */
 	int (*echo)(struct TCP_Server_Info *);
+	/* create directory */
+	int (*mkdir)(const unsigned int, struct cifs_tcon *, const char *,
+		     struct cifs_sb_info *);
+	/* set info on created directory */
+	void (*mkdir_setinfo)(struct inode *, const char *,
+			      struct cifs_sb_info *, struct cifs_tcon *,
+			      const unsigned int);
 };
 
 struct smb_version_values {

commit 764a1b1acecedfe204cb2e80d8e2cc7c6df1b0b8
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Jul 25 14:59:54 2012 -0400

    cifs: ensure that we always do cifsFileInfo_get under the spinlock
    
    The readpages bug is a regression that was introduced in 6993f74a5.
    This also fixes a couple of similar bugs in the uncached read and write
    codepaths.
    
    Also, prevent this sort of thing in the future by having cifsFileInfo_get
    take the spinlock itself, and adding a _locked variant for use in places
    that are already holding the lock. The _put code has always done that
    so this makes for a less confusing interface.
    
    Cc: <stable@vger.kernel.org> # 3.5.x
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index bcdf4d4420f1..497da5ce704c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -765,13 +765,13 @@ struct cifs_io_parms {
  * Take a reference on the file private data. Must be called with
  * cifs_file_list_lock held.
  */
-static inline
-struct cifsFileInfo *cifsFileInfo_get(struct cifsFileInfo *cifs_file)
+static inline void
+cifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)
 {
 	++cifs_file->count;
-	return cifs_file;
 }
 
+struct cifsFileInfo *cifsFileInfo_get(struct cifsFileInfo *cifs_file);
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 
 /*

commit 29e20f9c65fae245d6fd4fce31cc5d01cde3d93f
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri Jul 13 13:58:14 2012 +0400

    CIFS: Make CAP_* checks protocol independent
    
    Since both CIFS and SMB2 use ses->capabilities (server->capabilities)
    field but flags are different we should make such checks protocol
    independent.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 12b1176b87b0..bcdf4d4420f1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -258,6 +258,9 @@ struct smb_version_values {
 	size_t		max_header_size;
 	size_t		read_rsp_size;
 	__le16		lock_cmd;
+	unsigned int	cap_unix;
+	unsigned int	cap_nt_find;
+	unsigned int	cap_large_files;
 };
 
 #define HEADER_SIZE(server) (server->vals->header_size)
@@ -408,7 +411,7 @@ struct TCP_Server_Info {
 	unsigned int max_vcs;	/* maximum number of smb sessions, at least
 				   those that can be specified uniquely with
 				   vcnumbers */
-	int capabilities; /* allow selective disabling of caps by smb sess */
+	unsigned int capabilities; /* selective disabling of caps by smb sess */
 	int timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u64 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlm, ntlmv2 etc */
@@ -532,7 +535,7 @@ struct cifs_ses {
 	__u64 Suid;		/* remote smb uid  */
 	uid_t linux_uid;        /* overriding owner of files on the mount */
 	uid_t cred_uid;		/* owner of credentials */
-	int capabilities;
+	unsigned int capabilities;
 	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for
 				TCP names - will ipv6 and sctp addresses fit? */
 	char *user_name;	/* must not be null except during init of sess
@@ -554,6 +557,13 @@ struct cifs_ses {
    which do not negotiate NTLM or POSIX dialects, but instead
    negotiate one of the older LANMAN dialects */
 #define CIFS_SES_LANMAN 8
+
+static inline bool
+cap_unix(struct cifs_ses *ses)
+{
+	return ses->server->vals->cap_unix & ses->capabilities;
+}
+
 /*
  * there is one of these for each connection to a resource on a particular
  * session

commit d60622eb5a23904facf4a4efac60f5bfa810d7d4
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Mon May 28 15:19:39 2012 +0400

    CIFS: Allow SMB2 statistics to be tracked
    
    Since there are only 19 command codes, it also is easier to track by exact
    command code than it was for cifs.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0896328418aa..12b1176b87b0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -28,6 +28,9 @@
 #include "cifsacl.h"
 #include <crypto/internal/hash.h>
 #include <linux/scatterlist.h>
+#ifdef CONFIG_CIFS_SMB2
+#include "smb2pdu.h"
+#endif
 
 /*
  * The sizes of various internal tables and strings
@@ -592,6 +595,12 @@ struct cifs_tcon {
 			atomic_t num_acl_get;
 			atomic_t num_acl_set;
 		} cifs_stats;
+#ifdef CONFIG_CIFS_SMB2
+		struct {
+			atomic_t smb2_com_sent[NUMBER_OF_SMB2_COMMANDS];
+			atomic_t smb2_com_failed[NUMBER_OF_SMB2_COMMANDS];
+		} smb2_stats;
+#endif /* CONFIG_CIFS_SMB2 */
 	} stats;
 #ifdef CONFIG_CIFS_STATS2
 	unsigned long long time_writes;

commit 44c581866e2ae4bbc3c8eea5a3e3c7a0f639e12d
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Mon May 28 14:16:31 2012 +0400

    CIFS: Move clear/print_stats code to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ae9a1e900c15..0896328418aa 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -197,6 +197,8 @@ struct smb_version_operations {
 	/* find mid corresponding to the response message */
 	struct mid_q_entry * (*find_mid)(struct TCP_Server_Info *, char *);
 	void (*dump_detail)(void *);
+	void (*clear_stats)(struct cifs_tcon *);
+	void (*print_stats)(struct seq_file *m, struct cifs_tcon *);
 	/* verify the message */
 	int (*check_message)(char *, unsigned int);
 	bool (*is_oplock_break)(char *, struct TCP_Server_Info *);
@@ -566,27 +568,31 @@ struct cifs_tcon {
 	enum statusEnum tidStatus;
 #ifdef CONFIG_CIFS_STATS
 	atomic_t num_smbs_sent;
-	atomic_t num_writes;
-	atomic_t num_reads;
-	atomic_t num_flushes;
-	atomic_t num_oplock_brks;
-	atomic_t num_opens;
-	atomic_t num_closes;
-	atomic_t num_deletes;
-	atomic_t num_mkdirs;
-	atomic_t num_posixopens;
-	atomic_t num_posixmkdirs;
-	atomic_t num_rmdirs;
-	atomic_t num_renames;
-	atomic_t num_t2renames;
-	atomic_t num_ffirst;
-	atomic_t num_fnext;
-	atomic_t num_fclose;
-	atomic_t num_hardlinks;
-	atomic_t num_symlinks;
-	atomic_t num_locks;
-	atomic_t num_acl_get;
-	atomic_t num_acl_set;
+	union {
+		struct {
+			atomic_t num_writes;
+			atomic_t num_reads;
+			atomic_t num_flushes;
+			atomic_t num_oplock_brks;
+			atomic_t num_opens;
+			atomic_t num_closes;
+			atomic_t num_deletes;
+			atomic_t num_mkdirs;
+			atomic_t num_posixopens;
+			atomic_t num_posixmkdirs;
+			atomic_t num_rmdirs;
+			atomic_t num_renames;
+			atomic_t num_t2renames;
+			atomic_t num_ffirst;
+			atomic_t num_fnext;
+			atomic_t num_fclose;
+			atomic_t num_hardlinks;
+			atomic_t num_symlinks;
+			atomic_t num_locks;
+			atomic_t num_acl_get;
+			atomic_t num_acl_set;
+		} cifs_stats;
+	} stats;
 #ifdef CONFIG_CIFS_STATS2
 	unsigned long long time_writes;
 	unsigned long long time_reads;

commit 9094fad1ed90caebd25b1bdec3c8982d079356ee
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Jul 12 18:30:44 2012 +0400

    CIFS: Add echo request support for SMB2
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0c53a8339253..ae9a1e900c15 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -73,6 +73,9 @@
 /*           (max path length + 1 for null) * 2 for unicode    */
 #define MAX_NAME 514
 
+/* SMB echo "timeout" -- FIXME: tunable? */
+#define SMB_ECHO_INTERVAL (60 * HZ)
+
 #include "cifspdu.h"
 
 #ifndef XATTR_DOS_ATTRIB

commit f6d7617862e106affc59c6933099e45629af5c4e
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri May 25 14:47:16 2012 +0400

    CIFS: Move echo code to osp struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5e4d1c56767d..0c53a8339253 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -234,6 +234,10 @@ struct smb_version_operations {
 	/* build a full path to the root of the mount */
 	char * (*build_path_to_root)(struct smb_vol *, struct cifs_sb_info *,
 				     struct cifs_tcon *);
+	/* check if we can send an echo or nor */
+	bool (*can_echo)(struct TCP_Server_Info *);
+	/* send echo request */
+	int (*echo)(struct TCP_Server_Info *);
 };
 
 struct smb_version_values {

commit 45740847e2362f36410e8118ac685876be473039
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri Jun 1 14:26:18 2012 +0400

    CIFS: Setup async request in ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 340dce0ed07b..5e4d1c56767d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -173,6 +173,9 @@ struct smb_version_operations {
 	/* setup request: allocate mid, sign message */
 	int (*setup_request)(struct cifs_ses *, struct kvec *, unsigned int,
 			     struct mid_q_entry **);
+	/* setup async request: allocate mid, sign message */
+	int (*setup_async_request)(struct TCP_Server_Info *, struct kvec *,
+				   unsigned int, struct mid_q_entry **);
 	/* check response: verify signature, map error */
 	int (*check_receive)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     bool);

commit 9224dfc2f92f4faff7b3d9e169255278129b47e8
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Sun May 27 20:39:52 2012 +0400

    CIFS: Move building path to root to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2b1234599e72..340dce0ed07b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -164,6 +164,7 @@ struct cifs_ses;
 struct cifs_tcon;
 struct dfs_info3_param;
 struct cifs_fattr;
+struct smb_vol;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -227,6 +228,9 @@ struct smb_version_operations {
 	int (*get_srv_inum)(const unsigned int, struct cifs_tcon *,
 			    struct cifs_sb_info *, const char *,
 			    u64 *uniqueid, FILE_ALL_INFO *);
+	/* build a full path to the root of the mount */
+	char * (*build_path_to_root)(struct smb_vol *, struct cifs_sb_info *,
+				     struct cifs_tcon *);
 };
 
 struct smb_version_values {
@@ -803,6 +807,15 @@ convert_delimiter(char *path, char delim)
 	}
 }
 
+static inline char *
+build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,
+		   struct cifs_tcon *tcon)
+{
+	if (!vol->ops->build_path_to_root)
+		return NULL;
+	return vol->ops->build_path_to_root(vol, cifs_sb, tcon);
+}
+
 #ifdef CONFIG_CIFS_STATS
 #define cifs_stats_inc atomic_inc
 

commit 1208ef1f76540b621f80e6130c4fb7bed8ece360
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Sun May 27 17:34:43 2012 +0400

    CIFS: Move query inode info code to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f711d666e3db..2b1234599e72 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -163,6 +163,7 @@ struct cifsFileInfo;
 struct cifs_ses;
 struct cifs_tcon;
 struct dfs_info3_param;
+struct cifs_fattr;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -218,6 +219,14 @@ struct smb_version_operations {
 	/* check if a path is accessible or not */
 	int (*is_path_accessible)(const unsigned int, struct cifs_tcon *,
 				  struct cifs_sb_info *, const char *);
+	/* query path data from the server */
+	int (*query_path_info)(const unsigned int, struct cifs_tcon *,
+			       struct cifs_sb_info *, const char *,
+			       FILE_ALL_INFO *, bool *);
+	/* get server index number */
+	int (*get_srv_inum)(const unsigned int, struct cifs_tcon *,
+			    struct cifs_sb_info *, const char *,
+			    u64 *uniqueid, FILE_ALL_INFO *);
 };
 
 struct smb_version_values {

commit 68889f269b16a11866f4ec71e8177bdd0c184a3f
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri May 25 14:40:22 2012 +0400

    CIFS: Move is_path_accessible to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index acfa68569f3d..f711d666e3db 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -215,6 +215,9 @@ struct smb_version_operations {
 			     unsigned int *, const struct nls_table *, int);
 	/* informational QFS call */
 	void (*qfs_tcon)(const unsigned int, struct cifs_tcon *);
+	/* check if a path is accessible or not */
+	int (*is_path_accessible)(const unsigned int, struct cifs_tcon *,
+				  struct cifs_sb_info *, const char *);
 };
 
 struct smb_version_values {

commit af4281dc22f1eb8a9503b53330ca02f57db68b25
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Sun May 27 20:48:35 2012 +0400

    CIFS: Move informational tcon calls to ops struct
    
    and rename variables in cifs_mount.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2d80d82f41d0..acfa68569f3d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -213,6 +213,8 @@ struct smb_version_operations {
 	int (*get_dfs_refer)(const unsigned int, struct cifs_ses *,
 			     const char *, struct dfs_info3_param **,
 			     unsigned int *, const struct nls_table *, int);
+	/* informational QFS call */
+	void (*qfs_tcon)(const unsigned int, struct cifs_tcon *);
 };
 
 struct smb_version_values {

commit b669f33ca61738171aecc5ae90d776d91b122eb8
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Sun May 27 20:21:53 2012 +0400

    CIFS: Move getting dfs referalls to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ef4e0a0bc826..2d80d82f41d0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -162,6 +162,7 @@ struct TCP_Server_Info;
 struct cifsFileInfo;
 struct cifs_ses;
 struct cifs_tcon;
+struct dfs_info3_param;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -208,6 +209,10 @@ struct smb_version_operations {
 			    struct cifs_tcon *, const struct nls_table *);
 	/* close tree connecion */
 	int (*tree_disconnect)(const unsigned int, struct cifs_tcon *);
+	/* get DFS referrals */
+	int (*get_dfs_refer)(const unsigned int, struct cifs_ses *,
+			     const char *, struct dfs_info3_param **,
+			     unsigned int *, const struct nls_table *, int);
 };
 
 struct smb_version_values {

commit faaf946a7d5b79194358437150f34ab4c66bfe21
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Dec 27 16:04:00 2011 +0400

    CIFS: Add tree connect/disconnect capability for SMB2
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0d78bc410cb3..ef4e0a0bc826 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -528,7 +528,7 @@ struct cifs_tcon {
 	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
 	char *password;		/* for share-level security */
-	__u16 tid;		/* The 2 byte tree id */
+	__u32 tid;		/* The 4 byte tree id */
 	__u16 Flags;		/* optional support bits */
 	enum statusEnum tidStatus;
 #ifdef CONFIG_CIFS_STATS
@@ -584,6 +584,15 @@ struct cifs_tcon {
 	bool local_lease:1; /* check leases (only) on local system not remote */
 	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
 	bool need_reconnect:1; /* connection reset, tid now invalid */
+#ifdef CONFIG_CIFS_SMB2
+	bool print:1;		/* set if connection to printer share */
+	bool bad_network_name:1; /* set if ret status STATUS_BAD_NETWORK_NAME */
+	__u32 capabilities;
+	__u32 share_flags;
+	__u32 maximal_access;
+	__u32 vol_serial_number;
+	__le64 vol_create_time;
+#endif /* CONFIG_CIFS_SMB2 */
 #ifdef CONFIG_CIFS_FSCACHE
 	u64 resource_id;		/* server resource id */
 	struct fscache_cookie *fscache;	/* cookie for share */

commit 5478f9ba9a34d660eb3227dcd16314689c51f946
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Dec 27 16:22:00 2011 +0400

    CIFS: Add session setup/logoff capability for SMB2
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2d48f880b130..0d78bc410cb3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -504,6 +504,9 @@ struct cifs_ses {
 	struct session_key auth_key;
 	struct ntlmssp_auth *ntlmssp; /* ciphertext, flags, server challenge */
 	bool need_reconnect:1; /* connection reset, uid now invalid */
+#ifdef CONFIG_CIFS_SMB2
+	__u16 session_flags;
+#endif /* CONFIG_CIFS_SMB2 */
 };
 /* no more than one of the following three session flags may be set */
 #define CIFS_SES_NT4 1

commit ec2e4523fdba88317e06d0c7a88af3a0860447fc
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Dec 27 16:12:43 2011 +0400

    CIFS: Add capability to send SMB2 negotiate message
    
    and add negotiate request type to let set_credits know that
    we are only on negotiate stage and no need to make a decision
    about disabling echos and oplocks.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 480b6385a9b6..2d48f880b130 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -313,6 +313,12 @@ get_rfc1002_length(void *buf)
 	return be32_to_cpu(*((__be32 *)buf));
 }
 
+static inline void
+inc_rfc1001_len(void *buf, int count)
+{
+	be32_add_cpu((__be32 *)buf, count);
+}
+
 struct TCP_Server_Info {
 	struct list_head tcp_ses_list;
 	struct list_head smb_ses_list;
@@ -393,6 +399,10 @@ struct TCP_Server_Info {
 	atomic_t in_send; /* requests trying to send */
 	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
 #endif
+#ifdef CONFIG_CIFS_SMB2
+	unsigned int	max_read;
+	unsigned int	max_write;
+#endif /* CONFIG_CIFS_SMB2 */
 };
 
 static inline unsigned int
@@ -986,7 +996,8 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 /* Type of request operation */
 #define   CIFS_ECHO_OP      0x080    /* echo request */
 #define   CIFS_OBREAK_OP   0x0100    /* oplock break request */
-#define   CIFS_OP_MASK     0x0180    /* mask request type */
+#define   CIFS_NEG_OP      0x0200    /* negotiate request */
+#define   CIFS_OP_MASK     0x0380    /* mask request type */
 
 /* Security Flags: indicate type of session setup needed */
 #define   CIFSSEC_MAY_SIGN	0x00001

commit 28ea5290d78a7fc87a4b4f7cedcaa662f5b8d977
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed May 23 16:18:00 2012 +0400

    CIFS: Add SMB2 credits support
    
    For SMB2 protocol we can add more than one credit for one received
    request: it depends on CreditRequest field in SMB2 response header.
    Also we divide all requests by type: echoes, oplocks and others.
    Each type uses its own slot pull.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3575f0f832b1..480b6385a9b6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -343,6 +343,11 @@ struct TCP_Server_Info {
 	char server_GUID[16];
 	__u16 sec_mode;
 	bool session_estab; /* mark when very first sess is established */
+#ifdef CONFIG_CIFS_SMB2
+	int echo_credits;  /* echo reserved slots */
+	int oplock_credits;  /* oplock break reserved slots */
+	bool echoes:1; /* enable echoes */
+#endif
 	u16 dialect; /* dialect index that server chose */
 	enum securityEnum secType;
 	bool oplocks:1; /* enable oplocks */

commit 2dc7e1c03316940dec899fa3206a595de000e99b
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Mon Dec 26 22:53:34 2011 +0400

    CIFS: Make transport routines work with SMB2
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6d18962c9903..3575f0f832b1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -22,6 +22,7 @@
 #include <linux/in.h>
 #include <linux/in6.h>
 #include <linux/slab.h>
+#include <linux/mempool.h>
 #include <linux/workqueue.h>
 #include "cifs_fs_sb.h"
 #include "cifsacl.h"
@@ -218,6 +219,7 @@ struct smb_version_values {
 	size_t		header_size;
 	size_t		max_header_size;
 	size_t		read_rsp_size;
+	__le16		lock_cmd;
 };
 
 #define HEADER_SIZE(server) (server->vals->header_size)
@@ -812,6 +814,7 @@ typedef void (mid_callback_t)(struct mid_q_entry *mid);
 /* one of these for every pending CIFS request to the server */
 struct mid_q_entry {
 	struct list_head qhead;	/* mids waiting on reply from this server */
+	struct TCP_Server_Info *server;	/* server corresponding to this mid */
 	__u64 mid;		/* multiplex id */
 	__u32 pid;		/* process id */
 	__u32 sequence_number;  /* for CIFS signing */
@@ -1153,6 +1156,8 @@ void cifs_oplock_break(struct work_struct *work);
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;
 
+extern mempool_t *cifs_mid_poolp;
+
 /* Operations for different SMB versions */
 #define SMB1_VERSION_STRING	"1.0"
 extern struct smb_version_operations smb1_operations;

commit 2e6e02ab6ddbd539fd7e092973daf057adbd53dc
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri May 25 11:11:39 2012 +0400

    CIFS: Move protocol specific tcon/tdis code to ops struct
    
    and rename variables around the code changes.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a6eb9befdb2d..6d18962c9903 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -160,6 +160,7 @@ struct mid_q_entry;
 struct TCP_Server_Info;
 struct cifsFileInfo;
 struct cifs_ses;
+struct cifs_tcon;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
@@ -201,6 +202,11 @@ struct smb_version_operations {
 			  const struct nls_table *);
 	/* close smb session */
 	int (*logoff)(const unsigned int, struct cifs_ses *);
+	/* connect to a server share */
+	int (*tree_connect)(const unsigned int, struct cifs_ses *, const char *,
+			    struct cifs_tcon *, const struct nls_table *);
+	/* close tree connecion */
+	int (*tree_disconnect)(const unsigned int, struct cifs_tcon *);
 };
 
 struct smb_version_values {

commit 58c45c58a1cbc8d2e1d07839820bf745fb3e7f41
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri May 25 10:54:49 2012 +0400

    CIFS: Move protocol specific session setup/logoff code to ops struct
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8a4150573cf8..a6eb9befdb2d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -196,6 +196,11 @@ struct smb_version_operations {
 	bool (*need_neg)(struct TCP_Server_Info *);
 	/* negotiate to the server */
 	int (*negotiate)(const unsigned int, struct cifs_ses *);
+	/* setup smb sessionn */
+	int (*sess_setup)(const unsigned int, struct cifs_ses *,
+			  const struct nls_table *);
+	/* close smb session */
+	int (*logoff)(const unsigned int, struct cifs_ses *);
 };
 
 struct smb_version_values {

commit 286170aa241819f39d9d1d5d9f2434cfb8519506
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri May 25 10:43:58 2012 +0400

    CIFS: Move protocol specific negotiate code to ops struct
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 844b77c2bc9c..8a4150573cf8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -192,6 +192,10 @@ struct smb_version_operations {
 	/* process transaction2 response */
 	bool (*check_trans2)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     char *, int);
+	/* check if we need to negotiate */
+	bool (*need_neg)(struct TCP_Server_Info *);
+	/* negotiate to the server */
+	int (*negotiate)(const unsigned int, struct cifs_ses *);
 };
 
 struct smb_version_values {
@@ -324,7 +328,7 @@ struct TCP_Server_Info {
 	struct mutex srv_mutex;
 	struct task_struct *tsk;
 	char server_GUID[16];
-	char sec_mode;
+	__u16 sec_mode;
 	bool session_estab; /* mark when very first sess is established */
 	u16 dialect; /* dialect index that server chose */
 	enum securityEnum secType;
@@ -459,7 +463,7 @@ struct cifs_ses {
 	char *serverOS;		/* name of operating system underlying server */
 	char *serverNOS;	/* name of network operating system of server */
 	char *serverDomain;	/* security realm of server */
-	int Suid;		/* remote smb uid  */
+	__u64 Suid;		/* remote smb uid  */
 	uid_t linux_uid;        /* overriding owner of files on the mount */
 	uid_t cred_uid;		/* owner of credentials */
 	int capabilities;

commit a891f0f895f4a760fdb99636fab05e60597b8224
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed May 23 16:14:34 2012 +0400

    CIFS: Extend credit mechanism to process request type
    
    Split all requests to echos, oplocks and others - each group uses
    its own credit slot. This is indicated by new flags
    
    CIFS_ECHO_OP and CIFS_OBREAK_OP
    
    that are not used now for CIFS. This change is required to support
    SMB2 protocol because of different processing of these commands.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2aac4e5fb334..844b77c2bc9c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -171,9 +171,11 @@ struct smb_version_operations {
 	/* check response: verify signature, map error */
 	int (*check_receive)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     bool);
-	void (*add_credits)(struct TCP_Server_Info *, const unsigned int);
+	void (*add_credits)(struct TCP_Server_Info *, const unsigned int,
+			    const int);
 	void (*set_credits)(struct TCP_Server_Info *, const int);
-	int * (*get_credits_field)(struct TCP_Server_Info *);
+	int * (*get_credits_field)(struct TCP_Server_Info *, const int);
+	unsigned int (*get_credits)(struct mid_q_entry *);
 	__u64 (*get_next_mid)(struct TCP_Server_Info *);
 	/* data offset from read response message */
 	unsigned int (*read_data_offset)(char *);
@@ -392,9 +394,10 @@ has_credits(struct TCP_Server_Info *server, int *credits)
 }
 
 static inline void
-add_credits(struct TCP_Server_Info *server, const unsigned int add)
+add_credits(struct TCP_Server_Info *server, const unsigned int add,
+	    const int optype)
 {
-	server->ops->add_credits(server, add);
+	server->ops->add_credits(server, add, optype);
 }
 
 static inline void
@@ -957,6 +960,11 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 #define   CIFS_LARGE_BUF_OP 0x020    /* large request buffer */
 #define   CIFS_NO_RESP      0x040    /* no response buffer required */
 
+/* Type of request operation */
+#define   CIFS_ECHO_OP      0x080    /* echo request */
+#define   CIFS_OBREAK_OP   0x0100    /* oplock break request */
+#define   CIFS_OP_MASK     0x0180    /* mask request type */
+
 /* Security Flags: indicate type of session setup needed */
 #define   CIFSSEC_MAY_SIGN	0x00001
 #define   CIFSSEC_MAY_NTLM	0x00002

commit 316cf94a910f6f93d43cc574359d163ccae098a3
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed May 23 14:31:03 2012 +0400

    CIFS: Move trans2 processing to ops struct
    
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6df0cbe1cbc9..2aac4e5fb334 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -187,6 +187,9 @@ struct smb_version_operations {
 	/* verify the message */
 	int (*check_message)(char *, unsigned int);
 	bool (*is_oplock_break)(char *, struct TCP_Server_Info *);
+	/* process transaction2 response */
+	bool (*check_trans2)(struct mid_q_entry *, struct TCP_Server_Info *,
+			     char *, int);
 };
 
 struct smb_version_values {

commit 88257360605f9362dc4d79326c268dd334f61c90
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed May 23 14:01:59 2012 +0400

    CIFS: Move get_next_mid to ops struct
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 20350a93ed99..6df0cbe1cbc9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -174,6 +174,7 @@ struct smb_version_operations {
 	void (*add_credits)(struct TCP_Server_Info *, const unsigned int);
 	void (*set_credits)(struct TCP_Server_Info *, const int);
 	int * (*get_credits_field)(struct TCP_Server_Info *);
+	__u64 (*get_next_mid)(struct TCP_Server_Info *);
 	/* data offset from read response message */
 	unsigned int (*read_data_offset)(char *);
 	/* data length from read response message */
@@ -399,6 +400,12 @@ set_credits(struct TCP_Server_Info *server, const int val)
 	server->ops->set_credits(server, val);
 }
 
+static inline __u64
+get_next_mid(struct TCP_Server_Info *server)
+{
+	return server->ops->get_next_mid(server);
+}
+
 /*
  * Macros to allow the TCP_Server_Info->net field and related code to drop out
  * when CONFIG_NET_NS isn't set.

commit 2c0c2a08bed7a3b791f88d09d16ace56acb3dd98
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Mon May 21 09:20:12 2012 -0500

    cifs: fix oops while traversing open file list (try #4)
    
    While traversing the linked list of open file handles, if the identfied
    file handle is invalid, a reopen is attempted and if it fails, we
    resume traversing where we stopped and cifs can oops while accessing
    invalid next element, for list might have changed.
    
    So mark the invalid file handle and attempt reopen if no
    valid file handle is found in rest of the list.
    If reopen fails, move the invalid file handle to the end of the list
    and start traversing the list again from the begining.
    Repeat this four times before giving up and returning an error if
    file reopen keeps failing.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c0a027ec63c8..20350a93ed99 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -43,6 +43,7 @@
 
 #define CIFS_MIN_RCV_POOL 4
 
+#define MAX_REOPEN_ATT	5 /* these many maximum attempts to reopen a file */
 /*
  * default attribute cache timeout (jiffies)
  */

commit 1080ef758fb87f286b25277d8373e680a9e73363
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Feb 24 18:07:19 2011 +0000

    CIFS: Introduce SMB2 mounts as vers=2.1
    
    As with Linux nfs client, which uses "nfsvers=" or "vers=" to
    indicate which protocol to use for mount, specifying
    
    "vers=2.1"
    
    will force an SMB2 mount. When vers is not specified CIFS is used
    
    "vers=1"
    
    We can eventually autonegotiate down from SMB2 to CIFS
    when SMB2 is stable enough to make it the default, but this
    is for the future. At that time we could also implement a
    "maxprotocol" mount option as smbclient and Samba have today,
    but that would be premature until SMB2 is stable.
    
    Intially the SMB2 Kconfig option will depend on "BROKEN"
    until the merge is complete, and then be "EXPERIMENTAL"
    When it is no longer experimental we can consider changing
    the default protocol to attempt first.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2396456c4edc..c0a027ec63c8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -152,6 +152,7 @@ struct cifs_cred {
 
 enum smb_version {
 	Smb_1 = 1,
+	Smb_21,
 };
 
 struct mid_q_entry;
@@ -1122,4 +1123,7 @@ extern struct workqueue_struct *cifsiod_wq;
 #define SMB1_VERSION_STRING	"1.0"
 extern struct smb_version_operations smb1_operations;
 extern struct smb_version_values smb1_values;
+#define SMB21_VERSION_STRING	"2.1"
+extern struct smb_version_operations smb21_operations;
+extern struct smb_version_values smb21_values;
 #endif	/* _CIFS_GLOB_H */

commit 452757897a311b939ae202744754ffd9ce6704d8
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 17 17:53:29 2012 +0400

    CIFS: Move add/set_credits and get_credits_field to ops structure
    
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1001924f594a..2396456c4edc 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -169,6 +169,9 @@ struct smb_version_operations {
 	/* check response: verify signature, map error */
 	int (*check_receive)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     bool);
+	void (*add_credits)(struct TCP_Server_Info *, const unsigned int);
+	void (*set_credits)(struct TCP_Server_Info *, const int);
+	int * (*get_credits_field)(struct TCP_Server_Info *);
 	/* data offset from read response message */
 	unsigned int (*read_data_offset)(char *);
 	/* data length from read response message */
@@ -372,16 +375,6 @@ in_flight(struct TCP_Server_Info *server)
 	return num;
 }
 
-static inline int*
-get_credits_field(struct TCP_Server_Info *server)
-{
-	/*
-	 * This will change to switch statement when we reserve slots for echos
-	 * and oplock breaks.
-	 */
-	return &server->credits;
-}
-
 static inline bool
 has_credits(struct TCP_Server_Info *server, int *credits)
 {
@@ -392,6 +385,18 @@ has_credits(struct TCP_Server_Info *server, int *credits)
 	return num > 0;
 }
 
+static inline void
+add_credits(struct TCP_Server_Info *server, const unsigned int add)
+{
+	server->ops->add_credits(server, add);
+}
+
+static inline void
+set_credits(struct TCP_Server_Info *server, const int val)
+{
+	server->ops->set_credits(server, val);
+}
+
 /*
  * Macros to allow the TCP_Server_Info->net field and related code to drop out
  * when CONFIG_NET_NS isn't set.

commit 8aa26f3ed80ddbaf78804b6481fcfdbd447caa1c
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 17 13:25:35 2012 +0400

    CIFS: Move protocol specific demultiplex thread calls to ops struct
    
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 825140170b1e..1001924f594a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -175,6 +175,12 @@ struct smb_version_operations {
 	unsigned int (*read_data_length)(char *);
 	/* map smb to linux error */
 	int (*map_error)(char *, bool);
+	/* find mid corresponding to the response message */
+	struct mid_q_entry * (*find_mid)(struct TCP_Server_Info *, char *);
+	void (*dump_detail)(void *);
+	/* verify the message */
+	int (*check_message)(char *, unsigned int);
+	bool (*is_oplock_break)(char *, struct TCP_Server_Info *);
 };
 
 struct smb_version_values {

commit eb37871118abfc30629ee2bef11013eddb42c756
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 17 13:02:51 2012 +0400

    CIFS: Move protocol specific part from cifs_readv_receive to ops struct
    
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9ee832d29ec7..825140170b1e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -169,6 +169,12 @@ struct smb_version_operations {
 	/* check response: verify signature, map error */
 	int (*check_receive)(struct mid_q_entry *, struct TCP_Server_Info *,
 			     bool);
+	/* data offset from read response message */
+	unsigned int (*read_data_offset)(char *);
+	/* data length from read response message */
+	unsigned int (*read_data_length)(char *);
+	/* map smb to linux error */
+	int (*map_error)(char *, bool);
 };
 
 struct smb_version_values {
@@ -179,6 +185,7 @@ struct smb_version_values {
 	__u32		unlock_lock_type;
 	size_t		header_size;
 	size_t		max_header_size;
+	size_t		read_rsp_size;
 };
 
 #define HEADER_SIZE(server) (server->vals->header_size)

commit 1887f60103aaeeeb7a3fbf3b366d626043873164
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 17 12:45:31 2012 +0400

    CIFS: Move header_size/max_header_size to ops structure
    
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5b108382902a..9ee832d29ec7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -177,8 +177,13 @@ struct smb_version_values {
 	__u32		exclusive_lock_type;
 	__u32		shared_lock_type;
 	__u32		unlock_lock_type;
+	size_t		header_size;
+	size_t		max_header_size;
 };
 
+#define HEADER_SIZE(server) (server->vals->header_size)
+#define MAX_HEADER_SIZE(server) (server->vals->max_header_size)
+
 struct smb_vol {
 	char *username;
 	char *password;
@@ -374,18 +379,6 @@ has_credits(struct TCP_Server_Info *server, int *credits)
 	return num > 0;
 }
 
-static inline size_t
-header_size(void)
-{
-	return sizeof(struct smb_hdr);
-}
-
-static inline size_t
-max_header_size(void)
-{
-	return MAX_CIFS_HDR_SIZE;
-}
-
 /*
  * Macros to allow the TCP_Server_Info->net field and related code to drop out
  * when CONFIG_NET_NS isn't set.

commit 082d0642c61fc309ca7f6133968ba1264193dcc1
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 17 12:18:21 2012 +0400

    CIFS: Move protocol specific part from SendReceive2 to ops struct
    
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b6e97f8586d2..5b108382902a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -157,11 +157,18 @@ enum smb_version {
 struct mid_q_entry;
 struct TCP_Server_Info;
 struct cifsFileInfo;
+struct cifs_ses;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
 			   struct mid_q_entry *);
 	bool (*compare_fids)(struct cifsFileInfo *, struct cifsFileInfo *);
+	/* setup request: allocate mid, sign message */
+	int (*setup_request)(struct cifs_ses *, struct kvec *, unsigned int,
+			     struct mid_q_entry **);
+	/* check response: verify signature, map error */
+	int (*check_receive)(struct mid_q_entry *, struct TCP_Server_Info *,
+			     bool);
 };
 
 struct smb_version_values {

commit 55157dfbb566e23e3c76489cb028fc82bd985ea1
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Feb 28 14:04:17 2012 +0300

    CIFS: Separate protocol specific part from getlk
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6943448c57e2..b6e97f8586d2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -156,10 +156,12 @@ enum smb_version {
 
 struct mid_q_entry;
 struct TCP_Server_Info;
+struct cifsFileInfo;
 
 struct smb_version_operations {
 	int (*send_cancel)(struct TCP_Server_Info *, void *,
 			   struct mid_q_entry *);
+	bool (*compare_fids)(struct cifsFileInfo *, struct cifsFileInfo *);
 };
 
 struct smb_version_values {

commit 106dc538abac88e804c63b7fe21ffb09cffaefc7
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Feb 28 14:23:34 2012 +0300

    CIFS: Separate protocol specific lock type handling
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0e06de16f34e..6943448c57e2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -164,6 +164,10 @@ struct smb_version_operations {
 
 struct smb_version_values {
 	char		*version_string;
+	__u32		large_lock_type;
+	__u32		exclusive_lock_type;
+	__u32		shared_lock_type;
+	__u32		unlock_lock_type;
 };
 
 struct smb_vol {

commit 04a6aa8acfac51385ec3e72fac1227e15db78ed9
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Feb 28 14:16:55 2012 +0300

    CIFS: Convert lock type to 32 bit variable
    
    to handle SMB2 lock type field further.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 03d24a5c9774..0e06de16f34e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -567,7 +567,7 @@ struct cifsLockInfo {
 	__u64 offset;
 	__u64 length;
 	__u32 pid;
-	__u8 type;
+	__u32 type;
 };
 
 /*

commit fbd35acadd728eac5d94f360c7cd8cbe12a0379f
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Feb 24 15:41:06 2012 +0300

    CIFS: Move locks to cifsFileInfo structure
    
    CIFS brlock cache can be used by several file handles if we have a
    write-caching lease on the file that is supported by SMB2 protocol.
    Prepate the code to handle this situation correctly by sorting brlocks
    by a fid to easily push them in portions when lease break comes.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c41bf6d166e3..03d24a5c9774 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -568,7 +568,6 @@ struct cifsLockInfo {
 	__u64 length;
 	__u32 pid;
 	__u8 type;
-	__u16 netfid;
 };
 
 /*
@@ -593,6 +592,10 @@ struct cifs_search_info {
 struct cifsFileInfo {
 	struct list_head tlist;	/* pointer to next fid owned by tcon */
 	struct list_head flist;	/* next fid (file instance) for this inode */
+	struct list_head llist;	/*
+				 * brlocks held by this fid, protected by
+				 * lock_mutex from cifsInodeInfo structure
+				 */
 	unsigned int uid;	/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
 	__u16 netfid;		/* file id from remote */
@@ -635,9 +638,12 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
  */
 
 struct cifsInodeInfo {
-	struct list_head llist;		/* brlocks for this inode */
 	bool can_cache_brlcks;
-	struct mutex lock_mutex;	/* protect two fields above */
+	struct mutex lock_mutex;	/*
+					 * protect the field above and llist
+					 * from every cifsFileInfo structure
+					 * from openFileList
+					 */
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */

commit 121b046af54437b084aa0e4be967ae5aed7528b5
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue May 15 12:21:10 2012 -0400

    cifs: convert send_nt_cancel into a version specific op
    
    For SMB2, this should be a no-op. Obviously if we wanted to do something
    for the SMB2 case, we could also define an operation here for it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 812e22ab0a49..c41bf6d166e3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -154,7 +154,12 @@ enum smb_version {
 	Smb_1 = 1,
 };
 
+struct mid_q_entry;
+struct TCP_Server_Info;
+
 struct smb_version_operations {
+	int (*send_cancel)(struct TCP_Server_Info *, void *,
+			   struct mid_q_entry *);
 };
 
 struct smb_version_values {
@@ -718,7 +723,6 @@ static inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,
 
 #endif
 
-struct mid_q_entry;
 
 /*
  * This is the prototype for the mid receive function. This function is for

commit 23db65f511e6ee98ad767833f2ec58b0568ba32b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue May 15 12:20:51 2012 -0400

    cifs: add a smb_version_operations/values structures and a smb_version enum
    
    We need a way to dispatch different operations for different versions.
    Behold the smb_version_operations/values structures. For now, those
    structures just hold the version enum value and nothing uses them.
    Eventually, we'll expand them to cover other operations/values as we
    change the callers to dispatch from here.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a867d9923d7d..812e22ab0a49 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -150,6 +150,17 @@ struct cifs_cred {
  *****************************************************************
  */
 
+enum smb_version {
+	Smb_1 = 1,
+};
+
+struct smb_version_operations {
+};
+
+struct smb_version_values {
+	char		*version_string;
+};
+
 struct smb_vol {
 	char *username;
 	char *password;
@@ -205,6 +216,8 @@ struct smb_vol {
 	bool sockopt_tcp_nodelay:1;
 	unsigned short int port;
 	unsigned long actimeo; /* attribute cache timeout (jiffies) */
+	struct smb_version_operations *ops;
+	struct smb_version_values *vals;
 	char *prepath;
 	struct sockaddr_storage srcaddr; /* allow binding to a local IP */
 	struct nls_table *local_nls;
@@ -242,6 +255,8 @@ struct TCP_Server_Info {
 	int srv_count; /* reference counter */
 	/* 15 character server name + 0x20 16th byte indicating type = srv */
 	char server_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
+	struct smb_version_operations	*ops;
+	struct smb_version_values	*vals;
 	enum statusEnum tcpStatus; /* what we think the status is */
 	char *hostname; /* hostname portion of UNC string */
 	struct socket *ssocket;
@@ -1069,4 +1084,8 @@ void cifs_oplock_break(struct work_struct *work);
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;
 
+/* Operations for different SMB versions */
+#define SMB1_VERSION_STRING	"1.0"
+extern struct smb_version_operations smb1_operations;
+extern struct smb_version_values smb1_values;
 #endif	/* _CIFS_GLOB_H */

commit 5e500ed125f3b153aa3f228657723189e9f4c82e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed May 16 07:13:17 2012 -0400

    cifs: remove legacy MultiuserMount option
    
    We've now warned about this for two releases. Remove it for 3.5.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4ff6313f0a91..a867d9923d7d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1042,12 +1042,7 @@ GLOBAL_EXTERN atomic_t smBufAllocCount;
 GLOBAL_EXTERN atomic_t midCount;
 
 /* Misc globals */
-GLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions
-				to be established on existing mount if we
-				have the uid/password or Kerberos credential
-				or equivalent for current user */
-/* enable or disable oplocks */
-GLOBAL_EXTERN bool enable_oplocks;
+GLOBAL_EXTERN bool enable_oplocks; /* enable or disable oplocks */
 GLOBAL_EXTERN unsigned int lookupCacheEnabled;
 GLOBAL_EXTERN unsigned int global_secflags;	/* if on, session setup sent
 				with more secure ntlmssp2 challenge/resp */

commit 597b027f694481ffeebcffe634c24b807198d46c
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Mar 23 14:40:56 2012 -0400

    cifs: call cifs_update_eof with i_lock held
    
    cifs_update_eof has the potential to be racy if multiple threads are
    trying to modify it at the same time. Protect modifications of the
    server_eof value with the inode->i_lock.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d7e39b0de5b0..4ff6313f0a91 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -626,7 +626,7 @@ struct cifsInodeInfo {
 	bool delete_pending;		/* DELETE_ON_CLOSE is set */
 	bool invalid_mapping;		/* pagecache is invalid */
 	unsigned long time;		/* jiffies of last update of inode */
-	u64  server_eof;		/* current file size on server */
+	u64  server_eof;		/* current file size on server -- protected by i_lock */
 	u64  uniqueid;			/* server inode number */
 	u64  createtime;		/* creation time on server */
 #ifdef CONFIG_CIFS_FSCACHE

commit 35ebb4155f2f9d5580679d368aea81a5933db481
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Mar 23 14:40:56 2012 -0400

    cifs: make cifsFileInfo_get return the cifsFileInfo pointer
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 79eba5a15e80..d7e39b0de5b0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -601,9 +601,11 @@ struct cifs_io_parms {
  * Take a reference on the file private data. Must be called with
  * cifs_file_list_lock held.
  */
-static inline void cifsFileInfo_get(struct cifsFileInfo *cifs_file)
+static inline
+struct cifsFileInfo *cifsFileInfo_get(struct cifsFileInfo *cifs_file)
 {
 	++cifs_file->count;
+	return cifs_file;
 }
 
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file);

commit da472fc847e9d8c9da69b09ce0ab975b24f9b894
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Mar 23 14:40:53 2012 -0400

    cifs: add new cifsiod_wq workqueue
    
    ...and convert existing cifs users of system_nrt_wq to use that instead.
    
    Also, make it freezable, and set WQ_MEM_RECLAIM since we use it to
    deal with write reply handling.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d5ccd467a1d1..79eba5a15e80 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1070,5 +1070,6 @@ GLOBAL_EXTERN spinlock_t gidsidlock;
 void cifs_oplock_break(struct work_struct *work);
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
+extern struct workqueue_struct *cifsiod_wq;
 
 #endif	/* _CIFS_GLOB_H */

commit 7c9421e1a9ce8d17816f480c3a5b4f2609442cd5
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Mar 23 14:28:03 2012 -0400

    CIFS: Change mid_q_entry structure fields
    
    to be protocol-unspecific and big enough to keep both CIFS
    and SMB2 values.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b213458b852a..d5ccd467a1d1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -731,8 +731,8 @@ typedef void (mid_callback_t)(struct mid_q_entry *mid);
 /* one of these for every pending CIFS request to the server */
 struct mid_q_entry {
 	struct list_head qhead;	/* mids waiting on reply from this server */
-	__u16 mid;		/* multiplex id */
-	__u16 pid;		/* process id */
+	__u64 mid;		/* multiplex id */
+	__u32 pid;		/* process id */
 	__u32 sequence_number;  /* for CIFS signing */
 	unsigned long when_alloc;  /* when mid was created */
 #ifdef CONFIG_CIFS_STATS2
@@ -743,9 +743,9 @@ struct mid_q_entry {
 	mid_callback_t *callback; /* call completion callback */
 	void *callback_data;	  /* general purpose pointer for callback */
 	void *resp_buf;		/* pointer to received SMB header */
-	int midState;	/* wish this were enum but can not pass to wait_event */
-	__u8 command;	/* smb command code */
-	bool largeBuf:1;	/* if valid response, is pointer to large buf */
+	int mid_state;	/* wish this were enum but can not pass to wait_event */
+	__le16 command;		/* smb command code */
+	bool large_buf:1;	/* if valid response, is pointer to large buf */
 	bool multiRsp:1;	/* multiple trans2 responses for one request  */
 	bool multiEnd:1;	/* both received */
 };

commit 243d04b6e6de7fd08578fffd28b890c0200a2ca5
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Mar 23 14:28:03 2012 -0400

    CIFS: Expand CurrentMid field
    
    While in CIFS/SMB we have 16 bit mid, in SMB2 it is 64 bit.
    Convert the existing field to 64 bit and mask off higher bits
    for CIFS/SMB.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a40339826178..b213458b852a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -282,7 +282,7 @@ struct TCP_Server_Info {
 				   vcnumbers */
 	int capabilities; /* allow selective disabling of caps by smb sess */
 	int timeAdj;  /* Adjust for difference in server time zone in sec */
-	__u16 CurrentMid;         /* multiplex id - rotating counter */
+	__u64 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlm, ntlmv2 etc */
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];

commit 5ffef7bf1dd582e93b15f8cc735328a556a1d2c4
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Mar 23 14:28:03 2012 -0400

    CIFS: Separate protocol-specific code from cifs_readv_receive code
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 34a897e3d225..a40339826178 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -341,6 +341,18 @@ has_credits(struct TCP_Server_Info *server, int *credits)
 	return num > 0;
 }
 
+static inline size_t
+header_size(void)
+{
+	return sizeof(struct smb_hdr);
+}
+
+static inline size_t
+max_header_size(void)
+{
+	return MAX_CIFS_HDR_SIZE;
+}
+
 /*
  * Macros to allow the TCP_Server_Info->net field and related code to drop out
  * when CONFIG_NET_NS isn't set.

commit d4e4854fd1c85ac8ba4d6de39703e07704754b85
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Mar 23 14:28:02 2012 -0400

    CIFS: Separate protocol-specific code from demultiplex code
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c3c7d7c46220..34a897e3d225 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -730,7 +730,7 @@ struct mid_q_entry {
 	mid_receive_t *receive; /* call receive callback */
 	mid_callback_t *callback; /* call completion callback */
 	void *callback_data;	  /* general purpose pointer for callback */
-	struct smb_hdr *resp_buf;	/* pointer to received SMB header */
+	void *resp_buf;		/* pointer to received SMB header */
 	int midState;	/* wish this were enum but can not pass to wait_event */
 	__u8 command;	/* smb command code */
 	bool largeBuf:1;	/* if valid response, is pointer to large buf */

commit 792af7b05b8a78def080ec757a4d4420b9fd0cc2
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Mar 23 14:28:02 2012 -0400

    CIFS: Separate protocol-specific code from transport routines
    
    that lets us use this functions for SMB2.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 339ebe3ebc0d..c3c7d7c46220 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -230,6 +230,12 @@ struct cifs_mnt_data {
 	int flags;
 };
 
+static inline unsigned int
+get_rfc1002_length(void *buf)
+{
+	return be32_to_cpu(*((__be32 *)buf));
+}
+
 struct TCP_Server_Info {
 	struct list_head tcp_ses_list;
 	struct list_head smb_ses_list;

commit 6dae51a585008535858c29b489dbf90a913d511b
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Feb 21 16:50:23 2012 +0300

    CIFS: Delete echo_retries module parm
    
    It's the essential step before respecting MaxMpxCount value during
    negotiating because we will keep only one extra slot for sending
    echo requests. If there is no response during two echo intervals -
    reconnect the tcp session.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 2309a67738bf..339ebe3ebc0d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1038,9 +1038,6 @@ GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
 GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
 GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
 
-/* reconnect after this many failed echo attempts */
-GLOBAL_EXTERN unsigned short echo_retries;
-
 #ifdef CONFIG_CIFS_ACL
 GLOBAL_EXTERN struct rb_root uidtree;
 GLOBAL_EXTERN struct rb_root gidtree;

commit bc205ed19bdb56576b291830bc3f752aef5e3923
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Mar 15 13:22:27 2012 +0300

    CIFS: Prepare credits code for a slot reservation
    
    that is essential for CIFS/SMB/SMB2 oplock breaks and SMB2 echos.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d55de9684df9..2309a67738bf 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -315,12 +315,22 @@ in_flight(struct TCP_Server_Info *server)
 	return num;
 }
 
+static inline int*
+get_credits_field(struct TCP_Server_Info *server)
+{
+	/*
+	 * This will change to switch statement when we reserve slots for echos
+	 * and oplock breaks.
+	 */
+	return &server->credits;
+}
+
 static inline bool
-has_credits(struct TCP_Server_Info *server)
+has_credits(struct TCP_Server_Info *server, int *credits)
 {
 	int num;
 	spin_lock(&server->req_lock);
-	num = server->credits;
+	num = *credits;
 	spin_unlock(&server->req_lock);
 	return num > 0;
 }

commit 2d86dbc97094ea4cfc2204fdefd7d07685496189
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Mon Feb 6 15:59:18 2012 +0400

    CIFS: Introduce credit-based flow control
    
    and send no more than credits value requests at once. For SMB/CIFS
    it's trivial: increment this value by receiving any message and
    decrement by sending one.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fb78bc903887..d55de9684df9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -250,8 +250,9 @@ struct TCP_Server_Info {
 	bool noblocksnd;		/* use blocking sendmsg */
 	bool noautotune;		/* do not autotune send buf sizes */
 	bool tcp_nodelay;
+	int credits;  /* send no more requests at once */
 	unsigned int in_flight;  /* number of requests on the wire to server */
-	spinlock_t req_lock; /* protect the value above */
+	spinlock_t req_lock;  /* protect the two values above */
 	struct mutex srv_mutex;
 	struct task_struct *tsk;
 	char server_GUID[16];
@@ -314,12 +315,14 @@ in_flight(struct TCP_Server_Info *server)
 	return num;
 }
 
-static inline void
-dec_in_flight(struct TCP_Server_Info *server)
+static inline bool
+has_credits(struct TCP_Server_Info *server)
 {
+	int num;
 	spin_lock(&server->req_lock);
-	server->in_flight--;
+	num = server->credits;
 	spin_unlock(&server->req_lock);
+	return num > 0;
 }
 
 /*

commit fc40f9cf828908e91d9af820e9300a9d42fbbd72
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Feb 17 17:09:12 2012 +0300

    CIFS: Simplify inFlight logic
    
    by making it as unsigned integer and surround access with req_lock
    from server structure.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d47d20aac670..fb78bc903887 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -250,7 +250,8 @@ struct TCP_Server_Info {
 	bool noblocksnd;		/* use blocking sendmsg */
 	bool noautotune;		/* do not autotune send buf sizes */
 	bool tcp_nodelay;
-	atomic_t inFlight;  /* number of requests on the wire to server */
+	unsigned int in_flight;  /* number of requests on the wire to server */
+	spinlock_t req_lock; /* protect the value above */
 	struct mutex srv_mutex;
 	struct task_struct *tsk;
 	char server_GUID[16];
@@ -303,6 +304,24 @@ struct TCP_Server_Info {
 #endif
 };
 
+static inline unsigned int
+in_flight(struct TCP_Server_Info *server)
+{
+	unsigned int num;
+	spin_lock(&server->req_lock);
+	num = server->in_flight;
+	spin_unlock(&server->req_lock);
+	return num;
+}
+
+static inline void
+dec_in_flight(struct TCP_Server_Info *server)
+{
+	spin_lock(&server->req_lock);
+	server->in_flight--;
+	spin_unlock(&server->req_lock);
+}
+
 /*
  * Macros to allow the TCP_Server_Info->net field and related code to drop out
  * when CONFIG_NET_NS isn't set.

commit 10b9b98e41ba248a899f6175ce96ee91431b6194
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Mar 20 12:55:09 2012 +0300

    CIFS: Respect negotiated MaxMpxCount
    
    Some servers sets this value less than 50 that was hardcoded and
    we lost the connection if when we exceed this limit. Fix this by
    respecting this value - not sending more than the server allows.
    
    Cc: stable@kernel.org
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <stevef@smf-gateway.(none)>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 76e7d8b6da17..d47d20aac670 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -55,14 +55,9 @@
 
 /*
  * MAX_REQ is the maximum number of requests that WE will send
- * on one socket concurrently. It also matches the most common
- * value of max multiplex returned by servers.  We may
- * eventually want to use the negotiated value (in case
- * future servers can handle more) when we are more confident that
- * we will not have problems oveloading the socket with pending
- * write data.
+ * on one socket concurrently.
  */
-#define CIFS_MAX_REQ 50
+#define CIFS_MAX_REQ 32767
 
 #define RFC1001_NAME_LEN 15
 #define RFC1001_NAME_LEN_WITH_NULL (RFC1001_NAME_LEN + 1)
@@ -263,6 +258,7 @@ struct TCP_Server_Info {
 	bool session_estab; /* mark when very first sess is established */
 	u16 dialect; /* dialect index that server chose */
 	enum securityEnum secType;
+	bool oplocks:1; /* enable oplocks */
 	unsigned int maxReq;	/* Clients should submit no more */
 	/* than maxReq distinct unanswered SMBs to the server when using  */
 	/* multiplexed reads or writes */

commit 88a4412b798236bfdd9284d5c251d76679f944e1
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Jan 18 17:13:47 2012 -0600

    [CIFS] Fix build break with multiuser patch when LANMAN disabled
    
    CC: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ba53c1c6c6cc..76e7d8b6da17 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -879,6 +879,8 @@ require use of the stronger protocol */
 #define   CIFSSEC_MASK          0xB70B7 /* current flags supported if weak */
 #endif /* UPCALL */
 #else /* do not allow weak pw hash */
+#define   CIFSSEC_MUST_LANMAN	0
+#define   CIFSSEC_MUST_PLNTXT	0
 #ifdef CONFIG_CIFS_UPCALL
 #define   CIFSSEC_MASK          0x8F08F /* flags supported if no weak allowed */
 #else

commit 5206efd62ce49cf5c7940d81c22bc556fc843de2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 03:22:14 2011 -0400

    cifs: propagate umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8238aa13e01c..ba53c1c6c6cc 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -169,8 +169,8 @@ struct smb_vol {
 	gid_t linux_gid;
 	uid_t backupuid;
 	gid_t backupgid;
-	mode_t file_mode;
-	mode_t dir_mode;
+	umode_t file_mode;
+	umode_t dir_mode;
 	unsigned secFlg;
 	bool retry:1;
 	bool intr:1;

commit 85160e03a79e0d7f9082e61f6a784abc6f402701
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Sat Oct 22 15:33:29 2011 +0400

    CIFS: Implement caching mechanism for mandatory brlocks
    
    If we have an oplock and negotiate mandatory locking style we handle
    all brlock requests on the client.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Acked-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d153d0b89d39..8238aa13e01c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -496,6 +496,8 @@ extern struct cifs_tcon *cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb);
  */
 struct cifsLockInfo {
 	struct list_head llist;	/* pointer to next cifsLockInfo */
+	struct list_head blist; /* pointer to locks blocked on this */
+	wait_queue_head_t block_q;
 	__u64 offset;
 	__u64 length;
 	__u32 pid;

commit 44d22d846fdc7c3e688fc1ff5ae6d06d08bb5656
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 19 15:29:49 2011 -0400

    cifs: add a callback function to receive the rest of the frame
    
    In order to handle larger SMBs for readpages and other calls, we want
    to be able to read into a preallocated set of buffers. Rather than
    changing all of the existing code to preallocate buffers however, we
    instead add a receive callback function to the MID.
    
    cifsd will call this function once the mid_q_entry has been identified
    in order to receive the rest of the SMB. If the mid can't be identified
    or the receive pointer is unset, then the standard 3rd phase receive
    function will be called.
    
    Reviewed-and-Tested-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a73dd1d5e7ef..d153d0b89d39 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -656,8 +656,24 @@ static inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,
 struct mid_q_entry;
 
 /*
- * This is the prototype for the mid callback function. When creating one,
- * take special care to avoid deadlocks. Things to bear in mind:
+ * This is the prototype for the mid receive function. This function is for
+ * receiving the rest of the SMB frame, starting with the WordCount (which is
+ * just after the MID in struct smb_hdr). Note:
+ *
+ * - This will be called by cifsd, with no locks held.
+ * - The mid will still be on the pending_mid_q.
+ * - mid->resp_buf will point to the current buffer.
+ *
+ * Returns zero on a successful receive, or an error. The receive state in
+ * the TCP_Server_Info will also be updated.
+ */
+typedef int (mid_receive_t)(struct TCP_Server_Info *server,
+			    struct mid_q_entry *mid);
+
+/*
+ * This is the prototype for the mid callback function. This is called once the
+ * mid has been received off of the socket. When creating one, take special
+ * care to avoid deadlocks. Things to bear in mind:
  *
  * - it will be called by cifsd, with no locks held
  * - the mid will be removed from any lists
@@ -675,9 +691,10 @@ struct mid_q_entry {
 	unsigned long when_sent; /* time when smb send finished */
 	unsigned long when_received; /* when demux complete (taken off wire) */
 #endif
+	mid_receive_t *receive; /* call receive callback */
 	mid_callback_t *callback; /* call completion callback */
 	void *callback_data;	  /* general purpose pointer for callback */
-	struct smb_hdr *resp_buf;	/* response buffer */
+	struct smb_hdr *resp_buf;	/* pointer to received SMB header */
 	int midState;	/* wish this were enum but can not pass to wait_event */
 	__u8 command;	/* smb command code */
 	bool largeBuf:1;	/* if valid response, is pointer to large buf */

commit 2a37ef94bb153fad13cbb091aab679d7c8b9a67f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 19 15:29:23 2011 -0400

    cifs: move buffer pointers into TCP_Server_Info
    
    We have several functions that need to access these pointers. Currently
    that's done with a lot of double pointer passing. Instead, move them
    into the TCP_Server_Info and simplify the handling.
    
    Reviewed-and-Tested-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 51ed2de23070..a73dd1d5e7ef 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -291,9 +291,13 @@ struct TCP_Server_Info {
 	bool	sec_kerberosu2u;	/* supports U2U Kerberos */
 	bool	sec_kerberos;		/* supports plain Kerberos */
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
+	bool	large_buf;		/* is current buffer large? */
 	struct delayed_work	echo; /* echo ping workqueue job */
 	struct kvec *iov;	/* reusable kvec array for receives */
 	unsigned int nr_iov;	/* number of kvecs in array */
+	char	*smallbuf;	/* pointer to current "small" buffer */
+	char	*bigbuf;	/* pointer to current "big" buffer */
+	unsigned int total_read; /* total amount of data read in this pass */
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie   *fscache; /* client index cache cookie */
 #endif

commit 1041e3f9919999b22c9c2a453aa0d92cd16b76ee
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 19 15:28:27 2011 -0400

    cifs: keep a reusable kvec array for receives
    
    Having to continually allocate a new kvec array is expensive. Allocate
    one that's big enough, and only reallocate it as needed.
    
    Reviewed-and-Tested-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 55ebf39fb3fd..51ed2de23070 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -292,6 +292,8 @@ struct TCP_Server_Info {
 	bool	sec_kerberos;		/* supports plain Kerberos */
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
 	struct delayed_work	echo; /* echo ping workqueue job */
+	struct kvec *iov;	/* reusable kvec array for receives */
+	unsigned int nr_iov;	/* number of kvecs in array */
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie   *fscache; /* client index cache cookie */
 #endif

commit d59dad2be038132259ac99a2837d65a87fd90588
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Sep 22 09:53:59 2011 +0400

    CIFS: Move byte range lock list from fd to inode
    
    that let us do local lock checks before requesting to the server.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1f265ffe7e63..55ebf39fb3fd 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -494,6 +494,7 @@ struct cifsLockInfo {
 	__u64 length;
 	__u32 pid;
 	__u8 type;
+	__u16 netfid;
 };
 
 /*
@@ -526,8 +527,6 @@ struct cifsFileInfo {
 	struct dentry *dentry;
 	unsigned int f_flags;
 	struct tcon_link *tlink;
-	struct mutex lock_mutex;
-	struct list_head llist; /* list of byte range locks we have. */
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
 	int count;		/* refcount protected by cifs_file_list_lock */
@@ -560,7 +559,9 @@ void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
  */
 
 struct cifsInodeInfo {
-	struct list_head lockList;
+	struct list_head llist;		/* brlocks for this inode */
+	bool can_cache_brlcks;
+	struct mutex lock_mutex;	/* protect two fields above */
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */

commit 03776f4516bc299b3145595bdd704d40d69adc02
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Tue Aug 17 11:26:00 2010 +0400

    CIFS: Simplify byte range locking code
    
    Split cifs_lock into several functions and let CIFSSMBLock get pid
    as an argument.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3b83fe7bfe60..1f265ffe7e63 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -492,6 +492,7 @@ struct cifsLockInfo {
 	struct list_head llist;	/* pointer to next cifsLockInfo */
 	__u64 offset;
 	__u64 length;
+	__u32 pid;
 	__u8 type;
 };
 

commit 21fed0d5b763b94a7d1568c27d0cce892ab8d43e
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Tue Aug 9 14:30:48 2011 -0500

    cifs: Add data structures and functions for uid/gid to SID mapping (try #4)
    
    Add data structures and functions necessary to map a uid and gid to SID.
    These functions are very similar to the ones used to map a SID to uid and gid.
    This time, instead of storing sid to id mapping sorted on a sid value,
    id to sid is stored, sorted on an id.
    A cifs upcall sends an id (uid or gid) and expects a SID structure
    in return, if mapping was done successfully.
    
    A failed id to sid mapping to EINVAL.
    
    This patchset aims to enable chown and chgrp commands when
    cifsacl mount option is specified, especially to Windows SMB servers.
    Currently we can't do that.  So now along with chmod command,
    chown and chgrp work.
    
    Winbind is used to map id to a SID.  chown and chgrp use an upcall
    to provide an id to winbind and upcall returns with corrosponding
    SID if any exists. That SID is used to build security descriptor.
    The DACL part of a security descriptor is not changed by either
    chown or chgrp functionality.
    
    cifs client maintains a separate caches for uid to SID and
    gid to SID mapping. This is similar to the one used earlier
    to map SID to id (as part of ID mapping code).
    
    I tested it by mounting shares from a Windows (2003) server by
    authenticating as two users, one at a time, as Administrator and
    as a ordinary user.
    And then attempting to change owner of a file on the share.
    
    Depending on the permissions/privileges at the server for that file,
    chown request fails to either open a file (to change the ownership)
    or to set security descriptor.
    So it all depends on privileges on the file at the server and what
    user you are authenticated as at the server, cifs client is just a
    conduit.
    
    I compared the security descriptor during chown command to that
    what smbcacls sends when it is used with -M OWNNER: option
    and they are similar.
    
    This patchset aim to enable chown and chgrp commands when
    cifsacl mount option is specified, especially to Windows SMB servers.
    Currently we can't do that.  So now along with chmod command,
    chown and chgrp work.
    
    I tested it by mounting shares from a Windows (2003) server by
    authenticating as two users, one at a time, as Administrator and
    as a ordinary user.
    And then attempting to change owner of a file on the share.
    
    Depending on the permissions/privileges at the server for that file,
    chown request fails to either open a file (to change the ownership)
    or to set security descriptor.
    So it all depends on privileges on the file at the server and what
    user you are authenticated as at the server, cifs client is just a
    conduit.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9551437a2498..3b83fe7bfe60 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -984,10 +984,16 @@ GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
 /* reconnect after this many failed echo attempts */
 GLOBAL_EXTERN unsigned short echo_retries;
 
+#ifdef CONFIG_CIFS_ACL
 GLOBAL_EXTERN struct rb_root uidtree;
 GLOBAL_EXTERN struct rb_root gidtree;
 GLOBAL_EXTERN spinlock_t siduidlock;
 GLOBAL_EXTERN spinlock_t sidgidlock;
+GLOBAL_EXTERN struct rb_root siduidtree;
+GLOBAL_EXTERN struct rb_root sidgidtree;
+GLOBAL_EXTERN spinlock_t uidsidlock;
+GLOBAL_EXTERN spinlock_t gidsidlock;
+#endif /* CONFIG_CIFS_ACL */
 
 void cifs_oplock_break(struct work_struct *work);
 

commit 3d3ea8e64efbeb3e4289675dbbfab82333395642
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Mon Sep 26 09:56:44 2011 -0500

    cifs: Add mount options for backup intent (try #6)
    
    Add mount options backupuid and backugid.
    
    It allows an authenticated user to access files with the intent to back them
    up including their ACLs, who may not have access permission but has
    "Backup files and directories user right" on them (by virtue of being part
    of the built-in group Backup Operators.
    
    When mount options backupuid is specified, cifs client restricts the
    use of backup intents to the user whose effective user id is specified
    along with the mount option.
    
    When mount options backupgid is specified, cifs client restricts the
    use of backup intents to the users whose effective user id belongs to the
    group id specified along with the mount option.
    
    If an authenticated user is not part of the built-in group Backup Operators
    at the server, access to such files is denied, even if allowed by the client.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d734dee9d495..9551437a2498 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -167,6 +167,8 @@ struct smb_vol {
 	uid_t cred_uid;
 	uid_t linux_uid;
 	gid_t linux_gid;
+	uid_t backupuid;
+	gid_t backupgid;
 	mode_t file_mode;
 	mode_t dir_mode;
 	unsigned secFlg;
@@ -179,6 +181,8 @@ struct smb_vol {
 	bool noperm:1;
 	bool no_psx_acl:1; /* set if posix acl support should be disabled */
 	bool cifs_acl:1;
+	bool backupuid_specified; /* mount option  backupuid  is specified */
+	bool backupgid_specified; /* mount option  backupgid  is specified */
 	bool no_xattr:1;   /* set if xattr (EA) support should be disabled*/
 	bool server_ino:1; /* use inode numbers from server ie UniqueId */
 	bool direct_io:1;
@@ -219,7 +223,8 @@ struct smb_vol {
 			 CIFS_MOUNT_OVERR_GID | CIFS_MOUNT_DYNPERM | \
 			 CIFS_MOUNT_NOPOSIXBRL | CIFS_MOUNT_NOSSYNC | \
 			 CIFS_MOUNT_FSCACHE | CIFS_MOUNT_MF_SYMLINKS | \
-			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO)
+			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO | \
+			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID)
 
 #define CIFS_MS_MASK (MS_RDONLY | MS_MANDLOCK | MS_NOEXEC | MS_NOSUID | \
 		      MS_NODEV | MS_SYNCHRONOUS)

commit e75047344ea415760b2508a6fa29c0288c7b6b68
Author: Steve French <smfrench@gmail.com>
Date:   Wed Oct 12 17:47:03 2011 -0500

    add new module parameter 'enable_oplocks'
    
    Thus spake Jeff Layton:
    
    "Making that a module parm would allow you to set that parameter at boot
    time without needing to add special startup scripts. IMO, all of the
    procfile "switches" under /proc/fs/cifs should be module parms
    instead."
    
    This patch doesn't alter the default behavior (Oplocks are enabled by
    default).
    
    To disable oplocks when loading the module, use
    
       modprobe cifs enable_oplocks=0
    
    (any of '0' or 'n' or 'N' conventions can be used).
    
    To disable oplocks at runtime using the new interface, use
    
       echo 0 > /sys/module/cifs/parameters/enable_oplocks
    
    The older /proc/fs/cifs/OplockEnabled interface will be deprecated
    after two releases. A subsequent patch will add an warning message
    about this deprecation.
    
    Changes since v2:
       - make enable_oplocks a 'bool'
    
    Changes since v1:
       - eliminate the use of extra variable by renaming the old one to
         enable_oplocks and make it an 'int' type.
    
    Reported-by: Alexander Swen <alex@swen.nu>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 95dad9d14cf1..d734dee9d495 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -964,7 +964,8 @@ GLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions
 				to be established on existing mount if we
 				have the uid/password or Kerberos credential
 				or equivalent for current user */
-GLOBAL_EXTERN unsigned int oplockEnabled;
+/* enable or disable oplocks */
+GLOBAL_EXTERN bool enable_oplocks;
 GLOBAL_EXTERN unsigned int lookupCacheEnabled;
 GLOBAL_EXTERN unsigned int global_secflags;	/* if on, session setup sent
 				with more secure ntlmssp2 challenge/resp */

commit 789e66612367f9975d704c9e4990025cbbbb45ec
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Aug 9 18:44:44 2011 +0000

    [CIFS] Cleanup use of CONFIG_CIFS_STATS2 ifdef to make transport routines more readable
    
    Christoph had requested that the stats related code (in
    CONFIG_CIFS_STATS2) be moved into helpers to make code flow more
    readable.   This patch should help.   For example the following
    section from transport.c
    
                           spin_unlock(&GlobalMid_Lock);
                           atomic_inc(&ses->server->num_waiters);
                           wait_event(ses->server->request_q,
                                      atomic_read(&ses->server->inFlight)
                                        < cifs_max_pending);
                           atomic_dec(&ses->server->num_waiters);
                           spin_lock(&GlobalMid_Lock);
    
    becomes simpler (with the patch below):
                           spin_unlock(&GlobalMid_Lock);
                           cifs_num_waiters_inc(server);
                           wait_event(server->request_q,
                                      atomic_read(&server->inFlight)
                                        < cifs_max_pending);
                           cifs_num_waiters_dec(server);
                           spin_lock(&GlobalMid_Lock);
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    CC: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 38ce6d44b145..95dad9d14cf1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -291,7 +291,7 @@ struct TCP_Server_Info {
 	struct fscache_cookie   *fscache; /* client index cache cookie */
 #endif
 #ifdef CONFIG_CIFS_STATS2
-	atomic_t inSend; /* requests trying to send */
+	atomic_t in_send; /* requests trying to send */
 	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
 #endif
 };
@@ -672,12 +672,54 @@ struct mid_q_entry {
 	bool multiEnd:1;	/* both received */
 };
 
-struct oplock_q_entry {
-	struct list_head qhead;
-	struct inode *pinode;
-	struct cifs_tcon *tcon;
-	__u16 netfid;
-};
+/*	Make code in transport.c a little cleaner by moving
+	update of optional stats into function below */
+#ifdef CONFIG_CIFS_STATS2
+
+static inline void cifs_in_send_inc(struct TCP_Server_Info *server)
+{
+	atomic_inc(&server->in_send);
+}
+
+static inline void cifs_in_send_dec(struct TCP_Server_Info *server)
+{
+	atomic_dec(&server->in_send);
+}
+
+static inline void cifs_num_waiters_inc(struct TCP_Server_Info *server)
+{
+	atomic_inc(&server->num_waiters);
+}
+
+static inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)
+{
+	atomic_dec(&server->num_waiters);
+}
+
+static inline void cifs_save_when_sent(struct mid_q_entry *mid)
+{
+	mid->when_sent = jiffies;
+}
+#else
+static inline void cifs_in_send_inc(struct TCP_Server_Info *server)
+{
+}
+static inline void cifs_in_send_dec(struct TCP_Server_Info *server)
+{
+}
+
+static inline void cifs_num_waiters_inc(struct TCP_Server_Info *server)
+{
+}
+
+static inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)
+{
+}
+
+static inline void cifs_save_when_sent(struct mid_q_entry *mid)
+{
+}
+#endif
 
 /* for pending dnotify requests */
 struct dir_notify_req {

commit ad635942c869ad8fc9af270d4998c42b4e978b32
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jul 26 12:20:17 2011 -0400

    cifs: simplify refcounting for oplock breaks
    
    Currently, we take a sb->s_active reference and a cifsFileInfo reference
    when an oplock break workqueue job is queued. This is unnecessary and
    more complicated than it needs to be. Also as Al points out,
    deactivate_super has non-trivial locking implications so it's best to
    avoid that if we can.
    
    Instead, just cancel any pending oplock breaks for this filehandle
    synchronously in cifsFileInfo_put after taking it off the lists.
    That should ensure that this job doesn't outlive the structures it
    depends on.
    
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1fcf4e5b3112..38ce6d44b145 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -942,8 +942,6 @@ GLOBAL_EXTERN spinlock_t siduidlock;
 GLOBAL_EXTERN spinlock_t sidgidlock;
 
 void cifs_oplock_break(struct work_struct *work);
-void cifs_oplock_break_get(struct cifsFileInfo *cfile);
-void cifs_oplock_break_put(struct cifsFileInfo *cfile);
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
 

commit eaf35b1ea8c12edc5ba8299a8ecfe1efab85101b
Author: Christoph Hellwig <hch@infradead.org>
Date:   Sat Jul 16 15:24:37 2011 -0400

    cifs: use cifs_dirent in cifs_save_resume_key
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6255fa812c7a..1fcf4e5b3112 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -501,7 +501,7 @@ struct cifs_search_info {
 	char *ntwrk_buf_start;
 	char *srch_entries_start;
 	char *last_entry;
-	char *presume_name;
+	const char *presume_name;
 	unsigned int resume_name_len;
 	bool endOfSearch:1;
 	bool emptyDir:1;

commit 96daf2b09178d8ebde2b0d56b027de917c17dfdf
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri May 27 04:34:02 2011 +0000

    [CIFS] Rename three structures to avoid camel case
    
    secMode to sec_mode
    and
    cifsTconInfo to cifs_tcon
    and
    cifsSesInfo to cifs_ses
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 310cddabd3fd..6255fa812c7a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -254,7 +254,7 @@ struct TCP_Server_Info {
 	struct mutex srv_mutex;
 	struct task_struct *tsk;
 	char server_GUID[16];
-	char secMode;
+	char sec_mode;
 	bool session_estab; /* mark when very first sess is established */
 	u16 dialect; /* dialect index that server chose */
 	enum securityEnum secType;
@@ -329,7 +329,7 @@ static inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)
 /*
  * Session structure.  One of these for each uid session with a particular host
  */
-struct cifsSesInfo {
+struct cifs_ses {
 	struct list_head smb_ses_list;
 	struct list_head tcon_list;
 	struct mutex session_mutex;
@@ -369,11 +369,11 @@ struct cifsSesInfo {
  * there is one of these for each connection to a resource on a particular
  * session
  */
-struct cifsTconInfo {
+struct cifs_tcon {
 	struct list_head tcon_list;
 	int tc_count;
 	struct list_head openFileList;
-	struct cifsSesInfo *ses;	/* pointer to session associated with */
+	struct cifs_ses *ses;	/* pointer to session associated with */
 	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
 	char *password;		/* for share-level security */
@@ -455,12 +455,12 @@ struct tcon_link {
 #define TCON_LINK_IN_TREE	2
 	unsigned long		tl_time;
 	atomic_t		tl_count;
-	struct cifsTconInfo	*tl_tcon;
+	struct cifs_tcon	*tl_tcon;
 };
 
 extern struct tcon_link *cifs_sb_tlink(struct cifs_sb_info *cifs_sb);
 
-static inline struct cifsTconInfo *
+static inline struct cifs_tcon *
 tlink_tcon(struct tcon_link *tlink)
 {
 	return tlink->tl_tcon;
@@ -477,7 +477,7 @@ cifs_get_tlink(struct tcon_link *tlink)
 }
 
 /* This function is always expected to succeed */
-extern struct cifsTconInfo *cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb);
+extern struct cifs_tcon *cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb);
 
 /*
  * This info hangs off the cifsFileInfo structure, pointed to by llist.
@@ -535,7 +535,7 @@ struct cifs_io_parms {
 	__u32 pid;
 	__u64 offset;
 	unsigned int length;
-	struct cifsTconInfo *tcon;
+	struct cifs_tcon *tcon;
 };
 
 /*
@@ -615,7 +615,7 @@ convert_delimiter(char *path, char delim)
 #ifdef CONFIG_CIFS_STATS
 #define cifs_stats_inc atomic_inc
 
-static inline void cifs_stats_bytes_written(struct cifsTconInfo *tcon,
+static inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,
 					    unsigned int bytes)
 {
 	if (bytes) {
@@ -625,7 +625,7 @@ static inline void cifs_stats_bytes_written(struct cifsTconInfo *tcon,
 	}
 }
 
-static inline void cifs_stats_bytes_read(struct cifsTconInfo *tcon,
+static inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,
 					 unsigned int bytes)
 {
 	spin_lock(&tcon->stat_lock);
@@ -675,7 +675,7 @@ struct mid_q_entry {
 struct oplock_q_entry {
 	struct list_head qhead;
 	struct inode *pinode;
-	struct cifsTconInfo *tcon;
+	struct cifs_tcon *tcon;
 	__u16 netfid;
 };
 

commit d4ffff1fa9695c5b5c0bf337e208d8833b88ff2d
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 26 06:02:00 2011 +0000

    CIFS: Add rwpidforward mount option
    
    Add rwpidforward mount option that switches on a mode when we forward
    pid of a process who opened a file to any read and write operation.
    
    This can prevent applications like WINE from failing on read or write
    operation on a previously locked file region from the same netfd from
    another process if we use mandatory brlock style.
    
    It is actual for WINE because during a run of WINE program two processes
    work on the same netfd - share the same file struct between several VFS
    fds:
    1) WINE-server does open and lock;
    2) WINE-application does read and write.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ca0c3789206e..310cddabd3fd 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -200,6 +200,7 @@ struct smb_vol {
 	bool fsc:1;	/* enable fscache */
 	bool mfsymlinks:1; /* use Minshall+French Symlinks */
 	bool multiuser:1;
+	bool rwpidforward:1; /* pid forward for read/write operations */
 	unsigned int rsize;
 	unsigned int wsize;
 	bool sockopt_tcp_nodelay:1;

commit 25c7f41e9234f60af30e086278f1de7974f8816f
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 26 23:35:47 2011 +0400

    CIFS: Migrate to shared superblock model
    
    Add cifs_match_super to use in sget to share superblock between mounts
    that have the same //server/sharename, credentials and mount options.
    It helps us to improve performance on work with future SMB2.1 leases.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 68ec457f8476..ca0c3789206e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -210,6 +210,25 @@ struct smb_vol {
 	struct nls_table *local_nls;
 };
 
+#define CIFS_MOUNT_MASK (CIFS_MOUNT_NO_PERM | CIFS_MOUNT_SET_UID | \
+			 CIFS_MOUNT_SERVER_INUM | CIFS_MOUNT_DIRECT_IO | \
+			 CIFS_MOUNT_NO_XATTR | CIFS_MOUNT_MAP_SPECIAL_CHR | \
+			 CIFS_MOUNT_UNX_EMUL | CIFS_MOUNT_NO_BRL | \
+			 CIFS_MOUNT_CIFS_ACL | CIFS_MOUNT_OVERR_UID | \
+			 CIFS_MOUNT_OVERR_GID | CIFS_MOUNT_DYNPERM | \
+			 CIFS_MOUNT_NOPOSIXBRL | CIFS_MOUNT_NOSSYNC | \
+			 CIFS_MOUNT_FSCACHE | CIFS_MOUNT_MF_SYMLINKS | \
+			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO)
+
+#define CIFS_MS_MASK (MS_RDONLY | MS_MANDLOCK | MS_NOEXEC | MS_NOSUID | \
+		      MS_NODEV | MS_SYNCHRONOUS)
+
+struct cifs_mnt_data {
+	struct cifs_sb_info *cifs_sb;
+	struct smb_vol *vol;
+	int flags;
+};
+
 struct TCP_Server_Info {
 	struct list_head tcp_ses_list;
 	struct list_head smb_ses_list;

commit f87d39d951329cd8f462bf9007d334122c0599d0
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri May 27 03:50:55 2011 +0000

    [CIFS] Migrate from prefixpath logic
    
    Now we point superblock to a server share root and set a root dentry
    appropriately. This let us share superblock between mounts like
    //server/sharename/foo/bar and //server/sharename/foo further.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 30699d9378e9..68ec457f8476 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -155,6 +155,61 @@ struct cifs_cred {
  *****************************************************************
  */
 
+struct smb_vol {
+	char *username;
+	char *password;
+	char *domainname;
+	char *UNC;
+	char *UNCip;
+	char *iocharset;  /* local code page for mapping to and from Unicode */
+	char source_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* clnt nb name */
+	char target_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* srvr nb name */
+	uid_t cred_uid;
+	uid_t linux_uid;
+	gid_t linux_gid;
+	mode_t file_mode;
+	mode_t dir_mode;
+	unsigned secFlg;
+	bool retry:1;
+	bool intr:1;
+	bool setuids:1;
+	bool override_uid:1;
+	bool override_gid:1;
+	bool dynperm:1;
+	bool noperm:1;
+	bool no_psx_acl:1; /* set if posix acl support should be disabled */
+	bool cifs_acl:1;
+	bool no_xattr:1;   /* set if xattr (EA) support should be disabled*/
+	bool server_ino:1; /* use inode numbers from server ie UniqueId */
+	bool direct_io:1;
+	bool strict_io:1; /* strict cache behavior */
+	bool remap:1;      /* set to remap seven reserved chars in filenames */
+	bool posix_paths:1; /* unset to not ask for posix pathnames. */
+	bool no_linux_ext:1;
+	bool sfu_emul:1;
+	bool nullauth:1;   /* attempt to authenticate with null user */
+	bool nocase:1;     /* request case insensitive filenames */
+	bool nobrl:1;      /* disable sending byte range locks to srv */
+	bool mand_lock:1;  /* send mandatory not posix byte range lock reqs */
+	bool seal:1;       /* request transport encryption on share */
+	bool nodfs:1;      /* Do not request DFS, even if available */
+	bool local_lease:1; /* check leases only on local system, not remote */
+	bool noblocksnd:1;
+	bool noautotune:1;
+	bool nostrictsync:1; /* do not force expensive SMBflush on every sync */
+	bool fsc:1;	/* enable fscache */
+	bool mfsymlinks:1; /* use Minshall+French Symlinks */
+	bool multiuser:1;
+	unsigned int rsize;
+	unsigned int wsize;
+	bool sockopt_tcp_nodelay:1;
+	unsigned short int port;
+	unsigned long actimeo; /* attribute cache timeout (jiffies) */
+	char *prepath;
+	struct sockaddr_storage srcaddr; /* allow binding to a local IP */
+	struct nls_table *local_nls;
+};
+
 struct TCP_Server_Info {
 	struct list_head tcp_ses_list;
 	struct list_head smb_ses_list;
@@ -517,6 +572,26 @@ static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
 		return '\\';
 }
 
+static inline void
+convert_delimiter(char *path, char delim)
+{
+	int i;
+	char old_delim;
+
+	if (path == NULL)
+		return;
+
+	if (delim == '/')
+		old_delim = '\\';
+	else
+		old_delim = '/';
+
+	for (i = 0; path[i] != '\0'; i++) {
+		if (path[i] == old_delim)
+			path[i] = delim;
+	}
+}
+
 #ifdef CONFIG_CIFS_STATS
 #define cifs_stats_inc atomic_inc
 

commit fa2989f4473413a86890066aa3a5676a53b541e4
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 26 10:01:59 2011 +0400

    CIFS: Use pid saved from cifsFileInfo in writepages and set_file_size
    
    We need it to make them work with mandatory locking style because
    we can fail in a situation like when kernel need to flush dirty pages
    and there is a lock held by a process who opened file.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fd877c110e4c..30699d9378e9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -455,6 +455,14 @@ struct cifsFileInfo {
 	struct work_struct oplock_break; /* work for oplock breaks */
 };
 
+struct cifs_io_parms {
+	__u16 netfid;
+	__u32 pid;
+	__u64 offset;
+	unsigned int length;
+	struct cifsTconInfo *tcon;
+};
+
 /*
  * Take a reference on the file private data. Must be called with
  * cifs_file_list_lock held.

commit 3c1105df699188a70f5c17dc0795affea388bca7
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun May 22 07:09:13 2011 -0400

    cifs: don't call mid_q_entry->callback under the Global_MidLock (try #5)
    
    Minor revision to the last version of this patch -- the only difference
    is the fix to the cFYI statement in cifs_reconnect.
    
    Holding the spinlock while we call this function means that it can't
    sleep, which really limits what it can do. Taking it out from under
    the spinlock also means less contention for this global lock.
    
    Change the semantics such that the Global_MidLock is not held when
    the callback is called. To do this requires that we take extra care
    not to have sync_mid_result remove the mid from the list when the
    mid is in a state where that has already happened. This prevents
    list corruption when the mid is sitting on a private list for
    reconnect or when cifsd is coming down.
    
    Reviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 76b4517e74b0..fd877c110e4c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -543,9 +543,8 @@ struct mid_q_entry;
  * This is the prototype for the mid callback function. When creating one,
  * take special care to avoid deadlocks. Things to bear in mind:
  *
- * - it will be called by cifsd
- * - the GlobalMid_Lock will be held
- * - the mid will be removed from the pending_mid_q list
+ * - it will be called by cifsd, with no locks held
+ * - the mid will be removed from any lists
  */
 typedef void (mid_callback_t)(struct mid_q_entry *mid);
 
@@ -656,6 +655,7 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 #define   MID_RESPONSE_RECEIVED 4
 #define   MID_RETRY_NEEDED      8 /* session closed while this request out */
 #define   MID_RESPONSE_MALFORMED 0x10
+#define   MID_SHUTDOWN		 0x20
 
 /* Types of response buffer returned from SendReceive2 */
 #define   CIFS_NO_BUFFER        0    /* Response buffer not returned */

commit 4d79dba0e00749fa40de8ef13a9b85ce57a1603b
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Wed Apr 27 23:34:35 2011 -0500

    cifs: Add idmap key and related data structures and functions (try #17 repost)
    
    Define (global) data structures to store ids, uids and gids, to which a
    SID maps.  There are two separate trees, one for SID/uid and another one
    for SID/gid.
    
    A new type of key, cifs_idmap_key_type, is used.
    
    Keys are instantiated and searched using credential of the root by
    overriding and restoring the credentials of the caller requesting the key.
    
    Id mapping functions are invoked under config option of cifs acl.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 108a1e99aa9f..76b4517e74b0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -833,6 +833,11 @@ GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
 /* reconnect after this many failed echo attempts */
 GLOBAL_EXTERN unsigned short echo_retries;
 
+GLOBAL_EXTERN struct rb_root uidtree;
+GLOBAL_EXTERN struct rb_root gidtree;
+GLOBAL_EXTERN spinlock_t siduidlock;
+GLOBAL_EXTERN spinlock_t sidgidlock;
+
 void cifs_oplock_break(struct work_struct *work);
 void cifs_oplock_break_get(struct cifsFileInfo *cfile);
 void cifs_oplock_break_put(struct cifsFileInfo *cfile);

commit 34c87901e113799a45423fdac29c7478c889a95d
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Mar 1 05:02:57 2011 +0000

    Shrink stack space usage in cifs_construct_tcon
    
    We were reserving MAX_USERNAME (now 256) on stack for
    something which only needs to fit about 24 bytes ie
    string krb50x +  printf version of uid
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6e211b67b273..108a1e99aa9f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -274,7 +274,8 @@ struct cifsSesInfo {
 	int capabilities;
 	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for
 				TCP names - will ipv6 and sctp addresses fit? */
-	char *user_name;
+	char *user_name;	/* must not be null except during init of sess
+				   and after mount option parsing we fill it */
 	char *domainName;
 	char *password;
 	struct session_key auth_key;

commit 0eff0e26777430bcfee1ef47bd90250858ada431
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Feb 24 05:39:23 2011 +0000

    Remove unused CIFSSMBNotify worker function
    
    The CIFSSMBNotify worker is unused, pending changes to allow it to be called
    via inotify, so move it into its own experimental config option so it does
    not get built in, until the necessary VFS support is fixed.  It used to
    be used in dnotify, but according to Jeff, inotify needs minor changes
    before we can reenable this.
    
    CC: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a5d1106fcbde..6e211b67b273 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -780,10 +780,12 @@ GLOBAL_EXTERN spinlock_t		cifs_tcp_ses_lock;
  */
 GLOBAL_EXTERN spinlock_t	cifs_file_list_lock;
 
+#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* unused temporarily */
 /* Outstanding dir notify requests */
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;
 /* DirNotify response queue */
 GLOBAL_EXTERN struct list_head GlobalDnotifyRsp_Q;
+#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */
 
 /*
  * Global transaction id (XID) information

commit ca83ce3d5b9ad321ee24f5870a77f0b21ac5a5de
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Apr 12 09:13:44 2011 -0400

    cifs: don't allow mmap'ed pages to be dirtied while under writeback (try #3)
    
    This is more or less the same patch as before, but with some merge
    conflicts fixed up.
    
    If a process has a dirty page mapped into its page tables, then it has
    the ability to change it while the client is trying to write the data
    out to the server. If that happens after the signature has been
    calculated then that signature will then be wrong, and the server will
    likely reset the TCP connection.
    
    This patch adds a page_mkwrite handler for CIFS that simply takes the
    page lock. Because the page lock is held over the life of writepage and
    writepages, this prevents the page from becoming writeable until
    the write call has completed.
    
    With this, we can also remove the "sign_zero_copy" module option and
    always inline the pages when writing.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ddb359906708..a5d1106fcbde 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -826,7 +826,6 @@ GLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */
 GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
 GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
 GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
-GLOBAL_EXTERN bool sign_zero_copy; /* don't copy written pages with signing */
 
 /* reconnect after this many failed echo attempts */
 GLOBAL_EXTERN unsigned short echo_retries;

commit fd88ce9313e9f9d3b56eada7fc76a301828baefd
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Apr 12 01:01:14 2011 +0000

    [CIFS] cifs: clarify the meaning of tcpStatus == CifsGood
    
    When the TCP_Server_Info is first allocated and connected, tcpStatus ==
    CifsGood means that the NEGOTIATE_PROTOCOL request has completed and the
    socket is ready for other calls. cifs_reconnect however sets tcpStatus
    to CifsGood as soon as the socket is reconnected and the optional
    RFC1001 session setup is done. We have no clear way to tell the
    difference between these two states, and we need to know this in order
    to know whether we can send an echo or not.
    
    Resolve this by adding a new statusEnum value -- CifsNeedNegotiate. When
    the socket has been connected but has not yet had a NEGOTIATE_PROTOCOL
    request done, set it to this value. Once the NEGOTIATE is done,
    cifs_negotiate_protocol will set tcpStatus to CifsGood.
    
    This also fixes and cleans the logic in cifs_reconnect and
    cifs_reconnect_tcon. The old code checked for specific states when what
    it really wants to know is whether the state has actually changed from
    CifsNeedReconnect.
    
    Reported-and-Tested-by: JG <jg@cms.ac>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1cff9aa9020c..ddb359906708 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -91,7 +91,8 @@ enum statusEnum {
 	CifsNew = 0,
 	CifsGood,
 	CifsExiting,
-	CifsNeedReconnect
+	CifsNeedReconnect,
+	CifsNeedNegotiate
 };
 
 enum securityEnum {

commit 2e325d5973b99bb7421e689351ca74f349eee5ea
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Mar 8 05:51:19 2011 +0000

    Max share size is too small
    
    Max share name was set to 64, and (at least for Windows)
    can be 80.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 94cd8747d28b..1cff9aa9020c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -37,7 +37,7 @@
 
 #define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)
 #define MAX_SERVER_SIZE 15
-#define MAX_SHARE_SIZE  64	/* used to be 20, this should still be enough */
+#define MAX_SHARE_SIZE 80
 #define MAX_USERNAME_SIZE 256	/* reasonable maximum for current servers */
 #define MAX_PASSWORD_SIZE 512	/* max for windows seems to be 256 wide chars */
 

commit 8727c8a85f3951ef0eef36a665f5dceebb4c495d
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Feb 25 01:11:56 2011 -0600

    Allow user names longer than 32 bytes
    
    We artificially limited the user name to 32 bytes, but modern servers handle
    larger.  Set the maximum length to a reasonable 256, and make the user name
    string dynamically allocated rather than a fixed size in session structure.
    Also clean up old checkpatch warning.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 10e4afe54e22..94cd8747d28b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -38,9 +38,8 @@
 #define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)
 #define MAX_SERVER_SIZE 15
 #define MAX_SHARE_SIZE  64	/* used to be 20, this should still be enough */
-#define MAX_USERNAME_SIZE 32	/* 32 is to allow for 15 char names + null
-				   termination then *2 for unicode versions */
-#define MAX_PASSWORD_SIZE 512  /* max for windows seems to be 256 wide chars */
+#define MAX_USERNAME_SIZE 256	/* reasonable maximum for current servers */
+#define MAX_PASSWORD_SIZE 512	/* max for windows seems to be 256 wide chars */
 
 #define CIFS_MIN_RCV_POOL 4
 
@@ -274,7 +273,7 @@ struct cifsSesInfo {
 	int capabilities;
 	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for
 				TCP names - will ipv6 and sctp addresses fit? */
-	char userName[MAX_USERNAME_SIZE + 1];
+	char *user_name;
 	char *domainName;
 	char *password;
 	struct session_key auth_key;

commit bdf1b03e093bdbc571f404e751c7b0e2dca412ea
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Feb 22 20:17:19 2011 -0500

    cifs: replace /proc/fs/cifs/Experimental with a module parm
    
    This flag currently only affects whether we allow "zero-copy" writes
    with signing enabled. Typically we map pages in the pagecache directly
    into the write request. If signing is enabled however and the contents
    of the page change after the signature is calculated but before the
    write is sent then the signature will be wrong. Servers typically
    respond to this by closing down the socket.
    
    Still, this can provide a performance benefit so the "Experimental" flag
    was overloaded to allow this. That's really not a good place for this
    option however since it's not clear what that flag does.
    
    Move that flag instead to a new module parameter that better describes
    its purpose. That's also better since it can be set at module insertion
    time by configuring modprobe.d.
    
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 17afb0fbcaed..10e4afe54e22 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -817,7 +817,6 @@ GLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions
 				have the uid/password or Kerberos credential
 				or equivalent for current user */
 GLOBAL_EXTERN unsigned int oplockEnabled;
-GLOBAL_EXTERN unsigned int experimEnabled;
 GLOBAL_EXTERN unsigned int lookupCacheEnabled;
 GLOBAL_EXTERN unsigned int global_secflags;	/* if on, session setup sent
 				with more secure ntlmssp2 challenge/resp */
@@ -827,6 +826,7 @@ GLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */
 GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
 GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
 GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
+GLOBAL_EXTERN bool sign_zero_copy; /* don't copy written pages with signing */
 
 /* reconnect after this many failed echo attempts */
 GLOBAL_EXTERN unsigned short echo_retries;

commit 71823baff1978be892e7a36eddf6170e1cc6650d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Feb 10 08:03:50 2011 -0500

    cifs: don't always drop malformed replies on the floor (try #3)
    
    Slight revision to this patch...use min_t() instead of conditional
    assignment. Also, remove the FIXME comment and replace it with the
    explanation that Steve gave earlier.
    
    After receiving a packet, we currently check the header. If it's no
    good, then we toss it out and continue the loop, leaving the caller
    waiting on that response.
    
    In cases where the packet has length inconsistencies, but the MID is
    valid, this leads to unneeded delays. That's especially problematic now
    that the client waits indefinitely for responses.
    
    Instead, don't immediately discard the packet if checkSMB fails. Try to
    find a matching mid_q_entry, mark it as having a malformed response and
    issue the callback.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1ab33eb71d95..17afb0fbcaed 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -654,7 +654,7 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 #define   MID_REQUEST_SUBMITTED 2
 #define   MID_RESPONSE_RECEIVED 4
 #define   MID_RETRY_NEEDED      8 /* session closed while this request out */
-#define   MID_NO_RESP_NEEDED 0x10
+#define   MID_RESPONSE_MALFORMED 0x10
 
 /* Types of response buffer returned from SendReceive2 */
 #define   CIFS_NO_BUFFER        0    /* Response buffer not returned */

commit 7e90d705fc9f8c5e3a1549281dce0654d049243b
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Feb 8 23:52:32 2011 +0000

    [CIFS] Do not send SMBEcho requests on new sockets until SMBNegotiate
    
    In order to determine whether an SMBEcho request can be sent
    we need to know that the socket is established (server tcpStatus == CifsGood)
    AND that an SMB NegotiateProtocol has been sent (server maxBuf != 0).
    Without the second check we can send an Echo request during reconnection
    before the server can accept it.
    
    CC: JG <jg@cms.ac>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index edd5b29b53c9..1ab33eb71d95 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -188,6 +188,8 @@ struct TCP_Server_Info {
 	/* multiplexed reads or writes */
 	unsigned int maxBuf;	/* maxBuf specifies the maximum */
 	/* message size the server can send or receive for non-raw SMBs */
+	/* maxBuf is returned by SMB NegotiateProtocol so maxBuf is only 0 */
+	/* when socket is setup (and during reconnect) before NegProt sent */
 	unsigned int max_rw;	/* maxRw specifies the maximum */
 	/* message size the server can send or receive for */
 	/* SMB_COM_WRITE_RAW or SMB_COM_READ_RAW. */

commit f1d0c998653f1eeec60ee6420e550135b62dbab4
Author: Rob Landley <rlandley@parallels.com>
Date:   Sat Jan 22 15:44:05 2011 -0600

    Make CIFS mount work in a container.
    
    Teach cifs about network namespaces, so mounting uses adresses/routing
    visible from the container rather than from init context.
    
    A container is a chroot on steroids that changes more than just the root
    filesystem the new processes see.  One thing containers can isolate is
    "network namespaces", meaning each container can have its own set of
    ethernet interfaces, each with its own own IP address and routing to the
    outside world.  And if you open a socket in _userspace_ from processes
    within such a container, this works fine.
    
    But sockets opened from within the kernel still use a single global
    networking context in a lot of places, meaning the new socket's address
    and routing are correct for PID 1 on the host, but are _not_ what
    userspace processes in the container get to use.
    
    So when you mount a network filesystem from within in a container, the
    mount code in the CIFS driver uses the host's networking context and not
    the container's networking context, so it gets the wrong address, uses
    the wrong routing, and may even try to go out an interface that the
    container can't even access...  Bad stuff.
    
    This patch copies the mount process's network context into the CIFS
    structure that stores the rest of the server information for that mount
    point, and changes the socket open code to use the saved network context
    instead of the global network context.  I.E. "when you attempt to use
    these addresses, do so relative to THIS set of network interfaces and
    routing rules, not the old global context from back before we supported
    containers".
    
    The big long HOWTO sets up a test environment on the assumption you've
    never used ocntainers before.  It basically says:
    
    1) configure and build a new kernel that has container support
    2) build a new root filesystem that includes the userspace container
    control package (LXC)
    3) package/run them under KVM (so you don't have to mess up your host
    system in order to play with containers).
    4) set up some containers under the KVM system
    5) set up contradictory routing in the KVM system and the container so
    that the host and the container see different things for the same address
    6) try to mount a CIFS share from both contexts so you can both force it
    to work and force it to fail.
    
    For a long drawn out test reproduction sequence, see:
    
      http://landley.livejournal.com/47024.html
      http://landley.livejournal.com/47205.html
      http://landley.livejournal.com/47476.html
    
    Signed-off-by: Rob Landley <rlandley@parallels.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5bfb75346cb0..edd5b29b53c9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -166,6 +166,9 @@ struct TCP_Server_Info {
 	struct socket *ssocket;
 	struct sockaddr_storage dstaddr;
 	struct sockaddr_storage srcaddr; /* locally bind to this IP */
+#ifdef CONFIG_NET_NS
+	struct net *net;
+#endif
 	wait_queue_head_t response_q;
 	wait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/
 	struct list_head pending_mid_q;
@@ -216,6 +219,36 @@ struct TCP_Server_Info {
 #endif
 };
 
+/*
+ * Macros to allow the TCP_Server_Info->net field and related code to drop out
+ * when CONFIG_NET_NS isn't set.
+ */
+
+#ifdef CONFIG_NET_NS
+
+static inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)
+{
+	return srv->net;
+}
+
+static inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)
+{
+	srv->net = net;
+}
+
+#else
+
+static inline struct net *cifs_net_ns(struct TCP_Server_Info *srv)
+{
+	return &init_net;
+}
+
+static inline void cifs_set_net_ns(struct TCP_Server_Info *srv, struct net *net)
+{
+}
+
+#endif
+
 /*
  * Session structure.  One of these for each uid session with a particular host
  */

commit aae62fdb6b9a6605abdea7370c4a0e005e6c1cd7
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jan 20 13:36:50 2011 -0500

    cifs: move time field in cifsInodeInfo
    
    ...and remove length qualifiers from bools.
    
    Before:
    
            /* size: 1176, cachelines: 19, members: 13 */
            /* sum members: 1165, holes: 2, sum holes: 11 */
            /* bit holes: 1, sum bit holes: 4 bits */
            /* last cacheline: 24 bytes */
    
    After:
    
            /* size: 1168, cachelines: 19, members: 13 */
            /* last cacheline: 16 bytes */
    
    ...savings of 8 bytes per inode.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 36f097e1ee74..5bfb75346cb0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -439,11 +439,11 @@ struct cifsInodeInfo {
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
-	unsigned long time;	/* jiffies of last update/check of inode */
-	bool clientCanCacheRead:1;	/* read oplock */
-	bool clientCanCacheAll:1;	/* read and writebehind oplock */
-	bool delete_pending:1;		/* DELETE_ON_CLOSE is set */
-	bool invalid_mapping:1;		/* pagecache is invalid */
+	bool clientCanCacheRead;	/* read oplock */
+	bool clientCanCacheAll;		/* read and writebehind oplock */
+	bool delete_pending;		/* DELETE_ON_CLOSE is set */
+	bool invalid_mapping;		/* pagecache is invalid */
+	unsigned long time;		/* jiffies of last update of inode */
 	u64  server_eof;		/* current file size on server */
 	u64  uniqueid;			/* server inode number */
 	u64  createtime;		/* creation time on server */

commit c3dccf48174e50668b7c63544ac8c60c07a45978
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jan 20 13:36:50 2011 -0500

    cifs: TCP_Server_Info diet
    
    Remove fields that are completely unused, and rearrange struct
    according to recommendations by "pahole".
    
    Before:
    
            /* size: 1112, cachelines: 18, members: 49 */
            /* sum members: 1086, holes: 8, sum holes: 26 */
            /* bit holes: 1, sum bit holes: 7 bits */
            /* last cacheline: 24 bytes */
    
    After:
    
            /* size: 1072, cachelines: 17, members: 42 */
            /* sum members: 1065, holes: 3, sum holes: 7 */
            /* last cacheline: 48 bytes */
    
    ...savings of 40 bytes per struct on x86_64. 21 bytes by field removal,
    and 19 by reorganizing to eliminate holes.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 571132c95231..36f097e1ee74 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -161,6 +161,7 @@ struct TCP_Server_Info {
 	int srv_count; /* reference counter */
 	/* 15 character server name + 0x20 16th byte indicating type = srv */
 	char server_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
+	enum statusEnum tcpStatus; /* what we think the status is */
 	char *hostname; /* hostname portion of UNC string */
 	struct socket *ssocket;
 	struct sockaddr_storage dstaddr;
@@ -168,25 +169,16 @@ struct TCP_Server_Info {
 	wait_queue_head_t response_q;
 	wait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/
 	struct list_head pending_mid_q;
-	void *Server_NlsInfo;	/* BB - placeholder for future NLS info  */
-	unsigned short server_codepage;	/* codepage for the server    */
-	enum protocolEnum protocolType;
-	char versionMajor;
-	char versionMinor;
-	bool svlocal:1;			/* local server or remote */
 	bool noblocksnd;		/* use blocking sendmsg */
 	bool noautotune;		/* do not autotune send buf sizes */
 	bool tcp_nodelay;
 	atomic_t inFlight;  /* number of requests on the wire to server */
-#ifdef CONFIG_CIFS_STATS2
-	atomic_t inSend; /* requests trying to send */
-	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
-#endif
-	enum statusEnum tcpStatus; /* what we think the status is */
 	struct mutex srv_mutex;
 	struct task_struct *tsk;
 	char server_GUID[16];
 	char secMode;
+	bool session_estab; /* mark when very first sess is established */
+	u16 dialect; /* dialect index that server chose */
 	enum securityEnum secType;
 	unsigned int maxReq;	/* Clients should submit no more */
 	/* than maxReq distinct unanswered SMBs to the server when using  */
@@ -199,8 +191,6 @@ struct TCP_Server_Info {
 	unsigned int max_vcs;	/* maximum number of smb sessions, at least
 				   those that can be specified uniquely with
 				   vcnumbers */
-	char sessid[4];		/* unique token id for this session */
-	/* (returned on Negotiate */
 	int capabilities; /* allow selective disabling of caps by smb sess */
 	int timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u16 CurrentMid;         /* multiplex id - rotating counter */
@@ -210,18 +200,20 @@ struct TCP_Server_Info {
 	__u32 sequence_number; /* for signing, protected by srv_mutex */
 	struct session_key session_key;
 	unsigned long lstrp; /* when we got last response from this server */
-	u16 dialect; /* dialect index that server chose */
 	struct cifs_secmech secmech; /* crypto sec mech functs, descriptors */
 	/* extended security flavors that server supports */
+	bool	sec_ntlmssp;		/* supports NTLMSSP */
+	bool	sec_kerberosu2u;	/* supports U2U Kerberos */
 	bool	sec_kerberos;		/* supports plain Kerberos */
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
-	bool	sec_kerberosu2u;	/* supports U2U Kerberos */
-	bool	sec_ntlmssp;		/* supports NTLMSSP */
-	bool session_estab; /* mark when very first sess is established */
 	struct delayed_work	echo; /* echo ping workqueue job */
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie   *fscache; /* client index cache cookie */
 #endif
+#ifdef CONFIG_CIFS_STATS2
+	atomic_t inSend; /* requests trying to send */
+	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
+#endif
 };
 
 /*

commit 7749981ec31aa40e28a1ef5687e46bc1aa278fae
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jan 11 07:24:23 2011 -0500

    cifs: remove code for setting timeouts on requests
    
    Since we don't time out individual requests anymore, remove the code
    that we used to use for setting timeouts on different requests.
    
    Reviewed-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7040abc638fa..571132c95231 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -636,12 +636,9 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 #define   CIFS_IOVEC            4    /* array of response buffers */
 
 /* Type of Request to SendReceive2 */
-#define   CIFS_STD_OP	        0    /* normal request timeout */
-#define   CIFS_LONG_OP          1    /* long op (up to 45 sec, oplock time) */
-#define   CIFS_VLONG_OP         2    /* sloow op - can take up to 180 seconds */
-#define   CIFS_BLOCKING_OP      4    /* operation can block */
-#define   CIFS_ASYNC_OP         8    /* do not wait for response */
-#define   CIFS_TIMEOUT_MASK 0x00F    /* only one of 5 above set in req */
+#define   CIFS_BLOCKING_OP      1    /* operation can block */
+#define   CIFS_ASYNC_OP         2    /* do not wait for response */
+#define   CIFS_TIMEOUT_MASK 0x003    /* only one of above set in req */
 #define   CIFS_LOG_ERROR    0x010    /* log NT STATUS if non-zero */
 #define   CIFS_LARGE_BUF_OP 0x020    /* large request buffer */
 #define   CIFS_NO_RESP      0x040    /* no response buffer required */

commit fda3594362184383e73f0a2a5fa5b38ac0e04fd8
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jan 20 18:06:34 2011 +0000

    [CIFS] cifs: reconnect unresponsive servers
    
    If the server isn't responding to echoes, we don't want to leave tasks
    hung waiting for it to reply. At that point, we'll want to reconnect
    so that soft mounts can return an error to userspace quickly.
    
    If the client hasn't received a reply after a specified number of echo
    intervals, assume that the transport is down and attempt to reconnect
    the socket.
    
    The number of echo_intervals to wait before attempting to reconnect is
    tunable via a module parameter. Setting it to 0, means that the client
    will never attempt to reconnect. The default is 5.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9c728dd5b146..7040abc638fa 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -804,6 +804,9 @@ GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
 GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
 GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
 
+/* reconnect after this many failed echo attempts */
+GLOBAL_EXTERN unsigned short echo_retries;
+
 void cifs_oplock_break(struct work_struct *work);
 void cifs_oplock_break_get(struct cifsFileInfo *cfile);
 void cifs_oplock_break_put(struct cifsFileInfo *cfile);

commit c74093b694998d30105d9904686da5e3576497c4
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jan 11 07:24:23 2011 -0500

    cifs: set up recurring workqueue job to do SMB echo requests
    
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4de737575959..9c728dd5b146 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -218,6 +218,7 @@ struct TCP_Server_Info {
 	bool	sec_kerberosu2u;	/* supports U2U Kerberos */
 	bool	sec_ntlmssp;		/* supports NTLMSSP */
 	bool session_estab; /* mark when very first sess is established */
+	struct delayed_work	echo; /* echo ping workqueue job */
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie   *fscache; /* client index cache cookie */
 #endif

commit 2b84a36c5529da136d28b268e75268892d09869c
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jan 11 07:24:21 2011 -0500

    cifs: allow for different handling of received response
    
    In order to incorporate async requests, we need to allow for a more
    general way to do things on receive, rather than just waking up a
    process.
    
    Turn the task pointer in the mid_q_entry into a callback function and a
    generic data pointer. When a response comes in, or the socket is
    reconnected, cifsd can call the callback function in order to wake up
    the process.
    
    The default is to just wake up the current process which should mean no
    change in behavior for existing code.
    
    Also, clean up the locking in cifs_reconnect. There doesn't seem to be
    any need to hold both the srv_mutex and GlobalMid_Lock when walking the
    list of mids.
    
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 606ca8bb7102..4de737575959 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -508,6 +508,18 @@ static inline void cifs_stats_bytes_read(struct cifsTconInfo *tcon,
 
 #endif
 
+struct mid_q_entry;
+
+/*
+ * This is the prototype for the mid callback function. When creating one,
+ * take special care to avoid deadlocks. Things to bear in mind:
+ *
+ * - it will be called by cifsd
+ * - the GlobalMid_Lock will be held
+ * - the mid will be removed from the pending_mid_q list
+ */
+typedef void (mid_callback_t)(struct mid_q_entry *mid);
+
 /* one of these for every pending CIFS request to the server */
 struct mid_q_entry {
 	struct list_head qhead;	/* mids waiting on reply from this server */
@@ -519,7 +531,8 @@ struct mid_q_entry {
 	unsigned long when_sent; /* time when smb send finished */
 	unsigned long when_received; /* when demux complete (taken off wire) */
 #endif
-	struct task_struct *tsk;	/* task waiting for response */
+	mid_callback_t *callback; /* call completion callback */
+	void *callback_data;	  /* general purpose pointer for callback */
 	struct smb_hdr *resp_buf;	/* response buffer */
 	int midState;	/* wish this were enum but can not pass to wait_event */
 	__u8 command;	/* smb command code */

commit 20054bd65703f7504a9daceabc2a060828fde36c
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jan 7 11:30:27 2011 -0500

    cifs: use CreationTime like an i_generation field
    
    Reduce false inode collisions by using the CreationTime like an
    i_generation field. This way, even if the server ends up reusing
    a uniqueid after a delete/create cycle, we can avoid matching
    the inode incorrectly.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e6590e69fb0e..606ca8bb7102 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -453,6 +453,7 @@ struct cifsInodeInfo {
 	bool invalid_mapping:1;		/* pagecache is invalid */
 	u64  server_eof;		/* current file size on server */
 	u64  uniqueid;			/* server inode number */
+	u64  createtime;		/* creation time on server */
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie *fscache;
 #endif
@@ -573,6 +574,7 @@ struct cifs_fattr {
 	u64		cf_uniqueid;
 	u64		cf_eof;
 	u64		cf_bytes;
+	u64		cf_createtime;
 	uid_t		cf_uid;
 	gid_t		cf_gid;
 	umode_t		cf_mode;

commit a0f8b4fb4cab4bc32caaf34fc0a0c9d5dd369186
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jan 7 11:30:28 2011 -0500

    cifs: remove unnecessary locking around sequence_number
    
    The server->sequence_number is already protected by the srv_mutex. The
    GlobalMid_lock is unneeded here.
    
    Reviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index dfd2d46275ab..e6590e69fb0e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -207,7 +207,7 @@ struct TCP_Server_Info {
 	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlm, ntlmv2 etc */
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
-	__u32 sequence_number; /* needed for CIFS PDU signature */
+	__u32 sequence_number; /* for signing, protected by srv_mutex */
 	struct session_key session_key;
 	unsigned long lstrp; /* when we got last response from this server */
 	u16 dialect; /* dialect index that server chose */

commit a9f1b85e5ba80519dea6974e3574fa7a30cc5e29
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Mon Dec 13 19:08:35 2010 +0300

    CIFS: Simplify ipv*_connect functions into one (try #4)
    
    Make connect logic more ip-protocol independent and move RFC1001 stuff into
    a separate function. Also replace union addr in TCP_Server_Info structure
    with sockaddr_storage.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-and-Tested-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7136c0c3e2f9..dfd2d46275ab 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -163,10 +163,7 @@ struct TCP_Server_Info {
 	char server_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	char *hostname; /* hostname portion of UNC string */
 	struct socket *ssocket;
-	union {
-		struct sockaddr_in sockAddr;
-		struct sockaddr_in6 sockAddr6;
-	} addr;
+	struct sockaddr_storage dstaddr;
 	struct sockaddr_storage srcaddr; /* locally bind to this IP */
 	wait_queue_head_t response_q;
 	wait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/

commit 884639996814585ef7079daa9e03a1eb562e235c
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Mon Nov 22 15:31:03 2010 -0500

    cifs: remove Local_System_Name
    
    ...this string is zeroed out and nothing ever changes it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 94ccfacaed8a..7136c0c3e2f9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -756,8 +756,6 @@ GLOBAL_EXTERN unsigned int GlobalTotalActiveXid; /* prot by GlobalMid_Sem */
 GLOBAL_EXTERN unsigned int GlobalMaxActiveXid;	/* prot by GlobalMid_Sem */
 GLOBAL_EXTERN spinlock_t GlobalMid_Lock;  /* protects above & list operations */
 					  /* on midQ entries */
-GLOBAL_EXTERN char Local_System_Name[15];
-
 /*
  *  Global counters, updated atomically
  */

commit 6d20e8406f0942228a73000663c2b33f488103ea
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Wed Dec 1 14:42:28 2010 +0530

    cifs: add attribute cache timeout (actimeo) tunable
    
    Currently, the attribute cache timeout for CIFS is hardcoded to 1 second. This
    means that the client might have to issue a QPATHINFO/QFILEINFO call every 1
    second to verify if something has changes, which seems too expensive. On the
    other hand, if the timeout is hardcoded to a higher value, workloads that
    expect strict cache coherency might see unexpected results.
    
    Making attribute cache timeout as a tunable will allow us to make a tradeoff
    between performance and cache metadata correctness depending on the
    application/workload needs.
    
    Add 'actimeo' tunable that can be used to tune the attribute cache timeout.
    The default timeout is set to 1 second. Also, display actimeo option value in
    /proc/mounts.
    
    It appears to me that 'actimeo' and the proposed (but not yet merged)
    'strictcache' option cannot coexist, so care must be taken that we reset the
    other option if one of them is set.
    
    Changes since last post:
       - fix option parsing and handle possible values correcly
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b577bf0a1bb3..94ccfacaed8a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -44,6 +44,16 @@
 
 #define CIFS_MIN_RCV_POOL 4
 
+/*
+ * default attribute cache timeout (jiffies)
+ */
+#define CIFS_DEF_ACTIMEO (1 * HZ)
+
+/*
+ * max attribute cache timeout (jiffies) - 2^30
+ */
+#define CIFS_MAX_ACTIMEO (1 << 30)
+
 /*
  * MAX_REQ is the maximum number of requests that WE will send
  * on one socket concurrently. It also matches the most common

commit b647c35f77af9c07d336247b23014596e9f0a593
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Oct 28 11:16:44 2010 -0400

    cifs: convert tlink_tree to a rbtree
    
    Radix trees are ideal when you want to track a bunch of pointers and
    can't embed a tracking structure within the target of those pointers.
    The tradeoff is an increase in memory, particularly if the tree is
    sparse.
    
    In CIFS, we use the tlink_tree to track tcon_link structs. A tcon_link
    can never be in more than one tlink_tree, so there's no impediment to
    using a rb_tree here instead of a radix tree.
    
    Convert the new multiuser mount code to use a rb_tree instead. This
    should reduce the memory required to manage the tlink_tree.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f259e4d7612d..b577bf0a1bb3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -336,7 +336,8 @@ struct cifsTconInfo {
  * "get" on the container.
  */
 struct tcon_link {
-	unsigned long		tl_index;
+	struct rb_node		tl_rbnode;
+	uid_t			tl_uid;
 	unsigned long		tl_flags;
 #define TCON_LINK_MASTER	0
 #define TCON_LINK_PENDING	1

commit d3686d54c7902a303bd65d751226aa1647319863
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Thu Oct 28 09:53:07 2010 -0500

    cifs: Cleanup and thus reduce smb session structure and fields used during authentication
    
    Removed following fields from smb session structure
     cryptkey, ntlmv2_hash, tilen, tiblob
    and ntlmssp_auth structure is allocated dynamically only if the auth mech
    in NTLMSSP.
    
    response field within a session_key structure is used to initially store the
    target info (either plucked from type 2 challenge packet in case of NTLMSSP
    or fabricated in case of NTLMv2 without extended security) and then to store
    Message Authentication Key (mak) (session key + client response).
    
    Server challenge or cryptkey needed during a NTLMSSP authentication
    is now part of ntlmssp_auth structure which gets allocated and freed
    once authenticaiton process is done.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b73695176467..f259e4d7612d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -119,11 +119,12 @@ struct cifs_secmech {
 	struct sdesc *sdescmd5; /* ctxt to generate cifs/smb signature */
 };
 
-/* per smb connection structure/fields */
+/* per smb session structure/fields */
 struct ntlmssp_auth {
 	__u32 client_flags; /* sent by client in type 1 ntlmsssp exchange */
 	__u32 server_flags; /* sent by server in type 2 ntlmssp exchange */
 	unsigned char ciphertext[CIFS_CPHTXT_SIZE]; /* sent to server */
+	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlmssp */
 };
 
 struct cifs_cred {
@@ -241,12 +242,8 @@ struct cifsSesInfo {
 	char userName[MAX_USERNAME_SIZE + 1];
 	char *domainName;
 	char *password;
-	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlmssp */
 	struct session_key auth_key;
-	char ntlmv2_hash[16];
-	unsigned int tilen; /* length of the target info blob */
-	unsigned char *tiblob; /* target info blob in challenge response */
-	struct ntlmssp_auth ntlmssp; /* ciphertext, flags */
+	struct ntlmssp_auth *ntlmssp; /* ciphertext, flags, server challenge */
 	bool need_reconnect:1; /* connection reset, uid now invalid */
 };
 /* no more than one of the following three session flags may be set */

commit d3ba50b17aa7a391bb5b3dcd8d6ba7a02c4f031c
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Wed Oct 27 15:20:36 2010 -0500

    NTLM auth and sign - Use appropriate server challenge
    
    Need to have cryptkey or server challenge in smb connection
    (struct TCP_Server_Info) for ntlm and ntlmv2 auth types for which
    cryptkey (Encryption Key) is supplied just once in Negotiate Protocol
    response during an smb connection setup for all the smb sessions over
    that smb connection.
    
    For ntlmssp, cryptkey or server challenge is provided for every
    smb session in type 2 packet of ntlmssp negotiation, the cryptkey
    provided during Negotiation Protocol response before smb connection
    does not count.
    
    Rename cryptKey to cryptkey and related changes.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 67d6a2280a01..b73695176467 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -196,6 +196,7 @@ struct TCP_Server_Info {
 	int capabilities; /* allow selective disabling of caps by smb sess */
 	int timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u16 CurrentMid;         /* multiplex id - rotating counter */
+	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlm, ntlmv2 etc */
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
@@ -240,7 +241,7 @@ struct cifsSesInfo {
 	char userName[MAX_USERNAME_SIZE + 1];
 	char *domainName;
 	char *password;
-	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
+	char cryptkey[CIFS_CRYPTO_KEY_SIZE]; /* used by ntlmssp */
 	struct session_key auth_key;
 	char ntlmv2_hash[16];
 	unsigned int tilen; /* length of the target info blob */

commit f7c5445a9deecffea8a4fffc0163bf582411ac8a
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Tue Oct 26 18:10:24 2010 -0500

    NTLM auth and sign - minor error corrections and cleanup
    
    Minor cleanup - Fix spelling mistake, make meaningful (goto) label
    
    In function setup_ntlmv2_rsp(), do not return 0 and leak memory,
    let the tiblob get freed.
    
    For function find_domain_name(), pass already available nls table pointer
    instead of loading and unloading the table again in this function.
    
    For ntlmv2, the case sensitive password length is the length of the
    response, so subtract session key length (16 bytes) from the .len.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7ca5f6d8ed80..67d6a2280a01 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -111,7 +111,7 @@ struct sdesc {
 	char ctx[];
 };
 
-/* crypto hashing related structure/fields, not speicific to a sec mech */
+/* crypto hashing related structure/fields, not specific to a sec mech */
 struct cifs_secmech {
 	struct crypto_shash *hmacmd5; /* hmac-md5 hash function */
 	struct crypto_shash *md5; /* md5 hash function */

commit d2b915210b5ec01409f581421d633eca6c38d444
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Thu Oct 21 14:25:08 2010 -0500

    NTLM auth and sign - Define crypto hash functions and create and send keys needed for key exchange
    
    Mark dependency on crypto modules in Kconfig.
    
    Defining per structures sdesc and cifs_secmech which are used to store
    crypto hash functions and contexts.  They are stored per smb connection
    and used for all auth mechs to genereate hash values and signatures.
    
    Allocate crypto hashing functions, security descriptiors, and respective
    contexts when a smb/tcp connection is established.
    Release them when a tcp/smb connection is taken down.
    
    md5 and hmac-md5 are two crypto hashing functions that are used
    throught the life of an smb/tcp connection by various functions that
    calcualte signagure and ntlmv2 hash, HMAC etc.
    
    structure ntlmssp_auth is defined as per smb connection.
    
    ntlmssp_auth holds ciphertext which is genereated by rc4/arc4 encryption of
    secondary key, a nonce using ntlmv2 session key and sent in the session key
    field of the type 3 message sent by the client during ntlmssp
    negotiation/exchange
    
    A key is exchanged with the server if client indicates so in flags in
    type 1 messsage and server agrees in flag in type 2 message of ntlmssp
    negotiation.  If both client and agree, a key sent by client in
    type 3 message of ntlmssp negotiation in the session key field.
    The key is a ciphertext generated off of secondary key, a nonce, using
    ntlmv2 hash via rc4/arc4.
    
    Signing works for ntlmssp in this patch. The sequence number within
    the server structure needs to be zero until session is established
    i.e. till type 3 packet of ntlmssp exchange of a to be very first
    smb session on that smb connection is sent.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 66f76b2d270b..7ca5f6d8ed80 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -25,6 +25,9 @@
 #include <linux/workqueue.h>
 #include "cifs_fs_sb.h"
 #include "cifsacl.h"
+#include <crypto/internal/hash.h>
+#include <linux/scatterlist.h>
+
 /*
  * The sizes of various internal tables and strings
  */
@@ -102,6 +105,27 @@ struct session_key {
 	char *response;
 };
 
+/* crypto security descriptor definition */
+struct sdesc {
+	struct shash_desc shash;
+	char ctx[];
+};
+
+/* crypto hashing related structure/fields, not speicific to a sec mech */
+struct cifs_secmech {
+	struct crypto_shash *hmacmd5; /* hmac-md5 hash function */
+	struct crypto_shash *md5; /* md5 hash function */
+	struct sdesc *sdeschmacmd5;  /* ctxt to generate ntlmv2 hash, CR1 */
+	struct sdesc *sdescmd5; /* ctxt to generate cifs/smb signature */
+};
+
+/* per smb connection structure/fields */
+struct ntlmssp_auth {
+	__u32 client_flags; /* sent by client in type 1 ntlmsssp exchange */
+	__u32 server_flags; /* sent by server in type 2 ntlmssp exchange */
+	unsigned char ciphertext[CIFS_CPHTXT_SIZE]; /* sent to server */
+};
+
 struct cifs_cred {
 	int uid;
 	int gid;
@@ -178,6 +202,7 @@ struct TCP_Server_Info {
 	struct session_key session_key;
 	unsigned long lstrp; /* when we got last response from this server */
 	u16 dialect; /* dialect index that server chose */
+	struct cifs_secmech secmech; /* crypto sec mech functs, descriptors */
 	/* extended security flavors that server supports */
 	bool	sec_kerberos;		/* supports plain Kerberos */
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
@@ -220,6 +245,7 @@ struct cifsSesInfo {
 	char ntlmv2_hash[16];
 	unsigned int tilen; /* length of the target info blob */
 	unsigned char *tiblob; /* target info blob in challenge response */
+	struct ntlmssp_auth ntlmssp; /* ciphertext, flags */
 	bool need_reconnect:1; /* connection reset, uid now invalid */
 };
 /* no more than one of the following three session flags may be set */

commit 21e733930be6458e0c33482b6783e7c15ba984eb
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Thu Oct 21 06:42:55 2010 -0500

    NTLM auth and sign - Allocate session key/client response dynamically
    
    Start calculating auth response within a session.  Move/Add pertinet
    data structures like session key, server challenge and ntlmv2_hash in
    a session structure.  We should do the calculations within a session
    before copying session key and response over to server data
    structures because a session setup can fail.
    
    Only after a very first smb session succeeds, it copy/make its
    session key, session key of smb connection.  This key stays with
    the smb connection throughout its life.
    sequence_number within server is set to 0x2.
    
    The authentication Message Authentication Key (mak) which consists
    of session key followed by client response within structure session_key
    is now dynamic.  Every authentication type allocates the key + response
    sized memory within its session structure and later either assigns or
    frees it once the client response is sent and if session's session key
    becomes connetion's session key.
    
    ntlm/ntlmi authentication functions are rearranged.  A function
    named setup_ntlm_resp(), similar to setup_ntlmv2_resp(), replaces
    function cifs_calculate_session_key().
    
    size of CIFS_SESS_KEY_SIZE is changed to 16, to reflect the byte size
    of the key it holds.
    
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 539475a11c45..66f76b2d270b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -99,14 +99,7 @@ enum protocolEnum {
 
 struct session_key {
 	unsigned int len;
-	union {
-		char ntlm[CIFS_SESS_KEY_SIZE + 16];
-		char krb5[CIFS_SESS_KEY_SIZE + 16]; /* BB: length correct? */
-		struct {
-			char key[16];
-			struct ntlmv2_resp resp;
-		} ntlmv2;
-	} data;
+	char *response;
 };
 
 struct cifs_cred {

commit 6573e9b73e19c0f6b9dfa2b399267ea0f42d6c6b
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Mon Oct 18 23:52:18 2010 +0530

    cifs: update comments - [s/GlobalSMBSesLock/cifs_file_list_lock/g]
    
    GlobalSMBSesLock is now cifs_file_list_lock. Update comments to reflect this.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ef5709b250e6..539475a11c45 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -670,7 +670,7 @@ require use of the stronger protocol */
  *  GlobalMid_Lock protects:
  *	list operations on pending_mid_q and oplockQ
  *      updates to XID counters, multiplex id  and SMB sequence numbers
- *  GlobalSMBSesLock protects:
+ *  cifs_file_list_lock protects:
  *	list operations on tcp and SMB session lists and tCon lists
  *  f_owner.lock protects certain per file struct operations
  *  mapping->page_lock protects certain per page operations

commit eb4b756b1e60b66e54932619088b645c712414a3
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 22 14:52:29 2010 -0400

    cifs: eliminate cifsInodeInfo->write_behind_rc (try #6)
    
    write_behind_rc is redundant and just adds complexity to the code. What
    we really want to do instead is to use mapping_set_error to reset the
    flags on the mapping when we find a writeback error and can't report it
    to userspace yet.
    
    For cifs_flush and cifs_fsync, we shouldn't reset the flags since errors
    returned there do get reported to userspace.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Reviewed-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7128c291cec8..ef5709b250e6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -420,7 +420,6 @@ struct cifsInodeInfo {
 	struct list_head lockList;
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
-	int write_behind_rc;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
 	unsigned long time;	/* jiffies of last update/check of inode */
 	bool clientCanCacheRead:1;	/* read oplock */

commit 6c0f6218ba04a5d6e61d0c55b68e6c4ef0736531
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Oct 23 16:51:40 2010 +0000

    [CIFS] Fix checkpatch warnings and bump cifs version number
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6319db025e7b..7128c291cec8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -74,7 +74,7 @@
  * CIFS vfs client Status information (based on what we know.)
  */
 
- /* associated with each tcp and smb session */
+/* associated with each tcp and smb session */
 enum statusEnum {
 	CifsNew = 0,
 	CifsGood,
@@ -395,7 +395,7 @@ struct cifsFileInfo {
 	struct list_head llist; /* list of byte range locks we have. */
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
-	int count;		/* refcount -- protected by cifs_file_list_lock */
+	int count;		/* refcount protected by cifs_file_list_lock */
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 	struct work_struct oplock_break; /* work for oplock breaks */

commit 5f6dbc9e4afe4d1d39e85de3ac2720a2042ad191
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 15 15:34:06 2010 -0400

    cifs: convert cifsFileInfo->count to non-atomic counter
    
    The count for cifsFileInfo is currently an atomic, but that just adds
    complexity for little value. We generally need to hold cifs_file_list_lock
    to traverse the lists anyway so we might as well make this counter
    non-atomic and simply use the cifs_file_list_lock to protect it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3365e77f6f24..6319db025e7b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -395,16 +395,19 @@ struct cifsFileInfo {
 	struct list_head llist; /* list of byte range locks we have. */
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
-	atomic_t count;		/* reference count */
+	int count;		/* refcount -- protected by cifs_file_list_lock */
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 	struct work_struct oplock_break; /* work for oplock breaks */
 };
 
-/* Take a reference on the file private data */
+/*
+ * Take a reference on the file private data. Must be called with
+ * cifs_file_list_lock held.
+ */
 static inline void cifsFileInfo_get(struct cifsFileInfo *cifs_file)
 {
-	atomic_inc(&cifs_file->count);
+	++cifs_file->count;
 }
 
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file);

commit cdff08e76612e53580139653403aedea979aa639
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Oct 21 22:46:14 2010 +0000

    [CIFS] move close processing  from cifs_close to cifsFileInfo_put
    
    Now that it's feasible for a cifsFileInfo to outlive the filp under
    which it was created, move the close processing into cifsFileInfo_put.
    
    This means that the last user of the filehandle always does the actual
    on the wire close call. This also allows us to get rid of the closePend
    flag from cifsFileInfo. If we have an active reference to the file
    then it's never going to have a close pending.
    
    cifs_close is converted to simply put the filehandle.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 28337cba0295..3365e77f6f24 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -393,7 +393,6 @@ struct cifsFileInfo {
 	struct tcon_link *tlink;
 	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */
-	bool closePend:1;	/* file is marked to close */
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
 	atomic_t count;		/* reference count */

commit 3f9bcca7820a6711307b6499952b13cfcfc31dd6
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Mon Oct 18 23:29:37 2010 +0530

    cifs: convert cifs_tcp_ses_lock from a rwlock to a spinlock
    
    cifs_tcp_ses_lock is a rwlock with protects the cifs_tcp_ses_list,
    server->smb_ses_list and the ses->tcon_list. It also protects a few
    ref counters in server, ses and tcon. In most cases the critical section
    doesn't seem to be large, in a few cases where it is slightly large, there
    seem to be really no benefit from concurrent access. I briefly considered RCU
    mechanism but it appears to me that there is no real need.
    
    Replace it with a spinlock and get rid of the last rwlock in the cifs code.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 18ee0adda306..28337cba0295 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -703,7 +703,7 @@ GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;
  * the reference counters for the server, smb session, and tcon. Finally,
  * changes to the tcon->tidStatus should be done while holding this lock.
  */
-GLOBAL_EXTERN rwlock_t		cifs_tcp_ses_lock;
+GLOBAL_EXTERN spinlock_t		cifs_tcp_ses_lock;
 
 /*
  * This lock protects the cifs_file->llist and cifs_file->flist

commit b33879aa834ebe03ced3dca4e3b822bd8894a474
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 15 15:34:04 2010 -0400

    cifs: move cifsFileInfo_put to file.c
    
    ...and make it non-inlined in preparation for the move of most of
    cifs_close to it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 53899a8d7c4a..18ee0adda306 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -408,15 +408,7 @@ static inline void cifsFileInfo_get(struct cifsFileInfo *cifs_file)
 	atomic_inc(&cifs_file->count);
 }
 
-/* Release a reference on the file private data */
-static inline void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
-{
-	if (atomic_dec_and_test(&cifs_file->count)) {
-		cifs_put_tlink(cifs_file->tlink);
-		dput(cifs_file->dentry);
-		kfree(cifs_file);
-	}
-}
+void cifsFileInfo_put(struct cifsFileInfo *cifs_file);
 
 /*
  * One of these for each file inode

commit 4477288a103631980750c86547d1fd54bfd2ba7d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 15 15:34:03 2010 -0400

    cifs: convert GlobalSMBSeslock from a rwlock to regular spinlock
    
    Convert this lock to a regular spinlock
    
    A rwlock_t offers little value here. It's more expensive than a regular
    spinlock unless you have a fairly large section of code that runs under
    the read lock and can benefit from the concurrency.
    
    Additionally, we need to ensure that the refcounting for files isn't
    racy and to do that we need to lock areas that can increment it for
    write. That means that the areas that can actually use a read_lock are
    very few and relatively infrequently used.
    
    While we're at it, change the name to something easier to type, and fix
    a bug in find_writable_file. cifsFileInfo_put can sleep and shouldn't be
    called while holding the lock.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9f99afab9a04..53899a8d7c4a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -720,7 +720,7 @@ GLOBAL_EXTERN rwlock_t		cifs_tcp_ses_lock;
  * If cifs_tcp_ses_lock and the lock below are both needed to be held, then
  * the cifs_tcp_ses_lock must be grabbed first and released last.
  */
-GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;
+GLOBAL_EXTERN spinlock_t	cifs_file_list_lock;
 
 /* Outstanding dir notify requests */
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;

commit 2e396b83f6087b78dac5a18d6d0cf9f8426a00b3
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 15 15:34:01 2010 -0400

    cifs: eliminate pfile pointer from cifsFileInfo
    
    All the remaining users of cifsFileInfo->pfile just use it to get
    at the f_flags/f_mode. Now that we store that separately in the
    cifsFileInfo, there's no need to consult the pfile at all from
    a cifsFileInfo pointer.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Acked-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b746dec88396..9f99afab9a04 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -388,7 +388,6 @@ struct cifsFileInfo {
 	__u16 netfid;		/* file id from remote */
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
-	struct file *pfile; /* needed for writepage */
 	struct dentry *dentry;
 	unsigned int f_flags;
 	struct tcon_link *tlink;

commit 15886177e412db00aa86155fe72608c4ebf5a08f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 15 15:33:59 2010 -0400

    cifs: clean up cifs_reopen_file
    
    Add a f_flags field that holds the f_flags field from the filp. We'll
    need this info in case the filp ever goes away before the cifsFileInfo
    does. Have cifs_reopen_file use that value instead of filp->f_flags
    too and have it take a cifsFileInfo arg instead of a filp.
    
    While we're at it, get rid of some bogus cargo-cult NULL pointer
    checks in that function and reduce the level of indentation.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Acked-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6c69bd762498..b746dec88396 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -390,6 +390,7 @@ struct cifsFileInfo {
 	/* lock scope id (0 if none) */
 	struct file *pfile; /* needed for writepage */
 	struct dentry *dentry;
+	unsigned int f_flags;
 	struct tcon_link *tlink;
 	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */

commit 5d0d28824c76409f0d1a645bf0ae81318c8ffa42
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Wed Oct 13 18:15:00 2010 -0500

    NTLM authentication and signing - Calculate auth response per smb session
    
    Start calculation auth response within a session.  Move/Add pertinet
    data structures like session key, server challenge and ntlmv2_hash in
    a session structure.  We should do the calculations within a session
    before copying session key and response over to server data
    structures because a session setup can fail.
    
    Only after a very first smb session succeeds, it copies/makes its
    session key, session key of smb connection.  This key stays with
    the smb connection throughout its life.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e2b760ef22ff..6c69bd762498 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -179,12 +179,10 @@ struct TCP_Server_Info {
 	int capabilities; /* allow selective disabling of caps by smb sess */
 	int timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u16 CurrentMid;         /* multiplex id - rotating counter */
-	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
 	struct session_key session_key;
-	char ntlmv2_hash[16];
 	unsigned long lstrp; /* when we got last response from this server */
 	u16 dialect; /* dialect index that server chose */
 	/* extended security flavors that server supports */
@@ -192,6 +190,7 @@ struct TCP_Server_Info {
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
 	bool	sec_kerberosu2u;	/* supports U2U Kerberos */
 	bool	sec_ntlmssp;		/* supports NTLMSSP */
+	bool session_estab; /* mark when very first sess is established */
 #ifdef CONFIG_CIFS_FSCACHE
 	struct fscache_cookie   *fscache; /* client index cache cookie */
 #endif
@@ -223,6 +222,9 @@ struct cifsSesInfo {
 	char userName[MAX_USERNAME_SIZE + 1];
 	char *domainName;
 	char *password;
+	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
+	struct session_key auth_key;
+	char ntlmv2_hash[16];
 	unsigned int tilen; /* length of the target info blob */
 	unsigned char *tiblob; /* target info blob in challenge response */
 	bool need_reconnect:1; /* connection reset, uid now invalid */

commit d7c86ff8cd00abc730fe5d031f43dc9138b6324e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Oct 11 15:07:19 2010 -0400

    cifs: don't use vfsmount to pin superblock for oplock breaks
    
    Filesystems aren't really supposed to do anything with a vfsmount. It's
    considered a layering violation since vfsmounts are entirely managed at
    the VFS layer.
    
    CIFS currently keeps an active reference to a vfsmount in order to
    prevent the superblock vanishing before an oplock break has completed.
    What we really want to do instead is to keep sb->s_active high until the
    oplock break has completed. This patch borrows the scheme that NFS uses
    for handling sillyrenames.
    
    An atomic_t is added to the cifs_sb_info. When it transitions from 0 to
    1, an extra reference to the superblock is taken (by bumping the
    s_active value). When it transitions from 1 to 0, that reference is
    dropped and a the superblock teardown may proceed if there are no more
    references to it.
    
    Also, the vfsmount pointer is removed from cifsFileInfo and from
    cifs_new_fileinfo, and some bogus forward declarations are removed from
    cifsfs.h.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Acked-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8289e61937a2..e2b760ef22ff 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -388,7 +388,6 @@ struct cifsFileInfo {
 	/* lock scope id (0 if none) */
 	struct file *pfile; /* needed for writepage */
 	struct dentry *dentry;
-	struct vfsmount *mnt;
 	struct tcon_link *tlink;
 	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */

commit a5e18bc36e9e05ce0338d370a2ce4290910e43ea
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Oct 11 15:07:18 2010 -0400

    cifs: keep dentry reference in cifsFileInfo instead of inode reference
    
    cifsFileInfo is a bit problematic. It contains a reference back to the
    struct file itself. This makes it difficult for a cifsFileInfo to exist
    without a corresponding struct file.
    
    It would be better instead of the cifsFileInfo just held info pertaining
    to the open file on the server instead without any back refrences to the
    struct file. This would allow it to exist after the filp to which it was
    originally attached was closed.
    
    Much of the use of the file pointer in this struct is to get at the
    dentry.  Begin divorcing the cifsFileInfo from the struct file by
    keeping a reference to the dentry. Since the dentry will have a
    reference to the inode, we can eliminate the "pInode" field too and
    convert the igrab/iput to dget/dput.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Acked-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4f85dfdf197d..8289e61937a2 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -387,7 +387,7 @@ struct cifsFileInfo {
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
 	struct file *pfile; /* needed for writepage */
-	struct inode *pInode; /* needed for oplock break */
+	struct dentry *dentry;
 	struct vfsmount *mnt;
 	struct tcon_link *tlink;
 	struct mutex lock_mutex;
@@ -412,7 +412,7 @@ static inline void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 {
 	if (atomic_dec_and_test(&cifs_file->count)) {
 		cifs_put_tlink(cifs_file->tlink);
-		iput(cifs_file->pInode);
+		dput(cifs_file->dentry);
 		kfree(cifs_file);
 	}
 }

commit 13cd4b7f7472eea7cbc1ab34e042842fbb902160
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Oct 7 18:46:32 2010 +0000

    [CIFS] Various small checkpatch cleanups
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9a7c472a153f..4f85dfdf197d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -517,16 +517,16 @@ struct oplock_q_entry {
 
 /* for pending dnotify requests */
 struct dir_notify_req {
-       struct list_head lhead;
-       __le16 Pid;
-       __le16 PidHigh;
-       __u16 Mid;
-       __u16 Tid;
-       __u16 Uid;
-       __u16 netfid;
-       __u32 filter; /* CompletionFilter (for multishot) */
-       int multishot;
-       struct file *pfile;
+	struct list_head lhead;
+	__le16 Pid;
+	__le16 PidHigh;
+	__u16 Mid;
+	__u16 Tid;
+	__u16 Uid;
+	__u16 netfid;
+	__u32 filter; /* CompletionFilter (for multishot) */
+	int multishot;
+	struct file *pfile;
 };
 
 struct dfs_info3_param {

commit 9d002df492b14c690425d9785530371b6c1ccbca
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 6 19:51:11 2010 -0400

    cifs: add routines to build sessions and tcons on the fly
    
    This patch is rather large, but it's a bit difficult to do piecemeal...
    
    For non-multiuser mounts, everything will basically work as it does
    today. A call to cifs_sb_tlink will return the "master" tcon link.
    
    Turn the tcon pointer in the cifs_sb into a radix tree that uses the
    fsuid of the process as a key. The value is a new "tcon_link" struct
    that contains info about a tcon that's under construction.
    
    When a new process needs a tcon, it'll call cifs_sb_tcon. That will
    then look up the tcon_link in the radix tree. If it exists and is
    valid, it's returned.
    
    If it doesn't exist, then we stuff a new tcon_link into the tree and
    mark it as pending and then go and try to build the session/tcon.
    If that works, the tcon pointer in the tcon_link is updated and the
    pending flag is cleared.
    
    If the construction fails, then we set the tcon pointer to an ERR_PTR
    and clear the pending flag.
    
    If the radix tree is searched and the tcon_link is marked pending
    then we go to sleep and wait for the pending flag to be cleared.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d5324853203b..9a7c472a153f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -317,42 +317,36 @@ struct cifsTconInfo {
  * "get" on the container.
  */
 struct tcon_link {
-	spinlock_t		tl_lock;
-	u32			tl_count;
-	u64			tl_time;
+	unsigned long		tl_index;
+	unsigned long		tl_flags;
+#define TCON_LINK_MASTER	0
+#define TCON_LINK_PENDING	1
+#define TCON_LINK_IN_TREE	2
+	unsigned long		tl_time;
+	atomic_t		tl_count;
 	struct cifsTconInfo	*tl_tcon;
 };
 
-static inline struct tcon_link *
-cifs_sb_tlink(struct cifs_sb_info *cifs_sb)
-{
-	return (struct tcon_link *)cifs_sb->ptcon;
-}
+extern struct tcon_link *cifs_sb_tlink(struct cifs_sb_info *cifs_sb);
 
 static inline struct cifsTconInfo *
 tlink_tcon(struct tcon_link *tlink)
 {
-	return (struct cifsTconInfo *)tlink;
+	return tlink->tl_tcon;
 }
 
-static inline void
-cifs_put_tlink(struct tcon_link *tlink)
-{
-	return;
-}
+extern void cifs_put_tlink(struct tcon_link *tlink);
 
 static inline struct tcon_link *
 cifs_get_tlink(struct tcon_link *tlink)
 {
+	if (tlink && !IS_ERR(tlink))
+		atomic_inc(&tlink->tl_count);
 	return tlink;
 }
 
 /* This function is always expected to succeed */
-static inline struct cifsTconInfo *
-cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)
-{
-	return cifs_sb->ptcon;
-}
+extern struct cifsTconInfo *cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb);
 
 /*
  * This info hangs off the cifsFileInfo structure, pointed to by llist.

commit 13cfb7334eb6fd0fc06da5589aea1e947791f1d6
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 29 19:51:11 2010 -0400

    cifs: have cifsFileInfo hold a reference to a tlink rather than tcon pointer
    
    cifsFileInfo needs a pointer to a tcon, but it doesn't currently hold a
    reference to it. Change it to keep a pointer to a tcon_link instead and
    hold a reference to it.
    
    That will keep the tcon from being freed until the file is closed.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cdfd2db4e70d..d5324853203b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -341,6 +341,12 @@ cifs_put_tlink(struct tcon_link *tlink)
 	return;
 }
 
+static inline struct tcon_link *
+cifs_get_tlink(struct tcon_link *tlink)
+{
+	return tlink;
+}
+
 /* This function is always expected to succeed */
 static inline struct cifsTconInfo *
 cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)
@@ -389,7 +395,7 @@ struct cifsFileInfo {
 	struct file *pfile; /* needed for writepage */
 	struct inode *pInode; /* needed for oplock break */
 	struct vfsmount *mnt;
-	struct cifsTconInfo *tcon;
+	struct tcon_link *tlink;
 	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */
 	bool closePend:1;	/* file is marked to close */
@@ -411,6 +417,7 @@ static inline void cifsFileInfo_get(struct cifsFileInfo *cifs_file)
 static inline void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 {
 	if (atomic_dec_and_test(&cifs_file->count)) {
+		cifs_put_tlink(cifs_file->tlink);
 		iput(cifs_file->pInode);
 		kfree(cifs_file);
 	}

commit 7ffec372458d163492e56e663a1b3a2d7be0a0a2
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 29 19:51:11 2010 -0400

    cifs: add refcounted and timestamped container for holding tcons
    
    Eventually, we'll need to track the use of tcons on a per-sb basis, so that
    we know when it's ok to tear them down. Begin this conversion by adding a
    new "tcon_link" struct and accessors that get it. For now, the core data
    structures are untouched -- cifs_sb still just points to a single tcon and
    the pointers are just cast to deal with the accessor functions. A later
    patch will flesh this out.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c265ebdcd177..cdfd2db4e70d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -310,6 +310,44 @@ struct cifsTconInfo {
 	/* BB add field for back pointer to sb struct(s)? */
 };
 
+/*
+ * This is a refcounted and timestamped container for a tcon pointer. The
+ * container holds a tcon reference. It is considered safe to free one of
+ * these when the tl_count goes to 0. The tl_time is the time of the last
+ * "get" on the container.
+ */
+struct tcon_link {
+	spinlock_t		tl_lock;
+	u32			tl_count;
+	u64			tl_time;
+	struct cifsTconInfo	*tl_tcon;
+};
+
+static inline struct tcon_link *
+cifs_sb_tlink(struct cifs_sb_info *cifs_sb)
+{
+	return (struct tcon_link *)cifs_sb->ptcon;
+}
+
+static inline struct cifsTconInfo *
+tlink_tcon(struct tcon_link *tlink)
+{
+	return (struct cifsTconInfo *)tlink;
+}
+
+static inline void
+cifs_put_tlink(struct tcon_link *tlink)
+{
+	return;
+}
+
+/* This function is always expected to succeed */
+static inline struct cifsTconInfo *
+cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)
+{
+	return cifs_sb->ptcon;
+}
+
 /*
  * This info hangs off the cifsFileInfo structure, pointed to by llist.
  * This is used to track byte stream locks on the file
@@ -413,19 +451,6 @@ CIFS_SB(struct super_block *sb)
 	return sb->s_fs_info;
 }
 
-static inline struct cifsTconInfo *
-cifs_sb_tcon(struct cifs_sb_info *cifs_sb)
-{
-	return cifs_sb->ptcon;
-}
-
-/* This function is always expected to succeed */
-static inline struct cifsTconInfo *
-cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)
-{
-	return cifs_sb->ptcon;
-}
-
 static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
 {
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)

commit 0d424ad0a4b8c08e45928bccfa5b4b240097b01b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 20 16:01:35 2010 -0700

    cifs: add cifs_sb_master_tcon and convert some callers to use it
    
    At mount time, we'll always need to create a tcon that will serve as a
    template for others that are associated with the mount. This tcon is
    known as the "master" tcon.
    
    In some cases, we'll need to use that tcon regardless of who's accessing
    the mount. Add an accessor function for the master tcon and go ahead and
    switch the appropriate places to use it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cc8300c741b6..c265ebdcd177 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -419,6 +419,13 @@ cifs_sb_tcon(struct cifs_sb_info *cifs_sb)
 	return cifs_sb->ptcon;
 }
 
+/* This function is always expected to succeed */
+static inline struct cifsTconInfo *
+cifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)
+{
+	return cifs_sb->ptcon;
+}
+
 static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
 {
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)

commit f6acb9d0596889a774e142ed76cb05b90d9763d2
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 20 16:01:34 2010 -0700

    cifs: temporarily rename cifs_sb->tcon to ptcon to catch stragglers
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c3510168438e..cc8300c741b6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -416,7 +416,7 @@ CIFS_SB(struct super_block *sb)
 static inline struct cifsTconInfo *
 cifs_sb_tcon(struct cifs_sb_info *cifs_sb)
 {
-	return cifs_sb->tcon;
+	return cifs_sb->ptcon;
 }
 
 static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)

commit a6e8a8455c94565c53e1a1756d2ab9d9e3a902b8
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 20 16:01:33 2010 -0700

    cifs: add function to get a tcon from cifs_sb
    
    When we convert cifs to do multiple sessions per mount, we'll need more
    than one tcon per superblock. At that point "cifs_sb->tcon" will make
    no sense. Add a new accessor function that gets a tcon given a cifs_sb.
    For now, it just returns cifs_sb->tcon. Later it'll do more.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6f3968a5fea4..c3510168438e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -413,6 +413,12 @@ CIFS_SB(struct super_block *sb)
 	return sb->s_fs_info;
 }
 
+static inline struct cifsTconInfo *
+cifs_sb_tcon(struct cifs_sb_info *cifs_sb)
+{
+	return cifs_sb->tcon;
+}
+
 static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
 {
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)

commit 5fe97cfddc426f3145e8673b68faab7e54462173
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 20 16:01:30 2010 -0700

    cifs: add tcon field to cifsFileInfo struct
    
    Eventually, we'll have more than one tcon per superblock. At that point,
    we'll need to know which one is associated with a particular fid. For
    now, this is just set from the cifs_sb->tcon pointer, but eventually
    the caller of cifs_new_fileinfo will pass a tcon pointer in.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6ef0efaf68d4..6f3968a5fea4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -351,6 +351,7 @@ struct cifsFileInfo {
 	struct file *pfile; /* needed for writepage */
 	struct inode *pInode; /* needed for oplock break */
 	struct vfsmount *mnt;
+	struct cifsTconInfo *tcon;
 	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */
 	bool closePend:1;	/* file is marked to close */

commit 3eb9a8893a76cf1cda3b41c3212eb2cfe83eae0e
Author: Ben Greear <greearb@candelatech.com>
Date:   Wed Sep 1 17:06:02 2010 -0700

    cifs: Allow binding to local IP address.
    
    When using multi-homed machines, it's nice to be able to specify
    the local IP to use for outbound connections.  This patch gives
    cifs the ability to bind to a particular IP address.
    
       Usage:  mount -t cifs -o srcaddr=192.168.1.50,user=foo, ...
       Usage:  mount -t cifs -o srcaddr=2002::100:1,user=foo, ...
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Dr. David Holder <david.holder@erion.co.uk>
    Signed-off-by: Ben Greear <greearb@candelatech.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c68f31cf4550..6ef0efaf68d4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -139,6 +139,7 @@ struct TCP_Server_Info {
 		struct sockaddr_in sockAddr;
 		struct sockaddr_in6 sockAddr6;
 	} addr;
+	struct sockaddr_storage srcaddr; /* locally bind to this IP */
 	wait_queue_head_t response_q;
 	wait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/
 	struct list_head pending_mid_q;

commit 2b149f11978b44199954710d32c0eecf6c9efd9c
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Sat Sep 18 22:02:18 2010 -0500

    cifs NTLMv2/NTLMSSP ntlmv2 within ntlmssp autentication code
    
    Attribue Value (AV) pairs or Target Info (TI) pairs are part of
    ntlmv2 authentication.
    Structure ntlmv2_resp had only definition for two av pairs.
    So removed it, and now allocation of av pairs is dynamic.
    For servers like Windows 7/2008, av pairs sent by server in
    challege packet (type 2 in the ntlmssp exchange/negotiation) can
    vary.
    
    Server sends them during ntlmssp negotiation. So when ntlmssp is used
    as an authentication mechanism, type 2 challenge packet from server
    has this information.  Pluck it and use the entire blob for
    authenticaiton purpose.  If user has not specified, extract
    (netbios) domain name from the av pairs which is used to calculate
    ntlmv2 hash.  Servers like Windows 7 are particular about the AV pair
    blob.
    
    Servers like Windows 2003, are not very strict about the contents
    of av pair blob used during ntlmv2 authentication.
    So when security mechanism such as ntlmv2 is used (not ntlmv2 in ntlmssp),
    there is no negotiation and so genereate a minimal blob that gets
    used in ntlmv2 authentication as well as gets sent.
    
    Fields tilen and tilbob are session specific.  AV pair values are defined.
    
    To calculate ntlmv2 response we need ti/av pair blob.
    
    For sec mech like ntlmssp, the blob is plucked from type 2 response from
    the server.  From this blob, netbios name of the domain is retrieved,
    if user has not already provided, to be included in the Target String
    as part of ntlmv2 hash calculations.
    
    For sec mech like ntlmv2, create a minimal, two av pair blob.
    
    The allocated blob is freed in case of error.  In case there is no error,
    this blob is used in calculating ntlmv2 response (in CalcNTLMv2_response)
    and is also copied on the response to the server, and then freed.
    
    The type 3 ntlmssp response is prepared on a buffer,
    5 * sizeof of struct _AUTHENTICATE_MESSAGE, an empirical value large
    enough to hold _AUTHENTICATE_MESSAGE plus a blob with max possible
    10 values as part of ntlmv2 response and lmv2 keys and domain, user,
    workstation  names etc.
    
    Also, kerberos gets selected as a default mechanism if server supports it,
    over the other security mechanisms.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 14dfa9a067e5..c68f31cf4550 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -222,6 +222,8 @@ struct cifsSesInfo {
 	char userName[MAX_USERNAME_SIZE + 1];
 	char *domainName;
 	char *password;
+	unsigned int tilen; /* length of the target info blob */
+	unsigned char *tiblob; /* target info blob in challenge response */
 	bool need_reconnect:1; /* connection reset, uid now invalid */
 };
 /* no more than one of the following three session flags may be set */

commit 5f98ca9afb9c004f8948c0d40920503de447918a
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Sat Sep 18 22:01:58 2010 -0500

    cifs NTLMv2/NTLMSSP Change variable name mac_key to session key to reflect the key it holds
    
    Change name of variable mac_key to session key.
    The reason mac_key was changed to session key is, this structure does not
    hold message authentication code, it holds the session key (for ntlmv2,
    ntlmv1 etc.).  mac is generated as a signature in cifs_calc* functions.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0cdfb8c32ac6..14dfa9a067e5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -97,7 +97,7 @@ enum protocolEnum {
 	/* Netbios frames protocol not supported at this time */
 };
 
-struct mac_key {
+struct session_key {
 	unsigned int len;
 	union {
 		char ntlm[CIFS_SESS_KEY_SIZE + 16];
@@ -182,7 +182,7 @@ struct TCP_Server_Info {
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
-	struct mac_key mac_signing_key;
+	struct session_key session_key;
 	char ntlmv2_hash[16];
 	unsigned long lstrp; /* when we got last response from this server */
 	u16 dialect; /* dialect index that server chose */

commit c8e56f1f4fb9f82f63e4ce6d73a14501d0432c76
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Sep 8 21:10:58 2010 +0000

    Revert "[CIFS] Fix ntlmv2 auth with ntlmssp"
    
    This reverts commit 9fbc590860e75785bdaf8b83e48fabfe4d4f7d58.
    
    The change to kernel crypto and fixes to ntlvm2 and ntlmssp
    series, introduced a regression.  Deferring this patch series
    to 2.6.37 after Shirish fixes it.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    CC: Shirish Pargaonkar <shirishp@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 49563e0c1725..0cdfb8c32ac6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -25,9 +25,6 @@
 #include <linux/workqueue.h>
 #include "cifs_fs_sb.h"
 #include "cifsacl.h"
-#include <crypto/internal/hash.h>
-#include <linux/scatterlist.h>
-
 /*
  * The sizes of various internal tables and strings
  */
@@ -100,7 +97,7 @@ enum protocolEnum {
 	/* Netbios frames protocol not supported at this time */
 };
 
-struct session_key {
+struct mac_key {
 	unsigned int len;
 	union {
 		char ntlm[CIFS_SESS_KEY_SIZE + 16];
@@ -123,14 +120,6 @@ struct cifs_cred {
 	struct cifs_ace *aces;
 };
 
-struct ntlmssp_auth {
-	__u32 client_flags;
-	__u32 server_flags;
-	unsigned char ciphertext[CIFS_CPHTXT_SIZE];
-	struct crypto_shash *hmacmd5;
-	struct crypto_shash *md5;
-};
-
 /*
  *****************************************************************
  * Except the CIFS PDUs themselves all the
@@ -193,14 +182,11 @@ struct TCP_Server_Info {
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
-	struct session_key session_key;
+	struct mac_key mac_signing_key;
 	char ntlmv2_hash[16];
 	unsigned long lstrp; /* when we got last response from this server */
 	u16 dialect; /* dialect index that server chose */
 	/* extended security flavors that server supports */
-	unsigned int tilen; /* length of the target info blob */
-	unsigned char *tiblob; /* target info blob in challenge response */
-	struct ntlmssp_auth ntlmssp; /* various keys, ciphers, flags */
 	bool	sec_kerberos;		/* supports plain Kerberos */
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
 	bool	sec_kerberosu2u;	/* supports U2U Kerberos */

commit 56234e2767496c125a858f880f1b3a62e04a3406
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Sep 8 20:57:05 2010 +0000

    Revert "Eliminate sparse warning - bad constant expression"
    
    This reverts commit 2d20ca835867d93ead6ce61780d883a4b128106d.
    
        The change to kernel crypto and fixes to ntlvm2 and ntlmssp
        series, introduced a regression.  Deferring this patch series
        to 2.6.37 after Shirish fixes it.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    CC: Shirish Pargaonkar <shirishp@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c9d0cfc086eb..49563e0c1725 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -123,19 +123,12 @@ struct cifs_cred {
 	struct cifs_ace *aces;
 };
 
-struct sdesc {
-	struct shash_desc shash;
-	char ctx[];
-};
-
 struct ntlmssp_auth {
 	__u32 client_flags;
 	__u32 server_flags;
 	unsigned char ciphertext[CIFS_CPHTXT_SIZE];
 	struct crypto_shash *hmacmd5;
 	struct crypto_shash *md5;
-	struct sdesc *sdeschmacmd5;
-	struct sdesc *sdescmd5;
 };
 
 /*

commit 2d20ca835867d93ead6ce61780d883a4b128106d
Author: shirishpargaonkar@gmail.com <shirishpargaonkar@gmail.com>
Date:   Tue Aug 24 11:53:48 2010 -0500

    Eliminate sparse warning - bad constant expression
    
    Eliminiate sparse warning during usage of crypto_shash_* APIs
           error: bad constant expression
    
    Allocate memory for shash descriptors once, so that we do not kmalloc/kfree it
    for every signature generation (shash descriptor for md5 hash).
    
    From ed7538619817777decc44b5660b52268077b74f3 Mon Sep 17 00:00:00 2001
    From: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Date: Tue, 24 Aug 2010 11:47:43 -0500
    Subject: [PATCH] eliminate sparse warnings during crypto_shash_* APis usage
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 49563e0c1725..c9d0cfc086eb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -123,12 +123,19 @@ struct cifs_cred {
 	struct cifs_ace *aces;
 };
 
+struct sdesc {
+	struct shash_desc shash;
+	char ctx[];
+};
+
 struct ntlmssp_auth {
 	__u32 client_flags;
 	__u32 server_flags;
 	unsigned char ciphertext[CIFS_CPHTXT_SIZE];
 	struct crypto_shash *hmacmd5;
 	struct crypto_shash *md5;
+	struct sdesc *sdeschmacmd5;
+	struct sdesc *sdescmd5;
 };
 
 /*

commit 9fbc590860e75785bdaf8b83e48fabfe4d4f7d58
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Aug 20 20:42:26 2010 +0000

    [CIFS] Fix ntlmv2 auth with ntlmssp
    
    Make ntlmv2 as an authentication mechanism within ntlmssp
    instead of ntlmv1.
    Parse type 2 response in ntlmssp negotiation to pluck
    AV pairs and use them to calculate ntlmv2 response token.
    Also, assign domain name from the sever response in type 2
    packet of ntlmssp and use that (netbios) domain name in
    calculation of response.
    
    Enable cifs/smb signing using rc4 and md5.
    
    Changed name of the structure mac_key to session_key to reflect
    the type of key it holds.
    
    Use kernel crypto_shash_* APIs instead of the equivalent cifs functions.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0cdfb8c32ac6..49563e0c1725 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -25,6 +25,9 @@
 #include <linux/workqueue.h>
 #include "cifs_fs_sb.h"
 #include "cifsacl.h"
+#include <crypto/internal/hash.h>
+#include <linux/scatterlist.h>
+
 /*
  * The sizes of various internal tables and strings
  */
@@ -97,7 +100,7 @@ enum protocolEnum {
 	/* Netbios frames protocol not supported at this time */
 };
 
-struct mac_key {
+struct session_key {
 	unsigned int len;
 	union {
 		char ntlm[CIFS_SESS_KEY_SIZE + 16];
@@ -120,6 +123,14 @@ struct cifs_cred {
 	struct cifs_ace *aces;
 };
 
+struct ntlmssp_auth {
+	__u32 client_flags;
+	__u32 server_flags;
+	unsigned char ciphertext[CIFS_CPHTXT_SIZE];
+	struct crypto_shash *hmacmd5;
+	struct crypto_shash *md5;
+};
+
 /*
  *****************************************************************
  * Except the CIFS PDUs themselves all the
@@ -182,11 +193,14 @@ struct TCP_Server_Info {
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
-	struct mac_key mac_signing_key;
+	struct session_key session_key;
 	char ntlmv2_hash[16];
 	unsigned long lstrp; /* when we got last response from this server */
 	u16 dialect; /* dialect index that server chose */
 	/* extended security flavors that server supports */
+	unsigned int tilen; /* length of the target info blob */
+	unsigned char *tiblob; /* target info blob in challenge response */
+	struct ntlmssp_auth ntlmssp; /* various keys, ciphers, flags */
 	bool	sec_kerberos;		/* supports plain Kerberos */
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
 	bool	sec_kerberosu2u;	/* supports U2U Kerberos */

commit 3b7433b8a8a83c87972065b1852b7dcae691e464
Merge: 4a386c3e177c 6ee0578b4daa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 12:42:58 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq: (55 commits)
      workqueue: mark init_workqueues() as early_initcall()
      workqueue: explain for_each_*cwq_cpu() iterators
      fscache: fix build on !CONFIG_SYSCTL
      slow-work: kill it
      gfs2: use workqueue instead of slow-work
      drm: use workqueue instead of slow-work
      cifs: use workqueue instead of slow-work
      fscache: drop references to slow-work
      fscache: convert operation to use workqueue instead of slow-work
      fscache: convert object to use workqueue instead of slow-work
      workqueue: fix how cpu number is stored in work->data
      workqueue: fix mayday_mask handling on UP
      workqueue: fix build problem on !CONFIG_SMP
      workqueue: fix locking in retry path of maybe_create_worker()
      async: use workqueue for worker pool
      workqueue: remove WQ_SINGLE_CPU and use WQ_UNBOUND instead
      workqueue: implement unbound workqueue
      workqueue: prepare for WQ_UNBOUND implementation
      libata: take advantage of cmwq and remove concurrency limitations
      workqueue: fix worker management invocation without pending works
      ...
    
    Fixed up conflicts in fs/cifs/* as per Tejun. Other trivial conflicts in
    include/linux/workqueue.h, kernel/trace/Kconfig and kernel/workqueue.c

commit 3e4b3e1f68c10510ec8d3076cffc5729b88f8de6
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Jul 19 18:00:17 2010 -0400

    cifs: add separate cred_uid field to sesInfo
    
    Right now, there's no clear separation between the uid that owns the
    credentials used to do the mount and the overriding owner of the files
    on that mount.
    
    Add a separate cred_uid field that is set to the real uid
    of the mount user. Unlike the linux_uid, the uid= option does not
    override this parameter. The parm is sent to cifs.upcall, which can then
    preferentially use the creduid= parm instead of the uid= parm for
    finding credentials.
    
    This is not the only way to solve this. We could try to do all of this
    in kernel instead by having a module parameter that affects what gets
    passed in the uid= field of the upcall. That said, we have a lot more
    flexibility to change things in userspace so I think it probably makes
    sense to do it this way.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9b7cf9aa3a00..59906146ad36 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -214,7 +214,8 @@ struct cifsSesInfo {
 	char *serverNOS;	/* name of network operating system of server */
 	char *serverDomain;	/* security realm of server */
 	int Suid;		/* remote smb uid  */
-	uid_t linux_uid;        /* local Linux uid */
+	uid_t linux_uid;        /* overriding owner of files on the mount */
+	uid_t cred_uid;		/* owner of credentials */
 	int capabilities;
 	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for
 				TCP names - will ipv6 and sctp addresses fit? */

commit 9451a9a52f91a4c171cfaca2f6d7a2ce91867b8d
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Mon Jul 5 18:12:45 2010 +0530

    cifs: define inode-level cache object and register them
    
    Define inode-level data storage objects (managed by cifsInodeInfo structs).
    Each inode-level object is created in a super-block level object and is itself
    a data storage object in to which pages from the inode are stored.
    
    The inode object is keyed by UniqueId. The coherency data being used is
    LastWriteTime, LastChangeTime and end of file reported by the server.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a3e403e7e163..9b7cf9aa3a00 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -390,6 +390,9 @@ struct cifsInodeInfo {
 	bool invalid_mapping:1;		/* pagecache is invalid */
 	u64  server_eof;		/* current file size on server */
 	u64  uniqueid;			/* server inode number */
+#ifdef CONFIG_CIFS_FSCACHE
+	struct fscache_cookie *fscache;
+#endif
 	struct inode vfs_inode;
 };
 

commit d03382ce9a89dbe27cba25130f0b90c0d631d5c5
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Mon Jul 5 18:12:27 2010 +0530

    cifs: define superblock-level cache index objects and register them
    
    Define superblock-level cache index objects (managed by cifsTconInfo structs).
    Each superblock object is created in a server-level index object and in itself
    an index into which inode-level objects are inserted.
    
    The superblock object is keyed by sharename. The UniqueId/IndexNumber is used to
    validate that the exported share is the same since we accessed it last time.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 793c8e3a0e53..a3e403e7e163 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -299,6 +299,10 @@ struct cifsTconInfo {
 	bool local_lease:1; /* check leases (only) on local system not remote */
 	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
 	bool need_reconnect:1; /* connection reset, tid now invalid */
+#ifdef CONFIG_CIFS_FSCACHE
+	u64 resource_id;		/* server resource id */
+	struct fscache_cookie *fscache;	/* cookie for share */
+#endif
 	/* BB add field for back pointer to sb struct(s)? */
 };
 

commit 8913007e67106597fed4b9dd3787e8dca6915a83
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jul 6 20:43:08 2010 -0400

    cifs: remove unused cifsUidInfo struct
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7b91cb4f0da4..793c8e3a0e53 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -196,19 +196,6 @@ struct TCP_Server_Info {
 #endif
 };
 
-/*
- * The following is our shortcut to user information.  We surface the uid,
- * and name. We always get the password on the fly in case it
- * has changed. We also hang a list of sessions owned by this user off here.
- */
-struct cifsUidInfo {
-	struct list_head userList;
-	struct list_head sessionList; /* SMB sessions for this user */
-	uid_t linux_uid;
-	char user[MAX_USERNAME_SIZE + 1];	/* ascii name of user */
-	/* BB may need ptr or callback for PAM or WinBind info */
-};
-
 /*
  * Session structure.  One of these for each uid session with a particular host
  */
@@ -216,9 +203,6 @@ struct cifsSesInfo {
 	struct list_head smb_ses_list;
 	struct list_head tcon_list;
 	struct mutex session_mutex;
-#if 0
-	struct cifsUidInfo *uidInfo;	/* pointer to user info */
-#endif
 	struct TCP_Server_Info *server;	/* pointer to server info */
 	int ses_count;		/* reference counter */
 	enum statusEnum status;

commit 4ff67b720c02c36e54d55b88c2931879b7db1cd2
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jul 6 20:43:02 2010 -0400

    cifs: clean up cifs_find_smb_ses (try #2)
    
    This patch replaces the earlier patch by the same name. The only
    difference is that MAX_PASSWORD_SIZE has been increased to attempt to
    match the limits that windows enforces.
    
    Do a better job of matching sessions by authtype. Matching by username
    for a Kerberos session is incorrect, and anonymous sessions need special
    handling.
    
    Also, in the case where we do match by username, we also need to match
    by password. That ensures that someone else doesn't "borrow" an existing
    session without needing to know the password.
    
    Finally, passwords can be longer than 16 bytes. Bump MAX_PASSWORD_SIZE
    to 512 to match the size that the userspace mount helper allows.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8fb1d10b8742..7b91cb4f0da4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -37,7 +37,7 @@
 #define MAX_SHARE_SIZE  64	/* used to be 20, this should still be enough */
 #define MAX_USERNAME_SIZE 32	/* 32 is to allow for 15 char names + null
 				   termination then *2 for unicode versions */
-#define MAX_PASSWORD_SIZE 16
+#define MAX_PASSWORD_SIZE 512  /* max for windows seems to be 256 wide chars */
 
 #define CIFS_MIN_RCV_POOL 4
 

commit daf5b0b6f3f6d7b15c2600426cc6c60a0e155218
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jul 6 20:43:02 2010 -0400

    cifs: match secType when searching for existing tcp session
    
    The secType is a per-tcp session entity, but the current routine doesn't
    verify that it is acceptible when attempting to match an existing TCP
    session.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 06b48998db94..8fb1d10b8742 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -83,8 +83,7 @@ enum statusEnum {
 };
 
 enum securityEnum {
-	PLAINTXT = 0, 		/* Legacy with Plaintext passwords */
-	LANMAN,			/* Legacy LANMAN auth */
+	LANMAN = 0,			/* Legacy LANMAN auth */
 	NTLM,			/* Legacy NTLM012 auth with NTLM hash */
 	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
 	RawNTLMSSP,		/* NTLMSSP without SPNEGO, NTLMv2 hash */

commit 488f1d2d6cc9d665c9f09e4b54f77052732e3058
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Mon Jul 5 18:12:15 2010 +0530

    cifs: define server-level cache index objects and register them
    
    Define server-level cache index objects (as managed by TCP_ServerInfo structs)
    and register then with FS-Cache. Each server object is created in the CIFS
    top-level index object and is itself an index into which superblock-level
    objects are inserted.
    
    The server objects are now keyed by {IPaddress,family,port} tuple.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6113427651c4..06b48998db94 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -192,6 +192,9 @@ struct TCP_Server_Info {
 	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
 	bool	sec_kerberosu2u;	/* supports U2U Kerberos */
 	bool	sec_ntlmssp;		/* supports NTLMSSP */
+#ifdef CONFIG_CIFS_FSCACHE
+	struct fscache_cookie   *fscache; /* client index cache cookie */
+#endif
 };
 
 /*

commit c6332e237fb2ee54bc9c614291a006e4801e0f66
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Tue Jul 6 17:59:46 2010 +0530

    cifs: remove unused ip_address field in struct TCP_Server_Info
    
    The ip_address field is not used and seems redundant as there is union addr
    already and I don't see any future use as well.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6b2c39d809fb..6113427651c4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -145,7 +145,6 @@ struct TCP_Server_Info {
 	struct list_head pending_mid_q;
 	void *Server_NlsInfo;	/* BB - placeholder for future NLS info  */
 	unsigned short server_codepage;	/* codepage for the server    */
-	unsigned long ip_address;	/* IP addr for the server if known */
 	enum protocolEnum protocolType;
 	char versionMajor;
 	char versionMinor;

commit abd2e44dca2c5d65e047224c6ba4b4c8059f97f8
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Tue Jun 22 20:52:50 2010 +0530

    cifs: guard cifsglob.h against multiple inclusion
    
    Add conditional compile macros to guard the header file against multiple
    inclusion.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a88479ceaad5..6b2c39d809fb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -16,6 +16,9 @@
  *   the GNU Lesser General Public License for more details.
  *
  */
+#ifndef _CIFS_GLOB_H
+#define _CIFS_GLOB_H
+
 #include <linux/in.h>
 #include <linux/in6.h>
 #include <linux/slab.h>
@@ -733,3 +736,5 @@ GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
 GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
+
+#endif	/* _CIFS_GLOB_H */

commit 9b646972467fb5fdc677f9e4251875db20bdbb64
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 20 22:09:02 2010 +0200

    cifs: use workqueue instead of slow-work
    
    Workqueue can now handle high concurrency.  Use system_nrt_wq
    instead of slow-work.
    
    * Updated is_valid_oplock_break() to not call cifs_oplock_break_put()
      as advised by Steve French.  It might cause deadlock.  Instead,
      reference is increased after queueing succeeded and
      cifs_oplock_break() briefly grabs GlobalSMBSeslock before putting
      the cfile to make sure it doesn't put before the matching get is
      finished.
    
    * Anton Blanchard reported that cifs conversion was using now gone
      system_single_wq.  Use system_nrt_wq which provides non-reentrance
      guarantee which is enough and much better.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Steve French <sfrench@samba.org>
    Cc: Anton Blanchard <anton@samba.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a88479ceaad5..f5a1f9bb3a9f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -19,7 +19,7 @@
 #include <linux/in.h>
 #include <linux/in6.h>
 #include <linux/slab.h>
-#include <linux/slow-work.h>
+#include <linux/workqueue.h>
 #include "cifs_fs_sb.h"
 #include "cifsacl.h"
 /*
@@ -363,7 +363,7 @@ struct cifsFileInfo {
 	atomic_t count;		/* reference count */
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
-	struct slow_work oplock_break; /* slow_work job for oplock breaks */
+	struct work_struct oplock_break; /* work for oplock breaks */
 };
 
 /* Take a reference on the file private data */
@@ -732,4 +732,6 @@ GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
 GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
 GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
 
-extern const struct slow_work_ops cifs_oplock_break_ops;
+void cifs_oplock_break(struct work_struct *work);
+void cifs_oplock_break_get(struct cifsFileInfo *cfile);
+void cifs_oplock_break_put(struct cifsFileInfo *cfile);

commit baa456331738b4e76a92318b62b354377a30ad80
Merge: aa3e5572c538 4462dc028426
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu May 13 22:19:32 2010 +0000

    Merge branch 'master' of /pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
            fs/cifs/inode.c

commit 3d69438031b00c601c991ab447cafb7d5c3c59a6
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue May 11 14:59:55 2010 -0400

    cifs: guard against hardlinking directories
    
    When we made serverino the default, we trusted that the field sent by the
    server in the "uniqueid" field was actually unique. It turns out that it
    isn't reliably so.
    
    Samba, in particular, will just put the st_ino in the uniqueid field when
    unix extensions are enabled. When a share spans multiple filesystems, it's
    quite possible that there will be collisions. This is a server bug, but
    when the inodes in question are a directory (as is often the case) and
    there is a collision with the root inode of the mount, the result is a
    kernel panic on umount.
    
    Fix this by checking explicitly for directory inodes with the same
    uniqueid. If that is the case, then we can assume that using server inode
    numbers will be a problem and that they should be disabled.
    
    Fixes Samba bugzilla 7407
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    CC: Stable <stable@kernel.org>
    Reviewed-and-Tested-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ecf0ffbe2b64..0c2fd17439c8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -502,6 +502,7 @@ struct dfs_info3_param {
 #define CIFS_FATTR_DFS_REFERRAL		0x1
 #define CIFS_FATTR_DELETE_PENDING	0x2
 #define CIFS_FATTR_NEED_REVAL		0x4
+#define CIFS_FATTR_INO_COLLISION	0x8
 
 struct cifs_fattr {
 	u32		cf_flags;

commit 26efa0bac9dc3587ee8892c06642735bcded59e5
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Apr 24 07:57:49 2010 -0400

    cifs: have decode_negTokenInit set flags in server struct
    
    ...rather than the secType. This allows us to get rid of the MSKerberos
    securityEnum. The client just makes a decision at upcall time.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c412568b4a1a..4a99487400f3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -87,7 +87,6 @@ enum securityEnum {
 	RawNTLMSSP,		/* NTLMSSP without SPNEGO, NTLMv2 hash */
 /*	NTLMSSP, */ /* can use rawNTLMSSP instead of NTLMSSP via SPNEGO */
 	Kerberos,		/* Kerberos via SPNEGO */
-	MSKerberos,		/* MS Kerberos via SPNEGO */
 };
 
 enum protocolEnum {
@@ -186,6 +185,11 @@ struct TCP_Server_Info {
 	char ntlmv2_hash[16];
 	unsigned long lstrp; /* when we got last response from this server */
 	u16 dialect; /* dialect index that server chose */
+	/* extended security flavors that server supports */
+	bool	sec_kerberos;		/* supports plain Kerberos */
+	bool	sec_mskerberos;		/* supports legacy MS Kerberos */
+	bool	sec_kerberosu2u;	/* supports U2U Kerberos */
+	bool	sec_ntlmssp;		/* supports NTLMSSP */
 };
 
 /*

commit 9bf67e516f16d31f86aa6f063576a959bbf19990
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Apr 24 07:57:46 2010 -0400

    cifs: save the dialect chosen by server
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4a2715b389c6..c412568b4a1a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -185,6 +185,7 @@ struct TCP_Server_Info {
 	struct mac_key mac_signing_key;
 	char ntlmv2_hash[16];
 	unsigned long lstrp; /* when we got last response from this server */
+	u16 dialect; /* dialect index that server chose */
 };
 
 /*

commit 04912d6a20185473db025061b9b2c81fbdffc48b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Apr 24 07:57:45 2010 -0400

    cifs: rename "extended_security" to "global_secflags"
    
    ...since that more accurately describes what that variable holds.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ecf0ffbe2b64..4a2715b389c6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -717,7 +717,7 @@ GLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions
 GLOBAL_EXTERN unsigned int oplockEnabled;
 GLOBAL_EXTERN unsigned int experimEnabled;
 GLOBAL_EXTERN unsigned int lookupCacheEnabled;
-GLOBAL_EXTERN unsigned int extended_security;	/* if on, session setup sent
+GLOBAL_EXTERN unsigned int global_secflags;	/* if on, session setup sent
 				with more secure ntlmssp2 challenge/resp */
 GLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
 GLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 63c89d1d70b5..ecf0ffbe2b64 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -18,6 +18,7 @@
  */
 #include <linux/in.h>
 #include <linux/in6.h>
+#include <linux/slab.h>
 #include <linux/slow-work.h>
 #include "cifs_fs_sb.h"
 #include "cifsacl.h"

commit df2cf170c823ba779ca339e3ede347c87f4dc6a9
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Feb 12 07:44:16 2010 -0500

    cifs: overhaul cifs_revalidate and rename to cifs_revalidate_dentry
    
    cifs_revalidate is renamed to cifs_revalidate_dentry as a later patch
    will add a by-filehandle variant.
    
    Add a new "invalid_mapping" flag to the cifsInodeInfo that indicates
    that the pagecache is considered invalid. Add a new routine to check
    inode attributes whenever they're updated and set that flag if the inode
    has changed on the server.
    
    cifs_revalidate_dentry is then changed to just update the attrcache if
    needed and then to zap the pagecache if it's not valid.
    
    There are some other behavior changes in here as well. Open files are
    now allowed to have their caches invalidated. I see no reason why we'd
    want to keep stale data around just because a file is open. Also,
    cifs_revalidate_cache uses the server_eof for revalidating the file
    size since that should more closely match the size of the file on the
    server.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a1c817eb291a..63c89d1d70b5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -389,6 +389,7 @@ struct cifsInodeInfo {
 	bool clientCanCacheRead:1;	/* read oplock */
 	bool clientCanCacheAll:1;	/* read and writebehind oplock */
 	bool delete_pending:1;		/* DELETE_ON_CLOSE is set */
+	bool invalid_mapping:1;		/* pagecache is invalid */
 	u64  server_eof;		/* current file size on server */
 	u64  uniqueid;			/* server inode number */
 	struct inode vfs_inode;

commit d7b619cf56218704ffce9d510aa497f0a0bcda0b
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Feb 25 05:36:46 2010 +0000

    [CIFS] pSesInfo->sesSem is used as mutex. Rename it to session_mutex and
    convert it to a real mutex.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index ed751bb657db..a1c817eb291a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -205,7 +205,7 @@ struct cifsUidInfo {
 struct cifsSesInfo {
 	struct list_head smb_ses_list;
 	struct list_head tcon_list;
-	struct semaphore sesSem;
+	struct mutex session_mutex;
 #if 0
 	struct cifsUidInfo *uidInfo;	/* pointer to user info */
 #endif

commit 6a5fa2362b628ee950080bef8895a6fb62f58ab4
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Jan 1 01:28:43 2010 +0000

    [CIFS] Add support for TCP_NODELAY
    
    mount option sockopt=TCP_NODELAY helpful for faster networks
    boosting performance.  Kernel bugzilla bug number 14032.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4b35f7ec0583..ed751bb657db 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -149,6 +149,7 @@ struct TCP_Server_Info {
 	bool svlocal:1;			/* local server or remote */
 	bool noblocksnd;		/* use blocking sendmsg */
 	bool noautotune;		/* do not autotune send buf sizes */
+	bool tcp_nodelay;
 	atomic_t inFlight;  /* number of requests on the wire to server */
 #ifdef CONFIG_CIFS_STATS2
 	atomic_t inSend; /* requests trying to send */

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5d0fde18039c..4b35f7ec0583 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -39,7 +39,7 @@
 
 /*
  * MAX_REQ is the maximum number of requests that WE will send
- * on one socket concurently. It also matches the most common
+ * on one socket concurrently. It also matches the most common
  * value of max multiplex returned by servers.  We may
  * eventually want to use the negotiated value (in case
  * future servers can handle more) when we are more confident that

commit 3bc303c254335dbd7c7012cc1760b12f1d5514d3
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 21 06:47:50 2009 -0400

    cifs: convert oplock breaks to use slow_work facility (try #4)
    
    This is the fourth respin of the patch to convert oplock breaks to
    use the slow_work facility.
    
    A customer of ours was testing a backport of one of the earlier
    patchsets, and hit a "Busy inodes after umount..." problem. An oplock
    break job had raced with a umount, and the superblock got torn down and
    its memory reused. When the oplock break job tried to dereference the
    inode->i_sb, the kernel oopsed.
    
    This patchset has the oplock break job hold an inode and vfsmount
    reference until the oplock break completes.  With this, there should be
    no need to take a tcon reference (the vfsmount implicitly holds one
    already).
    
    Currently, when an oplock break comes in there's a chance that the
    oplock break job won't occur if the allocation of the oplock_q_entry
    fails. There are also some rather nasty races in the allocation and
    handling these structs.
    
    Rather than allocating oplock queue entries when an oplock break comes
    in, add a few extra fields to the cifsFileInfo struct. Get rid of the
    dedicated cifs_oplock_thread as well and queue the oplock break job to
    the slow_work thread pool.
    
    This approach also has the advantage that the oplock break jobs can
    potentially run in parallel rather than be serialized like they are
    today.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c19419a38f62..5d0fde18039c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -18,6 +18,7 @@
  */
 #include <linux/in.h>
 #include <linux/in6.h>
+#include <linux/slow-work.h>
 #include "cifs_fs_sb.h"
 #include "cifsacl.h"
 /*
@@ -346,14 +347,16 @@ struct cifsFileInfo {
 	/* lock scope id (0 if none) */
 	struct file *pfile; /* needed for writepage */
 	struct inode *pInode; /* needed for oplock break */
+	struct vfsmount *mnt;
 	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */
 	bool closePend:1;	/* file is marked to close */
 	bool invalidHandle:1;	/* file closed via session abend */
-	bool messageMode:1;	/* for pipes: message vs byte mode */
+	bool oplock_break_cancelled:1;
 	atomic_t count;		/* reference count */
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
+	struct slow_work oplock_break; /* slow_work job for oplock breaks */
 };
 
 /* Take a reference on the file private data */
@@ -670,12 +673,6 @@ GLOBAL_EXTERN rwlock_t		cifs_tcp_ses_lock;
  */
 GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;
 
-/* Global list of oplocks */
-GLOBAL_EXTERN struct list_head cifs_oplock_list;
-
-/* Protects the cifs_oplock_list */
-GLOBAL_EXTERN spinlock_t cifs_oplock_lock;
-
 /* Outstanding dir notify requests */
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;
 /* DirNotify response queue */
@@ -726,3 +723,4 @@ GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
 GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
 GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
 
+extern const struct slow_work_ops cifs_oplock_break_ops;

commit 48541bd3dd4739b4d574b44ea47660c88d833677
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Sep 12 11:54:29 2009 -0400

    cifs: have cifsFileInfo hold an extra inode reference
    
    It's possible that this struct will outlive the filp to which it is
    attached. If it does and it needs to do some work on the inode, then
    it'll need a reference.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9a7527dc977e..c19419a38f62 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -365,8 +365,10 @@ static inline void cifsFileInfo_get(struct cifsFileInfo *cifs_file)
 /* Release a reference on the file private data */
 static inline void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 {
-	if (atomic_dec_and_test(&cifs_file->count))
+	if (atomic_dec_and_test(&cifs_file->count)) {
+		iput(cifs_file->pInode);
 		kfree(cifs_file);
+	}
 }
 
 /*

commit 495e993745a722cfa54d76b97d18e8f30c3e6cea
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Sep 12 11:54:29 2009 -0400

    cifs: remove cifsInodeInfo.oplockPending flag
    
    It's set on oplock break but nothing ever looks at it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a03482298ed9..9a7527dc977e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -382,7 +382,6 @@ struct cifsInodeInfo {
 	unsigned long time;	/* jiffies of last update/check of inode */
 	bool clientCanCacheRead:1;	/* read oplock */
 	bool clientCanCacheAll:1;	/* read and writebehind oplock */
-	bool oplockPending:1;
 	bool delete_pending:1;		/* DELETE_ON_CLOSE is set */
 	u64  server_eof;		/* current file size on server */
 	u64  uniqueid;			/* server inode number */

commit 20d1752f3d6bd32beb90949559e0d14a0b234445
Author: Chuck Ebbert <cebbert@redhat.com>
Date:   Tue Sep 15 01:53:21 2009 -0400

    [CIFS] Re-enable Lanman security
    
    commit ac68392460ffefed13020967bae04edc4d3add06 ("[CIFS] Allow raw
    ntlmssp code to be enabled with sec=ntlmssp") added a new bit to the
    allowed security flags mask but seems to have inadvertently removed
    Lanman security from the allowed flags. Add it back.
    
    CC: Stable <stable@kernel.org>
    Signed-off-by: Chuck Ebbert <cebbert@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6cfc81a32703..a03482298ed9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -585,9 +585,9 @@ require use of the stronger protocol */
 #define   CIFSSEC_MUST_LANMAN	0x10010
 #define   CIFSSEC_MUST_PLNTXT	0x20020
 #ifdef CONFIG_CIFS_UPCALL
-#define   CIFSSEC_MASK          0xAF0AF /* allows weak security but also krb5 */
+#define   CIFSSEC_MASK          0xBF0BF /* allows weak security but also krb5 */
 #else
-#define   CIFSSEC_MASK          0xA70A7 /* current flags supported if weak */
+#define   CIFSSEC_MASK          0xB70B7 /* current flags supported if weak */
 #endif /* UPCALL */
 #else /* do not allow weak pw hash */
 #ifdef CONFIG_CIFS_UPCALL

commit 6ab409b53dcaf28f83d518a6702f904b7cee3f41
Author: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
Date:   Mon Aug 31 11:07:12 2009 -0400

    cifs: Replace wrtPending with a real reference count
    
    Currently, cifs_close() tries to wait until all I/O is complete and then
    frees the file private data.  If I/O does not completely in a reasonable
    amount of time it frees the structure anyway, leaving a potential use-
    after-free situation.
    
    This patch changes the wrtPending counter to a complete reference count and
    lets the last user free the structure.
    
    Signed-off-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Tested-by: Shirish Pargaonkar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f100399ee05e..6cfc81a32703 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -351,11 +351,24 @@ struct cifsFileInfo {
 	bool closePend:1;	/* file is marked to close */
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool messageMode:1;	/* for pipes: message vs byte mode */
-	atomic_t wrtPending;   /* handle in use - defer close */
+	atomic_t count;		/* reference count */
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 };
 
+/* Take a reference on the file private data */
+static inline void cifsFileInfo_get(struct cifsFileInfo *cifs_file)
+{
+	atomic_inc(&cifs_file->count);
+}
+
+/* Release a reference on the file private data */
+static inline void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
+{
+	if (atomic_dec_and_test(&cifs_file->count))
+		kfree(cifs_file);
+}
+
 /*
  * One of these for each file inode
  */

commit 1b49c5566136455764a8d17ead25784f534c202d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Aug 28 10:11:11 2009 -0400

    cifs: protect GlobalOplock_Q with its own spinlock
    
    Right now, the GlobalOplock_Q is protected by the GlobalMid_Lock. That
    lock is also used for completely unrelated purposes (mostly for managing
    the global mid queue). Give the list its own dedicated spinlock
    (cifs_oplock_lock) and rename the list to cifs_oplock_list to
    eliminate the camel-case.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6084d6379c03..f100399ee05e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -656,7 +656,11 @@ GLOBAL_EXTERN rwlock_t		cifs_tcp_ses_lock;
  */
 GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;
 
-GLOBAL_EXTERN struct list_head GlobalOplock_Q;
+/* Global list of oplocks */
+GLOBAL_EXTERN struct list_head cifs_oplock_list;
+
+/* Protects the cifs_oplock_list */
+GLOBAL_EXTERN spinlock_t cifs_oplock_lock;
 
 /* Outstanding dir notify requests */
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;

commit 65bc98b0059360e458aebd208587be44641227c1
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Jul 10 15:27:25 2009 +0000

    [CIFS] Distinguish posix opens and mkdirs from legacy mkdirs in stats
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 63f6cdfa5638..6084d6379c03 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -260,6 +260,8 @@ struct cifsTconInfo {
 	atomic_t num_closes;
 	atomic_t num_deletes;
 	atomic_t num_mkdirs;
+	atomic_t num_posixopens;
+	atomic_t num_posixmkdirs;
 	atomic_t num_rmdirs;
 	atomic_t num_renames;
 	atomic_t num_t2renames;

commit aeaaf253c4dee7ff9af2f3f0595f3bb66964e944
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jul 9 01:46:39 2009 -0400

    cifs: remove cifsInodeInfo->inUse counter
    
    cifs: remove cifsInodeInfo->inUse counter
    
    It was purported to be a refcounter of some sort, but was never
    used that way. It never served any purpose that wasn't served equally well
    by the I_NEW flag.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8bcf5a4bcded..63f6cdfa5638 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -364,7 +364,6 @@ struct cifsInodeInfo {
 	struct list_head openFileList;
 	int write_behind_rc;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
-	atomic_t inUse;	 /* num concurrent users (local openers cifs) of file*/
 	unsigned long time;	/* jiffies of last update/check of inode */
 	bool clientCanCacheRead:1;	/* read oplock */
 	bool clientCanCacheAll:1;	/* read and writebehind oplock */

commit 0b8f18e358384a52c1ed7fa7129c08e7eaf86bb6
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jul 9 01:46:37 2009 -0400

    cifs: convert cifs_get_inode_info and non-posix readdir to use cifs_iget
    
    cifs: convert cifs_get_inode_info and non-posix readdir to use cifs_iget
    
    Rather than allocating an inode and filling it out, have
    cifs_get_inode_info fill out a cifs_fattr and call cifs_iget. This means
    a pretty hefty reorganization of cifs_get_inode_info.
    
    For the readdir codepath, add a couple of new functions for filling out
    cifs_fattr's from different FindFile response infolevels.
    
    Finally, remove cifs_new_inode since there are no more callers.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e6435cba8113..8bcf5a4bcded 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -479,6 +479,8 @@ struct dfs_info3_param {
  */
 
 #define CIFS_FATTR_DFS_REFERRAL		0x1
+#define CIFS_FATTR_DELETE_PENDING	0x2
+#define CIFS_FATTR_NEED_REVAL		0x4
 
 struct cifs_fattr {
 	u32		cf_flags;

commit cc0bad7552308e8905d6ea56e6b7811fa67e716d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jun 25 00:56:52 2009 -0400

    cifs: add new cifs_iget function and convert unix codepath to use it
    
    cifs: add new cifs_iget function and convert unix codepath to use it
    
    In order to unify some codepaths, introduce a common cifs_fattr struct
    for storing inode attributes. The different codepaths (unix, legacy,
    normal, etc...) can fill out this struct with inode info. It can then be
    passed as an arg to a common set of routines to get and update inodes.
    
    Add a new cifs_iget function that uses iget5_locked to identify inodes.
    This will compare inodes based on the uniqueid value in a cifs_fattr
    struct.
    
    Rather than filling out an already-created inode, have
    cifs_get_inode_info_unix instead fill out cifs_fattr and hand that off
    to cifs_iget. cifs_iget can then properly look for hardlinked inodes.
    
    On the readdir side, add a new cifs_readdir_lookup function that spawns
    populated dentries. Redefine FILE_UNIX_INFO so that it's basically a
    FILE_UNIX_BASIC_INFO that has a few fields wrapped around it. This
    allows us to more easily use the same function for filling out the fattr
    as the non-readdir codepath.
    
    With this, we should then have proper hardlink detection and can
    eventually get rid of some nasty CIFS-specific hacks for handing them.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e1225e6ded2f..e6435cba8113 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -371,6 +371,7 @@ struct cifsInodeInfo {
 	bool oplockPending:1;
 	bool delete_pending:1;		/* DELETE_ON_CLOSE is set */
 	u64  server_eof;		/* current file size on server */
+	u64  uniqueid;			/* server inode number */
 	struct inode vfs_inode;
 };
 
@@ -472,6 +473,30 @@ struct dfs_info3_param {
 	char *node_name;
 };
 
+/*
+ * common struct for holding inode info when searching for or updating an
+ * inode with new info
+ */
+
+#define CIFS_FATTR_DFS_REFERRAL		0x1
+
+struct cifs_fattr {
+	u32		cf_flags;
+	u32		cf_cifsattrs;
+	u64		cf_uniqueid;
+	u64		cf_eof;
+	u64		cf_bytes;
+	uid_t		cf_uid;
+	gid_t		cf_gid;
+	umode_t		cf_mode;
+	dev_t		cf_rdev;
+	unsigned int	cf_nlink;
+	unsigned int	cf_dtype;
+	struct timespec	cf_atime;
+	struct timespec	cf_mtime;
+	struct timespec	cf_ctime;
+};
+
 static inline void free_dfs_info_param(struct dfs_info3_param *param)
 {
 	if (param) {

commit f46c7234e472ceee39afea4fb5a4365843e1850a
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jun 25 03:04:20 2009 +0000

    [CIFS] cleanup asn handling for ntlmssp
    
    Also removes obsolete distinction between rawntlmssp and ntlmssp (in asn/SPNEGO)
    since as jra noted we can always send raw ntlmssp in session setup now.
    
    remove check for experimental runtime flag (/proc/fs/cifs/Experimental) in
    ntlmssp path.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a61ab772c6f6..e1225e6ded2f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -83,7 +83,7 @@ enum securityEnum {
 	NTLM,			/* Legacy NTLM012 auth with NTLM hash */
 	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
 	RawNTLMSSP,		/* NTLMSSP without SPNEGO, NTLMv2 hash */
-	NTLMSSP,		/* NTLMSSP via SPNEGO, NTLMv2 hash */
+/*	NTLMSSP, */ /* can use rawNTLMSSP instead of NTLMSSP via SPNEGO */
 	Kerberos,		/* Kerberos via SPNEGO */
 	MSKerberos,		/* MS Kerberos via SPNEGO */
 };

commit ac68392460ffefed13020967bae04edc4d3add06
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed May 6 04:16:04 2009 +0000

    [CIFS] Allow raw ntlmssp code to be enabled with sec=ntlmssp
    
    On mount, "sec=ntlmssp" can now be specified to allow
    "rawntlmssp" security to be enabled during
    CIFS session establishment/authentication (ntlmssp used to
    require specifying krb5 which was counterintuitive).
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index df40ab64cd95..a61ab772c6f6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -82,8 +82,8 @@ enum securityEnum {
 	LANMAN,			/* Legacy LANMAN auth */
 	NTLM,			/* Legacy NTLM012 auth with NTLM hash */
 	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
-	RawNTLMSSP,		/* NTLMSSP without SPNEGO */
-	NTLMSSP,		/* NTLMSSP via SPNEGO */
+	RawNTLMSSP,		/* NTLMSSP without SPNEGO, NTLMv2 hash */
+	NTLMSSP,		/* NTLMSSP via SPNEGO, NTLMv2 hash */
 	Kerberos,		/* Kerberos via SPNEGO */
 	MSKerberos,		/* MS Kerberos via SPNEGO */
 };
@@ -531,6 +531,7 @@ static inline void free_dfs_info_array(struct dfs_info3_param *param,
 #define   CIFSSEC_MAY_PLNTXT    0
 #endif /* weak passwords */
 #define   CIFSSEC_MAY_SEAL	0x00040 /* not supported yet */
+#define   CIFSSEC_MAY_NTLMSSP	0x00080 /* raw ntlmssp with ntlmv2 */
 
 #define   CIFSSEC_MUST_SIGN	0x01001
 /* note that only one of the following can be set so the
@@ -543,22 +544,23 @@ require use of the stronger protocol */
 #define   CIFSSEC_MUST_LANMAN	0x10010
 #define   CIFSSEC_MUST_PLNTXT	0x20020
 #ifdef CONFIG_CIFS_UPCALL
-#define   CIFSSEC_MASK          0x3F03F /* allows weak security but also krb5 */
+#define   CIFSSEC_MASK          0xAF0AF /* allows weak security but also krb5 */
 #else
-#define   CIFSSEC_MASK          0x37037 /* current flags supported if weak */
+#define   CIFSSEC_MASK          0xA70A7 /* current flags supported if weak */
 #endif /* UPCALL */
 #else /* do not allow weak pw hash */
 #ifdef CONFIG_CIFS_UPCALL
-#define   CIFSSEC_MASK          0x0F00F /* flags supported if no weak allowed */
+#define   CIFSSEC_MASK          0x8F08F /* flags supported if no weak allowed */
 #else
-#define	  CIFSSEC_MASK          0x07007 /* flags supported if no weak allowed */
+#define	  CIFSSEC_MASK          0x87087 /* flags supported if no weak allowed */
 #endif /* UPCALL */
 #endif /* WEAK_PW_HASH */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
+#define   CIFSSEC_MUST_NTLMSSP	0x80080 /* raw ntlmssp with ntlmv2 */
 
 #define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2)
 #define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)
-#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5)
+#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)
 /*
  *****************************************************************
  * All constants go here

commit a6ce4932fbdbcd8f8e8c6df76812014351c32892
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Apr 9 01:14:32 2009 +0000

    [CIFS] Add support for posix open during lookup
    
    This patch by utilizing lookup intents, and thus removing a network
    roundtrip in the open path, improves performance dramatically on
    open (30% or more) to Samba and other servers which support the
    cifs posix extensions
    
    Signed-off-by: Shirish Pargaonkar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7ae19868fdc4..df40ab64cd95 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -350,7 +350,7 @@ struct cifsFileInfo {
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool messageMode:1;	/* for pipes: message vs byte mode */
 	atomic_t wrtPending;   /* handle in use - defer close */
-	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
+	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 };
 

commit fbec9ab952d4810960e620035c8e95f0fbbae4be
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Apr 3 13:44:00 2009 -0400

    cifs: vary timeout on writes past EOF based on offset (try #5)
    
    This is the fourth version of this patch:
    
    The first three generated a compiler warning asking for explicit curly
    braces.
    
    The first two didn't handle update the size correctly when writes that
    didn't start at the eof were done.
    
    The first patch also didn't update the size correctly when it explicitly
    set via truncate().
    
    This patch adds code to track the client's current understanding of the
    size of the file on the server separate from the i_size, and then to use
    this info to semi-intelligently set the timeout for writes past the EOF.
    
    This helps prevent timeouts when trying to write large, sparse files on
    windows servers.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9fbf4dff5da6..7ae19868fdc4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -370,6 +370,7 @@ struct cifsInodeInfo {
 	bool clientCanCacheAll:1;	/* read and writebehind oplock */
 	bool oplockPending:1;
 	bool delete_pending:1;		/* DELETE_ON_CLOSE is set */
+	u64  server_eof;		/* current file size on server */
 	struct inode vfs_inode;
 };
 

commit 64cc2c63694a03393985ffc8b178e72f52dd8a06
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Mar 4 19:54:08 2009 +0000

    [CIFS] work around bug in Samba server handling for posix open
    
    Samba server (version 3.3.1 and earlier, and 3.2.8 and earlier) incorrectly
    required the O_CREAT flag on posix open (even when a file was not being
    created).  This disables posix open (create is still ok) after the first
    attempt returns EINVAL (and logs an error, once, recommending that they
    update their server).
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 44ff94d37e18..9fbf4dff5da6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -299,6 +299,7 @@ struct cifsTconInfo {
 	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */
 	bool local_lease:1; /* check leases (only) on local system not remote */
+	bool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */
 	bool need_reconnect:1; /* connection reset, tid now invalid */
 	/* BB add field for back pointer to sb struct(s)? */
 };

commit b298f223559e0205244f553ceef8c7df3674da74
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Feb 21 21:17:43 2009 +0000

    [CIFS] Send SMB flush in cifs_fsync
    
    In contrast to the now-obsolete smbfs, cifs does not send SMB_COM_FLUSH
    in response to an explicit fsync(2) to guarantee that all volatile data
    is written to stable storage on the server side, provided the server
    honors the request (which, to my knowledge, is true for Windows and
    Samba with 'strict sync' enabled).
    This patch modifies the cifs_fsync implementation to restore the
    fsync-behavior of smbfs by triggering SMB_COM_FLUSH after sending
    outstanding data on the client side to the server.
    
    Signed-off-by: Horst Reiterer <horst.reiterer@gmail.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e004f6db5fc8..44ff94d37e18 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -254,6 +254,7 @@ struct cifsTconInfo {
 	atomic_t num_smbs_sent;
 	atomic_t num_writes;
 	atomic_t num_reads;
+	atomic_t num_flushes;
 	atomic_t num_oplock_brks;
 	atomic_t num_opens;
 	atomic_t num_closes;

commit eca6acf91552a9b2e997cc76339115c95eac0217
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Feb 20 05:43:09 2009 +0000

    [CIFS] Fix multiuser mounts so server does not invalidate earlier security contexts
    
    When two different users mount the same Windows 2003 Server share using CIFS,
    the first session mounted can be invalidated.  Some servers invalidate the first
    smb session when a second similar user (e.g. two users who get mapped by server to "guest")
    authenticates an smb session from the same client.
    
    By making sure that we set the 2nd and subsequent vc numbers to nonzero values,
    this ensures that we will not have this problem.
    
    Fixes Samba bug 6004, problem description follows:
    How to reproduce:
    
    - configure an "open share" (full permissions to Guest user) on Windows 2003
    Server (I couldn't reproduce the problem with Samba server or Windows older
    than 2003)
    - mount the share twice with different users who will be authenticated as guest.
    
     noacl,noperm,user=john,dir_mode=0700,domain=DOMAIN,rw
     noacl,noperm,user=jeff,dir_mode=0700,domain=DOMAIN,rw
    
    Result:
    
    - just the mount point mounted last is accessible:
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 94c1ca0ec953..e004f6db5fc8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -164,9 +164,12 @@ struct TCP_Server_Info {
 	/* multiplexed reads or writes */
 	unsigned int maxBuf;	/* maxBuf specifies the maximum */
 	/* message size the server can send or receive for non-raw SMBs */
-	unsigned int maxRw;	/* maxRw specifies the maximum */
+	unsigned int max_rw;	/* maxRw specifies the maximum */
 	/* message size the server can send or receive for */
 	/* SMB_COM_WRITE_RAW or SMB_COM_READ_RAW. */
+	unsigned int max_vcs;	/* maximum number of smb sessions, at least
+				   those that can be specified uniquely with
+				   vcnumbers */
 	char sessid[4];		/* unique token id for this session */
 	/* (returned on Negotiate */
 	int capabilities; /* allow selective disabling of caps by smb sess */
@@ -210,6 +213,7 @@ struct cifsSesInfo {
 	unsigned overrideSecFlg;  /* if non-zero override global sec flags */
 	__u16 ipc_tid;		/* special tid for connection to IPC share */
 	__u16 flags;
+	__u16 vcnum;
 	char *serverOS;		/* name of operating system underlying server */
 	char *serverNOS;	/* name of network operating system of server */
 	char *serverDomain;	/* security realm of server */

commit 00e485b0198ea4f509341373f1d9adb0a5977a2f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Dec 5 20:41:21 2008 -0500

    cifs: store password in tcon
    
    cifs: store password in tcon
    
    Each tcon has its own password for share-level security. Store it in
    the tcon and wipe it clean and free it when freeing the tcon. When
    doing the tree connect with share-level security, use the tcon password
    instead of the session password.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0fb934d3623b..94c1ca0ec953 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -242,6 +242,7 @@ struct cifsTconInfo {
 	struct cifsSesInfo *ses;	/* pointer to session associated with */
 	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
+	char *password;		/* for share-level security */
 	__u16 tid;		/* The 2 byte tree id */
 	__u16 Flags;		/* optional support bits */
 	enum statusEnum tidStatus;

commit 8ecaf67a8ea58c8f131ff045475c74e9538d6b7a
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 1 15:23:50 2008 -0500

    cifs: account for IPv6 in ses->serverName and clean up netbios name handling
    
    The current code for setting the session serverName is IPv4-specific.
    Allow it to be an IPv6 address as well. Use NIP* macros to set the
    format.
    
    This also entails increasing the length of the serverName field, so
    declare a new macro for RFC1001 name length and use it in the
    appropriate places.
    
    Finally, drop the unicode_server_Name field from TCP_Server_Info since
    it's not used. We can add it back later if needed, but for now it just
    wastes memory.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9b002cca6bb7..0fb934d3623b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -47,7 +47,11 @@
  */
 #define CIFS_MAX_REQ 50
 
-#define SERVER_NAME_LENGTH 15
+#define RFC1001_NAME_LEN 15
+#define RFC1001_NAME_LEN_WITH_NULL (RFC1001_NAME_LEN + 1)
+
+/* currently length of NIP6_FMT */
+#define SERVER_NAME_LENGTH 40
 #define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)
 
 /* used to define string lengths for reversing unicode strings */
@@ -125,8 +129,7 @@ struct TCP_Server_Info {
 	struct list_head smb_ses_list;
 	int srv_count; /* reference counter */
 	/* 15 character server name + 0x20 16th byte indicating type = srv */
-	char server_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
-	char unicode_server_Name[SERVER_NAME_LEN_WITH_NULL * 2];
+	char server_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	char *hostname; /* hostname portion of UNC string */
 	struct socket *ssocket;
 	union {
@@ -171,7 +174,7 @@ struct TCP_Server_Info {
 	__u16 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
 	/* 16th byte of RFC1001 workstation name is always null */
-	char workstation_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
+	char workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
 	struct mac_key mac_signing_key;
 	char ntlmv2_hash[16];

commit 72ca545b2d83ac7de671bf66d2dbc214528b4c0c
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 1 07:09:36 2008 -0500

    cifs: convert tcpSem to a mutex
    
    Mutexes are preferred for single-holder semaphores...
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 82e28f5515c8..9b002cca6bb7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -151,7 +151,7 @@ struct TCP_Server_Info {
 	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
 #endif
 	enum statusEnum tcpStatus; /* what we think the status is */
-	struct semaphore tcpSem;
+	struct mutex srv_mutex;
 	struct task_struct *tsk;
 	char server_GUID[16];
 	char secMode;

commit 24b9b06ba7ea53aa0c4d0b1c8c1e93aa1bd9fe72
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 1 07:09:34 2008 -0500

    cifs: remove unused SMB session pointer from struct mid_q_entry
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c57c0565547f..82e28f5515c8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -422,7 +422,6 @@ struct mid_q_entry {
 	unsigned long when_sent; /* time when smb send finished */
 	unsigned long when_received; /* when demux complete (taken off wire) */
 #endif
-	struct cifsSesInfo *ses;	/* smb was sent to this server */
 	struct task_struct *tsk;	/* task waiting for response */
 	struct smb_hdr *resp_buf;	/* response buffer */
 	int midState;	/* wish this were enum but can not pass to wait_event */

commit ddb4cbfc53aa0913ee8da059fcbf628d14f40f63
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Nov 20 20:00:44 2008 +0000

    [CIFS] Do not attempt to close invalidated file handles
    
    If a connection with open file handles has gone down
    and come back up and reconnected without reopening
    the file handle yet, do not attempt to send an SMB close
    request for this handle in cifs_close.  We were
    checking for the connection being invalid in cifs_close
    but since the connection may have been reconnected
    we also need to check whether the file handle
    was marked invalid (otherwise we could close the
    wrong file handle by accident).
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f1ae1f57c30d..c57c0565547f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -606,7 +606,15 @@ GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;
  * changes to the tcon->tidStatus should be done while holding this lock.
  */
 GLOBAL_EXTERN rwlock_t		cifs_tcp_ses_lock;
-GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */
+
+/*
+ * This lock protects the cifs_file->llist and cifs_file->flist
+ * list operations, and updates to some flags (cifs_file->invalidHandle)
+ * It will be moved to either use the tcon->stat_lock or equivalent later.
+ * If cifs_tcp_ses_lock and the lock below are both needed to be held, then
+ * the cifs_tcp_ses_lock must be grabbed first and released last.
+ */
+GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;
 
 GLOBAL_EXTERN struct list_head GlobalOplock_Q;
 

commit f1987b44f642e96176adc88b7ce23a1d74806f89
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Nov 15 11:12:47 2008 -0500

    cifs: reinstate sharing of tree connections
    
    Use a similar approach to the SMB session sharing. Add a list of tcons
    attached to each SMB session. Move the refcount to non-atomic. Protect
    all of the above with the cifs_tcp_ses_lock. Add functions to
    properly find and put references to the tcons.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 631a99f72f22..f1ae1f57c30d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -233,16 +233,15 @@ struct cifsSesInfo {
  * session
  */
 struct cifsTconInfo {
-	struct list_head cifsConnectionList;
+	struct list_head tcon_list;
+	int tc_count;
 	struct list_head openFileList;
-	struct semaphore tconSem;
 	struct cifsSesInfo *ses;	/* pointer to session associated with */
 	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
 	__u16 tid;		/* The 2 byte tree id */
 	__u16 Flags;		/* optional support bits */
 	enum statusEnum tidStatus;
-	atomic_t useCount;	/* how many explicit/implicit mounts to share */
 #ifdef CONFIG_CIFS_STATS
 	atomic_t num_smbs_sent;
 	atomic_t num_writes;
@@ -600,9 +599,13 @@ require use of the stronger protocol */
  */
 GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;
 
-/* protects cifs_tcp_ses_list and srv_count for each tcp session */
+/*
+ * This lock protects the cifs_tcp_ses_list, the list of smb sessions per
+ * tcp session, and the list of tcon's per smb session. It also protects
+ * the reference counters for the server, smb session, and tcon. Finally,
+ * changes to the tcon->tidStatus should be done while holding this lock.
+ */
 GLOBAL_EXTERN rwlock_t		cifs_tcp_ses_lock;
-GLOBAL_EXTERN struct list_head GlobalTreeConnectionList; /* BB to be removed */
 GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */
 
 GLOBAL_EXTERN struct list_head GlobalOplock_Q;

commit 14fbf50d695207754daeb96270b3027a3821121f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Nov 14 13:53:46 2008 -0500

    cifs: reinstate sharing of SMB sessions sans races
    
    We do this by abandoning the global list of SMB sessions and instead
    moving to a per-server list. This entails adding a new list head to the
    TCP_Server_Info struct. The refcounting for the cifsSesInfo is moved to
    a non-atomic variable. We have to protect it by a lock anyway, so there's
    no benefit to making it an atomic. The list and refcount are protected
    by the global cifs_tcp_ses_lock.
    
    The patch also adds a new routines to find and put SMB sessions and
    that properly take and put references under the lock.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 313f7bfedec7..631a99f72f22 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -195,14 +195,14 @@ struct cifsUidInfo {
  * Session structure.  One of these for each uid session with a particular host
  */
 struct cifsSesInfo {
-	struct list_head cifsSessionList;
+	struct list_head smb_ses_list;
 	struct list_head tcon_list;
 	struct semaphore sesSem;
 #if 0
 	struct cifsUidInfo *uidInfo;	/* pointer to user info */
 #endif
 	struct TCP_Server_Info *server;	/* pointer to server info */
-	atomic_t inUse; /* # of mounts (tree connections) on this ses */
+	int ses_count;		/* reference counter */
 	enum statusEnum status;
 	unsigned overrideSecFlg;  /* if non-zero override global sec flags */
 	__u16 ipc_tid;		/* special tid for connection to IPC share */
@@ -602,8 +602,6 @@ GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;
 
 /* protects cifs_tcp_ses_list and srv_count for each tcp session */
 GLOBAL_EXTERN rwlock_t		cifs_tcp_ses_lock;
-
-GLOBAL_EXTERN struct list_head GlobalSMBSessionList; /* BB to be removed by jl*/
 GLOBAL_EXTERN struct list_head GlobalTreeConnectionList; /* BB to be removed */
 GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */
 

commit e7ddee9037e7dd43de1ad08b51727e552aedd836
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Nov 14 13:44:38 2008 -0500

    cifs: disable sharing session and tcon and add new TCP sharing code
    
    The code that allows these structs to be shared is extremely racy.
    Disable the sharing of SMB and tcon structs for now until we can
    come up with a way to do this that's race free.
    
    We want to continue to share TCP sessions, however since they are
    required for multiuser mounts. For that, implement a new (hopefully
    race-free) scheme. Add a new global list of TCP sessions, and take
    care to get a reference to it whenever we're dealing with one.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 13dc48414a78..313f7bfedec7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -123,6 +123,7 @@ struct cifs_cred {
 struct TCP_Server_Info {
 	struct list_head tcp_ses_list;
 	struct list_head smb_ses_list;
+	int srv_count; /* reference counter */
 	/* 15 character server name + 0x20 16th byte indicating type = srv */
 	char server_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
 	char unicode_server_Name[SERVER_NAME_LEN_WITH_NULL * 2];
@@ -144,7 +145,6 @@ struct TCP_Server_Info {
 	bool svlocal:1;			/* local server or remote */
 	bool noblocksnd;		/* use blocking sendmsg */
 	bool noautotune;		/* do not autotune send buf sizes */
-	atomic_t socketUseCount; /* number of open cifs sessions on socket */
 	atomic_t inFlight;  /* number of requests on the wire to server */
 #ifdef CONFIG_CIFS_STATS2
 	atomic_t inSend; /* requests trying to send */
@@ -591,13 +591,18 @@ require use of the stronger protocol */
 #define GLOBAL_EXTERN extern
 #endif
 
-
-/* the list of TCP_Server_Info structures, ie each of the sockets
+/*
+ * the list of TCP_Server_Info structures, ie each of the sockets
  * connecting our client to a distinct server (ip address), is
- * chained together by global_cifs_sock_list. The list of all our SMB
+ * chained together by cifs_tcp_ses_list. The list of all our SMB
  * sessions (and from that the tree connections) can be found
- * by iterating over global_cifs_sock_list */
-GLOBAL_EXTERN struct list_head global_cifs_sock_list;
+ * by iterating over cifs_tcp_ses_list
+ */
+GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;
+
+/* protects cifs_tcp_ses_list and srv_count for each tcp session */
+GLOBAL_EXTERN rwlock_t		cifs_tcp_ses_lock;
+
 GLOBAL_EXTERN struct list_head GlobalSMBSessionList; /* BB to be removed by jl*/
 GLOBAL_EXTERN struct list_head GlobalTreeConnectionList; /* BB to be removed */
 GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */

commit 3ec332ef7a38c2327e18d087d4120a8e3bd3dc6e
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Nov 14 03:35:10 2008 +0000

    [CIFS] clean up server protocol handling
    
    We're currently declaring both a sockaddr_in and sockaddr6_in on the
    stack, but we really only need storage for one of them. Declare a
    sockaddr struct and cast it to the proper type. Also, eliminate the
    protocolType field in the TCP_Server_Info struct. It's redundant since
    we have a sa_family field in the sockaddr anyway.
    
    We may need to revisit this if SCTP is ever implemented, but for now
    this will simplify the code.
    
    CIFS over IPv6 also has a number of problems currently. This fixes all
    of them that I found. Eventually, it would be nice to move more of the
    code to be protocol independent, but this is a start.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d6357dc1be72..13dc48414a78 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -85,8 +85,7 @@ enum securityEnum {
 };
 
 enum protocolEnum {
-	IPV4 = 0,
-	IPV6,
+	TCP = 0,
 	SCTP
 	/* Netbios frames protocol not supported at this time */
 };

commit fb396016647ae9de5b3bd8c4ee4f7b9cc7148bd5
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Nov 13 20:04:07 2008 +0000

    [CIFS] remove unused list, add new cifs sock list to prepare for mount/umount fix
    
    Also adds two lines missing from the previous patch (for the need reconnect flag in the
    /proc/fs/cifs/DebugData handling)
    
    The new global_cifs_sock_list is added, and initialized in init_cifs but not used yet.
    Jeff Layton will be adding code in to use that and to remove the GlobalTcon and GlobalSMBSession
    lists.
    
    CC: Jeff Layton <jlayton@redhat.com>
    CC: Shirish Pargaonkar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index dc0aa140f1bf..d6357dc1be72 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -592,22 +592,15 @@ require use of the stronger protocol */
 #define GLOBAL_EXTERN extern
 #endif
 
-/*
- * The list of servers that did not respond with NT LM 0.12.
- * This list helps improve performance and eliminate the messages indicating
- * that we had a communications error talking to the server in this list.
- */
-/* Feature not supported */
-/* GLOBAL_EXTERN struct servers_not_supported *NotSuppList; */
-
-/*
- * The following is a hash table of all the users we know about.
- */
-GLOBAL_EXTERN struct smbUidInfo *GlobalUidList[UID_HASH];
 
-/* GLOBAL_EXTERN struct list_head GlobalServerList; BB not implemented yet */
-GLOBAL_EXTERN struct list_head GlobalSMBSessionList;
-GLOBAL_EXTERN struct list_head GlobalTreeConnectionList;
+/* the list of TCP_Server_Info structures, ie each of the sockets
+ * connecting our client to a distinct server (ip address), is
+ * chained together by global_cifs_sock_list. The list of all our SMB
+ * sessions (and from that the tree connections) can be found
+ * by iterating over global_cifs_sock_list */
+GLOBAL_EXTERN struct list_head global_cifs_sock_list;
+GLOBAL_EXTERN struct list_head GlobalSMBSessionList; /* BB to be removed by jl*/
+GLOBAL_EXTERN struct list_head GlobalTreeConnectionList; /* BB to be removed */
 GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */
 
 GLOBAL_EXTERN struct list_head GlobalOplock_Q;

commit 3b7952109361c684caf0c50474da8662ecc81019
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Nov 13 19:45:32 2008 +0000

    [CIFS] Fix cifs reconnection flags
    
    In preparation for Jeff's big umount/mount fixes to remove the possibility of
    various races in cifs mount and linked list handling of sessions, sockets and
    tree connections, this patch cleans up some repetitive code in cifs_mount,
    and addresses a problem with ses->status and tcon->tidStatus in which we
    were overloading the "need_reconnect" state with other status in that
    field.  So the "need_reconnect" flag has been broken out from those
    two state fields (need reconnect was not mutually exclusive from some of the
    other possible tid and ses states).  In addition, a few exit cases in
    cifs_mount were cleaned up, and a problem with a tcon flag (for lease support)
    was not being set consistently for the 2nd mount of the same share
    
    CC: Jeff Layton <jlayton@redhat.com>
    CC: Shirish Pargaonkar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1cb1189f24e0..dc0aa140f1bf 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -122,6 +122,8 @@ struct cifs_cred {
  */
 
 struct TCP_Server_Info {
+	struct list_head tcp_ses_list;
+	struct list_head smb_ses_list;
 	/* 15 character server name + 0x20 16th byte indicating type = srv */
 	char server_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
 	char unicode_server_Name[SERVER_NAME_LEN_WITH_NULL * 2];
@@ -195,6 +197,7 @@ struct cifsUidInfo {
  */
 struct cifsSesInfo {
 	struct list_head cifsSessionList;
+	struct list_head tcon_list;
 	struct semaphore sesSem;
 #if 0
 	struct cifsUidInfo *uidInfo;	/* pointer to user info */
@@ -216,6 +219,7 @@ struct cifsSesInfo {
 	char userName[MAX_USERNAME_SIZE + 1];
 	char *domainName;
 	char *password;
+	bool need_reconnect:1; /* connection reset, uid now invalid */
 };
 /* no more than one of the following three session flags may be set */
 #define CIFS_SES_NT4 1
@@ -288,6 +292,7 @@ struct cifsTconInfo {
 	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */
 	bool local_lease:1; /* check leases (only) on local system not remote */
+	bool need_reconnect:1; /* connection reset, tid now invalid */
 	/* BB add field for back pointer to sb struct(s)? */
 };
 

commit edf1ae403896cb7750800508b14996ba6be39a53
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Oct 29 00:47:57 2008 +0000

    [CIFS] Reduce number of socket retries in large write path
    
    CIFS in some heavy stress conditions cifs could get EAGAIN
    repeatedly in smb_send2 which led to repeated retries and eventually
    failure of large writes which could lead to data corruption.
    
    There are three changes that were suggested by various network
    developers:
    
    1) convert cifs from non-blocking to blocking tcp sendmsg
    (we left in the retry on failure)
    2) change cifs to not set sendbuf and rcvbuf size for the socket
    (let tcp autotune the buffer sizes since that works much better
    in the TCP stack now)
    3) if we have a partial frame sent in smb_send2, mark the tcp
    session as invalid (close the socket and reconnect) so we do
    not corrupt the remaining part of the SMB with the beginning
    of the next SMB.
    
    This does not appear to hurt performance measurably and has
    been run in various scenarios, but it definately removes
    a corruption that we were seeing in some high stress
    test cases.
    
    Acked-by: Shirish Pargaonkar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c791e5b5a914..1cb1189f24e0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -141,6 +141,8 @@ struct TCP_Server_Info {
 	char versionMajor;
 	char versionMinor;
 	bool svlocal:1;			/* local server or remote */
+	bool noblocksnd;		/* use blocking sendmsg */
+	bool noautotune;		/* do not autotune send buf sizes */
 	atomic_t socketUseCount; /* number of open cifs sessions on socket */
 	atomic_t inFlight;  /* number of requests on the wire to server */
 #ifdef CONFIG_CIFS_STATS2

commit 84210e9120a8c01a14379ba1f9a9b0f963641d94
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Oct 23 04:42:37 2008 +0000

    [CIFS] improve setlease handling
    
    fcntl(F_SETLEASE) currently is not exported by cifs (nor by local file
    systems) so cifs grants leases based on how other local processes have
    opened the file not by whether the file is cacheable (oplocked).  This
    adds the check to make sure that the file is cacheable on the client
    before checking whether we can grant the lease locally
    (generic_setlease).  It also adds a mount option for cifs (locallease)
    if the user wants to override this and try to grant leases even
    if the server did not grant oplock.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 178f733a368f..c791e5b5a914 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -285,6 +285,7 @@ struct cifsTconInfo {
 	bool seal:1;      /* transport encryption for this mounted share */
 	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */
+	bool local_lease:1; /* check leases (only) on local system not remote */
 	/* BB add field for back pointer to sb struct(s)? */
 };
 

commit 9a8165fce724d1aba21e2c713ac6ba11dbfecafa
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 17 21:03:20 2008 -0400

    cifs: track DeletePending flag in cifsInodeInfo
    
    cifs: track DeletePending flag in cifsInodeInfo
    
    The QPathInfo call returns a flag that indicates whether DELETE_ON_CLOSE
    is set. Track it in the cifsInodeInfo.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0d22479d99b7..178f733a368f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -353,6 +353,7 @@ struct cifsInodeInfo {
 	bool clientCanCacheRead:1;	/* read oplock */
 	bool clientCanCacheAll:1;	/* read and writebehind oplock */
 	bool oplockPending:1;
+	bool delete_pending:1;		/* DELETE_ON_CLOSE is set */
 	struct inode vfs_inode;
 };
 

commit 0752f1522a9120f731232919f7ad904e9e22b8ce
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Oct 7 20:03:33 2008 +0000

    [CIFS] make sure we have the right resume info before calling CIFSFindNext
    
    When we do a seekdir() or equivalent, we usually end up doing a
    FindFirst call and then call FindNext until we get to the offset that we
    want. The problem is that when we call FindNext, the code usually
    doesn't have the proper info (mostly, the filename of the entry from the
    last search) to resume the search.
    
    Add a "last_entry" field to the cifs_search_info that points to the last
    entry in the search. We calculate this pointer by using the
    LastNameOffset field from the search parms that are returned. We then
    use that info to do a cifs_save_resume_key before we call CIFSFindNext.
    
    This patch allows CIFS to reliably pass the "telldir" connectathon test.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    CC: Stable <stable@kernel.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8dfd6f24d488..0d22479d99b7 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -309,6 +309,7 @@ struct cifs_search_info {
 	__u32 resume_key;
 	char *ntwrk_buf_start;
 	char *srch_entries_start;
+	char *last_entry;
 	char *presume_name;
 	unsigned int resume_name_len;
 	bool endOfSearch:1;

commit c16fefa56334e8d0197492607e473fdbb813073f
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Aug 19 19:35:33 2008 +0000

    [CIFS] distinguish between Kerberos and MSKerberos in upcall
    
    Properly handle MSKRB5 by passing sec=mskrb5 to the upcall so that the
    spengo blob can be generated appropriately. Also, make
    decode_negTokenInit prefer whichever mechanism is first in the list.
    
    Needed for some NetApp servers, and possibly some older
    versions of Windows which treat the two KRB5 mechanisms differently.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7e1cf262effe..8dfd6f24d488 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -80,7 +80,8 @@ enum securityEnum {
 	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
 	RawNTLMSSP,		/* NTLMSSP without SPNEGO */
 	NTLMSSP,		/* NTLMSSP via SPNEGO */
-	Kerberos		/* Kerberos via SPNEGO */
+	Kerberos,		/* Kerberos via SPNEGO */
+	MSKerberos,		/* MS Kerberos via SPNEGO */
 };
 
 enum protocolEnum {

commit ef571cadd516e7ffcdeac6bb8054e5908fcccfcf
Author: Shirish Pargaonkar <shirishp@gmail.com>
Date:   Thu Jul 24 15:56:05 2008 +0000

    [CIFS] Fix warnings from checkpatch
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9cfcf326ead3..7e1cf262effe 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -27,7 +27,7 @@
 #define MAX_SES_INFO 2
 #define MAX_TCON_INFO 4
 
-#define MAX_TREE_SIZE 2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1
+#define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)
 #define MAX_SERVER_SIZE 15
 #define MAX_SHARE_SIZE  64	/* used to be 20, this should still be enough */
 #define MAX_USERNAME_SIZE 32	/* 32 is to allow for 15 char names + null
@@ -537,8 +537,8 @@ require use of the stronger protocol */
 #endif /* WEAK_PW_HASH */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
 
-#define   CIFSSEC_DEF  CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2
-#define   CIFSSEC_MAX  CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2
+#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2)
+#define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)
 #define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5)
 /*
  *****************************************************************

commit aaa9bbe039febf1d3a0f3a374deea0680d9f5758
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri May 23 17:38:32 2008 +0000

    [CIFS] remove unused variables
    
    CC: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 08914053242b..9cfcf326ead3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -333,7 +333,6 @@ struct cifsFileInfo {
 	bool messageMode:1;	/* for pipes: message vs byte mode */
 	atomic_t wrtPending;   /* handle in use - defer close */
 	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
-	char *search_resume_name; /* BB removeme BB */
 	struct cifs_search_info srch_inf;
 };
 
@@ -626,7 +625,7 @@ GLOBAL_EXTERN atomic_t tcpSesAllocCount;
 GLOBAL_EXTERN atomic_t tcpSesReconnectCount;
 GLOBAL_EXTERN atomic_t tconInfoReconnectCount;
 
-/* Various Debug counters to remove someday (BB) */
+/* Various Debug counters */
 GLOBAL_EXTERN atomic_t bufAllocCount;    /* current number allocated  */
 #ifdef CONFIG_CIFS_STATS2
 GLOBAL_EXTERN atomic_t totBufAllocCount; /* total allocated over all time */

commit 95b1cb90b79896c4bf5ea484bee2b41d7d293f43
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu May 15 16:44:38 2008 +0000

    [CIFS] enable parsing for transport encryption mount parm
    
    Samba now supports transport encryption on particular exports
    (mounted tree ids can be encrypted for servers which support the
    unix extensions).  This adds parsing support to cifs mount
    option parsing for this.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b7d9f698e63e..08914053242b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -281,6 +281,7 @@ struct cifsTconInfo {
 	bool ipc:1;		/* set if connection to IPC$ eg for RPC/PIPES */
 	bool retry:1;
 	bool nocase:1;
+	bool seal:1;      /* transport encryption for this mounted share */
 	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */
 	/* BB add field for back pointer to sb struct(s)? */

commit 4b18f2a9c3964f7612b7403dddc1d1ba5443ae24
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Apr 29 00:06:05 2008 +0000

    [CIFS] convert usage of implicit booleans to bool
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 69a2e1942542..b7d9f698e63e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -57,14 +57,6 @@
 
 #include "cifspdu.h"
 
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-
 #ifndef XATTR_DOS_ATTRIB
 #define XATTR_DOS_ATTRIB "user.DOSATTRIB"
 #endif
@@ -147,7 +139,7 @@ struct TCP_Server_Info {
 	enum protocolEnum protocolType;
 	char versionMajor;
 	char versionMinor;
-	unsigned svlocal:1;	/* local server or remote */
+	bool svlocal:1;			/* local server or remote */
 	atomic_t socketUseCount; /* number of open cifs sessions on socket */
 	atomic_t inFlight;  /* number of requests on the wire to server */
 #ifdef CONFIG_CIFS_STATS2
@@ -286,10 +278,10 @@ struct cifsTconInfo {
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
 	FILE_SYSTEM_UNIX_INFO fsUnixInfo;
-	unsigned ipc:1;		/* set if connection to IPC$ eg for RPC/PIPES */
-	unsigned retry:1;
-	unsigned nocase:1;
-	unsigned unix_ext:1; /* if off disable Linux extensions to CIFS protocol
+	bool ipc:1;		/* set if connection to IPC$ eg for RPC/PIPES */
+	bool retry:1;
+	bool nocase:1;
+	bool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol
 				for this mount even if server would support */
 	/* BB add field for back pointer to sb struct(s)? */
 };
@@ -317,10 +309,10 @@ struct cifs_search_info {
 	char *srch_entries_start;
 	char *presume_name;
 	unsigned int resume_name_len;
-	unsigned endOfSearch:1;
-	unsigned emptyDir:1;
-	unsigned unicode:1;
-	unsigned smallBuf:1; /* so we know which buf_release function to call */
+	bool endOfSearch:1;
+	bool emptyDir:1;
+	bool unicode:1;
+	bool smallBuf:1; /* so we know which buf_release function to call */
 };
 
 struct cifsFileInfo {
@@ -335,9 +327,9 @@ struct cifsFileInfo {
 	struct inode *pInode; /* needed for oplock break */
 	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */
-	unsigned closePend:1;	/* file is marked to close */
-	unsigned invalidHandle:1;  /* file closed via session abend */
-	unsigned messageMode:1;    /* for pipes: message vs byte mode */
+	bool closePend:1;	/* file is marked to close */
+	bool invalidHandle:1;	/* file closed via session abend */
+	bool messageMode:1;	/* for pipes: message vs byte mode */
 	atomic_t wrtPending;   /* handle in use - defer close */
 	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
 	char *search_resume_name; /* BB removeme BB */
@@ -356,9 +348,9 @@ struct cifsInodeInfo {
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
 	atomic_t inUse;	 /* num concurrent users (local openers cifs) of file*/
 	unsigned long time;	/* jiffies of last update/check of inode */
-	unsigned clientCanCacheRead:1; /* read oplock */
-	unsigned clientCanCacheAll:1;  /* read and writebehind oplock */
-	unsigned oplockPending:1;
+	bool clientCanCacheRead:1;	/* read oplock */
+	bool clientCanCacheAll:1;	/* read and writebehind oplock */
+	bool oplockPending:1;
 	struct inode vfs_inode;
 };
 
@@ -426,9 +418,9 @@ struct mid_q_entry {
 	struct smb_hdr *resp_buf;	/* response buffer */
 	int midState;	/* wish this were enum but can not pass to wait_event */
 	__u8 command;	/* smb command code */
-	unsigned largeBuf:1;    /* if valid response, is pointer to large buf */
-	unsigned multiRsp:1;   /* multiple trans2 responses for one request  */
-	unsigned multiEnd:1; /* both received */
+	bool largeBuf:1;	/* if valid response, is pointer to large buf */
+	bool multiRsp:1;	/* multiple trans2 responses for one request  */
+	bool multiEnd:1;	/* both received */
 };
 
 struct oplock_q_entry {

commit 8aad018b6c1a0257b37cdf7c90cdbee2353150fd
Author: Igor Mammedov <niallain@gmail.com>
Date:   Fri Feb 15 18:21:49 2008 +0000

    [CIFS] Fix mixed case name in structure dfs_info3_param
    
    Signed-off-by: Igor Mammedov <niallain@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 5d32d8ddc82e..69a2e1942542 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -454,7 +454,7 @@ struct dir_notify_req {
 
 struct dfs_info3_param {
 	int flags; /* DFSREF_REFERRAL_SERVER, DFSREF_STORAGE_SERVER*/
-	int PathConsumed;
+	int path_consumed;
 	int server_type;
 	int ref_flag;
 	char *path_name;

commit 366781c19635d861f43ff5e03388a3873ec912d9
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Jan 25 10:12:41 2008 +0000

    [CIFS] DFS build fixes
    
    Also includes a few minor changes suggested by Christoph
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1fde2197ad76..5d32d8ddc82e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/cifsglob.h
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2007
+ *   Copyright (C) International Business Machines  Corp., 2002,2008
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *              Jeremy Allison (jra@samba.org)
  *
@@ -69,14 +69,6 @@
 #define XATTR_DOS_ATTRIB "user.DOSATTRIB"
 #endif
 
-/*
- * This information is kept on every Server we know about.
- *
- * Some things to note:
- *
- */
-#define SERVER_NAME_LEN_WITH_NULL	(SERVER_NAME_LENGTH + 1)
-
 /*
  * CIFS vfs client Status information (based on what we know.)
  */
@@ -460,6 +452,37 @@ struct dir_notify_req {
        struct file *pfile;
 };
 
+struct dfs_info3_param {
+	int flags; /* DFSREF_REFERRAL_SERVER, DFSREF_STORAGE_SERVER*/
+	int PathConsumed;
+	int server_type;
+	int ref_flag;
+	char *path_name;
+	char *node_name;
+};
+
+static inline void free_dfs_info_param(struct dfs_info3_param *param)
+{
+	if (param) {
+		kfree(param->path_name);
+		kfree(param->node_name);
+		kfree(param);
+	}
+}
+
+static inline void free_dfs_info_array(struct dfs_info3_param *param,
+				       int number_of_items)
+{
+	int i;
+	if ((number_of_items == 0) || (param == NULL))
+		return;
+	for (i = 0; i < number_of_items; i++) {
+		kfree(param[i].path_name);
+		kfree(param[i].node_name);
+	}
+	kfree(param);
+}
+
 #define   MID_FREE 0
 #define   MID_REQUEST_ALLOCATED 1
 #define   MID_REQUEST_SUBMITTED 2

commit 2442421b176420eca7cb68c575fc221332f488d8
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Nov 16 23:37:35 2007 +0000

    [CIFS] Have CIFS_SessSetup build correct SPNEGO SessionSetup request
    
    Have CIFS_SessSetup call cifs_get_spnego_key when Kerberos is
    negotiated. Use the info in the key payload to build a session
    setup request packet. Also clean up how the request buffer in
    the function is freed on error.
    
    With appropriate user space helper (in samba/source/client). Kerberos
    support (secure session establishment can be done now via Kerberos,
    previously users would have to use NTLMv2 instead for more secure
    session setup).
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3525082f5e58..1fde2197ad76 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -110,6 +110,7 @@ struct mac_key {
 	unsigned int len;
 	union {
 		char ntlm[CIFS_SESS_KEY_SIZE + 16];
+		char krb5[CIFS_SESS_KEY_SIZE + 16]; /* BB: length correct? */
 		struct {
 			char key[16];
 			struct ntlmv2_resp resp;

commit c359cf3c61c6ea9f4f461a8bd22023a15d75d9b5
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Nov 16 22:22:06 2007 +0000

    [CIFS] add hostname field to TCP_Server_Info struct
    
    ...and populate it with the hostname portion of the UNC string.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4ff8179df7ec..3525082f5e58 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -139,6 +139,7 @@ struct TCP_Server_Info {
 	/* 15 character server name + 0x20 16th byte indicating type = srv */
 	char server_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
 	char unicode_server_Name[SERVER_NAME_LEN_WITH_NULL * 2];
+	char *hostname; /* hostname portion of UNC string */
 	struct socket *ssocket;
 	union {
 		struct sockaddr_in sockAddr;

commit 133672efbc1085f9af990bdc145e1822ea93bcf3
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Nov 13 22:41:37 2007 +0000

    [CIFS] Fix buffer overflow if server sends corrupt response to small
    request
    
    In SendReceive() function in transport.c - it memcpy's
    message payload into a buffer passed via out_buf param. The function
    assumes that all buffers are of size (CIFSMaxBufSize +
    MAX_CIFS_HDR_SIZE) , unfortunately it is also called with smaller
    (MAX_CIFS_SMALL_BUFFER_SIZE) buffers.  There are eight callers
    (SMB worker functions) which are primarily affected by this change:
    
    TreeDisconnect, uLogoff, Close, findClose, SetFileSize, SetFileTimes,
    Lock and PosixLock
    
    CC: Dave Kleikamp <shaggy@austin.ibm.com>
    CC: Przemyslaw Wegrzyn <czajnik@czajsoft.pl>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 87f51f23276f..4ff8179df7ec 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -471,6 +471,17 @@ struct dir_notify_req {
 #define   CIFS_LARGE_BUFFER     2
 #define   CIFS_IOVEC            4    /* array of response buffers */
 
+/* Type of Request to SendReceive2 */
+#define   CIFS_STD_OP	        0    /* normal request timeout */
+#define   CIFS_LONG_OP          1    /* long op (up to 45 sec, oplock time) */
+#define   CIFS_VLONG_OP         2    /* sloow op - can take up to 180 seconds */
+#define   CIFS_BLOCKING_OP      4    /* operation can block */
+#define   CIFS_ASYNC_OP         8    /* do not wait for response */
+#define   CIFS_TIMEOUT_MASK 0x00F    /* only one of 5 above set in req */
+#define   CIFS_LOG_ERROR    0x010    /* log NT STATUS if non-zero */
+#define   CIFS_LARGE_BUF_OP 0x020    /* large request buffer */
+#define   CIFS_NO_RESP      0x040    /* no response buffer required */
+
 /* Security Flags: indicate type of session setup needed */
 #define   CIFSSEC_MAY_SIGN	0x00001
 #define   CIFSSEC_MAY_NTLM	0x00002

commit 016ec75f1a0c0e765fce65d794569979104f031d
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Oct 16 18:10:10 2007 +0000

    [CIFS] missing #endif from a previous patch
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9b7762c754cb..87f51f23276f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -499,11 +499,13 @@ require use of the stronger protocol */
 #define   CIFSSEC_MASK          0x3F03F /* allows weak security but also krb5 */
 #else
 #define   CIFSSEC_MASK          0x37037 /* current flags supported if weak */
+#endif /* UPCALL */
 #else /* do not allow weak pw hash */
 #ifdef CONFIG_CIFS_UPCALL
 #define   CIFSSEC_MASK          0x0F00F /* flags supported if no weak allowed */
 #else
 #define	  CIFSSEC_MASK          0x07007 /* flags supported if no weak allowed */
+#endif /* UPCALL */
 #endif /* WEAK_PW_HASH */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
 

commit 0d3a01fadacef5901005dc8f61688a8f0471dc79
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Oct 16 17:32:19 2007 +0000

    [CIFS] Break up unicode_sessetup string functions
    
    SPNEGO setup needs only some of these strings. Break up
    unicode_ssetup_strings so we can call them individually.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 61d617370e56..9b7762c754cb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -495,9 +495,15 @@ require use of the stronger protocol */
 #ifdef CONFIG_CIFS_WEAK_PW_HASH
 #define   CIFSSEC_MUST_LANMAN	0x10010
 #define   CIFSSEC_MUST_PLNTXT	0x20020
+#ifdef CONFIG_CIFS_UPCALL
+#define   CIFSSEC_MASK          0x3F03F /* allows weak security but also krb5 */
+#else
 #define   CIFSSEC_MASK          0x37037 /* current flags supported if weak */
+#else /* do not allow weak pw hash */
+#ifdef CONFIG_CIFS_UPCALL
+#define   CIFSSEC_MASK          0x0F00F /* flags supported if no weak allowed */
 #else
-#define	  CIFSSEC_MASK          0x07007 /* flags supported if no weak config */
+#define	  CIFSSEC_MASK          0x07007 /* flags supported if no weak allowed */
 #endif /* WEAK_PW_HASH */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
 

commit 516897a208bc1423d561ce2ccce0624c3b652275
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Oct 12 19:24:06 2007 +0000

    [CIFS] fix build break when lanman not enabled
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fbde55c569fb..61d617370e56 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -479,6 +479,9 @@ struct dir_notify_req {
 #ifdef CONFIG_CIFS_WEAK_PW_HASH
 #define   CIFSSEC_MAY_LANMAN	0x00010
 #define   CIFSSEC_MAY_PLNTXT	0x00020
+#else
+#define   CIFSSEC_MAY_LANMAN    0
+#define   CIFSSEC_MAY_PLNTXT    0
 #endif /* weak passwords */
 #define   CIFSSEC_MAY_SEAL	0x00040 /* not supported yet */
 

commit a013689ddb2a4ba5f0452c053c0bf00bafb686f1
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Oct 4 20:05:09 2007 +0000

    [CIFS] Fix cifsd so shuts down when signing fails during mount
    
    Fixes two problems:
    1) we dropped down to negotiating lanman if we did not recognize the
    mechanism (krb5 e.g.)
    2) we did not stop cifsd (thus will fail when doing rmod cifs with
    slab free errors) when we fail tcon but have a bad session (which is
    the case in which signing is required but we don't allow signing on
    the client)
    
    It also turns on extended security flag in the header when passing
    "sec=krb5" on mount command (although kerberos support is not done of
    course)
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    CC: Shaggy <shaggy@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 3fb046be9c0b..fbde55c569fb 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -90,7 +90,8 @@ enum statusEnum {
 };
 
 enum securityEnum {
-	LANMAN = 0,             /* Legacy LANMAN auth */
+	PLAINTXT = 0, 		/* Legacy with Plaintext passwords */
+	LANMAN,			/* Legacy LANMAN auth */
 	NTLM,			/* Legacy NTLM012 auth with NTLM hash */
 	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
 	RawNTLMSSP,		/* NTLMSSP without SPNEGO */
@@ -499,6 +500,7 @@ require use of the stronger protocol */
 
 #define   CIFSSEC_DEF  CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2
 #define   CIFSSEC_MAX  CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2
+#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5)
 /*
  *****************************************************************
  * All constants go here

commit 92ad9b93cd268371d1fc0edbd09383cc1c59be34
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 29 05:21:58 2007 +0000

    [CIFS] named pipe support (part 2)
    
    Also fixes typo which could cause build break
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f55be8efa26d..3fb046be9c0b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -342,7 +342,7 @@ struct cifsFileInfo {
 	struct list_head llist; /* list of byte range locks we have. */
 	unsigned closePend:1;	/* file is marked to close */
 	unsigned invalidHandle:1;  /* file closed via session abend */
-	unsigned messageMode:1    /* for pipes: is message or byte mode */
+	unsigned messageMode:1;    /* for pipes: message vs byte mode */
 	atomic_t wrtPending;   /* handle in use - defer close */
 	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
 	char *search_resume_name; /* BB removeme BB */

commit 7f8ed420f80c91176dfd27c8089f22cab5c9ba78
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Sep 28 22:28:55 2007 +0000

    [CIFS] CIFS support for named pipes (part 1)
    
    This allows cifs to mount to ipc shares (IPC$)
    which will allow user space applications to
    layer over authenticated cifs connections
    (useful for Wine and others that would want
    to put DCE/RPC over CIFS or run CIFS named
    pipes)
    
    Acked-by: Rob Shearman <rob@codeweavers.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index bb468de4f474..f55be8efa26d 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -291,6 +291,7 @@ struct cifsTconInfo {
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
 	FILE_SYSTEM_UNIX_INFO fsUnixInfo;
+	unsigned ipc:1;		/* set if connection to IPC$ eg for RPC/PIPES */
 	unsigned retry:1;
 	unsigned nocase:1;
 	unsigned unix_ext:1; /* if off disable Linux extensions to CIFS protocol
@@ -341,6 +342,7 @@ struct cifsFileInfo {
 	struct list_head llist; /* list of byte range locks we have. */
 	unsigned closePend:1;	/* file is marked to close */
 	unsigned invalidHandle:1;  /* file closed via session abend */
+	unsigned messageMode:1    /* for pipes: is message or byte mode */
 	atomic_t wrtPending;   /* handle in use - defer close */
 	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
 	char *search_resume_name; /* BB removeme BB */

commit 442aa310f3bc49cf4e059da790fbae62411d50db
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Sep 24 20:25:46 2007 +0000

    [CIFS] Support for CIFS ACLs (part 1)
    
    Add code to be able to dump CIFS ACL information
    when Query Posix ACL with cifsacl mount parm enabled.
    
    Signed-off-by: Shirish Pargoankar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b98742fc3b5a..bb468de4f474 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -19,6 +19,7 @@
 #include <linux/in.h>
 #include <linux/in6.h>
 #include "cifs_fs_sb.h"
+#include "cifsacl.h"
 /*
  * The sizes of various internal tables and strings
  */
@@ -115,6 +116,17 @@ struct mac_key {
 	} data;
 };
 
+struct cifs_cred {
+	int uid;
+	int gid;
+	int mode;
+	int cecount;
+	struct cifs_sid osid;
+	struct cifs_sid gsid;
+	struct cifs_ntace *ntaces;
+	struct cifs_ace *aces;
+};
+
 /*
  *****************************************************************
  * Except the CIFS PDUs themselves all the

commit c18c842b1fdf527717303a4e173cbece7ab2deb8
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Jul 18 23:21:09 2007 +0000

    [CIFS] Allow disabling CIFS Unix Extensions as mount option
    
    Previously the only way to do this was to umount all mounts to that server,
    turn off a proc setting (/proc/fs/cifs/LinuxExtensionsEnabled).
    
    Fixes Samba bugzilla bug number: 4582 (and also 2008)
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 0a7813175a27..b98742fc3b5a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -281,7 +281,9 @@ struct cifsTconInfo {
 	FILE_SYSTEM_UNIX_INFO fsUnixInfo;
 	unsigned retry:1;
 	unsigned nocase:1;
-	/* BB add field for back pointer to sb struct? */
+	unsigned unix_ext:1; /* if off disable Linux extensions to CIFS protocol
+				for this mount even if server would support */
+	/* BB add field for back pointer to sb struct(s)? */
 };
 
 /*

commit b609f06ac4ac77433035366e9aa4dcd7a0f743a0
Author: Steve French <Yehuda.Sadeh@expand.com>
Date:   Mon Jul 9 07:55:14 2007 +0000

    [CIFS] Fix packet signatures for NTLMv2 case
    
    Signed-off-by: Yehuda Sadeh Weinraub <Yehuda.Sadeh@expand.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e16a2c473003..0a7813175a27 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -104,6 +104,17 @@ enum protocolEnum {
 	/* Netbios frames protocol not supported at this time */
 };
 
+struct mac_key {
+	unsigned int len;
+	union {
+		char ntlm[CIFS_SESS_KEY_SIZE + 16];
+		struct {
+			char key[16];
+			struct ntlmv2_resp resp;
+		} ntlmv2;
+	} data;
+};
+
 /*
  *****************************************************************
  * Except the CIFS PDUs themselves all the
@@ -159,7 +170,8 @@ struct TCP_Server_Info {
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
-	char mac_signing_key[CIFS_SESS_KEY_SIZE + 16];
+	struct mac_key mac_signing_key;
+	char ntlmv2_hash[16];
 	unsigned long lstrp; /* when we got last response from this server */
 };
 

commit d38d8c74c7cdfae910f9cd0ac5e1b7ba2d8a2fb2
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jun 28 19:44:13 2007 +0000

    [CIFS] whitespace fixes
    
    This changeset brought to you ... by patchcheck.pl
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 23655de2f4a4..e16a2c473003 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/cifsglob.h
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2006
+ *   Copyright (C) International Business Machines  Corp., 2002,2007
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *              Jeremy Allison (jra@samba.org)
  *
@@ -14,7 +14,7 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
  *   the GNU Lesser General Public License for more details.
- * 
+ *
  */
 #include <linux/in.h>
 #include <linux/in6.h>
@@ -28,7 +28,7 @@
 
 #define MAX_TREE_SIZE 2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1
 #define MAX_SERVER_SIZE 15
-#define MAX_SHARE_SIZE  64	/* used to be 20 - this should still be enough */
+#define MAX_SHARE_SIZE  64	/* used to be 20, this should still be enough */
 #define MAX_USERNAME_SIZE 32	/* 32 is to allow for 15 char names + null
 				   termination then *2 for unicode versions */
 #define MAX_PASSWORD_SIZE 16
@@ -38,13 +38,13 @@
 /*
  * MAX_REQ is the maximum number of requests that WE will send
  * on one socket concurently. It also matches the most common
- * value of max multiplex returned by servers.  We may 
+ * value of max multiplex returned by servers.  We may
  * eventually want to use the negotiated value (in case
  * future servers can handle more) when we are more confident that
  * we will not have problems oveloading the socket with pending
  * write data.
  */
-#define CIFS_MAX_REQ 50 
+#define CIFS_MAX_REQ 50
 
 #define SERVER_NAME_LENGTH 15
 #define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)
@@ -120,13 +120,13 @@ struct TCP_Server_Info {
 		struct sockaddr_in sockAddr;
 		struct sockaddr_in6 sockAddr6;
 	} addr;
-	wait_queue_head_t response_q; 
+	wait_queue_head_t response_q;
 	wait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/
 	struct list_head pending_mid_q;
 	void *Server_NlsInfo;	/* BB - placeholder for future NLS info  */
 	unsigned short server_codepage;	/* codepage for the server    */
 	unsigned long ip_address;	/* IP addr for the server if known */
-	enum protocolEnum protocolType;	
+	enum protocolEnum protocolType;
 	char versionMajor;
 	char versionMinor;
 	unsigned svlocal:1;	/* local server or remote */
@@ -166,7 +166,7 @@ struct TCP_Server_Info {
 /*
  * The following is our shortcut to user information.  We surface the uid,
  * and name. We always get the password on the fly in case it
- * has changed. We also hang a list of sessions owned by this user off here. 
+ * has changed. We also hang a list of sessions owned by this user off here.
  */
 struct cifsUidInfo {
 	struct list_head userList;
@@ -197,11 +197,11 @@ struct cifsSesInfo {
 	int Suid;		/* remote smb uid  */
 	uid_t linux_uid;        /* local Linux uid */
 	int capabilities;
-	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for 
+	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for
 				TCP names - will ipv6 and sctp addresses fit? */
 	char userName[MAX_USERNAME_SIZE + 1];
-	char * domainName;
-	char * password;
+	char *domainName;
+	char *password;
 };
 /* no more than one of the following three session flags may be set */
 #define CIFS_SES_NT4 1
@@ -213,7 +213,7 @@ struct cifsSesInfo {
 #define CIFS_SES_LANMAN 8
 /*
  * there is one of these for each connection to a resource on a particular
- * session 
+ * session
  */
 struct cifsTconInfo {
 	struct list_head cifsConnectionList;
@@ -291,9 +291,9 @@ struct cifs_search_info {
 	__u16 entries_in_buffer;
 	__u16 info_level;
 	__u32 resume_key;
-	char * ntwrk_buf_start;
-	char * srch_entries_start;
-	char * presume_name;
+	char *ntwrk_buf_start;
+	char *srch_entries_start;
+	char *presume_name;
 	unsigned int resume_name_len;
 	unsigned endOfSearch:1;
 	unsigned emptyDir:1;
@@ -309,15 +309,15 @@ struct cifsFileInfo {
 	__u16 netfid;		/* file id from remote */
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
-	struct file * pfile; /* needed for writepage */
-	struct inode * pInode; /* needed for oplock break */
+	struct file *pfile; /* needed for writepage */
+	struct inode *pInode; /* needed for oplock break */
 	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */
 	unsigned closePend:1;	/* file is marked to close */
 	unsigned invalidHandle:1;  /* file closed via session abend */
 	atomic_t wrtPending;   /* handle in use - defer close */
 	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
-	char * search_resume_name; /* BB removeme BB */
+	char *search_resume_name; /* BB removeme BB */
 	struct cifs_search_info srch_inf;
 };
 
@@ -327,7 +327,7 @@ struct cifsFileInfo {
 
 struct cifsInodeInfo {
 	struct list_head lockList;
-	/* BB add in lists for dirty pages - i.e. write caching info for oplock */
+	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
 	int write_behind_rc;
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
@@ -381,9 +381,9 @@ static inline void cifs_stats_bytes_read(struct cifsTconInfo *tcon,
 }
 #else
 
-#define  cifs_stats_inc(field) do {} while(0)
-#define  cifs_stats_bytes_written(tcon, bytes) do {} while(0)
-#define  cifs_stats_bytes_read(tcon, bytes) do {} while(0)
+#define  cifs_stats_inc(field) do {} while (0)
+#define  cifs_stats_bytes_written(tcon, bytes) do {} while (0)
+#define  cifs_stats_bytes_read(tcon, bytes) do {} while (0)
 
 #endif
 
@@ -410,8 +410,8 @@ struct mid_q_entry {
 
 struct oplock_q_entry {
 	struct list_head qhead;
-	struct inode * pinode;
-	struct cifsTconInfo * tcon; 
+	struct inode *pinode;
+	struct cifsTconInfo *tcon;
 	__u16 netfid;
 };
 
@@ -426,7 +426,7 @@ struct dir_notify_req {
        __u16 netfid;
        __u32 filter; /* CompletionFilter (for multishot) */
        int multishot;
-       struct file * pfile;
+       struct file *pfile;
 };
 
 #define   MID_FREE 0
@@ -464,7 +464,7 @@ require use of the stronger protocol */
 #define   CIFSSEC_MUST_LANMAN	0x10010
 #define   CIFSSEC_MUST_PLNTXT	0x20020
 #define   CIFSSEC_MASK          0x37037 /* current flags supported if weak */
-#else	  
+#else
 #define	  CIFSSEC_MASK          0x07007 /* flags supported if no weak config */
 #endif /* WEAK_PW_HASH */
 #define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
@@ -502,7 +502,7 @@ require use of the stronger protocol */
  *  ----------
  *  sesSem     operations on smb session
  *  tconSem    operations on tree connection
- *  fh_sem      file handle reconnection operations 
+ *  fh_sem      file handle reconnection operations
  *
  ****************************************************************************/
 
@@ -515,7 +515,7 @@ require use of the stronger protocol */
 /*
  * The list of servers that did not respond with NT LM 0.12.
  * This list helps improve performance and eliminate the messages indicating
- * that we had a communications error talking to the server in this list. 
+ * that we had a communications error talking to the server in this list.
  */
 /* Feature not supported */
 /* GLOBAL_EXTERN struct servers_not_supported *NotSuppList; */
@@ -568,12 +568,12 @@ GLOBAL_EXTERN atomic_t midCount;
 /* Misc globals */
 GLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions
 				to be established on existing mount if we
-				have the uid/password or Kerberos credential 
+				have the uid/password or Kerberos credential
 				or equivalent for current user */
 GLOBAL_EXTERN unsigned int oplockEnabled;
 GLOBAL_EXTERN unsigned int experimEnabled;
 GLOBAL_EXTERN unsigned int lookupCacheEnabled;
-GLOBAL_EXTERN unsigned int extended_security;	/* if on, session setup sent 
+GLOBAL_EXTERN unsigned int extended_security;	/* if on, session setup sent
 				with more secure ntlmssp2 challenge/resp */
 GLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
 GLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/

commit 796e5661f6b6be1600b3ab47c61ce61cf3e7a353
Author: Roland Dreier <roland@digitalvampire.org>
Date:   Thu May 3 04:33:45 2007 +0000

    [CIFS] Change semaphore to mutex for cifs lock_sem
    
    Originally at http://lkml.org/lkml/2006/9/2/86
    
    The recent change to "allow Windows blocking locks to be cancelled via a
    CANCEL_LOCK call" introduced a new semaphore in struct cifsFileInfo,
    lock_sem.  However, semaphores used as mutexes are deprecated these days,
    and there's no reason to add a new one to the kernel.  Therefore, convert
    lock_sem to a struct mutex (and also fix one indentation glitch on one of
    the lines changed anyway).
    
    Signed-off-by: Roland Dreier <roland@digitalvampire.org>
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e4de8eba4780..23655de2f4a4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -311,7 +311,7 @@ struct cifsFileInfo {
 	/* lock scope id (0 if none) */
 	struct file * pfile; /* needed for writepage */
 	struct inode * pInode; /* needed for oplock break */
-	struct semaphore lock_sem;
+	struct mutex lock_mutex;
 	struct list_head llist; /* list of byte range locks we have. */
 	unsigned closePend:1;	/* file is marked to close */
 	unsigned invalidHandle:1;  /* file closed via session abend */

commit 99ee4dbd7c99c27129a8e2026003a7680878345f
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Feb 27 05:35:17 2007 +0000

    [CIFS] Remove some unused functions/declarations
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 74d3ccbb103b..e4de8eba4780 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -525,15 +525,17 @@ require use of the stronger protocol */
  */
 GLOBAL_EXTERN struct smbUidInfo *GlobalUidList[UID_HASH];
 
-GLOBAL_EXTERN struct list_head GlobalServerList; /* BB not implemented yet */
+/* GLOBAL_EXTERN struct list_head GlobalServerList; BB not implemented yet */
 GLOBAL_EXTERN struct list_head GlobalSMBSessionList;
 GLOBAL_EXTERN struct list_head GlobalTreeConnectionList;
 GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */
 
 GLOBAL_EXTERN struct list_head GlobalOplock_Q;
 
-GLOBAL_EXTERN struct list_head GlobalDnotifyReqList; /* Outstanding dir notify requests */
-GLOBAL_EXTERN struct list_head GlobalDnotifyRsp_Q;/* DirNotify response queue */
+/* Outstanding dir notify requests */
+GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;
+/* DirNotify response queue */
+GLOBAL_EXTERN struct list_head GlobalDnotifyRsp_Q;
 
 /*
  * Global transaction id (XID) information

commit de7ed55dbb2f2c44be669d56c4adf28cbffb26ce
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 30 13:25:52 2006 +0000

    [CIFS] Make use of newer QFSInfo dependent on capability bit instead of
    whether we negotiated legacy lanman dialect so we do not keep retrying
    for mount to WindowsME
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 597afdf4c69c..74d3ccbb103b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -153,7 +153,7 @@ struct TCP_Server_Info {
 	char sessid[4];		/* unique token id for this session */
 	/* (returned on Negotiate */
 	int capabilities; /* allow selective disabling of caps by smb sess */
-	__u16 timeAdj;  /* Adjust for difference in server time zone in sec */
+	int timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u16 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
 	/* 16th byte of RFC1001 workstation name is always null */

commit 9ac00b7d96045fa3ce573e0ad5cdc0350ad8e1d2
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 30 04:13:17 2006 +0000

    [CIFS] Do not send newer QFSInfo to legacy servers which can not support it
    
    Fix dialect negotiation to save off when we have negotiated lanman.
    This allows us to avoid sending some somewhat newer requests that the server
    can not handle and go directly to the older version (infolevel) of the same
    call. Make sure we try to negotiate a level which allows us to get the
    server OS (which we check so we can detect Win9x vs. other legacy servers
    and eventually work around the Win9x DOS time bug (they reverse date/time
    fields).
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 98eb5446e8c1..597afdf4c69c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -203,9 +203,14 @@ struct cifsSesInfo {
 	char * domainName;
 	char * password;
 };
-/* session flags */
+/* no more than one of the following three session flags may be set */
 #define CIFS_SES_NT4 1
-
+#define CIFS_SES_OS2 2
+#define CIFS_SES_W9X 4
+/* following flag is set for old servers such as OS2 (and Win95?)
+   which do not negotiate NTLM or POSIX dialects, but instead
+   negotiate one of the older LANMAN dialects */
+#define CIFS_SES_LANMAN 8
 /*
  * there is one of these for each connection to a resource on a particular
  * session 

commit 175ec9e11cf18f8373b32f7a33e75a4cf7ce25e3
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 30 01:07:38 2006 +0000

    [CIFS] Rename server time zone field
    
    Server time zone is not really a time zone, rather a time adjustement
    in seconds.
    
    CC: Guenter Kukkukk <linux@kukkukk.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 441f8d2514fa..98eb5446e8c1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -153,7 +153,7 @@ struct TCP_Server_Info {
 	char sessid[4];		/* unique token id for this session */
 	/* (returned on Negotiate */
 	int capabilities; /* allow selective disabling of caps by smb sess */
-	__u16 timeZone;
+	__u16 timeAdj;  /* Adjust for difference in server time zone in sec */
 	__u16 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
 	/* 16th byte of RFC1001 workstation name is always null */

commit 2cd646a2d1d5e0e46aa4bb55b1847b0cb35bd855
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Sep 28 19:43:08 2006 +0000

    [CIFS] Remove static and unused symbols
    
    Most cases of the ones found by Shaggy by
            "make namespacecheck"
    could be removed or made static
    
    Ack: Dave Kleikamp <shaggy@austin.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index b24006c47df1..441f8d2514fa 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -512,7 +512,8 @@ require use of the stronger protocol */
  * This list helps improve performance and eliminate the messages indicating
  * that we had a communications error talking to the server in this list. 
  */
-GLOBAL_EXTERN struct servers_not_supported *NotSuppList;	/*@z4a */
+/* Feature not supported */
+/* GLOBAL_EXTERN struct servers_not_supported *NotSuppList; */
 
 /*
  * The following is a hash table of all the users we know about.
@@ -568,7 +569,6 @@ GLOBAL_EXTERN unsigned int lookupCacheEnabled;
 GLOBAL_EXTERN unsigned int extended_security;	/* if on, session setup sent 
 				with more secure ntlmssp2 challenge/resp */
 GLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
-GLOBAL_EXTERN unsigned int secFlags;
 GLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/
 GLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */
 GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */

commit 7ee1af765dfa3146aef958258003245e082284e5
Author: Jeremy Allison <jra@samba.com>
Date:   Wed Aug 2 21:56:33 2006 +0000

    [CIFS]
    
    Allow Windows blocking locks to be cancelled via a
    CANCEL_LOCK call. TODO - restrict this to servers
    that support NT_STATUS codes (Win9x will probably
    not support this call).
    
    Signed-off-by: Jeremy Allison <jra@samba.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>
    (cherry picked from 570d4d2d895569825d0d017d4e76b51138f68864 commit)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 39b43e6a7509..b24006c47df1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -3,6 +3,7 @@
  *
  *   Copyright (C) International Business Machines  Corp., 2002,2006
  *   Author(s): Steve French (sfrench@us.ibm.com)
+ *              Jeremy Allison (jra@samba.org)
  *
  *   This library is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU Lesser General Public License as published
@@ -267,14 +268,14 @@ struct cifsTconInfo {
 };
 
 /*
- * This info hangs off the cifsFileInfo structure.  This is used to track
- * byte stream locks on the file
+ * This info hangs off the cifsFileInfo structure, pointed to by llist.
+ * This is used to track byte stream locks on the file
  */
 struct cifsLockInfo {
-	struct cifsLockInfo *next;
-	int start;
-	int length;
-	int type;
+	struct list_head llist;	/* pointer to next cifsLockInfo */
+	__u64 offset;
+	__u64 length;
+	__u8 type;
 };
 
 /*
@@ -305,6 +306,8 @@ struct cifsFileInfo {
 	/* lock scope id (0 if none) */
 	struct file * pfile; /* needed for writepage */
 	struct inode * pInode; /* needed for oplock break */
+	struct semaphore lock_sem;
+	struct list_head llist; /* list of byte range locks we have. */
 	unsigned closePend:1;	/* file is marked to close */
 	unsigned invalidHandle:1;  /* file closed via session abend */
 	atomic_t wrtPending;   /* handle in use - defer close */

commit 3a5ff61c18659443f76bad6cf06f60103046de5d
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Jul 14 22:37:11 2006 +0000

    [CIFS] Do not time out posix brl requests when using new posix setfileinfo
    request and do not time out slow requests to a server that is still responding
    well to other threads
    
    Suggested by jra of Samba team
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>
    (cherry picked from 89b57148115479eef074b8d3f86c4c86c96ac969 commit)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6d7cf5f3bc0b..39b43e6a7509 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -158,7 +158,8 @@ struct TCP_Server_Info {
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
-	char mac_signing_key[CIFS_SESS_KEY_SIZE + 16]; 
+	char mac_signing_key[CIFS_SESS_KEY_SIZE + 16];
+	unsigned long lstrp; /* when we got last response from this server */
 };
 
 /*

commit 750d1151a6c95ef9b9a188bb7cff6b80ee30da17
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Jun 27 06:28:30 2006 +0000

    [CIFS] Fix allocation of buffers for new session setup routine to allow
    longer user and domain names and allow passing sec options on mount
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 87453a6bcaf8..6d7cf5f3bc0b 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -186,6 +186,7 @@ struct cifsSesInfo {
 	struct TCP_Server_Info *server;	/* pointer to server info */
 	atomic_t inUse; /* # of mounts (tree connections) on this ses */
 	enum statusEnum status;
+	unsigned overrideSecFlg;  /* if non-zero override global sec flags */
 	__u16 ipc_tid;		/* special tid for connection to IPC share */
 	__u16 flags;
 	char *serverOS;		/* name of operating system underlying server */

commit 254e55ed03e2e8d23089b4a468eec2fd2e1ead9b
Author: Steve French <sfrench@us.ibm.com>
Date:   Sun Jun 4 05:53:15 2006 +0000

    CIFS] Support for older servers which require plaintext passwords - part 2
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 975e69a2e1c4..87453a6bcaf8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -212,12 +212,12 @@ struct cifsTconInfo {
 	struct list_head openFileList;
 	struct semaphore tconSem;
 	struct cifsSesInfo *ses;	/* pointer to session associated with */
-	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource (in ASCII not UTF) */
+	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
 	__u16 tid;		/* The 2 byte tree id */
 	__u16 Flags;		/* optional support bits */
 	enum statusEnum tidStatus;
-	atomic_t useCount;	/* how many mounts (explicit or implicit) to this share */
+	atomic_t useCount;	/* how many explicit/implicit mounts to share */
 #ifdef CONFIG_CIFS_STATS
 	atomic_t num_smbs_sent;
 	atomic_t num_writes;
@@ -257,7 +257,7 @@ struct cifsTconInfo {
 	spinlock_t stat_lock;
 #endif /* CONFIG_CIFS_STATS */
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
-	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo;	/* ok if file system name truncated */
+	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
 	FILE_SYSTEM_UNIX_INFO fsUnixInfo;
 	unsigned retry:1;
 	unsigned nocase:1;
@@ -308,7 +308,6 @@ struct cifsFileInfo {
 	atomic_t wrtPending;   /* handle in use - defer close */
 	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
 	char * search_resume_name; /* BB removeme BB */
-	unsigned int resume_name_length; /* BB removeme - field renamed and moved BB */
 	struct cifs_search_info srch_inf;
 };
 
@@ -523,16 +522,16 @@ GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */
 GLOBAL_EXTERN struct list_head GlobalOplock_Q;
 
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList; /* Outstanding dir notify requests */
-GLOBAL_EXTERN struct list_head GlobalDnotifyRsp_Q; /* Dir notify response queue */
+GLOBAL_EXTERN struct list_head GlobalDnotifyRsp_Q;/* DirNotify response queue */
 
 /*
  * Global transaction id (XID) information
  */
 GLOBAL_EXTERN unsigned int GlobalCurrentXid;	/* protected by GlobalMid_Sem */
-GLOBAL_EXTERN unsigned int GlobalTotalActiveXid;	/* prot by GlobalMid_Sem */
+GLOBAL_EXTERN unsigned int GlobalTotalActiveXid; /* prot by GlobalMid_Sem */
 GLOBAL_EXTERN unsigned int GlobalMaxActiveXid;	/* prot by GlobalMid_Sem */
-GLOBAL_EXTERN spinlock_t GlobalMid_Lock;  /* protects above and list operations */
-					/* on midQ entries */
+GLOBAL_EXTERN spinlock_t GlobalMid_Lock;  /* protects above & list operations */
+					  /* on midQ entries */
 GLOBAL_EXTERN char Local_System_Name[15];
 
 /*
@@ -554,7 +553,7 @@ GLOBAL_EXTERN atomic_t smBufAllocCount;
 GLOBAL_EXTERN atomic_t midCount;
 
 /* Misc globals */
-GLOBAL_EXTERN unsigned int multiuser_mount;	/* if enabled allows new sessions
+GLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions
 				to be established on existing mount if we
 				have the uid/password or Kerberos credential 
 				or equivalent for current user */

commit 7c7b25bc8e392aea781324efa771bc191377b876
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jun 1 19:20:10 2006 +0000

    [CIFS] Support for setting up SMB sessions to legacy lanman servers part 2

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7a042041a16a..975e69a2e1c4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -158,7 +158,7 @@ struct TCP_Server_Info {
 	/* 16th byte of RFC1001 workstation name is always null */
 	char workstation_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
-	char mac_signing_key[CIFS_SESSION_KEY_SIZE + 16]; 
+	char mac_signing_key[CIFS_SESS_KEY_SIZE + 16]; 
 };
 
 /*

commit 3979877e5606ecc58c5a31bd0078c6d80ba9cbe7
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed May 31 22:40:51 2006 +0000

    [CIFS] Support for setting up SMB sessions to legacy lanman servers

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 006eb33bff5f..7a042041a16a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -88,7 +88,8 @@ enum statusEnum {
 };
 
 enum securityEnum {
-	NTLM = 0,		/* Legacy NTLM012 auth with NTLM hash */
+	LANMAN = 0,             /* Legacy LANMAN auth */
+	NTLM,			/* Legacy NTLM012 auth with NTLM hash */
 	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
 	RawNTLMSSP,		/* NTLMSSP without SPNEGO */
 	NTLMSSP,		/* NTLMSSP via SPNEGO */
@@ -179,7 +180,9 @@ struct cifsUidInfo {
 struct cifsSesInfo {
 	struct list_head cifsSessionList;
 	struct semaphore sesSem;
+#if 0
 	struct cifsUidInfo *uidInfo;	/* pointer to user info */
+#endif
 	struct TCP_Server_Info *server;	/* pointer to server info */
 	atomic_t inUse; /* # of mounts (tree connections) on this ses */
 	enum statusEnum status;
@@ -194,7 +197,7 @@ struct cifsSesInfo {
 	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for 
 				TCP names - will ipv6 and sctp addresses fit? */
 	char userName[MAX_USERNAME_SIZE + 1];
-	char domainName[MAX_USERNAME_SIZE + 1];
+	char * domainName;
 	char * password;
 };
 /* session flags */
@@ -391,9 +394,9 @@ struct mid_q_entry {
 	struct smb_hdr *resp_buf;	/* response buffer */
 	int midState;	/* wish this were enum but can not pass to wait_event */
 	__u8 command;	/* smb command code */
-	unsigned multiPart:1;	/* multiple responses to one SMB request */
 	unsigned largeBuf:1;    /* if valid response, is pointer to large buf */
-	unsigned multiResp:1;   /* multiple trans2 responses for one request  */
+	unsigned multiRsp:1;   /* multiple trans2 responses for one request  */
+	unsigned multiEnd:1; /* both received */
 };
 
 struct oplock_q_entry {
@@ -430,15 +433,35 @@ struct dir_notify_req {
 #define   CIFS_LARGE_BUFFER     2
 #define   CIFS_IOVEC            4    /* array of response buffers */
 
-/* Type of session setup needed */
-#define   CIFS_PLAINTEXT	0
-#define   CIFS_LANMAN		1
-#define   CIFS_NTLM		2
-#define   CIFS_NTLMSSP_NEG	3
-#define   CIFS_NTLMSSP_AUTH	4
-#define   CIFS_SPNEGO_INIT	5
-#define   CIFS_SPNEGO_TARG	6
-
+/* Security Flags: indicate type of session setup needed */
+#define   CIFSSEC_MAY_SIGN	0x00001
+#define   CIFSSEC_MAY_NTLM	0x00002
+#define   CIFSSEC_MAY_NTLMV2	0x00004
+#define   CIFSSEC_MAY_KRB5	0x00008
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+#define   CIFSSEC_MAY_LANMAN	0x00010
+#define   CIFSSEC_MAY_PLNTXT	0x00020
+#endif /* weak passwords */
+#define   CIFSSEC_MAY_SEAL	0x00040 /* not supported yet */
+
+#define   CIFSSEC_MUST_SIGN	0x01001
+/* note that only one of the following can be set so the
+result of setting MUST flags more than once will be to
+require use of the stronger protocol */
+#define   CIFSSEC_MUST_NTLM	0x02002
+#define   CIFSSEC_MUST_NTLMV2	0x04004
+#define   CIFSSEC_MUST_KRB5	0x08008
+#ifdef CONFIG_CIFS_WEAK_PW_HASH
+#define   CIFSSEC_MUST_LANMAN	0x10010
+#define   CIFSSEC_MUST_PLNTXT	0x20020
+#define   CIFSSEC_MASK          0x37037 /* current flags supported if weak */
+#else	  
+#define	  CIFSSEC_MASK          0x07007 /* flags supported if no weak config */
+#endif /* WEAK_PW_HASH */
+#define   CIFSSEC_MUST_SEAL	0x40040 /* not supported yet */
+
+#define   CIFSSEC_DEF  CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2
+#define   CIFSSEC_MAX  CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2
 /*
  *****************************************************************
  * All constants go here
@@ -540,8 +563,8 @@ GLOBAL_EXTERN unsigned int experimEnabled;
 GLOBAL_EXTERN unsigned int lookupCacheEnabled;
 GLOBAL_EXTERN unsigned int extended_security;	/* if on, session setup sent 
 				with more secure ntlmssp2 challenge/resp */
-GLOBAL_EXTERN unsigned int ntlmv2_support;  /* better optional password hash */
 GLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
+GLOBAL_EXTERN unsigned int secFlags;
 GLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/
 GLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */
 GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */

commit 5815449d1bfcb22f74b0e36a8b0631d6584cb7fc
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Feb 14 01:36:20 2006 +0000

    [CIFS] SessionSetup cleanup part 2
    
    The cifs session setup code has three cases, and a fourth for backlevel
    LANMAN2 style session setup needed to be added.  This new session setup
    implmentation will eventually replace the other three and should be
    easier to read while fixing a few minor problems (not setting
    the LARGE READ/WRITEX flags when NTLMSSP was negotiated for example) and
    adding support for NTLMv2 (which will be added with the next patch. In the
    meantime, this code is marked in an CONFIG_CIFS_EXPERIMENTAL block and will
    not be turned on by default until it is tested against more server types.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 7bed27601ce5..006eb33bff5f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/cifsglob.h
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2005
+ *   Copyright (C) International Business Machines  Corp., 2002,2006
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
  *   This library is free software; you can redistribute it and/or modify
@@ -430,6 +430,15 @@ struct dir_notify_req {
 #define   CIFS_LARGE_BUFFER     2
 #define   CIFS_IOVEC            4    /* array of response buffers */
 
+/* Type of session setup needed */
+#define   CIFS_PLAINTEXT	0
+#define   CIFS_LANMAN		1
+#define   CIFS_NTLM		2
+#define   CIFS_NTLMSSP_NEG	3
+#define   CIFS_NTLMSSP_AUTH	4
+#define   CIFS_SPNEGO_INIT	5
+#define   CIFS_SPNEGO_TARG	6
+
 /*
  *****************************************************************
  * All constants go here

commit 0a4b92c05ed02ad7abdd165823eaf4bbcb33ae5c
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jan 12 15:44:21 2006 -0800

    [CIFS] Add worker function for Get ACL cifs style
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 862e403ff211..7bed27601ce5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -233,6 +233,8 @@ struct cifsTconInfo {
 	atomic_t num_hardlinks;
 	atomic_t num_symlinks;
 	atomic_t num_locks;
+	atomic_t num_acl_get;
+	atomic_t num_acl_set;
 #ifdef CONFIG_CIFS_STATS2
 	unsigned long long time_writes;
 	unsigned long long time_reads;

commit ec637e3ffb6b978143652477c7c5f96c9519b691
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Dec 12 20:53:18 2005 -0800

    [CIFS] Avoid extra large buffer allocation (and memcpy) in cifs_readpages
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index c011c278af4c..862e403ff211 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -285,6 +285,7 @@ struct cifs_search_info {
 	unsigned endOfSearch:1;
 	unsigned emptyDir:1;
 	unsigned unicode:1;
+	unsigned smallBuf:1; /* so we know which buf_release function to call */
 };
 
 struct cifsFileInfo {
@@ -420,7 +421,12 @@ struct dir_notify_req {
 #define   MID_RESPONSE_RECEIVED 4
 #define   MID_RETRY_NEEDED      8 /* session closed while this request out */
 #define   MID_NO_RESP_NEEDED 0x10
-#define   MID_SMALL_BUFFER   0x20 /* 112 byte response buffer instead of 4K */
+
+/* Types of response buffer returned from SendReceive2 */
+#define   CIFS_NO_BUFFER        0    /* Response buffer not returned */
+#define   CIFS_SMALL_BUFFER     1
+#define   CIFS_LARGE_BUFFER     2
+#define   CIFS_IOVEC            4    /* array of response buffers */
 
 /*
  *****************************************************************

commit 4498eed50a114565debd38f173acd62cce6e7cb8
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Dec 3 13:58:57 2005 -0800

    [CIFS] Add extended stats (STATS2) for total buffer allocations for
    better performance debugging.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1ba08f8c5bc4..c011c278af4c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -505,8 +505,12 @@ GLOBAL_EXTERN atomic_t tcpSesReconnectCount;
 GLOBAL_EXTERN atomic_t tconInfoReconnectCount;
 
 /* Various Debug counters to remove someday (BB) */
-GLOBAL_EXTERN atomic_t bufAllocCount;
-GLOBAL_EXTERN atomic_t smBufAllocCount;      
+GLOBAL_EXTERN atomic_t bufAllocCount;    /* current number allocated  */
+#ifdef CONFIG_CIFS_STATS2
+GLOBAL_EXTERN atomic_t totBufAllocCount; /* total allocated over all time */
+GLOBAL_EXTERN atomic_t totSmBufAllocCount;
+#endif
+GLOBAL_EXTERN atomic_t smBufAllocCount;
 GLOBAL_EXTERN atomic_t midCount;
 
 /* Misc globals */

commit 23e7dd7d95f6fdc167a6d6ddea79ced0af33bbff
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Oct 20 13:44:56 2005 -0700

    [CIFS] Defer close of file handle slightly if there are pending writes that
    need to get in ahead of it that depend on that file handle. Fixes
    occassional bad file handle errors on write with heavy use multiple process
    cases.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 839a55667c3c..1ba08f8c5bc4 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -299,6 +299,7 @@ struct cifsFileInfo {
 	struct inode * pInode; /* needed for oplock break */
 	unsigned closePend:1;	/* file is marked to close */
 	unsigned invalidHandle:1;  /* file closed via session abend */
+	atomic_t wrtPending;   /* handle in use - defer close */
 	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
 	char * search_resume_name; /* BB removeme BB */
 	unsigned int resume_name_length; /* BB removeme - field renamed and moved BB */

commit 1047abc159b4eb4ba4a7342a0969e16e9d4b4c69
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Oct 11 19:58:06 2005 -0700

    [CIFS] CIFS Stats improvements
    
    New cifs_writepages routine was not updated bytes written in cifs stats.
    Also added ability to clear /proc/fs/cifs/Stats by writing (0 or 1) to it.
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 729717281b40..839a55667c3c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -377,7 +377,11 @@ struct mid_q_entry {
 	__u16 mid;		/* multiplex id */
 	__u16 pid;		/* process id */
 	__u32 sequence_number;  /* for CIFS signing */
-	struct timeval when_sent;	/* time when smb sent */
+	unsigned long when_alloc;  /* when mid was created */
+#ifdef CONFIG_CIFS_STATS2
+	unsigned long when_sent; /* time when smb send finished */
+	unsigned long when_received; /* when demux complete (taken off wire) */
+#endif
 	struct cifsSesInfo *ses;	/* smb was sent to this server */
 	struct task_struct *tsk;	/* task waiting for response */
 	struct smb_hdr *resp_buf;	/* response buffer */

commit 131afd0b748e382c3a00355d3fa245801f929298
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Oct 7 09:51:05 2005 -0700

    [CIFS] /proc/fs/cifs debug code cleanup and new stats2
    
    These changes to debug code and new stats are helpful in
    debugging potential tcp performance/configuration problems under cifs.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index cd421c76805e..729717281b40 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -123,13 +123,17 @@ struct TCP_Server_Info {
 	struct list_head pending_mid_q;
 	void *Server_NlsInfo;	/* BB - placeholder for future NLS info  */
 	unsigned short server_codepage;	/* codepage for the server    */
-	unsigned long ip_address;	/* IP addr for the server if known     */
+	unsigned long ip_address;	/* IP addr for the server if known */
 	enum protocolEnum protocolType;	
 	char versionMajor;
 	char versionMinor;
 	unsigned svlocal:1;	/* local server or remote */
 	atomic_t socketUseCount; /* number of open cifs sessions on socket */
 	atomic_t inFlight;  /* number of requests on the wire to server */
+#ifdef CONFIG_CIFS_STATS2
+	atomic_t inSend; /* requests trying to send */
+	atomic_t num_waiters;   /* blocked waiting to get in sendrecv */
+#endif
 	enum statusEnum tcpStatus; /* what we think the status is */
 	struct semaphore tcpSem;
 	struct task_struct *tsk;

commit ab2f218f4fa2c36ecd39ac1406eec1e63cd430bd
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Sep 15 20:44:50 2005 -0700

    [CIFS] Fix compiler warnings
    
    Fix some compiler warnings noticed on x64 by me and ppc64 by Shaggy
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a9c791edede5..cd421c76805e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -331,7 +331,7 @@ CIFS_SB(struct super_block *sb)
 	return sb->s_fs_info;
 }
 
-static inline const char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
+static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
 {
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 		return '/';

commit e22cb8bcb8bce94bf5cca90c98933a28816c6a75
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Aug 24 20:25:21 2005 -0700

    [CIFS] Use file instead of dentry in cifs dir_notify struct
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 236de07cbda6..a9c791edede5 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -402,7 +402,7 @@ struct dir_notify_req {
        __u16 netfid;
        __u32 filter; /* CompletionFilter (for multishot) */
        int multishot;
-       struct file * dentry;
+       struct file * pfile;
 };
 
 #define   MID_FREE 0

commit 167a251ad6678ad26aa3cf27bab677b274374ab6
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Aug 24 20:03:11 2005 -0700

    [CIFS] Change notify support part 3
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 92fba7609e67..236de07cbda6 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -402,7 +402,7 @@ struct dir_notify_req {
        __u16 netfid;
        __u32 filter; /* CompletionFilter (for multishot) */
        int multishot;
-       struct dentry * dentry;
+       struct file * dentry;
 };
 
 #define   MID_FREE 0

commit ff5dbd9ead0d82466cab8bdbdcbc9666707d328a
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Aug 24 17:10:36 2005 -0700

    [CIFS] Change notify support part 2
    
    Signed-off-by: Asser Ferno <asser@diku.dk>
    Signed-off-by: Steve French <sfrench@us.ibm.com> and lightly modified

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9a3c85bdd77e..92fba7609e67 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -391,6 +391,20 @@ struct oplock_q_entry {
 	__u16 netfid;
 };
 
+/* for pending dnotify requests */
+struct dir_notify_req {
+       struct list_head lhead;
+       __le16 Pid;
+       __le16 PidHigh;
+       __u16 Mid;
+       __u16 Tid;
+       __u16 Uid;
+       __u16 netfid;
+       __u32 filter; /* CompletionFilter (for multishot) */
+       int multishot;
+       struct dentry * dentry;
+};
+
 #define   MID_FREE 0
 #define   MID_REQUEST_ALLOCATED 1
 #define   MID_REQUEST_SUBMITTED 2
@@ -459,6 +473,9 @@ GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */
 
 GLOBAL_EXTERN struct list_head GlobalOplock_Q;
 
+GLOBAL_EXTERN struct list_head GlobalDnotifyReqList; /* Outstanding dir notify requests */
+GLOBAL_EXTERN struct list_head GlobalDnotifyRsp_Q; /* Dir notify response queue */
+
 /*
  * Global transaction id (XID) information
  */

commit a45443475835ab4d1c753159812aca21b5c333a3
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Aug 24 13:59:35 2005 -0700

    CIFS: Reduce CONFIG_CIFS_STATS ifdefs
    
    Make cifs_stats code conditional in the header files to avoid ifdefs in the
    main code.
    
    Signed-off-by: Dave Kleikamp <shaggy@austin.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index f143975627e0..9a3c85bdd77e 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -339,6 +339,34 @@ static inline const char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
 		return '\\';
 }
 
+#ifdef CONFIG_CIFS_STATS
+#define cifs_stats_inc atomic_inc
+
+static inline void cifs_stats_bytes_written(struct cifsTconInfo *tcon,
+					    unsigned int bytes)
+{
+	if (bytes) {
+		spin_lock(&tcon->stat_lock);
+		tcon->bytes_written += bytes;
+		spin_unlock(&tcon->stat_lock);
+	}
+}
+
+static inline void cifs_stats_bytes_read(struct cifsTconInfo *tcon,
+					 unsigned int bytes)
+{
+	spin_lock(&tcon->stat_lock);
+	tcon->bytes_read += bytes;
+	spin_unlock(&tcon->stat_lock);
+}
+#else
+
+#define  cifs_stats_inc(field) do {} while(0)
+#define  cifs_stats_bytes_written(tcon, bytes) do {} while(0)
+#define  cifs_stats_bytes_read(tcon, bytes) do {} while(0)
+
+#endif
+
 /* one of these for every pending CIFS request to the server */
 struct mid_q_entry {
 	struct list_head qhead;	/* mids waiting on reply from this server */

commit a10faeb2a3e266385cc334fe9af76e08e5e4330f
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Aug 22 21:38:31 2005 -0700

    [CIFS] Support for mounting to older, pre-CIFS servers added.  This
    allows specifying an RFC1001 target "called" name (netbios name of the
    server, which can now be pecified as mount option "servernetbiosname"
    but will eventually be passed in automatically on retry of host down
    error messages caused when server refuses to handle default server
    name and can not handle port 445). This is an important step, but
    additional testing and fixup is needed to add remaining function needed
    for these.
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 6a8c7d1bee8c..f143975627e0 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -110,7 +110,8 @@ enum protocolEnum {
  */
 
 struct TCP_Server_Info {
-	char server_Name[SERVER_NAME_LEN_WITH_NULL]; /* 15 chars + X'20' 16th */
+	/* 15 character server name + 0x20 16th byte indicating type = srv */
+	char server_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
 	char unicode_server_Name[SERVER_NAME_LEN_WITH_NULL * 2];
 	struct socket *ssocket;
 	union {
@@ -149,7 +150,8 @@ struct TCP_Server_Info {
 	__u16 timeZone;
 	__u16 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
-	char workstation_RFC1001_name[16]; /* 16th byte is always zero */
+	/* 16th byte of RFC1001 workstation name is always null */
+	char workstation_RFC1001_name[SERVER_NAME_LEN_WITH_NULL];
 	__u32 sequence_number; /* needed for CIFS PDU signature */
 	char mac_signing_key[CIFS_SESSION_KEY_SIZE + 16]; 
 };

commit a5a2b489bae8f66559a531df99a26eb16b42299e
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Aug 20 21:42:53 2005 -0700

    [CIFS] Make CIFS statistics more accurate and add some stats that were
    missing.  Most importantly SMB reads were undercounted.
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e7ba48c61a7a..6a8c7d1bee8c 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -215,6 +215,7 @@ struct cifsTconInfo {
 	atomic_t num_reads;
 	atomic_t num_oplock_brks;
 	atomic_t num_opens;
+	atomic_t num_closes;
 	atomic_t num_deletes;
 	atomic_t num_mkdirs;
 	atomic_t num_rmdirs;
@@ -223,10 +224,27 @@ struct cifsTconInfo {
 	atomic_t num_ffirst;
 	atomic_t num_fnext;
 	atomic_t num_fclose;
+	atomic_t num_hardlinks;
+	atomic_t num_symlinks;
+	atomic_t num_locks;
+#ifdef CONFIG_CIFS_STATS2
+	unsigned long long time_writes;
+	unsigned long long time_reads;
+	unsigned long long time_opens;
+	unsigned long long time_deletes;
+	unsigned long long time_closes;
+	unsigned long long time_mkdirs;
+	unsigned long long time_rmdirs;
+	unsigned long long time_renames;
+	unsigned long long time_t2renames;
+	unsigned long long time_ffirst;
+	unsigned long long time_fnext;
+	unsigned long long time_fclose;
+#endif /* CONFIG_CIFS_STATS2 */
 	__u64    bytes_read;
 	__u64    bytes_written;
 	spinlock_t stat_lock;
-#endif
+#endif /* CONFIG_CIFS_STATS */
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo;	/* ok if file system name truncated */
 	FILE_SYSTEM_UNIX_INFO fsUnixInfo;

commit d3485d37c0b3292aec0618b6663c57542df5da99
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Aug 19 11:04:29 2005 -0700

    [CIFS] Finish cifs mount option which requests case insensitive path
    name matching.
    
            Signed-off-by:  Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index e8287f76484f..e7ba48c61a7a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -110,8 +110,8 @@ enum protocolEnum {
  */
 
 struct TCP_Server_Info {
-	char server_Name[SERVER_NAME_LEN_WITH_NULL];	/* 15 chars + X'20'in 16th */
-	char unicode_server_Name[SERVER_NAME_LEN_WITH_NULL * 2];	/* Unicode version of server_Name */
+	char server_Name[SERVER_NAME_LEN_WITH_NULL]; /* 15 chars + X'20' 16th */
+	char unicode_server_Name[SERVER_NAME_LEN_WITH_NULL * 2];
 	struct socket *ssocket;
 	union {
 		struct sockaddr_in sockAddr;
@@ -231,6 +231,7 @@ struct cifsTconInfo {
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo;	/* ok if file system name truncated */
 	FILE_SYSTEM_UNIX_INFO fsUnixInfo;
 	unsigned retry:1;
+	unsigned nocase:1;
 	/* BB add field for back pointer to sb struct? */
 };
 

commit 1982c344f1bf08118f7c224958b30c64e162009e
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Aug 17 12:38:22 2005 -0700

    [CIFS] Ensure that cifs multiplex ids do not collide.
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index d3773e57acf9..e8287f76484f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -147,6 +147,7 @@ struct TCP_Server_Info {
 	/* (returned on Negotiate */
 	int capabilities; /* allow selective disabling of caps by smb sess */
 	__u16 timeZone;
+	__u16 CurrentMid;         /* multiplex id - rotating counter */
 	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
 	char workstation_RFC1001_name[16]; /* 16th byte is always zero */
 	__u32 sequence_number; /* needed for CIFS PDU signature */

commit ac67055ef2378ea95c34b593ddf9d0a0737a240a
Author: Jeremy Allison <jra@samba.org>
Date:   Wed Jun 22 17:26:35 2005 -0700

    [CIFS] POSIX extensions, SetFSInfo added
    
    Signed-off-by: Steve French@sfrench@us.ibm.com
    Signed-off-by: Jeremy Allison (jra@samba.org)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 4ed9c13fff55..d3773e57acf9 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -309,6 +309,13 @@ CIFS_SB(struct super_block *sb)
 	return sb->s_fs_info;
 }
 
+static inline const char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)
+{
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
+		return '/';
+	else
+		return '\\';
+}
 
 /* one of these for every pending CIFS request to the server */
 struct mid_q_entry {

commit dfb7533b5f157ac7135da23883e80d895227d965
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Jun 22 17:13:47 2005 -0700

    [CIFS] Add stats for findfirst, findnext, findclose
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 81babab265e1..4ed9c13fff55 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -219,6 +219,9 @@ struct cifsTconInfo {
 	atomic_t num_rmdirs;
 	atomic_t num_renames;
 	atomic_t num_t2renames;
+	atomic_t num_ffirst;
+	atomic_t num_fnext;
+	atomic_t num_fclose;
 	__u64    bytes_read;
 	__u64    bytes_written;
 	spinlock_t stat_lock;

commit 79944bf71352f33f984ac3973b159b5c2cee139d
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:09 2005 -0700

    [PATCH] cifs: missing semicolon from previous fix
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 8fc0801f8457..81babab265e1 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -321,7 +321,7 @@ struct mid_q_entry {
 	__u8 command;	/* smb command code */
 	unsigned multiPart:1;	/* multiple responses to one SMB request */
 	unsigned largeBuf:1;    /* if valid response, is pointer to large buf */
-	unsigned multiResp:1    /* multiple trans2 responses for one request  */
+	unsigned multiResp:1;   /* multiple trans2 responses for one request  */
 };
 
 struct oplock_q_entry {

commit 67010fbc6ff889aaf86592bc148d705c5b9e1a27
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:09 2005 -0700

    [PATCH] cifs: Better handle errors on second socket recv message call
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 322a12450ad3..8fc0801f8457 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/cifsglob.h
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2003
+ *   Copyright (C) International Business Machines  Corp., 2002,2005
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
  *   This library is free software; you can redistribute it and/or modify
@@ -321,6 +321,7 @@ struct mid_q_entry {
 	__u8 command;	/* smb command code */
 	unsigned multiPart:1;	/* multiple responses to one SMB request */
 	unsigned largeBuf:1;    /* if valid response, is pointer to large buf */
+	unsigned multiResp:1    /* multiple trans2 responses for one request  */
 };
 
 struct oplock_q_entry {

commit c81156dd217818c143a09b6a744e797a04571e99
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:07 2005 -0700

    [PATCH] cifs: cleanup of ifdefs usage so it is more consistent
    
    And fix to not needlessly send new POSIX QFSInfo when server does not
    explicitly claim support for the new protocol extensions.
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index fe1409799513..322a12450ad3 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -318,7 +318,9 @@ struct mid_q_entry {
 	struct task_struct *tsk;	/* task waiting for response */
 	struct smb_hdr *resp_buf;	/* response buffer */
 	int midState;	/* wish this were enum but can not pass to wait_event */
-	__u8 command;		/* smb command code */
+	__u8 command;	/* smb command code */
+	unsigned multiPart:1;	/* multiple responses to one SMB request */
+	unsigned largeBuf:1;    /* if valid response, is pointer to large buf */
 };
 
 struct oplock_q_entry {

commit 848f3fce45d2ba93e10b5e9d65bcae0d9269ad0d
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:07 2005 -0700

    [PATCH] cifs: Do not interpret oplock break responses as responses to an unrelated command
    
    .. even if the multiplex ids match.
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 1b3082d79379..fe1409799513 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -313,12 +313,12 @@ struct mid_q_entry {
 	__u16 mid;		/* multiplex id */
 	__u16 pid;		/* process id */
 	__u32 sequence_number;  /* for CIFS signing */
-	__u16 command;		/* smb command code */
 	struct timeval when_sent;	/* time when smb sent */
 	struct cifsSesInfo *ses;	/* smb was sent to this server */
 	struct task_struct *tsk;	/* task waiting for response */
 	struct smb_hdr *resp_buf;	/* response buffer */
 	int midState;	/* wish this were enum but can not pass to wait_event */
+	__u8 command;		/* smb command code */
 };
 
 struct oplock_q_entry {

commit ad009ac96509e005d9978d0ae9e9ec4d63ad2990
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:05 2005 -0700

    [PATCH] cifs: Fix multiuser packet signing to use the right sequence number and mac session key
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 69aff1a7da9b..1b3082d79379 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -149,6 +149,8 @@ struct TCP_Server_Info {
 	__u16 timeZone;
 	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
 	char workstation_RFC1001_name[16]; /* 16th byte is always zero */
+	__u32 sequence_number; /* needed for CIFS PDU signature */
+	char mac_signing_key[CIFS_SESSION_KEY_SIZE + 16]; 
 };
 
 /*
@@ -174,17 +176,16 @@ struct cifsSesInfo {
 	struct TCP_Server_Info *server;	/* pointer to server info */
 	atomic_t inUse; /* # of mounts (tree connections) on this ses */
 	enum statusEnum status;
-	__u32 sequence_number;  /* needed for CIFS PDU signature */
 	__u16 ipc_tid;		/* special tid for connection to IPC share */
 	__u16 flags;
-	char mac_signing_key[CIFS_SESSION_KEY_SIZE + 16];	
-	char *serverOS;		/* name of operating system underlying the server */
-	char *serverNOS;	/* name of network operating system that the server is running */
+	char *serverOS;		/* name of operating system underlying server */
+	char *serverNOS;	/* name of network operating system of server */
 	char *serverDomain;	/* security realm of server */
 	int Suid;		/* remote smb uid  */
 	uid_t linux_uid;        /* local Linux uid */
 	int capabilities;
-	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for tcp names - will ipv6 and sctp addresses fit here?? */
+	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for 
+				TCP names - will ipv6 and sctp addresses fit? */
 	char userName[MAX_USERNAME_SIZE + 1];
 	char domainName[MAX_USERNAME_SIZE + 1];
 	char * password;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
new file mode 100644
index 000000000000..69aff1a7da9b
--- /dev/null
+++ b/fs/cifs/cifsglob.h
@@ -0,0 +1,439 @@
+/*
+ *   fs/cifs/cifsglob.h
+ *
+ *   Copyright (C) International Business Machines  Corp., 2002,2003
+ *   Author(s): Steve French (sfrench@us.ibm.com)
+ *
+ *   This library is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU Lesser General Public License as published
+ *   by the Free Software Foundation; either version 2.1 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU Lesser General Public License for more details.
+ * 
+ */
+#include <linux/in.h>
+#include <linux/in6.h>
+#include "cifs_fs_sb.h"
+/*
+ * The sizes of various internal tables and strings
+ */
+#define MAX_UID_INFO 16
+#define MAX_SES_INFO 2
+#define MAX_TCON_INFO 4
+
+#define MAX_TREE_SIZE 2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1
+#define MAX_SERVER_SIZE 15
+#define MAX_SHARE_SIZE  64	/* used to be 20 - this should still be enough */
+#define MAX_USERNAME_SIZE 32	/* 32 is to allow for 15 char names + null
+				   termination then *2 for unicode versions */
+#define MAX_PASSWORD_SIZE 16
+
+#define CIFS_MIN_RCV_POOL 4
+
+/*
+ * MAX_REQ is the maximum number of requests that WE will send
+ * on one socket concurently. It also matches the most common
+ * value of max multiplex returned by servers.  We may 
+ * eventually want to use the negotiated value (in case
+ * future servers can handle more) when we are more confident that
+ * we will not have problems oveloading the socket with pending
+ * write data.
+ */
+#define CIFS_MAX_REQ 50 
+
+#define SERVER_NAME_LENGTH 15
+#define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)
+
+/* used to define string lengths for reversing unicode strings */
+/*         (256+1)*2 = 514                                     */
+/*           (max path length + 1 for null) * 2 for unicode    */
+#define MAX_NAME 514
+
+#include "cifspdu.h"
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef XATTR_DOS_ATTRIB
+#define XATTR_DOS_ATTRIB "user.DOSATTRIB"
+#endif
+
+/*
+ * This information is kept on every Server we know about.
+ *
+ * Some things to note:
+ *
+ */
+#define SERVER_NAME_LEN_WITH_NULL	(SERVER_NAME_LENGTH + 1)
+
+/*
+ * CIFS vfs client Status information (based on what we know.)
+ */
+
+ /* associated with each tcp and smb session */
+enum statusEnum {
+	CifsNew = 0,
+	CifsGood,
+	CifsExiting,
+	CifsNeedReconnect
+};
+
+enum securityEnum {
+	NTLM = 0,		/* Legacy NTLM012 auth with NTLM hash */
+	NTLMv2,			/* Legacy NTLM auth with NTLMv2 hash */
+	RawNTLMSSP,		/* NTLMSSP without SPNEGO */
+	NTLMSSP,		/* NTLMSSP via SPNEGO */
+	Kerberos		/* Kerberos via SPNEGO */
+};
+
+enum protocolEnum {
+	IPV4 = 0,
+	IPV6,
+	SCTP
+	/* Netbios frames protocol not supported at this time */
+};
+
+/*
+ *****************************************************************
+ * Except the CIFS PDUs themselves all the
+ * globally interesting structs should go here
+ *****************************************************************
+ */
+
+struct TCP_Server_Info {
+	char server_Name[SERVER_NAME_LEN_WITH_NULL];	/* 15 chars + X'20'in 16th */
+	char unicode_server_Name[SERVER_NAME_LEN_WITH_NULL * 2];	/* Unicode version of server_Name */
+	struct socket *ssocket;
+	union {
+		struct sockaddr_in sockAddr;
+		struct sockaddr_in6 sockAddr6;
+	} addr;
+	wait_queue_head_t response_q; 
+	wait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/
+	struct list_head pending_mid_q;
+	void *Server_NlsInfo;	/* BB - placeholder for future NLS info  */
+	unsigned short server_codepage;	/* codepage for the server    */
+	unsigned long ip_address;	/* IP addr for the server if known     */
+	enum protocolEnum protocolType;	
+	char versionMajor;
+	char versionMinor;
+	unsigned svlocal:1;	/* local server or remote */
+	atomic_t socketUseCount; /* number of open cifs sessions on socket */
+	atomic_t inFlight;  /* number of requests on the wire to server */
+	enum statusEnum tcpStatus; /* what we think the status is */
+	struct semaphore tcpSem;
+	struct task_struct *tsk;
+	char server_GUID[16];
+	char secMode;
+	enum securityEnum secType;
+	unsigned int maxReq;	/* Clients should submit no more */
+	/* than maxReq distinct unanswered SMBs to the server when using  */
+	/* multiplexed reads or writes */
+	unsigned int maxBuf;	/* maxBuf specifies the maximum */
+	/* message size the server can send or receive for non-raw SMBs */
+	unsigned int maxRw;	/* maxRw specifies the maximum */
+	/* message size the server can send or receive for */
+	/* SMB_COM_WRITE_RAW or SMB_COM_READ_RAW. */
+	char sessid[4];		/* unique token id for this session */
+	/* (returned on Negotiate */
+	int capabilities; /* allow selective disabling of caps by smb sess */
+	__u16 timeZone;
+	char cryptKey[CIFS_CRYPTO_KEY_SIZE];
+	char workstation_RFC1001_name[16]; /* 16th byte is always zero */
+};
+
+/*
+ * The following is our shortcut to user information.  We surface the uid,
+ * and name. We always get the password on the fly in case it
+ * has changed. We also hang a list of sessions owned by this user off here. 
+ */
+struct cifsUidInfo {
+	struct list_head userList;
+	struct list_head sessionList; /* SMB sessions for this user */
+	uid_t linux_uid;
+	char user[MAX_USERNAME_SIZE + 1];	/* ascii name of user */
+	/* BB may need ptr or callback for PAM or WinBind info */
+};
+
+/*
+ * Session structure.  One of these for each uid session with a particular host
+ */
+struct cifsSesInfo {
+	struct list_head cifsSessionList;
+	struct semaphore sesSem;
+	struct cifsUidInfo *uidInfo;	/* pointer to user info */
+	struct TCP_Server_Info *server;	/* pointer to server info */
+	atomic_t inUse; /* # of mounts (tree connections) on this ses */
+	enum statusEnum status;
+	__u32 sequence_number;  /* needed for CIFS PDU signature */
+	__u16 ipc_tid;		/* special tid for connection to IPC share */
+	__u16 flags;
+	char mac_signing_key[CIFS_SESSION_KEY_SIZE + 16];	
+	char *serverOS;		/* name of operating system underlying the server */
+	char *serverNOS;	/* name of network operating system that the server is running */
+	char *serverDomain;	/* security realm of server */
+	int Suid;		/* remote smb uid  */
+	uid_t linux_uid;        /* local Linux uid */
+	int capabilities;
+	char serverName[SERVER_NAME_LEN_WITH_NULL * 2];	/* BB make bigger for tcp names - will ipv6 and sctp addresses fit here?? */
+	char userName[MAX_USERNAME_SIZE + 1];
+	char domainName[MAX_USERNAME_SIZE + 1];
+	char * password;
+};
+/* session flags */
+#define CIFS_SES_NT4 1
+
+/*
+ * there is one of these for each connection to a resource on a particular
+ * session 
+ */
+struct cifsTconInfo {
+	struct list_head cifsConnectionList;
+	struct list_head openFileList;
+	struct semaphore tconSem;
+	struct cifsSesInfo *ses;	/* pointer to session associated with */
+	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource (in ASCII not UTF) */
+	char *nativeFileSystem;
+	__u16 tid;		/* The 2 byte tree id */
+	__u16 Flags;		/* optional support bits */
+	enum statusEnum tidStatus;
+	atomic_t useCount;	/* how many mounts (explicit or implicit) to this share */
+#ifdef CONFIG_CIFS_STATS
+	atomic_t num_smbs_sent;
+	atomic_t num_writes;
+	atomic_t num_reads;
+	atomic_t num_oplock_brks;
+	atomic_t num_opens;
+	atomic_t num_deletes;
+	atomic_t num_mkdirs;
+	atomic_t num_rmdirs;
+	atomic_t num_renames;
+	atomic_t num_t2renames;
+	__u64    bytes_read;
+	__u64    bytes_written;
+	spinlock_t stat_lock;
+#endif
+	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
+	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo;	/* ok if file system name truncated */
+	FILE_SYSTEM_UNIX_INFO fsUnixInfo;
+	unsigned retry:1;
+	/* BB add field for back pointer to sb struct? */
+};
+
+/*
+ * This info hangs off the cifsFileInfo structure.  This is used to track
+ * byte stream locks on the file
+ */
+struct cifsLockInfo {
+	struct cifsLockInfo *next;
+	int start;
+	int length;
+	int type;
+};
+
+/*
+ * One of these for each open instance of a file
+ */
+struct cifs_search_info {
+	loff_t index_of_last_entry;
+	__u16 entries_in_buffer;
+	__u16 info_level;
+	__u32 resume_key;
+	char * ntwrk_buf_start;
+	char * srch_entries_start;
+	char * presume_name;
+	unsigned int resume_name_len;
+	unsigned endOfSearch:1;
+	unsigned emptyDir:1;
+	unsigned unicode:1;
+};
+
+struct cifsFileInfo {
+	struct list_head tlist;	/* pointer to next fid owned by tcon */
+	struct list_head flist;	/* next fid (file instance) for this inode */
+	unsigned int uid;	/* allows finding which FileInfo structure */
+	__u32 pid;		/* process id who opened file */
+	__u16 netfid;		/* file id from remote */
+	/* BB add lock scope info here if needed */ ;
+	/* lock scope id (0 if none) */
+	struct file * pfile; /* needed for writepage */
+	struct inode * pInode; /* needed for oplock break */
+	unsigned closePend:1;	/* file is marked to close */
+	unsigned invalidHandle:1;  /* file closed via session abend */
+	struct semaphore fh_sem; /* prevents reopen race after dead ses*/
+	char * search_resume_name; /* BB removeme BB */
+	unsigned int resume_name_length; /* BB removeme - field renamed and moved BB */
+	struct cifs_search_info srch_inf;
+};
+
+/*
+ * One of these for each file inode
+ */
+
+struct cifsInodeInfo {
+	struct list_head lockList;
+	/* BB add in lists for dirty pages - i.e. write caching info for oplock */
+	struct list_head openFileList;
+	int write_behind_rc;
+	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
+	atomic_t inUse;	 /* num concurrent users (local openers cifs) of file*/
+	unsigned long time;	/* jiffies of last update/check of inode */
+	unsigned clientCanCacheRead:1; /* read oplock */
+	unsigned clientCanCacheAll:1;  /* read and writebehind oplock */
+	unsigned oplockPending:1;
+	struct inode vfs_inode;
+};
+
+static inline struct cifsInodeInfo *
+CIFS_I(struct inode *inode)
+{
+	return container_of(inode, struct cifsInodeInfo, vfs_inode);
+}
+
+static inline struct cifs_sb_info *
+CIFS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+
+
+/* one of these for every pending CIFS request to the server */
+struct mid_q_entry {
+	struct list_head qhead;	/* mids waiting on reply from this server */
+	__u16 mid;		/* multiplex id */
+	__u16 pid;		/* process id */
+	__u32 sequence_number;  /* for CIFS signing */
+	__u16 command;		/* smb command code */
+	struct timeval when_sent;	/* time when smb sent */
+	struct cifsSesInfo *ses;	/* smb was sent to this server */
+	struct task_struct *tsk;	/* task waiting for response */
+	struct smb_hdr *resp_buf;	/* response buffer */
+	int midState;	/* wish this were enum but can not pass to wait_event */
+};
+
+struct oplock_q_entry {
+	struct list_head qhead;
+	struct inode * pinode;
+	struct cifsTconInfo * tcon; 
+	__u16 netfid;
+};
+
+#define   MID_FREE 0
+#define   MID_REQUEST_ALLOCATED 1
+#define   MID_REQUEST_SUBMITTED 2
+#define   MID_RESPONSE_RECEIVED 4
+#define   MID_RETRY_NEEDED      8 /* session closed while this request out */
+#define   MID_NO_RESP_NEEDED 0x10
+#define   MID_SMALL_BUFFER   0x20 /* 112 byte response buffer instead of 4K */
+
+/*
+ *****************************************************************
+ * All constants go here
+ *****************************************************************
+ */
+
+#define UID_HASH (16)
+
+/*
+ * Note that ONE module should define _DECLARE_GLOBALS_HERE to cause the
+ * following to be declared.
+ */
+
+/****************************************************************************
+ *  Locking notes.  All updates to global variables and lists should be
+ *                  protected by spinlocks or semaphores.
+ *
+ *  Spinlocks
+ *  ---------
+ *  GlobalMid_Lock protects:
+ *	list operations on pending_mid_q and oplockQ
+ *      updates to XID counters, multiplex id  and SMB sequence numbers
+ *  GlobalSMBSesLock protects:
+ *	list operations on tcp and SMB session lists and tCon lists
+ *  f_owner.lock protects certain per file struct operations
+ *  mapping->page_lock protects certain per page operations
+ *
+ *  Semaphores
+ *  ----------
+ *  sesSem     operations on smb session
+ *  tconSem    operations on tree connection
+ *  fh_sem      file handle reconnection operations 
+ *
+ ****************************************************************************/
+
+#ifdef DECLARE_GLOBALS_HERE
+#define GLOBAL_EXTERN
+#else
+#define GLOBAL_EXTERN extern
+#endif
+
+/*
+ * The list of servers that did not respond with NT LM 0.12.
+ * This list helps improve performance and eliminate the messages indicating
+ * that we had a communications error talking to the server in this list. 
+ */
+GLOBAL_EXTERN struct servers_not_supported *NotSuppList;	/*@z4a */
+
+/*
+ * The following is a hash table of all the users we know about.
+ */
+GLOBAL_EXTERN struct smbUidInfo *GlobalUidList[UID_HASH];
+
+GLOBAL_EXTERN struct list_head GlobalServerList; /* BB not implemented yet */
+GLOBAL_EXTERN struct list_head GlobalSMBSessionList;
+GLOBAL_EXTERN struct list_head GlobalTreeConnectionList;
+GLOBAL_EXTERN rwlock_t GlobalSMBSeslock;  /* protects list inserts on 3 above */
+
+GLOBAL_EXTERN struct list_head GlobalOplock_Q;
+
+/*
+ * Global transaction id (XID) information
+ */
+GLOBAL_EXTERN unsigned int GlobalCurrentXid;	/* protected by GlobalMid_Sem */
+GLOBAL_EXTERN unsigned int GlobalTotalActiveXid;	/* prot by GlobalMid_Sem */
+GLOBAL_EXTERN unsigned int GlobalMaxActiveXid;	/* prot by GlobalMid_Sem */
+GLOBAL_EXTERN spinlock_t GlobalMid_Lock;  /* protects above and list operations */
+					/* on midQ entries */
+GLOBAL_EXTERN char Local_System_Name[15];
+
+/*
+ *  Global counters, updated atomically
+ */
+GLOBAL_EXTERN atomic_t sesInfoAllocCount;
+GLOBAL_EXTERN atomic_t tconInfoAllocCount;
+GLOBAL_EXTERN atomic_t tcpSesAllocCount;
+GLOBAL_EXTERN atomic_t tcpSesReconnectCount;
+GLOBAL_EXTERN atomic_t tconInfoReconnectCount;
+
+/* Various Debug counters to remove someday (BB) */
+GLOBAL_EXTERN atomic_t bufAllocCount;
+GLOBAL_EXTERN atomic_t smBufAllocCount;      
+GLOBAL_EXTERN atomic_t midCount;
+
+/* Misc globals */
+GLOBAL_EXTERN unsigned int multiuser_mount;	/* if enabled allows new sessions
+				to be established on existing mount if we
+				have the uid/password or Kerberos credential 
+				or equivalent for current user */
+GLOBAL_EXTERN unsigned int oplockEnabled;
+GLOBAL_EXTERN unsigned int experimEnabled;
+GLOBAL_EXTERN unsigned int lookupCacheEnabled;
+GLOBAL_EXTERN unsigned int extended_security;	/* if on, session setup sent 
+				with more secure ntlmssp2 challenge/resp */
+GLOBAL_EXTERN unsigned int ntlmv2_support;  /* better optional password hash */
+GLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
+GLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/
+GLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */
+GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
+GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
+GLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/
+
