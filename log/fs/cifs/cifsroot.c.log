commit a0a3036b81f1f66fa3333559ecfe18f5bbfa5076
Author: Joe Perches <joe@perches.com>
Date:   Tue Apr 14 22:42:53 2020 -0700

    cifs: Standardize logging output
    
    Use pr_fmt to standardize all logging for fs/cifs.
    
    Some logging output had no CIFS: specific prefix.
    
    Now all output has one of three prefixes:
    
    o CIFS:
    o CIFS: VFS:
    o Root-CIFS:
    
    Miscellanea:
    
    o Convert printks to pr_<level>
    o Neaten macro definitions
    o Remove embedded CIFS: prefixes from formats
    o Convert "illegal" to "invalid"
    o Coalesce formats
    o Add missing '\n' format terminations
    o Consolidate multiple cifs_dbg continuations into single calls
    o More consistent use of upper case first word output logging
    o Multiline statement argument alignment and wrapping
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsroot.c b/fs/cifs/cifsroot.c
index 37edbfb8e096..9e91a5a40aae 100644
--- a/fs/cifs/cifsroot.c
+++ b/fs/cifs/cifsroot.c
@@ -56,7 +56,7 @@ static int __init cifs_root_setup(char *line)
 		/* len is strlen(unc) + '\0' */
 		len = s - line + 1;
 		if (len > sizeof(root_dev)) {
-			printk(KERN_ERR "Root-CIFS: UNC path too long\n");
+			pr_err("Root-CIFS: UNC path too long\n");
 			return 1;
 		}
 		strlcpy(root_dev, line, len);
@@ -66,7 +66,7 @@ static int __init cifs_root_setup(char *line)
 					 sizeof(root_opts), "%s,%s",
 					 DEFAULT_MNT_OPTS, s + 1);
 			if (n >= sizeof(root_opts)) {
-				printk(KERN_ERR "Root-CIFS: mount options string too long\n");
+				pr_err("Root-CIFS: mount options string too long\n");
 				root_opts[sizeof(root_opts)-1] = '\0';
 				return 1;
 			}
@@ -83,7 +83,7 @@ __setup("cifsroot=", cifs_root_setup);
 int __init cifs_root_data(char **dev, char **opts)
 {
 	if (!root_dev[0] || root_server_addr == htonl(INADDR_NONE)) {
-		printk(KERN_ERR "Root-CIFS: no SMB server address\n");
+		pr_err("Root-CIFS: no SMB server address\n");
 		return -1;
 	}
 

commit 352f2c9a570d38bced287a273e79dccae7c5ef41
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Mon Sep 16 05:45:42 2019 +0200

    cifs: cifsroot: add more err checking
    
    make cifs more verbose about buffer size errors
    and add some comments
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsroot.c b/fs/cifs/cifsroot.c
index 8760d9cbf25e..37edbfb8e096 100644
--- a/fs/cifs/cifsroot.c
+++ b/fs/cifs/cifsroot.c
@@ -24,6 +24,7 @@ static char root_opts[1024] __initdata = DEFAULT_MNT_OPTS;
 
 static __be32 __init parse_srvaddr(char *start, char *end)
 {
+	/* TODO: ipv6 support */
 	char addr[sizeof("aaa.bbb.ccc.ddd")];
 	int i = 0;
 
@@ -50,14 +51,24 @@ static int __init cifs_root_setup(char *line)
 		if (!s || s[1] == '\0')
 			return 1;
 
+		/* make s point to ',' or '\0' at end of line */
 		s = strchrnul(s, ',');
+		/* len is strlen(unc) + '\0' */
 		len = s - line + 1;
-		if (len <= sizeof(root_dev)) {
-			strlcpy(root_dev, line, len);
-			srvaddr = parse_srvaddr(&line[2], s);
-			if (*s) {
-				snprintf(root_opts, sizeof(root_opts), "%s,%s",
+		if (len > sizeof(root_dev)) {
+			printk(KERN_ERR "Root-CIFS: UNC path too long\n");
+			return 1;
+		}
+		strlcpy(root_dev, line, len);
+		srvaddr = parse_srvaddr(&line[2], s);
+		if (*s) {
+			int n = snprintf(root_opts,
+					 sizeof(root_opts), "%s,%s",
 					 DEFAULT_MNT_OPTS, s + 1);
+			if (n >= sizeof(root_opts)) {
+				printk(KERN_ERR "Root-CIFS: mount options string too long\n");
+				root_opts[sizeof(root_opts)-1] = '\0';
+				return 1;
 			}
 		}
 	}

commit 8eecd1c2e5bc73d33f3a544751305679dbf88eb4
Author: Paulo Alcantara (SUSE) <paulo@paulo.ac>
Date:   Tue Jul 16 19:04:50 2019 -0300

    cifs: Add support for root file systems
    
    Introduce a new CONFIG_CIFS_ROOT option to handle root file systems
    over a SMB share.
    
    In order to mount the root file system during the init process, make
    cifs.ko perform non-blocking socket operations while mounting and
    accessing it.
    
    Cc: Steve French <smfrench@gmail.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Paulo Alcantara (SUSE) <paulo@paulo.ac>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsroot.c b/fs/cifs/cifsroot.c
new file mode 100644
index 000000000000..8760d9cbf25e
--- /dev/null
+++ b/fs/cifs/cifsroot.c
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * SMB root file system support
+ *
+ * Copyright (c) 2019 Paulo Alcantara <palcantara@suse.de>
+ */
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/root_dev.h>
+#include <linux/kernel.h>
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <net/ipconfig.h>
+
+#define DEFAULT_MNT_OPTS \
+	"vers=1.0,cifsacl,mfsymlinks,rsize=1048576,wsize=65536,uid=0,gid=0," \
+	"hard,rootfs"
+
+static char root_dev[2048] __initdata = "";
+static char root_opts[1024] __initdata = DEFAULT_MNT_OPTS;
+
+static __be32 __init parse_srvaddr(char *start, char *end)
+{
+	char addr[sizeof("aaa.bbb.ccc.ddd")];
+	int i = 0;
+
+	while (start < end && i < sizeof(addr) - 1) {
+		if (isdigit(*start) || *start == '.')
+			addr[i++] = *start;
+		start++;
+	}
+	addr[i] = '\0';
+	return in_aton(addr);
+}
+
+/* cifsroot=//<server-ip>/<share>[,options] */
+static int __init cifs_root_setup(char *line)
+{
+	char *s;
+	int len;
+	__be32 srvaddr = htonl(INADDR_NONE);
+
+	ROOT_DEV = Root_CIFS;
+
+	if (strlen(line) > 3 && line[0] == '/' && line[1] == '/') {
+		s = strchr(&line[2], '/');
+		if (!s || s[1] == '\0')
+			return 1;
+
+		s = strchrnul(s, ',');
+		len = s - line + 1;
+		if (len <= sizeof(root_dev)) {
+			strlcpy(root_dev, line, len);
+			srvaddr = parse_srvaddr(&line[2], s);
+			if (*s) {
+				snprintf(root_opts, sizeof(root_opts), "%s,%s",
+					 DEFAULT_MNT_OPTS, s + 1);
+			}
+		}
+	}
+
+	root_server_addr = srvaddr;
+
+	return 1;
+}
+
+__setup("cifsroot=", cifs_root_setup);
+
+int __init cifs_root_data(char **dev, char **opts)
+{
+	if (!root_dev[0] || root_server_addr == htonl(INADDR_NONE)) {
+		printk(KERN_ERR "Root-CIFS: no SMB server address\n");
+		return -1;
+	}
+
+	*dev = root_dev;
+	*opts = root_opts;
+
+	return 0;
+}
