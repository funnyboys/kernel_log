commit 0667059d0b4ad231e7258aa571f28574b313f34f
Author: Murphy Zhou <jencce.kernel@gmail.com>
Date:   Fri Feb 21 10:30:01 2020 +0800

    cifs: allow unlock flock and OFD lock across fork
    
    Since commit d0677992d2af ("cifs: add support for flock") added
    support for flock, LTP/flock03[1] testcase started to fail.
    
    This testcase is testing flock lock and unlock across fork.
    The parent locks file and starts the child process, in which
    it unlock the same fd and lock the same file with another fd
    again. All the lock and unlock operation should succeed.
    
    Now the child process does not actually unlock the file, so
    the following lock fails. Fix this by allowing flock and OFD
    lock go through the unlock routine, not skipping if the unlock
    request comes from another process.
    
    Patch has been tested by LTP/xfstests on samba and Windows
    server, v3.11, with or without cache=none mount option.
    
    [1] https://github.com/linux-test-project/ltp/blob/master/testcases/kernel/syscalls/flock/flock03.c
    Signed-off-by: Murphy Zhou <jencce.kernel@gmail.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 0a19d6d8e1cc..2fa3ba354cc9 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -152,7 +152,12 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 		    (li->offset + li->length))
 			continue;
 		if (current->tgid != li->pid)
-			continue;
+			/*
+			 * flock and OFD lock are associated with an open
+			 * file description, not the process.
+			 */
+			if (!(flock->fl_flags & (FL_FLOCK | FL_OFDLCK)))
+				continue;
 		if (cinode->can_cache_brlcks) {
 			/*
 			 * We can cache brlock requests - simply remove a lock

commit 69dda3059e7a4dbe02b05a38b4a066919da38a45
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Mon Mar 2 17:53:22 2020 +0100

    cifs: add SMB2_open() arg to return POSIX data
    
    allows SMB2_open() callers to pass down a POSIX data buffer that will
    trigger requesting POSIX create context and parsing the response into
    the provided buffer.
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index afe1f03aabe3..0a19d6d8e1cc 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -62,7 +62,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;
 
 	rc = SMB2_open(xid, oparms, smb2_path, &smb2_oplock, smb2_data, NULL,
-		       NULL);
+		       NULL, NULL);
 	if (rc)
 		goto out;
 

commit 7935799e041ae10d380d04ea23868240f082bd11
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Tue Dec 17 20:04:51 2019 -0700

    cifs: Adjust indentation in smb2_open_file
    
    Clang warns:
    
    ../fs/cifs/smb2file.c:70:3: warning: misleading indentation; statement
    is not part of the previous 'if' [-Wmisleading-indentation]
             if (oparms->tcon->use_resilient) {
             ^
    ../fs/cifs/smb2file.c:66:2: note: previous statement is here
            if (rc)
            ^
    1 warning generated.
    
    This warning occurs because there is a space after the tab on this line.
    Remove it so that the indentation is consistent with the Linux kernel
    coding style and clang no longer warns.
    
    Fixes: 592fafe644bf ("Add resilienthandles mount parm")
    Link: https://github.com/ClangBuiltLinux/linux/issues/826
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 8b0b512c5792..afe1f03aabe3 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -67,7 +67,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 		goto out;
 
 
-	 if (oparms->tcon->use_resilient) {
+	if (oparms->tcon->use_resilient) {
 		/* default timeout is 0, servers pick default (120 seconds) */
 		nr_ioctl_req.Timeout =
 			cpu_to_le32(oparms->tcon->handle_timeout);

commit d46b0da7a33dd8c99d969834f682267a45444ab3
Author: Dave Wysochanski <dwysocha@redhat.com>
Date:   Wed Oct 23 05:02:33 2019 -0400

    cifs: Fix cifsInodeInfo lock_sem deadlock when reconnect occurs
    
    There's a deadlock that is possible and can easily be seen with
    a test where multiple readers open/read/close of the same file
    and a disruption occurs causing reconnect.  The deadlock is due
    a reader thread inside cifs_strict_readv calling down_read and
    obtaining lock_sem, and then after reconnect inside
    cifs_reopen_file calling down_read a second time.  If in
    between the two down_read calls, a down_write comes from
    another process, deadlock occurs.
    
            CPU0                    CPU1
            ----                    ----
    cifs_strict_readv()
     down_read(&cifsi->lock_sem);
                                   _cifsFileInfo_put
                                      OR
                                   cifs_new_fileinfo
                                    down_write(&cifsi->lock_sem);
    cifs_reopen_file()
     down_read(&cifsi->lock_sem);
    
    Fix the above by changing all down_write(lock_sem) calls to
    down_write_trylock(lock_sem)/msleep() loop, which in turn
    makes the second down_read call benign since it will never
    block behind the writer while holding lock_sem.
    
    Signed-off-by: Dave Wysochanski <dwysocha@redhat.com>
    Suggested-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed--by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index e6a1fc72018f..8b0b512c5792 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -145,7 +145,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 
 	cur = buf;
 
-	down_write(&cinode->lock_sem);
+	cifs_down_write(&cinode->lock_sem);
 	list_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {
 		if (flock->fl_start > li->offset ||
 		    (flock->fl_start + length) <

commit 89a5bfa350faf87156acda4d7c457808bfecaa0e
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Jul 18 17:22:18 2019 -0500

    smb3: optimize open to not send query file internal info
    
    We can cut one third of the traffic on open by not querying the
    inode number explicitly via SMB3 query_info since it is now
    returned on open in the qfid context.
    
    This is better in multiple ways, and
    speeds up file open about 10% (more if network is slow).
    
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 54bffb2a1786..e6a1fc72018f 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -88,14 +88,20 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	}
 
 	if (buf) {
-		/* open response does not have IndexNumber field - get it */
-		rc = SMB2_get_srv_num(xid, oparms->tcon, fid->persistent_fid,
+		/* if open response does not have IndexNumber field - get it */
+		if (smb2_data->IndexNumber == 0) {
+			rc = SMB2_get_srv_num(xid, oparms->tcon,
+				      fid->persistent_fid,
 				      fid->volatile_fid,
 				      &smb2_data->IndexNumber);
-		if (rc) {
-			/* let get_inode_info disable server inode numbers */
-			smb2_data->IndexNumber = 0;
-			rc = 0;
+			if (rc) {
+				/*
+				 * let get_inode_info disable server inode
+				 * numbers
+				 */
+				smb2_data->IndexNumber = 0;
+				rc = 0;
+			}
 		}
 		move_smb2_info_to_cifs(buf, smb2_data);
 	}

commit ca567eb2b3f014d5be0f44c6f68b01a522f15ca4
Author: Steve French <stfrench@microsoft.com>
Date:   Fri Mar 29 16:31:07 2019 -0500

    SMB3: Allow persistent handle timeout to be configurable on mount
    
    Reconnecting after server or network failure can be improved
    (to maintain availability and protect data integrity) by allowing
    the client to choose the default persistent (or resilient)
    handle timeout in some use cases.  Today we default to 0 which lets
    the server pick the default timeout (usually 120 seconds) but this
    can be problematic for some workloads.  Add the new mount parameter
    to cifs.ko for SMB3 mounts "handletimeout" which enables the user
    to override the default handle timeout for persistent (mount
    option "persistenthandles") or resilient handles (mount option
    "resilienthandles").  Maximum allowed is 16 minutes (960000 ms).
    Units for the timeout are expressed in milliseconds. See
    section 2.2.14.2.12 and 2.2.31.3 of the MS-SMB2 protocol
    specification for more information.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index ac97e0c01d4e..54bffb2a1786 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -68,7 +68,9 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 
 
 	 if (oparms->tcon->use_resilient) {
-		nr_ioctl_req.Timeout = 0; /* use server default (120 seconds) */
+		/* default timeout is 0, servers pick default (120 seconds) */
+		nr_ioctl_req.Timeout =
+			cpu_to_le32(oparms->tcon->handle_timeout);
 		nr_ioctl_req.Reserved = 0;
 		rc = SMB2_ioctl(xid, oparms->tcon, fid->persistent_fid,
 			fid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY,

commit 153322f7536a181e4d1b288aa6f01c0ce65f5c7c
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Mar 28 22:32:49 2019 -0500

    smb3: Fix enumerating snapshots to Azure
    
    Some servers (see MS-SMB2 protocol specification
    section 3.3.5.15.1) expect that the FSCTL enumerate snapshots
    is done twice, with the first query having EXACTLY the minimum
    size response buffer requested (16 bytes) which refreshes
    the snapshot list (otherwise that and subsequent queries get
    an empty list returned).  So had to add code to set
    the maximum response size differently for the first snapshot
    query (which gets the size needed for the second query which
    contains the actual list of snapshots).
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable <stable@vger.kernel.org> # 4.19+

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index b204e84b87fb..ac97e0c01d4e 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -74,7 +74,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 			fid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY,
 			true /* is_fsctl */,
 			(char *)&nr_ioctl_req, sizeof(nr_ioctl_req),
-			NULL, NULL /* no return info */);
+			CIFSMaxBufSize, NULL, NULL /* no return info */);
 		if (rc == -EOPNOTSUPP) {
 			cifs_dbg(VFS,
 			     "resiliency not supported by server, disabling\n");

commit b9a74cde94957d82003fb9f7ab4777938ca851cd
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Tue Jan 8 18:30:57 2019 +0000

    cifs: Fix potential OOB access of lock element array
    
    If maxBuf is small but non-zero, it could result in a zero sized lock
    element array which we would then try and access OOB.
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index eff01ed6db0a..b204e84b87fb 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -122,10 +122,10 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 
 	/*
 	 * Accessing maxBuf is racy with cifs_reconnect - need to store value
-	 * and check it for zero before using.
+	 * and check it before using.
 	 */
 	max_buf = tcon->ses->server->maxBuf;
-	if (!max_buf)
+	if (max_buf < sizeof(struct smb2_lock_element))
 		return -EINVAL;
 
 	BUILD_BUG_ON(sizeof(struct smb2_lock_element) > PAGE_SIZE);

commit 92a8109e4d3a34fb6b115c9098b51767dc933444
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Tue Jan 8 18:30:56 2019 +0000

    cifs: Limit memory used by lock request calls to a page
    
    The code tries to allocate a contiguous buffer with a size supplied by
    the server (maxBuf). This could fail if memory is fragmented since it
    results in high order allocations for commonly used server
    implementations. It is also wasteful since there are probably
    few locks in the usual case. Limit the buffer to be no larger than a
    page to avoid memory allocation failures due to fragmentation.
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 4ed10dd086e6..eff01ed6db0a 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -128,6 +128,8 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 	if (!max_buf)
 		return -EINVAL;
 
+	BUILD_BUG_ON(sizeof(struct smb2_lock_element) > PAGE_SIZE);
+	max_buf = min_t(unsigned int, max_buf, PAGE_SIZE);
 	max_num = max_buf / sizeof(struct smb2_lock_element);
 	buf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);
 	if (!buf)
@@ -264,6 +266,8 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 		return -EINVAL;
 	}
 
+	BUILD_BUG_ON(sizeof(struct smb2_lock_element) > PAGE_SIZE);
+	max_buf = min_t(unsigned int, max_buf, PAGE_SIZE);
 	max_num = max_buf / sizeof(struct smb2_lock_element);
 	buf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);
 	if (!buf) {

commit 729c0c9dd55204f0c9a823ac8a7bfa83d36c7e78
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Thu Jul 5 15:10:02 2018 +0200

    cifs: Fix stack out-of-bounds in smb{2,3}_create_lease_buf()
    
    smb{2,3}_create_lease_buf() store a lease key in the lease
    context for later usage on a lease break.
    
    In most paths, the key is currently sourced from data that
    happens to be on the stack near local variables for oplock in
    SMB2_open() callers, e.g. from open_shroot(), whereas
    smb2_open_file() properly allocates space on its stack for it.
    
    The address of those local variables holding the oplock is then
    passed to create_lease_buf handlers via SMB2_open(), and 16
    bytes near oplock are used. This causes a stack out-of-bounds
    access as reported by KASAN on SMB2.1 and SMB3 mounts (first
    out-of-bounds access is shown here):
    
    [  111.528823] BUG: KASAN: stack-out-of-bounds in smb3_create_lease_buf+0x399/0x3b0 [cifs]
    [  111.530815] Read of size 8 at addr ffff88010829f249 by task mount.cifs/985
    [  111.532838] CPU: 3 PID: 985 Comm: mount.cifs Not tainted 4.18.0-rc3+ #91
    [  111.534656] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014
    [  111.536838] Call Trace:
    [  111.537528]  dump_stack+0xc2/0x16b
    [  111.540890]  print_address_description+0x6a/0x270
    [  111.542185]  kasan_report+0x258/0x380
    [  111.544701]  smb3_create_lease_buf+0x399/0x3b0 [cifs]
    [  111.546134]  SMB2_open+0x1ef8/0x4b70 [cifs]
    [  111.575883]  open_shroot+0x339/0x550 [cifs]
    [  111.591969]  smb3_qfs_tcon+0x32c/0x1e60 [cifs]
    [  111.617405]  cifs_mount+0x4f3/0x2fc0 [cifs]
    [  111.674332]  cifs_smb3_do_mount+0x263/0xf10 [cifs]
    [  111.677915]  mount_fs+0x55/0x2b0
    [  111.679504]  vfs_kern_mount.part.22+0xaa/0x430
    [  111.684511]  do_mount+0xc40/0x2660
    [  111.698301]  ksys_mount+0x80/0xd0
    [  111.701541]  do_syscall_64+0x14e/0x4b0
    [  111.711807]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [  111.713665] RIP: 0033:0x7f372385b5fa
    [  111.715311] Code: 48 8b 0d 99 78 2c 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 66 78 2c 00 f7 d8 64 89 01 48
    [  111.720330] RSP: 002b:00007ffff27049d8 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5
    [  111.722601] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f372385b5fa
    [  111.724842] RDX: 000055c2ecdc73b2 RSI: 000055c2ecdc73f9 RDI: 00007ffff270580f
    [  111.727083] RBP: 00007ffff2705804 R08: 000055c2ee976060 R09: 0000000000001000
    [  111.729319] R10: 0000000000000000 R11: 0000000000000206 R12: 00007f3723f4d000
    [  111.731615] R13: 000055c2ee976060 R14: 00007f3723f4f90f R15: 0000000000000000
    
    [  111.735448] The buggy address belongs to the page:
    [  111.737420] page:ffffea000420a7c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0
    [  111.739890] flags: 0x17ffffc0000000()
    [  111.741750] raw: 0017ffffc0000000 0000000000000000 dead000000000200 0000000000000000
    [  111.744216] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
    [  111.746679] page dumped because: kasan: bad access detected
    
    [  111.750482] Memory state around the buggy address:
    [  111.752562]  ffff88010829f100: 00 f2 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00 00 00
    [  111.754991]  ffff88010829f180: 00 00 f2 f2 00 00 00 00 00 00 00 00 00 00 00 00
    [  111.757401] >ffff88010829f200: 00 00 00 00 00 f1 f1 f1 f1 01 f2 f2 f2 f2 f2 f2
    [  111.759801]                                               ^
    [  111.762034]  ffff88010829f280: f2 02 f2 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00 00
    [  111.764486]  ffff88010829f300: f2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  111.766913] ==================================================================
    
    Lease keys are however already generated and stored in fid data
    on open and create paths: pass them down to the lease context
    creation handlers and use them.
    
    Suggested-by: Aur√©lien Aptel <aaptel@suse.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Fixes: b8c32dbb0deb ("CIFS: Request SMB2.1 leases")
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 788412675723..4ed10dd086e6 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -41,7 +41,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	int rc;
 	__le16 *smb2_path;
 	struct smb2_file_all_info *smb2_data = NULL;
-	__u8 smb2_oplock[17];
+	__u8 smb2_oplock;
 	struct cifs_fid *fid = oparms->fid;
 	struct network_resiliency_req nr_ioctl_req;
 
@@ -59,12 +59,9 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	}
 
 	oparms->desired_access |= FILE_READ_ATTRIBUTES;
-	*smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;
+	smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;
 
-	if (oparms->tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
-		memcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);
-
-	rc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data, NULL,
+	rc = SMB2_open(xid, oparms, smb2_path, &smb2_oplock, smb2_data, NULL,
 		       NULL);
 	if (rc)
 		goto out;
@@ -101,7 +98,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 		move_smb2_info_to_cifs(buf, smb2_data);
 	}
 
-	*oplock = *smb2_oplock;
+	*oplock = smb2_oplock;
 out:
 	kfree(smb2_data);
 	kfree(smb2_path);

commit 9d874c36552afbd08778687aeaff24a8a7260f20
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Fri Jun 8 13:21:18 2018 +1000

    cifs: fix a buffer leak in smb2_query_symlink
    
    This leak was introduced in 91cb74f5142c14dd921ab2d064b7b128054f9fae and caused us
    to leak one small buffer for every symlink query.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 12af5dba742b..788412675723 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -64,7 +64,8 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	if (oparms->tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
 		memcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);
 
-	rc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data, NULL);
+	rc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data, NULL,
+		       NULL);
 	if (rc)
 		goto out;
 

commit 63a83b861c47dba9e0f46b98423723a6a3d97fb1
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Wed Jan 24 13:46:11 2018 +0100

    CIFS: use tcon_ipc instead of use_ipc parameter of SMB2_ioctl
    
    Since IPC now has a tcon object, the caller can just pass it. This
    allows domain-based DFS requests to work with smb2+.
    
    Link: https://bugzilla.samba.org/show_bug.cgi?id=12917
    Fixes: 9d49640a21bf ("CIFS: implement get_dfs_refer for SMB2+")
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index b4b1f0305f29..12af5dba742b 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -74,7 +74,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 		nr_ioctl_req.Reserved = 0;
 		rc = SMB2_ioctl(xid, oparms->tcon, fid->persistent_fid,
 			fid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY,
-			true /* is_fsctl */, false /* use_ipc */,
+			true /* is_fsctl */,
 			(char *)&nr_ioctl_req, sizeof(nr_ioctl_req),
 			NULL, NULL /* no return info */);
 		if (rc == -EOPNOTSUPP) {

commit 51146625f34b348c15d55c378b5ae5c2fb963fc8
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Tue Feb 28 15:08:41 2017 +0100

    CIFS: add use_ipc flag to SMB2_ioctl()
    
    when set, use the session IPC tree id instead of the tid in the provided
    tcon.
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index b2aff0c6f22c..b4b1f0305f29 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -73,7 +73,8 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 		nr_ioctl_req.Timeout = 0; /* use server default (120 seconds) */
 		nr_ioctl_req.Reserved = 0;
 		rc = SMB2_ioctl(xid, oparms->tcon, fid->persistent_fid,
-			fid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY, true,
+			fid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY,
+			true /* is_fsctl */, false /* use_ipc */,
 			(char *)&nr_ioctl_req, sizeof(nr_ioctl_req),
 			NULL, NULL /* no return info */);
 		if (rc == -EOPNOTSUPP) {

commit e3d240e9d505fc67f8f8735836df97a794bbd946
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Tue Nov 29 16:14:43 2016 -0800

    CIFS: Fix a possible memory corruption in push locks
    
    If maxBuf is not 0 but less than a size of SMB2 lock structure
    we can end up with a memory corruption.
    
    Cc: Stable <stable@vger.kernel.org>
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index f9e766f464be..b2aff0c6f22c 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -260,7 +260,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	 * and check it for zero before using.
 	 */
 	max_buf = tlink_tcon(cfile->tlink)->ses->server->maxBuf;
-	if (!max_buf) {
+	if (max_buf < sizeof(struct smb2_lock_element)) {
 		free_xid(xid);
 		return -EINVAL;
 	}

commit 592fafe644bf3a48b9e00e182a67d301493634fc
Author: Steve French <smfrench@gmail.com>
Date:   Tue Nov 3 10:08:53 2015 -0600

    Add resilienthandles mount parm
    
    Since many servers (Windows clients, and non-clustered servers) do not
    support persistent handles but do support resilient handles, allow
    the user to specify a mount option "resilienthandles" in order
    to get more reliable connections and less chance of data loss
    (at least when SMB2.1 or later).  Default resilient handle
    timeout (120 seconds to recent Windows server) is used.
    
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 2ab297dae5a7..f9e766f464be 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -43,6 +43,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	struct smb2_file_all_info *smb2_data = NULL;
 	__u8 smb2_oplock[17];
 	struct cifs_fid *fid = oparms->fid;
+	struct network_resiliency_req nr_ioctl_req;
 
 	smb2_path = cifs_convert_path_to_utf16(oparms->path, oparms->cifs_sb);
 	if (smb2_path == NULL) {
@@ -67,6 +68,24 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	if (rc)
 		goto out;
 
+
+	 if (oparms->tcon->use_resilient) {
+		nr_ioctl_req.Timeout = 0; /* use server default (120 seconds) */
+		nr_ioctl_req.Reserved = 0;
+		rc = SMB2_ioctl(xid, oparms->tcon, fid->persistent_fid,
+			fid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY, true,
+			(char *)&nr_ioctl_req, sizeof(nr_ioctl_req),
+			NULL, NULL /* no return info */);
+		if (rc == -EOPNOTSUPP) {
+			cifs_dbg(VFS,
+			     "resiliency not supported by server, disabling\n");
+			oparms->tcon->use_resilient = false;
+		} else if (rc)
+			cifs_dbg(FYI, "error %d setting resiliency\n", rc);
+
+		rc = 0;
+	}
+
 	if (buf) {
 		/* open response does not have IndexNumber field - get it */
 		rc = SMB2_get_srv_num(xid, oparms->tcon, fid->persistent_fid,

commit 2b0143b5c986be1ce8408b3aadc4709e0a94429d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Mar 17 22:25:59 2015 +0000

    VFS: normal filesystems (and lustre): d_inode() annotations
    
    that's the bulk of filesystem drivers dealing with inodes of their own
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 7198eac5dddd..2ab297dae5a7 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -95,7 +95,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 	unsigned int max_num, num = 0, max_buf;
 	struct smb2_lock_element *buf, *cur;
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct cifsLockInfo *li, *tmp;
 	__u64 length = 1 + flock->fl_end - flock->fl_start;
 	struct list_head tmp_llist;
@@ -231,7 +231,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	unsigned int xid;
 	unsigned int max_num, max_buf;
 	struct smb2_lock_element *buf;
-	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));
 	struct cifs_fid_locks *fdlocks;
 
 	xid = get_xid();

commit 662e9b2b98a0b8e172c392f3d3437d354a6c4067
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Dec 10 15:41:20 2014 -0800

    fs/cifs/smb2file.c: replace count*size kzalloc by kcalloc
    
    kcalloc manages count*sizeof overflow.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Steve French <sfrench@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 45992944e238..7198eac5dddd 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -111,7 +111,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 		return -EINVAL;
 
 	max_num = max_buf / sizeof(struct smb2_lock_element);
-	buf = kzalloc(max_num * sizeof(struct smb2_lock_element), GFP_KERNEL);
+	buf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
@@ -247,7 +247,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	}
 
 	max_num = max_buf / sizeof(struct smb2_lock_element);
-	buf = kzalloc(max_num * sizeof(struct smb2_lock_element), GFP_KERNEL);
+	buf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);
 	if (!buf) {
 		free_xid(xid);
 		return -ENOMEM;

commit 1bbe4997b13de903c421c1cc78440e544b5f9064
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri Aug 22 13:32:11 2014 +0400

    CIFS: Fix wrong filename length for SMB2
    
    The existing code uses the old MAX_NAME constant. This causes
    XFS test generic/013 to fail. Fix it by replacing MAX_NAME with
    PATH_MAX that SMB1 uses. Also remove an unused MAX_NAME constant
    definition.
    
    Cc: <stable@vger.kernel.org> # v3.7+
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 3f17b4550831..45992944e238 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -50,7 +50,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 		goto out;
 	}
 
-	smb2_data = kzalloc(sizeof(struct smb2_file_all_info) + MAX_NAME * 2,
+	smb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,
 			    GFP_KERNEL);
 	if (smb2_data == NULL) {
 		rc = -ENOMEM;

commit 53ef1016fd0e4bab128a24f7fe06b9cdb2afdc31
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Sep 5 16:11:28 2013 +0400

    CIFS: Store lease state itself rather than a mapped oplock value
    
    and separate smb20_operations struct.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 4564787dc7d7..3f17b4550831 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -34,29 +34,6 @@
 #include "fscache.h"
 #include "smb2proto.h"
 
-void
-smb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)
-{
-	oplock &= 0xFF;
-	if (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)
-		return;
-	if (oplock == SMB2_OPLOCK_LEVEL_BATCH) {
-		cinode->oplock = CIFS_CACHE_READ_FLG | CIFS_CACHE_WRITE_FLG |
-				 CIFS_CACHE_HANDLE_FLG;
-		cifs_dbg(FYI, "Batch Oplock granted on inode %p\n",
-			 &cinode->vfs_inode);
-	} else if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
-		cinode->oplock = CIFS_CACHE_READ_FLG | CIFS_CACHE_WRITE_FLG;
-		cifs_dbg(FYI, "Exclusive Oplock granted on inode %p\n",
-			 &cinode->vfs_inode);
-	} else if (oplock == SMB2_OPLOCK_LEVEL_II) {
-		cinode->oplock = CIFS_CACHE_READ_FLG;
-		cifs_dbg(FYI, "Level II Oplock granted on inode %p\n",
-			 &cinode->vfs_inode);
-	} else
-		cinode->oplock = 0;
-}
-
 int
 smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	       __u32 *oplock, FILE_ALL_INFO *buf)

commit 18cceb6a78f46b65df654e8348fa2093b91b30f6
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Sep 5 13:01:06 2013 +0400

    CIFS: Replace clientCanCache* bools with an integer
    
    that prepare the code to handle different types of SMB2 leases.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 020245d5c9a7..4564787dc7d7 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -40,21 +40,21 @@ smb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)
 	oplock &= 0xFF;
 	if (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)
 		return;
-	if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||
-	    oplock == SMB2_OPLOCK_LEVEL_BATCH) {
-		cinode->clientCanCacheAll = true;
-		cinode->clientCanCacheRead = true;
+	if (oplock == SMB2_OPLOCK_LEVEL_BATCH) {
+		cinode->oplock = CIFS_CACHE_READ_FLG | CIFS_CACHE_WRITE_FLG |
+				 CIFS_CACHE_HANDLE_FLG;
+		cifs_dbg(FYI, "Batch Oplock granted on inode %p\n",
+			 &cinode->vfs_inode);
+	} else if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
+		cinode->oplock = CIFS_CACHE_READ_FLG | CIFS_CACHE_WRITE_FLG;
 		cifs_dbg(FYI, "Exclusive Oplock granted on inode %p\n",
 			 &cinode->vfs_inode);
 	} else if (oplock == SMB2_OPLOCK_LEVEL_II) {
-		cinode->clientCanCacheAll = false;
-		cinode->clientCanCacheRead = true;
+		cinode->oplock = CIFS_CACHE_READ_FLG;
 		cifs_dbg(FYI, "Level II Oplock granted on inode %p\n",
 			 &cinode->vfs_inode);
-	} else {
-		cinode->clientCanCacheAll = false;
-		cinode->clientCanCacheRead = false;
-	}
+	} else
+		cinode->oplock = 0;
 }
 
 int

commit b42bf88828cde60772dc08201d0a4f1a0663d7bc
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Aug 14 19:25:21 2013 +0400

    CIFS: Implement follow_link for SMB2
    
    that allows to access files through symlink created on a server.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 04a81a4142c3..020245d5c9a7 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -86,7 +86,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	if (oparms->tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
 		memcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);
 
-	rc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data);
+	rc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data, NULL);
 	if (rc)
 		goto out;
 

commit 9cbc0b7339b0542a1d13922d2745a2636ce44853
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Jul 9 18:40:58 2013 +0400

    CIFS: Reconnect durable handles for SMB2
    
    On reconnects, we need to reopen file and then obtain all byte-range
    locks held by the client. SMB2 protocol provides feature to make
    this process atomic by reconnecting to the same file handle
    with all it's byte-range locks. This patch adds this capability
    for SMB2 shares.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steven French <steven@steven-GA-970A-DS3.(none)>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 398992962cc6..04a81a4142c3 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -40,7 +40,8 @@ smb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)
 	oplock &= 0xFF;
 	if (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)
 		return;
-	if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
+	if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||
+	    oplock == SMB2_OPLOCK_LEVEL_BATCH) {
 		cinode->clientCanCacheAll = true;
 		cinode->clientCanCacheRead = true;
 		cifs_dbg(FYI, "Exclusive Oplock granted on inode %p\n",

commit 064f6047a123d61dd52bb44605c999cd8ef727d9
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Jul 9 18:20:30 2013 +0400

    CIFS: Make SMB2_open use cifs_open_parms struct
    
    to prepare it for further durable handle reconnect processing.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steven French <steven@steven-GA-970A-DS3.(none)>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 5bab192f64e8..398992962cc6 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -85,10 +85,7 @@ smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
 	if (oparms->tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
 		memcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);
 
-	rc = SMB2_open(xid, oparms->tcon, smb2_path, &fid->persistent_fid,
-		       &fid->volatile_fid, oparms->desired_access,
-		       oparms->disposition, oparms->create_options, smb2_oplock,
-		       smb2_data);
+	rc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data);
 	if (rc)
 		goto out;
 

commit 226730b4d8adae393dc07092655cdd29d2a2ff07
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri Jul 5 12:00:30 2013 +0400

    CIFS: Introduce cifs_open_parms struct
    
    and pass it to the open() call.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steven French <steven@steven-GA-970A-DS3.(none)>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 150a9b1bc7fa..5bab192f64e8 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -57,17 +57,16 @@ smb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)
 }
 
 int
-smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
-	       int disposition, int desired_access, int create_options,
-	       struct cifs_fid *fid, __u32 *oplock, FILE_ALL_INFO *buf,
-	       struct cifs_sb_info *cifs_sb)
+smb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,
+	       __u32 *oplock, FILE_ALL_INFO *buf)
 {
 	int rc;
 	__le16 *smb2_path;
 	struct smb2_file_all_info *smb2_data = NULL;
 	__u8 smb2_oplock[17];
+	struct cifs_fid *fid = oparms->fid;
 
-	smb2_path = cifs_convert_path_to_utf16(path, cifs_sb);
+	smb2_path = cifs_convert_path_to_utf16(oparms->path, oparms->cifs_sb);
 	if (smb2_path == NULL) {
 		rc = -ENOMEM;
 		goto out;
@@ -80,21 +79,22 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 		goto out;
 	}
 
-	desired_access |= FILE_READ_ATTRIBUTES;
+	oparms->desired_access |= FILE_READ_ATTRIBUTES;
 	*smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;
 
-	if (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
+	if (oparms->tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
 		memcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);
 
-	rc = SMB2_open(xid, tcon, smb2_path, &fid->persistent_fid,
-		       &fid->volatile_fid, desired_access, disposition,
-		       create_options, smb2_oplock, smb2_data);
+	rc = SMB2_open(xid, oparms->tcon, smb2_path, &fid->persistent_fid,
+		       &fid->volatile_fid, oparms->desired_access,
+		       oparms->disposition, oparms->create_options, smb2_oplock,
+		       smb2_data);
 	if (rc)
 		goto out;
 
 	if (buf) {
 		/* open response does not have IndexNumber field - get it */
-		rc = SMB2_get_srv_num(xid, tcon, fid->persistent_fid,
+		rc = SMB2_get_srv_num(xid, oparms->tcon, fid->persistent_fid,
 				      fid->volatile_fid,
 				      &smb2_data->IndexNumber);
 		if (rc) {

commit 63eb3def3267a5744863801e8221898b0ba9d41d
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Jul 4 18:41:09 2013 +0400

    CIFS: Request durable open for SMB2 opens
    
    by passing durable context together with a handle caching lease or
    batch oplock.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steven French <steven@steven-GA-970A-DS3.(none)>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 46a4299b7ae8..150a9b1bc7fa 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -81,7 +81,7 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 	}
 
 	desired_access |= FILE_READ_ATTRIBUTES;
-	*smb2_oplock = SMB2_OPLOCK_LEVEL_EXCLUSIVE;
+	*smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;
 
 	if (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
 		memcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);

commit ca81983fe5e095ee90c0f7b6013e7c446af17088
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Fri Jul 5 12:21:26 2013 +0400

    CIFS: Respect create_options in smb2_open_file
    
    and eliminated unused file_attribute parms of SMB2_open.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steven French <steven@steven-GA-970A-DS3.(none)>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 5da1b55a2258..46a4299b7ae8 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -88,7 +88,7 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 
 	rc = SMB2_open(xid, tcon, smb2_path, &fid->persistent_fid,
 		       &fid->volatile_fid, desired_access, disposition,
-		       0, 0, smb2_oplock, smb2_data);
+		       create_options, smb2_oplock, smb2_data);
 	if (rc)
 		goto out;
 

commit f96637be081141d6f8813429499f164260b49d70
Author: Joe Perches <joe@perches.com>
Date:   Sat May 4 22:12:25 2013 -0500

    [CIFS] cifs: Rename cERROR and cFYI to cifs_dbg
    
    It's not obvious from reading the macro names that these macros
    are for debugging.  Convert the names to a single more typical
    kernel style cifs_dbg macro.
    
            cERROR(1, ...)   -> cifs_dbg(VFS, ...)
            cFYI(1, ...)     -> cifs_dbg(FYI, ...)
            cFYI(DBG2, ...)  -> cifs_dbg(NOISY, ...)
    
    Move the terminating format newline from the macro to the call site.
    
    Add CONFIG_CIFS_DEBUG function cifs_vfs_err to emit the
    "CIFS VFS: " prefix for VFS messages.
    
    Size is reduced ~ 1% when CONFIG_CIFS_DEBUG is set (default y)
    
    $ size fs/cifs/cifs.ko*
       text    data     bss     dec     hex filename
     265245    2525     132  267902   4167e fs/cifs/cifs.ko.new
     268359    2525     132  271016   422a8 fs/cifs/cifs.ko.old
    
    Other miscellaneous changes around these conversions:
    
    o Miscellaneous typo fixes
    o Add terminating \n's to almost all formats and remove them
      from the macros to be more kernel style like.  A few formats
      previously had defective \n's
    o Remove unnecessary OOM messages as kmalloc() calls dump_stack
    o Coalesce formats to make grep easier,
      added missing spaces when coalescing formats
    o Use %s, __func__ instead of embedded function name
    o Removed unnecessary "cifs: " prefixes
    o Convert kzalloc with multiply to kcalloc
    o Remove unused cifswarn macro
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 71e6aed4b382..5da1b55a2258 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -43,13 +43,13 @@ smb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)
 	if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
 		cinode->clientCanCacheAll = true;
 		cinode->clientCanCacheRead = true;
-		cFYI(1, "Exclusive Oplock granted on inode %p",
-		     &cinode->vfs_inode);
+		cifs_dbg(FYI, "Exclusive Oplock granted on inode %p\n",
+			 &cinode->vfs_inode);
 	} else if (oplock == SMB2_OPLOCK_LEVEL_II) {
 		cinode->clientCanCacheAll = false;
 		cinode->clientCanCacheRead = true;
-		cFYI(1, "Level II Oplock granted on inode %p",
-		    &cinode->vfs_inode);
+		cifs_dbg(FYI, "Level II Oplock granted on inode %p\n",
+			 &cinode->vfs_inode);
 	} else {
 		cinode->clientCanCacheAll = false;
 		cinode->clientCanCacheRead = false;

commit b8db928b765b4b0fe1aec3eb7f1741fedbed9a33
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Nov 22 17:07:16 2012 +0400

    CIFS: Separate pushing mandatory locks and lock_sem handling
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index a93eec30a50d..71e6aed4b382 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -260,13 +260,6 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	struct cifs_fid_locks *fdlocks;
 
 	xid = get_xid();
-	/* we are going to update can_cache_brlcks here - need a write access */
-	down_write(&cinode->lock_sem);
-	if (!cinode->can_cache_brlcks) {
-		up_write(&cinode->lock_sem);
-		free_xid(xid);
-		return rc;
-	}
 
 	/*
 	 * Accessing maxBuf is racy with cifs_reconnect - need to store value
@@ -274,7 +267,6 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	 */
 	max_buf = tlink_tcon(cfile->tlink)->ses->server->maxBuf;
 	if (!max_buf) {
-		up_write(&cinode->lock_sem);
 		free_xid(xid);
 		return -EINVAL;
 	}
@@ -282,7 +274,6 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	max_num = max_buf / sizeof(struct smb2_lock_element);
 	buf = kzalloc(max_num * sizeof(struct smb2_lock_element), GFP_KERNEL);
 	if (!buf) {
-		up_write(&cinode->lock_sem);
 		free_xid(xid);
 		return -ENOMEM;
 	}
@@ -293,10 +284,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 			rc = stored_rc;
 	}
 
-	cinode->can_cache_brlcks = false;
 	kfree(buf);
-
-	up_write(&cinode->lock_sem);
 	free_xid(xid);
 	return rc;
 }

commit 0822f51426b51bd599b3a7e972b14aacaa045a92
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Sep 19 06:22:45 2012 -0700

    CIFS: Add SMB2.1 lease break support
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 78fb2050e0d6..a93eec30a50d 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -38,6 +38,8 @@ void
 smb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)
 {
 	oplock &= 0xFF;
+	if (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)
+		return;
 	if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
 		cinode->clientCanCacheAll = true;
 		cinode->clientCanCacheRead = true;

commit b8c32dbb0deb287a5fcb78251e4eae6c7275760d
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Sep 19 06:22:44 2012 -0700

    CIFS: Request SMB2.1 leases
    
    if server supports them and we need oplocks.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 0ddd617ffa1a..78fb2050e0d6 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -63,6 +63,7 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 	int rc;
 	__le16 *smb2_path;
 	struct smb2_file_all_info *smb2_data = NULL;
+	__u8 smb2_oplock[17];
 
 	smb2_path = cifs_convert_path_to_utf16(path, cifs_sb);
 	if (smb2_path == NULL) {
@@ -78,11 +79,14 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 	}
 
 	desired_access |= FILE_READ_ATTRIBUTES;
-	*oplock = SMB2_OPLOCK_LEVEL_EXCLUSIVE;
+	*smb2_oplock = SMB2_OPLOCK_LEVEL_EXCLUSIVE;
+
+	if (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)
+		memcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);
 
 	rc = SMB2_open(xid, tcon, smb2_path, &fid->persistent_fid,
 		       &fid->volatile_fid, desired_access, disposition,
-		       0, 0, (__u8 *)oplock, smb2_data);
+		       0, 0, smb2_oplock, smb2_data);
 	if (rc)
 		goto out;
 
@@ -99,6 +103,7 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 		move_smb2_info_to_cifs(buf, smb2_data);
 	}
 
+	*oplock = *smb2_oplock;
 out:
 	kfree(smb2_data);
 	kfree(smb2_path);

commit 1b4b55a1d9404f51aacf1ff19887eb911484057d
Author: Pavel Shilovsky <pshilovsky@etersoft.ru>
Date:   Wed Sep 19 06:22:44 2012 -0700

    CIFS: Turn lock mutex into rw semaphore
    
    and allow several processes to walk through the lock list and read
    can_cache_brlcks value if they are not going to modify them.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 181e13d9f9db..0ddd617ffa1a 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -135,7 +135,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 
 	cur = buf;
 
-	mutex_lock(&cinode->lock_mutex);
+	down_write(&cinode->lock_sem);
 	list_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {
 		if (flock->fl_start > li->offset ||
 		    (flock->fl_start + length) <
@@ -196,7 +196,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 		} else
 			cifs_free_llist(&tmp_llist);
 	}
-	mutex_unlock(&cinode->lock_mutex);
+	up_write(&cinode->lock_sem);
 
 	kfree(buf);
 	return rc;
@@ -253,9 +253,10 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	struct cifs_fid_locks *fdlocks;
 
 	xid = get_xid();
-	mutex_lock(&cinode->lock_mutex);
+	/* we are going to update can_cache_brlcks here - need a write access */
+	down_write(&cinode->lock_sem);
 	if (!cinode->can_cache_brlcks) {
-		mutex_unlock(&cinode->lock_mutex);
+		up_write(&cinode->lock_sem);
 		free_xid(xid);
 		return rc;
 	}
@@ -266,7 +267,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	 */
 	max_buf = tlink_tcon(cfile->tlink)->ses->server->maxBuf;
 	if (!max_buf) {
-		mutex_unlock(&cinode->lock_mutex);
+		up_write(&cinode->lock_sem);
 		free_xid(xid);
 		return -EINVAL;
 	}
@@ -274,7 +275,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	max_num = max_buf / sizeof(struct smb2_lock_element);
 	buf = kzalloc(max_num * sizeof(struct smb2_lock_element), GFP_KERNEL);
 	if (!buf) {
-		mutex_unlock(&cinode->lock_mutex);
+		up_write(&cinode->lock_sem);
 		free_xid(xid);
 		return -ENOMEM;
 	}
@@ -288,7 +289,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
 	cinode->can_cache_brlcks = false;
 	kfree(buf);
 
-	mutex_unlock(&cinode->lock_mutex);
+	up_write(&cinode->lock_sem);
 	free_xid(xid);
 	return rc;
 }

commit b140799a11adb6023d5f96712874c37b71dab290
Author: Pavel Shilovsky <pshilovsky@etersoft.ru>
Date:   Wed Sep 19 06:22:44 2012 -0700

    CIFS: Use brlock cache for SMB2
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index a25ea02149e7..181e13d9f9db 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -201,3 +201,94 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 	kfree(buf);
 	return rc;
 }
+
+static int
+smb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,
+		       struct smb2_lock_element *buf, unsigned int max_num)
+{
+	int rc = 0, stored_rc;
+	struct cifsFileInfo *cfile = fdlocks->cfile;
+	struct cifsLockInfo *li;
+	unsigned int num = 0;
+	struct smb2_lock_element *cur = buf;
+	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
+
+	list_for_each_entry(li, &fdlocks->locks, llist) {
+		cur->Length = cpu_to_le64(li->length);
+		cur->Offset = cpu_to_le64(li->offset);
+		cur->Flags = cpu_to_le32(li->type |
+						SMB2_LOCKFLAG_FAIL_IMMEDIATELY);
+		if (++num == max_num) {
+			stored_rc = smb2_lockv(xid, tcon,
+					       cfile->fid.persistent_fid,
+					       cfile->fid.volatile_fid,
+					       current->tgid, num, buf);
+			if (stored_rc)
+				rc = stored_rc;
+			cur = buf;
+			num = 0;
+		} else
+			cur++;
+	}
+	if (num) {
+		stored_rc = smb2_lockv(xid, tcon,
+				       cfile->fid.persistent_fid,
+				       cfile->fid.volatile_fid,
+				       current->tgid, num, buf);
+		if (stored_rc)
+			rc = stored_rc;
+	}
+
+	return rc;
+}
+
+int
+smb2_push_mandatory_locks(struct cifsFileInfo *cfile)
+{
+	int rc = 0, stored_rc;
+	unsigned int xid;
+	unsigned int max_num, max_buf;
+	struct smb2_lock_element *buf;
+	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifs_fid_locks *fdlocks;
+
+	xid = get_xid();
+	mutex_lock(&cinode->lock_mutex);
+	if (!cinode->can_cache_brlcks) {
+		mutex_unlock(&cinode->lock_mutex);
+		free_xid(xid);
+		return rc;
+	}
+
+	/*
+	 * Accessing maxBuf is racy with cifs_reconnect - need to store value
+	 * and check it for zero before using.
+	 */
+	max_buf = tlink_tcon(cfile->tlink)->ses->server->maxBuf;
+	if (!max_buf) {
+		mutex_unlock(&cinode->lock_mutex);
+		free_xid(xid);
+		return -EINVAL;
+	}
+
+	max_num = max_buf / sizeof(struct smb2_lock_element);
+	buf = kzalloc(max_num * sizeof(struct smb2_lock_element), GFP_KERNEL);
+	if (!buf) {
+		mutex_unlock(&cinode->lock_mutex);
+		free_xid(xid);
+		return -ENOMEM;
+	}
+
+	list_for_each_entry(fdlocks, &cinode->llist, llist) {
+		stored_rc = smb2_push_mand_fdlocks(fdlocks, xid, buf, max_num);
+		if (stored_rc)
+			rc = stored_rc;
+	}
+
+	cinode->can_cache_brlcks = false;
+	kfree(buf);
+
+	mutex_unlock(&cinode->lock_mutex);
+	free_xid(xid);
+	return rc;
+}

commit f7ba7fe685bc3ed8fd0687870e68b2567d17357f
Author: Pavel Shilovsky <pshilovsky@etersoft.ru>
Date:   Wed Sep 19 06:22:43 2012 -0700

    CIFS: Add brlock support for SMB2
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@etersoft.ru>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index 5ff25e025215..a25ea02149e7 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -104,3 +104,100 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 	kfree(smb2_path);
 	return rc;
 }
+
+int
+smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
+		  const unsigned int xid)
+{
+	int rc = 0, stored_rc;
+	unsigned int max_num, num = 0, max_buf;
+	struct smb2_lock_element *buf, *cur;
+	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
+	struct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);
+	struct cifsLockInfo *li, *tmp;
+	__u64 length = 1 + flock->fl_end - flock->fl_start;
+	struct list_head tmp_llist;
+
+	INIT_LIST_HEAD(&tmp_llist);
+
+	/*
+	 * Accessing maxBuf is racy with cifs_reconnect - need to store value
+	 * and check it for zero before using.
+	 */
+	max_buf = tcon->ses->server->maxBuf;
+	if (!max_buf)
+		return -EINVAL;
+
+	max_num = max_buf / sizeof(struct smb2_lock_element);
+	buf = kzalloc(max_num * sizeof(struct smb2_lock_element), GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	cur = buf;
+
+	mutex_lock(&cinode->lock_mutex);
+	list_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {
+		if (flock->fl_start > li->offset ||
+		    (flock->fl_start + length) <
+		    (li->offset + li->length))
+			continue;
+		if (current->tgid != li->pid)
+			continue;
+		if (cinode->can_cache_brlcks) {
+			/*
+			 * We can cache brlock requests - simply remove a lock
+			 * from the file's list.
+			 */
+			list_del(&li->llist);
+			cifs_del_lock_waiters(li);
+			kfree(li);
+			continue;
+		}
+		cur->Length = cpu_to_le64(li->length);
+		cur->Offset = cpu_to_le64(li->offset);
+		cur->Flags = cpu_to_le32(SMB2_LOCKFLAG_UNLOCK);
+		/*
+		 * We need to save a lock here to let us add it again to the
+		 * file's list if the unlock range request fails on the server.
+		 */
+		list_move(&li->llist, &tmp_llist);
+		if (++num == max_num) {
+			stored_rc = smb2_lockv(xid, tcon,
+					       cfile->fid.persistent_fid,
+					       cfile->fid.volatile_fid,
+					       current->tgid, num, buf);
+			if (stored_rc) {
+				/*
+				 * We failed on the unlock range request - add
+				 * all locks from the tmp list to the head of
+				 * the file's list.
+				 */
+				cifs_move_llist(&tmp_llist,
+						&cfile->llist->locks);
+				rc = stored_rc;
+			} else
+				/*
+				 * The unlock range request succeed - free the
+				 * tmp list.
+				 */
+				cifs_free_llist(&tmp_llist);
+			cur = buf;
+			num = 0;
+		} else
+			cur++;
+	}
+	if (num) {
+		stored_rc = smb2_lockv(xid, tcon, cfile->fid.persistent_fid,
+				       cfile->fid.volatile_fid, current->tgid,
+				       num, buf);
+		if (stored_rc) {
+			cifs_move_llist(&tmp_llist, &cfile->llist->locks);
+			rc = stored_rc;
+		} else
+			cifs_free_llist(&tmp_llist);
+	}
+	mutex_unlock(&cinode->lock_mutex);
+
+	kfree(buf);
+	return rc;
+}

commit 2e44b2887882134abf353b28867b82645e9f0856
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:33 2012 -0700

    CIFS: Process oplocks for SMB2
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index a7618dfb7712..5ff25e025215 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -34,6 +34,26 @@
 #include "fscache.h"
 #include "smb2proto.h"
 
+void
+smb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)
+{
+	oplock &= 0xFF;
+	if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
+		cinode->clientCanCacheAll = true;
+		cinode->clientCanCacheRead = true;
+		cFYI(1, "Exclusive Oplock granted on inode %p",
+		     &cinode->vfs_inode);
+	} else if (oplock == SMB2_OPLOCK_LEVEL_II) {
+		cinode->clientCanCacheAll = false;
+		cinode->clientCanCacheRead = true;
+		cFYI(1, "Level II Oplock granted on inode %p",
+		    &cinode->vfs_inode);
+	} else {
+		cinode->clientCanCacheAll = false;
+		cinode->clientCanCacheRead = false;
+	}
+}
+
 int
 smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 	       int disposition, int desired_access, int create_options,
@@ -58,10 +78,11 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 	}
 
 	desired_access |= FILE_READ_ATTRIBUTES;
+	*oplock = SMB2_OPLOCK_LEVEL_EXCLUSIVE;
 
 	rc = SMB2_open(xid, tcon, smb2_path, &fid->persistent_fid,
 		       &fid->volatile_fid, desired_access, disposition,
-		       0, 0, smb2_data);
+		       0, 0, (__u8 *)oplock, smb2_data);
 	if (rc)
 		goto out;
 
@@ -79,7 +100,6 @@ smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
 	}
 
 out:
-	*oplock = 0;
 	kfree(smb2_data);
 	kfree(smb2_path);
 	return rc;

commit f0df737ee820ec62055baf2b28e24db4fb1ad71d
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:26 2012 -0700

    CIFS: Add open/close file support for SMB2
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
new file mode 100644
index 000000000000..a7618dfb7712
--- /dev/null
+++ b/fs/cifs/smb2file.c
@@ -0,0 +1,86 @@
+/*
+ *   fs/cifs/smb2file.c
+ *
+ *   Copyright (C) International Business Machines  Corp., 2002, 2011
+ *   Author(s): Steve French (sfrench@us.ibm.com),
+ *              Pavel Shilovsky ((pshilovsky@samba.org) 2012
+ *
+ *   This library is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU Lesser General Public License as published
+ *   by the Free Software Foundation; either version 2.1 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU Lesser General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Lesser General Public License
+ *   along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <asm/div64.h>
+#include "cifsfs.h"
+#include "cifspdu.h"
+#include "cifsglob.h"
+#include "cifsproto.h"
+#include "cifs_debug.h"
+#include "cifs_fs_sb.h"
+#include "cifs_unicode.h"
+#include "fscache.h"
+#include "smb2proto.h"
+
+int
+smb2_open_file(const unsigned int xid, struct cifs_tcon *tcon, const char *path,
+	       int disposition, int desired_access, int create_options,
+	       struct cifs_fid *fid, __u32 *oplock, FILE_ALL_INFO *buf,
+	       struct cifs_sb_info *cifs_sb)
+{
+	int rc;
+	__le16 *smb2_path;
+	struct smb2_file_all_info *smb2_data = NULL;
+
+	smb2_path = cifs_convert_path_to_utf16(path, cifs_sb);
+	if (smb2_path == NULL) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	smb2_data = kzalloc(sizeof(struct smb2_file_all_info) + MAX_NAME * 2,
+			    GFP_KERNEL);
+	if (smb2_data == NULL) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	desired_access |= FILE_READ_ATTRIBUTES;
+
+	rc = SMB2_open(xid, tcon, smb2_path, &fid->persistent_fid,
+		       &fid->volatile_fid, desired_access, disposition,
+		       0, 0, smb2_data);
+	if (rc)
+		goto out;
+
+	if (buf) {
+		/* open response does not have IndexNumber field - get it */
+		rc = SMB2_get_srv_num(xid, tcon, fid->persistent_fid,
+				      fid->volatile_fid,
+				      &smb2_data->IndexNumber);
+		if (rc) {
+			/* let get_inode_info disable server inode numbers */
+			smb2_data->IndexNumber = 0;
+			rc = 0;
+		}
+		move_smb2_info_to_cifs(buf, smb2_data);
+	}
+
+out:
+	*oplock = 0;
+	kfree(smb2_data);
+	kfree(smb2_path);
+	return rc;
+}
