commit 7866c177a03b18be3d83175014c643546e5b53c6
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Jun 9 19:50:40 2020 -0500

    smb3: fix typo in mount options displayed in /proc/mounts
    
    Missing the final 's' in "max_channels" mount option when displayed in
    /proc/mounts (or by mount command)
    
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Shyam Prasad N <nspmangalore@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 889f9c71049b..0fb99d25e8a8 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -623,7 +623,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
 
 	if (tcon->ses->chan_max > 1)
-		seq_printf(s, ",multichannel,max_channel=%zu",
+		seq_printf(s, ",multichannel,max_channels=%zu",
 			   tcon->ses->chan_max);
 
 	return 0;

commit 82e9367c43890cb6a870f700c9180c7eb2035684
Author: Steve French <stfrench@microsoft.com>
Date:   Tue May 19 03:06:57 2020 -0500

    smb3: Add new parm "nodelete"
    
    In order to handle workloads where it is important to make sure that
    a buggy app did not delete content on the drive, the new mount option
    "nodelete" allows standard permission checks on the server to work,
    but prevents on the client any attempts to unlink a file or delete
    a directory on that mount point.  This can be helpful when running
    a little understood app on a network mount that contains important
    content that should not be deleted.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c31f362fa098..889f9c71049b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -534,6 +534,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",signloosely");
 	if (tcon->nocase)
 		seq_puts(s, ",nocase");
+	if (tcon->nodelete)
+		seq_puts(s, ",nodelete");
 	if (tcon->local_lease)
 		seq_puts(s, ",locallease");
 	if (tcon->retry)

commit 4e8aea30f7751ce7c4b158aa0c04e7744d281cc3
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Apr 9 21:42:18 2020 -0500

    smb3: enable swap on SMB3 mounts
    
    Add experimental support for allowing a swap file to be on an SMB3
    mount.  There are use cases where swapping over a secure network
    filesystem is preferable. In some cases there are no local
    block devices large enough, and network block devices can be
    hard to setup and secure.  And in some cases there are no
    local block devices at all (e.g. with the recent addition of
    remote boot over SMB3 mounts).
    
    There are various enhancements that can be added later e.g.:
    - doing a mandatory byte range lock over the swapfile (until
    the Linux VFS is modified to notify the file system that an open
    is for a swapfile, when the file can be opened "DENY_ALL" to prevent
    others from opening it).
    - pinning more buffers in the underlying transport to minimize memory
    allocations in the TCP stack under the fs
    - documenting how to create ACLs (on the server) to secure the
    swapfile (or adding additional tools to cifs-utils to make it easier)
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 94e3ed4850b5..c31f362fa098 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1208,6 +1208,10 @@ static ssize_t cifs_copy_file_range(struct file *src_file, loff_t off,
 {
 	unsigned int xid = get_xid();
 	ssize_t rc;
+	struct cifsFileInfo *cfile = dst_file->private_data;
+
+	if (cfile->swapfile)
+		return -EOPNOTSUPP;
 
 	rc = cifs_file_copychunk_range(xid, src_file, off, dst_file, destoff,
 					len, flags);

commit c7e9f78f7b459885ee472d661473aa87a0f24c04
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Feb 25 18:08:54 2020 -0600

    cifs: do d_move in rename
    
    See commit 349457ccf2592c14bdf13b6706170ae2e94931b1
    "Allow file systems to manually d_move() inside of ->rename()"
    
    Lessens possibility of race conditions in rename
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index fa77fe5258b0..94e3ed4850b5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1018,7 +1018,7 @@ struct file_system_type cifs_fs_type = {
 	.name = "cifs",
 	.mount = cifs_do_mount,
 	.kill_sb = cifs_kill_sb,
-	/*  .fs_flags */
+	.fs_flags = FS_RENAME_DOES_D_MOVE,
 };
 MODULE_ALIAS_FS("cifs");
 
@@ -1027,7 +1027,7 @@ static struct file_system_type smb3_fs_type = {
 	.name = "smb3",
 	.mount = smb3_do_mount,
 	.kill_sb = cifs_kill_sb,
-	/*  .fs_flags */
+	.fs_flags = FS_RENAME_DOES_D_MOVE,
 };
 MODULE_ALIAS_FS("smb3");
 MODULE_ALIAS("smb3");

commit ec57010acd03428a749d2600bf09bd537eaae993
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Feb 19 23:59:32 2020 -0600

    cifs: add missing mount option to /proc/mounts
    
    We were not displaying the mount option "signloosely" in /proc/mounts
    for cifs mounts which some users found confusing recently
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 46ebaf3f0824..fa77fe5258b0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -530,6 +530,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 
 	if (tcon->seal)
 		seq_puts(s, ",seal");
+	else if (tcon->ses->server->ignore_signature)
+		seq_puts(s, ",signloosely");
 	if (tcon->nocase)
 		seq_puts(s, ",nocase");
 	if (tcon->local_lease)

commit 3f6166aaf19902f2f3124b5426405e292e8974dd
Author: Petr Pavlu <petr.pavlu@suse.com>
Date:   Mon Feb 10 10:38:14 2020 +0100

    cifs: fix mount option display for sec=krb5i
    
    Fix display for sec=krb5i which was wrongly interleaved by cruid,
    resulting in string "sec=krb5,cruid=<...>i" instead of
    "sec=krb5i,cruid=<...>".
    
    Fixes: 96281b9e46eb ("smb3: for kerberos mounts display the credential uid used")
    Signed-off-by: Petr Pavlu <petr.pavlu@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index febab27cd838..46ebaf3f0824 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -414,7 +414,7 @@ cifs_show_security(struct seq_file *s, struct cifs_ses *ses)
 		seq_puts(s, "ntlm");
 		break;
 	case Kerberos:
-		seq_printf(s, "krb5,cruid=%u", from_kuid_munged(&init_user_ns,ses->cred_uid));
+		seq_puts(s, "krb5");
 		break;
 	case RawNTLMSSP:
 		seq_puts(s, "ntlmssp");
@@ -427,6 +427,10 @@ cifs_show_security(struct seq_file *s, struct cifs_ses *ses)
 
 	if (ses->sign)
 		seq_puts(s, "i");
+
+	if (ses->sectype == Kerberos)
+		seq_printf(s, ",cruid=%u",
+			   from_kuid_munged(&init_user_ns, ses->cred_uid));
 }
 
 static void

commit 0f060936e490c6279dfe773d75d526d3d3d77111
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Mon Feb 3 21:46:43 2020 +0200

    SMB3: Backup intent flag missing from some more ops
    
    When "backup intent" is requested on the mount (e.g. backupuid or
    backupgid mount options), the corresponding flag was missing from
    some of the operations.
    
    Change all operations to use the macro cifs_create_options() to
    set the backup intent flag if needed.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5492b9860baa..febab27cd838 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -275,7 +275,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_ffree = 0;	/* unlimited */
 
 	if (server->ops->queryfs)
-		rc = server->ops->queryfs(xid, tcon, buf);
+		rc = server->ops->queryfs(xid, tcon, cifs_sb, buf);
 
 	free_xid(xid);
 	return 0;

commit 0aecba6173216931c436a03183f4759a4fd4c2f2
Merge: b0d4beaa5a4b 2fa6b1e01a9b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 6 09:06:58 2019 -0800

    Merge branch 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs d_inode/d_flags memory ordering fixes from Al Viro:
     "Fallout from tree-wide audit for ->d_inode/->d_flags barriers use.
      Basically, the problem is that negative pinned dentries require
      careful treatment - unless ->d_lock is locked or parent is held at
      least shared, another thread can make them positive right under us.
    
      Most of the uses turned out to be safe - the main surprises as far as
      filesystems are concerned were
    
       - race in dget_parent() fastpath, that might end up with the caller
         observing the returned dentry _negative_, due to insufficient
         barriers. It is positive in memory, but we could end up seeing the
         wrong value of ->d_inode in CPU cache. Fixed.
    
       - manual checks that result of lookup_one_len_unlocked() is positive
         (and rejection of negatives). Again, insufficient barriers (we
         might end up with inconsistent observed values of ->d_inode and
         ->d_flags). Fixed by switching to a new primitive that does the
         checks itself and returns ERR_PTR(-ENOENT) instead of a negative
         dentry. That way we get rid of boilerplate converting negatives
         into ERR_PTR(-ENOENT) in the callers and have a single place to
         deal with the barrier-related mess - inside fs/namei.c rather than
         in every caller out there.
    
      The guts of pathname resolution *do* need to be careful - the race
      found by Ritesh is real, as well as several similar races.
      Fortunately, it turns out that we can take care of that with fairly
      local changes in there.
    
      The tree-wide audit had not been fun, and I hate the idea of repeating
      it. I think the right approach would be to annotate the places where
      we are _not_ guaranteed ->d_inode/->d_flags stability and have sparse
      catch regressions. But I'm still not sure what would be the least
      invasive way of doing that and it's clearly the next cycle fodder"
    
    * 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs/namei.c: fix missing barriers when checking positivity
      fix dget_parent() fastpath race
      new helper: lookup_positive_unlocked()
      fs/namei.c: pull positivity check into follow_managed()

commit 937d6eefc716a9071f0e3bada19200de1bb9d048
Merge: 2c97b5ae83dc 36bb9778fd11
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 2 11:51:02 2019 -0800

    Merge tag 'docs-5.5a' of git://git.lwn.net/linux
    
    Pull Documentation updates from Jonathan Corbet:
     "Here are the main documentation changes for 5.5:
    
       - Various kerneldoc script enhancements.
    
       - More RST conversions; those are slowing down as we run out of
         things to convert, but we're a ways from done still.
    
       - Dan's "maintainer profile entry" work landed at last. Now we just
         need to get maintainers to fill in the profiles...
    
       - A reworking of the parallel build setup to work better with a
         variety of systems (and to not take over huge systems entirely in
         particular).
    
       - The MAINTAINERS file is now converted to RST during the build.
         Hopefully nobody ever tries to print this thing, or they will need
         to load a lot of paper.
    
       - A script and documentation making it easy for maintainers to add
         Link: tags at commit time.
    
      Also included is the removal of a bunch of spurious CR characters"
    
    * tag 'docs-5.5a' of git://git.lwn.net/linux: (91 commits)
      docs: remove a bunch of stray CRs
      docs: fix up the maintainer profile document
      libnvdimm, MAINTAINERS: Maintainer Entry Profile
      Maintainer Handbook: Maintainer Entry Profile
      MAINTAINERS: Reclaim the P: tag for Maintainer Entry Profile
      docs, parallelism: Rearrange how jobserver reservations are made
      docs, parallelism: Do not leak blocking mode to other readers
      docs, parallelism: Fix failure path and add comment
      Documentation: Remove bootmem_debug from kernel-parameters.txt
      Documentation: security: core.rst: fix warnings
      Documentation/process/howto/kokr: Update for 4.x -> 5.x versioning
      Documentation/translation: Use Korean for Korean translation title
      docs/memory-barriers.txt: Remove remaining references to mmiowb()
      docs/memory-barriers.txt/kokr: Update I/O section to be clearer about CPU vs thread
      docs/memory-barriers.txt/kokr: Fix style, spacing and grammar in I/O section
      Documentation/kokr: Kill all references to mmiowb()
      docs/memory-barriers.txt/kokr: Rewrite "KERNEL I/O BARRIER EFFECTS" section
      docs: Add initial documentation for devfreq
      Documentation: Document how to get links with git am
      docs: Add request_irq() documentation
      ...

commit 32546a9586aa4565035bb557e191648e022b29e8
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Sun Nov 3 13:06:37 2019 +1000

    cifs: move cifsFileInfo_put logic into a work-queue
    
    This patch moves the final part of the cifsFileInfo_put() logic where we
    need a write lock on lock_sem to be processed in a separate thread that
    holds no other locks.
    This is to prevent deadlocks like the one below:
    
    > there are 6 processes looping to while trying to down_write
    > cinode->lock_sem, 5 of them from _cifsFileInfo_put, and one from
    > cifs_new_fileinfo
    >
    > and there are 5 other processes which are blocked, several of them
    > waiting on either PG_writeback or PG_locked (which are both set), all
    > for the same page of the file
    >
    > 2 inode_lock() (inode->i_rwsem) for the file
    > 1 wait_on_page_writeback() for the page
    > 1 down_read(inode->i_rwsem) for the inode of the directory
    > 1 inode_lock()(inode->i_rwsem) for the inode of the directory
    > 1 __lock_page
    >
    >
    > so processes are blocked waiting on:
    >   page flags PG_locked and PG_writeback for one specific page
    >   inode->i_rwsem for the directory
    >   inode->i_rwsem for the file
    >   cifsInodeInflock_sem
    >
    >
    >
    > here are the more gory details (let me know if I need to provide
    > anything more/better):
    >
    > [0 00:48:22.765] [UN]  PID: 8863   TASK: ffff8c691547c5c0  CPU: 3
    > COMMAND: "reopen_file"
    >  #0 [ffff9965007e3ba8] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965007e3c38] schedule at ffffffff9b6e64df
    >  #2 [ffff9965007e3c48] rwsem_down_write_slowpath at ffffffff9af283d7
    >  #3 [ffff9965007e3cb8] legitimize_path at ffffffff9b0f975d
    >  #4 [ffff9965007e3d08] path_openat at ffffffff9b0fe55d
    >  #5 [ffff9965007e3dd8] do_filp_open at ffffffff9b100a33
    >  #6 [ffff9965007e3ee0] do_sys_open at ffffffff9b0eb2d6
    >  #7 [ffff9965007e3f38] do_syscall_64 at ffffffff9ae04315
    > * (I think legitimize_path is bogus)
    >
    > in path_openat
    >         } else {
    >                 const char *s = path_init(nd, flags);
    >                 while (!(error = link_path_walk(s, nd)) &&
    >                         (error = do_last(nd, file, op)) > 0) {  <<<<
    >
    > do_last:
    >         if (open_flag & O_CREAT)
    >                 inode_lock(dir->d_inode);  <<<<
    >         else
    > so it's trying to take inode->i_rwsem for the directory
    >
    >      DENTRY           INODE           SUPERBLK     TYPE PATH
    > ffff8c68bb8e79c0 ffff8c691158ef20 ffff8c6915bf9000 DIR  /mnt/vm1_smb/
    > inode.i_rwsem is ffff8c691158efc0
    >
    > <struct rw_semaphore 0xffff8c691158efc0>:
    >         owner: <struct task_struct 0xffff8c6914275d00> (UN -   8856 -
    > reopen_file), counter: 0x0000000000000003
    >         waitlist: 2
    >         0xffff9965007e3c90     8863   reopen_file      UN 0  1:29:22.926
    >   RWSEM_WAITING_FOR_WRITE
    >         0xffff996500393e00     9802   ls               UN 0  1:17:26.700
    >   RWSEM_WAITING_FOR_READ
    >
    >
    > the owner of the inode.i_rwsem of the directory is:
    >
    > [0 00:00:00.109] [UN]  PID: 8856   TASK: ffff8c6914275d00  CPU: 3
    > COMMAND: "reopen_file"
    >  #0 [ffff99650065b828] __schedule at ffffffff9b6e6095
    >  #1 [ffff99650065b8b8] schedule at ffffffff9b6e64df
    >  #2 [ffff99650065b8c8] schedule_timeout at ffffffff9b6e9f89
    >  #3 [ffff99650065b940] msleep at ffffffff9af573a9
    >  #4 [ffff99650065b948] _cifsFileInfo_put.cold.63 at ffffffffc0a42dd6 [cifs]
    >  #5 [ffff99650065ba38] cifs_writepage_locked at ffffffffc0a0b8f3 [cifs]
    >  #6 [ffff99650065bab0] cifs_launder_page at ffffffffc0a0bb72 [cifs]
    >  #7 [ffff99650065bb30] invalidate_inode_pages2_range at ffffffff9b04d4bd
    >  #8 [ffff99650065bcb8] cifs_invalidate_mapping at ffffffffc0a11339 [cifs]
    >  #9 [ffff99650065bcd0] cifs_revalidate_mapping at ffffffffc0a1139a [cifs]
    > #10 [ffff99650065bcf0] cifs_d_revalidate at ffffffffc0a014f6 [cifs]
    > #11 [ffff99650065bd08] path_openat at ffffffff9b0fe7f7
    > #12 [ffff99650065bdd8] do_filp_open at ffffffff9b100a33
    > #13 [ffff99650065bee0] do_sys_open at ffffffff9b0eb2d6
    > #14 [ffff99650065bf38] do_syscall_64 at ffffffff9ae04315
    >
    > cifs_launder_page is for page 0xffffd1e2c07d2480
    >
    > crash> page.index,mapping,flags 0xffffd1e2c07d2480
    >       index = 0x8
    >       mapping = 0xffff8c68f3cd0db0
    >   flags = 0xfffffc0008095
    >
    >   PAGE-FLAG       BIT  VALUE
    >   PG_locked         0  0000001
    >   PG_uptodate       2  0000004
    >   PG_lru            4  0000010
    >   PG_waiters        7  0000080
    >   PG_writeback     15  0008000
    >
    >
    > inode is ffff8c68f3cd0c40
    > inode.i_rwsem is ffff8c68f3cd0ce0
    >      DENTRY           INODE           SUPERBLK     TYPE PATH
    > ffff8c68a1f1b480 ffff8c68f3cd0c40 ffff8c6915bf9000 REG
    > /mnt/vm1_smb/testfile.8853
    >
    >
    > this process holds the inode->i_rwsem for the parent directory, is
    > laundering a page attached to the inode of the file it's opening, and in
    > _cifsFileInfo_put is trying to down_write the cifsInodeInflock_sem
    > for the file itself.
    >
    >
    > <struct rw_semaphore 0xffff8c68f3cd0ce0>:
    >         owner: <struct task_struct 0xffff8c6914272e80> (UN -   8854 -
    > reopen_file), counter: 0x0000000000000003
    >         waitlist: 1
    >         0xffff9965005dfd80     8855   reopen_file      UN 0  1:29:22.912
    >   RWSEM_WAITING_FOR_WRITE
    >
    > this is the inode.i_rwsem for the file
    >
    > the owner:
    >
    > [0 00:48:22.739] [UN]  PID: 8854   TASK: ffff8c6914272e80  CPU: 2
    > COMMAND: "reopen_file"
    >  #0 [ffff99650054fb38] __schedule at ffffffff9b6e6095
    >  #1 [ffff99650054fbc8] schedule at ffffffff9b6e64df
    >  #2 [ffff99650054fbd8] io_schedule at ffffffff9b6e68e2
    >  #3 [ffff99650054fbe8] __lock_page at ffffffff9b03c56f
    >  #4 [ffff99650054fc80] pagecache_get_page at ffffffff9b03dcdf
    >  #5 [ffff99650054fcc0] grab_cache_page_write_begin at ffffffff9b03ef4c
    >  #6 [ffff99650054fcd0] cifs_write_begin at ffffffffc0a064ec [cifs]
    >  #7 [ffff99650054fd30] generic_perform_write at ffffffff9b03bba4
    >  #8 [ffff99650054fda8] __generic_file_write_iter at ffffffff9b04060a
    >  #9 [ffff99650054fdf0] cifs_strict_writev.cold.70 at ffffffffc0a4469b [cifs]
    > #10 [ffff99650054fe48] new_sync_write at ffffffff9b0ec1dd
    > #11 [ffff99650054fed0] vfs_write at ffffffff9b0eed35
    > #12 [ffff99650054ff00] ksys_write at ffffffff9b0eefd9
    > #13 [ffff99650054ff38] do_syscall_64 at ffffffff9ae04315
    >
    > the process holds the inode->i_rwsem for the file to which it's writing,
    > and is trying to __lock_page for the same page as in the other processes
    >
    >
    > the other tasks:
    > [0 00:00:00.028] [UN]  PID: 8859   TASK: ffff8c6915479740  CPU: 2
    > COMMAND: "reopen_file"
    >  #0 [ffff9965007b39d8] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965007b3a68] schedule at ffffffff9b6e64df
    >  #2 [ffff9965007b3a78] schedule_timeout at ffffffff9b6e9f89
    >  #3 [ffff9965007b3af0] msleep at ffffffff9af573a9
    >  #4 [ffff9965007b3af8] cifs_new_fileinfo.cold.61 at ffffffffc0a42a07 [cifs]
    >  #5 [ffff9965007b3b78] cifs_open at ffffffffc0a0709d [cifs]
    >  #6 [ffff9965007b3cd8] do_dentry_open at ffffffff9b0e9b7a
    >  #7 [ffff9965007b3d08] path_openat at ffffffff9b0fe34f
    >  #8 [ffff9965007b3dd8] do_filp_open at ffffffff9b100a33
    >  #9 [ffff9965007b3ee0] do_sys_open at ffffffff9b0eb2d6
    > #10 [ffff9965007b3f38] do_syscall_64 at ffffffff9ae04315
    >
    > this is opening the file, and is trying to down_write cinode->lock_sem
    >
    >
    > [0 00:00:00.041] [UN]  PID: 8860   TASK: ffff8c691547ae80  CPU: 2
    > COMMAND: "reopen_file"
    > [0 00:00:00.057] [UN]  PID: 8861   TASK: ffff8c6915478000  CPU: 3
    > COMMAND: "reopen_file"
    > [0 00:00:00.059] [UN]  PID: 8858   TASK: ffff8c6914271740  CPU: 2
    > COMMAND: "reopen_file"
    > [0 00:00:00.109] [UN]  PID: 8862   TASK: ffff8c691547dd00  CPU: 6
    > COMMAND: "reopen_file"
    >  #0 [ffff9965007c3c78] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965007c3d08] schedule at ffffffff9b6e64df
    >  #2 [ffff9965007c3d18] schedule_timeout at ffffffff9b6e9f89
    >  #3 [ffff9965007c3d90] msleep at ffffffff9af573a9
    >  #4 [ffff9965007c3d98] _cifsFileInfo_put.cold.63 at ffffffffc0a42dd6 [cifs]
    >  #5 [ffff9965007c3e88] cifs_close at ffffffffc0a07aaf [cifs]
    >  #6 [ffff9965007c3ea0] __fput at ffffffff9b0efa6e
    >  #7 [ffff9965007c3ee8] task_work_run at ffffffff9aef1614
    >  #8 [ffff9965007c3f20] exit_to_usermode_loop at ffffffff9ae03d6f
    >  #9 [ffff9965007c3f38] do_syscall_64 at ffffffff9ae0444c
    >
    > closing the file, and trying to down_write cifsi->lock_sem
    >
    >
    > [0 00:48:22.839] [UN]  PID: 8857   TASK: ffff8c6914270000  CPU: 7
    > COMMAND: "reopen_file"
    >  #0 [ffff9965006a7cc8] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965006a7d58] schedule at ffffffff9b6e64df
    >  #2 [ffff9965006a7d68] io_schedule at ffffffff9b6e68e2
    >  #3 [ffff9965006a7d78] wait_on_page_bit at ffffffff9b03cac6
    >  #4 [ffff9965006a7e10] __filemap_fdatawait_range at ffffffff9b03b028
    >  #5 [ffff9965006a7ed8] filemap_write_and_wait at ffffffff9b040165
    >  #6 [ffff9965006a7ef0] cifs_flush at ffffffffc0a0c2fa [cifs]
    >  #7 [ffff9965006a7f10] filp_close at ffffffff9b0e93f1
    >  #8 [ffff9965006a7f30] __x64_sys_close at ffffffff9b0e9a0e
    >  #9 [ffff9965006a7f38] do_syscall_64 at ffffffff9ae04315
    >
    > in __filemap_fdatawait_range
    >                         wait_on_page_writeback(page);
    > for the same page of the file
    >
    >
    >
    > [0 00:48:22.718] [UN]  PID: 8855   TASK: ffff8c69142745c0  CPU: 7
    > COMMAND: "reopen_file"
    >  #0 [ffff9965005dfc98] __schedule at ffffffff9b6e6095
    >  #1 [ffff9965005dfd28] schedule at ffffffff9b6e64df
    >  #2 [ffff9965005dfd38] rwsem_down_write_slowpath at ffffffff9af283d7
    >  #3 [ffff9965005dfdf0] cifs_strict_writev at ffffffffc0a0c40a [cifs]
    >  #4 [ffff9965005dfe48] new_sync_write at ffffffff9b0ec1dd
    >  #5 [ffff9965005dfed0] vfs_write at ffffffff9b0eed35
    >  #6 [ffff9965005dff00] ksys_write at ffffffff9b0eefd9
    >  #7 [ffff9965005dff38] do_syscall_64 at ffffffff9ae04315
    >
    >         inode_lock(inode);
    >
    >
    > and one 'ls' later on, to see whether the rest of the mount is available
    > (the test file is in the root, so we get blocked up on the directory
    > ->i_rwsem), so the entire mount is unavailable
    >
    > [0 00:36:26.473] [UN]  PID: 9802   TASK: ffff8c691436ae80  CPU: 4
    > COMMAND: "ls"
    >  #0 [ffff996500393d28] __schedule at ffffffff9b6e6095
    >  #1 [ffff996500393db8] schedule at ffffffff9b6e64df
    >  #2 [ffff996500393dc8] rwsem_down_read_slowpath at ffffffff9b6e9421
    >  #3 [ffff996500393e78] down_read_killable at ffffffff9b6e95e2
    >  #4 [ffff996500393e88] iterate_dir at ffffffff9b103c56
    >  #5 [ffff996500393ec8] ksys_getdents64 at ffffffff9b104b0c
    >  #6 [ffff996500393f30] __x64_sys_getdents64 at ffffffff9b104bb6
    >  #7 [ffff996500393f38] do_syscall_64 at ffffffff9ae04315
    >
    > in iterate_dir:
    >         if (shared)
    >                 res = down_read_killable(&inode->i_rwsem);  <<<<
    >         else
    >                 res = down_write_killable(&inode->i_rwsem);
    >
    
    Reported-by: Frank Sorenson <sorenson@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5664bb7ba40f..5d3e63aff253 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -119,6 +119,7 @@ extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
 struct workqueue_struct	*decrypt_wq;
+struct workqueue_struct	*fileinfo_put_wq;
 struct workqueue_struct	*cifsoplockd_wq;
 __u32 cifs_lock_secret;
 
@@ -1561,11 +1562,18 @@ init_cifs(void)
 		goto out_destroy_cifsiod_wq;
 	}
 
+	fileinfo_put_wq = alloc_workqueue("cifsfileinfoput",
+				     WQ_UNBOUND|WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
+	if (!fileinfo_put_wq) {
+		rc = -ENOMEM;
+		goto out_destroy_decrypt_wq;
+	}
+
 	cifsoplockd_wq = alloc_workqueue("cifsoplockd",
 					 WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
 	if (!cifsoplockd_wq) {
 		rc = -ENOMEM;
-		goto out_destroy_decrypt_wq;
+		goto out_destroy_fileinfo_put_wq;
 	}
 
 	rc = cifs_fscache_register();
@@ -1631,6 +1639,8 @@ init_cifs(void)
 	cifs_fscache_unregister();
 out_destroy_cifsoplockd_wq:
 	destroy_workqueue(cifsoplockd_wq);
+out_destroy_fileinfo_put_wq:
+	destroy_workqueue(fileinfo_put_wq);
 out_destroy_decrypt_wq:
 	destroy_workqueue(decrypt_wq);
 out_destroy_cifsiod_wq:
@@ -1660,6 +1670,7 @@ exit_cifs(void)
 	cifs_fscache_unregister();
 	destroy_workqueue(cifsoplockd_wq);
 	destroy_workqueue(decrypt_wq);
+	destroy_workqueue(fileinfo_put_wq);
 	destroy_workqueue(cifsiod_wq);
 	cifs_proc_clean();
 }

commit bcc8880115bcb36bc281c7f4895a12b51569d8d4
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Sep 20 04:32:20 2019 +0200

    cifs: add multichannel mount options and data structs
    
    adds:
    - [no]multichannel to enable/disable multichannel
    - max_channels=N to control how many channels to create
    
    these options are then stored in the volume struct.
    
    - store channels and max_channels in cifs_ses
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7bd7cd31d8f5..5664bb7ba40f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -613,6 +613,10 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	/* convert actimeo and display it in seconds */
 	seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
 
+	if (tcon->ses->chan_max > 1)
+		seq_printf(s, ",multichannel,max_channel=%zu",
+			   tcon->ses->chan_max);
+
 	return 0;
 }
 

commit 3591bb83eee7731d3421621a3b04d2432f80bba0
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Oct 31 13:55:14 2019 +1000

    cifs: don't use 'pre:' for MODULE_SOFTDEP
    
    It can cause
    to fail with
    modprobe: FATAL: Module <module> is builtin.
    
    RHBZ: 1767094
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e4e3b573d20c..7bd7cd31d8f5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1666,17 +1666,17 @@ MODULE_DESCRIPTION
 	("VFS to access SMB3 servers e.g. Samba, Macs, Azure and Windows (and "
 	"also older servers complying with the SNIA CIFS Specification)");
 MODULE_VERSION(CIFS_VERSION);
-MODULE_SOFTDEP("pre: ecb");
-MODULE_SOFTDEP("pre: hmac");
-MODULE_SOFTDEP("pre: md4");
-MODULE_SOFTDEP("pre: md5");
-MODULE_SOFTDEP("pre: nls");
-MODULE_SOFTDEP("pre: aes");
-MODULE_SOFTDEP("pre: cmac");
-MODULE_SOFTDEP("pre: sha256");
-MODULE_SOFTDEP("pre: sha512");
-MODULE_SOFTDEP("pre: aead2");
-MODULE_SOFTDEP("pre: ccm");
-MODULE_SOFTDEP("pre: gcm");
+MODULE_SOFTDEP("ecb");
+MODULE_SOFTDEP("hmac");
+MODULE_SOFTDEP("md4");
+MODULE_SOFTDEP("md5");
+MODULE_SOFTDEP("nls");
+MODULE_SOFTDEP("aes");
+MODULE_SOFTDEP("cmac");
+MODULE_SOFTDEP("sha256");
+MODULE_SOFTDEP("sha512");
+MODULE_SOFTDEP("aead2");
+MODULE_SOFTDEP("ccm");
+MODULE_SOFTDEP("gcm");
 module_init(init_cifs)
 module_exit(exit_cifs)

commit d0677992d2af3d65f1c1c21de3323d09d4891537
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Jul 16 18:55:38 2019 -0500

    cifs: add support for flock
    
    The flock system call locks the whole file rather than a byte
    range and so is currently emulated by various other file systems
    by simply sending a byte range lock for the whole file.
    Add flock handling for cifs.ko in similar way.
    
    xfstest generic/504 passes with this as well
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1a135d1b85bd..e4e3b573d20c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1219,6 +1219,7 @@ const struct file_operations cifs_file_ops = {
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
+	.flock = cifs_flock,
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
@@ -1238,6 +1239,7 @@ const struct file_operations cifs_file_strict_ops = {
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
+	.flock = cifs_flock,
 	.fsync = cifs_strict_fsync,
 	.flush = cifs_flush,
 	.mmap = cifs_file_strict_mmap,
@@ -1257,6 +1259,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
+	.flock = cifs_flock,
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
 	.mmap = cifs_file_mmap,

commit 6c2d4798a8d16cf4f3a28c3cd4af4f1dcbbb4d04
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 31 01:21:58 2019 -0400

    new helper: lookup_positive_unlocked()
    
    Most of the callers of lookup_one_len_unlocked() treat negatives are
    ERR_PTR(-ENOENT).  Provide a helper that would do just that.  Note
    that a pinned positive dentry remains positive - it's ->d_inode is
    stable, etc.; a pinned _negative_ dentry can become positive at any
    point as long as you are not holding its parent at least shared.
    So using lookup_one_len_unlocked() needs to be careful;
    lookup_positive_unlocked() is safer and that's what the callers
    end up open-coding anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c049c7b3aa87..8c8600e53339 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -719,11 +719,6 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		struct inode *dir = d_inode(dentry);
 		struct dentry *child;
 
-		if (!dir) {
-			dput(dentry);
-			dentry = ERR_PTR(-ENOENT);
-			break;
-		}
 		if (!S_ISDIR(dir->i_mode)) {
 			dput(dentry);
 			dentry = ERR_PTR(-ENOTDIR);
@@ -740,7 +735,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		while (*s && *s != sep)
 			s++;
 
-		child = lookup_one_len_unlocked(p, dentry, s - p);
+		child = lookup_positive_unlocked(p, dentry, s - p);
 		dput(dentry);
 		dentry = child;
 	} while (!IS_ERR(dentry));

commit 822bbba0cabb50825a0ce22707dc45eb82d02853
Merge: d41abfd7ae33 7d194c2100ad
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Tue Oct 29 04:43:29 2019 -0600

    Merge tag 'v5.4-rc4' into docs-next
    
    I need to pick up the independent changes made to
    Documentation/core-api/memory-allocation.rst to be able to merge further
    work without creating a total mess.

commit 553292a6342bc9e5636953ac6e20bccedaacbd1c
Author: Steve French <stfrench@microsoft.com>
Date:   Fri Oct 11 17:36:13 2019 -0700

    cifs: clarify comment about timestamp granularity for old servers
    
    It could be confusing why we set granularity to 1 seconds rather
    than 2 seconds (1 second is the max the VFS allows) for these
    mounts to very old servers ...
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c049c7b3aa87..1a135d1b85bd 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -169,7 +169,13 @@ cifs_read_super(struct super_block *sb)
 	else
 		sb->s_maxbytes = MAX_NON_LFS;
 
-	/* Some very old servers like DOS and OS/2 used 2 second granularity */
+	/*
+	 * Some very old servers like DOS and OS/2 used 2 second granularity
+	 * (while all current servers use 100ns granularity - see MS-DTYP)
+	 * but 1 second is the maximum allowed granularity for the VFS
+	 * so for old servers set time granularity to 1 second while for
+	 * everything else (current servers) set it to 100ns.
+	 */
 	if ((tcon->ses->server->vals->protocol_id == SMB10_PROT_ID) &&
 	    ((tcon->ses->capabilities &
 	      tcon->ses->server->vals->cap_nt_find) == 0) &&

commit 0ac624f47dd3474441bb56d64f97192f139b593f
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue Sep 24 10:01:28 2019 -0300

    docs: fix some broken references
    
    There are a number of documentation files that got moved or
    renamed. update their references.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Shannon Nelson <snelson@pensando.io>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Paul Walmsley <paul.walmsley@sifive.com> # RISC-V
    Acked-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2e9c7f493f99..811f510578cb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1529,7 +1529,7 @@ init_cifs(void)
 	/*
 	 * Consider in future setting limit!=0 maybe to min(num_of_cores - 1, 3)
 	 * so that we don't launch too many worker threads but
-	 * Documentation/workqueue.txt recommends setting it to 0
+	 * Documentation/core-api/workqueue.rst recommends setting it to 0
 	 */
 
 	/* WQ_UNBOUND allows decrypt tasks to run on any CPU */

commit d4cfbf04b2aafcb657eb8ea0835e5cf51d371448
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Oct 8 00:27:14 2019 -0500

    smb3: Fix regression in time handling
    
    Fixes: cb7a69e60590 ("cifs: Initialize filesystem timestamp ranges")
    
    Only very old servers (e.g. OS/2 and DOS) did not support
    DCE TIME (100 nanosecond granularity).  Fix the checks used
    to set minimum and maximum times.
    
    Fixes xfstest generic/258 (on 5.4-rc1 and later)
    
    CC: Deepa Dinamani <deepa.kernel@gmail.com>
    Acked-by: Jeff Layton <jlayton@kernel.org>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2e9c7f493f99..c049c7b3aa87 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -169,18 +169,26 @@ cifs_read_super(struct super_block *sb)
 	else
 		sb->s_maxbytes = MAX_NON_LFS;
 
-	/* BB FIXME fix time_gran to be larger for LANMAN sessions */
-	sb->s_time_gran = 100;
-
-	if (tcon->unix_ext) {
-		ts = cifs_NTtimeToUnix(0);
+	/* Some very old servers like DOS and OS/2 used 2 second granularity */
+	if ((tcon->ses->server->vals->protocol_id == SMB10_PROT_ID) &&
+	    ((tcon->ses->capabilities &
+	      tcon->ses->server->vals->cap_nt_find) == 0) &&
+	    !tcon->unix_ext) {
+		sb->s_time_gran = 1000000000; /* 1 second is max allowed gran */
+		ts = cnvrtDosUnixTm(cpu_to_le16(SMB_DATE_MIN), 0, 0);
 		sb->s_time_min = ts.tv_sec;
-		ts = cifs_NTtimeToUnix(cpu_to_le64(S64_MAX));
+		ts = cnvrtDosUnixTm(cpu_to_le16(SMB_DATE_MAX),
+				    cpu_to_le16(SMB_TIME_MAX), 0);
 		sb->s_time_max = ts.tv_sec;
 	} else {
-		ts = cnvrtDosUnixTm(cpu_to_le16(SMB_DATE_MIN), 0, 0);
+		/*
+		 * Almost every server, including all SMB2+, uses DCE TIME
+		 * ie 100 nanosecond units, since 1601.  See MS-DTYP and MS-FSCC
+		 */
+		sb->s_time_gran = 100;
+		ts = cifs_NTtimeToUnix(0);
 		sb->s_time_min = ts.tv_sec;
-		ts = cnvrtDosUnixTm(cpu_to_le16(SMB_DATE_MAX), cpu_to_le16(SMB_TIME_MAX), 0);
+		ts = cifs_NTtimeToUnix(cpu_to_le64(S64_MAX));
 		sb->s_time_max = ts.tv_sec;
 	}
 

commit 7e3d2c8210e67ebff472a0b371bb0efb4236ef52
Merge: 7a0d796100da 4d6bcba70aeb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 10:32:16 2019 -0700

    Merge tag '5.4-smb3-fixes' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull cifs updates from Steve French:
     "Various cifs/smb3 fixes (including for share deleted cases) and
      features including improved encrypted read performance, and various
      debugging improvements.
    
      Note that since I am at a test event this week with the Samba team,
      and at the annual Storage Developer Conference/SMB3 Plugfest test
      event next week a higher than usual number of fixes is expected later
      next week as other features in progress get additional testing and
      review during these two events"
    
    * tag '5.4-smb3-fixes' of git://git.samba.org/sfrench/cifs-2.6: (38 commits)
      cifs: update internal module version number
      cifs: modefromsid: write mode ACE first
      cifs: cifsroot: add more err checking
      smb3: add missing worker function for SMB3 change notify
      cifs: Add support for root file systems
      cifs: modefromsid: make room for 4 ACE
      smb3: fix potential null dereference in decrypt offload
      smb3: fix unmount hang in open_shroot
      smb3: allow disabling requesting leases
      smb3: improve handling of share deleted (and share recreated)
      smb3: display max smb3 requests in flight at any one time
      smb3: only offload decryption of read responses if multiple requests
      cifs: add a helper to find an existing readable handle to a file
      smb3: enable offload of decryption of large reads via mount option
      smb3: allow parallelizing decryption of reads
      cifs: add a debug macro that prints \\server\share for errors
      smb3: fix signing verification of large reads
      smb3: allow skipping signature verification for perf sensitive configurations
      smb3: add dynamic tracepoints for flush and close
      smb3: log warning if CSC policy conflicts with cache mount option
      ...

commit cfb82e1df8b7c76991ea12958855897c2fb4debc
Merge: b41dae061bbd cba465b4f982
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 09:42:37 2019 -0700

    Merge tag 'y2038-vfs' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground
    
    Pull y2038 vfs updates from Arnd Bergmann:
     "Add inode timestamp clamping.
    
      This series from Deepa Dinamani adds a per-superblock minimum/maximum
      timestamp limit for a file system, and clamps timestamps as they are
      written, to avoid random behavior from integer overflow as well as
      having different time stamps on disk vs in memory.
    
      At mount time, a warning is now printed for any file system that can
      represent current timestamps but not future timestamps more than 30
      years into the future, similar to the arbitrary 30 year limit that was
      added to settimeofday().
    
      This was picked as a compromise to warn users to migrate to other file
      systems (e.g. ext4 instead of ext3) when they need the file system to
      survive beyond 2038 (or similar limits in other file systems), but not
      get in the way of normal usage"
    
    * tag 'y2038-vfs' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground:
      ext4: Reduce ext4 timestamp warnings
      isofs: Initialize filesystem timestamp ranges
      pstore: fs superblock limits
      fs: omfs: Initialize filesystem timestamp ranges
      fs: hpfs: Initialize filesystem timestamp ranges
      fs: ceph: Initialize filesystem timestamp ranges
      fs: sysv: Initialize filesystem timestamp ranges
      fs: affs: Initialize filesystem timestamp ranges
      fs: fat: Initialize filesystem timestamp ranges
      fs: cifs: Initialize filesystem timestamp ranges
      fs: nfs: Initialize filesystem timestamp ranges
      ext4: Initialize timestamps limits
      9p: Fill min and max timestamps in sb
      fs: Fill in max and min timestamps in superblock
      utimes: Clamp the timestamps before update
      mount: Add mount warning for impending timestamp expiry
      timestamp_truncate: Replace users of timespec64_trunc
      vfs: Add timestamp_truncate() api
      vfs: Add file timestamp range support

commit 3e7a02d47872081f4b6234a9f72500f1d10f060c
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Sep 11 21:46:20 2019 -0500

    smb3: allow disabling requesting leases
    
    In some cases to work around server bugs or performance
    problems it can be helpful to be able to disable requesting
    SMB2.1/SMB3 leases on a particular mount (not to all servers
    and all shares we are mounted to). Add new mount parm
    "nolease" which turns off requesting leases on directory
    or file opens.  Currently the only way to disable leases is
    globally through a module load parameter. This is more
    granular.
    
    Suggested-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c1b685072063..69601a9b29ad 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -438,6 +438,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	cifs_show_security(s, tcon->ses);
 	cifs_show_cache_flavor(s, cifs_sb);
 
+	if (tcon->no_lease)
+		seq_puts(s, ",nolease");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)
 		seq_puts(s, ",multiuser");
 	else if (tcon->ses->user_name)

commit 10328c44cc1506dd82fd835efcaafd519866c464
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Sep 9 13:30:15 2019 -0500

    smb3: only offload decryption of read responses if multiple requests
    
    No point in offloading read decryption if no other requests on the
    wire
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ebf85a5d95e4..c1b685072063 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1503,11 +1503,14 @@ init_cifs(void)
 	}
 
 	/*
-	 * BB Consider setting limit!=0 maybe to min(num_of_cores - 1, 3) so we
-	 * don't launch too many worker threads
+	 * Consider in future setting limit!=0 maybe to min(num_of_cores - 1, 3)
+	 * so that we don't launch too many worker threads but
+	 * Documentation/workqueue.txt recommends setting it to 0
 	 */
+
+	/* WQ_UNBOUND allows decrypt tasks to run on any CPU */
 	decrypt_wq = alloc_workqueue("smb3decryptd",
-				     WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
+				     WQ_UNBOUND|WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
 	if (!decrypt_wq) {
 		rc = -ENOMEM;
 		goto out_destroy_cifsiod_wq;

commit 563317ec3083f7e126d7e30821ff8505ac338ee5
Author: Steve French <stfrench@microsoft.com>
Date:   Sun Sep 8 23:22:02 2019 -0500

    smb3: enable offload of decryption of large reads via mount option
    
    Disable offload of the decryption of encrypted read responses
    by default (equivalent to setting this new mount option "esize=0").
    
    Allow setting the minimum encrypted read response size that we
    will choose to offload to a worker thread - it is now configurable
    via on a new mount option "esize="
    
    Depending on which encryption mechanism (GCM vs. CCM) and
    the number of reads that will be issued in parallel and the
    performance of the network and CPU on the client, it may make
    sense to enable this since it can provide substantial benefit when
    multiple large reads are in flight at the same time.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b0ea332af35c..ebf85a5d95e4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -559,6 +559,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	seq_printf(s, ",rsize=%u", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%u", cifs_sb->wsize);
 	seq_printf(s, ",bsize=%u", cifs_sb->bsize);
+	if (tcon->ses->server->min_offload)
+		seq_printf(s, ",esize=%u", tcon->ses->server->min_offload);
 	seq_printf(s, ",echo_interval=%lu",
 			tcon->ses->server->echo_interval / HZ);
 

commit 35cf94a397280b9e27576ac1480f631bdd3e7b70
Author: Steve French <stfrench@microsoft.com>
Date:   Sat Sep 7 01:09:49 2019 -0500

    smb3: allow parallelizing decryption of reads
    
    decrypting large reads on encrypted shares can be slow (e.g. adding
    multiple milliseconds per-read on non-GCM capable servers or
    when mounting with dialects prior to SMB3.1.1) - allow parallelizing
    of read decryption by launching worker threads.
    
    Testing to Samba on localhost showed 25% improvement.
    Testing to remote server showed very large improvement when
    doing more than one 'cp' command was called at one time.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index de90e665ef11..b0ea332af35c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -109,6 +109,7 @@ extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
+struct workqueue_struct	*decrypt_wq;
 struct workqueue_struct	*cifsoplockd_wq;
 __u32 cifs_lock_secret;
 
@@ -1499,11 +1500,22 @@ init_cifs(void)
 		goto out_clean_proc;
 	}
 
+	/*
+	 * BB Consider setting limit!=0 maybe to min(num_of_cores - 1, 3) so we
+	 * don't launch too many worker threads
+	 */
+	decrypt_wq = alloc_workqueue("smb3decryptd",
+				     WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
+	if (!decrypt_wq) {
+		rc = -ENOMEM;
+		goto out_destroy_cifsiod_wq;
+	}
+
 	cifsoplockd_wq = alloc_workqueue("cifsoplockd",
 					 WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
 	if (!cifsoplockd_wq) {
 		rc = -ENOMEM;
-		goto out_destroy_cifsiod_wq;
+		goto out_destroy_decrypt_wq;
 	}
 
 	rc = cifs_fscache_register();
@@ -1569,6 +1581,8 @@ init_cifs(void)
 	cifs_fscache_unregister();
 out_destroy_cifsoplockd_wq:
 	destroy_workqueue(cifsoplockd_wq);
+out_destroy_decrypt_wq:
+	destroy_workqueue(decrypt_wq);
 out_destroy_cifsiod_wq:
 	destroy_workqueue(cifsiod_wq);
 out_clean_proc:
@@ -1595,6 +1609,7 @@ exit_cifs(void)
 	cifs_destroy_inodecache();
 	cifs_fscache_unregister();
 	destroy_workqueue(cifsoplockd_wq);
+	destroy_workqueue(decrypt_wq);
 	destroy_workqueue(cifsiod_wq);
 	cifs_proc_clean();
 }

commit 41e033fecdc891da629113c4f8ee80500b7656d6
Author: Steve French <stfrench@microsoft.com>
Date:   Fri Aug 30 02:12:41 2019 -0500

    smb3: add mount option to allow RW caching of share accessed by only 1 client
    
    If a share is known to be only to be accessed by one client, we
    can aggressively cache writes not just reads to it.
    
    Add "cache=" option (cache=singleclient) for mounting read write shares
    (that will not be read or written to from other clients while we have
    it mounted) in order to improve performance.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 970251bc0661..de90e665ef11 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -400,6 +400,8 @@ cifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)
 		seq_puts(s, "strict");
 	else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
 		seq_puts(s, "none");
+	else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RW_CACHE)
+		seq_puts(s, "singleclient"); /* assume only one client access */
 	else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE)
 		seq_puts(s, "ro"); /* read only caching assumed */
 	else

commit 83bbfa706dda668deb60e96df20327fc79e1716f
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Aug 27 23:58:54 2019 -0500

    smb3: add mount option to allow forced caching of read only share
    
    If a share is immutable (at least for the period that it will
    be mounted) it would be helpful to not have to revalidate
    dentries repeatedly that we know can not be changed remotely.
    
    Add "cache=" option (cache=ro) for mounting read only shares
    in order to improve performance in cases in which we know that
    the share will not be changing while it is in use.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3289b566463f..970251bc0661 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -400,6 +400,8 @@ cifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)
 		seq_puts(s, "strict");
 	else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
 		seq_puts(s, "none");
+	else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RO_CACHE)
+		seq_puts(s, "ro"); /* read only caching assumed */
 	else
 		seq_puts(s, "loose");
 }

commit cb7a69e605908c34aad47644afeb26a765ade8d7
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Fri Mar 22 14:32:35 2019 -0700

    fs: cifs: Initialize filesystem timestamp ranges
    
    Fill in the appropriate limits to avoid inconsistencies
    in the vfs cached inode times when timestamps are
    outside the permitted range.
    
    Also fixed cnvrtDosUnixTm calculations to avoid int overflow
    while computing maximum date.
    
    References:
    
    http://cifs.com/
    
    https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cifs/d416ff7c-c536-406e-a951-4f04b2fd1d2b
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Acked-by: Jeff Layton <jlayton@kernel.org>
    Cc: sfrench@samba.org
    Cc: linux-cifs@vger.kernel.org

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3289b566463f..7a75726442ad 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -56,6 +56,15 @@
 #include "dfs_cache.h"
 #endif
 
+/*
+ * DOS dates from 1980/1/1 through 2107/12/31
+ * Protocol specifications indicate the range should be to 119, which
+ * limits maximum year to 2099. But this range has not been checked.
+ */
+#define SMB_DATE_MAX (127<<9 | 12<<5 | 31)
+#define SMB_DATE_MIN (0<<9 | 1<<5 | 1)
+#define SMB_TIME_MAX (23<<11 | 59<<5 | 29)
+
 int cifsFYI = 0;
 bool traceSMB;
 bool enable_oplocks = true;
@@ -142,6 +151,7 @@ cifs_read_super(struct super_block *sb)
 	struct inode *inode;
 	struct cifs_sb_info *cifs_sb;
 	struct cifs_tcon *tcon;
+	struct timespec64 ts;
 	int rc = 0;
 
 	cifs_sb = CIFS_SB(sb);
@@ -161,6 +171,18 @@ cifs_read_super(struct super_block *sb)
 	/* BB FIXME fix time_gran to be larger for LANMAN sessions */
 	sb->s_time_gran = 100;
 
+	if (tcon->unix_ext) {
+		ts = cifs_NTtimeToUnix(0);
+		sb->s_time_min = ts.tv_sec;
+		ts = cifs_NTtimeToUnix(cpu_to_le64(S64_MAX));
+		sb->s_time_max = ts.tv_sec;
+	} else {
+		ts = cnvrtDosUnixTm(cpu_to_le16(SMB_DATE_MIN), 0, 0);
+		sb->s_time_min = ts.tv_sec;
+		ts = cnvrtDosUnixTm(cpu_to_le16(SMB_DATE_MAX), cpu_to_le16(SMB_TIME_MAX), 0);
+		sb->s_time_max = ts.tv_sec;
+	}
+
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
 	sb->s_xattr = cifs_xattr_handlers;

commit 9a394d1208147715b8a365f44b4e7bfbb2094748
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Aug 15 12:01:12 2019 +0300

    fs: cifs: move from the crypto cipher API to the new DES library interface
    
    Some legacy code in the CIFS driver uses single DES to calculate
    some password hash, and uses the crypto cipher API to do so. Given
    that there is no point in invoking an accelerated cipher for doing
    56-bit symmetric encryption on a single 8-byte block of input, the
    flexibility of the crypto cipher API does not add much value here,
    and so we're much better off using a library call into the generic
    C implementation.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3289b566463f..4e2f74894e9b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1601,7 +1601,6 @@ MODULE_DESCRIPTION
 	("VFS to access SMB3 servers e.g. Samba, Macs, Azure and Windows (and "
 	"also older servers complying with the SNIA CIFS Specification)");
 MODULE_VERSION(CIFS_VERSION);
-MODULE_SOFTDEP("pre: des");
 MODULE_SOFTDEP("pre: ecb");
 MODULE_SOFTDEP("pre: hmac");
 MODULE_SOFTDEP("pre: md4");

commit bf3c90ee1efe4dd3417d2129f9f6c68a4c76de00
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Mon Jun 10 20:36:57 2019 +0300

    cifs: copy_file_range needs to strip setuid bits and update timestamps
    
    cifs has both source and destination inodes locked throughout the copy.
    Like ->write_iter(), we update mtime and strip setuid bits of destination
    file before copy and like ->read_iter(), we update atime of source file
    after copy.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 270d3c58fb3b..3289b566463f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1104,6 +1104,10 @@ ssize_t cifs_file_copychunk_range(unsigned int xid,
 		goto out;
 	}
 
+	rc = -EOPNOTSUPP;
+	if (!target_tcon->ses->server->ops->copychunk_range)
+		goto out;
+
 	/*
 	 * Note: cifs case is easier than btrfs since server responsible for
 	 * checks for proper open modes and file type and if it wants
@@ -1115,11 +1119,12 @@ ssize_t cifs_file_copychunk_range(unsigned int xid,
 	/* should we flush first and last page first */
 	truncate_inode_pages(&target_inode->i_data, 0);
 
-	if (target_tcon->ses->server->ops->copychunk_range)
+	rc = file_modified(dst_file);
+	if (!rc)
 		rc = target_tcon->ses->server->ops->copychunk_range(xid,
 			smb_file_src, smb_file_target, off, len, destoff);
-	else
-		rc = -EOPNOTSUPP;
+
+	file_accessed(src_file);
 
 	/* force revalidate of size and timestamps of target file now
 	 * that target is updated on the server

commit ae9b728c8dc0a9939d89f84e8603258ca2a0df22
Merge: d9b9c893048e e9630660bd92
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 18 11:11:51 2019 -0700

    Merge tag '4.3-rc-smb3-fixes' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull cifs updates from Steve French:
     "Fixes (three for stable) and improvements including much faster
      encryption (SMB3.1.1 GCM)"
    
    * tag '4.3-rc-smb3-fixes' of git://git.samba.org/sfrench/cifs-2.6: (27 commits)
      smb3: smbdirect no longer experimental
      cifs: fix crash in smb2_compound_op()/smb2_set_next_command()
      cifs: fix crash in cifs_dfs_do_automount
      cifs: fix parsing of symbolic link error response
      cifs: refactor and clean up arguments in the reparse point parsing
      SMB3: query inode number on open via create context
      smb3: Send netname context during negotiate protocol
      smb3: do not send compression info by default
      smb3: add new mount option to retrieve mode from special ACE
      smb3: Allow query of symlinks stored as reparse points
      cifs: Fix a race condition with cifs_echo_request
      cifs: always add credits back for unsolicited PDUs
      fs: cifs: cifsssmb: Change return type of convert_ace_to_cifs_ace
      add some missing definitions
      cifs: fix typo in debug message with struct field ia_valid
      smb3: minor cleanup of compound_send_recv
      CIFS: Fix module dependency
      cifs: simplify code by removing CONFIG_CIFS_ACL ifdef
      cifs: Fix check for matching with existing mount
      cifs: Properly handle auto disabling of serverino option
      ...

commit 40f06c799539739a08a56be8a096f56aeed05731
Merge: a47f5c56b2eb fe0da9c09b2d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 20:32:37 2019 -0700

    Merge tag 'copy-file-range-fixes-1' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull copy_file_range updates from Darrick Wong:
     "This fixes numerous parameter checking problems and inconsistent
      behaviors in the new(ish) copy_file_range system call.
    
      Now the system call will actually check its range parameters
      correctly; refuse to copy into files for which the caller does not
      have sufficient privileges; update mtime and strip setuid like file
      writes are supposed to do; and allows copying up to the EOF of the
      source file instead of failing the call like we used to.
    
      Summary:
    
       - Create a generic copy_file_range handler and make individual
         filesystems responsible for calling it (i.e. no more assuming that
         do_splice_direct will work or is appropriate)
    
       - Refactor copy_file_range and remap_range parameter checking where
         they are the same
    
       - Install missing copy_file_range parameter checking(!)
    
       - Remove suid/sgid and update mtime like any other file write
    
       - Change the behavior so that a copy range crossing the source file's
         eof will result in a short copy to the source file's eof instead of
         EINVAL
    
       - Permit filesystems to decide if they want to handle
         cross-superblock copy_file_range in their local handlers"
    
    * tag 'copy-file-range-fixes-1' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      fuse: copy_file_range needs to strip setuid bits and update timestamps
      vfs: allow copy_file_range to copy across devices
      xfs: use file_modified() helper
      vfs: introduce file_modified() helper
      vfs: add missing checks to copy_file_range
      vfs: remove redundant checks from generic_remap_checks()
      vfs: introduce generic_file_rw_checks()
      vfs: no fallback for ->copy_file_range
      vfs: introduce generic_copy_file_range()

commit 4d2fa8b44b891f0da5ceda3e5a1402ccf0ab6f26
Merge: 8b68150883ca f3880a23564e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 20:57:08 2019 -0700

    Merge branch 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto updates from Herbert Xu:
     "Here is the crypto update for 5.3:
    
      API:
       - Test shash interface directly in testmgr
       - cra_driver_name is now mandatory
    
      Algorithms:
       - Replace arc4 crypto_cipher with library helper
       - Implement 5 way interleave for ECB, CBC and CTR on arm64
       - Add xxhash
       - Add continuous self-test on noise source to drbg
       - Update jitter RNG
    
      Drivers:
       - Add support for SHA204A random number generator
       - Add support for 7211 in iproc-rng200
       - Fix fuzz test failures in inside-secure
       - Fix fuzz test failures in talitos
       - Fix fuzz test failures in qat"
    
    * 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (143 commits)
      crypto: stm32/hash - remove interruptible condition for dma
      crypto: stm32/hash - Fix hmac issue more than 256 bytes
      crypto: stm32/crc32 - rename driver file
      crypto: amcc - remove memset after dma_alloc_coherent
      crypto: ccp - Switch to SPDX license identifiers
      crypto: ccp - Validate the the error value used to index error messages
      crypto: doc - Fix formatting of new crypto engine content
      crypto: doc - Add parameter documentation
      crypto: arm64/aes-ce - implement 5 way interleave for ECB, CBC and CTR
      crypto: arm64/aes-ce - add 5 way interleave routines
      crypto: talitos - drop icv_ool
      crypto: talitos - fix hash on SEC1.
      crypto: talitos - move struct talitos_edesc into talitos.h
      lib/scatterlist: Fix mapping iterator when sg->offset is greater than PAGE_SIZE
      crypto/NX: Set receive window credits to max number of CRBs in RxFIFO
      crypto: asymmetric_keys - select CRYPTO_HASH where needed
      crypto: serpent - mark __serpent_setkey_sbox noinline
      crypto: testmgr - dynamically allocate crypto_shash
      crypto: testmgr - dynamically allocate testvec_config
      crypto: talitos - eliminate unneeded 'done' functions at build time
      ...

commit 412094a8fb0711e9f332bed6723aa59706a4ff7e
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Jun 24 02:01:42 2019 -0500

    smb3: add new mount option to retrieve mode from special ACE
    
    There is a special ACE used by some servers to allow the mode
    bits to be stored.  This can be especially helpful in scenarios
    in which the client is trusted, and access checking on the
    client vs the POSIX mode bits is sufficient.
    
    Add mount option to allow enabling this behavior.
    Follow on patch will add support for chmod and queryinfo
    (stat) by retrieving the POSIX mode bits from the special
    ACE, SID: S-1-5-88-3
    
    See e.g.
    https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/hh509017(v=ws.10)
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index dc5fd7a648f0..0ee63ac4ef72 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -526,6 +526,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",nobrl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_HANDLE_CACHE)
 		seq_puts(s, ",nohandlecache");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MODE_FROM_SID)
+		seq_puts(s, ",modefromsid");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)
 		seq_puts(s, ",cifsacl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)

commit 73cf8085dc09442f17f32972d3cdec7232f1be55
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Jun 24 01:44:11 2019 -0500

    cifs: simplify code by removing CONFIG_CIFS_ACL ifdef
    
    SMB3 ACL support is needed for many use cases now and should not be
    ifdeffed out, even for SMB1 (CIFS).  Remove the CONFIG_CIFS_ACL
    ifdef so ACL support is always built into cifs.ko
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 786e07754107..dc5fd7a648f0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1518,11 +1518,9 @@ init_cifs(void)
 		goto out_destroy_dfs_cache;
 #endif /* CONFIG_CIFS_UPCALL */
 
-#ifdef CONFIG_CIFS_ACL
 	rc = init_cifs_idmap();
 	if (rc)
 		goto out_register_key_type;
-#endif /* CONFIG_CIFS_ACL */
 
 	rc = register_filesystem(&cifs_fs_type);
 	if (rc)
@@ -1537,10 +1535,8 @@ init_cifs(void)
 	return 0;
 
 out_init_cifs_idmap:
-#ifdef CONFIG_CIFS_ACL
 	exit_cifs_idmap();
 out_register_key_type:
-#endif
 #ifdef CONFIG_CIFS_UPCALL
 	exit_cifs_spnego();
 out_destroy_dfs_cache:
@@ -1572,9 +1568,7 @@ exit_cifs(void)
 	unregister_filesystem(&cifs_fs_type);
 	unregister_filesystem(&smb3_fs_type);
 	cifs_dfs_release_automount_timer();
-#ifdef CONFIG_CIFS_ACL
 	exit_cifs_idmap();
-#endif
 #ifdef CONFIG_CIFS_UPCALL
 	exit_cifs_spnego();
 #endif

commit dc179268cde43e0fb17e03507f09a3485625e52f
Author: Steve French <stfrench@microsoft.com>
Date:   Mon Jun 17 17:34:57 2019 -0500

    smb3: if max_credits is specified then display it in /proc/mounts
    
    If "max_credits" is overridden from its default by specifying
    it on the smb3 mount then display it in /proc/mounts
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d06edebf3a73..786e07754107 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -554,6 +554,11 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	seq_printf(s, ",bsize=%u", cifs_sb->bsize);
 	seq_printf(s, ",echo_interval=%lu",
 			tcon->ses->server->echo_interval / HZ);
+
+	/* Only display max_credits if it was overridden on mount */
+	if (tcon->ses->server->max_credits != SMB2_MAX_CREDITS_AVAILABLE)
+		seq_printf(s, ",max_credits=%u", tcon->ses->server->max_credits);
+
 	if (tcon->snapshot_time)
 		seq_printf(s, ",snapshot=%llu", tcon->snapshot_time);
 	if (tcon->handle_timeout)

commit 5fc3681fa5ed5cbbe70592967dcfa8f0848f75c0
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Jun 14 21:46:35 2019 +0200

    cifs: add missing GCM module dependency
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 65d9771e49f9..d06edebf3a73 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1604,5 +1604,6 @@ MODULE_SOFTDEP("pre: sha256");
 MODULE_SOFTDEP("pre: sha512");
 MODULE_SOFTDEP("pre: aead2");
 MODULE_SOFTDEP("pre: ccm");
+MODULE_SOFTDEP("pre: gcm");
 module_init(init_cifs)
 module_exit(exit_cifs)

commit 97a5fee2bd70df9e48cdfdbbacc15d45089228a3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jun 12 18:19:59 2019 +0200

    fs: cifs: switch to RC4 library interface
    
    The CIFS code uses the sync skcipher API to invoke the ecb(arc4) skcipher,
    of which only a single generic C code implementation exists. This means
    that going through all the trouble of using scatterlists etc buys us
    very little, and we're better off just invoking the arc4 library directly.
    
    This also reverts commit 5f4b55699aaf ("CIFS: Fix BUG() in calc_seckey()"),
    since it is no longer necessary to allocate sec_key on the heap.
    
    Cc: linux-cifs@vger.kernel.org
    Cc: Steve French <sfrench@samba.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Steve French <stfrench@microsoft.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f5fcd6360056..e55afaf9e5a3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1590,7 +1590,6 @@ MODULE_DESCRIPTION
 	("VFS to access SMB3 servers e.g. Samba, Macs, Azure and Windows (and "
 	"also older servers complying with the SNIA CIFS Specification)");
 MODULE_VERSION(CIFS_VERSION);
-MODULE_SOFTDEP("pre: arc4");
 MODULE_SOFTDEP("pre: des");
 MODULE_SOFTDEP("pre: ecb");
 MODULE_SOFTDEP("pre: hmac");

commit 487317c99477d00f22370625d53be3239febabbe
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed Jun 5 10:38:38 2019 +1000

    cifs: add spinlock for the openFileList to cifsInodeInfo
    
    We can not depend on the tcon->open_file_lock here since in multiuser mode
    we may have the same file/inode open via multiple different tcons.
    
    The current code is race prone and will crash if one user deletes a file
    at the same time a different user opens/create the file.
    
    To avoid this we need to have a spinlock attached to the inode and not the tcon.
    
    RHBZ:  1580165
    
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f5fcd6360056..65d9771e49f9 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -303,6 +303,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->uniqueid = 0;
 	cifs_inode->createtime = 0;
 	cifs_inode->epoch = 0;
+	spin_lock_init(&cifs_inode->open_file_lock);
 	generate_random_uuid(cifs_inode->lease_key);
 
 	/*

commit 5dae222a5ff0c269730393018a5539cc970a4726
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 5 08:04:50 2019 -0700

    vfs: allow copy_file_range to copy across devices
    
    We want to enable cross-filesystem copy_file_range functionality
    where possible, so push the "same superblock only" checks down to
    the individual filesystem callouts so they can make their own
    decisions about cross-superblock copy offload and fallack to
    generic_copy_file_range() for cross-superblock copy.
    
    [Amir] We do not call ->remap_file_range() in case the files are not
    on the same sb and do not call ->copy_file_range() in case the files
    do not belong to the same filesystem driver.
    
    This changes behavior of the copy_file_range(2) syscall, which will
    now allow cross filesystem in-kernel copy.  CIFS already supports
    cross-superblock copy, between two shares to the same server. This
    functionality will now be available via the copy_file_range(2) syscall.
    
    Cc: Steve French <stfrench@microsoft.com>
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c65823270313..f11eea6125c1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1149,7 +1149,7 @@ static ssize_t cifs_copy_file_range(struct file *src_file, loff_t off,
 					len, flags);
 	free_xid(xid);
 
-	if (rc == -EOPNOTSUPP)
+	if (rc == -EOPNOTSUPP || rc == -EXDEV)
 		rc = generic_copy_file_range(src_file, off, dst_file,
 					     destoff, len, flags);
 	return rc;

commit 64bf5ff58dff757253cf2142542672de4b21cd1a
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Jun 5 08:04:47 2019 -0700

    vfs: no fallback for ->copy_file_range
    
    Now that we have generic_copy_file_range(), remove it as a fallback
    case when offloads fail. This puts the responsibility for executing
    fallbacks on the filesystems that implement ->copy_file_range and
    allows us to add operational validity checks to
    generic_copy_file_range().
    
    Rework vfs_copy_file_range() to call a new do_copy_file_range()
    helper to execute the copying callout, and move calls to
    generic_file_copy_range() into filesystem methods where they
    currently return failures.
    
    [Amir] overlayfs is not responsible of executing the fallback.
    It is the responsibility of the underlying filesystem.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f5fcd6360056..c65823270313 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1148,6 +1148,10 @@ static ssize_t cifs_copy_file_range(struct file *src_file, loff_t off,
 	rc = cifs_file_copychunk_range(xid, src_file, off, dst_file, destoff,
 					len, flags);
 	free_xid(xid);
+
+	if (rc == -EOPNOTSUPP)
+		rc = generic_copy_file_range(src_file, off, dst_file,
+					     destoff, len, flags);
 	return rc;
 }
 

commit dece44e381ab4a9fd1021db45ba4472e8c85becb
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed May 15 07:17:02 2019 +1000

    cifs: add support for SEEK_DATA and SEEK_HOLE
    
    Add llseek op for SEEK_DATA and SEEK_HOLE.
    Improves xfstests/285,286,436,445,448 and 490
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d0cb042732cb..f5fcd6360056 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -878,6 +878,9 @@ static ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 
 static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)
 {
+	struct cifsFileInfo *cfile = file->private_data;
+	struct cifs_tcon *tcon;
+
 	/*
 	 * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate
 	 * the cached file length
@@ -909,6 +912,12 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)
 		if (rc < 0)
 			return (loff_t)rc;
 	}
+	if (cfile && cfile->tlink) {
+		tcon = tlink_tcon(cfile->tlink);
+		if (tcon->ses->server->ops->llseek)
+			return tcon->ses->server->ops->llseek(file, tcon,
+							      offset, whence);
+	}
 	return generic_file_llseek(file, offset, whence);
 }
 

commit 9ab70ca653307771589e1414102c552d8dbdbbef
Author: Kovtunenko Oleksandr <alexander198961@gmail.com>
Date:   Tue May 14 05:52:34 2019 +0000

    Fixed https://bugzilla.kernel.org/show_bug.cgi?id=202935 allow write on the same file
    
    Copychunk allows source and target to be on the same file.
    For details on restrictions see MS-SMB2 3.3.5.15.6
    
    Signed-off-by: Kovtunenko Oleksandr <alexander198961@gmail.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b1a5fcfa3ce1..d0cb042732cb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1070,11 +1070,6 @@ ssize_t cifs_file_copychunk_range(unsigned int xid,
 
 	cifs_dbg(FYI, "copychunk range\n");
 
-	if (src_inode == target_inode) {
-		rc = -EINVAL;
-		goto out;
-	}
-
 	if (!src_file->private_data || !dst_file->private_data) {
 		rc = -EBADF;
 		cifs_dbg(VFS, "missing cifsFileInfo on copy range src file\n");

commit 2f3ebaba13cebd8badfb9aed31c0cf3cc82eb4f4
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Thu Apr 25 16:45:29 2019 +1000

    cifs: add fiemap support
    
    Useful for improved copy performance as well as for
    applications which query allocated ranges of sparse
    files.
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 54c065ada4de..b1a5fcfa3ce1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -986,6 +986,7 @@ const struct inode_operations cifs_file_inode_ops = {
 	.getattr = cifs_getattr,
 	.permission = cifs_permission,
 	.listxattr = cifs_listxattr,
+	.fiemap = cifs_fiemap,
 };
 
 const struct inode_operations cifs_symlink_inode_ops = {

commit c8b6ac1a9d1fb26adaeaafc3fb872e6713dfeaf7
Author: Kenneth D'souza <kdsouza@redhat.com>
Date:   Mon Jan 21 11:51:59 2019 +1000

    CIFS: Show locallease in /proc/mounts for cifs shares mounted with locallease feature.
    
    Missing parameter that should be displayed in the mount list
    
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Kenneth D'souza <kdsouza@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 877174761efb..54c065ada4de 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -483,6 +483,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",seal");
 	if (tcon->nocase)
 		seq_puts(s, ",nocase");
+	if (tcon->local_lease)
+		seq_puts(s, ",locallease");
 	if (tcon->retry)
 		seq_puts(s, ",hard");
 	else

commit c2e6802e7b5aec2ac28075300dd5a849a6115ad6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Apr 14 23:18:35 2019 -0400

    cifs: switch to ->free_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a05bf1d6e1d0..877174761efb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -315,16 +315,10 @@ cifs_alloc_inode(struct super_block *sb)
 	return &cifs_inode->vfs_inode;
 }
 
-static void cifs_i_callback(struct rcu_head *head)
-{
-	struct inode *inode = container_of(head, struct inode, i_rcu);
-	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
-}
-
 static void
-cifs_destroy_inode(struct inode *inode)
+cifs_free_inode(struct inode *inode)
 {
-	call_rcu(&inode->i_rcu, cifs_i_callback);
+	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
 }
 
 static void
@@ -630,7 +624,7 @@ static int cifs_drop_inode(struct inode *inode)
 static const struct super_operations cifs_super_ops = {
 	.statfs = cifs_statfs,
 	.alloc_inode = cifs_alloc_inode,
-	.destroy_inode = cifs_destroy_inode,
+	.free_inode = cifs_free_inode,
 	.drop_inode	= cifs_drop_inode,
 	.evict_inode	= cifs_evict_inode,
 /*	.delete_inode	= cifs_delete_inode,  */  /* Do not need above

commit ca567eb2b3f014d5be0f44c6f68b01a522f15ca4
Author: Steve French <stfrench@microsoft.com>
Date:   Fri Mar 29 16:31:07 2019 -0500

    SMB3: Allow persistent handle timeout to be configurable on mount
    
    Reconnecting after server or network failure can be improved
    (to maintain availability and protect data integrity) by allowing
    the client to choose the default persistent (or resilient)
    handle timeout in some use cases.  Today we default to 0 which lets
    the server pick the default timeout (usually 120 seconds) but this
    can be problematic for some workloads.  Add the new mount parameter
    to cifs.ko for SMB3 mounts "handletimeout" which enables the user
    to override the default handle timeout for persistent (mount
    option "persistenthandles") or resilient handles (mount option
    "resilienthandles").  Maximum allowed is 16 minutes (960000 ms).
    Units for the timeout are expressed in milliseconds. See
    section 2.2.14.2.12 and 2.2.31.3 of the MS-SMB2 protocol
    specification for more information.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f9b71c12cc9f..a05bf1d6e1d0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -559,6 +559,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 			tcon->ses->server->echo_interval / HZ);
 	if (tcon->snapshot_time)
 		seq_printf(s, ",snapshot=%llu", tcon->snapshot_time);
+	if (tcon->handle_timeout)
+		seq_printf(s, ",handletimeout=%u", tcon->handle_timeout);
 	/* convert actimeo and display it in seconds */
 	seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
 

commit b073a08016a10f01dfb0d0b6c7fa89da0d544963
Author: Xiaoli Feng <fengxiaoli0714@gmail.com>
Date:   Sat Mar 16 12:11:54 2019 +0800

    cifs: fix that return -EINVAL when do dedupe operation
    
    dedupe_file_range operations is combiled into remap_file_range.
    But it's always skipped for dedupe operations in function
    cifs_remap_file_range.
    
    Example to test:
    Before this patch:
      # dd if=/dev/zero of=cifs/file bs=1M count=1
      # xfs_io -c "dedupe cifs/file 4k 64k 4k" cifs/file
      XFS_IOC_FILE_EXTENT_SAME: Invalid argument
    
    After this patch:
      # dd if=/dev/zero of=cifs/file bs=1M count=1
      # xfs_io -c "dedupe cifs/file 4k 64k 4k" cifs/file
      XFS_IOC_FILE_EXTENT_SAME: Operation not supported
    
    Influence for xfstests:
    generic/091
    generic/112
    generic/127
    generic/263
    These tests report this error "do_copy_range:: Invalid
    argument" instead of "FIDEDUPERANGE: Invalid argument".
    Because there are still two bugs cause these test failed.
    https://bugzilla.kernel.org/show_bug.cgi?id=202935
    https://bugzilla.kernel.org/show_bug.cgi?id=202785
    
    Signed-off-by: Xiaoli Feng <fengxiaoli0714@gmail.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 217276b8b942..f9b71c12cc9f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1008,7 +1008,7 @@ static loff_t cifs_remap_file_range(struct file *src_file, loff_t off,
 	unsigned int xid;
 	int rc;
 
-	if (remap_flags & ~REMAP_FILE_ADVISORY)
+	if (remap_flags & ~(REMAP_FILE_DEDUP | REMAP_FILE_ADVISORY))
 		return -EINVAL;
 
 	cifs_dbg(FYI, "clone range\n");

commit 96281b9e46ebb90cefa8b57b11ca40e5ac05f649
Author: Steve French <stfrench@microsoft.com>
Date:   Sat Mar 2 06:56:54 2019 -0600

    smb3: for kerberos mounts display the credential uid used
    
    For kerberos mounts, the cruid is helpful to display in
    /proc/mounts in order to tell which uid's krb5 cache we
    got the ticket for and to tell in the multiuser krb5 case
    which local users (uids) we have Kerberos authentic sessions
    for.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f2c0d863fb52..217276b8b942 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -381,7 +381,7 @@ cifs_show_security(struct seq_file *s, struct cifs_ses *ses)
 		seq_puts(s, "ntlm");
 		break;
 	case Kerberos:
-		seq_puts(s, "krb5");
+		seq_printf(s, "krb5,cruid=%u", from_kuid_munged(&init_user_ns,ses->cred_uid));
 		break;
 	case RawNTLMSSP:
 		seq_puts(s, "ntlmssp");

commit e8506d25f740fd058791cc12a6dfa9386ada6b96
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Feb 28 21:32:15 2019 -0600

    smb3: make default i/o size for smb3 mounts larger
    
    We negotiate rsize mounts (and it can be overridden by user) to
    typically 4MB, so using larger default I/O sizes from userspace
    (changing to 1MB default i/o size returned by stat) the
    performance is much better (and not just for long latency
    network connections) in most use cases for SMB3 than the default I/O
    size (which ends up being 128K for cp and can be even smaller for cp).
    This can be 4x slower or worse depending on network latency.
    
    By changing inode->blocksize from 32K (which was perhaps ok
    for very old SMB1/CIFS) to a larger value, 1MB (but still less than
    max size negotiated with the server which is 4MB, in order to minimize
    risk) it significantly increases performance for the
    noncached case, and slightly increases it for the cached case.
    This can be changed by the user on mount (specifying bsize=
    values from 16K to 16MB) to tune better for performance
    for applications that depend on blocksize.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 62d48d486d8f..f2c0d863fb52 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -554,6 +554,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 
 	seq_printf(s, ",rsize=%u", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%u", cifs_sb->wsize);
+	seq_printf(s, ",bsize=%u", cifs_sb->bsize);
 	seq_printf(s, ",echo_interval=%lu",
 			tcon->ses->server->echo_interval / HZ);
 	if (tcon->snapshot_time)

commit 1c780228e9d47b966983a8bbf475dd45967bf0d5
Author: Paulo Alcantara <palcantara@suse.de>
Date:   Wed Nov 14 16:24:03 2018 -0200

    cifs: Make use of DFS cache to get new DFS referrals
    
    This patch will make use of DFS cache routines where appropriate and
    do not always request a new referral from server.
    
    Signed-off-by: Paulo Alcantara <palcantara@suse.de>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 865706edb307..62d48d486d8f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -52,6 +52,9 @@
 #include "cifs_spnego.h"
 #include "fscache.h"
 #include "smb2pdu.h"
+#ifdef CONFIG_CIFS_DFS_UPCALL
+#include "dfs_cache.h"
+#endif
 
 int cifsFYI = 0;
 bool traceSMB;
@@ -1494,10 +1497,15 @@ init_cifs(void)
 	if (rc)
 		goto out_destroy_mids;
 
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	rc = dfs_cache_init();
+	if (rc)
+		goto out_destroy_request_bufs;
+#endif /* CONFIG_CIFS_DFS_UPCALL */
 #ifdef CONFIG_CIFS_UPCALL
 	rc = init_cifs_spnego();
 	if (rc)
-		goto out_destroy_request_bufs;
+		goto out_destroy_dfs_cache;
 #endif /* CONFIG_CIFS_UPCALL */
 
 #ifdef CONFIG_CIFS_ACL
@@ -1525,6 +1533,10 @@ init_cifs(void)
 #endif
 #ifdef CONFIG_CIFS_UPCALL
 	exit_cifs_spnego();
+out_destroy_dfs_cache:
+#endif
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	dfs_cache_destroy();
 out_destroy_request_bufs:
 #endif
 	cifs_destroy_request_bufs();
@@ -1555,6 +1567,9 @@ exit_cifs(void)
 #endif
 #ifdef CONFIG_CIFS_UPCALL
 	exit_cifs_spnego();
+#endif
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	dfs_cache_destroy();
 #endif
 	cifs_destroy_request_bufs();
 	cifs_destroy_mids();

commit 8c6c9bed8773375b1d54ccca2911ec892c59db5d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Nov 1 13:14:30 2018 +0000

    cifs: don't dereference smb_file_target before null check
    
    There is a null check on dst_file->private data which suggests
    it can be potentially null. However, before this check, pointer
    smb_file_target is derived from dst_file->private and dereferenced
    in the call to tlink_tcon, hence there is a potential null pointer
    deference.
    
    Fix this by assigning smb_file_target and target_tcon after the
    null pointer sanity checks.
    
    Detected by CoverityScan, CID#1475302 ("Dereference before null check")
    
    Fixes: 04b38d601239 ("vfs: pull btrfs clone API to vfs layer")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1b21262ec874..865706edb307 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -999,8 +999,8 @@ static loff_t cifs_remap_file_range(struct file *src_file, loff_t off,
 	struct inode *src_inode = file_inode(src_file);
 	struct inode *target_inode = file_inode(dst_file);
 	struct cifsFileInfo *smb_file_src = src_file->private_data;
-	struct cifsFileInfo *smb_file_target = dst_file->private_data;
-	struct cifs_tcon *target_tcon = tlink_tcon(smb_file_target->tlink);
+	struct cifsFileInfo *smb_file_target;
+	struct cifs_tcon *target_tcon;
 	unsigned int xid;
 	int rc;
 
@@ -1017,6 +1017,9 @@ static loff_t cifs_remap_file_range(struct file *src_file, loff_t off,
 		goto out;
 	}
 
+	smb_file_target = dst_file->private_data;
+	target_tcon = tlink_tcon(smb_file_target->tlink);
+
 	/*
 	 * Note: cifs case is easier than btrfs since server responsible for
 	 * checks for proper open modes and file type and if it wants

commit be4eb68846dc4450a9a4998d7c16d9f4955f9988
Author: Long Li <longli@microsoft.com>
Date:   Wed Oct 31 22:13:11 2018 +0000

    CIFS: Add direct I/O functions to file_operations
    
    With direct read/write functions implemented, add them to file_operations.
    
    Dircet I/O is used under two conditions:
    1. When mounting with "cache=none", CIFS uses direct I/O for all user file
    data transfer.
    2. When opening a file with O_DIRECT, CIFS uses direct I/O for all data
    transfer on this file.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b7ac09e38159..1b21262ec874 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1180,9 +1180,8 @@ const struct file_operations cifs_file_strict_ops = {
 };
 
 const struct file_operations cifs_file_direct_ops = {
-	/* BB reevaluate whether they can be done with directio, no cache */
-	.read_iter = cifs_user_readv,
-	.write_iter = cifs_user_writev,
+	.read_iter = cifs_direct_readv,
+	.write_iter = cifs_direct_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
@@ -1236,9 +1235,8 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 };
 
 const struct file_operations cifs_file_direct_nobrl_ops = {
-	/* BB reevaluate whether they can be done with directio, no cache */
-	.read_iter = cifs_user_readv,
-	.write_iter = cifs_user_writev,
+	.read_iter = cifs_direct_readv,
+	.write_iter = cifs_direct_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.fsync = cifs_fsync,

commit c2aa1a444cab2c673650ada80a7dffc4345ce2e6
Merge: b69f9e17a57a bf4a1fcf0bc1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 2 09:33:08 2018 -0700

    Merge tag 'xfs-4.20-merge-2' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull vfs dedup fixes from Dave Chinner:
     "This reworks the vfs data cloning infrastructure.
    
      We discovered many issues with these interfaces late in the 4.19 cycle
      - the worst of them (data corruption, setuid stripping) were fixed for
      XFS in 4.19-rc8, but a larger rework of the infrastructure fixing all
      the problems was needed. That rework is the contents of this pull
      request.
    
      Rework the vfs_clone_file_range and vfs_dedupe_file_range
      infrastructure to use a common .remap_file_range method and supply
      generic bounds and sanity checking functions that are shared with the
      data write path. The current VFS infrastructure has problems with
      rlimit, LFS file sizes, file time stamps, maximum filesystem file
      sizes, stripping setuid bits, etc and so they are addressed in these
      commits.
    
      We also introduce the ability for the ->remap_file_range methods to
      return short clones so that clones for vfs_copy_file_range() don't get
      rejected if the entire range can't be cloned. It also allows
      filesystems to sliently skip deduplication of partial EOF blocks if
      they are not capable of doing so without requiring errors to be thrown
      to userspace.
    
      Existing filesystems are converted to user the new remap_file_range
      method, and both XFS and ocfs2 are modified to make use of the new
      generic checking infrastructure"
    
    * tag 'xfs-4.20-merge-2' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux: (28 commits)
      xfs: remove [cm]time update from reflink calls
      xfs: remove xfs_reflink_remap_range
      xfs: remove redundant remap partial EOF block checks
      xfs: support returning partial reflink results
      xfs: clean up xfs_reflink_remap_blocks call site
      xfs: fix pagecache truncation prior to reflink
      ocfs2: remove ocfs2_reflink_remap_range
      ocfs2: support partial clone range and dedupe range
      ocfs2: fix pagecache truncation prior to reflink
      ocfs2: truncate page cache for clone destination file before remapping
      vfs: clean up generic_remap_file_range_prep return value
      vfs: hide file range comparison function
      vfs: enable remap callers that can handle short operations
      vfs: plumb remap flags through the vfs dedupe functions
      vfs: plumb remap flags through the vfs clone functions
      vfs: make remap_file_range functions take and return bytes completed
      vfs: remap helper should update destination inode metadata
      vfs: pass remap flags to generic_remap_checks
      vfs: pass remap flags to generic_remap_file_range_prep
      vfs: combine the clone and dedupe into a single remap_file_range
      ...

commit 42ec3d4c02187a18e27ff94b409ec27234bf2ffd
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:41:49 2018 +1100

    vfs: make remap_file_range functions take and return bytes completed
    
    Change the remap_file_range functions to take a number of bytes to
    operate upon and return the number of bytes they operated on.  This is a
    requirement for allowing fs implementations to return short clone/dedupe
    results to the user, which will enable us to obey resource limits in a
    graceful manner.
    
    A subsequent patch will enable copy_file_range to signal to the
    ->clone_file_range implementation that it can handle a short length,
    which will be returned in the function's return value.  For now the
    short return is not implemented anywhere so the behavior won't change --
    either copy_file_range manages to clone the entire range or it tries an
    alternative.
    
    Neither clone ioctl can take advantage of this, alas.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e8144d0dcde2..5ca71c6c8be2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -975,8 +975,8 @@ const struct inode_operations cifs_symlink_inode_ops = {
 	.listxattr = cifs_listxattr,
 };
 
-static int cifs_remap_file_range(struct file *src_file, loff_t off,
-		struct file *dst_file, loff_t destoff, u64 len,
+static loff_t cifs_remap_file_range(struct file *src_file, loff_t off,
+		struct file *dst_file, loff_t destoff, loff_t len,
 		unsigned int remap_flags)
 {
 	struct inode *src_inode = file_inode(src_file);
@@ -1029,7 +1029,7 @@ static int cifs_remap_file_range(struct file *src_file, loff_t off,
 	unlock_two_nondirectories(src_inode, target_inode);
 out:
 	free_xid(xid);
-	return rc;
+	return rc < 0 ? rc : len;
 }
 
 ssize_t cifs_file_copychunk_range(unsigned int xid,

commit 2e5dfc99f2e61c42083ba742395e7a7b353513d1
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:41:21 2018 +1100

    vfs: combine the clone and dedupe into a single remap_file_range
    
    Combine the clone_file_range and dedupe_file_range operations into a
    single remap_file_range file operation dispatch since they're
    fundamentally the same operation.  The differences between the two can
    be made in the prep functions.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7065426b3280..e8144d0dcde2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -975,8 +975,9 @@ const struct inode_operations cifs_symlink_inode_ops = {
 	.listxattr = cifs_listxattr,
 };
 
-static int cifs_clone_file_range(struct file *src_file, loff_t off,
-		struct file *dst_file, loff_t destoff, u64 len)
+static int cifs_remap_file_range(struct file *src_file, loff_t off,
+		struct file *dst_file, loff_t destoff, u64 len,
+		unsigned int remap_flags)
 {
 	struct inode *src_inode = file_inode(src_file);
 	struct inode *target_inode = file_inode(dst_file);
@@ -986,6 +987,9 @@ static int cifs_clone_file_range(struct file *src_file, loff_t off,
 	unsigned int xid;
 	int rc;
 
+	if (remap_flags & ~REMAP_FILE_ADVISORY)
+		return -EINVAL;
+
 	cifs_dbg(FYI, "clone range\n");
 
 	xid = get_xid();
@@ -1134,7 +1138,7 @@ const struct file_operations cifs_file_ops = {
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
-	.clone_file_range = cifs_clone_file_range,
+	.remap_file_range = cifs_remap_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -1153,7 +1157,7 @@ const struct file_operations cifs_file_strict_ops = {
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
-	.clone_file_range = cifs_clone_file_range,
+	.remap_file_range = cifs_remap_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -1172,7 +1176,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.splice_write = iter_file_splice_write,
 	.unlocked_ioctl  = cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
-	.clone_file_range = cifs_clone_file_range,
+	.remap_file_range = cifs_remap_file_range,
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -1191,7 +1195,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
-	.clone_file_range = cifs_clone_file_range,
+	.remap_file_range = cifs_remap_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -1209,7 +1213,7 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
-	.clone_file_range = cifs_clone_file_range,
+	.remap_file_range = cifs_remap_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -1227,7 +1231,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.splice_write = iter_file_splice_write,
 	.unlocked_ioctl  = cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
-	.clone_file_range = cifs_clone_file_range,
+	.remap_file_range = cifs_remap_file_range,
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -1239,7 +1243,7 @@ const struct file_operations cifs_dir_ops = {
 	.read    = generic_read_dir,
 	.unlocked_ioctl  = cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
-	.clone_file_range = cifs_clone_file_range,
+	.remap_file_range = cifs_remap_file_range,
 	.llseek = generic_file_llseek,
 	.fsync = cifs_dir_fsync,
 };

commit 8c1beb9801293b175cfa0341e5df89581a87dc02
Author: Steve French <stfrench@microsoft.com>
Date:   Sun Oct 7 13:52:18 2018 -0500

    cifs: minor clarification in comments
    
    Clarify meaning (in comments) meaning of various
    options for debug messages in cifs.ko. Also fixed
    trivial formatting/style issue with previous patch.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d78a31560995..7de9603c54f1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -717,8 +717,10 @@ cifs_smb3_do_mount(struct file_system_type *fs_type,
 	struct cifs_mnt_data mnt_data;
 	struct dentry *root;
 
-	/* Prints in Kernel / CIFS log the attempted mount operation *
-	 *	IF CIFS_DEBUG && cifs_FYI */
+	/*
+	 * Prints in Kernel / CIFS log the attempted mount operation
+	 *	If CIFS_DEBUG && cifs_FYI
+	 */
 	if (cifsFYI)
 		cifs_dbg(FYI, "Devname: %s flags: %d\n", dev_name, flags);
 	else

commit f80eaedd6c5978fdd31549446cfa4a7212522b8d
Author: Rodrigo Freire <rfreire@redhat.com>
Date:   Sun Oct 7 12:21:26 2018 -0300

    CIFS: Print message when attempting a mount
    
    Currently, no messages are printed when mounting a CIFS filesystem and
    no debug configuration is enabled.
    
    However, a CIFS mount information is valuable when troubleshooting
    and/or forensic analyzing a system and finding out if was a CIFS
    endpoint mount attempted.
    
    Other filesystems such as XFS, EXT* does issue a printk() when mounting
    their filesystems.
    
    A terse log message is printed only if cifsFYI is not enabled. Otherwise,
    the default full debug message is printed.
    
    In order to not clutter and classify correctly the event messages, these
    are logged as KERN_INFO level.
    
    Sample mount operations:
    
    [root@corinthians ~]# mount -o user=administrator //172.25.250.18/c$ /mnt
    (non-existent system)
    
    [root@corinthians ~]# mount -o user=administrator //172.25.250.19/c$ /mnt
    (Valid system)
    
    Kernel message log for the mount operations:
    
    [  450.464543] CIFS: Attempting to mount //172.25.250.18/c$
    [  456.478186] CIFS VFS: Error connecting to socket. Aborting operation.
    [  456.478381] CIFS VFS: cifs_mount failed w/return code = -113
    [  467.688866] CIFS: Attempting to mount //172.25.250.19/c$
    
    Signed-off-by: Rodrigo Freire <rfreire@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d2f9bc48ffac..d78a31560995 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -717,7 +717,12 @@ cifs_smb3_do_mount(struct file_system_type *fs_type,
 	struct cifs_mnt_data mnt_data;
 	struct dentry *root;
 
-	cifs_dbg(FYI, "Devname: %s flags: %d\n", dev_name, flags);
+	/* Prints in Kernel / CIFS log the attempted mount operation *
+	 *	IF CIFS_DEBUG && cifs_FYI */
+	if (cifsFYI)
+		cifs_dbg(FYI, "Devname: %s flags: %d\n", dev_name, flags);
+	else
+		cifs_info("Attempting to mount %s\n", dev_name);
 
 	volume_info = cifs_get_volume_info((char *)data, dev_name, is_smb3);
 	if (IS_ERR(volume_info))

commit 8393072bab060f0a05888ee31543175d44b5dde0
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Thu Sep 20 18:10:25 2018 -0700

    CIFS: make 'nodfs' mount opt a superblock flag
    
    tcon->Flags is only used by SMB1 code and changing it is not permanent
    (you lose the setting on tcon reconnect).
    
    * Move the setting to superblock flags (per mount-points).
    * Make automount callback exit early when flag present
    * Make dfs resolving happening in mount syscall exit early if flag present
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ba0054604f85..d2f9bc48ffac 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -500,6 +500,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",unix");
 	else
 		seq_puts(s, ",nounix");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS)
+		seq_puts(s, ",nodfs");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 		seq_puts(s, ",posixpaths");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)

commit 00778e2294d560361e2ed4e94cc003351a2d82d9
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Sep 18 14:05:18 2018 -0500

    smb3: add way to control slow response threshold for logging and stats
    
    /proc/fs/cifs/Stats when CONFIG_CIFS_STATS2 is enabled logs 'slow'
    responses, but depending on the server you are debugging a
    one second timeout may be too fast, so allow setting it to
    a larger number of seconds via new module parameter
    
    /sys/module/cifs/parameters/slow_rsp_threshold
    
    or via modprobe:
    
    slow_rsp_threshold:Amount of time (in seconds) to wait before
    logging that a response is delayed.
    Default: 1 (if set to 0 disables msg). (uint)
    
    Recommended values are 0 (disabled) to 32767 (9 hours) with
    the default remaining as 1 second.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index af6c2e1795ef..ba0054604f85 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -81,6 +81,14 @@ module_param(cifs_max_pending, uint, 0444);
 MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server for "
 				   "CIFS/SMB1 dialect (N/A for SMB3) "
 				   "Default: 32767 Range: 2 to 32767.");
+#ifdef CONFIG_CIFS_STATS2
+unsigned int slow_rsp_threshold = 1;
+module_param(slow_rsp_threshold, uint, 0644);
+MODULE_PARM_DESC(slow_rsp_threshold, "Amount of time (in seconds) to wait "
+				   "before logging that a response is delayed. "
+				   "Default: 1 (if set to 0 disables msg).");
+#endif /* STATS2 */
+
 module_param(enable_oplocks, bool, 0644);
 MODULE_PARM_DESC(enable_oplocks, "Enable or disable oplocks. Default: y/Y/1");
 
@@ -1418,6 +1426,11 @@ init_cifs(void)
 #ifdef CONFIG_CIFS_STATS2
 	atomic_set(&totBufAllocCount, 0);
 	atomic_set(&totSmBufAllocCount, 0);
+	if (slow_rsp_threshold < 1)
+		cifs_dbg(FYI, "slow_response_threshold msgs disabled\n");
+	else if (slow_rsp_threshold > 32767)
+		cifs_dbg(VFS,
+		       "slow response threshold set higher than recommended (0 to 32767)\n");
 #endif /* CONFIG_CIFS_STATS2 */
 
 	atomic_set(&midCount, 0);

commit 1c3a13a38a28c6ed84ff9220c1b8dadf5fbcf8a5
Author: Steve French <stfrench@microsoft.com>
Date:   Tue Sep 18 04:07:45 2018 -0500

    cifs: minor updates to module description for cifs.ko
    
    note smb3 (and common more modern servers) in the module description
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7065426b3280..af6c2e1795ef 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1538,11 +1538,11 @@ exit_cifs(void)
 	cifs_proc_clean();
 }
 
-MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");
+MODULE_AUTHOR("Steve French");
 MODULE_LICENSE("GPL");	/* combination of LGPL + GPL source behaves as GPL */
 MODULE_DESCRIPTION
-    ("VFS to access servers complying with the SNIA CIFS Specification "
-     "e.g. Samba and Windows");
+	("VFS to access SMB3 servers e.g. Samba, Macs, Azure and Windows (and "
+	"also older servers complying with the SNIA CIFS Specification)");
 MODULE_VERSION(CIFS_VERSION);
 MODULE_SOFTDEP("pre: arc4");
 MODULE_SOFTDEP("pre: des");

commit e55954a5f7ce0e321cea9f91f4ebeb2a4e0165f4
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Fri Aug 10 11:31:10 2018 +1000

    cifs: don't show domain= in mount output when domain is empty
    
    Reported-by: Xiaoli Feng <xifeng@redhat.com>
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index de16078e456b..7065426b3280 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -432,7 +432,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	else if (tcon->ses->user_name)
 		seq_show_option(s, "username", tcon->ses->user_name);
 
-	if (tcon->ses->domainName)
+	if (tcon->ses->domainName && tcon->ses->domainName[0] != 0)
 		seq_show_option(s, "domain", tcon->ses->domainName);
 
 	if (srcaddr->sa_family != AF_UNSPEC) {

commit 8a69e96e610b3ec8a55f6fd4e44363452838caa7
Author: Steve French <stfrench@microsoft.com>
Date:   Fri Jun 29 16:06:15 2018 -0500

    smb3: snapshot mounts are read-only and make sure info is displayable about the mount
    
    snapshot mounts were not marked as read-only and did not display the snapshot
    time (in /proc/mounts) specified on mount
    
    With this patch - note that can not write to the snapshot mount (see "ro" in
    /proc/mounts line) and also the missing snapshot timewarp token time is
    dumped.  Sample line from /proc/mounts with the patch:
    
    //127.0.0.1/scratch /mnt2 smb3 ro,relatime,vers=default,cache=strict,username=testuser,domain=,uid=0,noforceuid,gid=0,noforcegid,addr=127.0.0.1,file_mode=0755,dir_mode=0755,soft,nounix,serverino,mapposix,noperm,rsize=1048576,wsize=1048576,echo_interval=60,snapshot=1234567,actimeo=1 0 0
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Paulo Alcantara <palcantara@suse.de>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c162a416ddbf..de16078e456b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -139,6 +139,9 @@ cifs_read_super(struct super_block *sb)
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)
 		sb->s_flags |= SB_POSIXACL;
 
+	if (tcon->snapshot_time)
+		sb->s_flags |= SB_RDONLY;
+
 	if (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)
 		sb->s_maxbytes = MAX_LFS_FILESIZE;
 	else
@@ -540,6 +543,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	seq_printf(s, ",wsize=%u", cifs_sb->wsize);
 	seq_printf(s, ",echo_interval=%lu",
 			tcon->ses->server->echo_interval / HZ);
+	if (tcon->snapshot_time)
+		seq_printf(s, ",snapshot=%llu", tcon->snapshot_time);
 	/* convert actimeo and display it in seconds */
 	seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
 

commit 0fdfef9aa7ee68ddd508aef7c98630cfc054f8d6
Author: Steve French <stfrench@microsoft.com>
Date:   Thu Jun 28 19:30:23 2018 -0500

    smb3: simplify code by removing CONFIG_CIFS_SMB311
    
    We really, really want to be encouraging use of secure dialects,
    and SMB3.1.1 offers useful security features, and will soon
    be the recommended dialect for many use cases. Simplify the code
    by removing the CONFIG_CIFS_SMB311 ifdef so users don't disable
    it in the build, and create compatibility and/or security issues
    with modern servers - many of which have been supporting this
    dialect for multiple years.
    
    Also clarify some of the Kconfig text for cifs.ko about
    SMB3.1.1 and current supported features in the module.
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 69ec5427769c..c162a416ddbf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -483,20 +483,12 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",persistenthandles");
 	else if (tcon->use_resilient)
 		seq_puts(s, ",resilienthandles");
-
-#ifdef CONFIG_CIFS_SMB311
 	if (tcon->posix_extensions)
 		seq_puts(s, ",posix");
 	else if (tcon->unix_ext)
 		seq_puts(s, ",unix");
 	else
 		seq_puts(s, ",nounix");
-#else
-	if (tcon->unix_ext)
-		seq_puts(s, ",unix");
-	else
-		seq_puts(s, ",nounix");
-#endif /* SMB311 */
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 		seq_puts(s, ",posixpaths");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)

commit 21ba3845b59c733a79ed4fe1c4f3732e7ece9df7
Author: Steve French <stfrench@microsoft.com>
Date:   Sun Jun 24 23:18:52 2018 -0500

    smb3: fill in statfs fsid and correct namelen
    
    Fil in the correct namelen (typically 255 not 4096) in the
    statfs response and also fill in a reasonably unique fsid
    (in this case taken from the volume id, and the creation time
    of the volume).
    
    In the case of the POSIX statfs all fields are now filled in,
    and in the case of non-POSIX mounts, all fields are filled
    in which can be.
    
    Signed-off-by: Steve French <stfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d5aa7ae917bf..69ec5427769c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -209,14 +209,16 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 	xid = get_xid();
 
-	/*
-	 * PATH_MAX may be too long - it would presumably be total path,
-	 * but note that some servers (includinng Samba 3) have a shorter
-	 * maximum path.
-	 *
-	 * Instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO.
-	 */
-	buf->f_namelen = PATH_MAX;
+	if (le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength) > 0)
+		buf->f_namelen =
+		       le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength);
+	else
+		buf->f_namelen = PATH_MAX;
+
+	buf->f_fsid.val[0] = tcon->vol_serial_number;
+	/* are using part of create time for more randomness, see man statfs */
+	buf->f_fsid.val[1] =  (int)le64_to_cpu(tcon->vol_create_time);
+
 	buf->f_files = 0;	/* undefined */
 	buf->f_ffree = 0;	/* unlimited */
 

commit c7c137b931b6894531003b5de888ad012dc37ba6
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Jun 6 17:59:29 2018 -0500

    smb3: do not allow insecure cifs mounts when using smb3
    
    if mounting as smb3 do not allow cifs (vers=1.0) or insecure vers=2.0
    mounts.
    
    For example:
    root@smf-Thinkpad-P51:~/cifs-2.6# mount -t smb3 //127.0.0.1/scratch /mnt -o username=testuser,password=Testpass1
    root@smf-Thinkpad-P51:~/cifs-2.6# umount /mnt
    root@smf-Thinkpad-P51:~/cifs-2.6# mount -t smb3 //127.0.0.1/scratch /mnt -o username=testuser,password=Testpass1,vers=1.0
    mount: /mnt: wrong fs type, bad option, bad superblock on //127.0.0.1/scratch ...
    root@smf-Thinkpad-P51:~/cifs-2.6# dmesg | grep smb3
    [ 4302.200122] CIFS VFS: vers=1.0 (cifs) not permitted when mounting with smb3
    root@smf-Thinkpad-P51:~/cifs-2.6# mount -t smb3 //127.0.0.1/scratch /mnt -o username=testuser,password=Testpass1,vers=3.11
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Acked-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Sachin Prabhu <sprabhu@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index eb7b6573f322..d5aa7ae917bf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -698,8 +698,8 @@ static int cifs_set_super(struct super_block *sb, void *data)
 }
 
 static struct dentry *
-cifs_do_mount(struct file_system_type *fs_type,
-	      int flags, const char *dev_name, void *data)
+cifs_smb3_do_mount(struct file_system_type *fs_type,
+	      int flags, const char *dev_name, void *data, bool is_smb3)
 {
 	int rc;
 	struct super_block *sb;
@@ -710,7 +710,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	cifs_dbg(FYI, "Devname: %s flags: %d\n", dev_name, flags);
 
-	volume_info = cifs_get_volume_info((char *)data, dev_name);
+	volume_info = cifs_get_volume_info((char *)data, dev_name, is_smb3);
 	if (IS_ERR(volume_info))
 		return ERR_CAST(volume_info);
 
@@ -790,6 +790,20 @@ cifs_do_mount(struct file_system_type *fs_type,
 	goto out;
 }
 
+static struct dentry *
+smb3_do_mount(struct file_system_type *fs_type,
+	      int flags, const char *dev_name, void *data)
+{
+	return cifs_smb3_do_mount(fs_type, flags, dev_name, data, true);
+}
+
+static struct dentry *
+cifs_do_mount(struct file_system_type *fs_type,
+	      int flags, const char *dev_name, void *data)
+{
+	return cifs_smb3_do_mount(fs_type, flags, dev_name, data, false);
+}
+
 static ssize_t
 cifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
@@ -925,7 +939,7 @@ MODULE_ALIAS_FS("cifs");
 static struct file_system_type smb3_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "smb3",
-	.mount = cifs_do_mount,
+	.mount = smb3_do_mount,
 	.kill_sb = cifs_kill_sb,
 	/*  .fs_flags */
 };

commit b326614ea2159ea5c835d320f261d05d080cd201
Author: Steve French <stfrench@microsoft.com>
Date:   Sun May 20 23:41:10 2018 -0500

    smb3: allow "posix" mount option to enable new SMB311 protocol extensions
    
    If "posix" (or synonym "unix" for backward compatibility) specified on mount,
    and server advertises support for SMB3.11 POSIX negotiate context, then
    enable the new posix extensions on the tcon.  This can be viewed by
    looking for "posix" in the mount options displayed by /proc/mounts
    for that mount (ie if posix extensions allowed by server and the
    experimental POSIX extensions also requested on the mount by specifying
    "posix" at mount time).
    
    Also add check to warn user if conflicting unix/nounix or posix/noposix specified
    on mount.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c608ea62f536..eb7b6573f322 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -481,10 +481,20 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",persistenthandles");
 	else if (tcon->use_resilient)
 		seq_puts(s, ",resilienthandles");
+
+#ifdef CONFIG_CIFS_SMB311
+	if (tcon->posix_extensions)
+		seq_puts(s, ",posix");
+	else if (tcon->unix_ext)
+		seq_puts(s, ",unix");
+	else
+		seq_puts(s, ",nounix");
+#else
 	if (tcon->unix_ext)
 		seq_puts(s, ",unix");
 	else
 		seq_puts(s, ",nounix");
+#endif /* SMB311 */
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 		seq_puts(s, ",posixpaths");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)

commit f92a720ee9d5d4e76a9621ce0812aef133c7b981
Author: Steve French <stfrench@microsoft.com>
Date:   Thu May 24 04:11:07 2018 -0500

    cifs: allow disabling less secure legacy dialects
    
    To improve security it may be helpful to have additional ways to restrict the
    ability to override the default dialects (SMB2.1, SMB3 and SMB3.02) on mount
    with old dialects (CIFS/SMB1 and SMB2) since vers=1.0 (CIFS/SMB1) and vers=2.0
    are weaker and less secure.
    
    Add a module parameter "disable_legacy_dialects"
    (/sys/module/cifs/parameters/disable_legacy_dialects) which can be set to
    1 (or equivalently Y) to forbid use of vers=1.0 or vers=2.0 on mount.
    
    Also cleans up a few build warnings about globals for various module parms.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index fe30aabe00d7..c608ea62f536 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -58,6 +58,7 @@ bool traceSMB;
 bool enable_oplocks = true;
 bool linuxExtEnabled = true;
 bool lookupCacheEnabled = true;
+bool disable_legacy_dialects; /* false by default */
 unsigned int global_secflags = CIFSSEC_DEF;
 /* unsigned int ntlmv2_support = 0; */
 unsigned int sign_CIFS_PDUs = 1;
@@ -83,6 +84,15 @@ MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server for "
 module_param(enable_oplocks, bool, 0644);
 MODULE_PARM_DESC(enable_oplocks, "Enable or disable oplocks. Default: y/Y/1");
 
+module_param(disable_legacy_dialects, bool, 0644);
+MODULE_PARM_DESC(disable_legacy_dialects, "To improve security it may be "
+				  "helpful to restrict the ability to "
+				  "override the default dialects (SMB2.1, "
+				  "SMB3 and SMB3.02) on mount with old "
+				  "dialects (CIFS/SMB1 and SMB2) since "
+				  "vers=1.0 (CIFS/SMB1) and vers=2.0 are weaker"
+				  " and less secure. Default: n/N/0");
+
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;

commit 11911b956f35868be5b3c0f686e01973a221abe6
Author: Steve French <stfrench@microsoft.com>
Date:   Thu May 24 02:09:20 2018 -0500

    cifs: make minor clarifications to module params for cifs.ko
    
    Note which ones of the module params are cifs dialect only
    (N/A for default dialect now that has moved to SMB2.1 or later)
    
    Signed-off-by: Steve French <stfrench@microsoft.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f0a68e90f740..fe30aabe00d7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -64,7 +64,8 @@ unsigned int sign_CIFS_PDUs = 1;
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, uint, 0444);
-MODULE_PARM_DESC(CIFSMaxBufSize, "Network buffer size (not including header). "
+MODULE_PARM_DESC(CIFSMaxBufSize, "Network buffer size (not including header) "
+				 "for CIFS requests. "
 				 "Default: 16384 Range: 8192 to 130048");
 unsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;
 module_param(cifs_min_rcv, uint, 0444);
@@ -76,7 +77,8 @@ MODULE_PARM_DESC(cifs_min_small, "Small network buffers in pool. Default: 30 "
 				 "Range: 2 to 256");
 unsigned int cifs_max_pending = CIFS_MAX_REQ;
 module_param(cifs_max_pending, uint, 0444);
-MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server. "
+MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server for "
+				   "CIFS/SMB1 dialect (N/A for SMB3) "
 				   "Default: 32767 Range: 2 to 32767.");
 module_param(enable_oplocks, bool, 0644);
 MODULE_PARM_DESC(enable_oplocks, "Enable or disable oplocks. Default: y/Y/1");

commit 49218b4f5745b2f9884ce8bc302eae9ebde285cd
Author: Steve French <stfrench@microsoft.com>
Date:   Wed May 23 21:44:53 2018 -0500

    smb3: add module alias for smb3 to cifs.ko
    
    We really don't want to be encouraging people to use the old
    (less secure) cifs dialect (SMB1) and it can be confusing for them
    with SMB3 (or later) being recommended but the module name is cifs.
    
    Add a module alias for "smb3" to cifs.ko to make this less confusing.
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 62f166270459..f0a68e90f740 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -899,6 +899,17 @@ struct file_system_type cifs_fs_type = {
 	/*  .fs_flags */
 };
 MODULE_ALIAS_FS("cifs");
+
+static struct file_system_type smb3_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "smb3",
+	.mount = cifs_do_mount,
+	.kill_sb = cifs_kill_sb,
+	/*  .fs_flags */
+};
+MODULE_ALIAS_FS("smb3");
+MODULE_ALIAS("smb3");
+
 const struct inode_operations cifs_dir_inode_ops = {
 	.create = cifs_create,
 	.atomic_open = cifs_atomic_open,
@@ -1437,6 +1448,12 @@ init_cifs(void)
 	if (rc)
 		goto out_init_cifs_idmap;
 
+	rc = register_filesystem(&smb3_fs_type);
+	if (rc) {
+		unregister_filesystem(&cifs_fs_type);
+		goto out_init_cifs_idmap;
+	}
+
 	return 0;
 
 out_init_cifs_idmap:
@@ -1467,8 +1484,9 @@ init_cifs(void)
 static void __exit
 exit_cifs(void)
 {
-	cifs_dbg(NOISY, "exit_cifs\n");
+	cifs_dbg(NOISY, "exit_smb3\n");
 	unregister_filesystem(&cifs_fs_type);
+	unregister_filesystem(&smb3_fs_type);
 	cifs_dfs_release_automount_timer();
 #ifdef CONFIG_CIFS_ACL
 	exit_cifs_idmap();

commit 3d4ef9a15343f038ccae17f60468569f23113312
Author: Steve French <stfrench@microsoft.com>
Date:   Wed Apr 25 22:19:09 2018 -0500

    smb3: fix redundant opens on root
    
    In SMB2/SMB3 unlike in cifs we unnecessarily open the root of the share
    over and over again in various places during mount and path revalidation
    and also in statfs.  This patch cuts redundant traffic (opens and closes)
    by simply keeping the directory handle for the root around (and reopening
    it as needed on reconnect), so query calls don't require three round
    trips to copmlete - just one, and eases load on network, client and
    server (on mount alone, cuts network traffic by more than a third).
    
    Also add a new cifs mount parm "nohandlecache" to allow users whose
    servers might have resource constraints (eg in case they have a server
    with so many users connecting to it that this extra handle per mount
    could possibly be a resource concern).
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5a5a0158cc8f..62f166270459 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -495,6 +495,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",sfu");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)
 		seq_puts(s, ",nobrl");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_HANDLE_CACHE)
+		seq_puts(s, ",nohandlecache");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)
 		seq_puts(s, ",cifsacl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)

commit 6e70c267e68d77679534dcf4aaf84e66f2cf1425
Author: Steve French <smfrench@gmail.com>
Date:   Thu May 10 10:59:37 2018 -0500

    smb3: directory sync should not return an error
    
    As with NFS, which ignores sync on directory handles,
    fsync on a directory handle is a noop for CIFS/SMB3.
    Do not return an error on it.  It breaks some database
    apps otherwise.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f715609b13f3..5a5a0158cc8f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1047,6 +1047,18 @@ ssize_t cifs_file_copychunk_range(unsigned int xid,
 	return rc;
 }
 
+/*
+ * Directory operations under CIFS/SMB2/SMB3 are synchronous, so fsync()
+ * is a dummy operation.
+ */
+static int cifs_dir_fsync(struct file *file, loff_t start, loff_t end, int datasync)
+{
+	cifs_dbg(FYI, "Sync directory - name: %pD datasync: 0x%x\n",
+		 file, datasync);
+
+	return 0;
+}
+
 static ssize_t cifs_copy_file_range(struct file *src_file, loff_t off,
 				struct file *dst_file, loff_t destoff,
 				size_t len, unsigned int flags)
@@ -1181,6 +1193,7 @@ const struct file_operations cifs_dir_ops = {
 	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
 	.llseek = generic_file_llseek,
+	.fsync = cifs_dir_fsync,
 };
 
 static void

commit 5fcd7f3f966f37f3f9a215af4cc1597fe338d0d5
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Fri Feb 16 19:19:28 2018 +0100

    CIFS: add sha512 secmech
    
    * prepare for SMB3.11 pre-auth integrity
    * enable sha512 when SMB311 is enabled in Kconfig
    * add sha512 as a soft dependency
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 32cdea67bbfd..f715609b13f3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1486,6 +1486,7 @@ MODULE_SOFTDEP("pre: nls");
 MODULE_SOFTDEP("pre: aes");
 MODULE_SOFTDEP("pre: cmac");
 MODULE_SOFTDEP("pre: sha256");
+MODULE_SOFTDEP("pre: sha512");
 MODULE_SOFTDEP("pre: aead2");
 MODULE_SOFTDEP("pre: ccm");
 module_init(init_cifs)

commit 617aebe6a97efa539cc4b8a52adccd89596e6be0
Merge: 0771ad44a20b e47e311843de
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 3 16:25:42 2018 -0800

    Merge tag 'usercopy-v4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull hardened usercopy whitelisting from Kees Cook:
     "Currently, hardened usercopy performs dynamic bounds checking on slab
      cache objects. This is good, but still leaves a lot of kernel memory
      available to be copied to/from userspace in the face of bugs.
    
      To further restrict what memory is available for copying, this creates
      a way to whitelist specific areas of a given slab cache object for
      copying to/from userspace, allowing much finer granularity of access
      control.
    
      Slab caches that are never exposed to userspace can declare no
      whitelist for their objects, thereby keeping them unavailable to
      userspace via dynamic copy operations. (Note, an implicit form of
      whitelisting is the use of constant sizes in usercopy operations and
      get_user()/put_user(); these bypass all hardened usercopy checks since
      these sizes cannot change at runtime.)
    
      This new check is WARN-by-default, so any mistakes can be found over
      the next several releases without breaking anyone's system.
    
      The series has roughly the following sections:
       - remove %p and improve reporting with offset
       - prepare infrastructure and whitelist kmalloc
       - update VFS subsystem with whitelists
       - update SCSI subsystem with whitelists
       - update network subsystem with whitelists
       - update process memory with whitelists
       - update per-architecture thread_struct with whitelists
       - update KVM with whitelists and fix ioctl bug
       - mark all other allocations as not whitelisted
       - update lkdtm for more sensible test overage"
    
    * tag 'usercopy-v4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux: (38 commits)
      lkdtm: Update usercopy tests for whitelisting
      usercopy: Restrict non-usercopy caches to size 0
      kvm: x86: fix KVM_XEN_HVM_CONFIG ioctl
      kvm: whitelist struct kvm_vcpu_arch
      arm: Implement thread_struct whitelist for hardened usercopy
      arm64: Implement thread_struct whitelist for hardened usercopy
      x86: Implement thread_struct whitelist for hardened usercopy
      fork: Provide usercopy whitelisting for task_struct
      fork: Define usercopy region in thread_stack slab caches
      fork: Define usercopy region in mm_struct slab caches
      net: Restrict unwhitelisted proto caches to size 0
      sctp: Copy struct sctp_sock.autoclose to userspace using put_user()
      sctp: Define usercopy region in SCTP proto slab cache
      caif: Define usercopy region in caif proto slab cache
      ip: Define usercopy region in IP proto slab cache
      net: Define usercopy region in struct proto slab cache
      scsi: Define usercopy region in scsi_sense_cache slab cache
      cifs: Define usercopy region in cifs_request slab cache
      vxfs: Define usercopy region in vxfs_inode slab cache
      ufs: Define usercopy region in ufs_inode_cache slab cache
      ...

commit cd1aca29fa020b6e6edcd3d5b3e49ab877d1bed7
Author: Andrs Souto <kai670@gmail.com>
Date:   Thu Dec 28 14:23:08 2017 +0100

    cifs: add .splice_write
    
    add splice_write support in cifs vfs using iter_file_splice_write
    
    Signed-off-by: Andrs Souto <kai670@gmail.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 801b63b7900f..a7be591d8e18 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1070,6 +1070,7 @@ const struct file_operations cifs_file_ops = {
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
+	.splice_write = iter_file_splice_write,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
@@ -1088,6 +1089,7 @@ const struct file_operations cifs_file_strict_ops = {
 	.flush = cifs_flush,
 	.mmap = cifs_file_strict_mmap,
 	.splice_read = generic_file_splice_read,
+	.splice_write = iter_file_splice_write,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
@@ -1107,6 +1109,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.flush = cifs_flush,
 	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
+	.splice_write = iter_file_splice_write,
 	.unlocked_ioctl  = cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
@@ -1124,6 +1127,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
+	.splice_write = iter_file_splice_write,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
@@ -1141,6 +1145,7 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 	.flush = cifs_flush,
 	.mmap = cifs_file_strict_mmap,
 	.splice_read = generic_file_splice_read,
+	.splice_write = iter_file_splice_write,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
@@ -1159,6 +1164,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.flush = cifs_flush,
 	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
+	.splice_write = iter_file_splice_write,
 	.unlocked_ioctl  = cifs_ioctl,
 	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,

commit 8339dd32fbad71834d61b9103e8884ada9bf3e1c
Author: Long Li <longli@microsoft.com>
Date:   Tue Nov 7 01:54:55 2017 -0700

    CIFS: SMBD: Add rdma mount option
    
    Add "rdma" to CIFS mount options to connect to SMB Direct.
    Add checks to validate this is used on SMB 3.X dialects.
    
    To connect to SMBDirect, use "mount.cifs -o rdma,vers=3.x".
    At the time of this patch, 3.x can be 3.0, 3.02 or 3.1.1.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Acked-by: Ronnie Sahlberg <lsahlber.redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 31b7565b1617..801b63b7900f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -327,6 +327,8 @@ cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 	default:
 		seq_puts(s, "(unknown)");
 	}
+	if (server->rdma)
+		seq_puts(s, ",rdma");
 }
 
 static void

commit de046449045a329bae5c9256e55b58a685a22532
Author: David Windsor <dave@nullcore.net>
Date:   Sat Jun 10 22:50:33 2017 -0400

    cifs: Define usercopy region in cifs_request slab cache
    
    CIFS request buffers, stored in the cifs_request slab cache, need to be
    copied to/from userspace.
    
    cache object allocation:
        fs/cifs/cifsfs.c:
            cifs_init_request_bufs():
                ...
                cifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,
                                                          cifs_req_cachep);
    
        fs/cifs/misc.c:
            cifs_buf_get():
                ...
                ret_buf = mempool_alloc(cifs_req_poolp, GFP_NOFS);
                ...
                return ret_buf;
    
    In support of usercopy hardening, this patch defines a region in the
    cifs_request slab cache in which userspace copy operations are allowed.
    
    This region is known as the slab cache's usercopy region. Slab caches
    can now check that each dynamically sized copy operation involving
    cache-managed memory falls entirely within the slab's usercopy region.
    
    This patch is verbatim from Brad Spengler/PaX Team's PAX_USERCOPY
    whitelisting code in the last public patch of grsecurity/PaX based on my
    understanding of the code. Changes or omissions from the original code are
    mine and don't reflect the original grsecurity/PaX code.
    
    Signed-off-by: David Windsor <dave@nullcore.net>
    [kees: adjust commit log, provide usage trace]
    Cc: Steve French <sfrench@samba.org>
    Cc: linux-cifs@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 31b7565b1617..29f4b0290fbd 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1231,9 +1231,11 @@ cifs_init_request_bufs(void)
 	cifs_dbg(VFS, "CIFSMaxBufSize %d 0x%x\n",
 		 CIFSMaxBufSize, CIFSMaxBufSize);
 */
-	cifs_req_cachep = kmem_cache_create("cifs_request",
+	cifs_req_cachep = kmem_cache_create_usercopy("cifs_request",
 					    CIFSMaxBufSize + max_hdr_size, 0,
-					    SLAB_HWCACHE_ALIGN, NULL);
+					    SLAB_HWCACHE_ALIGN, 0,
+					    CIFSMaxBufSize + max_hdr_size,
+					    NULL);
 	if (cifs_req_cachep == NULL)
 		return -ENOMEM;
 
@@ -1259,9 +1261,9 @@ cifs_init_request_bufs(void)
 	more SMBs to use small buffer alloc and is still much more
 	efficient to alloc 1 per page off the slab compared to 17K (5page)
 	alloc of large cifs buffers even when page debugging is on */
-	cifs_sm_req_cachep = kmem_cache_create("cifs_small_rq",
+	cifs_sm_req_cachep = kmem_cache_create_usercopy("cifs_small_rq",
 			MAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,
-			NULL);
+			0, MAX_CIFS_SMALL_BUFFER_SIZE, NULL);
 	if (cifs_sm_req_cachep == NULL) {
 		mempool_destroy(cifs_req_poolp);
 		kmem_cache_destroy(cifs_req_cachep);

commit 1751e8a6cb935e555fcdbcb9ab4f0446e322ca3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 27 13:05:09 2017 -0800

    Rename superblock flags (MS_xyz -> SB_xyz)
    
    This is a pure automated search-and-replace of the internal kernel
    superblock flags.
    
    The s_flags are now called SB_*, with the names and the values for the
    moment mirroring the MS_* flags that they're equivalent to.
    
    Note how the MS_xyz flags are the ones passed to the mount system call,
    while the SB_xyz flags are what we then use in sb->s_flags.
    
    The script to do this was:
    
        # places to look in; re security/*: it generally should *not* be
        # touched (that stuff parses mount(2) arguments directly), but
        # there are two places where we really deal with superblock flags.
        FILES="drivers/mtd drivers/staging/lustre fs ipc mm \
                include/linux/fs.h include/uapi/linux/bfs_fs.h \
                security/apparmor/apparmorfs.c security/apparmor/include/lib.h"
        # the list of MS_... constants
        SYMS="RDONLY NOSUID NODEV NOEXEC SYNCHRONOUS REMOUNT MANDLOCK \
              DIRSYNC NOATIME NODIRATIME BIND MOVE REC VERBOSE SILENT \
              POSIXACL UNBINDABLE PRIVATE SLAVE SHARED RELATIME KERNMOUNT \
              I_VERSION STRICTATIME LAZYTIME SUBMOUNT NOREMOTELOCK NOSEC BORN \
              ACTIVE NOUSER"
    
        SED_PROG=
        for i in $SYMS; do SED_PROG="$SED_PROG -e s/MS_$i/SB_$i/g"; done
    
        # we want files that contain at least one of MS_...,
        # with fs/namespace.c and fs/pnode.c excluded.
        L=$(for i in $SYMS; do git grep -w -l MS_$i $FILES; done| sort|uniq|grep -v '^fs/namespace.c'|grep -v '^fs/pnode.c')
    
        for f in $L; do sed -i $f $SED_PROG; done
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8c8b75d33f31..31b7565b1617 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -125,7 +125,7 @@ cifs_read_super(struct super_block *sb)
 	tcon = cifs_sb_master_tcon(cifs_sb);
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)
-		sb->s_flags |= MS_POSIXACL;
+		sb->s_flags |= SB_POSIXACL;
 
 	if (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)
 		sb->s_maxbytes = MAX_LFS_FILESIZE;
@@ -497,7 +497,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",cifsacl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)
 		seq_puts(s, ",dynperm");
-	if (root->d_sb->s_flags & MS_POSIXACL)
+	if (root->d_sb->s_flags & SB_POSIXACL)
 		seq_puts(s, ",acl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)
 		seq_puts(s, ",mfsymlinks");
@@ -573,7 +573,7 @@ static int cifs_show_stats(struct seq_file *s, struct dentry *root)
 static int cifs_remount(struct super_block *sb, int *flags, char *data)
 {
 	sync_filesystem(sb);
-	*flags |= MS_NODIRATIME;
+	*flags |= SB_NODIRATIME;
 	return 0;
 }
 
@@ -708,7 +708,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	rc = cifs_mount(cifs_sb, volume_info);
 	if (rc) {
-		if (!(flags & MS_SILENT))
+		if (!(flags & SB_SILENT))
 			cifs_dbg(VFS, "cifs_mount failed w/return code = %d\n",
 				 rc);
 		root = ERR_PTR(rc);
@@ -720,7 +720,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	mnt_data.flags = flags;
 
 	/* BB should we make this contingent on mount parm? */
-	flags |= MS_NODIRATIME | MS_NOATIME;
+	flags |= SB_NODIRATIME | SB_NOATIME;
 
 	sb = sget(fs_type, cifs_match_super, cifs_set_super, flags, &mnt_data);
 	if (IS_ERR(sb)) {
@@ -739,7 +739,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 			goto out_super;
 		}
 
-		sb->s_flags |= MS_ACTIVE;
+		sb->s_flags |= SB_ACTIVE;
 	}
 
 	root = cifs_get_root(volume_info, sb);

commit 94183331e815617246b1baa97e0916f358c794bb
Author: Shu Wang <shuwang@redhat.com>
Date:   Thu Sep 7 16:03:27 2017 +0800

    cifs: release cifs root_cred after exit_cifs
    
    memory leak was found by kmemleak. exit_cifs_spnego
    should be called before cifs module removed, or
    cifs root_cred will not be released.
    
    kmemleak report:
    unreferenced object 0xffff880070a3ce40 (size 192):
      backtrace:
         kmemleak_alloc+0x4a/0xa0
         kmem_cache_alloc+0xc7/0x1d0
         prepare_kernel_cred+0x20/0x120
         init_cifs_spnego+0x2d/0x170 [cifs]
         0xffffffffc07801f3
         do_one_initcall+0x51/0x1b0
         do_init_module+0x60/0x1fd
         load_module+0x161e/0x1b60
         SYSC_finit_module+0xa9/0x100
         SyS_finit_module+0xe/0x10
    
    Signed-off-by: Shu Wang <shuwang@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a864e6575309..8c8b75d33f31 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1449,7 +1449,7 @@ exit_cifs(void)
 	exit_cifs_idmap();
 #endif
 #ifdef CONFIG_CIFS_UPCALL
-	unregister_key_type(&cifs_spnego_key_type);
+	exit_cifs_spnego();
 #endif
 	cifs_destroy_request_bufs();
 	cifs_destroy_mids();

commit 6e82e929d98552ed5156919e0f532eeba2da704b
Author: Ronnie Sahlberg <lsahlber@redhat.com>
Date:   Wed Sep 20 13:09:23 2017 +1000

    cifs: show 'soft' in the mount options for hard mounts
    
    Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 180b3356ff86..a864e6575309 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -461,6 +461,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",nocase");
 	if (tcon->retry)
 		seq_puts(s, ",hard");
+	else
+		seq_puts(s, ",soft");
 	if (tcon->use_persistent)
 		seq_puts(s, ",persistenthandles");
 	else if (tcon->use_resilient)

commit 52f6c588c77b76d548201470c2a28263a41b462b
Merge: 78dcf73421a8 72e5c740f633
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 15 12:44:02 2017 -0700

    Merge tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random
    
    Pull random updates from Ted Ts'o:
     "Add wait_for_random_bytes() and get_random_*_wait() functions so that
      callers can more safely get random bytes if they can block until the
      CRNG is initialized.
    
      Also print a warning if get_random_*() is called before the CRNG is
      initialized. By default, only one single-line warning will be printed
      per boot. If CONFIG_WARN_ALL_UNSEEDED_RANDOM is defined, then a
      warning will be printed for each function which tries to get random
      bytes before the CRNG is initialized. This can get spammy for certain
      architecture types, so it is not enabled by default"
    
    * tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random:
      random: reorder READ_ONCE() in get_random_uXX
      random: suppress spammy warnings about unseeded randomness
      random: warn when kernel uses unseeded randomness
      net/route: use get_random_int for random counter
      net/neighbor: use get_random_u32 for 32-bit hash random
      rhashtable: use get_random_u32 for hash_rnd
      ceph: ensure RNG is seeded before using
      iscsi: ensure RNG is seeded before use
      cifs: use get_random_u32 for 32-bit lock random
      random: add get_random_{bytes,u32,u64,int,long,once}_wait family
      random: add wait_for_random_bytes() API

commit 2a38e12053b760a8f5e85030eb89512660077c15
Author: Steve French <smfrench@gmail.com>
Date:   Sat Jul 8 18:48:15 2017 -0500

    [SMB3] Remove ifdef since SMB3 (and later) now STRONGLY preferred
    
    Remove the CONFIG_CIFS_SMB2 ifdef and Kconfig option since they
    must always be on now.
    
    For various security reasons, SMB3 and later are STRONGLY preferred
    over CIFS and older dialects, and SMB3 (and later) will now be
    the default dialects so we do not want to allow them to be
    ifdeffed out.
    
    In the longer term, we may be able to make older CIFS support
    disableable in Kconfig with a new set of #ifdef, but we always
    want SMB3 and later support enabled.
    
    Signed-off-by: Steven French <smfrench@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9a1667e0e8d6..556f480c6936 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -51,9 +51,7 @@
 #include <linux/key-type.h>
 #include "cifs_spnego.h"
 #include "fscache.h"
-#ifdef CONFIG_CIFS_SMB2
 #include "smb2pdu.h"
-#endif
 
 int cifsFYI = 0;
 bool traceSMB;
@@ -277,9 +275,8 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->uniqueid = 0;
 	cifs_inode->createtime = 0;
 	cifs_inode->epoch = 0;
-#ifdef CONFIG_CIFS_SMB2
 	generate_random_uuid(cifs_inode->lease_key);
-#endif
+
 	/*
 	 * Can not set i_flags here - they get immediately overwritten to zero
 	 * by the VFS.
@@ -1213,14 +1210,12 @@ cifs_destroy_inodecache(void)
 static int
 cifs_init_request_bufs(void)
 {
-	size_t max_hdr_size = MAX_CIFS_HDR_SIZE;
-#ifdef CONFIG_CIFS_SMB2
 	/*
 	 * SMB2 maximum header size is bigger than CIFS one - no problems to
 	 * allocate some more bytes for CIFS.
 	 */
-	max_hdr_size = MAX_SMB2_HDR_SIZE;
-#endif
+	size_t max_hdr_size = MAX_SMB2_HDR_SIZE;
+
 	if (CIFSMaxBufSize < 8192) {
 	/* Buffer size can not be smaller than 2 * PATH_MAX since maximum
 	Unicode path name has to fit in any SMB/CIFS path based frames */
@@ -1476,12 +1471,10 @@ MODULE_SOFTDEP("pre: hmac");
 MODULE_SOFTDEP("pre: md4");
 MODULE_SOFTDEP("pre: md5");
 MODULE_SOFTDEP("pre: nls");
-#ifdef CONFIG_CIFS_SMB2
 MODULE_SOFTDEP("pre: aes");
 MODULE_SOFTDEP("pre: cmac");
 MODULE_SOFTDEP("pre: sha256");
 MODULE_SOFTDEP("pre: aead2");
 MODULE_SOFTDEP("pre: ccm");
-#endif /* CONFIG_CIFS_SMB2 */
 module_init(init_cifs)
 module_exit(exit_cifs)

commit 51b0817b0d23d51223575eff14629b3602a93cd4
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jun 7 20:42:50 2017 -0400

    cifs: use get_random_u32 for 32-bit lock random
    
    Using get_random_u32 here is faster, more fitting of the use case, and
    just as cryptographically secure. It also has the benefit of providing
    better randomness at early boot, which is sometimes when this is used.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Cc: Steve French <sfrench@samba.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9a1667e0e8d6..fe0c8dcc7dc7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1359,7 +1359,7 @@ init_cifs(void)
 	spin_lock_init(&cifs_tcp_ses_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
-	get_random_bytes(&cifs_lock_secret, sizeof(cifs_lock_secret));
+	cifs_lock_secret = get_random_u32();
 
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;

commit fe7a719b30dfdb4d55680461954b99b257ebe671
Merge: d484467c860d 85435d7a1529
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 6 11:51:46 2017 -0700

    Merge branch 'for-next' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull cifs fixes from Steve French:
     "Various fixes for stable for CIFS/SMB3 especially for better
      interoperability for SMB3 to Macs.
    
      It also includes Pavel's improvements to SMB3 async i/o support
      (which is much faster now)"
    
    * 'for-next' of git://git.samba.org/sfrench/cifs-2.6:
      CIFS: add misssing SFM mapping for doublequote
      SMB3: Work around mount failure when using SMB3 dialect to Macs
      cifs: fix CIFS_IOC_GET_MNT_INFO oops
      CIFS: fix mapping of SFM_SPACE and SFM_PERIOD
      CIFS: fix oplock break deadlocks
      cifs: fix CIFS_ENUMERATE_SNAPSHOTS oops
      cifs: fix leak in FSCTL_ENUM_SNAPS response handling
      Set unicode flag on cifs echo request to avoid Mac error
      CIFS: Add asynchronous write support through kernel AIO
      CIFS: Add asynchronous read support through kernel AIO
      CIFS: Add asynchronous context to support kernel AIO
      cifs: fix IPv6 link local, with scope id, address parsing
      cifs: small underflow in cnvrtDosUnixTm()

commit 3998e6b87d4258a70df358296d6f1c7234012bfe
Author: Rabin Vincent <rabinv@axis.com>
Date:   Wed May 3 17:54:01 2017 +0200

    CIFS: fix oplock break deadlocks
    
    When the final cifsFileInfo_put() is called from cifsiod and an oplock
    break work is queued, lockdep complains loudly:
    
     =============================================
     [ INFO: possible recursive locking detected ]
     4.11.0+ #21 Not tainted
     ---------------------------------------------
     kworker/0:2/78 is trying to acquire lock:
      ("cifsiod"){++++.+}, at: flush_work+0x215/0x350
    
     but task is already holding lock:
      ("cifsiod"){++++.+}, at: process_one_work+0x255/0x8e0
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock("cifsiod");
       lock("cifsiod");
    
      *** DEADLOCK ***
    
      May be due to missing lock nesting notation
    
     2 locks held by kworker/0:2/78:
      #0:  ("cifsiod"){++++.+}, at: process_one_work+0x255/0x8e0
      #1:  ((&wdata->work)){+.+...}, at: process_one_work+0x255/0x8e0
    
     stack backtrace:
     CPU: 0 PID: 78 Comm: kworker/0:2 Not tainted 4.11.0+ #21
     Workqueue: cifsiod cifs_writev_complete
     Call Trace:
      dump_stack+0x85/0xc2
      __lock_acquire+0x17dd/0x2260
      ? match_held_lock+0x20/0x2b0
      ? trace_hardirqs_off_caller+0x86/0x130
      ? mark_lock+0xa6/0x920
      lock_acquire+0xcc/0x260
      ? lock_acquire+0xcc/0x260
      ? flush_work+0x215/0x350
      flush_work+0x236/0x350
      ? flush_work+0x215/0x350
      ? destroy_worker+0x170/0x170
      __cancel_work_timer+0x17d/0x210
      ? ___preempt_schedule+0x16/0x18
      cancel_work_sync+0x10/0x20
      cifsFileInfo_put+0x338/0x7f0
      cifs_writedata_release+0x2a/0x40
      ? cifs_writedata_release+0x2a/0x40
      cifs_writev_complete+0x29d/0x850
      ? preempt_count_sub+0x18/0xd0
      process_one_work+0x304/0x8e0
      worker_thread+0x9b/0x6a0
      kthread+0x1b2/0x200
      ? process_one_work+0x8e0/0x8e0
      ? kthread_create_on_node+0x40/0x40
      ret_from_fork+0x31/0x40
    
    This is a real warning.  Since the oplock is queued on the same
    workqueue this can deadlock if there is only one worker thread active
    for the workqueue (which will be the case during memory pressure when
    the rescuer thread is handling it).
    
    Furthermore, there is at least one other kind of hang possible due to
    the oplock break handling if there is only worker.  (This can be
    reproduced without introducing memory pressure by having passing 1 for
    the max_active parameter of cifsiod.) cifs_oplock_break() can wait
    indefintely in the filemap_fdatawait() while the cifs_writev_complete()
    work is blocked:
    
     sysrq: SysRq : Show Blocked State
       task                        PC stack   pid father
     kworker/0:1     D    0    16      2 0x00000000
     Workqueue: cifsiod cifs_oplock_break
     Call Trace:
      __schedule+0x562/0xf40
      ? mark_held_locks+0x4a/0xb0
      schedule+0x57/0xe0
      io_schedule+0x21/0x50
      wait_on_page_bit+0x143/0x190
      ? add_to_page_cache_lru+0x150/0x150
      __filemap_fdatawait_range+0x134/0x190
      ? do_writepages+0x51/0x70
      filemap_fdatawait_range+0x14/0x30
      filemap_fdatawait+0x3b/0x40
      cifs_oplock_break+0x651/0x710
      ? preempt_count_sub+0x18/0xd0
      process_one_work+0x304/0x8e0
      worker_thread+0x9b/0x6a0
      kthread+0x1b2/0x200
      ? process_one_work+0x8e0/0x8e0
      ? kthread_create_on_node+0x40/0x40
      ret_from_fork+0x31/0x40
     dd              D    0   683    171 0x00000000
     Call Trace:
      __schedule+0x562/0xf40
      ? mark_held_locks+0x29/0xb0
      schedule+0x57/0xe0
      io_schedule+0x21/0x50
      wait_on_page_bit+0x143/0x190
      ? add_to_page_cache_lru+0x150/0x150
      __filemap_fdatawait_range+0x134/0x190
      ? do_writepages+0x51/0x70
      filemap_fdatawait_range+0x14/0x30
      filemap_fdatawait+0x3b/0x40
      filemap_write_and_wait+0x4e/0x70
      cifs_flush+0x6a/0xb0
      filp_close+0x52/0xa0
      __close_fd+0xdc/0x150
      SyS_close+0x33/0x60
      entry_SYSCALL_64_fastpath+0x1f/0xbe
    
     Showing all locks held in the system:
     2 locks held by kworker/0:1/16:
      #0:  ("cifsiod"){.+.+.+}, at: process_one_work+0x255/0x8e0
      #1:  ((&cfile->oplock_break)){+.+.+.}, at: process_one_work+0x255/0x8e0
    
     Showing busy workqueues and worker pools:
     workqueue cifsiod: flags=0xc
       pwq 0: cpus=0 node=0 flags=0x0 nice=0 active=1/1
         in-flight: 16:cifs_oplock_break
         delayed: cifs_writev_complete, cifs_echo_request
     pool 0: cpus=0 node=0 flags=0x0 nice=0 hung=0s workers=3 idle: 750 3
    
    Fix these problems by creating a a new workqueue (with a rescuer) for
    the oplock break work.
    
    Signed-off-by: Rabin Vincent <rabinv@axis.com>
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 34fee9fb7e4f..5c52c8f56102 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -87,6 +87,7 @@ extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
+struct workqueue_struct	*cifsoplockd_wq;
 __u32 cifs_lock_secret;
 
 /*
@@ -1374,9 +1375,16 @@ init_cifs(void)
 		goto out_clean_proc;
 	}
 
+	cifsoplockd_wq = alloc_workqueue("cifsoplockd",
+					 WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
+	if (!cifsoplockd_wq) {
+		rc = -ENOMEM;
+		goto out_destroy_cifsiod_wq;
+	}
+
 	rc = cifs_fscache_register();
 	if (rc)
-		goto out_destroy_wq;
+		goto out_destroy_cifsoplockd_wq;
 
 	rc = cifs_init_inodecache();
 	if (rc)
@@ -1424,7 +1432,9 @@ init_cifs(void)
 	cifs_destroy_inodecache();
 out_unreg_fscache:
 	cifs_fscache_unregister();
-out_destroy_wq:
+out_destroy_cifsoplockd_wq:
+	destroy_workqueue(cifsoplockd_wq);
+out_destroy_cifsiod_wq:
 	destroy_workqueue(cifsiod_wq);
 out_clean_proc:
 	cifs_proc_clean();
@@ -1447,6 +1457,7 @@ exit_cifs(void)
 	cifs_destroy_mids();
 	cifs_destroy_inodecache();
 	cifs_fscache_unregister();
+	destroy_workqueue(cifsoplockd_wq);
 	destroy_workqueue(cifsiod_wq);
 	cifs_proc_clean();
 }

commit 8d65b08debc7e62b2c6032d7fe7389d895b92cbc
Merge: 5a0387a8a8ef 5d15af6778b8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 2 16:40:27 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Millar:
     "Here are some highlights from the 2065 networking commits that
      happened this development cycle:
    
       1) XDP support for IXGBE (John Fastabend) and thunderx (Sunil Kowuri)
    
       2) Add a generic XDP driver, so that anyone can test XDP even if they
          lack a networking device whose driver has explicit XDP support
          (me).
    
       3) Sparc64 now has an eBPF JIT too (me)
    
       4) Add a BPF program testing framework via BPF_PROG_TEST_RUN (Alexei
          Starovoitov)
    
       5) Make netfitler network namespace teardown less expensive (Florian
          Westphal)
    
       6) Add symmetric hashing support to nft_hash (Laura Garcia Liebana)
    
       7) Implement NAPI and GRO in netvsc driver (Stephen Hemminger)
    
       8) Support TC flower offload statistics in mlxsw (Arkadi Sharshevsky)
    
       9) Multiqueue support in stmmac driver (Joao Pinto)
    
      10) Remove TCP timewait recycling, it never really could possibly work
          well in the real world and timestamp randomization really zaps any
          hint of usability this feature had (Soheil Hassas Yeganeh)
    
      11) Support level3 vs level4 ECMP route hashing in ipv4 (Nikolay
          Aleksandrov)
    
      12) Add socket busy poll support to epoll (Sridhar Samudrala)
    
      13) Netlink extended ACK support (Johannes Berg, Pablo Neira Ayuso,
          and several others)
    
      14) IPSEC hw offload infrastructure (Steffen Klassert)"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (2065 commits)
      tipc: refactor function tipc_sk_recv_stream()
      tipc: refactor function tipc_sk_recvmsg()
      net: thunderx: Optimize page recycling for XDP
      net: thunderx: Support for XDP header adjustment
      net: thunderx: Add support for XDP_TX
      net: thunderx: Add support for XDP_DROP
      net: thunderx: Add basic XDP support
      net: thunderx: Cleanup receive buffer allocation
      net: thunderx: Optimize CQE_TX handling
      net: thunderx: Optimize RBDR descriptor handling
      net: thunderx: Support for page recycling
      ipx: call ipxitf_put() in ioctl error path
      net: sched: add helpers to handle extended actions
      qed*: Fix issues in the ptp filter config implementation.
      qede: Fix concurrency issue in PTP Tx path processing.
      stmmac: Add support for SIMATIC IOT2000 platform
      net: hns: fix ethtool_get_strings overflow in hns driver
      tcp: fix wraparound issue in tcp_lp
      bpf, arm64: fix jit branch offset related to ldimm64
      bpf, arm64: implement jiting of BPF_XADD
      ...

commit 694752922b12bd318aa80191bd9d8c3dcfb39055
Merge: a351e9b9fc24 9438b3e080be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 1 10:39:57 2017 -0700

    Merge branch 'for-4.12/block' of git://git.kernel.dk/linux-block
    
    Pull block layer updates from Jens Axboe:
    
     - Add BFQ IO scheduler under the new blk-mq scheduling framework. BFQ
       was initially a fork of CFQ, but subsequently changed to implement
       fairness based on B-WF2Q+, a modified variant of WF2Q. BFQ is meant
       to be used on desktop type single drives, providing good fairness.
       From Paolo.
    
     - Add Kyber IO scheduler. This is a full multiqueue aware scheduler,
       using a scalable token based algorithm that throttles IO based on
       live completion IO stats, similary to blk-wbt. From Omar.
    
     - A series from Jan, moving users to separately allocated backing
       devices. This continues the work of separating backing device life
       times, solving various problems with hot removal.
    
     - A series of updates for lightnvm, mostly from Javier. Includes a
       'pblk' target that exposes an open channel SSD as a physical block
       device.
    
     - A series of fixes and improvements for nbd from Josef.
    
     - A series from Omar, removing queue sharing between devices on mostly
       legacy drivers. This helps us clean up other bits, if we know that a
       queue only has a single device backing. This has been overdue for
       more than a decade.
    
     - Fixes for the blk-stats, and improvements to unify the stats and user
       windows. This both improves blk-wbt, and enables other users to
       register a need to receive IO stats for a device. From Omar.
    
     - blk-throttle improvements from Shaohua. This provides a scalable
       framework for implementing scalable priotization - particularly for
       blk-mq, but applicable to any type of block device. The interface is
       marked experimental for now.
    
     - Bucketized IO stats for IO polling from Stephen Bates. This improves
       efficiency of polled workloads in the presence of mixed block size
       IO.
    
     - A few fixes for opal, from Scott.
    
     - A few pulls for NVMe, including a lot of fixes for NVMe-over-fabrics.
       From a variety of folks, mostly Sagi and James Smart.
    
     - A series from Bart, improving our exposed info and capabilities from
       the blk-mq debugfs support.
    
     - A series from Christoph, cleaning up how handle WRITE_ZEROES.
    
     - A series from Christoph, cleaning up the block layer handling of how
       we track errors in a request. On top of being a nice cleanup, it also
       shrinks the size of struct request a bit.
    
     - Removal of mg_disk and hd (sorry Linus) by Christoph. The former was
       never used by platforms, and the latter has outlived it's usefulness.
    
     - Various little bug fixes and cleanups from a wide variety of folks.
    
    * 'for-4.12/block' of git://git.kernel.dk/linux-block: (329 commits)
      block: hide badblocks attribute by default
      blk-mq: unify hctx delay_work and run_work
      block: add kblock_mod_delayed_work_on()
      blk-mq: unify hctx delayed_run_work and run_work
      nbd: fix use after free on module unload
      MAINTAINERS: bfq: Add Paolo as maintainer for the BFQ I/O scheduler
      blk-mq-sched: alloate reserved tags out of normal pool
      mtip32xx: use runtime tag to initialize command header
      scsi: Implement blk_mq_ops.show_rq()
      blk-mq: Add blk_mq_ops.show_rq()
      blk-mq: Show operation, cmd_flags and rq_flags names
      blk-mq: Make blk_flags_show() callers append a newline character
      blk-mq: Move the "state" debugfs attribute one level down
      blk-mq: Unregister debugfs attributes earlier
      blk-mq: Only unregister hctxs for which registration succeeded
      blk-mq-debugfs: Rename functions for registering and unregistering the mq directory
      blk-mq: Let blk_mq_debugfs_register() look up the queue name
      blk-mq: Register <dev>/queue/mq after having registered <dev>/queue
      ide-pm: always pass 0 error to ide_complete_rq in ide_do_devset
      ide-pm: always pass 0 error to __blk_end_request_all
      ..

commit 851ea0860986961f32774e34753ad80e5fd545a1
Author: Jan Kara <jack@suse.cz>
Date:   Wed Apr 12 12:24:34 2017 +0200

    cifs: Convert to separately allocated bdi
    
    Allocate struct backing_dev_info separately instead of embedding it
    inside superblock. This unifies handling of bdi among users.
    
    CC: Steve French <sfrench@samba.org>
    CC: linux-cifs@vger.kernel.org
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 15e1db8738ae..502eab6bdbc4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -138,7 +138,12 @@ cifs_read_super(struct super_block *sb)
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
 	sb->s_xattr = cifs_xattr_handlers;
-	sb->s_bdi = &cifs_sb->bdi;
+	rc = super_setup_bdi(sb);
+	if (rc)
+		goto out_no_root;
+	/* tune readahead according to rsize */
+	sb->s_bdi->ra_pages = cifs_sb->rsize / PAGE_SIZE;
+
 	sb->s_blocksize = CIFS_MAX_MSGSIZE;
 	sb->s_blocksize_bits = 14;	/* default 2**14 = CIFS_MAX_MSGSIZE */
 	inode = cifs_root_iget(sb);

commit 6b6cbc1471676402565e958674523d06213b82d7
Merge: ce0718328297 1bf4b1268e66
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Apr 15 21:16:30 2017 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts were simply overlapping changes.  In the net/ipv4/route.c
    case the code had simply moved around a little bit and the same fix
    was made in both 'net' and 'net-next'.
    
    In the net/sched/sch_generic.c case a fix in 'net' happened at
    the same time that a new argument was added to qdisc_hash_add().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 620d8745b35daaf507186c26b40c7ea02aed131e
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Fri Feb 10 16:03:51 2017 +0530

    Introduce cifs_copy_file_range()
    
    The earlier changes to copy range for cifs unintentionally disabled the more
    common form of server side copy.
    
    The patch introduces the file_operations helper cifs_copy_file_range()
    which is used by the syscall copy_file_range. The new file operations
    helper allows us to perform server side copies for SMB2.0 and 2.1
    servers as well as SMB 3.0+ servers which do not support the ioctl
    FSCTL_DUPLICATE_EXTENTS_TO_FILE.
    
    The new helper uses the ioctl FSCTL_SRV_COPYCHUNK_WRITE to perform
    server side copies. The helper is called by vfs_copy_file_range() only
    once an attempt to clone the file using the ioctl
    FSCTL_DUPLICATE_EXTENTS_TO_FILE has failed.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    CC: Stable  <stable@vger.kernel.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 15e1db8738ae..dd3f5fabfdf6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -972,6 +972,86 @@ static int cifs_clone_file_range(struct file *src_file, loff_t off,
 	return rc;
 }
 
+ssize_t cifs_file_copychunk_range(unsigned int xid,
+				struct file *src_file, loff_t off,
+				struct file *dst_file, loff_t destoff,
+				size_t len, unsigned int flags)
+{
+	struct inode *src_inode = file_inode(src_file);
+	struct inode *target_inode = file_inode(dst_file);
+	struct cifsFileInfo *smb_file_src;
+	struct cifsFileInfo *smb_file_target;
+	struct cifs_tcon *src_tcon;
+	struct cifs_tcon *target_tcon;
+	ssize_t rc;
+
+	cifs_dbg(FYI, "copychunk range\n");
+
+	if (src_inode == target_inode) {
+		rc = -EINVAL;
+		goto out;
+	}
+
+	if (!src_file->private_data || !dst_file->private_data) {
+		rc = -EBADF;
+		cifs_dbg(VFS, "missing cifsFileInfo on copy range src file\n");
+		goto out;
+	}
+
+	rc = -EXDEV;
+	smb_file_target = dst_file->private_data;
+	smb_file_src = src_file->private_data;
+	src_tcon = tlink_tcon(smb_file_src->tlink);
+	target_tcon = tlink_tcon(smb_file_target->tlink);
+
+	if (src_tcon->ses != target_tcon->ses) {
+		cifs_dbg(VFS, "source and target of copy not on same server\n");
+		goto out;
+	}
+
+	/*
+	 * Note: cifs case is easier than btrfs since server responsible for
+	 * checks for proper open modes and file type and if it wants
+	 * server could even support copy of range where source = target
+	 */
+	lock_two_nondirectories(target_inode, src_inode);
+
+	cifs_dbg(FYI, "about to flush pages\n");
+	/* should we flush first and last page first */
+	truncate_inode_pages(&target_inode->i_data, 0);
+
+	if (target_tcon->ses->server->ops->copychunk_range)
+		rc = target_tcon->ses->server->ops->copychunk_range(xid,
+			smb_file_src, smb_file_target, off, len, destoff);
+	else
+		rc = -EOPNOTSUPP;
+
+	/* force revalidate of size and timestamps of target file now
+	 * that target is updated on the server
+	 */
+	CIFS_I(target_inode)->time = 0;
+	/* although unlocking in the reverse order from locking is not
+	 * strictly necessary here it is a little cleaner to be consistent
+	 */
+	unlock_two_nondirectories(src_inode, target_inode);
+
+out:
+	return rc;
+}
+
+static ssize_t cifs_copy_file_range(struct file *src_file, loff_t off,
+				struct file *dst_file, loff_t destoff,
+				size_t len, unsigned int flags)
+{
+	unsigned int xid = get_xid();
+	ssize_t rc;
+
+	rc = cifs_file_copychunk_range(xid, src_file, off, dst_file, destoff,
+					len, flags);
+	free_xid(xid);
+	return rc;
+}
+
 const struct file_operations cifs_file_ops = {
 	.read_iter = cifs_loose_read_iter,
 	.write_iter = cifs_file_write_iter,
@@ -984,6 +1064,7 @@ const struct file_operations cifs_file_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
+	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -1001,6 +1082,7 @@ const struct file_operations cifs_file_strict_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
+	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -1018,6 +1100,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
 	.unlocked_ioctl  = cifs_ioctl,
+	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
@@ -1035,6 +1118,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
+	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -1051,6 +1135,7 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
+	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -1067,6 +1152,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
 	.unlocked_ioctl  = cifs_ioctl,
+	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
@@ -1078,6 +1164,7 @@ const struct file_operations cifs_dir_ops = {
 	.release = cifs_closedir,
 	.read    = generic_read_dir,
 	.unlocked_ioctl  = cifs_ioctl,
+	.copy_file_range = cifs_copy_file_range,
 	.clone_file_range = cifs_clone_file_range,
 	.llseek = generic_file_llseek,
 };

commit c6e970a04bdceb7ef1fdbac6be3bd4cd0a0a02bd
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Mar 28 23:45:06 2017 +0200

    net: break include loop netdevice.h, dsa.h, devlink.h
    
    There is an include loop between netdevice.h, dsa.h, devlink.h because
    of NETDEV_ALIGN, making it impossible to use devlink structures in
    dsa.h.
    
    Break this loop by taking dsa.h out of netdevice.h, add a forward
    declaration of dsa_switch_tree and netdev_set_default_ethtool_ops()
    function, which is what netdevice.h requires.
    
    No longer having dsa.h in netdevice.h means the includes in dsa.h no
    longer get included. This breaks a few other files which depend on
    these includes. Add these directly in the affected file.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 15e1db8738ae..8c91f37ac0eb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -37,6 +37,7 @@
 #include <linux/freezer.h>
 #include <linux/namei.h>
 #include <linux/random.h>
+#include <linux/uuid.h>
 #include <linux/xattr.h>
 #include <net/ipv6.h>
 #include "cifsfs.h"

commit 026e93dc0a3eefb0be060bcb9ecd8d7a7fd5c398
Author: Pavel Shilovsky <pshilov@microsoft.com>
Date:   Thu Nov 3 16:47:37 2016 -0700

    CIFS: Encrypt SMB3 requests before sending
    
    This change allows to encrypt packets if it is required by a server
    for SMB sessions or tree connections.
    
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 956dd85d7aef..15e1db8738ae 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1376,6 +1376,8 @@ MODULE_SOFTDEP("pre: nls");
 MODULE_SOFTDEP("pre: aes");
 MODULE_SOFTDEP("pre: cmac");
 MODULE_SOFTDEP("pre: sha256");
+MODULE_SOFTDEP("pre: aead2");
+MODULE_SOFTDEP("pre: ccm");
 #endif /* CONFIG_CIFS_SMB2 */
 module_init(init_cifs)
 module_exit(exit_cifs)

commit b9be76d585d48cb25af8db0d35e1ef9030fbe13a
Author: Jean Delvare <jdelvare@suse.de>
Date:   Wed Jan 25 16:09:10 2017 +0100

    cifs: Add soft dependencies
    
    List soft dependencies of cifs so that mkinitrd and dracut can include
    the required helper modules.
    
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Cc: Steve French <sfrench@samba.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 70f4e65fced2..956dd85d7aef 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1365,5 +1365,17 @@ MODULE_DESCRIPTION
     ("VFS to access servers complying with the SNIA CIFS Specification "
      "e.g. Samba and Windows");
 MODULE_VERSION(CIFS_VERSION);
+MODULE_SOFTDEP("pre: arc4");
+MODULE_SOFTDEP("pre: des");
+MODULE_SOFTDEP("pre: ecb");
+MODULE_SOFTDEP("pre: hmac");
+MODULE_SOFTDEP("pre: md4");
+MODULE_SOFTDEP("pre: md5");
+MODULE_SOFTDEP("pre: nls");
+#ifdef CONFIG_CIFS_SMB2
+MODULE_SOFTDEP("pre: aes");
+MODULE_SOFTDEP("pre: cmac");
+MODULE_SOFTDEP("pre: sha256");
+#endif /* CONFIG_CIFS_SMB2 */
 module_init(init_cifs)
 module_exit(exit_cifs)

commit 1dd5c6b15372c7c127c509afa9a816bad5feed3b
Merge: 3a77fa854477 374402a2a1df
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:37:18 2016 -0800

    Merge branch 'for-next' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull cifs fixes from Steve French:
     "This ncludes various cifs/smb3 bug fixes, mostly for stable as well.
    
      In the next week I expect that Germano will have some reconnection
      fixes, and also I expect to have the remaining pieces of the snapshot
      enablement and SMB3 ACLs, but wanted to get this set of bug fixes in"
    
    * 'for-next' of git://git.samba.org/sfrench/cifs-2.6:
      cifs_get_root shouldn't use path with tree name
      Fix default behaviour for empty domains and add domainauto option
      cifs: use %16phN for formatting md5 sum
      cifs: Fix smbencrypt() to stop pointing a scatterlist at the stack
      CIFS: Fix a possible double locking of mutex during reconnect
      CIFS: Fix a possible memory corruption during reconnect
      CIFS: Fix a possible memory corruption in push locks
      CIFS: Fix missing nls unload in smb2_reconnect()
      CIFS: Decrease verbosity of ioctl call
      SMB3: parsing for new snapshot timestamp mount parm

commit 374402a2a1dfbbee8ab1a5a32ec4887bf8c15d52
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Thu Dec 15 12:31:19 2016 +0530

    cifs_get_root shouldn't use path with tree name
    
    When a server returns the optional flag SMB_SHARE_IS_IN_DFS in response
    to a tree connect, cifs_build_path_to_root() will return a pathname
    which includes the hostname. This causes problems with cifs_get_root()
    which separates each component and does a lookup for each component of
    the path which in this case will incorrectly include looking up the
    hostname component as a path component.
    
    We encountered a problem with dfs shares hosted by a Netapp. When
    connecting to nodes pointed to by the DFS share. The tree connect for
    these nodes return SMB_SHARE_IS_IN_DFS resulting failures in lookup
    in cifs_get_root().
    
    RH bz: 1373153
    The patch was tested against a Netapp simulator and by a user using an
    actual Netapp server.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reported-by: Pierguido Lambri <plambri@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 15261ba464c5..f135f088cdff 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -615,7 +615,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		return dget(sb->s_root);
 
 	full_path = cifs_build_path_to_root(vol, cifs_sb,
-					    cifs_sb_master_tcon(cifs_sb));
+				cifs_sb_master_tcon(cifs_sb), 0);
 	if (full_path == NULL)
 		return ERR_PTR(-ENOMEM);
 

commit dfeef68862edd7d4bafe68ef7aeb5f658ef24bb5
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 9 16:45:04 2016 +0100

    vfs: remove ".readlink = generic_readlink" assignments
    
    If .readlink == NULL implies generic_readlink().
    
    Generated by:
    
    to_del="\.readlink.*=.*generic_readlink"
    for i in `git grep -l $to_del`; do sed -i "/$to_del"/d $i; done
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 15261ba464c5..e6efb9a88598 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -914,7 +914,6 @@ const struct inode_operations cifs_file_inode_ops = {
 };
 
 const struct inode_operations cifs_symlink_inode_ops = {
-	.readlink = generic_readlink,
 	.get_link = cifs_get_link,
 	.permission = cifs_permission,
 	.listxattr = cifs_listxattr,

commit 9593265531fa66177a0547e63abd99907ec0a687
Author: Steve French <smfrench@gmail.com>
Date:   Fri Sep 23 01:36:34 2016 -0500

    CIFS: Add new mount option to set owner uid and gid from special sids in acl
    
    Add "idsfromsid" mount option to indicate to cifs.ko that it should
    try to retrieve the uid and gid owner fields from special sids in the
    ACL if present.  This first patch just adds the parsing for the mount
    option.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by:  Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f963c880c72d..15261ba464c5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -469,6 +469,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",posixpaths");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)
 		seq_puts(s, ",setuids");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UID_FROM_ACL)
+		seq_puts(s, ",idsfromsid");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
 		seq_puts(s, ",serverino");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)

commit cb978ac8b85fa8861352e57fcf8020f7f7bfbd82
Author: Germano Percossi <germano.percossi@citrix.com>
Date:   Fri Sep 30 21:25:24 2016 -0500

    Expose cifs module parameters in sysfs
    
    /sys/module/cifs/parameters should display the three
    other module load time configuration settings for cifs.ko
    
    Signed-off-by: Germano Percossi <germano.percossi@citrix.com>
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d2b2703fed7d..f963c880c72d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -64,15 +64,15 @@ unsigned int global_secflags = CIFSSEC_DEF;
 unsigned int sign_CIFS_PDUs = 1;
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
-module_param(CIFSMaxBufSize, uint, 0);
+module_param(CIFSMaxBufSize, uint, 0444);
 MODULE_PARM_DESC(CIFSMaxBufSize, "Network buffer size (not including header). "
 				 "Default: 16384 Range: 8192 to 130048");
 unsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;
-module_param(cifs_min_rcv, uint, 0);
+module_param(cifs_min_rcv, uint, 0444);
 MODULE_PARM_DESC(cifs_min_rcv, "Network buffers in pool. Default: 4 Range: "
 				"1 to 64");
 unsigned int cifs_min_small = 30;
-module_param(cifs_min_small, uint, 0);
+module_param(cifs_min_small, uint, 0444);
 MODULE_PARM_DESC(cifs_min_small, "Small network buffers in pool. Default: 30 "
 				 "Range: 2 to 256");
 unsigned int cifs_max_pending = CIFS_MAX_REQ;

commit 3afca265b5f53a0b15b79531c13858049505582d
Author: Steve French <smfrench@gmail.com>
Date:   Thu Sep 22 18:58:16 2016 -0500

    Clarify locking of cifs file and tcon structures and make more granular
    
    Remove the global file_list_lock to simplify cifs/smb3 locking and
    have spinlocks that more closely match the information they are
    protecting.
    
    Add new tcon->open_file_lock and file->file_info_lock spinlocks.
    Locks continue to follow a heirachy,
            cifs_socket --> cifs_ses --> cifs_tcon --> cifs_file
    where global tcp_ses_lock still protects socket and cifs_ses, while the
    the newer locks protect the lower level structure's information
    (tcon and cifs_file respectively).
    
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Reviewed-by: Germano Percossi <germano.percossi@citrix.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 978dbf049a77..d2b2703fed7d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1262,7 +1262,6 @@ init_cifs(void)
 	GlobalTotalActiveXid = 0;
 	GlobalMaxActiveXid = 0;
 	spin_lock_init(&cifs_tcp_ses_lock);
-	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
 	get_random_bytes(&cifs_lock_secret, sizeof(cifs_lock_secret));

commit fa70b87cc6641978b20e12cc5d517e9ffc0086d4
Author: Steve French <smfrench@gmail.com>
Date:   Thu Sep 22 00:39:34 2016 -0500

    SMB3: GUIDs should be constructed as random but valid uuids
    
    GUIDs although random, and 16 bytes, need to be generated as
    proper uuids.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by: Aurelien Aptel <aaptel@suse.com>
    Reported-by: David Goebels <davidgoe@microsoft.com>
    CC: Stable <stable@vger.kernel.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cca04e710421..978dbf049a77 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -271,7 +271,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->createtime = 0;
 	cifs_inode->epoch = 0;
 #ifdef CONFIG_CIFS_SMB2
-	get_random_bytes(cifs_inode->lease_key, SMB2_LEASE_KEY_SIZE);
+	generate_random_uuid(cifs_inode->lease_key);
 #endif
 	/*
 	 * Can not set i_flags here - they get immediately overwritten to zero

commit 101105b1717f536ca741f940033996302d4ef191
Merge: 35ff96dfd3c9 3873691e5ab3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 20:16:43 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     ">rename2() work from Miklos + current_time() from Deepa"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: Replace current_fs_time() with current_time()
      fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
      fs: Replace CURRENT_TIME with current_time() for inode timestamps
      fs: proc: Delete inode time initializations in proc_alloc_inode()
      vfs: Add current_time() api
      vfs: add note about i_op->rename changes to porting
      fs: rename "rename2" i_op to "rename"
      vfs: remove unused i_op->rename
      fs: make remaining filesystems use .rename2
      libfs: support RENAME_NOREPLACE in simple_rename()
      fs: support RENAME_NOREPLACE for local filesystems
      ncpfs: fix unused variable warning

commit fd50ecaddf8372a1d96e0daeaac0f93cf04e4d42
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Sep 29 17:48:45 2016 +0200

    vfs: Remove {get,set,remove}xattr inode operations
    
    These inode operations are no longer used; remove them.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 14ae4b8e1a3c..34aac1c73ee1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -901,30 +901,21 @@ const struct inode_operations cifs_dir_inode_ops = {
 	.setattr = cifs_setattr,
 	.symlink = cifs_symlink,
 	.mknod   = cifs_mknod,
-	.setxattr = generic_setxattr,
-	.getxattr = generic_getxattr,
 	.listxattr = cifs_listxattr,
-	.removexattr = generic_removexattr,
 };
 
 const struct inode_operations cifs_file_inode_ops = {
 	.setattr = cifs_setattr,
 	.getattr = cifs_getattr,
 	.permission = cifs_permission,
-	.setxattr = generic_setxattr,
-	.getxattr = generic_getxattr,
 	.listxattr = cifs_listxattr,
-	.removexattr = generic_removexattr,
 };
 
 const struct inode_operations cifs_symlink_inode_ops = {
 	.readlink = generic_readlink,
 	.get_link = cifs_get_link,
 	.permission = cifs_permission,
-	.setxattr = generic_setxattr,
-	.getxattr = generic_getxattr,
 	.listxattr = cifs_listxattr,
-	.removexattr = generic_removexattr,
 };
 
 static int cifs_clone_file_range(struct file *src_file, loff_t off,

commit 2773bf00aeb9bf39e022463272a61dd0ec9f55f4
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 27 11:03:58 2016 +0200

    fs: rename "rename2" i_op to "rename"
    
    Generated patch:
    
    sed -i "s/\.rename2\t/\.rename\t\t/" `git grep -wl rename2`
    sed -i "s/\brename2\b/rename/g" `git grep -wl rename2`
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 14ae4b8e1a3c..7d0e0f78da51 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -896,7 +896,7 @@ const struct inode_operations cifs_dir_inode_ops = {
 	.link = cifs_hardlink,
 	.mkdir = cifs_mkdir,
 	.rmdir = cifs_rmdir,
-	.rename2 = cifs_rename2,
+	.rename = cifs_rename2,
 	.permission = cifs_permission,
 	.setattr = cifs_setattr,
 	.symlink = cifs_symlink,

commit 348c1bfa84dfc47da1f1234b7f2bf09fa798edea
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Fri Jul 29 22:38:21 2016 +0100

    Move check for prefix path to within cifs_get_root()
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Tested-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cc9cdab52dab..14ae4b8e1a3c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -609,6 +609,9 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	char *s, *p;
 	char sep;
 
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)
+		return dget(sb->s_root);
+
 	full_path = cifs_build_path_to_root(vol, cifs_sb,
 					    cifs_sb_master_tcon(cifs_sb));
 	if (full_path == NULL)
@@ -731,11 +734,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 		sb->s_flags |= MS_ACTIVE;
 	}
 
-	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)
-		root = dget(sb->s_root);
-	else
-		root = cifs_get_root(volume_info, sb);
-
+	root = cifs_get_root(volume_info, sb);
 	if (IS_ERR(root))
 		goto out_super;
 

commit 4214ebf4654798309364d0c678b799e402f38288
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Fri Jul 29 22:38:19 2016 +0100

    Fix memory leaks in cifs_do_mount()
    
    Fix memory leaks introduced by the patch
    fs/cifs: make share unaccessible at root level mountable
    
    Also move allocation of cifs_sb->prepath to cifs_setup_cifs_sb().
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Tested-by: Aurelien Aptel <aaptel@suse.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 6bbec5e784cd..cc9cdab52dab 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -686,26 +686,22 @@ cifs_do_mount(struct file_system_type *fs_type,
 	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
 	if (cifs_sb->mountdata == NULL) {
 		root = ERR_PTR(-ENOMEM);
-		goto out_cifs_sb;
+		goto out_free;
 	}
 
-	if (volume_info->prepath) {
-		cifs_sb->prepath = kstrdup(volume_info->prepath, GFP_KERNEL);
-		if (cifs_sb->prepath == NULL) {
-			root = ERR_PTR(-ENOMEM);
-			goto out_cifs_sb;
-		}
+	rc = cifs_setup_cifs_sb(volume_info, cifs_sb);
+	if (rc) {
+		root = ERR_PTR(rc);
+		goto out_free;
 	}
 
-	cifs_setup_cifs_sb(volume_info, cifs_sb);
-
 	rc = cifs_mount(cifs_sb, volume_info);
 	if (rc) {
 		if (!(flags & MS_SILENT))
 			cifs_dbg(VFS, "cifs_mount failed w/return code = %d\n",
 				 rc);
 		root = ERR_PTR(rc);
-		goto out_mountdata;
+		goto out_free;
 	}
 
 	mnt_data.vol = volume_info;
@@ -752,9 +748,9 @@ cifs_do_mount(struct file_system_type *fs_type,
 	cifs_cleanup_volume_info(volume_info);
 	return root;
 
-out_mountdata:
+out_free:
+	kfree(cifs_sb->prepath);
 	kfree(cifs_sb->mountdata);
-out_cifs_sb:
 	kfree(cifs_sb);
 out_nls:
 	unload_nls(volume_info->local_nls);

commit a6b5058fafdf508904bbf16c29b24042cef3c496
Author: Aurelien Aptel <aaptel@suse.com>
Date:   Wed May 25 19:59:09 2016 +0200

    fs/cifs: make share unaccessible at root level mountable
    
    if, when mounting //HOST/share/sub/dir/foo we can query /sub/dir/foo but
    not any of the path components above:
    
    - store the /sub/dir/foo prefix in the cifs super_block info
    - in the superblock, set root dentry to the subpath dentry (instead of
      the share root)
    - set a flag in the superblock to remember it
    - use prefixpath when building path from a dentry
    
    fixes bso#8950
    
    Signed-off-by: Aurelien Aptel <aaptel@suse.com>
    CC: Stable <stable@vger.kernel.org>
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5d841f39c4b7..6bbec5e784cd 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -689,6 +689,14 @@ cifs_do_mount(struct file_system_type *fs_type,
 		goto out_cifs_sb;
 	}
 
+	if (volume_info->prepath) {
+		cifs_sb->prepath = kstrdup(volume_info->prepath, GFP_KERNEL);
+		if (cifs_sb->prepath == NULL) {
+			root = ERR_PTR(-ENOMEM);
+			goto out_cifs_sb;
+		}
+	}
+
 	cifs_setup_cifs_sb(volume_info, cifs_sb);
 
 	rc = cifs_mount(cifs_sb, volume_info);
@@ -727,7 +735,11 @@ cifs_do_mount(struct file_system_type *fs_type,
 		sb->s_flags |= MS_ACTIVE;
 	}
 
-	root = cifs_get_root(volume_info, sb);
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_USE_PREFIX_PATH)
+		root = dget(sb->s_root);
+	else
+		root = cifs_get_root(volume_info, sb);
+
 	if (IS_ERR(root))
 		goto out_super;
 

commit 3d22462ae915743f3be5bf1ab3d4a6b72c2bb6c9
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Tue May 24 06:27:44 2016 -0400

    cifs: stuff the fl_owner into "pid" field in the lock request
    
    Right now, we send the tgid cross the wire. What we really want to send
    though is a hashed fl_owner_t since samba treats this field as a generic
    lockowner.
    
    It turns out that because we enforce and release locks locally before
    they are ever sent to the server, this patch makes no difference in
    behavior. Still, setting OFD locks on the server using the process
    pid seems wrong, so I think this patch still makes sense.
    
    Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Acked-by: Pavel Shilovsky <pshilovsky@samba.org>
    Acked-by: Sachin Prabhu <sprabhu@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5d8b7edf8a8f..5d841f39c4b7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -87,6 +87,7 @@ extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
+__u32 cifs_lock_secret;
 
 /*
  * Bumps refcount for cifs super block.
@@ -1266,6 +1267,8 @@ init_cifs(void)
 	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
+	get_random_bytes(&cifs_lock_secret, sizeof(cifs_lock_secret));
+
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
 		cifs_dbg(FYI, "cifs_max_pending set to min of 2\n");

commit 48a77aa7e20557319205f9bd4cc02d4b67b5f761
Author: Steve French <smfrench@gmail.com>
Date:   Wed May 18 20:48:32 2016 -0500

    CIFS: Remove some obsolete comments
    
    Remove some obsolete comments in the cifs inode_operations
    structs that were pointed out by Stephen Rothwell.
    
    CC: Stephen Rothwell <sfr@canb.auug.org.au>
    CC: Al Viro <viro@zeniv.linux.org.uk>
    Reviewed-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 67f622df0858..5d8b7edf8a8f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -890,7 +890,6 @@ const struct inode_operations cifs_dir_inode_ops = {
 	.rmdir = cifs_rmdir,
 	.rename2 = cifs_rename2,
 	.permission = cifs_permission,
-/*	revalidate:cifs_revalidate,   */
 	.setattr = cifs_setattr,
 	.symlink = cifs_symlink,
 	.mknod   = cifs_mknod,
@@ -901,9 +900,8 @@ const struct inode_operations cifs_dir_inode_ops = {
 };
 
 const struct inode_operations cifs_file_inode_ops = {
-/*	revalidate:cifs_revalidate, */
 	.setattr = cifs_setattr,
-	.getattr = cifs_getattr, /* do we need this anymore? */
+	.getattr = cifs_getattr,
 	.permission = cifs_permission,
 	.setxattr = generic_setxattr,
 	.getxattr = generic_getxattr,
@@ -915,9 +913,6 @@ const struct inode_operations cifs_symlink_inode_ops = {
 	.readlink = generic_readlink,
 	.get_link = cifs_get_link,
 	.permission = cifs_permission,
-	/* BB add the following two eventually */
-	/* revalidate: cifs_revalidate,
-	   setattr:    cifs_notify_change, *//* BB do we need notify change */
 	.setxattr = generic_setxattr,
 	.getxattr = generic_getxattr,
 	.listxattr = cifs_listxattr,

commit b74cb9a80268be5c80cf4c87c74debf0ff2129ac
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue May 17 18:20:13 2016 -0500

    cifs: Create dedicated keyring for spnego operations
    
    The session key is the default keyring set for request_key operations.
    This session key is revoked when the user owning the session logs out.
    Any long running daemon processes started by this session ends up with
    revoked session keyring which prevents these processes from using the
    request_key mechanism from obtaining the krb5 keys.
    
    The problem has been reported by a large number of autofs users. The
    problem is also seen with multiuser mounts where the share may be used
    by processes run by a user who has since logged out. A reproducer using
    automount is available on the Red Hat bz.
    
    The patch creates a new keyring which is used to cache cifs spnego
    upcalls.
    
    Red Hat bz: 1267754
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reported-by: Scott Mayhew <smayhew@redhat.com>
    Reviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 08fa36e5b2bc..67f622df0858 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1303,7 +1303,7 @@ init_cifs(void)
 		goto out_destroy_mids;
 
 #ifdef CONFIG_CIFS_UPCALL
-	rc = register_key_type(&cifs_spnego_key_type);
+	rc = init_cifs_spnego();
 	if (rc)
 		goto out_destroy_request_bufs;
 #endif /* CONFIG_CIFS_UPCALL */
@@ -1326,7 +1326,7 @@ init_cifs(void)
 out_register_key_type:
 #endif
 #ifdef CONFIG_CIFS_UPCALL
-	unregister_key_type(&cifs_spnego_key_type);
+	exit_cifs_spnego();
 out_destroy_request_bufs:
 #endif
 	cifs_destroy_request_bufs();

commit 681750c0468185f92acb8080c13f26a19cb4ee0d
Merge: 820c687b70ae a9ae008f407b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 17 14:35:45 2016 -0700

    Merge branch 'for-cifs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull cifs xattr updates from Al Viro:
     "This is the remaining parts of the xattr work - the cifs bits"
    
    * 'for-cifs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      cifs: Switch to generic xattr handlers
      cifs: Fix removexattr for os2.* xattrs
      cifs: Check for equality with ACL_TYPE_ACCESS and ACL_TYPE_DEFAULT
      cifs: Fix xattr name checks

commit 3125d2650cae97d8f313ab696cd0ed66916e767a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 20 17:40:47 2016 -0400

    cifs: switch to ->iterate_shared()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 89201564c346..aadb59388e90 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1083,7 +1083,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 };
 
 const struct file_operations cifs_dir_ops = {
-	.iterate = cifs_readdir,
+	.iterate_shared = cifs_readdir,
 	.release = cifs_closedir,
 	.read    = generic_read_dir,
 	.unlocked_ioctl  = cifs_ioctl,

commit a9ae008f407b50fc92ef19588d2ea2be13a7f5e2
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Apr 22 12:11:38 2016 +0200

    cifs: Switch to generic xattr handlers
    
    Use xattr handlers for resolving attribute names.  The amount of setup
    code required on cifs is nontrivial, so use the same get and set
    functions for all handlers, with switch statements for the different
    types of attributes in them.
    
    The set_EA handler can handle NULL values, so we don't need a separate
    removexattr function anymore.  Remove the cifs_dbg statements related to
    xattr name resolution; they don't add much.  Don't build xattr.o when
    CONFIG_CIFS_XATTR is not defined.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1d86fc620e5c..43cc522b11e4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -37,6 +37,7 @@
 #include <linux/freezer.h>
 #include <linux/namei.h>
 #include <linux/random.h>
+#include <linux/xattr.h>
 #include <net/ipv6.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
@@ -135,6 +136,7 @@ cifs_read_super(struct super_block *sb)
 
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
+	sb->s_xattr = cifs_xattr_handlers;
 	sb->s_bdi = &cifs_sb->bdi;
 	sb->s_blocksize = CIFS_MAX_MSGSIZE;
 	sb->s_blocksize_bits = 14;	/* default 2**14 = CIFS_MAX_MSGSIZE */
@@ -892,12 +894,10 @@ const struct inode_operations cifs_dir_inode_ops = {
 	.setattr = cifs_setattr,
 	.symlink = cifs_symlink,
 	.mknod   = cifs_mknod,
-#ifdef CONFIG_CIFS_XATTR
-	.setxattr = cifs_setxattr,
-	.getxattr = cifs_getxattr,
+	.setxattr = generic_setxattr,
+	.getxattr = generic_getxattr,
 	.listxattr = cifs_listxattr,
-	.removexattr = cifs_removexattr,
-#endif
+	.removexattr = generic_removexattr,
 };
 
 const struct inode_operations cifs_file_inode_ops = {
@@ -905,12 +905,10 @@ const struct inode_operations cifs_file_inode_ops = {
 	.setattr = cifs_setattr,
 	.getattr = cifs_getattr, /* do we need this anymore? */
 	.permission = cifs_permission,
-#ifdef CONFIG_CIFS_XATTR
-	.setxattr = cifs_setxattr,
-	.getxattr = cifs_getxattr,
+	.setxattr = generic_setxattr,
+	.getxattr = generic_getxattr,
 	.listxattr = cifs_listxattr,
-	.removexattr = cifs_removexattr,
-#endif
+	.removexattr = generic_removexattr,
 };
 
 const struct inode_operations cifs_symlink_inode_ops = {
@@ -920,12 +918,10 @@ const struct inode_operations cifs_symlink_inode_ops = {
 	/* BB add the following two eventually */
 	/* revalidate: cifs_revalidate,
 	   setattr:    cifs_notify_change, *//* BB do we need notify change */
-#ifdef CONFIG_CIFS_XATTR
-	.setxattr = cifs_setxattr,
-	.getxattr = cifs_getxattr,
+	.setxattr = generic_setxattr,
+	.getxattr = generic_getxattr,
 	.listxattr = cifs_listxattr,
-	.removexattr = cifs_removexattr,
-#endif
+	.removexattr = generic_removexattr,
 };
 
 static int cifs_clone_file_range(struct file *src_file, loff_t off,

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1d86fc620e5c..89201564c346 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -962,7 +962,7 @@ static int cifs_clone_file_range(struct file *src_file, loff_t off,
 	cifs_dbg(FYI, "about to flush pages\n");
 	/* should we flush first and last page first */
 	truncate_inode_pages_range(&target_inode->i_data, destoff,
-				   PAGE_CACHE_ALIGN(destoff + len)-1);
+				   PAGE_ALIGN(destoff + len)-1);
 
 	if (target_tcon->ses->server->ops->duplicate_extents)
 		rc = target_tcon->ses->server->ops->duplicate_extents(xid,

commit 3c2de27d793bf55167804fc47954711e94f27be7
Merge: 51b3eae8dbe5 8b23a8ce1094
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 19 18:52:29 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
    
     - Preparations of parallel lookups (the remaining main obstacle is the
       need to move security_d_instantiate(); once that becomes safe, the
       rest will be a matter of rather short series local to fs/*.c
    
     - preadv2/pwritev2 series from Christoph
    
     - assorted fixes
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (32 commits)
      splice: handle zero nr_pages in splice_to_pipe()
      vfs: show_vfsstat: do not ignore errors from show_devname method
      dcache.c: new helper: __d_add()
      don't bother with __d_instantiate(dentry, NULL)
      untangle fsnotify_d_instantiate() a bit
      uninline d_add()
      replace d_add_unique() with saner primitive
      quota: use lookup_one_len_unlocked()
      cifs_get_root(): use lookup_one_len_unlocked()
      nfs_lookup: don't bother with d_instantiate(dentry, NULL)
      kill dentry_unhash()
      ceph_fill_trace(): don't bother with d_instantiate(dn, NULL)
      autofs4: don't bother with d_instantiate(dentry, NULL) in ->lookup()
      configfs: move d_rehash() into configfs_create() for regular files
      ceph: don't bother with d_rehash() in splice_dentry()
      namei: teach lookup_slow() to skip revalidate
      namei: massage lookup_slow() to be usable by lookup_one_len_unlocked()
      lookup_one_len_unlocked(): use lookup_dcache()
      namei: simplify invalidation logics in lookup_dcache()
      namei: change calling conventions for lookup_{fast,slow} and follow_managed()
      ...

commit 1404297ebf76fd91a41de215fc8c94c2619e5fdb
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Mar 17 14:22:54 2016 -0700

    lib: update single-char callers of strtobool()
    
    Some callers of strtobool() were passing a pointer to unterminated
    strings.  In preparation of adding multi-character processing to
    kstrtobool(), update the callers to not pass single-character pointers,
    and switch to using the new kstrtobool_from_user() helper where
    possible.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Amitkumar Karwar <akarwar@marvell.com>
    Cc: Nishant Sarmukadam <nishants@marvell.com>
    Cc: Kalle Valo <kvalo@codeaurora.org>
    Cc: Steve French <sfrench@samba.org>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2eea40353e60..fd8805de6a50 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -54,10 +54,10 @@
 #endif
 
 int cifsFYI = 0;
-int traceSMB = 0;
+bool traceSMB;
 bool enable_oplocks = true;
-unsigned int linuxExtEnabled = 1;
-unsigned int lookupCacheEnabled = 1;
+bool linuxExtEnabled = true;
+bool lookupCacheEnabled = true;
 unsigned int global_secflags = CIFSSEC_DEF;
 /* unsigned int ntlmv2_support = 0; */
 unsigned int sign_CIFS_PDUs = 1;

commit 85f40482bc175f14f63d78fe482ef1826cf3913d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 7 23:20:44 2016 -0500

    cifs_get_root(): use lookup_one_len_unlocked()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c48ca13673e3..09b1db2cac31 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -642,9 +642,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		while (*s && *s != sep)
 			s++;
 
-		inode_lock(dir);
-		child = lookup_one_len(p, dentry, s - p);
-		inode_unlock(dir);
+		child = lookup_one_len_unlocked(p, dentry, s - p);
 		dput(dentry);
 		dentry = child;
 	} while (!IS_ERR(dentry));

commit 9589995e46d89c70c6fa4723c5f3e5ec04c3c3e3
Author: Steve French <smfrench@gmail.com>
Date:   Mon Feb 29 01:02:11 2016 -0600

    CIFS: Fix duplicate line introduced by clone_file_range patch
    
    Commit 04b38d601239b4 ("vfs: pull btrfs clone API to vfs layer")
    added a duplicated line (in cifsfs.c) which causes a sparse compile
    warning.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c48ca13673e3..2eea40353e60 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1013,7 +1013,6 @@ const struct file_operations cifs_file_strict_ops = {
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
 	.clone_file_range = cifs_clone_file_range,
-	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };

commit 772950ed21c36f4157ff34e7d10fb61975f64558
Merge: 587198ba5206 01b9b0b28626
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 24 12:31:12 2016 -0800

    Merge branch 'for-next' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull SMB3 fixes from Steve French:
     "A collection of CIFS/SMB3 fixes.
    
      It includes a couple bug fixes, a few for improved debugging of
      cifs.ko and some improvements to the way cifs does key generation.
    
      I do have some additional bug fixes I expect in the next week or two
      (to address a problem found by xfstest, and some fixes for SMB3.11
      dialect, and a couple patches that just came in yesterday that I am
      reviewing)"
    
    * 'for-next' of git://git.samba.org/sfrench/cifs-2.6:
      cifs_dbg() outputs an uninitialized buffer in cifs_readdir()
      cifs: fix race between call_async() and reconnect()
      Prepare for encryption support (first part). Add decryption and encryption key generation. Thanks to Metze for helping with this.
      cifs: Allow using O_DIRECT with cache=loose
      cifs: Make echo interval tunable
      cifs: Check uniqueid for SMB2+ and return -ESTALE if necessary
      Print IP address of unresponsive server
      cifs: Ratelimit kernel log messages

commit 5955102c9984fa081b2d570cfac75c97eecf8f3b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 22 15:40:57 2016 -0500

    wrappers for ->i_mutex access
    
    parallel to mutex_{lock,unlock,trylock,is_locked,lock_nested},
    inode_foo(inode) being mutex_foo(&inode->i_mutex).
    
    Please, use those for access to ->i_mutex; over the coming cycle
    ->i_mutex will become rwsem, with ->lookup() done with it held
    only shared.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c4c1169814b2..e24ca79b140c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -640,9 +640,9 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		while (*s && *s != sep)
 			s++;
 
-		mutex_lock(&dir->i_mutex);
+		inode_lock(dir);
 		child = lookup_one_len(p, dentry, s - p);
-		mutex_unlock(&dir->i_mutex);
+		inode_unlock(dir);
 		dput(dentry);
 		dentry = child;
 	} while (!IS_ERR(dentry));

commit 5d097056c9a017a3b720849efb5432f37acabbac
Author: Vladimir Davydov <vdavydov@virtuozzo.com>
Date:   Thu Jan 14 15:18:21 2016 -0800

    kmemcg: account certain kmem allocations to memcg
    
    Mark those kmem allocations that are known to be easily triggered from
    userspace as __GFP_ACCOUNT/SLAB_ACCOUNT, which makes them accounted to
    memcg.  For the list, see below:
    
     - threadinfo
     - task_struct
     - task_delay_info
     - pid
     - cred
     - mm_struct
     - vm_area_struct and vm_region (nommu)
     - anon_vma and anon_vma_chain
     - signal_struct
     - sighand_struct
     - fs_struct
     - files_struct
     - fdtable and fdtable->full_fds_bits
     - dentry and external_name
     - inode for all filesystems. This is the most tedious part, because
       most filesystems overwrite the alloc_inode method.
    
    The list is far from complete, so feel free to add more objects.
    Nevertheless, it should be close to "account everything" approach and
    keep most workloads within bounds.  Malevolent users will be able to
    breach the limit, but this was possible even with the former "account
    everything" approach (simply because it did not account everything in
    fact).
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Vladimir Davydov <vdavydov@virtuozzo.com>
    Acked-by: Johannes Weiner <hannes@cmpxchg.org>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b7fcb3151103..c4c1169814b2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1092,7 +1092,7 @@ cifs_init_inodecache(void)
 	cifs_inode_cachep = kmem_cache_create("cifs_inode_cache",
 					      sizeof(struct cifsInodeInfo),
 					      0, (SLAB_RECLAIM_ACCOUNT|
-						SLAB_MEM_SPREAD),
+						SLAB_MEM_SPREAD|SLAB_ACCOUNT),
 					      cifs_init_once);
 	if (cifs_inode_cachep == NULL)
 		return -ENOMEM;

commit 882137c4d64175e2bb38cd842e25d54e6de31da8
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Wed Dec 2 14:46:07 2015 +0000

    cifs: Allow using O_DIRECT with cache=loose
    
    Currently O_DIRECT is supported with cache=none and cache=strict, but
    not cache=loose. Add support for using O_DIRECT when mounted with
    cache=loose.
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 53e343d073bb..565a4c0d2ee9 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -754,6 +754,9 @@ cifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 	ssize_t rc;
 	struct inode *inode = file_inode(iocb->ki_filp);
 
+	if (iocb->ki_filp->f_flags & O_DIRECT)
+		return cifs_user_readv(iocb, iter);
+
 	rc = cifs_revalidate_mapping(inode);
 	if (rc)
 		return rc;
@@ -768,6 +771,18 @@ static ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 	ssize_t written;
 	int rc;
 
+	if (iocb->ki_filp->f_flags & O_DIRECT) {
+		written = cifs_user_writev(iocb, from);
+		if (written > 0 && CIFS_CACHE_READ(cinode)) {
+			cifs_zap_mapping(inode);
+			cifs_dbg(FYI,
+				 "Set no oplock for inode=%p after a write operation\n",
+				 inode);
+			cinode->oplock = 0;
+		}
+		return written;
+	}
+
 	written = cifs_get_writer(cinode);
 	if (written)
 		return written;

commit adfeb3e00e8e1b9fb4ad19eb7367e7c272d16003
Author: Steve French <smfrench@gmail.com>
Date:   Fri Dec 18 12:31:36 2015 -0600

    cifs: Make echo interval tunable
    
    Currently the echo interval is set to 60 seconds using a macro. This
    setting determines the interval at which echo requests are sent to the
    server on an idling connection. This setting also affects the time
    required for a connection to an unresponsive server to timeout.
    
    Making this setting a tunable allows users to control the echo interval
    times as well as control the time after which the connecting to an
    unresponsive server times out.
    
    To set echo interval, pass the echo_interval=n mount option.
    
    Version four of the patch.
    v2: Change MIN and MAX timeout values
    v3: Remove incorrect comment in cifs_get_tcp_session
    v4: Fix bug in setting echo_intervalw
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b7fcb3151103..53e343d073bb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -507,6 +507,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 
 	seq_printf(s, ",rsize=%u", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%u", cifs_sb->wsize);
+	seq_printf(s, ",echo_interval=%lu",
+			tcon->ses->server->echo_interval / HZ);
 	/* convert actimeo and display it in seconds */
 	seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
 

commit fce205e9da8e063aa1cf3d6583c1a9ed2b82f3f0
Merge: 065019a38fea 2b3909f8a7fe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 12 16:30:34 2016 -0800

    Merge branch 'work.copy_file_range' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs copy_file_range updates from Al Viro:
     "Several series around copy_file_range/CLONE"
    
    * 'work.copy_file_range' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      btrfs: use new dedupe data function pointer
      vfs: hoist the btrfs deduplication ioctl to the vfs
      vfs: wire up compat ioctl for CLONE/CLONE_RANGE
      cifs: avoid unused variable and label
      nfsd: implement the NFSv4.2 CLONE operation
      nfsd: Pass filehandle to nfs4_preprocess_stateid_op()
      vfs: pull btrfs clone API to vfs layer
      locks: new locks_mandatory_area calling convention
      vfs: Add vfs_copy_file_range() support for pagecache copies
      btrfs: add .copy_file_range file operation
      x86: add sys_copy_file_range to syscall tables
      vfs: add copy_file_range syscall and vfs helper

commit fceef393a538134f03b778c5d2519e670269342f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 29 15:58:39 2015 -0500

    switch ->get_link() to delayed_call, kill ->put_link()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4593f41678ef..90e4e2b398b6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -901,7 +901,6 @@ const struct inode_operations cifs_file_inode_ops = {
 const struct inode_operations cifs_symlink_inode_ops = {
 	.readlink = generic_readlink,
 	.get_link = cifs_get_link,
-	.put_link = kfree_put_link,
 	.permission = cifs_permission,
 	/* BB add the following two eventually */
 	/* revalidate: cifs_revalidate,

commit 6b2553918d8b4e6de9853fd6315bec7271a2e592
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 17 10:20:54 2015 -0500

    replace ->follow_link() with new method that could stay in RCU mode
    
    new method: ->get_link(); replacement of ->follow_link().  The differences
    are:
            * inode and dentry are passed separately
            * might be called both in RCU and non-RCU mode;
    the former is indicated by passing it a NULL dentry.
            * when called that way it isn't allowed to block
    and should return ERR_PTR(-ECHILD) if it needs to be called
    in non-RCU mode.
    
    It's a flagday change - the old method is gone, all in-tree instances
    converted.  Conversion isn't hard; said that, so far very few instances
    do not immediately bail out when called in RCU mode.  That'll change
    in the next commits.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cbc0f4bca0c0..4593f41678ef 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -900,7 +900,7 @@ const struct inode_operations cifs_file_inode_ops = {
 
 const struct inode_operations cifs_symlink_inode_ops = {
 	.readlink = generic_readlink,
-	.follow_link = cifs_follow_link,
+	.get_link = cifs_get_link,
 	.put_link = kfree_put_link,
 	.permission = cifs_permission,
 	/* BB add the following two eventually */

commit 8c36e9dfe7527665e286c3ac970c3fb327e6ab24
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Dec 8 16:18:51 2015 +0100

    cifs: avoid unused variable and label
    
    The newly introduced cifs_clone_file_range() function produces
    two harmless compile-time warnings:
    
    cifsfs.c: In function 'cifs_clone_file_range':
    cifsfs.c:963:1: warning: label 'out_unlock' defined but not used [-Wunused-label]
    cifsfs.c:924:20: warning: unused variable 'src_tcon' [-Wunused-variable]
    
    In both cases, removing the extraneous line avoids the warning.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: c6f2a1e2e5f8 ("vfs: pull btrfs clone API to vfs layer")
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e9b978f2e114..fd3643451dd5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -921,7 +921,6 @@ static int cifs_clone_file_range(struct file *src_file, loff_t off,
 	struct inode *target_inode = file_inode(dst_file);
 	struct cifsFileInfo *smb_file_src = src_file->private_data;
 	struct cifsFileInfo *smb_file_target = dst_file->private_data;
-	struct cifs_tcon *src_tcon = tlink_tcon(smb_file_src->tlink);
 	struct cifs_tcon *target_tcon = tlink_tcon(smb_file_target->tlink);
 	unsigned int xid;
 	int rc;
@@ -960,7 +959,6 @@ static int cifs_clone_file_range(struct file *src_file, loff_t off,
 	/* force revalidate of size and timestamps of target file now
 	   that target is updated on the server */
 	CIFS_I(target_inode)->time = 0;
-out_unlock:
 	/* although unlocking in the reverse order from locking is not
 	   strictly necessary here it is a little cleaner to be consistent */
 	unlock_two_nondirectories(src_inode, target_inode);

commit 04b38d601239b4d9be641b412cf4b7456a041c67
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 3 12:59:50 2015 +0100

    vfs: pull btrfs clone API to vfs layer
    
    The btrfs clone ioctls are now adopted by other file systems, with NFS
    and CIFS already having support for them, and XFS being under active
    development.  To avoid growth of various slightly incompatible
    implementations, add one to the VFS.  Note that clones are different from
    file copies in several ways:
    
     - they are atomic vs other writers
     - they support whole file clones
     - they support 64-bit legth clones
     - they do not allow partial success (aka short writes)
     - clones are expected to be a fast metadata operation
    
    Because of that it would be rather cumbersome to try to piggyback them on
    top of the recent clone_file_range infrastructure.  The converse isn't
    true and the clone_file_range system call could try clone file range as
    a first attempt to copy, something that further patches will enable.
    
    Based on earlier work from Peng Tao.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cbc0f4bca0c0..e9b978f2e114 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -914,6 +914,61 @@ const struct inode_operations cifs_symlink_inode_ops = {
 #endif
 };
 
+static int cifs_clone_file_range(struct file *src_file, loff_t off,
+		struct file *dst_file, loff_t destoff, u64 len)
+{
+	struct inode *src_inode = file_inode(src_file);
+	struct inode *target_inode = file_inode(dst_file);
+	struct cifsFileInfo *smb_file_src = src_file->private_data;
+	struct cifsFileInfo *smb_file_target = dst_file->private_data;
+	struct cifs_tcon *src_tcon = tlink_tcon(smb_file_src->tlink);
+	struct cifs_tcon *target_tcon = tlink_tcon(smb_file_target->tlink);
+	unsigned int xid;
+	int rc;
+
+	cifs_dbg(FYI, "clone range\n");
+
+	xid = get_xid();
+
+	if (!src_file->private_data || !dst_file->private_data) {
+		rc = -EBADF;
+		cifs_dbg(VFS, "missing cifsFileInfo on copy range src file\n");
+		goto out;
+	}
+
+	/*
+	 * Note: cifs case is easier than btrfs since server responsible for
+	 * checks for proper open modes and file type and if it wants
+	 * server could even support copy of range where source = target
+	 */
+	lock_two_nondirectories(target_inode, src_inode);
+
+	if (len == 0)
+		len = src_inode->i_size - off;
+
+	cifs_dbg(FYI, "about to flush pages\n");
+	/* should we flush first and last page first */
+	truncate_inode_pages_range(&target_inode->i_data, destoff,
+				   PAGE_CACHE_ALIGN(destoff + len)-1);
+
+	if (target_tcon->ses->server->ops->duplicate_extents)
+		rc = target_tcon->ses->server->ops->duplicate_extents(xid,
+			smb_file_src, smb_file_target, off, len, destoff);
+	else
+		rc = -EOPNOTSUPP;
+
+	/* force revalidate of size and timestamps of target file now
+	   that target is updated on the server */
+	CIFS_I(target_inode)->time = 0;
+out_unlock:
+	/* although unlocking in the reverse order from locking is not
+	   strictly necessary here it is a little cleaner to be consistent */
+	unlock_two_nondirectories(src_inode, target_inode);
+out:
+	free_xid(xid);
+	return rc;
+}
+
 const struct file_operations cifs_file_ops = {
 	.read_iter = cifs_loose_read_iter,
 	.write_iter = cifs_file_write_iter,
@@ -926,6 +981,7 @@ const struct file_operations cifs_file_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
+	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -942,6 +998,8 @@ const struct file_operations cifs_file_strict_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
+	.clone_file_range = cifs_clone_file_range,
+	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -958,6 +1016,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
 	.unlocked_ioctl  = cifs_ioctl,
+	.clone_file_range = cifs_clone_file_range,
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -974,6 +1033,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
+	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -989,6 +1049,7 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 	.unlocked_ioctl	= cifs_ioctl,
+	.clone_file_range = cifs_clone_file_range,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -1004,6 +1065,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
 	.unlocked_ioctl  = cifs_ioctl,
+	.clone_file_range = cifs_clone_file_range,
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -1014,6 +1076,7 @@ const struct file_operations cifs_dir_ops = {
 	.release = cifs_closedir,
 	.read    = generic_read_dir,
 	.unlocked_ioctl  = cifs_ioctl,
+	.clone_file_range = cifs_clone_file_range,
 	.llseek = generic_file_llseek,
 };
 

commit 7b52e2793a58af61b5d349c2c080437a437a4edb
Author: Steve French <smfrench@gmail.com>
Date:   Mon Nov 9 08:59:45 2015 -0600

    Allow copy offload (CopyChunk) across shares
    
    FSCTL_SRV_COPYCHUNK_WRITE only requires that the source and target
    be on the same server (not the same volume or same share),
    so relax the existing check (which required them to be on
    the same share). Note that this works to Windows (and presumably
    most other NAS) but Samba requires that the source
    and target be on the same share.  Moving a file across
    shares is a common use case and can be very heplful (100x faster).
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by: David Disseldorp <ddiss@samba.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f578ef9bc1f4..cbc0f4bca0c0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -925,9 +925,7 @@ const struct file_operations cifs_file_ops = {
 	.mmap  = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
-#ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl	= cifs_ioctl,
-#endif /* CONFIG_CIFS_POSIX */
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -943,9 +941,7 @@ const struct file_operations cifs_file_strict_ops = {
 	.mmap = cifs_file_strict_mmap,
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
-#ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl	= cifs_ioctl,
-#endif /* CONFIG_CIFS_POSIX */
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -961,9 +957,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.flush = cifs_flush,
 	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
-#ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl  = cifs_ioctl,
-#endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
@@ -979,9 +973,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.mmap  = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
-#ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl	= cifs_ioctl,
-#endif /* CONFIG_CIFS_POSIX */
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -996,9 +988,7 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 	.mmap = cifs_file_strict_mmap,
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
-#ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl	= cifs_ioctl,
-#endif /* CONFIG_CIFS_POSIX */
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,
 };
@@ -1013,9 +1003,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.flush = cifs_flush,
 	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
-#ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl  = cifs_ioctl,
-#endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
 	.fallocate = cifs_fallocate,

commit 592fafe644bf3a48b9e00e182a67d301493634fc
Author: Steve French <smfrench@gmail.com>
Date:   Tue Nov 3 10:08:53 2015 -0600

    Add resilienthandles mount parm
    
    Since many servers (Windows clients, and non-clustered servers) do not
    support persistent handles but do support resilient handles, allow
    the user to specify a mount option "resilienthandles" in order
    to get more reliable connections and less chance of data loss
    (at least when SMB2.1 or later).  Default resilient handle
    timeout (120 seconds to recent Windows server) is used.
    
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <steve.french@primarydata.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 13302e94fee3..f578ef9bc1f4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -456,6 +456,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",hard");
 	if (tcon->use_persistent)
 		seq_puts(s, ",persistenthandles");
+	else if (tcon->use_resilient)
+		seq_puts(s, ",resilienthandles");
 	if (tcon->unix_ext)
 		seq_puts(s, ",unix");
 	else

commit f16dfa7cd1b588e5d7ef4b5a19ee579f11b7a41f
Author: Steve French <smfrench@gmail.com>
Date:   Wed Sep 30 21:07:59 2015 -0500

    [SMB3] Display persistenthandles in /proc/mounts for SMB3 shares if enabled
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by: Pavel Shilovsky <pshilovsky@samba.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e739950ca084..13302e94fee3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -454,6 +454,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",nocase");
 	if (tcon->retry)
 		seq_puts(s, ",hard");
+	if (tcon->use_persistent)
+		seq_puts(s, ",persistenthandles");
 	if (tcon->unix_ext)
 		seq_puts(s, ",unix");
 	else

commit eda2116f4ab6d79cfcffc202b5d2bbb0797ba013
Author: Steve French <smfrench@gmail.com>
Date:   Fri Sep 11 19:24:19 2015 -0500

    [CIFS] mount option sec=none not displayed properly in /proc/mounts
    
    When the user specifies "sec=none" in a cifs mount, we set
    sec_type as unspecified (and set a flag and the username will be
    null) rather than setting sectype as "none" so
    cifs_show_security was not properly displaying it in
    cifs /proc/mounts entries.
    
    Signed-off-by: Steve French <steve.french@primarydata.com>
    Reviewed-by: Jeff Layton <jlayton@poochiereds.net>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 6a1119e87fbb..e739950ca084 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -325,8 +325,11 @@ cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 static void
 cifs_show_security(struct seq_file *s, struct cifs_ses *ses)
 {
-	if (ses->sectype == Unspecified)
+	if (ses->sectype == Unspecified) {
+		if (ses->user_name == NULL)
+			seq_puts(s, ",sec=none");
 		return;
+	}
 
 	seq_puts(s, ",sec=");
 

commit a068acf2ee77693e0bf39d6e07139ba704f461c3
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Sep 4 15:44:57 2015 -0700

    fs: create and use seq_show_option for escaping
    
    Many file systems that implement the show_options hook fail to correctly
    escape their output which could lead to unescaped characters (e.g.  new
    lines) leaking into /proc/mounts and /proc/[pid]/mountinfo files.  This
    could lead to confusion, spoofed entries (resulting in things like
    systemd issuing false d-bus "mount" notifications), and who knows what
    else.  This looks like it would only be the root user stepping on
    themselves, but it's possible weird things could happen in containers or
    in other situations with delegated mount privileges.
    
    Here's an example using overlay with setuid fusermount trusting the
    contents of /proc/mounts (via the /etc/mtab symlink).  Imagine the use
    of "sudo" is something more sneaky:
    
      $ BASE="ovl"
      $ MNT="$BASE/mnt"
      $ LOW="$BASE/lower"
      $ UP="$BASE/upper"
      $ WORK="$BASE/work/ 0 0
      none /proc fuse.pwn user_id=1000"
      $ mkdir -p "$LOW" "$UP" "$WORK"
      $ sudo mount -t overlay -o "lowerdir=$LOW,upperdir=$UP,workdir=$WORK" none /mnt
      $ cat /proc/mounts
      none /root/ovl/mnt overlay rw,relatime,lowerdir=ovl/lower,upperdir=ovl/upper,workdir=ovl/work/ 0 0
      none /proc fuse.pwn user_id=1000 0 0
      $ fusermount -u /proc
      $ cat /proc/mounts
      cat: /proc/mounts: No such file or directory
    
    This fixes the problem by adding new seq_show_option and
    seq_show_option_n helpers, and updating the vulnerable show_option
    handlers to use them as needed.  Some, like SELinux, need to be open
    coded due to unusual existing escape mechanisms.
    
    [akpm@linux-foundation.org: add lost chunk, per Kees]
    [keescook@chromium.org: seq_show_option should be using const parameters]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Acked-by: Jan Kara <jack@suse.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Cc: J. R. Okajima <hooanon05g@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0a9fb6b53126..6a1119e87fbb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -394,17 +394,17 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	struct sockaddr *srcaddr;
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
-	seq_printf(s, ",vers=%s", tcon->ses->server->vals->version_string);
+	seq_show_option(s, "vers", tcon->ses->server->vals->version_string);
 	cifs_show_security(s, tcon->ses);
 	cifs_show_cache_flavor(s, cifs_sb);
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)
 		seq_puts(s, ",multiuser");
 	else if (tcon->ses->user_name)
-		seq_printf(s, ",username=%s", tcon->ses->user_name);
+		seq_show_option(s, "username", tcon->ses->user_name);
 
 	if (tcon->ses->domainName)
-		seq_printf(s, ",domain=%s", tcon->ses->domainName);
+		seq_show_option(s, "domain", tcon->ses->domainName);
 
 	if (srcaddr->sa_family != AF_UNSPEC) {
 		struct sockaddr_in *saddr4;

commit bc8ebdc4f54cc944b0ecc0fb0d18b0ffbaab0468
Author: Nakajima Akira <nakajima.akira@nttcom.co.jp>
Date:   Fri Feb 13 15:35:58 2015 +0900

    Fix that several functions handle incorrect value of mapchars
    
    Cifs client has problem with reserved chars filename.
    
    [BUG1] : several functions handle incorrect value of mapchars
    -       cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);
    +       cifs_remap(cifs_sb));
    
    [BUG2] : forget to convert reserved chars when creating SymbolicLink.
    -       CIFSUnixCreateSymLink() calls cifs_strtoUTF16
    +       CIFSUnixCreateSymLink() calls cifsConvertToUTF16() with remap
    
    [BUG3] : forget to convert reserved chars when getting SymbolicLink.
    -       CIFSSMBUnixQuerySymLink() calls cifs_strtoUTF16
    +       CIFSSMBUnixQuerySymLink() calls cifsConvertToUTF16() with remap
    
    [BUG4] : /proc/mounts don't show "mapposix" when using mapposix mount option
    +           cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)
    +               seq_puts(s, ",mapposix");
    
    Reported-by: t.wede@kw-reneg.de
    Reported-by: Nakajima Akira <nakajima.akira@nttcom.co.jp>
    Signed-off-by: Nakajima Akira <nakajima.akira@nttcom.co.jp>
    Signed-off-by: Carl Schaefer <schaefer@trilug.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f5089bde3635..0a9fb6b53126 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -469,6 +469,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_puts(s, ",nouser_xattr");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)
 		seq_puts(s, ",mapchars");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)
+		seq_puts(s, ",mapposix");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)
 		seq_puts(s, ",sfu");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)

commit 2b0143b5c986be1ce8408b3aadc4709e0a94429d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Mar 17 22:25:59 2015 +0000

    VFS: normal filesystems (and lustre): d_inode() annotations
    
    that's the bulk of filesystem drivers dealing with inodes of their own
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index eaab4b2a0595..f5089bde3635 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -607,7 +607,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	p = s = full_path;
 
 	do {
-		struct inode *dir = dentry->d_inode;
+		struct inode *dir = d_inode(dentry);
 		struct dentry *child;
 
 		if (!dir) {

commit 5d5d568975307877e9195f5305f4240e506a2807
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 3 15:41:18 2015 -0400

    make new_sync_{read,write}() static
    
    All places outside of core VFS that checked ->read and ->write for being NULL or
    called the methods directly are gone now, so NULL {read,write} with non-NULL
    {read,write}_iter will do the right thing in all cases.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d72fe37f5420..eaab4b2a0595 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -906,8 +906,6 @@ const struct inode_operations cifs_symlink_inode_ops = {
 };
 
 const struct file_operations cifs_file_ops = {
-	.read = new_sync_read,
-	.write = new_sync_write,
 	.read_iter = cifs_loose_read_iter,
 	.write_iter = cifs_file_write_iter,
 	.open = cifs_open,
@@ -926,8 +924,6 @@ const struct file_operations cifs_file_ops = {
 };
 
 const struct file_operations cifs_file_strict_ops = {
-	.read = new_sync_read,
-	.write = new_sync_write,
 	.read_iter = cifs_strict_readv,
 	.write_iter = cifs_strict_writev,
 	.open = cifs_open,
@@ -947,8 +943,6 @@ const struct file_operations cifs_file_strict_ops = {
 
 const struct file_operations cifs_file_direct_ops = {
 	/* BB reevaluate whether they can be done with directio, no cache */
-	.read = new_sync_read,
-	.write = new_sync_write,
 	.read_iter = cifs_user_readv,
 	.write_iter = cifs_user_writev,
 	.open = cifs_open,
@@ -967,8 +961,6 @@ const struct file_operations cifs_file_direct_ops = {
 };
 
 const struct file_operations cifs_file_nobrl_ops = {
-	.read = new_sync_read,
-	.write = new_sync_write,
 	.read_iter = cifs_loose_read_iter,
 	.write_iter = cifs_file_write_iter,
 	.open = cifs_open,
@@ -986,8 +978,6 @@ const struct file_operations cifs_file_nobrl_ops = {
 };
 
 const struct file_operations cifs_file_strict_nobrl_ops = {
-	.read = new_sync_read,
-	.write = new_sync_write,
 	.read_iter = cifs_strict_readv,
 	.write_iter = cifs_strict_writev,
 	.open = cifs_open,
@@ -1006,8 +996,6 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 
 const struct file_operations cifs_file_direct_nobrl_ops = {
 	/* BB reevaluate whether they can be done with directio, no cache */
-	.read = new_sync_read,
-	.write = new_sync_write,
 	.read_iter = cifs_user_readv,
 	.write_iter = cifs_user_writev,
 	.open = cifs_open,

commit 7119e220a7aed7b6e6df02ddfaa2c5f8df2e4e3d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 22 00:25:12 2014 -0400

    cifs: get rid of ->f_path.dentry->d_sb uses, add a new helper
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9d7996e8e793..d72fe37f5420 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -209,8 +209,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 static long cifs_fallocate(struct file *file, int mode, loff_t off, loff_t len)
 {
-	struct super_block *sb = file->f_path.dentry->d_sb;
-	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	struct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
 	struct TCP_Server_Info *server = tcon->ses->server;
 

commit ef4a48c513211d842c55e84f7a1c31884b91dcf7
Merge: 90d0c376f5ee 1b2b32dcdb3d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 11 13:21:34 2014 -0400

    Merge tag 'locks-v3.18-1' of git://git.samba.org/jlayton/linux
    
    Pull file locking related changes from Jeff Layton:
     "This release is a little more busy for file locking changes than the
      last:
    
       - a set of patches from Kinglong Mee to fix the lockowner handling in
         knfsd
       - a pile of cleanups to the internal file lease API.  This should get
         us a bit closer to allowing for setlease methods that can block.
    
      There are some dependencies between mine and Bruce's trees this cycle,
      and I based my tree on top of the requisite patches in Bruce's tree"
    
    * tag 'locks-v3.18-1' of git://git.samba.org/jlayton/linux: (26 commits)
      locks: fix fcntl_setlease/getlease return when !CONFIG_FILE_LOCKING
      locks: flock_make_lock should return a struct file_lock (or PTR_ERR)
      locks: set fl_owner for leases to filp instead of current->files
      locks: give lm_break a return value
      locks: __break_lease cleanup in preparation of allowing direct removal of leases
      locks: remove i_have_this_lease check from __break_lease
      locks: move freeing of leases outside of i_lock
      locks: move i_lock acquisition into generic_*_lease handlers
      locks: define a lm_setup handler for leases
      locks: plumb a "priv" pointer into the setlease routines
      nfsd: don't keep a pointer to the lease in nfs4_file
      locks: clean up vfs_setlease kerneldoc comments
      locks: generic_delete_lease doesn't need a file_lock at all
      nfsd: fix potential lease memory leak in nfs4_setlease
      locks: close potential race in lease_get_mtime
      security: make security_file_set_fowner, f_setown and __f_setown void return
      locks: consolidate "nolease" routines
      locks: remove lock_may_read and lock_may_write
      lockd: rip out deferred lock handling from testlock codepath
      NFSD: Get reference of lockowner when coping file_lock
      ...

commit e6f5c78930e409f3a6b37f5484313a416359ac7f
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Aug 22 10:40:25 2014 -0400

    locks: plumb a "priv" pointer into the setlease routines
    
    In later patches, we're going to add a new lock_manager_operation to
    finish setting up the lease while still holding the i_lock.  To do
    this, we'll need to pass a little bit of info in the fcntl setlease
    case (primarily an fasync structure). Plumb the extra pointer into
    there in advance of that.
    
    We declare this pointer as a void ** to make it clear that this is
    private info, and that the caller isn't required to set this unless
    the lm_setup specifically requires it.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ac4f260155c8..85c70d5969ac 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -800,7 +800,8 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)
 	return generic_file_llseek(file, offset, whence);
 }
 
-static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
+static int
+cifs_setlease(struct file *file, long arg, struct file_lock **lease, void **priv)
 {
 	/*
 	 * Note that this is called by vfs setlease with i_lock held to
@@ -815,7 +816,7 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 	/* check if file is oplocked */
 	if (((arg == F_RDLCK) && CIFS_CACHE_READ(CIFS_I(inode))) ||
 	    ((arg == F_WRLCK) && CIFS_CACHE_WRITE(CIFS_I(inode))))
-		return generic_setlease(file, arg, lease);
+		return generic_setlease(file, arg, lease, priv);
 	else if (tlink_tcon(cfile->tlink)->local_lease &&
 		 !CIFS_CACHE_READ(CIFS_I(inode)))
 		/*
@@ -826,7 +827,7 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 		 * knows that the file won't be changed on the server by anyone
 		 * else.
 		 */
-		return generic_setlease(file, arg, lease);
+		return generic_setlease(file, arg, lease, priv);
 	else
 		return -EAGAIN;
 }

commit 372b1dbdd1fb5697890b937228d93cfd9c734c90
Merge: 92075f9f640d 30175628bf7f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 20 18:33:21 2014 -0500

    Merge branch 'for-linus' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull cifs fixes from Steve French:
     "Most important fixes in this set include three SMB3 fixes for stable
      (including fix for possible kernel oops), and a workaround to allow
      writes to Mac servers (only cifs dialect, not more current SMB2.1,
      worked to Mac servers).  Also fallocate support added, and lease fix
      from Jeff"
    
    * 'for-linus' of git://git.samba.org/sfrench/cifs-2.6:
      [SMB3] Enable fallocate -z support for SMB3 mounts
      enable fallocate punch hole ("fallocate -p") for SMB3
      Incorrect error returned on setting file compressed on SMB2
      CIFS: Fix wrong directory attributes after rename
      CIFS: Fix SMB2 readdir error handling
      [CIFS] Possible null ptr deref in SMB2_tcon
      [CIFS] Workaround MacOS server problem with SMB2.1 write  response
      cifs: handle lease F_UNLCK requests properly
      Cleanup sparse file support by creating worker function for it
      Add sparse file support to SMB2/SMB3 mounts
      Add missing definitions for CIFS File System Attributes
      cifs: remove unused function cifs_oplock_break_wait

commit 31742c5a331766bc7df6b0d525df00c6cd20d5a6
Author: Steve French <smfrench@gmail.com>
Date:   Sun Aug 17 08:38:47 2014 -0500

    enable fallocate punch hole ("fallocate -p") for SMB3
    
    Implement FALLOC_FL_PUNCH_HOLE (which does not change the file size
    fortunately so this matches the behavior of the equivalent SMB3
    fsctl call) for SMB3 mounts.  This allows "fallocate -p" to work.
    It requires that the server support setting files as sparse
    (which Windows allows).
    
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0a4a4d7d407e..155347e190f9 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -207,6 +207,19 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
+static long cifs_fallocate(struct file *file, int mode, loff_t off, loff_t len)
+{
+	struct super_block *sb = file->f_path.dentry->d_sb;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
+	struct TCP_Server_Info *server = tcon->ses->server;
+
+	if (server->ops->fallocate)
+		return server->ops->fallocate(file, tcon, mode, off, len);
+
+	return -EOPNOTSUPP;
+}
+
 static int cifs_permission(struct inode *inode, int mask)
 {
 	struct cifs_sb_info *cifs_sb;
@@ -909,6 +922,7 @@ const struct file_operations cifs_file_ops = {
 	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.setlease = cifs_setlease,
+	.fallocate = cifs_fallocate,
 };
 
 const struct file_operations cifs_file_strict_ops = {
@@ -928,6 +942,7 @@ const struct file_operations cifs_file_strict_ops = {
 	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.setlease = cifs_setlease,
+	.fallocate = cifs_fallocate,
 };
 
 const struct file_operations cifs_file_direct_ops = {
@@ -948,6 +963,7 @@ const struct file_operations cifs_file_direct_ops = {
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
+	.fallocate = cifs_fallocate,
 };
 
 const struct file_operations cifs_file_nobrl_ops = {
@@ -966,6 +982,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.setlease = cifs_setlease,
+	.fallocate = cifs_fallocate,
 };
 
 const struct file_operations cifs_file_strict_nobrl_ops = {
@@ -984,6 +1001,7 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.setlease = cifs_setlease,
+	.fallocate = cifs_fallocate,
 };
 
 const struct file_operations cifs_file_direct_nobrl_ops = {
@@ -1003,6 +1021,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
+	.fallocate = cifs_fallocate,
 };
 
 const struct file_operations cifs_dir_ops = {

commit 024408062b21af7316221c420ff16bdaac478fa8
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Sat Aug 9 10:16:44 2014 -0400

    cifs: handle lease F_UNLCK requests properly
    
    Currently any F_UNLCK request for a lease just gets back -EAGAIN. Allow
    them to go immediately to generic_setlease instead.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 888398067420..0a4a4d7d407e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -812,8 +812,9 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 	if (!(S_ISREG(inode->i_mode)))
 		return -EINVAL;
 
-	/* check if file is oplocked */
-	if (((arg == F_RDLCK) && CIFS_CACHE_READ(CIFS_I(inode))) ||
+	/* Check if file is oplocked if this is request for new lease */
+	if (arg == F_UNLCK ||
+	    ((arg == F_RDLCK) && CIFS_CACHE_READ(CIFS_I(inode))) ||
 	    ((arg == F_WRLCK) && CIFS_CACHE_WRITE(CIFS_I(inode))))
 		return generic_setlease(file, arg, lease);
 	else if (tlink_tcon(cfile->tlink)->local_lease &&

commit 7c33d5972ce382bcc506d16235f1e9b7d22cbef8
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 23 15:15:36 2014 +0200

    cifs: support RENAME_NOREPLACE
    
    This flag gives CIFS the ability to support its native rename semantics.
    
    Implementation is simple: just bail out before trying to hack around the
    noreplace semantics.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 888398067420..ac4f260155c8 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -848,7 +848,7 @@ const struct inode_operations cifs_dir_inode_ops = {
 	.link = cifs_hardlink,
 	.mkdir = cifs_mkdir,
 	.rmdir = cifs_rmdir,
-	.rename = cifs_rename,
+	.rename2 = cifs_rename2,
 	.permission = cifs_permission,
 /*	revalidate:cifs_revalidate,   */
 	.setattr = cifs_setattr,

commit 08bc03539d38508eff3fd470a82ea422ce279f6e
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Fri May 23 06:50:21 2014 -0400

    cifs: revalidate mapping prior to satisfying read_iter request with cache=loose
    
    Before satisfying a read with cache=loose, we should always check
    that the pagecache is valid before allowing a read to be satisfied
    out of it.
    
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2c90d07c0b3a..888398067420 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -725,6 +725,19 @@ cifs_do_mount(struct file_system_type *fs_type,
 	goto out;
 }
 
+static ssize_t
+cifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)
+{
+	ssize_t rc;
+	struct inode *inode = file_inode(iocb->ki_filp);
+
+	rc = cifs_revalidate_mapping(inode);
+	if (rc)
+		return rc;
+
+	return generic_file_read_iter(iocb, iter);
+}
+
 static ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct inode *inode = file_inode(iocb->ki_filp);
@@ -881,7 +894,7 @@ const struct inode_operations cifs_symlink_inode_ops = {
 const struct file_operations cifs_file_ops = {
 	.read = new_sync_read,
 	.write = new_sync_write,
-	.read_iter = generic_file_read_iter,
+	.read_iter = cifs_loose_read_iter,
 	.write_iter = cifs_file_write_iter,
 	.open = cifs_open,
 	.release = cifs_close,
@@ -939,7 +952,7 @@ const struct file_operations cifs_file_direct_ops = {
 const struct file_operations cifs_file_nobrl_ops = {
 	.read = new_sync_read,
 	.write = new_sync_write,
-	.read_iter = generic_file_read_iter,
+	.read_iter = cifs_loose_read_iter,
 	.write_iter = cifs_file_write_iter,
 	.open = cifs_open,
 	.release = cifs_close,

commit 16b9057804c02e2d351e9c8f606e909b43cbd9e7
Merge: 5c02c392cd23 c2338f2dc7c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 12 10:30:18 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "This the bunch that sat in -next + lock_parent() fix.  This is the
      minimal set; there's more pending stuff.
    
      In particular, I really hope to get acct.c fixes merged this cycle -
      we need that to deal sanely with delayed-mntput stuff.  In the next
      pile, hopefully - that series is fairly short and localized
      (kernel/acct.c, fs/super.c and fs/namespace.c).  In this pile: more
      iov_iter work.  Most of prereqs for ->splice_write with sane locking
      order are there and Kent's dio rewrite would also fit nicely on top of
      this pile"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (70 commits)
      lock_parent: don't step on stale ->d_parent of all-but-freed one
      kill generic_file_splice_write()
      ceph: switch to iter_file_splice_write()
      shmem: switch to iter_file_splice_write()
      nfs: switch to iter_splice_write_file()
      fs/splice.c: remove unneeded exports
      ocfs2: switch to iter_file_splice_write()
      ->splice_write() via ->write_iter()
      bio_vec-backed iov_iter
      optimize copy_page_{to,from}_iter()
      bury generic_file_aio_{read,write}
      lustre: get rid of messing with iovecs
      ceph: switch to ->write_iter()
      ceph_sync_direct_write: stop poking into iov_iter guts
      ceph_sync_read: stop poking into iov_iter guts
      new helper: copy_page_from_iter()
      fuse: switch to ->write_iter()
      btrfs: switch to ->write_iter()
      ocfs2: switch to ->write_iter()
      xfs: switch to ->write_iter()
      ...

commit 39552ea8120a699dbd0360848c4d949f9f0e6deb
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue May 13 00:48:12 2014 +0100

    cifs: Set client guid on per connection basis
    
    When mounting from a Windows 2012R2 server, we hit the following
    problem:
    1) Mount with any of the following versions - 2.0, 2.1 or 3.0
    2) unmount
    3) Attempt a mount again using a different SMB version >= 2.0.
    
    You end up with the following failure:
    Status code returned 0xc0000203 STATUS_USER_SESSION_DELETED
    CIFS VFS: Send error in SessSetup = -5
    CIFS VFS: cifs_mount failed w/return code = -5
    
    I cannot reproduce this issue using a Windows 2008 R2 server.
    
    This appears to be caused because we use the same client guid for the
    connection on first mount which we then disconnect and attempt to mount
    again using a different protocol version. By generating a new guid each
    time a new connection is Negotiated, we avoid hitting this problem.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index be66533c0f58..6aaa8112c538 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -87,10 +87,6 @@ extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
 
-#ifdef CONFIG_CIFS_SMB2
-__u8 cifs_client_guid[SMB2_CLIENT_GUID_SIZE];
-#endif
-
 /*
  * Bumps refcount for cifs super block.
  * Note that it should be only called if a referece to VFS super block is
@@ -1188,10 +1184,6 @@ init_cifs(void)
 	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
-#ifdef CONFIG_CIFS_SMB2
-	get_random_bytes(cifs_client_guid, SMB2_CLIENT_GUID_SIZE);
-#endif
-
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
 		cifs_dbg(FYI, "cifs_max_pending set to min of 2\n");

commit 571d597206a94a042f9a3c9fdc2b9d7f33ab85e5
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue May 13 18:04:17 2014 +0200

    fs/cifs/cifs.c: replace seq_printf by seq_puts
    
    Replace seq_printf where possible
    
    Cc: Steve French <sfrench@samba.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3ef0299ed43e..be66533c0f58 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -298,7 +298,7 @@ cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 	struct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;
 	struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;
 
-	seq_printf(s, ",addr=");
+	seq_puts(s, ",addr=");
 
 	switch (server->dstaddr.ss_family) {
 	case AF_INET:
@@ -310,7 +310,7 @@ cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 			seq_printf(s, "%%%u", sa6->sin6_scope_id);
 		break;
 	default:
-		seq_printf(s, "(unknown)");
+		seq_puts(s, "(unknown)");
 	}
 }
 
@@ -320,45 +320,45 @@ cifs_show_security(struct seq_file *s, struct cifs_ses *ses)
 	if (ses->sectype == Unspecified)
 		return;
 
-	seq_printf(s, ",sec=");
+	seq_puts(s, ",sec=");
 
 	switch (ses->sectype) {
 	case LANMAN:
-		seq_printf(s, "lanman");
+		seq_puts(s, "lanman");
 		break;
 	case NTLMv2:
-		seq_printf(s, "ntlmv2");
+		seq_puts(s, "ntlmv2");
 		break;
 	case NTLM:
-		seq_printf(s, "ntlm");
+		seq_puts(s, "ntlm");
 		break;
 	case Kerberos:
-		seq_printf(s, "krb5");
+		seq_puts(s, "krb5");
 		break;
 	case RawNTLMSSP:
-		seq_printf(s, "ntlmssp");
+		seq_puts(s, "ntlmssp");
 		break;
 	default:
 		/* shouldn't ever happen */
-		seq_printf(s, "unknown");
+		seq_puts(s, "unknown");
 		break;
 	}
 
 	if (ses->sign)
-		seq_printf(s, "i");
+		seq_puts(s, "i");
 }
 
 static void
 cifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)
 {
-	seq_printf(s, ",cache=");
+	seq_puts(s, ",cache=");
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)
-		seq_printf(s, "strict");
+		seq_puts(s, "strict");
 	else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
-		seq_printf(s, "none");
+		seq_puts(s, "none");
 	else
-		seq_printf(s, "loose");
+		seq_puts(s, "loose");
 }
 
 static void
@@ -391,7 +391,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	cifs_show_cache_flavor(s, cifs_sb);
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)
-		seq_printf(s, ",multiuser");
+		seq_puts(s, ",multiuser");
 	else if (tcon->ses->user_name)
 		seq_printf(s, ",username=%s", tcon->ses->user_name);
 
@@ -417,16 +417,16 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	seq_printf(s, ",uid=%u",
 		   from_kuid_munged(&init_user_ns, cifs_sb->mnt_uid));
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)
-		seq_printf(s, ",forceuid");
+		seq_puts(s, ",forceuid");
 	else
-		seq_printf(s, ",noforceuid");
+		seq_puts(s, ",noforceuid");
 
 	seq_printf(s, ",gid=%u",
 		   from_kgid_munged(&init_user_ns, cifs_sb->mnt_gid));
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)
-		seq_printf(s, ",forcegid");
+		seq_puts(s, ",forcegid");
 	else
-		seq_printf(s, ",noforcegid");
+		seq_puts(s, ",noforcegid");
 
 	cifs_show_address(s, tcon->ses->server);
 
@@ -438,47 +438,47 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	cifs_show_nls(s, cifs_sb->local_nls);
 
 	if (tcon->seal)
-		seq_printf(s, ",seal");
+		seq_puts(s, ",seal");
 	if (tcon->nocase)
-		seq_printf(s, ",nocase");
+		seq_puts(s, ",nocase");
 	if (tcon->retry)
-		seq_printf(s, ",hard");
+		seq_puts(s, ",hard");
 	if (tcon->unix_ext)
-		seq_printf(s, ",unix");
+		seq_puts(s, ",unix");
 	else
-		seq_printf(s, ",nounix");
+		seq_puts(s, ",nounix");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
-		seq_printf(s, ",posixpaths");
+		seq_puts(s, ",posixpaths");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)
-		seq_printf(s, ",setuids");
+		seq_puts(s, ",setuids");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
-		seq_printf(s, ",serverino");
+		seq_puts(s, ",serverino");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
-		seq_printf(s, ",rwpidforward");
+		seq_puts(s, ",rwpidforward");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL)
-		seq_printf(s, ",forcemand");
+		seq_puts(s, ",forcemand");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
-		seq_printf(s, ",nouser_xattr");
+		seq_puts(s, ",nouser_xattr");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)
-		seq_printf(s, ",mapchars");
+		seq_puts(s, ",mapchars");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)
-		seq_printf(s, ",sfu");
+		seq_puts(s, ",sfu");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)
-		seq_printf(s, ",nobrl");
+		seq_puts(s, ",nobrl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)
-		seq_printf(s, ",cifsacl");
+		seq_puts(s, ",cifsacl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)
-		seq_printf(s, ",dynperm");
+		seq_puts(s, ",dynperm");
 	if (root->d_sb->s_flags & MS_POSIXACL)
-		seq_printf(s, ",acl");
+		seq_puts(s, ",acl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)
-		seq_printf(s, ",mfsymlinks");
+		seq_puts(s, ",mfsymlinks");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)
-		seq_printf(s, ",fsc");
+		seq_puts(s, ",fsc");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)
-		seq_printf(s, ",nostrictsync");
+		seq_puts(s, ",nostrictsync");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)
-		seq_printf(s, ",noperm");
+		seq_puts(s, ",noperm");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID)
 		seq_printf(s, ",backupuid=%u",
 			   from_kuid_munged(&init_user_ns,

commit aff8d5ca7a3dca0bd6f6e86c9a85bf04941262ce
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Wed Apr 30 09:31:45 2014 -0400

    cifs: convert booleans in cifsInodeInfo to a flags field
    
    In later patches, we'll need to have a bitlock, so go ahead and convert
    these bools to use atomic bitops instead.
    
    Also, clean up the initialization of the flags field. There's no need
    to unset each bit individually just after it was zeroed on allocation.
    
    Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5be1f997ecde..3ef0299ed43e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -251,11 +251,7 @@ cifs_alloc_inode(struct super_block *sb)
 	 * server, can not assume caching of file data or metadata.
 	 */
 	cifs_set_oplock_level(cifs_inode, 0);
-	cifs_inode->delete_pending = false;
-	cifs_inode->invalid_mapping = false;
-	clear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cifs_inode->flags);
-	clear_bit(CIFS_INODE_PENDING_WRITERS, &cifs_inode->flags);
-	clear_bit(CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2, &cifs_inode->flags);
+	cifs_inode->flags = 0;
 	spin_lock_init(&cifs_inode->writers_lock);
 	cifs_inode->writers = 0;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */

commit 3dae8750c368f8ac11c3c8c2a28f56dcee865c01
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 3 12:05:17 2014 -0400

    cifs: switch to ->write_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f0a567a344cf..496b520934e0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -733,8 +733,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	goto out;
 }
 
-static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
-				   unsigned long nr_segs, loff_t pos)
+static ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct inode *inode = file_inode(iocb->ki_filp);
 	struct cifsInodeInfo *cinode = CIFS_I(inode);
@@ -745,14 +744,14 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	if (written)
 		return written;
 
-	written = generic_file_aio_write(iocb, iov, nr_segs, pos);
+	written = generic_file_write_iter(iocb, from);
 
 	if (CIFS_CACHE_WRITE(CIFS_I(inode)))
 		goto out;
 
 	rc = filemap_fdatawrite(inode->i_mapping);
 	if (rc)
-		cifs_dbg(FYI, "cifs_file_aio_write: %d rc on %p inode\n",
+		cifs_dbg(FYI, "cifs_file_write_iter: %d rc on %p inode\n",
 			 rc, inode);
 
 out:
@@ -889,9 +888,9 @@ const struct inode_operations cifs_symlink_inode_ops = {
 
 const struct file_operations cifs_file_ops = {
 	.read = new_sync_read,
-	.write = do_sync_write,
+	.write = new_sync_write,
 	.read_iter = generic_file_read_iter,
-	.aio_write = cifs_file_aio_write,
+	.write_iter = cifs_file_write_iter,
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
@@ -908,9 +907,9 @@ const struct file_operations cifs_file_ops = {
 
 const struct file_operations cifs_file_strict_ops = {
 	.read = new_sync_read,
-	.write = do_sync_write,
+	.write = new_sync_write,
 	.read_iter = cifs_strict_readv,
-	.aio_write = cifs_strict_writev,
+	.write_iter = cifs_strict_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
@@ -928,9 +927,9 @@ const struct file_operations cifs_file_strict_ops = {
 const struct file_operations cifs_file_direct_ops = {
 	/* BB reevaluate whether they can be done with directio, no cache */
 	.read = new_sync_read,
-	.write = do_sync_write,
+	.write = new_sync_write,
 	.read_iter = cifs_user_readv,
-	.aio_write = cifs_user_writev,
+	.write_iter = cifs_user_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
@@ -947,9 +946,9 @@ const struct file_operations cifs_file_direct_ops = {
 
 const struct file_operations cifs_file_nobrl_ops = {
 	.read = new_sync_read,
-	.write = do_sync_write,
+	.write = new_sync_write,
 	.read_iter = generic_file_read_iter,
-	.aio_write = cifs_file_aio_write,
+	.write_iter = cifs_file_write_iter,
 	.open = cifs_open,
 	.release = cifs_close,
 	.fsync = cifs_fsync,
@@ -965,9 +964,9 @@ const struct file_operations cifs_file_nobrl_ops = {
 
 const struct file_operations cifs_file_strict_nobrl_ops = {
 	.read = new_sync_read,
-	.write = do_sync_write,
+	.write = new_sync_write,
 	.read_iter = cifs_strict_readv,
-	.aio_write = cifs_strict_writev,
+	.write_iter = cifs_strict_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.fsync = cifs_strict_fsync,
@@ -984,9 +983,9 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 const struct file_operations cifs_file_direct_nobrl_ops = {
 	/* BB reevaluate whether they can be done with directio, no cache */
 	.read = new_sync_read,
-	.write = do_sync_write,
+	.write = new_sync_write,
 	.read_iter = cifs_user_readv,
-	.aio_write = cifs_user_writev,
+	.write_iter = cifs_user_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.fsync = cifs_fsync,

commit e6a7bcb4c489e3e078ba3cc92ae6621b2b8bb9a7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 2 19:53:36 2014 -0400

    cifs: switch to ->read_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c57a9b16edd4..f0a567a344cf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -907,9 +907,9 @@ const struct file_operations cifs_file_ops = {
 };
 
 const struct file_operations cifs_file_strict_ops = {
-	.read = do_sync_read,
+	.read = new_sync_read,
 	.write = do_sync_write,
-	.aio_read = cifs_strict_readv,
+	.read_iter = cifs_strict_readv,
 	.aio_write = cifs_strict_writev,
 	.open = cifs_open,
 	.release = cifs_close,
@@ -927,9 +927,9 @@ const struct file_operations cifs_file_strict_ops = {
 
 const struct file_operations cifs_file_direct_ops = {
 	/* BB reevaluate whether they can be done with directio, no cache */
-	.read = do_sync_read,
+	.read = new_sync_read,
 	.write = do_sync_write,
-	.aio_read = cifs_user_readv,
+	.read_iter = cifs_user_readv,
 	.aio_write = cifs_user_writev,
 	.open = cifs_open,
 	.release = cifs_close,
@@ -964,9 +964,9 @@ const struct file_operations cifs_file_nobrl_ops = {
 };
 
 const struct file_operations cifs_file_strict_nobrl_ops = {
-	.read = do_sync_read,
+	.read = new_sync_read,
 	.write = do_sync_write,
-	.aio_read = cifs_strict_readv,
+	.read_iter = cifs_strict_readv,
 	.aio_write = cifs_strict_writev,
 	.open = cifs_open,
 	.release = cifs_close,
@@ -983,9 +983,9 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 
 const struct file_operations cifs_file_direct_nobrl_ops = {
 	/* BB reevaluate whether they can be done with directio, no cache */
-	.read = do_sync_read,
+	.read = new_sync_read,
 	.write = do_sync_write,
-	.aio_read = cifs_user_readv,
+	.read_iter = cifs_user_readv,
 	.aio_write = cifs_user_writev,
 	.open = cifs_open,
 	.release = cifs_close,

commit aad4f8bb42af06371aa0e85bf0cd9d52c0494985
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 2 14:33:16 2014 -0400

    switch simple generic_file_aio_read() users to ->read_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5be1f997ecde..c57a9b16edd4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -888,9 +888,9 @@ const struct inode_operations cifs_symlink_inode_ops = {
 };
 
 const struct file_operations cifs_file_ops = {
-	.read = do_sync_read,
+	.read = new_sync_read,
 	.write = do_sync_write,
-	.aio_read = generic_file_aio_read,
+	.read_iter = generic_file_read_iter,
 	.aio_write = cifs_file_aio_write,
 	.open = cifs_open,
 	.release = cifs_close,
@@ -946,9 +946,9 @@ const struct file_operations cifs_file_direct_ops = {
 };
 
 const struct file_operations cifs_file_nobrl_ops = {
-	.read = do_sync_read,
+	.read = new_sync_read,
 	.write = do_sync_write,
-	.aio_read = generic_file_aio_read,
+	.read_iter = generic_file_read_iter,
 	.aio_write = cifs_file_aio_write,
 	.open = cifs_open,
 	.release = cifs_close,

commit c11f1df5003d534fd067f0168bfad7befffb3b5c
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue Mar 11 16:11:47 2014 +0000

    cifs: Wait for writebacks to complete before attempting write.
    
    Problem reported in Red Hat bz 1040329 for strict writes where we cache
    only when we hold oplock and write direct to the server when we don't.
    
    When we receive an oplock break, we first change the oplock value for
    the inode in cifsInodeInfo->oplock to indicate that we no longer hold
    the oplock before we enqueue a task to flush changes to the backing
    device. Once we have completed flushing the changes, we return the
    oplock to the server.
    
    There are 2 ways here where we can have data corruption
    1) While we flush changes to the backing device as part of the oplock
    break, we can have processes write to the file. These writes check for
    the oplock, find none and attempt to write directly to the server.
    These direct writes made while we are flushing from cache could be
    overwritten by data being flushed from the cache causing data
    corruption.
    2) While a thread runs in cifs_strict_writev, the machine could receive
    and process an oplock break after the thread has checked the oplock and
    found that it allows us to cache and before we have made changes to the
    cache. In that case, we end up with a dirty page in cache when we
    shouldn't have any. This will be flushed later and will overwrite all
    subsequent writes to the part of the file represented by this page.
    
    Before making any writes to the server, we need to confirm that we are
    not in the process of flushing data to the server and if we are, we
    should wait until the process is complete before we attempt the write.
    We should also wait for existing writes to complete before we process
    an oplock break request which changes oplock values.
    
    We add a version specific  downgrade_oplock() operation to allow for
    differences in the oplock values set for the different smb versions.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index df9c9141c099..5be1f997ecde 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -253,6 +253,11 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_set_oplock_level(cifs_inode, 0);
 	cifs_inode->delete_pending = false;
 	cifs_inode->invalid_mapping = false;
+	clear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cifs_inode->flags);
+	clear_bit(CIFS_INODE_PENDING_WRITERS, &cifs_inode->flags);
+	clear_bit(CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2, &cifs_inode->flags);
+	spin_lock_init(&cifs_inode->writers_lock);
+	cifs_inode->writers = 0;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
 	cifs_inode->server_eof = 0;
 	cifs_inode->uniqueid = 0;
@@ -732,19 +737,26 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				   unsigned long nr_segs, loff_t pos)
 {
 	struct inode *inode = file_inode(iocb->ki_filp);
+	struct cifsInodeInfo *cinode = CIFS_I(inode);
 	ssize_t written;
 	int rc;
 
+	written = cifs_get_writer(cinode);
+	if (written)
+		return written;
+
 	written = generic_file_aio_write(iocb, iov, nr_segs, pos);
 
 	if (CIFS_CACHE_WRITE(CIFS_I(inode)))
-		return written;
+		goto out;
 
 	rc = filemap_fdatawrite(inode->i_mapping);
 	if (rc)
 		cifs_dbg(FYI, "cifs_file_aio_write: %d rc on %p inode\n",
 			 rc, inode);
 
+out:
+	cifs_put_writer(cinode);
 	return written;
 }
 

commit 5166701b368caea89d57b14bf41cf39e819dad51
Merge: 0a7418f5f569 a786c06d9f27
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 12 14:49:50 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "The first vfs pile, with deep apologies for being very late in this
      window.
    
      Assorted cleanups and fixes, plus a large preparatory part of iov_iter
      work.  There's a lot more of that, but it'll probably go into the next
      merge window - it *does* shape up nicely, removes a lot of
      boilerplate, gets rid of locking inconsistencie between aio_write and
      splice_write and I hope to get Kent's direct-io rewrite merged into
      the same queue, but some of the stuff after this point is having
      (mostly trivial) conflicts with the things already merged into
      mainline and with some I want more testing.
    
      This one passes LTP and xfstests without regressions, in addition to
      usual beating.  BTW, readahead02 in ltp syscalls testsuite has started
      giving failures since "mm/readahead.c: fix readahead failure for
      memoryless NUMA nodes and limit readahead pages" - might be a false
      positive, might be a real regression..."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      missing bits of "splice: fix racy pipe->buffers uses"
      cifs: fix the race in cifs_writev()
      ceph_sync_{,direct_}write: fix an oops on ceph_osdc_new_request() failure
      kill generic_file_buffered_write()
      ocfs2_file_aio_write(): switch to generic_perform_write()
      ceph_aio_write(): switch to generic_perform_write()
      xfs_file_buffered_aio_write(): switch to generic_perform_write()
      export generic_perform_write(), start getting rid of generic_file_buffer_write()
      generic_file_direct_write(): get rid of ppos argument
      btrfs_file_aio_write(): get rid of ppos
      kill the 5th argument of generic_file_buffered_write()
      kill the 4th argument of __generic_file_aio_write()
      lustre: don't open-code kernel_recvmsg()
      ocfs2: don't open-code kernel_recvmsg()
      drbd: don't open-code kernel_recvmsg()
      constify blk_rq_map_user_iov() and friends
      lustre: switch to kernel_sendmsg()
      ocfs2: don't open-code kernel_sendmsg()
      take iov_iter stuff to mm/iov_iter.c
      process_vm_access: tidy up a bit
      ...

commit 24e7ea3bea94fe05eae5019f5f12bcdc98fc5157
Merge: 8e343c8b5c2e ad6599ab3ac9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 4 15:39:39 2014 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates from Ted Ts'o:
     "Major changes for 3.14 include support for the newly added ZERO_RANGE
      and COLLAPSE_RANGE fallocate operations, and scalability improvements
      in the jbd2 layer and in xattr handling when the extended attributes
      spill over into an external block.
    
      Other than that, the usual clean ups and minor bug fixes"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (42 commits)
      ext4: fix premature freeing of partial clusters split across leaf blocks
      ext4: remove unneeded test of ret variable
      ext4: fix comment typo
      ext4: make ext4_block_zero_page_range static
      ext4: atomically set inode->i_flags in ext4_set_inode_flags()
      ext4: optimize Hurd tests when reading/writing inodes
      ext4: kill i_version support for Hurd-castrated file systems
      ext4: each filesystem creates and uses its own mb_cache
      fs/mbcache.c: doucple the locking of local from global data
      fs/mbcache.c: change block and index hash chain to hlist_bl_node
      ext4: Introduce FALLOC_FL_ZERO_RANGE flag for fallocate
      ext4: refactor ext4_fallocate code
      ext4: Update inode i_size after the preallocation
      ext4: fix partial cluster handling for bigalloc file systems
      ext4: delete path dealloc code in ext4_ext_handle_uninitialized_extents
      ext4: only call sync_filesystm() when remounting read-only
      fs: push sync_filesystem() down to the file system's remount_fs()
      jbd2: improve error messages for inconsistent journal heads
      jbd2: minimize region locked by j_list_lock in jbd2_journal_forget()
      jbd2: minimize region locked by j_list_lock in journal_get_create_access()
      ...

commit 91b0abe36a7b2b3b02d7500925a5f8455334f0e5
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Thu Apr 3 14:47:49 2014 -0700

    mm + fs: store shadow entries in page cache
    
    Reclaim will be leaving shadow entries in the page cache radix tree upon
    evicting the real page.  As those pages are found from the LRU, an
    iput() can lead to the inode being freed concurrently.  At this point,
    reclaim must no longer install shadow pages because the inode freeing
    code needs to ensure the page tree is really empty.
    
    Add an address_space flag, AS_EXITING, that the inode freeing code sets
    under the tree lock before doing the final truncate.  Reclaim will check
    for this flag before installing shadow pages.
    
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Reviewed-by: Minchan Kim <minchan@kernel.org>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Bob Liu <bob.liu@oracle.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Luigi Semenzato <semenzato@google.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Metin Doslu <metin@citusdata.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Ozgun Erdogan <ozgun@citusdata.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Roman Gushchin <klamm@yandex-team.ru>
    Cc: Ryan Mallon <rmallon@gmail.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e8ae8323c058..ab8ad2546c3e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -286,7 +286,7 @@ cifs_destroy_inode(struct inode *inode)
 static void
 cifs_evict_inode(struct inode *inode)
 {
-	truncate_inode_pages(&inode->i_data, 0);
+	truncate_inode_pages_final(&inode->i_data);
 	clear_inode(inode);
 	cifs_fscache_release_inode_cookie(inode);
 }

commit 9ee108b2c626eab894f5c669cda04933b492813d
Author: Fabian Frederick <fabf@skynet.be>
Date:   Thu Apr 3 14:46:30 2014 -0700

    fs/cifs/cifsfs.c: add __init to cifs_init_inodecache()
    
    cifs_init_inodecache is only called by __init init_cifs.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 849f6132b327..e8ae8323c058 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1005,7 +1005,7 @@ cifs_init_once(void *inode)
 	init_rwsem(&cifsi->lock_sem);
 }
 
-static int
+static int __init
 cifs_init_inodecache(void)
 {
 	cifs_inode_cachep = kmem_cache_create("cifs_inode_cache",

commit 81c5a68478be38816bb5110ae0a5de1320cd2dfd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 1 08:26:29 2014 -0500

    cifs: ->rename() without ->lookup() makes no sense
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 849f6132b327..f31f9d6913b2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -849,7 +849,6 @@ const struct inode_operations cifs_file_inode_ops = {
 /*	revalidate:cifs_revalidate, */
 	.setattr = cifs_setattr,
 	.getattr = cifs_getattr, /* do we need this anymore? */
-	.rename = cifs_rename,
 	.permission = cifs_permission,
 #ifdef CONFIG_CIFS_XATTR
 	.setxattr = cifs_setxattr,

commit 02b9984d640873b7b3809e63f81a0d7e13496886
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Mar 13 10:14:33 2014 -0400

    fs: push sync_filesystem() down to the file system's remount_fs()
    
    Previously, the no-op "mount -o mount /dev/xxx" operation when the
    file system is already mounted read-write causes an implied,
    unconditional syncfs().  This seems pretty stupid, and it's certainly
    documented or guaraunteed to do this, nor is it particularly useful,
    except in the case where the file system was mounted rw and is getting
    remounted read-only.
    
    However, it's possible that there might be some file systems that are
    actually depending on this behavior.  In most file systems, it's
    probably fine to only call sync_filesystem() when transitioning from
    read-write to read-only, and there are some file systems where this is
    not needed at all (for example, for a pseudo-filesystem or something
    like romfs).
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Evgeniy Dushistov <dushistov@mail.ru>
    Cc: Jan Kara <jack@suse.cz>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Anders Larsen <al@alarsen.net>
    Cc: Phillip Lougher <phillip@squashfs.org.uk>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Mikulas Patocka <mikulas@artax.karlin.mff.cuni.cz>
    Cc: Petr Vandrovec <petr@vandrovec.name>
    Cc: xfs@oss.sgi.com
    Cc: linux-btrfs@vger.kernel.org
    Cc: linux-cifs@vger.kernel.org
    Cc: samba-technical@lists.samba.org
    Cc: codalist@coda.cs.cmu.edu
    Cc: linux-ext4@vger.kernel.org
    Cc: linux-f2fs-devel@lists.sourceforge.net
    Cc: fuse-devel@lists.sourceforge.net
    Cc: cluster-devel@redhat.com
    Cc: linux-mtd@lists.infradead.org
    Cc: jfs-discussion@lists.sourceforge.net
    Cc: linux-nfs@vger.kernel.org
    Cc: linux-nilfs@vger.kernel.org
    Cc: linux-ntfs-dev@lists.sourceforge.net
    Cc: ocfs2-devel@oss.oracle.com
    Cc: reiserfs-devel@vger.kernel.org

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 849f6132b327..4942c94bf7ee 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -541,6 +541,7 @@ static int cifs_show_stats(struct seq_file *s, struct dentry *root)
 
 static int cifs_remount(struct super_block *sb, int *flags, char *data)
 {
+	sync_filesystem(sb);
 	*flags |= MS_NODIRATIME;
 	return 0;
 }

commit 9bc9ccd7db1c9f043f75380b5a5b94912046a60e
Merge: f0230294271f bdd353661844
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 13 15:34:18 2013 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "All kinds of stuff this time around; some more notable parts:
    
       - RCU'd vfsmounts handling
       - new primitives for coredump handling
       - files_lock is gone
       - Bruce's delegations handling series
       - exportfs fixes
    
      plus misc stuff all over the place"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (101 commits)
      ecryptfs: ->f_op is never NULL
      locks: break delegations on any attribute modification
      locks: break delegations on link
      locks: break delegations on rename
      locks: helper functions for delegation breaking
      locks: break delegations on unlink
      namei: minor vfs_unlink cleanup
      locks: implement delegations
      locks: introduce new FL_DELEG lock flag
      vfs: take i_mutex on renamed file
      vfs: rename I_MUTEX_QUOTA now that it's not used for quotas
      vfs: don't use PARENT/CHILD lock classes for non-directories
      vfs: pull ext4's double-i_mutex-locking into common code
      exportfs: fix quadratic behavior in filehandle lookup
      exportfs: better variable name
      exportfs: move most of reconnect_path to helper function
      exportfs: eliminate unused "noprogress" counter
      exportfs: stop retrying once we race with rename/remove
      exportfs: clear DISCONNECTED on all parents sooner
      exportfs: more detailed comment for path_reconnect
      ...

commit 87dc800be2499128efb3a6f059d75dc8e1e6d503
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Sep 16 10:30:04 2013 -0400

    new helper: kfree_put_link()
    
    duplicated to hell and back...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a16b4e58bcc6..801975c34cf9 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -860,7 +860,7 @@ const struct inode_operations cifs_file_inode_ops = {
 const struct inode_operations cifs_symlink_inode_ops = {
 	.readlink = generic_readlink,
 	.follow_link = cifs_follow_link,
-	.put_link = cifs_put_link,
+	.put_link = kfree_put_link,
 	.permission = cifs_permission,
 	/* BB add the following two eventually */
 	/* revalidate: cifs_revalidate,

commit 2f6c9479633780ba4a3484bba7eba5a721a5cf20
Author: Jan Klos <honza.klos@gmail.com>
Date:   Sun Oct 6 21:08:20 2013 +0200

    cifs: Fix inability to write files >2GB to SMB2/3 shares
    
    When connecting to SMB2/3 shares, maximum file size is set to non-LFS maximum in superblock. This is due to cap_large_files bit being different for SMB1 and SMB2/3 (where it is just an internal flag that is not negotiated and the SMB1 one corresponds to multichannel capability, so maybe LFS works correctly if server sends 0x08 flag) while capabilities are checked always for the SMB1 bit in cifs_read_super().
    
    The patch fixes this by checking for the correct bit according to the protocol version.
    
    CC: Stable <stable@kernel.org>
    Signed-off-by: Jan Klos <honza.klos@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a16b4e58bcc6..77fc5e181077 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -120,14 +120,16 @@ cifs_read_super(struct super_block *sb)
 {
 	struct inode *inode;
 	struct cifs_sb_info *cifs_sb;
+	struct cifs_tcon *tcon;
 	int rc = 0;
 
 	cifs_sb = CIFS_SB(sb);
+	tcon = cifs_sb_master_tcon(cifs_sb);
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)
 		sb->s_flags |= MS_POSIXACL;
 
-	if (cifs_sb_master_tcon(cifs_sb)->ses->capabilities & CAP_LARGE_FILES)
+	if (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)
 		sb->s_maxbytes = MAX_LFS_FILESIZE;
 	else
 		sb->s_maxbytes = MAX_NON_LFS;
@@ -147,7 +149,7 @@ cifs_read_super(struct super_block *sb)
 		goto out_no_root;
 	}
 
-	if (cifs_sb_master_tcon(cifs_sb)->nocase)
+	if (tcon->nocase)
 		sb->s_d_op = &cifs_ci_dentry_ops;
 	else
 		sb->s_d_op = &cifs_dentry_ops;

commit 42873b0a282ac84a56e0e48c408beb62d0ad2917
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Sep 5 21:30:16 2013 +0400

    CIFS: Respect epoch value from create lease context v2
    
    that force a client to purge cache pages when a server requests it.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ab88efe014a5..a16b4e58bcc6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -255,6 +255,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->server_eof = 0;
 	cifs_inode->uniqueid = 0;
 	cifs_inode->createtime = 0;
+	cifs_inode->epoch = 0;
 #ifdef CONFIG_CIFS_SMB2
 	get_random_bytes(cifs_inode->lease_key, SMB2_LEASE_KEY_SIZE);
 #endif

commit 18cceb6a78f46b65df654e8348fa2093b91b30f6
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Thu Sep 5 13:01:06 2013 +0400

    CIFS: Replace clientCanCache* bools with an integer
    
    that prepare the code to handle different types of SMB2 leases.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d70e551f0bfb..ab88efe014a5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -733,7 +733,7 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 
 	written = generic_file_aio_write(iocb, iov, nr_segs, pos);
 
-	if (CIFS_I(inode)->clientCanCacheAll)
+	if (CIFS_CACHE_WRITE(CIFS_I(inode)))
 		return written;
 
 	rc = filemap_fdatawrite(inode->i_mapping);
@@ -758,7 +758,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)
 		 * We need to be sure that all dirty pages are written and the
 		 * server has the newest file length.
 		 */
-		if (!CIFS_I(inode)->clientCanCacheRead && inode->i_mapping &&
+		if (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&
 		    inode->i_mapping->nrpages != 0) {
 			rc = filemap_fdatawait(inode->i_mapping);
 			if (rc) {
@@ -782,8 +782,10 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)
 
 static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 {
-	/* note that this is called by vfs setlease with i_lock held
-	   to protect *lease from going away */
+	/*
+	 * Note that this is called by vfs setlease with i_lock held to
+	 * protect *lease from going away.
+	 */
 	struct inode *inode = file_inode(file);
 	struct cifsFileInfo *cfile = file->private_data;
 
@@ -791,20 +793,19 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 		return -EINVAL;
 
 	/* check if file is oplocked */
-	if (((arg == F_RDLCK) &&
-		(CIFS_I(inode)->clientCanCacheRead)) ||
-	    ((arg == F_WRLCK) &&
-		(CIFS_I(inode)->clientCanCacheAll)))
+	if (((arg == F_RDLCK) && CIFS_CACHE_READ(CIFS_I(inode))) ||
+	    ((arg == F_WRLCK) && CIFS_CACHE_WRITE(CIFS_I(inode))))
 		return generic_setlease(file, arg, lease);
 	else if (tlink_tcon(cfile->tlink)->local_lease &&
-		 !CIFS_I(inode)->clientCanCacheRead)
-		/* If the server claims to support oplock on this
-		   file, then we still need to check oplock even
-		   if the local_lease mount option is set, but there
-		   are servers which do not support oplock for which
-		   this mount option may be useful if the user
-		   knows that the file won't be changed on the server
-		   by anyone else */
+		 !CIFS_CACHE_READ(CIFS_I(inode)))
+		/*
+		 * If the server claims to support oplock on this file, then we
+		 * still need to check oplock even if the local_lease mount
+		 * option is set, but there are servers which do not support
+		 * oplock for which this mount option may be useful if the user
+		 * knows that the file won't be changed on the server by anyone
+		 * else.
+		 */
 		return generic_setlease(file, arg, lease);
 	else
 		return -EAGAIN;

commit 3ae35cde67c1ec50267bcc55d81f4953b5f637c2
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jul 30 13:34:40 2013 -0400

    cifs: display iocharset= option in /proc/mounts
    
    ...but only if it's not the default charset.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 85ea98d139fc..d70e551f0bfb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -357,6 +357,18 @@ cifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)
 		seq_printf(s, "loose");
 }
 
+static void
+cifs_show_nls(struct seq_file *s, struct nls_table *cur)
+{
+	struct nls_table *def;
+
+	/* Display iocharset= option if it's not default charset */
+	def = load_nls_default();
+	if (def != cur)
+		seq_printf(s, ",iocharset=%s", cur->charset);
+	unload_nls(def);
+}
+
 /*
  * cifs_show_options() is for displaying mount options in /proc/mounts.
  * Not all settable options are displayed but most of the important
@@ -418,6 +430,9 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_printf(s, ",file_mode=0%ho,dir_mode=0%ho",
 					   cifs_sb->mnt_file_mode,
 					   cifs_sb->mnt_dir_mode);
+
+	cifs_show_nls(s, cifs_sb->local_nls);
+
 	if (tcon->seal)
 		seq_printf(s, ",seal");
 	if (tcon->nocase)

commit 66ffd113f5d81e951b0379acfd0a1df0771d8828
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jul 30 11:38:44 2013 -0400

    cifs: set sb->s_d_op before calling d_make_root()
    
    Currently, the s_root dentry doesn't get its d_op pointer set to
    anything. This breaks lookups in the root of case-insensitive mounts
    since that relies on having d_hash and d_compare routines that know to
    treat the filename as case-insensitive.
    
    cifs.ko has been broken this way for a long time, but commit 1c929cfe6
    ("switch cifs"), added a cryptic comment which is removed in the patch
    below, which makes me wonder if this was done deliberately for some
    reason. It's not clear to me why we'd want the s_root not to have d_op
    set properly.
    
    It may have something to do with d_automount or d_revalidate on the
    root, but my suspicion in looking over the code is that Al was just
    trying to preserve the existing behavior when changing this code over to
    use s_d_op.
    
    This patch changes it so that we set s_d_op before calling d_make_root
    and removes the comment. I tested mounting, accessing and unmounting
    several types of shares (including DFS referrals) and everything still
    seemed to work OK afterward. I could be missing something however, so
    please do let me know if I am.
    
    Reported-by: Jan-Marek Glogowski <glogow@fbihome.de>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Ian Kent <raven@themaw.net>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4bdd547dbf6f..85ea98d139fc 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -147,18 +147,17 @@ cifs_read_super(struct super_block *sb)
 		goto out_no_root;
 	}
 
+	if (cifs_sb_master_tcon(cifs_sb)->nocase)
+		sb->s_d_op = &cifs_ci_dentry_ops;
+	else
+		sb->s_d_op = &cifs_dentry_ops;
+
 	sb->s_root = d_make_root(inode);
 	if (!sb->s_root) {
 		rc = -ENOMEM;
 		goto out_no_root;
 	}
 
-	/* do that *after* d_make_root() - we want NULL ->d_op for root here */
-	if (cifs_sb_master_tcon(cifs_sb)->nocase)
-		sb->s_d_op = &cifs_ci_dentry_ops;
-	else
-		sb->s_d_op = &cifs_dentry_ops;
-
 #ifdef CONFIG_CIFS_NFSD_EXPORT
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {
 		cifs_dbg(FYI, "export ops supported\n");

commit d4141531f63a29bb2a980092b6f2828c385e6edd
Merge: f39d420f672f 7ac0febb8125
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 14:06:30 2013 -0700

    Merge branch 'for-next' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull cifs updates from Steve French:
     "Various CIFS/SMB2/SMB3 updates for 3.11.  Includes bug fixes - SMB3
      support should be much more stable with key DFS fix and also signing
      possible now (although is more work to do to get SMB3 signing working
      well with multiuser).
    
      Mounts using the new SMB 3.02 dialect can now be done (specify
      "vers=3.02" on mount) against the most current Microsoft systems.
    
      Also includes a big cleanup of the cifs/smb2/smb3 authentication code
      from Jeff which fixes some long standing problems with the way allowed
      authentication flavors and signing are configured.
    
      Some followon patches later in the cycle will clean up allocation of
      structures for the various security mechanisms depending on what
      dialect is chosen (reduces memory usage a little) and to add support
      for the secure negotiate fsctl (for smb3) which prevents downgrade
      attacks."
    
    * 'for-next' of git://git.samba.org/sfrench/cifs-2.6: (39 commits)
      cifs: fill TRANS2_QUERY_FILE_INFO ByteCount fields
      cifs: fix SMB2 signing enablement in cifs_enable_signing
      [CIFS] Fix build warning
      [CIFS] SMB3 Signing enablement
      [CIFS] Do not set DFS flag on SMB2 open
      [CIFS] fix static checker warning
      cifs: try to handle the MUST SecurityFlags sanely
      When server doesn't provide SecurityBuffer on SMB2Negotiate pick default
      Handle big endianness in NTLM (ntlmv2) authentication
      revalidate directories instiantiated via FIND_* in order to handle DFS referrals
      SMB2 FSCTL and IOCTL worker function
      Charge at least one credit, if server says that it supports multicredit
      Remove typo
      Some missing share flags
      cifs: using strlcpy instead of strncpy
      Update headers to update various SMB3 ioctl definitions
      Update cifs version number
      Add ability to dipslay SMB3 share flags and capabilities for debugging
      Add some missing SMB3 and SMB3.02 flags
      Add SMB3.02 dialect support
      ...

commit 1c8c601a8c0dc59fe64907dcd9d512a3d181ddc7
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:15 2013 -0400

    locks: protect most of the file_lock handling with i_lock
    
    Having a global lock that protects all of this code is a clear
    scalability problem. Instead of doing that, move most of the code to be
    protected by the i_lock instead. The exceptions are the global lists
    that the ->fl_link sits on, and the ->fl_block list.
    
    ->fl_link is what connects these structures to the
    global lists, so we must ensure that we hold those locks when iterating
    over or updating these lists.
    
    Furthermore, sound deadlock detection requires that we hold the
    blocked_list state steady while checking for loops. We also must ensure
    that the search and update to the list are atomic.
    
    For the checking and insertion side of the blocked_list, push the
    acquisition of the global lock into __posix_lock_file and ensure that
    checking and update of the  blocked_list is done without dropping the
    lock in between.
    
    On the removal side, when waking up blocked lock waiters, take the
    global lock before walking the blocked list and dequeue the waiters from
    the global list prior to removal from the fl_block list.
    
    With this, deadlock detection should be race free while we minimize
    excessive file_lock_lock thrashing.
    
    Finally, in order to avoid a lock inversion problem when handling
    /proc/locks output we must ensure that manipulations of the fl_block
    list are also protected by the file_lock_lock.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 540c1ccfcdb2..a445e71746fa 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -765,7 +765,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)
 
 static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 {
-	/* note that this is called by vfs setlease with lock_flocks held
+	/* note that this is called by vfs setlease with i_lock held
 	   to protect *lease from going away */
 	struct inode *inode = file_inode(file);
 	struct cifsFileInfo *cfile = file->private_data;

commit be4ccdcc2575ae154426083765b8b8eb9253c925
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 22 16:17:25 2013 -0400

    [readdir] convert cifs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3752b9f6d9e4..540c1ccfcdb2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -968,7 +968,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 };
 
 const struct file_operations cifs_dir_ops = {
-	.readdir = cifs_readdir,
+	.iterate = cifs_readdir,
 	.release = cifs_closedir,
 	.read    = generic_read_dir,
 	.unlocked_ioctl  = cifs_ioctl,

commit 28e11bd86d63ce18b481cd9f90bd5fa1b5ba746b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun May 26 07:01:00 2013 -0400

    cifs: add new fields to cifs_ses to track requested security flavor
    
    Currently we have the overrideSecFlg field, but it's quite cumbersome
    to work with. Add some new fields that will eventually supercede it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3752b9f6d9e4..0f36654f22d0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -312,11 +312,14 @@ cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 }
 
 static void
-cifs_show_security(struct seq_file *s, struct TCP_Server_Info *server)
+cifs_show_security(struct seq_file *s, struct cifs_ses *ses)
 {
+	if (ses->sectype == Unspecified)
+		return;
+
 	seq_printf(s, ",sec=");
 
-	switch (server->secType) {
+	switch (ses->sectype) {
 	case LANMAN:
 		seq_printf(s, "lanman");
 		break;
@@ -338,7 +341,7 @@ cifs_show_security(struct seq_file *s, struct TCP_Server_Info *server)
 		break;
 	}
 
-	if (server->sec_mode & (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))
+	if (ses->sign)
 		seq_printf(s, "i");
 }
 
@@ -369,7 +372,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
 	seq_printf(s, ",vers=%s", tcon->ses->server->vals->version_string);
-	cifs_show_security(s, tcon->ses->server);
+	cifs_show_security(s, tcon->ses);
 	cifs_show_cache_flavor(s, cifs_sb);
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)

commit 9c9c29e1af2ff0459087876e3800078555794b60
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri May 24 07:40:05 2013 -0400

    cifs: stop printing the unc= option in /proc/mounts
    
    Since we no longer recognize that option, stop printing it out. The
    devicename is now the canonical source for this info.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 72e4efee1389..3752b9f6d9e4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -372,9 +372,6 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	cifs_show_security(s, tcon->ses->server);
 	cifs_show_cache_flavor(s, cifs_sb);
 
-	seq_printf(s, ",unc=");
-	seq_escape(s, tcon->treeName, " \t\n\\");
-
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)
 		seq_printf(s, ",multiuser");
 	else if (tcon->ses->user_name)

commit f96637be081141d6f8813429499f164260b49d70
Author: Joe Perches <joe@perches.com>
Date:   Sat May 4 22:12:25 2013 -0500

    [CIFS] cifs: Rename cERROR and cFYI to cifs_dbg
    
    It's not obvious from reading the macro names that these macros
    are for debugging.  Convert the names to a single more typical
    kernel style cifs_dbg macro.
    
            cERROR(1, ...)   -> cifs_dbg(VFS, ...)
            cFYI(1, ...)     -> cifs_dbg(FYI, ...)
            cFYI(DBG2, ...)  -> cifs_dbg(NOISY, ...)
    
    Move the terminating format newline from the macro to the call site.
    
    Add CONFIG_CIFS_DEBUG function cifs_vfs_err to emit the
    "CIFS VFS: " prefix for VFS messages.
    
    Size is reduced ~ 1% when CONFIG_CIFS_DEBUG is set (default y)
    
    $ size fs/cifs/cifs.ko*
       text    data     bss     dec     hex filename
     265245    2525     132  267902   4167e fs/cifs/cifs.ko.new
     268359    2525     132  271016   422a8 fs/cifs/cifs.ko.old
    
    Other miscellaneous changes around these conversions:
    
    o Miscellaneous typo fixes
    o Add terminating \n's to almost all formats and remove them
      from the macros to be more kernel style like.  A few formats
      previously had defective \n's
    o Remove unnecessary OOM messages as kmalloc() calls dump_stack
    o Coalesce formats to make grep easier,
      added missing spaces when coalescing formats
    o Use %s, __func__ instead of embedded function name
    o Removed unnecessary "cifs: " prefixes
    o Convert kzalloc with multiply to kcalloc
    o Remove unused cifswarn macro
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 345fc89c4286..72e4efee1389 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -161,7 +161,7 @@ cifs_read_super(struct super_block *sb)
 
 #ifdef CONFIG_CIFS_NFSD_EXPORT
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {
-		cFYI(1, "export ops supported");
+		cifs_dbg(FYI, "export ops supported\n");
 		sb->s_export_op = &cifs_export_ops;
 	}
 #endif /* CONFIG_CIFS_NFSD_EXPORT */
@@ -169,7 +169,7 @@ cifs_read_super(struct super_block *sb)
 	return 0;
 
 out_no_root:
-	cERROR(1, "cifs_read_super: get root inode failed");
+	cifs_dbg(VFS, "%s: get root inode failed\n", __func__);
 	return rc;
 }
 
@@ -502,7 +502,7 @@ static void cifs_umount_begin(struct super_block *sb)
 	/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */
 	/* cancel_notify_requests(tcon); */
 	if (tcon->ses && tcon->ses->server) {
-		cFYI(1, "wake up tasks now - umount begin not complete");
+		cifs_dbg(FYI, "wake up tasks now - umount begin not complete\n");
 		wake_up_all(&tcon->ses->server->request_q);
 		wake_up_all(&tcon->ses->server->response_q);
 		msleep(1); /* yield */
@@ -573,7 +573,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	if (full_path == NULL)
 		return ERR_PTR(-ENOMEM);
 
-	cFYI(1, "Get root dentry for %s", full_path);
+	cifs_dbg(FYI, "Get root dentry for %s\n", full_path);
 
 	sep = CIFS_DIR_SEP(cifs_sb);
 	dentry = dget(sb->s_root);
@@ -632,7 +632,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	struct cifs_mnt_data mnt_data;
 	struct dentry *root;
 
-	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
+	cifs_dbg(FYI, "Devname: %s flags: %d\n", dev_name, flags);
 
 	volume_info = cifs_get_volume_info((char *)data, dev_name);
 	if (IS_ERR(volume_info))
@@ -655,7 +655,8 @@ cifs_do_mount(struct file_system_type *fs_type,
 	rc = cifs_mount(cifs_sb, volume_info);
 	if (rc) {
 		if (!(flags & MS_SILENT))
-			cERROR(1, "cifs_mount failed w/return code = %d", rc);
+			cifs_dbg(VFS, "cifs_mount failed w/return code = %d\n",
+				 rc);
 		root = ERR_PTR(rc);
 		goto out_mountdata;
 	}
@@ -675,7 +676,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	}
 
 	if (sb->s_root) {
-		cFYI(1, "Use existing superblock");
+		cifs_dbg(FYI, "Use existing superblock\n");
 		cifs_umount(cifs_sb);
 	} else {
 		rc = cifs_read_super(sb);
@@ -691,7 +692,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	if (IS_ERR(root))
 		goto out_super;
 
-	cFYI(1, "dentry root is: %p", root);
+	cifs_dbg(FYI, "dentry root is: %p\n", root);
 	goto out;
 
 out_super:
@@ -723,7 +724,8 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 
 	rc = filemap_fdatawrite(inode->i_mapping);
 	if (rc)
-		cFYI(1, "cifs_file_aio_write: %d rc on %p inode", rc, inode);
+		cifs_dbg(FYI, "cifs_file_aio_write: %d rc on %p inode\n",
+			 rc, inode);
 
 	return written;
 }
@@ -1030,7 +1032,10 @@ cifs_init_request_bufs(void)
 	} else {
 		CIFSMaxBufSize &= 0x1FE00; /* Round size to even 512 byte mult*/
 	}
-/*	cERROR(1, "CIFSMaxBufSize %d 0x%x",CIFSMaxBufSize,CIFSMaxBufSize); */
+/*
+	cifs_dbg(VFS, "CIFSMaxBufSize %d 0x%x\n",
+		 CIFSMaxBufSize, CIFSMaxBufSize);
+*/
 	cifs_req_cachep = kmem_cache_create("cifs_request",
 					    CIFSMaxBufSize + max_hdr_size, 0,
 					    SLAB_HWCACHE_ALIGN, NULL);
@@ -1041,7 +1046,7 @@ cifs_init_request_bufs(void)
 		cifs_min_rcv = 1;
 	else if (cifs_min_rcv > 64) {
 		cifs_min_rcv = 64;
-		cERROR(1, "cifs_min_rcv set to maximum (64)");
+		cifs_dbg(VFS, "cifs_min_rcv set to maximum (64)\n");
 	}
 
 	cifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,
@@ -1072,7 +1077,7 @@ cifs_init_request_bufs(void)
 		cifs_min_small = 2;
 	else if (cifs_min_small > 256) {
 		cifs_min_small = 256;
-		cFYI(1, "cifs_min_small set to maximum (256)");
+		cifs_dbg(FYI, "cifs_min_small set to maximum (256)\n");
 	}
 
 	cifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,
@@ -1163,10 +1168,11 @@ init_cifs(void)
 
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
-		cFYI(1, "cifs_max_pending set to min of 2");
+		cifs_dbg(FYI, "cifs_max_pending set to min of 2\n");
 	} else if (cifs_max_pending > CIFS_MAX_REQ) {
 		cifs_max_pending = CIFS_MAX_REQ;
-		cFYI(1, "cifs_max_pending set to max of %u", CIFS_MAX_REQ);
+		cifs_dbg(FYI, "cifs_max_pending set to max of %u\n",
+			 CIFS_MAX_REQ);
 	}
 
 	cifsiod_wq = alloc_workqueue("cifsiod", WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
@@ -1235,7 +1241,7 @@ init_cifs(void)
 static void __exit
 exit_cifs(void)
 {
-	cFYI(DBG2, "exit_cifs");
+	cifs_dbg(NOISY, "exit_cifs\n");
 	unregister_filesystem(&cifs_fs_type);
 	cifs_dfs_release_automount_timer();
 #ifdef CONFIG_CIFS_ACL

commit 9217cbb8df31c10efc96362227b2ebdbb9fe996c
Merge: d3c926264a92 f853c616883a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 21 17:59:22 2013 -0700

    Merge branch 'for-next' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull CIFS fixes from Steve French:
     "Three small CIFS Fixes (the most important of the three fixes a recent
      problem authenticating to Windows 8 using cifs rather than SMB2)"
    
    * 'for-next' of git://git.samba.org/sfrench/cifs-2.6:
      cifs: ignore everything in SPNEGO blob after mechTypes
      cifs: delay super block destruction until all cifsFileInfo objects are gone
      cifs: map NT_STATUS_SHARING_VIOLATION to EBUSY instead of ETXTBSY

commit 24261fc23db950951760d00c188ba63cc756b932
Author: Mateusz Guzik <mguzik@redhat.com>
Date:   Fri Mar 8 16:30:03 2013 +0100

    cifs: delay super block destruction until all cifsFileInfo objects are gone
    
    cifsFileInfo objects hold references to dentries and it is possible that
    these will still be around in workqueues when VFS decides to kill super
    block during unmount.
    
    This results in panics like this one:
    BUG: Dentry ffff88001f5e76c0{i=66b4a,n=1M-2} still in use (1) [unmount of cifs cifs]
    ------------[ cut here ]------------
    kernel BUG at fs/dcache.c:943!
    [..]
    Process umount (pid: 1781, threadinfo ffff88003d6e8000, task ffff880035eeaec0)
    [..]
    Call Trace:
     [<ffffffff811b44f3>] shrink_dcache_for_umount+0x33/0x60
     [<ffffffff8119f7fc>] generic_shutdown_super+0x2c/0xe0
     [<ffffffff8119f946>] kill_anon_super+0x16/0x30
     [<ffffffffa036623a>] cifs_kill_sb+0x1a/0x30 [cifs]
     [<ffffffff8119fcc7>] deactivate_locked_super+0x57/0x80
     [<ffffffff811a085e>] deactivate_super+0x4e/0x70
     [<ffffffff811bb417>] mntput_no_expire+0xd7/0x130
     [<ffffffff811bc30c>] sys_umount+0x9c/0x3c0
     [<ffffffff81657c19>] system_call_fastpath+0x16/0x1b
    
    Fix this by making each cifsFileInfo object hold a reference to cifs
    super block, which implicitly keeps VFS super block around as well.
    
    Signed-off-by: Mateusz Guzik <mguzik@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Cc: <stable@vger.kernel.org>
    Reported-and-Tested-by: Ben Greear <greearb@candelatech.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1a052c0eee8e..054b90b682a7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -91,6 +91,30 @@ struct workqueue_struct	*cifsiod_wq;
 __u8 cifs_client_guid[SMB2_CLIENT_GUID_SIZE];
 #endif
 
+/*
+ * Bumps refcount for cifs super block.
+ * Note that it should be only called if a referece to VFS super block is
+ * already held, e.g. in open-type syscalls context. Otherwise it can race with
+ * atomic_dec_and_test in deactivate_locked_super.
+ */
+void
+cifs_sb_active(struct super_block *sb)
+{
+	struct cifs_sb_info *server = CIFS_SB(sb);
+
+	if (atomic_inc_return(&server->active) == 1)
+		atomic_inc(&sb->s_active);
+}
+
+void
+cifs_sb_deactive(struct super_block *sb)
+{
+	struct cifs_sb_info *server = CIFS_SB(sb);
+
+	if (atomic_dec_and_test(&server->active))
+		deactivate_super(sb);
+}
+
 static int
 cifs_read_super(struct super_block *sb)
 {

commit 3e64fe5b21852375f2f53e7244ba697f1fee2fcf
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Mar 11 07:05:42 2013 -0700

    fs: Limit sys_mount to only request filesystem modules. (Part 3)
    
    Somehow I failed to add the MODULE_ALIAS_FS for cifs, hostfs, hpfs,
    squashfs, and udf despite what I thought were my careful checks :(
    
    Add them now.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1a052c0eee8e..3cf8a15af916 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -777,6 +777,7 @@ struct file_system_type cifs_fs_type = {
 	.kill_sb = cifs_kill_sb,
 	/*  .fs_flags */
 };
+MODULE_ALIAS_FS("cifs");
 const struct inode_operations cifs_dir_inode_ops = {
 	.create = cifs_create,
 	.atomic_open = cifs_atomic_open,

commit ce2ac52105aa663056dfc17966ebed1bf93e6e64
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Feb 1 15:11:01 2013 -0500

    cifs: ensure that cifs_get_root() only traverses directories
    
    Kjell Braden reported this oops:
    
    [  833.211970] BUG: unable to handle kernel NULL pointer dereference at           (null)
    [  833.212816] IP: [<          (null)>]           (null)
    [  833.213280] PGD 1b9b2067 PUD e9f7067 PMD 0
    [  833.213874] Oops: 0010 [#1] SMP
    [  833.214344] CPU 0
    [  833.214458] Modules linked in: des_generic md4 nls_utf8 cifs vboxvideo drm snd_intel8x0 snd_ac97_codec ac97_bus snd_pcm snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq bnep rfcomm snd_timer bluetooth snd_seq_device ppdev snd vboxguest parport_pc joydev mac_hid soundcore snd_page_alloc psmouse i2c_piix4 serio_raw lp parport usbhid hid e1000
    [  833.215629]
    [  833.215629] Pid: 1752, comm: mount.cifs Not tainted 3.0.0-rc7-bisectcifs-fec11dd9a0+ #18 innotek GmbH VirtualBox/VirtualBox
    [  833.215629] RIP: 0010:[<0000000000000000>]  [<          (null)>]           (null)
    [  833.215629] RSP: 0018:ffff8800119c9c50  EFLAGS: 00010282
    [  833.215629] RAX: ffffffffa02186c0 RBX: ffff88000c427780 RCX: 0000000000000000
    [  833.215629] RDX: 0000000000000000 RSI: ffff88000c427780 RDI: ffff88000c4362e8
    [  833.215629] RBP: ffff8800119c9c88 R08: ffff88001fc15e30 R09: 00000000d69515c7
    [  833.215629] R10: ffffffffa0201972 R11: ffff88000e8f6a28 R12: ffff88000c4362e8
    [  833.215629] R13: 0000000000000000 R14: 0000000000000000 R15: ffff88001181aaa6
    [  833.215629] FS:  00007f2986171700(0000) GS:ffff88001fc00000(0000) knlGS:0000000000000000
    [  833.215629] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [  833.215629] CR2: 0000000000000000 CR3: 000000001b982000 CR4: 00000000000006f0
    [  833.215629] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  833.215629] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  833.215629] Process mount.cifs (pid: 1752, threadinfo ffff8800119c8000, task ffff88001c1c16f0)
    [  833.215629] Stack:
    [  833.215629]  ffffffff8116a9b5 ffff8800119c9c88 ffffffff81178075 0000000000000286
    [  833.215629]  0000000000000000 ffff88000c4276c0 ffff8800119c9ce8 ffff8800119c9cc8
    [  833.215629]  ffffffff8116b06e ffff88001bc6fc00 ffff88000c4276c0 ffff88000c4276c0
    [  833.215629] Call Trace:
    [  833.215629]  [<ffffffff8116a9b5>] ? d_alloc_and_lookup+0x45/0x90
    [  833.215629]  [<ffffffff81178075>] ? d_lookup+0x35/0x60
    [  833.215629]  [<ffffffff8116b06e>] __lookup_hash.part.14+0x9e/0xc0
    [  833.215629]  [<ffffffff8116b1d6>] lookup_one_len+0x146/0x1e0
    [  833.215629]  [<ffffffff815e4f7e>] ? _raw_spin_lock+0xe/0x20
    [  833.215629]  [<ffffffffa01eef0d>] cifs_do_mount+0x26d/0x500 [cifs]
    [  833.215629]  [<ffffffff81163bd3>] mount_fs+0x43/0x1b0
    [  833.215629]  [<ffffffff8117d41a>] vfs_kern_mount+0x6a/0xd0
    [  833.215629]  [<ffffffff8117e584>] do_kern_mount+0x54/0x110
    [  833.215629]  [<ffffffff8117fdc2>] do_mount+0x262/0x840
    [  833.215629]  [<ffffffff81108a0e>] ? __get_free_pages+0xe/0x50
    [  833.215629]  [<ffffffff8117f9ca>] ? copy_mount_options+0x3a/0x180
    [  833.215629]  [<ffffffff8118075d>] sys_mount+0x8d/0xe0
    [  833.215629]  [<ffffffff815ece82>] system_call_fastpath+0x16/0x1b
    [  833.215629] Code:  Bad RIP value.
    [  833.215629] RIP  [<          (null)>]           (null)
    [  833.215629]  RSP <ffff8800119c9c50>
    [  833.215629] CR2: 0000000000000000
    [  833.238525] ---[ end trace ec00758b8d44f529 ]---
    
    When walking down the path on the server, it's possible to hit a
    symlink. The path walking code assumes that the caller will handle that
    situation properly, but cifs_get_root() isn't set up for it. This patch
    prevents the oops by simply returning an error.
    
    A better solution would be to try and chase the symlinks here, but that's
    fairly complicated to handle.
    
    Fixes:
    
        https://bugzilla.kernel.org/show_bug.cgi?id=53221
    
    Reported-and-tested-by: Kjell Braden <afflux@pentabarf.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4bad7b16271f..1a052c0eee8e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -564,6 +564,11 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 			dentry = ERR_PTR(-ENOENT);
 			break;
 		}
+		if (!S_ISDIR(dir->i_mode)) {
+			dput(dentry);
+			dentry = ERR_PTR(-ENOTDIR);
+			break;
+		}
 
 		/* skip separators */
 		while (*s == sep)

commit d895cb1af15c04c522a25c79cc429076987c089b
Merge: 9626357371b5 d3d009cb965e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 26 20:16:07 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile (part one) from Al Viro:
     "Assorted stuff - cleaning namei.c up a bit, fixing ->d_name/->d_parent
      locking violations, etc.
    
      The most visible changes here are death of FS_REVAL_DOT (replaced with
      "has ->d_weak_revalidate()") and a new helper getting from struct file
      to inode.  Some bits of preparation to xattr method interface changes.
    
      Misc patches by various people sent this cycle *and* ocfs2 fixes from
      several cycles ago that should've been upstream right then.
    
      PS: the next vfs pile will be xattr stuff."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (46 commits)
      saner proc_get_inode() calling conventions
      proc: avoid extra pde_put() in proc_fill_super()
      fs: change return values from -EACCES to -EPERM
      fs/exec.c: make bprm_mm_init() static
      ocfs2/dlm: use GFP_ATOMIC inside a spin_lock
      ocfs2: fix possible use-after-free with AIO
      ocfs2: Fix oops in ocfs2_fast_symlink_readpage() code path
      get_empty_filp()/alloc_file() leave both ->f_pos and ->f_version zero
      target: writev() on single-element vector is pointless
      export kernel_write(), convert open-coded instances
      fs: encode_fh: return FILEID_INVALID if invalid fid_type
      kill f_vfsmnt
      vfs: kill FS_REVAL_DOT by adding a d_weak_revalidate dentry op
      nfsd: handle vfs_getattr errors in acl protocol
      switch vfs_getattr() to struct path
      default SET_PERSONALITY() in linux/elf.h
      ceph: prepopulate inodes only when request is aborted
      d_hash_and_lookup(): export, switch open-coded instances
      9p: switch v9fs_set_create_acl() to inode+fid, do it before d_instantiate()
      9p: split dropping the acls from v9fs_set_create_acl()
      ...

commit 94f2f14234178f118545a0be60a6371ddeb229b7
Merge: 8d168f71551e 139321c65c05
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 16:00:49 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace and namespace infrastructure changes from Eric W Biederman:
     "This set of changes starts with a few small enhnacements to the user
      namespace.  reboot support, allowing more arbitrary mappings, and
      support for mounting devpts, ramfs, tmpfs, and mqueuefs as just the
      user namespace root.
    
      I do my best to document that if you care about limiting your
      unprivileged users that when you have the user namespace support
      enabled you will need to enable memory control groups.
    
      There is a minor bug fix to prevent overflowing the stack if someone
      creates way too many user namespaces.
    
      The bulk of the changes are a continuation of the kuid/kgid push down
      work through the filesystems.  These changes make using uids and gids
      typesafe which ensures that these filesystems are safe to use when
      multiple user namespaces are in use.  The filesystems converted for
      3.9 are ceph, 9p, afs, ocfs2, gfs2, ncpfs, nfs, nfsd, and cifs.  The
      changes for these filesystems were a little more involved so I split
      the changes into smaller hopefully obviously correct changes.
    
      XFS is the only filesystem that remains.  I was hoping I could get
      that in this release so that user namespace support would be enabled
      with an allyesconfig or an allmodconfig but it looks like the xfs
      changes need another couple of days before it they are ready."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (93 commits)
      cifs: Enable building with user namespaces enabled.
      cifs: Convert struct cifs_ses to use a kuid_t and a kgid_t
      cifs: Convert struct cifs_sb_info to use kuids and kgids
      cifs: Modify struct smb_vol to use kuids and kgids
      cifs: Convert struct cifsFileInfo to use a kuid
      cifs: Convert struct cifs_fattr to use kuid and kgids
      cifs: Convert struct tcon_link to use a kuid.
      cifs: Modify struct cifs_unix_set_info_args to hold a kuid_t and a kgid_t
      cifs: Convert from a kuid before printing current_fsuid
      cifs: Use kuids and kgids SID to uid/gid mapping
      cifs: Pass GLOBAL_ROOT_UID and GLOBAL_ROOT_GID to keyring_alloc
      cifs: Use BUILD_BUG_ON to validate uids and gids are the same size
      cifs: Override unmappable incoming uids and gids
      nfsd: Enable building with user namespaces enabled.
      nfsd: Properly compare and initialize kuids and kgids
      nfsd: Store ex_anon_uid and ex_anon_gid as kuids and kgids
      nfsd: Modify nfsd4_cb_sec to use kuids and kgids
      nfsd: Handle kuids and kgids in the nfs4acl to posix_acl conversion
      nfsd: Convert nfsxdr to use kuids and kgids
      nfsd: Convert nfs3xdr to use kuids and kgids
      ...

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index de7f9168a118..8b35365c70be 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -677,7 +677,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				   unsigned long nr_segs, loff_t pos)
 {
-	struct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;
+	struct inode *inode = file_inode(iocb->ki_filp);
 	ssize_t written;
 	int rc;
 
@@ -701,7 +701,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)
 	 */
 	if (whence != SEEK_SET && whence != SEEK_CUR) {
 		int rc;
-		struct inode *inode = file->f_path.dentry->d_inode;
+		struct inode *inode = file_inode(file);
 
 		/*
 		 * We need to be sure that all dirty pages are written and the
@@ -733,7 +733,7 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 {
 	/* note that this is called by vfs setlease with lock_flocks held
 	   to protect *lease from going away */
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = file_inode(file);
 	struct cifsFileInfo *cfile = file->private_data;
 
 	if (!(S_ISREG(inode->i_mode)))

commit 1f68233c52e9f2bb53130a0063bc1e6864f6d204
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 6 01:20:20 2013 -0800

    cifs: Convert struct cifs_sb_info to use kuids and kgids
    
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f653835d067b..17590731786d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -376,13 +376,15 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 				   (int)(srcaddr->sa_family));
 	}
 
-	seq_printf(s, ",uid=%u", cifs_sb->mnt_uid);
+	seq_printf(s, ",uid=%u",
+		   from_kuid_munged(&init_user_ns, cifs_sb->mnt_uid));
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)
 		seq_printf(s, ",forceuid");
 	else
 		seq_printf(s, ",noforceuid");
 
-	seq_printf(s, ",gid=%u", cifs_sb->mnt_gid);
+	seq_printf(s, ",gid=%u",
+		   from_kgid_munged(&init_user_ns, cifs_sb->mnt_gid));
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)
 		seq_printf(s, ",forcegid");
 	else
@@ -437,9 +439,13 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)
 		seq_printf(s, ",noperm");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID)
-		seq_printf(s, ",backupuid=%u", cifs_sb->mnt_backupuid);
+		seq_printf(s, ",backupuid=%u",
+			   from_kuid_munged(&init_user_ns,
+					    cifs_sb->mnt_backupuid));
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID)
-		seq_printf(s, ",backupgid=%u", cifs_sb->mnt_backupgid);
+		seq_printf(s, ",backupgid=%u",
+			   from_kgid_munged(&init_user_ns,
+					    cifs_sb->mnt_backupgid));
 
 	seq_printf(s, ",rsize=%u", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%u", cifs_sb->wsize);

commit ca8aa29c60238720af2ca2a5caab25fa0c70067e
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Dec 21 15:05:47 2012 +0400

    Revert "CIFS: Fix write after setting a read lock for read oplock files"
    
    that solution has data races and can end up two identical writes to the
    server: when clientCanCacheAll value can be changed during the execution
    of __generic_file_aio_write.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f653835d067b..de7f9168a118 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -228,7 +228,6 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_set_oplock_level(cifs_inode, 0);
 	cifs_inode->delete_pending = false;
 	cifs_inode->invalid_mapping = false;
-	cifs_inode->leave_pages_clean = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
 	cifs_inode->server_eof = 0;
 	cifs_inode->uniqueid = 0;

commit 9acbd26b0a5ac4a3d52d31034feb3d935e39032a
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Dec 18 06:35:10 2012 -0500

    cifs: eliminate cifsERROR variable
    
    It's always set to "1" and there's no way to change it to anything else.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ce9f3c5421bf..f653835d067b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -54,7 +54,6 @@
 #endif
 
 int cifsFYI = 0;
-int cifsERROR = 1;
 int traceSMB = 0;
 bool enable_oplocks = true;
 unsigned int linuxExtEnabled = 1;

commit 965c8e59cfcf845ecde2265a1d1bfee5f011d302
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Dec 17 15:59:39 2012 -0800

    lseek: the "whence" argument is called "whence"
    
    But the kernel decided to call it "origin" instead.  Fix most of the
    sites.
    
    Acked-by: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 210f0af83fc4..ce9f3c5421bf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -695,13 +695,13 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	return written;
 }
 
-static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
+static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)
 {
 	/*
-	 * origin == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate
+	 * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate
 	 * the cached file length
 	 */
-	if (origin != SEEK_SET && origin != SEEK_CUR) {
+	if (whence != SEEK_SET && whence != SEEK_CUR) {
 		int rc;
 		struct inode *inode = file->f_path.dentry->d_inode;
 
@@ -728,7 +728,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 		if (rc < 0)
 			return (loff_t)rc;
 	}
-	return generic_file_llseek(file, offset, origin);
+	return generic_file_llseek(file, offset, whence);
 }
 
 static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)

commit c299dd0e2d3dd61d0048a9d9b021aa01f023ed0c
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Dec 6 22:07:52 2012 +0400

    CIFS: Fix write after setting a read lock for read oplock files
    
    If we have a read oplock and set a read lock in it, we can't write to the
    locked area - so, filemap_fdatawrite may fail with a no information for a
    userspace application even if we request a write to non-locked area. Fix
    this by populating the page cache without marking affected pages dirty
    after a successful write directly to the server.
    
    Also remove CONFIG_CIFS_SMB2 ifdefs because it's suitable for both CIFS
    and SMB2 protocols.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c6e32f22fbd3..210f0af83fc4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -229,6 +229,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_set_oplock_level(cifs_inode, 0);
 	cifs_inode->delete_pending = false;
 	cifs_inode->invalid_mapping = false;
+	cifs_inode->leave_pages_clean = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
 	cifs_inode->server_eof = 0;
 	cifs_inode->uniqueid = 0;

commit faa65f07d21e7d37190c91fdcf9f940d733ae3cc
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 3 06:05:29 2012 -0500

    cifs: simplify id_to_sid and sid_to_id mapping code
    
    The cifs.idmap handling code currently causes the kernel to cache the
    data from userspace twice. It first looks in a rbtree to see if there is
    a matching entry for the given id. If there isn't then it calls
    request_key which then checks its cache and then calls out to userland
    if it doesn't have one. If the userland program establishes a mapping
    and downcalls with that info, it then gets cached in the keyring and in
    this rbtree.
    
    Aside from the double memory usage and the performance penalty in doing
    all of these extra copies, there are some nasty bugs in here too. The
    code declares four rbtrees and spinlocks to protect them, but only seems
    to use two of them. The upshot is that the same tree is used to hold
    (eg) uid:sid and sid:uid mappings. The comparitors aren't equipped to
    deal with that.
    
    I think we'd be best off to remove a layer of caching in this code. If
    this was originally done for performance reasons, then that really seems
    like a premature optimization.
    
    This patch does that -- it removes the rbtrees and the locks that
    protect them and simply has the code do a request_key call on each call
    into sid_to_id and id_to_sid. This greatly simplifies this code and
    should roughly halve the memory utilization from using the idmapping
    code.
    
    Reviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 273b34904d5b..c6e32f22fbd3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1204,7 +1204,6 @@ exit_cifs(void)
 	unregister_filesystem(&cifs_fs_type);
 	cifs_dfs_release_automount_timer();
 #ifdef CONFIG_CIFS_ACL
-	cifs_destroy_idmaptrees();
 	exit_cifs_idmap();
 #endif
 #ifdef CONFIG_CIFS_UPCALL

commit 6d3ea7e4975aed451fbee4dea2fef63b0de8cb4f
Author: Steve French <smfrench@gmail.com>
Date:   Wed Nov 28 22:34:41 2012 -0600

    CIFS: Make use of common cifs_build_path_to_root for CIFS and SMB2
    
    because the is no difference here. This also adds support of prefixpath
    mount option for SMB2.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 07a8ab527c3a..273b34904d5b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -539,8 +539,8 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	char *s, *p;
 	char sep;
 
-	full_path = build_path_to_root(vol, cifs_sb,
-				       cifs_sb_master_tcon(cifs_sb));
+	full_path = cifs_build_path_to_root(vol, cifs_sb,
+					    cifs_sb_master_tcon(cifs_sb));
 	if (full_path == NULL)
 		return ERR_PTR(-ENOMEM);
 

commit 60654ce047f7be62afa291573501e011297a47d8
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sun Nov 25 08:00:34 2012 -0500

    cifs: fix types on module parameters
    
    Most of these are unsigned ints, so we should be passing "uint" to
    module_param. Also, get rid of the extra "(bool)" in the description
    of enable_oplocks.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e7931cc55d0c..07a8ab527c3a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -64,24 +64,23 @@ unsigned int global_secflags = CIFSSEC_DEF;
 unsigned int sign_CIFS_PDUs = 1;
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
-module_param(CIFSMaxBufSize, int, 0);
+module_param(CIFSMaxBufSize, uint, 0);
 MODULE_PARM_DESC(CIFSMaxBufSize, "Network buffer size (not including header). "
 				 "Default: 16384 Range: 8192 to 130048");
 unsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;
-module_param(cifs_min_rcv, int, 0);
+module_param(cifs_min_rcv, uint, 0);
 MODULE_PARM_DESC(cifs_min_rcv, "Network buffers in pool. Default: 4 Range: "
 				"1 to 64");
 unsigned int cifs_min_small = 30;
-module_param(cifs_min_small, int, 0);
+module_param(cifs_min_small, uint, 0);
 MODULE_PARM_DESC(cifs_min_small, "Small network buffers in pool. Default: 30 "
 				 "Range: 2 to 256");
 unsigned int cifs_max_pending = CIFS_MAX_REQ;
-module_param(cifs_max_pending, int, 0444);
+module_param(cifs_max_pending, uint, 0444);
 MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server. "
 				   "Default: 32767 Range: 2 to 32767.");
 module_param(enable_oplocks, bool, 0644);
-MODULE_PARM_DESC(enable_oplocks, "Enable or disable oplocks (bool). Default:"
-				 "y/Y/1");
+MODULE_PARM_DESC(enable_oplocks, "Enable or disable oplocks. Default: y/Y/1");
 
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;

commit aab174f0df5d72d31caccf281af5f614fa254578
Merge: ca41cc96b281 2bd2c1941f14
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 20:25:04 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs update from Al Viro:
    
     - big one - consolidation of descriptor-related logics; almost all of
       that is moved to fs/file.c
    
       (BTW, I'm seriously tempted to rename the result to fd.c.  As it is,
       we have a situation when file_table.c is about handling of struct
       file and file.c is about handling of descriptor tables; the reasons
       are historical - file_table.c used to be about a static array of
       struct file we used to have way back).
    
       A lot of stray ends got cleaned up and converted to saner primitives,
       disgusting mess in android/binder.c is still disgusting, but at least
       doesn't poke so much in descriptor table guts anymore.  A bunch of
       relatively minor races got fixed in process, plus an ext4 struct file
       leak.
    
     - related thing - fget_light() partially unuglified; see fdget() in
       there (and yes, it generates the code as good as we used to have).
    
     - also related - bits of Cyrill's procfs stuff that got entangled into
       that work; _not_ all of it, just the initial move to fs/proc/fd.c and
       switch of fdinfo to seq_file.
    
     - Alex's fs/coredump.c spiltoff - the same story, had been easier to
       take that commit than mess with conflicts.  The rest is a separate
       pile, this was just a mechanical code movement.
    
     - a few misc patches all over the place.  Not all for this cycle,
       there'll be more (and quite a few currently sit in akpm's tree)."
    
    Fix up trivial conflicts in the android binder driver, and some fairly
    simple conflicts due to two different changes to the sock_alloc_file()
    interface ("take descriptor handling from sock_alloc_file() to callers"
    vs "net: Providing protocol type via system.sockprotoname xattr of
    /proc/PID/fd entries" adding a dentry name to the socket)
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (72 commits)
      MAX_LFS_FILESIZE should be a loff_t
      compat: fs: Generic compat_sys_sendfile implementation
      fs: push rcu_barrier() from deactivate_locked_super() to filesystems
      btrfs: reada_extent doesn't need kref for refcount
      coredump: move core dump functionality into its own file
      coredump: prevent double-free on an error path in core dumper
      usb/gadget: fix misannotations
      fcntl: fix misannotations
      ceph: don't abuse d_delete() on failure exits
      hypfs: ->d_parent is never NULL or negative
      vfs: delete surplus inode NULL check
      switch simple cases of fget_light to fdget
      new helpers: fdget()/fdput()
      switch o2hb_region_dev_write() to fget_light()
      proc_map_files_readdir(): don't bother with grabbing files
      make get_file() return its argument
      vhost_set_vring(): turn pollstart/pollstop into bool
      switch prctl_set_mm_exe_file() to fget_light()
      switch xfs_find_handle() to fget_light()
      switch xfs_swapext() to fget_light()
      ...

commit 8c0a85377048b64c880e76ec7368904fe46d0b94
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Wed Sep 26 11:33:07 2012 +1000

    fs: push rcu_barrier() from deactivate_locked_super() to filesystems
    
    There's no reason to call rcu_barrier() on every
    deactivate_locked_super().  We only need to make sure that all delayed rcu
    free inodes are flushed before we destroy related cache.
    
    Removing rcu_barrier() from deactivate_locked_super() affects some fast
    paths.  E.g.  on my machine exit_group() of a last process in IPC
    namespace takes 0.07538s.  rcu_barrier() takes 0.05188s of that time.
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index db8a404a51dd..d4ce77a02327 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -977,6 +977,11 @@ cifs_init_inodecache(void)
 static void
 cifs_destroy_inodecache(void)
 {
+	/*
+	 * Make sure all delayed rcu free inodes are flushed before we
+	 * destroy cache.
+	 */
+	rcu_barrier();
 	kmem_cache_destroy(cifs_inode_cachep);
 }
 

commit ecdb69e2cc80cca77d6afcc0aca244b72cc5ee68
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Wed Sep 19 06:22:45 2012 -0700

    cifs: Mangle string used for unc in /proc/mounts
    
    The string for "unc=" in /proc/mounts needs to be escaped. The current
    behaviour can create problems in cases when mounting a share starting
    with a number.
    
    example:
    >mount -t cifs -o username=test,password=x vm140-31:/17000-test /mnt
    >mount -o remount,password=x /mnt
    mount error: could not resolve address for vm140-31x00-test: Unknown
    error
    
    The sub-string "\170" which is part of the unc for the mount above in
    /proc/mounts is interpreted as character'x' in the case above. Escaping
    the string fixes the problem.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 28ac048d54ea..a41044a31083 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -350,7 +350,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	cifs_show_security(s, tcon->ses->server);
 	cifs_show_cache_flavor(s, cifs_sb);
 
-	seq_printf(s, ",unc=%s", tcon->treeName);
+	seq_printf(s, ",unc=");
+	seq_escape(s, tcon->treeName, " \t\n\\");
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)
 		seq_printf(s, ",multiuser");

commit b8c32dbb0deb287a5fcb78251e4eae6c7275760d
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Sep 19 06:22:44 2012 -0700

    CIFS: Request SMB2.1 leases
    
    if server supports them and we need oplocks.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4cd68c77ce39..28ac048d54ea 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -36,6 +36,7 @@
 #include <linux/kthread.h>
 #include <linux/freezer.h>
 #include <linux/namei.h>
+#include <linux/random.h>
 #include <net/ipv6.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
@@ -88,6 +89,10 @@ extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
 
+#ifdef CONFIG_CIFS_SMB2
+__u8 cifs_client_guid[SMB2_CLIENT_GUID_SIZE];
+#endif
+
 static int
 cifs_read_super(struct super_block *sb)
 {
@@ -218,9 +223,10 @@ cifs_alloc_inode(struct super_block *sb)
 		return NULL;
 	cifs_inode->cifsAttrs = 0x20;	/* default */
 	cifs_inode->time = 0;
-	/* Until the file is open and we have gotten oplock
-	info back from the server, can not assume caching of
-	file data or metadata */
+	/*
+	 * Until the file is open and we have gotten oplock info back from the
+	 * server, can not assume caching of file data or metadata.
+	 */
 	cifs_set_oplock_level(cifs_inode, 0);
 	cifs_inode->delete_pending = false;
 	cifs_inode->invalid_mapping = false;
@@ -228,10 +234,14 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->server_eof = 0;
 	cifs_inode->uniqueid = 0;
 	cifs_inode->createtime = 0;
-
-	/* Can not set i_flags here - they get immediately overwritten
-	   to zero by the VFS */
-/*	cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;*/
+#ifdef CONFIG_CIFS_SMB2
+	get_random_bytes(cifs_inode->lease_key, SMB2_LEASE_KEY_SIZE);
+#endif
+	/*
+	 * Can not set i_flags here - they get immediately overwritten to zero
+	 * by the VFS.
+	 */
+	/* cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME; */
 	INIT_LIST_HEAD(&cifs_inode->openFileList);
 	INIT_LIST_HEAD(&cifs_inode->llist);
 	return &cifs_inode->vfs_inode;
@@ -1107,6 +1117,10 @@ init_cifs(void)
 	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
+#ifdef CONFIG_CIFS_SMB2
+	get_random_bytes(cifs_client_guid, SMB2_CLIENT_GUID_SIZE);
+#endif
+
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
 		cFYI(1, "cifs_max_pending set to min of 2");

commit 1b4b55a1d9404f51aacf1ff19887eb911484057d
Author: Pavel Shilovsky <pshilovsky@etersoft.ru>
Date:   Wed Sep 19 06:22:44 2012 -0700

    CIFS: Turn lock mutex into rw semaphore
    
    and allow several processes to walk through the lock list and read
    can_cache_brlcks value if they are not going to modify them.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e958d9438505..4cd68c77ce39 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -937,7 +937,7 @@ cifs_init_once(void *inode)
 	struct cifsInodeInfo *cifsi = inode;
 
 	inode_init_once(&cifsi->vfs_inode);
-	mutex_init(&cifsi->lock_mutex);
+	init_rwsem(&cifsi->lock_sem);
 }
 
 static int

commit f45d34167c67b083b54690e349e77f59062ef0ea
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Sep 19 06:22:43 2012 -0700

    CIFS: Remove spinlock dependence in brlock processing
    
    Now we need to lock/unlock a spinlock while processing brlock ops
    on the inode. Move brlocks of a fid to a separate list and attach
    all such lists to the inode. This let us not hold a spinlock.
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3a3e2fee0b3e..e958d9438505 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -233,6 +233,7 @@ cifs_alloc_inode(struct super_block *sb)
 	   to zero by the VFS */
 /*	cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;*/
 	INIT_LIST_HEAD(&cifs_inode->openFileList);
+	INIT_LIST_HEAD(&cifs_inode->llist);
 	return &cifs_inode->vfs_inode;
 }
 

commit 71953fc6e4ce5ac05b594d8e5866accf531aa969
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 19 06:22:42 2012 -0700

    cifs: remove kmap lock and rsize limit
    
    Now that we aren't abusing the kmap address space, there's no need for
    this lock or to impose a limit on the rsize.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4dda4890d776..3a3e2fee0b3e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -88,10 +88,6 @@ extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
 
-#ifdef CONFIG_HIGHMEM
-DEFINE_MUTEX(cifs_kmap_mutex);
-#endif
-
 static int
 cifs_read_super(struct super_block *sb)
 {

commit 76ec5e33846de386f44826f145cd725b92c23630
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:33 2012 -0700

    CIFS: Move statfs to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2829f374dbf7..4dda4890d776 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -51,7 +51,6 @@
 #ifdef CONFIG_CIFS_SMB2
 #include "smb2pdu.h"
 #endif
-#define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
 
 int cifsFYI = 0;
 int cifsERROR = 1;
@@ -164,13 +163,12 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct super_block *sb = dentry->d_sb;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
-	int rc = -EOPNOTSUPP;
+	struct TCP_Server_Info *server = tcon->ses->server;
 	unsigned int xid;
+	int rc = 0;
 
 	xid = get_xid();
 
-	buf->f_type = CIFS_MAGIC_NUMBER;
-
 	/*
 	 * PATH_MAX may be too long - it would presumably be total path,
 	 * but note that some servers (includinng Samba 3) have a shorter
@@ -182,27 +180,8 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_files = 0;	/* undefined */
 	buf->f_ffree = 0;	/* unlimited */
 
-	/*
-	 * We could add a second check for a QFS Unix capability bit
-	 */
-	if ((tcon->ses->capabilities & CAP_UNIX) &&
-	    (CIFS_POSIX_EXTENSIONS & le64_to_cpu(tcon->fsUnixInfo.Capability)))
-		rc = CIFSSMBQFSPosixInfo(xid, tcon, buf);
-
-	/*
-	 * Only need to call the old QFSInfo if failed on newer one,
-	 * e.g. by OS/2.
-	 **/
-	if (rc && (tcon->ses->capabilities & CAP_NT_SMBS))
-		rc = CIFSSMBQFSInfo(xid, tcon, buf);
-
-	/*
-	 * Some old Windows servers also do not support level 103, retry with
-	 * older level one if old server failed the previous call or we
-	 * bypassed it because we detected that this was an older LANMAN sess
-	 */
-	if (rc)
-		rc = SMBOldQFSInfo(xid, tcon, buf);
+	if (server->ops->queryfs)
+		rc = server->ops->queryfs(xid, tcon, buf);
 
 	free_xid(xid);
 	return 0;

commit 33319141252fd14b58cf13685156c23dcaac2527
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Tue Sep 18 16:20:29 2012 -0700

    CIFS: Add SMB2 support for cifs_iovec_write
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index db8a404a51dd..2829f374dbf7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -89,6 +89,10 @@ extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
 
+#ifdef CONFIG_HIGHMEM
+DEFINE_MUTEX(cifs_kmap_mutex);
+#endif
+
 static int
 cifs_read_super(struct super_block *sb)
 {

commit 9224dfc2f92f4faff7b3d9e169255278129b47e8
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Sun May 27 20:39:52 2012 +0400

    CIFS: Move building path to root to ops struct
    
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7a7cda9f7912..db8a404a51dd 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -549,8 +549,8 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	char *s, *p;
 	char sep;
 
-	full_path = cifs_build_path_to_root(vol, cifs_sb,
-					    cifs_sb_master_tcon(cifs_sb));
+	full_path = build_path_to_root(vol, cifs_sb,
+				       cifs_sb_master_tcon(cifs_sb));
 	if (full_path == NULL)
 		return ERR_PTR(-ENOMEM);
 

commit 3792c1732878822ebf5a1c7e83e23453b9bbb698
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Jan 12 22:40:50 2012 +0400

    CIFS: Respect SMB2 header/max header size
    
    Use SMB2 header size values for allocation and memset because they
    are bigger and suitable for both CIFS and SMB2.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2e9929dc2072..7a7cda9f7912 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -48,6 +48,9 @@
 #include <linux/key-type.h>
 #include "cifs_spnego.h"
 #include "fscache.h"
+#ifdef CONFIG_CIFS_SMB2
+#include "smb2pdu.h"
+#endif
 #define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
 
 int cifsFYI = 0;
@@ -980,6 +983,14 @@ cifs_destroy_inodecache(void)
 static int
 cifs_init_request_bufs(void)
 {
+	size_t max_hdr_size = MAX_CIFS_HDR_SIZE;
+#ifdef CONFIG_CIFS_SMB2
+	/*
+	 * SMB2 maximum header size is bigger than CIFS one - no problems to
+	 * allocate some more bytes for CIFS.
+	 */
+	max_hdr_size = MAX_SMB2_HDR_SIZE;
+#endif
 	if (CIFSMaxBufSize < 8192) {
 	/* Buffer size can not be smaller than 2 * PATH_MAX since maximum
 	Unicode path name has to fit in any SMB/CIFS path based frames */
@@ -991,8 +1002,7 @@ cifs_init_request_bufs(void)
 	}
 /*	cERROR(1, "CIFSMaxBufSize %d 0x%x",CIFSMaxBufSize,CIFSMaxBufSize); */
 	cifs_req_cachep = kmem_cache_create("cifs_request",
-					    CIFSMaxBufSize +
-					    MAX_CIFS_HDR_SIZE, 0,
+					    CIFSMaxBufSize + max_hdr_size, 0,
 					    SLAB_HWCACHE_ALIGN, NULL);
 	if (cifs_req_cachep == NULL)
 		return -ENOMEM;

commit 6d5786a34d98bffb8ad50d8053d1e53231fe0636
Author: Pavel Shilovsky <pshilovsky@samba.org>
Date:   Wed Jun 20 11:21:16 2012 +0400

    CIFS: Rename Get/FreeXid and make them work with unsigned int
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a7610cfedf0a..2e9929dc2072 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -158,9 +158,9 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
 	int rc = -EOPNOTSUPP;
-	int xid;
+	unsigned int xid;
 
-	xid = GetXid();
+	xid = get_xid();
 
 	buf->f_type = CIFS_MAGIC_NUMBER;
 
@@ -197,7 +197,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	if (rc)
 		rc = SMBOldQFSInfo(xid, tcon, buf);
 
-	FreeXid(xid);
+	free_xid(xid);
 	return 0;
 }
 

commit 9249e17fe094d853d1ef7475dd559a2cc7e23d42
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jun 25 12:55:37 2012 +0100

    VFS: Pass mount flags to sget()
    
    Pass mount flags to sget() so that it can use them in initialising a new
    superblock before the set function is called.  They could also be passed to the
    compare function.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c0c2751a7573..a7610cfedf0a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -637,7 +637,10 @@ cifs_do_mount(struct file_system_type *fs_type,
 	mnt_data.cifs_sb = cifs_sb;
 	mnt_data.flags = flags;
 
-	sb = sget(fs_type, cifs_match_super, cifs_set_super, &mnt_data);
+	/* BB should we make this contingent on mount parm? */
+	flags |= MS_NODIRATIME | MS_NOATIME;
+
+	sb = sget(fs_type, cifs_match_super, cifs_set_super, flags, &mnt_data);
 	if (IS_ERR(sb)) {
 		root = ERR_CAST(sb);
 		cifs_umount(cifs_sb);
@@ -648,10 +651,6 @@ cifs_do_mount(struct file_system_type *fs_type,
 		cFYI(1, "Use existing superblock");
 		cifs_umount(cifs_sb);
 	} else {
-		sb->s_flags = flags;
-		/* BB should we make this contingent on mount parm? */
-		sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
-
 		rc = cifs_read_super(sb);
 		if (rc) {
 			root = ERR_PTR(rc);

commit d2c127197dfc0b2bae62a52e1e0d3e3ff493919e
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 5 15:10:23 2012 +0200

    cifs: implement i_op->atomic_open()
    
    Add an ->atomic_open implementation which replaces the atomic lookup+open+create
    operation implemented via ->lookup and ->create operations.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    CC: Steve French <sfrench@samba.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index bcab12c87146..c0c2751a7573 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -777,6 +777,7 @@ struct file_system_type cifs_fs_type = {
 };
 const struct inode_operations cifs_dir_inode_ops = {
 	.create = cifs_create,
+	.atomic_open = cifs_atomic_open,
 	.lookup = cifs_lookup,
 	.getattr = cifs_getattr,
 	.unlink = cifs_unlink,

commit e6f9f8d0296aad7fbaf01de38ccaa1bf654bbda4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 9 11:50:36 2012 -0400

    cifs: don't bother with ->i_dentry in ->destroy_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8b6e344eb0ba..bcab12c87146 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -257,7 +257,6 @@ cifs_alloc_inode(struct super_block *sb)
 static void cifs_i_callback(struct rcu_head *head)
 {
 	struct inode *inode = container_of(head, struct inode, i_rcu);
-	INIT_LIST_HEAD(&inode->i_dentry);
 	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
 }
 

commit 442a9ffabb21f175027e93e72ea05159818271a6
Merge: 4b7814746824 2c0c2a08bed7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 29 12:42:10 2012 -0700

    Merge branch 'for-next' of git://git.samba.org/sfrench/cifs-2.6
    
    Pull CIFS updates from Steve French.
    
    * 'for-next' of git://git.samba.org/sfrench/cifs-2.6: (29 commits)
      cifs: fix oops while traversing open file list (try #4)
      cifs: Fix comment as d_alloc_root() is replaced by d_make_root()
      CIFS: Introduce SMB2 mounts as vers=2.1
      CIFS: Introduce SMB2 Kconfig option
      CIFS: Move add/set_credits and get_credits_field to ops structure
      CIFS: Move protocol specific demultiplex thread calls to ops struct
      CIFS: Move protocol specific part from cifs_readv_receive to ops struct
      CIFS: Move header_size/max_header_size to ops structure
      CIFS: Move protocol specific part from SendReceive2 to ops struct
      cifs: Include backup intent search flags during searches {try #2)
      CIFS: Separate protocol specific part from setlk
      CIFS: Separate protocol specific part from getlk
      CIFS: Separate protocol specific lock type handling
      CIFS: Convert lock type to 32 bit variable
      CIFS: Move locks to cifsFileInfo structure
      cifs: convert send_nt_cancel into a version specific op
      cifs: add a smb_version_operations/values structures and a smb_version enum
      cifs: remove the vers= and version= synonyms for ver=
      cifs: add warning about change in default cache semantics in 3.7
      cifs: display cache= option in /proc/mounts
      ...

commit 90324cc1b11a211e37eabd8cb863e1a1561d6b1d
Merge: fb8b00675eb6 169ebd90131b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 28 09:54:45 2012 -0700

    Merge tag 'writeback' of git://git.kernel.org/pub/scm/linux/kernel/git/wfg/linux
    
    Pull writeback tree from Wu Fengguang:
     "Mainly from Jan Kara to avoid iput() in the flusher threads."
    
    * tag 'writeback' of git://git.kernel.org/pub/scm/linux/kernel/git/wfg/linux:
      writeback: Avoid iput() from flusher thread
      vfs: Rename end_writeback() to clear_inode()
      vfs: Move waiting for inode writeback from end_writeback() to evict_inode()
      writeback: Refactor writeback_single_inode()
      writeback: Remove wb->list_lock from writeback_single_inode()
      writeback: Separate inode requeueing after writeback
      writeback: Move I_DIRTY_PAGES handling
      writeback: Move requeueing when I_SYNC set to writeback_sb_inodes()
      writeback: Move clearing of I_SYNC into inode_sync_complete()
      writeback: initialize global_dirty_limit
      fs: remove 8 bytes of padding from struct writeback_control on 64 bit builds
      mm: page-writeback.c: local functions should not be exposed globally

commit ea4b574028f0c30d736ab6b13b518af8533a86c4
Author: Sedat Dilek <sedat.dilek@googlemail.com>
Date:   Sat Apr 28 14:13:53 2012 +0200

    cifs: Fix comment as d_alloc_root() is replaced by d_make_root()
    
    For more details see <file: Documentation/filesystems/porting>.
    
    Signed-off-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d6660f7e42f4..3c9c794ede53 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -124,7 +124,7 @@ cifs_read_super(struct super_block *sb)
 		goto out_no_root;
 	}
 
-	/* do that *after* d_alloc_root() - we want NULL ->d_op for root here */
+	/* do that *after* d_make_root() - we want NULL ->d_op for root here */
 	if (cifs_sb_master_tcon(cifs_sb)->nocase)
 		sb->s_d_op = &cifs_ci_dentry_ops;
 	else

commit fbd35acadd728eac5d94f360c7cd8cbe12a0379f
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Fri Feb 24 15:41:06 2012 +0300

    CIFS: Move locks to cifsFileInfo structure
    
    CIFS brlock cache can be used by several file handles if we have a
    write-caching lease on the file that is supported by SMB2 protocol.
    Prepate the code to handle this situation correctly by sorting brlocks
    by a fid to easily push them in portions when lease break comes.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8a6928c4537d..d6660f7e42f4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -955,7 +955,6 @@ cifs_init_once(void *inode)
 	struct cifsInodeInfo *cifsi = inode;
 
 	inode_init_once(&cifsi->vfs_inode);
-	INIT_LIST_HEAD(&cifsi->llist);
 	mutex_init(&cifsi->lock_mutex);
 }
 

commit 23db65f511e6ee98ad767833f2ec58b0568ba32b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue May 15 12:20:51 2012 -0400

    cifs: add a smb_version_operations/values structures and a smb_version enum
    
    We need a way to dispatch different operations for different versions.
    Behold the smb_version_operations/values structures. For now, those
    structures just hold the version enum value and nothing uses them.
    Eventually, we'll expand them to cover other operations/values as we
    change the callers to dispatch from here.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f718d5780062..8a6928c4537d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -354,6 +354,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	struct sockaddr *srcaddr;
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
+	seq_printf(s, ",vers=%s", tcon->ses->server->vals->version_string);
 	cifs_show_security(s, tcon->ses->server);
 	cifs_show_cache_flavor(s, cifs_sb);
 

commit d06b5056ae160453c4be17e24e8cf08d65f4569f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed May 16 07:53:01 2012 -0400

    cifs: display cache= option in /proc/mounts
    
    ...and deprecate the display of strictcache, forcedirectio, and fsc
    as separate options.
    
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c45f170c28d0..f718d5780062 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -328,6 +328,19 @@ cifs_show_security(struct seq_file *s, struct TCP_Server_Info *server)
 		seq_printf(s, "i");
 }
 
+static void
+cifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)
+{
+	seq_printf(s, ",cache=");
+
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)
+		seq_printf(s, "strict");
+	else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
+		seq_printf(s, "none");
+	else
+		seq_printf(s, "loose");
+}
+
 /*
  * cifs_show_options() is for displaying mount options in /proc/mounts.
  * Not all settable options are displayed but most of the important
@@ -342,6 +355,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
 	cifs_show_security(s, tcon->ses->server);
+	cifs_show_cache_flavor(s, cifs_sb);
 
 	seq_printf(s, ",unc=%s", tcon->treeName);
 
@@ -407,8 +421,6 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_printf(s, ",rwpidforward");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL)
 		seq_printf(s, ",forcemand");
-	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
-		seq_printf(s, ",directio");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
 		seq_printf(s, ",nouser_xattr");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)
@@ -431,8 +443,6 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_printf(s, ",nostrictsync");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)
 		seq_printf(s, ",noperm");
-	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)
-		seq_printf(s, ",strictcache");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID)
 		seq_printf(s, ",backupuid=%u", cifs_sb->mnt_backupuid);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID)

commit 5e500ed125f3b153aa3f228657723189e9f4c82e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed May 16 07:13:17 2012 -0400

    cifs: remove legacy MultiuserMount option
    
    We've now warned about this for two releases. Remove it for 3.5.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 541ef81f6ae8..c45f170c28d0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -56,7 +56,6 @@ int traceSMB = 0;
 bool enable_oplocks = true;
 unsigned int linuxExtEnabled = 1;
 unsigned int lookupCacheEnabled = 1;
-unsigned int multiuser_mount = 0;
 unsigned int global_secflags = CIFSSEC_DEF;
 /* unsigned int ntlmv2_support = 0; */
 unsigned int sign_CIFS_PDUs = 1;

commit 48a5730e5b71201e226ff06e245bf308feba5f10
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Apr 30 17:36:21 2012 +0300

    cifs: fix revalidation test in cifs_llseek()
    
    This test is always true so it means we revalidate the length every
    time, which generates more network traffic.  When it is SEEK_SET or
    SEEK_CUR, then we don't need to revalidate.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ca6a3796a33b..541ef81f6ae8 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -699,7 +699,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 	 * origin == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate
 	 * the cached file length
 	 */
-	if (origin != SEEK_SET || origin != SEEK_CUR) {
+	if (origin != SEEK_SET && origin != SEEK_CUR) {
 		int rc;
 		struct inode *inode = file->f_path.dentry->d_inode;
 

commit dbd5768f87ff6fb0a4fe09c4d7b6c4a24de99430
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 3 14:48:02 2012 +0200

    vfs: Rename end_writeback() to clear_inode()
    
    After we moved inode_sync_wait() from end_writeback() it doesn't make sense
    to call the function end_writeback() anymore. Rename it to clear_inode()
    which well says what the function really does - set I_CLEAR flag.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d34212822444..acb138f0eba0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -272,7 +272,7 @@ static void
 cifs_evict_inode(struct inode *inode)
 {
 	truncate_inode_pages(&inode->i_data, 0);
-	end_writeback(inode);
+	clear_inode(inode);
 	cifs_fscache_release_inode_cookie(inode);
 }
 

commit 156d17905e783d057061b3b56a9b3befec064e47
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Wed Apr 25 12:10:14 2012 +0100

    CIFS: Fix indentation in cifs_show_options
    
    Trivial patch which fixes a misplaced tab in cifs_show_options().
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 811245b1ff2e..ca6a3796a33b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -442,7 +442,7 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	seq_printf(s, ",rsize=%u", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%u", cifs_sb->wsize);
 	/* convert actimeo and display it in seconds */
-		seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
+	seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
 
 	return 0;
 }

commit 28f8881023c9713c303c0feda270929f9384c019
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue Apr 24 15:28:30 2012 +0100

    Use correct conversion specifiers in cifs_show_options
    
    cifs_show_options uses the wrong conversion specifier for uid, gid,
    rsize & wsize. Correct this to %u to match it to the variable type
    'unsigned integer'.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ea8eb92b65b4..811245b1ff2e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -370,13 +370,13 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 				   (int)(srcaddr->sa_family));
 	}
 
-	seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
+	seq_printf(s, ",uid=%u", cifs_sb->mnt_uid);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)
 		seq_printf(s, ",forceuid");
 	else
 		seq_printf(s, ",noforceuid");
 
-	seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
+	seq_printf(s, ",gid=%u", cifs_sb->mnt_gid);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)
 		seq_printf(s, ",forcegid");
 	else
@@ -439,8 +439,8 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID)
 		seq_printf(s, ",backupgid=%u", cifs_sb->mnt_backupgid);
 
-	seq_printf(s, ",rsize=%d", cifs_sb->rsize);
-	seq_printf(s, ",wsize=%d", cifs_sb->wsize);
+	seq_printf(s, ",rsize=%u", cifs_sb->rsize);
+	seq_printf(s, ",wsize=%u", cifs_sb->wsize);
 	/* convert actimeo and display it in seconds */
 		seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
 

commit 3c7c87fd5bd71f57c68a64d11a15170d0dc4f7aa
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue Apr 24 15:28:14 2012 +0100

    CIFS: Show backupuid/gid in /proc/mounts
    
    Show  backupuid/backupgid in /proc/mounts for cifs shares mounted with
    the backupuid/backupgid feature.
    
    Also consolidate the two separate checks for
    pvolume_info->backupuid_specified into a single if condition in
    cifs_setup_cifs_sb().
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d34212822444..ea8eb92b65b4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -434,6 +434,10 @@ cifs_show_options(struct seq_file *s, struct dentry *root)
 		seq_printf(s, ",noperm");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)
 		seq_printf(s, ",strictcache");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID)
+		seq_printf(s, ",backupuid=%u", cifs_sb->mnt_backupuid);
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID)
+		seq_printf(s, ",backupgid=%u", cifs_sb->mnt_backupgid);
 
 	seq_printf(s, ",rsize=%d", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%d", cifs_sb->wsize);

commit da472fc847e9d8c9da69b09ce0ab975b24f9b894
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Mar 23 14:40:53 2012 -0400

    cifs: add new cifsiod_wq workqueue
    
    ...and convert existing cifs users of system_nrt_wq to use that instead.
    
    Also, make it freezable, and set WQ_MEM_RECLAIM since we use it to
    deal with write reply handling.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index eee522c56ef0..d34212822444 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -85,6 +85,8 @@ extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
+struct workqueue_struct	*cifsiod_wq;
+
 static int
 cifs_read_super(struct super_block *sb)
 {
@@ -1111,9 +1113,15 @@ init_cifs(void)
 		cFYI(1, "cifs_max_pending set to max of %u", CIFS_MAX_REQ);
 	}
 
+	cifsiod_wq = alloc_workqueue("cifsiod", WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);
+	if (!cifsiod_wq) {
+		rc = -ENOMEM;
+		goto out_clean_proc;
+	}
+
 	rc = cifs_fscache_register();
 	if (rc)
-		goto out_clean_proc;
+		goto out_destroy_wq;
 
 	rc = cifs_init_inodecache();
 	if (rc)
@@ -1161,6 +1169,8 @@ init_cifs(void)
 	cifs_destroy_inodecache();
 out_unreg_fscache:
 	cifs_fscache_unregister();
+out_destroy_wq:
+	destroy_workqueue(cifsiod_wq);
 out_clean_proc:
 	cifs_proc_clean();
 	return rc;
@@ -1183,6 +1193,7 @@ exit_cifs(void)
 	cifs_destroy_mids();
 	cifs_destroy_inodecache();
 	cifs_fscache_unregister();
+	destroy_workqueue(cifsiod_wq);
 	cifs_proc_clean();
 }
 

commit 1c3ddfe5ab886c4dc0443535e95ad8e41c41d0e5
Merge: f63d395d47f3 3dd933061d3a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 23 09:07:15 2012 -0700

    Merge git://git.samba.org/sfrench/cifs-2.6
    
    Pull CIFS fixes from Steve French
    
    * git://git.samba.org/sfrench/cifs-2.6:
      cifs: clean up ordering in exit_cifs
      cifs: clean up call to cifs_dfs_release_automount_timer()
      CIFS: Delete echo_retries module parm
      CIFS: Prepare credits code for a slot reservation
      CIFS: Make wait_for_free_request killable
      CIFS: Introduce credit-based flow control
      CIFS: Simplify inFlight logic
      cifs: fix issue mounting of DFS ROOT when redirecting from one domain controller to the next
      CIFS: Respect negotiated MaxMpxCount
      CIFS: Fix a spurious error in cifs_push_posix_locks

commit 3dd933061d3a4f33fb6ba1616e88fa55a8b8cb9c
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Mar 21 06:27:55 2012 -0400

    cifs: clean up ordering in exit_cifs
    
    ...ensure that we undo things in the reverse order from the way they
    were done. In truth, the ordering doesn't matter for a lot of these,
    but it's still better to do it that way to be sure.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 260025fd8c3b..cc098ccac611 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1175,8 +1175,7 @@ static void __exit
 exit_cifs(void)
 {
 	cFYI(DBG2, "exit_cifs");
-	cifs_proc_clean();
-	cifs_fscache_unregister();
+	unregister_filesystem(&cifs_fs_type);
 	cifs_dfs_release_automount_timer();
 #ifdef CONFIG_CIFS_ACL
 	cifs_destroy_idmaptrees();
@@ -1185,10 +1184,11 @@ exit_cifs(void)
 #ifdef CONFIG_CIFS_UPCALL
 	unregister_key_type(&cifs_spnego_key_type);
 #endif
-	unregister_filesystem(&cifs_fs_type);
-	cifs_destroy_inodecache();
-	cifs_destroy_mids();
 	cifs_destroy_request_bufs();
+	cifs_destroy_mids();
+	cifs_destroy_inodecache();
+	cifs_fscache_unregister();
+	cifs_proc_clean();
 }
 
 MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");

commit 815465c4d724e851932843227b4b700d64216cf2
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Mar 21 06:27:54 2012 -0400

    cifs: clean up call to cifs_dfs_release_automount_timer()
    
    Take the #ifdef junk out of the code, and turn it into a noop macro
    when CONFIG_CIFS_DFS_UPCALL isn't defined.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f2661610fcf3..260025fd8c3b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1177,9 +1177,7 @@ exit_cifs(void)
 	cFYI(DBG2, "exit_cifs");
 	cifs_proc_clean();
 	cifs_fscache_unregister();
-#ifdef CONFIG_CIFS_DFS_UPCALL
 	cifs_dfs_release_automount_timer();
-#endif
 #ifdef CONFIG_CIFS_ACL
 	cifs_destroy_idmaptrees();
 	exit_cifs_idmap();

commit 6dae51a585008535858c29b489dbf90a913d511b
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Feb 21 16:50:23 2012 +0300

    CIFS: Delete echo_retries module parm
    
    It's the essential step before respecting MaxMpxCount value during
    negotiating because we will keep only one extra slot for sending
    echo requests. If there is no response during two echo intervals -
    reconnect the tcp session.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 6ee1cb45ca0d..f2661610fcf3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -77,11 +77,6 @@ unsigned int cifs_max_pending = CIFS_MAX_REQ;
 module_param(cifs_max_pending, int, 0444);
 MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server. "
 				   "Default: 32767 Range: 2 to 32767.");
-unsigned short echo_retries = 5;
-module_param(echo_retries, ushort, 0644);
-MODULE_PARM_DESC(echo_retries, "Number of echo attempts before giving up and "
-			       "reconnecting server. Default: 5. 0 means "
-			       "never reconnect.");
 module_param(enable_oplocks, bool, 0644);
 MODULE_PARM_DESC(enable_oplocks, "Enable or disable oplocks (bool). Default:"
 				 "y/Y/1");

commit 48fde701aff662559b38d9a609574068f22d00fe
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jan 8 22:15:13 2012 -0500

    switch open-coded instances of d_make_root() to new helper
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8b7d7ff88792..418fc42fb8b2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -122,11 +122,9 @@ cifs_read_super(struct super_block *sb)
 		goto out_no_root;
 	}
 
-	sb->s_root = d_alloc_root(inode);
-
+	sb->s_root = d_make_root(inode);
 	if (!sb->s_root) {
 		rc = -ENOMEM;
-		iput(inode);
 		goto out_no_root;
 	}
 

commit 064326c0773af8a0e8bb82d895cceaedc8a51b9e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 12 21:06:12 2012 -0500

    clean up the failure exits in cifs_read_super()
    
    no need to make that iput() conditional, just take it to the right place...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b1fd382d1952..8b7d7ff88792 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -119,7 +119,6 @@ cifs_read_super(struct super_block *sb)
 
 	if (IS_ERR(inode)) {
 		rc = PTR_ERR(inode);
-		inode = NULL;
 		goto out_no_root;
 	}
 
@@ -127,6 +126,7 @@ cifs_read_super(struct super_block *sb)
 
 	if (!sb->s_root) {
 		rc = -ENOMEM;
+		iput(inode);
 		goto out_no_root;
 	}
 
@@ -147,9 +147,6 @@ cifs_read_super(struct super_block *sb)
 
 out_no_root:
 	cERROR(1, "cifs_read_super: get root inode failed");
-	if (inode)
-		iput(inode);
-
 	return rc;
 }
 

commit 10b9b98e41ba248a899f6175ce96ee91431b6194
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Tue Mar 20 12:55:09 2012 +0300

    CIFS: Respect negotiated MaxMpxCount
    
    Some servers sets this value less than 50 that was hardcoded and
    we lost the connection if when we exceed this limit. Fix this by
    respecting this value - not sending more than the server allows.
    
    Cc: stable@kernel.org
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <stevef@smf-gateway.(none)>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b1fd382d1952..6ee1cb45ca0d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -76,7 +76,7 @@ MODULE_PARM_DESC(cifs_min_small, "Small network buffers in pool. Default: 30 "
 unsigned int cifs_max_pending = CIFS_MAX_REQ;
 module_param(cifs_max_pending, int, 0444);
 MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server. "
-				   "Default: 50 Range: 2 to 256");
+				   "Default: 32767 Range: 2 to 32767.");
 unsigned short echo_retries = 5;
 module_param(echo_retries, ushort, 0644);
 MODULE_PARM_DESC(echo_retries, "Number of echo attempts before giving up and "
@@ -1116,9 +1116,9 @@ init_cifs(void)
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
 		cFYI(1, "cifs_max_pending set to min of 2");
-	} else if (cifs_max_pending > 256) {
-		cifs_max_pending = 256;
-		cFYI(1, "cifs_max_pending set to max of 256");
+	} else if (cifs_max_pending > CIFS_MAX_REQ) {
+		cifs_max_pending = CIFS_MAX_REQ;
+		cFYI(1, "cifs_max_pending set to max of %u", CIFS_MAX_REQ);
 	}
 
 	rc = cifs_fscache_register();

commit 34c80b1d93e6e20ca9dea0baf583a5b5510d92d4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 21:32:45 2011 -0500

    vfs: switch ->show_options() to struct dentry *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0cb89dc6526c..b1fd382d1952 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -343,9 +343,9 @@ cifs_show_security(struct seq_file *s, struct TCP_Server_Info *server)
  * ones are.
  */
 static int
-cifs_show_options(struct seq_file *s, struct vfsmount *m)
+cifs_show_options(struct seq_file *s, struct dentry *root)
 {
-	struct cifs_sb_info *cifs_sb = CIFS_SB(m->mnt_sb);
+	struct cifs_sb_info *cifs_sb = CIFS_SB(root->d_sb);
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
 	struct sockaddr *srcaddr;
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
@@ -430,7 +430,7 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		seq_printf(s, ",cifsacl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)
 		seq_printf(s, ",dynperm");
-	if (m->mnt_sb->s_flags & MS_POSIXACL)
+	if (root->d_sb->s_flags & MS_POSIXACL)
 		seq_printf(s, ",acl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)
 		seq_printf(s, ",mfsymlinks");

commit 64132379d509184425672e0dce1ac0a031e3f2a5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 20:51:13 2011 -0500

    vfs: switch ->show_stats to struct dentry *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5bb961c13c4d..0cb89dc6526c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -488,7 +488,7 @@ static void cifs_umount_begin(struct super_block *sb)
 }
 
 #ifdef CONFIG_CIFS_STATS2
-static int cifs_show_stats(struct seq_file *s, struct vfsmount *mnt)
+static int cifs_show_stats(struct seq_file *s, struct dentry *root)
 {
 	/* BB FIXME */
 	return 0;

commit 5206efd62ce49cf5c7940d81c22bc556fc843de2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 03:22:14 2011 -0400

    cifs: propagate umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8f1fe324162b..5bb961c13c4d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -393,7 +393,7 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	cifs_show_address(s, tcon->ses->server);
 
 	if (!tcon->unix_ext)
-		seq_printf(s, ",file_mode=0%o,dir_mode=0%o",
+		seq_printf(s, ",file_mode=0%ho,dir_mode=0%ho",
 					   cifs_sb->mnt_file_mode,
 					   cifs_sb->mnt_dir_mode);
 	if (tcon->seal)

commit f362f98e7c445643d27c610bb7a86b79727b592e
Merge: f793f2961170 f3c7691e8d30
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 10:49:34 2011 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/hch/vfs-queue
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/hch/vfs-queue: (21 commits)
      leases: fix write-open/read-lease race
      nfs: drop unnecessary locking in llseek
      ext4: replace cut'n'pasted llseek code with generic_file_llseek_size
      vfs: add generic_file_llseek_size
      vfs: do (nearly) lockless generic_file_llseek
      direct-io: merge direct_io_walker into __blockdev_direct_IO
      direct-io: inline the complete submission path
      direct-io: separate map_bh from dio
      direct-io: use a slab cache for struct dio
      direct-io: rearrange fields in dio/dio_submit to avoid holes
      direct-io: fix a wrong comment
      direct-io: separate fields only used in the submission path from struct dio
      vfs: fix spinning prevention in prune_icache_sb
      vfs: add a comment to inode_permission()
      vfs: pass all mask flags check_acl and posix_acl_permission
      vfs: add hex format for MAY_* flag values
      vfs: indicate that the permission functions take all the MAY_* flags
      compat: sync compat_stats with statfs.
      vfs: add "device" tag to /proc/self/mountstats
      cleanup: vfs: small comment fix for block_invalidatepage
      ...
    
    Fix up trivial conflict in fs/gfs2/file.c (llseek changes)

commit ef3d0fd27e90f67e35da516dafc1482c82939a60
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Sep 15 16:06:48 2011 -0700

    vfs: do (nearly) lockless generic_file_llseek
    
    The i_mutex lock use of generic _file_llseek hurts.  Independent processes
    accessing the same file synchronize over a single lock, even though
    they have no need for synchronization at all.
    
    Under high utilization this can cause llseek to scale very poorly on larger
    systems.
    
    This patch does some rethinking of the llseek locking model:
    
    First the 64bit f_pos is not necessarily atomic without locks
    on 32bit systems. This can already cause races with read() today.
    This was discussed on linux-kernel in the past and deemed acceptable.
    The patch does not change that.
    
    Let's look at the different seek variants:
    
    SEEK_SET: Doesn't really need any locking.
    If there's a race one writer wins, the other loses.
    
    For 32bit the non atomic update races against read()
    stay the same. Without a lock they can also happen
    against write() now.  The read() race was deemed
    acceptable in past discussions, and I think if it's
    ok for read it's ok for write too.
    
    => Don't need a lock.
    
    SEEK_END: This behaves like SEEK_SET plus it reads
    the maximum size too. Reading the maximum size would have the
    32bit atomic problem. But luckily we already have a way to read
    the maximum size without locking (i_size_read), so we
    can just use that instead.
    
    Without i_mutex there is no synchronization with write() anymore,
    however since the write() update is atomic on 64bit it just behaves
    like another racy SEEK_SET.  On non atomic 32bit it's the same
    as SEEK_SET.
    
    => Don't need a lock, but need to use i_size_read()
    
    SEEK_CUR: This has a read-modify-write race window
    on the same file. One could argue that any application
    doing unsynchronized seeks on the same file is already broken.
    But for the sake of not adding a regression here I'm
    using the file->f_lock to synchronize this. Using this
    lock is much better than the inode mutex because it doesn't
    synchronize between processes.
    
    => So still need a lock, but can use a f_lock.
    
    This patch implements this new scheme in generic_file_llseek.
    I dropped generic_file_llseek_unlocked and changed all callers.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 54b8f1e7da94..db7ce87d37a5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -723,7 +723,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 		if (rc < 0)
 			return (loff_t)rc;
 	}
-	return generic_file_llseek_unlocked(file, offset, origin);
+	return generic_file_llseek(file, offset, origin);
 }
 
 static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)

commit fbcae3ea169189ee49dc6820478cb1d069b80a08
Merge: 71c424bac567 f06ac72e9291
Author: Steve French <smfrench@gmail.com>
Date:   Wed Oct 19 21:22:41 2011 -0500

    Merge branch 'cifs-3.2' of git://git.samba.org/jlayton/linux into temp-3.2-jeff

commit 71c424bac5679200e272357a225639da8bf94068
Author: Steve French <smfrench@gmail.com>
Date:   Wed Oct 19 20:44:48 2011 -0500

    [CIFS] Show nostrictsync and noperm mount options in /proc/mounts
    
    Add support to print nostrictsync and noperm mount options in
    /proc/mounts for shares mounted with these options.
    (cleanup merge conflict in Sachin's original patch)
    
    Suggested-by: Sachin Prabhu <sprabhu@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b0a2e1647390..96a48baad8f7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -436,6 +436,10 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		seq_printf(s, ",mfsymlinks");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)
 		seq_printf(s, ",fsc");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)
+		seq_printf(s, ",nostrictsync");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)
+		seq_printf(s, ",noperm");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)
 		seq_printf(s, ",strictcache");
 

commit fef33df88bef6810cc3c4e6edf55c741a8fd68e3
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 19 15:30:37 2011 -0400

    cifs: allow cifs_max_pending to be readable under /sys/module/cifs/parameters
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b0a2e1647390..fa6724562a41 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -74,7 +74,7 @@ module_param(cifs_min_small, int, 0);
 MODULE_PARM_DESC(cifs_min_small, "Small network buffers in pool. Default: 30 "
 				 "Range: 2 to 256");
 unsigned int cifs_max_pending = CIFS_MAX_REQ;
-module_param(cifs_max_pending, int, 0);
+module_param(cifs_max_pending, int, 0444);
 MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server. "
 				   "Default: 50 Range: 2 to 256");
 unsigned short echo_retries = 5;

commit d59dad2be038132259ac99a2837d65a87fd90588
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Sep 22 09:53:59 2011 +0400

    CIFS: Move byte range lock list from fd to inode
    
    that let us do local lock checks before requesting to the server.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5c2972106816..b0a2e1647390 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -945,7 +945,8 @@ cifs_init_once(void *inode)
 	struct cifsInodeInfo *cifsi = inode;
 
 	inode_init_once(&cifsi->vfs_inode);
-	INIT_LIST_HEAD(&cifsi->lockList);
+	INIT_LIST_HEAD(&cifsi->llist);
+	mutex_init(&cifsi->lock_mutex);
 }
 
 static int

commit e75047344ea415760b2508a6fa29c0288c7b6b68
Author: Steve French <smfrench@gmail.com>
Date:   Wed Oct 12 17:47:03 2011 -0500

    add new module parameter 'enable_oplocks'
    
    Thus spake Jeff Layton:
    
    "Making that a module parm would allow you to set that parameter at boot
    time without needing to add special startup scripts. IMO, all of the
    procfile "switches" under /proc/fs/cifs should be module parms
    instead."
    
    This patch doesn't alter the default behavior (Oplocks are enabled by
    default).
    
    To disable oplocks when loading the module, use
    
       modprobe cifs enable_oplocks=0
    
    (any of '0' or 'n' or 'N' conventions can be used).
    
    To disable oplocks at runtime using the new interface, use
    
       echo 0 > /sys/module/cifs/parameters/enable_oplocks
    
    The older /proc/fs/cifs/OplockEnabled interface will be deprecated
    after two releases. A subsequent patch will add an warning message
    about this deprecation.
    
    Changes since v2:
       - make enable_oplocks a 'bool'
    
    Changes since v1:
       - eliminate the use of extra variable by renaming the old one to
         enable_oplocks and make it an 'int' type.
    
    Reported-by: Alexander Swen <alex@swen.nu>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index aa8fe7cee0b4..5c2972106816 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -53,7 +53,7 @@
 int cifsFYI = 0;
 int cifsERROR = 1;
 int traceSMB = 0;
-unsigned int oplockEnabled = 1;
+bool enable_oplocks = true;
 unsigned int linuxExtEnabled = 1;
 unsigned int lookupCacheEnabled = 1;
 unsigned int multiuser_mount = 0;
@@ -82,6 +82,10 @@ module_param(echo_retries, ushort, 0644);
 MODULE_PARM_DESC(echo_retries, "Number of echo attempts before giving up and "
 			       "reconnecting server. Default: 5. 0 means "
 			       "never reconnect.");
+module_param(enable_oplocks, bool, 0644);
+MODULE_PARM_DESC(enable_oplocks, "Enable or disable oplocks (bool). Default:"
+				 "y/Y/1");
+
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;

commit f3a6a60e4c3ac83370c620dbbd08d2a418b9364d
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Wed Oct 12 14:14:04 2011 +0200

    cifs: Fix typo 'CIFS_NFSD_EXPORT'
    
    It should be 'CONFIG_CIFS_NFSD_EXPORT'. No-one noticed because that
    symbol depends on BROKEN.
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7986d330cbb5..aa8fe7cee0b4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -132,12 +132,12 @@ cifs_read_super(struct super_block *sb)
 	else
 		sb->s_d_op = &cifs_dentry_ops;
 
-#ifdef CIFS_NFSD_EXPORT
+#ifdef CONFIG_CIFS_NFSD_EXPORT
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {
 		cFYI(1, "export ops supported");
 		sb->s_export_op = &cifs_export_ops;
 	}
-#endif /* CIFS_NFSD_EXPORT */
+#endif /* CONFIG_CIFS_NFSD_EXPORT */
 
 	return 0;
 

commit 4a29a0bd1d63c1a434f29ce5dd6428b65604a398
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Oct 11 06:41:32 2011 -0400

    cifs: get rid of unused xid in cifs_get_root
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 03d2f6b27cc4..7986d330cbb5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -532,7 +532,6 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	char *full_path = NULL;
 	char *s, *p;
 	char sep;
-	int xid;
 
 	full_path = cifs_build_path_to_root(vol, cifs_sb,
 					    cifs_sb_master_tcon(cifs_sb));
@@ -541,7 +540,6 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 
 	cFYI(1, "Get root dentry for %s", full_path);
 
-	xid = GetXid();
 	sep = CIFS_DIR_SEP(cifs_sb);
 	dentry = dget(sb->s_root);
 	p = s = full_path;
@@ -572,7 +570,6 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		dput(dentry);
 		dentry = child;
 	} while (!IS_ERR(dentry));
-	_FreeXid(xid);
 	kfree(full_path);
 	return dentry;
 }

commit 875cd04381e695afbbbef025438113e12af84963
Author: Sachin Prabhu <sprabhu@redhat.com>
Date:   Tue Oct 11 13:43:50 2011 +0100

    cifs: Display strictcache mount option in /proc/mounts
    
    Commit d39454ffe4a3c85428483b8a8a8e5e797b6363d5 adds a strictcache mount
    option. This patch allows the display of this mount option in
    /proc/mounts when listing shares mounted with the strictcache mount
    option.
    
    Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 54b8f1e7da94..03d2f6b27cc4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -432,6 +432,8 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		seq_printf(s, ",mfsymlinks");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)
 		seq_printf(s, ",fsc");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)
+		seq_printf(s, ",strictcache");
 
 	seq_printf(s, ",rsize=%d", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%d", cifs_sb->wsize);

commit 5b980b01212199833ee8023770fa4cbf1b85e9f4
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Sun Aug 21 19:30:15 2011 +0400

    CIFS: Fix ERR_PTR dereference in cifs_get_root
    
    move it to the beginning of the loop.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f93eb948d071..54b8f1e7da94 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -548,6 +548,12 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		struct inode *dir = dentry->d_inode;
 		struct dentry *child;
 
+		if (!dir) {
+			dput(dentry);
+			dentry = ERR_PTR(-ENOENT);
+			break;
+		}
+
 		/* skip separators */
 		while (*s == sep)
 			s++;
@@ -563,10 +569,6 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		mutex_unlock(&dir->i_mutex);
 		dput(dentry);
 		dentry = child;
-		if (!dentry->d_inode) {
-			dput(dentry);
-			dentry = ERR_PTR(-ENOENT);
-		}
 	} while (!IS_ERR(dentry));
 	_FreeXid(xid);
 	kfree(full_path);

commit 80975d21aae2136ccae1ce914a1602dc1d8b0795
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Aug 5 09:02:40 2011 -0400

    cifs: cope with negative dentries in cifs_get_root
    
    The loop around lookup_one_len doesn't handle the case where it might
    return a negative dentry, which can cause an oops on the next pass
    through the loop. Check for that and break out of the loop with an
    error of -ENOENT if there is one.
    
    Fixes the panic reported here:
    
        https://bugzilla.redhat.com/show_bug.cgi?id=727927
    
    Reported-by: TR Bentley <home@trarbentley.net>
    Reported-by: Iain Arnell <iarnell@gmail.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: stable@kernel.org
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 212e5629cc1d..f93eb948d071 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -563,6 +563,10 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 		mutex_unlock(&dir->i_mutex);
 		dput(dentry);
 		dentry = child;
+		if (!dentry->d_inode) {
+			dput(dentry);
+			dentry = ERR_PTR(-ENOENT);
+		}
 	} while (!IS_ERR(dentry));
 	_FreeXid(xid);
 	kfree(full_path);

commit ad635942c869ad8fc9af270d4998c42b4e978b32
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jul 26 12:20:17 2011 -0400

    cifs: simplify refcounting for oplock breaks
    
    Currently, we take a sb->s_active reference and a cifsFileInfo reference
    when an oplock break workqueue job is queued. This is unnecessary and
    more complicated than it needs to be. Also as Al points out,
    deactivate_super has non-trivial locking implications so it's best to
    avoid that if we can.
    
    Instead, just cancel any pending oplock breaks for this filehandle
    synchronously in cifsFileInfo_put after taking it off the lists.
    That should ensure that this job doesn't outlive the structures it
    depends on.
    
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 865517470967..212e5629cc1d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -86,24 +86,6 @@ extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
-void
-cifs_sb_active(struct super_block *sb)
-{
-	struct cifs_sb_info *server = CIFS_SB(sb);
-
-	if (atomic_inc_return(&server->active) == 1)
-		atomic_inc(&sb->s_active);
-}
-
-void
-cifs_sb_deactive(struct super_block *sb)
-{
-	struct cifs_sb_info *server = CIFS_SB(sb);
-
-	if (atomic_dec_and_test(&server->active))
-		deactivate_super(sb);
-}
-
 static int
 cifs_read_super(struct super_block *sb)
 {

commit 06222e491e663dac939f04b125c9dc52126a75c4
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Jul 18 13:21:38 2011 -0400

    fs: handle SEEK_HOLE/SEEK_DATA properly in all fs's that define their own llseek
    
    This converts everybody to handle SEEK_HOLE/SEEK_DATA properly.  In some cases
    we just return -EINVAL, in others we do the normal generic thing, and in others
    we're simply making sure that the properly due-dilligence is done.  For example
    in NFS/CIFS we need to make sure the file size is update properly for the
    SEEK_HOLE and SEEK_DATA case, but since it calls the generic llseek stuff itself
    that is all we have to do.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cbbb55e781d3..865517470967 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -704,8 +704,11 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 
 static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 {
-	/* origin == SEEK_END => we must revalidate the cached file length */
-	if (origin == SEEK_END) {
+	/*
+	 * origin == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate
+	 * the cached file length
+	 */
+	if (origin != SEEK_SET || origin != SEEK_CUR) {
 		int rc;
 		struct inode *inode = file->f_path.dentry->d_inode;
 

commit 10556cb21a0d0b24d95f00ea6df16f599a3345b2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:28:19 2011 -0400

    ->permission() sanitizing: don't pass flags to ->permission()
    
    not used by the instances anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b285b5bcf711..cbbb55e781d3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -224,7 +224,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
-static int cifs_permission(struct inode *inode, int mask, unsigned int flags)
+static int cifs_permission(struct inode *inode, int mask)
 {
 	struct cifs_sb_info *cifs_sb;
 

commit 2830ba7f34ebb27c4e5b8b6ef408cd6d74860890
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:16:29 2011 -0400

    ->permission() sanitizing: don't pass flags to generic_permission()
    
    redundant; all callers get it duplicated in mask & MAY_NOT_BLOCK and none of
    them removes that bit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b79804fa410f..b285b5bcf711 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -239,7 +239,7 @@ static int cifs_permission(struct inode *inode, int mask, unsigned int flags)
 		on the client (above and beyond ACL on servers) for
 		servers which do not support setting and viewing mode bits,
 		so allowing client to check permissions is useful */
-		return generic_permission(inode, mask, flags);
+		return generic_permission(inode, mask);
 }
 
 static struct kmem_cache *cifs_inode_cachep;

commit 178ea73521d64ba41d7aa5488fb9f549c6d4507d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 11:31:30 2011 -0400

    kill check_acl callback of generic_permission()
    
    its value depends only on inode and does not change; we might as
    well store it in ->i_op->check_acl and be done with that.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index bc4b12ca537b..b79804fa410f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -239,7 +239,7 @@ static int cifs_permission(struct inode *inode, int mask, unsigned int flags)
 		on the client (above and beyond ACL on servers) for
 		servers which do not support setting and viewing mode bits,
 		so allowing client to check permissions is useful */
-		return generic_permission(inode, mask, flags, NULL);
+		return generic_permission(inode, mask, flags);
 }
 
 static struct kmem_cache *cifs_inode_cachep;

commit fec11dd9a0109fe52fd631e5c510778d6cbff6cc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 18 13:50:40 2011 -0400

    Fix cifs_get_root()
    
    Add missing ->i_mutex, convert to lookup_one_len() instead of
    (broken) open-coded analog, cope with getting something like
    a//b as relative pathname.  Simplify the hell out of it, while
    we are there...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3e2989976297..bc4b12ca537b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -35,6 +35,7 @@
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/freezer.h>
+#include <linux/namei.h>
 #include <net/ipv6.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
@@ -542,14 +543,12 @@ static const struct super_operations cifs_super_ops = {
 static struct dentry *
 cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 {
-	int xid, rc;
-	struct inode *inode;
-	struct qstr name;
-	struct dentry *dparent = NULL, *dchild = NULL, *alias;
+	struct dentry *dentry;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	unsigned int i, full_len, len;
-	char *full_path = NULL, *pstart;
+	char *full_path = NULL;
+	char *s, *p;
 	char sep;
+	int xid;
 
 	full_path = cifs_build_path_to_root(vol, cifs_sb,
 					    cifs_sb_master_tcon(cifs_sb));
@@ -560,73 +559,32 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 
 	xid = GetXid();
 	sep = CIFS_DIR_SEP(cifs_sb);
-	dparent = dget(sb->s_root);
-	full_len = strlen(full_path);
-	full_path[full_len] = sep;
-	pstart = full_path + 1;
-
-	for (i = 1, len = 0; i <= full_len; i++) {
-		if (full_path[i] != sep || !len) {
-			len++;
-			continue;
-		}
-
-		full_path[i] = 0;
-		cFYI(1, "get dentry for %s", pstart);
-
-		name.name = pstart;
-		name.len = len;
-		name.hash = full_name_hash(pstart, len);
-		dchild = d_lookup(dparent, &name);
-		if (dchild == NULL) {
-			cFYI(1, "not exists");
-			dchild = d_alloc(dparent, &name);
-			if (dchild == NULL) {
-				dput(dparent);
-				dparent = ERR_PTR(-ENOMEM);
-				goto out;
-			}
-		}
-
-		cFYI(1, "get inode");
-		if (dchild->d_inode == NULL) {
-			cFYI(1, "not exists");
-			inode = NULL;
-			if (cifs_sb_master_tcon(CIFS_SB(sb))->unix_ext)
-				rc = cifs_get_inode_info_unix(&inode, full_path,
-							      sb, xid);
-			else
-				rc = cifs_get_inode_info(&inode, full_path,
-							 NULL, sb, xid, NULL);
-			if (rc) {
-				dput(dchild);
-				dput(dparent);
-				dparent = ERR_PTR(rc);
-				goto out;
-			}
-			alias = d_materialise_unique(dchild, inode);
-			if (alias != NULL) {
-				dput(dchild);
-				if (IS_ERR(alias)) {
-					dput(dparent);
-					dparent = ERR_PTR(-EINVAL); /* XXX */
-					goto out;
-				}
-				dchild = alias;
-			}
-		}
-		cFYI(1, "parent %p, child %p", dparent, dchild);
-
-		dput(dparent);
-		dparent = dchild;
-		len = 0;
-		pstart = full_path + i + 1;
-		full_path[i] = sep;
-	}
-out:
+	dentry = dget(sb->s_root);
+	p = s = full_path;
+
+	do {
+		struct inode *dir = dentry->d_inode;
+		struct dentry *child;
+
+		/* skip separators */
+		while (*s == sep)
+			s++;
+		if (!*s)
+			break;
+		p = s++;
+		/* next separator */
+		while (*s && *s != sep)
+			s++;
+
+		mutex_lock(&dir->i_mutex);
+		child = lookup_one_len(p, dentry, s - p);
+		mutex_unlock(&dir->i_mutex);
+		dput(dentry);
+		dentry = child;
+	} while (!IS_ERR(dentry));
 	_FreeXid(xid);
 	kfree(full_path);
-	return dparent;
+	return dentry;
 }
 
 static int cifs_set_super(struct super_block *sb, void *data)

commit 04db79b015dafcb79371fda6b5c32ffdbd31a2ff
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Jul 6 08:10:38 2011 -0400

    cifs: factor smb_vol allocation out of cifs_setup_volume_info
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e11b83149833..3e2989976297 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -649,9 +649,9 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
 
-	rc = cifs_setup_volume_info(&volume_info, (char *)data, dev_name);
-	if (rc)
-		return ERR_PTR(rc);
+	volume_info = cifs_get_volume_info((char *)data, dev_name);
+	if (IS_ERR(volume_info))
+		return ERR_CAST(volume_info);
 
 	cifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
 	if (cifs_sb == NULL) {

commit f9e59bcba2cff580a3ccf62e89460f9eed295d89
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Jul 6 08:10:37 2011 -0400

    cifs: have cifs_cleanup_volume_info not take a double pointer
    
    ...as that makes for a cumbersome interface. Make it take a regular
    smb_vol pointer and rely on the caller to zero it out if needed.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 35f9154615fa..e11b83149833 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -713,7 +713,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 out_super:
 	deactivate_locked_super(sb);
 out:
-	cifs_cleanup_volume_info(&volume_info);
+	cifs_cleanup_volume_info(volume_info);
 	return root;
 
 out_mountdata:

commit 9403c9c598e91d473c0582066e47ed2289292e45
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 10:02:59 2011 -0400

    cifs: propagate errors from cifs_get_root() to mount(2)
    
    ... instead of just failing with -EINVAL
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9a6696a5eb78..35f9154615fa 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -554,7 +554,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	full_path = cifs_build_path_to_root(vol, cifs_sb,
 					    cifs_sb_master_tcon(cifs_sb));
 	if (full_path == NULL)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
 	cFYI(1, "Get root dentry for %s", full_path);
 
@@ -583,7 +583,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 			dchild = d_alloc(dparent, &name);
 			if (dchild == NULL) {
 				dput(dparent);
-				dparent = NULL;
+				dparent = ERR_PTR(-ENOMEM);
 				goto out;
 			}
 		}
@@ -601,7 +601,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 			if (rc) {
 				dput(dchild);
 				dput(dparent);
-				dparent = NULL;
+				dparent = ERR_PTR(rc);
 				goto out;
 			}
 			alias = d_materialise_unique(dchild, inode);
@@ -609,7 +609,7 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 				dput(dchild);
 				if (IS_ERR(alias)) {
 					dput(dparent);
-					dparent = NULL;
+					dparent = ERR_PTR(-EINVAL); /* XXX */
 					goto out;
 				}
 				dchild = alias;
@@ -704,10 +704,8 @@ cifs_do_mount(struct file_system_type *fs_type,
 	}
 
 	root = cifs_get_root(volume_info, sb);
-	if (root == NULL) {
-		root = ERR_PTR(-EINVAL); /* XXX */
+	if (IS_ERR(root))
 		goto out_super;
-	}
 
 	cFYI(1, "dentry root is: %p", root);
 	goto out;

commit 5c4f1ad7c6aa3b729bd3a93b80f9417d7e978c32
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:56:55 2011 -0400

    cifs: tidy cifs_do_mount() up a bit
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 234e9d08db76..9a6696a5eb78 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -656,16 +656,13 @@ cifs_do_mount(struct file_system_type *fs_type,
 	cifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
 	if (cifs_sb == NULL) {
 		root = ERR_PTR(-ENOMEM);
-		unload_nls(volume_info->local_nls);
-		goto out;
+		goto out_nls;
 	}
 
 	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
 	if (cifs_sb->mountdata == NULL) {
 		root = ERR_PTR(-ENOMEM);
-		unload_nls(volume_info->local_nls);
-		kfree(cifs_sb);
-		goto out;
+		goto out_cifs_sb;
 	}
 
 	cifs_setup_cifs_sb(volume_info, cifs_sb);
@@ -675,10 +672,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 		if (!(flags & MS_SILENT))
 			cERROR(1, "cifs_mount failed w/return code = %d", rc);
 		root = ERR_PTR(rc);
-		unload_nls(volume_info->local_nls);
-		kfree(cifs_sb->mountdata);
-		kfree(cifs_sb);
-		goto out;
+		goto out_mountdata;
 	}
 
 	mnt_data.vol = volume_info;
@@ -695,22 +689,20 @@ cifs_do_mount(struct file_system_type *fs_type,
 	if (sb->s_root) {
 		cFYI(1, "Use existing superblock");
 		cifs_umount(cifs_sb);
-		goto out_shared;
-	}
-
-	sb->s_flags = flags;
-	/* BB should we make this contingent on mount parm? */
-	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
+	} else {
+		sb->s_flags = flags;
+		/* BB should we make this contingent on mount parm? */
+		sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
+
+		rc = cifs_read_super(sb);
+		if (rc) {
+			root = ERR_PTR(rc);
+			goto out_super;
+		}
 
-	rc = cifs_read_super(sb);
-	if (rc) {
-		root = ERR_PTR(rc);
-		goto out_super;
+		sb->s_flags |= MS_ACTIVE;
 	}
 
-	sb->s_flags |= MS_ACTIVE;
-
-out_shared:
 	root = cifs_get_root(volume_info, sb);
 	if (root == NULL) {
 		root = ERR_PTR(-EINVAL); /* XXX */
@@ -725,6 +717,14 @@ cifs_do_mount(struct file_system_type *fs_type,
 out:
 	cifs_cleanup_volume_info(&volume_info);
 	return root;
+
+out_mountdata:
+	kfree(cifs_sb->mountdata);
+out_cifs_sb:
+	kfree(cifs_sb);
+out_nls:
+	unload_nls(volume_info->local_nls);
+	goto out;
 }
 
 static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,

commit fa18f1bdce898f0efd0c8639c901d826d01be04f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:50:44 2011 -0400

    cifs: more breakage on mount failures
    
    if cifs_get_root() fails, we end up with ->mount() returning NULL,
    which is not what callers expect.  Moreover, in case of superblock
    reuse we end up leaking a superblock reference...
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ba2b2da360d3..234e9d08db76 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -710,19 +710,16 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	sb->s_flags |= MS_ACTIVE;
 
+out_shared:
 	root = cifs_get_root(volume_info, sb);
-	if (root == NULL)
+	if (root == NULL) {
+		root = ERR_PTR(-EINVAL); /* XXX */
 		goto out_super;
+	}
 
 	cFYI(1, "dentry root is: %p", root);
 	goto out;
 
-out_shared:
-	root = cifs_get_root(volume_info, sb);
-	if (root)
-		cFYI(1, "dentry root is: %p", root);
-	goto out;
-
 out_super:
 	deactivate_locked_super(sb);
 out:

commit ee01a14d9ddcf3f832f9ceb837888501cb496e27
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:47:23 2011 -0400

    cifs: close sget() races
    
    have ->s_fs_info set by the set() callback passed to sget()
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 46960b7ee433..ba2b2da360d3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -629,6 +629,13 @@ cifs_get_root(struct smb_vol *vol, struct super_block *sb)
 	return dparent;
 }
 
+static int cifs_set_super(struct super_block *sb, void *data)
+{
+	struct cifs_mnt_data *mnt_data = data;
+	sb->s_fs_info = mnt_data->cifs_sb;
+	return set_anon_super(sb, NULL);
+}
+
 static struct dentry *
 cifs_do_mount(struct file_system_type *fs_type,
 	      int flags, const char *dev_name, void *data)
@@ -678,14 +685,14 @@ cifs_do_mount(struct file_system_type *fs_type,
 	mnt_data.cifs_sb = cifs_sb;
 	mnt_data.flags = flags;
 
-	sb = sget(fs_type, cifs_match_super, set_anon_super, &mnt_data);
+	sb = sget(fs_type, cifs_match_super, cifs_set_super, &mnt_data);
 	if (IS_ERR(sb)) {
 		root = ERR_CAST(sb);
 		cifs_umount(cifs_sb);
 		goto out;
 	}
 
-	if (sb->s_fs_info) {
+	if (sb->s_root) {
 		cFYI(1, "Use existing superblock");
 		cifs_umount(cifs_sb);
 		goto out_shared;
@@ -694,7 +701,6 @@ cifs_do_mount(struct file_system_type *fs_type,
 	sb->s_flags = flags;
 	/* BB should we make this contingent on mount parm? */
 	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
-	sb->s_fs_info = cifs_sb;
 
 	rc = cifs_read_super(sb);
 	if (rc) {

commit d757d71bfc30669a500b72792067e8d1c5d401a5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:42:43 2011 -0400

    cifs: pull freeing mountdata/dropping nls/freeing cifs_sb into cifs_umount()
    
    all callers of cifs_umount() proceed to do the same thing; pull it into
    cifs_umount() itself.
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 15de4561dbc5..46960b7ee433 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -171,9 +171,6 @@ static void cifs_kill_sb(struct super_block *sb)
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	kill_anon_super(sb);
 	cifs_umount(cifs_sb);
-	kfree(cifs_sb->mountdata);
-	unload_nls(cifs_sb->local_nls);
-	kfree(cifs_sb);
 }
 
 static int
@@ -685,15 +682,12 @@ cifs_do_mount(struct file_system_type *fs_type,
 	if (IS_ERR(sb)) {
 		root = ERR_CAST(sb);
 		cifs_umount(cifs_sb);
-		goto out_cifs_sb;
+		goto out;
 	}
 
 	if (sb->s_fs_info) {
 		cFYI(1, "Use existing superblock");
 		cifs_umount(cifs_sb);
-		kfree(cifs_sb->mountdata);
-		unload_nls(cifs_sb->local_nls);
-		kfree(cifs_sb);
 		goto out_shared;
 	}
 
@@ -725,13 +719,6 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 out_super:
 	deactivate_locked_super(sb);
-	goto out;
-
-out_cifs_sb:
-	kfree(cifs_sb->mountdata);
-	unload_nls(cifs_sb->local_nls);
-	kfree(cifs_sb);
-
 out:
 	cifs_cleanup_volume_info(&volume_info);
 	return root;

commit 98ab494dd1d25388981114057cf9446250cc7dc7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:32:10 2011 -0400

    cifs: move cifs_umount() call into ->kill_sb()
    
    instead of calling it manually in case if cifs_read_super() fails
    to set ->s_root, just call it from ->kill_sb().  cifs_put_super()
    is gone now *and* we have cifs_sb shutdown and destruction done
    after the superblock is gone from ->s_instances.
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4004bc647a72..15de4561dbc5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -163,30 +163,14 @@ cifs_read_super(struct super_block *sb)
 	if (inode)
 		iput(inode);
 
-	cifs_umount(cifs_sb);
 	return rc;
 }
 
-static void
-cifs_put_super(struct super_block *sb)
-{
-	int rc = 0;
-	struct cifs_sb_info *cifs_sb;
-
-	cFYI(1, "In cifs_put_super");
-	cifs_sb = CIFS_SB(sb);
-	if (cifs_sb == NULL) {
-		cFYI(1, "Empty cifs superblock info passed to unmount");
-		return;
-	}
-
-	cifs_umount(cifs_sb);
-}
-
 static void cifs_kill_sb(struct super_block *sb)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	kill_anon_super(sb);
+	cifs_umount(cifs_sb);
 	kfree(cifs_sb->mountdata);
 	unload_nls(cifs_sb->local_nls);
 	kfree(cifs_sb);
@@ -537,7 +521,6 @@ static int cifs_drop_inode(struct inode *inode)
 }
 
 static const struct super_operations cifs_super_ops = {
-	.put_super = cifs_put_super,
 	.statfs = cifs_statfs,
 	.alloc_inode = cifs_alloc_inode,
 	.destroy_inode = cifs_destroy_inode,

commit 97d1152acec0647b72f8c6ecc57da0d6fed574de
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:29:57 2011 -0400

    cifs: pull cifs_mount() call up
    
    ... to the point prior to sget().  Now we have cifs_sb set up early
    enough.
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2af14d4577a7..4004bc647a72 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -104,8 +104,7 @@ cifs_sb_deactive(struct super_block *sb)
 }
 
 static int
-cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
-		const char *devname, int silent)
+cifs_read_super(struct super_block *sb)
 {
 	struct inode *inode;
 	struct cifs_sb_info *cifs_sb;
@@ -113,14 +112,6 @@ cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
 
 	cifs_sb = CIFS_SB(sb);
 
-	rc = cifs_mount(cifs_sb, volume_info);
-
-	if (rc) {
-		if (!silent)
-			cERROR(1, "cifs_mount failed w/return code = %d", rc);
-		return rc;
-	}
-
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)
 		sb->s_flags |= MS_POSIXACL;
 
@@ -692,6 +683,17 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	cifs_setup_cifs_sb(volume_info, cifs_sb);
 
+	rc = cifs_mount(cifs_sb, volume_info);
+	if (rc) {
+		if (!(flags & MS_SILENT))
+			cERROR(1, "cifs_mount failed w/return code = %d", rc);
+		root = ERR_PTR(rc);
+		unload_nls(volume_info->local_nls);
+		kfree(cifs_sb->mountdata);
+		kfree(cifs_sb);
+		goto out;
+	}
+
 	mnt_data.vol = volume_info;
 	mnt_data.cifs_sb = cifs_sb;
 	mnt_data.flags = flags;
@@ -699,11 +701,13 @@ cifs_do_mount(struct file_system_type *fs_type,
 	sb = sget(fs_type, cifs_match_super, set_anon_super, &mnt_data);
 	if (IS_ERR(sb)) {
 		root = ERR_CAST(sb);
+		cifs_umount(cifs_sb);
 		goto out_cifs_sb;
 	}
 
 	if (sb->s_fs_info) {
 		cFYI(1, "Use existing superblock");
+		cifs_umount(cifs_sb);
 		kfree(cifs_sb->mountdata);
 		unload_nls(cifs_sb->local_nls);
 		kfree(cifs_sb);
@@ -715,8 +719,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
 	sb->s_fs_info = cifs_sb;
 
-	rc = cifs_read_super(sb, volume_info, dev_name,
-			     flags & MS_SILENT ? 1 : 0);
+	rc = cifs_read_super(sb);
 	if (rc) {
 		root = ERR_PTR(rc);
 		goto out_super;

commit 2a9b99516c662d1713d58648e4a4c9aef72051bc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:27:16 2011 -0400

    sanitize cifs_umount() prototype
    
    a) superblock argument is unused
    b) it always returns 0
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 61c7aa870f1c..2af14d4577a7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -172,7 +172,7 @@ cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
 	if (inode)
 		iput(inode);
 
-	cifs_umount(sb, cifs_sb);
+	cifs_umount(cifs_sb);
 	return rc;
 }
 
@@ -189,9 +189,7 @@ cifs_put_super(struct super_block *sb)
 		return;
 	}
 
-	rc = cifs_umount(sb, cifs_sb);
-	if (rc)
-		cERROR(1, "cifs_umount failed with return code %d", rc);
+	cifs_umount(cifs_sb);
 }
 
 static void cifs_kill_sb(struct super_block *sb)

commit 2ced6f693581357b2a5bf8b031a702c624b12d0d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:20:04 2011 -0400

    cifs: initialize ->tlink_tree in cifs_setup_cifs_sb()
    
    no need to wait until cifs_read_super() and we need it done
    by the time cifs_mount() will be called.
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ec19161dd278..61c7aa870f1c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -113,9 +113,6 @@ cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
 
 	cifs_sb = CIFS_SB(sb);
 
-	spin_lock_init(&cifs_sb->tlink_tree_lock);
-	cifs_sb->tlink_tree = RB_ROOT;
-
 	rc = cifs_mount(cifs_sb, volume_info);
 
 	if (rc) {

commit 5d3bc605cafe3f367b1c43b673bf643245c81626
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:17:28 2011 -0400

    cifs: allocate mountdata earlier
    
    pull mountdata allocation up, so that it won't stand in the way when
    we lift cifs_mount() to location before sget().
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4162ee45d043..ec19161dd278 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -687,6 +687,14 @@ cifs_do_mount(struct file_system_type *fs_type,
 		goto out;
 	}
 
+	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
+	if (cifs_sb->mountdata == NULL) {
+		root = ERR_PTR(-ENOMEM);
+		unload_nls(volume_info->local_nls);
+		kfree(cifs_sb);
+		goto out;
+	}
+
 	cifs_setup_cifs_sb(volume_info, cifs_sb);
 
 	mnt_data.vol = volume_info;
@@ -701,22 +709,12 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	if (sb->s_fs_info) {
 		cFYI(1, "Use existing superblock");
+		kfree(cifs_sb->mountdata);
 		unload_nls(cifs_sb->local_nls);
 		kfree(cifs_sb);
 		goto out_shared;
 	}
 
-	/*
-	 * Copy mount params for use in submounts. Better to do
-	 * the copy here and deal with the error before cleanup gets
-	 * complicated post-mount.
-	 */
-	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
-	if (cifs_sb->mountdata == NULL) {
-		root = ERR_PTR(-ENOMEM);
-		goto out_super;
-	}
-
 	sb->s_flags = flags;
 	/* BB should we make this contingent on mount parm? */
 	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
@@ -749,6 +747,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	goto out;
 
 out_cifs_sb:
+	kfree(cifs_sb->mountdata);
 	unload_nls(cifs_sb->local_nls);
 	kfree(cifs_sb);
 

commit d687ca380f1a8f3043f42efd2403cbe58c846e70
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:14:27 2011 -0400

    cifs: leak on mount if we share superblock
    
    cifs_sb and nls end up leaked...
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8f7451f3c8e6..4162ee45d043 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -701,6 +701,8 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	if (sb->s_fs_info) {
 		cFYI(1, "Use existing superblock");
+		unload_nls(cifs_sb->local_nls);
+		kfree(cifs_sb);
 		goto out_shared;
 	}
 

commit 2c6292ae4be00454882246d07f38cdf15a823c2a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 09:05:48 2011 -0400

    cifs: don't pass superblock to cifs_mount()
    
    To close sget() races we'll need to be able to set cifs_sb up before
    we get the superblock, so we'll want to be able to do cifs_mount()
    earlier.  Fortunately, it's easy to do - setting ->s_maxbytes can
    be done in cifs_read_super(), ditto for ->s_time_gran and as for
    putting MS_POSIXACL into ->s_flags, we can mirror it in ->mnt_cifs_flags
    until cifs_read_super() is called.  Kill unused 'devname' argument,
    while we are at it...
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index bfab2bc83726..8f7451f3c8e6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -116,7 +116,7 @@ cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
 	spin_lock_init(&cifs_sb->tlink_tree_lock);
 	cifs_sb->tlink_tree = RB_ROOT;
 
-	rc = cifs_mount(sb, cifs_sb, volume_info, devname);
+	rc = cifs_mount(cifs_sb, volume_info);
 
 	if (rc) {
 		if (!silent)
@@ -124,6 +124,17 @@ cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
 		return rc;
 	}
 
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)
+		sb->s_flags |= MS_POSIXACL;
+
+	if (cifs_sb_master_tcon(cifs_sb)->ses->capabilities & CAP_LARGE_FILES)
+		sb->s_maxbytes = MAX_LFS_FILESIZE;
+	else
+		sb->s_maxbytes = MAX_NON_LFS;
+
+	/* BB FIXME fix time_gran to be larger for LANMAN sessions */
+	sb->s_time_gran = 100;
+
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
 	sb->s_bdi = &cifs_sb->bdi;

commit ca171baaad1420a29cca98be5bdf5596cd70b294
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 08:49:12 2011 -0400

    cifs: don't leak nls on mount failure
    
    if cifs_sb allocation fails, we still need to drop nls we'd stashed
    into volume_info - the one we would've copied to cifs_sb if we could
    allocate the latter.
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index dc76c7bccb15..bfab2bc83726 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -672,6 +672,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	cifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
 	if (cifs_sb == NULL) {
 		root = ERR_PTR(-ENOMEM);
+		unload_nls(volume_info->local_nls);
 		goto out;
 	}
 

commit 6d6861757dfadb7d6aec6bb34acd471210a755f9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 08:34:57 2011 -0400

    cifs: double free on mount failure
    
    if we get to out_super with ->s_root already set (e.g. with
    cifs_get_root() failure), we'll end up with cifs_put_super()
    called and ->mountdata freed twice.  We'll also get cifs_sb
    freed twice and cifs_sb->local_nls dropped twice.  The problem
    is, we can get to out_super both with and without ->s_root,
    which makes ->put_super() a bad place for such work.
    
    Switch to ->kill_sb(), have all that work done there after
    kill_anon_super().  Unlike ->put_super(), ->kill_sb() is
    called by deactivate_locked_super() whether we have ->s_root
    or not.
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5d3c4fa4b546..dc76c7bccb15 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -184,11 +184,13 @@ cifs_put_super(struct super_block *sb)
 	rc = cifs_umount(sb, cifs_sb);
 	if (rc)
 		cERROR(1, "cifs_umount failed with return code %d", rc);
-	if (cifs_sb->mountdata) {
-		kfree(cifs_sb->mountdata);
-		cifs_sb->mountdata = NULL;
-	}
+}
 
+static void cifs_kill_sb(struct super_block *sb)
+{
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	kill_anon_super(sb);
+	kfree(cifs_sb->mountdata);
 	unload_nls(cifs_sb->local_nls);
 	kfree(cifs_sb);
 }
@@ -729,8 +731,8 @@ cifs_do_mount(struct file_system_type *fs_type,
 	goto out;
 
 out_super:
-	kfree(cifs_sb->mountdata);
 	deactivate_locked_super(sb);
+	goto out;
 
 out_cifs_sb:
 	unload_nls(cifs_sb->local_nls);
@@ -827,7 +829,7 @@ struct file_system_type cifs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "cifs",
 	.mount = cifs_do_mount,
-	.kill_sb = kill_anon_super,
+	.kill_sb = cifs_kill_sb,
 	/*  .fs_flags */
 };
 const struct inode_operations cifs_dir_inode_ops = {

commit dd8544661947ad6d8d87b3c9d4333bfa1583d1bc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 17 08:24:42 2011 -0400

    take bdi setup/destruction into cifs_mount/cifs_umount
    
    Acked-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2f0c58646c10..5d3c4fa4b546 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -116,18 +116,12 @@ cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
 	spin_lock_init(&cifs_sb->tlink_tree_lock);
 	cifs_sb->tlink_tree = RB_ROOT;
 
-	rc = bdi_setup_and_register(&cifs_sb->bdi, "cifs", BDI_CAP_MAP_COPY);
-	if (rc)
-		return rc;
-
-	cifs_sb->bdi.ra_pages = default_backing_dev_info.ra_pages;
-
 	rc = cifs_mount(sb, cifs_sb, volume_info, devname);
 
 	if (rc) {
 		if (!silent)
 			cERROR(1, "cifs_mount failed w/return code = %d", rc);
-		goto out_mount_failed;
+		return rc;
 	}
 
 	sb->s_magic = CIFS_MAGIC_NUMBER;
@@ -171,9 +165,6 @@ cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
 		iput(inode);
 
 	cifs_umount(sb, cifs_sb);
-
-out_mount_failed:
-	bdi_destroy(&cifs_sb->bdi);
 	return rc;
 }
 
@@ -199,7 +190,6 @@ cifs_put_super(struct super_block *sb)
 	}
 
 	unload_nls(cifs_sb->local_nls);
-	bdi_destroy(&cifs_sb->bdi);
 	kfree(cifs_sb);
 }
 

commit ec12781f192568f7ea860f440f890389ba393df7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 18 20:03:36 2011 -0400

    cifs_permission() doesn't need to bail out in RCU mode
    
    nothing potentially blocking except generic_permission(), which
    will DTRT
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e9def996e383..2f0c58646c10 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -257,9 +257,6 @@ static int cifs_permission(struct inode *inode, int mask, unsigned int flags)
 {
 	struct cifs_sb_info *cifs_sb;
 
-	if (flags & IPERM_FLAG_RCU)
-		return -ECHILD;
-
 	cifs_sb = CIFS_SB(inode->i_sb);
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {

commit 3e715513643f0207c8f3c22010b54954cd697474
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Jun 13 11:50:41 2011 -0400

    cifs: show sec= option in /proc/mounts
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 989442dcfb45..e9def996e383 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -352,6 +352,37 @@ cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 	}
 }
 
+static void
+cifs_show_security(struct seq_file *s, struct TCP_Server_Info *server)
+{
+	seq_printf(s, ",sec=");
+
+	switch (server->secType) {
+	case LANMAN:
+		seq_printf(s, "lanman");
+		break;
+	case NTLMv2:
+		seq_printf(s, "ntlmv2");
+		break;
+	case NTLM:
+		seq_printf(s, "ntlm");
+		break;
+	case Kerberos:
+		seq_printf(s, "krb5");
+		break;
+	case RawNTLMSSP:
+		seq_printf(s, "ntlmssp");
+		break;
+	default:
+		/* shouldn't ever happen */
+		seq_printf(s, "unknown");
+		break;
+	}
+
+	if (server->sec_mode & (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))
+		seq_printf(s, "i");
+}
+
 /*
  * cifs_show_options() is for displaying mount options in /proc/mounts.
  * Not all settable options are displayed but most of the important
@@ -365,6 +396,8 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	struct sockaddr *srcaddr;
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
+	cifs_show_security(s, tcon->ses->server);
+
 	seq_printf(s, ",unc=%s", tcon->treeName);
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)

commit 96daf2b09178d8ebde2b0d56b027de917c17dfdf
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri May 27 04:34:02 2011 +0000

    [CIFS] Rename three structures to avoid camel case
    
    secMode to sec_mode
    and
    cifsTconInfo to cifs_tcon
    and
    cifsSesInfo to cifs_ses
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 26981bf2cf3f..989442dcfb45 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -208,7 +208,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct super_block *sb = dentry->d_sb;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	struct cifsTconInfo *tcon = cifs_sb_master_tcon(cifs_sb);
+	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
 	int rc = -EOPNOTSUPP;
 	int xid;
 
@@ -361,7 +361,7 @@ static int
 cifs_show_options(struct seq_file *s, struct vfsmount *m)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(m->mnt_sb);
-	struct cifsTconInfo *tcon = cifs_sb_master_tcon(cifs_sb);
+	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
 	struct sockaddr *srcaddr;
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
@@ -461,7 +461,7 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 static void cifs_umount_begin(struct super_block *sb)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	struct cifsTconInfo *tcon;
+	struct cifs_tcon *tcon;
 
 	if (cifs_sb == NULL)
 		return;

commit d4ffff1fa9695c5b5c0bf337e208d8833b88ff2d
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 26 06:02:00 2011 +0000

    CIFS: Add rwpidforward mount option
    
    Add rwpidforward mount option that switches on a mode when we forward
    pid of a process who opened a file to any read and write operation.
    
    This can prevent applications like WINE from failing on read or write
    operation on a previously locked file region from the same netfd from
    another process if we use mandatory brlock style.
    
    It is actual for WINE because during a run of WINE program two processes
    work on the same netfd - share the same file struct between several VFS
    fds:
    1) WINE-server does open and lock;
    2) WINE-application does read and write.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 360fe2ec2a19..26981bf2cf3f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -415,12 +415,20 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		seq_printf(s, ",nocase");
 	if (tcon->retry)
 		seq_printf(s, ",hard");
+	if (tcon->unix_ext)
+		seq_printf(s, ",unix");
+	else
+		seq_printf(s, ",nounix");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 		seq_printf(s, ",posixpaths");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)
 		seq_printf(s, ",setuids");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
 		seq_printf(s, ",serverino");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
+		seq_printf(s, ",rwpidforward");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL)
+		seq_printf(s, ",forcemand");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
 		seq_printf(s, ",directio");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)

commit 25c7f41e9234f60af30e086278f1de7974f8816f
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 26 23:35:47 2011 +0400

    CIFS: Migrate to shared superblock model
    
    Add cifs_match_super to use in sget to share superblock between mounts
    that have the same //server/sharename, credentials and mount options.
    It helps us to improve performance on work with future SMB2.1 leases.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 46fdd55cf427..360fe2ec2a19 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -630,6 +630,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	struct super_block *sb;
 	struct cifs_sb_info *cifs_sb;
 	struct smb_vol *volume_info;
+	struct cifs_mnt_data mnt_data;
 	struct dentry *root;
 
 	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
@@ -646,12 +647,21 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	cifs_setup_cifs_sb(volume_info, cifs_sb);
 
-	sb = sget(fs_type, NULL, set_anon_super, NULL);
+	mnt_data.vol = volume_info;
+	mnt_data.cifs_sb = cifs_sb;
+	mnt_data.flags = flags;
+
+	sb = sget(fs_type, cifs_match_super, set_anon_super, &mnt_data);
 	if (IS_ERR(sb)) {
 		root = ERR_CAST(sb);
 		goto out_cifs_sb;
 	}
 
+	if (sb->s_fs_info) {
+		cFYI(1, "Use existing superblock");
+		goto out_shared;
+	}
+
 	/*
 	 * Copy mount params for use in submounts. Better to do
 	 * the copy here and deal with the error before cleanup gets
@@ -680,9 +690,16 @@ cifs_do_mount(struct file_system_type *fs_type,
 	root = cifs_get_root(volume_info, sb);
 	if (root == NULL)
 		goto out_super;
+
 	cFYI(1, "dentry root is: %p", root);
 	goto out;
 
+out_shared:
+	root = cifs_get_root(volume_info, sb);
+	if (root)
+		cFYI(1, "dentry root is: %p", root);
+	goto out;
+
 out_super:
 	kfree(cifs_sb->mountdata);
 	deactivate_locked_super(sb);

commit f87d39d951329cd8f462bf9007d334122c0599d0
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri May 27 03:50:55 2011 +0000

    [CIFS] Migrate from prefixpath logic
    
    Now we point superblock to a server share root and set a root dentry
    appropriately. This let us share superblock between mounts like
    //server/sharename/foo/bar and //server/sharename/foo further.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1d2a93c60e75..46fdd55cf427 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -415,8 +415,6 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		seq_printf(s, ",nocase");
 	if (tcon->retry)
 		seq_printf(s, ",hard");
-	if (cifs_sb->prepath)
-		seq_printf(s, ",prepath=%s", cifs_sb->prepath);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 		seq_printf(s, ",posixpaths");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)
@@ -530,6 +528,100 @@ static const struct super_operations cifs_super_ops = {
 #endif
 };
 
+/*
+ * Get root dentry from superblock according to prefix path mount option.
+ * Return dentry with refcount + 1 on success and NULL otherwise.
+ */
+static struct dentry *
+cifs_get_root(struct smb_vol *vol, struct super_block *sb)
+{
+	int xid, rc;
+	struct inode *inode;
+	struct qstr name;
+	struct dentry *dparent = NULL, *dchild = NULL, *alias;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	unsigned int i, full_len, len;
+	char *full_path = NULL, *pstart;
+	char sep;
+
+	full_path = cifs_build_path_to_root(vol, cifs_sb,
+					    cifs_sb_master_tcon(cifs_sb));
+	if (full_path == NULL)
+		return NULL;
+
+	cFYI(1, "Get root dentry for %s", full_path);
+
+	xid = GetXid();
+	sep = CIFS_DIR_SEP(cifs_sb);
+	dparent = dget(sb->s_root);
+	full_len = strlen(full_path);
+	full_path[full_len] = sep;
+	pstart = full_path + 1;
+
+	for (i = 1, len = 0; i <= full_len; i++) {
+		if (full_path[i] != sep || !len) {
+			len++;
+			continue;
+		}
+
+		full_path[i] = 0;
+		cFYI(1, "get dentry for %s", pstart);
+
+		name.name = pstart;
+		name.len = len;
+		name.hash = full_name_hash(pstart, len);
+		dchild = d_lookup(dparent, &name);
+		if (dchild == NULL) {
+			cFYI(1, "not exists");
+			dchild = d_alloc(dparent, &name);
+			if (dchild == NULL) {
+				dput(dparent);
+				dparent = NULL;
+				goto out;
+			}
+		}
+
+		cFYI(1, "get inode");
+		if (dchild->d_inode == NULL) {
+			cFYI(1, "not exists");
+			inode = NULL;
+			if (cifs_sb_master_tcon(CIFS_SB(sb))->unix_ext)
+				rc = cifs_get_inode_info_unix(&inode, full_path,
+							      sb, xid);
+			else
+				rc = cifs_get_inode_info(&inode, full_path,
+							 NULL, sb, xid, NULL);
+			if (rc) {
+				dput(dchild);
+				dput(dparent);
+				dparent = NULL;
+				goto out;
+			}
+			alias = d_materialise_unique(dchild, inode);
+			if (alias != NULL) {
+				dput(dchild);
+				if (IS_ERR(alias)) {
+					dput(dparent);
+					dparent = NULL;
+					goto out;
+				}
+				dchild = alias;
+			}
+		}
+		cFYI(1, "parent %p, child %p", dparent, dchild);
+
+		dput(dparent);
+		dparent = dchild;
+		len = 0;
+		pstart = full_path + i + 1;
+		full_path[i] = sep;
+	}
+out:
+	_FreeXid(xid);
+	kfree(full_path);
+	return dparent;
+}
+
 static struct dentry *
 cifs_do_mount(struct file_system_type *fs_type,
 	      int flags, const char *dev_name, void *data)
@@ -585,7 +677,10 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	sb->s_flags |= MS_ACTIVE;
 
-	root = dget(sb->s_root);
+	root = cifs_get_root(volume_info, sb);
+	if (root == NULL)
+		goto out_super;
+	cFYI(1, "dentry root is: %p", root);
 	goto out;
 
 out_super:

commit 641a58d66d086327042e9d73c6606fd02c8f067c
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 26 00:02:16 2011 +0400

    CIFS: Fix memory leak in cifs_do_mount
    
    and simplify error handling code.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d1ed7f9946d5..1d2a93c60e75 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -556,9 +556,8 @@ cifs_do_mount(struct file_system_type *fs_type,
 
 	sb = sget(fs_type, NULL, set_anon_super, NULL);
 	if (IS_ERR(sb)) {
-		kfree(cifs_sb);
 		root = ERR_CAST(sb);
-		goto out;
+		goto out_cifs_sb;
 	}
 
 	/*
@@ -569,7 +568,7 @@ cifs_do_mount(struct file_system_type *fs_type,
 	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
 	if (cifs_sb->mountdata == NULL) {
 		root = ERR_PTR(-ENOMEM);
-		goto err_out;
+		goto out_super;
 	}
 
 	sb->s_flags = flags;
@@ -581,21 +580,23 @@ cifs_do_mount(struct file_system_type *fs_type,
 			     flags & MS_SILENT ? 1 : 0);
 	if (rc) {
 		root = ERR_PTR(rc);
-		goto err_out;
+		goto out_super;
 	}
 
 	sb->s_flags |= MS_ACTIVE;
 
 	root = dget(sb->s_root);
-out:
-	cifs_cleanup_volume_info(&volume_info);
-	return root;
+	goto out;
 
-err_out:
+out_super:
 	kfree(cifs_sb->mountdata);
+	deactivate_locked_super(sb);
+
+out_cifs_sb:
 	unload_nls(cifs_sb->local_nls);
 	kfree(cifs_sb);
-	deactivate_locked_super(sb);
+
+out:
 	cifs_cleanup_volume_info(&volume_info);
 	return root;
 }

commit b2e5cd33b598fb496b9366c445bd77c801efabb8
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Wed May 25 13:35:34 2011 +0400

    CIFS: Fix undefined behavior when mount fails
    
    Fix double kfree() calls on the same pointers and cleanup mount code.
    
    Reviewed-and-Tested-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 131afadce0e0..d1ed7f9946d5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -104,29 +104,23 @@ cifs_sb_deactive(struct super_block *sb)
 }
 
 static int
-cifs_read_super(struct super_block *sb, struct cifs_sb_info *cifs_sb,
-		void *data, struct smb_vol *volume_info, const char *devname,
-		int silent)
+cifs_read_super(struct super_block *sb, struct smb_vol *volume_info,
+		const char *devname, int silent)
 {
 	struct inode *inode;
+	struct cifs_sb_info *cifs_sb;
 	int rc = 0;
 
-	/* BB should we make this contingent on mount parm? */
-	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
-	sb->s_fs_info = cifs_sb;
+	cifs_sb = CIFS_SB(sb);
 
 	spin_lock_init(&cifs_sb->tlink_tree_lock);
 	cifs_sb->tlink_tree = RB_ROOT;
 
 	rc = bdi_setup_and_register(&cifs_sb->bdi, "cifs", BDI_CAP_MAP_COPY);
-	if (rc) {
-		kfree(cifs_sb);
+	if (rc)
 		return rc;
-	}
-	cifs_sb->bdi.ra_pages = default_backing_dev_info.ra_pages;
 
-	if (data)
-		cifs_sb->mountdata = data;
+	cifs_sb->bdi.ra_pages = default_backing_dev_info.ra_pages;
 
 	rc = cifs_mount(sb, cifs_sb, volume_info, devname);
 
@@ -179,15 +173,7 @@ cifs_read_super(struct super_block *sb, struct cifs_sb_info *cifs_sb,
 	cifs_umount(sb, cifs_sb);
 
 out_mount_failed:
-	if (cifs_sb) {
-		if (cifs_sb->mountdata) {
-			kfree(cifs_sb->mountdata);
-			cifs_sb->mountdata = NULL;
-		}
-		unload_nls(cifs_sb->local_nls);
-		bdi_destroy(&cifs_sb->bdi);
-		kfree(cifs_sb);
-	}
+	bdi_destroy(&cifs_sb->bdi);
 	return rc;
 }
 
@@ -553,7 +539,6 @@ cifs_do_mount(struct file_system_type *fs_type,
 	struct cifs_sb_info *cifs_sb;
 	struct smb_vol *volume_info;
 	struct dentry *root;
-	char *copied_data = NULL;
 
 	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
 
@@ -576,20 +561,23 @@ cifs_do_mount(struct file_system_type *fs_type,
 		goto out;
 	}
 
-	sb->s_flags = flags;
-
 	/*
 	 * Copy mount params for use in submounts. Better to do
 	 * the copy here and deal with the error before cleanup gets
 	 * complicated post-mount.
 	 */
-	copied_data = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
-	if (copied_data == NULL) {
+	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
+	if (cifs_sb->mountdata == NULL) {
 		root = ERR_PTR(-ENOMEM);
 		goto err_out;
 	}
 
-	rc = cifs_read_super(sb, cifs_sb, copied_data, volume_info, dev_name,
+	sb->s_flags = flags;
+	/* BB should we make this contingent on mount parm? */
+	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
+	sb->s_fs_info = cifs_sb;
+
+	rc = cifs_read_super(sb, volume_info, dev_name,
 			     flags & MS_SILENT ? 1 : 0);
 	if (rc) {
 		root = ERR_PTR(rc);
@@ -604,6 +592,8 @@ cifs_do_mount(struct file_system_type *fs_type,
 	return root;
 
 err_out:
+	kfree(cifs_sb->mountdata);
+	unload_nls(cifs_sb->local_nls);
 	kfree(cifs_sb);
 	deactivate_locked_super(sb);
 	cifs_cleanup_volume_info(&volume_info);

commit 724d9f1cfba0cb16a7151333b501e8f7885450d8
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu May 5 09:55:12 2011 +0000

    CIFS: Simplify mount code for further shared sb capability
    
    Reorganize code to get mount option at first and when get a superblock.
    This lets us use shared superblock model further for equal mounts.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 493b74ca5648..131afadce0e0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -104,19 +104,16 @@ cifs_sb_deactive(struct super_block *sb)
 }
 
 static int
-cifs_read_super(struct super_block *sb, void *data,
-		const char *devname, int silent)
+cifs_read_super(struct super_block *sb, struct cifs_sb_info *cifs_sb,
+		void *data, struct smb_vol *volume_info, const char *devname,
+		int silent)
 {
 	struct inode *inode;
-	struct cifs_sb_info *cifs_sb;
 	int rc = 0;
 
 	/* BB should we make this contingent on mount parm? */
 	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
-	sb->s_fs_info = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
-	cifs_sb = CIFS_SB(sb);
-	if (cifs_sb == NULL)
-		return -ENOMEM;
+	sb->s_fs_info = cifs_sb;
 
 	spin_lock_init(&cifs_sb->tlink_tree_lock);
 	cifs_sb->tlink_tree = RB_ROOT;
@@ -128,22 +125,10 @@ cifs_read_super(struct super_block *sb, void *data,
 	}
 	cifs_sb->bdi.ra_pages = default_backing_dev_info.ra_pages;
 
-	/*
-	 * Copy mount params to sb for use in submounts. Better to do
-	 * the copy here and deal with the error before cleanup gets
-	 * complicated post-mount.
-	 */
-	if (data) {
-		cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
-		if (cifs_sb->mountdata == NULL) {
-			bdi_destroy(&cifs_sb->bdi);
-			kfree(sb->s_fs_info);
-			sb->s_fs_info = NULL;
-			return -ENOMEM;
-		}
-	}
+	if (data)
+		cifs_sb->mountdata = data;
 
-	rc = cifs_mount(sb, cifs_sb, devname);
+	rc = cifs_mount(sb, cifs_sb, volume_info, devname);
 
 	if (rc) {
 		if (!silent)
@@ -561,27 +546,68 @@ static const struct super_operations cifs_super_ops = {
 
 static struct dentry *
 cifs_do_mount(struct file_system_type *fs_type,
-	    int flags, const char *dev_name, void *data)
+	      int flags, const char *dev_name, void *data)
 {
 	int rc;
 	struct super_block *sb;
-
-	sb = sget(fs_type, NULL, set_anon_super, NULL);
+	struct cifs_sb_info *cifs_sb;
+	struct smb_vol *volume_info;
+	struct dentry *root;
+	char *copied_data = NULL;
 
 	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
 
-	if (IS_ERR(sb))
-		return ERR_CAST(sb);
+	rc = cifs_setup_volume_info(&volume_info, (char *)data, dev_name);
+	if (rc)
+		return ERR_PTR(rc);
+
+	cifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
+	if (cifs_sb == NULL) {
+		root = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+
+	cifs_setup_cifs_sb(volume_info, cifs_sb);
+
+	sb = sget(fs_type, NULL, set_anon_super, NULL);
+	if (IS_ERR(sb)) {
+		kfree(cifs_sb);
+		root = ERR_CAST(sb);
+		goto out;
+	}
 
 	sb->s_flags = flags;
 
-	rc = cifs_read_super(sb, data, dev_name, flags & MS_SILENT ? 1 : 0);
+	/*
+	 * Copy mount params for use in submounts. Better to do
+	 * the copy here and deal with the error before cleanup gets
+	 * complicated post-mount.
+	 */
+	copied_data = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
+	if (copied_data == NULL) {
+		root = ERR_PTR(-ENOMEM);
+		goto err_out;
+	}
+
+	rc = cifs_read_super(sb, cifs_sb, copied_data, volume_info, dev_name,
+			     flags & MS_SILENT ? 1 : 0);
 	if (rc) {
-		deactivate_locked_super(sb);
-		return ERR_PTR(rc);
+		root = ERR_PTR(rc);
+		goto err_out;
 	}
+
 	sb->s_flags |= MS_ACTIVE;
-	return dget(sb->s_root);
+
+	root = dget(sb->s_root);
+out:
+	cifs_cleanup_volume_info(&volume_info);
+	return root;
+
+err_out:
+	kfree(cifs_sb);
+	deactivate_locked_super(sb);
+	cifs_cleanup_volume_info(&volume_info);
+	return root;
 }
 
 static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,

commit 156ecb2d8b06589098f6ce3012e6a10fef07c416
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri May 20 17:00:01 2011 +0000

    [CIFS] Fix to problem with getattr caused by invalidate simplification patch
    
    Fix to earlier "Simplify invalidate part (try #6)" patch
    That patch caused problems with connectathon test 5.
    
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ed92c7d36378..493b74ca5648 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -617,8 +617,10 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 		if (!CIFS_I(inode)->clientCanCacheRead && inode->i_mapping &&
 		    inode->i_mapping->nrpages != 0) {
 			rc = filemap_fdatawait(inode->i_mapping);
-			mapping_set_error(inode->i_mapping, rc);
-			return rc;
+			if (rc) {
+				mapping_set_error(inode->i_mapping, rc);
+				return rc;
+			}
 		}
 		/*
 		 * Some applications poll for the file length in this strange

commit c4aca0c09f80ca40dbcecb2370af9594fbe9051d
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Fri May 6 02:35:00 2011 -0500

    cifs: Change key name to cifs.idmap, misc. clean-up
    
    Change idmap key name from cifs.cifs_idmap to cifs.idmap.
    Removed unused structure wksidarr and function match_sid().
    Handle errors correctly in function init_cifs().
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2b8e47e5e533..ed92c7d36378 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1046,21 +1046,23 @@ init_cifs(void)
 #ifdef CONFIG_CIFS_ACL
 	rc = init_cifs_idmap();
 	if (rc)
-		goto out_destroy_request_bufs;
+		goto out_register_key_type;
 #endif /* CONFIG_CIFS_ACL */
 
 	rc = register_filesystem(&cifs_fs_type);
 	if (rc)
-		goto out_destroy_request_bufs;
+		goto out_init_cifs_idmap;
 
 	return 0;
 
-out_destroy_request_bufs:
+out_init_cifs_idmap:
 #ifdef CONFIG_CIFS_ACL
 	exit_cifs_idmap();
+out_register_key_type:
 #endif
 #ifdef CONFIG_CIFS_UPCALL
 	unregister_key_type(&cifs_spnego_key_type);
+out_destroy_request_bufs:
 #endif
 	cifs_destroy_request_bufs();
 out_destroy_mids:

commit f14bcf71d1b802f6042b6c70a0c37120e47a0876
Author: Sean Finney <seanius@seanius.net>
Date:   Mon Apr 11 13:19:35 2011 +0000

    cifs: Unconditionally copy mount options to superblock info
    
    Previously mount options were copied and updated in the cifs_sb_info
    struct only when CONFIG_CIFS_DFS_UPCALL was enabled.  Making this
    information generally available allows us to remove a number of ifdefs,
    extra function params, and temporary variables.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Sean Finney <seanius@seanius.net>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index bb39afcc6f38..2b8e47e5e533 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -128,7 +128,6 @@ cifs_read_super(struct super_block *sb, void *data,
 	}
 	cifs_sb->bdi.ra_pages = default_backing_dev_info.ra_pages;
 
-#ifdef CONFIG_CIFS_DFS_UPCALL
 	/*
 	 * Copy mount params to sb for use in submounts. Better to do
 	 * the copy here and deal with the error before cleanup gets
@@ -143,9 +142,8 @@ cifs_read_super(struct super_block *sb, void *data,
 			return -ENOMEM;
 		}
 	}
-#endif
 
-	rc = cifs_mount(sb, cifs_sb, data, devname);
+	rc = cifs_mount(sb, cifs_sb, devname);
 
 	if (rc) {
 		if (!silent)
@@ -197,12 +195,10 @@ cifs_read_super(struct super_block *sb, void *data,
 
 out_mount_failed:
 	if (cifs_sb) {
-#ifdef CONFIG_CIFS_DFS_UPCALL
 		if (cifs_sb->mountdata) {
 			kfree(cifs_sb->mountdata);
 			cifs_sb->mountdata = NULL;
 		}
-#endif
 		unload_nls(cifs_sb->local_nls);
 		bdi_destroy(&cifs_sb->bdi);
 		kfree(cifs_sb);
@@ -226,12 +222,10 @@ cifs_put_super(struct super_block *sb)
 	rc = cifs_umount(sb, cifs_sb);
 	if (rc)
 		cERROR(1, "cifs_umount failed with return code %d", rc);
-#ifdef CONFIG_CIFS_DFS_UPCALL
 	if (cifs_sb->mountdata) {
 		kfree(cifs_sb->mountdata);
 		cifs_sb->mountdata = NULL;
 	}
-#endif
 
 	unload_nls(cifs_sb->local_nls);
 	bdi_destroy(&cifs_sb->bdi);

commit 5167f11ec962690ecf926fab00f1d0524cd78664
Author: Sean Finney <seanius@seanius.net>
Date:   Mon Apr 11 13:19:34 2011 +0000

    cifs: Use kstrndup for cifs_sb->mountdata
    
    A relatively minor nit, but also clarified the "consensus" from the
    preceding comments that it is in fact better to try for the kstrdup
    early and cleanup while cleaning up is still a simple thing to do.
    
    Reviewed-By: Steve French <smfrench@gmail.com>
    Signed-off-by: Sean Finney <seanius@seanius.net>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0f6a54f14eff..bb39afcc6f38 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -129,24 +129,19 @@ cifs_read_super(struct super_block *sb, void *data,
 	cifs_sb->bdi.ra_pages = default_backing_dev_info.ra_pages;
 
 #ifdef CONFIG_CIFS_DFS_UPCALL
-	/* copy mount params to sb for use in submounts */
-	/* BB: should we move this after the mount so we
-	 * do not have to do the copy on failed mounts?
-	 * BB: May be it is better to do simple copy before
-	 * complex operation (mount), and in case of fail
-	 * just exit instead of doing mount and attempting
-	 * undo it if this copy fails?*/
+	/*
+	 * Copy mount params to sb for use in submounts. Better to do
+	 * the copy here and deal with the error before cleanup gets
+	 * complicated post-mount.
+	 */
 	if (data) {
-		int len = strlen(data);
-		cifs_sb->mountdata = kzalloc(len + 1, GFP_KERNEL);
+		cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
 		if (cifs_sb->mountdata == NULL) {
 			bdi_destroy(&cifs_sb->bdi);
 			kfree(sb->s_fs_info);
 			sb->s_fs_info = NULL;
 			return -ENOMEM;
 		}
-		strncpy(cifs_sb->mountdata, data, len + 1);
-		cifs_sb->mountdata[len] = '\0';
 	}
 #endif
 

commit 6feb9891da4f8b04ffca69c00eb56bb7c1b64dc4
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Apr 7 18:18:11 2011 +0400

    CIFS: Simplify invalidate part (try #5)
    
    Simplify many places when we call cifs_revalidate/invalidate to make
    it do what it exactly needs.
    
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f736d8a2e771..0f6a54f14eff 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -618,16 +618,29 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 {
 	/* origin == SEEK_END => we must revalidate the cached file length */
 	if (origin == SEEK_END) {
-		int retval;
-
-		/* some applications poll for the file length in this strange
-		   way so we must seek to end on non-oplocked files by
-		   setting the revalidate time to zero */
-		CIFS_I(file->f_path.dentry->d_inode)->time = 0;
-
-		retval = cifs_revalidate_file(file);
-		if (retval < 0)
-			return (loff_t)retval;
+		int rc;
+		struct inode *inode = file->f_path.dentry->d_inode;
+
+		/*
+		 * We need to be sure that all dirty pages are written and the
+		 * server has the newest file length.
+		 */
+		if (!CIFS_I(inode)->clientCanCacheRead && inode->i_mapping &&
+		    inode->i_mapping->nrpages != 0) {
+			rc = filemap_fdatawait(inode->i_mapping);
+			mapping_set_error(inode->i_mapping, rc);
+			return rc;
+		}
+		/*
+		 * Some applications poll for the file length in this strange
+		 * way so we must seek to end on non-oplocked files by
+		 * setting the revalidate time to zero.
+		 */
+		CIFS_I(inode)->time = 0;
+
+		rc = cifs_revalidate_file_attr(file);
+		if (rc < 0)
+			return (loff_t)rc;
 	}
 	return generic_file_llseek_unlocked(file, offset, origin);
 }

commit 0b81c1c405c063f3ecea66c2f5e9c3aefc5359c8
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Thu Mar 10 10:11:05 2011 +0300

    CIFS: directio read/write cleanups
    
    Recently introduced strictcache mode brought a new code that can be
    efficiently used by directio part. That's let us add vectored operations
    and break unnecessary cifs_user_read and cifs_user_write.
    
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 6c1d738418f1..f736d8a2e771 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -760,10 +760,11 @@ const struct file_operations cifs_file_strict_ops = {
 };
 
 const struct file_operations cifs_file_direct_ops = {
-	/* no aio, no readv -
-	   BB reevaluate whether they can be done with directio, no cache */
-	.read = cifs_user_read,
-	.write = cifs_user_write,
+	/* BB reevaluate whether they can be done with directio, no cache */
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = cifs_user_readv,
+	.aio_write = cifs_user_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
@@ -815,10 +816,11 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 };
 
 const struct file_operations cifs_file_direct_nobrl_ops = {
-	/* no mmap, no aio, no readv -
-	   BB reevaluate whether they can be done with directio, no cache */
-	.read = cifs_user_read,
-	.write = cifs_user_write,
+	/* BB reevaluate whether they can be done with directio, no cache */
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = cifs_user_readv,
+	.aio_write = cifs_user_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.fsync = cifs_fsync,

commit 4d79dba0e00749fa40de8ef13a9b85ce57a1603b
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Wed Apr 27 23:34:35 2011 -0500

    cifs: Add idmap key and related data structures and functions (try #17 repost)
    
    Define (global) data structures to store ids, uids and gids, to which a
    SID maps.  There are two separate trees, one for SID/uid and another one
    for SID/gid.
    
    A new type of key, cifs_idmap_key_type, is used.
    
    Keys are instantiated and searched using credential of the root by
    overriding and restoring the credentials of the caller requesting the key.
    
    Id mapping functions are invoked under config option of cifs acl.
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 30fc505b7ef1..6c1d738418f1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1033,22 +1033,31 @@ init_cifs(void)
 	if (rc)
 		goto out_destroy_mids;
 
-	rc = register_filesystem(&cifs_fs_type);
-	if (rc)
-		goto out_destroy_request_bufs;
 #ifdef CONFIG_CIFS_UPCALL
 	rc = register_key_type(&cifs_spnego_key_type);
 	if (rc)
-		goto out_unregister_filesystem;
-#endif
+		goto out_destroy_request_bufs;
+#endif /* CONFIG_CIFS_UPCALL */
+
+#ifdef CONFIG_CIFS_ACL
+	rc = init_cifs_idmap();
+	if (rc)
+		goto out_destroy_request_bufs;
+#endif /* CONFIG_CIFS_ACL */
+
+	rc = register_filesystem(&cifs_fs_type);
+	if (rc)
+		goto out_destroy_request_bufs;
 
 	return 0;
 
+out_destroy_request_bufs:
+#ifdef CONFIG_CIFS_ACL
+	exit_cifs_idmap();
+#endif
 #ifdef CONFIG_CIFS_UPCALL
-out_unregister_filesystem:
-	unregister_filesystem(&cifs_fs_type);
+	unregister_key_type(&cifs_spnego_key_type);
 #endif
-out_destroy_request_bufs:
 	cifs_destroy_request_bufs();
 out_destroy_mids:
 	cifs_destroy_mids();
@@ -1070,6 +1079,10 @@ exit_cifs(void)
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	cifs_dfs_release_automount_timer();
 #endif
+#ifdef CONFIG_CIFS_ACL
+	cifs_destroy_idmaptrees();
+	exit_cifs_idmap();
+#endif
 #ifdef CONFIG_CIFS_UPCALL
 	unregister_key_type(&cifs_spnego_key_type);
 #endif

commit 257208736acc694def83627fa0de2892490a5d42
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Fri Feb 25 10:48:55 2011 -0600

    cifs: cleanup: Rename and remove config flags
    
    Remove config flag CIFS_EXPERIMENTAL.
    Do export operations under new config flag CIFS_NFSD_EXPORT
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b45d38b89116..30fc505b7ef1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -184,12 +184,12 @@ cifs_read_super(struct super_block *sb, void *data,
 	else
 		sb->s_d_op = &cifs_dentry_ops;
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
+#ifdef CIFS_NFSD_EXPORT
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {
 		cFYI(1, "export ops supported");
 		sb->s_export_op = &cifs_export_ops;
 	}
-#endif /* EXPERIMENTAL */
+#endif /* CIFS_NFSD_EXPORT */
 
 	return 0;
 

commit 0eff0e26777430bcfee1ef47bd90250858ada431
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Feb 24 05:39:23 2011 +0000

    Remove unused CIFSSMBNotify worker function
    
    The CIFSSMBNotify worker is unused, pending changes to allow it to be called
    via inotify, so move it into its own experimental config option so it does
    not get built in, until the necessary VFS support is fixed.  It used to
    be used in dnotify, but according to Jeff, inotify needs minor changes
    before we can reenable this.
    
    CC: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0742c269ef12..b45d38b89116 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -981,10 +981,10 @@ init_cifs(void)
 	int rc = 0;
 	cifs_proc_init();
 	INIT_LIST_HEAD(&cifs_tcp_ses_list);
-#ifdef CONFIG_CIFS_EXPERIMENTAL
+#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* unused temporarily */
 	INIT_LIST_HEAD(&GlobalDnotifyReqList);
 	INIT_LIST_HEAD(&GlobalDnotifyRsp_Q);
-#endif
+#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */
 /*
  *  Initialize Global counters
  */

commit 9b6763e0aacf245b58687a372816a0a4aabf2b1e
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Mon Feb 21 23:56:59 2011 -0600

    cifs: Remove unused inode number while fetching root inode
    
    ino is unused in function cifs_root_iget().
    
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5c412b33cd7c..0742c269ef12 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -163,7 +163,7 @@ cifs_read_super(struct super_block *sb, void *data,
 	sb->s_bdi = &cifs_sb->bdi;
 	sb->s_blocksize = CIFS_MAX_MSGSIZE;
 	sb->s_blocksize_bits = 14;	/* default 2**14 = CIFS_MAX_MSGSIZE */
-	inode = cifs_root_iget(sb, ROOT_I);
+	inode = cifs_root_iget(sb);
 
 	if (IS_ERR(inode)) {
 		rc = PTR_ERR(inode);

commit ca83ce3d5b9ad321ee24f5870a77f0b21ac5a5de
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Apr 12 09:13:44 2011 -0400

    cifs: don't allow mmap'ed pages to be dirtied while under writeback (try #3)
    
    This is more or less the same patch as before, but with some merge
    conflicts fixed up.
    
    If a process has a dirty page mapped into its page tables, then it has
    the ability to change it while the client is trying to write the data
    out to the server. If that happens after the signature has been
    calculated then that signature will then be wrong, and the server will
    likely reset the TCP connection.
    
    This patch adds a page_mkwrite handler for CIFS that simply takes the
    page lock. Because the page lock is held over the life of writepage and
    writepages, this prevents the page from becoming writeable until
    the write call has completed.
    
    With this, we can also remove the "sign_zero_copy" module option and
    always inline the pages when writing.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e3352a1ac479..5c412b33cd7c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -81,10 +81,6 @@ module_param(echo_retries, ushort, 0644);
 MODULE_PARM_DESC(echo_retries, "Number of echo attempts before giving up and "
 			       "reconnecting server. Default: 5. 0 means "
 			       "never reconnect.");
-bool sign_zero_copy;  /* globals init to false automatically */
-module_param(sign_zero_copy, bool, 0644);
-MODULE_PARM_DESC(sign_zero_copy, "Don't copy pages on write with signing "
-				 "enabled. Default: N");
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;

commit 2b6c26a0a62cc0bab0ad487533d5581d7c293fef
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Mar 25 16:25:57 2011 -0400

    cifs: set ra_pages in backing_dev_info
    
    Commit 522440ed made cifs set backing_dev_info on the mapping attached
    to new inodes. This change caused a fairly significant read performance
    regression, as cifs started doing page-sized reads exclusively.
    
    By virtue of the fact that they're allocated as part of cifs_sb_info by
    kzalloc, the ra_pages on cifs BDIs get set to 0, which prevents any
    readahead. This forces the normal read codepaths to use readpage instead
    of readpages causing a four-fold increase in the number of read calls
    with the default rsize.
    
    Fix it by setting ra_pages in the BDI to the same value as that in the
    default_backing_dev_info.
    
    Fixes https://bugzilla.kernel.org/show_bug.cgi?id=31662
    
    Cc: stable@kernel.org
    Reported-and-Tested-by: Till <till2.schaefer@uni-dortmund.de>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0e0cc60dbde0..e3352a1ac479 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -130,6 +130,7 @@ cifs_read_super(struct super_block *sb, void *data,
 		kfree(cifs_sb);
 		return rc;
 	}
+	cifs_sb->bdi.ra_pages = default_backing_dev_info.ra_pages;
 
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	/* copy mount params to sb for use in submounts */

commit 8727c8a85f3951ef0eef36a665f5dceebb4c495d
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Feb 25 01:11:56 2011 -0600

    Allow user names longer than 32 bytes
    
    We artificially limited the user name to 32 bytes, but modern servers handle
    larger.  Set the maximum length to a reasonable 256, and make the user name
    string dynamically allocated rather than a fixed size in session structure.
    Also clean up old checkpatch warning.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 41c78e8fc591..0e0cc60dbde0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -412,8 +412,8 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)
 		seq_printf(s, ",multiuser");
-	else if (tcon->ses->userName)
-		seq_printf(s, ",username=%s", tcon->ses->userName);
+	else if (tcon->ses->user_name)
+		seq_printf(s, ",username=%s", tcon->ses->user_name);
 
 	if (tcon->ses->domainName)
 		seq_printf(s, ",domain=%s", tcon->ses->domainName);

commit bdf1b03e093bdbc571f404e751c7b0e2dca412ea
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Feb 22 20:17:19 2011 -0500

    cifs: replace /proc/fs/cifs/Experimental with a module parm
    
    This flag currently only affects whether we allow "zero-copy" writes
    with signing enabled. Typically we map pages in the pagecache directly
    into the write request. If signing is enabled however and the contents
    of the page change after the signature is calculated but before the
    write is sent then the signature will be wrong. Servers typically
    respond to this by closing down the socket.
    
    Still, this can provide a performance benefit so the "Experimental" flag
    was overloaded to allow this. That's really not a good place for this
    option however since it's not clear what that flag does.
    
    Move that flag instead to a new module parameter that better describes
    its purpose. That's also better since it can be set at module insertion
    time by configuring modprobe.d.
    
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f2970136d17d..41c78e8fc591 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -53,7 +53,6 @@ int cifsFYI = 0;
 int cifsERROR = 1;
 int traceSMB = 0;
 unsigned int oplockEnabled = 1;
-unsigned int experimEnabled = 0;
 unsigned int linuxExtEnabled = 1;
 unsigned int lookupCacheEnabled = 1;
 unsigned int multiuser_mount = 0;
@@ -82,6 +81,10 @@ module_param(echo_retries, ushort, 0644);
 MODULE_PARM_DESC(echo_retries, "Number of echo attempts before giving up and "
 			       "reconnecting server. Default: 5. 0 means "
 			       "never reconnect.");
+bool sign_zero_copy;  /* globals init to false automatically */
+module_param(sign_zero_copy, bool, 0644);
+MODULE_PARM_DESC(sign_zero_copy, "Don't copy pages on write with signing "
+				 "enabled. Default: N");
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;

commit 72432ffcf555decbbae47f1be338e1d2f210aa69
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Mon Jan 24 14:16:35 2011 -0500

    CIFS: Implement cifs_strict_writev (try #4)
    
    If we don't have Exclusive oplock we write a data to the server.
    Also set invalidate_mapping flag on the inode if we wrote something
    to the server. Add cifs_iovec_write to let the client write iovec
    buffers through CIFSSMBWrite2.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a8323f1dc1c4..f2970136d17d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -600,10 +600,17 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 {
 	struct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;
 	ssize_t written;
+	int rc;
 
 	written = generic_file_aio_write(iocb, iov, nr_segs, pos);
-	if (!CIFS_I(inode)->clientCanCacheAll)
-		filemap_fdatawrite(inode->i_mapping);
+
+	if (CIFS_I(inode)->clientCanCacheAll)
+		return written;
+
+	rc = filemap_fdatawrite(inode->i_mapping);
+	if (rc)
+		cFYI(1, "cifs_file_aio_write: %d rc on %p inode", rc, inode);
+
 	return written;
 }
 
@@ -737,7 +744,7 @@ const struct file_operations cifs_file_strict_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
 	.aio_read = cifs_strict_readv,
-	.aio_write = cifs_file_aio_write,
+	.aio_write = cifs_strict_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
@@ -793,7 +800,7 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
 	.aio_read = cifs_strict_readv,
-	.aio_write = cifs_file_aio_write,
+	.aio_write = cifs_strict_writev,
 	.open = cifs_open,
 	.release = cifs_close,
 	.fsync = cifs_strict_fsync,

commit a70307eeeb25b89f6b2baf3cf3f0cef83c96ba12
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Tue Dec 14 11:50:41 2010 +0300

    CIFS: Implement cifs_strict_readv (try #4)
    
    Read from the cache if we have at least Level II oplock - otherwise
    read from the server. Add cifs_user_readv to let the client read into
    iovec buffers.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e24d966fb214..a8323f1dc1c4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -736,7 +736,7 @@ const struct file_operations cifs_file_ops = {
 const struct file_operations cifs_file_strict_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
-	.aio_read = generic_file_aio_read,
+	.aio_read = cifs_strict_readv,
 	.aio_write = cifs_file_aio_write,
 	.open = cifs_open,
 	.release = cifs_close,
@@ -792,7 +792,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 const struct file_operations cifs_file_strict_nobrl_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
-	.aio_read = generic_file_aio_read,
+	.aio_read = cifs_strict_readv,
 	.aio_write = cifs_file_aio_write,
 	.open = cifs_open,
 	.release = cifs_close,

commit 7a6a19b17ab9103ec708c18befd28f2a3908d4c1
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Tue Dec 14 11:29:51 2010 +0300

    CIFS: Implement cifs_file_strict_mmap (try #2)
    
    Invalidate inode mapping if we don't have at least Level II oplock.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f6093e401c5a..e24d966fb214 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -743,7 +743,7 @@ const struct file_operations cifs_file_strict_ops = {
 	.lock = cifs_lock,
 	.fsync = cifs_strict_fsync,
 	.flush = cifs_flush,
-	.mmap = cifs_file_mmap,
+	.mmap = cifs_file_strict_mmap,
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_POSIX
@@ -798,7 +798,7 @@ const struct file_operations cifs_file_strict_nobrl_ops = {
 	.release = cifs_close,
 	.fsync = cifs_strict_fsync,
 	.flush = cifs_flush,
-	.mmap = cifs_file_mmap,
+	.mmap = cifs_file_strict_mmap,
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_POSIX

commit 8be7e6ba142423e6ad98fed293c96f196f685229
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Sun Dec 12 13:11:13 2010 +0300

    CIFS: Implement cifs_strict_fsync
    
    Invalidate inode mapping if we don't have at least Level II oplock in
    cifs_strict_fsync. Also remove filemap_write_and_wait call from cifs_fsync
    because it is previously called from vfs_fsync_range. Add file operations'
    structures for strict cache mode.
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 99d777a03dd0..f6093e401c5a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -733,6 +733,25 @@ const struct file_operations cifs_file_ops = {
 	.setlease = cifs_setlease,
 };
 
+const struct file_operations cifs_file_strict_ops = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = cifs_file_aio_write,
+	.open = cifs_open,
+	.release = cifs_close,
+	.lock = cifs_lock,
+	.fsync = cifs_strict_fsync,
+	.flush = cifs_flush,
+	.mmap = cifs_file_mmap,
+	.splice_read = generic_file_splice_read,
+	.llseek = cifs_llseek,
+#ifdef CONFIG_CIFS_POSIX
+	.unlocked_ioctl	= cifs_ioctl,
+#endif /* CONFIG_CIFS_POSIX */
+	.setlease = cifs_setlease,
+};
+
 const struct file_operations cifs_file_direct_ops = {
 	/* no aio, no readv -
 	   BB reevaluate whether they can be done with directio, no cache */
@@ -751,6 +770,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.llseek = cifs_llseek,
 	.setlease = cifs_setlease,
 };
+
 const struct file_operations cifs_file_nobrl_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
@@ -769,6 +789,24 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.setlease = cifs_setlease,
 };
 
+const struct file_operations cifs_file_strict_nobrl_ops = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = cifs_file_aio_write,
+	.open = cifs_open,
+	.release = cifs_close,
+	.fsync = cifs_strict_fsync,
+	.flush = cifs_flush,
+	.mmap = cifs_file_mmap,
+	.splice_read = generic_file_splice_read,
+	.llseek = cifs_llseek,
+#ifdef CONFIG_CIFS_POSIX
+	.unlocked_ioctl	= cifs_ioctl,
+#endif /* CONFIG_CIFS_POSIX */
+	.setlease = cifs_setlease,
+};
+
 const struct file_operations cifs_file_direct_nobrl_ops = {
 	/* no mmap, no aio, no readv -
 	   BB reevaluate whether they can be done with directio, no cache */

commit fda3594362184383e73f0a2a5fa5b38ac0e04fd8
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jan 20 18:06:34 2011 +0000

    [CIFS] cifs: reconnect unresponsive servers
    
    If the server isn't responding to echoes, we don't want to leave tasks
    hung waiting for it to reply. At that point, we'll want to reconnect
    so that soft mounts can return an error to userspace quickly.
    
    If the client hasn't received a reply after a specified number of echo
    intervals, assume that the transport is down and attempt to reconnect
    the socket.
    
    The number of echo_intervals to wait before attempting to reconnect is
    tunable via a module parameter. Setting it to 0, means that the client
    will never attempt to reconnect. The default is 5.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d9f652a522a6..99d777a03dd0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -77,7 +77,11 @@ unsigned int cifs_max_pending = CIFS_MAX_REQ;
 module_param(cifs_max_pending, int, 0);
 MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server. "
 				   "Default: 50 Range: 2 to 256");
-
+unsigned short echo_retries = 5;
+module_param(echo_retries, ushort, 0644);
+MODULE_PARM_DESC(echo_retries, "Number of echo attempts before giving up and "
+			       "reconnecting server. Default: 5. 0 means "
+			       "never reconnect.");
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;

commit 1c929cfe6d8f2087a337a868fbf6c38d56bb4889
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 18 11:43:51 2010 -0500

    switch cifs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5e7075d5f139..d9f652a522a6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -174,6 +174,12 @@ cifs_read_super(struct super_block *sb, void *data,
 		goto out_no_root;
 	}
 
+	/* do that *after* d_alloc_root() - we want NULL ->d_op for root here */
+	if (cifs_sb_master_tcon(cifs_sb)->nocase)
+		sb->s_d_op = &cifs_ci_dentry_ops;
+	else
+		sb->s_d_op = &cifs_dentry_ops;
+
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {
 		cFYI(1, "export ops supported");

commit 20054bd65703f7504a9daceabc2a060828fde36c
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jan 7 11:30:27 2011 -0500

    cifs: use CreationTime like an i_generation field
    
    Reduce false inode collisions by using the CreationTime like an
    i_generation field. This way, even if the server ends up reusing
    a uniqueid after a delete/create cycle, we can avoid matching
    the inode incorrectly.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5abfedaa5e78..5e7075d5f139 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -329,6 +329,8 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->invalid_mapping = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
 	cifs_inode->server_eof = 0;
+	cifs_inode->uniqueid = 0;
+	cifs_inode->createtime = 0;
 
 	/* Can not set i_flags here - they get immediately overwritten
 	   to zero by the VFS */

commit acc6f11272ce4f77c40b1a6292eb198fd6aaf8c3
Merge: 7e12eddb73d4 0c21e3aaf6ae
Author: Steve French <sfrench@us.ibm.com>
Date:   Sun Jan 9 23:18:16 2011 +0000

    Merge branch 'master' of /pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
            fs/cifs/dir.c

commit b74c79e99389cd79b31fcc08f82c24e492e63c7e
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:58 2011 +1100

    fs: provide rcu-walk aware permission i_ops
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 223717dcc401..8e21e0fe65d5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -283,10 +283,13 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
-static int cifs_permission(struct inode *inode, int mask)
+static int cifs_permission(struct inode *inode, int mask, unsigned int flags)
 {
 	struct cifs_sb_info *cifs_sb;
 
+	if (flags & IPERM_FLAG_RCU)
+		return -ECHILD;
+
 	cifs_sb = CIFS_SB(inode->i_sb);
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {
@@ -298,7 +301,7 @@ static int cifs_permission(struct inode *inode, int mask)
 		on the client (above and beyond ACL on servers) for
 		servers which do not support setting and viewing mode bits,
 		so allowing client to check permissions is useful */
-		return generic_permission(inode, mask, NULL);
+		return generic_permission(inode, mask, flags, NULL);
 }
 
 static struct kmem_cache *cifs_inode_cachep;

commit fa0d7e3de6d6fc5004ad9dea0dd6b286af8f03e9
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:49 2011 +1100

    fs: icache RCU free inodes
    
    RCU free the struct inode. This will allow:
    
    - Subsequent store-free path walking patch. The inode must be consulted for
      permissions when walking, so an RCU inode reference is a must.
    - sb_inode_list_lock to be moved inside i_lock because sb list walkers who want
      to take i_lock no longer need to take sb_inode_list_lock to walk the list in
      the first place. This will simplify and optimize locking.
    - Could remove some nested trylock loops in dcache code
    - Could potentially simplify things a bit in VM land. Do not need to take the
      page lock to follow page->mapping.
    
    The downsides of this is the performance cost of using RCU. In a simple
    creat/unlink microbenchmark, performance drops by about 10% due to inability to
    reuse cache-hot slab objects. As iterations increase and RCU freeing starts
    kicking over, this increases to about 20%.
    
    In cases where inode lifetimes are longer (ie. many inodes may be allocated
    during the average life span of a single inode), a lot of this cache reuse is
    not applicable, so the regression caused by this patch is smaller.
    
    The cache-hot regression could largely be avoided by using SLAB_DESTROY_BY_RCU,
    however this adds some complexity to list walking and store-free path walking,
    so I prefer to implement this at a later date, if it is shown to be a win in
    real situations. I haven't found a regression in any non-micro benchmark so I
    doubt it will be a problem.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3936aa7f2c22..223717dcc401 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -334,10 +334,17 @@ cifs_alloc_inode(struct super_block *sb)
 	return &cifs_inode->vfs_inode;
 }
 
+static void cifs_i_callback(struct rcu_head *head)
+{
+	struct inode *inode = container_of(head, struct inode, i_rcu);
+	INIT_LIST_HEAD(&inode->i_dentry);
+	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
+}
+
 static void
 cifs_destroy_inode(struct inode *inode)
 {
-	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
+	call_rcu(&inode->i_rcu, cifs_i_callback);
 }
 
 static void

commit a9f1b85e5ba80519dea6974e3574fa7a30cc5e29
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Mon Dec 13 19:08:35 2010 +0300

    CIFS: Simplify ipv*_connect functions into one (try #4)
    
    Make connect logic more ip-protocol independent and move RFC1001 stuff into
    a separate function. Also replace union addr in TCP_Server_Info structure
    with sockaddr_storage.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-and-Tested-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3936aa7f2c22..9df5c0b94d0f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -351,18 +351,19 @@ cifs_evict_inode(struct inode *inode)
 static void
 cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 {
+	struct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;
+	struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;
+
 	seq_printf(s, ",addr=");
 
-	switch (server->addr.sockAddr.sin_family) {
+	switch (server->dstaddr.ss_family) {
 	case AF_INET:
-		seq_printf(s, "%pI4", &server->addr.sockAddr.sin_addr.s_addr);
+		seq_printf(s, "%pI4", &sa->sin_addr.s_addr);
 		break;
 	case AF_INET6:
-		seq_printf(s, "%pI6",
-			   &server->addr.sockAddr6.sin6_addr.s6_addr);
-		if (server->addr.sockAddr6.sin6_scope_id)
-			seq_printf(s, "%%%u",
-				   server->addr.sockAddr6.sin6_scope_id);
+		seq_printf(s, "%pI6", &sa6->sin6_addr.s6_addr);
+		if (sa6->sin6_scope_id)
+			seq_printf(s, "%%%u", sa6->sin6_scope_id);
 		break;
 	default:
 		seq_printf(s, "(unknown)");

commit 884639996814585ef7079daa9e03a1eb562e235c
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Mon Nov 22 15:31:03 2010 -0500

    cifs: remove Local_System_Name
    
    ...this string is zeroed out and nothing ever changes it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 56a4b7544c3c..3936aa7f2c22 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -937,7 +937,6 @@ init_cifs(void)
 	GlobalCurrentXid = 0;
 	GlobalTotalActiveXid = 0;
 	GlobalMaxActiveXid = 0;
-	memset(Local_System_Name, 0, 15);
 	spin_lock_init(&cifs_tcp_ses_lock);
 	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);

commit 6d20e8406f0942228a73000663c2b33f488103ea
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Wed Dec 1 14:42:28 2010 +0530

    cifs: add attribute cache timeout (actimeo) tunable
    
    Currently, the attribute cache timeout for CIFS is hardcoded to 1 second. This
    means that the client might have to issue a QPATHINFO/QFILEINFO call every 1
    second to verify if something has changes, which seems too expensive. On the
    other hand, if the timeout is hardcoded to a higher value, workloads that
    expect strict cache coherency might see unexpected results.
    
    Making attribute cache timeout as a tunable will allow us to make a tradeoff
    between performance and cache metadata correctness depending on the
    application/workload needs.
    
    Add 'actimeo' tunable that can be used to tune the attribute cache timeout.
    The default timeout is set to 1 second. Also, display actimeo option value in
    /proc/mounts.
    
    It appears to me that 'actimeo' and the proposed (but not yet merged)
    'strictcache' option cannot coexist, so care must be taken that we reset the
    other option if one of them is set.
    
    Changes since last post:
       - fix option parsing and handle possible values correcly
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 76c8a906a63e..56a4b7544c3c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -463,6 +463,8 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 
 	seq_printf(s, ",rsize=%d", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%d", cifs_sb->wsize);
+	/* convert actimeo and display it in seconds */
+		seq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);
 
 	return 0;
 }

commit 476428f8c3bb6679f8f52bf2b935ac40bc9c7358
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Wed Nov 24 17:49:07 2010 +0530

    cifs: display fsc in /proc/mounts
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9c3789762ab7..76c8a906a63e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -458,6 +458,8 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		seq_printf(s, ",acl");
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)
 		seq_printf(s, ",mfsymlinks");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)
+		seq_printf(s, ",fsc");
 
 	seq_printf(s, ",rsize=%d", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%d", cifs_sb->wsize);

commit c67236281c5d749741f5414103903a7c1b9c4636
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Wed Nov 3 10:58:57 2010 +0300

    cifs: make cifs_set_oplock_level() take a cifsInodeInfo pointer
    
    All the callers already have a pointer to struct cifsInodeInfo. Use it.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 38526a6c4acf..9c3789762ab7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -321,8 +321,7 @@ cifs_alloc_inode(struct super_block *sb)
 	/* Until the file is open and we have gotten oplock
 	info back from the server, can not assume caching of
 	file data or metadata */
-	cifs_inode->clientCanCacheRead = false;
-	cifs_inode->clientCanCacheAll = false;
+	cifs_set_oplock_level(cifs_inode, 0);
 	cifs_inode->delete_pending = false;
 	cifs_inode->invalid_mapping = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */

commit b647c35f77af9c07d336247b23014596e9f0a593
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Oct 28 11:16:44 2010 -0400

    cifs: convert tlink_tree to a rbtree
    
    Radix trees are ideal when you want to track a bunch of pointers and
    can't embed a tracking structure within the target of those pointers.
    The tradeoff is an increase in memory, particularly if the tree is
    sparse.
    
    In CIFS, we use the tlink_tree to track tcon_link structs. A tcon_link
    can never be in more than one tlink_tree, so there's no impediment to
    using a rb_tree here instead of a radix tree.
    
    Convert the new multiuser mount code to use a rb_tree instead. This
    should reduce the memory required to manage the tlink_tree.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 75c4eaa79588..38526a6c4acf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -116,7 +116,7 @@ cifs_read_super(struct super_block *sb, void *data,
 		return -ENOMEM;
 
 	spin_lock_init(&cifs_sb->tlink_tree_lock);
-	INIT_RADIX_TREE(&cifs_sb->tlink_tree, GFP_KERNEL);
+	cifs_sb->tlink_tree = RB_ROOT;
 
 	rc = bdi_setup_and_register(&cifs_sb->bdi, "cifs", BDI_CAP_MAP_COPY);
 	if (rc) {

commit 51ee4b84f5c86935b438d6636f34b523edb415a8
Author: Christoph Hellwig <hch@infradead.org>
Date:   Sun Oct 31 08:35:10 2010 -0400

    locks: let the caller free file_lock on ->setlease failure
    
    The caller allocated it, the caller should free it.
    
    The only issue so far is that we could change the flp pointer even on an
    error return if the fl_change callback failed.  But we can simply move
    the flp assignment after the fl_change invocation, as the callers don't
    care about the flp return value if the setlease call failed.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 54745b6c3db9..75c4eaa79588 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -625,11 +625,8 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 		   knows that the file won't be changed on the server
 		   by anyone else */
 		return generic_setlease(file, arg, lease);
-	else {
-		if (arg != F_UNLCK)
-			locks_free_lock(*lease);
+	else
 		return -EAGAIN;
-	}
 }
 
 struct file_system_type cifs_fs_type = {

commit 05fa3135fdc7b9b510b502a35b6b97d2b38c6f48
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Sat Oct 30 17:31:15 2010 -0400

    locks: fix setlease methods to free passed-in lock
    
    We modified setlease to require the caller to allocate the new lease in
    the case of creating a new lease, but forgot to fix up the filesystem
    methods.
    
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Steve French <sfrench@samba.org>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 75c4eaa79588..54745b6c3db9 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -625,8 +625,11 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 		   knows that the file won't be changed on the server
 		   by anyone else */
 		return generic_setlease(file, arg, lease);
-	else
+	else {
+		if (arg != F_UNLCK)
+			locks_free_lock(*lease);
 		return -EAGAIN;
+	}
 }
 
 struct file_system_type cifs_fs_type = {

commit b4020c1b198c0f0c0b0ff0cfdd824a26b93edd6f
Merge: 435f49a518c7 d3686d54c790
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 29 10:37:27 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6:
      cifs: Cleanup and thus reduce smb session structure and fields used during authentication
      NTLM auth and sign - Use appropriate server challenge
      cifs: add kfree() on error path
      NTLM auth and sign - minor error corrections and cleanup
      NTLM auth and sign - Use kernel crypto apis to calculate hashes and smb signatures
      NTLM auth and sign - Define crypto hash functions and create and send keys needed for key exchange
      cifs: cifs_convert_address() returns zero on error
      NTLM auth and sign - Allocate session key/client response dynamically
      cifs: update comments - [s/GlobalSMBSesLock/cifs_file_list_lock/g]
      cifs: eliminate cifsInodeInfo->write_behind_rc (try #6)
      [CIFS] Fix checkpatch warnings and bump cifs version number
      cifs: wait for writeback to complete in cifs_flush
      cifs: convert cifsFileInfo->count to non-atomic counter

commit d753ed975953a4e97a356bcd59ff146919f29235
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 26 12:52:33 2010 +0400

    convert cifs
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 34371637f210..8bd5c2c243a5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -545,9 +545,9 @@ static const struct super_operations cifs_super_ops = {
 #endif
 };
 
-static int
-cifs_get_sb(struct file_system_type *fs_type,
-	    int flags, const char *dev_name, void *data, struct vfsmount *mnt)
+static struct dentry *
+cifs_do_mount(struct file_system_type *fs_type,
+	    int flags, const char *dev_name, void *data)
 {
 	int rc;
 	struct super_block *sb;
@@ -557,18 +557,17 @@ cifs_get_sb(struct file_system_type *fs_type,
 	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
 
 	if (IS_ERR(sb))
-		return PTR_ERR(sb);
+		return ERR_CAST(sb);
 
 	sb->s_flags = flags;
 
 	rc = cifs_read_super(sb, data, dev_name, flags & MS_SILENT ? 1 : 0);
 	if (rc) {
 		deactivate_locked_super(sb);
-		return rc;
+		return ERR_PTR(rc);
 	}
 	sb->s_flags |= MS_ACTIVE;
-	simple_set_mnt(mnt, sb);
-	return 0;
+	return dget(sb->s_root);
 }
 
 static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
@@ -634,7 +633,7 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 struct file_system_type cifs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "cifs",
-	.get_sb = cifs_get_sb,
+	.mount = cifs_do_mount,
 	.kill_sb = kill_anon_super,
 	/*  .fs_flags */
 };

commit eb4b756b1e60b66e54932619088b645c712414a3
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 22 14:52:29 2010 -0400

    cifs: eliminate cifsInodeInfo->write_behind_rc (try #6)
    
    write_behind_rc is redundant and just adds complexity to the code. What
    we really want to do instead is to use mapping_set_error to reset the
    flags on the mapping when we find a writeback error and can't report it
    to userspace yet.
    
    For cifs_flush and cifs_fsync, we shouldn't reset the flags since errors
    returned there do get reported to userspace.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Reviewed-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 34371637f210..e8b9523c9f39 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -318,7 +318,6 @@ cifs_alloc_inode(struct super_block *sb)
 		return NULL;
 	cifs_inode->cifsAttrs = 0x20;	/* default */
 	cifs_inode->time = 0;
-	cifs_inode->write_behind_rc = 0;
 	/* Until the file is open and we have gotten oplock
 	info back from the server, can not assume caching of
 	file data or metadata */

commit d2ecad9faca2221ae6f664f146f0dcae661bf39d
Merge: c70b5296e775 cdff08e76612
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 17:52:29 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6: (56 commits)
      [CIFS] move close processing  from cifs_close to cifsFileInfo_put
      cifs: convert cifs_tcp_ses_lock from a rwlock to a spinlock
      cifs: cancel_delayed_work() + flush_scheduled_work() -> cancel_delayed_work_sync()
      Clean up two declarations of blob_len
      cifs: move cifsFileInfo_put to file.c
      cifs: convert GlobalSMBSeslock from a rwlock to regular spinlock
      [CIFS] Fix minor checkpatch warning and update cifs version
      cifs: move cifs_new_fileinfo to file.c
      cifs: eliminate pfile pointer from cifsFileInfo
      cifs: cifs_write argument change and cleanup
      cifs: clean up cifs_reopen_file
      cifs: eliminate the inode argument from cifs_new_fileinfo
      cifs: eliminate oflags option from cifs_new_fileinfo
      cifs: fix flags handling in cifs_posix_open
      cifs: eliminate cifs_posix_open_inode_helper
      cifs: handle FindFirst failure gracefully
      NTLM authentication and signing - Calculate auth response per smb session
      cifs: don't use vfsmount to pin superblock for oplock breaks
      cifs: keep dentry reference in cifsFileInfo instead of inode reference
      cifs: on multiuser mount, set ownership to current_fsuid/current_fsgid (try #7)
      ...
    
    Fix up trivial conflict in fs/cifs/cifsfs.c due to added/removed header files

commit 3f9bcca7820a6711307b6499952b13cfcfc31dd6
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Mon Oct 18 23:29:37 2010 +0530

    cifs: convert cifs_tcp_ses_lock from a rwlock to a spinlock
    
    cifs_tcp_ses_lock is a rwlock with protects the cifs_tcp_ses_list,
    server->smb_ses_list and the ses->tcon_list. It also protects a few
    ref counters in server, ses and tcon. In most cases the critical section
    doesn't seem to be large, in a few cases where it is slightly large, there
    seem to be really no benefit from concurrent access. I briefly considered RCU
    mechanism but it appears to me that there is no real need.
    
    Replace it with a spinlock and get rid of the last rwlock in the cifs code.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f1d9c71e807f..cb77915a445b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -482,16 +482,16 @@ static void cifs_umount_begin(struct super_block *sb)
 
 	tcon = cifs_sb_master_tcon(cifs_sb);
 
-	read_lock(&cifs_tcp_ses_lock);
+	spin_lock(&cifs_tcp_ses_lock);
 	if ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {
 		/* we have other mounts to same share or we have
 		   already tried to force umount this and woken up
 		   all waiting network requests, nothing to do */
-		read_unlock(&cifs_tcp_ses_lock);
+		spin_unlock(&cifs_tcp_ses_lock);
 		return;
 	} else if (tcon->tc_count == 1)
 		tcon->tidStatus = CifsExiting;
-	read_unlock(&cifs_tcp_ses_lock);
+	spin_unlock(&cifs_tcp_ses_lock);
 
 	/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */
 	/* cancel_notify_requests(tcon); */
@@ -940,7 +940,7 @@ init_cifs(void)
 	GlobalTotalActiveXid = 0;
 	GlobalMaxActiveXid = 0;
 	memset(Local_System_Name, 0, 15);
-	rwlock_init(&cifs_tcp_ses_lock);
+	spin_lock_init(&cifs_tcp_ses_lock);
 	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);
 

commit 4477288a103631980750c86547d1fd54bfd2ba7d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 15 15:34:03 2010 -0400

    cifs: convert GlobalSMBSeslock from a rwlock to regular spinlock
    
    Convert this lock to a regular spinlock
    
    A rwlock_t offers little value here. It's more expensive than a regular
    spinlock unless you have a fairly large section of code that runs under
    the read lock and can benefit from the concurrency.
    
    Additionally, we need to ensure that the refcounting for files isn't
    racy and to do that we need to lock areas that can increment it for
    write. That means that the areas that can actually use a read_lock are
    very few and relatively infrequently used.
    
    While we're at it, change the name to something easier to type, and fix
    a bug in find_writable_file. cifsFileInfo_put can sleep and shouldn't be
    called while holding the lock.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cbd468c880c4..f1d9c71e807f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -940,8 +940,8 @@ init_cifs(void)
 	GlobalTotalActiveXid = 0;
 	GlobalMaxActiveXid = 0;
 	memset(Local_System_Name, 0, 15);
-	rwlock_init(&GlobalSMBSeslock);
 	rwlock_init(&cifs_tcp_ses_lock);
+	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
 	if (cifs_max_pending < 2) {

commit d7c86ff8cd00abc730fe5d031f43dc9138b6324e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Oct 11 15:07:19 2010 -0400

    cifs: don't use vfsmount to pin superblock for oplock breaks
    
    Filesystems aren't really supposed to do anything with a vfsmount. It's
    considered a layering violation since vfsmounts are entirely managed at
    the VFS layer.
    
    CIFS currently keeps an active reference to a vfsmount in order to
    prevent the superblock vanishing before an oplock break has completed.
    What we really want to do instead is to keep sb->s_active high until the
    oplock break has completed. This patch borrows the scheme that NFS uses
    for handling sillyrenames.
    
    An atomic_t is added to the cifs_sb_info. When it transitions from 0 to
    1, an extra reference to the superblock is taken (by bumping the
    s_active value). When it transitions from 1 to 0, that reference is
    dropped and a the superblock teardown may proceed if there are no more
    references to it.
    
    Also, the vfsmount pointer is removed from cifsFileInfo and from
    cifs_new_fileinfo, and some bogus forward declarations are removed from
    cifsfs.h.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
    Acked-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3258c822328b..cbd468c880c4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -83,6 +83,24 @@ extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
+void
+cifs_sb_active(struct super_block *sb)
+{
+	struct cifs_sb_info *server = CIFS_SB(sb);
+
+	if (atomic_inc_return(&server->active) == 1)
+		atomic_inc(&sb->s_active);
+}
+
+void
+cifs_sb_deactive(struct super_block *sb)
+{
+	struct cifs_sb_info *server = CIFS_SB(sb);
+
+	if (atomic_dec_and_test(&server->active))
+		deactivate_super(sb);
+}
+
 static int
 cifs_read_super(struct super_block *sb, void *data,
 		const char *devname, int silent)

commit 0dd12c21951e085357046b68c3a108273062d2aa
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 8 12:20:12 2010 -0400

    cifs: initialize tlink_tree_lock and tlink_tree
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c96345c3314d..3258c822328b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -98,6 +98,9 @@ cifs_read_super(struct super_block *sb, void *data,
 	if (cifs_sb == NULL)
 		return -ENOMEM;
 
+	spin_lock_init(&cifs_sb->tlink_tree_lock);
+	INIT_RADIX_TREE(&cifs_sb->tlink_tree, GFP_KERNEL);
+
 	rc = bdi_setup_and_register(&cifs_sb->bdi, "cifs", BDI_CAP_MAP_COPY);
 	if (rc) {
 		kfree(cifs_sb);

commit 29e07c82a9e8acebbb38ecc22b0b5005a0a5d839
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 29 19:51:12 2010 -0400

    cifs: fix cifs_show_options to show "username=" or "multiuser"
    
    ...based on CIFS_MOUNT_MULTIUSER flag.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b2fd075dc2e6..c96345c3314d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -369,8 +369,12 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
 	seq_printf(s, ",unc=%s", tcon->treeName);
-	if (tcon->ses->userName)
+
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)
+		seq_printf(s, ",multiuser");
+	else if (tcon->ses->userName)
 		seq_printf(s, ",username=%s", tcon->ses->userName);
+
 	if (tcon->ses->domainName)
 		seq_printf(s, ",domain=%s", tcon->ses->domainName);
 

commit 13cfb7334eb6fd0fc06da5589aea1e947791f1d6
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 29 19:51:11 2010 -0400

    cifs: have cifsFileInfo hold a reference to a tlink rather than tcon pointer
    
    cifsFileInfo needs a pointer to a tcon, but it doesn't currently hold a
    reference to it. Change it to keep a pointer to a tcon_link instead and
    hold a reference to it.
    
    That will keep the tcon from being freed until the file is closed.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 898d2a5cfad2..b2fd075dc2e6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -595,7 +595,8 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 	    ((arg == F_WRLCK) &&
 		(CIFS_I(inode)->clientCanCacheAll)))
 		return generic_setlease(file, arg, lease);
-	else if (cfile->tcon->local_lease && !CIFS_I(inode)->clientCanCacheRead)
+	else if (tlink_tcon(cfile->tlink)->local_lease &&
+		 !CIFS_I(inode)->clientCanCacheRead)
 		/* If the server claims to support oplock on this
 		   file, then we still need to check oplock even
 		   if the local_lease mount option is set, but there

commit b89f432133851a01c0d28822f11cbdcc15781a75
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Sep 18 15:09:31 2010 +0200

    fs/locks.c: prepare for BKL removal
    
    This prepares the removal of the big kernel lock from the
    file locking code. We still use the BKL as long as fs/lockd
    uses it and ceph might sleep, but we can flip the definition
    to a private spinlock as soon as that's done.
    All users outside of fs/lockd get converted to use
    lock_flocks() instead of lock_kernel() where appropriate.
    
    Based on an earlier patch to use a spinlock from Matthew
    Wilcox, who has attempted this a few times before, the
    earliest patch from over 10 years ago turned it into
    a semaphore, which ended up being slower than the BKL
    and was subsequently reverted.
    
    Someone should do some serious performance testing when
    this becomes a spinlock, since this has caused problems
    before. Using a spinlock should be at least as good
    as the BKL in theory, but who knows...
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: John Kacur <jkacur@redhat.com>
    Cc: Sage Weil <sage@newdream.net>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-fsdevel@vger.kernel.org

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4e273f7793f6..50208c15309a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -562,8 +562,8 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 
 static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 {
-	/* note that this is called by vfs setlease with the BKL held
-	   although I doubt that BKL is needed here in cifs */
+	/* note that this is called by vfs setlease with lock_flocks held
+	   to protect *lease from going away */
 	struct inode *inode = file->f_path.dentry->d_inode;
 
 	if (!(S_ISREG(inode->i_mode)))

commit b0991aa324b57dca8feef75ed75b24080ee4a9fc
Author: Jan Blunck <jblunck@infradead.org>
Date:   Wed Feb 24 13:25:29 2010 +0100

    BKL: Remove BKL from CifsFS
    
    The BKL is only used in put_super and fill_super that are both protected by
    the superblocks s_umount rw_semaphore. Therefore it is safe to remove the
    BKL entirely.
    
    Signed-off-by: Jan Blunck <jblunck@infradead.org>
    Cc: Steve French <smfrench@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 070bf1aecd2d..4e273f7793f6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -35,7 +35,6 @@
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/freezer.h>
-#include <linux/smp_lock.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE
@@ -200,8 +199,6 @@ cifs_put_super(struct super_block *sb)
 		return;
 	}
 
-	lock_kernel();
-
 	rc = cifs_umount(sb, cifs_sb);
 	if (rc)
 		cERROR(1, "cifs_umount failed with return code %d", rc);
@@ -215,8 +212,6 @@ cifs_put_super(struct super_block *sb)
 	unload_nls(cifs_sb->local_nls);
 	bdi_destroy(&cifs_sb->bdi);
 	kfree(cifs_sb);
-
-	unlock_kernel();
 }
 
 static int
@@ -516,28 +511,22 @@ cifs_get_sb(struct file_system_type *fs_type,
 	int rc;
 	struct super_block *sb;
 
-	lock_kernel();
-
 	sb = sget(fs_type, NULL, set_anon_super, NULL);
 
 	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
 
-	if (IS_ERR(sb)) {
-		unlock_kernel();
+	if (IS_ERR(sb))
 		return PTR_ERR(sb);
-	}
 
 	sb->s_flags = flags;
 
 	rc = cifs_read_super(sb, data, dev_name, flags & MS_SILENT ? 1 : 0);
 	if (rc) {
 		deactivate_locked_super(sb);
-		unlock_kernel();
 		return rc;
 	}
 	sb->s_flags |= MS_ACTIVE;
 	simple_set_mnt(mnt, sb);
-	unlock_kernel();
 	return 0;
 }
 

commit db71922217a214e5c9268448e537b54fc1f301ea
Author: Jan Blunck <jblunck@infradead.org>
Date:   Sun Aug 15 22:51:10 2010 +0200

    BKL: Explicitly add BKL around get_sb/fill_super
    
    This patch is a preparation necessary to remove the BKL from do_new_mount().
    It explicitly adds calls to lock_kernel()/unlock_kernel() around
    get_sb/fill_super operations for filesystems that still uses the BKL.
    
    I've read through all the code formerly covered by the BKL inside
    do_kern_mount() and have satisfied myself that it doesn't need the BKL
    any more.
    
    do_kern_mount() is already called without the BKL when mounting the rootfs
    and in nfsctl. do_kern_mount() calls vfs_kern_mount(), which is called
    from various places without BKL: simple_pin_fs(), nfs_do_clone_mount()
    through nfs_follow_mountpoint(), afs_mntpt_do_automount() through
    afs_mntpt_follow_link(). Both later functions are actually the filesystems
    follow_link inode operation. vfs_kern_mount() is calling the specified
    get_sb function and lets the filesystem do its job by calling the given
    fill_super function.
    
    Therefore I think it is safe to push down the BKL from the VFS to the
    low-level filesystems get_sb/fill_super operation.
    
    [arnd: do not add the BKL to those file systems that already
           don't use it elsewhere]
    
    Signed-off-by: Jan Blunck <jblunck@infradead.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b7431afdd76d..070bf1aecd2d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -514,22 +514,30 @@ cifs_get_sb(struct file_system_type *fs_type,
 	    int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
 	int rc;
-	struct super_block *sb = sget(fs_type, NULL, set_anon_super, NULL);
+	struct super_block *sb;
+
+	lock_kernel();
+
+	sb = sget(fs_type, NULL, set_anon_super, NULL);
 
 	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
 
-	if (IS_ERR(sb))
+	if (IS_ERR(sb)) {
+		unlock_kernel();
 		return PTR_ERR(sb);
+	}
 
 	sb->s_flags = flags;
 
 	rc = cifs_read_super(sb, data, dev_name, flags & MS_SILENT ? 1 : 0);
 	if (rc) {
 		deactivate_locked_super(sb);
+		unlock_kernel();
 		return rc;
 	}
 	sb->s_flags |= MS_ACTIVE;
 	simple_set_mnt(mnt, sb);
+	unlock_kernel();
 	return 0;
 }
 

commit 0d424ad0a4b8c08e45928bccfa5b4b240097b01b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 20 16:01:35 2010 -0700

    cifs: add cifs_sb_master_tcon and convert some callers to use it
    
    At mount time, we'll always need to create a tcon that will serve as a
    template for others that are associated with the mount. This tcon is
    known as the "master" tcon.
    
    In some cases, we'll need to use that tcon regardless of who's accessing
    the mount. Add an accessor function for the master tcon and go ahead and
    switch the appropriate places to use it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b9624abb7261..898d2a5cfad2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -222,7 +222,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct super_block *sb = dentry->d_sb;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	struct cifsTconInfo *tcon = cifs_sb_tcon(cifs_sb);
+	struct cifsTconInfo *tcon = cifs_sb_master_tcon(cifs_sb);
 	int rc = -EOPNOTSUPP;
 	int xid;
 
@@ -364,7 +364,7 @@ static int
 cifs_show_options(struct seq_file *s, struct vfsmount *m)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(m->mnt_sb);
-	struct cifsTconInfo *tcon = cifs_sb_tcon(cifs_sb);
+	struct cifsTconInfo *tcon = cifs_sb_master_tcon(cifs_sb);
 	struct sockaddr *srcaddr;
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
@@ -455,7 +455,7 @@ static void cifs_umount_begin(struct super_block *sb)
 	if (cifs_sb == NULL)
 		return;
 
-	tcon = cifs_sb_tcon(cifs_sb);
+	tcon = cifs_sb_master_tcon(cifs_sb);
 
 	read_lock(&cifs_tcp_ses_lock);
 	if ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {

commit a6e8a8455c94565c53e1a1756d2ab9d9e3a902b8
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 20 16:01:33 2010 -0700

    cifs: add function to get a tcon from cifs_sb
    
    When we convert cifs to do multiple sessions per mount, we'll need more
    than one tcon per superblock. At that point "cifs_sb->tcon" will make
    no sense. Add a new accessor function that gets a tcon given a cifs_sb.
    For now, it just returns cifs_sb->tcon. Later it'll do more.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7193494efc03..b9624abb7261 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -137,9 +137,6 @@ cifs_read_super(struct super_block *sb, void *data,
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
 	sb->s_bdi = &cifs_sb->bdi;
-/*	if (cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
-	    sb->s_blocksize =
-		cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
 	sb->s_blocksize = CIFS_MAX_MSGSIZE;
 	sb->s_blocksize_bits = 14;	/* default 2**14 = CIFS_MAX_MSGSIZE */
 	inode = cifs_root_iget(sb, ROOT_I);
@@ -225,7 +222,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct super_block *sb = dentry->d_sb;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	struct cifsTconInfo *tcon = cifs_sb->tcon;
+	struct cifsTconInfo *tcon = cifs_sb_tcon(cifs_sb);
 	int rc = -EOPNOTSUPP;
 	int xid;
 
@@ -367,7 +364,7 @@ static int
 cifs_show_options(struct seq_file *s, struct vfsmount *m)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(m->mnt_sb);
-	struct cifsTconInfo *tcon = cifs_sb->tcon;
+	struct cifsTconInfo *tcon = cifs_sb_tcon(cifs_sb);
 	struct sockaddr *srcaddr;
 	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
@@ -458,9 +455,7 @@ static void cifs_umount_begin(struct super_block *sb)
 	if (cifs_sb == NULL)
 		return;
 
-	tcon = cifs_sb->tcon;
-	if (tcon == NULL)
-		return;
+	tcon = cifs_sb_tcon(cifs_sb);
 
 	read_lock(&cifs_tcp_ses_lock);
 	if ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {

commit ba00ba64cf0895e4c2ac507e56306363dc125a90
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 20 16:01:31 2010 -0700

    cifs: make various routines use the cifsFileInfo->tcon pointer
    
    ...where it's available and appropriate.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index eeb8c67a3f29..7193494efc03 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -589,6 +589,7 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 	/* note that this is called by vfs setlease with the BKL held
 	   although I doubt that BKL is needed here in cifs */
 	struct inode *inode = file->f_path.dentry->d_inode;
+	struct cifsFileInfo *cfile = file->private_data;
 
 	if (!(S_ISREG(inode->i_mode)))
 		return -EINVAL;
@@ -599,8 +600,7 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 	    ((arg == F_WRLCK) &&
 		(CIFS_I(inode)->clientCanCacheAll)))
 		return generic_setlease(file, arg, lease);
-	else if (CIFS_SB(inode->i_sb)->tcon->local_lease &&
-			!CIFS_I(inode)->clientCanCacheRead)
+	else if (cfile->tcon->local_lease && !CIFS_I(inode)->clientCanCacheRead)
 		/* If the server claims to support oplock on this
 		   file, then we still need to check oplock even
 		   if the local_lease mount option is set, but there

commit d3bf5221d3274b5015ad18a55060b074cca8d2f0
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Sep 22 19:15:36 2010 +0000

    [CIFS] Fix ordering of cleanup on module init failure
    
    If registering fs cache failed, we weren't cleaning up proc.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    CC: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 52e89ea07458..eeb8c67a3f29 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -933,11 +933,11 @@ init_cifs(void)
 
 	rc = cifs_fscache_register();
 	if (rc)
-		goto out;
+		goto out_clean_proc;
 
 	rc = cifs_init_inodecache();
 	if (rc)
-		goto out_clean_proc;
+		goto out_unreg_fscache;
 
 	rc = cifs_init_mids();
 	if (rc)
@@ -959,19 +959,19 @@ init_cifs(void)
 	return 0;
 
 #ifdef CONFIG_CIFS_UPCALL
- out_unregister_filesystem:
+out_unregister_filesystem:
 	unregister_filesystem(&cifs_fs_type);
 #endif
- out_destroy_request_bufs:
+out_destroy_request_bufs:
 	cifs_destroy_request_bufs();
- out_destroy_mids:
+out_destroy_mids:
 	cifs_destroy_mids();
- out_destroy_inodecache:
+out_destroy_inodecache:
 	cifs_destroy_inodecache();
- out_clean_proc:
-	cifs_proc_clean();
+out_unreg_fscache:
 	cifs_fscache_unregister();
- out:
+out_clean_proc:
+	cifs_proc_clean();
 	return rc;
 }
 

commit 736a33205969c16f81d747db14ff4c0f133609a6
Author: Stefan Metzmacher <metze@samba.org>
Date:   Fri Jul 30 14:56:00 2010 +0200

    cifs: add "mfsymlinks" mount option
    
    This is the start for an implementation of "Minshall+French Symlinks"
    (see http://wiki.samba.org/index.php/UNIX_Extensions#Minshall.2BFrench_symlinks).
    
    Signed-off-by: Stefan Metzmacher <metze@samba.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1b6ddd6f760f..52e89ea07458 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -441,6 +441,8 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		seq_printf(s, ",dynperm");
 	if (m->mnt_sb->s_flags & MS_POSIXACL)
 		seq_printf(s, ",acl");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)
+		seq_printf(s, ",mfsymlinks");
 
 	seq_printf(s, ",rsize=%d", cifs_sb->rsize);
 	seq_printf(s, ",wsize=%d", cifs_sb->wsize);

commit 3eb9a8893a76cf1cda3b41c3212eb2cfe83eae0e
Author: Ben Greear <greearb@candelatech.com>
Date:   Wed Sep 1 17:06:02 2010 -0700

    cifs: Allow binding to local IP address.
    
    When using multi-homed machines, it's nice to be able to specify
    the local IP to use for outbound connections.  This patch gives
    cifs the ability to bind to a particular IP address.
    
       Usage:  mount -t cifs -o srcaddr=192.168.1.50,user=foo, ...
       Usage:  mount -t cifs -o srcaddr=2002::100:1,user=foo, ...
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Dr. David Holder <david.holder@erion.co.uk>
    Signed-off-by: Ben Greear <greearb@candelatech.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b7431afdd76d..1b6ddd6f760f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -36,6 +36,7 @@
 #include <linux/kthread.h>
 #include <linux/freezer.h>
 #include <linux/smp_lock.h>
+#include <net/ipv6.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE
@@ -367,6 +368,8 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(m->mnt_sb);
 	struct cifsTconInfo *tcon = cifs_sb->tcon;
+	struct sockaddr *srcaddr;
+	srcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;
 
 	seq_printf(s, ",unc=%s", tcon->treeName);
 	if (tcon->ses->userName)
@@ -374,6 +377,22 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	if (tcon->ses->domainName)
 		seq_printf(s, ",domain=%s", tcon->ses->domainName);
 
+	if (srcaddr->sa_family != AF_UNSPEC) {
+		struct sockaddr_in *saddr4;
+		struct sockaddr_in6 *saddr6;
+		saddr4 = (struct sockaddr_in *)srcaddr;
+		saddr6 = (struct sockaddr_in6 *)srcaddr;
+		if (srcaddr->sa_family == AF_INET6)
+			seq_printf(s, ",srcaddr=%pI6c",
+				   &saddr6->sin6_addr);
+		else if (srcaddr->sa_family == AF_INET)
+			seq_printf(s, ",srcaddr=%pI4",
+				   &saddr4->sin_addr.s_addr);
+		else
+			seq_printf(s, ",srcaddr=BAD-AF:%i",
+				   (int)(srcaddr->sa_family));
+	}
+
 	seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)
 		seq_printf(s, ",forceuid");

commit 5f248c9c251c60af3403902b26e08de43964ea0b
Merge: f6cec0ae58c1 dca332528bc6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 10 11:26:52 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6: (96 commits)
      no need for list_for_each_entry_safe()/resetting with superblock list
      Fix sget() race with failing mount
      vfs: don't hold s_umount over close_bdev_exclusive() call
      sysv: do not mark superblock dirty on remount
      sysv: do not mark superblock dirty on mount
      btrfs: remove junk sb_dirt change
      BFS: clean up the superblock usage
      AFFS: wait for sb synchronization when needed
      AFFS: clean up dirty flag usage
      cifs: truncate fallout
      mbcache: fix shrinker function return value
      mbcache: Remove unused features
      add f_flags to struct statfs(64)
      pass a struct path to vfs_statfs
      update VFS documentation for method changes.
      All filesystems that need invalidate_inode_buffers() are doing that explicitly
      convert remaining ->clear_inode() to ->evict_inode()
      Make ->drop_inode() just return whether inode needs to be dropped
      fs/inode.c:clear_inode() is gone
      fs/inode.c:evict() doesn't care about delete vs. non-delete paths now
      ...
    
    Fix up trivial conflicts in fs/nilfs2/super.c

commit b57922d97fd6f79b6dbe6db0c4fd30d219fa08c1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 14:34:48 2010 -0400

    convert remaining ->clear_inode() to ->evict_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 20914f5627dd..5574a42b7bb6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -330,8 +330,10 @@ cifs_destroy_inode(struct inode *inode)
 }
 
 static void
-cifs_clear_inode(struct inode *inode)
+cifs_evict_inode(struct inode *inode)
 {
+	truncate_inode_pages(&inode->i_data, 0);
+	end_writeback(inode);
 	cifs_fscache_release_inode_cookie(inode);
 }
 
@@ -495,7 +497,7 @@ static const struct super_operations cifs_super_ops = {
 	.alloc_inode = cifs_alloc_inode,
 	.destroy_inode = cifs_destroy_inode,
 	.drop_inode	= cifs_drop_inode,
-	.clear_inode	= cifs_clear_inode,
+	.evict_inode	= cifs_evict_inode,
 /*	.delete_inode	= cifs_delete_inode,  */  /* Do not need above
 	function unless later we add lazy close of inodes or unless the
 	kernel forgets to call us with the same number of releases (closes)

commit 45321ac54316eaeeebde0b5f728a1791e500974c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 13:43:19 2010 -0400

    Make ->drop_inode() just return whether inode needs to be dropped
    
    ... and let iput_final() do the actual eviction or retention
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8a2cf129e535..20914f5627dd 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -480,14 +480,13 @@ static int cifs_remount(struct super_block *sb, int *flags, char *data)
 	return 0;
 }
 
-void cifs_drop_inode(struct inode *inode)
+static int cifs_drop_inode(struct inode *inode)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 
-	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
-		return generic_drop_inode(inode);
-
-	return generic_delete_inode(inode);
+	/* no serverino => unconditional eviction */
+	return !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) ||
+		generic_drop_inode(inode);
 }
 
 static const struct super_operations cifs_super_ops = {

commit 1fc7995d19139d6f99203b43c161968f3f554a15
Merge: 3b7433b8a8a8 5227bbb008fa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 12:54:46 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6:
      [DNS RESOLVER] Minor typo correction
      DNS: Fixes for the DNS query module
      cifs: Include linux/err.h for IS_ERR and PTR_ERR
      DNS: Make AFS go to the DNS for AFSDB records for unknown cells
      DNS: Separate out CIFS DNS Resolver code
      cifs: account for new creduid=0x%x parameter in spnego upcall string
      cifs: reduce false positives with inode aliasing serverino autodisable
      CIFS: Make cifs_convert_address() take a const src pointer and a length
      cifs: show features compiled in as part of DebugData
      cifs: update README
    
    Fix up trivial conflicts in fs/cifs/cifsfs.c due to workqueue changes

commit 3b7433b8a8a83c87972065b1852b7dcae691e464
Merge: 4a386c3e177c 6ee0578b4daa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 12:42:58 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq: (55 commits)
      workqueue: mark init_workqueues() as early_initcall()
      workqueue: explain for_each_*cwq_cpu() iterators
      fscache: fix build on !CONFIG_SYSCTL
      slow-work: kill it
      gfs2: use workqueue instead of slow-work
      drm: use workqueue instead of slow-work
      cifs: use workqueue instead of slow-work
      fscache: drop references to slow-work
      fscache: convert operation to use workqueue instead of slow-work
      fscache: convert object to use workqueue instead of slow-work
      workqueue: fix how cpu number is stored in work->data
      workqueue: fix mayday_mask handling on UP
      workqueue: fix build problem on !CONFIG_SMP
      workqueue: fix locking in retry path of maybe_create_worker()
      async: use workqueue for worker pool
      workqueue: remove WQ_SINGLE_CPU and use WQ_UNBOUND instead
      workqueue: implement unbound workqueue
      workqueue: prepare for WQ_UNBOUND implementation
      libata: take advantage of cmwq and remove concurrency limitations
      workqueue: fix worker management invocation without pending works
      ...
    
    Fixed up conflicts in fs/cifs/* as per Tejun. Other trivial conflicts in
    include/linux/workqueue.h, kernel/trace/Kconfig and kernel/workqueue.c

commit 1a4240f4764ac78adbf4b0ebb49b3bd8c72ffa11
Author: Wang Lei <wang840925@gmail.com>
Date:   Wed Aug 4 15:16:33 2010 +0100

    DNS: Separate out CIFS DNS Resolver code
    
    Separate out the DNS resolver key type from the CIFS filesystem into its own
    module so that it can be made available for general use, including the AFS
    filesystem module.
    
    This facility makes it possible for the kernel to upcall to userspace to have
    it issue DNS requests, package up the replies and present them to the kernel
    in a useful form.  The kernel is then able to cache the DNS replies as keys
    can be retained in keyrings.
    
    Resolver keys are of type "dns_resolver" and have a case-insensitive
    description that is of the form "[<type>:]<domain_name>".  The optional <type>
    indicates the particular DNS lookup and packaging that's required.  The
    <domain_name> is the query to be made.
    
    If <type> isn't given, a basic hostname to IP address lookup is made, and the
    result is stored in the key in the form of a printable string consisting of a
    comma-separated list of IPv4 and IPv6 addresses.
    
    This key type is supported by userspace helpers driven from /sbin/request-key
    and configured through /etc/request-key.conf.  The cifs.upcall utility is
    invoked for UNC path server name to IP address resolution.
    
    The CIFS functionality is encapsulated by the dns_resolve_unc_to_ip() function,
    which is used to resolve a UNC path to an IP address for CIFS filesystem.  This
    part remains in the CIFS module for now.
    
    See the added Documentation/networking/dns_resolver.txt for more information.
    
    Signed-off-by: Wang Lei <wang840925@gmail.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8a2cf129e535..2a0c892959f4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -45,7 +45,6 @@
 #include "cifs_fs_sb.h"
 #include <linux/mm.h>
 #include <linux/key-type.h>
-#include "dns_resolve.h"
 #include "cifs_spnego.h"
 #include "fscache.h"
 #define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
@@ -933,23 +932,14 @@ init_cifs(void)
 	rc = register_key_type(&cifs_spnego_key_type);
 	if (rc)
 		goto out_unregister_filesystem;
-#endif
-#ifdef CONFIG_CIFS_DFS_UPCALL
-	rc = cifs_init_dns_resolver();
-	if (rc)
-		goto out_unregister_key_type;
 #endif
 	rc = slow_work_register_user(THIS_MODULE);
 	if (rc)
-		goto out_unregister_resolver_key;
+		goto out_unregister_key_type;
 
 	return 0;
 
- out_unregister_resolver_key:
-#ifdef CONFIG_CIFS_DFS_UPCALL
-	cifs_exit_dns_resolver();
  out_unregister_key_type:
-#endif
 #ifdef CONFIG_CIFS_UPCALL
 	unregister_key_type(&cifs_spnego_key_type);
  out_unregister_filesystem:
@@ -976,7 +966,6 @@ exit_cifs(void)
 	cifs_fscache_unregister();
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	cifs_dfs_release_automount_timer();
-	cifs_exit_dns_resolver();
 #endif
 #ifdef CONFIG_CIFS_UPCALL
 	unregister_key_type(&cifs_spnego_key_type);

commit 9451a9a52f91a4c171cfaca2f6d7a2ce91867b8d
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Mon Jul 5 18:12:45 2010 +0530

    cifs: define inode-level cache object and register them
    
    Define inode-level data storage objects (managed by cifsInodeInfo structs).
    Each inode-level object is created in a super-block level object and is itself
    a data storage object in to which pages from the inode are stored.
    
    The inode object is keyed by UniqueId. The coherency data being used is
    LastWriteTime, LastChangeTime and end of file reported by the server.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 24d7f4ab3b65..8a2cf129e535 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -329,6 +329,12 @@ cifs_destroy_inode(struct inode *inode)
 	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
 }
 
+static void
+cifs_clear_inode(struct inode *inode)
+{
+	cifs_fscache_release_inode_cookie(inode);
+}
+
 static void
 cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 {
@@ -490,6 +496,7 @@ static const struct super_operations cifs_super_ops = {
 	.alloc_inode = cifs_alloc_inode,
 	.destroy_inode = cifs_destroy_inode,
 	.drop_inode	= cifs_drop_inode,
+	.clear_inode	= cifs_clear_inode,
 /*	.delete_inode	= cifs_delete_inode,  */  /* Do not need above
 	function unless later we add lazy close of inodes or unless the
 	kernel forgets to call us with the same number of releases (closes)

commit f579cf3cfd1e19ae5aab6929679d0c04bf1a6284
Author: Suresh Jayaraman <sjayaraman@suse.de>
Date:   Mon Jul 5 18:11:50 2010 +0530

    cifs: register CIFS for caching
    
    Define CIFS for FS-Cache and register for caching. Upon registration the
    top-level index object cookie will be stuck to the netfs definition by
    FS-Cache.
    
    Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2cb1a70214d7..24d7f4ab3b65 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -47,6 +47,7 @@
 #include <linux/key-type.h>
 #include "dns_resolve.h"
 #include "cifs_spnego.h"
+#include "fscache.h"
 #define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
 
 int cifsFYI = 0;
@@ -902,6 +903,10 @@ init_cifs(void)
 		cFYI(1, "cifs_max_pending set to max of 256");
 	}
 
+	rc = cifs_fscache_register();
+	if (rc)
+		goto out;
+
 	rc = cifs_init_inodecache();
 	if (rc)
 		goto out_clean_proc;
@@ -951,6 +956,8 @@ init_cifs(void)
 	cifs_destroy_inodecache();
  out_clean_proc:
 	cifs_proc_clean();
+	cifs_fscache_unregister();
+ out:
 	return rc;
 }
 
@@ -959,6 +966,7 @@ exit_cifs(void)
 {
 	cFYI(DBG2, "exit_cifs");
 	cifs_proc_clean();
+	cifs_fscache_unregister();
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	cifs_dfs_release_automount_timer();
 	cifs_exit_dns_resolver();

commit 9b646972467fb5fdc677f9e4251875db20bdbb64
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 20 22:09:02 2010 +0200

    cifs: use workqueue instead of slow-work
    
    Workqueue can now handle high concurrency.  Use system_nrt_wq
    instead of slow-work.
    
    * Updated is_valid_oplock_break() to not call cifs_oplock_break_put()
      as advised by Steve French.  It might cause deadlock.  Instead,
      reference is increased after queueing succeeded and
      cifs_oplock_break() briefly grabs GlobalSMBSeslock before putting
      the cfile to make sure it doesn't put before the matching get is
      finished.
    
    * Anton Blanchard reported that cifs conversion was using now gone
      system_single_wq.  Use system_nrt_wq which provides non-reentrance
      guarantee which is enough and much better.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Steve French <sfrench@samba.org>
    Cc: Anton Blanchard <anton@samba.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 78c02eb4cb1f..4c075177c8b6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -917,15 +917,10 @@ init_cifs(void)
 	if (rc)
 		goto out_unregister_key_type;
 #endif
-	rc = slow_work_register_user(THIS_MODULE);
-	if (rc)
-		goto out_unregister_resolver_key;
 
 	return 0;
 
- out_unregister_resolver_key:
 #ifdef CONFIG_CIFS_DFS_UPCALL
-	unregister_key_type(&key_type_dns_resolver);
  out_unregister_key_type:
 #endif
 #ifdef CONFIG_CIFS_UPCALL

commit 4c0c03ca54f72fdd5912516ad0a23ec5cf01bda7
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jul 22 12:53:18 2010 +0100

    CIFS: Fix a malicious redirect problem in the DNS lookup code
    
    Fix the security problem in the CIFS filesystem DNS lookup code in which a
    malicious redirect could be installed by a random user by simply adding a
    result record into one of their keyrings with add_key() and then invoking a
    CIFS CFS lookup [CVE-2010-2524].
    
    This is done by creating an internal keyring specifically for the caching of
    DNS lookups.  To enforce the use of this keyring, the module init routine
    creates a set of override credentials with the keyring installed as the thread
    keyring and instructs request_key() to only install lookup result keys in that
    keyring.
    
    The override is then applied around the call to request_key().
    
    This has some additional benefits when a kernel service uses this module to
    request a key:
    
     (1) The result keys are owned by root, not the user that caused the lookup.
    
     (2) The result keys don't pop up in the user's keyrings.
    
     (3) The result keys don't come out of the quota of the user that caused the
         lookup.
    
    The keyring can be viewed as root by doing cat /proc/keys:
    
    2a0ca6c3 I-----     1 perm 1f030000     0     0 keyring   .dns_resolver: 1/4
    
    It can then be listed with 'keyctl list' by root.
    
            # keyctl list 0x2a0ca6c3
            1 key in keyring:
            726766307: --alswrv     0     0 dns_resolver: foo.bar.com
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-and-Tested-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Steve French <smfrench@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 484e52bb40bb..2cb1a70214d7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -923,7 +923,7 @@ init_cifs(void)
 		goto out_unregister_filesystem;
 #endif
 #ifdef CONFIG_CIFS_DFS_UPCALL
-	rc = register_key_type(&key_type_dns_resolver);
+	rc = cifs_init_dns_resolver();
 	if (rc)
 		goto out_unregister_key_type;
 #endif
@@ -935,7 +935,7 @@ init_cifs(void)
 
  out_unregister_resolver_key:
 #ifdef CONFIG_CIFS_DFS_UPCALL
-	unregister_key_type(&key_type_dns_resolver);
+	cifs_exit_dns_resolver();
  out_unregister_key_type:
 #endif
 #ifdef CONFIG_CIFS_UPCALL
@@ -961,7 +961,7 @@ exit_cifs(void)
 	cifs_proc_clean();
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	cifs_dfs_release_automount_timer();
-	unregister_key_type(&key_type_dns_resolver);
+	cifs_exit_dns_resolver();
 #endif
 #ifdef CONFIG_CIFS_UPCALL
 	unregister_key_type(&cifs_spnego_key_type);

commit 12420ac341533f3715b3deb788637568f22b78ff
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jun 1 14:47:40 2010 -0400

    cifs: implement drop_inode superblock op
    
    The standard behavior for drop_inode is to delete the inode when the
    last reference to it is put and the nlink count goes to 0. This helps
    keep inodes that are still considered "not deleted" in cache as long as
    possible even when there aren't dentries attached to them.
    
    When server inode numbers are disabled, it's not possible for cifs_iget
    to ever match an existing inode (since inode numbers are generated via
    iunique). In this situation, cifs can keep a lot of inodes in cache that
    will never be used again.
    
    Implement a drop_inode routine that deletes the inode if server inode
    numbers are disabled on the mount. This helps keep the cifs inode
    caches down to a more manageable size when server inode numbers are
    disabled.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 78c02eb4cb1f..484e52bb40bb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -473,14 +473,24 @@ static int cifs_remount(struct super_block *sb, int *flags, char *data)
 	return 0;
 }
 
+void cifs_drop_inode(struct inode *inode)
+{
+	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
+
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
+		return generic_drop_inode(inode);
+
+	return generic_delete_inode(inode);
+}
+
 static const struct super_operations cifs_super_ops = {
 	.put_super = cifs_put_super,
 	.statfs = cifs_statfs,
 	.alloc_inode = cifs_alloc_inode,
 	.destroy_inode = cifs_destroy_inode,
-/*	.drop_inode	    = generic_delete_inode,
-	.delete_inode	= cifs_delete_inode,  */  /* Do not need above two
-	functions unless later we add lazy close of inodes or unless the
+	.drop_inode	= cifs_drop_inode,
+/*	.delete_inode	= cifs_delete_inode,  */  /* Do not need above
+	function unless later we add lazy close of inodes or unless the
 	kernel forgets to call us with the same number of releases (closes)
 	as opens */
 	.show_options = cifs_show_options,

commit baa456331738b4e76a92318b62b354377a30ad80
Merge: aa3e5572c538 4462dc028426
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu May 13 22:19:32 2010 +0000

    Merge branch 'master' of /pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
            fs/cifs/inode.c

commit aa3e5572c538d753dce11bf93532a75f95d22b40
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed May 12 02:24:12 2010 +0000

    [CIFS] drop quota operation stubs
    
    CIFS has stubs for XFS-style quotas without an actual implementation backing
    them, hidden behind a config option not visible in Kconfig.  Remove these
    stubs for now as the quota operations will see some major changes and this
    code simply gets in the way.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 09842d3f7e1d..833166372a08 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -49,10 +49,6 @@
 #include "cifs_spnego.h"
 #define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
 
-#ifdef CONFIG_CIFS_QUOTA
-static const struct quotactl_ops cifs_quotactl_ops;
-#endif /* QUOTA */
-
 int cifsFYI = 0;
 int cifsERROR = 1;
 int traceSMB = 0;
@@ -135,9 +131,6 @@ cifs_read_super(struct super_block *sb, void *data,
 /*	if (cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
 	    sb->s_blocksize =
 		cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
-#ifdef CONFIG_CIFS_QUOTA
-	sb->s_qcop = &cifs_quotactl_ops;
-#endif
 	sb->s_blocksize = CIFS_MAX_MSGSIZE;
 	sb->s_blocksize_bits = 14;	/* default 2**14 = CIFS_MAX_MSGSIZE */
 	inode = cifs_root_iget(sb, ROOT_I);
@@ -418,106 +411,6 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	return 0;
 }
 
-#ifdef CONFIG_CIFS_QUOTA
-int cifs_xquota_set(struct super_block *sb, int quota_type, qid_t qid,
-		struct fs_disk_quota *pdquota)
-{
-	int xid;
-	int rc = 0;
-	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	struct cifsTconInfo *pTcon;
-
-	if (cifs_sb)
-		pTcon = cifs_sb->tcon;
-	else
-		return -EIO;
-
-
-	xid = GetXid();
-	if (pTcon) {
-		cFYI(1, "set type: 0x%x id: %d", quota_type, qid);
-	} else
-		rc = -EIO;
-
-	FreeXid(xid);
-	return rc;
-}
-
-int cifs_xquota_get(struct super_block *sb, int quota_type, qid_t qid,
-		    struct fs_disk_quota *pdquota)
-{
-	int xid;
-	int rc = 0;
-	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	struct cifsTconInfo *pTcon;
-
-	if (cifs_sb)
-		pTcon = cifs_sb->tcon;
-	else
-		return -EIO;
-
-	xid = GetXid();
-	if (pTcon) {
-		cFYI(1, "set type: 0x%x id: %d", quota_type, qid);
-	} else
-		rc = -EIO;
-
-	FreeXid(xid);
-	return rc;
-}
-
-int cifs_xstate_set(struct super_block *sb, unsigned int flags, int operation)
-{
-	int xid;
-	int rc = 0;
-	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	struct cifsTconInfo *pTcon;
-
-	if (cifs_sb)
-		pTcon = cifs_sb->tcon;
-	else
-		return -EIO;
-
-	xid = GetXid();
-	if (pTcon) {
-		cFYI(1, "flags: 0x%x operation: 0x%x", flags, operation);
-	} else
-		rc = -EIO;
-
-	FreeXid(xid);
-	return rc;
-}
-
-int cifs_xstate_get(struct super_block *sb, struct fs_quota_stat *qstats)
-{
-	int xid;
-	int rc = 0;
-	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
-	struct cifsTconInfo *pTcon;
-
-	if (cifs_sb)
-		pTcon = cifs_sb->tcon;
-	else
-		return -EIO;
-
-	xid = GetXid();
-	if (pTcon) {
-		cFYI(1, "pqstats %p", qstats);
-	} else
-		rc = -EIO;
-
-	FreeXid(xid);
-	return rc;
-}
-
-static const struct quotactl_ops cifs_quotactl_ops = {
-	.set_xquota	= cifs_xquota_set,
-	.get_xquota	= cifs_xquota_get,
-	.set_xstate	= cifs_xstate_set,
-	.get_xstate	= cifs_xstate_get,
-};
-#endif
-
 static void cifs_umount_begin(struct super_block *sb)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);

commit bdfae149c5b7430b9a26371f14b2d385fd3a4389
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu May 6 00:38:16 2010 +0000

    [CIFS] Remove unused cifs_oplock_cachep
    
    CC: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 80a93562b47a..09842d3f7e1d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -86,8 +86,6 @@ extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
-extern struct kmem_cache *cifs_oplock_cachep;
-
 static int
 cifs_read_super(struct super_block *sb, void *data,
 		const char *devname, int silent)
@@ -289,7 +287,6 @@ static int cifs_permission(struct inode *inode, int mask)
 static struct kmem_cache *cifs_inode_cachep;
 static struct kmem_cache *cifs_req_cachep;
 static struct kmem_cache *cifs_mid_cachep;
-struct kmem_cache *cifs_oplock_cachep;
 static struct kmem_cache *cifs_sm_req_cachep;
 mempool_t *cifs_sm_req_poolp;
 mempool_t *cifs_req_poolp;
@@ -939,15 +936,6 @@ cifs_init_mids(void)
 		return -ENOMEM;
 	}
 
-	cifs_oplock_cachep = kmem_cache_create("cifs_oplock_structs",
-					sizeof(struct oplock_q_entry), 0,
-					SLAB_HWCACHE_ALIGN, NULL);
-	if (cifs_oplock_cachep == NULL) {
-		mempool_destroy(cifs_mid_poolp);
-		kmem_cache_destroy(cifs_mid_cachep);
-		return -ENOMEM;
-	}
-
 	return 0;
 }
 
@@ -956,7 +944,6 @@ cifs_destroy_mids(void)
 {
 	mempool_destroy(cifs_mid_poolp);
 	kmem_cache_destroy(cifs_mid_cachep);
-	kmem_cache_destroy(cifs_oplock_cachep);
 }
 
 static int __init

commit d54ff73259a852d4b3886dc586587fdef5e9c8de
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Apr 27 04:38:15 2010 +0000

    [CIFS] Fix lease break for writes
    
    On lease break we were breaking to readonly leases always
    even if write requested.  Also removed experimental
    ifdef around setlease code
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 440e98ca01e3..80a93562b47a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -645,7 +645,6 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 	return generic_file_llseek_unlocked(file, offset, origin);
 }
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 {
 	/* note that this is called by vfs setlease with the BKL held
@@ -674,7 +673,6 @@ static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 	else
 		return -EAGAIN;
 }
-#endif
 
 struct file_system_type cifs_fs_type = {
 	.owner = THIS_MODULE,
@@ -751,10 +749,7 @@ const struct file_operations cifs_file_ops = {
 #ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
-
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.setlease = cifs_setlease,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
 const struct file_operations cifs_file_direct_ops = {
@@ -773,9 +768,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.unlocked_ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.setlease = cifs_setlease,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 const struct file_operations cifs_file_nobrl_ops = {
 	.read = do_sync_read,
@@ -792,10 +785,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 #ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
-
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.setlease = cifs_setlease,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
 const struct file_operations cifs_file_direct_nobrl_ops = {
@@ -813,9 +803,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.unlocked_ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.setlease = cifs_setlease,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
 const struct file_operations cifs_dir_ops = {

commit 04912d6a20185473db025061b9b2c81fbdffc48b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Apr 24 07:57:45 2010 -0400

    cifs: rename "extended_security" to "global_secflags"
    
    ...since that more accurately describes what that variable holds.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 53e794131c2a..440e98ca01e3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -61,7 +61,7 @@ unsigned int experimEnabled = 0;
 unsigned int linuxExtEnabled = 1;
 unsigned int lookupCacheEnabled = 1;
 unsigned int multiuser_mount = 0;
-unsigned int extended_security = CIFSSEC_DEF;
+unsigned int global_secflags = CIFSSEC_DEF;
 /* unsigned int ntlmv2_support = 0; */
 unsigned int sign_CIFS_PDUs = 1;
 static const struct super_operations cifs_super_ops;

commit 8044f7f468469c80031611206d554f86fcdfe704
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Thu Apr 22 12:09:48 2010 +0200

    cifs: add bdi backing to mount session
    
    This ensures that dirty data gets flushed properly.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ded66be6597c..ad235d604a0b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -103,6 +103,12 @@ cifs_read_super(struct super_block *sb, void *data,
 	if (cifs_sb == NULL)
 		return -ENOMEM;
 
+	rc = bdi_setup_and_register(&cifs_sb->bdi, "cifs", BDI_CAP_MAP_COPY);
+	if (rc) {
+		kfree(cifs_sb);
+		return rc;
+	}
+
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	/* copy mount params to sb for use in submounts */
 	/* BB: should we move this after the mount so we
@@ -115,6 +121,7 @@ cifs_read_super(struct super_block *sb, void *data,
 		int len = strlen(data);
 		cifs_sb->mountdata = kzalloc(len + 1, GFP_KERNEL);
 		if (cifs_sb->mountdata == NULL) {
+			bdi_destroy(&cifs_sb->bdi);
 			kfree(sb->s_fs_info);
 			sb->s_fs_info = NULL;
 			return -ENOMEM;
@@ -135,6 +142,7 @@ cifs_read_super(struct super_block *sb, void *data,
 
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
+	sb->s_bdi = &cifs_sb->bdi;
 /*	if (cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
 	    sb->s_blocksize =
 		cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
@@ -183,6 +191,7 @@ cifs_read_super(struct super_block *sb, void *data,
 		}
 #endif
 		unload_nls(cifs_sb->local_nls);
+		bdi_destroy(&cifs_sb->bdi);
 		kfree(cifs_sb);
 	}
 	return rc;
@@ -214,6 +223,7 @@ cifs_put_super(struct super_block *sb)
 #endif
 
 	unload_nls(cifs_sb->local_nls);
+	bdi_destroy(&cifs_sb->bdi);
 	kfree(cifs_sb);
 
 	unlock_kernel();

commit b6b38f704a8193daba520493ebdaf7e819962fc8
Author: Joe Perches <joe@perches.com>
Date:   Wed Apr 21 03:50:45 2010 +0000

    [CIFS] Neaten cERROR and cFYI macros, reduce text space
    
    Neaten cERROR and cFYI macros, reduce text space
    ~2.5K
    
    Convert '__FILE__ ": " fmt' to '"%s: " fmt', __FILE__' to save text space
    Surround macros with do {} while
    Add parentheses to macros
    Make statement expression macro from macro with assign
    Remove now unnecessary parentheses from cFYI and cERROR uses
    
    defconfig with CIFS support old
    $ size fs/cifs/built-in.o
       text    data     bss     dec     hex filename
     156012    1760     148  157920   268e0 fs/cifs/built-in.o
    
    defconfig with CIFS support old
    $ size fs/cifs/built-in.o
       text    data     bss     dec     hex filename
     153508    1760     148  155416   25f18 fs/cifs/built-in.o
    
    allyesconfig old:
    $ size fs/cifs/built-in.o
       text    data     bss     dec     hex filename
     309138    3864   74824  387826   5eaf2 fs/cifs/built-in.o
    
    allyesconfig new
    $ size fs/cifs/built-in.o
       text    data     bss     dec     hex filename
     305655    3864   74824  384343   5dd57 fs/cifs/built-in.o
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ded66be6597c..53e794131c2a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -128,8 +128,7 @@ cifs_read_super(struct super_block *sb, void *data,
 
 	if (rc) {
 		if (!silent)
-			cERROR(1,
-			       ("cifs_mount failed w/return code = %d", rc));
+			cERROR(1, "cifs_mount failed w/return code = %d", rc);
 		goto out_mount_failed;
 	}
 
@@ -160,7 +159,7 @@ cifs_read_super(struct super_block *sb, void *data,
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {
-		cFYI(1, ("export ops supported"));
+		cFYI(1, "export ops supported");
 		sb->s_export_op = &cifs_export_ops;
 	}
 #endif /* EXPERIMENTAL */
@@ -168,7 +167,7 @@ cifs_read_super(struct super_block *sb, void *data,
 	return 0;
 
 out_no_root:
-	cERROR(1, ("cifs_read_super: get root inode failed"));
+	cERROR(1, "cifs_read_super: get root inode failed");
 	if (inode)
 		iput(inode);
 
@@ -194,10 +193,10 @@ cifs_put_super(struct super_block *sb)
 	int rc = 0;
 	struct cifs_sb_info *cifs_sb;
 
-	cFYI(1, ("In cifs_put_super"));
+	cFYI(1, "In cifs_put_super");
 	cifs_sb = CIFS_SB(sb);
 	if (cifs_sb == NULL) {
-		cFYI(1, ("Empty cifs superblock info passed to unmount"));
+		cFYI(1, "Empty cifs superblock info passed to unmount");
 		return;
 	}
 
@@ -205,7 +204,7 @@ cifs_put_super(struct super_block *sb)
 
 	rc = cifs_umount(sb, cifs_sb);
 	if (rc)
-		cERROR(1, ("cifs_umount failed with return code %d", rc));
+		cERROR(1, "cifs_umount failed with return code %d", rc);
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	if (cifs_sb->mountdata) {
 		kfree(cifs_sb->mountdata);
@@ -439,7 +438,7 @@ int cifs_xquota_set(struct super_block *sb, int quota_type, qid_t qid,
 
 	xid = GetXid();
 	if (pTcon) {
-		cFYI(1, ("set type: 0x%x id: %d", quota_type, qid));
+		cFYI(1, "set type: 0x%x id: %d", quota_type, qid);
 	} else
 		rc = -EIO;
 
@@ -462,7 +461,7 @@ int cifs_xquota_get(struct super_block *sb, int quota_type, qid_t qid,
 
 	xid = GetXid();
 	if (pTcon) {
-		cFYI(1, ("set type: 0x%x id: %d", quota_type, qid));
+		cFYI(1, "set type: 0x%x id: %d", quota_type, qid);
 	} else
 		rc = -EIO;
 
@@ -484,7 +483,7 @@ int cifs_xstate_set(struct super_block *sb, unsigned int flags, int operation)
 
 	xid = GetXid();
 	if (pTcon) {
-		cFYI(1, ("flags: 0x%x operation: 0x%x", flags, operation));
+		cFYI(1, "flags: 0x%x operation: 0x%x", flags, operation);
 	} else
 		rc = -EIO;
 
@@ -506,7 +505,7 @@ int cifs_xstate_get(struct super_block *sb, struct fs_quota_stat *qstats)
 
 	xid = GetXid();
 	if (pTcon) {
-		cFYI(1, ("pqstats %p", qstats));
+		cFYI(1, "pqstats %p", qstats);
 	} else
 		rc = -EIO;
 
@@ -548,7 +547,7 @@ static void cifs_umount_begin(struct super_block *sb)
 	/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */
 	/* cancel_notify_requests(tcon); */
 	if (tcon->ses && tcon->ses->server) {
-		cFYI(1, ("wake up tasks now - umount begin not complete"));
+		cFYI(1, "wake up tasks now - umount begin not complete");
 		wake_up_all(&tcon->ses->server->request_q);
 		wake_up_all(&tcon->ses->server->response_q);
 		msleep(1); /* yield */
@@ -599,7 +598,7 @@ cifs_get_sb(struct file_system_type *fs_type,
 	int rc;
 	struct super_block *sb = sget(fs_type, NULL, set_anon_super, NULL);
 
-	cFYI(1, ("Devname: %s flags: %d ", dev_name, flags));
+	cFYI(1, "Devname: %s flags: %d ", dev_name, flags);
 
 	if (IS_ERR(sb))
 		return PTR_ERR(sb);
@@ -868,7 +867,7 @@ cifs_init_request_bufs(void)
 	} else {
 		CIFSMaxBufSize &= 0x1FE00; /* Round size to even 512 byte mult*/
 	}
-/*	cERROR(1,("CIFSMaxBufSize %d 0x%x",CIFSMaxBufSize,CIFSMaxBufSize)); */
+/*	cERROR(1, "CIFSMaxBufSize %d 0x%x",CIFSMaxBufSize,CIFSMaxBufSize); */
 	cifs_req_cachep = kmem_cache_create("cifs_request",
 					    CIFSMaxBufSize +
 					    MAX_CIFS_HDR_SIZE, 0,
@@ -880,7 +879,7 @@ cifs_init_request_bufs(void)
 		cifs_min_rcv = 1;
 	else if (cifs_min_rcv > 64) {
 		cifs_min_rcv = 64;
-		cERROR(1, ("cifs_min_rcv set to maximum (64)"));
+		cERROR(1, "cifs_min_rcv set to maximum (64)");
 	}
 
 	cifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,
@@ -911,7 +910,7 @@ cifs_init_request_bufs(void)
 		cifs_min_small = 2;
 	else if (cifs_min_small > 256) {
 		cifs_min_small = 256;
-		cFYI(1, ("cifs_min_small set to maximum (256)"));
+		cFYI(1, "cifs_min_small set to maximum (256)");
 	}
 
 	cifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,
@@ -1009,10 +1008,10 @@ init_cifs(void)
 
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
-		cFYI(1, ("cifs_max_pending set to min of 2"));
+		cFYI(1, "cifs_max_pending set to min of 2");
 	} else if (cifs_max_pending > 256) {
 		cifs_max_pending = 256;
-		cFYI(1, ("cifs_max_pending set to max of 256"));
+		cFYI(1, "cifs_max_pending set to max of 256");
 	}
 
 	rc = cifs_init_inodecache();
@@ -1070,7 +1069,7 @@ init_cifs(void)
 static void __exit
 exit_cifs(void)
 {
-	cFYI(DBG2, ("exit_cifs"));
+	cFYI(DBG2, "exit_cifs");
 	cifs_proc_clean();
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	cifs_dfs_release_automount_timer();

commit 810627a013163cd294762d57c0ea2ec055ffe4f6
Author: Pavel Shilovsky <piastryyy@gmail.com>
Date:   Sat Mar 27 02:00:49 2010 +0000

    [CIFS] Add mmap for direct, nobrl cifs mount types
    
    without mmap functions in file_ops OpenOffice can't save changes in
    existing document. The same situation you can see with gedit. Also, a.out
    format of files can't be executed without mmap.
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5183bc2a1916..ded66be6597c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -808,6 +808,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.release = cifs_close,
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
+	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
 #ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl  = cifs_ioctl,

commit abab095d1fd25986b910d3c46289d8fa3582cdc5
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Feb 12 07:44:18 2010 -0500

    cifs: add cifs_revalidate_file
    
    ...to allow updating inode attributes on an existing inode by
    filehandle. Change mmap and llseek codepaths to use that
    instead of cifs_revalidate_dentry since they have a filehandle
    readily available.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cf85a4165b01..5183bc2a1916 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -639,7 +639,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 		   setting the revalidate time to zero */
 		CIFS_I(file->f_path.dentry->d_inode)->time = 0;
 
-		retval = cifs_revalidate_dentry(file->f_path.dentry);
+		retval = cifs_revalidate_file(file);
 		if (retval < 0)
 			return (loff_t)retval;
 	}

commit df2cf170c823ba779ca339e3ede347c87f4dc6a9
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Feb 12 07:44:16 2010 -0500

    cifs: overhaul cifs_revalidate and rename to cifs_revalidate_dentry
    
    cifs_revalidate is renamed to cifs_revalidate_dentry as a later patch
    will add a by-filehandle variant.
    
    Add a new "invalid_mapping" flag to the cifsInodeInfo that indicates
    that the pagecache is considered invalid. Add a new routine to check
    inode attributes whenever they're updated and set that flag if the inode
    has changed on the server.
    
    cifs_revalidate_dentry is then changed to just update the attrcache if
    needed and then to zap the pagecache if it's not valid.
    
    There are some other behavior changes in here as well. Open files are
    now allowed to have their caches invalidated. I see no reason why we'd
    want to keep stale data around just because a file is open. Also,
    cifs_revalidate_cache uses the server_eof for revalidating the file
    size since that should more closely match the size of the file on the
    server.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8c6a03627176..cf85a4165b01 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -312,6 +312,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->clientCanCacheRead = false;
 	cifs_inode->clientCanCacheAll = false;
 	cifs_inode->delete_pending = false;
+	cifs_inode->invalid_mapping = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
 	cifs_inode->server_eof = 0;
 
@@ -638,7 +639,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 		   setting the revalidate time to zero */
 		CIFS_I(file->f_path.dentry->d_inode)->time = 0;
 
-		retval = cifs_revalidate(file->f_path.dentry);
+		retval = cifs_revalidate_dentry(file->f_path.dentry);
 		if (retval < 0)
 			return (loff_t)retval;
 	}

commit a994b8fa669f16c50728328c3735722a3f20652e
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Dec 7 05:44:46 2009 +0000

    [CIFS] Enable mmap on forcedirectio mounts
    
    openoffice and gedit failed with 'direct' options
    
    Signed-off-by: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 29f1da761bbf..8c6a03627176 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -758,7 +758,7 @@ const struct file_operations cifs_file_ops = {
 };
 
 const struct file_operations cifs_file_direct_ops = {
-	/* no mmap, no aio, no readv -
+	/* no aio, no readv -
 	   BB reevaluate whether they can be done with directio, no cache */
 	.read = cifs_user_read,
 	.write = cifs_user_write,
@@ -767,6 +767,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.lock = cifs_lock,
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
+	.mmap = cifs_file_mmap,
 	.splice_read = generic_file_splice_read,
 #ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl  = cifs_ioctl,

commit 0109d7e614e016a842569628116f54847a177f6e
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 20 21:50:36 2009 +0000

    SLOW_WORK: Fix CIFS to pass THIS_MODULE to slow_work_register_user()
    
    As of the patch:
    
            SLOW_WORK: Wait for outstanding work items belonging to a module to clear
    
            Wait for outstanding slow work items belonging to a module to clear
            when unregistering that module as a user of the facility.  This
            prevents the put_ref code of a work item from being taken away before
            it returns.
    
    slow_work_register_user() takes a module pointer as an argument.  CIFS must now
    pass THIS_MODULE as that argument, lest the following error be observed:
    
            fs/cifs/cifsfs.c: In function 'init_cifs':
            fs/cifs/cifsfs.c:1040: error: too few arguments to function 'slow_work_register_user'
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9a5e4f5f3122..29f1da761bbf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1037,7 +1037,7 @@ init_cifs(void)
 	if (rc)
 		goto out_unregister_key_type;
 #endif
-	rc = slow_work_register_user();
+	rc = slow_work_register_user(THIS_MODULE);
 	if (rc)
 		goto out_unregister_resolver_key;
 

commit 07e2e6ba2761291aa182993ebba1f490b5005dcc
Merge: d8f654ef6a55 3321b791b2e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 26 10:10:35 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6:
      cifs: fix locking and list handling code in cifs_open and its helper
      [CIFS] Remove build warning
      cifs: fix problems with last two commits
      [CIFS] Fix build break when keys support turned off
      cifs: eliminate cifs_init_private
      cifs: convert oplock breaks to use slow_work facility (try #4)
      cifs: have cifsFileInfo hold an extra inode reference
      cifs: take read lock on GlobalSMBSes_lock in is_valid_oplock_break
      cifs: remove cifsInodeInfo.oplockPending flag
      cifs: fix oplock request handling in posix codepath
      [CIFS] Re-enable Lanman security

commit 0f59e61c1f034b8088086bc85dc777af2ad3e836
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Sep 25 00:33:37 2009 +0000

    [CIFS] Fix build break when keys support turned off
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 89142b39fec1..c635b03accb1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1045,8 +1045,8 @@ init_cifs(void)
 	return 0;
 
  out_unregister_resolver_key:
-	unregister_key_type(&key_type_dns_resolver);
 #ifdef CONFIG_CIFS_DFS_UPCALL
+	unregister_key_type(&key_type_dns_resolver);
  out_unregister_key_type:
 #endif
 #ifdef CONFIG_CIFS_UPCALL

commit 3bc303c254335dbd7c7012cc1760b12f1d5514d3
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Sep 21 06:47:50 2009 -0400

    cifs: convert oplock breaks to use slow_work facility (try #4)
    
    This is the fourth respin of the patch to convert oplock breaks to
    use the slow_work facility.
    
    A customer of ours was testing a backport of one of the earlier
    patchsets, and hit a "Busy inodes after umount..." problem. An oplock
    break job had raced with a umount, and the superblock got torn down and
    its memory reused. When the oplock break job tried to dereference the
    inode->i_sb, the kernel oopsed.
    
    This patchset has the oplock break job hold an inode and vfsmount
    reference until the oplock break completes.  With this, there should be
    no need to take a tcon reference (the vfsmount implicitly holds one
    already).
    
    Currently, when an oplock break comes in there's a chance that the
    oplock break job won't occur if the allocation of the oplock_q_entry
    fails. There are also some rather nasty races in the allocation and
    handling these structs.
    
    Rather than allocating oplock queue entries when an oplock break comes
    in, add a few extra fields to the cifsFileInfo struct. Get rid of the
    dedicated cifs_oplock_thread as well and queue the oplock break job to
    the slow_work thread pool.
    
    This approach also has the advantage that the oplock break jobs can
    potentially run in parallel rather than be serialized like they are
    today.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3610e9958b4c..89142b39fec1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -64,9 +64,6 @@ unsigned int multiuser_mount = 0;
 unsigned int extended_security = CIFSSEC_DEF;
 /* unsigned int ntlmv2_support = 0; */
 unsigned int sign_CIFS_PDUs = 1;
-extern struct task_struct *oplockThread; /* remove sparse warning */
-struct task_struct *oplockThread = NULL;
-/* extern struct task_struct * dnotifyThread; remove sparse warning */
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
@@ -973,89 +970,12 @@ cifs_destroy_mids(void)
 	kmem_cache_destroy(cifs_oplock_cachep);
 }
 
-static int cifs_oplock_thread(void *dummyarg)
-{
-	struct oplock_q_entry *oplock_item;
-	struct cifsTconInfo *pTcon;
-	struct inode *inode;
-	__u16  netfid;
-	int rc, waitrc = 0;
-
-	set_freezable();
-	do {
-		if (try_to_freeze())
-			continue;
-
-		spin_lock(&cifs_oplock_lock);
-		if (list_empty(&cifs_oplock_list)) {
-			spin_unlock(&cifs_oplock_lock);
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(39*HZ);
-		} else {
-			oplock_item = list_entry(cifs_oplock_list.next,
-						struct oplock_q_entry, qhead);
-			cFYI(1, ("found oplock item to write out"));
-			pTcon = oplock_item->tcon;
-			inode = oplock_item->pinode;
-			netfid = oplock_item->netfid;
-			spin_unlock(&cifs_oplock_lock);
-			DeleteOplockQEntry(oplock_item);
-			/* can not grab inode sem here since it would
-				deadlock when oplock received on delete
-				since vfs_unlink holds the i_mutex across
-				the call */
-			/* mutex_lock(&inode->i_mutex);*/
-			if (S_ISREG(inode->i_mode)) {
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-				if (CIFS_I(inode)->clientCanCacheAll == 0)
-					break_lease(inode, FMODE_READ);
-				else if (CIFS_I(inode)->clientCanCacheRead == 0)
-					break_lease(inode, FMODE_WRITE);
-#endif
-				rc = filemap_fdatawrite(inode->i_mapping);
-				if (CIFS_I(inode)->clientCanCacheRead == 0) {
-					waitrc = filemap_fdatawait(
-							      inode->i_mapping);
-					invalidate_remote_inode(inode);
-				}
-				if (rc == 0)
-					rc = waitrc;
-			} else
-				rc = 0;
-			/* mutex_unlock(&inode->i_mutex);*/
-			if (rc)
-				CIFS_I(inode)->write_behind_rc = rc;
-			cFYI(1, ("Oplock flush inode %p rc %d",
-				inode, rc));
-
-				/* releasing stale oplock after recent reconnect
-				of smb session using a now incorrect file
-				handle is not a data integrity issue but do
-				not bother sending an oplock release if session
-				to server still is disconnected since oplock
-				already released by the server in that case */
-			if (!pTcon->need_reconnect) {
-				rc = CIFSSMBLock(0, pTcon, netfid,
-						0 /* len */ , 0 /* offset */, 0,
-						0, LOCKING_ANDX_OPLOCK_RELEASE,
-						false /* wait flag */);
-				cFYI(1, ("Oplock release rc = %d", rc));
-			}
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(1);  /* yield in case q were corrupt */
-		}
-	} while (!kthread_should_stop());
-
-	return 0;
-}
-
 static int __init
 init_cifs(void)
 {
 	int rc = 0;
 	cifs_proc_init();
 	INIT_LIST_HEAD(&cifs_tcp_ses_list);
-	INIT_LIST_HEAD(&cifs_oplock_list);
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	INIT_LIST_HEAD(&GlobalDnotifyReqList);
 	INIT_LIST_HEAD(&GlobalDnotifyRsp_Q);
@@ -1084,7 +1004,6 @@ init_cifs(void)
 	rwlock_init(&GlobalSMBSeslock);
 	rwlock_init(&cifs_tcp_ses_lock);
 	spin_lock_init(&GlobalMid_Lock);
-	spin_lock_init(&cifs_oplock_lock);
 
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
@@ -1119,18 +1038,15 @@ init_cifs(void)
 	if (rc)
 		goto out_unregister_key_type;
 #endif
-	oplockThread = kthread_run(cifs_oplock_thread, NULL, "cifsoplockd");
-	if (IS_ERR(oplockThread)) {
-		rc = PTR_ERR(oplockThread);
-		cERROR(1, ("error %d create oplock thread", rc));
-		goto out_unregister_dfs_key_type;
-	}
+	rc = slow_work_register_user();
+	if (rc)
+		goto out_unregister_resolver_key;
 
 	return 0;
 
- out_unregister_dfs_key_type:
-#ifdef CONFIG_CIFS_DFS_UPCALL
+ out_unregister_resolver_key:
 	unregister_key_type(&key_type_dns_resolver);
+#ifdef CONFIG_CIFS_DFS_UPCALL
  out_unregister_key_type:
 #endif
 #ifdef CONFIG_CIFS_UPCALL
@@ -1165,7 +1081,6 @@ exit_cifs(void)
 	cifs_destroy_inodecache();
 	cifs_destroy_mids();
 	cifs_destroy_request_bufs();
-	kthread_stop(oplockThread);
 }
 
 MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");

commit 6d729e44a55547c009d7a87ea66bff21a8e0afea
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Aug 16 21:05:08 2009 +0000

    fs: Make unload_nls() NULL pointer safe
    
    Most call sites of unload_nls() do:
            if (nls)
                    unload_nls(nls);
    
    Check the pointer inside unload_nls() like we do in kfree() and
    simplify the call sites.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Steve French <sfrench@us.ibm.com>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Cc: Petr Vandrovec <vandrove@vc.cvut.cz>
    Cc: Anton Altaparmakov <aia21@cantab.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d79ce2e95c23..90c5b39f0313 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -185,8 +185,7 @@ cifs_read_super(struct super_block *sb, void *data,
 			cifs_sb->mountdata = NULL;
 		}
 #endif
-		if (cifs_sb->local_nls)
-			unload_nls(cifs_sb->local_nls);
+		unload_nls(cifs_sb->local_nls);
 		kfree(cifs_sb);
 	}
 	return rc;

commit 0d54b217a247f39605361f867fefbb9e099a5432
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 21 17:01:09 2009 -0700

    const: make struct super_block::s_qcop const
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3610e9958b4c..d79ce2e95c23 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -50,7 +50,7 @@
 #define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
 
 #ifdef CONFIG_CIFS_QUOTA
-static struct quotactl_ops cifs_quotactl_ops;
+static const struct quotactl_ops cifs_quotactl_ops;
 #endif /* QUOTA */
 
 int cifsFYI = 0;
@@ -517,7 +517,7 @@ int cifs_xstate_get(struct super_block *sb, struct fs_quota_stat *qstats)
 	return rc;
 }
 
-static struct quotactl_ops cifs_quotactl_ops = {
+static const struct quotactl_ops cifs_quotactl_ops = {
 	.set_xquota	= cifs_xquota_set,
 	.get_xquota	= cifs_xquota_get,
 	.set_xstate	= cifs_xstate_set,

commit 1b49c5566136455764a8d17ead25784f534c202d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Aug 28 10:11:11 2009 -0400

    cifs: protect GlobalOplock_Q with its own spinlock
    
    Right now, the GlobalOplock_Q is protected by the GlobalMid_Lock. That
    lock is also used for completely unrelated purposes (mostly for managing
    the global mid queue). Give the list its own dedicated spinlock
    (cifs_oplock_lock) and rename the list to cifs_oplock_list to
    eliminate the camel-case.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b750aa502ff7..3610e9958b4c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -986,19 +986,19 @@ static int cifs_oplock_thread(void *dummyarg)
 		if (try_to_freeze())
 			continue;
 
-		spin_lock(&GlobalMid_Lock);
-		if (list_empty(&GlobalOplock_Q)) {
-			spin_unlock(&GlobalMid_Lock);
+		spin_lock(&cifs_oplock_lock);
+		if (list_empty(&cifs_oplock_list)) {
+			spin_unlock(&cifs_oplock_lock);
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(39*HZ);
 		} else {
-			oplock_item = list_entry(GlobalOplock_Q.next,
+			oplock_item = list_entry(cifs_oplock_list.next,
 						struct oplock_q_entry, qhead);
 			cFYI(1, ("found oplock item to write out"));
 			pTcon = oplock_item->tcon;
 			inode = oplock_item->pinode;
 			netfid = oplock_item->netfid;
-			spin_unlock(&GlobalMid_Lock);
+			spin_unlock(&cifs_oplock_lock);
 			DeleteOplockQEntry(oplock_item);
 			/* can not grab inode sem here since it would
 				deadlock when oplock received on delete
@@ -1055,7 +1055,7 @@ init_cifs(void)
 	int rc = 0;
 	cifs_proc_init();
 	INIT_LIST_HEAD(&cifs_tcp_ses_list);
-	INIT_LIST_HEAD(&GlobalOplock_Q);
+	INIT_LIST_HEAD(&cifs_oplock_list);
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	INIT_LIST_HEAD(&GlobalDnotifyReqList);
 	INIT_LIST_HEAD(&GlobalDnotifyRsp_Q);
@@ -1084,6 +1084,7 @@ init_cifs(void)
 	rwlock_init(&GlobalSMBSeslock);
 	rwlock_init(&cifs_tcp_ses_lock);
 	spin_lock_init(&GlobalMid_Lock);
+	spin_lock_init(&cifs_oplock_lock);
 
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;

commit 8e047d09ee1143058b71f40c5f4d028dde52d883
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Aug 28 10:11:10 2009 -0400

    cifs: use tcon pointer in cifs_show_options
    
    Minor nit: we already have a tcon pointer so we don't need to
    dereference cifs_sb again.
    
    Also initialize the vars in the declaration.
    
    Reported-by: Peter Staubach <staubach@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 84b75253b05a..b750aa502ff7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -361,13 +361,10 @@ cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
 static int
 cifs_show_options(struct seq_file *s, struct vfsmount *m)
 {
-	struct cifs_sb_info *cifs_sb;
-	struct cifsTconInfo *tcon;
-
-	cifs_sb = CIFS_SB(m->mnt_sb);
-	tcon = cifs_sb->tcon;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(m->mnt_sb);
+	struct cifsTconInfo *tcon = cifs_sb->tcon;
 
-	seq_printf(s, ",unc=%s", cifs_sb->tcon->treeName);
+	seq_printf(s, ",unc=%s", tcon->treeName);
 	if (tcon->ses->userName)
 		seq_printf(s, ",username=%s", tcon->ses->userName);
 	if (tcon->ses->domainName)

commit 4486d6ede16b362f89b29845af6fe1a26ae78a54
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Aug 3 12:45:10 2009 -0400

    cifs: show noforceuid/noforcegid mount options (try #2)
    
    Since forceuid is the default, we now need to show when it's disabled.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 44f30504b82d..84b75253b05a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -376,10 +376,14 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)
 		seq_printf(s, ",forceuid");
+	else
+		seq_printf(s, ",noforceuid");
 
 	seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)
 		seq_printf(s, ",forcegid");
+	else
+		seq_printf(s, ",noforcegid");
 
 	cifs_show_address(s, tcon->ses->server);
 

commit aeaaf253c4dee7ff9af2f3f0595f3bb66964e944
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jul 9 01:46:39 2009 -0400

    cifs: remove cifsInodeInfo->inUse counter
    
    cifs: remove cifsInodeInfo->inUse counter
    
    It was purported to be a refcounter of some sort, but was never
    used that way. It never served any purpose that wasn't served equally well
    by the I_NEW flag.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9f669f982c4d..44f30504b82d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -308,7 +308,6 @@ cifs_alloc_inode(struct super_block *sb)
 	if (!cifs_inode)
 		return NULL;
 	cifs_inode->cifsAttrs = 0x20;	/* default */
-	atomic_set(&cifs_inode->inUse, 0);
 	cifs_inode->time = 0;
 	cifs_inode->write_behind_rc = 0;
 	/* Until the file is open and we have gotten oplock

commit ad8034f19792736db5c259103c2eaaf72887bbb4
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Jun 26 03:25:49 2009 +0000

    [CIFS] remove bkl usage from umount begin
    
    The lock_kernel call moved into the fs for umount_begin
    is not needed.  This adds a check to make sure we don't
    call umount_begin twice on the same fs.
    
    umount_begin for cifs is probably not needed and
    may eventually be able to be removed, but in
    the meantime this smaller patch is safe and
    gets rid of the bkl from this path which provides
    some benefit.
    
    Acked-by: Jeff Layton <redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b5e9f398c2e5..9f669f982c4d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -537,9 +537,14 @@ static void cifs_umount_begin(struct super_block *sb)
 	if (tcon == NULL)
 		return;
 
-	lock_kernel();
 	read_lock(&cifs_tcp_ses_lock);
-	if (tcon->tc_count == 1)
+	if ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {
+		/* we have other mounts to same share or we have
+		   already tried to force umount this and woken up
+		   all waiting network requests, nothing to do */
+		read_unlock(&cifs_tcp_ses_lock);
+		return;
+	} else if (tcon->tc_count == 1)
 		tcon->tidStatus = CifsExiting;
 	read_unlock(&cifs_tcp_ses_lock);
 
@@ -554,9 +559,7 @@ static void cifs_umount_begin(struct super_block *sb)
 		wake_up_all(&tcon->ses->server->response_q);
 		msleep(1);
 	}
-/* BB FIXME - finish add checks for tidStatus BB */
 
-	unlock_kernel();
 	return;
 }
 

commit b48a485884b5afb3e33b1871bcbd246b67491923
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jun 25 00:56:54 2009 -0400

    cifs: fix problems with earlier patches
    
    cifs: fix problems with earlier patches
    
    cifs_show_address hasn't been introduced yet, and fix a typo that was
    silently fixed by a later patch in the series.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ddef913ff3e6..b5e9f398c2e5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -374,8 +374,6 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	if (tcon->ses->domainName)
 		seq_printf(s, ",domain=%s", tcon->ses->domainName);
 
-	cifs_show_address(s, tcon->ses->server);
-
 	seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)
 		seq_printf(s, ",forceuid");

commit 61f98ffd74254a95871168bd5a6646b4f3002e31
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jun 11 10:27:32 2009 -0400

    cifs: display scopeid in /proc/mounts
    
    Move address display into a new function and display the scopeid as part
    of the address in /proc/mounts.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8b315708cb3f..ddef913ff3e6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -333,6 +333,27 @@ cifs_destroy_inode(struct inode *inode)
 	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
 }
 
+static void
+cifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)
+{
+	seq_printf(s, ",addr=");
+
+	switch (server->addr.sockAddr.sin_family) {
+	case AF_INET:
+		seq_printf(s, "%pI4", &server->addr.sockAddr.sin_addr.s_addr);
+		break;
+	case AF_INET6:
+		seq_printf(s, "%pI6",
+			   &server->addr.sockAddr6.sin6_addr.s6_addr);
+		if (server->addr.sockAddr6.sin6_scope_id)
+			seq_printf(s, "%%%u",
+				   server->addr.sockAddr6.sin6_scope_id);
+		break;
+	default:
+		seq_printf(s, "(unknown)");
+	}
+}
+
 /*
  * cifs_show_options() is for displaying mount options in /proc/mounts.
  * Not all settable options are displayed but most of the important
@@ -343,7 +364,6 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 {
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *tcon;
-	struct TCP_Server_Info *server;
 
 	cifs_sb = CIFS_SB(m->mnt_sb);
 	tcon = cifs_sb->tcon;
@@ -364,16 +384,7 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)
 		seq_printf(s, ",forcegid");
 
-	server = tcon->ses->server;
-	seq_printf(s, ",addr=");
-	switch (server->addr.sockAddr6.sin6_family) {
-	case AF_INET6:
-		seq_printf(s, "%pI6", &server->addr.sockAddr6.sin6_addr);
-		break;
-	case AF_INET:
-		seq_printf(s, "%pI4", &server->addr.sockAddr.sin_addr.s_addr);
-		break;
-	}
+	cifs_show_address(s, tcon->ses->server);
 
 	if (!tcon->unix_ext)
 		seq_printf(s, ",file_mode=0%o,dir_mode=0%o",

commit 340481a36498bf3fe404bcecb2e2d6188e950bff
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jun 11 10:27:29 2009 -0400

    cifs: have cifs_show_options show forceuid/forcegid options
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3f121fbd6c56..8b315708cb3f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -357,7 +357,12 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	cifs_show_address(s, tcon->ses->server);
 
 	seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)
+		seq_printf(s, ",forceuid");
+
 	seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)
+		seq_printf(s, ",forcegid");
 
 	server = tcon->ses->server;
 	seq_printf(s, ",addr=");

commit 8616e0fc1e27295316f9821a883f0e9fa6f8200f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jun 11 10:27:28 2009 -0400

    cifs: remove unneeded NULL checks from cifs_show_options
    
    show_options is always called with the namespace_sem held. Therefore we
    don't need to worry about the vfsmount being NULL, or it vanishing while
    the function is running. By the same token, there's no need to worry
    about the superblock, tcon, smb or tcp sessions being NULL on entry.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0d92114195ab..3f121fbd6c56 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -346,80 +346,68 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	struct TCP_Server_Info *server;
 
 	cifs_sb = CIFS_SB(m->mnt_sb);
+	tcon = cifs_sb->tcon;
 
-	if (cifs_sb) {
-		tcon = cifs_sb->tcon;
-		if (tcon) {
-			seq_printf(s, ",unc=%s", cifs_sb->tcon->treeName);
-			if (tcon->ses) {
-				if (tcon->ses->userName)
-					seq_printf(s, ",username=%s",
-					   tcon->ses->userName);
-				if (tcon->ses->domainName)
-					seq_printf(s, ",domain=%s",
-					   tcon->ses->domainName);
-				server = tcon->ses->server;
-				if (server) {
-					seq_printf(s, ",addr=");
-					switch (server->addr.sockAddr6.
-						sin6_family) {
-					case AF_INET6:
-						seq_printf(s, "%pI6",
-							   &server->addr.sockAddr6.sin6_addr);
-						break;
-					case AF_INET:
-						seq_printf(s, "%pI4",
-							   &server->addr.sockAddr.sin_addr.s_addr);
-						break;
-					}
-				}
-			}
-			if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID) ||
-			   !(tcon->unix_ext))
-				seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
-			if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) ||
-			   !(tcon->unix_ext))
-				seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
-			if (!tcon->unix_ext) {
-				seq_printf(s, ",file_mode=0%o,dir_mode=0%o",
+	seq_printf(s, ",unc=%s", cifs_sb->tcon->treeName);
+	if (tcon->ses->userName)
+		seq_printf(s, ",username=%s", tcon->ses->userName);
+	if (tcon->ses->domainName)
+		seq_printf(s, ",domain=%s", tcon->ses->domainName);
+
+	cifs_show_address(s, tcon->ses->server);
+
+	seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
+	seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
+
+	server = tcon->ses->server;
+	seq_printf(s, ",addr=");
+	switch (server->addr.sockAddr6.sin6_family) {
+	case AF_INET6:
+		seq_printf(s, "%pI6", &server->addr.sockAddr6.sin6_addr);
+		break;
+	case AF_INET:
+		seq_printf(s, "%pI4", &server->addr.sockAddr.sin_addr.s_addr);
+		break;
+	}
+
+	if (!tcon->unix_ext)
+		seq_printf(s, ",file_mode=0%o,dir_mode=0%o",
 					   cifs_sb->mnt_file_mode,
 					   cifs_sb->mnt_dir_mode);
-			}
-			if (tcon->seal)
-				seq_printf(s, ",seal");
-			if (tcon->nocase)
-				seq_printf(s, ",nocase");
-			if (tcon->retry)
-				seq_printf(s, ",hard");
-		}
-		if (cifs_sb->prepath)
-			seq_printf(s, ",prepath=%s", cifs_sb->prepath);
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
-			seq_printf(s, ",posixpaths");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)
-			seq_printf(s, ",setuids");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
-			seq_printf(s, ",serverino");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
-			seq_printf(s, ",directio");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
-			seq_printf(s, ",nouser_xattr");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)
-			seq_printf(s, ",mapchars");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)
-			seq_printf(s, ",sfu");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)
-			seq_printf(s, ",nobrl");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)
-			seq_printf(s, ",cifsacl");
-		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)
-			seq_printf(s, ",dynperm");
-		if (m->mnt_sb->s_flags & MS_POSIXACL)
-			seq_printf(s, ",acl");
-
-		seq_printf(s, ",rsize=%d", cifs_sb->rsize);
-		seq_printf(s, ",wsize=%d", cifs_sb->wsize);
-	}
+	if (tcon->seal)
+		seq_printf(s, ",seal");
+	if (tcon->nocase)
+		seq_printf(s, ",nocase");
+	if (tcon->retry)
+		seq_printf(s, ",hard");
+	if (cifs_sb->prepath)
+		seq_printf(s, ",prepath=%s", cifs_sb->prepath);
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
+		seq_printf(s, ",posixpaths");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)
+		seq_printf(s, ",setuids");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
+		seq_printf(s, ",serverino");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
+		seq_printf(s, ",directio");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
+		seq_printf(s, ",nouser_xattr");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)
+		seq_printf(s, ",mapchars");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)
+		seq_printf(s, ",sfu");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)
+		seq_printf(s, ",nobrl");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)
+		seq_printf(s, ",cifsacl");
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)
+		seq_printf(s, ",dynperm");
+	if (m->mnt_sb->s_flags & MS_POSIXACL)
+		seq_printf(s, ",acl");
+
+	seq_printf(s, ",rsize=%d", cifs_sb->rsize);
+	seq_printf(s, ",wsize=%d", cifs_sb->wsize);
+
 	return 0;
 }
 

commit 6cfd0148425e528b859b26e436b01f23f6926224
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 5 15:40:36 2009 +0200

    push BKL down into ->put_super
    
    Move BKL into ->put_super from the only caller.  A couple of
    filesystems had trivial enough ->put_super (only kfree and NULLing of
    s_fs_info + stuff in there) to not get any locking: coda, cramfs, efs,
    hugetlbfs, omfs, qnx4, shmem, all others got the full treatment.  Most
    of them probably don't need it, but I'd rather sort that out individually.
    Preferably after all the other BKL pushdowns in that area.
    
    [AV: original used to move lock_super() down as well; these changes are
    removed since we don't do lock_super() at all in generic_shutdown_super()
    now]
    [AV: fuse, btrfs and xfs are known to need no damn BKL, exempt]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0a10a59b6392..0d92114195ab 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -204,6 +204,9 @@ cifs_put_super(struct super_block *sb)
 		cFYI(1, ("Empty cifs superblock info passed to unmount"));
 		return;
 	}
+
+	lock_kernel();
+
 	rc = cifs_umount(sb, cifs_sb);
 	if (rc)
 		cERROR(1, ("cifs_umount failed with return code %d", rc));
@@ -216,7 +219,8 @@ cifs_put_super(struct super_block *sb)
 
 	unload_nls(cifs_sb->local_nls);
 	kfree(cifs_sb);
-	return;
+
+	unlock_kernel();
 }
 
 static int

commit bd433d4cf4d8593a5f1764776b91f1794fce5a77
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed May 27 09:37:34 2009 -0400

    cifs: rename cifs_iget to cifs_root_iget
    
    The current cifs_iget isn't suitable for anything but the root inode.
    Rename it with a more appropriate name.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5e6d35804d73..0a10a59b6392 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -146,7 +146,7 @@ cifs_read_super(struct super_block *sb, void *data,
 #endif
 	sb->s_blocksize = CIFS_MAX_MSGSIZE;
 	sb->s_blocksize_bits = 14;	/* default 2**14 = CIFS_MAX_MSGSIZE */
-	inode = cifs_iget(sb, ROOT_I);
+	inode = cifs_root_iget(sb, ROOT_I);
 
 	if (IS_ERR(inode)) {
 		rc = PTR_ERR(inode);

commit 6f5bbff9a1b7d6864a495763448a363bbfa96324
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 6 01:34:22 2009 -0400

    Convert obvious places to deactivate_locked_super()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 355e0efec0cf..5e6d35804d73 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -602,8 +602,7 @@ cifs_get_sb(struct file_system_type *fs_type,
 
 	rc = cifs_read_super(sb, data, dev_name, flags & MS_SILENT ? 1 : 0);
 	if (rc) {
-		up_write(&sb->s_umount);
-		deactivate_super(sb);
+		deactivate_locked_super(sb);
 		return rc;
 	}
 	sb->s_flags |= MS_ACTIVE;

commit 67e55205ec55cc7899f1d783f217961596798419
Author: Alessio Igor Bogani <abogani@texware.it>
Date:   Fri Apr 24 09:06:53 2009 +0200

    vfs: umount_begin BKL pushdown
    
    Push BKL down into ->umount_begin()
    
    Signed-off-by: Alessio Igor Bogani <abogani@texware.it>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0d6d8b573652..355e0efec0cf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -35,6 +35,7 @@
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/freezer.h>
+#include <linux/smp_lock.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE
@@ -530,6 +531,7 @@ static void cifs_umount_begin(struct super_block *sb)
 	if (tcon == NULL)
 		return;
 
+	lock_kernel();
 	read_lock(&cifs_tcp_ses_lock);
 	if (tcon->tc_count == 1)
 		tcon->tidStatus = CifsExiting;
@@ -548,6 +550,7 @@ static void cifs_umount_begin(struct super_block *sb)
 	}
 /* BB FIXME - finish add checks for tidStatus BB */
 
+	unlock_kernel();
 	return;
 }
 

commit 5144ebf408ed08380917126493450ee22e63fe3f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Mar 23 01:47:12 2009 -0400

    cifs: remove dnotify thread code
    
    cifs: remove dnotify thread code
    
    Al Viro recently removed the dir_notify code from the kernel along with
    the CIFS code that used it. We can also get rid of the dnotify thread
    as well.
    
    In actuality, it never had anything to do with dir_notify anyway. All
    it did was unnecessarily wake up all the tasks waiting on the response
    queues every 15s. Previously that happened to prevent tasks from hanging
    indefinitely when the server went unresponsive, but we put those to
    sleep with proper timeouts now so there's no reason to keep this around.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 34f5701d9555..0d6d8b573652 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -66,9 +66,6 @@ unsigned int sign_CIFS_PDUs = 1;
 extern struct task_struct *oplockThread; /* remove sparse warning */
 struct task_struct *oplockThread = NULL;
 /* extern struct task_struct * dnotifyThread; remove sparse warning */
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-static struct task_struct *dnotifyThread = NULL;
-#endif
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
@@ -1041,34 +1038,6 @@ static int cifs_oplock_thread(void *dummyarg)
 	return 0;
 }
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-static int cifs_dnotify_thread(void *dummyarg)
-{
-	struct list_head *tmp;
-	struct TCP_Server_Info *server;
-
-	do {
-		if (try_to_freeze())
-			continue;
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(15*HZ);
-		/* check if any stuck requests that need
-		   to be woken up and wakeq so the
-		   thread can wake up and error out */
-		read_lock(&cifs_tcp_ses_lock);
-		list_for_each(tmp, &cifs_tcp_ses_list) {
-			server = list_entry(tmp, struct TCP_Server_Info,
-					 tcp_ses_list);
-			if (atomic_read(&server->inFlight))
-				wake_up_all(&server->response_q);
-		}
-		read_unlock(&cifs_tcp_ses_lock);
-	} while (!kthread_should_stop());
-
-	return 0;
-}
-#endif
-
 static int __init
 init_cifs(void)
 {
@@ -1145,21 +1114,8 @@ init_cifs(void)
 		goto out_unregister_dfs_key_type;
 	}
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-	dnotifyThread = kthread_run(cifs_dnotify_thread, NULL, "cifsdnotifyd");
-	if (IS_ERR(dnotifyThread)) {
-		rc = PTR_ERR(dnotifyThread);
-		cERROR(1, ("error %d create dnotify thread", rc));
-		goto out_stop_oplock_thread;
-	}
-#endif
-
 	return 0;
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
- out_stop_oplock_thread:
-#endif
-	kthread_stop(oplockThread);
  out_unregister_dfs_key_type:
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	unregister_key_type(&key_type_dns_resolver);
@@ -1197,9 +1153,6 @@ exit_cifs(void)
 	cifs_destroy_inodecache();
 	cifs_destroy_mids();
 	cifs_destroy_request_bufs();
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-	kthread_stop(dnotifyThread);
-#endif
 	kthread_stop(oplockThread);
 }
 

commit fbec9ab952d4810960e620035c8e95f0fbbae4be
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Apr 3 13:44:00 2009 -0400

    cifs: vary timeout on writes past EOF based on offset (try #5)
    
    This is the fourth version of this patch:
    
    The first three generated a compiler warning asking for explicit curly
    braces.
    
    The first two didn't handle update the size correctly when writes that
    didn't start at the eof were done.
    
    The first patch also didn't update the size correctly when it explicitly
    set via truncate().
    
    This patch adds code to track the client's current understanding of the
    size of the file on the server separate from the i_size, and then to use
    this info to semi-intelligently set the timeout for writes past the EOF.
    
    This helps prevent timeouts when trying to write large, sparse files on
    windows servers.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 38491fd3871d..34f5701d9555 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -316,6 +316,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->clientCanCacheAll = false;
 	cifs_inode->delete_pending = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
+	cifs_inode->server_eof = 0;
 
 	/* Can not set i_flags here - they get immediately overwritten
 	   to zero by the VFS */

commit a3ec947c85ec339884b30ef6a08133e9311fdae1
Author: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
Date:   Wed Mar 4 12:06:34 2009 -0800

    vfs: simple_set_mnt() should return void
    
    simple_set_mnt() is defined as returning 'int' but always returns 0.
    Callers assume simple_set_mnt() never fails and don't properly cleanup if
    it were to _ever_ fail.  For instance, get_sb_single() and get_sb_nodev()
    should:
    
            up_write(sb->s_unmount);
            deactivate_super(sb);
    
    if simple_set_mnt() fails.
    
    Since simple_set_mnt() never fails, would be cleaner if it did not
    return anything.
    
    [akpm@linux-foundation.org: fix build]
    Signed-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 13ea53251dcf..38491fd3871d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -606,7 +606,8 @@ cifs_get_sb(struct file_system_type *fs_type,
 		return rc;
 	}
 	sb->s_flags |= MS_ACTIVE;
-	return simple_set_mnt(mnt, sb);
+	simple_set_mnt(mnt, sb);
+	return 0;
 }
 
 static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,

commit 6badd79bd002788aaec27b50a74ab69ef65ab8ee
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Dec 26 00:57:40 2008 -0500

    kill ->dir_notify()
    
    Remove the hopelessly misguided ->dir_notify().  The only instance (cifs)
    has been broken by design from the very beginning; the objects it creates
    are never destroyed, keep references to struct file they can outlive, nothing
    that could possibly evict them exists on close(2) path *and* no locking
    whatsoever is done to prevent races with close(), should the previous, er,
    deficiencies someday be dealt with.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 0005a194a75c..13ea53251dcf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -747,7 +747,6 @@ const struct file_operations cifs_file_ops = {
 #endif /* CONFIG_CIFS_POSIX */
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-	.dir_notify = cifs_dir_notify,
 	.setlease = cifs_setlease,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
@@ -768,7 +767,6 @@ const struct file_operations cifs_file_direct_ops = {
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-	.dir_notify = cifs_dir_notify,
 	.setlease = cifs_setlease,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
@@ -789,7 +787,6 @@ const struct file_operations cifs_file_nobrl_ops = {
 #endif /* CONFIG_CIFS_POSIX */
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-	.dir_notify = cifs_dir_notify,
 	.setlease = cifs_setlease,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
@@ -809,7 +806,6 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-	.dir_notify = cifs_dir_notify,
 	.setlease = cifs_setlease,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
@@ -818,9 +814,6 @@ const struct file_operations cifs_dir_ops = {
 	.readdir = cifs_readdir,
 	.release = cifs_closedir,
 	.read    = generic_read_dir,
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-	.dir_notify = cifs_dir_notify,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 	.unlocked_ioctl  = cifs_ioctl,
 	.llseek = generic_file_llseek,
 };

commit bf66542bef3771a42ad3b1d5dc503c804bc22b33
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Dec 3 13:49:23 2008 +1100

    cifs: update for new IP4/6 address printing
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 974c8f0e615e..0005a194a75c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -361,12 +361,12 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 					switch (server->addr.sockAddr6.
 						sin6_family) {
 					case AF_INET6:
-						seq_printf(s, NIP6_FMT,
-							   NIP6(server->addr.sockAddr6.sin6_addr));
+						seq_printf(s, "%pI6",
+							   &server->addr.sockAddr6.sin6_addr);
 						break;
 					case AF_INET:
-						seq_printf(s, NIPQUAD_FMT,
-							   NIPQUAD(server->addr.sockAddr.sin_addr.s_addr));
+						seq_printf(s, "%pI4",
+							   &server->addr.sockAddr.sin_addr.s_addr);
 						break;
 					}
 				}

commit 61e748015866e48aff91284e3d300c6e3035a87a
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Dec 3 00:57:54 2008 +0000

    [CIFS] various minor cleanups pointed out by checkpatch script
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 061a1dca987d..974c8f0e615e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -347,7 +347,6 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 	if (cifs_sb) {
 		tcon = cifs_sb->tcon;
 		if (tcon) {
-/* BB add prepath to mount options displayed */
 			seq_printf(s, ",unc=%s", cifs_sb->tcon->treeName);
 			if (tcon->ses) {
 				if (tcon->ses->userName)
@@ -439,9 +438,8 @@ int cifs_xquota_set(struct super_block *sb, int quota_type, qid_t qid,
 	xid = GetXid();
 	if (pTcon) {
 		cFYI(1, ("set type: 0x%x id: %d", quota_type, qid));
-	} else {
+	} else
 		rc = -EIO;
-	}
 
 	FreeXid(xid);
 	return rc;
@@ -463,9 +461,8 @@ int cifs_xquota_get(struct super_block *sb, int quota_type, qid_t qid,
 	xid = GetXid();
 	if (pTcon) {
 		cFYI(1, ("set type: 0x%x id: %d", quota_type, qid));
-	} else {
+	} else
 		rc = -EIO;
-	}
 
 	FreeXid(xid);
 	return rc;
@@ -486,9 +483,8 @@ int cifs_xstate_set(struct super_block *sb, unsigned int flags, int operation)
 	xid = GetXid();
 	if (pTcon) {
 		cFYI(1, ("flags: 0x%x operation: 0x%x", flags, operation));
-	} else {
+	} else
 		rc = -EIO;
-	}
 
 	FreeXid(xid);
 	return rc;
@@ -501,17 +497,16 @@ int cifs_xstate_get(struct super_block *sb, struct fs_quota_stat *qstats)
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifsTconInfo *pTcon;
 
-	if (cifs_sb) {
+	if (cifs_sb)
 		pTcon = cifs_sb->tcon;
-	} else {
+	else
 		return -EIO;
-	}
+
 	xid = GetXid();
 	if (pTcon) {
 		cFYI(1, ("pqstats %p", qstats));
-	} else {
+	} else
 		rc = -EIO;
-	}
 
 	FreeXid(xid);
 	return rc;

commit 954d7a1cf12158fed23dd8b0f3f563d5a5c97f28
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 1 15:23:50 2008 -0500

    cifs: make dnotify thread experimental code
    
    Now that tasks sleeping in wait_for_response will time out on their own,
    we're not reliant on the dnotify thread to do this. Mark it as
    experimental code for now.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7f87066ce29f..061a1dca987d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -66,7 +66,9 @@ unsigned int sign_CIFS_PDUs = 1;
 extern struct task_struct *oplockThread; /* remove sparse warning */
 struct task_struct *oplockThread = NULL;
 /* extern struct task_struct * dnotifyThread; remove sparse warning */
+#ifdef CONFIG_CIFS_EXPERIMENTAL
 static struct task_struct *dnotifyThread = NULL;
+#endif
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
@@ -1049,6 +1051,7 @@ static int cifs_oplock_thread(void *dummyarg)
 	return 0;
 }
 
+#ifdef CONFIG_CIFS_EXPERIMENTAL
 static int cifs_dnotify_thread(void *dummyarg)
 {
 	struct list_head *tmp;
@@ -1074,6 +1077,7 @@ static int cifs_dnotify_thread(void *dummyarg)
 
 	return 0;
 }
+#endif
 
 static int __init
 init_cifs(void)
@@ -1151,16 +1155,20 @@ init_cifs(void)
 		goto out_unregister_dfs_key_type;
 	}
 
+#ifdef CONFIG_CIFS_EXPERIMENTAL
 	dnotifyThread = kthread_run(cifs_dnotify_thread, NULL, "cifsdnotifyd");
 	if (IS_ERR(dnotifyThread)) {
 		rc = PTR_ERR(dnotifyThread);
 		cERROR(1, ("error %d create dnotify thread", rc));
 		goto out_stop_oplock_thread;
 	}
+#endif
 
 	return 0;
 
+#ifdef CONFIG_CIFS_EXPERIMENTAL
  out_stop_oplock_thread:
+#endif
 	kthread_stop(oplockThread);
  out_unregister_dfs_key_type:
 #ifdef CONFIG_CIFS_DFS_UPCALL
@@ -1199,8 +1207,10 @@ exit_cifs(void)
 	cifs_destroy_inodecache();
 	cifs_destroy_mids();
 	cifs_destroy_request_bufs();
-	kthread_stop(oplockThread);
+#ifdef CONFIG_CIFS_EXPERIMENTAL
 	kthread_stop(dnotifyThread);
+#endif
+	kthread_stop(oplockThread);
 }
 
 MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");

commit 80909022ce966191e6140fcc15d8aff57a7df32e
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 1 07:09:35 2008 -0500

    cifs: display addr and prefixpath options in /proc/mounts
    
    Have cifs_show_options display the addr and prefixpath options in
    /proc/mounts. Reduce struct dereferencing by adding some local
    variables.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d9cf467309e8..7f87066ce29f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -337,39 +337,59 @@ static int
 cifs_show_options(struct seq_file *s, struct vfsmount *m)
 {
 	struct cifs_sb_info *cifs_sb;
+	struct cifsTconInfo *tcon;
+	struct TCP_Server_Info *server;
 
 	cifs_sb = CIFS_SB(m->mnt_sb);
 
 	if (cifs_sb) {
-		if (cifs_sb->tcon) {
+		tcon = cifs_sb->tcon;
+		if (tcon) {
 /* BB add prepath to mount options displayed */
 			seq_printf(s, ",unc=%s", cifs_sb->tcon->treeName);
-			if (cifs_sb->tcon->ses) {
-				if (cifs_sb->tcon->ses->userName)
+			if (tcon->ses) {
+				if (tcon->ses->userName)
 					seq_printf(s, ",username=%s",
-					   cifs_sb->tcon->ses->userName);
-				if (cifs_sb->tcon->ses->domainName)
+					   tcon->ses->userName);
+				if (tcon->ses->domainName)
 					seq_printf(s, ",domain=%s",
-					   cifs_sb->tcon->ses->domainName);
+					   tcon->ses->domainName);
+				server = tcon->ses->server;
+				if (server) {
+					seq_printf(s, ",addr=");
+					switch (server->addr.sockAddr6.
+						sin6_family) {
+					case AF_INET6:
+						seq_printf(s, NIP6_FMT,
+							   NIP6(server->addr.sockAddr6.sin6_addr));
+						break;
+					case AF_INET:
+						seq_printf(s, NIPQUAD_FMT,
+							   NIPQUAD(server->addr.sockAddr.sin_addr.s_addr));
+						break;
+					}
+				}
 			}
 			if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID) ||
-			   !(cifs_sb->tcon->unix_ext))
+			   !(tcon->unix_ext))
 				seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
 			if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) ||
-			   !(cifs_sb->tcon->unix_ext))
+			   !(tcon->unix_ext))
 				seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
-			if (!cifs_sb->tcon->unix_ext) {
+			if (!tcon->unix_ext) {
 				seq_printf(s, ",file_mode=0%o,dir_mode=0%o",
 					   cifs_sb->mnt_file_mode,
 					   cifs_sb->mnt_dir_mode);
 			}
-			if (cifs_sb->tcon->seal)
+			if (tcon->seal)
 				seq_printf(s, ",seal");
-			if (cifs_sb->tcon->nocase)
+			if (tcon->nocase)
 				seq_printf(s, ",nocase");
-			if (cifs_sb->tcon->retry)
+			if (tcon->retry)
 				seq_printf(s, ",hard");
 		}
+		if (cifs_sb->prepath)
+			seq_printf(s, ",prepath=%s", cifs_sb->prepath);
 		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 			seq_printf(s, ",posixpaths");
 		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)

commit f1987b44f642e96176adc88b7ce23a1d74806f89
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Nov 15 11:12:47 2008 -0500

    cifs: reinstate sharing of tree connections
    
    Use a similar approach to the SMB session sharing. Add a list of tcons
    attached to each SMB session. Move the refcount to non-atomic. Protect
    all of the above with the cifs_tcp_ses_lock. Add functions to
    properly find and put references to the tcons.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a1e96620b097..d9cf467309e8 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -514,10 +514,11 @@ static void cifs_umount_begin(struct super_block *sb)
 	tcon = cifs_sb->tcon;
 	if (tcon == NULL)
 		return;
-	down(&tcon->tconSem);
-	if (atomic_read(&tcon->useCount) == 1)
+
+	read_lock(&cifs_tcp_ses_lock);
+	if (tcon->tc_count == 1)
 		tcon->tidStatus = CifsExiting;
-	up(&tcon->tconSem);
+	read_unlock(&cifs_tcp_ses_lock);
 
 	/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */
 	/* cancel_notify_requests(tcon); */
@@ -1060,7 +1061,6 @@ init_cifs(void)
 	int rc = 0;
 	cifs_proc_init();
 	INIT_LIST_HEAD(&cifs_tcp_ses_list);
-	INIT_LIST_HEAD(&GlobalTreeConnectionList); /* BB to be removed by jl */
 	INIT_LIST_HEAD(&GlobalOplock_Q);
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	INIT_LIST_HEAD(&GlobalDnotifyReqList);

commit 14fbf50d695207754daeb96270b3027a3821121f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Nov 14 13:53:46 2008 -0500

    cifs: reinstate sharing of SMB sessions sans races
    
    We do this by abandoning the global list of SMB sessions and instead
    moving to a per-server list. This entails adding a new list head to the
    TCP_Server_Info struct. The refcounting for the cifsSesInfo is moved to
    a non-atomic variable. We have to protect it by a lock anyway, so there's
    no benefit to making it an atomic. The list and refcount are protected
    by the global cifs_tcp_ses_lock.
    
    The patch also adds a new routines to find and put SMB sessions and
    that properly take and put references under the lock.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2946dab0718f..a1e96620b097 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1031,24 +1031,24 @@ static int cifs_oplock_thread(void *dummyarg)
 static int cifs_dnotify_thread(void *dummyarg)
 {
 	struct list_head *tmp;
-	struct cifsSesInfo *ses;
+	struct TCP_Server_Info *server;
 
 	do {
 		if (try_to_freeze())
 			continue;
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(15*HZ);
-		read_lock(&GlobalSMBSeslock);
 		/* check if any stuck requests that need
 		   to be woken up and wakeq so the
 		   thread can wake up and error out */
-		list_for_each(tmp, &GlobalSMBSessionList) {
-			ses = list_entry(tmp, struct cifsSesInfo,
-				cifsSessionList);
-			if (ses->server && atomic_read(&ses->server->inFlight))
-				wake_up_all(&ses->server->response_q);
+		read_lock(&cifs_tcp_ses_lock);
+		list_for_each(tmp, &cifs_tcp_ses_list) {
+			server = list_entry(tmp, struct TCP_Server_Info,
+					 tcp_ses_list);
+			if (atomic_read(&server->inFlight))
+				wake_up_all(&server->response_q);
 		}
-		read_unlock(&GlobalSMBSeslock);
+		read_unlock(&cifs_tcp_ses_lock);
 	} while (!kthread_should_stop());
 
 	return 0;
@@ -1060,7 +1060,6 @@ init_cifs(void)
 	int rc = 0;
 	cifs_proc_init();
 	INIT_LIST_HEAD(&cifs_tcp_ses_list);
-	INIT_LIST_HEAD(&GlobalSMBSessionList); /* BB to be removed by jl */
 	INIT_LIST_HEAD(&GlobalTreeConnectionList); /* BB to be removed by jl */
 	INIT_LIST_HEAD(&GlobalOplock_Q);
 #ifdef CONFIG_CIFS_EXPERIMENTAL

commit e7ddee9037e7dd43de1ad08b51727e552aedd836
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Nov 14 13:44:38 2008 -0500

    cifs: disable sharing session and tcon and add new TCP sharing code
    
    The code that allows these structs to be shared is extremely racy.
    Disable the sharing of SMB and tcon structs for now until we can
    come up with a way to do this that's race free.
    
    We want to continue to share TCP sessions, however since they are
    required for multiuser mounts. For that, implement a new (hopefully
    race-free) scheme. Add a new global list of TCP sessions, and take
    care to get a reference to it whenever we're dealing with one.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index af16a2406b1c..2946dab0718f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1059,7 +1059,7 @@ init_cifs(void)
 {
 	int rc = 0;
 	cifs_proc_init();
-	INIT_LIST_HEAD(&global_cifs_sock_list);
+	INIT_LIST_HEAD(&cifs_tcp_ses_list);
 	INIT_LIST_HEAD(&GlobalSMBSessionList); /* BB to be removed by jl */
 	INIT_LIST_HEAD(&GlobalTreeConnectionList); /* BB to be removed by jl */
 	INIT_LIST_HEAD(&GlobalOplock_Q);
@@ -1089,6 +1089,7 @@ init_cifs(void)
 	GlobalMaxActiveXid = 0;
 	memset(Local_System_Name, 0, 15);
 	rwlock_init(&GlobalSMBSeslock);
+	rwlock_init(&cifs_tcp_ses_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
 	if (cifs_max_pending < 2) {

commit fb396016647ae9de5b3bd8c4ee4f7b9cc7148bd5
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Nov 13 20:04:07 2008 +0000

    [CIFS] remove unused list, add new cifs sock list to prepare for mount/umount fix
    
    Also adds two lines missing from the previous patch (for the need reconnect flag in the
    /proc/fs/cifs/DebugData handling)
    
    The new global_cifs_sock_list is added, and initialized in init_cifs but not used yet.
    Jeff Layton will be adding code in to use that and to remove the GlobalTcon and GlobalSMBSession
    lists.
    
    CC: Jeff Layton <jlayton@redhat.com>
    CC: Shirish Pargaonkar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 903bbd6449d1..af16a2406b1c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1059,9 +1059,9 @@ init_cifs(void)
 {
 	int rc = 0;
 	cifs_proc_init();
-/*	INIT_LIST_HEAD(&GlobalServerList);*/	/* BB not implemented yet */
-	INIT_LIST_HEAD(&GlobalSMBSessionList);
-	INIT_LIST_HEAD(&GlobalTreeConnectionList);
+	INIT_LIST_HEAD(&global_cifs_sock_list);
+	INIT_LIST_HEAD(&GlobalSMBSessionList); /* BB to be removed by jl */
+	INIT_LIST_HEAD(&GlobalTreeConnectionList); /* BB to be removed by jl */
 	INIT_LIST_HEAD(&GlobalOplock_Q);
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	INIT_LIST_HEAD(&GlobalDnotifyReqList);

commit 3b7952109361c684caf0c50474da8662ecc81019
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Nov 13 19:45:32 2008 +0000

    [CIFS] Fix cifs reconnection flags
    
    In preparation for Jeff's big umount/mount fixes to remove the possibility of
    various races in cifs mount and linked list handling of sessions, sockets and
    tree connections, this patch cleans up some repetitive code in cifs_mount,
    and addresses a problem with ses->status and tcon->tidStatus in which we
    were overloading the "need_reconnect" state with other status in that
    field.  So the "need_reconnect" flag has been broken out from those
    two state fields (need reconnect was not mutually exclusive from some of the
    other possible tid and ses states).  In addition, a few exit cases in
    cifs_mount were cleaned up, and a problem with a tcon flag (for lease support)
    was not being set consistently for the 2nd mount of the same share
    
    CC: Jeff Layton <jlayton@redhat.com>
    CC: Shirish Pargaonkar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ac5915d61dca..903bbd6449d1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1013,7 +1013,7 @@ static int cifs_oplock_thread(void *dummyarg)
 				not bother sending an oplock release if session
 				to server still is disconnected since oplock
 				already released by the server in that case */
-			if (pTcon->tidStatus != CifsNeedReconnect) {
+			if (!pTcon->need_reconnect) {
 				rc = CIFSSMBLock(0, pTcon, netfid,
 						0 /* len */ , 0 /* offset */, 0,
 						0, LOCKING_ANDX_OPLOCK_RELEASE,

commit db563fc2e80534f98c7f9121a6f7dfe41f177a79
Merge: eb81071584be b1c8d2b42137
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 23 10:43:36 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6:
      cifs: handle the TCP_Server_Info->tsk field more carefully
      cifs: fix unlinking of rename target when server doesn't support open file renames
      [CIFS] improve setlease handling
      [CIFS] fix saving of resume key before CIFSFindNext
      cifs: make cifs_rename handle -EACCES errors
      [CIFS] fix build error
      [CIFS] undo changes in cifs_rename_pending_delete if it errors out
      cifs: track DeletePending flag in cifsInodeInfo
      cifs: don't use CREATE_DELETE_ON_CLOSE in cifs_rename_pending_delete
      [CIFS] eliminate usage of kthread_stop for cifsd
      [CIFS] Add nodfs mount option

commit f696a3659fc4b3a3bf4bc83d9dbec5e5a2ffd929
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Thu Jul 31 13:41:58 2008 +0200

    [PATCH] move executable checking into ->permission()
    
    For execute permission on a regular files we need to check if file has
    any execute bits at all, regardless of capabilites.
    
    This check is normally performed by generic_permission() but was also
    added to the case when the filesystem defines its own ->permission()
    method.  In the latter case the filesystem should be responsible for
    performing this check.
    
    Move the check from inode_permission() inside filesystems which are
    not calling generic_permission().
    
    Create a helper function execute_ok() that returns true if the inode
    is a directory or if any execute bits are present in i_mode.
    
    Also fix up the following code:
    
     - coda control file is never executable
     - sysctl files are never executable
     - hfs_permission seems broken on MAY_EXEC, remove
     - hfsplus_permission is eqivalent to generic_permission(), remove
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 89c64a8dcb99..84cc011a16e4 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -275,9 +275,12 @@ static int cifs_permission(struct inode *inode, int mask)
 
 	cifs_sb = CIFS_SB(inode->i_sb);
 
-	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)
-		return 0;
-	else /* file mode might have been restricted at mount time
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {
+		if ((mask & MAY_EXEC) && !execute_ok(inode))
+			return -EACCES;
+		else
+			return 0;
+	} else /* file mode might have been restricted at mount time
 		on the client (above and beyond ACL on servers) for
 		servers which do not support setting and viewing mode bits,
 		so allowing client to check permissions is useful */

commit 3222a3e55f4025acb2a5a4379cf2f2b7df1f1243
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Sep 3 21:53:01 2008 +0200

    [PATCH] fix ->llseek for more directories
    
    With this patch all directory fops instances that have a readdir
    that doesn't take the BKL are switched to generic_file_llseek.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 25ecbd5b0404..89c64a8dcb99 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -765,6 +765,7 @@ const struct file_operations cifs_dir_ops = {
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 	.unlocked_ioctl  = cifs_ioctl,
+	.llseek = generic_file_llseek,
 };
 
 static void

commit 84210e9120a8c01a14379ba1f9a9b0f963641d94
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Oct 23 04:42:37 2008 +0000

    [CIFS] improve setlease handling
    
    fcntl(F_SETLEASE) currently is not exported by cifs (nor by local file
    systems) so cifs grants leases based on how other local processes have
    opened the file not by whether the file is cacheable (oplocked).  This
    adds the check to make sure that the file is cacheable on the client
    before checking whether we can grant the lease locally
    (generic_setlease).  It also adds a mount option for cifs (locallease)
    if the user wants to override this and try to grant leases even
    if the server did not grant oplock.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c6aad775dd6d..76919c25acc7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -618,6 +618,37 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 	return generic_file_llseek_unlocked(file, offset, origin);
 }
 
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
+{
+	/* note that this is called by vfs setlease with the BKL held
+	   although I doubt that BKL is needed here in cifs */
+	struct inode *inode = file->f_path.dentry->d_inode;
+
+	if (!(S_ISREG(inode->i_mode)))
+		return -EINVAL;
+
+	/* check if file is oplocked */
+	if (((arg == F_RDLCK) &&
+		(CIFS_I(inode)->clientCanCacheRead)) ||
+	    ((arg == F_WRLCK) &&
+		(CIFS_I(inode)->clientCanCacheAll)))
+		return generic_setlease(file, arg, lease);
+	else if (CIFS_SB(inode->i_sb)->tcon->local_lease &&
+			!CIFS_I(inode)->clientCanCacheRead)
+		/* If the server claims to support oplock on this
+		   file, then we still need to check oplock even
+		   if the local_lease mount option is set, but there
+		   are servers which do not support oplock for which
+		   this mount option may be useful if the user
+		   knows that the file won't be changed on the server
+		   by anyone else */
+		return generic_setlease(file, arg, lease);
+	else
+		return -EAGAIN;
+}
+#endif
+
 struct file_system_type cifs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "cifs",
@@ -696,6 +727,7 @@ const struct file_operations cifs_file_ops = {
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
+	.setlease = cifs_setlease,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
@@ -716,6 +748,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
+	.setlease = cifs_setlease,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 const struct file_operations cifs_file_nobrl_ops = {
@@ -736,6 +769,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
+	.setlease = cifs_setlease,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
@@ -755,6 +789,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
+	.setlease = cifs_setlease,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
@@ -946,6 +981,12 @@ static int cifs_oplock_thread(void *dummyarg)
 				the call */
 			/* mutex_lock(&inode->i_mutex);*/
 			if (S_ISREG(inode->i_mode)) {
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+				if (CIFS_I(inode)->clientCanCacheAll == 0)
+					break_lease(inode, FMODE_READ);
+				else if (CIFS_I(inode)->clientCanCacheRead == 0)
+					break_lease(inode, FMODE_WRITE);
+#endif
 				rc = filemap_fdatawrite(inode->i_mapping);
 				if (CIFS_I(inode)->clientCanCacheRead == 0) {
 					waitrc = filemap_fdatawait(

commit 9a8165fce724d1aba21e2c713ac6ba11dbfecafa
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Oct 17 21:03:20 2008 -0400

    cifs: track DeletePending flag in cifsInodeInfo
    
    cifs: track DeletePending flag in cifsInodeInfo
    
    The QPathInfo call returns a flag that indicates whether DELETE_ON_CLOSE
    is set. Track it in the cifsInodeInfo.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 25ecbd5b0404..c6aad775dd6d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -309,6 +309,7 @@ cifs_alloc_inode(struct super_block *sb)
 	file data or metadata */
 	cifs_inode->clientCanCacheRead = false;
 	cifs_inode->clientCanCacheAll = false;
+	cifs_inode->delete_pending = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
 
 	/* Can not set i_flags here - they get immediately overwritten

commit 54b4602d5fe50571362e101138d24edb9cf82d29
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Aug 11 22:31:40 2008 +0000

    [CIFS] remove trailing whitespace
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f50fc8728c94..25ecbd5b0404 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -174,7 +174,7 @@ cifs_read_super(struct super_block *sb, void *data,
 	cERROR(1, ("cifs_read_super: get root inode failed"));
 	if (inode)
 		iput(inode);
-	
+
 	cifs_umount(sb, cifs_sb);
 
 out_mount_failed:

commit 2c731afb0d4ba16018b400c75665fbdb8feb2175
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Aug 11 22:28:53 2008 +0000

    [CIFS] if get root inode fails during mount, cleanup tree connection
    
    CC: Stable Kernel <stable@kernel.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e8da4ee761b5..f50fc8728c94 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -174,6 +174,8 @@ cifs_read_super(struct super_block *sb, void *data,
 	cERROR(1, ("cifs_read_super: get root inode failed"));
 	if (inode)
 		iput(inode);
+	
+	cifs_umount(sb, cifs_sb);
 
 out_mount_failed:
 	if (cifs_sb) {

commit ad8b15f0ffc297cdd6c65ef7552b3b8abd11a401
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Aug 8 21:10:16 2008 +0000

    [CIFS] list entry can not return null
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1ec7076f7b24..e8da4ee761b5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -930,36 +930,34 @@ static int cifs_oplock_thread(void *dummyarg)
 			schedule_timeout(39*HZ);
 		} else {
 			oplock_item = list_entry(GlobalOplock_Q.next,
-				struct oplock_q_entry, qhead);
-			if (oplock_item) {
-				cFYI(1, ("found oplock item to write out"));
-				pTcon = oplock_item->tcon;
-				inode = oplock_item->pinode;
-				netfid = oplock_item->netfid;
-				spin_unlock(&GlobalMid_Lock);
-				DeleteOplockQEntry(oplock_item);
-				/* can not grab inode sem here since it would
+						struct oplock_q_entry, qhead);
+			cFYI(1, ("found oplock item to write out"));
+			pTcon = oplock_item->tcon;
+			inode = oplock_item->pinode;
+			netfid = oplock_item->netfid;
+			spin_unlock(&GlobalMid_Lock);
+			DeleteOplockQEntry(oplock_item);
+			/* can not grab inode sem here since it would
 				deadlock when oplock received on delete
 				since vfs_unlink holds the i_mutex across
 				the call */
-				/* mutex_lock(&inode->i_mutex);*/
-				if (S_ISREG(inode->i_mode)) {
-					rc =
-					   filemap_fdatawrite(inode->i_mapping);
-					if (CIFS_I(inode)->clientCanCacheRead
-									 == 0) {
-						waitrc = filemap_fdatawait(inode->i_mapping);
-						invalidate_remote_inode(inode);
-					}
-					if (rc == 0)
-						rc = waitrc;
-				} else
-					rc = 0;
-				/* mutex_unlock(&inode->i_mutex);*/
-				if (rc)
-					CIFS_I(inode)->write_behind_rc = rc;
-				cFYI(1, ("Oplock flush inode %p rc %d",
-					inode, rc));
+			/* mutex_lock(&inode->i_mutex);*/
+			if (S_ISREG(inode->i_mode)) {
+				rc = filemap_fdatawrite(inode->i_mapping);
+				if (CIFS_I(inode)->clientCanCacheRead == 0) {
+					waitrc = filemap_fdatawait(
+							      inode->i_mapping);
+					invalidate_remote_inode(inode);
+				}
+				if (rc == 0)
+					rc = waitrc;
+			} else
+				rc = 0;
+			/* mutex_unlock(&inode->i_mutex);*/
+			if (rc)
+				CIFS_I(inode)->write_behind_rc = rc;
+			cFYI(1, ("Oplock flush inode %p rc %d",
+				inode, rc));
 
 				/* releasing stale oplock after recent reconnect
 				of smb session using a now incorrect file
@@ -967,15 +965,13 @@ static int cifs_oplock_thread(void *dummyarg)
 				not bother sending an oplock release if session
 				to server still is disconnected since oplock
 				already released by the server in that case */
-				if (pTcon->tidStatus != CifsNeedReconnect) {
-				    rc = CIFSSMBLock(0, pTcon, netfid,
-					    0 /* len */ , 0 /* offset */, 0,
-					    0, LOCKING_ANDX_OPLOCK_RELEASE,
-					    false /* wait flag */);
-					cFYI(1, ("Oplock release rc = %d", rc));
-				}
-			} else
-				spin_unlock(&GlobalMid_Lock);
+			if (pTcon->tidStatus != CifsNeedReconnect) {
+				rc = CIFSSMBLock(0, pTcon, netfid,
+						0 /* len */ , 0 /* offset */, 0,
+						0, LOCKING_ANDX_OPLOCK_RELEASE,
+						false /* wait flag */);
+				cFYI(1, ("Oplock release rc = %d", rc));
+			}
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(1);  /* yield in case q were corrupt */
 		}
@@ -1001,8 +997,7 @@ static int cifs_dnotify_thread(void *dummyarg)
 		list_for_each(tmp, &GlobalSMBSessionList) {
 			ses = list_entry(tmp, struct cifsSesInfo,
 				cifsSessionList);
-			if (ses && ses->server &&
-			     atomic_read(&ses->server->inFlight))
+			if (ses->server && atomic_read(&ses->server->inFlight))
 				wake_up_all(&ses->server->response_q);
 		}
 		read_unlock(&GlobalSMBSeslock);

commit e6305c43eda10ebfd2ad9e35d6e172ccc7bb3695
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 15 21:03:57 2008 -0400

    [PATCH] sanitize ->permission() prototype
    
    * kill nameidata * argument; map the 3 bits in ->flags anybody cares
      about to new MAY_... ones and pass with the mask.
    * kill redundant gfs2_iop_permission()
    * sanitize ecryptfs_permission()
    * fix remaining places where ->permission() instances might barf on new
      MAY_... found in mask.
    
    The obvious next target in that direction is permission(9)
    
    folded fix for nfs_permission() breakage from Miklos Szeredi <mszeredi@suse.cz>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index fe5f6809cba6..1ec7076f7b24 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -267,7 +267,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	return 0;
 }
 
-static int cifs_permission(struct inode *inode, int mask, struct nameidata *nd)
+static int cifs_permission(struct inode *inode, int mask)
 {
 	struct cifs_sb_info *cifs_sb;
 

commit 51cc50685a4275c6a02653670af9f108a64e01cf
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Jul 25 19:45:34 2008 -0700

    SL*B: drop kmem cache argument from constructor
    
    Kmem cache passed to constructor is only needed for constructors that are
    themselves multiplexeres.  Nobody uses this "feature", nor does anybody uses
    passed kmem cache in non-trivial way, so pass only pointer to object.
    
    Non-trivial places are:
            arch/powerpc/mm/init_64.c
            arch/powerpc/mm/hugetlbpage.c
    
    This is flag day, yes.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Jon Tollefson <kniht@linux.vnet.ibm.com>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Cc: Matt Mackall <mpm@selenic.com>
    [akpm@linux-foundation.org: fix arch/powerpc/mm/hugetlbpage.c]
    [akpm@linux-foundation.org: fix mm/slab.c]
    [akpm@linux-foundation.org: fix ubifs]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 22857c639df5..fe5f6809cba6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -766,7 +766,7 @@ const struct file_operations cifs_dir_ops = {
 };
 
 static void
-cifs_init_once(struct kmem_cache *cachep, void *inode)
+cifs_init_once(void *inode)
 {
 	struct cifsInodeInfo *cifsi = inode;
 

commit 2fceef397f9880b212a74c418290ce69e7ac00eb
Merge: feae1ef116ed bce7f793daec
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Mon Jul 14 15:29:34 2008 -0600

    Merge commit 'v2.6.26' into bkl-removal

commit 9465efc9e96135a2cec8154c0c766fa59984a298
Author: Andi Kleen <andi@firstfloor.org>
Date:   Fri Jun 27 11:05:24 2008 +0200

    Remove BKL from remote_llseek v2
    
    - Replace remote_llseek with generic_file_llseek_unlocked (to force compilation
    failures in all users)
    - Change all users to either use generic_file_llseek_unlocked directly or
    take the BKL around. I changed the file systems who don't use the BKL
    for anything (CIFS, GFS) to call it directly. NCPFS and SMBFS and NFS
    take the BKL, but explicitely in their own source now.
    
    I moved them all over in a single patch to avoid unbisectable sections.
    
    Open problem: 32bit kernels can corrupt fpos because its modification
    is not atomic, but they can do that anyways because there's other paths who
    modify it without BKL.
    
    Do we need a special lock for the pos/f_version = 0 checks?
    
    Trond says the NFS BKL is likely not needed, but keep it for now
    until his full audit.
    
    v2: Use generic_file_llseek_unlocked instead of remote_llseek_unlocked
        and factor duplicated code (suggested by hch)
    
    Cc: Trond.Myklebust@netapp.com
    Cc: swhiteho@redhat.com
    Cc: sfrench@samba.org
    Cc: vandrove@vc.cvut.cz
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 427a7c695896..aeff0fe5b6b9 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -581,7 +581,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 		if (retval < 0)
 			return (loff_t)retval;
 	}
-	return remote_llseek(file, offset, origin);
+	return generic_file_llseek_unlocked(file, offset, origin);
 }
 
 struct file_system_type cifs_fs_type = {

commit 79ee9a8b2d328243488fee8b55bfacc822049a2a
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Jun 10 21:37:02 2008 +0000

    [CIFS] cifs: fix oops on mount when CONFIG_CIFS_DFS_UPCALL is enabled
    
    simple "mount -t cifs //xxx /mnt" oopsed on strlen of options
    http://kerneloops.org/guilty.php?guilty=cifs_get_sb&version=2.6.25-release&start=16711 \
    68&end=1703935&class=oops
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5df93fd6303f..86b4d5f405ae 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -97,9 +97,6 @@ cifs_read_super(struct super_block *sb, void *data,
 {
 	struct inode *inode;
 	struct cifs_sb_info *cifs_sb;
-#ifdef CONFIG_CIFS_DFS_UPCALL
-	int len;
-#endif
 	int rc = 0;
 
 	/* BB should we make this contingent on mount parm? */
@@ -117,15 +114,17 @@ cifs_read_super(struct super_block *sb, void *data,
 	 * complex operation (mount), and in case of fail
 	 * just exit instead of doing mount and attempting
 	 * undo it if this copy fails?*/
-	len = strlen(data);
-	cifs_sb->mountdata = kzalloc(len + 1, GFP_KERNEL);
-	if (cifs_sb->mountdata == NULL) {
-		kfree(sb->s_fs_info);
-		sb->s_fs_info = NULL;
-		return -ENOMEM;
+	if (data) {
+		int len = strlen(data);
+		cifs_sb->mountdata = kzalloc(len + 1, GFP_KERNEL);
+		if (cifs_sb->mountdata == NULL) {
+			kfree(sb->s_fs_info);
+			sb->s_fs_info = NULL;
+			return -ENOMEM;
+		}
+		strncpy(cifs_sb->mountdata, data, len + 1);
+		cifs_sb->mountdata[len] = '\0';
 	}
-	strncpy(cifs_sb->mountdata, data, len + 1);
-	cifs_sb->mountdata[len] = '\0';
 #endif
 
 	rc = cifs_mount(sb, cifs_sb, data, devname);

commit 89562b777c50d100d1694db7b1b023279839b9ae
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon May 19 22:26:42 2008 +0000

    [CIFS] add missing seq_printf to cifs_show_options for hard mount option
    
    Also Kari Hurtta noticed a missing check in the same function which is now fixed.
    
    CC: Kari Hurtta <hurtta+gmane@siilo.fmi.fi>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 57e40c49d3b6..5df93fd6303f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -360,7 +360,10 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 			}
 			if (cifs_sb->tcon->seal)
 				seq_printf(s, ",seal");
+			if (cifs_sb->tcon->nocase)
 				seq_printf(s, ",nocase");
+			if (cifs_sb->tcon->retry)
+				seq_printf(s, ",hard");
 		}
 		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 			seq_printf(s, ",posixpaths");

commit 2b280fab12b6697b6a7a24a13aaf9f4339edd075
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat May 17 03:12:45 2008 +0000

    [CIFS] add more complete mount options to cifs_show_options
    
    adds various options to cifs_show_options
    (displayed when you cat /proc/mounts with a cifs mount).  I limited
    the new ones to values that are associated with the mount with the
    exception of "seal" (which is a per tree connection property, but I
    thought was important enough to show through).
    
    Eventually cifs's parse_mount_options also needs to
    be rewritten to use the match_token API but that would be a big enough
    change that I would prefer that changing parse_mount_options wait
    until next release.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index b6436b888cf9..57e40c49d3b6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/cifsfs.c
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2007
+ *   Copyright (C) International Business Machines  Corp., 2002,2008
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
  *   Common Internet FileSystem (CIFS) client
@@ -353,9 +353,38 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 			if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) ||
 			   !(cifs_sb->tcon->unix_ext))
 				seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
+			if (!cifs_sb->tcon->unix_ext) {
+				seq_printf(s, ",file_mode=0%o,dir_mode=0%o",
+					   cifs_sb->mnt_file_mode,
+					   cifs_sb->mnt_dir_mode);
+			}
+			if (cifs_sb->tcon->seal)
+				seq_printf(s, ",seal");
+				seq_printf(s, ",nocase");
 		}
 		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 			seq_printf(s, ",posixpaths");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)
+			seq_printf(s, ",setuids");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)
+			seq_printf(s, ",serverino");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)
+			seq_printf(s, ",directio");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
+			seq_printf(s, ",nouser_xattr");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)
+			seq_printf(s, ",mapchars");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)
+			seq_printf(s, ",sfu");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)
+			seq_printf(s, ",nobrl");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)
+			seq_printf(s, ",cifsacl");
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)
+			seq_printf(s, ",dynperm");
+		if (m->mnt_sb->s_flags & MS_POSIXACL)
+			seq_printf(s, ",acl");
+
 		seq_printf(s, ",rsize=%d", cifs_sb->rsize);
 		seq_printf(s, ",wsize=%d", cifs_sb->wsize);
 	}

commit f9ddcca4cf7d95238beb295484d1de7c0bf490dd
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu May 15 05:51:55 2008 +0000

    [CIFS] BKL-removal: convert CIFS over to unlocked_ioctl
    
    cifs_ioctl doesn't seem to need the BKL for anything, so convert it over
    to use unlocked_ioctl.
    
    Signed-off-by: Andi Kleen <andi@firstfloor.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 427a7c695896..b6436b888cf9 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -657,7 +657,7 @@ const struct file_operations cifs_file_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_POSIX
-	.ioctl	= cifs_ioctl,
+	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
@@ -677,7 +677,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.flush = cifs_flush,
 	.splice_read = generic_file_splice_read,
 #ifdef CONFIG_CIFS_POSIX
-	.ioctl  = cifs_ioctl,
+	.unlocked_ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
@@ -697,7 +697,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_POSIX
-	.ioctl	= cifs_ioctl,
+	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
@@ -716,7 +716,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.flush = cifs_flush,
 	.splice_read = generic_file_splice_read,
 #ifdef CONFIG_CIFS_POSIX
-	.ioctl  = cifs_ioctl,
+	.unlocked_ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
@@ -731,7 +731,7 @@ const struct file_operations cifs_dir_ops = {
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
-	.ioctl  = cifs_ioctl,
+	.unlocked_ioctl  = cifs_ioctl,
 };
 
 static void

commit 4b18f2a9c3964f7612b7403dddc1d1ba5443ae24
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Apr 29 00:06:05 2008 +0000

    [CIFS] convert usage of implicit booleans to bool
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 68f1cdf6aed7..427a7c695896 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -306,8 +306,8 @@ cifs_alloc_inode(struct super_block *sb)
 	/* Until the file is open and we have gotten oplock
 	info back from the server, can not assume caching of
 	file data or metadata */
-	cifs_inode->clientCanCacheRead = FALSE;
-	cifs_inode->clientCanCacheAll = FALSE;
+	cifs_inode->clientCanCacheRead = false;
+	cifs_inode->clientCanCacheAll = false;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
 
 	/* Can not set i_flags here - they get immediately overwritten
@@ -940,7 +940,7 @@ static int cifs_oplock_thread(void *dummyarg)
 				    rc = CIFSSMBLock(0, pTcon, netfid,
 					    0 /* len */ , 0 /* offset */, 0,
 					    0, LOCKING_ANDX_OPLOCK_RELEASE,
-					    0 /* wait flag */);
+					    false /* wait flag */);
 					cFYI(1, ("Oplock release rc = %d", rc));
 				}
 			} else

commit 39da9847113a870b20fee9a7c216a848b9a5e9f7
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Apr 28 04:04:34 2008 +0000

    [CIFS] Fix statfs formatting
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 39c2cbdface7..68f1cdf6aed7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -222,50 +222,50 @@ static int
 cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct super_block *sb = dentry->d_sb;
-	int xid;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	struct cifsTconInfo *tcon = cifs_sb->tcon;
 	int rc = -EOPNOTSUPP;
-	struct cifs_sb_info *cifs_sb;
-	struct cifsTconInfo *pTcon;
+	int xid;
 
 	xid = GetXid();
 
-	cifs_sb = CIFS_SB(sb);
-	pTcon = cifs_sb->tcon;
-
 	buf->f_type = CIFS_MAGIC_NUMBER;
 
-	/* instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO */
-	buf->f_namelen = PATH_MAX; /* PATH_MAX may be too long - it would
-				      presumably be total path, but note
-				      that some servers (includinng Samba 3)
-				      have a shorter maximum path */
+	/*
+	 * PATH_MAX may be too long - it would presumably be total path,
+	 * but note that some servers (includinng Samba 3) have a shorter
+	 * maximum path.
+	 *
+	 * Instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO.
+	 */
+	buf->f_namelen = PATH_MAX;
 	buf->f_files = 0;	/* undefined */
 	buf->f_ffree = 0;	/* unlimited */
 
-/* BB we could add a second check for a QFS Unix capability bit */
-/* BB FIXME check CIFS_POSIX_EXTENSIONS Unix cap first FIXME BB */
-    if ((pTcon->ses->capabilities & CAP_UNIX) && (CIFS_POSIX_EXTENSIONS &
-			le64_to_cpu(pTcon->fsUnixInfo.Capability)))
-	    rc = CIFSSMBQFSPosixInfo(xid, pTcon, buf);
-
-    /* Only need to call the old QFSInfo if failed
-    on newer one */
-    if (rc)
-	if (pTcon->ses->capabilities & CAP_NT_SMBS)
-		rc = CIFSSMBQFSInfo(xid, pTcon, buf); /* not supported by OS2 */
-
-	/* Some old Windows servers also do not support level 103, retry with
-	   older level one if old server failed the previous call or we
-	   bypassed it because we detected that this was an older LANMAN sess */
+	/*
+	 * We could add a second check for a QFS Unix capability bit
+	 */
+	if ((tcon->ses->capabilities & CAP_UNIX) &&
+	    (CIFS_POSIX_EXTENSIONS & le64_to_cpu(tcon->fsUnixInfo.Capability)))
+		rc = CIFSSMBQFSPosixInfo(xid, tcon, buf);
+
+	/*
+	 * Only need to call the old QFSInfo if failed on newer one,
+	 * e.g. by OS/2.
+	 **/
+	if (rc && (tcon->ses->capabilities & CAP_NT_SMBS))
+		rc = CIFSSMBQFSInfo(xid, tcon, buf);
+
+	/*
+	 * Some old Windows servers also do not support level 103, retry with
+	 * older level one if old server failed the previous call or we
+	 * bypassed it because we detected that this was an older LANMAN sess
+	 */
 	if (rc)
-		rc = SMBOldQFSInfo(xid, pTcon, buf);
-	/* int f_type;
-	   __fsid_t f_fsid;
-	   int f_namelen;  */
-	/* BB get from info in tcon struct at mount time call to QFSAttrInfo */
+		rc = SMBOldQFSInfo(xid, tcon, buf);
+
 	FreeXid(xid);
-	return 0;		/* always return success? what if volume is no
-				   longer available? */
+	return 0;
 }
 
 static int cifs_permission(struct inode *inode, int mask, struct nameidata *nd)

commit 42faad99658eed7ca8bd328ffa4bcb7d78c9bcca
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 24 07:21:56 2008 -0400

    [PATCH] restore sane ->umount_begin() API
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index dbb2cd678bf5..39c2cbdface7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -466,14 +466,11 @@ static struct quotactl_ops cifs_quotactl_ops = {
 };
 #endif
 
-static void cifs_umount_begin(struct vfsmount *vfsmnt, int flags)
+static void cifs_umount_begin(struct super_block *sb)
 {
-	struct cifs_sb_info *cifs_sb;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifsTconInfo *tcon;
 
-	if (!(flags & MNT_FORCE))
-		return;
-	cifs_sb = CIFS_SB(vfsmnt->mnt_sb);
 	if (cifs_sb == NULL)
 		return;
 

commit 78d31a3a87f84cf56004b7bc154831f2ee1186e8
Author: Igor Mammedov <niallain@gmail.com>
Date:   Thu Apr 24 12:56:07 2008 +0400

    cifs: timeout dfs automounts +little fix.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a04b17e5a9d0..dbb2cd678bf5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -471,8 +471,6 @@ static void cifs_umount_begin(struct vfsmount *vfsmnt, int flags)
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *tcon;
 
-	dfs_shrink_umount_helper(vfsmnt);
-
 	if (!(flags & MNT_FORCE))
 		return;
 	cifs_sb = CIFS_SB(vfsmnt->mnt_sb);
@@ -1100,6 +1098,7 @@ exit_cifs(void)
 	cFYI(DBG2, ("exit_cifs"));
 	cifs_proc_clean();
 #ifdef CONFIG_CIFS_DFS_UPCALL
+	cifs_dfs_release_automount_timer();
 	unregister_key_type(&key_type_dns_resolver);
 #endif
 #ifdef CONFIG_CIFS_UPCALL

commit 0a3abcf75bf391fec4e32356ab5ddb8f5d2e6b41
Merge: 70eff55d2d97 101142c37be8
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Feb 15 21:06:08 2008 +0000

    Merge branch 'master' of /pub/scm/linux/kernel/git/torvalds/linux-2.6

commit 6f7e8f376360c789cf84a0321960dcef8bf92aff
Author: Roel Kluin <12o3l@tiscali.nl>
Date:   Tue Feb 12 20:38:10 2008 +0000

    [CIFS] Fix typo in quota operations
    
    Although these experimental operations are not fully implemented, fix the
    typo in the definition of the quotactl operations for cifs.
    
    Signed-off-by: Roel Kluin <12o3l@tiscali.nl>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ff57ad4efe82..29bbf655b99c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -459,7 +459,7 @@ int cifs_xstate_get(struct super_block *sb, struct fs_quota_stat *qstats)
 
 static struct quotactl_ops cifs_quotactl_ops = {
 	.set_xquota	= cifs_xquota_set,
-	.get_xquota	= cifs_xquota_set,
+	.get_xquota	= cifs_xquota_get,
 	.set_xstate	= cifs_xstate_set,
 	.get_xstate	= cifs_xstate_get,
 };

commit 90c81e0b0eda214196cbe4340facbce8cc797ee7
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Feb 12 20:32:36 2008 +0000

    [CIFS] clean up some hard to read ifdefs
    
    Christoph had noticed too many ifdefs in the CIFS code making it
    hard to read.  This patch removes about a quarter of them from
    the C files in cifs by improving a few key ifdefs in the .h files.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index bca6a69aaf20..ff57ad4efe82 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -470,9 +470,7 @@ static void cifs_umount_begin(struct vfsmount *vfsmnt, int flags)
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *tcon;
 
-#ifdef CONFIG_CIFS_DFS_UPCALL
 	dfs_shrink_umount_helper(vfsmnt);
-#endif /* CONFIG CIFS_DFS_UPCALL */
 
 	if (!(flags & MNT_FORCE))
 		return;
@@ -991,9 +989,7 @@ static int __init
 init_cifs(void)
 {
 	int rc = 0;
-#ifdef CONFIG_PROC_FS
 	cifs_proc_init();
-#endif
 /*	INIT_LIST_HEAD(&GlobalServerList);*/	/* BB not implemented yet */
 	INIT_LIST_HEAD(&GlobalSMBSessionList);
 	INIT_LIST_HEAD(&GlobalTreeConnectionList);
@@ -1094,19 +1090,15 @@ init_cifs(void)
  out_destroy_inodecache:
 	cifs_destroy_inodecache();
  out_clean_proc:
-#ifdef CONFIG_PROC_FS
 	cifs_proc_clean();
-#endif
 	return rc;
 }
 
 static void __exit
 exit_cifs(void)
 {
-	cFYI(0, ("exit_cifs"));
-#ifdef CONFIG_PROC_FS
+	cFYI(DBG2, ("exit_cifs"));
 	cifs_proc_clean();
-#endif
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	unregister_key_type(&key_type_dns_resolver);
 #endif

commit ad7a2926b9e53cfb3020d15bdfacacc54e2b63da
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Feb 7 23:25:02 2008 +0000

    [CIFS] reduce checkpatch warnings
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e9f4ec701092..bca6a69aaf20 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -203,9 +203,8 @@ cifs_put_super(struct super_block *sb)
 		return;
 	}
 	rc = cifs_umount(sb, cifs_sb);
-	if (rc) {
+	if (rc)
 		cERROR(1, ("cifs_umount failed with return code %d", rc));
-	}
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	if (cifs_sb->mountdata) {
 		kfree(cifs_sb->mountdata);

commit ce634ab28e7dbcc13ebe6e7bc5bc7de4f8def4c8
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 7 00:15:33 2008 -0800

    iget: stop CIFS from using iget() and read_inode()
    
    Stop the CIFS filesystem from using iget() and read_inode().  Replace
    cifs_read_inode() with cifs_iget(), and call that instead of iget().
    cifs_iget() then uses iget_locked() directly and returns a proper error code
    instead of an inode in the event of an error.
    
    cifs_read_super() now returns any error incurred when getting the root inode
    instead of ENOMEM.
    
    cifs_iget() needs examining.  The comment "can not call macro FreeXid here
    since in a void func" is no longer true.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Steven French <sfrench@us.ibm.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e9f4ec701092..fcc434227691 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -147,10 +147,11 @@ cifs_read_super(struct super_block *sb, void *data,
 #endif
 	sb->s_blocksize = CIFS_MAX_MSGSIZE;
 	sb->s_blocksize_bits = 14;	/* default 2**14 = CIFS_MAX_MSGSIZE */
-	inode = iget(sb, ROOT_I);
+	inode = cifs_iget(sb, ROOT_I);
 
-	if (!inode) {
-		rc = -ENOMEM;
+	if (IS_ERR(inode)) {
+		rc = PTR_ERR(inode);
+		inode = NULL;
 		goto out_no_root;
 	}
 
@@ -520,7 +521,6 @@ static int cifs_remount(struct super_block *sb, int *flags, char *data)
 }
 
 static const struct super_operations cifs_super_ops = {
-	.read_inode = cifs_read_inode,
 	.put_super = cifs_put_super,
 	.statfs = cifs_statfs,
 	.alloc_inode = cifs_alloc_inode,

commit 6d5ae0deb1641bf615eafd8fef64218e10cb2fd0
Author: Igor Mammedov <niallain@gmail.com>
Date:   Fri Jan 25 03:28:31 2008 +0000

    [CIFS] DFS support: provide shrinkable mounts
    
    Signed-off-by: Igor Mammedov <niallain@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 93e107883a61..e9f4ec701092 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -471,6 +471,10 @@ static void cifs_umount_begin(struct vfsmount *vfsmnt, int flags)
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *tcon;
 
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	dfs_shrink_umount_helper(vfsmnt);
+#endif /* CONFIG CIFS_DFS_UPCALL */
+
 	if (!(flags & MNT_FORCE))
 		return;
 	cifs_sb = CIFS_SB(vfsmnt->mnt_sb);

commit e6ab15827eec0bc4444421f7ccf0223de321c708
Author: Igor Mammedov <niallain@gmail.com>
Date:   Fri Jan 11 01:49:48 2008 +0000

    [CIFS] DFS support patchset: Added mountdata
    
    Also cifs_fs_type was made not static for ussage in dfs code.
    
    Signed-off-by: Igor Mammedov <niallain@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 000b4a5d3219..93e107883a61 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -97,6 +97,9 @@ cifs_read_super(struct super_block *sb, void *data,
 {
 	struct inode *inode;
 	struct cifs_sb_info *cifs_sb;
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	int len;
+#endif
 	int rc = 0;
 
 	/* BB should we make this contingent on mount parm? */
@@ -106,6 +109,25 @@ cifs_read_super(struct super_block *sb, void *data,
 	if (cifs_sb == NULL)
 		return -ENOMEM;
 
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	/* copy mount params to sb for use in submounts */
+	/* BB: should we move this after the mount so we
+	 * do not have to do the copy on failed mounts?
+	 * BB: May be it is better to do simple copy before
+	 * complex operation (mount), and in case of fail
+	 * just exit instead of doing mount and attempting
+	 * undo it if this copy fails?*/
+	len = strlen(data);
+	cifs_sb->mountdata = kzalloc(len + 1, GFP_KERNEL);
+	if (cifs_sb->mountdata == NULL) {
+		kfree(sb->s_fs_info);
+		sb->s_fs_info = NULL;
+		return -ENOMEM;
+	}
+	strncpy(cifs_sb->mountdata, data, len + 1);
+	cifs_sb->mountdata[len] = '\0';
+#endif
+
 	rc = cifs_mount(sb, cifs_sb, data, devname);
 
 	if (rc) {
@@ -155,6 +177,12 @@ cifs_read_super(struct super_block *sb, void *data,
 
 out_mount_failed:
 	if (cifs_sb) {
+#ifdef CONFIG_CIFS_DFS_UPCALL
+		if (cifs_sb->mountdata) {
+			kfree(cifs_sb->mountdata);
+			cifs_sb->mountdata = NULL;
+		}
+#endif
 		if (cifs_sb->local_nls)
 			unload_nls(cifs_sb->local_nls);
 		kfree(cifs_sb);
@@ -178,6 +206,13 @@ cifs_put_super(struct super_block *sb)
 	if (rc) {
 		cERROR(1, ("cifs_umount failed with return code %d", rc));
 	}
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	if (cifs_sb->mountdata) {
+		kfree(cifs_sb->mountdata);
+		cifs_sb->mountdata = NULL;
+	}
+#endif
+
 	unload_nls(cifs_sb->local_nls);
 	kfree(cifs_sb);
 	return;
@@ -553,7 +588,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 	return remote_llseek(file, offset, origin);
 }
 
-static struct file_system_type cifs_fs_type = {
+struct file_system_type cifs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "cifs",
 	.get_sb = cifs_get_sb,

commit 6103335de8afa5d780dcd512abe85c696af7b040
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Jan 9 16:21:36 2008 +0000

    [CIFS] DNS name resolution helper upcall for cifs
    
            Adds additional option CIFS_DFS_UPCALL to fs/Kconfig for enabling
            DFS support.  Resolved IP address is saved as a string in the
            key payload.
    
            Igor has a series of related patches that will follow which finish up
            CIFS DFS support
    
    Acked-by: Igor Mammedov <niallain@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 093beaa3900d..000b4a5d3219 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -44,6 +44,7 @@
 #include "cifs_fs_sb.h"
 #include <linux/mm.h>
 #include <linux/key-type.h>
+#include "dns_resolve.h"
 #include "cifs_spnego.h"
 #define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
 
@@ -1014,12 +1015,17 @@ init_cifs(void)
 	rc = register_key_type(&cifs_spnego_key_type);
 	if (rc)
 		goto out_unregister_filesystem;
+#endif
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	rc = register_key_type(&key_type_dns_resolver);
+	if (rc)
+		goto out_unregister_key_type;
 #endif
 	oplockThread = kthread_run(cifs_oplock_thread, NULL, "cifsoplockd");
 	if (IS_ERR(oplockThread)) {
 		rc = PTR_ERR(oplockThread);
 		cERROR(1, ("error %d create oplock thread", rc));
-		goto out_unregister_key_type;
+		goto out_unregister_dfs_key_type;
 	}
 
 	dnotifyThread = kthread_run(cifs_dnotify_thread, NULL, "cifsdnotifyd");
@@ -1033,7 +1039,11 @@ init_cifs(void)
 
  out_stop_oplock_thread:
 	kthread_stop(oplockThread);
+ out_unregister_dfs_key_type:
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	unregister_key_type(&key_type_dns_resolver);
  out_unregister_key_type:
+#endif
 #ifdef CONFIG_CIFS_UPCALL
 	unregister_key_type(&cifs_spnego_key_type);
  out_unregister_filesystem:
@@ -1059,6 +1069,9 @@ exit_cifs(void)
 #ifdef CONFIG_PROC_FS
 	cifs_proc_clean();
 #endif
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	unregister_key_type(&key_type_dns_resolver);
+#endif
 #ifdef CONFIG_CIFS_UPCALL
 	unregister_key_type(&cifs_spnego_key_type);
 #endif

commit cea218054ad277d6c126890213afde07b4eb1602
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Nov 20 23:19:03 2007 +0000

    [CIFS] Fix potential data corruption when writing out cached dirty pages
    
    Fix RedHat bug 329431
    
    The idea here is separate "conscious" from "unconscious" flushes.
    Conscious flushes are those due to a fsync() or close(). Unconscious
    ones are flushes that occur as a side effect of some other operation or
    due to memory pressure.
    
    Currently, when an error occurs during an unconscious flush (ENOSPC or
    EIO), we toss out the page and don't preserve that error to report to
    the user when a conscious flush occurs. If after the unconscious flush,
    there are no more dirty pages for the inode, the conscious flush will
    simply return success even though there were previous errors when writing
    out pages. This can lead to data corruption.
    
    The easiest way to reproduce this is to mount up a CIFS share that's
    very close to being full or where the user is very close to quota. mv
    a file to the share that's slightly larger than the quota allows. The
    writes will all succeed (since they go to pagecache). The mv will do a
    setattr to set the new file's attributes. This calls
    filemap_write_and_wait,
    which will return an error since all of the pages can't be written out.
    Then later, when the flush and release ops occur, there are no more
    dirty pages in pagecache for the file and those operations return 0. mv
    then assumes that the file was written out correctly and deletes the
    original.
    
    CIFS already has a write_behind_rc variable where it stores the results
    from earlier flushes, but that value is only reported in cifs_close.
    Since the VFS ignores the return value from the release operation, this
    isn't helpful. We should be reporting this error during the flush
    operation.
    
    This patch does the following:
    
    1) changes cifs_fsync to use filemap_write_and_wait and cifs_flush and also
    sync to check its return code. If it returns successful, they then check
    the value of write_behind_rc to see if an earlier flush had reported any
    errors. If so, they return that error and clear write_behind_rc.
    
    2) sets write_behind_rc in a few other places where pages are written
    out as a side effect of other operations and the code waits on them.
    
    3) changes cifs_setattr to only call filemap_write_and_wait for
    ATTR_SIZE changes.
    
    4) makes cifs_writepages accurately distinguish between EIO and ENOSPC
    errors when writing out pages.
    
    Some simple testing indicates that the patch works as expected and that
    it fixes the reproduceable known problem.
    
    Acked-by: Dave Kleikamp <shaggy@austin.rr.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 416dc9fe8961..093beaa3900d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -266,6 +266,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->cifsAttrs = 0x20;	/* default */
 	atomic_set(&cifs_inode->inUse, 0);
 	cifs_inode->time = 0;
+	cifs_inode->write_behind_rc = 0;
 	/* Until the file is open and we have gotten oplock
 	info back from the server, can not assume caching of
 	file data or metadata */
@@ -852,7 +853,7 @@ static int cifs_oplock_thread(void *dummyarg)
 	struct cifsTconInfo *pTcon;
 	struct inode *inode;
 	__u16  netfid;
-	int rc;
+	int rc, waitrc = 0;
 
 	set_freezable();
 	do {
@@ -884,9 +885,11 @@ static int cifs_oplock_thread(void *dummyarg)
 					   filemap_fdatawrite(inode->i_mapping);
 					if (CIFS_I(inode)->clientCanCacheRead
 									 == 0) {
-						filemap_fdatawait(inode->i_mapping);
+						waitrc = filemap_fdatawait(inode->i_mapping);
 						invalidate_remote_inode(inode);
 					}
+					if (rc == 0)
+						rc = waitrc;
 				} else
 					rc = 0;
 				/* mutex_unlock(&inode->i_mutex);*/

commit e545937a51fe0cc78cea55752764daabb81ec96d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Nov 3 05:11:06 2007 +0000

    [CIFS] add OIDs for KRB5 and MSKRB5 to ASN1 parsing routines
    
    Also, fix the parser to recognize them and set the secType
    accordingly. Make CIFSSMBNegotiate not error out automatically
    after parsing the securityBlob.
    
    Also thanks to Q (Igor) and Simo for their help on this
    set of kerberos patches (and Dave Howells for help on the
    upcall).
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 94c0f55d7669..416dc9fe8961 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -44,6 +44,7 @@
 #include "cifs_fs_sb.h"
 #include <linux/mm.h>
 #include <linux/key-type.h>
+#include "cifs_spnego.h"
 #define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
 
 #ifdef CONFIG_CIFS_QUOTA

commit 84a15b935481fa651cc6ec60aed015312b67adda
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Nov 3 05:02:24 2007 +0000

    [CIFS] Register and unregister cifs_spnego_key_type on module init/exit
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a6fbea57c4b1..94c0f55d7669 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -43,6 +43,7 @@
 #include "cifs_debug.h"
 #include "cifs_fs_sb.h"
 #include <linux/mm.h>
+#include <linux/key-type.h>
 #define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
 
 #ifdef CONFIG_CIFS_QUOTA
@@ -1005,12 +1006,16 @@ init_cifs(void)
 	rc = register_filesystem(&cifs_fs_type);
 	if (rc)
 		goto out_destroy_request_bufs;
-
+#ifdef CONFIG_CIFS_UPCALL
+	rc = register_key_type(&cifs_spnego_key_type);
+	if (rc)
+		goto out_unregister_filesystem;
+#endif
 	oplockThread = kthread_run(cifs_oplock_thread, NULL, "cifsoplockd");
 	if (IS_ERR(oplockThread)) {
 		rc = PTR_ERR(oplockThread);
 		cERROR(1, ("error %d create oplock thread", rc));
-		goto out_unregister_filesystem;
+		goto out_unregister_key_type;
 	}
 
 	dnotifyThread = kthread_run(cifs_dnotify_thread, NULL, "cifsdnotifyd");
@@ -1024,7 +1029,11 @@ init_cifs(void)
 
  out_stop_oplock_thread:
 	kthread_stop(oplockThread);
+ out_unregister_key_type:
+#ifdef CONFIG_CIFS_UPCALL
+	unregister_key_type(&cifs_spnego_key_type);
  out_unregister_filesystem:
+#endif
 	unregister_filesystem(&cifs_fs_type);
  out_destroy_request_bufs:
 	cifs_destroy_request_bufs();
@@ -1045,6 +1054,9 @@ exit_cifs(void)
 	cFYI(0, ("exit_cifs"));
 #ifdef CONFIG_PROC_FS
 	cifs_proc_clean();
+#endif
+#ifdef CONFIG_CIFS_UPCALL
+	unregister_key_type(&cifs_spnego_key_type);
 #endif
 	unregister_filesystem(&cifs_fs_type);
 	cifs_destroy_inodecache();

commit 2843483d2eb02ad104edbe8b2429fb6a39d25063
Merge: 26790656d7dc a761ac579b89
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Fri Oct 19 12:00:58 2007 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6: (51 commits)
      [CIFS] log better errors on failed mounts
      [CIFS] Return better error when server requires signing but client forbids
      [CIFS] fix typo
      [CIFS] acl support part 4
      [CIFS] Fix minor problems noticed by scan
      [CIFS] fix bad handling of EAGAIN error on kernel_recvmsg in cifs_demultiplex_thread
      [CIFS] build break
      [CIFS] endian fixes
      [CIFS] endian fixes in new acl code
      [CIFS] Fix some endianness problems in new acl code
      [CIFS] missing #endif from a previous patch
      [CIFS] formatting fixes
      [CIFS] Break up unicode_sessetup string functions
      [CIFS] parse server_GUID in SPNEGO negProt response
      [CIFS]
      [CIFS] Fix endian conversion problem in posix mkdir
      [CIFS] fix build break when lanman not enabled
      [CIFS] remove two sparse warnings
      [CIFS] remove compile warnings when debug disabled
      [CIFS] CIFS ACL support part 3
      ...

commit d5d18501090179d557a4ca976d1c30bfaf5de091
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Oct 17 21:31:52 2007 +0000

    [CIFS] Fix minor problems noticed by scan
    
    Coverity scan pointed out some minor possible errors.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index abca6b084ed1..91ba32861c88 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -308,15 +308,15 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 					seq_printf(s, ",domain=%s",
 					   cifs_sb->tcon->ses->domainName);
 			}
+			if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID) ||
+			   !(cifs_sb->tcon->unix_ext))
+				seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
+			if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) ||
+			   !(cifs_sb->tcon->unix_ext))
+				seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
 		}
 		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 			seq_printf(s, ",posixpaths");
-		if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID) ||
-		   !(cifs_sb->tcon->unix_ext))
-			seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
-		if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) ||
-		   !(cifs_sb->tcon->unix_ext))
-			seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
 		seq_printf(s, ",rsize=%d", cifs_sb->rsize);
 		seq_printf(s, ",wsize=%d", cifs_sb->wsize);
 	}

commit 4ba9b9d0ba0a49d91fa6417c7510ee36f48cf957
Author: Christoph Lameter <clameter@sgi.com>
Date:   Tue Oct 16 23:25:51 2007 -0700

    Slab API: remove useless ctor parameter and reorder parameters
    
    Slab constructors currently have a flags parameter that is never used.  And
    the order of the arguments is opposite to other slab functions.  The object
    pointer is placed before the kmem_cache pointer.
    
    Convert
    
            ctor(void *object, struct kmem_cache *s, unsigned long flags)
    
    to
    
            ctor(struct kmem_cache *s, void *object)
    
    throughout the kernel
    
    [akpm@linux-foundation.org: coupla fixes]
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cabb6a55d7dd..ba8f7868cb23 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -704,7 +704,7 @@ const struct file_operations cifs_dir_ops = {
 };
 
 static void
-cifs_init_once(void *inode, struct kmem_cache *cachep, unsigned long flags)
+cifs_init_once(struct kmem_cache *cachep, void *inode)
 {
 	struct cifsInodeInfo *cifsi = inode;
 

commit 297647c21f11dc1449f9bdb1601ae43e951bba0b
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Oct 12 04:11:59 2007 +0000

    [CIFS] CIFS ACL support part 3
    
    Signed-off-by: Shirish Pargaonkar <shirishp@us.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c7c3521aa7cd..abca6b084ed1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -49,10 +49,6 @@
 static struct quotactl_ops cifs_quotactl_ops;
 #endif /* QUOTA */
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-extern struct export_operations cifs_export_ops;
-#endif /* EXPERIMENTAL */
-
 int cifsFYI = 0;
 int cifsERROR = 1;
 int traceSMB = 0;

commit 26f57364d7cdef9d7ebe27c931fff5e4f21ffb1c
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Aug 30 22:09:15 2007 +0000

    [CIFS] formatting cleanup found by checkpatch
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2493cc4f9e7f..c7c3521aa7cd 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -240,9 +240,9 @@ static int cifs_permission(struct inode *inode, int mask, struct nameidata *nd)
 
 	cifs_sb = CIFS_SB(inode->i_sb);
 
-	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)
 		return 0;
-	} else /* file mode might have been restricted at mount time
+	else /* file mode might have been restricted at mount time
 		on the client (above and beyond ACL on servers) for
 		servers which do not support setting and viewing mode bits,
 		so allowing client to check permissions is useful */
@@ -716,7 +716,7 @@ static int
 cifs_init_inodecache(void)
 {
 	cifs_inode_cachep = kmem_cache_create("cifs_inode_cache",
-					      sizeof (struct cifsInodeInfo),
+					      sizeof(struct cifsInodeInfo),
 					      0, (SLAB_RECLAIM_ACCOUNT|
 						SLAB_MEM_SPREAD),
 					      cifs_init_once);
@@ -816,8 +816,8 @@ static int
 cifs_init_mids(void)
 {
 	cifs_mid_cachep = kmem_cache_create("cifs_mpx_ids",
-				sizeof (struct mid_q_entry), 0,
-				SLAB_HWCACHE_ALIGN, NULL);
+					    sizeof(struct mid_q_entry), 0,
+					    SLAB_HWCACHE_ALIGN, NULL);
 	if (cifs_mid_cachep == NULL)
 		return -ENOMEM;
 
@@ -829,8 +829,8 @@ cifs_init_mids(void)
 	}
 
 	cifs_oplock_cachep = kmem_cache_create("cifs_oplock_structs",
-				sizeof (struct oplock_q_entry), 0,
-				SLAB_HWCACHE_ALIGN, NULL);
+					sizeof(struct oplock_q_entry), 0,
+					SLAB_HWCACHE_ALIGN, NULL);
 	if (cifs_oplock_cachep == NULL) {
 		mempool_destroy(cifs_mid_poolp);
 		kmem_cache_destroy(cifs_mid_cachep);
@@ -882,7 +882,8 @@ static int cifs_oplock_thread(void *dummyarg)
 				the call */
 				/* mutex_lock(&inode->i_mutex);*/
 				if (S_ISREG(inode->i_mode)) {
-					rc = filemap_fdatawrite(inode->i_mapping);
+					rc =
+					   filemap_fdatawrite(inode->i_mapping);
 					if (CIFS_I(inode)->clientCanCacheRead
 									 == 0) {
 						filemap_fdatawait(inode->i_mapping);
@@ -907,8 +908,7 @@ static int cifs_oplock_thread(void *dummyarg)
 					    0 /* len */ , 0 /* offset */, 0,
 					    0, LOCKING_ANDX_OPLOCK_RELEASE,
 					    0 /* wait flag */);
-					cFYI(1, 
-					      ("Oplock release rc = %d ", rc));
+					cFYI(1, ("Oplock release rc = %d", rc));
 				}
 			} else
 				spin_unlock(&GlobalMid_Lock);

commit 95ba7362105646523ee712fd252ec2e34ccbec15
Author: Cyrill Gorcunov <gorcunov@gmail.com>
Date:   Fri Aug 24 00:23:36 2007 +0000

    [CIFS] Fix unbalanced call to GetXid/FreeXid
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cabb6a55d7dd..2493cc4f9e7f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -346,7 +346,7 @@ int cifs_xquota_set(struct super_block *sb, int quota_type, qid_t qid,
 	if (pTcon) {
 		cFYI(1, ("set type: 0x%x id: %d", quota_type, qid));
 	} else {
-		return -EIO;
+		rc = -EIO;
 	}
 
 	FreeXid(xid);

commit 20c2df83d25c6a95affe6157a4c9cac4cf5ffaac
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jul 20 10:11:58 2007 +0900

    mm: Remove slab destructors from kmem_cache_create().
    
    Slab destructors were no longer supported after Christoph's
    c59def9f222d44bb7e2f0a559f2906191a0862d7 change. They've been
    BUGs for both slab and slub, and slob never supported them
    either.
    
    This rips out support for the dtor pointer from kmem_cache_create()
    completely and fixes up every single callsite in the kernel (there were
    about 224, not including the slab allocator definitions themselves,
    or the documentation references).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1fd0dc85f53c..cabb6a55d7dd 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -719,7 +719,7 @@ cifs_init_inodecache(void)
 					      sizeof (struct cifsInodeInfo),
 					      0, (SLAB_RECLAIM_ACCOUNT|
 						SLAB_MEM_SPREAD),
-					      cifs_init_once, NULL);
+					      cifs_init_once);
 	if (cifs_inode_cachep == NULL)
 		return -ENOMEM;
 
@@ -748,7 +748,7 @@ cifs_init_request_bufs(void)
 	cifs_req_cachep = kmem_cache_create("cifs_request",
 					    CIFSMaxBufSize +
 					    MAX_CIFS_HDR_SIZE, 0,
-					    SLAB_HWCACHE_ALIGN, NULL, NULL);
+					    SLAB_HWCACHE_ALIGN, NULL);
 	if (cifs_req_cachep == NULL)
 		return -ENOMEM;
 
@@ -776,7 +776,7 @@ cifs_init_request_bufs(void)
 	alloc of large cifs buffers even when page debugging is on */
 	cifs_sm_req_cachep = kmem_cache_create("cifs_small_rq",
 			MAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,
-			NULL, NULL);
+			NULL);
 	if (cifs_sm_req_cachep == NULL) {
 		mempool_destroy(cifs_req_poolp);
 		kmem_cache_destroy(cifs_req_cachep);
@@ -817,7 +817,7 @@ cifs_init_mids(void)
 {
 	cifs_mid_cachep = kmem_cache_create("cifs_mpx_ids",
 				sizeof (struct mid_q_entry), 0,
-				SLAB_HWCACHE_ALIGN, NULL, NULL);
+				SLAB_HWCACHE_ALIGN, NULL);
 	if (cifs_mid_cachep == NULL)
 		return -ENOMEM;
 
@@ -830,7 +830,7 @@ cifs_init_mids(void)
 
 	cifs_oplock_cachep = kmem_cache_create("cifs_oplock_structs",
 				sizeof (struct oplock_q_entry), 0,
-				SLAB_HWCACHE_ALIGN, NULL, NULL);
+				SLAB_HWCACHE_ALIGN, NULL);
 	if (cifs_oplock_cachep == NULL) {
 		mempool_destroy(cifs_mid_poolp);
 		kmem_cache_destroy(cifs_mid_cachep);

commit 1ff8392c32a2645d2665ca779ecb91bb29361c13
Merge: 70b315b0dd38 5bae7ac9feba
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jul 19 00:38:57 2007 +0000

    Merge branch 'master' of /pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            fs/cifs/export.c

commit c18c842b1fdf527717303a4e173cbece7ab2deb8
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Jul 18 23:21:09 2007 +0000

    [CIFS] Allow disabling CIFS Unix Extensions as mount option
    
    Previously the only way to do this was to umount all mounts to that server,
    turn off a proc setting (/proc/fs/cifs/LinuxExtensionsEnabled).
    
    Fixes Samba bugzilla bug number: 4582 (and also 2008)
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index a0a2f3186557..1cebb7e34215 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -316,10 +316,10 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
 			seq_printf(s, ",posixpaths");
 		if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID) ||
-		   !(cifs_sb->tcon->ses->capabilities & CAP_UNIX))
+		   !(cifs_sb->tcon->unix_ext))
 			seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
 		if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) ||
-		   !(cifs_sb->tcon->ses->capabilities & CAP_UNIX))
+		   !(cifs_sb->tcon->unix_ext))
 			seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
 		seq_printf(s, ",rsize=%d", cifs_sb->rsize);
 		seq_printf(s, ",wsize=%d", cifs_sb->wsize);

commit 63135e088a604b955746c51964c195c8d3ebac11
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Jul 17 17:34:02 2007 +0000

    [CIFS] More whitespace/formatting fixes (noticed by checkpatch)
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8ebd887205bb..a0a2f3186557 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -71,16 +71,20 @@ static struct task_struct *dnotifyThread = NULL;
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
-MODULE_PARM_DESC(CIFSMaxBufSize,"Network buffer size (not including header). Default: 16384 Range: 8192 to 130048");
+MODULE_PARM_DESC(CIFSMaxBufSize, "Network buffer size (not including header). "
+				 "Default: 16384 Range: 8192 to 130048");
 unsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;
 module_param(cifs_min_rcv, int, 0);
-MODULE_PARM_DESC(cifs_min_rcv,"Network buffers in pool. Default: 4 Range: 1 to 64");
+MODULE_PARM_DESC(cifs_min_rcv, "Network buffers in pool. Default: 4 Range: "
+				"1 to 64");
 unsigned int cifs_min_small = 30;
 module_param(cifs_min_small, int, 0);
-MODULE_PARM_DESC(cifs_min_small,"Small network buffers in pool. Default: 30 Range: 2 to 256");
+MODULE_PARM_DESC(cifs_min_small, "Small network buffers in pool. Default: 30 "
+				 "Range: 2 to 256");
 unsigned int cifs_max_pending = CIFS_MAX_REQ;
 module_param(cifs_max_pending, int, 0);
-MODULE_PARM_DESC(cifs_max_pending,"Simultaneous requests to server. Default: 50 Range: 2 to 256");
+MODULE_PARM_DESC(cifs_max_pending, "Simultaneous requests to server. "
+				   "Default: 50 Range: 2 to 256");
 
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
@@ -902,7 +906,8 @@ static int cifs_oplock_thread(void *dummyarg)
 					    0 /* len */ , 0 /* offset */, 0,
 					    0, LOCKING_ANDX_OPLOCK_RELEASE,
 					    0 /* wait flag */);
-					cFYI(1,("Oplock release rc = %d ", rc));
+					cFYI(1, 
+					      ("Oplock release rc = %d ", rc));
 				}
 			} else
 				spin_unlock(&GlobalMid_Lock);
@@ -1040,7 +1045,7 @@ init_cifs(void)
 static void __exit
 exit_cifs(void)
 {
-	cFYI(0, ("In unregister ie exit_cifs"));
+	cFYI(0, ("exit_cifs"));
 #ifdef CONFIG_PROC_FS
 	cifs_proc_clean();
 #endif
@@ -1055,7 +1060,8 @@ exit_cifs(void)
 MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");
 MODULE_LICENSE("GPL");	/* combination of LGPL + GPL source behaves as GPL */
 MODULE_DESCRIPTION
-    ("VFS to access servers complying with the SNIA CIFS Specification e.g. Samba and Windows");
+    ("VFS to access servers complying with the SNIA CIFS Specification "
+     "e.g. Samba and Windows");
 MODULE_VERSION(CIFS_VERSION);
 module_init(init_cifs)
 module_exit(exit_cifs)

commit 831441862956fffa17b9801db37e6ea1650b0f69
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jul 17 04:03:35 2007 -0700

    Freezer: make kernel threads nonfreezable by default
    
    Currently, the freezer treats all tasks as freezable, except for the kernel
    threads that explicitly set the PF_NOFREEZE flag for themselves.  This
    approach is problematic, since it requires every kernel thread to either
    set PF_NOFREEZE explicitly, or call try_to_freeze(), even if it doesn't
    care for the freezing of tasks at all.
    
    It seems better to only require the kernel threads that want to or need to
    be frozen to use some freezer-related code and to remove any
    freezer-related code from the other (nonfreezable) kernel threads, which is
    done in this patch.
    
    The patch causes all kernel threads to be nonfreezable by default (ie.  to
    have PF_NOFREEZE set by default) and introduces the set_freezable()
    function that should be called by the freezable kernel threads in order to
    unset PF_NOFREEZE.  It also makes all of the currently freezable kernel
    threads call set_freezable(), so it shouldn't cause any (intentional)
    change of behaviour to appear.  Additionally, it updates documentation to
    describe the freezing of tasks more accurately.
    
    [akpm@linux-foundation.org: build fixes]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8b0cbf4a4ad0..bd0f2f2353ce 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -849,6 +849,7 @@ static int cifs_oplock_thread(void * dummyarg)
 	__u16  netfid;
 	int rc;
 
+	set_freezable();
 	do {
 		if (try_to_freeze()) 
 			continue;

commit 50c2f75388727018c3c357454a247072915a9e3f
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Jul 13 00:33:32 2007 +0000

    [CIFS] whitespace/formatting fixes
    
    This should be the last big batch of whitespace/formatting fixes.
    checkpatch warnings for the cifs directory are down about 90% and
    many of the remaining ones are harder to remove or make the code
    harder to read.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 40f35f0263ac..8ebd887205bb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -95,7 +95,7 @@ cifs_read_super(struct super_block *sb, void *data,
 	struct inode *inode;
 	struct cifs_sb_info *cifs_sb;
 	int rc = 0;
-	
+
 	/* BB should we make this contingent on mount parm? */
 	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
 	sb->s_fs_info = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
@@ -135,7 +135,7 @@ cifs_read_super(struct super_block *sb, void *data,
 		rc = -ENOMEM;
 		goto out_no_root;
 	}
-	
+
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {
 		cFYI(1, ("export ops supported"));
@@ -153,7 +153,7 @@ cifs_read_super(struct super_block *sb, void *data,
 out_mount_failed:
 	if (cifs_sb) {
 		if (cifs_sb->local_nls)
-			unload_nls(cifs_sb->local_nls);	
+			unload_nls(cifs_sb->local_nls);
 		kfree(cifs_sb);
 	}
 	return rc;
@@ -230,7 +230,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 				   longer available? */
 }
 
-static int cifs_permission(struct inode * inode, int mask, struct nameidata *nd)
+static int cifs_permission(struct inode *inode, int mask, struct nameidata *nd)
 {
 	struct cifs_sb_info *cifs_sb;
 
@@ -238,10 +238,10 @@ static int cifs_permission(struct inode * inode, int mask, struct nameidata *nd)
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {
 		return 0;
-	} else /* file mode might have been restricted at mount time 
-		on the client (above and beyond ACL on servers) for  
+	} else /* file mode might have been restricted at mount time
+		on the client (above and beyond ACL on servers) for
 		servers which do not support setting and viewing mode bits,
-		so allowing client to check permissions is useful */ 
+		so allowing client to check permissions is useful */
 		return generic_permission(inode, mask, NULL);
 }
 
@@ -270,7 +270,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->clientCanCacheRead = FALSE;
 	cifs_inode->clientCanCacheAll = FALSE;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
-	
+
 	/* Can not set i_flags here - they get immediately overwritten
 	   to zero by the VFS */
 /*	cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;*/
@@ -317,21 +317,21 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 		if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) ||
 		   !(cifs_sb->tcon->ses->capabilities & CAP_UNIX))
 			seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
-		seq_printf(s, ",rsize=%d",cifs_sb->rsize);
-		seq_printf(s, ",wsize=%d",cifs_sb->wsize);
+		seq_printf(s, ",rsize=%d", cifs_sb->rsize);
+		seq_printf(s, ",wsize=%d", cifs_sb->wsize);
 	}
 	return 0;
 }
 
 #ifdef CONFIG_CIFS_QUOTA
-int cifs_xquota_set(struct super_block * sb, int quota_type, qid_t qid,
-		struct fs_disk_quota * pdquota)
+int cifs_xquota_set(struct super_block *sb, int quota_type, qid_t qid,
+		struct fs_disk_quota *pdquota)
 {
 	int xid;
 	int rc = 0;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifsTconInfo *pTcon;
-	
+
 	if (cifs_sb)
 		pTcon = cifs_sb->tcon;
 	else
@@ -340,7 +340,7 @@ int cifs_xquota_set(struct super_block * sb, int quota_type, qid_t qid,
 
 	xid = GetXid();
 	if (pTcon) {
-		cFYI(1,("set type: 0x%x id: %d",quota_type,qid));		
+		cFYI(1, ("set type: 0x%x id: %d", quota_type, qid));
 	} else {
 		return -EIO;
 	}
@@ -349,8 +349,8 @@ int cifs_xquota_set(struct super_block * sb, int quota_type, qid_t qid,
 	return rc;
 }
 
-int cifs_xquota_get(struct super_block * sb, int quota_type, qid_t qid,
-                struct fs_disk_quota * pdquota)
+int cifs_xquota_get(struct super_block *sb, int quota_type, qid_t qid,
+		    struct fs_disk_quota *pdquota)
 {
 	int xid;
 	int rc = 0;
@@ -364,7 +364,7 @@ int cifs_xquota_get(struct super_block * sb, int quota_type, qid_t qid,
 
 	xid = GetXid();
 	if (pTcon) {
-                cFYI(1,("set type: 0x%x id: %d",quota_type,qid));
+		cFYI(1, ("set type: 0x%x id: %d", quota_type, qid));
 	} else {
 		rc = -EIO;
 	}
@@ -373,9 +373,9 @@ int cifs_xquota_get(struct super_block * sb, int quota_type, qid_t qid,
 	return rc;
 }
 
-int cifs_xstate_set(struct super_block * sb, unsigned int flags, int operation)
+int cifs_xstate_set(struct super_block *sb, unsigned int flags, int operation)
 {
-	int xid; 
+	int xid;
 	int rc = 0;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifsTconInfo *pTcon;
@@ -387,7 +387,7 @@ int cifs_xstate_set(struct super_block * sb, unsigned int flags, int operation)
 
 	xid = GetXid();
 	if (pTcon) {
-                cFYI(1,("flags: 0x%x operation: 0x%x",flags,operation));
+		cFYI(1, ("flags: 0x%x operation: 0x%x", flags, operation));
 	} else {
 		rc = -EIO;
 	}
@@ -396,7 +396,7 @@ int cifs_xstate_set(struct super_block * sb, unsigned int flags, int operation)
 	return rc;
 }
 
-int cifs_xstate_get(struct super_block * sb, struct fs_quota_stat *qstats)
+int cifs_xstate_get(struct super_block *sb, struct fs_quota_stat *qstats)
 {
 	int xid;
 	int rc = 0;
@@ -410,7 +410,7 @@ int cifs_xstate_get(struct super_block * sb, struct fs_quota_stat *qstats)
 	}
 	xid = GetXid();
 	if (pTcon) {
-		cFYI(1,("pqstats %p",qstats));		
+		cFYI(1, ("pqstats %p", qstats));
 	} else {
 		rc = -EIO;
 	}
@@ -427,10 +427,10 @@ static struct quotactl_ops cifs_quotactl_ops = {
 };
 #endif
 
-static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
+static void cifs_umount_begin(struct vfsmount *vfsmnt, int flags)
 {
 	struct cifs_sb_info *cifs_sb;
-	struct cifsTconInfo * tcon;
+	struct cifsTconInfo *tcon;
 
 	if (!(flags & MNT_FORCE))
 		return;
@@ -448,9 +448,8 @@ static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
 
 	/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */
 	/* cancel_notify_requests(tcon); */
-	if (tcon->ses && tcon->ses->server)
-	{
-		cFYI(1,("wake up tasks now - umount begin not complete"));
+	if (tcon->ses && tcon->ses->server) {
+		cFYI(1, ("wake up tasks now - umount begin not complete"));
 		wake_up_all(&tcon->ses->server->request_q);
 		wake_up_all(&tcon->ses->server->response_q);
 		msleep(1); /* yield */
@@ -483,10 +482,11 @@ static const struct super_operations cifs_super_ops = {
 	.statfs = cifs_statfs,
 	.alloc_inode = cifs_alloc_inode,
 	.destroy_inode = cifs_destroy_inode,
-/*	.drop_inode	    = generic_delete_inode, 
-	.delete_inode	= cifs_delete_inode,  *//* Do not need the above two functions     
-   unless later we add lazy close of inodes or unless the kernel forgets to call
-   us with the same number of releases (closes) as opens */
+/*	.drop_inode	    = generic_delete_inode,
+	.delete_inode	= cifs_delete_inode,  */  /* Do not need above two
+	functions unless later we add lazy close of inodes or unless the
+	kernel forgets to call us with the same number of releases (closes)
+	as opens */
 	.show_options = cifs_show_options,
 	.umount_begin   = cifs_umount_begin,
 	.remount_fs = cifs_remount,
@@ -589,11 +589,11 @@ const struct inode_operations cifs_file_inode_ops = {
 	.getxattr = cifs_getxattr,
 	.listxattr = cifs_listxattr,
 	.removexattr = cifs_removexattr,
-#endif 
+#endif
 };
 
 const struct inode_operations cifs_symlink_inode_ops = {
-	.readlink = generic_readlink, 
+	.readlink = generic_readlink,
 	.follow_link = cifs_follow_link,
 	.put_link = cifs_put_link,
 	.permission = cifs_permission,
@@ -605,7 +605,7 @@ const struct inode_operations cifs_symlink_inode_ops = {
 	.getxattr = cifs_getxattr,
 	.listxattr = cifs_listxattr,
 	.removexattr = cifs_removexattr,
-#endif 
+#endif
 };
 
 const struct file_operations cifs_file_ops = {
@@ -631,7 +631,7 @@ const struct file_operations cifs_file_ops = {
 };
 
 const struct file_operations cifs_file_direct_ops = {
-	/* no mmap, no aio, no readv - 
+	/* no mmap, no aio, no readv -
 	   BB reevaluate whether they can be done with directio, no cache */
 	.read = cifs_user_read,
 	.write = cifs_user_write,
@@ -671,7 +671,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 };
 
 const struct file_operations cifs_file_direct_nobrl_ops = {
-	/* no mmap, no aio, no readv - 
+	/* no mmap, no aio, no readv -
 	   BB reevaluate whether they can be done with directio, no cache */
 	.read = cifs_user_read,
 	.write = cifs_user_write,
@@ -696,11 +696,11 @@ const struct file_operations cifs_dir_ops = {
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
-        .ioctl  = cifs_ioctl,
+	.ioctl  = cifs_ioctl,
 };
 
 static void
-cifs_init_once(void *inode, struct kmem_cache * cachep, unsigned long flags)
+cifs_init_once(void *inode, struct kmem_cache *cachep, unsigned long flags)
 {
 	struct cifsInodeInfo *cifsi = inode;
 
@@ -752,7 +752,7 @@ cifs_init_request_bufs(void)
 		cifs_min_rcv = 1;
 	else if (cifs_min_rcv > 64) {
 		cifs_min_rcv = 64;
-		cERROR(1,("cifs_min_rcv set to maximum (64)"));
+		cERROR(1, ("cifs_min_rcv set to maximum (64)"));
 	}
 
 	cifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,
@@ -765,7 +765,7 @@ cifs_init_request_bufs(void)
 	/* MAX_CIFS_SMALL_BUFFER_SIZE bytes is enough for most SMB responses and
 	almost all handle based requests (but not write response, nor is it
 	sufficient for path based requests).  A smaller size would have
-	been more efficient (compacting multiple slab items on one 4k page) 
+	been more efficient (compacting multiple slab items on one 4k page)
 	for the case in which debug was on, but this larger size allows
 	more SMBs to use small buffer alloc and is still much more
 	efficient to alloc 1 per page off the slab compared to 17K (5page)
@@ -844,7 +844,7 @@ cifs_destroy_mids(void)
 	kmem_cache_destroy(cifs_oplock_cachep);
 }
 
-static int cifs_oplock_thread(void * dummyarg)
+static int cifs_oplock_thread(void *dummyarg)
 {
 	struct oplock_q_entry *oplock_item;
 	struct cifsTconInfo *pTcon;
@@ -855,7 +855,7 @@ static int cifs_oplock_thread(void * dummyarg)
 	do {
 		if (try_to_freeze())
 			continue;
-		
+
 		spin_lock(&GlobalMid_Lock);
 		if (list_empty(&GlobalOplock_Q)) {
 			spin_unlock(&GlobalMid_Lock);
@@ -865,7 +865,7 @@ static int cifs_oplock_thread(void * dummyarg)
 			oplock_item = list_entry(GlobalOplock_Q.next,
 				struct oplock_q_entry, qhead);
 			if (oplock_item) {
-				cFYI(1,("found oplock item to write out"));
+				cFYI(1, ("found oplock item to write out"));
 				pTcon = oplock_item->tcon;
 				inode = oplock_item->pinode;
 				netfid = oplock_item->netfid;
@@ -878,7 +878,8 @@ static int cifs_oplock_thread(void * dummyarg)
 				/* mutex_lock(&inode->i_mutex);*/
 				if (S_ISREG(inode->i_mode)) {
 					rc = filemap_fdatawrite(inode->i_mapping);
-					if (CIFS_I(inode)->clientCanCacheRead == 0) {
+					if (CIFS_I(inode)->clientCanCacheRead
+									 == 0) {
 						filemap_fdatawait(inode->i_mapping);
 						invalidate_remote_inode(inode);
 					}
@@ -913,7 +914,7 @@ static int cifs_oplock_thread(void * dummyarg)
 	return 0;
 }
 
-static int cifs_dnotify_thread(void * dummyarg)
+static int cifs_dnotify_thread(void *dummyarg)
 {
 	struct list_head *tmp;
 	struct cifsSesInfo *ses;

commit 7521a3c566dda7bb09576975324fc0a08a79ad14
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Jul 11 18:30:34 2007 +0000

    [CIFS] Fix oops in cifs_create when nfsd server exports cifs mount
    
    nfsd is passing null nameidata (probably the only one doing that)
    on call to create - cifs was missing one check for this.
    
    Note that running nfsd over a cifs mount requires specifying fsid on
    the nfs exports entry and requires mounting cifs with serverino mount
    option.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 17ed7cf750af..40f35f0263ac 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -114,10 +114,6 @@ cifs_read_super(struct super_block *sb, void *data,
 
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-	if (experimEnabled != 0)
-		sb->s_export_op = &cifs_export_ops;
-#endif /* EXPERIMENTAL */
 /*	if (cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
 	    sb->s_blocksize =
 		cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
@@ -139,6 +135,13 @@ cifs_read_super(struct super_block *sb, void *data,
 		rc = -ENOMEM;
 		goto out_no_root;
 	}
+	
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {
+		cFYI(1, ("export ops supported"));
+		sb->s_export_op = &cifs_export_ops;
+	}
+#endif /* EXPERIMENTAL */
 
 	return 0;
 

commit 5ffc4ef45b3b0a57872f631b4e4ceb8ace0d7496
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Fri Jun 1 11:49:19 2007 +0200

    sendfile: remove .sendfile from filesystems that use generic_file_sendfile()
    
    They can use generic_file_splice_read() instead. Since sys_sendfile() now
    prefers that, there should be no change in behaviour.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7c04752b76cb..8b0cbf4a4ad0 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -616,7 +616,7 @@ const struct file_operations cifs_file_ops = {
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
-	.sendfile = generic_file_sendfile,
+	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_POSIX
 	.ioctl	= cifs_ioctl,
@@ -637,7 +637,7 @@ const struct file_operations cifs_file_direct_ops = {
 	.lock = cifs_lock,
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
-	.sendfile = generic_file_sendfile, /* BB removeme BB */
+	.splice_read = generic_file_splice_read,
 #ifdef CONFIG_CIFS_POSIX
 	.ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
@@ -656,7 +656,7 @@ const struct file_operations cifs_file_nobrl_ops = {
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
-	.sendfile = generic_file_sendfile,
+	.splice_read = generic_file_splice_read,
 	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_POSIX
 	.ioctl	= cifs_ioctl,
@@ -676,7 +676,7 @@ const struct file_operations cifs_file_direct_nobrl_ops = {
 	.release = cifs_close,
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
-	.sendfile = generic_file_sendfile, /* BB removeme BB */
+	.splice_read = generic_file_splice_read,
 #ifdef CONFIG_CIFS_POSIX
 	.ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */

commit 790fe579f5006b72dfd2814f9263a73b0b455e81
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Jul 7 19:25:05 2007 +0000

    [CIFS] more whitespace cleanup
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9122ef5c3174..17ed7cf750af 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -98,7 +98,7 @@ cifs_read_super(struct super_block *sb, void *data,
 	
 	/* BB should we make this contingent on mount parm? */
 	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
-	sb->s_fs_info = kzalloc(sizeof(struct cifs_sb_info),GFP_KERNEL);
+	sb->s_fs_info = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
 	cifs_sb = CIFS_SB(sb);
 	if (cifs_sb == NULL)
 		return -ENOMEM;
@@ -117,9 +117,10 @@ cifs_read_super(struct super_block *sb, void *data,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	if (experimEnabled != 0)
 		sb->s_export_op = &cifs_export_ops;
-#endif /* EXPERIMENTAL */	
+#endif /* EXPERIMENTAL */
 /*	if (cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
-	    sb->s_blocksize = cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
+	    sb->s_blocksize =
+		cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
 #ifdef CONFIG_CIFS_QUOTA
 	sb->s_qcop = &cifs_quotactl_ops;
 #endif
@@ -164,10 +165,10 @@ cifs_put_super(struct super_block *sb)
 	cFYI(1, ("In cifs_put_super"));
 	cifs_sb = CIFS_SB(sb);
 	if (cifs_sb == NULL) {
-		cFYI(1,("Empty cifs superblock info passed to unmount"));
+		cFYI(1, ("Empty cifs superblock info passed to unmount"));
 		return;
 	}
-	rc = cifs_umount(sb, cifs_sb); 
+	rc = cifs_umount(sb, cifs_sb);
 	if (rc) {
 		cERROR(1, ("cifs_umount failed with return code %d", rc));
 	}
@@ -180,7 +181,7 @@ static int
 cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct super_block *sb = dentry->d_sb;
-	int xid; 
+	int xid;
 	int rc = -EOPNOTSUPP;
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *pTcon;
@@ -193,7 +194,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_type = CIFS_MAGIC_NUMBER;
 
 	/* instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO */
-	buf->f_namelen = PATH_MAX; /* PATH_MAX may be too long - it would 
+	buf->f_namelen = PATH_MAX; /* PATH_MAX may be too long - it would
 				      presumably be total path, but note
 				      that some servers (includinng Samba 3)
 				      have a shorter maximum path */
@@ -217,8 +218,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	   bypassed it because we detected that this was an older LANMAN sess */
 	if (rc)
 		rc = SMBOldQFSInfo(xid, pTcon, buf);
-	/*     
-	   int f_type;
+	/* int f_type;
 	   __fsid_t f_fsid;
 	   int f_namelen;  */
 	/* BB get from info in tcon struct at mount time call to QFSAttrInfo */

commit 6dc0f87e351142e224b396f29b59527c4b2d834c
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Jul 6 23:13:06 2007 +0000

    [CIFS] whitespace cleanup
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7c04752b76cb..9122ef5c3174 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -64,10 +64,10 @@ unsigned int multiuser_mount = 0;
 unsigned int extended_security = CIFSSEC_DEF;
 /* unsigned int ntlmv2_support = 0; */
 unsigned int sign_CIFS_PDUs = 1;
-extern struct task_struct * oplockThread; /* remove sparse warning */
-struct task_struct * oplockThread = NULL;
+extern struct task_struct *oplockThread; /* remove sparse warning */
+struct task_struct *oplockThread = NULL;
 /* extern struct task_struct * dnotifyThread; remove sparse warning */
-static struct task_struct * dnotifyThread = NULL;
+static struct task_struct *dnotifyThread = NULL;
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
@@ -765,22 +765,22 @@ cifs_init_request_bufs(void)
 	been more efficient (compacting multiple slab items on one 4k page) 
 	for the case in which debug was on, but this larger size allows
 	more SMBs to use small buffer alloc and is still much more
-	efficient to alloc 1 per page off the slab compared to 17K (5page) 
+	efficient to alloc 1 per page off the slab compared to 17K (5page)
 	alloc of large cifs buffers even when page debugging is on */
 	cifs_sm_req_cachep = kmem_cache_create("cifs_small_rq",
-			MAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN, 
+			MAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,
 			NULL, NULL);
 	if (cifs_sm_req_cachep == NULL) {
 		mempool_destroy(cifs_req_poolp);
 		kmem_cache_destroy(cifs_req_cachep);
-		return -ENOMEM;              
+		return -ENOMEM;
 	}
 
 	if (cifs_min_small < 2)
 		cifs_min_small = 2;
 	else if (cifs_min_small > 256) {
 		cifs_min_small = 256;
-		cFYI(1,("cifs_min_small set to maximum (256)"));
+		cFYI(1, ("cifs_min_small set to maximum (256)"));
 	}
 
 	cifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,
@@ -843,14 +843,14 @@ cifs_destroy_mids(void)
 
 static int cifs_oplock_thread(void * dummyarg)
 {
-	struct oplock_q_entry * oplock_item;
+	struct oplock_q_entry *oplock_item;
 	struct cifsTconInfo *pTcon;
-	struct inode * inode;
+	struct inode *inode;
 	__u16  netfid;
 	int rc;
 
 	do {
-		if (try_to_freeze()) 
+		if (try_to_freeze())
 			continue;
 		
 		spin_lock(&GlobalMid_Lock);
@@ -859,17 +859,17 @@ static int cifs_oplock_thread(void * dummyarg)
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(39*HZ);
 		} else {
-			oplock_item = list_entry(GlobalOplock_Q.next, 
+			oplock_item = list_entry(GlobalOplock_Q.next,
 				struct oplock_q_entry, qhead);
 			if (oplock_item) {
-				cFYI(1,("found oplock item to write out")); 
+				cFYI(1,("found oplock item to write out"));
 				pTcon = oplock_item->tcon;
 				inode = oplock_item->pinode;
 				netfid = oplock_item->netfid;
 				spin_unlock(&GlobalMid_Lock);
 				DeleteOplockQEntry(oplock_item);
 				/* can not grab inode sem here since it would
-				deadlock when oplock received on delete 
+				deadlock when oplock received on delete
 				since vfs_unlink holds the i_mutex across
 				the call */
 				/* mutex_lock(&inode->i_mutex);*/
@@ -884,20 +884,21 @@ static int cifs_oplock_thread(void * dummyarg)
 				/* mutex_unlock(&inode->i_mutex);*/
 				if (rc)
 					CIFS_I(inode)->write_behind_rc = rc;
-				cFYI(1,("Oplock flush inode %p rc %d",inode,rc));
-
-				/* releasing a stale oplock after recent reconnection 
-				of smb session using a now incorrect file 
-				handle is not a data integrity issue but do  
-				not bother sending an oplock release if session 
-				to server still is disconnected since oplock 
+				cFYI(1, ("Oplock flush inode %p rc %d",
+					inode, rc));
+
+				/* releasing stale oplock after recent reconnect
+				of smb session using a now incorrect file
+				handle is not a data integrity issue but do
+				not bother sending an oplock release if session
+				to server still is disconnected since oplock
 				already released by the server in that case */
 				if (pTcon->tidStatus != CifsNeedReconnect) {
 				    rc = CIFSSMBLock(0, pTcon, netfid,
-					    0 /* len */ , 0 /* offset */, 0, 
+					    0 /* len */ , 0 /* offset */, 0,
 					    0, LOCKING_ANDX_OPLOCK_RELEASE,
 					    0 /* wait flag */);
-					cFYI(1,("Oplock release rc = %d ",rc));
+					cFYI(1,("Oplock release rc = %d ", rc));
 				}
 			} else
 				spin_unlock(&GlobalMid_Lock);
@@ -924,9 +925,9 @@ static int cifs_dnotify_thread(void * dummyarg)
 		   to be woken up and wakeq so the
 		   thread can wake up and error out */
 		list_for_each(tmp, &GlobalSMBSessionList) {
-			ses = list_entry(tmp, struct cifsSesInfo, 
+			ses = list_entry(tmp, struct cifsSesInfo,
 				cifsSessionList);
-			if (ses && ses->server && 
+			if (ses && ses->server &&
 			     atomic_read(&ses->server->inFlight))
 				wake_up_all(&ses->server->response_q);
 		}
@@ -950,13 +951,13 @@ init_cifs(void)
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	INIT_LIST_HEAD(&GlobalDnotifyReqList);
 	INIT_LIST_HEAD(&GlobalDnotifyRsp_Q);
-#endif	
+#endif
 /*
  *  Initialize Global counters
  */
 	atomic_set(&sesInfoAllocCount, 0);
 	atomic_set(&tconInfoAllocCount, 0);
-	atomic_set(&tcpSesAllocCount,0);
+	atomic_set(&tcpSesAllocCount, 0);
 	atomic_set(&tcpSesReconnectCount, 0);
 	atomic_set(&tconInfoReconnectCount, 0);
 
@@ -977,10 +978,10 @@ init_cifs(void)
 
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
-		cFYI(1,("cifs_max_pending set to min of 2"));
+		cFYI(1, ("cifs_max_pending set to min of 2"));
 	} else if (cifs_max_pending > 256) {
 		cifs_max_pending = 256;
-		cFYI(1,("cifs_max_pending set to max of 256"));
+		cFYI(1, ("cifs_max_pending set to max of 256"));
 	}
 
 	rc = cifs_init_inodecache();
@@ -1002,14 +1003,14 @@ init_cifs(void)
 	oplockThread = kthread_run(cifs_oplock_thread, NULL, "cifsoplockd");
 	if (IS_ERR(oplockThread)) {
 		rc = PTR_ERR(oplockThread);
-		cERROR(1,("error %d create oplock thread", rc));
+		cERROR(1, ("error %d create oplock thread", rc));
 		goto out_unregister_filesystem;
 	}
 
 	dnotifyThread = kthread_run(cifs_dnotify_thread, NULL, "cifsdnotifyd");
 	if (IS_ERR(dnotifyThread)) {
 		rc = PTR_ERR(dnotifyThread);
-		cERROR(1,("error %d create dnotify thread", rc));
+		cERROR(1, ("error %d create dnotify thread", rc));
 		goto out_stop_oplock_thread;
 	}
 
@@ -1048,7 +1049,7 @@ exit_cifs(void)
 }
 
 MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");
-MODULE_LICENSE("GPL");		/* combination of LGPL + GPL source behaves as GPL */
+MODULE_LICENSE("GPL");	/* combination of LGPL + GPL source behaves as GPL */
 MODULE_DESCRIPTION
     ("VFS to access servers complying with the SNIA CIFS Specification e.g. Samba and Windows");
 MODULE_VERSION(CIFS_VERSION);

commit e6985c7f6842fa040d058640e363140ad1730dc5
Author: Akinobu Mita <akinobu.mita@gmail..com>
Date:   Mon Jun 4 16:14:59 2007 +0000

    [CIFS] fix mempool destroy done in wrong order in cifs error path
    
    Slab cache used as memory pool can not be destroyed before the memory
    pool destruction. Because the memory pool still holds some objects and
    kmem_cache_destroy() says "Can't free all objects".
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d38c69b591cf..7c04752b76cb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -825,8 +825,8 @@ cifs_init_mids(void)
 				sizeof (struct oplock_q_entry), 0,
 				SLAB_HWCACHE_ALIGN, NULL, NULL);
 	if (cifs_oplock_cachep == NULL) {
-		kmem_cache_destroy(cifs_mid_cachep);
 		mempool_destroy(cifs_mid_poolp);
+		kmem_cache_destroy(cifs_mid_cachep);
 		return -ENOMEM;
 	}
 

commit a35afb830f8d71ec211531aeb9a621b09a2efb39
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed May 16 22:10:57 2007 -0700

    Remove SLAB_CTOR_CONSTRUCTOR
    
    SLAB_CTOR_CONSTRUCTOR is always specified. No point in checking it.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: Michael Halcrow <mhalcrow@us.ibm.com>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Dave Kleikamp <shaggy@austin.ibm.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Anton Altaparmakov <aia21@cantab.net>
    Cc: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Jan Kara <jack@ucw.cz>
    Cc: David Chinner <dgc@sgi.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8568e100953c..d38c69b591cf 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -701,10 +701,8 @@ cifs_init_once(void *inode, struct kmem_cache * cachep, unsigned long flags)
 {
 	struct cifsInodeInfo *cifsi = inode;
 
-	if (flags & SLAB_CTOR_CONSTRUCTOR) {
-		inode_init_once(&cifsi->vfs_inode);
-		INIT_LIST_HEAD(&cifsi->lockList);
-	}
+	inode_init_once(&cifsi->vfs_inode);
+	INIT_LIST_HEAD(&cifsi->lockList);
 }
 
 static int

commit 50953fe9e00ebbeffa032a565ab2f08312d51a87
Author: Christoph Lameter <clameter@sgi.com>
Date:   Sun May 6 14:50:16 2007 -0700

    slab allocators: Remove SLAB_DEBUG_INITIAL flag
    
    I have never seen a use of SLAB_DEBUG_INITIAL.  It is only supported by
    SLAB.
    
    I think its purpose was to have a callback after an object has been freed
    to verify that the state is the constructor state again?  The callback is
    performed before each freeing of an object.
    
    I would think that it is much easier to check the object state manually
    before the free.  That also places the check near the code object
    manipulation of the object.
    
    Also the SLAB_DEBUG_INITIAL callback is only performed if the kernel was
    compiled with SLAB debugging on.  If there would be code in a constructor
    handling SLAB_DEBUG_INITIAL then it would have to be conditional on
    SLAB_DEBUG otherwise it would just be dead code.  But there is no such code
    in the kernel.  I think SLUB_DEBUG_INITIAL is too problematic to make real
    use of, difficult to understand and there are easier ways to accomplish the
    same effect (i.e.  add debug code before kfree).
    
    There is a related flag SLAB_CTOR_VERIFY that is frequently checked to be
    clear in fs inode caches.  Remove the pointless checks (they would even be
    pointless without removeal of SLAB_DEBUG_INITIAL) from the fs constructors.
    
    This is the last slab flag that SLUB did not support.  Remove the check for
    unimplemented flags from SLUB.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5036dae09cd7..8568e100953c 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -701,8 +701,7 @@ cifs_init_once(void *inode, struct kmem_cache * cachep, unsigned long flags)
 {
 	struct cifsInodeInfo *cifsi = inode;
 
-	if ((flags & (SLAB_CTOR_VERIFY | SLAB_CTOR_CONSTRUCTOR)) ==
-	    SLAB_CTOR_CONSTRUCTOR) {
+	if (flags & SLAB_CTOR_CONSTRUCTOR) {
 		inode_init_once(&cifsi->vfs_inode);
 		INIT_LIST_HEAD(&cifsi->lockList);
 	}

commit 4523cc3044d1bc7fcf3d7fee75d62bc76b8e1abb
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Apr 30 20:13:06 2007 +0000

    [CIFS] UID/GID override on CIFS mounts to Samba
    
    When CIFS Unix Extensions are negotiated we get the Unix uid and gid
    owners of the file from the server (on the Unix Query Path Info
    levels), but if the server's uids don't match the client uid's users
    were having to disable the Unix Extensions (which turned off features
    they still wanted).   The changeset patch allows users to override uid
    and/or gid for file/directory owner with a default uid and/or gid
    specified at mount (as is often done when mounting from Linux cifs
    client to Windows server).  This changeset also displays the uid
    and gid used by default in /proc/mounts (if applicable).
    
    Also cleans up code by adding some of the missing spaces after
    "if" keywords per-kernel style guidelines (as suggested by Randy Dunlap
    when he reviewed the patch).
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index dd03e680f8f8..5036dae09cd7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -100,7 +100,7 @@ cifs_read_super(struct super_block *sb, void *data,
 	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
 	sb->s_fs_info = kzalloc(sizeof(struct cifs_sb_info),GFP_KERNEL);
 	cifs_sb = CIFS_SB(sb);
-	if(cifs_sb == NULL)
+	if (cifs_sb == NULL)
 		return -ENOMEM;
 
 	rc = cifs_mount(sb, cifs_sb, data, devname);
@@ -115,10 +115,10 @@ cifs_read_super(struct super_block *sb, void *data,
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-	if(experimEnabled != 0)
+	if (experimEnabled != 0)
 		sb->s_export_op = &cifs_export_ops;
 #endif /* EXPERIMENTAL */	
-/*	if(cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
+/*	if (cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
 	    sb->s_blocksize = cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
 #ifdef CONFIG_CIFS_QUOTA
 	sb->s_qcop = &cifs_quotactl_ops;
@@ -147,8 +147,8 @@ cifs_read_super(struct super_block *sb, void *data,
 		iput(inode);
 
 out_mount_failed:
-	if(cifs_sb) {
-		if(cifs_sb->local_nls)
+	if (cifs_sb) {
+		if (cifs_sb->local_nls)
 			unload_nls(cifs_sb->local_nls);	
 		kfree(cifs_sb);
 	}
@@ -163,7 +163,7 @@ cifs_put_super(struct super_block *sb)
 
 	cFYI(1, ("In cifs_put_super"));
 	cifs_sb = CIFS_SB(sb);
-	if(cifs_sb == NULL) {
+	if (cifs_sb == NULL) {
 		cFYI(1,("Empty cifs superblock info passed to unmount"));
 		return;
 	}
@@ -208,14 +208,14 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
     /* Only need to call the old QFSInfo if failed
     on newer one */
-    if(rc)
-	if(pTcon->ses->capabilities & CAP_NT_SMBS)
+    if (rc)
+	if (pTcon->ses->capabilities & CAP_NT_SMBS)
 		rc = CIFSSMBQFSInfo(xid, pTcon, buf); /* not supported by OS2 */
 
 	/* Some old Windows servers also do not support level 103, retry with
 	   older level one if old server failed the previous call or we
 	   bypassed it because we detected that this was an older LANMAN sess */
-	if(rc)
+	if (rc)
 		rc = SMBOldQFSInfo(xid, pTcon, buf);
 	/*     
 	   int f_type;
@@ -301,11 +301,19 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 				if (cifs_sb->tcon->ses->userName)
 					seq_printf(s, ",username=%s",
 					   cifs_sb->tcon->ses->userName);
-				if(cifs_sb->tcon->ses->domainName)
+				if (cifs_sb->tcon->ses->domainName)
 					seq_printf(s, ",domain=%s",
 					   cifs_sb->tcon->ses->domainName);
 			}
 		}
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)
+			seq_printf(s, ",posixpaths");
+		if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID) ||
+		   !(cifs_sb->tcon->ses->capabilities & CAP_UNIX))
+			seq_printf(s, ",uid=%d", cifs_sb->mnt_uid);
+		if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) ||
+		   !(cifs_sb->tcon->ses->capabilities & CAP_UNIX))
+			seq_printf(s, ",gid=%d", cifs_sb->mnt_gid);
 		seq_printf(s, ",rsize=%d",cifs_sb->rsize);
 		seq_printf(s, ",wsize=%d",cifs_sb->wsize);
 	}
@@ -321,14 +329,14 @@ int cifs_xquota_set(struct super_block * sb, int quota_type, qid_t qid,
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifsTconInfo *pTcon;
 	
-	if(cifs_sb)
+	if (cifs_sb)
 		pTcon = cifs_sb->tcon;
 	else
 		return -EIO;
 
 
 	xid = GetXid();
-	if(pTcon) {
+	if (pTcon) {
 		cFYI(1,("set type: 0x%x id: %d",quota_type,qid));		
 	} else {
 		return -EIO;
@@ -346,13 +354,13 @@ int cifs_xquota_get(struct super_block * sb, int quota_type, qid_t qid,
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifsTconInfo *pTcon;
 
-	if(cifs_sb)
+	if (cifs_sb)
 		pTcon = cifs_sb->tcon;
 	else
 		return -EIO;
 
 	xid = GetXid();
-	if(pTcon) {
+	if (pTcon) {
                 cFYI(1,("set type: 0x%x id: %d",quota_type,qid));
 	} else {
 		rc = -EIO;
@@ -369,13 +377,13 @@ int cifs_xstate_set(struct super_block * sb, unsigned int flags, int operation)
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifsTconInfo *pTcon;
 
-	if(cifs_sb)
+	if (cifs_sb)
 		pTcon = cifs_sb->tcon;
 	else
 		return -EIO;
 
 	xid = GetXid();
-	if(pTcon) {
+	if (pTcon) {
                 cFYI(1,("flags: 0x%x operation: 0x%x",flags,operation));
 	} else {
 		rc = -EIO;
@@ -392,13 +400,13 @@ int cifs_xstate_get(struct super_block * sb, struct fs_quota_stat *qstats)
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 	struct cifsTconInfo *pTcon;
 
-	if(cifs_sb) {
+	if (cifs_sb) {
 		pTcon = cifs_sb->tcon;
 	} else {
 		return -EIO;
 	}
 	xid = GetXid();
-	if(pTcon) {
+	if (pTcon) {
 		cFYI(1,("pqstats %p",qstats));		
 	} else {
 		rc = -EIO;
@@ -424,11 +432,11 @@ static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
 	if (!(flags & MNT_FORCE))
 		return;
 	cifs_sb = CIFS_SB(vfsmnt->mnt_sb);
-	if(cifs_sb == NULL)
+	if (cifs_sb == NULL)
 		return;
 
 	tcon = cifs_sb->tcon;
-	if(tcon == NULL)
+	if (tcon == NULL)
 		return;
 	down(&tcon->tconSem);
 	if (atomic_read(&tcon->useCount) == 1)
@@ -437,7 +445,7 @@ static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
 
 	/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */
 	/* cancel_notify_requests(tcon); */
-	if(tcon->ses && tcon->ses->server)
+	if (tcon->ses && tcon->ses->server)
 	{
 		cFYI(1,("wake up tasks now - umount begin not complete"));
 		wake_up_all(&tcon->ses->server->request_q);
@@ -723,7 +731,7 @@ cifs_destroy_inodecache(void)
 static int
 cifs_init_request_bufs(void)
 {
-	if(CIFSMaxBufSize < 8192) {
+	if (CIFSMaxBufSize < 8192) {
 	/* Buffer size can not be smaller than 2 * PATH_MAX since maximum
 	Unicode path name has to fit in any SMB/CIFS path based frames */
 		CIFSMaxBufSize = 8192;
@@ -740,7 +748,7 @@ cifs_init_request_bufs(void)
 	if (cifs_req_cachep == NULL)
 		return -ENOMEM;
 
-	if(cifs_min_rcv < 1)
+	if (cifs_min_rcv < 1)
 		cifs_min_rcv = 1;
 	else if (cifs_min_rcv > 64) {
 		cifs_min_rcv = 64;
@@ -750,7 +758,7 @@ cifs_init_request_bufs(void)
 	cifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,
 						  cifs_req_cachep);
 
-	if(cifs_req_poolp == NULL) {
+	if (cifs_req_poolp == NULL) {
 		kmem_cache_destroy(cifs_req_cachep);
 		return -ENOMEM;
 	}
@@ -771,7 +779,7 @@ cifs_init_request_bufs(void)
 		return -ENOMEM;              
 	}
 
-	if(cifs_min_small < 2)
+	if (cifs_min_small < 2)
 		cifs_min_small = 2;
 	else if (cifs_min_small > 256) {
 		cifs_min_small = 256;
@@ -781,7 +789,7 @@ cifs_init_request_bufs(void)
 	cifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,
 						     cifs_sm_req_cachep);
 
-	if(cifs_sm_req_poolp == NULL) {
+	if (cifs_sm_req_poolp == NULL) {
 		mempool_destroy(cifs_req_poolp);
 		kmem_cache_destroy(cifs_req_cachep);
 		kmem_cache_destroy(cifs_sm_req_cachep);
@@ -811,7 +819,7 @@ cifs_init_mids(void)
 
 	/* 3 is a reasonable minimum number of simultaneous operations */
 	cifs_mid_poolp = mempool_create_slab_pool(3, cifs_mid_cachep);
-	if(cifs_mid_poolp == NULL) {
+	if (cifs_mid_poolp == NULL) {
 		kmem_cache_destroy(cifs_mid_cachep);
 		return -ENOMEM;
 	}
@@ -849,14 +857,14 @@ static int cifs_oplock_thread(void * dummyarg)
 			continue;
 		
 		spin_lock(&GlobalMid_Lock);
-		if(list_empty(&GlobalOplock_Q)) {
+		if (list_empty(&GlobalOplock_Q)) {
 			spin_unlock(&GlobalMid_Lock);
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(39*HZ);
 		} else {
 			oplock_item = list_entry(GlobalOplock_Q.next, 
 				struct oplock_q_entry, qhead);
-			if(oplock_item) {
+			if (oplock_item) {
 				cFYI(1,("found oplock item to write out")); 
 				pTcon = oplock_item->tcon;
 				inode = oplock_item->pinode;
@@ -870,7 +878,7 @@ static int cifs_oplock_thread(void * dummyarg)
 				/* mutex_lock(&inode->i_mutex);*/
 				if (S_ISREG(inode->i_mode)) {
 					rc = filemap_fdatawrite(inode->i_mapping);
-					if(CIFS_I(inode)->clientCanCacheRead == 0) {
+					if (CIFS_I(inode)->clientCanCacheRead == 0) {
 						filemap_fdatawait(inode->i_mapping);
 						invalidate_remote_inode(inode);
 					}
@@ -887,7 +895,7 @@ static int cifs_oplock_thread(void * dummyarg)
 				not bother sending an oplock release if session 
 				to server still is disconnected since oplock 
 				already released by the server in that case */
-				if(pTcon->tidStatus != CifsNeedReconnect) {
+				if (pTcon->tidStatus != CifsNeedReconnect) {
 				    rc = CIFSSMBLock(0, pTcon, netfid,
 					    0 /* len */ , 0 /* offset */, 0, 
 					    0, LOCKING_ANDX_OPLOCK_RELEASE,
@@ -921,7 +929,7 @@ static int cifs_dnotify_thread(void * dummyarg)
 		list_for_each(tmp, &GlobalSMBSessionList) {
 			ses = list_entry(tmp, struct cifsSesInfo, 
 				cifsSessionList);
-			if(ses && ses->server && 
+			if (ses && ses->server && 
 			     atomic_read(&ses->server->inFlight))
 				wake_up_all(&ses->server->response_q);
 		}
@@ -970,10 +978,10 @@ init_cifs(void)
 	rwlock_init(&GlobalSMBSeslock);
 	spin_lock_init(&GlobalMid_Lock);
 
-	if(cifs_max_pending < 2) {
+	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
 		cFYI(1,("cifs_max_pending set to min of 2"));
-	} else if(cifs_max_pending > 256) {
+	} else if (cifs_max_pending > 256) {
 		cifs_max_pending = 256;
 		cFYI(1,("cifs_max_pending set to max of 256"));
 	}

commit c33f8d32746db12ba353b0a05b25f7893a0ac344
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Apr 2 18:47:20 2007 +0000

    [CIFS] Remove unnecessary checks
    
    file->f_path.dentry or file->f_path.dentry.d_inode can't be NULL since at
    least ten years, similar for all but very few arguments passed in from the
    VFS.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index faba4d69fe91..dd03e680f8f8 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -529,8 +529,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 		/* some applications poll for the file length in this strange
 		   way so we must seek to end on non-oplocked files by
 		   setting the revalidate time to zero */
-		if(file->f_path.dentry->d_inode)		
-			CIFS_I(file->f_path.dentry->d_inode)->time = 0;
+		CIFS_I(file->f_path.dentry->d_inode)->time = 0;
 
 		retval = cifs_revalidate(file->f_path.dentry);
 		if (retval < 0)

commit 99ee4dbd7c99c27129a8e2026003a7680878345f
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Feb 27 05:35:17 2007 +0000

    [CIFS] Remove some unused functions/declarations
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4dab32a1489a..faba4d69fe91 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -66,8 +66,8 @@ unsigned int extended_security = CIFSSEC_DEF;
 unsigned int sign_CIFS_PDUs = 1;
 extern struct task_struct * oplockThread; /* remove sparse warning */
 struct task_struct * oplockThread = NULL;
-extern struct task_struct * dnotifyThread; /* remove sparse warning */
-struct task_struct * dnotifyThread = NULL;
+/* extern struct task_struct * dnotifyThread; remove sparse warning */
+static struct task_struct * dnotifyThread = NULL;
 static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);

commit 35c11fdda7b556db73631dc17dc1723624690dfb
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Feb 27 05:09:35 2007 +0000

    [CIFS] cifs export operations
    
    For nfsd to work over cifs mounts (which presumably makes sense when trying
    to reexport mounts to windows, network appliances or Samba servers to nfs
    clients via nfs server).
    
    This is the first stage of that enablement, marked experimental and turned
    off by default.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index bc2c0ac27169..4dab32a1489a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -1,7 +1,7 @@
 /*
  *   fs/cifs/cifsfs.c
  *
- *   Copyright (C) International Business Machines  Corp., 2002,2004
+ *   Copyright (C) International Business Machines  Corp., 2002,2007
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
  *   Common Internet FileSystem (CIFS) client
@@ -47,7 +47,11 @@
 
 #ifdef CONFIG_CIFS_QUOTA
 static struct quotactl_ops cifs_quotactl_ops;
-#endif
+#endif /* QUOTA */
+
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+extern struct export_operations cifs_export_ops;
+#endif /* EXPERIMENTAL */
 
 int cifsFYI = 0;
 int cifsERROR = 1;
@@ -110,6 +114,10 @@ cifs_read_super(struct super_block *sb, void *data,
 
 	sb->s_magic = CIFS_MAGIC_NUMBER;
 	sb->s_op = &cifs_super_ops;
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+	if(experimEnabled != 0)
+		sb->s_export_op = &cifs_export_ops;
+#endif /* EXPERIMENTAL */	
 /*	if(cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
 	    sb->s_blocksize = cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
 #ifdef CONFIG_CIFS_QUOTA

commit 004c46b9e588edf549a39c5db54e37ebd0b3b3ad
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Feb 17 04:34:13 2007 +0000

    [CIFS] One line missing from previous commit
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 887c89b43bd8..bc2c0ac27169 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -287,6 +287,7 @@ cifs_show_options(struct seq_file *s, struct vfsmount *m)
 
 	if (cifs_sb) {
 		if (cifs_sb->tcon) {
+/* BB add prepath to mount options displayed */
 			seq_printf(s, ",unc=%s", cifs_sb->tcon->treeName);
 			if (cifs_sb->tcon->ses) {
 				if (cifs_sb->tcon->ses->userName)

commit 1b2b212603ceb47d60aff571dcfffc846fcfa336
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Feb 17 04:30:54 2007 +0000

    [CIFS] mtime bounces from local to remote when cifs nocmtime i_flags overwritten
    
    atime flag was also overwritten. Noticed by Shirish when he was debugging
    an atime problem.  Should help performance a bit too.
    
    cifs should be getting time stamps from the server (that was the original
    intent too)
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e8287c4c6eb3..887c89b43bd8 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -91,8 +91,9 @@ cifs_read_super(struct super_block *sb, void *data,
 	struct inode *inode;
 	struct cifs_sb_info *cifs_sb;
 	int rc = 0;
-
-	sb->s_flags |= MS_NODIRATIME; /* and probably even noatime */
+	
+	/* BB should we make this contingent on mount parm? */
+	sb->s_flags |= MS_NODIRATIME | MS_NOATIME;
 	sb->s_fs_info = kzalloc(sizeof(struct cifs_sb_info),GFP_KERNEL);
 	cifs_sb = CIFS_SB(sb);
 	if(cifs_sb == NULL)
@@ -258,7 +259,10 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->clientCanCacheRead = FALSE;
 	cifs_inode->clientCanCacheAll = FALSE;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
-	cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;
+	
+	/* Can not set i_flags here - they get immediately overwritten
+	   to zero by the VFS */
+/*	cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;*/
 	INIT_LIST_HEAD(&cifs_inode->openFileList);
 	return &cifs_inode->vfs_inode;
 }

commit ee9b6d61a2a43c5952eb43283f8db284a4e70b8a
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Mon Feb 12 00:55:41 2007 -0800

    [PATCH] Mark struct super_operations const
    
    This patch is inspired by Arjan's "Patch series to mark struct
    file_operations and struct inode_operations const".
    
    Compile tested with gcc & sparse.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 481e84f5f361..e8287c4c6eb3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -64,7 +64,7 @@ extern struct task_struct * oplockThread; /* remove sparse warning */
 struct task_struct * oplockThread = NULL;
 extern struct task_struct * dnotifyThread; /* remove sparse warning */
 struct task_struct * dnotifyThread = NULL;
-static struct super_operations cifs_super_ops; 
+static const struct super_operations cifs_super_ops;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
 MODULE_PARM_DESC(CIFSMaxBufSize,"Network buffer size (not including header). Default: 16384 Range: 8192 to 130048");
@@ -453,7 +453,7 @@ static int cifs_remount(struct super_block *sb, int *flags, char *data)
 	return 0;
 }
 
-static struct super_operations cifs_super_ops = {
+static const struct super_operations cifs_super_ops = {
 	.read_inode = cifs_read_inode,
 	.put_super = cifs_put_super,
 	.statfs = cifs_statfs,

commit 754661f143e70d66eae6c48532ca245aa05dec0e
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:38 2007 -0800

    [PATCH] mark struct inode_operations const 1
    
    Many struct inode_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 93ef09971d2f..481e84f5f361 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -533,7 +533,7 @@ static struct file_system_type cifs_fs_type = {
 	.kill_sb = kill_anon_super,
 	/*  .fs_flags */
 };
-struct inode_operations cifs_dir_inode_ops = {
+const struct inode_operations cifs_dir_inode_ops = {
 	.create = cifs_create,
 	.lookup = cifs_lookup,
 	.getattr = cifs_getattr,
@@ -555,7 +555,7 @@ struct inode_operations cifs_dir_inode_ops = {
 #endif
 };
 
-struct inode_operations cifs_file_inode_ops = {
+const struct inode_operations cifs_file_inode_ops = {
 /*	revalidate:cifs_revalidate, */
 	.setattr = cifs_setattr,
 	.getattr = cifs_getattr, /* do we need this anymore? */
@@ -569,7 +569,7 @@ struct inode_operations cifs_file_inode_ops = {
 #endif 
 };
 
-struct inode_operations cifs_symlink_inode_ops = {
+const struct inode_operations cifs_symlink_inode_ops = {
 	.readlink = generic_readlink, 
 	.follow_link = cifs_follow_link,
 	.put_link = cifs_put_link,

commit 030e9d8147491a9d2fe1b67882a3720fcf8b95f7
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Feb 1 04:27:59 2007 +0000

    [CIFS] lseek polling returned stale EOF
    
    Fixes Samba bug 4362
    
    Discovered by Jeremy Allison
    
    Clipper database polls on EOF via lseek and can get stale EOF
    when file is open on different client
    
    Signed-off-by: Jeremy Allison <jra@samba.org>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 10c90294cd18..93ef09971d2f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -511,7 +511,15 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 {
 	/* origin == SEEK_END => we must revalidate the cached file length */
 	if (origin == SEEK_END) {
-		int retval = cifs_revalidate(file->f_path.dentry);
+		int retval;
+
+		/* some applications poll for the file length in this strange
+		   way so we must seek to end on non-oplocked files by
+		   setting the revalidate time to zero */
+		if(file->f_path.dentry->d_inode)		
+			CIFS_I(file->f_path.dentry->d_inode)->time = 0;
+
+		retval = cifs_revalidate(file->f_path.dentry);
 		if (retval < 0)
 			return (loff_t)retval;
 	}

commit e6a002964cf376c2acb1d67c4741044dcd3b1622
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Dec 8 02:36:48 2006 -0800

    [PATCH] cifs: change uses of f_{dentry, vfsmnt} to use f_path
    
    Change all the uses of f_{dentry,vfsmnt} to f_path.{dentry,mnt} in the cifs
    filesystem.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 71bc87a37fc1..10c90294cd18 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -498,7 +498,7 @@ cifs_get_sb(struct file_system_type *fs_type,
 static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				   unsigned long nr_segs, loff_t pos)
 {
-	struct inode *inode = iocb->ki_filp->f_dentry->d_inode;
+	struct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;
 	ssize_t written;
 
 	written = generic_file_aio_write(iocb, iov, nr_segs, pos);
@@ -511,7 +511,7 @@ static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 {
 	/* origin == SEEK_END => we must revalidate the cached file length */
 	if (origin == SEEK_END) {
-		int retval = cifs_revalidate(file->f_dentry);
+		int retval = cifs_revalidate(file->f_path.dentry);
 		if (retval < 0)
 			return (loff_t)retval;
 	}

commit 7dfb71030f7636a0d65200158113c37764552f93
Author: Nigel Cunningham <ncunningham@linuxmail.org>
Date:   Wed Dec 6 20:34:23 2006 -0800

    [PATCH] Add include/linux/freezer.h and move definitions from sched.h
    
    Move process freezing functions from include/linux/sched.h to freezer.h, so
    that modifications to the freezer or the kernel configuration don't require
    recompiling just about everything.
    
    [akpm@osdl.org: fix ueagle driver]
    Signed-off-by: Nigel Cunningham <nigel@suspend2.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e6b5866e5001..71bc87a37fc1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -34,6 +34,7 @@
 #include <linux/mempool.h>
 #include <linux/delay.h>
 #include <linux/kthread.h>
+#include <linux/freezer.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE

commit e18b890bb0881bbab6f4f1a6cd20d9c60d66b003
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:33:20 2006 -0800

    [PATCH] slab: remove kmem_cache_t
    
    Replace all uses of kmem_cache_t with struct kmem_cache.
    
    The patch was generated using the following script:
    
            #!/bin/sh
            #
            # Replace one string by another in all the kernel sources.
            #
    
            set -e
    
            for file in `find * -name "*.c" -o -name "*.h"|xargs grep -l $1`; do
                    quilt add $file
                    sed -e "1,\$s/$1/$2/g" $file >/tmp/$$
                    mv /tmp/$$ $file
                    quilt refresh
            done
    
    The script was run like this
    
            sh replace kmem_cache_t "struct kmem_cache"
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 84168629cea3..e6b5866e5001 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -81,7 +81,7 @@ extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
-extern kmem_cache_t *cifs_oplock_cachep;
+extern struct kmem_cache *cifs_oplock_cachep;
 
 static int
 cifs_read_super(struct super_block *sb, void *data,
@@ -232,11 +232,11 @@ static int cifs_permission(struct inode * inode, int mask, struct nameidata *nd)
 		return generic_permission(inode, mask, NULL);
 }
 
-static kmem_cache_t *cifs_inode_cachep;
-static kmem_cache_t *cifs_req_cachep;
-static kmem_cache_t *cifs_mid_cachep;
-kmem_cache_t *cifs_oplock_cachep;
-static kmem_cache_t *cifs_sm_req_cachep;
+static struct kmem_cache *cifs_inode_cachep;
+static struct kmem_cache *cifs_req_cachep;
+static struct kmem_cache *cifs_mid_cachep;
+struct kmem_cache *cifs_oplock_cachep;
+static struct kmem_cache *cifs_sm_req_cachep;
 mempool_t *cifs_sm_req_poolp;
 mempool_t *cifs_req_poolp;
 mempool_t *cifs_mid_poolp;
@@ -668,7 +668,7 @@ const struct file_operations cifs_dir_ops = {
 };
 
 static void
-cifs_init_once(void *inode, kmem_cache_t * cachep, unsigned long flags)
+cifs_init_once(void *inode, struct kmem_cache * cachep, unsigned long flags)
 {
 	struct cifsInodeInfo *cifsi = inode;
 

commit e94b1766097d53e6f3ccfb36c8baa562ffeda3fc
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:33:17 2006 -0800

    [PATCH] slab: remove SLAB_KERNEL
    
    SLAB_KERNEL is an alias of GFP_KERNEL.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 84976cdbe713..84168629cea3 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -245,7 +245,7 @@ static struct inode *
 cifs_alloc_inode(struct super_block *sb)
 {
 	struct cifsInodeInfo *cifs_inode;
-	cifs_inode = kmem_cache_alloc(cifs_inode_cachep, SLAB_KERNEL);
+	cifs_inode = kmem_cache_alloc(cifs_inode_cachep, GFP_KERNEL);
 	if (!cifs_inode)
 		return NULL;
 	cifs_inode->cifsAttrs = 0x20;	/* default */

commit 12e36b2f41b6cbc67386fcb9c59c32a3e2033905
Merge: 1baaf0b424fe 1a4e15a04ec6
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Oct 13 08:09:29 2006 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6: (27 commits)
      [CIFS] Missing flags2 for DFS
      [CIFS] Workaround incomplete byte length returned by some
      [CIFS] cifs Kconfig: don't select CONNECTOR
      [CIFS] Level 1 QPathInfo needed for proper OS2 support
      [CIFS] fix typo in previous patch
      [CIFS] Fix old DOS time conversion to handle timezone
      [CIFS] Do not need to adjust for Jan/Feb for leap day
      [CIFS] Fix leaps year calculation for years after 2100
      [CIFS] readdir (ffirst) enablement of accurate timestamps from legacy servers
      [CIFS] Fix compiler warning with previous patch
      [CIFS] Fix typo
      [CIFS] Allow for 15 minute TZs (e.g. Nepal) and be more explicit about
      [CIFS] Fix readdir of large directories for backlevel servers
      [CIFS] Allow LANMAN21 support even in both POSIX non-POSIX path
      [CIFS] Make use of newer QFSInfo dependent on capability bit instead of
      [CIFS] Do not send newer QFSInfo to legacy servers which can not support it
      [CIFS] Fix typo in name of new cifs_show_stats
      [CIFS] Rename server time zone field
      [CIFS] Handle legacy servers which return undefined time zone
      [CIFS] CIFS support for /proc/<pid>/mountstats part 1
      ...
    
    Manual conflict resolution in fs/cifs/connect.c

commit ee0b3e671baff681d69fbf0db33b47603c0a8280
Author: Badari Pulavarty <pbadari@us.ibm.com>
Date:   Sat Sep 30 23:28:47 2006 -0700

    [PATCH] Remove readv/writev methods and use aio_read/aio_write instead
    
    This patch removes readv() and writev() methods and replaces them with
    aio_read()/aio_write() methods.
    
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5abb42a7c53e..c00c654f2e11 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -480,18 +480,6 @@ cifs_get_sb(struct file_system_type *fs_type,
 	return simple_set_mnt(mnt, sb);
 }
 
-static ssize_t cifs_file_writev(struct file *file, const struct iovec *iov,
-				unsigned long nr_segs, loff_t *ppos)
-{
-	struct inode *inode = file->f_dentry->d_inode;
-	ssize_t written;
-
-	written = generic_file_writev(file, iov, nr_segs, ppos);
-	if (!CIFS_I(inode)->clientCanCacheAll)
-		filemap_fdatawrite(inode->i_mapping);
-	return written;
-}
-
 static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				   unsigned long nr_segs, loff_t pos)
 {
@@ -577,8 +565,6 @@ struct inode_operations cifs_symlink_inode_ops = {
 const struct file_operations cifs_file_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
-	.readv = generic_file_readv,
-	.writev = cifs_file_writev,
 	.aio_read = generic_file_aio_read,
 	.aio_write = cifs_file_aio_write,
 	.open = cifs_open,
@@ -620,8 +606,6 @@ const struct file_operations cifs_file_direct_ops = {
 const struct file_operations cifs_file_nobrl_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
-	.readv = generic_file_readv,
-	.writev = cifs_file_writev,
 	.aio_read = generic_file_aio_read,
 	.aio_write = cifs_file_aio_write,
 	.open = cifs_open,

commit 027445c37282bc1ed26add45e573ad2d3e4860a5
Author: Badari Pulavarty <pbadari@us.ibm.com>
Date:   Sat Sep 30 23:28:46 2006 -0700

    [PATCH] Vectorize aio_read/aio_write fileop methods
    
    This patch vectorizes aio_read() and aio_write() methods to prepare for
    collapsing all aio & vectored operations into one interface - which is
    aio_read()/aio_write().
    
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Michael Holzheu <HOLZHEU@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 22bcf4d7e7ae..5abb42a7c53e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -492,13 +492,13 @@ static ssize_t cifs_file_writev(struct file *file, const struct iovec *iov,
 	return written;
 }
 
-static ssize_t cifs_file_aio_write(struct kiocb *iocb, const char __user *buf,
-				   size_t count, loff_t pos)
+static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
+				   unsigned long nr_segs, loff_t pos)
 {
 	struct inode *inode = iocb->ki_filp->f_dentry->d_inode;
 	ssize_t written;
 
-	written = generic_file_aio_write(iocb, buf, count, pos);
+	written = generic_file_aio_write(iocb, iov, nr_segs, pos);
 	if (!CIFS_I(inode)->clientCanCacheAll)
 		filemap_fdatawrite(inode->i_mapping);
 	return written;

commit de7ed55dbb2f2c44be669d56c4adf28cbffb26ce
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 30 13:25:52 2006 +0000

    [CIFS] Make use of newer QFSInfo dependent on capability bit instead of
    whether we negotiated legacy lanman dialect so we do not keep retrying
    for mount to WindowsME
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d6d226addde2..43364361276e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -199,7 +199,7 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
     /* Only need to call the old QFSInfo if failed
     on newer one */
     if(rc)
-	if((pTcon->ses->flags & CIFS_SES_LANMAN) == 0)
+	if(pTcon->ses->capabilities & CAP_NT_SMBS)
 		rc = CIFSSMBQFSInfo(xid, pTcon, buf); /* not supported by OS2 */
 
 	/* Some old Windows servers also do not support level 103, retry with

commit 9ac00b7d96045fa3ce573e0ad5cdc0350ad8e1d2
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 30 04:13:17 2006 +0000

    [CIFS] Do not send newer QFSInfo to legacy servers which can not support it
    
    Fix dialect negotiation to save off when we have negotiated lanman.
    This allows us to avoid sending some somewhat newer requests that the server
    can not handle and go directly to the older version (infolevel) of the same
    call. Make sure we try to negotiate a level which allows us to get the
    server OS (which we check so we can detect Win9x vs. other legacy servers
    and eventually work around the Win9x DOS time bug (they reverse date/time
    fields).
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ca53720fa5b1..d6d226addde2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -199,10 +199,12 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
     /* Only need to call the old QFSInfo if failed
     on newer one */
     if(rc)
-	rc = CIFSSMBQFSInfo(xid, pTcon, buf);
+	if((pTcon->ses->flags & CIFS_SES_LANMAN) == 0)
+		rc = CIFSSMBQFSInfo(xid, pTcon, buf); /* not supported by OS2 */
 
-	/* Old Windows servers do not support level 103, retry with level 
-	   one if old server failed the previous call */ 
+	/* Some old Windows servers also do not support level 103, retry with
+	   older level one if old server failed the previous call or we
+	   bypassed it because we detected that this was an older LANMAN sess */
 	if(rc)
 		rc = SMBOldQFSInfo(xid, pTcon, buf);
 	/*     

commit f46d3e11903e452924ef2996aa9aca2aae4427e2
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 30 01:08:55 2006 +0000

    [CIFS] Fix typo in name of new cifs_show_stats
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e7641f9a13bb..ca53720fa5b1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -465,7 +465,7 @@ static struct super_operations cifs_super_ops = {
 	.umount_begin   = cifs_umount_begin,
 	.remount_fs = cifs_remount,
 #ifdef CONFIG_CIFS_STATS2
-	.cifs_show_stats,
+	.show_stats = cifs_show_stats,
 #endif
 };
 

commit 175ec9e11cf18f8373b32f7a33e75a4cf7ce25e3
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 30 01:07:38 2006 +0000

    [CIFS] Rename server time zone field
    
    Server time zone is not really a time zone, rather a time adjustement
    in seconds.
    
    CC: Guenter Kukkukk <linux@kukkukk.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7ecfcbf31e55..e7641f9a13bb 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -465,7 +465,7 @@ static struct super_operations cifs_super_ops = {
 	.umount_begin   = cifs_umount_begin,
 	.remount_fs = cifs_remount,
 #ifdef CONFIG_CIFS_STATS2
-	cifs_show_stats,
+	.cifs_show_stats,
 #endif
 };
 

commit bf97d28711e2dc4dc947faa6477cd1b36b91a2da
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Sep 28 21:34:06 2006 +0000

    [CIFS] CIFS support for /proc/<pid>/mountstats part 1
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 51e888fcef2d..7ecfcbf31e55 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -437,6 +437,14 @@ static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
 	return;
 }
 
+#ifdef CONFIG_CIFS_STATS2
+static int cifs_show_stats(struct seq_file *s, struct vfsmount *mnt)
+{
+	/* BB FIXME */
+	return 0;
+}
+#endif
+
 static int cifs_remount(struct super_block *sb, int *flags, char *data)
 {
 	*flags |= MS_NODIRATIME;
@@ -456,6 +464,9 @@ static struct super_operations cifs_super_ops = {
 	.show_options = cifs_show_options,
 	.umount_begin   = cifs_umount_begin,
 	.remount_fs = cifs_remount,
+#ifdef CONFIG_CIFS_STATS2
+	cifs_show_stats,
+#endif
 };
 
 static int

commit e33c74d06e2b46a5f187ec7f60248da774c84e72
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Sep 28 20:35:48 2006 +0000

    [CIFS] Fix build break
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index cd17d4b78173..51e888fcef2d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -63,6 +63,7 @@ extern struct task_struct * oplockThread; /* remove sparse warning */
 struct task_struct * oplockThread = NULL;
 extern struct task_struct * dnotifyThread; /* remove sparse warning */
 struct task_struct * dnotifyThread = NULL;
+static struct super_operations cifs_super_ops; 
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
 MODULE_PARM_DESC(CIFSMaxBufSize,"Network buffer size (not including header). Default: 16384 Range: 8192 to 130048");

commit 2cd646a2d1d5e0e46aa4bb55b1847b0cb35bd855
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Sep 28 19:43:08 2006 +0000

    [CIFS] Remove static and unused symbols
    
    Most cases of the ones found by Shaggy by
            "make namespacecheck"
    could be removed or made static
    
    Ack: Dave Kleikamp <shaggy@austin.ibm.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f5ba41132488..cd17d4b78173 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -442,7 +442,7 @@ static int cifs_remount(struct super_block *sb, int *flags, char *data)
 	return 0;
 }
 
-struct super_operations cifs_super_ops = {
+static struct super_operations cifs_super_ops = {
 	.read_inode = cifs_read_inode,
 	.put_super = cifs_put_super,
 	.statfs = cifs_statfs,
@@ -930,7 +930,7 @@ init_cifs(void)
 #ifdef CONFIG_PROC_FS
 	cifs_proc_init();
 #endif
-	INIT_LIST_HEAD(&GlobalServerList);	/* BB not implemented yet */
+/*	INIT_LIST_HEAD(&GlobalServerList);*/	/* BB not implemented yet */
 	INIT_LIST_HEAD(&GlobalSMBSessionList);
 	INIT_LIST_HEAD(&GlobalTreeConnectionList);
 	INIT_LIST_HEAD(&GlobalOplock_Q);
@@ -958,6 +958,7 @@ init_cifs(void)
 	GlobalCurrentXid = 0;
 	GlobalTotalActiveXid = 0;
 	GlobalMaxActiveXid = 0;
+	memset(Local_System_Name, 0, 15);
 	rwlock_init(&GlobalSMBSeslock);
 	spin_lock_init(&GlobalMid_Lock);
 

commit ba52de123d454b57369f291348266d86f4b35070
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Wed Sep 27 01:50:49 2006 -0700

    [PATCH] inode-diet: Eliminate i_blksize from the inode structure
    
    This eliminates the i_blksize field from struct inode.  Filesystems that want
    to provide a per-inode st_blksize can do so by providing their own getattr
    routine instead of using the generic_fillattr() function.
    
    Note that some filesystems were providing pretty much random (and incorrect)
    values for i_blksize.
    
    [bunk@stusta.de: cleanup]
    [akpm@osdl.org: generic_fillattr() fix]
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 4197a5043f13..22bcf4d7e7ae 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -253,7 +253,6 @@ cifs_alloc_inode(struct super_block *sb)
 	file data or metadata */
 	cifs_inode->clientCanCacheRead = FALSE;
 	cifs_inode->clientCanCacheAll = FALSE;
-	cifs_inode->vfs_inode.i_blksize = CIFS_MAX_MSGSIZE;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
 	cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;
 	INIT_LIST_HEAD(&cifs_inode->openFileList);

commit 1a1d92c10dd24bbdc28b3d6e2d03ec199dd3a65b
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Sep 27 01:49:40 2006 -0700

    [PATCH] Really ignore kmem_cache_destroy return value
    
    * Rougly half of callers already do it by not checking return value
    * Code in drivers/acpi/osl.c does the following to be sure:
    
            (void)kmem_cache_destroy(cache);
    
    * Those who check it printk something, however, slab_error already printed
      the name of failed cache.
    * XFS BUGs on failed kmem_cache_destroy which is not the decision
      low-level filesystem driver should make. Converted to ignore.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c3ef1c0d0e68..4197a5043f13 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -699,8 +699,7 @@ cifs_init_inodecache(void)
 static void
 cifs_destroy_inodecache(void)
 {
-	if (kmem_cache_destroy(cifs_inode_cachep))
-		printk(KERN_WARNING "cifs_inode_cache: error freeing\n");
+	kmem_cache_destroy(cifs_inode_cachep);
 }
 
 static int
@@ -778,13 +777,9 @@ static void
 cifs_destroy_request_bufs(void)
 {
 	mempool_destroy(cifs_req_poolp);
-	if (kmem_cache_destroy(cifs_req_cachep))
-		printk(KERN_WARNING
-		       "cifs_destroy_request_cache: error not all structures were freed\n");
+	kmem_cache_destroy(cifs_req_cachep);
 	mempool_destroy(cifs_sm_req_poolp);
-	if (kmem_cache_destroy(cifs_sm_req_cachep))
-		printk(KERN_WARNING
-		      "cifs_destroy_request_cache: cifs_small_rq free error\n");
+	kmem_cache_destroy(cifs_sm_req_cachep);
 }
 
 static int
@@ -819,13 +814,8 @@ static void
 cifs_destroy_mids(void)
 {
 	mempool_destroy(cifs_mid_poolp);
-	if (kmem_cache_destroy(cifs_mid_cachep))
-		printk(KERN_WARNING
-		       "cifs_destroy_mids: error not all structures were freed\n");
-
-	if (kmem_cache_destroy(cifs_oplock_cachep))
-		printk(KERN_WARNING
-		       "error not all oplock structures were freed\n");
+	kmem_cache_destroy(cifs_mid_cachep);
+	kmem_cache_destroy(cifs_oplock_cachep);
 }
 
 static int cifs_oplock_thread(void * dummyarg)

commit 0889a9441d98af7951c5377647413d79c84c9efa
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Sep 23 22:11:07 2006 +0000

    CIFS: Use SEEK_END instead of hardcoded value
    
    Signed-off-by: Josef 'Jeff' Sipek <jeffpc@josefsipek.net>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c3ef1c0d0e68..f5ba41132488 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -508,7 +508,7 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const char __user *buf,
 static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
 {
 	/* origin == SEEK_END => we must revalidate the cached file length */
-	if (origin == 2) {
+	if (origin == SEEK_END) {
 		int retval = cifs_revalidate(file->f_dentry);
 		if (retval < 0)
 			return (loff_t)retval;

commit b8c06a2ab68661bf841e21003f4447f8d422aed3
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Sep 22 01:14:52 2006 +0000

    [CIFS] statfs for cifs unix extensions no longer experimental
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3cd750029be2..c3ef1c0d0e68 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -189,7 +189,6 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_files = 0;	/* undefined */
 	buf->f_ffree = 0;	/* unlimited */
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 /* BB we could add a second check for a QFS Unix capability bit */
 /* BB FIXME check CIFS_POSIX_EXTENSIONS Unix cap first FIXME BB */
     if ((pTcon->ses->capabilities & CAP_UNIX) && (CIFS_POSIX_EXTENSIONS &
@@ -199,7 +198,6 @@ cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
     /* Only need to call the old QFSInfo if failed
     on newer one */
     if(rc)
-#endif /* CIFS_EXPERIMENTAL */
 	rc = CIFSSMBQFSInfo(xid, pTcon, buf);
 
 	/* Old Windows servers do not support level 103, retry with level 

commit 3a5ff61c18659443f76bad6cf06f60103046de5d
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Jul 14 22:37:11 2006 +0000

    [CIFS] Do not time out posix brl requests when using new posix setfileinfo
    request and do not time out slow requests to a server that is still responding
    well to other threads
    
    Suggested by jra of Samba team
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>
    (cherry picked from 89b57148115479eef074b8d3f86c4c86c96ac969 commit)

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c28ede599946..3cd750029be2 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -402,7 +402,6 @@ static struct quotactl_ops cifs_quotactl_ops = {
 };
 #endif
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
 {
 	struct cifs_sb_info *cifs_sb;
@@ -422,7 +421,7 @@ static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
 		tcon->tidStatus = CifsExiting;
 	up(&tcon->tconSem);
 
-	/* cancel_brl_requests(tcon); */
+	/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */
 	/* cancel_notify_requests(tcon); */
 	if(tcon->ses && tcon->ses->server)
 	{
@@ -438,7 +437,6 @@ static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
 
 	return;
 }
-#endif	
 
 static int cifs_remount(struct super_block *sb, int *flags, char *data)
 {
@@ -457,9 +455,7 @@ struct super_operations cifs_super_ops = {
    unless later we add lazy close of inodes or unless the kernel forgets to call
    us with the same number of releases (closes) as opens */
 	.show_options = cifs_show_options,
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.umount_begin   = cifs_umount_begin,
-#endif
 	.remount_fs = cifs_remount,
 };
 

commit f17a2686b11453680e9662ef8bdc8d948d0dce18
Merge: 01f7e67367f7 f40c56285529
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jun 27 18:31:57 2006 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sfrench/cifs-2.6: (25 commits)
      [CIFS] Fix authentication choice so we do not force NTLMv2 unless the
      [CIFS] Fix alignment of unicode strings in previous patch
      [CIFS] Fix allocation of buffers for new session setup routine to allow
      [CIFS] Remove calls to to take f_owner.lock
      [CIFS] remove some redundant null pointer checks
      [CIFS] Fix compile warning when CONFIG_CIFS_EXPERIMENTAL is off
      [CIFS] Enable sec flags on mount for cifs (part one)
      [CIFS] Fix suspend/resume problem which causes EIO on subsequent access to
      [CIFS] fix minor compile warning when config_cifs_weak_security is off
      [CIFS] NTLMv2 support part 5
      [CIFS] Add support for readdir to legacy servers
      [CIFS] NTLMv2 support part 4
      [CIFS] NTLMv2 support part 3
      [CIFS] NTLMv2 support part 2
      [CIFS] Fix mask so can set new cifs security flags properly
      CIFS] Support for older servers which require plaintext passwords - part 2
      [CIFS] Support for older servers which require plaintext passwords
      [CIFS] Fix mapping of old SMB return code Invalid Net Name so it is
      [CIFS] Missing brace
      [CIFS] Do not overwrite aops
      ...

commit bbe5d235ee201705530a7153b57e141cd77d818b
Merge: 189acaaef81b dfd8317d3340
Author: Steve French <sfrench@us.ibm.com>
Date:   Sun Jun 25 15:57:32 2006 +0000

    Merge with /pub/scm/linux/kernel/git/torvalds/linux-2.6.git

commit 816724e65c72a90a44fbad0ef0b59b186c85fa90
Merge: 70ac4385a13f d384ea691fe4
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jun 24 08:41:41 2006 -0400

    Merge branch 'master' of /home/trondmy/kernel/linux-2.6/
    
    Conflicts:
    
            fs/nfs/inode.c
            fs/super.c
    
    Fix conflicts between patch 'NFS: Split fs/nfs/inode.c' and patch
    'VFS: Permit filesystem to override root dentry on mount'

commit 726c334223180e3c0197cc980a432681370d4baf
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jun 23 02:02:58 2006 -0700

    [PATCH] VFS: Permit filesystem to perform statfs with a known root dentry
    
    Give the statfs superblock operation a dentry pointer rather than a superblock
    pointer.
    
    This complements the get_sb() patch.  That reduced the significance of
    sb->s_root, allowing NFS to place a fake root there.  However, NFS does
    require a dentry to use as a target for the statfs operation.  This permits
    the root in the vfsmount to be used instead.
    
    linux/mount.h has been added where necessary to make allyesconfig build
    successfully.
    
    Interest has also been expressed for use with the FUSE and XFS filesystems.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Nathan Scott <nathans@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 08b35801dfed..7520f4687158 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -166,8 +166,9 @@ cifs_put_super(struct super_block *sb)
 }
 
 static int
-cifs_statfs(struct super_block *sb, struct kstatfs *buf)
+cifs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
+	struct super_block *sb = dentry->d_sb;
 	int xid; 
 	int rc = -EOPNOTSUPP;
 	struct cifs_sb_info *cifs_sb;

commit 454e2398be9b9fa30433fccc548db34d19aa9958
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jun 23 02:02:57 2006 -0700

    [PATCH] VFS: Permit filesystem to override root dentry on mount
    
    Extend the get_sb() filesystem operation to take an extra argument that
    permits the VFS to pass in the target vfsmount that defines the mountpoint.
    
    The filesystem is then required to manually set the superblock and root dentry
    pointers.  For most filesystems, this should be done with simple_set_mnt()
    which will set the superblock pointer and then set the root dentry to the
    superblock's s_root (as per the old default behaviour).
    
    The get_sb() op now returns an integer as there's now no need to return the
    superblock pointer.
    
    This patch permits a superblock to be implicitly shared amongst several mount
    points, such as can be done with NFS to avoid potential inode aliasing.  In
    such a case, simple_set_mnt() would not be called, and instead the mnt_root
    and mnt_sb would be set directly.
    
    The patch also makes the following changes:
    
     (*) the get_sb_*() convenience functions in the core kernel now take a vfsmount
         pointer argument and return an integer, so most filesystems have to change
         very little.
    
     (*) If one of the convenience function is not used, then get_sb() should
         normally call simple_set_mnt() to instantiate the vfsmount. This will
         always return 0, and so can be tail-called from get_sb().
    
     (*) generic_shutdown_super() now calls shrink_dcache_sb() to clean up the
         dcache upon superblock destruction rather than shrink_dcache_anon().
    
         This is required because the superblock may now have multiple trees that
         aren't actually bound to s_root, but that still need to be cleaned up. The
         currently called functions assume that the whole tree is rooted at s_root,
         and that anonymous dentries are not the roots of trees which results in
         dentries being left unculled.
    
         However, with the way NFS superblock sharing are currently set to be
         implemented, these assumptions are violated: the root of the filesystem is
         simply a dummy dentry and inode (the real inode for '/' may well be
         inaccessible), and all the vfsmounts are rooted on anonymous[*] dentries
         with child trees.
    
         [*] Anonymous until discovered from another tree.
    
     (*) The documentation has been adjusted, including the additional bit of
         changing ext2_* into foo_* in the documentation.
    
    [akpm@osdl.org: convert ipath_fs, do other stuff]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Nathan Scott <nathans@sgi.com>
    Cc: Roland Dreier <rolandd@cisco.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c262d8874ce9..08b35801dfed 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -460,9 +460,9 @@ struct super_operations cifs_super_ops = {
 	.remount_fs = cifs_remount,
 };
 
-static struct super_block *
+static int
 cifs_get_sb(struct file_system_type *fs_type,
-	    int flags, const char *dev_name, void *data)
+	    int flags, const char *dev_name, void *data, struct vfsmount *mnt)
 {
 	int rc;
 	struct super_block *sb = sget(fs_type, NULL, set_anon_super, NULL);
@@ -470,7 +470,7 @@ cifs_get_sb(struct file_system_type *fs_type,
 	cFYI(1, ("Devname: %s flags: %d ", dev_name, flags));
 
 	if (IS_ERR(sb))
-		return sb;
+		return PTR_ERR(sb);
 
 	sb->s_flags = flags;
 
@@ -478,10 +478,10 @@ cifs_get_sb(struct file_system_type *fs_type,
 	if (rc) {
 		up_write(&sb->s_umount);
 		deactivate_super(sb);
-		return ERR_PTR(rc);
+		return rc;
 	}
 	sb->s_flags |= MS_ACTIVE;
-	return sb;
+	return simple_set_mnt(mnt, sb);
 }
 
 static ssize_t cifs_file_writev(struct file *file, const struct iovec *iov,

commit 0fd1ffe0633b4b039b343b753598e6df435e034d
Author: Pavel Machek <pavel@suse.de>
Date:   Tue Jun 13 21:31:39 2006 +0000

    [CIFS] Fix suspend/resume problem which causes EIO on subsequent access to
    the mount.
    
    Signed-off-by: Pavel Machek <pavel@suse.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 700570522b23..fb7c11c2c913 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -905,7 +905,7 @@ static int cifs_dnotify_thread(void * dummyarg)
 	struct cifsSesInfo *ses;
 
 	do {
-		if(try_to_freeze())
+		if (try_to_freeze())
 			continue;
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(15*HZ);

commit 8b512d9a88875affe584bb3d2a7a235f84343b9e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 9 09:34:18 2006 -0400

    VFS: Remove dependency of ->umount_begin() call on MNT_FORCE
    
    Allow filesystems to decide to perform pre-umount processing whether or not
    MNT_FORCE is set.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c262d8874ce9..3fdc2258f447 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -402,12 +402,14 @@ static struct quotactl_ops cifs_quotactl_ops = {
 #endif
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-static void cifs_umount_begin(struct super_block * sblock)
+static void cifs_umount_begin(struct vfsmount * vfsmnt, int flags)
 {
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo * tcon;
 
-	cifs_sb = CIFS_SB(sblock);
+	if (!(flags & MNT_FORCE))
+		return;
+	cifs_sb = CIFS_SB(vfsmnt->mnt_sb);
 	if(cifs_sb == NULL)
 		return;
 

commit 3979877e5606ecc58c5a31bd0078c6d80ba9cbe7
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed May 31 22:40:51 2006 +0000

    [CIFS] Support for setting up SMB sessions to legacy lanman servers

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index c262d8874ce9..700570522b23 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -56,8 +56,8 @@ unsigned int experimEnabled = 0;
 unsigned int linuxExtEnabled = 1;
 unsigned int lookupCacheEnabled = 1;
 unsigned int multiuser_mount = 0;
-unsigned int extended_security = 0;
-unsigned int ntlmv2_support = 0;
+unsigned int extended_security = CIFSSEC_DEF;
+/* unsigned int ntlmv2_support = 0; */
 unsigned int sign_CIFS_PDUs = 1;
 extern struct task_struct * oplockThread; /* remove sparse warning */
 struct task_struct * oplockThread = NULL;

commit 45af7a0f2ebad1304cab956e15f0b37318226fcd
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Apr 21 22:52:25 2006 +0000

    [CIFS] Use the kthread_ API instead of opencoding lots of hairy code for kernel
    thread creation and teardown.
    
    It does not move the cifsd thread handling to kthread due to problems
    found in testing with wakeup of threads blocked in the socket peek api,
    but the other cifs kernel threads now use kthread.
    Also cleanup cifs_init to properly unwind when thread creation fails.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d4b713e5affb..c262d8874ce9 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -33,6 +33,7 @@
 #include <linux/vfs.h>
 #include <linux/mempool.h>
 #include <linux/delay.h>
+#include <linux/kthread.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE
@@ -75,9 +76,6 @@ unsigned int cifs_max_pending = CIFS_MAX_REQ;
 module_param(cifs_max_pending, int, 0);
 MODULE_PARM_DESC(cifs_max_pending,"Simultaneous requests to server. Default: 50 Range: 2 to 256");
 
-static DECLARE_COMPLETION(cifs_oplock_exited);
-static DECLARE_COMPLETION(cifs_dnotify_exited);
-
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
@@ -841,10 +839,6 @@ static int cifs_oplock_thread(void * dummyarg)
 	__u16  netfid;
 	int rc;
 
-	daemonize("cifsoplockd");
-	allow_signal(SIGTERM);
-
-	oplockThread = current;
 	do {
 		if (try_to_freeze()) 
 			continue;
@@ -900,9 +894,9 @@ static int cifs_oplock_thread(void * dummyarg)
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(1);  /* yield in case q were corrupt */
 		}
-	} while(!signal_pending(current));
-	oplockThread = NULL;
-	complete_and_exit (&cifs_oplock_exited, 0);
+	} while (!kthread_should_stop());
+
+	return 0;
 }
 
 static int cifs_dnotify_thread(void * dummyarg)
@@ -910,10 +904,6 @@ static int cifs_dnotify_thread(void * dummyarg)
 	struct list_head *tmp;
 	struct cifsSesInfo *ses;
 
-	daemonize("cifsdnotifyd");
-	allow_signal(SIGTERM);
-
-	dnotifyThread = current;
 	do {
 		if(try_to_freeze())
 			continue;
@@ -931,8 +921,9 @@ static int cifs_dnotify_thread(void * dummyarg)
 				wake_up_all(&ses->server->response_q);
 		}
 		read_unlock(&GlobalSMBSeslock);
-	} while(!signal_pending(current));
-	complete_and_exit (&cifs_dnotify_exited, 0);
+	} while (!kthread_should_stop());
+
+	return 0;
 }
 
 static int __init
@@ -982,32 +973,48 @@ init_cifs(void)
 	}
 
 	rc = cifs_init_inodecache();
-	if (!rc) {
-		rc = cifs_init_mids();
-		if (!rc) {
-			rc = cifs_init_request_bufs();
-			if (!rc) {
-				rc = register_filesystem(&cifs_fs_type);
-				if (!rc) {                
-					rc = (int)kernel_thread(cifs_oplock_thread, NULL, 
-						CLONE_FS | CLONE_FILES | CLONE_VM);
-					if(rc > 0) {
-						rc = (int)kernel_thread(cifs_dnotify_thread, NULL,
-							CLONE_FS | CLONE_FILES | CLONE_VM);
-						if(rc > 0)
-							return 0;
-						else
-							cERROR(1,("error %d create dnotify thread", rc));
-					} else {
-						cERROR(1,("error %d create oplock thread",rc));
-					}
-				}
-				cifs_destroy_request_bufs();
-			}
-			cifs_destroy_mids();
-		}
-		cifs_destroy_inodecache();
+	if (rc)
+		goto out_clean_proc;
+
+	rc = cifs_init_mids();
+	if (rc)
+		goto out_destroy_inodecache;
+
+	rc = cifs_init_request_bufs();
+	if (rc)
+		goto out_destroy_mids;
+
+	rc = register_filesystem(&cifs_fs_type);
+	if (rc)
+		goto out_destroy_request_bufs;
+
+	oplockThread = kthread_run(cifs_oplock_thread, NULL, "cifsoplockd");
+	if (IS_ERR(oplockThread)) {
+		rc = PTR_ERR(oplockThread);
+		cERROR(1,("error %d create oplock thread", rc));
+		goto out_unregister_filesystem;
 	}
+
+	dnotifyThread = kthread_run(cifs_dnotify_thread, NULL, "cifsdnotifyd");
+	if (IS_ERR(dnotifyThread)) {
+		rc = PTR_ERR(dnotifyThread);
+		cERROR(1,("error %d create dnotify thread", rc));
+		goto out_stop_oplock_thread;
+	}
+
+	return 0;
+
+ out_stop_oplock_thread:
+	kthread_stop(oplockThread);
+ out_unregister_filesystem:
+	unregister_filesystem(&cifs_fs_type);
+ out_destroy_request_bufs:
+	cifs_destroy_request_bufs();
+ out_destroy_mids:
+	cifs_destroy_mids();
+ out_destroy_inodecache:
+	cifs_destroy_inodecache();
+ out_clean_proc:
 #ifdef CONFIG_PROC_FS
 	cifs_proc_clean();
 #endif
@@ -1025,14 +1032,8 @@ exit_cifs(void)
 	cifs_destroy_inodecache();
 	cifs_destroy_mids();
 	cifs_destroy_request_bufs();
-	if(oplockThread) {
-		send_sig(SIGTERM, oplockThread, 1);
-		wait_for_completion(&cifs_oplock_exited);
-	}
-	if(dnotifyThread) {
-		send_sig(SIGTERM, dnotifyThread, 1);
-		wait_for_completion(&cifs_dnotify_exited);
-	}
+	kthread_stop(oplockThread);
+	kthread_stop(dnotifyThread);
 }
 
 MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");

commit d62e54abca1146981fc9f98f85ff398a113a22c2
Merge: fd4a0b92db6a ce362c009250
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Mar 31 03:35:56 2006 +0000

    Merge with /pub/scm/linux/kernel/git/torvalds/linux-2.6.git
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

commit 4b6f5d20b04dcbc3d888555522b90ba6d36c4106
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:42 2006 -0800

    [PATCH] Make most file operations structs in fs/ const
    
    This is a conversion to make the various file_operations structs in fs/
    const.  Basically a regexp job, with a few manual fixups
    
    The goal is both to increase correctness (harder to accidentally write to
    shared datastructures) and reducing the false sharing of cachelines with
    things that get dirty in .data (while .rodata is nicely read only and thus
    cache clean)
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 6b99b51d6694..4bbc544857bc 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -583,7 +583,7 @@ struct inode_operations cifs_symlink_inode_ops = {
 #endif 
 };
 
-struct file_operations cifs_file_ops = {
+const struct file_operations cifs_file_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
 	.readv = generic_file_readv,
@@ -607,7 +607,7 @@ struct file_operations cifs_file_ops = {
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
-struct file_operations cifs_file_direct_ops = {
+const struct file_operations cifs_file_direct_ops = {
 	/* no mmap, no aio, no readv - 
 	   BB reevaluate whether they can be done with directio, no cache */
 	.read = cifs_user_read,
@@ -626,7 +626,7 @@ struct file_operations cifs_file_direct_ops = {
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
-struct file_operations cifs_file_nobrl_ops = {
+const struct file_operations cifs_file_nobrl_ops = {
 	.read = do_sync_read,
 	.write = do_sync_write,
 	.readv = generic_file_readv,
@@ -649,7 +649,7 @@ struct file_operations cifs_file_nobrl_ops = {
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
-struct file_operations cifs_file_direct_nobrl_ops = {
+const struct file_operations cifs_file_direct_nobrl_ops = {
 	/* no mmap, no aio, no readv - 
 	   BB reevaluate whether they can be done with directio, no cache */
 	.read = cifs_user_read,
@@ -668,7 +668,7 @@ struct file_operations cifs_file_direct_nobrl_ops = {
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
-struct file_operations cifs_dir_ops = {
+const struct file_operations cifs_dir_ops = {
 	.readdir = cifs_readdir,
 	.release = cifs_closedir,
 	.read    = generic_read_dir,

commit 93d2341c750cda0df48a6cc67b35fe25f1ec47df
Author: Matthew Dobson <colpatch@us.ibm.com>
Date:   Sun Mar 26 01:37:50 2006 -0800

    [PATCH] mempool: use mempool_create_slab_pool()
    
    Modify well over a dozen mempool users to call mempool_create_slab_pool()
    rather than calling mempool_create() with extra arguments, saving about 30
    lines of code and increasing readability.
    
    Signed-off-by: Matthew Dobson <colpatch@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 221b3334b737..6b99b51d6694 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -738,10 +738,8 @@ cifs_init_request_bufs(void)
 		cERROR(1,("cifs_min_rcv set to maximum (64)"));
 	}
 
-	cifs_req_poolp = mempool_create(cifs_min_rcv,
-					mempool_alloc_slab,
-					mempool_free_slab,
-					cifs_req_cachep);
+	cifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,
+						  cifs_req_cachep);
 
 	if(cifs_req_poolp == NULL) {
 		kmem_cache_destroy(cifs_req_cachep);
@@ -771,10 +769,8 @@ cifs_init_request_bufs(void)
 		cFYI(1,("cifs_min_small set to maximum (256)"));
 	}
 
-	cifs_sm_req_poolp = mempool_create(cifs_min_small,
-				mempool_alloc_slab,
-				mempool_free_slab,
-				cifs_sm_req_cachep);
+	cifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,
+						     cifs_sm_req_cachep);
 
 	if(cifs_sm_req_poolp == NULL) {
 		mempool_destroy(cifs_req_poolp);
@@ -808,10 +804,8 @@ cifs_init_mids(void)
 	if (cifs_mid_cachep == NULL)
 		return -ENOMEM;
 
-	cifs_mid_poolp = mempool_create(3 /* a reasonable min simultan opers */,
-					mempool_alloc_slab,
-					mempool_free_slab,
-					cifs_mid_cachep);
+	/* 3 is a reasonable minimum number of simultaneous operations */
+	cifs_mid_poolp = mempool_create_slab_pool(3, cifs_mid_cachep);
 	if(cifs_mid_poolp == NULL) {
 		kmem_cache_destroy(cifs_mid_cachep);
 		return -ENOMEM;

commit fffb60f93ce5880aade88e01d7133b52a4879710
Author: Paul Jackson <pj@sgi.com>
Date:   Fri Mar 24 03:16:06 2006 -0800

    [PATCH] cpuset memory spread: slab cache format
    
    Rewrap the overly long source code lines resulting from the previous
    patch's addition of the slab cache flag SLAB_MEM_SPREAD.  This patch
    contains only formatting changes, and no function change.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ba5a24b99a11..221b3334b737 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -695,7 +695,8 @@ cifs_init_inodecache(void)
 {
 	cifs_inode_cachep = kmem_cache_create("cifs_inode_cache",
 					      sizeof (struct cifsInodeInfo),
-					      0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,
+					      0, (SLAB_RECLAIM_ACCOUNT|
+						SLAB_MEM_SPREAD),
 					      cifs_init_once, NULL);
 	if (cifs_inode_cachep == NULL)
 		return -ENOMEM;

commit 4b6a9316fab51af611dc8671f296734089f6a22a
Author: Paul Jackson <pj@sgi.com>
Date:   Fri Mar 24 03:16:05 2006 -0800

    [PATCH] cpuset memory spread: slab cache filesystems
    
    Mark file system inode and similar slab caches subject to SLAB_MEM_SPREAD
    memory spreading.
    
    If a slab cache is marked SLAB_MEM_SPREAD, then anytime that a task that's
    in a cpuset with the 'memory_spread_slab' option enabled goes to allocate
    from such a slab cache, the allocations are spread evenly over all the
    memory nodes (task->mems_allowed) allowed to that task, instead of favoring
    allocation on the node local to the current cpu.
    
    The following inode and similar caches are marked SLAB_MEM_SPREAD:
    
        file                               cache
        ====                               =====
        fs/adfs/super.c                    adfs_inode_cache
        fs/affs/super.c                    affs_inode_cache
        fs/befs/linuxvfs.c                 befs_inode_cache
        fs/bfs/inode.c                     bfs_inode_cache
        fs/block_dev.c                     bdev_cache
        fs/cifs/cifsfs.c                   cifs_inode_cache
        fs/coda/inode.c                    coda_inode_cache
        fs/dquot.c                         dquot
        fs/efs/super.c                     efs_inode_cache
        fs/ext2/super.c                    ext2_inode_cache
        fs/ext2/xattr.c (fs/mbcache.c)     ext2_xattr
        fs/ext3/super.c                    ext3_inode_cache
        fs/ext3/xattr.c (fs/mbcache.c)     ext3_xattr
        fs/fat/cache.c                     fat_cache
        fs/fat/inode.c                     fat_inode_cache
        fs/freevxfs/vxfs_super.c           vxfs_inode
        fs/hpfs/super.c                    hpfs_inode_cache
        fs/isofs/inode.c                   isofs_inode_cache
        fs/jffs/inode-v23.c                jffs_fm
        fs/jffs2/super.c                   jffs2_i
        fs/jfs/super.c                     jfs_ip
        fs/minix/inode.c                   minix_inode_cache
        fs/ncpfs/inode.c                   ncp_inode_cache
        fs/nfs/direct.c                    nfs_direct_cache
        fs/nfs/inode.c                     nfs_inode_cache
        fs/ntfs/super.c                    ntfs_big_inode_cache_name
        fs/ntfs/super.c                    ntfs_inode_cache
        fs/ocfs2/dlm/dlmfs.c               dlmfs_inode_cache
        fs/ocfs2/super.c                   ocfs2_inode_cache
        fs/proc/inode.c                    proc_inode_cache
        fs/qnx4/inode.c                    qnx4_inode_cache
        fs/reiserfs/super.c                reiser_inode_cache
        fs/romfs/inode.c                   romfs_inode_cache
        fs/smbfs/inode.c                   smb_inode_cache
        fs/sysv/inode.c                    sysv_inode_cache
        fs/udf/super.c                     udf_inode_cache
        fs/ufs/super.c                     ufs_inode_cache
        net/socket.c                       sock_inode_cache
        net/sunrpc/rpc_pipe.c              rpc_inode_cache
    
    The choice of which slab caches to so mark was quite simple.  I marked
    those already marked SLAB_RECLAIM_ACCOUNT, except for fs/xfs, dentry_cache,
    inode_cache, and buffer_head, which were marked in a previous patch.  Even
    though SLAB_RECLAIM_ACCOUNT is for a different purpose, it marks the same
    potentially large file system i/o related slab caches as we need for memory
    spreading.
    
    Given that the rule now becomes "wherever you would have used a
    SLAB_RECLAIM_ACCOUNT slab cache flag before (usually the inode cache), use
    the SLAB_MEM_SPREAD flag too", this should be easy enough to maintain.
    Future file system writers will just copy one of the existing file system
    slab cache setups and tend to get it right without thinking.
    
    Signed-off-by: Paul Jackson <pj@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1cd044ce82a6..ba5a24b99a11 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -695,7 +695,7 @@ cifs_init_inodecache(void)
 {
 	cifs_inode_cachep = kmem_cache_create("cifs_inode_cache",
 					      sizeof (struct cifsInodeInfo),
-					      0, SLAB_RECLAIM_ACCOUNT,
+					      0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,
 					      cifs_init_once, NULL);
 	if (cifs_inode_cachep == NULL)
 		return -ENOMEM;

commit 9b04c997b1120feefa1e6ee8e2902270bc055cd2
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Fri Mar 24 03:15:10 2006 -0800

    [PATCH] vfs: MS_VERBOSE should be MS_SILENT
    
    The meaning of MS_VERBOSE is backwards; if the bit is set, it really means,
    "don't be verbose".  This is confusing and counter-intuitive.
    
    In addition, there is also no way to set the MS_VERBOSE flag in the
    mount(8) program in util-linux, but interesting, it does define options
    which would do the right thing if MS_SILENT were defined, which
    unfortunately we do not:
    
    #ifdef MS_SILENT
      { "quiet",    0, 0, MS_SILENT    },   /* be quiet  */
      { "loud",     0, 1, MS_SILENT    },   /* print out messages. */
    #endif
    
    So the obvious fix is to deprecate the use of MS_VERBOSE and replace it
    with MS_SILENT.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 79eeccd0437f..1cd044ce82a6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -479,7 +479,7 @@ cifs_get_sb(struct file_system_type *fs_type,
 
 	sb->s_flags = flags;
 
-	rc = cifs_read_super(sb, data, dev_name, flags & MS_VERBOSE ? 1 : 0);
+	rc = cifs_read_super(sb, data, dev_name, flags & MS_SILENT ? 1 : 0);
 	if (rc) {
 		up_write(&sb->s_umount);
 		deactivate_super(sb);

commit a048d7a8704b35ff6372fdf5eedd4533f37b1885
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Tue Feb 21 22:33:09 2006 +0000

    [CIFS] Convert remaining places in fs/cifs from
    kmalloc/memset to simpler kzalloc usage
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 79eeccd0437f..8219c02145a7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -93,13 +93,10 @@ cifs_read_super(struct super_block *sb, void *data,
 	int rc = 0;
 
 	sb->s_flags |= MS_NODIRATIME; /* and probably even noatime */
-	sb->s_fs_info = kmalloc(sizeof(struct cifs_sb_info),GFP_KERNEL);
+	sb->s_fs_info = kzalloc(sizeof(struct cifs_sb_info),GFP_KERNEL);
 	cifs_sb = CIFS_SB(sb);
 	if(cifs_sb == NULL)
 		return -ENOMEM;
-	else
-		memset(cifs_sb,0,sizeof(struct cifs_sb_info));
-	
 
 	rc = cifs_mount(sb, cifs_sb, data, devname);
 

commit 94bc2be31a01a3055ec94176e595dfe208e92d3b
Merge: c32a0b689cb9 58cba4650a7a
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jan 12 14:47:08 2006 -0800

    Merge with /pub/scm/linux/kernel/git/torvalds/linux-2.6.git
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

commit c32a0b689cb9cc160cfcd19735bbf50bb70c6ef4
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Jan 12 14:41:28 2006 -0800

    [CIFS] Allow local filesize for file that is open for write to be updated
    from server when mount forcedirectio.
    
    Allowing update of file size with non forcedirectio mounts should be
    allowed in the fiture but requires carefully writing out the
    last page in the local file if it is a partial page in order to
    avoid corruption and careful serialization
    
    Thanks to Maximiliano Curia who suggested similar changes and provided
    a testcase.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 582d66ca6da5..136af8a08f45 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -513,6 +513,17 @@ static ssize_t cifs_file_aio_write(struct kiocb *iocb, const char __user *buf,
 	return written;
 }
 
+static loff_t cifs_llseek(struct file *file, loff_t offset, int origin)
+{
+	/* origin == SEEK_END => we must revalidate the cached file length */
+	if (origin == 2) {
+		int retval = cifs_revalidate(file->f_dentry);
+		if (retval < 0)
+			return (loff_t)retval;
+	}
+	return remote_llseek(file, offset, origin);
+}
+
 static struct file_system_type cifs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "cifs",
@@ -586,6 +597,7 @@ struct file_operations cifs_file_ops = {
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
 	.sendfile = generic_file_sendfile,
+	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_POSIX
 	.ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
@@ -609,7 +621,7 @@ struct file_operations cifs_file_direct_ops = {
 #ifdef CONFIG_CIFS_POSIX
 	.ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
-
+	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
@@ -627,6 +639,7 @@ struct file_operations cifs_file_nobrl_ops = {
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
 	.sendfile = generic_file_sendfile,
+	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_POSIX
 	.ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
@@ -649,7 +662,7 @@ struct file_operations cifs_file_direct_nobrl_ops = {
 #ifdef CONFIG_CIFS_POSIX
 	.ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
-
+	.llseek = cifs_llseek,
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */

commit 1b1dcc1b57a49136f118a0f16367256ff9994a69
Author: Jes Sorensen <jes@sgi.com>
Date:   Mon Jan 9 15:59:24 2006 -0800

    [PATCH] mutex subsystem, semaphore to mutex: VFS, ->i_sem
    
    This patch converts the inode semaphore to a mutex. I have tested it on
    XFS and compiled as much as one can consider on an ia64. Anyway your
    luck with it might be different.
    
    Modified-by: Ingo Molnar <mingo@elte.hu>
    
    (finished the conversion)
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2a13a2bac8f1..e10213b7541e 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -860,9 +860,9 @@ static int cifs_oplock_thread(void * dummyarg)
 				DeleteOplockQEntry(oplock_item);
 				/* can not grab inode sem here since it would
 				deadlock when oplock received on delete 
-				since vfs_unlink holds the i_sem across
+				since vfs_unlink holds the i_mutex across
 				the call */
-				/* down(&inode->i_sem);*/
+				/* mutex_lock(&inode->i_mutex);*/
 				if (S_ISREG(inode->i_mode)) {
 					rc = filemap_fdatawrite(inode->i_mapping);
 					if(CIFS_I(inode)->clientCanCacheRead == 0) {
@@ -871,7 +871,7 @@ static int cifs_oplock_thread(void * dummyarg)
 					}
 				} else
 					rc = 0;
-				/* up(&inode->i_sem);*/
+				/* mutex_unlock(&inode->i_mutex);*/
 				if (rc)
 					CIFS_I(inode)->write_behind_rc = rc;
 				cFYI(1,("Oplock flush inode %p rc %d",inode,rc));

commit ec637e3ffb6b978143652477c7c5f96c9519b691
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Dec 12 20:53:18 2005 -0800

    [CIFS] Avoid extra large buffer allocation (and memcpy) in cifs_readpages
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ba90903909a6..582d66ca6da5 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -733,7 +733,7 @@ cifs_init_request_bufs(void)
 		kmem_cache_destroy(cifs_req_cachep);
 		return -ENOMEM;
 	}
-	/* 256 (MAX_CIFS_HDR_SIZE bytes is enough for most SMB responses and
+	/* MAX_CIFS_SMALL_BUFFER_SIZE bytes is enough for most SMB responses and
 	almost all handle based requests (but not write response, nor is it
 	sufficient for path based requests).  A smaller size would have
 	been more efficient (compacting multiple slab items on one 4k page) 
@@ -742,7 +742,8 @@ cifs_init_request_bufs(void)
 	efficient to alloc 1 per page off the slab compared to 17K (5page) 
 	alloc of large cifs buffers even when page debugging is on */
 	cifs_sm_req_cachep = kmem_cache_create("cifs_small_rq",
-			MAX_CIFS_HDR_SIZE, 0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+			MAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN, 
+			NULL, NULL);
 	if (cifs_sm_req_cachep == NULL) {
 		mempool_destroy(cifs_req_poolp);
 		kmem_cache_destroy(cifs_req_cachep);

commit 4498eed50a114565debd38f173acd62cce6e7cb8
Author: Steve French <sfrench@us.ibm.com>
Date:   Sat Dec 3 13:58:57 2005 -0800

    [CIFS] Add extended stats (STATS2) for total buffer allocations for
    better performance debugging.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 2a13a2bac8f1..ba90903909a6 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -954,6 +954,12 @@ init_cifs(void)
 	atomic_set(&tconInfoReconnectCount, 0);
 
 	atomic_set(&bufAllocCount, 0);
+	atomic_set(&smBufAllocCount, 0);
+#ifdef CONFIG_CIFS_STATS2
+	atomic_set(&totBufAllocCount, 0);
+	atomic_set(&totSmBufAllocCount, 0);
+#endif /* CONFIG_CIFS_STATS2 */
+
 	atomic_set(&midCount, 0);
 	GlobalCurrentXid = 0;
 	GlobalTotalActiveXid = 0;

commit 2a138ebb012ac42c082ae8b40c87c1f265664391
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Nov 29 21:22:19 2005 -0800

    [CIFS] Missing parenthesis and typo in previous fix
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f4974b41e485..2a13a2bac8f1 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -921,7 +921,7 @@ static int cifs_dnotify_thread(void * dummyarg)
 			ses = list_entry(tmp, struct cifsSesInfo, 
 				cifsSessionList);
 			if(ses && ses->server && 
-			     atomic_read(&ses->server->inSend))
+			     atomic_read(&ses->server->inFlight))
 				wake_up_all(&ses->server->response_q);
 		}
 		read_unlock(&GlobalSMBSeslock);

commit 6ab16d249513a50bef3f1b275cea6aa8d3f51832
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Nov 29 20:55:11 2005 -0800

    [CIFS] Fix umount --force to wake up the pending response queue, not just
    the request queue. Also periodically wakeup response_q so threads can
    check if stuck requests have timed out. Workaround Windows server illegal smb
    length on transact2 findfirst response.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 51548ed2e9cc..f4974b41e485 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -32,6 +32,7 @@
 #include <linux/seq_file.h>
 #include <linux/vfs.h>
 #include <linux/mempool.h>
+#include <linux/delay.h>
 #include "cifsfs.h"
 #include "cifspdu.h"
 #define DECLARE_GLOBALS_HERE
@@ -429,6 +430,11 @@ static void cifs_umount_begin(struct super_block * sblock)
 	{
 		cFYI(1,("wake up tasks now - umount begin not complete"));
 		wake_up_all(&tcon->ses->server->request_q);
+		wake_up_all(&tcon->ses->server->response_q);
+		msleep(1); /* yield */
+		/* we have to kick the requests once more */
+		wake_up_all(&tcon->ses->server->response_q);
+		msleep(1);
 	}
 /* BB FIXME - finish add checks for tidStatus BB */
 
@@ -895,6 +901,9 @@ static int cifs_oplock_thread(void * dummyarg)
 
 static int cifs_dnotify_thread(void * dummyarg)
 {
+	struct list_head *tmp;
+	struct cifsSesInfo *ses;
+
 	daemonize("cifsdnotifyd");
 	allow_signal(SIGTERM);
 
@@ -903,7 +912,19 @@ static int cifs_dnotify_thread(void * dummyarg)
 		if(try_to_freeze())
 			continue;
 		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(39*HZ);
+		schedule_timeout(15*HZ);
+		read_lock(&GlobalSMBSeslock);
+		/* check if any stuck requests that need
+		   to be woken up and wakeq so the
+		   thread can wake up and error out */
+		list_for_each(tmp, &GlobalSMBSessionList) {
+			ses = list_entry(tmp, struct cifsSesInfo, 
+				cifsSessionList);
+			if(ses && ses->server && 
+			     atomic_read(&ses->server->inSend))
+				wake_up_all(&ses->server->response_q);
+		}
+		read_unlock(&GlobalSMBSeslock);
 	} while(!signal_pending(current));
 	complete_and_exit (&cifs_dnotify_exited, 0);
 }

commit 87c89dd7330735d70cc9912483f6f4c7bc3ff19c
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Nov 17 17:03:00 2005 -0800

    [CIFS] Vectored and async i/o turned on and correct the
    writev and aio_write to flush properly.
    
    This is Christoph's patch merged with the new nobrl file operations
    
    Signed-off-by: Dave Kleikamp <shaggy@austin.ibm.com>
    
    From: Christoph Hellwig <hch@lst.de>
    
     - support vectored and async aio ops unconditionally - this is above
       the pagecache and transparent to the fs
     - remove cifs_read_wrapper.  it was only doing silly checks and
       calling generic_file_write in all cases.
     - use do_sync_read/do_sync_write as read/write operations.  They call
       ->readv/->writev which we now always implemente.
     - add the filemap_fdatawrite calls to writev/aio_write which were
       missing previously compared to plain write.  no idea what the point
       behind them is, but let's be consistent at least..
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steven French <sfrench@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1433455c61ea..51548ed2e9cc 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -483,57 +483,30 @@ cifs_get_sb(struct file_system_type *fs_type,
 	return sb;
 }
 
-static ssize_t
-cifs_read_wrapper(struct file * file, char __user *read_data, size_t read_size,
-          loff_t * poffset)
+static ssize_t cifs_file_writev(struct file *file, const struct iovec *iov,
+				unsigned long nr_segs, loff_t *ppos)
 {
-	if(file->f_dentry == NULL)
-		return -EIO;
-	else if(file->f_dentry->d_inode == NULL)
-		return -EIO;
-
-	cFYI(1,("In read_wrapper size %zd at %lld",read_size,*poffset));
+	struct inode *inode = file->f_dentry->d_inode;
+	ssize_t written;
 
-	if(CIFS_I(file->f_dentry->d_inode)->clientCanCacheRead) {
-		return generic_file_read(file,read_data,read_size,poffset);
-	} else {
-		/* BB do we need to lock inode from here until after invalidate? */
-/*		if(file->f_dentry->d_inode->i_mapping) {
-			filemap_fdatawrite(file->f_dentry->d_inode->i_mapping);
-			filemap_fdatawait(file->f_dentry->d_inode->i_mapping);
-		}*/
-/*		cifs_revalidate(file->f_dentry);*/ /* BB fixme */
-
-		/* BB we should make timer configurable - perhaps 
-		   by simply calling cifs_revalidate here */
-		/* invalidate_remote_inode(file->f_dentry->d_inode);*/
-		return generic_file_read(file,read_data,read_size,poffset);
-	}
+	written = generic_file_writev(file, iov, nr_segs, ppos);
+	if (!CIFS_I(inode)->clientCanCacheAll)
+		filemap_fdatawrite(inode->i_mapping);
+	return written;
 }
 
-static ssize_t
-cifs_write_wrapper(struct file * file, const char __user *write_data,
-           size_t write_size, loff_t * poffset) 
+static ssize_t cifs_file_aio_write(struct kiocb *iocb, const char __user *buf,
+				   size_t count, loff_t pos)
 {
+	struct inode *inode = iocb->ki_filp->f_dentry->d_inode;
 	ssize_t written;
 
-	if(file->f_dentry == NULL)
-		return -EIO;
-	else if(file->f_dentry->d_inode == NULL)
-		return -EIO;
-
-	cFYI(1,("In write_wrapper size %zd at %lld",write_size,*poffset));
-
-	written = generic_file_write(file,write_data,write_size,poffset);
-	if(!CIFS_I(file->f_dentry->d_inode)->clientCanCacheAll)  {
-		if(file->f_dentry->d_inode->i_mapping) {
-			filemap_fdatawrite(file->f_dentry->d_inode->i_mapping);
-		}
-	}
+	written = generic_file_aio_write(iocb, buf, count, pos);
+	if (!CIFS_I(inode)->clientCanCacheAll)
+		filemap_fdatawrite(inode->i_mapping);
 	return written;
 }
 
-
 static struct file_system_type cifs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "cifs",
@@ -594,8 +567,12 @@ struct inode_operations cifs_symlink_inode_ops = {
 };
 
 struct file_operations cifs_file_ops = {
-	.read = cifs_read_wrapper,
-	.write = cifs_write_wrapper, 
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.readv = generic_file_readv,
+	.writev = cifs_file_writev,
+	.aio_read = generic_file_aio_read,
+	.aio_write = cifs_file_aio_write,
 	.open = cifs_open,
 	.release = cifs_close,
 	.lock = cifs_lock,
@@ -608,10 +585,6 @@ struct file_operations cifs_file_ops = {
 #endif /* CONFIG_CIFS_POSIX */
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-	.readv = generic_file_readv,
-	.writev = generic_file_writev,
-	.aio_read = generic_file_aio_read,
-	.aio_write = generic_file_aio_write,
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
@@ -636,43 +609,43 @@ struct file_operations cifs_file_direct_ops = {
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 struct file_operations cifs_file_nobrl_ops = {
-        .read = cifs_read_wrapper,
-        .write = cifs_write_wrapper,
-        .open = cifs_open,
-        .release = cifs_close,
-        .fsync = cifs_fsync,
-        .flush = cifs_flush,
-        .mmap  = cifs_file_mmap,
-        .sendfile = generic_file_sendfile,
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.readv = generic_file_readv,
+	.writev = cifs_file_writev,
+	.aio_read = generic_file_aio_read,
+	.aio_write = cifs_file_aio_write,
+	.open = cifs_open,
+	.release = cifs_close,
+	.fsync = cifs_fsync,
+	.flush = cifs_flush,
+	.mmap  = cifs_file_mmap,
+	.sendfile = generic_file_sendfile,
 #ifdef CONFIG_CIFS_POSIX
-        .ioctl  = cifs_ioctl,
+	.ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-        .readv = generic_file_readv,
-        .writev = generic_file_writev,
-        .aio_read = generic_file_aio_read,
-        .aio_write = generic_file_aio_write,
-        .dir_notify = cifs_dir_notify,
+	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
 struct file_operations cifs_file_direct_nobrl_ops = {
-        /* no mmap, no aio, no readv -
-           BB reevaluate whether they can be done with directio, no cache */
-        .read = cifs_user_read,
-        .write = cifs_user_write,
-        .open = cifs_open,
-        .release = cifs_close,
-        .fsync = cifs_fsync,
-        .flush = cifs_flush,
-        .sendfile = generic_file_sendfile, /* BB removeme BB */
+	/* no mmap, no aio, no readv - 
+	   BB reevaluate whether they can be done with directio, no cache */
+	.read = cifs_user_read,
+	.write = cifs_user_write,
+	.open = cifs_open,
+	.release = cifs_close,
+	.fsync = cifs_fsync,
+	.flush = cifs_flush,
+	.sendfile = generic_file_sendfile, /* BB removeme BB */
 #ifdef CONFIG_CIFS_POSIX
-        .ioctl  = cifs_ioctl,
+	.ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
-        .dir_notify = cifs_dir_notify,
+	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 

commit 8b94bcb923dff923a5a5b7c6f890702a54cb19cf
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Nov 11 11:41:00 2005 -0800

    [CIFS] Fix CIFS "nobrl" mount option so does not disable sending brl requests
    for all mounts just that particular mount.
    
    Found by Arjan Vand de Ven
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 682b0235ad9a..1433455c61ea 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -635,6 +635,46 @@ struct file_operations cifs_file_direct_ops = {
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
+struct file_operations cifs_file_nobrl_ops = {
+        .read = cifs_read_wrapper,
+        .write = cifs_write_wrapper,
+        .open = cifs_open,
+        .release = cifs_close,
+        .fsync = cifs_fsync,
+        .flush = cifs_flush,
+        .mmap  = cifs_file_mmap,
+        .sendfile = generic_file_sendfile,
+#ifdef CONFIG_CIFS_POSIX
+        .ioctl  = cifs_ioctl,
+#endif /* CONFIG_CIFS_POSIX */
+
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+        .readv = generic_file_readv,
+        .writev = generic_file_writev,
+        .aio_read = generic_file_aio_read,
+        .aio_write = generic_file_aio_write,
+        .dir_notify = cifs_dir_notify,
+#endif /* CONFIG_CIFS_EXPERIMENTAL */
+};
+
+struct file_operations cifs_file_direct_nobrl_ops = {
+        /* no mmap, no aio, no readv -
+           BB reevaluate whether they can be done with directio, no cache */
+        .read = cifs_user_read,
+        .write = cifs_user_write,
+        .open = cifs_open,
+        .release = cifs_close,
+        .fsync = cifs_fsync,
+        .flush = cifs_flush,
+        .sendfile = generic_file_sendfile, /* BB removeme BB */
+#ifdef CONFIG_CIFS_POSIX
+        .ioctl  = cifs_ioctl,
+#endif /* CONFIG_CIFS_POSIX */
+
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+        .dir_notify = cifs_dir_notify,
+#endif /* CONFIG_CIFS_EXPERIMENTAL */
+};
 
 struct file_operations cifs_dir_ops = {
 	.readdir = cifs_readdir,

commit 7b7abfe3dd81d659a0889f88965168f7eef8c5c6
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Nov 9 15:21:09 2005 -0800

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 877095a1192a..682b0235ad9a 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -405,6 +405,7 @@ static struct quotactl_ops cifs_quotactl_ops = {
 };
 #endif
 
+#ifdef CONFIG_CIFS_EXPERIMENTAL
 static void cifs_umount_begin(struct super_block * sblock)
 {
 	struct cifs_sb_info *cifs_sb;
@@ -422,16 +423,18 @@ static void cifs_umount_begin(struct super_block * sblock)
 		tcon->tidStatus = CifsExiting;
 	up(&tcon->tconSem);
 
+	/* cancel_brl_requests(tcon); */
+	/* cancel_notify_requests(tcon); */
 	if(tcon->ses && tcon->ses->server)
 	{
-		cERROR(1,("wake up tasks now - umount begin not complete"));
+		cFYI(1,("wake up tasks now - umount begin not complete"));
 		wake_up_all(&tcon->ses->server->request_q);
 	}
 /* BB FIXME - finish add checks for tidStatus BB */
 
 	return;
 }
-	
+#endif	
 
 static int cifs_remount(struct super_block *sb, int *flags, char *data)
 {
@@ -450,7 +453,9 @@ struct super_operations cifs_super_ops = {
    unless later we add lazy close of inodes or unless the kernel forgets to call
    us with the same number of releases (closes) as opens */
 	.show_options = cifs_show_options,
-/*	.umount_begin   = cifs_umount_begin, */ /* BB finish in the future */
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+	.umount_begin   = cifs_umount_begin,
+#endif
 	.remount_fs = cifs_remount,
 };
 

commit d6d3f5bc68be3c4ab84e6f1f9db92291da671504
Merge: ac9b9c667c2e 23e7dd7d95f6
Author: Steve French <sfrench@us.ibm.com>
Date:   Fri Oct 21 08:39:12 2005 -0700

    Merge with /pub/scm/linux/kernel/git/sfrench/cifs-2.6.git/

commit 4ca9c190d902caa7efb899a4c7fc8c6e6d926e95
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Oct 10 19:52:13 2005 -0700

    [CIFS] Fix oops in experimental notify code (when CONFIG_CIFS_EXPERIMENTAL
    was turned on).
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3bc9db522600..d2d16a9c1f05 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -901,6 +901,10 @@ init_cifs(void)
 	INIT_LIST_HEAD(&GlobalSMBSessionList);
 	INIT_LIST_HEAD(&GlobalTreeConnectionList);
 	INIT_LIST_HEAD(&GlobalOplock_Q);
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+	INIT_LIST_HEAD(&GlobalDnotifyReqList);
+	INIT_LIST_HEAD(&GlobalDnotifyRsp_Q);
+#endif	
 /*
  *  Initialize Global counters
  */

commit 34210f33025a3256b9ac3f0a182f02f1879140cb
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Oct 10 14:31:13 2005 -0700

    [CIFS] Still missing a line from previous fix
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 99e087d3554f..3bc9db522600 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -410,7 +410,7 @@ static void cifs_umount_begin(struct super_block * sblock)
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo * tcon;
 
-	cifs_sb = CIFS_SB(sb);
+	cifs_sb = CIFS_SB(sblock);
 	if(cifs_sb == NULL)
 		return;
 

commit 9e2e85f82fa280e937ee42152e7cbaff78be01a2
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Oct 10 14:28:38 2005 -0700

    [CIFS] Fix minor build problem with previous changeset
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index fd5eae37f2a8..99e087d3554f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -408,21 +408,24 @@ static struct quotactl_ops cifs_quotactl_ops = {
 static void cifs_umount_begin(struct super_block * sblock)
 {
 	struct cifs_sb_info *cifs_sb;
+	struct cifsTconInfo * tcon;
 
 	cifs_sb = CIFS_SB(sb);
 	if(cifs_sb == NULL)
-		return -EIO;
-	if(cifs_sb->tcon == NULL)
-		return -EIO;
+		return;
+
+	tcon = cifs_sb->tcon;
+	if(tcon == NULL)
+		return;
 	down(&tcon->tconSem);
 	if (atomic_read(&tcon->useCount) == 1)
 		tcon->tidStatus = CifsExiting;
 	up(&tcon->tconSem);
 
-	if((cifs->sb->tcon->ses) && (cifs_sb->tcon->ses->server))
+	if(tcon->ses && tcon->ses->server)
 	{
 		cERROR(1,("wake up tasks now - umount begin not complete"));
-		wake_up_all(&server->request_q);
+		wake_up_all(&tcon->ses->server->request_q);
 	}
 /* BB FIXME - finish add checks for tidStatus BB */
 

commit 5e1253b50111220f06ee13bc4e555d89ff39176b
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Oct 10 14:06:37 2005 -0700

    [CIFS] Correct cifs tcp retry when some data sent before getting EAGAIN.
    Continue implementation of cifs umount begin to allow force unmounts of
    cifs mounts.
    
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index e3177a031edc..fd5eae37f2a8 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -407,9 +407,24 @@ static struct quotactl_ops cifs_quotactl_ops = {
 
 static void cifs_umount_begin(struct super_block * sblock)
 {
-	cERROR(1,("kill all tasks now - umount begin not implemented yet"));
+	struct cifs_sb_info *cifs_sb;
 
-/* BB FIXME - finish BB */
+	cifs_sb = CIFS_SB(sb);
+	if(cifs_sb == NULL)
+		return -EIO;
+	if(cifs_sb->tcon == NULL)
+		return -EIO;
+	down(&tcon->tconSem);
+	if (atomic_read(&tcon->useCount) == 1)
+		tcon->tidStatus = CifsExiting;
+	up(&tcon->tconSem);
+
+	if((cifs->sb->tcon->ses) && (cifs_sb->tcon->ses->server))
+	{
+		cERROR(1,("wake up tasks now - umount begin not complete"));
+		wake_up_all(&server->request_q);
+	}
+/* BB FIXME - finish add checks for tidStatus BB */
 
 	return;
 }

commit 68058e757573d4e81550e74c5a03a29a29069ce7
Author: Steve French <sfrench@us.ibm.com>
Date:   Mon Oct 10 10:34:22 2005 -0700

    [CIFS] Reduce CIFS tcp congestion timeout (it was too long) and backoff
    ever longer amounts (up to 15 seconds).  This improves performance
    especially when using large wsize.
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 1f97d39100ee..e3177a031edc 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -405,6 +405,16 @@ static struct quotactl_ops cifs_quotactl_ops = {
 };
 #endif
 
+static void cifs_umount_begin(struct super_block * sblock)
+{
+	cERROR(1,("kill all tasks now - umount begin not implemented yet"));
+
+/* BB FIXME - finish BB */
+
+	return;
+}
+	
+
 static int cifs_remount(struct super_block *sb, int *flags, char *data)
 {
 	*flags |= MS_NODIRATIME;
@@ -422,7 +432,7 @@ struct super_operations cifs_super_ops = {
    unless later we add lazy close of inodes or unless the kernel forgets to call
    us with the same number of releases (closes) as opens */
 	.show_options = cifs_show_options,
-/*    .umount_begin   = cifs_umount_begin, *//* consider adding in the future */
+/*	.umount_begin   = cifs_umount_begin, */ /* BB finish in the future */
 	.remount_fs = cifs_remount,
 };
 
@@ -790,9 +800,7 @@ static int cifs_oplock_thread(void * dummyarg)
 	do {
 		if(try_to_freeze()) 
 			continue;
-		set_current_state(TASK_INTERRUPTIBLE);
 		
-		schedule_timeout(1*HZ);  
 		spin_lock(&GlobalMid_Lock);
 		if(list_empty(&GlobalOplock_Q)) {
 			spin_unlock(&GlobalMid_Lock);
@@ -841,6 +849,8 @@ static int cifs_oplock_thread(void * dummyarg)
 				}
 			} else
 				spin_unlock(&GlobalMid_Lock);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);  /* yield in case q were corrupt */
 		}
 	} while(!signal_pending(current));
 	oplockThread = NULL;

commit ede1327ea4ca8019ec6df24b3e837def091c26b8
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Aug 30 20:10:14 2005 -0700

    [PATCH] cifs: Add support for suspend
    
    cifsd had been preventing software suspend from completing.
    
    Signed-off-by: pavel@suse.de
    Signed-off-by: Steve French <sfrench@us.ibm.com>  lightly modified
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8cc23e7d0d5d..1ebf7dafc1d7 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -781,6 +781,8 @@ static int cifs_oplock_thread(void * dummyarg)
 
 	oplockThread = current;
 	do {
+		if (try_to_freeze()) 
+			continue;
 		set_current_state(TASK_INTERRUPTIBLE);
 		
 		schedule_timeout(1*HZ);  

commit 2096243885ee34b78cb57ce835e07c8536a67d2a
Author: Steve French <sfrench@us.ibm.com>
Date:   Wed Sep 21 22:05:57 2005 -0700

    [CIFS] Add support for legacy servers part nine.  statfs (df and du) is now
    functional, and the length check is fixed so readdir does not throw a
    warning message when windows me messes up the response to FindFirst
    of an empty dir (with only . and ..).
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index f738c8b19e3b..1f97d39100ee 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -205,6 +205,10 @@ cifs_statfs(struct super_block *sb, struct kstatfs *buf)
 #endif /* CIFS_EXPERIMENTAL */
 	rc = CIFSSMBQFSInfo(xid, pTcon, buf);
 
+	/* Old Windows servers do not support level 103, retry with level 
+	   one if old server failed the previous call */ 
+	if(rc)
+		rc = SMBOldQFSInfo(xid, pTcon, buf);
 	/*     
 	   int f_type;
 	   __fsid_t f_fsid;

commit e30dcf3a1905b4d2154f95db5fdfdf69691b4f0e
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Sep 20 20:49:16 2005 -0700

    [CIFS] Add support for legacy servers part eight. Write fixes for Windows
    ME, and do not set ctime unless explicitly requested with atime and/or
    mtime (it gets thrown away by most servers anyway as there is no way to set
    this via posix).
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 43fb2aafa528..f738c8b19e3b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -256,7 +256,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->clientCanCacheAll = FALSE;
 	cifs_inode->vfs_inode.i_blksize = CIFS_MAX_MSGSIZE;
 	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
-
+	cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;
 	INIT_LIST_HEAD(&cifs_inode->openFileList);
 	return &cifs_inode->vfs_inode;
 }

commit 16abbecdad3367c76c12537450eba0d86943fe2c
Author: Steve French <sfrench@us.ibm.com>
Date:   Tue Aug 30 13:10:14 2005 -0700

    [CIFS] Add support for suspend
    
    cifsd had been preventing software suspend from completing.
    
    Signed-off-by: pavel@suse.de
    Signed-off-by: Steve French <sfrench@us.ibm.com>  lightly modified
    ---
    
     fs/cifs/CHANGES   |    3 ++-
     fs/cifs/cifsfs.c  |    4 ++++
     fs/cifs/connect.c |    2 ++
     3 files changed, 8 insertions(+), 1 deletions(-)

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index d77abe236a67..43fb2aafa528 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -784,6 +784,8 @@ static int cifs_oplock_thread(void * dummyarg)
 
 	oplockThread = current;
 	do {
+		if(try_to_freeze()) 
+			continue;
 		set_current_state(TASK_INTERRUPTIBLE);
 		
 		schedule_timeout(1*HZ);  
@@ -848,6 +850,8 @@ static int cifs_dnotify_thread(void * dummyarg)
 
 	dnotifyThread = current;
 	do {
+		if(try_to_freeze())
+			continue;
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(39*HZ);
 	} while(!signal_pending(current));

commit 8d0d50948b276b46b75b1b5855d3f9fab1e0fd92
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Aug 18 09:41:43 2005 -0700

    [CIFS] Change Notify support part 1 - add dnotify thread for processing
    notify responses.
    
    Signed-off-by: Asser Ferno  <asser@diku.dk>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7fda0f7d9c00..d77abe236a67 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -59,6 +59,8 @@ unsigned int ntlmv2_support = 0;
 unsigned int sign_CIFS_PDUs = 1;
 extern struct task_struct * oplockThread; /* remove sparse warning */
 struct task_struct * oplockThread = NULL;
+extern struct task_struct * dnotifyThread; /* remove sparse warning */
+struct task_struct * dnotifyThread = NULL;
 unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
 module_param(CIFSMaxBufSize, int, 0);
 MODULE_PARM_DESC(CIFSMaxBufSize,"Network buffer size (not including header). Default: 16384 Range: 8192 to 130048");
@@ -73,6 +75,7 @@ module_param(cifs_max_pending, int, 0);
 MODULE_PARM_DESC(cifs_max_pending,"Simultaneous requests to server. Default: 50 Range: 2 to 256");
 
 static DECLARE_COMPLETION(cifs_oplock_exited);
+static DECLARE_COMPLETION(cifs_dnotify_exited);
 
 extern mempool_t *cifs_sm_req_poolp;
 extern mempool_t *cifs_req_poolp;
@@ -838,6 +841,19 @@ static int cifs_oplock_thread(void * dummyarg)
 	complete_and_exit (&cifs_oplock_exited, 0);
 }
 
+static int cifs_dnotify_thread(void * dummyarg)
+{
+	daemonize("cifsdnotifyd");
+	allow_signal(SIGTERM);
+
+	dnotifyThread = current;
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(39*HZ);
+	} while(!signal_pending(current));
+	complete_and_exit (&cifs_dnotify_exited, 0);
+}
+
 static int __init
 init_cifs(void)
 {
@@ -884,10 +900,16 @@ init_cifs(void)
 				if (!rc) {                
 					rc = (int)kernel_thread(cifs_oplock_thread, NULL, 
 						CLONE_FS | CLONE_FILES | CLONE_VM);
-					if(rc > 0)
-						return 0;
-					else 
+					if(rc > 0) {
+						rc = (int)kernel_thread(cifs_dnotify_thread, NULL,
+							CLONE_FS | CLONE_FILES | CLONE_VM);
+						if(rc > 0)
+							return 0;
+						else
+							cERROR(1,("error %d create dnotify thread", rc));
+					} else {
 						cERROR(1,("error %d create oplock thread",rc));
+					}
 				}
 				cifs_destroy_request_bufs();
 			}
@@ -916,6 +938,10 @@ exit_cifs(void)
 		send_sig(SIGTERM, oplockThread, 1);
 		wait_for_completion(&cifs_oplock_exited);
 	}
+	if(dnotifyThread) {
+		send_sig(SIGTERM, dnotifyThread, 1);
+		wait_for_completion(&cifs_dnotify_exited);
+	}
 }
 
 MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");

commit f191401f5906f4d942fac87ebeb4671faf1ba7d6
Author: Steve French <sfrench@us.ibm.com>
Date:   Thu Aug 18 09:37:34 2005 -0700

    [CIFS] rmmod cifs can oops if done soon after the last cifs unmount
    
    Signed-off-by: Shaggy (shaggy@austin.ibm.com)
    Signed-off-by: Steve French (sfrench@us.ibm.com)

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 8cc23e7d0d5d..7fda0f7d9c00 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -834,8 +834,8 @@ static int cifs_oplock_thread(void * dummyarg)
 				spin_unlock(&GlobalMid_Lock);
 		}
 	} while(!signal_pending(current));
-	complete_and_exit (&cifs_oplock_exited, 0);
 	oplockThread = NULL;
+	complete_and_exit (&cifs_oplock_exited, 0);
 }
 
 static int __init

commit 57337e42f1393941d59d5154eed27a63988ff2be
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:10 2005 -0700

    [PATCH] cifs: handle termination of cifs oplockd kernel thread
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 6322aada491f..8cc23e7d0d5d 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -835,6 +835,7 @@ static int cifs_oplock_thread(void * dummyarg)
 		}
 	} while(!signal_pending(current));
 	complete_and_exit (&cifs_oplock_exited, 0);
+	oplockThread = NULL;
 }
 
 static int __init

commit c81156dd217818c143a09b6a744e797a04571e99
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:07 2005 -0700

    [PATCH] cifs: cleanup of ifdefs usage so it is more consistent
    
    And fix to not needlessly send new POSIX QFSInfo when server does not
    explicitly claim support for the new protocol extensions.
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 461a706b237b..6322aada491f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -169,7 +169,8 @@ cifs_put_super(struct super_block *sb)
 static int
 cifs_statfs(struct super_block *sb, struct kstatfs *buf)
 {
-	int xid, rc = -EOPNOTSUPP;
+	int xid; 
+	int rc = -EOPNOTSUPP;
 	struct cifs_sb_info *cifs_sb;
 	struct cifsTconInfo *pTcon;
 
@@ -181,17 +182,18 @@ cifs_statfs(struct super_block *sb, struct kstatfs *buf)
 	buf->f_type = CIFS_MAGIC_NUMBER;
 
 	/* instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO */
-	buf->f_namelen = PATH_MAX;	/* PATH_MAX may be too long - it would presumably
-					   be length of total path, note that some servers may be 
-					   able to support more than this, but best to be safe
-					   since Win2k and others can not handle very long filenames */
+	buf->f_namelen = PATH_MAX; /* PATH_MAX may be too long - it would 
+				      presumably be total path, but note
+				      that some servers (includinng Samba 3)
+				      have a shorter maximum path */
 	buf->f_files = 0;	/* undefined */
 	buf->f_ffree = 0;	/* unlimited */
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 /* BB we could add a second check for a QFS Unix capability bit */
 /* BB FIXME check CIFS_POSIX_EXTENSIONS Unix cap first FIXME BB */
-    if (pTcon->ses->capabilities & CAP_UNIX)
+    if ((pTcon->ses->capabilities & CAP_UNIX) && (CIFS_POSIX_EXTENSIONS &
+			le64_to_cpu(pTcon->fsUnixInfo.Capability)))
 	    rc = CIFSSMBQFSPosixInfo(xid, pTcon, buf);
 
     /* Only need to call the old QFSInfo if failed
@@ -204,9 +206,10 @@ cifs_statfs(struct super_block *sb, struct kstatfs *buf)
 	   int f_type;
 	   __fsid_t f_fsid;
 	   int f_namelen;  */
-	/* BB get from info put in tcon struct at mount time with call to QFSAttrInfo */
+	/* BB get from info in tcon struct at mount time call to QFSAttrInfo */
 	FreeXid(xid);
-	return 0;		/* always return success? what if volume is no longer available? */
+	return 0;		/* always return success? what if volume is no
+				   longer available? */
 }
 
 static int cifs_permission(struct inode * inode, int mask, struct nameidata *nd)
@@ -600,9 +603,7 @@ struct file_operations cifs_dir_ops = {
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
-#ifdef CONFIG_CIFS_POSIX
         .ioctl  = cifs_ioctl,
-#endif /* CONFIG_CIFS_POSIX */
 };
 
 static void

commit f28ac91b0541a49d5bc7bfb9f0efd5289a7dd181
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:07 2005 -0700

    [PATCH] cifs: CIFS ioctl needed by umount.cifs utility
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 3d5365b9f5ba..461a706b237b 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -190,6 +190,7 @@ cifs_statfs(struct super_block *sb, struct kstatfs *buf)
 
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 /* BB we could add a second check for a QFS Unix capability bit */
+/* BB FIXME check CIFS_POSIX_EXTENSIONS Unix cap first FIXME BB */
     if (pTcon->ses->capabilities & CAP_UNIX)
 	    rc = CIFSSMBQFSPosixInfo(xid, pTcon, buf);
 
@@ -599,6 +600,9 @@ struct file_operations cifs_dir_ops = {
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */
+#ifdef CONFIG_CIFS_POSIX
+        .ioctl  = cifs_ioctl,
+#endif /* CONFIG_CIFS_POSIX */
 };
 
 static void

commit 737b758c965a9b223ac1243ab38d9e507ac86c64
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:06 2005 -0700

    [PATCH] cifs: character mapping of special characters (part 3 of 3)
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index ae48ef042977..3d5365b9f5ba 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -191,13 +191,13 @@ cifs_statfs(struct super_block *sb, struct kstatfs *buf)
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 /* BB we could add a second check for a QFS Unix capability bit */
     if (pTcon->ses->capabilities & CAP_UNIX)
-	    rc = CIFSSMBQFSPosixInfo(xid, pTcon, buf, cifs_sb->local_nls);
+	    rc = CIFSSMBQFSPosixInfo(xid, pTcon, buf);
 
     /* Only need to call the old QFSInfo if failed
     on newer one */
     if(rc)
 #endif /* CIFS_EXPERIMENTAL */
-	rc = CIFSSMBQFSInfo(xid, pTcon, buf, cifs_sb->local_nls);
+	rc = CIFSSMBQFSInfo(xid, pTcon, buf);
 
 	/*     
 	   int f_type;

commit c67593a03129967eae8939c4899767182eb6d6cd
Author: Steve French <smfrench@austin.rr.com>
Date:   Thu Apr 28 22:41:04 2005 -0700

    [PATCH] cifs: Enable ioctl support in POSIX extensions to handle lsattr
    
    remove sparse warnings, unnecessary pad in QueryFileInfo and redundant
    function define.
    
    Signed-off-by: Steve French (sfrench@us.ibm.com)
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 5082fce3c566..ae48ef042977 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -559,6 +559,10 @@ struct file_operations cifs_file_ops = {
 	.flush = cifs_flush,
 	.mmap  = cifs_file_mmap,
 	.sendfile = generic_file_sendfile,
+#ifdef CONFIG_CIFS_POSIX
+	.ioctl	= cifs_ioctl,
+#endif /* CONFIG_CIFS_POSIX */
+
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.readv = generic_file_readv,
 	.writev = generic_file_writev,
@@ -579,6 +583,10 @@ struct file_operations cifs_file_direct_ops = {
 	.fsync = cifs_fsync,
 	.flush = cifs_flush,
 	.sendfile = generic_file_sendfile, /* BB removeme BB */
+#ifdef CONFIG_CIFS_POSIX
+	.ioctl  = cifs_ioctl,
+#endif /* CONFIG_CIFS_POSIX */
+
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 	.dir_notify = cifs_dir_notify,
 #endif /* CONFIG_CIFS_EXPERIMENTAL */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
new file mode 100644
index 000000000000..5082fce3c566
--- /dev/null
+++ b/fs/cifs/cifsfs.c
@@ -0,0 +1,913 @@
+/*
+ *   fs/cifs/cifsfs.c
+ *
+ *   Copyright (C) International Business Machines  Corp., 2002,2004
+ *   Author(s): Steve French (sfrench@us.ibm.com)
+ *
+ *   Common Internet FileSystem (CIFS) client
+ *
+ *   This library is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU Lesser General Public License as published
+ *   by the Free Software Foundation; either version 2.1 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ *   the GNU Lesser General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Lesser General Public License
+ *   along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/* Note that BB means BUGBUG (ie something to fix eventually) */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/seq_file.h>
+#include <linux/vfs.h>
+#include <linux/mempool.h>
+#include "cifsfs.h"
+#include "cifspdu.h"
+#define DECLARE_GLOBALS_HERE
+#include "cifsglob.h"
+#include "cifsproto.h"
+#include "cifs_debug.h"
+#include "cifs_fs_sb.h"
+#include <linux/mm.h>
+#define CIFS_MAGIC_NUMBER 0xFF534D42	/* the first four bytes of SMB PDUs */
+
+#ifdef CONFIG_CIFS_QUOTA
+static struct quotactl_ops cifs_quotactl_ops;
+#endif
+
+int cifsFYI = 0;
+int cifsERROR = 1;
+int traceSMB = 0;
+unsigned int oplockEnabled = 1;
+unsigned int experimEnabled = 0;
+unsigned int linuxExtEnabled = 1;
+unsigned int lookupCacheEnabled = 1;
+unsigned int multiuser_mount = 0;
+unsigned int extended_security = 0;
+unsigned int ntlmv2_support = 0;
+unsigned int sign_CIFS_PDUs = 1;
+extern struct task_struct * oplockThread; /* remove sparse warning */
+struct task_struct * oplockThread = NULL;
+unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;
+module_param(CIFSMaxBufSize, int, 0);
+MODULE_PARM_DESC(CIFSMaxBufSize,"Network buffer size (not including header). Default: 16384 Range: 8192 to 130048");
+unsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;
+module_param(cifs_min_rcv, int, 0);
+MODULE_PARM_DESC(cifs_min_rcv,"Network buffers in pool. Default: 4 Range: 1 to 64");
+unsigned int cifs_min_small = 30;
+module_param(cifs_min_small, int, 0);
+MODULE_PARM_DESC(cifs_min_small,"Small network buffers in pool. Default: 30 Range: 2 to 256");
+unsigned int cifs_max_pending = CIFS_MAX_REQ;
+module_param(cifs_max_pending, int, 0);
+MODULE_PARM_DESC(cifs_max_pending,"Simultaneous requests to server. Default: 50 Range: 2 to 256");
+
+static DECLARE_COMPLETION(cifs_oplock_exited);
+
+extern mempool_t *cifs_sm_req_poolp;
+extern mempool_t *cifs_req_poolp;
+extern mempool_t *cifs_mid_poolp;
+
+extern kmem_cache_t *cifs_oplock_cachep;
+
+static int
+cifs_read_super(struct super_block *sb, void *data,
+		const char *devname, int silent)
+{
+	struct inode *inode;
+	struct cifs_sb_info *cifs_sb;
+	int rc = 0;
+
+	sb->s_flags |= MS_NODIRATIME; /* and probably even noatime */
+	sb->s_fs_info = kmalloc(sizeof(struct cifs_sb_info),GFP_KERNEL);
+	cifs_sb = CIFS_SB(sb);
+	if(cifs_sb == NULL)
+		return -ENOMEM;
+	else
+		memset(cifs_sb,0,sizeof(struct cifs_sb_info));
+	
+
+	rc = cifs_mount(sb, cifs_sb, data, devname);
+
+	if (rc) {
+		if (!silent)
+			cERROR(1,
+			       ("cifs_mount failed w/return code = %d", rc));
+		goto out_mount_failed;
+	}
+
+	sb->s_magic = CIFS_MAGIC_NUMBER;
+	sb->s_op = &cifs_super_ops;
+/*	if(cifs_sb->tcon->ses->server->maxBuf > MAX_CIFS_HDR_SIZE + 512)
+	    sb->s_blocksize = cifs_sb->tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE; */
+#ifdef CONFIG_CIFS_QUOTA
+	sb->s_qcop = &cifs_quotactl_ops;
+#endif
+	sb->s_blocksize = CIFS_MAX_MSGSIZE;
+	sb->s_blocksize_bits = 14;	/* default 2**14 = CIFS_MAX_MSGSIZE */
+	inode = iget(sb, ROOT_I);
+
+	if (!inode) {
+		rc = -ENOMEM;
+		goto out_no_root;
+	}
+
+	sb->s_root = d_alloc_root(inode);
+
+	if (!sb->s_root) {
+		rc = -ENOMEM;
+		goto out_no_root;
+	}
+
+	return 0;
+
+out_no_root:
+	cERROR(1, ("cifs_read_super: get root inode failed"));
+	if (inode)
+		iput(inode);
+
+out_mount_failed:
+	if(cifs_sb) {
+		if(cifs_sb->local_nls)
+			unload_nls(cifs_sb->local_nls);	
+		kfree(cifs_sb);
+	}
+	return rc;
+}
+
+static void
+cifs_put_super(struct super_block *sb)
+{
+	int rc = 0;
+	struct cifs_sb_info *cifs_sb;
+
+	cFYI(1, ("In cifs_put_super"));
+	cifs_sb = CIFS_SB(sb);
+	if(cifs_sb == NULL) {
+		cFYI(1,("Empty cifs superblock info passed to unmount"));
+		return;
+	}
+	rc = cifs_umount(sb, cifs_sb); 
+	if (rc) {
+		cERROR(1, ("cifs_umount failed with return code %d", rc));
+	}
+	unload_nls(cifs_sb->local_nls);
+	kfree(cifs_sb);
+	return;
+}
+
+static int
+cifs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	int xid, rc = -EOPNOTSUPP;
+	struct cifs_sb_info *cifs_sb;
+	struct cifsTconInfo *pTcon;
+
+	xid = GetXid();
+
+	cifs_sb = CIFS_SB(sb);
+	pTcon = cifs_sb->tcon;
+
+	buf->f_type = CIFS_MAGIC_NUMBER;
+
+	/* instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO */
+	buf->f_namelen = PATH_MAX;	/* PATH_MAX may be too long - it would presumably
+					   be length of total path, note that some servers may be 
+					   able to support more than this, but best to be safe
+					   since Win2k and others can not handle very long filenames */
+	buf->f_files = 0;	/* undefined */
+	buf->f_ffree = 0;	/* unlimited */
+
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+/* BB we could add a second check for a QFS Unix capability bit */
+    if (pTcon->ses->capabilities & CAP_UNIX)
+	    rc = CIFSSMBQFSPosixInfo(xid, pTcon, buf, cifs_sb->local_nls);
+
+    /* Only need to call the old QFSInfo if failed
+    on newer one */
+    if(rc)
+#endif /* CIFS_EXPERIMENTAL */
+	rc = CIFSSMBQFSInfo(xid, pTcon, buf, cifs_sb->local_nls);
+
+	/*     
+	   int f_type;
+	   __fsid_t f_fsid;
+	   int f_namelen;  */
+	/* BB get from info put in tcon struct at mount time with call to QFSAttrInfo */
+	FreeXid(xid);
+	return 0;		/* always return success? what if volume is no longer available? */
+}
+
+static int cifs_permission(struct inode * inode, int mask, struct nameidata *nd)
+{
+	struct cifs_sb_info *cifs_sb;
+
+	cifs_sb = CIFS_SB(inode->i_sb);
+
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {
+		return 0;
+	} else /* file mode might have been restricted at mount time 
+		on the client (above and beyond ACL on servers) for  
+		servers which do not support setting and viewing mode bits,
+		so allowing client to check permissions is useful */ 
+		return generic_permission(inode, mask, NULL);
+}
+
+static kmem_cache_t *cifs_inode_cachep;
+static kmem_cache_t *cifs_req_cachep;
+static kmem_cache_t *cifs_mid_cachep;
+kmem_cache_t *cifs_oplock_cachep;
+static kmem_cache_t *cifs_sm_req_cachep;
+mempool_t *cifs_sm_req_poolp;
+mempool_t *cifs_req_poolp;
+mempool_t *cifs_mid_poolp;
+
+static struct inode *
+cifs_alloc_inode(struct super_block *sb)
+{
+	struct cifsInodeInfo *cifs_inode;
+	cifs_inode = kmem_cache_alloc(cifs_inode_cachep, SLAB_KERNEL);
+	if (!cifs_inode)
+		return NULL;
+	cifs_inode->cifsAttrs = 0x20;	/* default */
+	atomic_set(&cifs_inode->inUse, 0);
+	cifs_inode->time = 0;
+	/* Until the file is open and we have gotten oplock
+	info back from the server, can not assume caching of
+	file data or metadata */
+	cifs_inode->clientCanCacheRead = FALSE;
+	cifs_inode->clientCanCacheAll = FALSE;
+	cifs_inode->vfs_inode.i_blksize = CIFS_MAX_MSGSIZE;
+	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
+
+	INIT_LIST_HEAD(&cifs_inode->openFileList);
+	return &cifs_inode->vfs_inode;
+}
+
+static void
+cifs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
+}
+
+/*
+ * cifs_show_options() is for displaying mount options in /proc/mounts.
+ * Not all settable options are displayed but most of the important
+ * ones are.
+ */
+static int
+cifs_show_options(struct seq_file *s, struct vfsmount *m)
+{
+	struct cifs_sb_info *cifs_sb;
+
+	cifs_sb = CIFS_SB(m->mnt_sb);
+
+	if (cifs_sb) {
+		if (cifs_sb->tcon) {
+			seq_printf(s, ",unc=%s", cifs_sb->tcon->treeName);
+			if (cifs_sb->tcon->ses) {
+				if (cifs_sb->tcon->ses->userName)
+					seq_printf(s, ",username=%s",
+					   cifs_sb->tcon->ses->userName);
+				if(cifs_sb->tcon->ses->domainName)
+					seq_printf(s, ",domain=%s",
+					   cifs_sb->tcon->ses->domainName);
+			}
+		}
+		seq_printf(s, ",rsize=%d",cifs_sb->rsize);
+		seq_printf(s, ",wsize=%d",cifs_sb->wsize);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_CIFS_QUOTA
+int cifs_xquota_set(struct super_block * sb, int quota_type, qid_t qid,
+		struct fs_disk_quota * pdquota)
+{
+	int xid;
+	int rc = 0;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	struct cifsTconInfo *pTcon;
+	
+	if(cifs_sb)
+		pTcon = cifs_sb->tcon;
+	else
+		return -EIO;
+
+
+	xid = GetXid();
+	if(pTcon) {
+		cFYI(1,("set type: 0x%x id: %d",quota_type,qid));		
+	} else {
+		return -EIO;
+	}
+
+	FreeXid(xid);
+	return rc;
+}
+
+int cifs_xquota_get(struct super_block * sb, int quota_type, qid_t qid,
+                struct fs_disk_quota * pdquota)
+{
+	int xid;
+	int rc = 0;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	struct cifsTconInfo *pTcon;
+
+	if(cifs_sb)
+		pTcon = cifs_sb->tcon;
+	else
+		return -EIO;
+
+	xid = GetXid();
+	if(pTcon) {
+                cFYI(1,("set type: 0x%x id: %d",quota_type,qid));
+	} else {
+		rc = -EIO;
+	}
+
+	FreeXid(xid);
+	return rc;
+}
+
+int cifs_xstate_set(struct super_block * sb, unsigned int flags, int operation)
+{
+	int xid; 
+	int rc = 0;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	struct cifsTconInfo *pTcon;
+
+	if(cifs_sb)
+		pTcon = cifs_sb->tcon;
+	else
+		return -EIO;
+
+	xid = GetXid();
+	if(pTcon) {
+                cFYI(1,("flags: 0x%x operation: 0x%x",flags,operation));
+	} else {
+		rc = -EIO;
+	}
+
+	FreeXid(xid);
+	return rc;
+}
+
+int cifs_xstate_get(struct super_block * sb, struct fs_quota_stat *qstats)
+{
+	int xid;
+	int rc = 0;
+	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
+	struct cifsTconInfo *pTcon;
+
+	if(cifs_sb) {
+		pTcon = cifs_sb->tcon;
+	} else {
+		return -EIO;
+	}
+	xid = GetXid();
+	if(pTcon) {
+		cFYI(1,("pqstats %p",qstats));		
+	} else {
+		rc = -EIO;
+	}
+
+	FreeXid(xid);
+	return rc;
+}
+
+static struct quotactl_ops cifs_quotactl_ops = {
+	.set_xquota	= cifs_xquota_set,
+	.get_xquota	= cifs_xquota_set,
+	.set_xstate	= cifs_xstate_set,
+	.get_xstate	= cifs_xstate_get,
+};
+#endif
+
+static int cifs_remount(struct super_block *sb, int *flags, char *data)
+{
+	*flags |= MS_NODIRATIME;
+	return 0;
+}
+
+struct super_operations cifs_super_ops = {
+	.read_inode = cifs_read_inode,
+	.put_super = cifs_put_super,
+	.statfs = cifs_statfs,
+	.alloc_inode = cifs_alloc_inode,
+	.destroy_inode = cifs_destroy_inode,
+/*	.drop_inode	    = generic_delete_inode, 
+	.delete_inode	= cifs_delete_inode,  *//* Do not need the above two functions     
+   unless later we add lazy close of inodes or unless the kernel forgets to call
+   us with the same number of releases (closes) as opens */
+	.show_options = cifs_show_options,
+/*    .umount_begin   = cifs_umount_begin, *//* consider adding in the future */
+	.remount_fs = cifs_remount,
+};
+
+static struct super_block *
+cifs_get_sb(struct file_system_type *fs_type,
+	    int flags, const char *dev_name, void *data)
+{
+	int rc;
+	struct super_block *sb = sget(fs_type, NULL, set_anon_super, NULL);
+
+	cFYI(1, ("Devname: %s flags: %d ", dev_name, flags));
+
+	if (IS_ERR(sb))
+		return sb;
+
+	sb->s_flags = flags;
+
+	rc = cifs_read_super(sb, data, dev_name, flags & MS_VERBOSE ? 1 : 0);
+	if (rc) {
+		up_write(&sb->s_umount);
+		deactivate_super(sb);
+		return ERR_PTR(rc);
+	}
+	sb->s_flags |= MS_ACTIVE;
+	return sb;
+}
+
+static ssize_t
+cifs_read_wrapper(struct file * file, char __user *read_data, size_t read_size,
+          loff_t * poffset)
+{
+	if(file->f_dentry == NULL)
+		return -EIO;
+	else if(file->f_dentry->d_inode == NULL)
+		return -EIO;
+
+	cFYI(1,("In read_wrapper size %zd at %lld",read_size,*poffset));
+
+	if(CIFS_I(file->f_dentry->d_inode)->clientCanCacheRead) {
+		return generic_file_read(file,read_data,read_size,poffset);
+	} else {
+		/* BB do we need to lock inode from here until after invalidate? */
+/*		if(file->f_dentry->d_inode->i_mapping) {
+			filemap_fdatawrite(file->f_dentry->d_inode->i_mapping);
+			filemap_fdatawait(file->f_dentry->d_inode->i_mapping);
+		}*/
+/*		cifs_revalidate(file->f_dentry);*/ /* BB fixme */
+
+		/* BB we should make timer configurable - perhaps 
+		   by simply calling cifs_revalidate here */
+		/* invalidate_remote_inode(file->f_dentry->d_inode);*/
+		return generic_file_read(file,read_data,read_size,poffset);
+	}
+}
+
+static ssize_t
+cifs_write_wrapper(struct file * file, const char __user *write_data,
+           size_t write_size, loff_t * poffset) 
+{
+	ssize_t written;
+
+	if(file->f_dentry == NULL)
+		return -EIO;
+	else if(file->f_dentry->d_inode == NULL)
+		return -EIO;
+
+	cFYI(1,("In write_wrapper size %zd at %lld",write_size,*poffset));
+
+	written = generic_file_write(file,write_data,write_size,poffset);
+	if(!CIFS_I(file->f_dentry->d_inode)->clientCanCacheAll)  {
+		if(file->f_dentry->d_inode->i_mapping) {
+			filemap_fdatawrite(file->f_dentry->d_inode->i_mapping);
+		}
+	}
+	return written;
+}
+
+
+static struct file_system_type cifs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "cifs",
+	.get_sb = cifs_get_sb,
+	.kill_sb = kill_anon_super,
+	/*  .fs_flags */
+};
+struct inode_operations cifs_dir_inode_ops = {
+	.create = cifs_create,
+	.lookup = cifs_lookup,
+	.getattr = cifs_getattr,
+	.unlink = cifs_unlink,
+	.link = cifs_hardlink,
+	.mkdir = cifs_mkdir,
+	.rmdir = cifs_rmdir,
+	.rename = cifs_rename,
+	.permission = cifs_permission,
+/*	revalidate:cifs_revalidate,   */
+	.setattr = cifs_setattr,
+	.symlink = cifs_symlink,
+	.mknod   = cifs_mknod,
+#ifdef CONFIG_CIFS_XATTR
+	.setxattr = cifs_setxattr,
+	.getxattr = cifs_getxattr,
+	.listxattr = cifs_listxattr,
+	.removexattr = cifs_removexattr,
+#endif
+};
+
+struct inode_operations cifs_file_inode_ops = {
+/*	revalidate:cifs_revalidate, */
+	.setattr = cifs_setattr,
+	.getattr = cifs_getattr, /* do we need this anymore? */
+	.rename = cifs_rename,
+	.permission = cifs_permission,
+#ifdef CONFIG_CIFS_XATTR
+	.setxattr = cifs_setxattr,
+	.getxattr = cifs_getxattr,
+	.listxattr = cifs_listxattr,
+	.removexattr = cifs_removexattr,
+#endif 
+};
+
+struct inode_operations cifs_symlink_inode_ops = {
+	.readlink = generic_readlink, 
+	.follow_link = cifs_follow_link,
+	.put_link = cifs_put_link,
+	.permission = cifs_permission,
+	/* BB add the following two eventually */
+	/* revalidate: cifs_revalidate,
+	   setattr:    cifs_notify_change, *//* BB do we need notify change */
+#ifdef CONFIG_CIFS_XATTR
+	.setxattr = cifs_setxattr,
+	.getxattr = cifs_getxattr,
+	.listxattr = cifs_listxattr,
+	.removexattr = cifs_removexattr,
+#endif 
+};
+
+struct file_operations cifs_file_ops = {
+	.read = cifs_read_wrapper,
+	.write = cifs_write_wrapper, 
+	.open = cifs_open,
+	.release = cifs_close,
+	.lock = cifs_lock,
+	.fsync = cifs_fsync,
+	.flush = cifs_flush,
+	.mmap  = cifs_file_mmap,
+	.sendfile = generic_file_sendfile,
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+	.readv = generic_file_readv,
+	.writev = generic_file_writev,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.dir_notify = cifs_dir_notify,
+#endif /* CONFIG_CIFS_EXPERIMENTAL */
+};
+
+struct file_operations cifs_file_direct_ops = {
+	/* no mmap, no aio, no readv - 
+	   BB reevaluate whether they can be done with directio, no cache */
+	.read = cifs_user_read,
+	.write = cifs_user_write,
+	.open = cifs_open,
+	.release = cifs_close,
+	.lock = cifs_lock,
+	.fsync = cifs_fsync,
+	.flush = cifs_flush,
+	.sendfile = generic_file_sendfile, /* BB removeme BB */
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+	.dir_notify = cifs_dir_notify,
+#endif /* CONFIG_CIFS_EXPERIMENTAL */
+};
+
+struct file_operations cifs_dir_ops = {
+	.readdir = cifs_readdir,
+	.release = cifs_closedir,
+	.read    = generic_read_dir,
+#ifdef CONFIG_CIFS_EXPERIMENTAL
+	.dir_notify = cifs_dir_notify,
+#endif /* CONFIG_CIFS_EXPERIMENTAL */
+};
+
+static void
+cifs_init_once(void *inode, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct cifsInodeInfo *cifsi = inode;
+
+	if ((flags & (SLAB_CTOR_VERIFY | SLAB_CTOR_CONSTRUCTOR)) ==
+	    SLAB_CTOR_CONSTRUCTOR) {
+		inode_init_once(&cifsi->vfs_inode);
+		INIT_LIST_HEAD(&cifsi->lockList);
+	}
+}
+
+static int
+cifs_init_inodecache(void)
+{
+	cifs_inode_cachep = kmem_cache_create("cifs_inode_cache",
+					      sizeof (struct cifsInodeInfo),
+					      0, SLAB_RECLAIM_ACCOUNT,
+					      cifs_init_once, NULL);
+	if (cifs_inode_cachep == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void
+cifs_destroy_inodecache(void)
+{
+	if (kmem_cache_destroy(cifs_inode_cachep))
+		printk(KERN_WARNING "cifs_inode_cache: error freeing\n");
+}
+
+static int
+cifs_init_request_bufs(void)
+{
+	if(CIFSMaxBufSize < 8192) {
+	/* Buffer size can not be smaller than 2 * PATH_MAX since maximum
+	Unicode path name has to fit in any SMB/CIFS path based frames */
+		CIFSMaxBufSize = 8192;
+	} else if (CIFSMaxBufSize > 1024*127) {
+		CIFSMaxBufSize = 1024 * 127;
+	} else {
+		CIFSMaxBufSize &= 0x1FE00; /* Round size to even 512 byte mult*/
+	}
+/*	cERROR(1,("CIFSMaxBufSize %d 0x%x",CIFSMaxBufSize,CIFSMaxBufSize)); */
+	cifs_req_cachep = kmem_cache_create("cifs_request",
+					    CIFSMaxBufSize +
+					    MAX_CIFS_HDR_SIZE, 0,
+					    SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (cifs_req_cachep == NULL)
+		return -ENOMEM;
+
+	if(cifs_min_rcv < 1)
+		cifs_min_rcv = 1;
+	else if (cifs_min_rcv > 64) {
+		cifs_min_rcv = 64;
+		cERROR(1,("cifs_min_rcv set to maximum (64)"));
+	}
+
+	cifs_req_poolp = mempool_create(cifs_min_rcv,
+					mempool_alloc_slab,
+					mempool_free_slab,
+					cifs_req_cachep);
+
+	if(cifs_req_poolp == NULL) {
+		kmem_cache_destroy(cifs_req_cachep);
+		return -ENOMEM;
+	}
+	/* 256 (MAX_CIFS_HDR_SIZE bytes is enough for most SMB responses and
+	almost all handle based requests (but not write response, nor is it
+	sufficient for path based requests).  A smaller size would have
+	been more efficient (compacting multiple slab items on one 4k page) 
+	for the case in which debug was on, but this larger size allows
+	more SMBs to use small buffer alloc and is still much more
+	efficient to alloc 1 per page off the slab compared to 17K (5page) 
+	alloc of large cifs buffers even when page debugging is on */
+	cifs_sm_req_cachep = kmem_cache_create("cifs_small_rq",
+			MAX_CIFS_HDR_SIZE, 0, SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (cifs_sm_req_cachep == NULL) {
+		mempool_destroy(cifs_req_poolp);
+		kmem_cache_destroy(cifs_req_cachep);
+		return -ENOMEM;              
+	}
+
+	if(cifs_min_small < 2)
+		cifs_min_small = 2;
+	else if (cifs_min_small > 256) {
+		cifs_min_small = 256;
+		cFYI(1,("cifs_min_small set to maximum (256)"));
+	}
+
+	cifs_sm_req_poolp = mempool_create(cifs_min_small,
+				mempool_alloc_slab,
+				mempool_free_slab,
+				cifs_sm_req_cachep);
+
+	if(cifs_sm_req_poolp == NULL) {
+		mempool_destroy(cifs_req_poolp);
+		kmem_cache_destroy(cifs_req_cachep);
+		kmem_cache_destroy(cifs_sm_req_cachep);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void
+cifs_destroy_request_bufs(void)
+{
+	mempool_destroy(cifs_req_poolp);
+	if (kmem_cache_destroy(cifs_req_cachep))
+		printk(KERN_WARNING
+		       "cifs_destroy_request_cache: error not all structures were freed\n");
+	mempool_destroy(cifs_sm_req_poolp);
+	if (kmem_cache_destroy(cifs_sm_req_cachep))
+		printk(KERN_WARNING
+		      "cifs_destroy_request_cache: cifs_small_rq free error\n");
+}
+
+static int
+cifs_init_mids(void)
+{
+	cifs_mid_cachep = kmem_cache_create("cifs_mpx_ids",
+				sizeof (struct mid_q_entry), 0,
+				SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (cifs_mid_cachep == NULL)
+		return -ENOMEM;
+
+	cifs_mid_poolp = mempool_create(3 /* a reasonable min simultan opers */,
+					mempool_alloc_slab,
+					mempool_free_slab,
+					cifs_mid_cachep);
+	if(cifs_mid_poolp == NULL) {
+		kmem_cache_destroy(cifs_mid_cachep);
+		return -ENOMEM;
+	}
+
+	cifs_oplock_cachep = kmem_cache_create("cifs_oplock_structs",
+				sizeof (struct oplock_q_entry), 0,
+				SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (cifs_oplock_cachep == NULL) {
+		kmem_cache_destroy(cifs_mid_cachep);
+		mempool_destroy(cifs_mid_poolp);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void
+cifs_destroy_mids(void)
+{
+	mempool_destroy(cifs_mid_poolp);
+	if (kmem_cache_destroy(cifs_mid_cachep))
+		printk(KERN_WARNING
+		       "cifs_destroy_mids: error not all structures were freed\n");
+
+	if (kmem_cache_destroy(cifs_oplock_cachep))
+		printk(KERN_WARNING
+		       "error not all oplock structures were freed\n");
+}
+
+static int cifs_oplock_thread(void * dummyarg)
+{
+	struct oplock_q_entry * oplock_item;
+	struct cifsTconInfo *pTcon;
+	struct inode * inode;
+	__u16  netfid;
+	int rc;
+
+	daemonize("cifsoplockd");
+	allow_signal(SIGTERM);
+
+	oplockThread = current;
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+		
+		schedule_timeout(1*HZ);  
+		spin_lock(&GlobalMid_Lock);
+		if(list_empty(&GlobalOplock_Q)) {
+			spin_unlock(&GlobalMid_Lock);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(39*HZ);
+		} else {
+			oplock_item = list_entry(GlobalOplock_Q.next, 
+				struct oplock_q_entry, qhead);
+			if(oplock_item) {
+				cFYI(1,("found oplock item to write out")); 
+				pTcon = oplock_item->tcon;
+				inode = oplock_item->pinode;
+				netfid = oplock_item->netfid;
+				spin_unlock(&GlobalMid_Lock);
+				DeleteOplockQEntry(oplock_item);
+				/* can not grab inode sem here since it would
+				deadlock when oplock received on delete 
+				since vfs_unlink holds the i_sem across
+				the call */
+				/* down(&inode->i_sem);*/
+				if (S_ISREG(inode->i_mode)) {
+					rc = filemap_fdatawrite(inode->i_mapping);
+					if(CIFS_I(inode)->clientCanCacheRead == 0) {
+						filemap_fdatawait(inode->i_mapping);
+						invalidate_remote_inode(inode);
+					}
+				} else
+					rc = 0;
+				/* up(&inode->i_sem);*/
+				if (rc)
+					CIFS_I(inode)->write_behind_rc = rc;
+				cFYI(1,("Oplock flush inode %p rc %d",inode,rc));
+
+				/* releasing a stale oplock after recent reconnection 
+				of smb session using a now incorrect file 
+				handle is not a data integrity issue but do  
+				not bother sending an oplock release if session 
+				to server still is disconnected since oplock 
+				already released by the server in that case */
+				if(pTcon->tidStatus != CifsNeedReconnect) {
+				    rc = CIFSSMBLock(0, pTcon, netfid,
+					    0 /* len */ , 0 /* offset */, 0, 
+					    0, LOCKING_ANDX_OPLOCK_RELEASE,
+					    0 /* wait flag */);
+					cFYI(1,("Oplock release rc = %d ",rc));
+				}
+			} else
+				spin_unlock(&GlobalMid_Lock);
+		}
+	} while(!signal_pending(current));
+	complete_and_exit (&cifs_oplock_exited, 0);
+}
+
+static int __init
+init_cifs(void)
+{
+	int rc = 0;
+#ifdef CONFIG_PROC_FS
+	cifs_proc_init();
+#endif
+	INIT_LIST_HEAD(&GlobalServerList);	/* BB not implemented yet */
+	INIT_LIST_HEAD(&GlobalSMBSessionList);
+	INIT_LIST_HEAD(&GlobalTreeConnectionList);
+	INIT_LIST_HEAD(&GlobalOplock_Q);
+/*
+ *  Initialize Global counters
+ */
+	atomic_set(&sesInfoAllocCount, 0);
+	atomic_set(&tconInfoAllocCount, 0);
+	atomic_set(&tcpSesAllocCount,0);
+	atomic_set(&tcpSesReconnectCount, 0);
+	atomic_set(&tconInfoReconnectCount, 0);
+
+	atomic_set(&bufAllocCount, 0);
+	atomic_set(&midCount, 0);
+	GlobalCurrentXid = 0;
+	GlobalTotalActiveXid = 0;
+	GlobalMaxActiveXid = 0;
+	rwlock_init(&GlobalSMBSeslock);
+	spin_lock_init(&GlobalMid_Lock);
+
+	if(cifs_max_pending < 2) {
+		cifs_max_pending = 2;
+		cFYI(1,("cifs_max_pending set to min of 2"));
+	} else if(cifs_max_pending > 256) {
+		cifs_max_pending = 256;
+		cFYI(1,("cifs_max_pending set to max of 256"));
+	}
+
+	rc = cifs_init_inodecache();
+	if (!rc) {
+		rc = cifs_init_mids();
+		if (!rc) {
+			rc = cifs_init_request_bufs();
+			if (!rc) {
+				rc = register_filesystem(&cifs_fs_type);
+				if (!rc) {                
+					rc = (int)kernel_thread(cifs_oplock_thread, NULL, 
+						CLONE_FS | CLONE_FILES | CLONE_VM);
+					if(rc > 0)
+						return 0;
+					else 
+						cERROR(1,("error %d create oplock thread",rc));
+				}
+				cifs_destroy_request_bufs();
+			}
+			cifs_destroy_mids();
+		}
+		cifs_destroy_inodecache();
+	}
+#ifdef CONFIG_PROC_FS
+	cifs_proc_clean();
+#endif
+	return rc;
+}
+
+static void __exit
+exit_cifs(void)
+{
+	cFYI(0, ("In unregister ie exit_cifs"));
+#ifdef CONFIG_PROC_FS
+	cifs_proc_clean();
+#endif
+	unregister_filesystem(&cifs_fs_type);
+	cifs_destroy_inodecache();
+	cifs_destroy_mids();
+	cifs_destroy_request_bufs();
+	if(oplockThread) {
+		send_sig(SIGTERM, oplockThread, 1);
+		wait_for_completion(&cifs_oplock_exited);
+	}
+}
+
+MODULE_AUTHOR("Steve French <sfrench@us.ibm.com>");
+MODULE_LICENSE("GPL");		/* combination of LGPL + GPL source behaves as GPL */
+MODULE_DESCRIPTION
+    ("VFS to access servers complying with the SNIA CIFS Specification e.g. Samba and Windows");
+MODULE_VERSION(CIFS_VERSION);
+module_init(init_cifs)
+module_exit(exit_cifs)
