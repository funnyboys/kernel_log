commit 2522fe45a186e6276583e02723b78e1d1987cdd5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:20 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 193
    
    Based on 1 normalized pattern(s):
    
      this copyrighted material is made available to anyone wishing to use
      modify copy or redistribute it subject to the terms and conditions
      of the gnu general public license v 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 45 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.342746075@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/dlm/user.h b/fs/dlm/user.h
index 00499ab8835f..6b9bce6b96e0 100644
--- a/fs/dlm/user.h
+++ b/fs/dlm/user.h
@@ -1,9 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2006-2010 Red Hat, Inc.  All rights reserved.
- *
- * This copyrighted material is made available to anyone wishing to use,
- * modify, copy, or redistribute it subject to the terms and conditions
- * of the GNU General Public License v.2.
  */
 
 #ifndef __USER_DOT_H__

commit 8304d6f24cc1221392b6d61fa9d16631cbd6beb7
Author: David Teigland <teigland@redhat.com>
Date:   Mon Feb 21 14:58:21 2011 -0600

    dlm: record full callback state
    
    Change how callbacks are recorded for locks.  Previously, information
    about multiple callbacks was combined into a couple of variables that
    indicated what the end result should be.  In some situations, we
    could not tell from this combined state what the exact sequence of
    callbacks were, and would end up either delivering the callbacks in
    the wrong order, or suppress redundant callbacks incorrectly.  This
    new approach records all the data for each callback, leaving no
    uncertainty about what needs to be delivered.
    
    Signed-off-by: David Teigland <teigland@redhat.com>

diff --git a/fs/dlm/user.h b/fs/dlm/user.h
index f196091dd7ff..00499ab8835f 100644
--- a/fs/dlm/user.h
+++ b/fs/dlm/user.h
@@ -9,7 +9,8 @@
 #ifndef __USER_DOT_H__
 #define __USER_DOT_H__
 
-void dlm_user_add_ast(struct dlm_lkb *lkb, int type, int mode);
+void dlm_user_add_ast(struct dlm_lkb *lkb, uint32_t flags, int mode,
+                      int status, uint32_t sbflags, uint64_t seq);
 int dlm_user_init(void);
 void dlm_user_exit(void);
 int dlm_device_deregister(struct dlm_ls *ls);

commit 7fe2b3190b8b299409f13cf3a6f85c2bd371f8bb
Author: David Teigland <teigland@redhat.com>
Date:   Wed Feb 24 11:08:18 2010 -0600

    dlm: fix ordering of bast and cast
    
    When both blocking and completion callbacks are queued for lock,
    the dlm would always deliver the completion callback (cast) first.
    In some cases the blocking callback (bast) is queued before the
    cast, though, and should be delivered first.  This patch keeps
    track of the order in which they were queued and delivers them
    in that order.
    
    This patch also keeps track of the granted mode in the last cast
    and eliminates the following bast if the bast mode is compatible
    with the preceding cast mode.  This happens when a remotely mastered
    lock is demoted, e.g. EX->NL, in which case the local node queues
    a cast immediately after sending the demote message.  In this way
    a cast can be queued for a mode, e.g. NL, that makes an in-transit
    bast extraneous.
    
    Signed-off-by: David Teigland <teigland@redhat.com>

diff --git a/fs/dlm/user.h b/fs/dlm/user.h
index 1c9686492286..f196091dd7ff 100644
--- a/fs/dlm/user.h
+++ b/fs/dlm/user.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006-2008 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2006-2010 Red Hat, Inc.  All rights reserved.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
@@ -9,7 +9,7 @@
 #ifndef __USER_DOT_H__
 #define __USER_DOT_H__
 
-void dlm_user_add_ast(struct dlm_lkb *lkb, int type, int bastmode);
+void dlm_user_add_ast(struct dlm_lkb *lkb, int type, int mode);
 int dlm_user_init(void);
 void dlm_user_exit(void);
 int dlm_device_deregister(struct dlm_ls *ls);

commit fd22a51bcc0b7b76fc729b02316214fd979f9fe1
Author: David Teigland <teigland@redhat.com>
Date:   Tue Dec 9 11:55:46 2008 -0600

    dlm: improve how bast mode handling
    
    The lkb bastmode value is set in the context of processing the
    lock, and read by the dlm_astd thread.  Because it's accessed
    in these two separate contexts, the writing/reading ought to
    be done under a lock.  This is simple to do by setting it and
    reading it when the lkb is added to and removed from dlm_astd's
    callback list which is properly locked.
    
    Signed-off-by: David Teigland <teigland@redhat.com>

diff --git a/fs/dlm/user.h b/fs/dlm/user.h
index 35eb6a13d616..1c9686492286 100644
--- a/fs/dlm/user.h
+++ b/fs/dlm/user.h
@@ -9,7 +9,7 @@
 #ifndef __USER_DOT_H__
 #define __USER_DOT_H__
 
-void dlm_user_add_ast(struct dlm_lkb *lkb, int type);
+void dlm_user_add_ast(struct dlm_lkb *lkb, int type, int bastmode);
 int dlm_user_init(void);
 void dlm_user_exit(void);
 int dlm_device_deregister(struct dlm_ls *ls);

commit dc68c7ed362a00a48290252573a8eb9f74463c3a
Author: David Teigland <teigland@redhat.com>
Date:   Mon Aug 18 11:43:30 2008 -0500

    dlm: detect available userspace daemon
    
    If dlm_controld (the userspace daemon that controls the setup and
    recovery of the dlm) fails, the kernel should shut down the lockspaces
    in the kernel rather than leaving them running.  This is detected by
    having dlm_controld hold a misc device open while running, and if
    the kernel detects a close while the daemon is still needed, it stops
    the lockspaces in the kernel.
    
    Knowing that the userspace daemon isn't running also allows the
    lockspace create/remove routines to avoid waiting on the daemon
    for join/leave operations.
    
    Signed-off-by: David Teigland <teigland@redhat.com>

diff --git a/fs/dlm/user.h b/fs/dlm/user.h
index c528b6b2991b..35eb6a13d616 100644
--- a/fs/dlm/user.h
+++ b/fs/dlm/user.h
@@ -13,5 +13,6 @@ void dlm_user_add_ast(struct dlm_lkb *lkb, int type);
 int dlm_user_init(void);
 void dlm_user_exit(void);
 int dlm_device_deregister(struct dlm_ls *ls);
+int dlm_user_daemon_available(void);
 
 #endif

commit 0f8e0d9a317406612700426fad3efab0b7bbc467
Author: David Teigland <teigland@redhat.com>
Date:   Wed Aug 6 13:30:24 2008 -0500

    dlm: allow multiple lockspace creates
    
    Add a count for lockspace create and release so that create can
    be called multiple times to use the lockspace from different places.
    Also add the new flag DLM_LSFL_NEWEXCL to create a lockspace with
    the previous behavior of returning -EEXIST if the lockspace already
    exists.
    
    Signed-off-by: David Teigland <teigland@redhat.com>

diff --git a/fs/dlm/user.h b/fs/dlm/user.h
index d38e9f3e4151..c528b6b2991b 100644
--- a/fs/dlm/user.h
+++ b/fs/dlm/user.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2006-2008 Red Hat, Inc.  All rights reserved.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
@@ -12,5 +12,6 @@
 void dlm_user_add_ast(struct dlm_lkb *lkb, int type);
 int dlm_user_init(void);
 void dlm_user_exit(void);
+int dlm_device_deregister(struct dlm_ls *ls);
 
 #endif

commit 597d0cae0f99f62501e229bed50e8149604015bb
Author: David Teigland <teigland@redhat.com>
Date:   Wed Jul 12 16:44:04 2006 -0500

    [DLM] dlm: user locks
    
    This changes the way the dlm handles user locks.  The core dlm is now
    aware of user locks so they can be dealt with more efficiently.  There is
    no more dlm_device module which previously managed its own duplicate copy
    of every user lock.
    
    Signed-off-by: Patrick Caulfield <pcaulfie@redhat.com>
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/dlm/user.h b/fs/dlm/user.h
new file mode 100644
index 000000000000..d38e9f3e4151
--- /dev/null
+++ b/fs/dlm/user.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ *
+ * This copyrighted material is made available to anyone wishing to use,
+ * modify, copy, or redistribute it subject to the terms and conditions
+ * of the GNU General Public License v.2.
+ */
+
+#ifndef __USER_DOT_H__
+#define __USER_DOT_H__
+
+void dlm_user_add_ast(struct dlm_lkb *lkb, int type);
+int dlm_user_init(void);
+void dlm_user_exit(void);
+
+#endif
