commit 2522fe45a186e6276583e02723b78e1d1987cdd5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:20 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 193
    
    Based on 1 normalized pattern(s):
    
      this copyrighted material is made available to anyone wishing to use
      modify copy or redistribute it subject to the terms and conditions
      of the gnu general public license v 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 45 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.342746075@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/dlm/lowcomms.h b/fs/dlm/lowcomms.h
index 67462e54fc2f..687b2894e469 100644
--- a/fs/dlm/lowcomms.h
+++ b/fs/dlm/lowcomms.h
@@ -1,12 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /******************************************************************************
 *******************************************************************************
 **
 **  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
 **  Copyright (C) 2004-2009 Red Hat, Inc.  All rights reserved.
 **
-**  This copyrighted material is made available to anyone wishing to use,
-**  modify, copy, or redistribute it subject to the terms and conditions
-**  of the GNU General Public License v.2.
 **
 *******************************************************************************
 ******************************************************************************/

commit 36b71a8bfbc92e1ba164e9aec840c0180ee933b5
Author: David Teigland <teigland@redhat.com>
Date:   Thu Jul 26 12:44:30 2012 -0500

    dlm: fix deadlock between dlm_send and dlm_controld
    
    A deadlock sometimes occurs between dlm_controld closing
    a lowcomms connection through configfs and dlm_send looking
    up the address for a new connection in configfs.
    
    dlm_controld does a configfs rmdir which calls
    dlm_lowcomms_close which waits for dlm_send to
    cancel work on the workqueues.
    
    The dlm_send workqueue thread has called
    tcp_connect_to_sock which calls dlm_nodeid_to_addr
    which does a configfs lookup and blocks on a lock
    held by dlm_controld in the rmdir path.
    
    The solution here is to save the node addresses within
    the lowcomms code so that the lowcomms workqueue does
    not need to step through configfs to get a node address.
    
    dlm_controld:
    wait_for_completion+0x1d/0x20
    __cancel_work_timer+0x1b3/0x1e0
    cancel_work_sync+0x10/0x20
    dlm_lowcomms_close+0x4c/0xb0 [dlm]
    drop_comm+0x22/0x60 [dlm]
    client_drop_item+0x26/0x50 [configfs]
    configfs_rmdir+0x180/0x230 [configfs]
    vfs_rmdir+0xbd/0xf0
    do_rmdir+0x103/0x120
    sys_rmdir+0x16/0x20
    
    dlm_send:
    mutex_lock+0x2b/0x50
    get_comm+0x34/0x140 [dlm]
    dlm_nodeid_to_addr+0x18/0xd0 [dlm]
    tcp_connect_to_sock+0xf4/0x2d0 [dlm]
    process_send_sockets+0x1d2/0x260 [dlm]
    worker_thread+0x170/0x2a0
    
    Signed-off-by: David Teigland <teigland@redhat.com>

diff --git a/fs/dlm/lowcomms.h b/fs/dlm/lowcomms.h
index 1311e6426287..67462e54fc2f 100644
--- a/fs/dlm/lowcomms.h
+++ b/fs/dlm/lowcomms.h
@@ -16,10 +16,12 @@
 
 int dlm_lowcomms_start(void);
 void dlm_lowcomms_stop(void);
+void dlm_lowcomms_exit(void);
 int dlm_lowcomms_close(int nodeid);
 void *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc);
 void dlm_lowcomms_commit_buffer(void *mh);
 int dlm_lowcomms_connect_node(int nodeid);
+int dlm_lowcomms_addr(int nodeid, struct sockaddr_storage *addr, int len);
 
 #endif				/* __LOWCOMMS_DOT_H__ */
 

commit 391fbdc5d527149578490db2f1619951d91f3561
Author: Christine Caulfield <ccaulfie@redhat.com>
Date:   Thu May 7 10:54:16 2009 -0500

    dlm: connect to nodes earlier
    
    Make network connections to other nodes earlier, in the context of
    dlm_recoverd.  This avoids connecting to nodes from dlm_send where we
    try to avoid allocations which could possibly deadlock if memory reclaim
    goes into the cluster fs which may try to do a dlm operation.
    
    Signed-off-by: Christine Caulfield <ccaulfie@redhat.com>
    Signed-off-by: David Teigland <teigland@redhat.com>

diff --git a/fs/dlm/lowcomms.h b/fs/dlm/lowcomms.h
index a9a9618c0d3f..1311e6426287 100644
--- a/fs/dlm/lowcomms.h
+++ b/fs/dlm/lowcomms.h
@@ -2,7 +2,7 @@
 *******************************************************************************
 **
 **  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
-**  Copyright (C) 2004-2005 Red Hat, Inc.  All rights reserved.
+**  Copyright (C) 2004-2009 Red Hat, Inc.  All rights reserved.
 **
 **  This copyrighted material is made available to anyone wishing to use,
 **  modify, copy, or redistribute it subject to the terms and conditions
@@ -19,6 +19,7 @@ void dlm_lowcomms_stop(void);
 int dlm_lowcomms_close(int nodeid);
 void *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc);
 void dlm_lowcomms_commit_buffer(void *mh);
+int dlm_lowcomms_connect_node(int nodeid);
 
 #endif				/* __LOWCOMMS_DOT_H__ */
 

commit ac33d0710595579e3cfca42dde2257eb0b123f6d
Author: Patrick Caulfield <pcaulfie@redhat.com>
Date:   Wed Dec 6 15:10:37 2006 +0000

    [DLM] Clean up lowcomms
    
    This fixes up most of the things pointed out by akpm and Pavel Machek
    with comments below indicating why some things have been left:
    
    Andrew Morton wrote:
    >
    >> +static struct nodeinfo *nodeid2nodeinfo(int nodeid, gfp_t alloc)
    >> +{
    >> +    struct nodeinfo *ni;
    >> +    int r;
    >> +    int n;
    >> +
    >> +    down_read(&nodeinfo_lock);
    >
    > Given that this function can sleep, I wonder if `alloc' is useful.
    >
    > I see lots of callers passing in a literal "0" for `alloc'.  That's in fact
    > a secret (GFP_ATOMIC & ~__GFP_HIGH).  I doubt if that's what you really
    > meant.  Particularly as the code could at least have used __GFP_WAIT (aka
    > GFP_NOIO) which is much, much more reliable than "0".  In fact "0" is the
    > least reliable mode possible.
    >
    > IOW, this is all bollixed up.
    
    When 0 is passed into nodeid2nodeinfo the function does not try to allocate a
    new structure at all. it's an indication that the caller only wants the nodeinfo
    struct for that nodeid if there actually is one in existance.
    I've tidied the function itself so it's more obvious, (and tidier!)
    
    >> +/* Data received from remote end */
    >> +static int receive_from_sock(void)
    >> +{
    >> +    int ret = 0;
    >> +    struct msghdr msg;
    >> +    struct kvec iov[2];
    >> +    unsigned len;
    >> +    int r;
    >> +    struct sctp_sndrcvinfo *sinfo;
    >> +    struct cmsghdr *cmsg;
    >> +    struct nodeinfo *ni;
    >> +
    >> +    /* These two are marginally too big for stack allocation, but this
    >> +     * function is (currently) only called by dlm_recvd so static should be
    >> +     * OK.
    >> +     */
    >> +    static struct sockaddr_storage msgname;
    >> +    static char incmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];
    >
    > whoa.  This is globally singly-threaded code??
    
    Yes. it is only ever run in the context of dlm_recvd.
    >>
    >> +static void initiate_association(int nodeid)
    >> +{
    >> +    struct sockaddr_storage rem_addr;
    >> +    static char outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];
    >
    > Another static buffer to worry about.  Globally singly-threaded code?
    
    Yes. Only ever called by dlm_sendd.
    
    >> +
    >> +/* Send a message */
    >> +static int send_to_sock(struct nodeinfo *ni)
    >> +{
    >> +    int ret = 0;
    >> +    struct writequeue_entry *e;
    >> +    int len, offset;
    >> +    struct msghdr outmsg;
    >> +    static char outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];
    >
    > Singly-threaded?
    
    Yep.
    
    >>
    >> +static void dealloc_nodeinfo(void)
    >> +{
    >> +    int i;
    >> +
    >> +    for (i=1; i<=max_nodeid; i++) {
    >> +            struct nodeinfo *ni = nodeid2nodeinfo(i, 0);
    >> +            if (ni) {
    >> +                    idr_remove(&nodeinfo_idr, i);
    >
    > Didn't that need locking?
    
    Not. it's only ever called at DLM shutdown after all the other threads
    have been stopped.
    
    >>
    >> +static int write_list_empty(void)
    >> +{
    >> +    int status;
    >> +
    >> +    spin_lock_bh(&write_nodes_lock);
    >> +    status = list_empty(&write_nodes);
    >> +    spin_unlock_bh(&write_nodes_lock);
    >> +
    >> +    return status;
    >> +}
    >
    > This function's return value is meaningless.  As soon as the lock gets
    > dropped, the return value can get out of sync with reality.
    >
    > Looking at the caller, this _might_ happen to be OK, but it's a nasty and
    > dangerous thing.  Really the locking should be moved into the caller.
    
    It's just an optimisation to allow the caller to schedule if there is no work
    to do. if something arrives immediately afterwards then it will get picked up
    when the process re-awakes (and it will be woken by that arrival).
    
    The 'accepting' atomic has gone completely. as Andrew pointed out it didn't
    really achieve much anyway. I suspect it was a plaster over some other
    startup or shutdown bug to be honest.
    
    
    Signed-off-by: Patrick Caulfield <pcaulfie@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Andrew Morton <akpm@osdl.org>
    Cc: Pavel Machek <pavel@ucw.cz>

diff --git a/fs/dlm/lowcomms.h b/fs/dlm/lowcomms.h
index 2d045e0daae1..a9a9618c0d3f 100644
--- a/fs/dlm/lowcomms.h
+++ b/fs/dlm/lowcomms.h
@@ -14,8 +14,6 @@
 #ifndef __LOWCOMMS_DOT_H__
 #define __LOWCOMMS_DOT_H__
 
-int dlm_lowcomms_init(void);
-void dlm_lowcomms_exit(void);
 int dlm_lowcomms_start(void);
 void dlm_lowcomms_stop(void);
 int dlm_lowcomms_close(int nodeid);

commit 38d6fd26ea7f291141039fe340a581dc6f770fc0
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Mon Oct 9 20:27:30 2006 +0100

    [PATCH] dlm gfp_t annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/dlm/lowcomms.h b/fs/dlm/lowcomms.h
index 6c04bb09cfa8..2d045e0daae1 100644
--- a/fs/dlm/lowcomms.h
+++ b/fs/dlm/lowcomms.h
@@ -19,7 +19,7 @@ void dlm_lowcomms_exit(void);
 int dlm_lowcomms_start(void);
 void dlm_lowcomms_stop(void);
 int dlm_lowcomms_close(int nodeid);
-void *dlm_lowcomms_get_buffer(int nodeid, int len, int allocation, char **ppc);
+void *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc);
 void dlm_lowcomms_commit_buffer(void *mh);
 
 #endif				/* __LOWCOMMS_DOT_H__ */

commit 1c032c03117c014512195f2e33c3af999f132146
Author: David Teigland <teigland@redhat.com>
Date:   Fri Apr 28 10:50:41 2006 -0400

    [DLM] PATCH 2/3 dlm: lowcomms close
    
    When a node is removed from a lockspace configuration, close our
    connection to it, clearing any remaining messages for it.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Patrick Caulfield <pcaulfie@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/dlm/lowcomms.h b/fs/dlm/lowcomms.h
index 3af8035ff12f..6c04bb09cfa8 100644
--- a/fs/dlm/lowcomms.h
+++ b/fs/dlm/lowcomms.h
@@ -18,6 +18,7 @@ int dlm_lowcomms_init(void);
 void dlm_lowcomms_exit(void);
 int dlm_lowcomms_start(void);
 void dlm_lowcomms_stop(void);
+int dlm_lowcomms_close(int nodeid);
 void *dlm_lowcomms_get_buffer(int nodeid, int len, int allocation, char **ppc);
 void dlm_lowcomms_commit_buffer(void *mh);
 

commit e7fd41792fc0ee52a05fcaac87511f118328d147
Author: David Teigland <teigland@redhat.com>
Date:   Wed Jan 18 09:30:29 2006 +0000

    [DLM] The core of the DLM for GFS2/CLVM
    
    This is the core of the distributed lock manager which is required
    to use GFS2 as a cluster filesystem. It is also used by CLVM and
    can be used as a standalone lock manager independantly of either
    of these two projects.
    
    It implements VAX-style locking modes.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steve Whitehouse <swhiteho@redhat.com>

diff --git a/fs/dlm/lowcomms.h b/fs/dlm/lowcomms.h
new file mode 100644
index 000000000000..3af8035ff12f
--- /dev/null
+++ b/fs/dlm/lowcomms.h
@@ -0,0 +1,25 @@
+/******************************************************************************
+*******************************************************************************
+**
+**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
+**  Copyright (C) 2004-2005 Red Hat, Inc.  All rights reserved.
+**
+**  This copyrighted material is made available to anyone wishing to use,
+**  modify, copy, or redistribute it subject to the terms and conditions
+**  of the GNU General Public License v.2.
+**
+*******************************************************************************
+******************************************************************************/
+
+#ifndef __LOWCOMMS_DOT_H__
+#define __LOWCOMMS_DOT_H__
+
+int dlm_lowcomms_init(void);
+void dlm_lowcomms_exit(void);
+int dlm_lowcomms_start(void);
+void dlm_lowcomms_stop(void);
+void *dlm_lowcomms_get_buffer(int nodeid, int len, int allocation, char **ppc);
+void dlm_lowcomms_commit_buffer(void *mh);
+
+#endif				/* __LOWCOMMS_DOT_H__ */
+
