commit 8a8dcabffb991a08fa1fab4e75b80a9075825606
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 13 21:04:45 2018 +0200

    tty: replace ->proc_fops with ->proc_show
    
    Just set up the show callback in the tty_operations, and use
    proc_create_single_data to create the file without additional
    boilerplace code.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index b1a4a8ddd246..c69ff191e5d8 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -135,11 +135,11 @@ void proc_tty_register_driver(struct tty_driver *driver)
 	struct proc_dir_entry *ent;
 		
 	if (!driver->driver_name || driver->proc_entry ||
-	    !driver->ops->proc_fops)
+	    !driver->ops->proc_show)
 		return;
 
-	ent = proc_create_data(driver->driver_name, 0, proc_tty_driver,
-			       driver->ops->proc_fops, driver);
+	ent = proc_create_single_data(driver->driver_name, 0, proc_tty_driver,
+			       driver->ops->proc_show, driver);
 	driver->proc_entry = ent;
 }
 

commit fddda2b7b521185f3aa018f9559eb33b0aee53a9
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 13 19:44:18 2018 +0200

    proc: introduce proc_create_seq{,_data}
    
    Variants of proc_create{,_data} that directly take a struct seq_operations
    argument and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index d0cf1c50bb6c..b1a4a8ddd246 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -126,18 +126,6 @@ static const struct seq_operations tty_drivers_op = {
 	.show	= show_tty_driver
 };
 
-static int tty_drivers_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &tty_drivers_op);
-}
-
-static const struct file_operations proc_tty_drivers_operations = {
-	.open		= tty_drivers_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= seq_release,
-};
-
 /*
  * This function is called by tty_register_driver() to handle
  * registering the driver's /proc handler into /proc/tty/driver/<foo>
@@ -186,6 +174,6 @@ void __init proc_tty_init(void)
 	 * entry.
 	 */
 	proc_tty_driver = proc_mkdir_mode("tty/driver", S_IRUSR|S_IXUSR, NULL);
-	proc_create("tty/ldiscs", 0, NULL, &tty_ldiscs_proc_fops);
-	proc_create("tty/drivers", 0, NULL, &proc_tty_drivers_operations);
+	proc_create_seq("tty/ldiscs", 0, NULL, &tty_ldiscs_seq_ops);
+	proc_create_seq("tty/drivers", 0, NULL, &tty_drivers_op);
 }

commit fb0255fb2941ef6f21742b2bc146d6b9aef4fedc
Merge: 449fcf3ab0ba 57f5d648c45c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 21:05:31 2017 -0800

    Merge tag 'tty-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial updates from Greg KH:
     "Here is the big tty/serial driver pull request for 4.15-rc1.
    
      Lots of serial driver updates in here, some small vt cleanups, and a
      raft of SPDX and license boilerplate cleanups, messing up the diffstat
      a bit.
    
      Nothing major, with no realy functional changes except better hardware
      support for some platforms.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'tty-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (110 commits)
      tty: ehv_bytechan: fix spelling mistake
      tty: serial: meson: allow baud-rates lower than 9600
      serial: 8250_fintek: Fix crash with baud rate B0
      serial: 8250_fintek: Disable delays for ports != 0
      serial: 8250_fintek: Return -EINVAL on invalid configuration
      tty: Remove redundant license text
      tty: serdev: Remove redundant license text
      tty: hvc: Remove redundant license text
      tty: serial: Remove redundant license text
      tty: add SPDX identifiers to all remaining files in drivers/tty/
      tty: serial: jsm: remove redundant pointer ts
      tty: serial: jsm: add space before the open parenthesis '('
      tty: serial: jsm: fix coding style
      tty: serial: jsm: delete space between function name and '('
      tty: serial: jsm: add blank line after declarations
      tty: serial: jsm: change the type of local variable
      tty: serial: imx: remove dead code imx_dma_rxint
      tty: serial: imx: disable ageing timer interrupt if dma in use
      serial: 8250: fix potential deadlock in rs485-mode
      serial: m32r_sio: Drop redundant .data assignment
      ...

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 901bd06f437d..2da657848cfc 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * proc_tty.c -- handles /proc/tty
  *

commit c79dde629d2027ca80329c62854a7635e623d527
Author: nixiaoming <nixiaoming@huawei.com>
Date:   Fri Sep 15 17:45:56 2017 +0800

    tty fix oops when rmmod 8250
    
    After rmmod 8250.ko
    tty_kref_put starts kwork (release_one_tty) to release proc interface
    oops when accessing driver->driver_name in proc_tty_unregister_driver
    
    Use jprobe, found driver->driver_name point to 8250.ko
    static static struct uart_driver serial8250_reg
    .driver_name= serial,
    
    Use name in proc_dir_entry instead of driver->driver_name to fix oops
    
    test on linux 4.1.12:
    
    BUG: unable to handle kernel paging request at ffffffffa01979de
    IP: [<ffffffff81310f40>] strchr+0x0/0x30
    PGD 1a0d067 PUD 1a0e063 PMD 851c1f067 PTE 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in: ... ...  [last unloaded: 8250]
    CPU: 7 PID: 116 Comm: kworker/7:1 Tainted: G           O    4.1.12 #1
    Hardware name: Insyde RiverForest/Type2 - Board Product Name1, BIOS NE5KV904 12/21/2015
    Workqueue: events release_one_tty
    task: ffff88085b684960 ti: ffff880852884000 task.ti: ffff880852884000
    RIP: 0010:[<ffffffff81310f40>]  [<ffffffff81310f40>] strchr+0x0/0x30
    RSP: 0018:ffff880852887c90  EFLAGS: 00010282
    RAX: ffffffff81a5eca0 RBX: ffffffffa01979de RCX: 0000000000000004
    RDX: ffff880852887d10 RSI: 000000000000002f RDI: ffffffffa01979de
    RBP: ffff880852887cd8 R08: 0000000000000000 R09: ffff88085f5d94d0
    R10: 0000000000000195 R11: 0000000000000000 R12: ffffffffa01979de
    R13: ffff880852887d00 R14: ffffffffa01979de R15: ffff88085f02e840
    FS:  0000000000000000(0000) GS:ffff88085f5c0000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: ffffffffa01979de CR3: 0000000001a0c000 CR4: 00000000001406e0
    Stack:
     ffffffff812349b1 ffff880852887cb8 ffff880852887d10 ffff88085f5cd6c2
     ffff880852800a80 ffffffffa01979de ffff880852800a84 0000000000000010
     ffff88085bb28bd8 ffff880852887d38 ffffffff812354f0 ffff880852887d08
    Call Trace:
     [<ffffffff812349b1>] ? __xlate_proc_name+0x71/0xd0
     [<ffffffff812354f0>] remove_proc_entry+0x40/0x180
     [<ffffffff815f6811>] ? _raw_spin_lock_irqsave+0x41/0x60
     [<ffffffff813be520>] ? destruct_tty_driver+0x60/0xe0
     [<ffffffff81237c68>] proc_tty_unregister_driver+0x28/0x40
     [<ffffffff813be548>] destruct_tty_driver+0x88/0xe0
     [<ffffffff813be5bd>] tty_driver_kref_put+0x1d/0x20
     [<ffffffff813becca>] release_one_tty+0x5a/0xd0
     [<ffffffff81074159>] process_one_work+0x139/0x420
     [<ffffffff810745a1>] worker_thread+0x121/0x450
     [<ffffffff81074480>] ? process_scheduled_works+0x40/0x40
     [<ffffffff8107a16c>] kthread+0xec/0x110
     [<ffffffff81080000>] ? tg_rt_schedulable+0x210/0x220
     [<ffffffff8107a080>] ? kthread_freezable_should_stop+0x80/0x80
     [<ffffffff815f7292>] ret_from_fork+0x42/0x70
     [<ffffffff8107a080>] ? kthread_freezable_should_stop+0x80/0x80
    
    Signed-off-by: nixiaoming <nixiaoming@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 901bd06f437d..20e2c18e2b47 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -14,6 +14,7 @@
 #include <linux/tty.h>
 #include <linux/seq_file.h>
 #include <linux/bitops.h>
+#include "internal.h"
 
 /*
  * The /proc/tty directory inodes...
@@ -164,7 +165,7 @@ void proc_tty_unregister_driver(struct tty_driver *driver)
 	if (!ent)
 		return;
 		
-	remove_proc_entry(driver->driver_name, proc_tty_driver);
+	remove_proc_entry(ent->name, proc_tty_driver);
 	
 	driver->proc_entry = NULL;
 }

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 15f327bed8c6..901bd06f437d 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -4,7 +4,7 @@
  * Copyright 1997, Theodore Ts'o
  */
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/errno.h>

commit 849d20a12822cba355c054ab0bfe490473413cce
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Aug 8 14:21:31 2014 -0700

    proc: remove proc_tty_ldisc variable
    
    /proc/tty/ldisc appear to be unused as a directory and
    it had been always that way.
    
    But it is userspace visible thing.
    
    Cowardly remove only in-kernel variable holding it.
    
    [akpm@linux-foundation.org: add comment]
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index cb761f010300..15f327bed8c6 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -18,7 +18,7 @@
 /*
  * The /proc/tty directory inodes...
  */
-static struct proc_dir_entry *proc_tty_ldisc, *proc_tty_driver;
+static struct proc_dir_entry *proc_tty_driver;
 
 /*
  * This is the handler for /proc/tty/drivers
@@ -176,7 +176,7 @@ void __init proc_tty_init(void)
 {
 	if (!proc_mkdir("tty", NULL))
 		return;
-	proc_tty_ldisc = proc_mkdir("tty/ldisc", NULL);
+	proc_mkdir("tty/ldisc", NULL);	/* Preserved: it's userspace visible */
 	/*
 	 * /proc/tty/driver/serial reveals the exact character counts for
 	 * serial links which is just too easy to abuse for inferring

commit 9d6de12f70d2fb1487c4f482a21fed25fe74e0fd
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Jan 12 17:00:32 2011 -0800

    proc: use seq_puts()/seq_putc() where possible
    
    For string without format specifiers, use seq_puts().
    For seq_printf("\n"), use seq_putc('\n').
    
       text    data     bss     dec     hex filename
      61866     488     112   62466    f402 fs/proc/proc.o
      61729     488     112   62329    f379 fs/proc/proc.o
      ----------------------------------------------------
                               -139
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 83adcc869437..cb761f010300 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -36,27 +36,27 @@ static void show_tty_range(struct seq_file *m, struct tty_driver *p,
 	}
 	switch (p->type) {
 	case TTY_DRIVER_TYPE_SYSTEM:
-		seq_printf(m, "system");
+		seq_puts(m, "system");
 		if (p->subtype == SYSTEM_TYPE_TTY)
-			seq_printf(m, ":/dev/tty");
+			seq_puts(m, ":/dev/tty");
 		else if (p->subtype == SYSTEM_TYPE_SYSCONS)
-			seq_printf(m, ":console");
+			seq_puts(m, ":console");
 		else if (p->subtype == SYSTEM_TYPE_CONSOLE)
-			seq_printf(m, ":vtmaster");
+			seq_puts(m, ":vtmaster");
 		break;
 	case TTY_DRIVER_TYPE_CONSOLE:
-		seq_printf(m, "console");
+		seq_puts(m, "console");
 		break;
 	case TTY_DRIVER_TYPE_SERIAL:
-		seq_printf(m, "serial");
+		seq_puts(m, "serial");
 		break;
 	case TTY_DRIVER_TYPE_PTY:
 		if (p->subtype == PTY_TYPE_MASTER)
-			seq_printf(m, "pty:master");
+			seq_puts(m, "pty:master");
 		else if (p->subtype == PTY_TYPE_SLAVE)
-			seq_printf(m, "pty:slave");
+			seq_puts(m, "pty:slave");
 		else
-			seq_printf(m, "pty");
+			seq_puts(m, "pty");
 		break;
 	default:
 		seq_printf(m, "type:%d.%d", p->type, p->subtype);
@@ -74,19 +74,19 @@ static int show_tty_driver(struct seq_file *m, void *v)
 		/* pseudo-drivers first */
 		seq_printf(m, "%-20s /dev/%-8s ", "/dev/tty", "tty");
 		seq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 0);
-		seq_printf(m, "system:/dev/tty\n");
+		seq_puts(m, "system:/dev/tty\n");
 		seq_printf(m, "%-20s /dev/%-8s ", "/dev/console", "console");
 		seq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 1);
-		seq_printf(m, "system:console\n");
+		seq_puts(m, "system:console\n");
 #ifdef CONFIG_UNIX98_PTYS
 		seq_printf(m, "%-20s /dev/%-8s ", "/dev/ptmx", "ptmx");
 		seq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 2);
-		seq_printf(m, "system\n");
+		seq_puts(m, "system\n");
 #endif
 #ifdef CONFIG_VT
 		seq_printf(m, "%-20s /dev/%-8s ", "/dev/vc/0", "vc/0");
 		seq_printf(m, "%3d %7d ", TTY_MAJOR, 0);
-		seq_printf(m, "system:vtmaster\n");
+		seq_puts(m, "system:vtmaster\n");
 #endif
 	}
 

commit 6c2754c28f2388a276fe21edde826f2113c8f60e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 23 08:14:12 2010 -0700

    Revert "tty: Add a new file /proc/tty/consoles"
    
    This reverts commit f4a3e0bceb57466c31757f25e4e0ed108d1299ec.  Jiri
    Sladby points out that the tty structure we're using may already be
    gone, and Al Viro doesn't hold back in complaining about the random
    loading of 'filp->private_data' which doesn't have to be a pointer at
    all, nor does checking the magic field for TTY_MAGIC prove anything.
    
    Belated review by Al:
    
     "a) global variable depending on stdin of the last opener? Affecting
         output of read(2)? Really?
    
      b) iterator is broken; list should be locked in ->start(), unlocked in
         ->stop() and *NOT* unlocked/relocked in ->next()
    
      c) ->show() ought to do nothing in case of ->device == NULL, instead
         of skipping those in ->next()/->start()
    
      d) regardless of the merits of the bright idea about asterisk at that
         line in output *and* regardless of (a), the implementation is not
         only atrociously ugly, it's actually very likely to be a roothole.
         Verifying that Cthulhu knows what number happens to be address of a
         tty_struct by blindly dereferencing memory at that address...
         Ouch.
    
      Please revert that crap."
    
    And Christoph pipes in and NAK's the approach of walking fd tables etc
    too.  So it's pretty unanimous.
    
    Noticed-by: Jri Slaby <jslaby@suse.cz>
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Werner Fink <werner@suse.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index dc44f94022f1..83adcc869437 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -12,10 +12,7 @@
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
 #include <linux/tty.h>
-#include <linux/tty_driver.h>
-#include <linux/console.h>
 #include <linux/seq_file.h>
-#include <linux/fdtable.h>
 #include <linux/bitops.h>
 
 /*
@@ -139,160 +136,6 @@ static const struct file_operations proc_tty_drivers_operations = {
 	.release	= seq_release,
 };
 
-/*
- * The device ID of file descriptor 0 of the current reading
- * task if a character device...
- */
-static dev_t current_dev;
-
-/*
- * This is the handler for /proc/tty/consoles
- */
-static int show_console_dev(struct seq_file *m, void *v)
-{
-	const struct tty_driver *driver;
-	struct console *con;
-	int index, len;
-	char flags[10];
-	dev_t dev;
-
-	if (v == SEQ_START_TOKEN)
-		return 0;
-	con = (struct console *)v;
-	if (!con)
-		return 0;
-	driver = con->device(con, &index);
-	if (!driver)
-		return 0;
-	dev = MKDEV(driver->major, driver->minor_start) + index;
-
-	index = 0;
-	if (con->flags & CON_ENABLED)
-		flags[index++] = 'E';
-	if (con->flags & CON_CONSDEV)
-		flags[index++] = 'C';
-	if (con->flags & CON_BOOT)
-		flags[index++] = 'B';
-	if (con->flags & CON_PRINTBUFFER)
-		flags[index++] = 'p';
-	if (con->flags & CON_BRL)
-		flags[index++] = 'b';
-	if (con->flags & CON_ANYTIME)
-		flags[index++] = 'a';
-	if (current_dev == dev)
-		flags[index++] = '*';
-	flags[index] = 0;
-
-	seq_printf(m, "%s%d%n", con->name, con->index, &len);
-	len = 21 - len;
-	if (len < 1)
-		len = 1;
-	seq_printf(m, "%*c", len, ' ');
-	seq_printf(m, "%c%c%c (%s)%n", con->read ? 'R' : '-',
-			con->write ? 'W' : '-', con->unblank ? 'U' : '-',
-			flags, &len);
-	len = 13 - len;
-	if (len < 1)
-		len = 1;
-	seq_printf(m, "%*c%4d:%d\n", len, ' ', MAJOR(dev), MINOR(dev));
-
-	return 0;
-}
-
-/* iterator for consoles */
-static void *c_start(struct seq_file *m, loff_t *pos)
-{
-	struct console *con;
-	loff_t off = 0;
-
-	if (*pos == 0)
-		return SEQ_START_TOKEN;
-
-	acquire_console_sem();
-	for (con = console_drivers; con; con = con->next) {
-		if (!con->device)
-			continue;
-		if (++off == *pos)
-			break;
-	}
-	release_console_sem();
-
-	return con;
-}
-
-static void *c_next(struct seq_file *m, void *v, loff_t *pos)
-{
-	struct console *con;
-
-	acquire_console_sem();
-	if (v == SEQ_START_TOKEN)
-		con = console_drivers;
-	else
-		con = ((struct console *)v)->next;
-	for (; con; con = con->next) {
-		if (!con->device)
-			continue;
-		++*pos;
-		break;
-	}
-	release_console_sem();
-
-	return con;
-}
-
-static void c_stop(struct seq_file *m, void *v)
-{
-}
-
-static const struct seq_operations tty_consoles_op = {
-	.start	= c_start,
-	.next	= c_next,
-	.stop	= c_stop,
-	.show	= show_console_dev
-};
-
-/*
- * Used for open /proc/tty/consoles. Before this detect
- * the device ID of file descriptor 0 of the current
- * reading task if a character device...
- */
-static int tty_consoles_open(struct inode *inode, struct file *file)
-{
-	struct files_struct *curfiles;
-
-	current_dev = 0;
-	curfiles = get_files_struct(current);
-	if (curfiles) {
-		const struct file *curfp;
-		spin_lock(&curfiles->file_lock);
-		curfp = fcheck_files(curfiles, 0);
-		if (curfp && curfp->private_data) {
-			const struct inode *inode;
-			dget(curfp->f_dentry);
-			inode = curfp->f_dentry->d_inode;
-			if (S_ISCHR(inode->i_mode)) {
-				struct tty_struct *tty;
-				tty = (struct tty_struct *)curfp->private_data;
-				if (tty && tty->magic == TTY_MAGIC) {
-					tty = tty_pair_get_tty(tty);
-					current_dev = tty_devnum(tty);
-				}
-			}
-			dput(curfp->f_dentry);
-		}
-		spin_unlock(&curfiles->file_lock);
-		put_files_struct(curfiles);
-	}
-	return seq_open(file, &tty_consoles_op);
-}
-
-static const struct file_operations proc_tty_consoles_operations = {
-	.open		= tty_consoles_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= seq_release,
-};
-
 /*
  * This function is called by tty_register_driver() to handle
  * registering the driver's /proc handler into /proc/tty/driver/<foo>
@@ -343,5 +186,4 @@ void __init proc_tty_init(void)
 	proc_tty_driver = proc_mkdir_mode("tty/driver", S_IRUSR|S_IXUSR, NULL);
 	proc_create("tty/ldiscs", 0, NULL, &tty_ldiscs_proc_fops);
 	proc_create("tty/drivers", 0, NULL, &proc_tty_drivers_operations);
-	proc_create("tty/consoles", 0, NULL, &proc_tty_consoles_operations);
 }

commit f4a3e0bceb57466c31757f25e4e0ed108d1299ec
Author: Dr. Werner Fink <werner@suse.de>
Date:   Wed Sep 22 12:45:40 2010 +0200

    tty: Add a new file /proc/tty/consoles
    
    Add a new file /proc/tty/consoles to be able to determine the registered
    system console lines.  If the reading process holds /dev/console open at
    the regular standard input stream the active device will be marked by an
    asterisk.  Show possible operations and also decode the used flags of
    the listed console lines.
    
    Signed-off-by: Werner Fink <werner@suse.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 83adcc869437..dc44f94022f1 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -12,7 +12,10 @@
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
 #include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/console.h>
 #include <linux/seq_file.h>
+#include <linux/fdtable.h>
 #include <linux/bitops.h>
 
 /*
@@ -136,6 +139,160 @@ static const struct file_operations proc_tty_drivers_operations = {
 	.release	= seq_release,
 };
 
+/*
+ * The device ID of file descriptor 0 of the current reading
+ * task if a character device...
+ */
+static dev_t current_dev;
+
+/*
+ * This is the handler for /proc/tty/consoles
+ */
+static int show_console_dev(struct seq_file *m, void *v)
+{
+	const struct tty_driver *driver;
+	struct console *con;
+	int index, len;
+	char flags[10];
+	dev_t dev;
+
+	if (v == SEQ_START_TOKEN)
+		return 0;
+	con = (struct console *)v;
+	if (!con)
+		return 0;
+	driver = con->device(con, &index);
+	if (!driver)
+		return 0;
+	dev = MKDEV(driver->major, driver->minor_start) + index;
+
+	index = 0;
+	if (con->flags & CON_ENABLED)
+		flags[index++] = 'E';
+	if (con->flags & CON_CONSDEV)
+		flags[index++] = 'C';
+	if (con->flags & CON_BOOT)
+		flags[index++] = 'B';
+	if (con->flags & CON_PRINTBUFFER)
+		flags[index++] = 'p';
+	if (con->flags & CON_BRL)
+		flags[index++] = 'b';
+	if (con->flags & CON_ANYTIME)
+		flags[index++] = 'a';
+	if (current_dev == dev)
+		flags[index++] = '*';
+	flags[index] = 0;
+
+	seq_printf(m, "%s%d%n", con->name, con->index, &len);
+	len = 21 - len;
+	if (len < 1)
+		len = 1;
+	seq_printf(m, "%*c", len, ' ');
+	seq_printf(m, "%c%c%c (%s)%n", con->read ? 'R' : '-',
+			con->write ? 'W' : '-', con->unblank ? 'U' : '-',
+			flags, &len);
+	len = 13 - len;
+	if (len < 1)
+		len = 1;
+	seq_printf(m, "%*c%4d:%d\n", len, ' ', MAJOR(dev), MINOR(dev));
+
+	return 0;
+}
+
+/* iterator for consoles */
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	struct console *con;
+	loff_t off = 0;
+
+	if (*pos == 0)
+		return SEQ_START_TOKEN;
+
+	acquire_console_sem();
+	for (con = console_drivers; con; con = con->next) {
+		if (!con->device)
+			continue;
+		if (++off == *pos)
+			break;
+	}
+	release_console_sem();
+
+	return con;
+}
+
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	struct console *con;
+
+	acquire_console_sem();
+	if (v == SEQ_START_TOKEN)
+		con = console_drivers;
+	else
+		con = ((struct console *)v)->next;
+	for (; con; con = con->next) {
+		if (!con->device)
+			continue;
+		++*pos;
+		break;
+	}
+	release_console_sem();
+
+	return con;
+}
+
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+static const struct seq_operations tty_consoles_op = {
+	.start	= c_start,
+	.next	= c_next,
+	.stop	= c_stop,
+	.show	= show_console_dev
+};
+
+/*
+ * Used for open /proc/tty/consoles. Before this detect
+ * the device ID of file descriptor 0 of the current
+ * reading task if a character device...
+ */
+static int tty_consoles_open(struct inode *inode, struct file *file)
+{
+	struct files_struct *curfiles;
+
+	current_dev = 0;
+	curfiles = get_files_struct(current);
+	if (curfiles) {
+		const struct file *curfp;
+		spin_lock(&curfiles->file_lock);
+		curfp = fcheck_files(curfiles, 0);
+		if (curfp && curfp->private_data) {
+			const struct inode *inode;
+			dget(curfp->f_dentry);
+			inode = curfp->f_dentry->d_inode;
+			if (S_ISCHR(inode->i_mode)) {
+				struct tty_struct *tty;
+				tty = (struct tty_struct *)curfp->private_data;
+				if (tty && tty->magic == TTY_MAGIC) {
+					tty = tty_pair_get_tty(tty);
+					current_dev = tty_devnum(tty);
+				}
+			}
+			dput(curfp->f_dentry);
+		}
+		spin_unlock(&curfiles->file_lock);
+		put_files_struct(curfiles);
+	}
+	return seq_open(file, &tty_consoles_op);
+}
+
+static const struct file_operations proc_tty_consoles_operations = {
+	.open		= tty_consoles_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
 /*
  * This function is called by tty_register_driver() to handle
  * registering the driver's /proc handler into /proc/tty/driver/<foo>
@@ -186,4 +343,5 @@ void __init proc_tty_init(void)
 	proc_tty_driver = proc_mkdir_mode("tty/driver", S_IRUSR|S_IXUSR, NULL);
 	proc_create("tty/ldiscs", 0, NULL, &tty_ldiscs_proc_fops);
 	proc_create("tty/drivers", 0, NULL, &proc_tty_drivers_operations);
+	proc_create("tty/consoles", 0, NULL, &proc_tty_consoles_operations);
 }

commit 0f043a81ebe84be3576667f04fdda481609e3816
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 31 15:19:25 2009 -0700

    proc tty: remove struct tty_operations::read_proc
    
    struct tty_operations::proc_fops took it's place and there is one less
    create_proc_read_entry() user now!
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 854827b1d463..83adcc869437 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -144,22 +144,12 @@ void proc_tty_register_driver(struct tty_driver *driver)
 {
 	struct proc_dir_entry *ent;
 		
-	if (!driver->driver_name || driver->proc_entry)
+	if (!driver->driver_name || driver->proc_entry ||
+	    !driver->ops->proc_fops)
 		return;
 
-	if (driver->ops->proc_fops) {
-		ent = proc_create_data(driver->driver_name, 0, proc_tty_driver,
-				       driver->ops->proc_fops, driver);
-		if (!ent)
-			return;
-	} else if (driver->ops->read_proc) {
-		ent = create_proc_entry(driver->driver_name, 0, proc_tty_driver);
-		if (!ent)
-			return;
-		ent->read_proc = driver->ops->read_proc;
-		ent->data = driver;
-	} else
-		return;
+	ent = proc_create_data(driver->driver_name, 0, proc_tty_driver,
+			       driver->ops->proc_fops, driver);
 	driver->proc_entry = ent;
 }
 

commit ae149b6bec64a09373ba20fce75f8aa6b14b78fd
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 31 15:19:15 2009 -0700

    proc tty: add struct tty_operations::proc_fops
    
    Used for gradual switch of TTY drivers from using ->read_proc which helps
    with gradual switch from ->read_proc for the whole tree.
    
    As side effect, fix possible race condition when ->data initialized after
    PDE is hooked into proc tree.
    
    ->proc_fops takes precedence over ->read_proc.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 4a9e0f65ae60..854827b1d463 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -144,16 +144,22 @@ void proc_tty_register_driver(struct tty_driver *driver)
 {
 	struct proc_dir_entry *ent;
 		
-	if (!driver->ops->read_proc || !driver->driver_name ||
-	    driver->proc_entry)
+	if (!driver->driver_name || driver->proc_entry)
 		return;
 
-	ent = create_proc_entry(driver->driver_name, 0, proc_tty_driver);
-	if (!ent)
+	if (driver->ops->proc_fops) {
+		ent = proc_create_data(driver->driver_name, 0, proc_tty_driver,
+				       driver->ops->proc_fops, driver);
+		if (!ent)
+			return;
+	} else if (driver->ops->read_proc) {
+		ent = create_proc_entry(driver->driver_name, 0, proc_tty_driver);
+		if (!ent)
+			return;
+		ent->read_proc = driver->ops->read_proc;
+		ent->data = driver;
+	} else
 		return;
-	ent->read_proc = driver->ops->read_proc;
-	ent->data = driver;
-
 	driver->proc_entry = ent;
 }
 

commit 99b76233803beab302123d243eea9e41149804f3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 25 22:48:06 2009 +0300

    proc 2/2: remove struct proc_dir_entry::owner
    
    Setting ->owner as done currently (pde->owner = THIS_MODULE) is racy
    as correctly noted at bug #12454. Someone can lookup entry with NULL
    ->owner, thus not pinning enything, and release it later resulting
    in module refcount underflow.
    
    We can keep ->owner and supply it at registration time like ->proc_fops
    and ->data.
    
    But this leaves ->owner as easy-manipulative field (just one C assignment)
    and somebody will forget to unpin previous/pin current module when
    switching ->owner. ->proc_fops is declared as "const" which should give
    some thoughts.
    
    ->read_proc/->write_proc were just fixed to not require ->owner for
    protection.
    
    rmmod'ed directories will be empty and return "." and ".." -- no harm.
    And directories with tricky enough readdir and lookup shouldn't be modular.
    We definitely don't want such modular code.
    
    Removing ->owner will also make PDE smaller.
    
    So, let's nuke it.
    
    Kudos to Jeff Layton for reminding about this, let's say, oversight.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12454
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index d153946d6d15..4a9e0f65ae60 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -152,7 +152,6 @@ void proc_tty_register_driver(struct tty_driver *driver)
 	if (!ent)
 		return;
 	ent->read_proc = driver->ops->read_proc;
-	ent->owner = driver->owner;
 	ent->data = driver;
 
 	driver->proc_entry = ent;

commit a352def21a642133758b868c71bee12ab34ad5c5
Author: Alan Cox <alan@redhat.com>
Date:   Wed Jul 16 21:53:12 2008 +0100

    tty: Ldisc revamp
    
    Move the line disciplines towards a conventional ->ops arrangement.  For
    the moment the actual 'tty_ldisc' struct in the tty is kept as part of
    the tty struct but this can then be changed if it turns out that when it
    all settles down we want to refcount ldiscs separately to the tty.
    
    Pull the ldisc code out of /proc and put it with our ldisc code.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 21f490f5d65c..d153946d6d15 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -136,54 +136,6 @@ static const struct file_operations proc_tty_drivers_operations = {
 	.release	= seq_release,
 };
 
-static void * tty_ldiscs_seq_start(struct seq_file *m, loff_t *pos)
-{
-	return (*pos < NR_LDISCS) ? pos : NULL;
-}
-
-static void * tty_ldiscs_seq_next(struct seq_file *m, void *v, loff_t *pos)
-{
-	(*pos)++;
-	return (*pos < NR_LDISCS) ? pos : NULL;
-}
-
-static void tty_ldiscs_seq_stop(struct seq_file *m, void *v)
-{
-}
-
-static int tty_ldiscs_seq_show(struct seq_file *m, void *v)
-{
-	int i = *(loff_t *)v;
-	struct tty_ldisc *ld;
-	
-	ld = tty_ldisc_get(i);
-	if (ld == NULL)
-		return 0;
-	seq_printf(m, "%-10s %2d\n", ld->name ? ld->name : "???", i);
-	tty_ldisc_put(i);
-	return 0;
-}
-
-static const struct seq_operations tty_ldiscs_seq_ops = {
-	.start	= tty_ldiscs_seq_start,
-	.next	= tty_ldiscs_seq_next,
-	.stop	= tty_ldiscs_seq_stop,
-	.show	= tty_ldiscs_seq_show,
-};
-
-static int proc_tty_ldiscs_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &tty_ldiscs_seq_ops);
-}
-
-static const struct file_operations tty_ldiscs_proc_fops = {
-	.owner		= THIS_MODULE,
-	.open		= proc_tty_ldiscs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= seq_release,
-};
-
 /*
  * This function is called by tty_register_driver() to handle
  * registering the driver's /proc handler into /proc/tty/driver/<foo>

commit f34d7a5b7010b82fe97da95496b9971435530062
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Apr 30 00:54:13 2008 -0700

    tty: The big operations rework
    
    - Operations are now a shared const function block as with most other Linux
      objects
    
    - Introduce wrappers for some optional functions to get consistent behaviour
    
    - Wrap put_char which used to be patched by the tty layer
    
    - Document which functions are needed/optional
    
    - Make put_char report success/fail
    
    - Cache the driver->ops pointer in the tty as tty->ops
    
    - Remove various surplus lock calls we no longer need
    
    - Remove proc_write method as noted by Alexey Dobriyan
    
    - Introduce some missing sanity checks where certain driver/ldisc
      combinations would oops as they didn't check needed methods were present
    
    [akpm@linux-foundation.org: fix fs/compat_ioctl.c build]
    [akpm@linux-foundation.org: fix isicom]
    [akpm@linux-foundation.org: fix arch/ia64/hp/sim/simserial.c build]
    [akpm@linux-foundation.org: fix kgdb]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index ac26ccc25f42..21f490f5d65c 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -192,16 +192,14 @@ void proc_tty_register_driver(struct tty_driver *driver)
 {
 	struct proc_dir_entry *ent;
 		
-	if ((!driver->read_proc && !driver->write_proc) ||
-	    !driver->driver_name ||
+	if (!driver->ops->read_proc || !driver->driver_name ||
 	    driver->proc_entry)
 		return;
 
 	ent = create_proc_entry(driver->driver_name, 0, proc_tty_driver);
 	if (!ent)
 		return;
-	ent->read_proc = driver->read_proc;
-	ent->write_proc = driver->write_proc;
+	ent->read_proc = driver->ops->read_proc;
 	ent->owner = driver->owner;
 	ent->data = driver;
 

commit b640a89ddd742782bd2d83873da30d4776d1b9c6
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Apr 29 01:01:58 2008 -0700

    proc: convert /proc/tty/ldiscs to seq_file interface
    
    Note: THIS_MODULE and header addition aren't technically needed because
          this code is not modular, but let's keep it anyway because people
          can copy this code into modular code.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 63f45383035d..ac26ccc25f42 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -5,7 +5,7 @@
  */
 
 #include <asm/uaccess.h>
-
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/time.h>
@@ -136,39 +136,54 @@ static const struct file_operations proc_tty_drivers_operations = {
 	.release	= seq_release,
 };
 
-/*
- * This is the handler for /proc/tty/ldiscs
- */
-static int tty_ldiscs_read_proc(char *page, char **start, off_t off,
-				int count, int *eof, void *data)
+static void * tty_ldiscs_seq_start(struct seq_file *m, loff_t *pos)
 {
-	int	i;
-	int	len = 0;
-	off_t	begin = 0;
+	return (*pos < NR_LDISCS) ? pos : NULL;
+}
+
+static void * tty_ldiscs_seq_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	(*pos)++;
+	return (*pos < NR_LDISCS) ? pos : NULL;
+}
+
+static void tty_ldiscs_seq_stop(struct seq_file *m, void *v)
+{
+}
+
+static int tty_ldiscs_seq_show(struct seq_file *m, void *v)
+{
+	int i = *(loff_t *)v;
 	struct tty_ldisc *ld;
 	
-	for (i=0; i < NR_LDISCS; i++) {
-		ld = tty_ldisc_get(i);
-		if (ld == NULL)
-			continue;
-		len += sprintf(page+len, "%-10s %2d\n",
-			       ld->name ? ld->name : "???", i);
-		tty_ldisc_put(i);
-		if (len+begin > off+count)
-			break;
-		if (len+begin < off) {
-			begin += len;
-			len = 0;
-		}
-	}
-	if (i >= NR_LDISCS)
-		*eof = 1;
-	if (off >= len+begin)
+	ld = tty_ldisc_get(i);
+	if (ld == NULL)
 		return 0;
-	*start = page + (off-begin);
-	return ((count < begin+len-off) ? count : begin+len-off);
+	seq_printf(m, "%-10s %2d\n", ld->name ? ld->name : "???", i);
+	tty_ldisc_put(i);
+	return 0;
+}
+
+static const struct seq_operations tty_ldiscs_seq_ops = {
+	.start	= tty_ldiscs_seq_start,
+	.next	= tty_ldiscs_seq_next,
+	.stop	= tty_ldiscs_seq_stop,
+	.show	= tty_ldiscs_seq_show,
+};
+
+static int proc_tty_ldiscs_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &tty_ldiscs_seq_ops);
 }
 
+static const struct file_operations tty_ldiscs_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_tty_ldiscs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
 /*
  * This function is called by tty_register_driver() to handle
  * registering the driver's /proc handler into /proc/tty/driver/<foo>
@@ -223,8 +238,7 @@ void __init proc_tty_init(void)
 	 * password lengths and inter-keystroke timings during password
 	 * entry.
 	 */
-	proc_tty_driver = proc_mkdir_mode("tty/driver", S_IRUSR | S_IXUSR, NULL);
-
-	create_proc_read_entry("tty/ldiscs", 0, NULL, tty_ldiscs_read_proc, NULL);
+	proc_tty_driver = proc_mkdir_mode("tty/driver", S_IRUSR|S_IXUSR, NULL);
+	proc_create("tty/ldiscs", 0, NULL, &tty_ldiscs_proc_fops);
 	proc_create("tty/drivers", 0, NULL, &proc_tty_drivers_operations);
 }

commit 0d5c9f5f59a61cf8e98e2925cb5d81cbe7694305
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Tue Apr 29 01:01:37 2008 -0700

    proc: switch to proc_create()
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 49816e00b51a..63f45383035d 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -214,7 +214,6 @@ void proc_tty_unregister_driver(struct tty_driver *driver)
  */
 void __init proc_tty_init(void)
 {
-	struct proc_dir_entry *entry;
 	if (!proc_mkdir("tty", NULL))
 		return;
 	proc_tty_ldisc = proc_mkdir("tty/ldisc", NULL);
@@ -227,7 +226,5 @@ void __init proc_tty_init(void)
 	proc_tty_driver = proc_mkdir_mode("tty/driver", S_IRUSR | S_IXUSR, NULL);
 
 	create_proc_read_entry("tty/ldiscs", 0, NULL, tty_ldiscs_read_proc, NULL);
-	entry = create_proc_entry("tty/drivers", 0, NULL);
-	if (entry)
-		entry->proc_fops = &proc_tty_drivers_operations;
+	proc_create("tty/drivers", 0, NULL, &proc_tty_drivers_operations);
 }

commit 03a44825be987d720df854f63b2f7bd30e46bdde
Author: Jan Engelhardt <jengelh@computergmbh.de>
Date:   Fri Feb 8 04:21:19 2008 -0800

    procfs: constify function pointer tables
    
    Signed-off-by: Jan Engelhardt <jengelh@computergmbh.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Acked-By: David Howells <dhowells@redhat.com>
    Acked-by: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 34296839b417..49816e00b51a 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -117,7 +117,7 @@ static void t_stop(struct seq_file *m, void *v)
 	mutex_unlock(&tty_mutex);
 }
 
-static struct seq_operations tty_drivers_op = {
+static const struct seq_operations tty_drivers_op = {
 	.start	= t_start,
 	.next	= t_next,
 	.stop	= t_stop,

commit 76df0c25d0c34eba9fbb8a44106ed096553ba0e8
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Fri Feb 8 04:18:27 2008 -0800

    proc: simplify function prototypes
    
    Move code around so as to reduce the number of forward-declarations.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 22846225acfa..34296839b417 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -15,9 +15,6 @@
 #include <linux/seq_file.h>
 #include <linux/bitops.h>
 
-static int tty_ldiscs_read_proc(char *page, char **start, off_t off,
-				int count, int *eof, void *data);
-
 /*
  * The /proc/tty directory inodes...
  */

commit 25216b00395dfb52bfe06e4886a6ad831ede7b4b
Author: Pavel Emelianov <xemul@sw.ru>
Date:   Sun Jul 15 23:39:54 2007 -0700

    Make /proc/tty/drivers use seq_list_xxx helpers
    
    Simple and stupid like some previous ones.  Just use new API.
    
    Signed-off-by: Pavel Emelianov <xemul@openvz.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index b3a473b0a191..22846225acfa 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -69,7 +69,7 @@ static void show_tty_range(struct seq_file *m, struct tty_driver *p,
 
 static int show_tty_driver(struct seq_file *m, void *v)
 {
-	struct tty_driver *p = v;
+	struct tty_driver *p = list_entry(v, struct tty_driver, tty_drivers);
 	dev_t from = MKDEV(p->major, p->minor_start);
 	dev_t to = from + p->num;
 
@@ -106,22 +106,13 @@ static int show_tty_driver(struct seq_file *m, void *v)
 /* iterator */
 static void *t_start(struct seq_file *m, loff_t *pos)
 {
-	struct list_head *p;
-	loff_t l = *pos;
-
 	mutex_lock(&tty_mutex);
-	list_for_each(p, &tty_drivers)
-		if (!l--)
-			return list_entry(p, struct tty_driver, tty_drivers);
-	return NULL;
+	return seq_list_start(&tty_drivers, *pos);
 }
 
 static void *t_next(struct seq_file *m, void *v, loff_t *pos)
 {
-	struct list_head *p = ((struct tty_driver *)v)->tty_drivers.next;
-	(*pos)++;
-	return p==&tty_drivers ? NULL :
-			list_entry(p, struct tty_driver, tty_drivers);
+	return seq_list_next(v, &tty_drivers, pos);
 }
 
 static void t_stop(struct seq_file *m, void *v)

commit ca509f69dec7fa564005aa7e9fcf0cd46de3f7d6
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Tue May 8 00:27:12 2007 -0700

    Protect tty drivers list with tty_mutex
    
    Additions and removal from tty_drivers list were just done as well as
    iterating on it for /proc/tty/drivers generation.
    
    testing: modprobe/rmmod loop of simple module which does nothing but
    tty_register_driver() vs cat /proc/tty/drivers loop
    
    BUG: unable to handle kernel paging request at virtual address 6b6b6b6b
     printing eip:
    c01cefa7
    *pde = 00000000
    Oops: 0000 [#1]
    PREEMPT
    last sysfs file: devices/pci0000:00/0000:00:1d.7/usb5/5-0:1.0/bInterfaceProtocol
    Modules linked in: ohci_hcd af_packet e1000 ehci_hcd uhci_hcd usbcore xfs
    CPU:    0
    EIP:    0060:[<c01cefa7>]    Not tainted VLI
    EFLAGS: 00010297   (2.6.21-rc4-mm1 #4)
    EIP is at vsnprintf+0x3a4/0x5fc
    eax: 6b6b6b6b   ebx: f6cb50f2   ecx: 6b6b6b6b   edx: fffffffe
    esi: c0354700   edi: f6cb6000   ebp: 6b6b6b6b   esp: f31f5e68
    ds: 007b   es: 007b   fs: 00d8  gs: 0033  ss: 0068
    Process cat (pid: 31864, ti=f31f4000 task=c1998030 task.ti=f31f4000)
    Stack: 00000000 c0103f20 c013003a c0103f20 00000000 f6cb50da 0000000a 00000f0e
           f6cb50f2 00000010 00000014 ffffffff ffffffff 00000007 c0354753 f6cb50f2
           f73e39dc f73e39dc 00000001 c0175416 f31f5ed8 f31f5ed4 0ee00000 f32090bc
    Call Trace:
     [<c0103f20>] restore_nocheck+0x12/0x15
     [<c013003a>] mark_held_locks+0x6d/0x86
     [<c0103f20>] restore_nocheck+0x12/0x15
     [<c0175416>] seq_printf+0x2e/0x52
     [<c0192895>] show_tty_range+0x35/0x1f3
     [<c0175416>] seq_printf+0x2e/0x52
     [<c0192add>] show_tty_driver+0x8a/0x1d9
     [<c01758f6>] seq_read+0x70/0x2ba
     [<c0175886>] seq_read+0x0/0x2ba
     [<c018d8e6>] proc_reg_read+0x63/0x9f
     [<c015e764>] vfs_read+0x7d/0xb5
     [<c018d883>] proc_reg_read+0x0/0x9f
     [<c015eab1>] sys_read+0x41/0x6a
     [<c0103e4e>] sysenter_past_esp+0x5f/0x99
     =======================
    Code: 00 8b 4d 04 e9 44 ff ff ff 8d 4d 04 89 4c 24 50 8b 6d 00 81 fd ff 0f 00 00 b8 a4 c1 35 c0 0f 46 e8 8b 54 24 2c 89 e9 89 c8 eb 06 <80> 38 00 74 07 40 4a 83 fa ff 75 f4 29 c8 89 c6 8b 44 24 28 89
    EIP: [<c01cefa7>] vsnprintf+0x3a4/0x5fc SS:ESP 0068:f31f5e68
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index c1bbfbeb035e..b3a473b0a191 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -108,6 +108,8 @@ static void *t_start(struct seq_file *m, loff_t *pos)
 {
 	struct list_head *p;
 	loff_t l = *pos;
+
+	mutex_lock(&tty_mutex);
 	list_for_each(p, &tty_drivers)
 		if (!l--)
 			return list_entry(p, struct tty_driver, tty_drivers);
@@ -124,6 +126,7 @@ static void *t_next(struct seq_file *m, void *v, loff_t *pos)
 
 static void t_stop(struct seq_file *m, void *v)
 {
+	mutex_unlock(&tty_mutex);
 }
 
 static struct seq_operations tty_drivers_op = {

commit 00977a59b951207d38380c75f03a36829950265c
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:34 2007 -0800

    [PATCH] mark struct file_operations const 6
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
index 15c4455b09eb..c1bbfbeb035e 100644
--- a/fs/proc/proc_tty.c
+++ b/fs/proc/proc_tty.c
@@ -138,7 +138,7 @@ static int tty_drivers_open(struct inode *inode, struct file *file)
 	return seq_open(file, &tty_drivers_op);
 }
 
-static struct file_operations proc_tty_drivers_operations = {
+static const struct file_operations proc_tty_drivers_operations = {
 	.open		= tty_drivers_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/proc/proc_tty.c b/fs/proc/proc_tty.c
new file mode 100644
index 000000000000..15c4455b09eb
--- /dev/null
+++ b/fs/proc/proc_tty.c
@@ -0,0 +1,242 @@
+/*
+ * proc_tty.c -- handles /proc/tty
+ *
+ * Copyright 1997, Theodore Ts'o
+ */
+
+#include <asm/uaccess.h>
+
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/time.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/tty.h>
+#include <linux/seq_file.h>
+#include <linux/bitops.h>
+
+static int tty_ldiscs_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data);
+
+/*
+ * The /proc/tty directory inodes...
+ */
+static struct proc_dir_entry *proc_tty_ldisc, *proc_tty_driver;
+
+/*
+ * This is the handler for /proc/tty/drivers
+ */
+static void show_tty_range(struct seq_file *m, struct tty_driver *p,
+	dev_t from, int num)
+{
+	seq_printf(m, "%-20s ", p->driver_name ? p->driver_name : "unknown");
+	seq_printf(m, "/dev/%-8s ", p->name);
+	if (p->num > 1) {
+		seq_printf(m, "%3d %d-%d ", MAJOR(from), MINOR(from),
+			MINOR(from) + num - 1);
+	} else {
+		seq_printf(m, "%3d %7d ", MAJOR(from), MINOR(from));
+	}
+	switch (p->type) {
+	case TTY_DRIVER_TYPE_SYSTEM:
+		seq_printf(m, "system");
+		if (p->subtype == SYSTEM_TYPE_TTY)
+			seq_printf(m, ":/dev/tty");
+		else if (p->subtype == SYSTEM_TYPE_SYSCONS)
+			seq_printf(m, ":console");
+		else if (p->subtype == SYSTEM_TYPE_CONSOLE)
+			seq_printf(m, ":vtmaster");
+		break;
+	case TTY_DRIVER_TYPE_CONSOLE:
+		seq_printf(m, "console");
+		break;
+	case TTY_DRIVER_TYPE_SERIAL:
+		seq_printf(m, "serial");
+		break;
+	case TTY_DRIVER_TYPE_PTY:
+		if (p->subtype == PTY_TYPE_MASTER)
+			seq_printf(m, "pty:master");
+		else if (p->subtype == PTY_TYPE_SLAVE)
+			seq_printf(m, "pty:slave");
+		else
+			seq_printf(m, "pty");
+		break;
+	default:
+		seq_printf(m, "type:%d.%d", p->type, p->subtype);
+	}
+	seq_putc(m, '\n');
+}
+
+static int show_tty_driver(struct seq_file *m, void *v)
+{
+	struct tty_driver *p = v;
+	dev_t from = MKDEV(p->major, p->minor_start);
+	dev_t to = from + p->num;
+
+	if (&p->tty_drivers == tty_drivers.next) {
+		/* pseudo-drivers first */
+		seq_printf(m, "%-20s /dev/%-8s ", "/dev/tty", "tty");
+		seq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 0);
+		seq_printf(m, "system:/dev/tty\n");
+		seq_printf(m, "%-20s /dev/%-8s ", "/dev/console", "console");
+		seq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 1);
+		seq_printf(m, "system:console\n");
+#ifdef CONFIG_UNIX98_PTYS
+		seq_printf(m, "%-20s /dev/%-8s ", "/dev/ptmx", "ptmx");
+		seq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 2);
+		seq_printf(m, "system\n");
+#endif
+#ifdef CONFIG_VT
+		seq_printf(m, "%-20s /dev/%-8s ", "/dev/vc/0", "vc/0");
+		seq_printf(m, "%3d %7d ", TTY_MAJOR, 0);
+		seq_printf(m, "system:vtmaster\n");
+#endif
+	}
+
+	while (MAJOR(from) < MAJOR(to)) {
+		dev_t next = MKDEV(MAJOR(from)+1, 0);
+		show_tty_range(m, p, from, next - from);
+		from = next;
+	}
+	if (from != to)
+		show_tty_range(m, p, from, to - from);
+	return 0;
+}
+
+/* iterator */
+static void *t_start(struct seq_file *m, loff_t *pos)
+{
+	struct list_head *p;
+	loff_t l = *pos;
+	list_for_each(p, &tty_drivers)
+		if (!l--)
+			return list_entry(p, struct tty_driver, tty_drivers);
+	return NULL;
+}
+
+static void *t_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	struct list_head *p = ((struct tty_driver *)v)->tty_drivers.next;
+	(*pos)++;
+	return p==&tty_drivers ? NULL :
+			list_entry(p, struct tty_driver, tty_drivers);
+}
+
+static void t_stop(struct seq_file *m, void *v)
+{
+}
+
+static struct seq_operations tty_drivers_op = {
+	.start	= t_start,
+	.next	= t_next,
+	.stop	= t_stop,
+	.show	= show_tty_driver
+};
+
+static int tty_drivers_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &tty_drivers_op);
+}
+
+static struct file_operations proc_tty_drivers_operations = {
+	.open		= tty_drivers_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+/*
+ * This is the handler for /proc/tty/ldiscs
+ */
+static int tty_ldiscs_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int	i;
+	int	len = 0;
+	off_t	begin = 0;
+	struct tty_ldisc *ld;
+	
+	for (i=0; i < NR_LDISCS; i++) {
+		ld = tty_ldisc_get(i);
+		if (ld == NULL)
+			continue;
+		len += sprintf(page+len, "%-10s %2d\n",
+			       ld->name ? ld->name : "???", i);
+		tty_ldisc_put(i);
+		if (len+begin > off+count)
+			break;
+		if (len+begin < off) {
+			begin += len;
+			len = 0;
+		}
+	}
+	if (i >= NR_LDISCS)
+		*eof = 1;
+	if (off >= len+begin)
+		return 0;
+	*start = page + (off-begin);
+	return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+/*
+ * This function is called by tty_register_driver() to handle
+ * registering the driver's /proc handler into /proc/tty/driver/<foo>
+ */
+void proc_tty_register_driver(struct tty_driver *driver)
+{
+	struct proc_dir_entry *ent;
+		
+	if ((!driver->read_proc && !driver->write_proc) ||
+	    !driver->driver_name ||
+	    driver->proc_entry)
+		return;
+
+	ent = create_proc_entry(driver->driver_name, 0, proc_tty_driver);
+	if (!ent)
+		return;
+	ent->read_proc = driver->read_proc;
+	ent->write_proc = driver->write_proc;
+	ent->owner = driver->owner;
+	ent->data = driver;
+
+	driver->proc_entry = ent;
+}
+
+/*
+ * This function is called by tty_unregister_driver()
+ */
+void proc_tty_unregister_driver(struct tty_driver *driver)
+{
+	struct proc_dir_entry *ent;
+
+	ent = driver->proc_entry;
+	if (!ent)
+		return;
+		
+	remove_proc_entry(driver->driver_name, proc_tty_driver);
+	
+	driver->proc_entry = NULL;
+}
+
+/*
+ * Called by proc_root_init() to initialize the /proc/tty subtree
+ */
+void __init proc_tty_init(void)
+{
+	struct proc_dir_entry *entry;
+	if (!proc_mkdir("tty", NULL))
+		return;
+	proc_tty_ldisc = proc_mkdir("tty/ldisc", NULL);
+	/*
+	 * /proc/tty/driver/serial reveals the exact character counts for
+	 * serial links which is just too easy to abuse for inferring
+	 * password lengths and inter-keystroke timings during password
+	 * entry.
+	 */
+	proc_tty_driver = proc_mkdir_mode("tty/driver", S_IRUSR | S_IXUSR, NULL);
+
+	create_proc_read_entry("tty/ldiscs", 0, NULL, tty_ldiscs_read_proc, NULL);
+	entry = create_proc_entry("tty/drivers", 0, NULL);
+	if (entry)
+		entry->proc_fops = &proc_tty_drivers_operations;
+}
