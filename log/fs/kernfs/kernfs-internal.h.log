commit 0c47383ba3bd10877956e41149d19644fba937d1
Author: Daniel Xu <dxu@dxuuu.xyz>
Date:   Thu Mar 12 13:03:16 2020 -0700

    kernfs: Add option to enable user xattrs
    
    User extended attributes are useful as metadata storage for kernfs
    consumers like cgroups. Especially in the case of cgroups, it is useful
    to have a central metadata store that multiple processes/services can
    use to coordinate actions.
    
    A concrete example is for userspace out of memory killers. We want to
    let delegated cgroup subtree owners (running as non-root) to be able to
    say "please avoid killing this cgroup". This is especially important for
    desktop linux as delegated subtrees owners are less likely to run as
    root.
    
    This patch introduces a new flag, KERNFS_ROOT_SUPPORT_USER_XATTR, that
    lets kernfs consumers enable user xattr support. An initial limit of 128
    entries or 128KB -- whichever is hit first -- is placed per cgroup
    because xattrs come from kernel memory and we don't want to let
    unprivileged users accidentally eat up too much kernel memory.
    
    Signed-off-by: Daniel Xu <dxu@dxuuu.xyz>
    Acked-by: Chris Down <chris@chrisdown.name>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 2f3c51d55261..7ee97ef59184 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -26,6 +26,8 @@ struct kernfs_iattrs {
 	struct timespec64	ia_ctime;
 
 	struct simple_xattrs	xattrs;
+	atomic_t		nr_user_xattrs;
+	atomic_t		user_xattr_size;
 };
 
 /* +1 to avoid triggering overflow warning when negating it */

commit fe0f726c9fb626b1092a9ea3bf75f57f2eed676e
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: combine ino/id lookup functions into kernfs_find_and_get_node_by_id()
    
    kernfs_find_and_get_node_by_ino() looks the kernfs_node matching the
    specified ino.  On top of that, kernfs_get_node_by_id() and
    kernfs_fh_get_inode() implement full ID matching by testing the rest
    of ID.
    
    On surface, confusingly, the two are slightly different in that the
    latter uses 0 gen as wildcard while the former doesn't - does it mean
    that the latter can't uniquely identify inodes w/ 0 gen?  In practice,
    this is a distinction without a difference because generation number
    starts at 1.  There are no actual IDs with 0 gen, so it can always
    safely used as wildcard.
    
    Let's simplify the code by renaming kernfs_find_and_get_node_by_ino()
    to kernfs_find_and_get_node_by_id(), moving all lookup logics into it,
    and removing now unnecessary kernfs_get_node_by_id().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 02ce570a9a3c..2f3c51d55261 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -109,8 +109,6 @@ struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,
 				    const char *name, umode_t mode,
 				    kuid_t uid, kgid_t gid,
 				    unsigned flags);
-struct kernfs_node *kernfs_find_and_get_node_by_ino(struct kernfs_root *root,
-						    unsigned int ino);
 
 /*
  * file.c

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 3c437990f39a..02ce570a9a3c 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -1,11 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * fs/kernfs/kernfs-internal.h - kernfs internal header file
  *
  * Copyright (c) 2001-3 Patrick Mochel
  * Copyright (c) 2007 SUSE Linux Products GmbH
  * Copyright (c) 2007, 2013 Tejun Heo <teheo@suse.de>
- *
- * This file is released under the GPLv2.
  */
 
 #ifndef __KERNFS_INTERNAL_H

commit 0ac6075a32fc05bc7fa025965914e8dcd448a668
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Feb 22 15:57:15 2019 +0100

    kernfs: use simple_xattrs for security attributes
    
    Replace the special handling of security xattrs with simple_xattrs, as
    is already done for the trusted xattrs. This simplifies the code and
    allows LSMs to use more than just a single xattr to do their business.
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    [PM: manual merge fixes]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 385a5ca0b2f6..3c437990f39a 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -25,8 +25,6 @@ struct kernfs_iattrs {
 	struct timespec64	ia_atime;
 	struct timespec64	ia_mtime;
 	struct timespec64	ia_ctime;
-	void			*ia_secdata;
-	u32			ia_secdata_len;
 
 	struct simple_xattrs	xattrs;
 };

commit 05895219627c416e3ba78de84b83c6937387786b
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Feb 22 15:57:12 2019 +0100

    kernfs: clean up struct kernfs_iattrs
    
    Right now, kernfs_iattrs embeds the whole struct iattr, even though it
    doesn't really use half of its fields... This both leads to wasting
    space and makes the code look awkward. Let's just list the few fields
    we need directly in struct kernfs_iattrs.
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    [PM: merged a number of chunks manually due to fuzz]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 0b7d197a904c..385a5ca0b2f6 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -20,7 +20,11 @@
 #include <linux/fs_context.h>
 
 struct kernfs_iattrs {
-	struct iattr		ia_iattr;
+	kuid_t			ia_uid;
+	kgid_t			ia_gid;
+	struct timespec64	ia_atime;
+	struct timespec64	ia_mtime;
+	struct timespec64	ia_ctime;
 	void			*ia_secdata;
 	u32			ia_secdata_len;
 

commit 7b47a9e7c8f672b6fb0b77fca11a63a8a77f5a91
Merge: dbc2fba3fc46 c99c2171fc61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 12 14:08:19 2019 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount infrastructure updates from Al Viro:
     "The rest of core infrastructure; no new syscalls in that pile, but the
      old parts are switched to new infrastructure. At that point
      conversions of individual filesystems can happen independently; some
      are done here (afs, cgroup, procfs, etc.), there's also a large series
      outside of that pile dealing with NFS (quite a bit of option-parsing
      stuff is getting used there - it's one of the most convoluted
      filesystems in terms of mount-related logics), but NFS bits are the
      next cycle fodder.
    
      It got seriously simplified since the last cycle; documentation is
      probably the weakest bit at the moment - I considered dropping the
      commit introducing Documentation/filesystems/mount_api.txt (cutting
      the size increase by quarter ;-), but decided that it would be better
      to fix it up after -rc1 instead.
    
      That pile allows to do followup work in independent branches, which
      should make life much easier for the next cycle. fs/super.c size
      increase is unpleasant; there's a followup series that allows to
      shrink it considerably, but I decided to leave that until the next
      cycle"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (41 commits)
      afs: Use fs_context to pass parameters over automount
      afs: Add fs_context support
      vfs: Add some logging to the core users of the fs_context log
      vfs: Implement logging through fs_context
      vfs: Provide documentation for new mount API
      vfs: Remove kern_mount_data()
      hugetlbfs: Convert to fs_context
      cpuset: Use fs_context
      kernfs, sysfs, cgroup, intel_rdt: Support fs_context
      cgroup: store a reference to cgroup_ns into cgroup_fs_context
      cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper
      cgroup_do_mount(): massage calling conventions
      cgroup: stash cgroup_root reference into cgroup_fs_context
      cgroup2: switch to option-by-option parsing
      cgroup1: switch to option-by-option parsing
      cgroup: take options parsing into ->parse_monolithic()
      cgroup: fold cgroup1_mount() into cgroup1_get_tree()
      cgroup: start switching to fs_context
      ipc: Convert mqueue fs to fs_context
      proc: Add fs_context support to procfs
      ...

commit 23bf1b6be9c291a7130118dcc7384f72ac04d813
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:26 2018 +0000

    kernfs, sysfs, cgroup, intel_rdt: Support fs_context
    
    Make kernfs support superblock creation/mount/remount with fs_context.
    
    This requires that sysfs, cgroup and intel_rdt, which are built on kernfs,
    be made to support fs_context also.
    
    Notes:
    
     (1) A kernfs_fs_context struct is created to wrap fs_context and the
         kernfs mount parameters are moved in here (or are in fs_context).
    
     (2) kernfs_mount{,_ns}() are made into kernfs_get_tree().  The extra
         namespace tag parameter is passed in the context if desired
    
     (3) kernfs_free_fs_context() is provided as a destructor for the
         kernfs_fs_context struct, but for the moment it does nothing except
         get called in the right places.
    
     (4) sysfs doesn't wrap kernfs_fs_context since it has no parameters to
         pass, but possibly this should be done anyway in case someone wants to
         add a parameter in future.
    
     (5) A cgroup_fs_context struct is created to wrap kernfs_fs_context and
         the cgroup v1 and v2 mount parameters are all moved there.
    
     (6) cgroup1 parameter parsing error messages are now handled by invalf(),
         which allows userspace to collect them directly.
    
     (7) cgroup1 parameter cleanup is now done in the context destructor rather
         than in the mount/get_tree and remount functions.
    
    Weirdies:
    
     (*) cgroup_do_get_tree() calls cset_cgroup_from_root() with locks held,
         but then uses the resulting pointer after dropping the locks.  I'm
         told this is okay and needs commenting.
    
     (*) The cgroup refcount web.  This really needs documenting.
    
     (*) cgroup2 only has one root?
    
    Add a suggestion from Thomas Gleixner in which the RDT enablement code is
    placed into its own function.
    
    [folded a leak fix from Andrey Vagin]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Tejun Heo <tj@kernel.org>
    cc: Li Zefan <lizefan@huawei.com>
    cc: Johannes Weiner <hannes@cmpxchg.org>
    cc: cgroups@vger.kernel.org
    cc: fenghua.yu@intel.com
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 3d83b114bb08..379e3a9eb1ec 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -17,6 +17,7 @@
 #include <linux/xattr.h>
 
 #include <linux/kernfs.h>
+#include <linux/fs_context.h>
 
 struct kernfs_iattrs {
 	struct iattr		ia_iattr;

commit 26e28d68b146ec17ecc1b1833077bc712de19637
Author: Ayush Mittal <ayush.m@samsung.com>
Date:   Wed Feb 6 10:25:42 2019 +0530

    kernfs: Allocating memory for kernfs_iattrs with kmem_cache.
    
    Creating a new cache for kernfs_iattrs.
    Currently, memory is allocated with kzalloc() which
    always gives aligned memory. On ARM, this is 64 byte aligned.
    To avoid the wastage of memory in aligning the size requested,
    a new cache for kernfs_iattrs is created.
    
    Size of struct kernfs_iattrs is 80 Bytes.
    On ARM, it will come in kmalloc-128 slab.
    and it will come in kmalloc-192 slab if debug info is enabled.
    Extra bytes taken 48 bytes.
    
    Total number of objects created : 4096
    Total saving = 48*4096 = 192 KB
    
    After creating new slab(When debug info is enabled) :
    sh-3.2# cat /proc/slabinfo
    ...
    kernfs_iattrs_cache   4069   4096    128   32    1 : tunables    0    0    0 : slabdata    128    128      0
    ...
    
    All testing has been done on ARM target.
    
    Signed-off-by: Ayush Mittal <ayush.m@samsung.com>
    Signed-off-by: Vaneet Narang <v.narang@samsung.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 3d83b114bb08..dba810cd83b1 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -78,7 +78,7 @@ static inline struct kernfs_node *kernfs_dentry_node(struct dentry *dentry)
 }
 
 extern const struct super_operations kernfs_sops;
-extern struct kmem_cache *kernfs_node_cache;
+extern struct kmem_cache *kernfs_node_cache, *kernfs_iattrs_cache;
 
 /*
  * inode.c

commit 488dee96bb62f0b3d9e678cf42574034d5b033a5
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 20 21:56:47 2018 +0000

    kernfs: allow creating kernfs objects with arbitrary uid/gid
    
    This change allows creating kernfs files and directories with arbitrary
    uid/gid instead of always using GLOBAL_ROOT_UID/GID by extending
    kernfs_create_dir_ns() and kernfs_create_file_ns() with uid/gid arguments.
    The "simple" kernfs_create_file() and kernfs_create_dir() are left alone
    and always create objects belonging to the global root.
    
    When creating symlinks ownership (uid/gid) is taken from the target kernfs
    object.
    
    Co-Developed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 0f260dcca177..3d83b114bb08 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -90,6 +90,7 @@ int kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr);
 int kernfs_iop_getattr(const struct path *path, struct kstat *stat,
 		       u32 request_mask, unsigned int query_flags);
 ssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size);
+int __kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr);
 
 /*
  * dir.c
@@ -104,6 +105,7 @@ void kernfs_put_active(struct kernfs_node *kn);
 int kernfs_add_one(struct kernfs_node *kn);
 struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,
 				    const char *name, umode_t mode,
+				    kuid_t uid, kgid_t gid,
 				    unsigned flags);
 struct kernfs_node *kernfs_find_and_get_node_by_ino(struct kernfs_root *root,
 						    unsigned int ino);

commit 319ba91d352a74acb47678788109a14b9b4dd4c2
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:49 2017 -0700

    kernfs: don't set dentry->d_fsdata
    
    When working on adding exportfs operations in kernfs, I found it's hard
    to initialize dentry->d_fsdata in the exportfs operations. Looks there
    is no way to do it without race condition. Look at the kernfs code
    closely, there is no point to set dentry->d_fsdata. inode->i_private
    already points to kernfs_node, and we can get inode from a dentry. So
    this patch just delete the d_fsdata usage.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index e9c226f29828..0f260dcca177 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -70,6 +70,13 @@ struct kernfs_super_info {
 };
 #define kernfs_info(SB) ((struct kernfs_super_info *)(SB->s_fs_info))
 
+static inline struct kernfs_node *kernfs_dentry_node(struct dentry *dentry)
+{
+	if (d_really_is_negative(dentry))
+		return NULL;
+	return d_inode(dentry)->i_private;
+}
+
 extern const struct super_operations kernfs_sops;
 extern struct kmem_cache *kernfs_node_cache;
 

commit ba16b2846a8c6965d0d35be3968bc10f6277812d
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:48 2017 -0700

    kernfs: add an API to get kernfs node from inode number
    
    Add an API to get kernfs node from inode number. We will need this to
    implement exportfs operations.
    
    This API will be used in blktrace too later, so it should be as fast as
    possible. To make the API lock free, kernfs node is freed in RCU
    context. And we depend on kernfs_node count/ino number to filter out
    stale kernfs nodes.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 2d5144ab4251..e9c226f29828 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -98,6 +98,8 @@ int kernfs_add_one(struct kernfs_node *kn);
 struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,
 				    const char *name, umode_t mode,
 				    unsigned flags);
+struct kernfs_node *kernfs_find_and_get_node_by_ino(struct kernfs_root *root,
+						    unsigned int ino);
 
 /*
  * file.c

commit a528d35e8bfcc521d7cb70aaf03e1bd296c8493f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 31 16:46:22 2017 +0000

    statx: Add a system call to make enhanced file info available
    
    Add a system call to make extended file information available, including
    file creation and some attribute flags where available through the
    underlying filesystem.
    
    The getattr inode operation is altered to take two additional arguments: a
    u32 request_mask and an unsigned int flags that indicate the
    synchronisation mode.  This change is propagated to the vfs_getattr*()
    function.
    
    Functions like vfs_stat() are now inline wrappers around new functions
    vfs_statx() and vfs_statx_fd() to reduce stack usage.
    
    ========
    OVERVIEW
    ========
    
    The idea was initially proposed as a set of xattrs that could be retrieved
    with getxattr(), but the general preference proved to be for a new syscall
    with an extended stat structure.
    
    A number of requests were gathered for features to be included.  The
    following have been included:
    
     (1) Make the fields a consistent size on all arches and make them large.
    
     (2) Spare space, request flags and information flags are provided for
         future expansion.
    
     (3) Better support for the y2038 problem [Arnd Bergmann] (tv_sec is an
         __s64).
    
     (4) Creation time: The SMB protocol carries the creation time, which could
         be exported by Samba, which will in turn help CIFS make use of
         FS-Cache as that can be used for coherency data (stx_btime).
    
         This is also specified in NFSv4 as a recommended attribute and could
         be exported by NFSD [Steve French].
    
     (5) Lightweight stat: Ask for just those details of interest, and allow a
         netfs (such as NFS) to approximate anything not of interest, possibly
         without going to the server [Trond Myklebust, Ulrich Drepper, Andreas
         Dilger] (AT_STATX_DONT_SYNC).
    
     (6) Heavyweight stat: Force a netfs to go to the server, even if it thinks
         its cached attributes are up to date [Trond Myklebust]
         (AT_STATX_FORCE_SYNC).
    
    And the following have been left out for future extension:
    
     (7) Data version number: Could be used by userspace NFS servers [Aneesh
         Kumar].
    
         Can also be used to modify fill_post_wcc() in NFSD which retrieves
         i_version directly, but has just called vfs_getattr().  It could get
         it from the kstat struct if it used vfs_xgetattr() instead.
    
         (There's disagreement on the exact semantics of a single field, since
         not all filesystems do this the same way).
    
     (8) BSD stat compatibility: Including more fields from the BSD stat such
         as creation time (st_btime) and inode generation number (st_gen)
         [Jeremy Allison, Bernd Schubert].
    
     (9) Inode generation number: Useful for FUSE and userspace NFS servers
         [Bernd Schubert].
    
         (This was asked for but later deemed unnecessary with the
         open-by-handle capability available and caused disagreement as to
         whether it's a security hole or not).
    
    (10) Extra coherency data may be useful in making backups [Andreas Dilger].
    
         (No particular data were offered, but things like last backup
         timestamp, the data version number and the DOS archive bit would come
         into this category).
    
    (11) Allow the filesystem to indicate what it can/cannot provide: A
         filesystem can now say it doesn't support a standard stat feature if
         that isn't available, so if, for instance, inode numbers or UIDs don't
         exist or are fabricated locally...
    
         (This requires a separate system call - I have an fsinfo() call idea
         for this).
    
    (12) Store a 16-byte volume ID in the superblock that can be returned in
         struct xstat [Steve French].
    
         (Deferred to fsinfo).
    
    (13) Include granularity fields in the time data to indicate the
         granularity of each of the times (NFSv4 time_delta) [Steve French].
    
         (Deferred to fsinfo).
    
    (14) FS_IOC_GETFLAGS value.  These could be translated to BSD's st_flags.
         Note that the Linux IOC flags are a mess and filesystems such as Ext4
         define flags that aren't in linux/fs.h, so translation in the kernel
         may be a necessity (or, possibly, we provide the filesystem type too).
    
         (Some attributes are made available in stx_attributes, but the general
         feeling was that the IOC flags were to ext[234]-specific and shouldn't
         be exposed through statx this way).
    
    (15) Mask of features available on file (eg: ACLs, seclabel) [Brad Boyer,
         Michael Kerrisk].
    
         (Deferred, probably to fsinfo.  Finding out if there's an ACL or
         seclabal might require extra filesystem operations).
    
    (16) Femtosecond-resolution timestamps [Dave Chinner].
    
         (A __reserved field has been left in the statx_timestamp struct for
         this - if there proves to be a need).
    
    (17) A set multiple attributes syscall to go with this.
    
    ===============
    NEW SYSTEM CALL
    ===============
    
    The new system call is:
    
            int ret = statx(int dfd,
                            const char *filename,
                            unsigned int flags,
                            unsigned int mask,
                            struct statx *buffer);
    
    The dfd, filename and flags parameters indicate the file to query, in a
    similar way to fstatat().  There is no equivalent of lstat() as that can be
    emulated with statx() by passing AT_SYMLINK_NOFOLLOW in flags.  There is
    also no equivalent of fstat() as that can be emulated by passing a NULL
    filename to statx() with the fd of interest in dfd.
    
    Whether or not statx() synchronises the attributes with the backing store
    can be controlled by OR'ing a value into the flags argument (this typically
    only affects network filesystems):
    
     (1) AT_STATX_SYNC_AS_STAT tells statx() to behave as stat() does in this
         respect.
    
     (2) AT_STATX_FORCE_SYNC will require a network filesystem to synchronise
         its attributes with the server - which might require data writeback to
         occur to get the timestamps correct.
    
     (3) AT_STATX_DONT_SYNC will suppress synchronisation with the server in a
         network filesystem.  The resulting values should be considered
         approximate.
    
    mask is a bitmask indicating the fields in struct statx that are of
    interest to the caller.  The user should set this to STATX_BASIC_STATS to
    get the basic set returned by stat().  It should be noted that asking for
    more information may entail extra I/O operations.
    
    buffer points to the destination for the data.  This must be 256 bytes in
    size.
    
    ======================
    MAIN ATTRIBUTES RECORD
    ======================
    
    The following structures are defined in which to return the main attribute
    set:
    
            struct statx_timestamp {
                    __s64   tv_sec;
                    __s32   tv_nsec;
                    __s32   __reserved;
            };
    
            struct statx {
                    __u32   stx_mask;
                    __u32   stx_blksize;
                    __u64   stx_attributes;
                    __u32   stx_nlink;
                    __u32   stx_uid;
                    __u32   stx_gid;
                    __u16   stx_mode;
                    __u16   __spare0[1];
                    __u64   stx_ino;
                    __u64   stx_size;
                    __u64   stx_blocks;
                    __u64   __spare1[1];
                    struct statx_timestamp  stx_atime;
                    struct statx_timestamp  stx_btime;
                    struct statx_timestamp  stx_ctime;
                    struct statx_timestamp  stx_mtime;
                    __u32   stx_rdev_major;
                    __u32   stx_rdev_minor;
                    __u32   stx_dev_major;
                    __u32   stx_dev_minor;
                    __u64   __spare2[14];
            };
    
    The defined bits in request_mask and stx_mask are:
    
            STATX_TYPE              Want/got stx_mode & S_IFMT
            STATX_MODE              Want/got stx_mode & ~S_IFMT
            STATX_NLINK             Want/got stx_nlink
            STATX_UID               Want/got stx_uid
            STATX_GID               Want/got stx_gid
            STATX_ATIME             Want/got stx_atime{,_ns}
            STATX_MTIME             Want/got stx_mtime{,_ns}
            STATX_CTIME             Want/got stx_ctime{,_ns}
            STATX_INO               Want/got stx_ino
            STATX_SIZE              Want/got stx_size
            STATX_BLOCKS            Want/got stx_blocks
            STATX_BASIC_STATS       [The stuff in the normal stat struct]
            STATX_BTIME             Want/got stx_btime{,_ns}
            STATX_ALL               [All currently available stuff]
    
    stx_btime is the file creation time, stx_mask is a bitmask indicating the
    data provided and __spares*[] are where as-yet undefined fields can be
    placed.
    
    Time fields are structures with separate seconds and nanoseconds fields
    plus a reserved field in case we want to add even finer resolution.  Note
    that times will be negative if before 1970; in such a case, the nanosecond
    fields will also be negative if not zero.
    
    The bits defined in the stx_attributes field convey information about a
    file, how it is accessed, where it is and what it does.  The following
    attributes map to FS_*_FL flags and are the same numerical value:
    
            STATX_ATTR_COMPRESSED           File is compressed by the fs
            STATX_ATTR_IMMUTABLE            File is marked immutable
            STATX_ATTR_APPEND               File is append-only
            STATX_ATTR_NODUMP               File is not to be dumped
            STATX_ATTR_ENCRYPTED            File requires key to decrypt in fs
    
    Within the kernel, the supported flags are listed by:
    
            KSTAT_ATTR_FS_IOC_FLAGS
    
    [Are any other IOC flags of sufficient general interest to be exposed
    through this interface?]
    
    New flags include:
    
            STATX_ATTR_AUTOMOUNT            Object is an automount trigger
    
    These are for the use of GUI tools that might want to mark files specially,
    depending on what they are.
    
    Fields in struct statx come in a number of classes:
    
     (0) stx_dev_*, stx_blksize.
    
         These are local system information and are always available.
    
     (1) stx_mode, stx_nlinks, stx_uid, stx_gid, stx_[amc]time, stx_ino,
         stx_size, stx_blocks.
    
         These will be returned whether the caller asks for them or not.  The
         corresponding bits in stx_mask will be set to indicate whether they
         actually have valid values.
    
         If the caller didn't ask for them, then they may be approximated.  For
         example, NFS won't waste any time updating them from the server,
         unless as a byproduct of updating something requested.
    
         If the values don't actually exist for the underlying object (such as
         UID or GID on a DOS file), then the bit won't be set in the stx_mask,
         even if the caller asked for the value.  In such a case, the returned
         value will be a fabrication.
    
         Note that there are instances where the type might not be valid, for
         instance Windows reparse points.
    
     (2) stx_rdev_*.
    
         This will be set only if stx_mode indicates we're looking at a
         blockdev or a chardev, otherwise will be 0.
    
     (3) stx_btime.
    
         Similar to (1), except this will be set to 0 if it doesn't exist.
    
    =======
    TESTING
    =======
    
    The following test program can be used to test the statx system call:
    
            samples/statx/test-statx.c
    
    Just compile and run, passing it paths to the files you want to examine.
    The file is built automatically if CONFIG_SAMPLES is enabled.
    
    Here's some example output.  Firstly, an NFS directory that crosses to
    another FSID.  Note that the AUTOMOUNT attribute is set because transiting
    this directory will cause d_automount to be invoked by the VFS.
    
            [root@andromeda ~]# /tmp/test-statx -A /warthog/data
            statx(/warthog/data) = 0
            results=7ff
              Size: 4096            Blocks: 8          IO Block: 1048576  directory
            Device: 00:26           Inode: 1703937     Links: 125
            Access: (3777/drwxrwxrwx)  Uid:     0   Gid:  4041
            Access: 2016-11-24 09:02:12.219699527+0000
            Modify: 2016-11-17 10:44:36.225653653+0000
            Change: 2016-11-17 10:44:36.225653653+0000
            Attributes: 0000000000001000 (-------- -------- -------- -------- -------- -------- ---m---- --------)
    
    Secondly, the result of automounting on that directory.
    
            [root@andromeda ~]# /tmp/test-statx /warthog/data
            statx(/warthog/data) = 0
            results=7ff
              Size: 4096            Blocks: 8          IO Block: 1048576  directory
            Device: 00:27           Inode: 2           Links: 125
            Access: (3777/drwxrwxrwx)  Uid:     0   Gid:  4041
            Access: 2016-11-24 09:02:12.219699527+0000
            Modify: 2016-11-17 10:44:36.225653653+0000
            Change: 2016-11-17 10:44:36.225653653+0000
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 3100987cf8ba..2d5144ab4251 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -80,8 +80,8 @@ extern const struct xattr_handler *kernfs_xattr_handlers[];
 void kernfs_evict_inode(struct inode *inode);
 int kernfs_iop_permission(struct inode *inode, int mask);
 int kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr);
-int kernfs_iop_getattr(struct vfsmount *mnt, struct dentry *dentry,
-		       struct kstat *stat);
+int kernfs_iop_getattr(const struct path *path, struct kstat *stat,
+		       u32 request_mask, unsigned int query_flags);
 ssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size);
 
 /*

commit 0e67db2f9fe91937e798e3d7d22c50a8438187e1
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Dec 27 14:49:03 2016 -0500

    kernfs: add kernfs_ops->open/release() callbacks
    
    Add ->open/release() methods to kernfs_ops.  ->open() is called when
    the file is opened and ->release() when the file is either released or
    severed.  These callbacks can be used, for example, to manage
    persistent caching objects over multiple seq_file iterations.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Acked-by: Zefan Li <lizefan@huawei.com>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index bfd551bbf231..3100987cf8ba 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -104,7 +104,7 @@ struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,
  */
 extern const struct file_operations kernfs_file_fops;
 
-void kernfs_unmap_bin_file(struct kernfs_node *kn);
+void kernfs_drain_open_files(struct kernfs_node *kn);
 
 /*
  * symlink.c

commit e72a1a8b3a5a2a0c034f9ad07ca34638fc3b0c33
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Sep 29 17:48:33 2016 +0200

    kernfs: Switch to generic xattr handlers
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 37159235ac10..bfd551bbf231 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -76,17 +76,12 @@ extern struct kmem_cache *kernfs_node_cache;
 /*
  * inode.c
  */
+extern const struct xattr_handler *kernfs_xattr_handlers[];
 void kernfs_evict_inode(struct inode *inode);
 int kernfs_iop_permission(struct inode *inode, int mask);
 int kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr);
 int kernfs_iop_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		       struct kstat *stat);
-int kernfs_iop_setxattr(struct dentry *dentry, struct inode *inode,
-			const char *name, const void *value,
-			size_t size, int flags);
-int kernfs_iop_removexattr(struct dentry *dentry, const char *name);
-ssize_t kernfs_iop_getxattr(struct dentry *dentry, struct inode *inode,
-			    const char *name, void *buf, size_t size);
 ssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size);
 
 /*

commit 3767e255b390d72f9a33c08d9e86c5f21f25860f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 27 11:06:05 2016 -0400

    switch ->setxattr() to passing dentry and inode separately
    
    smack ->d_instantiate() uses ->setxattr(), so to be able to call it before
    we'd hashed the new dentry and attached it to inode, we need ->setxattr()
    instances getting the inode as an explicit argument rather than obtaining
    it from dentry.
    
    Similar change for ->getxattr() had been done in commit ce23e64.  Unlike
    ->getxattr() (which is used by both selinux and smack instances of
    ->d_instantiate()) ->setxattr() is used only by smack one and unfortunately
    it got missed back then.
    
    Reported-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Tested-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 45c9192c276e..37159235ac10 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -81,7 +81,8 @@ int kernfs_iop_permission(struct inode *inode, int mask);
 int kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr);
 int kernfs_iop_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		       struct kstat *stat);
-int kernfs_iop_setxattr(struct dentry *dentry, const char *name, const void *value,
+int kernfs_iop_setxattr(struct dentry *dentry, struct inode *inode,
+			const char *name, const void *value,
 			size_t size, int flags);
 int kernfs_iop_removexattr(struct dentry *dentry, const char *name);
 ssize_t kernfs_iop_getxattr(struct dentry *dentry, struct inode *inode,

commit ce23e640133484eebc20ca7b7668388213e11327
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 11 00:48:00 2016 -0400

    ->getxattr(): pass dentry and inode as separate arguments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 6762bfbd8207..45c9192c276e 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -84,8 +84,8 @@ int kernfs_iop_getattr(struct vfsmount *mnt, struct dentry *dentry,
 int kernfs_iop_setxattr(struct dentry *dentry, const char *name, const void *value,
 			size_t size, int flags);
 int kernfs_iop_removexattr(struct dentry *dentry, const char *name);
-ssize_t kernfs_iop_getxattr(struct dentry *dentry, const char *name, void *buf,
-			    size_t size);
+ssize_t kernfs_iop_getxattr(struct dentry *dentry, struct inode *inode,
+			    const char *name, void *buf, size_t size);
 ssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size);
 
 /*

commit fb02915f47181e824339d91f8e385fd4bd746d6a
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jun 18 16:54:28 2015 -0400

    kernfs: make kernfs_get_inode() public
    
    Move kernfs_get_inode() prototype from fs/kernfs/kernfs-internal.h to
    include/linux/kernfs.h.  It obtains the matching inode for a
    kernfs_node.
    
    It will be used by cgroup for inode based permission checks for now
    but is generally useful.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index af9fa7499919..6762bfbd8207 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -76,7 +76,6 @@ extern struct kmem_cache *kernfs_node_cache;
 /*
  * inode.c
  */
-struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn);
 void kernfs_evict_inode(struct inode *inode);
 int kernfs_iop_permission(struct inode *inode, int mask);
 int kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr);

commit a7a2c680a2ad81b3181a335ee76e23d5195007ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 14 10:42:30 2015 +0100

    fs: deduplicate noop_backing_dev_info
    
    hugetlbfs, kernfs and dlmfs can simply use noop_backing_dev_info instead
    of creating a local duplicate.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index dc84a3ef9ca2..af9fa7499919 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -88,7 +88,6 @@ int kernfs_iop_removexattr(struct dentry *dentry, const char *name);
 ssize_t kernfs_iop_getxattr(struct dentry *dentry, const char *name, void *buf,
 			    size_t size);
 ssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size);
-void kernfs_inode_init(void);
 
 /*
  * dir.c

commit 7d568a8383bbb9c1f5167781075906acb2bb1550
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Apr 9 11:07:30 2014 -0400

    kernfs: implement kernfs_root->supers list
    
    Currently, there's no way to find out which super_blocks are
    associated with a given kernfs_root.  Let's implement it - the planned
    inotify extension to kernfs_notify() needs it.
    
    Make kernfs_super_info point back to the super_block and chain it at
    kernfs_root->supers.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 8be13b2a079b..dc84a3ef9ca2 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -49,6 +49,8 @@ static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)
  * mount.c
  */
 struct kernfs_super_info {
+	struct super_block	*sb;
+
 	/*
 	 * The root associated with this super_block.  Each super_block is
 	 * identified by the root and ns it's associated with.
@@ -62,6 +64,9 @@ struct kernfs_super_info {
 	 * an array and compare kernfs_node tag against every entry.
 	 */
 	const void		*ns;
+
+	/* anchored at kernfs_root->supers, protected by kernfs_mutex */
+	struct list_head	node;
 };
 #define kernfs_info(SB) ((struct kernfs_super_info *)(SB->s_fs_info))
 

commit f41c593454943b80a2017c8a2a3d6b1d0b0a6f89
Author: Li Zefan <lizefan@huawei.com>
Date:   Fri Feb 14 16:57:27 2014 +0800

    kernfs: fix kernfs_node_from_dentry()
    
    Currently kernfs_node_from_dentry() returns NULL for root dentry,
    because root_dentry->d_op == NULL.
    
    Due to this bug cgroupstats_build() returns -EINVAL for root cgroup.
    
      # mount -t cgroup -o cpuacct /cgroup
      # Documentation/accounting/getdelays -C /cgroup
      fatal reply error,  errno -22
    
    With this fix:
    
      # Documentation/accounting/getdelays -C /cgroup
      sleeping 305, blocked 0, running 1, stopped 0, uninterruptible 1
    
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index a91d7a1113d9..8be13b2a079b 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -65,6 +65,7 @@ struct kernfs_super_info {
 };
 #define kernfs_info(SB) ((struct kernfs_super_info *)(SB->s_fs_info))
 
+extern const struct super_operations kernfs_sops;
 extern struct kmem_cache *kernfs_node_cache;
 
 /*

commit 81c173cb5e87fbb47ccd80630faefe39bbf68449
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:03:00 2014 -0500

    kernfs: remove KERNFS_REMOVED
    
    KERNFS_REMOVED is used to mark half-initialized and dying nodes so
    that they don't show up in lookups and deny adding new nodes under or
    renaming it; however, its role overlaps that of deactivation.
    
    It's necessary to deny addition of new children while removal is in
    progress; however, this role considerably intersects with deactivation
    - KERNFS_REMOVED prevents new children while deactivation prevents new
    file operations.  There's no reason to have them separate making
    things more complex than necessary.
    
    This patch removes KERNFS_REMOVED.
    
    * Instead of KERNFS_REMOVED, each node now starts its life
      deactivated.  This means that we now use both atomic_add() and
      atomic_sub() on KN_DEACTIVATED_BIAS, which is INT_MIN.  The compiler
      generates an overflow warnings when negating INT_MIN as the negation
      can't be represented as a positive number.  Nothing is actually
      broken but let's bump BIAS by one to avoid the warnings for archs
      which negates the subtrahend..
    
    * A new helper kernfs_active() which tests whether kn->active >= 0 is
      added for convenience and lockdep annotation.  All KERNFS_REMOVED
      tests are replaced with negated kernfs_active() tests.
    
    * __kernfs_remove() is updated to deactivate, but not drain, all nodes
      in the subtree instead of setting KERNFS_REMOVED.  This removes
      deactivation from kernfs_deactivate(), which is now renamed to
      kernfs_drain().
    
    * Sanity check on KERNFS_REMOVED in kernfs_put() is replaced with
      checks on the active ref.
    
    * Some comment style updates in the affected area.
    
    v2: Reordered before removal path restructuring.  kernfs_active()
        dropped and kernfs_get/put_active() used instead.  RB_EMPTY_NODE()
        used in the lookup paths.
    
    v3: Reverted most of v2 except for creating a new node with
        KN_DEACTIVATED_BIAS.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 46b58de794d6..a91d7a1113d9 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -26,7 +26,8 @@ struct kernfs_iattrs {
 	struct simple_xattrs	xattrs;
 };
 
-#define KN_DEACTIVATED_BIAS		INT_MIN
+/* +1 to avoid triggering overflow warning when negating it */
+#define KN_DEACTIVATED_BIAS		(INT_MIN + 1)
 
 /* KERNFS_TYPE_MASK and types are defined in include/linux/kernfs.h */
 

commit 988cd7afb3f37598891ca70b4c6eb914c338c46a
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:02:58 2014 -0500

    kernfs: remove kernfs_addrm_cxt
    
    kernfs_addrm_cxt and the accompanying kernfs_addrm_start/finish() were
    added because there were operations which should be performed outside
    kernfs_mutex after adding and removing kernfs_nodes.  The necessary
    operations were recorded in kernfs_addrm_cxt and performed by
    kernfs_addrm_finish(); however, after the recent changes which
    relocated deactivation and unmapping so that they're performed
    directly during removal, the only operation kernfs_addrm_finish()
    performs is kernfs_put(), which can be moved inside the removal path
    too.
    
    This patch moves the kernfs_put() of the base ref to __kernfs_remove()
    and remove kernfs_addrm_cxt and kernfs_addrm_start/finish().
    
    * kernfs_add_one() is updated to grab and release kernfs_mutex itself.
      sysfs_addrm_start/finish() invocations around it are removed from
      all users.
    
    * __kernfs_remove() puts an unlinked node directly instead of chaining
      it to kernfs_addrm_cxt.  Its callers are updated to grab and release
      kernfs_mutex instead of calling kernfs_addrm_start/finish() around
      it.
    
    v2: Rebased on top of "kernfs: associate a new kernfs_node with its
        parent on creation" which dropped @parent from kernfs_add_one().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index eb536b76374a..46b58de794d6 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -44,13 +44,6 @@ static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)
 	return kn->dir.root;
 }
 
-/*
- * Context structure to be used while adding/removing nodes.
- */
-struct kernfs_addrm_cxt {
-	struct kernfs_node	*removed;
-};
-
 /*
  * mount.c
  */
@@ -100,9 +93,7 @@ extern const struct inode_operations kernfs_dir_iops;
 
 struct kernfs_node *kernfs_get_active(struct kernfs_node *kn);
 void kernfs_put_active(struct kernfs_node *kn);
-void kernfs_addrm_start(struct kernfs_addrm_cxt *acxt);
-int kernfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn);
-void kernfs_addrm_finish(struct kernfs_addrm_cxt *acxt);
+int kernfs_add_one(struct kernfs_node *kn);
 struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,
 				    const char *name, umode_t mode,
 				    unsigned flags);

commit db4aad209bc9aefd91f0a9aeb9e37364088b39ad
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 17 09:58:25 2014 -0500

    kernfs: associate a new kernfs_node with its parent on creation
    
    Once created, a kernfs_node is always destroyed by kernfs_put().
    Since ba7443bc656e ("sysfs, kernfs: implement
    kernfs_create/destroy_root()"), kernfs_put() depends on kernfs_root()
    to locate the ino_ida.  kernfs_root() in turn depends on
    kernfs_node->parent being set for !dir nodes.  This means that
    kernfs_put() of a !dir node requires its ->parent to be initialized.
    
    This leads to oops when a newly created !dir node is destroyed without
    going through kernfs_add_one() or after failing kernfs_add_one()
    before ->parent is set.  kernfs_root() invoked from kernfs_put() will
    try to dereference NULL parent.
    
    Fix it by moving parent association to kernfs_new_node() from
    kernfs_add_one().  kernfs_new_node() now takes @parent instead of
    @root and determines the root from the parent and also sets the new
    node's parent properly.  @parent parameter is removed from
    kernfs_add_one().  As there's no parent when creating the root node,
    __kernfs_new_node() which takes @root as before and doesn't set the
    parent is used in that case.
    
    This ensures that a kernfs_node in any stage in its life has its
    parent associated and thus can be put.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index c6ba5bc37a98..eb536b76374a 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -101,11 +101,11 @@ extern const struct inode_operations kernfs_dir_iops;
 struct kernfs_node *kernfs_get_active(struct kernfs_node *kn);
 void kernfs_put_active(struct kernfs_node *kn);
 void kernfs_addrm_start(struct kernfs_addrm_cxt *acxt);
-int kernfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn,
-		   struct kernfs_node *parent);
+int kernfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn);
 void kernfs_addrm_finish(struct kernfs_addrm_cxt *acxt);
-struct kernfs_node *kernfs_new_node(struct kernfs_root *root, const char *name,
-				    umode_t mode, unsigned flags);
+struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,
+				    const char *name, umode_t mode,
+				    unsigned flags);
 
 /*
  * file.c

commit 798c75a0d44cdbd6e3d82a6a676e6de38525b3bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:36:03 2014 -0800

    Revert "kernfs: remove KERNFS_REMOVED"
    
    This reverts commit ae34372eb8408b3d07e870f1939f99007a730d28.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 57a93f4d645c..c6ba5bc37a98 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -26,8 +26,7 @@ struct kernfs_iattrs {
 	struct simple_xattrs	xattrs;
 };
 
-/* +1 to avoid triggering overflow warning when negating it */
-#define KN_DEACTIVATED_BIAS		(INT_MIN + 1)
+#define KN_DEACTIVATED_BIAS		INT_MIN
 
 /* KERNFS_TYPE_MASK and types are defined in include/linux/kernfs.h */
 

commit 55f6e30d0a6a8975cc0831e8a4a3715b815b6a2f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:27:16 2014 -0800

    Revert "kernfs: invoke kernfs_unmap_bin_file() directly from __kernfs_remove()"
    
    This reverts commit f601f9a2bf7dc1f7ee18feece4c4e2fc6845d6c4.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index e9ec38c86074..57a93f4d645c 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -113,7 +113,7 @@ struct kernfs_node *kernfs_new_node(struct kernfs_root *root, const char *name,
  */
 extern const struct file_operations kernfs_file_fops;
 
-void kernfs_unmap_file(struct kernfs_node *kn);
+void kernfs_unmap_bin_file(struct kernfs_node *kn);
 
 /*
  * symlink.c

commit 7653fe9d6cddc3fc5e4220608079006d8ac0054c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:20:56 2014 -0800

    Revert "kernfs: remove kernfs_addrm_cxt"
    
    This reverts commit 99177a34110889a8f2c36420c34e3bcc9bfd8a70.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 4bc57848076c..e9ec38c86074 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -45,6 +45,13 @@ static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)
 	return kn->dir.root;
 }
 
+/*
+ * Context structure to be used while adding/removing nodes.
+ */
+struct kernfs_addrm_cxt {
+	struct kernfs_node	*removed;
+};
+
 /*
  * mount.c
  */
@@ -94,7 +101,10 @@ extern const struct inode_operations kernfs_dir_iops;
 
 struct kernfs_node *kernfs_get_active(struct kernfs_node *kn);
 void kernfs_put_active(struct kernfs_node *kn);
-int kernfs_add_one(struct kernfs_node *kn, struct kernfs_node *parent);
+void kernfs_addrm_start(struct kernfs_addrm_cxt *acxt);
+int kernfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn,
+		   struct kernfs_node *parent);
+void kernfs_addrm_finish(struct kernfs_addrm_cxt *acxt);
 struct kernfs_node *kernfs_new_node(struct kernfs_root *root, const char *name,
 				    umode_t mode, unsigned flags);
 

commit 99177a34110889a8f2c36420c34e3bcc9bfd8a70
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:24 2014 -0500

    kernfs: remove kernfs_addrm_cxt
    
    kernfs_addrm_cxt and the accompanying kernfs_addrm_start/finish() were
    added because there were operations which should be performed outside
    kernfs_mutex after adding and removing kernfs_nodes.  The necessary
    operations were recorded in kernfs_addrm_cxt and performed by
    kernfs_addrm_finish(); however, after the recent changes which
    relocated deactivation and unmapping so that they're performed
    directly during removal, the only operation kernfs_addrm_finish()
    performs is kernfs_put(), which can be moved inside the removal path
    too.
    
    This patch moves the kernfs_put() of the base ref to __kernfs_remove()
    and remove kernfs_addrm_cxt and kernfs_addrm_start/finish().
    
    * kernfs_add_one() is updated to grab and release the parent's active
      ref and kernfs_mutex itself.  kernfs_get/put_active() and
      kernfs_addrm_start/finish() invocations around it are removed from
      all users.
    
    * __kernfs_remove() puts an unlinked node directly instead of chaining
      it to kernfs_addrm_cxt.  Its callers are updated to grab and release
      kernfs_mutex instead of calling kernfs_addrm_start/finish() around
      it.
    
    v2: Updated to fit the v2 restructuring of removal path.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index e9ec38c86074..4bc57848076c 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -45,13 +45,6 @@ static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)
 	return kn->dir.root;
 }
 
-/*
- * Context structure to be used while adding/removing nodes.
- */
-struct kernfs_addrm_cxt {
-	struct kernfs_node	*removed;
-};
-
 /*
  * mount.c
  */
@@ -101,10 +94,7 @@ extern const struct inode_operations kernfs_dir_iops;
 
 struct kernfs_node *kernfs_get_active(struct kernfs_node *kn);
 void kernfs_put_active(struct kernfs_node *kn);
-void kernfs_addrm_start(struct kernfs_addrm_cxt *acxt);
-int kernfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn,
-		   struct kernfs_node *parent);
-void kernfs_addrm_finish(struct kernfs_addrm_cxt *acxt);
+int kernfs_add_one(struct kernfs_node *kn, struct kernfs_node *parent);
 struct kernfs_node *kernfs_new_node(struct kernfs_root *root, const char *name,
 				    umode_t mode, unsigned flags);
 

commit f601f9a2bf7dc1f7ee18feece4c4e2fc6845d6c4
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:23 2014 -0500

    kernfs: invoke kernfs_unmap_bin_file() directly from __kernfs_remove()
    
    kernfs_unmap_bin_file() is supposed to unmap all memory mappings of
    the target file before kernfs_remove() finishes; however, it currently
    is being called from kernfs_addrm_finish() and has the same race
    problem as the original implementation of deactivation when there are
    multiple removers - only the remover which snatches the node to its
    addrm_cxt->removed list is guaranteed to wait for its completion
    before returning.
    
    It can be fixed by moving kernfs_unmap_bin_file() invocation from
    kernfs_addrm_finish() to __kernfs_remove().  The function may be
    called multiple times but that shouldn't do any harm.
    
    We end up dropping kernfs_mutex in the removal loop and the node may
    be removed inbetween by someone else.  kernfs_unlink_sibling() is
    updated to test whether the node has already been removed and return
    accordingly.  __kernfs_remove() in turn performs post-unlinking
    cleanup only if it actually unlinked the node.
    
    KERNFS_HAS_MMAP test is moved out of the unmap function into
    __kernfs_remove() so that we don't unlock kernfs_mutex unnecessarily.
    While at it, drop the now meaningless "bin" qualifier from the
    function name.
    
    v2: Rewritten to fit the v2 restructuring of removal path.  HAS_MMAP
        test relocated.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 57a93f4d645c..e9ec38c86074 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -113,7 +113,7 @@ struct kernfs_node *kernfs_new_node(struct kernfs_root *root, const char *name,
  */
 extern const struct file_operations kernfs_file_fops;
 
-void kernfs_unmap_bin_file(struct kernfs_node *kn);
+void kernfs_unmap_file(struct kernfs_node *kn);
 
 /*
  * symlink.c

commit ae34372eb8408b3d07e870f1939f99007a730d28
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:21 2014 -0500

    kernfs: remove KERNFS_REMOVED
    
    KERNFS_REMOVED is used to mark half-initialized and dying nodes so
    that they don't show up in lookups and deny adding new nodes under or
    renaming it; however, its role overlaps those of deactivation and
    removal from rbtree.
    
    It's necessary to deny addition of new children while removal is in
    progress; however, this role considerably intersects with deactivation
    - KERNFS_REMOVED prevents new children while deactivation prevents new
    file operations.  There's no reason to have them separate making
    things more complex than necessary.
    
    KERNFS_REMOVED is also used to decide whether a node is still visible
    to vfs layer, which is rather redundant as equivalent determination
    can be made by testing whether the node is on its parent's children
    rbtree or not.
    
    This patch removes KERNFS_REMOVED.
    
    * Instead of KERNFS_REMOVED, each node now starts its life
      deactivated.  This means that we now use both atomic_add() and
      atomic_sub() on KN_DEACTIVATED_BIAS, which is INT_MIN.  The compiler
      generates an overflow warnings when negating INT_MIN as the negation
      can't be represented as a positive number.  Nothing is actually
      broken but let's bump BIAS by one to avoid the warnings for archs
      which negates the subtrahend..
    
    * KERNFS_REMOVED tests in add and rename paths are replaced with
      kernfs_get/put_active() of the target nodes.  Due to the way the add
      path is structured now, active ref handling is done in the callers
      of kernfs_add_one().  This will be consolidated up later.
    
    * kernfs_remove_one() is updated to deactivate instead of setting
      KERNFS_REMOVED.  This removes deactivation from kernfs_deactivate(),
      which is now renamed to kernfs_drain().
    
    * kernfs_dop_revalidate() now tests RB_EMPTY_NODE(&kn->rb) instead of
      KERNFS_REMOVED and KERNFS_REMOVED test in kernfs_dir_pos() is
      dropped.  A node which is removed from the children rbtree is not
      included in the iteration in the first place.  This means that a
      node may be visible through vfs a bit longer - it's now also visible
      after deactivation until the actual removal.  This slightly enlarged
      window difference doesn't make any difference to the userland.
    
    * Sanity check on KERNFS_REMOVED in kernfs_put() is replaced with
      checks on the active ref.
    
    * Some comment style updates in the affected area.
    
    v2: Reordered before removal path restructuring.  kernfs_active()
        dropped and kernfs_get/put_active() used instead.  RB_EMPTY_NODE()
        used in the lookup paths.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index c6ba5bc37a98..57a93f4d645c 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -26,7 +26,8 @@ struct kernfs_iattrs {
 	struct simple_xattrs	xattrs;
 };
 
-#define KN_DEACTIVATED_BIAS		INT_MIN
+/* +1 to avoid triggering overflow warning when negating it */
+#define KN_DEACTIVATED_BIAS		(INT_MIN + 1)
 
 /* KERNFS_TYPE_MASK and types are defined in include/linux/kernfs.h */
 

commit 2063d608f5110d120db60e896ec2c70c95bb7978
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 16:02:57 2013 -0500

    kernfs: mark static names with KERNFS_STATIC_NAME
    
    Because sysfs used struct attribute which are supposed to stay
    constant, sysfs didn't copy names when creating regular files.  The
    specified string for name was supposed to stay constant.  Such
    distinction isn't inherent for kernfs.  kernfs_create_file[_ns]()
    should be able to take the same @name as kernfs_create_dir[_ns]()
    
    As there can be huge number of sysfs attributes, we still want to be
    able to use static names for sysfs attributes.  This patch renames
    kernfs_create_file_ns_key() to __kernfs_create_file() and adds
    @name_is_static parameter so that the caller can explicitly indicate
    that @name can be used without copying.  kernfs is updated to use
    KERNFS_STATIC_NAME to distinguish static and copied names.
    
    This patch doesn't introduce any behavior changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index a4ff491fd59c..c6ba5bc37a98 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -105,7 +105,7 @@ int kernfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn,
 		   struct kernfs_node *parent);
 void kernfs_addrm_finish(struct kernfs_addrm_cxt *acxt);
 struct kernfs_node *kernfs_new_node(struct kernfs_root *root, const char *name,
-				    umode_t mode, int type);
+				    umode_t mode, unsigned flags);
 
 /*
  * file.c

commit c637b8acbe079edb477d887041755b489036f146
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:58 2013 -0500

    kernfs: s/sysfs/kernfs/ in internal functions and whatever is left
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_*()/kernfs_*()/ in all internal functions
    * s/sysfs/kernfs/ in internal strings, comments and whatever is remaining
    * Uniformly rename various vfs operations so that they're consistently
      named and distinguishable.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index e62e8ec15d65..a4ff491fd59c 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -76,19 +76,19 @@ extern struct kmem_cache *kernfs_node_cache;
 /*
  * inode.c
  */
-struct inode *sysfs_get_inode(struct super_block *sb, struct kernfs_node *kn);
-void sysfs_evict_inode(struct inode *inode);
-int sysfs_permission(struct inode *inode, int mask);
-int sysfs_setattr(struct dentry *dentry, struct iattr *iattr);
-int sysfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
-		  struct kstat *stat);
-int sysfs_setxattr(struct dentry *dentry, const char *name, const void *value,
-		   size_t size, int flags);
-int sysfs_removexattr(struct dentry *dentry, const char *name);
-ssize_t sysfs_getxattr(struct dentry *dentry, const char *name, void *buf,
-		       size_t size);
-ssize_t sysfs_listxattr(struct dentry *dentry, char *buf, size_t size);
-void sysfs_inode_init(void);
+struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn);
+void kernfs_evict_inode(struct inode *inode);
+int kernfs_iop_permission(struct inode *inode, int mask);
+int kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr);
+int kernfs_iop_getattr(struct vfsmount *mnt, struct dentry *dentry,
+		       struct kstat *stat);
+int kernfs_iop_setxattr(struct dentry *dentry, const char *name, const void *value,
+			size_t size, int flags);
+int kernfs_iop_removexattr(struct dentry *dentry, const char *name);
+ssize_t kernfs_iop_getxattr(struct dentry *dentry, const char *name, void *buf,
+			    size_t size);
+ssize_t kernfs_iop_listxattr(struct dentry *dentry, char *buf, size_t size);
+void kernfs_inode_init(void);
 
 /*
  * dir.c
@@ -98,21 +98,21 @@ extern const struct dentry_operations kernfs_dops;
 extern const struct file_operations kernfs_dir_fops;
 extern const struct inode_operations kernfs_dir_iops;
 
-struct kernfs_node *sysfs_get_active(struct kernfs_node *kn);
-void sysfs_put_active(struct kernfs_node *kn);
-void sysfs_addrm_start(struct kernfs_addrm_cxt *acxt);
-int sysfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn,
-		  struct kernfs_node *parent);
-void sysfs_addrm_finish(struct kernfs_addrm_cxt *acxt);
-struct kernfs_node *sysfs_new_dirent(struct kernfs_root *root,
-				     const char *name, umode_t mode, int type);
+struct kernfs_node *kernfs_get_active(struct kernfs_node *kn);
+void kernfs_put_active(struct kernfs_node *kn);
+void kernfs_addrm_start(struct kernfs_addrm_cxt *acxt);
+int kernfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn,
+		   struct kernfs_node *parent);
+void kernfs_addrm_finish(struct kernfs_addrm_cxt *acxt);
+struct kernfs_node *kernfs_new_node(struct kernfs_root *root, const char *name,
+				    umode_t mode, int type);
 
 /*
  * file.c
  */
 extern const struct file_operations kernfs_file_fops;
 
-void sysfs_unmap_bin_file(struct kernfs_node *kn);
+void kernfs_unmap_bin_file(struct kernfs_node *kn);
 
 /*
  * symlink.c

commit a797bfc30532388e8a11ca726df60cdd77aa8675
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:57 2013 -0500

    kernfs: s/sysfs/kernfs/ in global variables
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_mutex/kernfs_mutex/
    * s/sysfs_dentry_ops/kernfs_dops/
    * s/sysfs_dir_operations/kernfs_dir_fops/
    * s/sysfs_dir_inode_operations/kernfs_dir_iops/
    * s/kernfs_file_operations/kernfs_file_fops/ - renamed for consistency
    * s/sysfs_symlink_inode_operations/kernfs_symlink_iops/
    * s/sysfs_aops/kernfs_aops/
    * s/sysfs_backing_dev_info/kernfs_bdi/
    * s/sysfs_inode_operations/kernfs_iops/
    * s/sysfs_dir_cachep/kernfs_node_cache/
    * s/sysfs_ops/kernfs_sops/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index c4bf5bf72f78..e62e8ec15d65 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -71,7 +71,7 @@ struct kernfs_super_info {
 };
 #define kernfs_info(SB) ((struct kernfs_super_info *)(SB->s_fs_info))
 
-extern struct kmem_cache *sysfs_dir_cachep;
+extern struct kmem_cache *kernfs_node_cache;
 
 /*
  * inode.c
@@ -93,10 +93,10 @@ void sysfs_inode_init(void);
 /*
  * dir.c
  */
-extern struct mutex sysfs_mutex;
-extern const struct dentry_operations sysfs_dentry_ops;
-extern const struct file_operations sysfs_dir_operations;
-extern const struct inode_operations sysfs_dir_inode_operations;
+extern struct mutex kernfs_mutex;
+extern const struct dentry_operations kernfs_dops;
+extern const struct file_operations kernfs_dir_fops;
+extern const struct inode_operations kernfs_dir_iops;
 
 struct kernfs_node *sysfs_get_active(struct kernfs_node *kn);
 void sysfs_put_active(struct kernfs_node *kn);
@@ -110,13 +110,13 @@ struct kernfs_node *sysfs_new_dirent(struct kernfs_root *root,
 /*
  * file.c
  */
-extern const struct file_operations kernfs_file_operations;
+extern const struct file_operations kernfs_file_fops;
 
 void sysfs_unmap_bin_file(struct kernfs_node *kn);
 
 /*
  * symlink.c
  */
-extern const struct inode_operations sysfs_symlink_inode_operations;
+extern const struct inode_operations kernfs_symlink_iops;
 
 #endif	/* __KERNFS_INTERNAL_H */

commit df23fc39bce03bb26e63bea57fc5f5bf6882d74b
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:56 2013 -0500

    kernfs: s/sysfs/kernfs/ in constants
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/SYSFS_DIR/KERNFS_DIR/
    * s/SYSFS_KOBJ_ATTR/KERNFS_FILE/
    * s/SYSFS_KOBJ_LINK/KERNFS_LINK/
    * s/SYSFS_{TYPE_FLAGS}/KERNFS_{TYPE_FLAGS}/
    * s/SYSFS_FLAG_{FLAG}/KERNFS_{FLAG}/
    * s/sysfs_type()/kernfs_type()/
    * s/SD_DEACTIVATED_BIAS/KN_DEACTIVATED_BIAS/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 573f66988643..c4bf5bf72f78 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -26,9 +26,9 @@ struct kernfs_iattrs {
 	struct simple_xattrs	xattrs;
 };
 
-#define SD_DEACTIVATED_BIAS		INT_MIN
+#define KN_DEACTIVATED_BIAS		INT_MIN
 
-/* SYSFS_TYPE_MASK and types are defined in include/linux/kernfs.h */
+/* KERNFS_TYPE_MASK and types are defined in include/linux/kernfs.h */
 
 /**
  * kernfs_root - find out the kernfs_root a kernfs_node belongs to

commit c525aaddc366df23eb095d58a2bdf11cce62a98b
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:55 2013 -0500

    kernfs: s/sysfs/kernfs/ in various data structures
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_open_dirent/kernfs_open_node/
    * s/sysfs_open_file/kernfs_open_file/
    * s/sysfs_inode_attrs/kernfs_iattrs/
    * s/sysfs_addrm_cxt/kernfs_addrm_cxt/
    * s/sysfs_super_info/kernfs_super_info/
    * s/sysfs_info()/kernfs_info()/
    * s/sysfs_open_dirent_lock/kernfs_open_node_lock/
    * s/sysfs_open_file_mutex/kernfs_open_file_mutex/
    * s/sysfs_of()/kernfs_of()/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 2dbb1cb95e7f..573f66988643 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -18,7 +18,7 @@
 
 #include <linux/kernfs.h>
 
-struct sysfs_inode_attrs {
+struct kernfs_iattrs {
 	struct iattr		ia_iattr;
 	void			*ia_secdata;
 	u32			ia_secdata_len;
@@ -47,14 +47,14 @@ static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)
 /*
  * Context structure to be used while adding/removing nodes.
  */
-struct sysfs_addrm_cxt {
+struct kernfs_addrm_cxt {
 	struct kernfs_node	*removed;
 };
 
 /*
  * mount.c
  */
-struct sysfs_super_info {
+struct kernfs_super_info {
 	/*
 	 * The root associated with this super_block.  Each super_block is
 	 * identified by the root and ns it's associated with.
@@ -63,13 +63,13 @@ struct sysfs_super_info {
 
 	/*
 	 * Each sb is associated with one namespace tag, currently the
-	 * network namespace of the task which mounted this sysfs instance.
-	 * If multiple tags become necessary, make the following an array
-	 * and compare kernfs_node tag against every entry.
+	 * network namespace of the task which mounted this kernfs
+	 * instance.  If multiple tags become necessary, make the following
+	 * an array and compare kernfs_node tag against every entry.
 	 */
 	const void		*ns;
 };
-#define sysfs_info(SB) ((struct sysfs_super_info *)(SB->s_fs_info))
+#define kernfs_info(SB) ((struct kernfs_super_info *)(SB->s_fs_info))
 
 extern struct kmem_cache *sysfs_dir_cachep;
 
@@ -100,10 +100,10 @@ extern const struct inode_operations sysfs_dir_inode_operations;
 
 struct kernfs_node *sysfs_get_active(struct kernfs_node *kn);
 void sysfs_put_active(struct kernfs_node *kn);
-void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt);
-int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct kernfs_node *kn,
+void sysfs_addrm_start(struct kernfs_addrm_cxt *acxt);
+int sysfs_add_one(struct kernfs_addrm_cxt *acxt, struct kernfs_node *kn,
 		  struct kernfs_node *parent);
-void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
+void sysfs_addrm_finish(struct kernfs_addrm_cxt *acxt);
 struct kernfs_node *sysfs_new_dirent(struct kernfs_root *root,
 				     const char *name, umode_t mode, int type);
 

commit adc5e8b58f4886d45f79f4ff41a09001a76a6b12
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:54 2013 -0500

    kernfs: drop s_ prefix from kernfs_node members
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    s_ prefix for kernfs members is used inconsistently and a misnomer
    now.  It's not like kernfs_node is used widely across the kernel
    making the ability to grep for the members particularly useful.  Let's
    just drop the prefix.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index b7ea76c6fb33..2dbb1cb95e7f 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -39,9 +39,9 @@ struct sysfs_inode_attrs {
 static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)
 {
 	/* if parent exists, it's always a dir; otherwise, @sd is a dir */
-	if (kn->s_parent)
-		kn = kn->s_parent;
-	return kn->s_dir.root;
+	if (kn->parent)
+		kn = kn->parent;
+	return kn->dir.root;
 }
 
 /*

commit 324a56e16e44baecac3ca799fd216154145c14bf
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:53 2013 -0500

    kernfs: s/sysfs_dirent/kernfs_node/ and rename its friends accordingly
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_elem_dir/kernfs_elem_dir/
    * s/sysfs_elem_symlink/kernfs_elem_symlink/
    * s/sysfs_elem_attr/kernfs_elem_file/
    * s/sysfs_dirent/kernfs_node/
    * s/sd/kn/ in kernfs proper
    * s/parent_sd/parent/
    * s/target_sd/target/
    * s/dir_sd/parent/
    * s/to_sysfs_dirent()/rb_to_kn()/
    * misc renames of local vars when they conflict with the above
    
    Because md, mic and gpio dig into sysfs details, this patch ends up
    modifying them.  All are sysfs_dirent renames and trivial.  While we
    can avoid these by introducing a dummy wrapping struct sysfs_dirent
    around kernfs_node, given the limited usage outside kernfs and sysfs
    proper, I don't think such workaround is called for.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    - mic / gpio renames were missing.  Spotted by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 910e485b7333..b7ea76c6fb33 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -31,24 +31,24 @@ struct sysfs_inode_attrs {
 /* SYSFS_TYPE_MASK and types are defined in include/linux/kernfs.h */
 
 /**
- * kernfs_root - find out the kernfs_root a sysfs_dirent belongs to
- * @sd: sysfs_dirent of interest
+ * kernfs_root - find out the kernfs_root a kernfs_node belongs to
+ * @kn: kernfs_node of interest
  *
- * Return the kernfs_root @sd belongs to.
+ * Return the kernfs_root @kn belongs to.
  */
-static inline struct kernfs_root *kernfs_root(struct sysfs_dirent *sd)
+static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)
 {
 	/* if parent exists, it's always a dir; otherwise, @sd is a dir */
-	if (sd->s_parent)
-		sd = sd->s_parent;
-	return sd->s_dir.root;
+	if (kn->s_parent)
+		kn = kn->s_parent;
+	return kn->s_dir.root;
 }
 
 /*
  * Context structure to be used while adding/removing nodes.
  */
 struct sysfs_addrm_cxt {
-	struct sysfs_dirent	*removed;
+	struct kernfs_node	*removed;
 };
 
 /*
@@ -62,10 +62,10 @@ struct sysfs_super_info {
 	struct kernfs_root	*root;
 
 	/*
-	 * Each sb is associated with one namespace tag, currently the network
-	 * namespace of the task which mounted this sysfs instance.  If multiple
-	 * tags become necessary, make the following an array and compare
-	 * sysfs_dirent tag against every entry.
+	 * Each sb is associated with one namespace tag, currently the
+	 * network namespace of the task which mounted this sysfs instance.
+	 * If multiple tags become necessary, make the following an array
+	 * and compare kernfs_node tag against every entry.
 	 */
 	const void		*ns;
 };
@@ -76,7 +76,7 @@ extern struct kmem_cache *sysfs_dir_cachep;
 /*
  * inode.c
  */
-struct inode *sysfs_get_inode(struct super_block *sb, struct sysfs_dirent *sd);
+struct inode *sysfs_get_inode(struct super_block *sb, struct kernfs_node *kn);
 void sysfs_evict_inode(struct inode *inode);
 int sysfs_permission(struct inode *inode, int mask);
 int sysfs_setattr(struct dentry *dentry, struct iattr *iattr);
@@ -98,21 +98,21 @@ extern const struct dentry_operations sysfs_dentry_ops;
 extern const struct file_operations sysfs_dir_operations;
 extern const struct inode_operations sysfs_dir_inode_operations;
 
-struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd);
-void sysfs_put_active(struct sysfs_dirent *sd);
+struct kernfs_node *sysfs_get_active(struct kernfs_node *kn);
+void sysfs_put_active(struct kernfs_node *kn);
 void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt);
-int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
-		  struct sysfs_dirent *parent_sd);
+int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct kernfs_node *kn,
+		  struct kernfs_node *parent);
 void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
-struct sysfs_dirent *sysfs_new_dirent(struct kernfs_root *root,
-				      const char *name, umode_t mode, int type);
+struct kernfs_node *sysfs_new_dirent(struct kernfs_root *root,
+				     const char *name, umode_t mode, int type);
 
 /*
  * file.c
  */
 extern const struct file_operations kernfs_file_operations;
 
-void sysfs_unmap_bin_file(struct sysfs_dirent *sd);
+void sysfs_unmap_bin_file(struct kernfs_node *kn);
 
 /*
  * symlink.c

commit 2322392b020badfe49730f1529b9c1a15248c387
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 23 17:40:02 2013 -0500

    kernfs: implement "trusted.*" xattr support
    
    kernfs inherited "security.*" xattr support from sysfs.  This patch
    extends xattr support to "trusted.*" using simple_xattr_*().  As
    trusted xattrs are restricted to CAP_SYS_ADMIN, simple_xattr_*() which
    uses kernel memory for storage shouldn't be problematic.
    
    Note that the existing "security.*" support doesn't implement
    get/remove/list and the this patch only implements those ops for
    "trusted.*".  We probably want to extend those ops to include support
    for "security.*".
    
    This patch will allow using kernfs from cgroup which requires
    "trusted.*" xattr support.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: David P. Quigley <dpquigl@tycho.nsa.gov>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index f25b3548bcca..910e485b7333 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -14,6 +14,7 @@
 #include <linux/lockdep.h>
 #include <linux/fs.h>
 #include <linux/mutex.h>
+#include <linux/xattr.h>
 
 #include <linux/kernfs.h>
 
@@ -21,6 +22,8 @@ struct sysfs_inode_attrs {
 	struct iattr		ia_iattr;
 	void			*ia_secdata;
 	u32			ia_secdata_len;
+
+	struct simple_xattrs	xattrs;
 };
 
 #define SD_DEACTIVATED_BIAS		INT_MIN
@@ -81,6 +84,10 @@ int sysfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		  struct kstat *stat);
 int sysfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		   size_t size, int flags);
+int sysfs_removexattr(struct dentry *dentry, const char *name);
+ssize_t sysfs_getxattr(struct dentry *dentry, const char *name, void *buf,
+		       size_t size);
+ssize_t sysfs_listxattr(struct dentry *dentry, char *buf, size_t size);
 void sysfs_inode_init(void);
 
 /*

commit 9a8049affd55a2c857a89faece27b878416fbf91
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 23 17:40:01 2013 -0500

    kernfs: update sysfs_init_inode_attrs()
    
    sysfs_init_inode_attrs() is a bit clumsy to use requiring the caller
    to check whether @sd->s_iattr is already set or not.  Rename it to
    sysfs_inode_attrs(), update it to check whether @sd->s_iattr is
    already initialized before trying to initialize it and return
    @sd->s_iattr.  This simplifies the callers.
    
    While at it,
    
    * Rename struct sysfs_inode_attrs pointer variables to "attrs".  As
      kernfs no longer deals with "struct attribute", this isn't confusing
      and makes it easier to distinguish from struct iattr pointers.
    
    * A new field will be added to sysfs_inode_attrs.  Reindent in
      preparation.
    
    This patch doesn't introduce any behavior changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index d1ff591c5cf3..f25b3548bcca 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -18,9 +18,9 @@
 #include <linux/kernfs.h>
 
 struct sysfs_inode_attrs {
-	struct iattr	ia_iattr;
-	void		*ia_secdata;
-	u32		ia_secdata_len;
+	struct iattr		ia_iattr;
+	void			*ia_secdata;
+	u32			ia_secdata_len;
 };
 
 #define SD_DEACTIVATED_BIAS		INT_MIN

commit bfc5c17337145955b31c22b96a6e07def048471b
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:47 2013 -0500

    sysfs, kernfs: remove cross inclusions of internal headers
    
    fs/kernfs/kernfs-internal.h needed to include fs/sysfs/sysfs.h because
    part of kernfs core implementation was living in sysfs.
    
    fs/sysfs/sysfs.h needed to include fs/kernfs/kernfs-internal.h because
    include/linux/kernfs.h didn't expose enough interface.
    
    The separation is complete and neither is true anymore.  Remove the
    cross inclusion and make sysfs a proper user of kernfs.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index f33a7844e8fd..d1ff591c5cf3 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -48,8 +48,6 @@ struct sysfs_addrm_cxt {
 	struct sysfs_dirent	*removed;
 };
 
-#include "../sysfs/sysfs.h"
-
 /*
  * mount.c
  */

commit cf9e5a73aaff0204801dd19cb4bd91d32f32026a
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Nov 29 17:18:32 2013 -0500

    sysfs, kernfs: make sysfs_dirent definition public
    
    sysfs_dirent includes some information which should be available to
    kernfs users - the type, flags, name and parent pointer.  This patch
    moves sysfs_dirent definition from kernfs/kernfs-internal.h to
    include/linux/kernfs.h so that kernfs users can access them.
    
    The type part of flags is exported as enum kernfs_node_type, the flags
    kernfs_node_flag, sysfs_type() and kernfs_enable_ns() are moved to
    include/linux/kernfs.h and the former is updated to return the enum
    type.  sysfs_dirent->s_parent and ->s_name are marked explicitly as
    public.
    
    This patch doesn't introduce any functional changes.
    
    v2: Flags exported too and kernfs_enable_ns() definition moved.
    
    v3: While moving kernfs_enable_ns() to include/linux/kernfs.h, v1 and
        v2 put the definition outside CONFIG_SYSFS replacing the dummy
        implementation with the actual implementation too.  Unfortunately,
        this can lead to oops when !CONFIG_SYSFS because
        kernfs_enable_ns() may be called on a NULL @sd and now tries to
        dereference @sd instead of not doing anything.  This issue was
        reported by Yuanhan Liu.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index ced0d6dadc7d..f33a7844e8fd 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -13,102 +13,19 @@
 
 #include <linux/lockdep.h>
 #include <linux/fs.h>
-#include <linux/rbtree.h>
 #include <linux/mutex.h>
 
 #include <linux/kernfs.h>
 
-struct sysfs_open_dirent;
-
-/* type-specific structures for sysfs_dirent->s_* union members */
-struct sysfs_elem_dir {
-	unsigned long		subdirs;
-	/* children rbtree starts here and goes through sd->s_rb */
-	struct rb_root		children;
-
-	/*
-	 * The kernfs hierarchy this directory belongs to.  This fits
-	 * better directly in sysfs_dirent but is here to save space.
-	 */
-	struct kernfs_root	*root;
-};
-
-struct sysfs_elem_symlink {
-	struct sysfs_dirent	*target_sd;
-};
-
-struct sysfs_elem_attr {
-	const struct kernfs_ops	*ops;
-	struct sysfs_open_dirent *open;
-	loff_t			size;
-};
-
 struct sysfs_inode_attrs {
 	struct iattr	ia_iattr;
 	void		*ia_secdata;
 	u32		ia_secdata_len;
 };
 
-/*
- * sysfs_dirent - the building block of sysfs hierarchy.  Each and
- * every sysfs node is represented by single sysfs_dirent.
- *
- * As long as s_count reference is held, the sysfs_dirent itself is
- * accessible.  Dereferencing s_elem or any other outer entity
- * requires s_active reference.
- */
-struct sysfs_dirent {
-	atomic_t		s_count;
-	atomic_t		s_active;
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-	struct lockdep_map	dep_map;
-#endif
-	struct sysfs_dirent	*s_parent;
-	const char		*s_name;
-
-	struct rb_node		s_rb;
-
-	union {
-		struct completion	*completion;
-		struct sysfs_dirent	*removed_list;
-	} u;
-
-	const void		*s_ns; /* namespace tag */
-	unsigned int		s_hash; /* ns + name hash */
-	union {
-		struct sysfs_elem_dir		s_dir;
-		struct sysfs_elem_symlink	s_symlink;
-		struct sysfs_elem_attr		s_attr;
-	};
-
-	void			*priv;
-
-	unsigned short		s_flags;
-	umode_t			s_mode;
-	unsigned int		s_ino;
-	struct sysfs_inode_attrs *s_iattr;
-};
-
 #define SD_DEACTIVATED_BIAS		INT_MIN
 
-#define SYSFS_TYPE_MASK			0x000f
-#define SYSFS_DIR			0x0001
-#define SYSFS_KOBJ_ATTR			0x0002
-#define SYSFS_KOBJ_LINK			0x0004
-#define SYSFS_COPY_NAME			(SYSFS_DIR | SYSFS_KOBJ_LINK)
-#define SYSFS_ACTIVE_REF		SYSFS_KOBJ_ATTR
-
-#define SYSFS_FLAG_MASK			~SYSFS_TYPE_MASK
-#define SYSFS_FLAG_REMOVED		0x0010
-#define SYSFS_FLAG_NS			0x0020
-#define SYSFS_FLAG_HAS_SEQ_SHOW		0x0040
-#define SYSFS_FLAG_HAS_MMAP		0x0080
-#define SYSFS_FLAG_LOCKDEP		0x0100
-
-static inline unsigned int sysfs_type(struct sysfs_dirent *sd)
-{
-	return sd->s_flags & SYSFS_TYPE_MASK;
-}
+/* SYSFS_TYPE_MASK and types are defined in include/linux/kernfs.h */
 
 /**
  * kernfs_root - find out the kernfs_root a sysfs_dirent belongs to

commit fa736a951e456b996a76826ba78ff974414c3b55
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:44 2013 -0500

    sysfs, kernfs: move mount core code to fs/kernfs/mount.c
    
    Move core mount code to fs/kernfs/mount.c.  The respective
    declarations in fs/sysfs/sysfs.h are moved to
    fs/kernfs/kernfs-internal.h.
    
    This is pure relocation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 0d949885389d..ced0d6dadc7d 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -133,6 +133,28 @@ struct sysfs_addrm_cxt {
 
 #include "../sysfs/sysfs.h"
 
+/*
+ * mount.c
+ */
+struct sysfs_super_info {
+	/*
+	 * The root associated with this super_block.  Each super_block is
+	 * identified by the root and ns it's associated with.
+	 */
+	struct kernfs_root	*root;
+
+	/*
+	 * Each sb is associated with one namespace tag, currently the network
+	 * namespace of the task which mounted this sysfs instance.  If multiple
+	 * tags become necessary, make the following an array and compare
+	 * sysfs_dirent tag against every entry.
+	 */
+	const void		*ns;
+};
+#define sysfs_info(SB) ((struct sysfs_super_info *)(SB->s_fs_info))
+
+extern struct kmem_cache *sysfs_dir_cachep;
+
 /*
  * inode.c
  */

commit 4b93dc9b1c684d0587fe44d36bbfdf45bd3bea9d
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:43 2013 -0500

    sysfs, kernfs: prepare mount path for kernfs
    
    We're in the process of separating out core sysfs functionality into
    kernfs which will deal with sysfs_dirents directly.  This patch
    rearranges mount path so that the kernfs and sysfs parts are separate.
    
    * As sysfs_super_info won't be visible outside kernfs proper,
      kernfs_super_ns() is added to allow kernfs users to access a
      super_block's namespace tag.
    
    * Generic mount operation is separated out into kernfs_mount_ns().
      sysfs_mount() now just performs sysfs-specific permission check,
      acquires namespace tag, and invokes kernfs_mount_ns().
    
    * Generic superblock release is separated out into kernfs_kill_sb()
      which can be used directly as file_system_type->kill_sb().  As sysfs
      needs to put the namespace tag, sysfs_kill_sb() wraps
      kernfs_kill_sb() with ns tag put.
    
    * sysfs_dir_cachep init and sysfs_inode_init() are separated out into
      kernfs_init().  kernfs_init() uses only small amount of memory and
      trying to handle and propagate kernfs_init() failure doesn't make
      much sense.  Use SLAB_PANIC for sysfs_dir_cachep and make
      sysfs_inode_init() panic on failure.
    
      After this change, kernfs_init() should be called before
      sysfs_init(), fs/namespace.c::mnt_init() modified accordingly.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 466943d576f1..0d949885389d 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -144,7 +144,7 @@ int sysfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		  struct kstat *stat);
 int sysfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		   size_t size, int flags);
-int sysfs_inode_init(void);
+void sysfs_inode_init(void);
 
 /*
  * dir.c

commit bc755553df9ab33f389c1a0a8bd0b4f4646e80ef
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:41 2013 -0500

    sysfs, kernfs: make inode number ida per kernfs_root
    
    kernfs is being updated to allow multiple sysfs_dirent hierarchies so
    that it can also be used by other users.  Currently, inode number is
    allocated using a global ida, sysfs_ino_ida; however, inos for
    different hierarchies should be handled separately.
    
    This patch makes ino allocation per kernfs_root.  sysfs_ino_ida is
    replaced by kernfs_root->ino_ida and sysfs_new_dirent() is updated to
    take @root and allocate ino from it.  ida_simple_get/remove() are used
    instead of sysfs_ino_lock and sysfs_alloc/free_ino().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 7dfe06278350..466943d576f1 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -160,7 +160,8 @@ void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt);
 int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
 		  struct sysfs_dirent *parent_sd);
 void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
-struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type);
+struct sysfs_dirent *sysfs_new_dirent(struct kernfs_root *root,
+				      const char *name, umode_t mode, int type);
 
 /*
  * file.c

commit ba7443bc656e5236c316b2acacc8b551f872910f
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:40 2013 -0500

    sysfs, kernfs: implement kernfs_create/destroy_root()
    
    There currently is single kernfs hierarchy in the whole system which
    is used for sysfs.  kernfs needs to support multiple hierarchies to
    allow other users.  This patch introduces struct kernfs_root which
    serves as the root of each kernfs hierarchy and implements
    kernfs_create/destroy_root().
    
    * Each kernfs_root is associated with a root sd (sysfs_dentry).  The
      root is freed when the root sd is released and kernfs_destory_root()
      simply invokes kernfs_remove() on the root sd.  sysfs_remove_one()
      is updated to handle release of the root sd.  Note that ps_iattr
      update in sysfs_remove_one() is trivially updated for readability.
    
    * Root sd's are now dynamically allocated using sysfs_new_dirent().
      Update sysfs_alloc_ino() so that it gives out ino from 1 so that the
      root sd still gets ino 1.
    
    * While kernfs currently only points to the root sd, it'll soon grow
      fields which are specific to each hierarchy.  As determining a given
      sd's root will be necessary, sd->s_dir.root is added.  This backlink
      fits better as a separate field in sd; however, sd->s_dir is inside
      union with space to spare, so use it to save space and provide
      kernfs_root() accessor to determine the root sd.
    
    * As hierarchies may be destroyed now, each mount needs to hold onto
      the hierarchy it's attached to.  Update sysfs_fill_super() and
      sysfs_kill_sb() so that they get and put the kernfs_root
      respectively.
    
    * sysfs_root is replaced with kernfs_root which is dynamically created
      by invoking kernfs_create_root() from sysfs_init().
    
    This patch doesn't introduce any visible behavior changes.
    
    v2: kernfs_create_root() forgot to set @sd->priv.  Fixed.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 62ae35f997f7..7dfe06278350 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -25,6 +25,12 @@ struct sysfs_elem_dir {
 	unsigned long		subdirs;
 	/* children rbtree starts here and goes through sd->s_rb */
 	struct rb_root		children;
+
+	/*
+	 * The kernfs hierarchy this directory belongs to.  This fits
+	 * better directly in sysfs_dirent but is here to save space.
+	 */
+	struct kernfs_root	*root;
 };
 
 struct sysfs_elem_symlink {
@@ -104,6 +110,20 @@ static inline unsigned int sysfs_type(struct sysfs_dirent *sd)
 	return sd->s_flags & SYSFS_TYPE_MASK;
 }
 
+/**
+ * kernfs_root - find out the kernfs_root a sysfs_dirent belongs to
+ * @sd: sysfs_dirent of interest
+ *
+ * Return the kernfs_root @sd belongs to.
+ */
+static inline struct kernfs_root *kernfs_root(struct sysfs_dirent *sd)
+{
+	/* if parent exists, it's always a dir; otherwise, @sd is a dir */
+	if (sd->s_parent)
+		sd = sd->s_parent;
+	return sd->s_dir.root;
+}
+
 /*
  * Context structure to be used while adding/removing nodes.
  */

commit 2072f1afddfe9fa00c1c0c79f8986707324ec65b
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:35 2013 -0500

    sysfs, kernfs: move symlink core code to fs/kernfs/symlink.c
    
    Move core symlink code to fs/kernfs/symlink.c.  fs/sysfs/symlink.c now
    only contains sysfs wrappers around kernfs interfaces.  The respective
    declarations in fs/sysfs/sysfs.h are moved to
    fs/kernfs/kernfs-internal.h.
    
    This is pure relocation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 38e3a163e5ad..62ae35f997f7 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -149,4 +149,9 @@ extern const struct file_operations kernfs_file_operations;
 
 void sysfs_unmap_bin_file(struct sysfs_dirent *sd);
 
+/*
+ * symlink.c
+ */
+extern const struct inode_operations sysfs_symlink_inode_operations;
+
 #endif	/* __KERNFS_INTERNAL_H */

commit 414985ae23c031efbd6d16d484dea8b5de28b8f7
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:34 2013 -0500

    sysfs, kernfs: move file core code to fs/kernfs/file.c
    
    Move core file code to fs/kernfs/file.c.  fs/sysfs/file.c now contains
    sysfs kernfs_ops callbacks, sysfs wrappers around kernfs interfaces,
    and sysfs_schedule_callback().  The respective declarations in
    fs/sysfs/sysfs.h are moved to fs/kernfs/kernfs-internal.h.
    
    This is pure relocation.
    
    v2: Refreshed on top of the v2 of "sysfs, kernfs: prepare read path
        for kernfs".
    
    v3: Refreshed on top of the v3 of "sysfs, kernfs: prepare read path
        for kernfs".
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 31f0dbe1881b..38e3a163e5ad 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -142,4 +142,11 @@ int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
 void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
 struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type);
 
+/*
+ * file.c
+ */
+extern const struct file_operations kernfs_file_operations;
+
+void sysfs_unmap_bin_file(struct sysfs_dirent *sd);
+
 #endif	/* __KERNFS_INTERNAL_H */

commit fd7b9f7b9776b11df629e9dd3865320bf57ce588
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:33 2013 -0500

    sysfs, kernfs: move dir core code to fs/kernfs/dir.c
    
    Move core dir code to fs/kernfs/dir.c.  fs/sysfs/dir.c now only
    contains sysfs_warn_dup() and sysfs wrappers around kernfs interfaces.
    The respective declarations in fs/sysfs/sysfs.h are moved to
    fs/kernfs/kernfs-internal.h.
    
    This is pure relocation.
    
    v2: sysfs_symlink_target_lock was mistakenly relocated to kernfs.  It
        should remain with sysfs.  Fixed.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 933ac8d5d07a..31f0dbe1881b 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -14,6 +14,7 @@
 #include <linux/lockdep.h>
 #include <linux/fs.h>
 #include <linux/rbtree.h>
+#include <linux/mutex.h>
 
 #include <linux/kernfs.h>
 
@@ -125,4 +126,20 @@ int sysfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		   size_t size, int flags);
 int sysfs_inode_init(void);
 
+/*
+ * dir.c
+ */
+extern struct mutex sysfs_mutex;
+extern const struct dentry_operations sysfs_dentry_ops;
+extern const struct file_operations sysfs_dir_operations;
+extern const struct inode_operations sysfs_dir_inode_operations;
+
+struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd);
+void sysfs_put_active(struct sysfs_dirent *sd);
+void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt);
+int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
+		  struct sysfs_dirent *parent_sd);
+void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
+struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type);
+
 #endif	/* __KERNFS_INTERNAL_H */

commit ffed24e22845a3da0ae01095ae3f11c8d16e889d
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:32 2013 -0500

    sysfs, kernfs: move inode code to fs/kernfs/inode.c
    
    There's nothing sysfs-specific in fs/sysfs/inode.c.  Move everything
    in it to fs/kernfs/inode.c.  The respective declarations in
    fs/sysfs/sysfs.h are moved to fs/kernfs/kernfs-internal.h.
    
    This is pure relocation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
index 5a2c3a17d7cb..933ac8d5d07a 100644
--- a/fs/kernfs/kernfs-internal.h
+++ b/fs/kernfs/kernfs-internal.h
@@ -112,4 +112,17 @@ struct sysfs_addrm_cxt {
 
 #include "../sysfs/sysfs.h"
 
+/*
+ * inode.c
+ */
+struct inode *sysfs_get_inode(struct super_block *sb, struct sysfs_dirent *sd);
+void sysfs_evict_inode(struct inode *inode);
+int sysfs_permission(struct inode *inode, int mask);
+int sysfs_setattr(struct dentry *dentry, struct iattr *iattr);
+int sysfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
+		  struct kstat *stat);
+int sysfs_setxattr(struct dentry *dentry, const char *name, const void *value,
+		   size_t size, int flags);
+int sysfs_inode_init(void);
+
 #endif	/* __KERNFS_INTERNAL_H */

commit ae6621b0716852146e4655fef7f74a181faa6c81
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:31 2013 -0500

    sysfs, kernfs: move internal decls to fs/kernfs/kernfs-internal.h
    
    Move data structure, constant and basic accessor declarations from
    fs/sysfs/sysfs.h to fs/kernfs/kernfs-internal.h.  The two files
    currently include each other.  Once kernfs / sysfs separation is
    complete, the cross inclusions will be removed.  Inclusion protectors
    are added to fs/sysfs/sysfs.h to allow cross-inclusion.
    
    This patch doesn't introduce any functional changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/kernfs-internal.h b/fs/kernfs/kernfs-internal.h
new file mode 100644
index 000000000000..5a2c3a17d7cb
--- /dev/null
+++ b/fs/kernfs/kernfs-internal.h
@@ -0,0 +1,115 @@
+/*
+ * fs/kernfs/kernfs-internal.h - kernfs internal header file
+ *
+ * Copyright (c) 2001-3 Patrick Mochel
+ * Copyright (c) 2007 SUSE Linux Products GmbH
+ * Copyright (c) 2007, 2013 Tejun Heo <teheo@suse.de>
+ *
+ * This file is released under the GPLv2.
+ */
+
+#ifndef __KERNFS_INTERNAL_H
+#define __KERNFS_INTERNAL_H
+
+#include <linux/lockdep.h>
+#include <linux/fs.h>
+#include <linux/rbtree.h>
+
+#include <linux/kernfs.h>
+
+struct sysfs_open_dirent;
+
+/* type-specific structures for sysfs_dirent->s_* union members */
+struct sysfs_elem_dir {
+	unsigned long		subdirs;
+	/* children rbtree starts here and goes through sd->s_rb */
+	struct rb_root		children;
+};
+
+struct sysfs_elem_symlink {
+	struct sysfs_dirent	*target_sd;
+};
+
+struct sysfs_elem_attr {
+	const struct kernfs_ops	*ops;
+	struct sysfs_open_dirent *open;
+	loff_t			size;
+};
+
+struct sysfs_inode_attrs {
+	struct iattr	ia_iattr;
+	void		*ia_secdata;
+	u32		ia_secdata_len;
+};
+
+/*
+ * sysfs_dirent - the building block of sysfs hierarchy.  Each and
+ * every sysfs node is represented by single sysfs_dirent.
+ *
+ * As long as s_count reference is held, the sysfs_dirent itself is
+ * accessible.  Dereferencing s_elem or any other outer entity
+ * requires s_active reference.
+ */
+struct sysfs_dirent {
+	atomic_t		s_count;
+	atomic_t		s_active;
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	dep_map;
+#endif
+	struct sysfs_dirent	*s_parent;
+	const char		*s_name;
+
+	struct rb_node		s_rb;
+
+	union {
+		struct completion	*completion;
+		struct sysfs_dirent	*removed_list;
+	} u;
+
+	const void		*s_ns; /* namespace tag */
+	unsigned int		s_hash; /* ns + name hash */
+	union {
+		struct sysfs_elem_dir		s_dir;
+		struct sysfs_elem_symlink	s_symlink;
+		struct sysfs_elem_attr		s_attr;
+	};
+
+	void			*priv;
+
+	unsigned short		s_flags;
+	umode_t			s_mode;
+	unsigned int		s_ino;
+	struct sysfs_inode_attrs *s_iattr;
+};
+
+#define SD_DEACTIVATED_BIAS		INT_MIN
+
+#define SYSFS_TYPE_MASK			0x000f
+#define SYSFS_DIR			0x0001
+#define SYSFS_KOBJ_ATTR			0x0002
+#define SYSFS_KOBJ_LINK			0x0004
+#define SYSFS_COPY_NAME			(SYSFS_DIR | SYSFS_KOBJ_LINK)
+#define SYSFS_ACTIVE_REF		SYSFS_KOBJ_ATTR
+
+#define SYSFS_FLAG_MASK			~SYSFS_TYPE_MASK
+#define SYSFS_FLAG_REMOVED		0x0010
+#define SYSFS_FLAG_NS			0x0020
+#define SYSFS_FLAG_HAS_SEQ_SHOW		0x0040
+#define SYSFS_FLAG_HAS_MMAP		0x0080
+#define SYSFS_FLAG_LOCKDEP		0x0100
+
+static inline unsigned int sysfs_type(struct sysfs_dirent *sd)
+{
+	return sd->s_flags & SYSFS_TYPE_MASK;
+}
+
+/*
+ * Context structure to be used while adding/removing nodes.
+ */
+struct sysfs_addrm_cxt {
+	struct sysfs_dirent	*removed;
+};
+
+#include "../sysfs/sysfs.h"
+
+#endif	/* __KERNFS_INTERNAL_H */
