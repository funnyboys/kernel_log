commit 0aecba6173216931c436a03183f4759a4fd4c2f2
Merge: b0d4beaa5a4b 2fa6b1e01a9b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 6 09:06:58 2019 -0800

    Merge branch 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs d_inode/d_flags memory ordering fixes from Al Viro:
     "Fallout from tree-wide audit for ->d_inode/->d_flags barriers use.
      Basically, the problem is that negative pinned dentries require
      careful treatment - unless ->d_lock is locked or parent is held at
      least shared, another thread can make them positive right under us.
    
      Most of the uses turned out to be safe - the main surprises as far as
      filesystems are concerned were
    
       - race in dget_parent() fastpath, that might end up with the caller
         observing the returned dentry _negative_, due to insufficient
         barriers. It is positive in memory, but we could end up seeing the
         wrong value of ->d_inode in CPU cache. Fixed.
    
       - manual checks that result of lookup_one_len_unlocked() is positive
         (and rejection of negatives). Again, insufficient barriers (we
         might end up with inconsistent observed values of ->d_inode and
         ->d_flags). Fixed by switching to a new primitive that does the
         checks itself and returns ERR_PTR(-ENOENT) instead of a negative
         dentry. That way we get rid of boilerplate converting negatives
         into ERR_PTR(-ENOENT) in the callers and have a single place to
         deal with the barrier-related mess - inside fs/namei.c rather than
         in every caller out there.
    
      The guts of pathname resolution *do* need to be careful - the race
      found by Ritesh is real, as well as several similar races.
      Fortunately, it turns out that we can take care of that with fairly
      local changes in there.
    
      The tree-wide audit had not been fun, and I hate the idea of repeating
      it. I think the right approach would be to annotate the places where
      we are _not_ guaranteed ->d_inode/->d_flags stability and have sparse
      catch regressions. But I'm still not sure what would be the least
      invasive way of doing that and it's clearly the next cycle fodder"
    
    * 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs/namei.c: fix missing barriers when checking positivity
      fix dget_parent() fastpath race
      new helper: lookup_positive_unlocked()
      fs/namei.c: pull positivity check into follow_managed()

commit 6c2d4798a8d16cf4f3a28c3cd4af4f1dcbbb4d04
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 31 01:21:58 2019 -0400

    new helper: lookup_positive_unlocked()
    
    Most of the callers of lookup_one_len_unlocked() treat negatives are
    ERR_PTR(-ENOENT).  Provide a helper that would do just that.  Note
    that a pinned positive dentry remains positive - it's ->d_inode is
    stable, etc.; a pinned _negative_ dentry can become positive at any
    point as long as you are not holding its parent at least shared.
    So using lookup_one_len_unlocked() needs to be careful;
    lookup_positive_unlocked() is safer and that's what the callers
    end up open-coding anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 6c12fac2c287..d62cec6d838d 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -200,7 +200,7 @@ struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
 			dput(dentry);
 			return ERR_PTR(-EINVAL);
 		}
-		dtmp = lookup_one_len_unlocked(kntmp->name, dentry,
+		dtmp = lookup_positive_unlocked(kntmp->name, dentry,
 					       strlen(kntmp->name));
 		dput(dentry);
 		if (IS_ERR(dtmp))

commit 40430452fd5da1509177ac597b394614cd3a121f
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: use 64bit inos if ino_t is 64bit
    
    Each kernfs_node is identified with a 64bit ID.  The low 32bit is
    exposed as ino and the high gen.  While this already allows using inos
    as keys by looking up with wildcard generation number of 0, it's
    adding unnecessary complications for 64bit ino archs which can
    directly use kernfs_node IDs as inos to uniquely identify each cgroup
    instance.
    
    This patch exposes IDs directly as inos on 64bit ino archs.  The
    conversion is mostly straight-forward.
    
    * 32bit ino archs behave the same as before.  64bit ino archs now use
      the whole 64bit ID as ino and the generation number is fixed at 1.
    
    * 64bit inos still use the same idr allocator which gurantees that the
      lower 32bits identify the current live instance uniquely and the
      high 32bits are incremented whenever the low bits wrap.  As the
      upper 32bits are no longer used as gen and we don't wanna start ino
      allocation with 33rd bit set, the initial value for highbits
      allocation is changed to 0 on 64bit ino archs.
    
    * blktrace exposes two 32bit numbers - (INO,GEN) pair - to identify
      the issuing cgroup.  Userland builds FILEID_INO32_GEN fids from
      these numbers to look up the cgroups.  To remain compatible with the
      behavior, always output (LOW32,HIGH32) which will be constructed
      back to the original 64bit ID by __kernfs_fh_to_dentry().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 37a1e5df117a..4d31503abaee 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -87,9 +87,10 @@ static struct dentry *__kernfs_fh_to_dentry(struct super_block *sb,
 	case FILEID_INO32_GEN:
 	case FILEID_INO32_GEN_PARENT:
 		/*
-		 * blk_log_action() exposes (ino,gen) pair without type and
-		 * userland can call us with generic fid constructed from
-		 * them.  Combine it back to ID.  See blk_log_action().
+		 * blk_log_action() exposes "LOW32,HIGH32" pair without
+		 * type and userland can call us with generic fid
+		 * constructed from them.  Combine it back to ID.  See
+		 * blk_log_action().
 		 */
 		id = ((u64)fid->i32.gen << 32) | fid->i32.ino;
 		break;

commit 33c5ac9175195c36a0b7005aaf503a2e81f117a1
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: implement custom exportfs ops and fid type
    
    The current kernfs exportfs implementation uses the generic_fh_*()
    helpers and FILEID_INO32_GEN[_PARENT] which limits ino to 32bits.
    Let's implement custom exportfs operations and fid type to remove the
    restriction.
    
    * FILEID_KERNFS is a single u64 value whose content is
      kernfs_node->id.  This is the only native fid type.
    
    * For backward compatibility with blk_log_action() path which exposes
      (ino,gen) pairs which userland assembles into FILEID_INO32_GEN keys,
      combine the generic keys into 64bit IDs in the same order.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 8aed2cccd002..37a1e5df117a 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -53,40 +53,84 @@ const struct super_operations kernfs_sops = {
 	.show_path	= kernfs_sop_show_path,
 };
 
-static struct inode *kernfs_fh_get_inode(struct super_block *sb,
-		u64 ino, u32 generation)
+static int kernfs_encode_fh(struct inode *inode, __u32 *fh, int *max_len,
+			    struct inode *parent)
+{
+	struct kernfs_node *kn = inode->i_private;
+
+	if (*max_len < 2) {
+		*max_len = 2;
+		return FILEID_INVALID;
+	}
+
+	*max_len = 2;
+	*(u64 *)fh = kn->id;
+	return FILEID_KERNFS;
+}
+
+static struct dentry *__kernfs_fh_to_dentry(struct super_block *sb,
+					    struct fid *fid, int fh_len,
+					    int fh_type, bool get_parent)
 {
 	struct kernfs_super_info *info = kernfs_info(sb);
-	struct inode *inode;
 	struct kernfs_node *kn;
+	struct inode *inode;
+	u64 id;
 
-	if (ino == 0)
-		return ERR_PTR(-ESTALE);
+	if (fh_len < 2)
+		return NULL;
+
+	switch (fh_type) {
+	case FILEID_KERNFS:
+		id = *(u64 *)fid;
+		break;
+	case FILEID_INO32_GEN:
+	case FILEID_INO32_GEN_PARENT:
+		/*
+		 * blk_log_action() exposes (ino,gen) pair without type and
+		 * userland can call us with generic fid constructed from
+		 * them.  Combine it back to ID.  See blk_log_action().
+		 */
+		id = ((u64)fid->i32.gen << 32) | fid->i32.ino;
+		break;
+	default:
+		return NULL;
+	}
 
-	kn = kernfs_find_and_get_node_by_id(info->root,
-					    ino | ((u64)generation << 32));
+	kn = kernfs_find_and_get_node_by_id(info->root, id);
 	if (!kn)
 		return ERR_PTR(-ESTALE);
+
+	if (get_parent) {
+		struct kernfs_node *parent;
+
+		parent = kernfs_get_parent(kn);
+		kernfs_put(kn);
+		kn = parent;
+		if (!kn)
+			return ERR_PTR(-ESTALE);
+	}
+
 	inode = kernfs_get_inode(sb, kn);
 	kernfs_put(kn);
 	if (!inode)
 		return ERR_PTR(-ESTALE);
 
-	return inode;
+	return d_obtain_alias(inode);
 }
 
-static struct dentry *kernfs_fh_to_dentry(struct super_block *sb, struct fid *fid,
-		int fh_len, int fh_type)
+static struct dentry *kernfs_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
 {
-	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
-				    kernfs_fh_get_inode);
+	return __kernfs_fh_to_dentry(sb, fid, fh_len, fh_type, false);
 }
 
-static struct dentry *kernfs_fh_to_parent(struct super_block *sb, struct fid *fid,
-		int fh_len, int fh_type)
+static struct dentry *kernfs_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
 {
-	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
-				    kernfs_fh_get_inode);
+	return __kernfs_fh_to_dentry(sb, fid, fh_len, fh_type, true);
 }
 
 static struct dentry *kernfs_get_parent_dentry(struct dentry *child)
@@ -97,6 +141,7 @@ static struct dentry *kernfs_get_parent_dentry(struct dentry *child)
 }
 
 static const struct export_operations kernfs_export_ops = {
+	.encode_fh	= kernfs_encode_fh,
 	.fh_to_dentry	= kernfs_fh_to_dentry,
 	.fh_to_parent	= kernfs_fh_to_parent,
 	.get_parent	= kernfs_get_parent_dentry,

commit fe0f726c9fb626b1092a9ea3bf75f57f2eed676e
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: combine ino/id lookup functions into kernfs_find_and_get_node_by_id()
    
    kernfs_find_and_get_node_by_ino() looks the kernfs_node matching the
    specified ino.  On top of that, kernfs_get_node_by_id() and
    kernfs_fh_get_inode() implement full ID matching by testing the rest
    of ID.
    
    On surface, confusingly, the two are slightly different in that the
    latter uses 0 gen as wildcard while the former doesn't - does it mean
    that the latter can't uniquely identify inodes w/ 0 gen?  In practice,
    this is a distinction without a difference because generation number
    starts at 1.  There are no actual IDs with 0 gen, so it can always
    safely used as wildcard.
    
    Let's simplify the code by renaming kernfs_find_and_get_node_by_ino()
    to kernfs_find_and_get_node_by_id(), moving all lookup logics into it,
    and removing now unnecessary kernfs_get_node_by_id().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index f05d5d6f926d..8aed2cccd002 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -53,24 +53,6 @@ const struct super_operations kernfs_sops = {
 	.show_path	= kernfs_sop_show_path,
 };
 
-/*
- * Similar to kernfs_fh_get_inode, this one gets kernfs node from inode
- * number and generation
- */
-struct kernfs_node *kernfs_get_node_by_id(struct kernfs_root *root, u64 id)
-{
-	struct kernfs_node *kn;
-
-	kn = kernfs_find_and_get_node_by_ino(root, kernfs_id_ino(id));
-	if (!kn)
-		return NULL;
-	if (kernfs_gen(kn) != kernfs_id_gen(id)) {
-		kernfs_put(kn);
-		return NULL;
-	}
-	return kn;
-}
-
 static struct inode *kernfs_fh_get_inode(struct super_block *sb,
 		u64 ino, u32 generation)
 {
@@ -81,7 +63,8 @@ static struct inode *kernfs_fh_get_inode(struct super_block *sb,
 	if (ino == 0)
 		return ERR_PTR(-ESTALE);
 
-	kn = kernfs_find_and_get_node_by_ino(info->root, ino);
+	kn = kernfs_find_and_get_node_by_id(info->root,
+					    ino | ((u64)generation << 32));
 	if (!kn)
 		return ERR_PTR(-ESTALE);
 	inode = kernfs_get_inode(sb, kn);
@@ -89,11 +72,6 @@ static struct inode *kernfs_fh_get_inode(struct super_block *sb,
 	if (!inode)
 		return ERR_PTR(-ESTALE);
 
-	if (generation && inode->i_generation != generation) {
-		/* we didn't find the right inode.. */
-		iput(inode);
-		return ERR_PTR(-ESTALE);
-	}
 	return inode;
 }
 

commit 67c0496e87d193b8356d2af49ab95e8a1b954b3c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: convert kernfs_node->id from union kernfs_node_id to u64
    
    kernfs_node->id is currently a union kernfs_node_id which represents
    either a 32bit (ino, gen) pair or u64 value.  I can't see much value
    in the usage of the union - all that's needed is a 64bit ID which the
    current code is already limited to.  Using a union makes the code
    unnecessarily complicated and prevents using 64bit ino without adding
    practical benefits.
    
    This patch drops union kernfs_node_id and makes kernfs_node->id a u64.
    ino is stored in the lower 32bits and gen upper.  Accessors -
    kernfs[_id]_ino() and kernfs[_id]_gen() - are added to retrieve the
    ino and gen.  This simplifies ID handling less cumbersome and will
    allow using 64bit inos on supported archs.
    
    This patch doesn't make any functional changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Alexei Starovoitov <ast@kernel.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 067b7c380056..f05d5d6f926d 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -57,15 +57,14 @@ const struct super_operations kernfs_sops = {
  * Similar to kernfs_fh_get_inode, this one gets kernfs node from inode
  * number and generation
  */
-struct kernfs_node *kernfs_get_node_by_id(struct kernfs_root *root,
-	const union kernfs_node_id *id)
+struct kernfs_node *kernfs_get_node_by_id(struct kernfs_root *root, u64 id)
 {
 	struct kernfs_node *kn;
 
-	kn = kernfs_find_and_get_node_by_ino(root, id->ino);
+	kn = kernfs_find_and_get_node_by_ino(root, kernfs_id_ino(id));
 	if (!kn)
 		return NULL;
-	if (kn->id.generation != id->generation) {
+	if (kernfs_gen(kn) != kernfs_id_gen(id)) {
 		kernfs_put(kn);
 		return NULL;
 	}

commit b680b08171ebf890a4ebb7f82ada9959f4534ade
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:29 2019 -0800

    kernfs: use dumber locking for kernfs_find_and_get_node_by_ino()
    
    kernfs_find_and_get_node_by_ino() uses RCU protection.  It's currently
    a bit buggy because it can look up a node which hasn't been activated
    yet and thus may end up exposing a node that the kernfs user is still
    prepping.
    
    While it can be fixed by pushing it further in the current direction,
    it's already complicated and isn't clear whether the complexity is
    justified.  The main use of kernfs_find_and_get_node_by_ino() is for
    exportfs operations.  They aren't super hot and all the follow-up
    operations (e.g. mapping to path) use normal locking anyway.
    
    Let's switch to a dumber locking scheme and protect the lookup with
    kernfs_idr_lock.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 6c12fac2c287..067b7c380056 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -363,18 +363,9 @@ void kernfs_kill_sb(struct super_block *sb)
 
 void __init kernfs_init(void)
 {
-
-	/*
-	 * the slab is freed in RCU context, so kernfs_find_and_get_node_by_ino
-	 * can access the slab lock free. This could introduce stale nodes,
-	 * please see how kernfs_find_and_get_node_by_ino filters out stale
-	 * nodes.
-	 */
 	kernfs_node_cache = kmem_cache_create("kernfs_node_cache",
 					      sizeof(struct kernfs_node),
-					      0,
-					      SLAB_PANIC | SLAB_TYPESAFE_BY_RCU,
-					      NULL);
+					      0, SLAB_PANIC, NULL);
 
 	/* Creates slab cache for kernfs inode attributes */
 	kernfs_iattrs_cache  = kmem_cache_create("kernfs_iattrs_cache",

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 9a4646eecb71..6c12fac2c287 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * fs/kernfs/mount.c - kernfs mount implementation
  *
  * Copyright (c) 2001-3 Patrick Mochel
  * Copyright (c) 2007 SUSE Linux Products GmbH
  * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>
- *
- * This file is released under the GPLv2.
  */
 
 #include <linux/fs.h>

commit 7b47a9e7c8f672b6fb0b77fca11a63a8a77f5a91
Merge: dbc2fba3fc46 c99c2171fc61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 12 14:08:19 2019 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount infrastructure updates from Al Viro:
     "The rest of core infrastructure; no new syscalls in that pile, but the
      old parts are switched to new infrastructure. At that point
      conversions of individual filesystems can happen independently; some
      are done here (afs, cgroup, procfs, etc.), there's also a large series
      outside of that pile dealing with NFS (quite a bit of option-parsing
      stuff is getting used there - it's one of the most convoluted
      filesystems in terms of mount-related logics), but NFS bits are the
      next cycle fodder.
    
      It got seriously simplified since the last cycle; documentation is
      probably the weakest bit at the moment - I considered dropping the
      commit introducing Documentation/filesystems/mount_api.txt (cutting
      the size increase by quarter ;-), but decided that it would be better
      to fix it up after -rc1 instead.
    
      That pile allows to do followup work in independent branches, which
      should make life much easier for the next cycle. fs/super.c size
      increase is unpleasant; there's a followup series that allows to
      shrink it considerably, but I decided to leave that until the next
      cycle"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (41 commits)
      afs: Use fs_context to pass parameters over automount
      afs: Add fs_context support
      vfs: Add some logging to the core users of the fs_context log
      vfs: Implement logging through fs_context
      vfs: Provide documentation for new mount API
      vfs: Remove kern_mount_data()
      hugetlbfs: Convert to fs_context
      cpuset: Use fs_context
      kernfs, sysfs, cgroup, intel_rdt: Support fs_context
      cgroup: store a reference to cgroup_ns into cgroup_fs_context
      cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper
      cgroup_do_mount(): massage calling conventions
      cgroup: stash cgroup_root reference into cgroup_fs_context
      cgroup2: switch to option-by-option parsing
      cgroup1: switch to option-by-option parsing
      cgroup: take options parsing into ->parse_monolithic()
      cgroup: fold cgroup1_mount() into cgroup1_get_tree()
      cgroup: start switching to fs_context
      ipc: Convert mqueue fs to fs_context
      proc: Add fs_context support to procfs
      ...

commit e431f2d74e1b91e00e71e97cadcadffc4cda8a9b
Merge: 45763bf4bc1e 36cf3b1363f4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 6 14:52:48 2019 -0800

    Merge tag 'driver-core-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the big driver core patchset for 5.1-rc1
    
      More patches than "normal" here this merge window, due to some work in
      the driver core by Alexander Duyck to rework the async probe
      functionality to work better for a number of devices, and independant
      work from Rafael for the device link functionality to make it work
      "correctly".
    
      Also in here is:
    
       - lots of BUS_ATTR() removals, the macro is about to go away
    
       - firmware test fixups
    
       - ihex fixups and simplification
    
       - component additions (also includes i915 patches)
    
       - lots of minor coding style fixups and cleanups.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (65 commits)
      driver core: platform: remove misleading err_alloc label
      platform: set of_node in platform_device_register_full()
      firmware: hardcode the debug message for -ENOENT
      driver core: Add missing description of new struct device_link field
      driver core: Fix PM-runtime for links added during consumer probe
      drivers/component: kerneldoc polish
      async: Add cmdline option to specify drivers to be async probed
      driver core: Fix possible supplier PM-usage counter imbalance
      PM-runtime: Fix __pm_runtime_set_status() race with runtime resume
      driver: platform: Support parsing GpioInt 0 in platform_get_irq()
      selftests: firmware: fix verify_reqs() return value
      Revert "selftests: firmware: remove use of non-standard diff -Z option"
      Revert "selftests: firmware: add CONFIG_FW_LOADER_USER_HELPER_FALLBACK to config"
      device: Fix comment for driver_data in struct device
      kernfs: Allocating memory for kernfs_iattrs with kmem_cache.
      sysfs: remove unused include of kernfs-internal.h
      driver core: Postpone DMA tear-down until after devres release
      driver core: Document limitation related to DL_FLAG_RPM_ACTIVE
      PM-runtime: Take suppliers into account in __pm_runtime_set_status()
      device.h: Add __cold to dev_<level> logging functions
      ...

commit 23bf1b6be9c291a7130118dcc7384f72ac04d813
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:26 2018 +0000

    kernfs, sysfs, cgroup, intel_rdt: Support fs_context
    
    Make kernfs support superblock creation/mount/remount with fs_context.
    
    This requires that sysfs, cgroup and intel_rdt, which are built on kernfs,
    be made to support fs_context also.
    
    Notes:
    
     (1) A kernfs_fs_context struct is created to wrap fs_context and the
         kernfs mount parameters are moved in here (or are in fs_context).
    
     (2) kernfs_mount{,_ns}() are made into kernfs_get_tree().  The extra
         namespace tag parameter is passed in the context if desired
    
     (3) kernfs_free_fs_context() is provided as a destructor for the
         kernfs_fs_context struct, but for the moment it does nothing except
         get called in the right places.
    
     (4) sysfs doesn't wrap kernfs_fs_context since it has no parameters to
         pass, but possibly this should be done anyway in case someone wants to
         add a parameter in future.
    
     (5) A cgroup_fs_context struct is created to wrap kernfs_fs_context and
         the cgroup v1 and v2 mount parameters are all moved there.
    
     (6) cgroup1 parameter parsing error messages are now handled by invalf(),
         which allows userspace to collect them directly.
    
     (7) cgroup1 parameter cleanup is now done in the context destructor rather
         than in the mount/get_tree and remount functions.
    
    Weirdies:
    
     (*) cgroup_do_get_tree() calls cset_cgroup_from_root() with locks held,
         but then uses the resulting pointer after dropping the locks.  I'm
         told this is okay and needs commenting.
    
     (*) The cgroup refcount web.  This really needs documenting.
    
     (*) cgroup2 only has one root?
    
    Add a suggestion from Thomas Gleixner in which the RDT enablement code is
    placed into its own function.
    
    [folded a leak fix from Andrey Vagin]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Tejun Heo <tj@kernel.org>
    cc: Li Zefan <lizefan@huawei.com>
    cc: Johannes Weiner <hannes@cmpxchg.org>
    cc: cgroups@vger.kernel.org
    cc: fenghua.yu@intel.com
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 4d303047a4f8..36376cc5c9c2 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -22,16 +22,6 @@
 
 struct kmem_cache *kernfs_node_cache;
 
-static int kernfs_sop_remount_fs(struct super_block *sb, int *flags, char *data)
-{
-	struct kernfs_root *root = kernfs_info(sb)->root;
-	struct kernfs_syscall_ops *scops = root->syscall_ops;
-
-	if (scops && scops->remount_fs)
-		return scops->remount_fs(root, flags, data);
-	return 0;
-}
-
 static int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)
 {
 	struct kernfs_root *root = kernfs_root(kernfs_dentry_node(dentry));
@@ -60,7 +50,6 @@ const struct super_operations kernfs_sops = {
 	.drop_inode	= generic_delete_inode,
 	.evict_inode	= kernfs_evict_inode,
 
-	.remount_fs	= kernfs_sop_remount_fs,
 	.show_options	= kernfs_sop_show_options,
 	.show_path	= kernfs_sop_show_path,
 };
@@ -222,7 +211,7 @@ struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
 	} while (true);
 }
 
-static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
+static int kernfs_fill_super(struct super_block *sb, struct kernfs_fs_context *kfc)
 {
 	struct kernfs_super_info *info = kernfs_info(sb);
 	struct inode *inode;
@@ -233,7 +222,7 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 	sb->s_iflags |= SB_I_NOEXEC | SB_I_NODEV;
 	sb->s_blocksize = PAGE_SIZE;
 	sb->s_blocksize_bits = PAGE_SHIFT;
-	sb->s_magic = magic;
+	sb->s_magic = kfc->magic;
 	sb->s_op = &kernfs_sops;
 	sb->s_xattr = kernfs_xattr_handlers;
 	if (info->root->flags & KERNFS_ROOT_SUPPORT_EXPORTOP)
@@ -263,21 +252,20 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 	return 0;
 }
 
-static int kernfs_test_super(struct super_block *sb, void *data)
+static int kernfs_test_super(struct super_block *sb, struct fs_context *fc)
 {
 	struct kernfs_super_info *sb_info = kernfs_info(sb);
-	struct kernfs_super_info *info = data;
+	struct kernfs_super_info *info = fc->s_fs_info;
 
 	return sb_info->root == info->root && sb_info->ns == info->ns;
 }
 
-static int kernfs_set_super(struct super_block *sb, void *data)
+static int kernfs_set_super(struct super_block *sb, struct fs_context *fc)
 {
-	int error;
-	error = set_anon_super(sb, data);
-	if (!error)
-		sb->s_fs_info = data;
-	return error;
+	struct kernfs_fs_context *kfc = fc->fs_private;
+
+	kfc->ns_tag = NULL;
+	return set_anon_super_fc(sb, fc);
 }
 
 /**
@@ -294,63 +282,60 @@ const void *kernfs_super_ns(struct super_block *sb)
 }
 
 /**
- * kernfs_mount_ns - kernfs mount helper
- * @fs_type: file_system_type of the fs being mounted
- * @flags: mount flags specified for the mount
- * @root: kernfs_root of the hierarchy being mounted
- * @magic: file system specific magic number
- * @new_sb_created: tell the caller if we allocated a new superblock
- * @ns: optional namespace tag of the mount
+ * kernfs_get_tree - kernfs filesystem access/retrieval helper
+ * @fc: The filesystem context.
  *
- * This is to be called from each kernfs user's file_system_type->mount()
- * implementation, which should pass through the specified @fs_type and
- * @flags, and specify the hierarchy and namespace tag to mount via @root
- * and @ns, respectively.
- *
- * The return value can be passed to the vfs layer verbatim.
+ * This is to be called from each kernfs user's fs_context->ops->get_tree()
+ * implementation, which should set the specified ->@fs_type and ->@flags, and
+ * specify the hierarchy and namespace tag to mount via ->@root and ->@ns,
+ * respectively.
  */
-struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-				struct kernfs_root *root, unsigned long magic,
-				bool *new_sb_created, const void *ns)
+int kernfs_get_tree(struct fs_context *fc)
 {
+	struct kernfs_fs_context *kfc = fc->fs_private;
 	struct super_block *sb;
 	struct kernfs_super_info *info;
 	int error;
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info)
-		return ERR_PTR(-ENOMEM);
+		return -ENOMEM;
 
-	info->root = root;
-	info->ns = ns;
+	info->root = kfc->root;
+	info->ns = kfc->ns_tag;
 	INIT_LIST_HEAD(&info->node);
 
-	sb = sget_userns(fs_type, kernfs_test_super, kernfs_set_super, flags,
-			 &init_user_ns, info);
-	if (IS_ERR(sb) || sb->s_fs_info != info)
-		kfree(info);
+	fc->s_fs_info = info;
+	sb = sget_fc(fc, kernfs_test_super, kernfs_set_super);
 	if (IS_ERR(sb))
-		return ERR_CAST(sb);
-
-	if (new_sb_created)
-		*new_sb_created = !sb->s_root;
+		return PTR_ERR(sb);
 
 	if (!sb->s_root) {
 		struct kernfs_super_info *info = kernfs_info(sb);
 
-		error = kernfs_fill_super(sb, magic);
+		kfc->new_sb_created = true;
+
+		error = kernfs_fill_super(sb, kfc);
 		if (error) {
 			deactivate_locked_super(sb);
-			return ERR_PTR(error);
+			return error;
 		}
 		sb->s_flags |= SB_ACTIVE;
 
 		mutex_lock(&kernfs_mutex);
-		list_add(&info->node, &root->supers);
+		list_add(&info->node, &info->root->supers);
 		mutex_unlock(&kernfs_mutex);
 	}
 
-	return dget(sb->s_root);
+	fc->root = dget(sb->s_root);
+	return 0;
+}
+
+void kernfs_free_fs_context(struct fs_context *fc)
+{
+	/* Note that we don't deal with kfc->ns_tag here. */
+	kfree(fc->s_fs_info);
+	fc->s_fs_info = NULL;
 }
 
 /**

commit 26e28d68b146ec17ecc1b1833077bc712de19637
Author: Ayush Mittal <ayush.m@samsung.com>
Date:   Wed Feb 6 10:25:42 2019 +0530

    kernfs: Allocating memory for kernfs_iattrs with kmem_cache.
    
    Creating a new cache for kernfs_iattrs.
    Currently, memory is allocated with kzalloc() which
    always gives aligned memory. On ARM, this is 64 byte aligned.
    To avoid the wastage of memory in aligning the size requested,
    a new cache for kernfs_iattrs is created.
    
    Size of struct kernfs_iattrs is 80 Bytes.
    On ARM, it will come in kmalloc-128 slab.
    and it will come in kmalloc-192 slab if debug info is enabled.
    Extra bytes taken 48 bytes.
    
    Total number of objects created : 4096
    Total saving = 48*4096 = 192 KB
    
    After creating new slab(When debug info is enabled) :
    sh-3.2# cat /proc/slabinfo
    ...
    kernfs_iattrs_cache   4069   4096    128   32    1 : tunables    0    0    0 : slabdata    128    128      0
    ...
    
    All testing has been done on ARM target.
    
    Signed-off-by: Ayush Mittal <ayush.m@samsung.com>
    Signed-off-by: Vaneet Narang <v.narang@samsung.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index fdf527b6d79c..450eb388bae6 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -20,7 +20,7 @@
 
 #include "kernfs-internal.h"
 
-struct kmem_cache *kernfs_node_cache;
+struct kmem_cache *kernfs_node_cache, *kernfs_iattrs_cache;
 
 static int kernfs_sop_remount_fs(struct super_block *sb, int *flags, char *data)
 {
@@ -417,4 +417,9 @@ void __init kernfs_init(void)
 					      0,
 					      SLAB_PANIC | SLAB_TYPESAFE_BY_RCU,
 					      NULL);
+
+	/* Creates slab cache for kernfs inode attributes */
+	kernfs_iattrs_cache  = kmem_cache_create("kernfs_iattrs_cache",
+					      sizeof(struct kernfs_iattrs),
+					      0, SLAB_PANIC, NULL);
 }

commit 6d7fbce7da0cd06ff3f3f30e009a15a6243f0bc0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 17 12:02:57 2019 -0500

    kill kernfs_pin_sb()
    
    unused now and impossible to use safely anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index d71c9405874a..4d303047a4f8 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -377,36 +377,6 @@ void kernfs_kill_sb(struct super_block *sb)
 	kfree(info);
 }
 
-/**
- * kernfs_pin_sb: try to pin the superblock associated with a kernfs_root
- * @kernfs_root: the kernfs_root in question
- * @ns: the namespace tag
- *
- * Pin the superblock so the superblock won't be destroyed in subsequent
- * operations.  This can be used to block ->kill_sb() which may be useful
- * for kernfs users which dynamically manage superblocks.
- *
- * Returns NULL if there's no superblock associated to this kernfs_root, or
- * -EINVAL if the superblock is being freed.
- */
-struct super_block *kernfs_pin_sb(struct kernfs_root *root, const void *ns)
-{
-	struct kernfs_super_info *info;
-	struct super_block *sb = NULL;
-
-	mutex_lock(&kernfs_mutex);
-	list_for_each_entry(info, &root->supers, node) {
-		if (info->ns == ns) {
-			sb = info->sb;
-			if (!atomic_inc_not_zero(&info->sb->s_active))
-				sb = ERR_PTR(-EINVAL);
-			break;
-		}
-	}
-	mutex_unlock(&kernfs_mutex);
-	return sb;
-}
-
 void __init kernfs_init(void)
 {
 

commit 399504e21a10be16dd1408ba0147367d9d82a10c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jan 6 11:41:29 2019 -0500

    fix cgroup_do_mount() handling of failure exits
    
    same story as with last May fixes in sysfs (7b745a4e4051
    "unfuck sysfs_mount()"); new_sb is left uninitialized
    in case of early errors in kernfs_mount_ns() and papering
    over it by treating any error from kernfs_mount_ns() as
    equivalent to !new_ns ends up conflating the cases when
    objects had never been transferred to a superblock with
    ones when that has happened and resulting new superblock
    had been dropped.  Easily fixed (same way as in sysfs
    case).  Additionally, there's a superblock leak on
    kernfs_node_dentry() failure *and* a dentry leak inside
    kernfs_node_dentry() itself - the latter on probably
    impossible errors, but the former not impossible to trigger
    (as the matter of fact, injecting allocation failures
    at that point *does* trigger it).
    
    Cc: stable@kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index fdf527b6d79c..d71c9405874a 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -196,8 +196,10 @@ struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
 		return dentry;
 
 	knparent = find_next_ancestor(kn, NULL);
-	if (WARN_ON(!knparent))
+	if (WARN_ON(!knparent)) {
+		dput(dentry);
 		return ERR_PTR(-EINVAL);
+	}
 
 	do {
 		struct dentry *dtmp;
@@ -206,8 +208,10 @@ struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
 		if (kn == knparent)
 			return dentry;
 		kntmp = find_next_ancestor(kn, knparent);
-		if (WARN_ON(!kntmp))
+		if (WARN_ON(!kntmp)) {
+			dput(dentry);
 			return ERR_PTR(-EINVAL);
+		}
 		dtmp = lookup_one_len_unlocked(kntmp->name, dentry,
 					       strlen(kntmp->name));
 		dput(dentry);

commit 4b85afbdacd290c7a22c96df40a6433fdcacb509
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Fri Oct 26 15:06:42 2018 -0700

    mm: zero-seek shrinkers
    
    The page cache and most shrinkable slab caches hold data that has been
    read from disk, but there are some caches that only cache CPU work, such
    as the dentry and inode caches of procfs and sysfs, as well as the subset
    of radix tree nodes that track non-resident page cache.
    
    Currently, all these are shrunk at the same rate: using DEFAULT_SEEKS for
    the shrinker's seeks setting tells the reclaim algorithm that for every
    two page cache pages scanned it should scan one slab object.
    
    This is a bogus setting.  A virtual inode that required no IO to create is
    not twice as valuable as a page cache page; shadow cache entries with
    eviction distances beyond the size of memory aren't either.
    
    In most cases, the behavior in practice is still fine.  Such virtual
    caches don't tend to grow and assert themselves aggressively, and usually
    get picked up before they cause problems.  But there are scenarios where
    that's not true.
    
    Our database workloads suffer from two of those.  For one, their file
    workingset is several times bigger than available memory, which has the
    kernel aggressively create shadow page cache entries for the non-resident
    parts of it.  The workingset code does tell the VM that most of these are
    expendable, but the VM ends up balancing them 2:1 to cache pages as per
    the seeks setting.  This is a huge waste of memory.
    
    These workloads also deal with tens of thousands of open files and use
    /proc for introspection, which ends up growing the proc_inode_cache to
    absurdly large sizes - again at the cost of valuable cache space, which
    isn't a reasonable trade-off, given that proc inodes can be re-created
    without involving the disk.
    
    This patch implements a "zero-seek" setting for shrinkers that results in
    a target ratio of 0:1 between their objects and IO-backed caches.  This
    allows such virtual caches to grow when memory is available (they do
    cache/avoid CPU work after all), but effectively disables them as soon as
    IO-backed objects are under pressure.
    
    It then switches the shrinkers for procfs and sysfs metadata, as well as
    excess page cache shadow nodes, to the new zero-seek setting.
    
    Link: http://lkml.kernel.org/r/20181009184732.762-5-hannes@cmpxchg.org
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Reported-by: Domas Mituzas <dmituzas@fb.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Rik van Riel <riel@surriel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index ff2716f9322e..fdf527b6d79c 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -236,6 +236,9 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 		sb->s_export_op = &kernfs_export_ops;
 	sb->s_time_gran = 1;
 
+	/* sysfs dentries and inodes don't require IO to create */
+	sb->s_shrink.seeks = 0;
+
 	/* get root inode, initialize and unlock it */
 	mutex_lock(&kernfs_mutex);
 	inode = kernfs_get_inode(sb, info->root->kn);

commit 82382acec0c97b91830fff7130d0acce4ac4f3f3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 3 00:22:29 2018 -0400

    kernfs: deal with kernfs_fill_super() failures
    
    make sure that info->node is initialized early, so that kernfs_kill_sb()
    can list_del() it safely.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 26dd9a50f383..ff2716f9322e 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -316,6 +316,7 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 
 	info->root = root;
 	info->ns = ns;
+	INIT_LIST_HEAD(&info->node);
 
 	sb = sget_userns(fs_type, kernfs_test_super, kernfs_set_super, flags,
 			 &init_user_ns, info);

commit 1751e8a6cb935e555fcdbcb9ab4f0446e322ca3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 27 13:05:09 2017 -0800

    Rename superblock flags (MS_xyz -> SB_xyz)
    
    This is a pure automated search-and-replace of the internal kernel
    superblock flags.
    
    The s_flags are now called SB_*, with the names and the values for the
    moment mirroring the MS_* flags that they're equivalent to.
    
    Note how the MS_xyz flags are the ones passed to the mount system call,
    while the SB_xyz flags are what we then use in sb->s_flags.
    
    The script to do this was:
    
        # places to look in; re security/*: it generally should *not* be
        # touched (that stuff parses mount(2) arguments directly), but
        # there are two places where we really deal with superblock flags.
        FILES="drivers/mtd drivers/staging/lustre fs ipc mm \
                include/linux/fs.h include/uapi/linux/bfs_fs.h \
                security/apparmor/apparmorfs.c security/apparmor/include/lib.h"
        # the list of MS_... constants
        SYMS="RDONLY NOSUID NODEV NOEXEC SYNCHRONOUS REMOUNT MANDLOCK \
              DIRSYNC NOATIME NODIRATIME BIND MOVE REC VERBOSE SILENT \
              POSIXACL UNBINDABLE PRIVATE SLAVE SHARED RELATIME KERNMOUNT \
              I_VERSION STRICTATIME LAZYTIME SUBMOUNT NOREMOTELOCK NOSEC BORN \
              ACTIVE NOUSER"
    
        SED_PROG=
        for i in $SYMS; do SED_PROG="$SED_PROG -e s/MS_$i/SB_$i/g"; done
    
        # we want files that contain at least one of MS_...,
        # with fs/namespace.c and fs/pnode.c excluded.
        L=$(for i in $SYMS; do git grep -w -l MS_$i $FILES; done| sort|uniq|grep -v '^fs/namespace.c'|grep -v '^fs/pnode.c')
    
        for f in $L; do sed -i $f $SED_PROG; done
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 95a7c88baed9..26dd9a50f383 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -335,7 +335,7 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 			deactivate_locked_super(sb);
 			return ERR_PTR(error);
 		}
-		sb->s_flags |= MS_ACTIVE;
+		sb->s_flags |= SB_ACTIVE;
 
 		mutex_lock(&kernfs_mutex);
 		list_add(&info->node, &root->supers);

commit ef13ecbc134d7e0ca4ab4834d08bd20885b53c62
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Aug 30 17:04:56 2017 +0300

    kernfs: checking for IS_ERR() instead of NULL
    
    The kernfs_get_inode() returns NULL on error, it never returns error
    pointers.
    
    Fixes: aa8188253474 ("kernfs: add exportfs operations")
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 7c452f4d83e9..95a7c88baed9 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -99,8 +99,8 @@ static struct inode *kernfs_fh_get_inode(struct super_block *sb,
 		return ERR_PTR(-ESTALE);
 	inode = kernfs_get_inode(sb, kn);
 	kernfs_put(kn);
-	if (IS_ERR(inode))
-		return ERR_CAST(inode);
+	if (!inode)
+		return ERR_PTR(-ESTALE);
 
 	if (generation && inode->i_generation != generation) {
 		/* we didn't find the right inode.. */

commit 69fd5c391763bd94a40dd152bc72a7f230137150
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:55 2017 -0700

    blktrace: add an option to allow displaying cgroup path
    
    By default we output cgroup id in blktrace. This adds an option to
    display cgroup path. Since get cgroup path is a relativly heavy
    operation, we don't enable it by default.
    
    with the option enabled, blktrace will output something like this:
    dd-1353  [007] d..2   293.015252:   8,0   /test/level  D   R 24 + 8 [dd]
    
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index fa323589704f..7c452f4d83e9 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -65,6 +65,25 @@ const struct super_operations kernfs_sops = {
 	.show_path	= kernfs_sop_show_path,
 };
 
+/*
+ * Similar to kernfs_fh_get_inode, this one gets kernfs node from inode
+ * number and generation
+ */
+struct kernfs_node *kernfs_get_node_by_id(struct kernfs_root *root,
+	const union kernfs_node_id *id)
+{
+	struct kernfs_node *kn;
+
+	kn = kernfs_find_and_get_node_by_ino(root, id->ino);
+	if (!kn)
+		return NULL;
+	if (kn->id.generation != id->generation) {
+		kernfs_put(kn);
+		return NULL;
+	}
+	return kn;
+}
+
 static struct inode *kernfs_fh_get_inode(struct super_block *sb,
 		u64 ino, u32 generation)
 {

commit aa8188253474b4053bc2900d9fcb545ce68bdf5c
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:51 2017 -0700

    kernfs: add exportfs operations
    
    Now we have the facilities to implement exportfs operations. The idea is
    cgroup can export the fhandle info to userspace, then userspace uses
    fhandle to find the cgroup name. Another example is userspace can get
    fhandle for a cgroup and BPF uses the fhandle to filter info for the
    cgroup.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index acd542625fd8..fa323589704f 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -16,6 +16,7 @@
 #include <linux/pagemap.h>
 #include <linux/namei.h>
 #include <linux/seq_file.h>
+#include <linux/exportfs.h>
 
 #include "kernfs-internal.h"
 
@@ -64,6 +65,59 @@ const struct super_operations kernfs_sops = {
 	.show_path	= kernfs_sop_show_path,
 };
 
+static struct inode *kernfs_fh_get_inode(struct super_block *sb,
+		u64 ino, u32 generation)
+{
+	struct kernfs_super_info *info = kernfs_info(sb);
+	struct inode *inode;
+	struct kernfs_node *kn;
+
+	if (ino == 0)
+		return ERR_PTR(-ESTALE);
+
+	kn = kernfs_find_and_get_node_by_ino(info->root, ino);
+	if (!kn)
+		return ERR_PTR(-ESTALE);
+	inode = kernfs_get_inode(sb, kn);
+	kernfs_put(kn);
+	if (IS_ERR(inode))
+		return ERR_CAST(inode);
+
+	if (generation && inode->i_generation != generation) {
+		/* we didn't find the right inode.. */
+		iput(inode);
+		return ERR_PTR(-ESTALE);
+	}
+	return inode;
+}
+
+static struct dentry *kernfs_fh_to_dentry(struct super_block *sb, struct fid *fid,
+		int fh_len, int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    kernfs_fh_get_inode);
+}
+
+static struct dentry *kernfs_fh_to_parent(struct super_block *sb, struct fid *fid,
+		int fh_len, int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    kernfs_fh_get_inode);
+}
+
+static struct dentry *kernfs_get_parent_dentry(struct dentry *child)
+{
+	struct kernfs_node *kn = kernfs_dentry_node(child);
+
+	return d_obtain_alias(kernfs_get_inode(child->d_sb, kn->parent));
+}
+
+static const struct export_operations kernfs_export_ops = {
+	.fh_to_dentry	= kernfs_fh_to_dentry,
+	.fh_to_parent	= kernfs_fh_to_parent,
+	.get_parent	= kernfs_get_parent_dentry,
+};
+
 /**
  * kernfs_root_from_sb - determine kernfs_root associated with a super_block
  * @sb: the super_block in question
@@ -159,6 +213,8 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 	sb->s_magic = magic;
 	sb->s_op = &kernfs_sops;
 	sb->s_xattr = kernfs_xattr_handlers;
+	if (info->root->flags & KERNFS_ROOT_SUPPORT_EXPORTOP)
+		sb->s_export_op = &kernfs_export_ops;
 	sb->s_time_gran = 1;
 
 	/* get root inode, initialize and unlock it */

commit 319ba91d352a74acb47678788109a14b9b4dd4c2
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:49 2017 -0700

    kernfs: don't set dentry->d_fsdata
    
    When working on adding exportfs operations in kernfs, I found it's hard
    to initialize dentry->d_fsdata in the exportfs operations. Looks there
    is no way to do it without race condition. Look at the kernfs code
    closely, there is no point to set dentry->d_fsdata. inode->i_private
    already points to kernfs_node, and we can get inode from a dentry. So
    this patch just delete the d_fsdata usage.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 69c48bec8a63..acd542625fd8 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -33,7 +33,7 @@ static int kernfs_sop_remount_fs(struct super_block *sb, int *flags, char *data)
 
 static int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)
 {
-	struct kernfs_root *root = kernfs_root(dentry->d_fsdata);
+	struct kernfs_root *root = kernfs_root(kernfs_dentry_node(dentry));
 	struct kernfs_syscall_ops *scops = root->syscall_ops;
 
 	if (scops && scops->show_options)
@@ -43,7 +43,7 @@ static int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)
 
 static int kernfs_sop_show_path(struct seq_file *sf, struct dentry *dentry)
 {
-	struct kernfs_node *node = dentry->d_fsdata;
+	struct kernfs_node *node = kernfs_dentry_node(dentry);
 	struct kernfs_root *root = kernfs_root(node);
 	struct kernfs_syscall_ops *scops = root->syscall_ops;
 
@@ -176,8 +176,6 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 		pr_debug("%s: could not get root dentry!\n", __func__);
 		return -ENOMEM;
 	}
-	kernfs_get(info->root->kn);
-	root->d_fsdata = info->root->kn;
 	sb->s_root = root;
 	sb->s_d_op = &kernfs_dops;
 	return 0;
@@ -283,7 +281,6 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 void kernfs_kill_sb(struct super_block *sb)
 {
 	struct kernfs_super_info *info = kernfs_info(sb);
-	struct kernfs_node *root_kn = sb->s_root->d_fsdata;
 
 	mutex_lock(&kernfs_mutex);
 	list_del(&info->node);
@@ -295,7 +292,6 @@ void kernfs_kill_sb(struct super_block *sb)
 	 */
 	kill_anon_super(sb);
 	kfree(info);
-	kernfs_put(root_kn);
 }
 
 /**

commit ba16b2846a8c6965d0d35be3968bc10f6277812d
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:48 2017 -0700

    kernfs: add an API to get kernfs node from inode number
    
    Add an API to get kernfs node from inode number. We will need this to
    implement exportfs operations.
    
    This API will be used in blktrace too later, so it should be as fast as
    possible. To make the API lock free, kernfs node is freed in RCU
    context. And we depend on kernfs_node count/ino number to filter out
    stale kernfs nodes.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index d5b149a45be1..69c48bec8a63 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -330,7 +330,16 @@ struct super_block *kernfs_pin_sb(struct kernfs_root *root, const void *ns)
 
 void __init kernfs_init(void)
 {
+
+	/*
+	 * the slab is freed in RCU context, so kernfs_find_and_get_node_by_ino
+	 * can access the slab lock free. This could introduce stale nodes,
+	 * please see how kernfs_find_and_get_node_by_ino filters out stale
+	 * nodes.
+	 */
 	kernfs_node_cache = kmem_cache_create("kernfs_node_cache",
 					      sizeof(struct kernfs_node),
-					      0, SLAB_PANIC, NULL);
+					      0,
+					      SLAB_PANIC | SLAB_TYPESAFE_BY_RCU,
+					      NULL);
 }

commit e72a1a8b3a5a2a0c034f9ad07ca34638fc3b0c33
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Sep 29 17:48:33 2016 +0200

    kernfs: Switch to generic xattr handlers
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index b3d73ad52b22..d5b149a45be1 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -158,6 +158,7 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 	sb->s_blocksize_bits = PAGE_SHIFT;
 	sb->s_magic = magic;
 	sb->s_op = &kernfs_sops;
+	sb->s_xattr = kernfs_xattr_handlers;
 	sb->s_time_gran = 1;
 
 	/* get root inode, initialize and unlock it */

commit a2982cc922c3068783eb9a1f77a5626a1ec36a1f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jun 9 15:34:02 2016 -0500

    vfs: Generalize filesystem nodev handling.
    
    Introduce a function may_open_dev that tests MNT_NODEV and a new
    superblock flab SB_I_NODEV.  Use this new function in all of the
    places where MNT_NODEV was previously tested.
    
    Add the new SB_I_NODEV s_iflag to proc, sysfs, and mqueuefs as those
    filesystems should never support device nodes, and a simple superblock
    flags makes that very hard to get wrong.  With SB_I_NODEV set if any
    device nodes somehow manage to show up on on a filesystem those
    device nodes will be unopenable.
    
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 1443df670260..b3d73ad52b22 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -152,8 +152,8 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 	struct dentry *root;
 
 	info->sb = sb;
-	/* Userspace would break if executables appear on sysfs */
-	sb->s_iflags |= SB_I_NOEXEC;
+	/* Userspace would break if executables or devices appear on sysfs */
+	sb->s_iflags |= SB_I_NOEXEC | SB_I_NODEV;
 	sb->s_blocksize = PAGE_SIZE;
 	sb->s_blocksize_bits = PAGE_SHIFT;
 	sb->s_magic = magic;

commit 29a517c232d21a717aecea29838aeb07131f6196
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Jun 10 13:03:05 2016 -0500

    kernfs: The cgroup filesystem also benefits from SB_I_NOEXEC
    
    The cgroup filesystem is in the same boat as sysfs.  No one ever
    permits executables of any kind on the cgroup filesystem, and there is
    no reasonable future case to support executables in the future.
    
    Therefore move the setting of SB_I_NOEXEC which makes the code proof
    against future mistakes of accidentally creating executables from
    sysfs to kernfs itself.  Making the code simpler and covering the
    sysfs, cgroup, and cgroup2 filesystems.
    
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index d90d574c15a2..1443df670260 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -152,6 +152,8 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 	struct dentry *root;
 
 	info->sb = sb;
+	/* Userspace would break if executables appear on sysfs */
+	sb->s_iflags |= SB_I_NOEXEC;
 	sb->s_blocksize = PAGE_SIZE;
 	sb->s_blocksize_bits = PAGE_SHIFT;
 	sb->s_magic = magic;

commit 6e4eab577a0cae15b3da9b888cff16fe57981b3e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue May 24 09:29:01 2016 -0500

    fs: Add user namespace member to struct super_block
    
    Start marking filesystems with a user namespace owner, s_user_ns.  In
    this change this is only used for permission checks of who may mount a
    filesystem.  Ultimately s_user_ns will be used for translating ids and
    checking capabilities for filesystems mounted from user namespaces.
    
    The default policy for setting s_user_ns is implemented in sget(),
    which arranges for s_user_ns to be set to current_user_ns() and to
    ensure that the mounter of the filesystem has CAP_SYS_ADMIN in that
    user_ns.
    
    The guts of sget are split out into another function sget_userns().
    The function sget_userns calls alloc_super with the specified user
    namespace or it verifies the existing superblock that was found
    has the expected user namespace, and fails with EBUSY when it is not.
    This failing prevents users with the wrong privileges mounting a
    filesystem.
    
    The reason for the split of sget_userns from sget is that in some
    cases such as mount_ns and kernfs_mount_ns a different policy for
    permission checking of mounts and setting s_user_ns is necessary, and
    the existence of sget_userns() allows those policies to be
    implemented.
    
    The helper mount_ns is expected to be used for filesystems such as
    proc and mqueuefs which present per namespace information.  The
    function mount_ns is modified to call sget_userns instead of sget to
    ensure the user namespace owner of the namespace whose information is
    presented by the filesystem is used on the superblock.
    
    For sysfs and cgroup the appropriate permission checks are already in
    place, and kernfs_mount_ns is modified to call sget_userns so that
    the init_user_ns is the only user namespace used.
    
    For the cgroup filesystem cgroup namespace mounts are bind mounts of a
    subset of the full cgroup filesystem and as such s_user_ns must be the
    same for all of them as there is only a single superblock.
    
    Mounts of sysfs that vary based on the network namespace could in principle
    change s_user_ns but it keeps the analysis and implementation of kernfs
    simpler if that is not supported, and at present there appear to be no
    benefits from supporting a different s_user_ns on any sysfs mount.
    
    Getting the details of setting s_user_ns correct has been
    a long process.  Thanks to Pavel Tikhorirorv who spotted a leak
    in sget_userns.  Thanks to Seth Forshee who has kept the work alive.
    
    Thanks-to: Seth Forshee <seth.forshee@canonical.com>
    Thanks-to: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 63534f5f9073..d90d574c15a2 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -241,7 +241,8 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 	info->root = root;
 	info->ns = ns;
 
-	sb = sget(fs_type, kernfs_test_super, kernfs_set_super, flags, info);
+	sb = sget_userns(fs_type, kernfs_test_super, kernfs_set_super, flags,
+			 &init_user_ns, info);
 	if (IS_ERR(sb) || sb->s_fs_info != info)
 		kfree(info);
 	if (IS_ERR(sb))

commit 7f427d3a6029331304f91ef4d7cf646f054216d2
Merge: ede40902cf80 0e0162bb8c00
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 17 11:01:31 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull parallel filesystem directory handling update from Al Viro.
    
    This is the main parallel directory work by Al that makes the vfs layer
    able to do lookup and readdir in parallel within a single directory.
    That's a big change, since this used to be all protected by the
    directory inode mutex.
    
    The inode mutex is replaced by an rwsem, and serialization of lookups of
    a single name is done by a "in-progress" dentry marker.
    
    The series begins with xattr cleanups, and then ends with switching
    filesystems over to actually doing the readdir in parallel (switching to
    the "iterate_shared()" that only takes the read lock).
    
    A more detailed explanation of the process from Al Viro:
     "The xattr work starts with some acl fixes, then switches ->getxattr to
      passing inode and dentry separately.  This is the point where the
      things start to get tricky - that got merged into the very beginning
      of the -rc3-based #work.lookups, to allow untangling the
      security_d_instantiate() mess.  The xattr work itself proceeds to
      switch a lot of filesystems to generic_...xattr(); no complications
      there.
    
      After that initial xattr work, the series then does the following:
    
       - untangle security_d_instantiate()
    
       - convert a bunch of open-coded lookup_one_len_unlocked() to calls of
         that thing; one such place (in overlayfs) actually yields a trivial
         conflict with overlayfs fixes later in the cycle - overlayfs ended
         up switching to a variant of lookup_one_len_unlocked() sans the
         permission checks.  I would've dropped that commit (it gets
         overridden on merge from #ovl-fixes in #for-next; proper resolution
         is to use the variant in mainline fs/overlayfs/super.c), but I
         didn't want to rebase the damn thing - it was fairly late in the
         cycle...
    
       - some filesystems had managed to depend on lookup/lookup exclusion
         for *fs-internal* data structures in a way that would break if we
         relaxed the VFS exclusion.  Fixing hadn't been hard, fortunately.
    
       - core of that series - parallel lookup machinery, replacing
         ->i_mutex with rwsem, making lookup_slow() take it only shared.  At
         that point lookups happen in parallel; lookups on the same name
         wait for the in-progress one to be done with that dentry.
    
         Surprisingly little code, at that - almost all of it is in
         fs/dcache.c, with fs/namei.c changes limited to lookup_slow() -
         making it use the new primitive and actually switching to locking
         shared.
    
       - parallel readdir stuff - first of all, we provide the exclusion on
         per-struct file basis, same as we do for read() vs lseek() for
         regular files.  That takes care of most of the needed exclusion in
         readdir/readdir; however, these guys are trickier than lookups, so
         I went for switching them one-by-one.  To do that, a new method
         '->iterate_shared()' is added and filesystems are switched to it
         as they are either confirmed to be OK with shared lock on directory
         or fixed to be OK with that.  I hope to kill the original method
         come next cycle (almost all in-tree filesystems are switched
         already), but it's still not quite finished.
    
       - several filesystems get switched to parallel readdir.  The
         interesting part here is dealing with dcache preseeding by readdir;
         that needs minor adjustment to be safe with directory locked only
         shared.
    
         Most of the filesystems doing that got switched to in those
         commits.  Important exception: NFS.  Turns out that NFS folks, with
         their, er, insistence on VFS getting the fuck out of the way of the
         Smart Filesystem Code That Knows How And What To Lock(tm) have
         grown the locking of their own.  They had their own homegrown
         rwsem, with lookup/readdir/atomic_open being *writers* (sillyunlink
         is the reader there).  Of course, with VFS getting the fuck out of
         the way, as requested, the actual smarts of the smart filesystem
         code etc. had become exposed...
    
       - do_last/lookup_open/atomic_open cleanups.  As the result, open()
         without O_CREAT locks the directory only shared.  Including the
         ->atomic_open() case.  Backmerge from #for-linus in the middle of
         that - atomic_open() fix got brought in.
    
       - then comes NFS switch to saner (VFS-based ;-) locking, killing the
         homegrown "lookup and readdir are writers" kinda-sorta rwsem.  All
         exclusion for sillyunlink/lookup is done by the parallel lookups
         mechanism.  Exclusion between sillyunlink and rmdir is a real rwsem
         now - rmdir being the writer.
    
         Result: NFS lookups/readdirs/O_CREAT-less opens happen in parallel
         now.
    
       - the rest of the series consists of switching a lot of filesystems
         to parallel readdir; in a lot of cases ->llseek() gets simplified
         as well.  One backmerge in there (again, #for-linus - rockridge
         fix)"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (74 commits)
      ext4: switch to ->iterate_shared()
      hfs: switch to ->iterate_shared()
      hfsplus: switch to ->iterate_shared()
      hostfs: switch to ->iterate_shared()
      hpfs: switch to ->iterate_shared()
      hpfs: handle allocation failures in hpfs_add_pos()
      gfs2: switch to ->iterate_shared()
      f2fs: switch to ->iterate_shared()
      afs: switch to ->iterate_shared()
      befs: switch to ->iterate_shared()
      befs: constify stuff a bit
      isofs: switch to ->iterate_shared()
      get_acorn_filename(): deobfuscate a bit
      btrfs: switch to ->iterate_shared()
      logfs: no need to lock directory in lseek
      switch ecryptfs to ->iterate_shared
      9p: switch to ->iterate_shared()
      fat: switch to ->iterate_shared()
      romfs, squashfs: switch to ->iterate_shared()
      more trivial ->iterate_shared conversions
      ...

commit 3cc9b23c8137e9bb4eaf6d97d825b7f0dc711d0c
Author: Serge E. Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu May 12 00:29:45 2016 -0500

    kernfs: kernfs_sop_show_path: don't return 0 after seq_dentry call
    
    Our caller expects 0 on success, not >0.
    
    This fixes a bug in the patch
    
            cgroup, kernfs: make mountinfo show properly scoped path for cgroup namespaces
    
    where /sys does not show up in mountinfo, breaking criu.
    
    Thanks for catching this, Andrei.
    
    Reported-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 3b78724c1979..3d670a3678f2 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -50,7 +50,8 @@ static int kernfs_sop_show_path(struct seq_file *sf, struct dentry *dentry)
 	if (scops && scops->show_path)
 		return scops->show_path(sf, node, root);
 
-	return seq_dentry(sf, dentry, " \t\n\\");
+	seq_dentry(sf, dentry, " \t\n\\");
+	return 0;
 }
 
 const struct super_operations kernfs_sops = {

commit 4f41fc59620fcedaa97cbdf3d7d2956d80fcd922
Author: Serge E. Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon May 9 09:59:55 2016 -0500

    cgroup, kernfs: make mountinfo show properly scoped path for cgroup namespaces
    
    Patch summary:
    
    When showing a cgroupfs entry in mountinfo, show the path of the mount
    root dentry relative to the reader's cgroup namespace root.
    
    Short explanation (courtesy of mkerrisk):
    
    If we create a new cgroup namespace, then we want both /proc/self/cgroup
    and /proc/self/mountinfo to show cgroup paths that are correctly
    virtualized with respect to the cgroup mount point.  Previous to this
    patch, /proc/self/cgroup shows the right info, but /proc/self/mountinfo
    does not.
    
    Long version:
    
    When a uid 0 task which is in freezer cgroup /a/b, unshares a new cgroup
    namespace, and then mounts a new instance of the freezer cgroup, the new
    mount will be rooted at /a/b.  The root dentry field of the mountinfo
    entry will show '/a/b'.
    
     cat > /tmp/do1 << EOF
     mount -t cgroup -o freezer freezer /mnt
     grep freezer /proc/self/mountinfo
     EOF
    
     unshare -Gm  bash /tmp/do1
     > 330 160 0:34 / /sys/fs/cgroup/freezer rw,nosuid,nodev,noexec,relatime - cgroup cgroup rw,freezer
     > 355 133 0:34 /a/b /mnt rw,relatime - cgroup freezer rw,freezer
    
    The task's freezer cgroup entry in /proc/self/cgroup will simply show
    '/':
    
     grep freezer /proc/self/cgroup
     9:freezer:/
    
    If instead the same task simply bind mounts the /a/b cgroup directory,
    the resulting mountinfo entry will again show /a/b for the dentry root.
    However in this case the task will find its own cgroup at /mnt/a/b,
    not at /mnt:
    
     mount --bind /sys/fs/cgroup/freezer/a/b /mnt
     130 25 0:34 /a/b /mnt rw,nosuid,nodev,noexec,relatime shared:21 - cgroup cgroup rw,freezer
    
    In other words, there is no way for the task to know, based on what is
    in mountinfo, which cgroup directory is its own.
    
    Example (by mkerrisk):
    
    First, a little script to save some typing and verbiage:
    
    echo -e "\t/proc/self/cgroup:\t$(cat /proc/self/cgroup | grep freezer)"
    cat /proc/self/mountinfo | grep freezer |
            awk '{print "\tmountinfo:\t\t" $4 "\t" $5}'
    
    Create cgroup, place this shell into the cgroup, and look at the state
    of the /proc files:
    
    2653
    2653                         # Our shell
    14254                        # cat(1)
            /proc/self/cgroup:      10:freezer:/a/b
            mountinfo:              /       /sys/fs/cgroup/freezer
    
    Create a shell in new cgroup and mount namespaces. The act of creating
    a new cgroup namespace causes the process's current cgroups directories
    to become its cgroup root directories. (Here, I'm using my own version
    of the "unshare" utility, which takes the same options as the util-linux
    version):
    
    Look at the state of the /proc files:
    
            /proc/self/cgroup:      10:freezer:/
            mountinfo:              /       /sys/fs/cgroup/freezer
    
    The third entry in /proc/self/cgroup (the pathname of the cgroup inside
    the hierarchy) is correctly virtualized w.r.t. the cgroup namespace, which
    is rooted at /a/b in the outer namespace.
    
    However, the info in /proc/self/mountinfo is not for this cgroup
    namespace, since we are seeing a duplicate of the mount from the
    old mount namespace, and the info there does not correspond to the
    new cgroup namespace. However, trying to create a new mount still
    doesn't show us the right information in mountinfo:
    
                                          # propagating to other mountns
            /proc/self/cgroup:      7:freezer:/
            mountinfo:              /a/b    /mnt/freezer
    
    The act of creating a new cgroup namespace caused the process's
    current freezer directory, "/a/b", to become its cgroup freezer root
    directory. In other words, the pathname directory of the directory
    within the newly mounted cgroup filesystem should be "/",
    but mountinfo wrongly shows us "/a/b". The consequence of this is
    that the process in the cgroup namespace cannot correctly construct
    the pathname of its cgroup root directory from the information in
    /proc/PID/mountinfo.
    
    With this patch, the dentry root field in mountinfo is shown relative
    to the reader's cgroup namespace.  So the same steps as above:
    
            /proc/self/cgroup:      10:freezer:/a/b
            mountinfo:              /       /sys/fs/cgroup/freezer
            /proc/self/cgroup:      10:freezer:/
            mountinfo:              /../..  /sys/fs/cgroup/freezer
            /proc/self/cgroup:      10:freezer:/
            mountinfo:              /       /mnt/freezer
    
    cgroup.clone_children  freezer.parent_freezing  freezer.state      tasks
    cgroup.procs           freezer.self_freezing    notify_on_release
    3164
    2653                   # First shell that placed in this cgroup
    3164                   # Shell started by 'unshare'
    14197                  # cat(1)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Tested-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index f73541fbe7af..3b78724c1979 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/pagemap.h>
 #include <linux/namei.h>
+#include <linux/seq_file.h>
 
 #include "kernfs-internal.h"
 
@@ -40,6 +41,18 @@ static int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)
 	return 0;
 }
 
+static int kernfs_sop_show_path(struct seq_file *sf, struct dentry *dentry)
+{
+	struct kernfs_node *node = dentry->d_fsdata;
+	struct kernfs_root *root = kernfs_root(node);
+	struct kernfs_syscall_ops *scops = root->syscall_ops;
+
+	if (scops && scops->show_path)
+		return scops->show_path(sf, node, root);
+
+	return seq_dentry(sf, dentry, " \t\n\\");
+}
+
 const struct super_operations kernfs_sops = {
 	.statfs		= simple_statfs,
 	.drop_inode	= generic_delete_inode,
@@ -47,6 +60,7 @@ const struct super_operations kernfs_sops = {
 
 	.remount_fs	= kernfs_sop_remount_fs,
 	.show_options	= kernfs_sop_show_options,
+	.show_path	= kernfs_sop_show_path,
 };
 
 /**

commit 779b839133d7ab23229be7e601cabab7678ceab1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 11 08:42:55 2016 -0400

    kernfs: use lookup_one_len_unlocked()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index f73541fbe7af..b5b5f079a7f7 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -120,9 +120,8 @@ struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
 		kntmp = find_next_ancestor(kn, knparent);
 		if (WARN_ON(!kntmp))
 			return ERR_PTR(-EINVAL);
-		mutex_lock(&d_inode(dentry)->i_mutex);
-		dtmp = lookup_one_len(kntmp->name, dentry, strlen(kntmp->name));
-		mutex_unlock(&d_inode(dentry)->i_mutex);
+		dtmp = lookup_one_len_unlocked(kntmp->name, dentry,
+					       strlen(kntmp->name));
 		dput(dentry);
 		if (IS_ERR(dtmp))
 			return dtmp;

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index b67dbccdaf88..f73541fbe7af 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -138,8 +138,8 @@ static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 	struct dentry *root;
 
 	info->sb = sb;
-	sb->s_blocksize = PAGE_CACHE_SIZE;
-	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_blocksize = PAGE_SIZE;
+	sb->s_blocksize_bits = PAGE_SHIFT;
 	sb->s_magic = magic;
 	sb->s_op = &kernfs_sops;
 	sb->s_time_gran = 1;

commit fb3c8315650f89a1993fb3ae3e74e9c7e4a1c9c0
Author: Aditya Kali <adityakali@google.com>
Date:   Fri Jan 29 02:54:08 2016 -0600

    kernfs: define kernfs_node_dentry
    
    Add a new kernfs api is added to lookup the dentry for a particular
    kernfs path.
    
    Signed-off-by: Aditya Kali <adityakali@google.com>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 8eaf417187f1..b67dbccdaf88 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -14,6 +14,7 @@
 #include <linux/magic.h>
 #include <linux/slab.h>
 #include <linux/pagemap.h>
+#include <linux/namei.h>
 
 #include "kernfs-internal.h"
 
@@ -62,6 +63,74 @@ struct kernfs_root *kernfs_root_from_sb(struct super_block *sb)
 	return NULL;
 }
 
+/*
+ * find the next ancestor in the path down to @child, where @parent was the
+ * ancestor whose descendant we want to find.
+ *
+ * Say the path is /a/b/c/d.  @child is d, @parent is NULL.  We return the root
+ * node.  If @parent is b, then we return the node for c.
+ * Passing in d as @parent is not ok.
+ */
+static struct kernfs_node *find_next_ancestor(struct kernfs_node *child,
+					      struct kernfs_node *parent)
+{
+	if (child == parent) {
+		pr_crit_once("BUG in find_next_ancestor: called with parent == child");
+		return NULL;
+	}
+
+	while (child->parent != parent) {
+		if (!child->parent)
+			return NULL;
+		child = child->parent;
+	}
+
+	return child;
+}
+
+/**
+ * kernfs_node_dentry - get a dentry for the given kernfs_node
+ * @kn: kernfs_node for which a dentry is needed
+ * @sb: the kernfs super_block
+ */
+struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
+				  struct super_block *sb)
+{
+	struct dentry *dentry;
+	struct kernfs_node *knparent = NULL;
+
+	BUG_ON(sb->s_op != &kernfs_sops);
+
+	dentry = dget(sb->s_root);
+
+	/* Check if this is the root kernfs_node */
+	if (!kn->parent)
+		return dentry;
+
+	knparent = find_next_ancestor(kn, NULL);
+	if (WARN_ON(!knparent))
+		return ERR_PTR(-EINVAL);
+
+	do {
+		struct dentry *dtmp;
+		struct kernfs_node *kntmp;
+
+		if (kn == knparent)
+			return dentry;
+		kntmp = find_next_ancestor(kn, knparent);
+		if (WARN_ON(!kntmp))
+			return ERR_PTR(-EINVAL);
+		mutex_lock(&d_inode(dentry)->i_mutex);
+		dtmp = lookup_one_len(kntmp->name, dentry, strlen(kntmp->name));
+		mutex_unlock(&d_inode(dentry)->i_mutex);
+		dput(dentry);
+		if (IS_ERR(dtmp))
+			return dtmp;
+		knparent = kntmp;
+		dentry = dtmp;
+	} while (true);
+}
+
 static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 {
 	struct kernfs_super_info *info = kernfs_info(sb);

commit a7a2c680a2ad81b3181a335ee76e23d5195007ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 14 10:42:30 2015 +0100

    fs: deduplicate noop_backing_dev_info
    
    hugetlbfs, kernfs and dlmfs can simply use noop_backing_dev_info instead
    of creating a local duplicate.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index f973ae9b05f1..8eaf417187f1 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -246,5 +246,4 @@ void __init kernfs_init(void)
 	kernfs_node_cache = kmem_cache_create("kernfs_node_cache",
 					      sizeof(struct kernfs_node),
 					      0, SLAB_PANIC, NULL);
-	kernfs_inode_init();
 }

commit 4e26445faad366d67d7723622bf6a60a6f0f5993
Author: Li Zefan <lizefan@huawei.com>
Date:   Mon Jun 30 11:50:28 2014 +0800

    kernfs: introduce kernfs_pin_sb()
    
    kernfs_pin_sb() tries to get a refcnt of the superblock.
    
    This will be used by cgroupfs.
    
    v2:
    - make kernfs_pin_sb() return the superblock.
    - drop kernfs_drop_sb().
    
    tj: Updated the comment a bit.
    
    [ This is a prerequisite for a bugfix. ]
    Cc: <stable@vger.kernel.org> # 3.15
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index d171b98a6cdd..f973ae9b05f1 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -211,6 +211,36 @@ void kernfs_kill_sb(struct super_block *sb)
 	kernfs_put(root_kn);
 }
 
+/**
+ * kernfs_pin_sb: try to pin the superblock associated with a kernfs_root
+ * @kernfs_root: the kernfs_root in question
+ * @ns: the namespace tag
+ *
+ * Pin the superblock so the superblock won't be destroyed in subsequent
+ * operations.  This can be used to block ->kill_sb() which may be useful
+ * for kernfs users which dynamically manage superblocks.
+ *
+ * Returns NULL if there's no superblock associated to this kernfs_root, or
+ * -EINVAL if the superblock is being freed.
+ */
+struct super_block *kernfs_pin_sb(struct kernfs_root *root, const void *ns)
+{
+	struct kernfs_super_info *info;
+	struct super_block *sb = NULL;
+
+	mutex_lock(&kernfs_mutex);
+	list_for_each_entry(info, &root->supers, node) {
+		if (info->ns == ns) {
+			sb = info->sb;
+			if (!atomic_inc_not_zero(&info->sb->s_active))
+				sb = ERR_PTR(-EINVAL);
+			break;
+		}
+	}
+	mutex_unlock(&kernfs_mutex);
+	return sb;
+}
+
 void __init kernfs_init(void)
 {
 	kernfs_node_cache = kmem_cache_create("kernfs_node_cache",

commit 26fc9cd200ec839e0b3095e05ae018f27314e7aa
Author: Jianyu Zhan <nasa4836@gmail.com>
Date:   Sat Apr 26 15:40:28 2014 +0800

    kernfs: move the last knowledge of sysfs out from kernfs
    
    There is still one residue of sysfs remaining: the sb_magic
    SYSFS_MAGIC. However this should be kernfs user specific,
    so this patch moves it out. Kerrnfs user should specify their
    magic number while mouting.
    
    Signed-off-by: Jianyu Zhan <nasa4836@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index f25a7c0c3cdc..d171b98a6cdd 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -62,7 +62,7 @@ struct kernfs_root *kernfs_root_from_sb(struct super_block *sb)
 	return NULL;
 }
 
-static int kernfs_fill_super(struct super_block *sb)
+static int kernfs_fill_super(struct super_block *sb, unsigned long magic)
 {
 	struct kernfs_super_info *info = kernfs_info(sb);
 	struct inode *inode;
@@ -71,7 +71,7 @@ static int kernfs_fill_super(struct super_block *sb)
 	info->sb = sb;
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
-	sb->s_magic = SYSFS_MAGIC;
+	sb->s_magic = magic;
 	sb->s_op = &kernfs_sops;
 	sb->s_time_gran = 1;
 
@@ -132,6 +132,7 @@ const void *kernfs_super_ns(struct super_block *sb)
  * @fs_type: file_system_type of the fs being mounted
  * @flags: mount flags specified for the mount
  * @root: kernfs_root of the hierarchy being mounted
+ * @magic: file system specific magic number
  * @new_sb_created: tell the caller if we allocated a new superblock
  * @ns: optional namespace tag of the mount
  *
@@ -143,8 +144,8 @@ const void *kernfs_super_ns(struct super_block *sb)
  * The return value can be passed to the vfs layer verbatim.
  */
 struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-			       struct kernfs_root *root, bool *new_sb_created,
-			       const void *ns)
+				struct kernfs_root *root, unsigned long magic,
+				bool *new_sb_created, const void *ns)
 {
 	struct super_block *sb;
 	struct kernfs_super_info *info;
@@ -169,7 +170,7 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 	if (!sb->s_root) {
 		struct kernfs_super_info *info = kernfs_info(sb);
 
-		error = kernfs_fill_super(sb);
+		error = kernfs_fill_super(sb, magic);
 		if (error) {
 			deactivate_locked_super(sb);
 			return ERR_PTR(error);

commit 7d568a8383bbb9c1f5167781075906acb2bb1550
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Apr 9 11:07:30 2014 -0400

    kernfs: implement kernfs_root->supers list
    
    Currently, there's no way to find out which super_blocks are
    associated with a given kernfs_root.  Let's implement it - the planned
    inotify extension to kernfs_notify() needs it.
    
    Make kernfs_super_info point back to the super_block and chain it at
    kernfs_root->supers.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 6a5f04ac8704..f25a7c0c3cdc 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -68,6 +68,7 @@ static int kernfs_fill_super(struct super_block *sb)
 	struct inode *inode;
 	struct dentry *root;
 
+	info->sb = sb;
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = SYSFS_MAGIC;
@@ -166,12 +167,18 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 		*new_sb_created = !sb->s_root;
 
 	if (!sb->s_root) {
+		struct kernfs_super_info *info = kernfs_info(sb);
+
 		error = kernfs_fill_super(sb);
 		if (error) {
 			deactivate_locked_super(sb);
 			return ERR_PTR(error);
 		}
 		sb->s_flags |= MS_ACTIVE;
+
+		mutex_lock(&kernfs_mutex);
+		list_add(&info->node, &root->supers);
+		mutex_unlock(&kernfs_mutex);
 	}
 
 	return dget(sb->s_root);
@@ -190,6 +197,10 @@ void kernfs_kill_sb(struct super_block *sb)
 	struct kernfs_super_info *info = kernfs_info(sb);
 	struct kernfs_node *root_kn = sb->s_root->d_fsdata;
 
+	mutex_lock(&kernfs_mutex);
+	list_del(&info->node);
+	mutex_unlock(&kernfs_mutex);
+
 	/*
 	 * Remove the superblock from fs_supers/s_instances
 	 * so we can't find it, before freeing kernfs_super_info.

commit 13df7977431e3b906a23bb75f29e0f40a8d73f87
Merge: 6d8b3e1ad3d3 0414855fdc4a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Mar 2 20:09:08 2014 -0800

    Merge 3.14-rc5 into driver-core-next
    
    We want the fixes in here.

commit fed95bab8d29b928fcf6225be72d37ded452e8a2
Author: Li Zefan <lizefan@huawei.com>
Date:   Tue Feb 25 19:28:44 2014 +0800

    sysfs: fix namespace refcnt leak
    
    As mount() and kill_sb() is not a one-to-one match, we shoudn't get
    ns refcnt unconditionally in sysfs_mount(), and instead we should
    get the refcnt only when kernfs_mount() allocated a new superblock.
    
    v2:
    - Changed the name of the new argument, suggested by Tejun.
    - Made the argument optional, suggested by Tejun.
    
    v3:
    - Make the new argument as second-to-last arg, suggested by Tejun.
    
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Acked-by: Tejun Heo <tj@kernel.org>
     ---
     fs/kernfs/mount.c      | 8 +++++++-
     fs/sysfs/mount.c       | 5 +++--
     include/linux/kernfs.h | 9 +++++----
     3 files changed, 15 insertions(+), 7 deletions(-)
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 0d6ce895a9ee..0f4152defe7b 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -94,6 +94,7 @@ const void *kernfs_super_ns(struct super_block *sb)
  * @fs_type: file_system_type of the fs being mounted
  * @flags: mount flags specified for the mount
  * @root: kernfs_root of the hierarchy being mounted
+ * @new_sb_created: tell the caller if we allocated a new superblock
  * @ns: optional namespace tag of the mount
  *
  * This is to be called from each kernfs user's file_system_type->mount()
@@ -104,7 +105,8 @@ const void *kernfs_super_ns(struct super_block *sb)
  * The return value can be passed to the vfs layer verbatim.
  */
 struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-			       struct kernfs_root *root, const void *ns)
+			       struct kernfs_root *root, bool *new_sb_created,
+			       const void *ns)
 {
 	struct super_block *sb;
 	struct kernfs_super_info *info;
@@ -122,6 +124,10 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 		kfree(info);
 	if (IS_ERR(sb))
 		return ERR_CAST(sb);
+
+	if (new_sb_created)
+		*new_sb_created = !sb->s_root;
+
 	if (!sb->s_root) {
 		error = kernfs_fill_super(sb);
 		if (error) {

commit f41c593454943b80a2017c8a2a3d6b1d0b0a6f89
Author: Li Zefan <lizefan@huawei.com>
Date:   Fri Feb 14 16:57:27 2014 +0800

    kernfs: fix kernfs_node_from_dentry()
    
    Currently kernfs_node_from_dentry() returns NULL for root dentry,
    because root_dentry->d_op == NULL.
    
    Due to this bug cgroupstats_build() returns -EINVAL for root cgroup.
    
      # mount -t cgroup -o cpuacct /cgroup
      # Documentation/accounting/getdelays -C /cgroup
      fatal reply error,  errno -22
    
    With this fix:
    
      # Documentation/accounting/getdelays -C /cgroup
      sleeping 305, blocked 0, running 1, stopped 0, uninterruptible 1
    
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index e5b28b0ebc37..405279b5517b 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -39,7 +39,7 @@ static int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)
 	return 0;
 }
 
-static const struct super_operations kernfs_sops = {
+const struct super_operations kernfs_sops = {
 	.statfs		= simple_statfs,
 	.drop_inode	= generic_delete_inode,
 	.evict_inode	= kernfs_evict_inode,

commit 0c23b2259a4850494e2c53e864ea840597c6cdd3
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:15 2014 -0500

    kernfs: implement kernfs_node_from_dentry(), kernfs_root_from_sb() and kernfs_rename()
    
    Implement helpers to determine node from dentry and root from
    super_block.  Also add a kernfs_rename_ns() wrapper which assumes NULL
    namespace.  These generally make sense and will be used by cgroup.
    
    v2: Some dummy implementations for !CONFIG_SYSFS was missing.  Fixed.
        Reported by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 70cc6983d9b5..e5b28b0ebc37 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -48,6 +48,20 @@ static const struct super_operations kernfs_sops = {
 	.show_options	= kernfs_sop_show_options,
 };
 
+/**
+ * kernfs_root_from_sb - determine kernfs_root associated with a super_block
+ * @sb: the super_block in question
+ *
+ * Return the kernfs_root associated with @sb.  If @sb is not a kernfs one,
+ * %NULL is returned.
+ */
+struct kernfs_root *kernfs_root_from_sb(struct super_block *sb)
+{
+	if (sb->s_op == &kernfs_sops)
+		return kernfs_info(sb)->root;
+	return NULL;
+}
+
 static int kernfs_fill_super(struct super_block *sb)
 {
 	struct kernfs_super_info *info = kernfs_info(sb);

commit 6a7fed4eefddad48224f1c9d534b4e262f0897f6
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:10 2014 -0500

    kernfs: implement kernfs_syscall_ops->remount_fs() and ->show_options()
    
    Add two super_block related syscall callbacks ->remount_fs() and
    ->show_options() to kernfs_syscall_ops.  These simply forward the
    matching super_operations.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 0d6ce895a9ee..70cc6983d9b5 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -19,10 +19,33 @@
 
 struct kmem_cache *kernfs_node_cache;
 
+static int kernfs_sop_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	struct kernfs_root *root = kernfs_info(sb)->root;
+	struct kernfs_syscall_ops *scops = root->syscall_ops;
+
+	if (scops && scops->remount_fs)
+		return scops->remount_fs(root, flags, data);
+	return 0;
+}
+
+static int kernfs_sop_show_options(struct seq_file *sf, struct dentry *dentry)
+{
+	struct kernfs_root *root = kernfs_root(dentry->d_fsdata);
+	struct kernfs_syscall_ops *scops = root->syscall_ops;
+
+	if (scops && scops->show_options)
+		return scops->show_options(sf, root);
+	return 0;
+}
+
 static const struct super_operations kernfs_sops = {
 	.statfs		= simple_statfs,
 	.drop_inode	= generic_delete_inode,
 	.evict_inode	= kernfs_evict_inode,
+
+	.remount_fs	= kernfs_sop_remount_fs,
+	.show_options	= kernfs_sop_show_options,
 };
 
 static int kernfs_fill_super(struct super_block *sb)

commit c637b8acbe079edb477d887041755b489036f146
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:58 2013 -0500

    kernfs: s/sysfs/kernfs/ in internal functions and whatever is left
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_*()/kernfs_*()/ in all internal functions
    * s/sysfs/kernfs/ in internal strings, comments and whatever is remaining
    * Uniformly rename various vfs operations so that they're consistently
      named and distinguishable.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 27d967ba0bb9..0d6ce895a9ee 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -22,10 +22,10 @@ struct kmem_cache *kernfs_node_cache;
 static const struct super_operations kernfs_sops = {
 	.statfs		= simple_statfs,
 	.drop_inode	= generic_delete_inode,
-	.evict_inode	= sysfs_evict_inode,
+	.evict_inode	= kernfs_evict_inode,
 };
 
-static int sysfs_fill_super(struct super_block *sb)
+static int kernfs_fill_super(struct super_block *sb)
 {
 	struct kernfs_super_info *info = kernfs_info(sb);
 	struct inode *inode;
@@ -39,10 +39,10 @@ static int sysfs_fill_super(struct super_block *sb)
 
 	/* get root inode, initialize and unlock it */
 	mutex_lock(&kernfs_mutex);
-	inode = sysfs_get_inode(sb, info->root->kn);
+	inode = kernfs_get_inode(sb, info->root->kn);
 	mutex_unlock(&kernfs_mutex);
 	if (!inode) {
-		pr_debug("sysfs: could not get root inode\n");
+		pr_debug("kernfs: could not get root inode\n");
 		return -ENOMEM;
 	}
 
@@ -59,7 +59,7 @@ static int sysfs_fill_super(struct super_block *sb)
 	return 0;
 }
 
-static int sysfs_test_super(struct super_block *sb, void *data)
+static int kernfs_test_super(struct super_block *sb, void *data)
 {
 	struct kernfs_super_info *sb_info = kernfs_info(sb);
 	struct kernfs_super_info *info = data;
@@ -67,7 +67,7 @@ static int sysfs_test_super(struct super_block *sb, void *data)
 	return sb_info->root == info->root && sb_info->ns == info->ns;
 }
 
-static int sysfs_set_super(struct super_block *sb, void *data)
+static int kernfs_set_super(struct super_block *sb, void *data)
 {
 	int error;
 	error = set_anon_super(sb, data);
@@ -117,13 +117,13 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 	info->root = root;
 	info->ns = ns;
 
-	sb = sget(fs_type, sysfs_test_super, sysfs_set_super, flags, info);
+	sb = sget(fs_type, kernfs_test_super, kernfs_set_super, flags, info);
 	if (IS_ERR(sb) || sb->s_fs_info != info)
 		kfree(info);
 	if (IS_ERR(sb))
 		return ERR_CAST(sb);
 	if (!sb->s_root) {
-		error = sysfs_fill_super(sb);
+		error = kernfs_fill_super(sb);
 		if (error) {
 			deactivate_locked_super(sb);
 			return ERR_PTR(error);
@@ -161,5 +161,5 @@ void __init kernfs_init(void)
 	kernfs_node_cache = kmem_cache_create("kernfs_node_cache",
 					      sizeof(struct kernfs_node),
 					      0, SLAB_PANIC, NULL);
-	sysfs_inode_init();
+	kernfs_inode_init();
 }

commit a797bfc30532388e8a11ca726df60cdd77aa8675
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:57 2013 -0500

    kernfs: s/sysfs/kernfs/ in global variables
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_mutex/kernfs_mutex/
    * s/sysfs_dentry_ops/kernfs_dops/
    * s/sysfs_dir_operations/kernfs_dir_fops/
    * s/sysfs_dir_inode_operations/kernfs_dir_iops/
    * s/kernfs_file_operations/kernfs_file_fops/ - renamed for consistency
    * s/sysfs_symlink_inode_operations/kernfs_symlink_iops/
    * s/sysfs_aops/kernfs_aops/
    * s/sysfs_backing_dev_info/kernfs_bdi/
    * s/sysfs_inode_operations/kernfs_iops/
    * s/sysfs_dir_cachep/kernfs_node_cache/
    * s/sysfs_ops/kernfs_sops/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index e0796dcb6065..27d967ba0bb9 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -17,9 +17,9 @@
 
 #include "kernfs-internal.h"
 
-struct kmem_cache *sysfs_dir_cachep;
+struct kmem_cache *kernfs_node_cache;
 
-static const struct super_operations sysfs_ops = {
+static const struct super_operations kernfs_sops = {
 	.statfs		= simple_statfs,
 	.drop_inode	= generic_delete_inode,
 	.evict_inode	= sysfs_evict_inode,
@@ -34,13 +34,13 @@ static int sysfs_fill_super(struct super_block *sb)
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = SYSFS_MAGIC;
-	sb->s_op = &sysfs_ops;
+	sb->s_op = &kernfs_sops;
 	sb->s_time_gran = 1;
 
 	/* get root inode, initialize and unlock it */
-	mutex_lock(&sysfs_mutex);
+	mutex_lock(&kernfs_mutex);
 	inode = sysfs_get_inode(sb, info->root->kn);
-	mutex_unlock(&sysfs_mutex);
+	mutex_unlock(&kernfs_mutex);
 	if (!inode) {
 		pr_debug("sysfs: could not get root inode\n");
 		return -ENOMEM;
@@ -55,7 +55,7 @@ static int sysfs_fill_super(struct super_block *sb)
 	kernfs_get(info->root->kn);
 	root->d_fsdata = info->root->kn;
 	sb->s_root = root;
-	sb->s_d_op = &sysfs_dentry_ops;
+	sb->s_d_op = &kernfs_dops;
 	return 0;
 }
 
@@ -158,7 +158,7 @@ void kernfs_kill_sb(struct super_block *sb)
 
 void __init kernfs_init(void)
 {
-	sysfs_dir_cachep = kmem_cache_create("sysfs_dir_cache",
+	kernfs_node_cache = kmem_cache_create("kernfs_node_cache",
 					      sizeof(struct kernfs_node),
 					      0, SLAB_PANIC, NULL);
 	sysfs_inode_init();

commit c525aaddc366df23eb095d58a2bdf11cce62a98b
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:55 2013 -0500

    kernfs: s/sysfs/kernfs/ in various data structures
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_open_dirent/kernfs_open_node/
    * s/sysfs_open_file/kernfs_open_file/
    * s/sysfs_inode_attrs/kernfs_iattrs/
    * s/sysfs_addrm_cxt/kernfs_addrm_cxt/
    * s/sysfs_super_info/kernfs_super_info/
    * s/sysfs_info()/kernfs_info()/
    * s/sysfs_open_dirent_lock/kernfs_open_node_lock/
    * s/sysfs_open_file_mutex/kernfs_open_file_mutex/
    * s/sysfs_of()/kernfs_of()/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 9dbbf37b1af9..e0796dcb6065 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -27,7 +27,7 @@ static const struct super_operations sysfs_ops = {
 
 static int sysfs_fill_super(struct super_block *sb)
 {
-	struct sysfs_super_info *info = sysfs_info(sb);
+	struct kernfs_super_info *info = kernfs_info(sb);
 	struct inode *inode;
 	struct dentry *root;
 
@@ -61,8 +61,8 @@ static int sysfs_fill_super(struct super_block *sb)
 
 static int sysfs_test_super(struct super_block *sb, void *data)
 {
-	struct sysfs_super_info *sb_info = sysfs_info(sb);
-	struct sysfs_super_info *info = data;
+	struct kernfs_super_info *sb_info = kernfs_info(sb);
+	struct kernfs_super_info *info = data;
 
 	return sb_info->root == info->root && sb_info->ns == info->ns;
 }
@@ -84,7 +84,7 @@ static int sysfs_set_super(struct super_block *sb, void *data)
  */
 const void *kernfs_super_ns(struct super_block *sb)
 {
-	struct sysfs_super_info *info = sysfs_info(sb);
+	struct kernfs_super_info *info = kernfs_info(sb);
 
 	return info->ns;
 }
@@ -107,7 +107,7 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 			       struct kernfs_root *root, const void *ns)
 {
 	struct super_block *sb;
-	struct sysfs_super_info *info;
+	struct kernfs_super_info *info;
 	int error;
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
@@ -144,12 +144,12 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
  */
 void kernfs_kill_sb(struct super_block *sb)
 {
-	struct sysfs_super_info *info = sysfs_info(sb);
+	struct kernfs_super_info *info = kernfs_info(sb);
 	struct kernfs_node *root_kn = sb->s_root->d_fsdata;
 
 	/*
 	 * Remove the superblock from fs_supers/s_instances
-	 * so we can't find it, before freeing sysfs_super_info.
+	 * so we can't find it, before freeing kernfs_super_info.
 	 */
 	kill_anon_super(sb);
 	kfree(info);

commit 324a56e16e44baecac3ca799fd216154145c14bf
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:53 2013 -0500

    kernfs: s/sysfs_dirent/kernfs_node/ and rename its friends accordingly
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_elem_dir/kernfs_elem_dir/
    * s/sysfs_elem_symlink/kernfs_elem_symlink/
    * s/sysfs_elem_attr/kernfs_elem_file/
    * s/sysfs_dirent/kernfs_node/
    * s/sd/kn/ in kernfs proper
    * s/parent_sd/parent/
    * s/target_sd/target/
    * s/dir_sd/parent/
    * s/to_sysfs_dirent()/rb_to_kn()/
    * misc renames of local vars when they conflict with the above
    
    Because md, mic and gpio dig into sysfs details, this patch ends up
    modifying them.  All are sysfs_dirent renames and trivial.  While we
    can avoid these by introducing a dummy wrapping struct sysfs_dirent
    around kernfs_node, given the limited usage outside kernfs and sysfs
    proper, I don't think such workaround is called for.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    - mic / gpio renames were missing.  Spotted by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 84c83e24bf25..9dbbf37b1af9 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -39,7 +39,7 @@ static int sysfs_fill_super(struct super_block *sb)
 
 	/* get root inode, initialize and unlock it */
 	mutex_lock(&sysfs_mutex);
-	inode = sysfs_get_inode(sb, info->root->sd);
+	inode = sysfs_get_inode(sb, info->root->kn);
 	mutex_unlock(&sysfs_mutex);
 	if (!inode) {
 		pr_debug("sysfs: could not get root inode\n");
@@ -52,8 +52,8 @@ static int sysfs_fill_super(struct super_block *sb)
 		pr_debug("%s: could not get root dentry!\n", __func__);
 		return -ENOMEM;
 	}
-	kernfs_get(info->root->sd);
-	root->d_fsdata = info->root->sd;
+	kernfs_get(info->root->kn);
+	root->d_fsdata = info->root->kn;
 	sb->s_root = root;
 	sb->s_d_op = &sysfs_dentry_ops;
 	return 0;
@@ -145,7 +145,7 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 void kernfs_kill_sb(struct super_block *sb)
 {
 	struct sysfs_super_info *info = sysfs_info(sb);
-	struct sysfs_dirent *root_sd = sb->s_root->d_fsdata;
+	struct kernfs_node *root_kn = sb->s_root->d_fsdata;
 
 	/*
 	 * Remove the superblock from fs_supers/s_instances
@@ -153,13 +153,13 @@ void kernfs_kill_sb(struct super_block *sb)
 	 */
 	kill_anon_super(sb);
 	kfree(info);
-	kernfs_put(root_sd);
+	kernfs_put(root_kn);
 }
 
 void __init kernfs_init(void)
 {
 	sysfs_dir_cachep = kmem_cache_create("sysfs_dir_cache",
-					      sizeof(struct sysfs_dirent),
+					      sizeof(struct kernfs_node),
 					      0, SLAB_PANIC, NULL);
 	sysfs_inode_init();
 }

commit fa736a951e456b996a76826ba78ff974414c3b55
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:44 2013 -0500

    sysfs, kernfs: move mount core code to fs/kernfs/mount.c
    
    Move core mount code to fs/kernfs/mount.c.  The respective
    declarations in fs/sysfs/sysfs.h are moved to
    fs/kernfs/kernfs-internal.h.
    
    This is pure relocation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
index 872e262e5166..84c83e24bf25 100644
--- a/fs/kernfs/mount.c
+++ b/fs/kernfs/mount.c
@@ -7,3 +7,159 @@
  *
  * This file is released under the GPLv2.
  */
+
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/init.h>
+#include <linux/magic.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+
+#include "kernfs-internal.h"
+
+struct kmem_cache *sysfs_dir_cachep;
+
+static const struct super_operations sysfs_ops = {
+	.statfs		= simple_statfs,
+	.drop_inode	= generic_delete_inode,
+	.evict_inode	= sysfs_evict_inode,
+};
+
+static int sysfs_fill_super(struct super_block *sb)
+{
+	struct sysfs_super_info *info = sysfs_info(sb);
+	struct inode *inode;
+	struct dentry *root;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = SYSFS_MAGIC;
+	sb->s_op = &sysfs_ops;
+	sb->s_time_gran = 1;
+
+	/* get root inode, initialize and unlock it */
+	mutex_lock(&sysfs_mutex);
+	inode = sysfs_get_inode(sb, info->root->sd);
+	mutex_unlock(&sysfs_mutex);
+	if (!inode) {
+		pr_debug("sysfs: could not get root inode\n");
+		return -ENOMEM;
+	}
+
+	/* instantiate and link root dentry */
+	root = d_make_root(inode);
+	if (!root) {
+		pr_debug("%s: could not get root dentry!\n", __func__);
+		return -ENOMEM;
+	}
+	kernfs_get(info->root->sd);
+	root->d_fsdata = info->root->sd;
+	sb->s_root = root;
+	sb->s_d_op = &sysfs_dentry_ops;
+	return 0;
+}
+
+static int sysfs_test_super(struct super_block *sb, void *data)
+{
+	struct sysfs_super_info *sb_info = sysfs_info(sb);
+	struct sysfs_super_info *info = data;
+
+	return sb_info->root == info->root && sb_info->ns == info->ns;
+}
+
+static int sysfs_set_super(struct super_block *sb, void *data)
+{
+	int error;
+	error = set_anon_super(sb, data);
+	if (!error)
+		sb->s_fs_info = data;
+	return error;
+}
+
+/**
+ * kernfs_super_ns - determine the namespace tag of a kernfs super_block
+ * @sb: super_block of interest
+ *
+ * Return the namespace tag associated with kernfs super_block @sb.
+ */
+const void *kernfs_super_ns(struct super_block *sb)
+{
+	struct sysfs_super_info *info = sysfs_info(sb);
+
+	return info->ns;
+}
+
+/**
+ * kernfs_mount_ns - kernfs mount helper
+ * @fs_type: file_system_type of the fs being mounted
+ * @flags: mount flags specified for the mount
+ * @root: kernfs_root of the hierarchy being mounted
+ * @ns: optional namespace tag of the mount
+ *
+ * This is to be called from each kernfs user's file_system_type->mount()
+ * implementation, which should pass through the specified @fs_type and
+ * @flags, and specify the hierarchy and namespace tag to mount via @root
+ * and @ns, respectively.
+ *
+ * The return value can be passed to the vfs layer verbatim.
+ */
+struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
+			       struct kernfs_root *root, const void *ns)
+{
+	struct super_block *sb;
+	struct sysfs_super_info *info;
+	int error;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return ERR_PTR(-ENOMEM);
+
+	info->root = root;
+	info->ns = ns;
+
+	sb = sget(fs_type, sysfs_test_super, sysfs_set_super, flags, info);
+	if (IS_ERR(sb) || sb->s_fs_info != info)
+		kfree(info);
+	if (IS_ERR(sb))
+		return ERR_CAST(sb);
+	if (!sb->s_root) {
+		error = sysfs_fill_super(sb);
+		if (error) {
+			deactivate_locked_super(sb);
+			return ERR_PTR(error);
+		}
+		sb->s_flags |= MS_ACTIVE;
+	}
+
+	return dget(sb->s_root);
+}
+
+/**
+ * kernfs_kill_sb - kill_sb for kernfs
+ * @sb: super_block being killed
+ *
+ * This can be used directly for file_system_type->kill_sb().  If a kernfs
+ * user needs extra cleanup, it can implement its own kill_sb() and call
+ * this function at the end.
+ */
+void kernfs_kill_sb(struct super_block *sb)
+{
+	struct sysfs_super_info *info = sysfs_info(sb);
+	struct sysfs_dirent *root_sd = sb->s_root->d_fsdata;
+
+	/*
+	 * Remove the superblock from fs_supers/s_instances
+	 * so we can't find it, before freeing sysfs_super_info.
+	 */
+	kill_anon_super(sb);
+	kfree(info);
+	kernfs_put(root_sd);
+}
+
+void __init kernfs_init(void)
+{
+	sysfs_dir_cachep = kmem_cache_create("sysfs_dir_cache",
+					      sizeof(struct sysfs_dirent),
+					      0, SLAB_PANIC, NULL);
+	sysfs_inode_init();
+}

commit b8441ed279bff09a0a5ddeacf8f4087d2fb424ca
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Nov 24 09:54:58 2013 -0500

    sysfs, kernfs: add skeletons for kernfs
    
    Core sysfs implementation will be separated into kernfs so that it can
    be used by other non-kobject users.
    
    This patch creates fs/kernfs/ directory and makes boilerplate changes.
    kernfs interface will be directly based on sysfs_dirent and its
    forward declaration is moved to include/linux/kernfs.h which is
    included from include/linux/sysfs.h.  sysfs core implementation will
    be gradually separated out and moved to kernfs.
    
    This patch doesn't introduce any functional changes.
    
    v2: mount.c added.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/mount.c b/fs/kernfs/mount.c
new file mode 100644
index 000000000000..872e262e5166
--- /dev/null
+++ b/fs/kernfs/mount.c
@@ -0,0 +1,9 @@
+/*
+ * fs/kernfs/mount.c - kernfs mount implementation
+ *
+ * Copyright (c) 2001-3 Patrick Mochel
+ * Copyright (c) 2007 SUSE Linux Products GmbH
+ * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>
+ *
+ * This file is released under the GPLv2.
+ */
