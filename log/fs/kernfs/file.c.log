commit c1e8d7c6a7a682e1405e3e242d32fc377fd196ff
Author: Michel Lespinasse <walken@google.com>
Date:   Mon Jun 8 21:33:54 2020 -0700

    mmap locking API: convert mmap_sem comments
    
    Convert comments that reference mmap_sem to reference mmap_lock instead.
    
    [akpm@linux-foundation.org: fix up linux-next leftovers]
    [akpm@linux-foundation.org: s/lockaphore/lock/, per Vlastimil]
    [akpm@linux-foundation.org: more linux-next fixups, per Michel]
    
    Signed-off-by: Michel Lespinasse <walken@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Hubbard <jhubbard@nvidia.com>
    Cc: Laurent Dufour <ldufour@linux.ibm.com>
    Cc: Liam Howlett <Liam.Howlett@oracle.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ying Han <yinghan@google.com>
    Link: http://lkml.kernel.org/r/20200520052908.204642-13-walken@google.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index fd6ddfe4cd94..06b342d8462b 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -652,9 +652,9 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 	 * The following is done to give a different lockdep key to
 	 * @of->mutex for files which implement mmap.  This is a rather
 	 * crude way to avoid false positive lockdep warning around
-	 * mm->mmap_sem - mmap nests @of->mutex under mm->mmap_sem and
+	 * mm->mmap_lock - mmap nests @of->mutex under mm->mmap_lock and
 	 * reading /sys/block/sda/trace/act_mask grabs sr_mutex, under
-	 * which mm->mmap_sem nests, while holding @of->mutex.  As each
+	 * which mm->mmap_lock nests, while holding @of->mutex.  As each
 	 * open file has a separate mutex, it's okay as long as those don't
 	 * happen on the same file.  At this point, we can't easily give
 	 * each file a separate locking class.  Let's differentiate on

commit 0f605db5bdd42edfbfcac36acaf8f72cfe9ce774
Author: Waiman Long <longman@redhat.com>
Date:   Thu Apr 2 13:10:56 2020 -0400

    kernfs: Change kernfs_node lockdep name to "kn->active"
    
    The kernfs_node lockdep tracking is being done on kn->active, the
    active reference count. The other reference count (kn->count) is not
    tracked by lockdep. So change the lockdep name to reflect what it is
    tracking.
    
    Signed-off-by: Waiman Long <longman@redhat.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Link: https://lore.kernel.org/r/20200402171056.27871-1-longman@redhat.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 34366db3620d..fd6ddfe4cd94 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -1010,7 +1010,7 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	if (key) {
-		lockdep_init_map(&kn->dep_map, "kn->count", key, 0);
+		lockdep_init_map(&kn->dep_map, "kn->active", key, 0);
 		kn->flags |= KERNFS_LOCKDEP;
 	}
 #endif

commit 67c0496e87d193b8356d2af49ab95e8a1b954b3c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: convert kernfs_node->id from union kernfs_node_id to u64
    
    kernfs_node->id is currently a union kernfs_node_id which represents
    either a 32bit (ino, gen) pair or u64 value.  I can't see much value
    in the usage of the union - all that's needed is a 64bit ID which the
    current code is already limited to.  Using a union makes the code
    unnecessarily complicated and prevents using 64bit ino without adding
    practical benefits.
    
    This patch drops union kernfs_node_id and makes kernfs_node->id a u64.
    ino is stored in the lower 32bits and gen upper.  Accessors -
    kernfs[_id]_ino() and kernfs[_id]_gen() - are added to retrieve the
    ino and gen.  This simplifies ID handling less cumbersome and will
    allow using 64bit inos on supported archs.
    
    This patch doesn't make any functional changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Alexei Starovoitov <ast@kernel.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index e8c792b49616..34366db3620d 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -892,7 +892,7 @@ static void kernfs_notify_workfn(struct work_struct *work)
 		 * have the matching @file available.  Look up the inodes
 		 * and generate the events manually.
 		 */
-		inode = ilookup(info->sb, kn->id.ino);
+		inode = ilookup(info->sb, kernfs_ino(kn));
 		if (!inode)
 			continue;
 
@@ -901,7 +901,7 @@ static void kernfs_notify_workfn(struct work_struct *work)
 		if (parent) {
 			struct inode *p_inode;
 
-			p_inode = ilookup(info->sb, parent->id.ino);
+			p_inode = ilookup(info->sb, kernfs_ino(parent));
 			if (p_inode) {
 				fsnotify(p_inode, FS_MODIFY | FS_EVENT_ON_CHILD,
 					 inode, FSNOTIFY_EVENT_INODE, &name, 0);

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 553ce0a92b05..e8c792b49616 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * fs/kernfs/file.c - kernfs file implementation
  *
  * Copyright (c) 2001-3 Patrick Mochel
  * Copyright (c) 2007 SUSE Linux Products GmbH
  * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>
- *
- * This file is released under the GPLv2.
  */
 
 #include <linux/fs.h>

commit 25b229dff4ffffd0fad2dd409faf1e2ae4d94866
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 26 13:37:25 2019 -0400

    fsnotify(): switch to passing const struct qstr * for file_name
    
    Note that in fnsotify_move() and fsnotify_link() we are guaranteed
    that dentry->d_name won't change during the fsnotify() evaluation
    (by having the parent directory locked exclusive), so we don't
    need to fetch dentry->d_name.name in the callers.  In fsnotify_dirent()
    the same stability of dentry->d_name is also true, but it's a bit
    more convoluted - there is one callchain (devpts_pty_new() ->
    fsnotify_create() -> fsnotify_dirent()) where the parent is _not_
    locked, but on devpts ->d_name of everything is unchanging; it
    has neither explicit nor implicit renames.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index ae948aaa4c53..553ce0a92b05 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -885,6 +885,7 @@ static void kernfs_notify_workfn(struct work_struct *work)
 	list_for_each_entry(info, &kernfs_root(kn)->supers, node) {
 		struct kernfs_node *parent;
 		struct inode *inode;
+		struct qstr name;
 
 		/*
 		 * We want fsnotify_modify() on @kn but as the
@@ -896,6 +897,7 @@ static void kernfs_notify_workfn(struct work_struct *work)
 		if (!inode)
 			continue;
 
+		name = (struct qstr)QSTR_INIT(kn->name, strlen(kn->name));
 		parent = kernfs_get_parent(kn);
 		if (parent) {
 			struct inode *p_inode;
@@ -903,7 +905,7 @@ static void kernfs_notify_workfn(struct work_struct *work)
 			p_inode = ilookup(info->sb, parent->id.ino);
 			if (p_inode) {
 				fsnotify(p_inode, FS_MODIFY | FS_EVENT_ON_CHILD,
-					 inode, FSNOTIFY_EVENT_INODE, kn->name, 0);
+					 inode, FSNOTIFY_EVENT_INODE, &name, 0);
 				iput(p_inode);
 			}
 
@@ -911,7 +913,7 @@ static void kernfs_notify_workfn(struct work_struct *work)
 		}
 
 		fsnotify(inode, FS_MODIFY, inode, FSNOTIFY_EVENT_INODE,
-			 kn->name, 0);
+			 &name, 0);
 		iput(inode);
 	}
 

commit 147e1a97c4a0bdd43f55a582a9416bb9092563a9
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Tue Mar 5 15:45:45 2019 -0800

    fs: kernfs: add poll file operation
    
    Patch series "psi: pressure stall monitors", v3.
    
    Android is adopting psi to detect and remedy memory pressure that
    results in stuttering and decreased responsiveness on mobile devices.
    
    Psi gives us the stall information, but because we're dealing with
    latencies in the millisecond range, periodically reading the pressure
    files to detect stalls in a timely fashion is not feasible.  Psi also
    doesn't aggregate its averages at a high enough frequency right now.
    
    This patch series extends the psi interface such that users can
    configure sensitive latency thresholds and use poll() and friends to be
    notified when these are breached.
    
    As high-frequency aggregation is costly, it implements an aggregation
    method that is optimized for fast, short-interval averaging, and makes
    the aggregation frequency adaptive, such that high-frequency updates
    only happen while monitored stall events are actively occurring.
    
    With these patches applied, Android can monitor for, and ward off,
    mounting memory shortages before they cause problems for the user.  For
    example, using memory stall monitors in userspace low memory killer
    daemon (lmkd) we can detect mounting pressure and kill less important
    processes before device becomes visibly sluggish.
    
    In our memory stress testing psi memory monitors produce roughly 10x
    less false positives compared to vmpressure signals.  Having ability to
    specify multiple triggers for the same psi metric allows other parts of
    Android framework to monitor memory state of the device and act
    accordingly.
    
    The new interface is straightforward.  The user opens one of the
    pressure files for writing and writes a trigger description into the
    file descriptor that defines the stall state - some or full, and the
    maximum stall time over a given window of time.  E.g.:
    
            /* Signal when stall time exceeds 100ms of a 1s window */
            char trigger[] = "full 100000 1000000";
            fd = open("/proc/pressure/memory");
            write(fd, trigger, sizeof(trigger));
            while (poll() >= 0) {
                    ...
            }
            close(fd);
    
    When the monitored stall state is entered, psi adapts its aggregation
    frequency according to what the configured time window requires in order
    to emit event signals in a timely fashion.  Once the stalling subsides,
    aggregation reverts back to normal.
    
    The trigger is associated with the open file descriptor.  To stop
    monitoring, the user only needs to close the file descriptor and the
    trigger is discarded.
    
    Patches 1-4 prepare the psi code for polling support.  Patch 5
    implements the adaptive polling logic, the pressure growth detection
    optimized for short intervals, and hooks up write() and poll() on the
    pressure files.
    
    The patches were developed in collaboration with Johannes Weiner.
    
    This patch (of 5):
    
    Kernfs has a standardized poll/notification mechanism for waking all
    pollers on all fds when a filesystem node changes.  To allow polling for
    custom events, add a .poll callback that can override the default.
    
    This is in preparation for pollable cgroup pressure files which have
    per-fd trigger configurations.
    
    Link: http://lkml.kernel.org/r/20190124211518.244221-2-surenb@google.com
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Signed-off-by: Suren Baghdasaryan <surenb@google.com>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index f8d5021a652e..ae948aaa4c53 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -832,26 +832,35 @@ void kernfs_drain_open_files(struct kernfs_node *kn)
  * to see if it supports poll (Neither 'poll' nor 'select' return
  * an appropriate error code).  When in doubt, set a suitable timeout value.
  */
+__poll_t kernfs_generic_poll(struct kernfs_open_file *of, poll_table *wait)
+{
+	struct kernfs_node *kn = kernfs_dentry_node(of->file->f_path.dentry);
+	struct kernfs_open_node *on = kn->attr.open;
+
+	poll_wait(of->file, &on->poll, wait);
+
+	if (of->event != atomic_read(&on->event))
+		return DEFAULT_POLLMASK|EPOLLERR|EPOLLPRI;
+
+	return DEFAULT_POLLMASK;
+}
+
 static __poll_t kernfs_fop_poll(struct file *filp, poll_table *wait)
 {
 	struct kernfs_open_file *of = kernfs_of(filp);
 	struct kernfs_node *kn = kernfs_dentry_node(filp->f_path.dentry);
-	struct kernfs_open_node *on = kn->attr.open;
+	__poll_t ret;
 
 	if (!kernfs_get_active(kn))
-		goto trigger;
+		return DEFAULT_POLLMASK|EPOLLERR|EPOLLPRI;
 
-	poll_wait(filp, &on->poll, wait);
+	if (kn->attr.ops->poll)
+		ret = kn->attr.ops->poll(of, wait);
+	else
+		ret = kernfs_generic_poll(of, wait);
 
 	kernfs_put_active(kn);
-
-	if (of->event != atomic_read(&on->event))
-		goto trigger;
-
-	return DEFAULT_POLLMASK;
-
- trigger:
-	return DEFAULT_POLLMASK|EPOLLERR|EPOLLPRI;
+	return ret;
 }
 
 static void kernfs_notify_workfn(struct work_struct *work)

commit 03c0a9208bb10821e5e3f1c81e6218df32524311
Author: Radu Rendec <radu.rendec@gmail.com>
Date:   Thu Nov 15 21:09:54 2018 -0500

    kernfs: Improve kernfs_notify() poll notification latency
    
    kernfs_notify() does two notifications: poll and fsnotify. Originally,
    both notifications were done from scheduled work context and all that
    kernfs_notify() did was schedule the work.
    
    This patch simply moves the poll notification from the scheduled work
    handler to kernfs_notify(). The fsnotify notification still needs to be
    done from scheduled work context because it can sleep (it needs to lock
    a mutex).
    
    If the poll notification is time critical (the notified thread needs to
    wake as quickly as possible), it's better to do it from kernfs_notify()
    directly. One example is calling sysfs_notify_dirent() from a hardware
    interrupt handler to wake up a thread and handle the interrupt in user
    space.
    
    Signed-off-by: Radu Rendec <radu.rendec@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index dbf5bc250bfd..f8d5021a652e 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -857,7 +857,6 @@ static __poll_t kernfs_fop_poll(struct file *filp, poll_table *wait)
 static void kernfs_notify_workfn(struct work_struct *work)
 {
 	struct kernfs_node *kn;
-	struct kernfs_open_node *on;
 	struct kernfs_super_info *info;
 repeat:
 	/* pop one off the notify_list */
@@ -871,17 +870,6 @@ static void kernfs_notify_workfn(struct work_struct *work)
 	kn->attr.notify_next = NULL;
 	spin_unlock_irq(&kernfs_notify_lock);
 
-	/* kick poll */
-	spin_lock_irq(&kernfs_open_node_lock);
-
-	on = kn->attr.open;
-	if (on) {
-		atomic_inc(&on->event);
-		wake_up_interruptible(&on->poll);
-	}
-
-	spin_unlock_irq(&kernfs_open_node_lock);
-
 	/* kick fsnotify */
 	mutex_lock(&kernfs_mutex);
 
@@ -934,10 +922,21 @@ void kernfs_notify(struct kernfs_node *kn)
 {
 	static DECLARE_WORK(kernfs_notify_work, kernfs_notify_workfn);
 	unsigned long flags;
+	struct kernfs_open_node *on;
 
 	if (WARN_ON(kernfs_type(kn) != KERNFS_FILE))
 		return;
 
+	/* kick poll immediately */
+	spin_lock_irqsave(&kernfs_open_node_lock, flags);
+	on = kn->attr.open;
+	if (on) {
+		atomic_inc(&on->event);
+		wake_up_interruptible(&on->poll);
+	}
+	spin_unlock_irqrestore(&kernfs_open_node_lock, flags);
+
+	/* schedule work to kick fsnotify */
 	spin_lock_irqsave(&kernfs_notify_lock, flags);
 	if (!kn->attr.notify_next) {
 		kernfs_get(kn);

commit 488dee96bb62f0b3d9e678cf42574034d5b033a5
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 20 21:56:47 2018 +0000

    kernfs: allow creating kernfs objects with arbitrary uid/gid
    
    This change allows creating kernfs files and directories with arbitrary
    uid/gid instead of always using GLOBAL_ROOT_UID/GID by extending
    kernfs_create_dir_ns() and kernfs_create_file_ns() with uid/gid arguments.
    The "simple" kernfs_create_file() and kernfs_create_dir() are left alone
    and always create objects belonging to the global root.
    
    When creating symlinks ownership (uid/gid) is taken from the target kernfs
    object.
    
    Co-Developed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 2015d8c45e4a..dbf5bc250bfd 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -965,6 +965,8 @@ const struct file_operations kernfs_file_fops = {
  * @parent: directory to create the file in
  * @name: name of the file
  * @mode: mode of the file
+ * @uid: uid of the file
+ * @gid: gid of the file
  * @size: size of the file
  * @ops: kernfs operations for the file
  * @priv: private data for the file
@@ -975,7 +977,8 @@ const struct file_operations kernfs_file_fops = {
  */
 struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 const char *name,
-					 umode_t mode, loff_t size,
+					 umode_t mode, kuid_t uid, kgid_t gid,
+					 loff_t size,
 					 const struct kernfs_ops *ops,
 					 void *priv, const void *ns,
 					 struct lock_class_key *key)
@@ -986,7 +989,8 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 
 	flags = KERNFS_FILE;
 
-	kn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG, flags);
+	kn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG,
+			     uid, gid, flags);
 	if (!kn)
 		return ERR_PTR(-ENOMEM);
 

commit 9ee84466b7130360d07241baf4c95a553fc0a997
Author: Souptick Joarder <jrdr.linux@gmail.com>
Date:   Sat Apr 21 01:15:24 2018 +0530

    fs: kernfs: Adding new return type vm_fault_t
    
    Use new return type vm_fault_t for page_mkwrite and
    fault handler. For now, this is just documenting that
    the function returns a VM_FAULT value rather than an
    errno.  Once all instances are converted, vm_fault_t
    will become a distinct type.
    
    Reference id -> 1c8f422059ae ("mm: change return type to
    vm_fault_t")
    
    Signed-off-by: Souptick Joarder <jrdr.linux@gmail.com>
    Reviewed-by: Matthew Wilcox <mawilcox@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index fd5ce883072e..2015d8c45e4a 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -348,11 +348,11 @@ static void kernfs_vma_open(struct vm_area_struct *vma)
 	kernfs_put_active(of->kn);
 }
 
-static int kernfs_vma_fault(struct vm_fault *vmf)
+static vm_fault_t kernfs_vma_fault(struct vm_fault *vmf)
 {
 	struct file *file = vmf->vma->vm_file;
 	struct kernfs_open_file *of = kernfs_of(file);
-	int ret;
+	vm_fault_t ret;
 
 	if (!of->vm_ops)
 		return VM_FAULT_SIGBUS;
@@ -368,11 +368,11 @@ static int kernfs_vma_fault(struct vm_fault *vmf)
 	return ret;
 }
 
-static int kernfs_vma_page_mkwrite(struct vm_fault *vmf)
+static vm_fault_t kernfs_vma_page_mkwrite(struct vm_fault *vmf)
 {
 	struct file *file = vmf->vma->vm_file;
 	struct kernfs_open_file *of = kernfs_of(file);
-	int ret;
+	vm_fault_t ret;
 
 	if (!of->vm_ops)
 		return VM_FAULT_SIGBUS;

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index a03ce3422578..fd5ce883072e 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -823,7 +823,7 @@ void kernfs_drain_open_files(struct kernfs_node *kn)
  * the content and then you use 'poll' or 'select' to wait for
  * the content to change.  When the content changes (assuming the
  * manager for the kobject supports notification), poll will
- * return POLLERR|POLLPRI, and select will return the fd whether
+ * return EPOLLERR|EPOLLPRI, and select will return the fd whether
  * it is waiting for read, write, or exceptions.
  * Once poll/select indicates that the value has changed, you
  * need to close and re-open the file, or seek to 0 and read again.
@@ -851,7 +851,7 @@ static __poll_t kernfs_fop_poll(struct file *filp, poll_table *wait)
 	return DEFAULT_POLLMASK;
 
  trigger:
-	return DEFAULT_POLLMASK|POLLERR|POLLPRI;
+	return DEFAULT_POLLMASK|EPOLLERR|EPOLLPRI;
 }
 
 static void kernfs_notify_workfn(struct work_struct *work)

commit 878e66d06fd098a744b9caafdd0e99bba415ce37
Merge: c839682c719f cf5eebae2cd2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 9 19:22:17 2018 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs fixes from Al Viro.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      seq_file: fix incomplete reset on read from zero offset
      kernfs: fix regression in kernfs_fop_write caused by wrong type

commit ba87977a49913129962af8ac35b0e13e0fa4382d
Author: Ivan Vecera <ivecera@redhat.com>
Date:   Fri Jan 19 09:18:54 2018 +0100

    kernfs: fix regression in kernfs_fop_write caused by wrong type
    
    Commit b7ce40cff0b9 ("kernfs: cache atomic_write_len in
    kernfs_open_file") changes type of local variable 'len' from ssize_t
    to size_t. This change caused that the *ppos value is updated also
    when the previous write callback failed.
    
    Mentioned snippet:
    ...
    len = ops->write(...); <- return value can be negative
    ...
    if (len > 0)           <- true here in this case
            *ppos += len;
    ...
    
    Fixes: b7ce40cff0b9 ("kernfs: cache atomic_write_len in kernfs_open_file")
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Ivan Vecera <ivecera@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 9698e51656b1..d8f49c412f50 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -275,7 +275,7 @@ static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
 {
 	struct kernfs_open_file *of = kernfs_of(file);
 	const struct kernfs_ops *ops;
-	size_t len;
+	ssize_t len;
 	char *buf;
 
 	if (of->atomic_write_len) {

commit 076ccb76e1a6cf0aa5371132efdd502a11e806f1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 01:02:18 2017 -0400

    fs: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 9698e51656b1..c53d9cc5ae7a 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -832,7 +832,7 @@ void kernfs_drain_open_files(struct kernfs_node *kn)
  * to see if it supports poll (Neither 'poll' nor 'select' return
  * an appropriate error code).  When in doubt, set a suitable timeout value.
  */
-static unsigned int kernfs_fop_poll(struct file *filp, poll_table *wait)
+static __poll_t kernfs_fop_poll(struct file *filp, poll_table *wait)
 {
 	struct kernfs_open_file *of = kernfs_of(filp);
 	struct kernfs_node *kn = kernfs_dentry_node(filp->f_path.dentry);

commit a0725ab0c7536076d5477264420ef420ebb64501
Merge: 3ee31b89d9b1 ef13ecbc134d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 11:59:42 2017 -0700

    Merge branch 'for-4.14/block' of git://git.kernel.dk/linux-block
    
    Pull block layer updates from Jens Axboe:
     "This is the first pull request for 4.14, containing most of the code
      changes. It's a quiet series this round, which I think we needed after
      the churn of the last few series. This contains:
    
       - Fix for a registration race in loop, from Anton Volkov.
    
       - Overflow complaint fix from Arnd for DAC960.
    
       - Series of drbd changes from the usual suspects.
    
       - Conversion of the stec/skd driver to blk-mq. From Bart.
    
       - A few BFQ improvements/fixes from Paolo.
    
       - CFQ improvement from Ritesh, allowing idling for group idle.
    
       - A few fixes found by Dan's smatch, courtesy of Dan.
    
       - A warning fixup for a race between changing the IO scheduler and
         device remova. From David Jeffery.
    
       - A few nbd fixes from Josef.
    
       - Support for cgroup info in blktrace, from Shaohua.
    
       - Also from Shaohua, new features in the null_blk driver to allow it
         to actually hold data, among other things.
    
       - Various corner cases and error handling fixes from Weiping Zhang.
    
       - Improvements to the IO stats tracking for blk-mq from me. Can
         drastically improve performance for fast devices and/or big
         machines.
    
       - Series from Christoph removing bi_bdev as being needed for IO
         submission, in preparation for nvme multipathing code.
    
       - Series from Bart, including various cleanups and fixes for switch
         fall through case complaints"
    
    * 'for-4.14/block' of git://git.kernel.dk/linux-block: (162 commits)
      kernfs: checking for IS_ERR() instead of NULL
      drbd: remove BIOSET_NEED_RESCUER flag from drbd_{md_,}io_bio_set
      drbd: Fix allyesconfig build, fix recent commit
      drbd: switch from kmalloc() to kmalloc_array()
      drbd: abort drbd_start_resync if there is no connection
      drbd: move global variables to drbd namespace and make some static
      drbd: rename "usermode_helper" to "drbd_usermode_helper"
      drbd: fix race between handshake and admin disconnect/down
      drbd: fix potential deadlock when trying to detach during handshake
      drbd: A single dot should be put into a sequence.
      drbd: fix rmmod cleanup, remove _all_ debugfs entries
      drbd: Use setup_timer() instead of init_timer() to simplify the code.
      drbd: fix potential get_ldev/put_ldev refcount imbalance during attach
      drbd: new disk-option disable-write-same
      drbd: Fix resource role for newly created resources in events2
      drbd: mark symbols static where possible
      drbd: Send P_NEG_ACK upon write error in protocol != C
      drbd: add explicit plugging when submitting batches
      drbd: change list_for_each_safe to while(list_first_entry_or_null)
      drbd: introduce drbd_recv_header_maybe_unplug
      ...

commit 39bf04db6b2b13eeb2aa565930034dc9d4198d93
Author: Waiman Long <longman@redhat.com>
Date:   Thu Aug 17 11:49:56 2017 -0400

    kernfs: Clarify lockdep name for kn->count
    
    The reference count in kernfs_node structure is treated like a rwsem by
    using lockdep instrumentation code. The lockdep name, however, is still
    "s_active" which is carried over from the old sysfs code. As s_active
    is no longer the variable name, its use may confuse users on where the
    lock is when it is reported by lockdep. So it is changed to "kn->count"
    which is how this variable is normally referenced in kernfs code.
    
    Signed-off-by: Waiman Long <longman@redhat.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index ac2dfe0c5a9c..e6c8954a4e89 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -997,7 +997,7 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	if (key) {
-		lockdep_init_map(&kn->dep_map, "s_active", key, 0);
+		lockdep_init_map(&kn->dep_map, "kn->count", key, 0);
 		kn->flags |= KERNFS_LOCKDEP;
 	}
 #endif

commit c53cd490b1a491ebf1d8e30da97e7231459a4208
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:50 2017 -0700

    kernfs: introduce kernfs_node_id
    
    inode number and generation can identify a kernfs node. We are going to
    export the identification by exportfs operations, so put ino and
    generation into a separate structure. It's convenient when later patches
    use the identification.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 7f90d4de86b6..744192539010 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -895,7 +895,7 @@ static void kernfs_notify_workfn(struct work_struct *work)
 		 * have the matching @file available.  Look up the inodes
 		 * and generate the events manually.
 		 */
-		inode = ilookup(info->sb, kn->ino);
+		inode = ilookup(info->sb, kn->id.ino);
 		if (!inode)
 			continue;
 
@@ -903,7 +903,7 @@ static void kernfs_notify_workfn(struct work_struct *work)
 		if (parent) {
 			struct inode *p_inode;
 
-			p_inode = ilookup(info->sb, parent->ino);
+			p_inode = ilookup(info->sb, parent->id.ino);
 			if (p_inode) {
 				fsnotify(p_inode, FS_MODIFY | FS_EVENT_ON_CHILD,
 					 inode, FSNOTIFY_EVENT_INODE, kn->name, 0);

commit 319ba91d352a74acb47678788109a14b9b4dd4c2
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:49 2017 -0700

    kernfs: don't set dentry->d_fsdata
    
    When working on adding exportfs operations in kernfs, I found it's hard
    to initialize dentry->d_fsdata in the exportfs operations. Looks there
    is no way to do it without race condition. Look at the kernfs code
    closely, there is no point to set dentry->d_fsdata. inode->i_private
    already points to kernfs_node, and we can get inode from a dentry. So
    this patch just delete the d_fsdata usage.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index ac2dfe0c5a9c..7f90d4de86b6 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -616,7 +616,7 @@ static void kernfs_put_open_node(struct kernfs_node *kn,
 
 static int kernfs_fop_open(struct inode *inode, struct file *file)
 {
-	struct kernfs_node *kn = file->f_path.dentry->d_fsdata;
+	struct kernfs_node *kn = inode->i_private;
 	struct kernfs_root *root = kernfs_root(kn);
 	const struct kernfs_ops *ops;
 	struct kernfs_open_file *of;
@@ -768,7 +768,7 @@ static void kernfs_release_file(struct kernfs_node *kn,
 
 static int kernfs_fop_release(struct inode *inode, struct file *filp)
 {
-	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
+	struct kernfs_node *kn = inode->i_private;
 	struct kernfs_open_file *of = kernfs_of(filp);
 
 	if (kn->flags & KERNFS_HAS_RELEASE) {
@@ -835,7 +835,7 @@ void kernfs_drain_open_files(struct kernfs_node *kn)
 static unsigned int kernfs_fop_poll(struct file *filp, poll_table *wait)
 {
 	struct kernfs_open_file *of = kernfs_of(filp);
-	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
+	struct kernfs_node *kn = kernfs_dentry_node(filp->f_path.dentry);
 	struct kernfs_open_node *on = kn->attr.open;
 
 	if (!kernfs_get_active(kn))

commit 966fa72a716ceafc69de901a31f7cc1f52b35f81
Author: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>
Date:   Tue Mar 14 08:17:00 2017 +0530

    kernfs: Check KERNFS_HAS_RELEASE before calling kernfs_release_file()
    
    Recently started seeing a kernel oops when a module tries removing a
    memory mapped sysfs bin_attribute. On closer investigation the root
    cause seems to be kernfs_release_file() trying to call
    kernfs_op.release() callback that's NULL for such sysfs
    bin_attributes. The oops occurs when kernfs_release_file() is called from
    kernfs_drain_open_files() to cleanup any open handles with active
    memory mappings.
    
    The patch fixes this by checking for flag KERNFS_HAS_RELEASE before
    calling kernfs_release_file() in function kernfs_drain_open_files().
    
    On ppc64-le arch with cxl module the oops back-trace is of the
    form below:
    [  861.381126] Unable to handle kernel paging request for instruction fetch
    [  861.381360] Faulting instruction address: 0x00000000
    [  861.381428] Oops: Kernel access of bad area, sig: 11 [#1]
    ....
    [  861.382481] NIP: 0000000000000000 LR: c000000000362c60 CTR:
    0000000000000000
    ....
    Call Trace:
    [c000000f1680b750] [c000000000362c34] kernfs_drain_open_files+0x104/0x1d0 (unreliable)
    [c000000f1680b790] [c00000000035fa00] __kernfs_remove+0x260/0x2c0
    [c000000f1680b820] [c000000000360da0] kernfs_remove_by_name_ns+0x60/0xe0
    [c000000f1680b8b0] [c0000000003638f4] sysfs_remove_bin_file+0x24/0x40
    [c000000f1680b8d0] [c00000000062a164] device_remove_bin_file+0x24/0x40
    [c000000f1680b8f0] [d000000009b7b22c] cxl_sysfs_afu_remove+0x144/0x170 [cxl]
    [c000000f1680b940] [d000000009b7c7e4] cxl_remove+0x6c/0x1a0 [cxl]
    [c000000f1680b990] [c00000000052f694] pci_device_remove+0x64/0x110
    [c000000f1680b9d0] [c0000000006321d4] device_release_driver_internal+0x1f4/0x2b0
    [c000000f1680ba20] [c000000000525cb0] pci_stop_bus_device+0xa0/0xd0
    [c000000f1680ba60] [c000000000525e80] pci_stop_and_remove_bus_device+0x20/0x40
    [c000000f1680ba90] [c00000000004a6c4] pci_hp_remove_devices+0x84/0xc0
    [c000000f1680bad0] [c00000000004a688] pci_hp_remove_devices+0x48/0xc0
    [c000000f1680bb10] [c0000000009dfda4] eeh_reset_device+0xb0/0x290
    [c000000f1680bbb0] [c000000000032b4c] eeh_handle_normal_event+0x47c/0x530
    [c000000f1680bc60] [c000000000032e64] eeh_handle_event+0x174/0x350
    [c000000f1680bd10] [c000000000033228] eeh_event_handler+0x1e8/0x1f0
    [c000000f1680bdc0] [c0000000000d384c] kthread+0x14c/0x190
    [c000000f1680be30] [c00000000000b5a0] ret_from_kernel_thread+0x5c/0xbc
    
    Fixes: f83f3c515654 ("kernfs: fix locking around kernfs_ops->release() callback")
    Signed-off-by: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 8e4dc7ab584c..ac2dfe0c5a9c 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -809,7 +809,8 @@ void kernfs_drain_open_files(struct kernfs_node *kn)
 		if (kn->flags & KERNFS_HAS_MMAP)
 			unmap_mapping_range(inode->i_mapping, 0, 0, 1);
 
-		kernfs_release_file(kn, of);
+		if (kn->flags & KERNFS_HAS_RELEASE)
+			kernfs_release_file(kn, of);
 	}
 
 	mutex_unlock(&kernfs_open_file_mutex);

commit 589ee62844e042b0b7d19ef57fb4cff77f3ca294
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Feb 4 00:16:44 2017 +0100

    sched/headers: Prepare to remove the <linux/mm_types.h> dependency from <linux/sched.h>
    
    Update code that relied on sched.h including various MM types for them.
    
    This will allow us to remove the <linux/mm_types.h> include from <linux/sched.h>.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 35043a8c4529..8e4dc7ab584c 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -13,7 +13,7 @@
 #include <linux/slab.h>
 #include <linux/poll.h>
 #include <linux/pagemap.h>
-#include <linux/sched.h>
+#include <linux/sched/mm.h>
 #include <linux/fsnotify.h>
 
 #include "kernfs-internal.h"

commit f7878dc3a9d3d900c86a66d9742f7e06681b06cd
Merge: fb15a78210f1 f83f3c515654
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 27 21:41:08 2017 -0800

    Merge branch 'for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup
    
    Pull cgroup updates from Tejun Heo:
     "Several noteworthy changes.
    
       - Parav's rdma controller is finally merged. It is very straight
         forward and can limit the abosolute numbers of common rdma
         constructs used by different cgroups.
    
       - kernel/cgroup.c got too chubby and disorganized. Created
         kernel/cgroup/ subdirectory and moved all cgroup related files
         under kernel/ there and reorganized the core code. This hurts for
         backporting patches but was long overdue.
    
       - cgroup v2 process listing reimplemented so that it no longer
         depends on allocating a buffer large enough to cache the entire
         result to sort and uniq the output. v2 has always mangled the sort
         order to ensure that users don't depend on the sorted output, so
         this shouldn't surprise anybody. This makes the pid listing
         functions use the same iterators that are used internally, which
         have to have the same iterating capabilities anyway.
    
       - perf cgroup filtering now works automatically on cgroup v2. This
         patch was posted a long time ago but somehow fell through the
         cracks.
    
       - misc fixes asnd documentation updates"
    
    * 'for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup: (27 commits)
      kernfs: fix locking around kernfs_ops->release() callback
      cgroup: drop the matching uid requirement on migration for cgroup v2
      cgroup, perf_event: make perf_event controller work on cgroup2 hierarchy
      cgroup: misc cleanups
      cgroup: call subsys->*attach() only for subsystems which are actually affected by migration
      cgroup: track migration context in cgroup_mgctx
      cgroup: cosmetic update to cgroup_taskset_add()
      rdmacg: Fixed uninitialized current resource usage
      cgroup: Add missing cgroup-v2 PID controller documentation.
      rdmacg: Added documentation for rdmacg
      IB/core: added support to use rdma cgroup controller
      rdmacg: Added rdma cgroup controller
      cgroup: fix a comment typo
      cgroup: fix RCU related sparse warnings
      cgroup: move namespace code to kernel/cgroup/namespace.c
      cgroup: rename functions for consistency
      cgroup: move v1 mount functions to kernel/cgroup/cgroup-v1.c
      cgroup: separate out cgroup1_kf_syscall_ops
      cgroup: refactor mount path and clearly distinguish v1 and v2 paths
      cgroup: move cgroup v1 specific code to kernel/cgroup/cgroup-v1.c
      ...

commit 11bac80004499ea59f361ef2a5516c84b6eab675
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Fri Feb 24 14:56:41 2017 -0800

    mm, fs: reduce fault, page_mkwrite, and pfn_mkwrite to take only vmf
    
    ->fault(), ->page_mkwrite(), and ->pfn_mkwrite() calls do not need to
    take a vma and vmf parameter when the vma already resides in vmf.
    
    Remove the vma parameter to simplify things.
    
    [arnd@arndb.de: fix ARM build]
      Link: http://lkml.kernel.org/r/20170125223558.1451224-1-arnd@arndb.de
    Link: http://lkml.kernel.org/r/148521301778.19116.10840599906674778980.stgit@djiang5-desk3.ch.intel.com
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Darrick J. Wong <darrick.wong@oracle.com>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Jan Kara <jack@suse.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 78219d5644e9..4f0535890b30 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -348,9 +348,9 @@ static void kernfs_vma_open(struct vm_area_struct *vma)
 	kernfs_put_active(of->kn);
 }
 
-static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+static int kernfs_vma_fault(struct vm_fault *vmf)
 {
-	struct file *file = vma->vm_file;
+	struct file *file = vmf->vma->vm_file;
 	struct kernfs_open_file *of = kernfs_of(file);
 	int ret;
 
@@ -362,16 +362,15 @@ static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 
 	ret = VM_FAULT_SIGBUS;
 	if (of->vm_ops->fault)
-		ret = of->vm_ops->fault(vma, vmf);
+		ret = of->vm_ops->fault(vmf);
 
 	kernfs_put_active(of->kn);
 	return ret;
 }
 
-static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
-				   struct vm_fault *vmf)
+static int kernfs_vma_page_mkwrite(struct vm_fault *vmf)
 {
-	struct file *file = vma->vm_file;
+	struct file *file = vmf->vma->vm_file;
 	struct kernfs_open_file *of = kernfs_of(file);
 	int ret;
 
@@ -383,7 +382,7 @@ static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
 
 	ret = 0;
 	if (of->vm_ops->page_mkwrite)
-		ret = of->vm_ops->page_mkwrite(vma, vmf);
+		ret = of->vm_ops->page_mkwrite(vmf);
 	else
 		file_update_time(file);
 

commit f83f3c515654474e19c7fc86e3b06564bb5cb4d4
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Feb 12 05:33:02 2017 +0900

    kernfs: fix locking around kernfs_ops->release() callback
    
    The release callback may be called from two places - file release
    operation and kernfs open file draining.  kernfs_open_file->mutex is
    used to synchronize the two callsites.  This unfortunately leads to
    possible circular locking because of->mutex is used to protect the
    usual kernfs operations which may use locking constructs which are
    held while removing and thus draining kernfs files.
    
    @of->mutex is for synchronizing concurrent kernfs access operations
    and all we need here is synchronization between the releaes and drain
    paths.  As the drain path has to grab kernfs_open_file_mutex anyway,
    let's use the mutex to synchronize the release operation instead.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-and-tested-by: Tony Lindgren <tony@atomide.com>
    Fixes: 0e67db2f9fe9 ("kernfs: add kernfs_ops->open/release() callbacks")
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 20c396291ac1..14da136028de 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -747,10 +747,15 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 static void kernfs_release_file(struct kernfs_node *kn,
 				struct kernfs_open_file *of)
 {
-	if (!(kn->flags & KERNFS_HAS_RELEASE))
-		return;
+	/*
+	 * @of is guaranteed to have no other file operations in flight and
+	 * we just want to synchronize release and drain paths.
+	 * @kernfs_open_file_mutex is enough.  @of->mutex can't be used
+	 * here because drain path may be called from places which can
+	 * cause circular dependency.
+	 */
+	lockdep_assert_held(&kernfs_open_file_mutex);
 
-	mutex_lock(&of->mutex);
 	if (!of->released) {
 		/*
 		 * A file is never detached without being released and we
@@ -760,7 +765,6 @@ static void kernfs_release_file(struct kernfs_node *kn,
 		kn->attr.ops->release(of);
 		of->released = true;
 	}
-	mutex_unlock(&of->mutex);
 }
 
 static int kernfs_fop_release(struct inode *inode, struct file *filp)
@@ -768,7 +772,12 @@ static int kernfs_fop_release(struct inode *inode, struct file *filp)
 	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
 	struct kernfs_open_file *of = kernfs_of(filp);
 
-	kernfs_release_file(kn, of);
+	if (kn->flags & KERNFS_HAS_RELEASE) {
+		mutex_lock(&kernfs_open_file_mutex);
+		kernfs_release_file(kn, of);
+		mutex_unlock(&kernfs_open_file_mutex);
+	}
+
 	kernfs_put_open_node(kn, of);
 	seq_release(inode, filp);
 	kfree(of->prealloc_buf);

commit 0e67db2f9fe91937e798e3d7d22c50a8438187e1
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Dec 27 14:49:03 2016 -0500

    kernfs: add kernfs_ops->open/release() callbacks
    
    Add ->open/release() methods to kernfs_ops.  ->open() is called when
    the file is opened and ->release() when the file is either released or
    severed.  These callbacks can be used, for example, to manage
    persistent caching objects over multiple seq_file iterations.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Acked-by: Zefan Li <lizefan@huawei.com>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index d0b6fb13ead0..20c396291ac1 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -708,7 +708,8 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 	if (error)
 		goto err_free;
 
-	((struct seq_file *)file->private_data)->private = of;
+	of->seq_file = file->private_data;
+	of->seq_file->private = of;
 
 	/* seq_file clears PWRITE unconditionally, restore it if WRITE */
 	if (file->f_mode & FMODE_WRITE)
@@ -717,13 +718,22 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 	/* make sure we have open node struct */
 	error = kernfs_get_open_node(kn, of);
 	if (error)
-		goto err_close;
+		goto err_seq_release;
+
+	if (ops->open) {
+		/* nobody has access to @of yet, skip @of->mutex */
+		error = ops->open(of);
+		if (error)
+			goto err_put_node;
+	}
 
 	/* open succeeded, put active references */
 	kernfs_put_active(kn);
 	return 0;
 
-err_close:
+err_put_node:
+	kernfs_put_open_node(kn, of);
+err_seq_release:
 	seq_release(inode, file);
 err_free:
 	kfree(of->prealloc_buf);
@@ -733,11 +743,32 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 	return error;
 }
 
+/* used from release/drain to ensure that ->release() is called exactly once */
+static void kernfs_release_file(struct kernfs_node *kn,
+				struct kernfs_open_file *of)
+{
+	if (!(kn->flags & KERNFS_HAS_RELEASE))
+		return;
+
+	mutex_lock(&of->mutex);
+	if (!of->released) {
+		/*
+		 * A file is never detached without being released and we
+		 * need to be able to release files which are deactivated
+		 * and being drained.  Don't use kernfs_ops().
+		 */
+		kn->attr.ops->release(of);
+		of->released = true;
+	}
+	mutex_unlock(&of->mutex);
+}
+
 static int kernfs_fop_release(struct inode *inode, struct file *filp)
 {
 	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
 	struct kernfs_open_file *of = kernfs_of(filp);
 
+	kernfs_release_file(kn, of);
 	kernfs_put_open_node(kn, of);
 	seq_release(inode, filp);
 	kfree(of->prealloc_buf);
@@ -746,12 +777,12 @@ static int kernfs_fop_release(struct inode *inode, struct file *filp)
 	return 0;
 }
 
-void kernfs_unmap_bin_file(struct kernfs_node *kn)
+void kernfs_drain_open_files(struct kernfs_node *kn)
 {
 	struct kernfs_open_node *on;
 	struct kernfs_open_file *of;
 
-	if (!(kn->flags & KERNFS_HAS_MMAP))
+	if (!(kn->flags & (KERNFS_HAS_MMAP | KERNFS_HAS_RELEASE)))
 		return;
 
 	spin_lock_irq(&kernfs_open_node_lock);
@@ -763,10 +794,16 @@ void kernfs_unmap_bin_file(struct kernfs_node *kn)
 		return;
 
 	mutex_lock(&kernfs_open_file_mutex);
+
 	list_for_each_entry(of, &on->files, list) {
 		struct inode *inode = file_inode(of->file);
-		unmap_mapping_range(inode->i_mapping, 0, 0, 1);
+
+		if (kn->flags & KERNFS_HAS_MMAP)
+			unmap_mapping_range(inode->i_mapping, 0, 0, 1);
+
+		kernfs_release_file(kn, of);
 	}
+
 	mutex_unlock(&kernfs_open_file_mutex);
 
 	kernfs_put_open_node(kn, NULL);
@@ -965,6 +1002,8 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 		kn->flags |= KERNFS_HAS_SEQ_SHOW;
 	if (ops->mmap)
 		kn->flags |= KERNFS_HAS_MMAP;
+	if (ops->release)
+		kn->flags |= KERNFS_HAS_RELEASE;
 
 	rc = kernfs_add_one(kn);
 	if (rc) {

commit a1d82aff5df760d933b6ea3a03805dbc2bd73eb8
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Dec 27 14:49:02 2016 -0500

    kernfs: make kernfs_open_file->mmapped a bitfield
    
    More kernfs_open_file->mutex synchronized flags are planned to be
    added.  Convert ->mmapped to a bitfield in preparation.
    
    While at it, make kernfs_fop_mmap() use "true" instead of "1" on
    ->mmapped.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Acked-by: Zefan Li <lizefan@huawei.com>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 78219d5644e9..d0b6fb13ead0 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -516,7 +516,7 @@ static int kernfs_fop_mmap(struct file *file, struct vm_area_struct *vma)
 		goto out_put;
 
 	rc = 0;
-	of->mmapped = 1;
+	of->mmapped = true;
 	of->vm_ops = vma->vm_ops;
 	vma->vm_ops = &kernfs_vm_ops;
 out_put:

commit 2a9becdd4dbed499815938308bdab9aae70dd561
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Oct 14 10:56:42 2016 -0700

    kernfs: Add noop_fsync to supported kernfs_file_fops
    
    If you edit a kernfs backed file with vi(1), you see an ugly error
    message when you write the file because vi tries to fsync(2) the
    file after writing, which fails.
    
    We have noop_fsync() for this, use it.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 2bcb86e6e6ca..78219d5644e9 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -911,6 +911,7 @@ const struct file_operations kernfs_file_fops = {
 	.open		= kernfs_fop_open,
 	.release	= kernfs_fop_release,
 	.poll		= kernfs_fop_poll,
+	.fsync		= noop_fsync,
 };
 
 /**

commit df6a58c5c5aa8ecb1e088ecead3fa33ae70181f1
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jun 17 17:51:17 2016 -0400

    kernfs: don't depend on d_find_any_alias() when generating notifications
    
    kernfs_notify_workfn() sends out file modified events for the
    scheduled kernfs_nodes.  Because the modifications aren't from
    userland, it doesn't have the matching file struct at hand and can't
    use fsnotify_modify().  Instead, it looked up the inode and then used
    d_find_any_alias() to find the dentry and used fsnotify_parent() and
    fsnotify() directly to generate notifications.
    
    The assumption was that the relevant dentries would have been pinned
    if there are listeners, which isn't true as inotify doesn't pin
    dentries at all and watching the parent doesn't pin the child dentries
    even for dnotify.  This led to, for example, inotify watchers not
    getting notifications if the system is under memory pressure and the
    matching dentries got reclaimed.  It can also be triggered through
    /proc/sys/vm/drop_caches or a remount attempt which involves shrinking
    dcache.
    
    fsnotify_parent() only uses the dentry to access the parent inode,
    which kernfs can do easily.  Update kernfs_notify_workfn() so that it
    uses fsnotify() directly for both the parent and target inodes without
    going through d_find_any_alias().  While at it, supply the target file
    name to fsnotify() from kernfs_node->name.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Evgeny Vereshchagin <evvers@ya.ru>
    Fixes: d911d9874801 ("kernfs: make kernfs_notify() trigger inotify events too")
    Cc: John McCutchan <john@johnmccutchan.com>
    Cc: Robert Love <rlove@rlove.org>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: stable@vger.kernel.org # v3.16+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index e1574008adc9..2bcb86e6e6ca 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -840,21 +840,35 @@ static void kernfs_notify_workfn(struct work_struct *work)
 	mutex_lock(&kernfs_mutex);
 
 	list_for_each_entry(info, &kernfs_root(kn)->supers, node) {
+		struct kernfs_node *parent;
 		struct inode *inode;
-		struct dentry *dentry;
 
+		/*
+		 * We want fsnotify_modify() on @kn but as the
+		 * modifications aren't originating from userland don't
+		 * have the matching @file available.  Look up the inodes
+		 * and generate the events manually.
+		 */
 		inode = ilookup(info->sb, kn->ino);
 		if (!inode)
 			continue;
 
-		dentry = d_find_any_alias(inode);
-		if (dentry) {
-			fsnotify_parent(NULL, dentry, FS_MODIFY);
-			fsnotify(inode, FS_MODIFY, inode, FSNOTIFY_EVENT_INODE,
-				 NULL, 0);
-			dput(dentry);
+		parent = kernfs_get_parent(kn);
+		if (parent) {
+			struct inode *p_inode;
+
+			p_inode = ilookup(info->sb, parent->ino);
+			if (p_inode) {
+				fsnotify(p_inode, FS_MODIFY | FS_EVENT_ON_CHILD,
+					 inode, FSNOTIFY_EVENT_INODE, kn->name, 0);
+				iput(p_inode);
+			}
+
+			kernfs_put(parent);
 		}
 
+		fsnotify(inode, FS_MODIFY, inode, FSNOTIFY_EVENT_INODE,
+			 kn->name, 0);
 		iput(inode);
 	}
 

commit e4234a1fc343ca35f852bc527fae56fade879d4a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 31 11:45:06 2016 +0100

    kernfs: Move faulting copy_user operations outside of the mutex
    
    A fault in a user provided buffer may lead anywhere, and lockdep warns
    that we have a potential deadlock between the mm->mmap_sem and the
    kernfs file mutex:
    
    [   82.811702] ======================================================
    [   82.811705] [ INFO: possible circular locking dependency detected ]
    [   82.811709] 4.5.0-rc4-gfxbench+ #1 Not tainted
    [   82.811711] -------------------------------------------------------
    [   82.811714] kms_setmode/5859 is trying to acquire lock:
    [   82.811717]  (&dev->struct_mutex){+.+.+.}, at: [<ffffffff8150d9c1>] drm_gem_mmap+0x1a1/0x270
    [   82.811731]
    but task is already holding lock:
    [   82.811734]  (&mm->mmap_sem){++++++}, at: [<ffffffff8117b364>] vm_mmap_pgoff+0x44/0xa0
    [   82.811745]
    which lock already depends on the new lock.
    
    [   82.811749]
    the existing dependency chain (in reverse order) is:
    [   82.811752]
    -> #3 (&mm->mmap_sem){++++++}:
    [   82.811761]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811766]        [<ffffffff8118bc65>] __might_fault+0x75/0xa0
    [   82.811771]        [<ffffffff8124da4a>] kernfs_fop_write+0x8a/0x180
    [   82.811787]        [<ffffffff811d1023>] __vfs_write+0x23/0xe0
    [   82.811792]        [<ffffffff811d1d74>] vfs_write+0xa4/0x190
    [   82.811797]        [<ffffffff811d2c14>] SyS_write+0x44/0xb0
    [   82.811801]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.811807]
    -> #2 (s_active#6){++++.+}:
    [   82.811814]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811819]        [<ffffffff8124c070>] __kernfs_remove+0x210/0x2f0
    [   82.811823]        [<ffffffff8124d040>] kernfs_remove_by_name_ns+0x40/0xa0
    [   82.811828]        [<ffffffff8124e9e0>] sysfs_remove_file_ns+0x10/0x20
    [   82.811832]        [<ffffffff815318d4>] device_del+0x124/0x250
    [   82.811837]        [<ffffffff81531a19>] device_unregister+0x19/0x60
    [   82.811841]        [<ffffffff8153c051>] cpu_cache_sysfs_exit+0x51/0xb0
    [   82.811846]        [<ffffffff8153c628>] cacheinfo_cpu_callback+0x38/0x70
    [   82.811851]        [<ffffffff8109ae89>] notifier_call_chain+0x39/0xa0
    [   82.811856]        [<ffffffff8109aef9>] __raw_notifier_call_chain+0x9/0x10
    [   82.811860]        [<ffffffff810786de>] cpu_notify+0x1e/0x40
    [   82.811865]        [<ffffffff81078779>] cpu_notify_nofail+0x9/0x20
    [   82.811869]        [<ffffffff81078ac3>] _cpu_down+0x233/0x340
    [   82.811874]        [<ffffffff81079019>] disable_nonboot_cpus+0xc9/0x350
    [   82.811878]        [<ffffffff810d2e11>] suspend_devices_and_enter+0x5a1/0xb50
    [   82.811883]        [<ffffffff810d3903>] pm_suspend+0x543/0x8d0
    [   82.811888]        [<ffffffff810d1b77>] state_store+0x77/0xe0
    [   82.811892]        [<ffffffff813fa68f>] kobj_attr_store+0xf/0x20
    [   82.811897]        [<ffffffff8124e740>] sysfs_kf_write+0x40/0x50
    [   82.811902]        [<ffffffff8124dafc>] kernfs_fop_write+0x13c/0x180
    [   82.811906]        [<ffffffff811d1023>] __vfs_write+0x23/0xe0
    [   82.811910]        [<ffffffff811d1d74>] vfs_write+0xa4/0x190
    [   82.811914]        [<ffffffff811d2c14>] SyS_write+0x44/0xb0
    [   82.811918]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.811923]
    -> #1 (cpu_hotplug.lock){+.+.+.}:
    [   82.811929]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811933]        [<ffffffff817b6f72>] mutex_lock_nested+0x62/0x3b0
    [   82.811940]        [<ffffffff810784c1>] get_online_cpus+0x61/0x80
    [   82.811944]        [<ffffffff811170eb>] stop_machine+0x1b/0xe0
    [   82.811949]        [<ffffffffa0178edd>] gen8_ggtt_insert_entries__BKL+0x2d/0x30 [i915]
    [   82.812009]        [<ffffffffa017d3a6>] ggtt_bind_vma+0x46/0x70 [i915]
    [   82.812045]        [<ffffffffa017eb70>] i915_vma_bind+0x140/0x290 [i915]
    [   82.812081]        [<ffffffffa01862b9>] i915_gem_object_do_pin+0x899/0xb00 [i915]
    [   82.812117]        [<ffffffffa0186555>] i915_gem_object_pin+0x35/0x40 [i915]
    [   82.812154]        [<ffffffffa019a23e>] intel_init_pipe_control+0xbe/0x210 [i915]
    [   82.812192]        [<ffffffffa0197312>] intel_logical_rings_init+0xe2/0xde0 [i915]
    [   82.812232]        [<ffffffffa0186fe3>] i915_gem_init+0xf3/0x130 [i915]
    [   82.812278]        [<ffffffffa02097ed>] i915_driver_load+0xf2d/0x1770 [i915]
    [   82.812318]        [<ffffffff81512474>] drm_dev_register+0xa4/0xb0
    [   82.812323]        [<ffffffff8151467e>] drm_get_pci_dev+0xce/0x1e0
    [   82.812328]        [<ffffffffa01472cf>] i915_pci_probe+0x2f/0x50 [i915]
    [   82.812360]        [<ffffffff8143f907>] pci_device_probe+0x87/0xf0
    [   82.812366]        [<ffffffff81535f89>] driver_probe_device+0x229/0x450
    [   82.812371]        [<ffffffff81536233>] __driver_attach+0x83/0x90
    [   82.812375]        [<ffffffff81533c61>] bus_for_each_dev+0x61/0xa0
    [   82.812380]        [<ffffffff81535879>] driver_attach+0x19/0x20
    [   82.812384]        [<ffffffff8153535f>] bus_add_driver+0x1ef/0x290
    [   82.812388]        [<ffffffff81536e9b>] driver_register+0x5b/0xe0
    [   82.812393]        [<ffffffff8143e83b>] __pci_register_driver+0x5b/0x60
    [   82.812398]        [<ffffffff81514866>] drm_pci_init+0xd6/0x100
    [   82.812402]        [<ffffffffa027c094>] 0xffffffffa027c094
    [   82.812406]        [<ffffffff810003de>] do_one_initcall+0xae/0x1d0
    [   82.812412]        [<ffffffff811595a0>] do_init_module+0x5b/0x1cb
    [   82.812417]        [<ffffffff81106160>] load_module+0x1c20/0x2480
    [   82.812422]        [<ffffffff81106bae>] SyS_finit_module+0x7e/0xa0
    [   82.812428]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.812433]
    -> #0 (&dev->struct_mutex){+.+.+.}:
    [   82.812439]        [<ffffffff810cbe59>] __lock_acquire+0x1fc9/0x20f0
    [   82.812443]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.812456]        [<ffffffff8150d9e7>] drm_gem_mmap+0x1c7/0x270
    [   82.812460]        [<ffffffff81196a14>] mmap_region+0x334/0x580
    [   82.812466]        [<ffffffff81196fc4>] do_mmap+0x364/0x410
    [   82.812470]        [<ffffffff8117b38d>] vm_mmap_pgoff+0x6d/0xa0
    [   82.812474]        [<ffffffff811950f4>] SyS_mmap_pgoff+0x184/0x220
    [   82.812479]        [<ffffffff8100a0fd>] SyS_mmap+0x1d/0x20
    [   82.812484]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.812489]
    other info that might help us debug this:
    
    [   82.812493] Chain exists of:
      &dev->struct_mutex --> s_active#6 --> &mm->mmap_sem
    
    [   82.812502]  Possible unsafe locking scenario:
    
    [   82.812506]        CPU0                    CPU1
    [   82.812508]        ----                    ----
    [   82.812510]   lock(&mm->mmap_sem);
    [   82.812514]                                lock(s_active#6);
    [   82.812519]                                lock(&mm->mmap_sem);
    [   82.812522]   lock(&dev->struct_mutex);
    [   82.812526]
     *** DEADLOCK ***
    
    [   82.812531] 1 lock held by kms_setmode/5859:
    [   82.812533]  #0:  (&mm->mmap_sem){++++++}, at: [<ffffffff8117b364>] vm_mmap_pgoff+0x44/0xa0
    [   82.812541]
    stack backtrace:
    [   82.812547] CPU: 0 PID: 5859 Comm: kms_setmode Not tainted 4.5.0-rc4-gfxbench+ #1
    [   82.812550] Hardware name:                  /NUC5CPYB, BIOS PYBSWCEL.86A.0040.2015.0814.1353 08/14/2015
    [   82.812553]  0000000000000000 ffff880079407bf0 ffffffff813f8505 ffffffff825fb270
    [   82.812560]  ffffffff825c4190 ffff880079407c30 ffffffff810c84ac ffff880079407c90
    [   82.812566]  ffff8800797ed328 ffff8800797ecb00 0000000000000001 ffff8800797ed350
    [   82.812573] Call Trace:
    [   82.812578]  [<ffffffff813f8505>] dump_stack+0x67/0x92
    [   82.812582]  [<ffffffff810c84ac>] print_circular_bug+0x1fc/0x310
    [   82.812586]  [<ffffffff810cbe59>] __lock_acquire+0x1fc9/0x20f0
    [   82.812590]  [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.812594]  [<ffffffff8150d9c1>] ? drm_gem_mmap+0x1a1/0x270
    [   82.812599]  [<ffffffff8150d9e7>] drm_gem_mmap+0x1c7/0x270
    [   82.812603]  [<ffffffff8150d9c1>] ? drm_gem_mmap+0x1a1/0x270
    [   82.812608]  [<ffffffff81196a14>] mmap_region+0x334/0x580
    [   82.812612]  [<ffffffff81196fc4>] do_mmap+0x364/0x410
    [   82.812616]  [<ffffffff8117b38d>] vm_mmap_pgoff+0x6d/0xa0
    [   82.812629]  [<ffffffff811950f4>] SyS_mmap_pgoff+0x184/0x220
    [   82.812633]  [<ffffffff8100a0fd>] SyS_mmap+0x1d/0x20
    [   82.812637]  [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    
    Highly unlikely though this scenario is, we can avoid the issue entirely
    by moving the copy operation from out under the kernfs_get_active()
    tracking by assigning the preallocated buffer its own mutex. The
    temporary buffer allocation doesn't require mutex locking as it is
    entirely local.
    
    The locked section was extended by the addition of the preallocated buf
    to speed up md user operations in
    
    commit 2b75869bba676c248d8d25ae6d2bd9221dfffdb6
    Author: NeilBrown <neilb@suse.de>
    Date:   Mon Oct 13 16:41:28 2014 +1100
    
        sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
    
    Reported-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94350
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: NeilBrown <neilb@suse.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 7247252ee9b1..e1574008adc9 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -190,15 +190,16 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 	char *buf;
 
 	buf = of->prealloc_buf;
-	if (!buf)
+	if (buf)
+		mutex_lock(&of->prealloc_mutex);
+	else
 		buf = kmalloc(len, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
 	/*
 	 * @of->mutex nests outside active ref and is used both to ensure that
-	 * the ops aren't called concurrently for the same open file, and
-	 * to provide exclusive access to ->prealloc_buf (when that exists).
+	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
 	if (!kernfs_get_active(of->kn)) {
@@ -214,21 +215,23 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 	else
 		len = -EINVAL;
 
+	kernfs_put_active(of->kn);
+	mutex_unlock(&of->mutex);
+
 	if (len < 0)
-		goto out_unlock;
+		goto out_free;
 
 	if (copy_to_user(user_buf, buf, len)) {
 		len = -EFAULT;
-		goto out_unlock;
+		goto out_free;
 	}
 
 	*ppos += len;
 
- out_unlock:
-	kernfs_put_active(of->kn);
-	mutex_unlock(&of->mutex);
  out_free:
-	if (buf != of->prealloc_buf)
+	if (buf == of->prealloc_buf)
+		mutex_unlock(&of->prealloc_mutex);
+	else
 		kfree(buf);
 	return len;
 }
@@ -284,15 +287,22 @@ static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
 	}
 
 	buf = of->prealloc_buf;
-	if (!buf)
+	if (buf)
+		mutex_lock(&of->prealloc_mutex);
+	else
 		buf = kmalloc(len + 1, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
+	if (copy_from_user(buf, user_buf, len)) {
+		len = -EFAULT;
+		goto out_free;
+	}
+	buf[len] = '\0';	/* guarantee string termination */
+
 	/*
 	 * @of->mutex nests outside active ref and is used both to ensure that
-	 * the ops aren't called concurrently for the same open file, and
-	 * to provide exclusive access to ->prealloc_buf (when that exists).
+	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
 	if (!kernfs_get_active(of->kn)) {
@@ -301,26 +311,22 @@ static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
 		goto out_free;
 	}
 
-	if (copy_from_user(buf, user_buf, len)) {
-		len = -EFAULT;
-		goto out_unlock;
-	}
-	buf[len] = '\0';	/* guarantee string termination */
-
 	ops = kernfs_ops(of->kn);
 	if (ops->write)
 		len = ops->write(of, buf, len, *ppos);
 	else
 		len = -EINVAL;
 
+	kernfs_put_active(of->kn);
+	mutex_unlock(&of->mutex);
+
 	if (len > 0)
 		*ppos += len;
 
-out_unlock:
-	kernfs_put_active(of->kn);
-	mutex_unlock(&of->mutex);
 out_free:
-	if (buf != of->prealloc_buf)
+	if (buf == of->prealloc_buf)
+		mutex_unlock(&of->prealloc_mutex);
+	else
 		kfree(buf);
 	return len;
 }
@@ -687,6 +693,7 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 		error = -ENOMEM;
 		if (!of->prealloc_buf)
 			goto err_free;
+		mutex_init(&of->prealloc_mutex);
 	}
 
 	/*

commit ba50150e80088e159ac80f0e71243ae2fa0c4901
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Apr 23 17:14:31 2015 +0200

    kernfs: remove outdated and confusing comment
    
    Grabbing the parent is not happening anymore since 2010 (e72ceb8ccac5f7
    "sysfs: Remove sysfs_get/put_active_two"). Remove this confusing
    comment.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 2bacb9988566..7247252ee9b1 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -785,7 +785,6 @@ static unsigned int kernfs_fop_poll(struct file *filp, poll_table *wait)
 	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
 	struct kernfs_open_node *on = kn->attr.open;
 
-	/* need parent for the kobj, grab both */
 	if (!kernfs_get_active(kn))
 		goto trigger;
 

commit 7cff4b1836a9d3f18aadd6e88fd43055e2ff4132
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 16 10:44:52 2015 +1100

    kernfs: handle poll correctly on 'direct_read' files.
    
    Kernfs supports two styles of read: direct_read and seqfile_read.
    
    The latter supports 'poll' correctly thanks to the update of
    '->event' in kernfs_seq_show.
    The former does not as '->event' is never updated on a read.
    
    So add an appropriate update in kernfs_file_direct_read().
    
    This was noticed because some 'md' sysfs attributes were
    recently changed to use direct reads.
    
    Reported-by: Prakash Punnoor <prakash@punnoor.de>
    Reported-by: Torsten Kaiser <just.for.lkml@googlemail.com>
    Fixes: 750f199ee8b578062341e6ddfe36c59ac8ff2dcb
    Signed-off-by: NeilBrown <neilb@suse.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index b684e8a132e6..2bacb9988566 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -207,6 +207,7 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 		goto out_free;
 	}
 
+	of->event = atomic_read(&of->kn->attr.open->event);
 	ops = kernfs_ops(of->kn);
 	if (ops->read)
 		len = ops->read(of, buf, len, *ppos);

commit dfeb0750b630b72b5d4fb2461bc7179eceb54666
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Feb 13 14:36:31 2015 -0800

    kernfs: remove KERNFS_STATIC_NAME
    
    When a new kernfs node is created, KERNFS_STATIC_NAME is used to avoid
    making a separate copy of its name.  It's currently only used for sysfs
    attributes whose filenames are required to stay accessible and unchanged.
    There are rare exceptions where these names are allocated and formatted
    dynamically but for the vast majority of cases they're consts in the
    rodata section.
    
    Now that kernfs is converted to use kstrdup_const() and kfree_const(),
    there's little point in keeping KERNFS_STATIC_NAME around.  Remove it.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index ddc9f9612f16..b684e8a132e6 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -901,7 +901,6 @@ const struct file_operations kernfs_file_fops = {
  * @ops: kernfs operations for the file
  * @priv: private data for the file
  * @ns: optional namespace tag of the file
- * @name_is_static: don't copy file name
  * @key: lockdep key for the file's active_ref, %NULL to disable lockdep
  *
  * Returns the created node on success, ERR_PTR() value on error.
@@ -911,7 +910,6 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 umode_t mode, loff_t size,
 					 const struct kernfs_ops *ops,
 					 void *priv, const void *ns,
-					 bool name_is_static,
 					 struct lock_class_key *key)
 {
 	struct kernfs_node *kn;
@@ -919,8 +917,6 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 	int rc;
 
 	flags = KERNFS_FILE;
-	if (name_is_static)
-		flags |= KERNFS_STATIC_NAME;
 
 	kn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG, flags);
 	if (!kn)

commit 50062175ffc844b8ff9664024c6416a37ad63c77
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 15 05:06:42 2014 -0400

    vm_area_operations: kill ->migrate()
    
    the only instance this method has ever grown was one in kernfs -
    one that call ->migrate() of another vm_ops if it exists.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 697390ea47b8..ddc9f9612f16 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -448,27 +448,6 @@ static struct mempolicy *kernfs_vma_get_policy(struct vm_area_struct *vma,
 	return pol;
 }
 
-static int kernfs_vma_migrate(struct vm_area_struct *vma,
-			      const nodemask_t *from, const nodemask_t *to,
-			      unsigned long flags)
-{
-	struct file *file = vma->vm_file;
-	struct kernfs_open_file *of = kernfs_of(file);
-	int ret;
-
-	if (!of->vm_ops)
-		return 0;
-
-	if (!kernfs_get_active(of->kn))
-		return 0;
-
-	ret = 0;
-	if (of->vm_ops->migrate)
-		ret = of->vm_ops->migrate(vma, from, to, flags);
-
-	kernfs_put_active(of->kn);
-	return ret;
-}
 #endif
 
 static const struct vm_operations_struct kernfs_vm_ops = {
@@ -479,7 +458,6 @@ static const struct vm_operations_struct kernfs_vm_ops = {
 #ifdef CONFIG_NUMA
 	.set_policy	= kernfs_vma_set_policy,
 	.get_policy	= kernfs_vma_get_policy,
-	.migrate	= kernfs_vma_migrate,
 #endif
 };
 

commit 4ef67a8c95f32ed0c8c6ed5fe01d1dd16358350e
Author: NeilBrown <neilb@suse.de>
Date:   Tue Oct 14 16:57:26 2014 +1100

    sysfs/kernfs: make read requests on pre-alloc files use the buffer.
    
    To match the previous patch which used the pre-alloc buffer for
    writes, this patch causes reads to use the same buffer.
    This is not strictly necessary as the current seq_read() will allocate
    on first read, so user-space can trigger the required pre-alloc.  But
    consistency is valuable.
    
    The read function is somewhat simpler than seq_read() and, for example,
    does not support reading from an offset into the file: reads must be
    at the start of the file.
    
    As seq_read() does not use the prealloc buffer, ->seq_show is
    incompatible with ->prealloc and caused an EINVAL return from open().
    sysfs code which calls into kernfs always chooses the correct function.
    
    As the buffer is shared with writes and other reads, the mutex is
    extended to cover the copy_to_user.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 70186e2e692a..697390ea47b8 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -189,13 +189,16 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 	const struct kernfs_ops *ops;
 	char *buf;
 
-	buf = kmalloc(len, GFP_KERNEL);
+	buf = of->prealloc_buf;
+	if (!buf)
+		buf = kmalloc(len, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
 	/*
-	 * @of->mutex nests outside active ref and is primarily to ensure that
-	 * the ops aren't called concurrently for the same open file.
+	 * @of->mutex nests outside active ref and is used both to ensure that
+	 * the ops aren't called concurrently for the same open file, and
+	 * to provide exclusive access to ->prealloc_buf (when that exists).
 	 */
 	mutex_lock(&of->mutex);
 	if (!kernfs_get_active(of->kn)) {
@@ -210,21 +213,22 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 	else
 		len = -EINVAL;
 
-	kernfs_put_active(of->kn);
-	mutex_unlock(&of->mutex);
-
 	if (len < 0)
-		goto out_free;
+		goto out_unlock;
 
 	if (copy_to_user(user_buf, buf, len)) {
 		len = -EFAULT;
-		goto out_free;
+		goto out_unlock;
 	}
 
 	*ppos += len;
 
+ out_unlock:
+	kernfs_put_active(of->kn);
+	mutex_unlock(&of->mutex);
  out_free:
-	kfree(buf);
+	if (buf != of->prealloc_buf)
+		kfree(buf);
 	return len;
 }
 
@@ -690,6 +694,14 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 	 */
 	of->atomic_write_len = ops->atomic_write_len;
 
+	error = -EINVAL;
+	/*
+	 * ->seq_show is incompatible with ->prealloc,
+	 * as seq_read does its own allocation.
+	 * ->read must be used instead.
+	 */
+	if (ops->prealloc && ops->seq_show)
+		goto err_free;
 	if (ops->prealloc) {
 		int len = of->atomic_write_len ?: PAGE_SIZE;
 		of->prealloc_buf = kmalloc(len + 1, GFP_KERNEL);

commit 2b75869bba676c248d8d25ae6d2bd9221dfffdb6
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 13 16:41:28 2014 +1100

    sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
    
    md/raid allows metadata management to be performed in user-space.
    A various times, particularly on device failure, the metadata needs
    to be updated before further writes can be permitted.
    This means that the user-space program which updates metadata much
    not block on writeout, and so must not allocate memory.
    
    mlockall(MCL_CURRENT|MCL_FUTURE) and pre-allocation can avoid all
    memory allocation issues for user-memory, but that does not help
    kernel memory.
    Several kernel objects can be pre-allocated.  e.g. files opened before
    any writes to the array are permitted.
    However some kernel allocation happens in places that cannot be
    pre-allocated.
    In particular, writes to sysfs files (to tell md that it can now
    allow writes to the array) allocate a buffer using GFP_KERNEL.
    
    This patch allows attributes to be marked as "PREALLOC".  In that case
    the maximal buffer is allocated when the file is opened, and then used
    on each write instead of allocating a new buffer.
    
    As the same buffer is now shared for all writes on the same file
    description, the mutex is extended to cover full use of the buffer
    including the copy_from_user().
    
    The new __ATTR_PREALLOC() 'or's a new flag in to the 'mode', which is
    inspected by sysfs_add_file_mode_ns() to determine if the file should be
    marked as requiring prealloc.
    
    Despite the comment, we *do* use ->seq_show together with ->prealloc
    in this patch.  The next patch fixes that.
    
    Signed-off-by: NeilBrown  <neilb@suse.de>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 4429d6d9217f..70186e2e692a 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -106,7 +106,7 @@ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 	const struct kernfs_ops *ops;
 
 	/*
-	 * @of->mutex nests outside active ref and is just to ensure that
+	 * @of->mutex nests outside active ref and is primarily to ensure that
 	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
@@ -194,7 +194,7 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 		return -ENOMEM;
 
 	/*
-	 * @of->mutex nests outside active ref and is just to ensure that
+	 * @of->mutex nests outside active ref and is primarily to ensure that
 	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
@@ -278,19 +278,16 @@ static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
 		len = min_t(size_t, count, PAGE_SIZE);
 	}
 
-	buf = kmalloc(len + 1, GFP_KERNEL);
+	buf = of->prealloc_buf;
+	if (!buf)
+		buf = kmalloc(len + 1, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
-	if (copy_from_user(buf, user_buf, len)) {
-		len = -EFAULT;
-		goto out_free;
-	}
-	buf[len] = '\0';	/* guarantee string termination */
-
 	/*
-	 * @of->mutex nests outside active ref and is just to ensure that
-	 * the ops aren't called concurrently for the same open file.
+	 * @of->mutex nests outside active ref and is used both to ensure that
+	 * the ops aren't called concurrently for the same open file, and
+	 * to provide exclusive access to ->prealloc_buf (when that exists).
 	 */
 	mutex_lock(&of->mutex);
 	if (!kernfs_get_active(of->kn)) {
@@ -299,19 +296,27 @@ static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
 		goto out_free;
 	}
 
+	if (copy_from_user(buf, user_buf, len)) {
+		len = -EFAULT;
+		goto out_unlock;
+	}
+	buf[len] = '\0';	/* guarantee string termination */
+
 	ops = kernfs_ops(of->kn);
 	if (ops->write)
 		len = ops->write(of, buf, len, *ppos);
 	else
 		len = -EINVAL;
 
-	kernfs_put_active(of->kn);
-	mutex_unlock(&of->mutex);
-
 	if (len > 0)
 		*ppos += len;
+
+out_unlock:
+	kernfs_put_active(of->kn);
+	mutex_unlock(&of->mutex);
 out_free:
-	kfree(buf);
+	if (buf != of->prealloc_buf)
+		kfree(buf);
 	return len;
 }
 
@@ -685,6 +690,14 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 	 */
 	of->atomic_write_len = ops->atomic_write_len;
 
+	if (ops->prealloc) {
+		int len = of->atomic_write_len ?: PAGE_SIZE;
+		of->prealloc_buf = kmalloc(len + 1, GFP_KERNEL);
+		error = -ENOMEM;
+		if (!of->prealloc_buf)
+			goto err_free;
+	}
+
 	/*
 	 * Always instantiate seq_file even if read access doesn't use
 	 * seq_file or is not requested.  This unifies private data access
@@ -715,6 +728,7 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 err_close:
 	seq_release(inode, file);
 err_free:
+	kfree(of->prealloc_buf);
 	kfree(of);
 err_out:
 	kernfs_put_active(kn);
@@ -728,6 +742,7 @@ static int kernfs_fop_release(struct inode *inode, struct file *filp)
 
 	kernfs_put_open_node(kn, of);
 	seq_release(inode, filp);
+	kfree(of->prealloc_buf);
 	kfree(of);
 
 	return 0;

commit 8278bd3abd727f894f6e41adc06f1126a23ee1fd
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Jul 4 21:47:53 2014 +0200

    kernfs: kernel-doc warning fix
    
    s/static_name/name_is_static
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index d895b4b7b661..4429d6d9217f 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -896,7 +896,7 @@ const struct file_operations kernfs_file_fops = {
  * @ops: kernfs operations for the file
  * @priv: private data for the file
  * @ns: optional namespace tag of the file
- * @static_name: don't copy file name
+ * @name_is_static: don't copy file name
  * @key: lockdep key for the file's active_ref, %NULL to disable lockdep
  *
  * Returns the created node on success, ERR_PTR() value on error.

commit ecca47ce8294843045e7465d76fee84dbf07a004
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 1 16:41:03 2014 -0400

    kernfs: kernfs_notify() must be useable from non-sleepable contexts
    
    d911d9874801 ("kernfs: make kernfs_notify() trigger inotify events
    too") added fsnotify triggering to kernfs_notify() which requires a
    sleepable context.  There are already existing users of
    kernfs_notify() which invoke it from an atomic context and in general
    it's silly to require a sleepable context for triggering a
    notification.
    
    The following is an invalid context bug triggerd by md invoking
    sysfs_notify() from IO completion path.
    
     BUG: sleeping function called from invalid context at kernel/locking/mutex.c:586
     in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/1
     2 locks held by swapper/1/0:
      #0:  (&(&vblk->vq_lock)->rlock){-.-...}, at: [<ffffffffa0039042>] virtblk_done+0x42/0xe0 [virtio_blk]
      #1:  (&(&bitmap->counts.lock)->rlock){-.....}, at: [<ffffffff81633718>] bitmap_endwrite+0x68/0x240
     irq event stamp: 33518
     hardirqs last  enabled at (33515): [<ffffffff8102544f>] default_idle+0x1f/0x230
     hardirqs last disabled at (33516): [<ffffffff818122ed>] common_interrupt+0x6d/0x72
     softirqs last  enabled at (33518): [<ffffffff810a1272>] _local_bh_enable+0x22/0x50
     softirqs last disabled at (33517): [<ffffffff810a29e0>] irq_enter+0x60/0x80
     CPU: 1 PID: 0 Comm: swapper/1 Not tainted 3.16.0-0.rc2.git2.1.fc21.x86_64 #1
     Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
      0000000000000000 f90db13964f4ee05 ffff88007d403b80 ffffffff81807b4c
      0000000000000000 ffff88007d403ba8 ffffffff810d4f14 0000000000000000
      0000000000441800 ffff880078fa1780 ffff88007d403c38 ffffffff8180caf2
     Call Trace:
      <IRQ>  [<ffffffff81807b4c>] dump_stack+0x4d/0x66
      [<ffffffff810d4f14>] __might_sleep+0x184/0x240
      [<ffffffff8180caf2>] mutex_lock_nested+0x42/0x440
      [<ffffffff812d76a0>] kernfs_notify+0x90/0x150
      [<ffffffff8163377c>] bitmap_endwrite+0xcc/0x240
      [<ffffffffa00de863>] close_write+0x93/0xb0 [raid1]
      [<ffffffffa00df029>] r1_bio_write_done+0x29/0x50 [raid1]
      [<ffffffffa00e0474>] raid1_end_write_request+0xe4/0x260 [raid1]
      [<ffffffff813acb8b>] bio_endio+0x6b/0xa0
      [<ffffffff813b46c4>] blk_update_request+0x94/0x420
      [<ffffffff813bf0ea>] blk_mq_end_io+0x1a/0x70
      [<ffffffffa00392c2>] virtblk_request_done+0x32/0x80 [virtio_blk]
      [<ffffffff813c0648>] __blk_mq_complete_request+0x88/0x120
      [<ffffffff813c070a>] blk_mq_complete_request+0x2a/0x30
      [<ffffffffa0039066>] virtblk_done+0x66/0xe0 [virtio_blk]
      [<ffffffffa002535a>] vring_interrupt+0x3a/0xa0 [virtio_ring]
      [<ffffffff81116177>] handle_irq_event_percpu+0x77/0x340
      [<ffffffff8111647d>] handle_irq_event+0x3d/0x60
      [<ffffffff81119436>] handle_edge_irq+0x66/0x130
      [<ffffffff8101c3e4>] handle_irq+0x84/0x150
      [<ffffffff818146ad>] do_IRQ+0x4d/0xe0
      [<ffffffff818122f2>] common_interrupt+0x72/0x72
      <EOI>  [<ffffffff8105f706>] ? native_safe_halt+0x6/0x10
      [<ffffffff81025454>] default_idle+0x24/0x230
      [<ffffffff81025f9f>] arch_cpu_idle+0xf/0x20
      [<ffffffff810f5adc>] cpu_startup_entry+0x37c/0x7b0
      [<ffffffff8104df1b>] start_secondary+0x25b/0x300
    
    This patch fixes it by punting the notification delivery through a
    work item.  This ends up adding an extra pointer to kernfs_elem_attr
    enlarging kernfs_node by a pointer, which is not ideal but not a very
    big deal either.  If this turns out to be an actual issue, we can move
    kernfs_elem_attr->size to kernfs_node->iattr later.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index e3d37f607f97..d895b4b7b661 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -39,6 +39,19 @@ struct kernfs_open_node {
 	struct list_head	files; /* goes through kernfs_open_file.list */
 };
 
+/*
+ * kernfs_notify() may be called from any context and bounces notifications
+ * through a work item.  To minimize space overhead in kernfs_node, the
+ * pending queue is implemented as a singly linked list of kernfs_nodes.
+ * The list is terminated with the self pointer so that whether a
+ * kernfs_node is on the list or not can be determined by testing the next
+ * pointer for NULL.
+ */
+#define KERNFS_NOTIFY_EOL			((void *)&kernfs_notify_list)
+
+static DEFINE_SPINLOCK(kernfs_notify_lock);
+static struct kernfs_node *kernfs_notify_list = KERNFS_NOTIFY_EOL;
+
 static struct kernfs_open_file *kernfs_of(struct file *file)
 {
 	return ((struct seq_file *)file->private_data)->private;
@@ -783,24 +796,25 @@ static unsigned int kernfs_fop_poll(struct file *filp, poll_table *wait)
 	return DEFAULT_POLLMASK|POLLERR|POLLPRI;
 }
 
-/**
- * kernfs_notify - notify a kernfs file
- * @kn: file to notify
- *
- * Notify @kn such that poll(2) on @kn wakes up.
- */
-void kernfs_notify(struct kernfs_node *kn)
+static void kernfs_notify_workfn(struct work_struct *work)
 {
-	struct kernfs_root *root = kernfs_root(kn);
+	struct kernfs_node *kn;
 	struct kernfs_open_node *on;
 	struct kernfs_super_info *info;
-	unsigned long flags;
-
-	if (WARN_ON(kernfs_type(kn) != KERNFS_FILE))
+repeat:
+	/* pop one off the notify_list */
+	spin_lock_irq(&kernfs_notify_lock);
+	kn = kernfs_notify_list;
+	if (kn == KERNFS_NOTIFY_EOL) {
+		spin_unlock_irq(&kernfs_notify_lock);
 		return;
+	}
+	kernfs_notify_list = kn->attr.notify_next;
+	kn->attr.notify_next = NULL;
+	spin_unlock_irq(&kernfs_notify_lock);
 
 	/* kick poll */
-	spin_lock_irqsave(&kernfs_open_node_lock, flags);
+	spin_lock_irq(&kernfs_open_node_lock);
 
 	on = kn->attr.open;
 	if (on) {
@@ -808,12 +822,12 @@ void kernfs_notify(struct kernfs_node *kn)
 		wake_up_interruptible(&on->poll);
 	}
 
-	spin_unlock_irqrestore(&kernfs_open_node_lock, flags);
+	spin_unlock_irq(&kernfs_open_node_lock);
 
 	/* kick fsnotify */
 	mutex_lock(&kernfs_mutex);
 
-	list_for_each_entry(info, &root->supers, node) {
+	list_for_each_entry(info, &kernfs_root(kn)->supers, node) {
 		struct inode *inode;
 		struct dentry *dentry;
 
@@ -833,6 +847,33 @@ void kernfs_notify(struct kernfs_node *kn)
 	}
 
 	mutex_unlock(&kernfs_mutex);
+	kernfs_put(kn);
+	goto repeat;
+}
+
+/**
+ * kernfs_notify - notify a kernfs file
+ * @kn: file to notify
+ *
+ * Notify @kn such that poll(2) on @kn wakes up.  Maybe be called from any
+ * context.
+ */
+void kernfs_notify(struct kernfs_node *kn)
+{
+	static DECLARE_WORK(kernfs_notify_work, kernfs_notify_workfn);
+	unsigned long flags;
+
+	if (WARN_ON(kernfs_type(kn) != KERNFS_FILE))
+		return;
+
+	spin_lock_irqsave(&kernfs_notify_lock, flags);
+	if (!kn->attr.notify_next) {
+		kernfs_get(kn);
+		kn->attr.notify_next = kernfs_notify_list;
+		kernfs_notify_list = kn;
+		schedule_work(&kernfs_notify_work);
+	}
+	spin_unlock_irqrestore(&kernfs_notify_lock, flags);
 }
 EXPORT_SYMBOL_GPL(kernfs_notify);
 

commit cbfef53360ea88fa7ef9f80def778fba9b05d21e
Merge: d35cc56ddfc9 4b660a7f5c80
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 23 10:13:53 2014 +0900

    Merge 3.15-rc6 into driver-core-next
    
    We want the kernfs fixes in this branch as well for testing.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 555724a831b4a146e7bdf16ecc989cda032b076d
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 12 13:56:27 2014 -0400

    kernfs, sysfs, cgroup: restrict extra perm check on open to sysfs
    
    The kernfs open method - kernfs_fop_open() - inherited extra
    permission checks from sysfs.  While the vfs layer allows ignoring the
    read/write permissions checks if the issuer has CAP_DAC_OVERRIDE,
    sysfs explicitly denied open regardless of the cap if the file doesn't
    have any of the UGO perms of the requested access or doesn't implement
    the requested operation.  It can be debated whether this was a good
    idea or not but the behavior is too subtle and dangerous to change at
    this point.
    
    After cgroup got converted to kernfs, this extra perm check also got
    applied to cgroup breaking libcgroup which opens write-only files with
    O_RDWR as root.  This patch gates the extra open permission check with
    a new flag KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK and enables it for sysfs.
    For sysfs, nothing changes.  For cgroup, root now can perform any
    operation regardless of the permissions as it was before kernfs
    conversion.  Note that kernfs still fails unimplemented operations
    with -EINVAL.
    
    While at it, add comments explaining KERNFS_ROOT flags.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Andrey Wagin <avagin@gmail.com>
    Tested-by: Andrey Wagin <avagin@gmail.com>
    Cc: Li Zefan <lizefan@huawei.com>
    References: http://lkml.kernel.org/g/CANaxB-xUm3rJ-Cbp72q-rQJO5mZe1qK6qXsQM=vh0U8upJ44+A@mail.gmail.com
    Fixes: 2bd59d48ebfb ("cgroup: convert to kernfs")
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index e01ea4a14a01..5e9a80cfc3d8 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -610,6 +610,7 @@ static void kernfs_put_open_node(struct kernfs_node *kn,
 static int kernfs_fop_open(struct inode *inode, struct file *file)
 {
 	struct kernfs_node *kn = file->f_path.dentry->d_fsdata;
+	struct kernfs_root *root = kernfs_root(kn);
 	const struct kernfs_ops *ops;
 	struct kernfs_open_file *of;
 	bool has_read, has_write, has_mmap;
@@ -624,14 +625,16 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 	has_write = ops->write || ops->mmap;
 	has_mmap = ops->mmap;
 
-	/* check perms and supported operations */
-	if ((file->f_mode & FMODE_WRITE) &&
-	    (!(inode->i_mode & S_IWUGO) || !has_write))
-		goto err_out;
+	/* see the flag definition for details */
+	if (root->flags & KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK) {
+		if ((file->f_mode & FMODE_WRITE) &&
+		    (!(inode->i_mode & S_IWUGO) || !has_write))
+			goto err_out;
 
-	if ((file->f_mode & FMODE_READ) &&
-	    (!(inode->i_mode & S_IRUGO) || !has_read))
-		goto err_out;
+		if ((file->f_mode & FMODE_READ) &&
+		    (!(inode->i_mode & S_IRUGO) || !has_read))
+			goto err_out;
+	}
 
 	/* allocate a kernfs_open_file for the file */
 	error = -ENOMEM;

commit d35cc56ddfc948d8df1aa6d41ac345fcec01854d
Merge: 86d56134f1b6 d1db0eea8524
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Apr 27 21:36:39 2014 -0700

    Merge 3.15-rc3 into staging-next

commit b44b2140265ddfde03acbe809336111d31adb0d1
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Apr 20 08:29:21 2014 -0400

    kernfs: add back missing error check in kernfs_fop_mmap()
    
    While updating how mmap enabled kernfs files are handled by lockdep,
    9b2db6e18945 ("sysfs: bail early from kernfs_file_mmap() to avoid
    spurious lockdep warning") inadvertently dropped error return check
    from kernfs_file_mmap().  The intention was just dropping "if
    (ops->mmap)" check as the control won't reach the point if the mmap
    callback isn't implemented, but I mistakenly removed the error return
    check together with it.
    
    This led to Xorg crash on i810 which was reported and bisected to the
    commit and then to the specific change by Tobias.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-and-bisected-by: Tobias Powalowski <tobias.powalowski@googlemail.com>
    Tested-by: Tobias Powalowski <tobias.powalowski@googlemail.com>
    References: http://lkml.kernel.org/g/533D01BD.1010200@googlemail.com
    Cc: stable <stable@vger.kernel.org> # 3.14
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 8034706a7af8..e01ea4a14a01 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -484,6 +484,8 @@ static int kernfs_fop_mmap(struct file *file, struct vm_area_struct *vma)
 
 	ops = kernfs_ops(of->kn);
 	rc = ops->mmap(of, vma);
+	if (rc)
+		goto out_put;
 
 	/*
 	 * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()

commit d911d98748018f7c8facc035ba39c30f5cce6f9c
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Apr 9 11:07:31 2014 -0400

    kernfs: make kernfs_notify() trigger inotify events too
    
    kernfs_notify() is used to indicate either new data is available or
    the content of a file has changed.  It currently only triggers poll
    which may not be the most convenient to monitor especially when there
    are a lot to monitor.  Let's hook it up to fsnotify too so that the
    events can be monitored via inotify too.
    
    fsnotify_modify() requires file * but kernfs_notify() doesn't have any
    specific file associated; however, we can walk all super_blocks
    associated with a kernfs_root and as kernfs always associate one ino
    with inode and one dentry with an inode, it's trivial to look up the
    dentry associated with a given kernfs_node.  As any active monitor
    would pin dentry, just looking up existing dentry is enough.  This
    patch looks up the dentry associated with the specified kernfs_node
    and generates events equivalent to fsnotify_modify().
    
    Note that as fsnotify doesn't provide fsnotify_modify() equivalent
    which can be called with dentry, kernfs_notify() directly calls
    fsnotify_parent() and fsnotify().  It might be better to add a wrapper
    in fsnotify.h instead.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: John McCutchan <john@johnmccutchan.com>
    Cc: Robert Love <rlove@rlove.org>
    Cc: Eric Paris <eparis@parisplace.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 8034706a7af8..98bacd9ea7fd 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -14,6 +14,7 @@
 #include <linux/poll.h>
 #include <linux/pagemap.h>
 #include <linux/sched.h>
+#include <linux/fsnotify.h>
 
 #include "kernfs-internal.h"
 
@@ -785,20 +786,48 @@ static unsigned int kernfs_fop_poll(struct file *filp, poll_table *wait)
  */
 void kernfs_notify(struct kernfs_node *kn)
 {
+	struct kernfs_root *root = kernfs_root(kn);
 	struct kernfs_open_node *on;
+	struct kernfs_super_info *info;
 	unsigned long flags;
 
+	if (WARN_ON(kernfs_type(kn) != KERNFS_FILE))
+		return;
+
+	/* kick poll */
 	spin_lock_irqsave(&kernfs_open_node_lock, flags);
 
-	if (!WARN_ON(kernfs_type(kn) != KERNFS_FILE)) {
-		on = kn->attr.open;
-		if (on) {
-			atomic_inc(&on->event);
-			wake_up_interruptible(&on->poll);
-		}
+	on = kn->attr.open;
+	if (on) {
+		atomic_inc(&on->event);
+		wake_up_interruptible(&on->poll);
 	}
 
 	spin_unlock_irqrestore(&kernfs_open_node_lock, flags);
+
+	/* kick fsnotify */
+	mutex_lock(&kernfs_mutex);
+
+	list_for_each_entry(info, &root->supers, node) {
+		struct inode *inode;
+		struct dentry *dentry;
+
+		inode = ilookup(info->sb, kn->ino);
+		if (!inode)
+			continue;
+
+		dentry = d_find_any_alias(inode);
+		if (dentry) {
+			fsnotify_parent(NULL, dentry, FS_MODIFY);
+			fsnotify(inode, FS_MODIFY, inode, FSNOTIFY_EVENT_INODE,
+				 NULL, 0);
+			dput(dentry);
+		}
+
+		iput(inode);
+	}
+
+	mutex_unlock(&kernfs_mutex);
 }
 EXPORT_SYMBOL_GPL(kernfs_notify);
 

commit b7ce40cff0b9f6597f8318fd761accd92727f61f
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Mar 4 15:38:46 2014 -0500

    kernfs: cache atomic_write_len in kernfs_open_file
    
    While implementing atomic_write_len, 4d3773c4bb41 ("kernfs: implement
    kernfs_ops->atomic_write_len") moved data copy from userland inside
    kernfs_get_active() and kernfs_open_file->mutex so that
    kernfs_ops->atomic_write_len can be accessed before copying buffer
    from userland; unfortunately, this could lead to locking order
    inversion involving mmap_sem if copy_from_user() takes a page fault.
    
      ======================================================
      [ INFO: possible circular locking dependency detected ]
      3.14.0-rc4-next-20140228-sasha-00011-g4077c67-dirty #26 Tainted: G        W
      -------------------------------------------------------
      trinity-c236/10658 is trying to acquire lock:
       (&of->mutex#2){+.+.+.}, at: [<fs/kernfs/file.c:487>] kernfs_fop_mmap+0x54/0x120
    
      but task is already holding lock:
       (&mm->mmap_sem){++++++}, at: [<mm/util.c:397>] vm_mmap_pgoff+0x6e/0xe0
    
      which lock already depends on the new lock.
    
      the existing dependency chain (in reverse order) is:
    
     -> #1 (&mm->mmap_sem){++++++}:
             [<kernel/locking/lockdep.c:1945 kernel/locking/lockdep.c:2131>] validate_chain+0x6c5/0x7b0
             [<kernel/locking/lockdep.c:3182>] __lock_acquire+0x4cd/0x5a0
             [<arch/x86/include/asm/current.h:14 kernel/locking/lockdep.c:3602>] lock_acquire+0x182/0x1d0
             [<mm/memory.c:4188>] might_fault+0x7e/0xb0
             [<arch/x86/include/asm/uaccess.h:713 fs/kernfs/file.c:291>] kernfs_fop_write+0xd8/0x190
             [<fs/read_write.c:473>] vfs_write+0xe3/0x1d0
             [<fs/read_write.c:523 fs/read_write.c:515>] SyS_write+0x5d/0xa0
             [<arch/x86/kernel/entry_64.S:749>] tracesys+0xdd/0xe2
    
     -> #0 (&of->mutex#2){+.+.+.}:
             [<kernel/locking/lockdep.c:1840>] check_prev_add+0x13f/0x560
             [<kernel/locking/lockdep.c:1945 kernel/locking/lockdep.c:2131>] validate_chain+0x6c5/0x7b0
             [<kernel/locking/lockdep.c:3182>] __lock_acquire+0x4cd/0x5a0
             [<arch/x86/include/asm/current.h:14 kernel/locking/lockdep.c:3602>] lock_acquire+0x182/0x1d0
             [<kernel/locking/mutex.c:470 kernel/locking/mutex.c:571>] mutex_lock_nested+0x6a/0x510
             [<fs/kernfs/file.c:487>] kernfs_fop_mmap+0x54/0x120
             [<mm/mmap.c:1573>] mmap_region+0x310/0x5c0
             [<mm/mmap.c:1365>] do_mmap_pgoff+0x385/0x430
             [<mm/util.c:399>] vm_mmap_pgoff+0x8f/0xe0
             [<mm/mmap.c:1416 mm/mmap.c:1374>] SyS_mmap_pgoff+0x1b0/0x210
             [<arch/x86/kernel/sys_x86_64.c:72>] SyS_mmap+0x1d/0x20
             [<arch/x86/kernel/entry_64.S:749>] tracesys+0xdd/0xe2
    
      other info that might help us debug this:
    
       Possible unsafe locking scenario:
    
             CPU0                    CPU1
             ----                    ----
        lock(&mm->mmap_sem);
                                     lock(&of->mutex#2);
                                     lock(&mm->mmap_sem);
        lock(&of->mutex#2);
    
       *** DEADLOCK ***
    
      1 lock held by trinity-c236/10658:
       #0:  (&mm->mmap_sem){++++++}, at: [<mm/util.c:397>] vm_mmap_pgoff+0x6e/0xe0
    
      stack backtrace:
      CPU: 2 PID: 10658 Comm: trinity-c236 Tainted: G        W 3.14.0-rc4-next-20140228-sasha-00011-g4077c67-dirty #26
       0000000000000000 ffff88011911fa48 ffffffff8438e945 0000000000000000
       0000000000000000 ffff88011911fa98 ffffffff811a0109 ffff88011911fab8
       ffff88011911fab8 ffff88011911fa98 ffff880119128cc0 ffff880119128cf8
      Call Trace:
       [<lib/dump_stack.c:52>] dump_stack+0x52/0x7f
       [<kernel/locking/lockdep.c:1213>] print_circular_bug+0x129/0x160
       [<kernel/locking/lockdep.c:1840>] check_prev_add+0x13f/0x560
       [<include/linux/spinlock.h:343 mm/slub.c:1933>] ? deactivate_slab+0x511/0x550
       [<kernel/locking/lockdep.c:1945 kernel/locking/lockdep.c:2131>] validate_chain+0x6c5/0x7b0
       [<kernel/locking/lockdep.c:3182>] __lock_acquire+0x4cd/0x5a0
       [<mm/mmap.c:1552>] ? mmap_region+0x24a/0x5c0
       [<arch/x86/include/asm/current.h:14 kernel/locking/lockdep.c:3602>] lock_acquire+0x182/0x1d0
       [<fs/kernfs/file.c:487>] ? kernfs_fop_mmap+0x54/0x120
       [<kernel/locking/mutex.c:470 kernel/locking/mutex.c:571>] mutex_lock_nested+0x6a/0x510
       [<fs/kernfs/file.c:487>] ? kernfs_fop_mmap+0x54/0x120
       [<kernel/sched/core.c:2477>] ? get_parent_ip+0x11/0x50
       [<fs/kernfs/file.c:487>] ? kernfs_fop_mmap+0x54/0x120
       [<fs/kernfs/file.c:487>] kernfs_fop_mmap+0x54/0x120
       [<mm/mmap.c:1573>] mmap_region+0x310/0x5c0
       [<mm/mmap.c:1365>] do_mmap_pgoff+0x385/0x430
       [<mm/util.c:397>] ? vm_mmap_pgoff+0x6e/0xe0
       [<mm/util.c:399>] vm_mmap_pgoff+0x8f/0xe0
       [<kernel/rcu/update.c:97>] ? __rcu_read_unlock+0x44/0xb0
       [<fs/file.c:641>] ? dup_fd+0x3c0/0x3c0
       [<mm/mmap.c:1416 mm/mmap.c:1374>] SyS_mmap_pgoff+0x1b0/0x210
       [<arch/x86/kernel/sys_x86_64.c:72>] SyS_mmap+0x1d/0x20
       [<arch/x86/kernel/entry_64.S:749>] tracesys+0xdd/0xe2
    
    Fix it by caching atomic_write_len in kernfs_open_file during open so
    that it can be determined without accessing kernfs_ops in
    kernfs_fop_write().  This restores the structure of kernfs_fop_write()
    before 4d3773c4bb41 with updated @len determination logic.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    References: http://lkml.kernel.org/g/53113485.2090407@oracle.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index ddcb471b9cc9..8034706a7af8 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -253,55 +253,50 @@ static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
 {
 	struct kernfs_open_file *of = kernfs_of(file);
 	const struct kernfs_ops *ops;
-	char *buf = NULL;
-	ssize_t len;
-
-	/*
-	 * @of->mutex nests outside active ref and is just to ensure that
-	 * the ops aren't called concurrently for the same open file.
-	 */
-	mutex_lock(&of->mutex);
-	if (!kernfs_get_active(of->kn)) {
-		mutex_unlock(&of->mutex);
-		return -ENODEV;
-	}
-
-	ops = kernfs_ops(of->kn);
-	if (!ops->write) {
-		len = -EINVAL;
-		goto out_unlock;
-	}
+	size_t len;
+	char *buf;
 
-	if (ops->atomic_write_len) {
+	if (of->atomic_write_len) {
 		len = count;
-		if (len > ops->atomic_write_len) {
-			len = -E2BIG;
-			goto out_unlock;
-		}
+		if (len > of->atomic_write_len)
+			return -E2BIG;
 	} else {
 		len = min_t(size_t, count, PAGE_SIZE);
 	}
 
 	buf = kmalloc(len + 1, GFP_KERNEL);
-	if (!buf) {
-		len = -ENOMEM;
-		goto out_unlock;
-	}
+	if (!buf)
+		return -ENOMEM;
 
 	if (copy_from_user(buf, user_buf, len)) {
 		len = -EFAULT;
-		goto out_unlock;
+		goto out_free;
 	}
 	buf[len] = '\0';	/* guarantee string termination */
 
-	len = ops->write(of, buf, len, *ppos);
-out_unlock:
+	/*
+	 * @of->mutex nests outside active ref and is just to ensure that
+	 * the ops aren't called concurrently for the same open file.
+	 */
+	mutex_lock(&of->mutex);
+	if (!kernfs_get_active(of->kn)) {
+		mutex_unlock(&of->mutex);
+		len = -ENODEV;
+		goto out_free;
+	}
+
+	ops = kernfs_ops(of->kn);
+	if (ops->write)
+		len = ops->write(of, buf, len, *ppos);
+	else
+		len = -EINVAL;
+
 	kernfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 
 	if (len > 0)
 		*ppos += len;
-
+out_free:
 	kfree(buf);
 	return len;
 }
@@ -665,6 +660,12 @@ static int kernfs_fop_open(struct inode *inode, struct file *file)
 	of->kn = kn;
 	of->file = file;
 
+	/*
+	 * Write path needs to atomic_write_len outside active reference.
+	 * Cache it in open_file.  See kernfs_fop_write() for details.
+	 */
+	of->atomic_write_len = ops->atomic_write_len;
+
 	/*
 	 * Always instantiate seq_file even if read access doesn't use
 	 * seq_file or is not requested.  This unifies private data access

commit 4d3773c4bb41ed5228f1ab7a4a52b79e17b10515
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:13 2014 -0500

    kernfs: implement kernfs_ops->atomic_write_len
    
    A write to a kernfs_node is buffered through a kernel buffer.  Writes
    <= PAGE_SIZE are performed atomically, while larger ones are executed
    in PAGE_SIZE chunks.  While this is enough for sysfs, cgroup which is
    scheduled to be converted to use kernfs needs a bit more control over
    it.
    
    This patch adds kernfs_ops->atomic_write_len.  If not set (zero), the
    behavior stays the same.  If set, writes upto the size are executed
    atomically and larger writes are rejected with -E2BIG.
    
    A different implementation strategy would be allowing configuring
    chunking size while making the original write size available to the
    write method; however, such strategy, while being more complicated,
    doesn't really buy anything.  If the write implementation has to
    handle chunking, the specific chunk size shouldn't matter all that
    much.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 10a8c91c49d6..ddcb471b9cc9 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -252,19 +252,9 @@ static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
 				size_t count, loff_t *ppos)
 {
 	struct kernfs_open_file *of = kernfs_of(file);
-	ssize_t len = min_t(size_t, count, PAGE_SIZE);
 	const struct kernfs_ops *ops;
-	char *buf;
-
-	buf = kmalloc(len + 1, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (copy_from_user(buf, user_buf, len)) {
-		len = -EFAULT;
-		goto out_free;
-	}
-	buf[len] = '\0';	/* guarantee string termination */
+	char *buf = NULL;
+	ssize_t len;
 
 	/*
 	 * @of->mutex nests outside active ref and is just to ensure that
@@ -273,22 +263,45 @@ static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
 	mutex_lock(&of->mutex);
 	if (!kernfs_get_active(of->kn)) {
 		mutex_unlock(&of->mutex);
-		len = -ENODEV;
-		goto out_free;
+		return -ENODEV;
 	}
 
 	ops = kernfs_ops(of->kn);
-	if (ops->write)
-		len = ops->write(of, buf, len, *ppos);
-	else
+	if (!ops->write) {
 		len = -EINVAL;
+		goto out_unlock;
+	}
+
+	if (ops->atomic_write_len) {
+		len = count;
+		if (len > ops->atomic_write_len) {
+			len = -E2BIG;
+			goto out_unlock;
+		}
+	} else {
+		len = min_t(size_t, count, PAGE_SIZE);
+	}
+
+	buf = kmalloc(len + 1, GFP_KERNEL);
+	if (!buf) {
+		len = -ENOMEM;
+		goto out_unlock;
+	}
 
+	if (copy_from_user(buf, user_buf, len)) {
+		len = -EFAULT;
+		goto out_unlock;
+	}
+	buf[len] = '\0';	/* guarantee string termination */
+
+	len = ops->write(of, buf, len, *ppos);
+out_unlock:
 	kernfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 
 	if (len > 0)
 		*ppos += len;
-out_free:
+
 	kfree(buf);
 	return len;
 }

commit 988cd7afb3f37598891ca70b4c6eb914c338c46a
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:02:58 2014 -0500

    kernfs: remove kernfs_addrm_cxt
    
    kernfs_addrm_cxt and the accompanying kernfs_addrm_start/finish() were
    added because there were operations which should be performed outside
    kernfs_mutex after adding and removing kernfs_nodes.  The necessary
    operations were recorded in kernfs_addrm_cxt and performed by
    kernfs_addrm_finish(); however, after the recent changes which
    relocated deactivation and unmapping so that they're performed
    directly during removal, the only operation kernfs_addrm_finish()
    performs is kernfs_put(), which can be moved inside the removal path
    too.
    
    This patch moves the kernfs_put() of the base ref to __kernfs_remove()
    and remove kernfs_addrm_cxt and kernfs_addrm_start/finish().
    
    * kernfs_add_one() is updated to grab and release kernfs_mutex itself.
      sysfs_addrm_start/finish() invocations around it are removed from
      all users.
    
    * __kernfs_remove() puts an unlinked node directly instead of chaining
      it to kernfs_addrm_cxt.  Its callers are updated to grab and release
      kernfs_mutex instead of calling kernfs_addrm_start/finish() around
      it.
    
    v2: Rebased on top of "kernfs: associate a new kernfs_node with its
        parent on creation" which dropped @parent from kernfs_add_one().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index dbf397bfdff2..10a8c91c49d6 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -820,7 +820,6 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 bool name_is_static,
 					 struct lock_class_key *key)
 {
-	struct kernfs_addrm_cxt acxt;
 	struct kernfs_node *kn;
 	unsigned flags;
 	int rc;
@@ -855,10 +854,7 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 	if (ops->mmap)
 		kn->flags |= KERNFS_HAS_MMAP;
 
-	kernfs_addrm_start(&acxt);
-	rc = kernfs_add_one(&acxt, kn);
-	kernfs_addrm_finish(&acxt);
-
+	rc = kernfs_add_one(kn);
 	if (rc) {
 		kernfs_put(kn);
 		return ERR_PTR(rc);

commit db4aad209bc9aefd91f0a9aeb9e37364088b39ad
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 17 09:58:25 2014 -0500

    kernfs: associate a new kernfs_node with its parent on creation
    
    Once created, a kernfs_node is always destroyed by kernfs_put().
    Since ba7443bc656e ("sysfs, kernfs: implement
    kernfs_create/destroy_root()"), kernfs_put() depends on kernfs_root()
    to locate the ino_ida.  kernfs_root() in turn depends on
    kernfs_node->parent being set for !dir nodes.  This means that
    kernfs_put() of a !dir node requires its ->parent to be initialized.
    
    This leads to oops when a newly created !dir node is destroyed without
    going through kernfs_add_one() or after failing kernfs_add_one()
    before ->parent is set.  kernfs_root() invoked from kernfs_put() will
    try to dereference NULL parent.
    
    Fix it by moving parent association to kernfs_new_node() from
    kernfs_add_one().  kernfs_new_node() now takes @parent instead of
    @root and determines the root from the parent and also sets the new
    node's parent properly.  @parent parameter is removed from
    kernfs_add_one().  As there's no parent when creating the root node,
    __kernfs_new_node() which takes @root as before and doesn't set the
    parent is used in that case.
    
    This ensures that a kernfs_node in any stage in its life has its
    parent associated and thus can be put.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index bdd38854ef65..dbf397bfdff2 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -829,8 +829,7 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 	if (name_is_static)
 		flags |= KERNFS_STATIC_NAME;
 
-	kn = kernfs_new_node(kernfs_root(parent), name,
-			     (mode & S_IALLUGO) | S_IFREG, flags);
+	kn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG, flags);
 	if (!kn)
 		return ERR_PTR(-ENOMEM);
 
@@ -857,7 +856,7 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 		kn->flags |= KERNFS_HAS_MMAP;
 
 	kernfs_addrm_start(&acxt);
-	rc = kernfs_add_one(&acxt, kn, parent);
+	rc = kernfs_add_one(&acxt, kn);
 	kernfs_addrm_finish(&acxt);
 
 	if (rc) {

commit bb305947bdbb67325e1f949183cdd208fc2a7999
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jan 14 09:52:01 2014 -0500

    kernfs: fix get_active failure handling in kernfs_seq_*()
    
    When kernfs_seq_start() fails to obtain an active reference, it
    returns ERR_PTR(-ENODEV).  kernfs_seq_stop() is then invoked with the
    error pointer value; however, it still proceeds to invoke
    kernfs_put_active() on the node leading to unbalanced put.
    
    If kernfs_seq_stop() is called even after active ref failure, it
    should skip invocation of @ops->seq_stop() and put_active.
    Unfortunately, this is a bit complicated because active ref failure
    isn't the only thing which may fail with ERR_PTR(-ENODEV).
    @ops->seq_start/next() may also fail with the error value and
    kernfs_seq_stop() doesn't have a way to tell apart those failures.
    
    Work it around by factoring out the active part of kernfs_seq_stop()
    into kernfs_seq_stop_active() and invoking it directly if
    @ops->seq_start/next() fail with ERR_PTR(-ENODEV) and updating
    kernfs_seq_stop() to skip kernfs_seq_stop_active() on
    ERR_PTR(-ENODEV).  This is a bit nasty but ensures that the active put
    is skipped iff get_active failed in kernfs_seq_start().
    
    tj: This was originally committed as d92d2e6bd72b but got reverted by
        683bb2761fbf along with other kernfs self removal patches.
        However, this one is an independent fix and shouldn't have been
        reverted together.  Reinstate the change.  Sorry about the mess.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 316604cc3a1c..bdd38854ef65 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -54,6 +54,38 @@ static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)
 	return kn->attr.ops;
 }
 
+/*
+ * As kernfs_seq_stop() is also called after kernfs_seq_start() or
+ * kernfs_seq_next() failure, it needs to distinguish whether it's stopping
+ * a seq_file iteration which is fully initialized with an active reference
+ * or an aborted kernfs_seq_start() due to get_active failure.  The
+ * position pointer is the only context for each seq_file iteration and
+ * thus the stop condition should be encoded in it.  As the return value is
+ * directly visible to userland, ERR_PTR(-ENODEV) is the only acceptable
+ * choice to indicate get_active failure.
+ *
+ * Unfortunately, this is complicated due to the optional custom seq_file
+ * operations which may return ERR_PTR(-ENODEV) too.  kernfs_seq_stop()
+ * can't distinguish whether ERR_PTR(-ENODEV) is from get_active failure or
+ * custom seq_file operations and thus can't decide whether put_active
+ * should be performed or not only on ERR_PTR(-ENODEV).
+ *
+ * This is worked around by factoring out the custom seq_stop() and
+ * put_active part into kernfs_seq_stop_active(), skipping it from
+ * kernfs_seq_stop() if ERR_PTR(-ENODEV) while invoking it directly after
+ * custom seq_file operations fail with ERR_PTR(-ENODEV) - this ensures
+ * that kernfs_seq_stop_active() is skipped only after get_active failure.
+ */
+static void kernfs_seq_stop_active(struct seq_file *sf, void *v)
+{
+	struct kernfs_open_file *of = sf->private;
+	const struct kernfs_ops *ops = kernfs_ops(of->kn);
+
+	if (ops->seq_stop)
+		ops->seq_stop(sf, v);
+	kernfs_put_active(of->kn);
+}
+
 static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 {
 	struct kernfs_open_file *of = sf->private;
@@ -69,7 +101,11 @@ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 
 	ops = kernfs_ops(of->kn);
 	if (ops->seq_start) {
-		return ops->seq_start(sf, ppos);
+		void *next = ops->seq_start(sf, ppos);
+		/* see the comment above kernfs_seq_stop_active() */
+		if (next == ERR_PTR(-ENODEV))
+			kernfs_seq_stop_active(sf, next);
+		return next;
 	} else {
 		/*
 		 * The same behavior and code as single_open().  Returns
@@ -85,7 +121,11 @@ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
 	if (ops->seq_next) {
-		return ops->seq_next(sf, v, ppos);
+		void *next = ops->seq_next(sf, v, ppos);
+		/* see the comment above kernfs_seq_stop_active() */
+		if (next == ERR_PTR(-ENODEV))
+			kernfs_seq_stop_active(sf, next);
+		return next;
 	} else {
 		/*
 		 * The same behavior and code as single_open(), always
@@ -99,12 +139,9 @@ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 static void kernfs_seq_stop(struct seq_file *sf, void *v)
 {
 	struct kernfs_open_file *of = sf->private;
-	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
-	if (ops->seq_stop)
-		ops->seq_stop(sf, v);
-
-	kernfs_put_active(of->kn);
+	if (v != ERR_PTR(-ENODEV))
+		kernfs_seq_stop_active(sf, v);
 	mutex_unlock(&of->mutex);
 }
 

commit 683bb2761fbf123b24aed03a1c0d5d7556ec3018
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:49:01 2014 -0800

    Revert "kernfs: fix get_active failure handling in kernfs_seq_*()"
    
    This reverts commit d92d2e6bd72b653f9811e0c9c46307c743b3fc58.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index bdd38854ef65..316604cc3a1c 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -54,38 +54,6 @@ static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)
 	return kn->attr.ops;
 }
 
-/*
- * As kernfs_seq_stop() is also called after kernfs_seq_start() or
- * kernfs_seq_next() failure, it needs to distinguish whether it's stopping
- * a seq_file iteration which is fully initialized with an active reference
- * or an aborted kernfs_seq_start() due to get_active failure.  The
- * position pointer is the only context for each seq_file iteration and
- * thus the stop condition should be encoded in it.  As the return value is
- * directly visible to userland, ERR_PTR(-ENODEV) is the only acceptable
- * choice to indicate get_active failure.
- *
- * Unfortunately, this is complicated due to the optional custom seq_file
- * operations which may return ERR_PTR(-ENODEV) too.  kernfs_seq_stop()
- * can't distinguish whether ERR_PTR(-ENODEV) is from get_active failure or
- * custom seq_file operations and thus can't decide whether put_active
- * should be performed or not only on ERR_PTR(-ENODEV).
- *
- * This is worked around by factoring out the custom seq_stop() and
- * put_active part into kernfs_seq_stop_active(), skipping it from
- * kernfs_seq_stop() if ERR_PTR(-ENODEV) while invoking it directly after
- * custom seq_file operations fail with ERR_PTR(-ENODEV) - this ensures
- * that kernfs_seq_stop_active() is skipped only after get_active failure.
- */
-static void kernfs_seq_stop_active(struct seq_file *sf, void *v)
-{
-	struct kernfs_open_file *of = sf->private;
-	const struct kernfs_ops *ops = kernfs_ops(of->kn);
-
-	if (ops->seq_stop)
-		ops->seq_stop(sf, v);
-	kernfs_put_active(of->kn);
-}
-
 static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 {
 	struct kernfs_open_file *of = sf->private;
@@ -101,11 +69,7 @@ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 
 	ops = kernfs_ops(of->kn);
 	if (ops->seq_start) {
-		void *next = ops->seq_start(sf, ppos);
-		/* see the comment above kernfs_seq_stop_active() */
-		if (next == ERR_PTR(-ENODEV))
-			kernfs_seq_stop_active(sf, next);
-		return next;
+		return ops->seq_start(sf, ppos);
 	} else {
 		/*
 		 * The same behavior and code as single_open().  Returns
@@ -121,11 +85,7 @@ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
 	if (ops->seq_next) {
-		void *next = ops->seq_next(sf, v, ppos);
-		/* see the comment above kernfs_seq_stop_active() */
-		if (next == ERR_PTR(-ENODEV))
-			kernfs_seq_stop_active(sf, next);
-		return next;
+		return ops->seq_next(sf, v, ppos);
 	} else {
 		/*
 		 * The same behavior and code as single_open(), always
@@ -139,9 +99,12 @@ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 static void kernfs_seq_stop(struct seq_file *sf, void *v)
 {
 	struct kernfs_open_file *of = sf->private;
+	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
-	if (v != ERR_PTR(-ENODEV))
-		kernfs_seq_stop_active(sf, v);
+	if (ops->seq_stop)
+		ops->seq_stop(sf, v);
+
+	kernfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 }
 

commit 798c75a0d44cdbd6e3d82a6a676e6de38525b3bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:36:03 2014 -0800

    Revert "kernfs: remove KERNFS_REMOVED"
    
    This reverts commit ae34372eb8408b3d07e870f1939f99007a730d28.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 231a171f48b6..bdd38854ef65 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -856,13 +856,9 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 	if (ops->mmap)
 		kn->flags |= KERNFS_HAS_MMAP;
 
-	rc = -ENOENT;
-	if (kernfs_get_active(parent)) {
-		kernfs_addrm_start(&acxt);
-		rc = kernfs_add_one(&acxt, kn, parent);
-		kernfs_addrm_finish(&acxt);
-		kernfs_put_active(parent);
-	}
+	kernfs_addrm_start(&acxt);
+	rc = kernfs_add_one(&acxt, kn, parent);
+	kernfs_addrm_finish(&acxt);
 
 	if (rc) {
 		kernfs_put(kn);

commit 55f6e30d0a6a8975cc0831e8a4a3715b815b6a2f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:27:16 2014 -0800

    Revert "kernfs: invoke kernfs_unmap_bin_file() directly from __kernfs_remove()"
    
    This reverts commit f601f9a2bf7dc1f7ee18feece4c4e2fc6845d6c4.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 404ffd2f27bc..231a171f48b6 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -700,11 +700,14 @@ static int kernfs_fop_release(struct inode *inode, struct file *filp)
 	return 0;
 }
 
-void kernfs_unmap_file(struct kernfs_node *kn)
+void kernfs_unmap_bin_file(struct kernfs_node *kn)
 {
 	struct kernfs_open_node *on;
 	struct kernfs_open_file *of;
 
+	if (!(kn->flags & KERNFS_HAS_MMAP))
+		return;
+
 	spin_lock_irq(&kernfs_open_node_lock);
 	on = kn->attr.open;
 	if (on)

commit 7653fe9d6cddc3fc5e4220608079006d8ac0054c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:20:56 2014 -0800

    Revert "kernfs: remove kernfs_addrm_cxt"
    
    This reverts commit 99177a34110889a8f2c36420c34e3bcc9bfd8a70.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index ffe1bebf9197..404ffd2f27bc 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -817,6 +817,7 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 bool name_is_static,
 					 struct lock_class_key *key)
 {
+	struct kernfs_addrm_cxt acxt;
 	struct kernfs_node *kn;
 	unsigned flags;
 	int rc;
@@ -852,7 +853,14 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 	if (ops->mmap)
 		kn->flags |= KERNFS_HAS_MMAP;
 
-	rc = kernfs_add_one(kn, parent);
+	rc = -ENOENT;
+	if (kernfs_get_active(parent)) {
+		kernfs_addrm_start(&acxt);
+		rc = kernfs_add_one(&acxt, kn, parent);
+		kernfs_addrm_finish(&acxt);
+		kernfs_put_active(parent);
+	}
+
 	if (rc) {
 		kernfs_put(kn);
 		return ERR_PTR(rc);

commit 99177a34110889a8f2c36420c34e3bcc9bfd8a70
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:24 2014 -0500

    kernfs: remove kernfs_addrm_cxt
    
    kernfs_addrm_cxt and the accompanying kernfs_addrm_start/finish() were
    added because there were operations which should be performed outside
    kernfs_mutex after adding and removing kernfs_nodes.  The necessary
    operations were recorded in kernfs_addrm_cxt and performed by
    kernfs_addrm_finish(); however, after the recent changes which
    relocated deactivation and unmapping so that they're performed
    directly during removal, the only operation kernfs_addrm_finish()
    performs is kernfs_put(), which can be moved inside the removal path
    too.
    
    This patch moves the kernfs_put() of the base ref to __kernfs_remove()
    and remove kernfs_addrm_cxt and kernfs_addrm_start/finish().
    
    * kernfs_add_one() is updated to grab and release the parent's active
      ref and kernfs_mutex itself.  kernfs_get/put_active() and
      kernfs_addrm_start/finish() invocations around it are removed from
      all users.
    
    * __kernfs_remove() puts an unlinked node directly instead of chaining
      it to kernfs_addrm_cxt.  Its callers are updated to grab and release
      kernfs_mutex instead of calling kernfs_addrm_start/finish() around
      it.
    
    v2: Updated to fit the v2 restructuring of removal path.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 404ffd2f27bc..ffe1bebf9197 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -817,7 +817,6 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 bool name_is_static,
 					 struct lock_class_key *key)
 {
-	struct kernfs_addrm_cxt acxt;
 	struct kernfs_node *kn;
 	unsigned flags;
 	int rc;
@@ -853,14 +852,7 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 	if (ops->mmap)
 		kn->flags |= KERNFS_HAS_MMAP;
 
-	rc = -ENOENT;
-	if (kernfs_get_active(parent)) {
-		kernfs_addrm_start(&acxt);
-		rc = kernfs_add_one(&acxt, kn, parent);
-		kernfs_addrm_finish(&acxt);
-		kernfs_put_active(parent);
-	}
-
+	rc = kernfs_add_one(kn, parent);
 	if (rc) {
 		kernfs_put(kn);
 		return ERR_PTR(rc);

commit f601f9a2bf7dc1f7ee18feece4c4e2fc6845d6c4
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:23 2014 -0500

    kernfs: invoke kernfs_unmap_bin_file() directly from __kernfs_remove()
    
    kernfs_unmap_bin_file() is supposed to unmap all memory mappings of
    the target file before kernfs_remove() finishes; however, it currently
    is being called from kernfs_addrm_finish() and has the same race
    problem as the original implementation of deactivation when there are
    multiple removers - only the remover which snatches the node to its
    addrm_cxt->removed list is guaranteed to wait for its completion
    before returning.
    
    It can be fixed by moving kernfs_unmap_bin_file() invocation from
    kernfs_addrm_finish() to __kernfs_remove().  The function may be
    called multiple times but that shouldn't do any harm.
    
    We end up dropping kernfs_mutex in the removal loop and the node may
    be removed inbetween by someone else.  kernfs_unlink_sibling() is
    updated to test whether the node has already been removed and return
    accordingly.  __kernfs_remove() in turn performs post-unlinking
    cleanup only if it actually unlinked the node.
    
    KERNFS_HAS_MMAP test is moved out of the unmap function into
    __kernfs_remove() so that we don't unlock kernfs_mutex unnecessarily.
    While at it, drop the now meaningless "bin" qualifier from the
    function name.
    
    v2: Rewritten to fit the v2 restructuring of removal path.  HAS_MMAP
        test relocated.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 231a171f48b6..404ffd2f27bc 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -700,14 +700,11 @@ static int kernfs_fop_release(struct inode *inode, struct file *filp)
 	return 0;
 }
 
-void kernfs_unmap_bin_file(struct kernfs_node *kn)
+void kernfs_unmap_file(struct kernfs_node *kn)
 {
 	struct kernfs_open_node *on;
 	struct kernfs_open_file *of;
 
-	if (!(kn->flags & KERNFS_HAS_MMAP))
-		return;
-
 	spin_lock_irq(&kernfs_open_node_lock);
 	on = kn->attr.open;
 	if (on)

commit ae34372eb8408b3d07e870f1939f99007a730d28
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:21 2014 -0500

    kernfs: remove KERNFS_REMOVED
    
    KERNFS_REMOVED is used to mark half-initialized and dying nodes so
    that they don't show up in lookups and deny adding new nodes under or
    renaming it; however, its role overlaps those of deactivation and
    removal from rbtree.
    
    It's necessary to deny addition of new children while removal is in
    progress; however, this role considerably intersects with deactivation
    - KERNFS_REMOVED prevents new children while deactivation prevents new
    file operations.  There's no reason to have them separate making
    things more complex than necessary.
    
    KERNFS_REMOVED is also used to decide whether a node is still visible
    to vfs layer, which is rather redundant as equivalent determination
    can be made by testing whether the node is on its parent's children
    rbtree or not.
    
    This patch removes KERNFS_REMOVED.
    
    * Instead of KERNFS_REMOVED, each node now starts its life
      deactivated.  This means that we now use both atomic_add() and
      atomic_sub() on KN_DEACTIVATED_BIAS, which is INT_MIN.  The compiler
      generates an overflow warnings when negating INT_MIN as the negation
      can't be represented as a positive number.  Nothing is actually
      broken but let's bump BIAS by one to avoid the warnings for archs
      which negates the subtrahend..
    
    * KERNFS_REMOVED tests in add and rename paths are replaced with
      kernfs_get/put_active() of the target nodes.  Due to the way the add
      path is structured now, active ref handling is done in the callers
      of kernfs_add_one().  This will be consolidated up later.
    
    * kernfs_remove_one() is updated to deactivate instead of setting
      KERNFS_REMOVED.  This removes deactivation from kernfs_deactivate(),
      which is now renamed to kernfs_drain().
    
    * kernfs_dop_revalidate() now tests RB_EMPTY_NODE(&kn->rb) instead of
      KERNFS_REMOVED and KERNFS_REMOVED test in kernfs_dir_pos() is
      dropped.  A node which is removed from the children rbtree is not
      included in the iteration in the first place.  This means that a
      node may be visible through vfs a bit longer - it's now also visible
      after deactivation until the actual removal.  This slightly enlarged
      window difference doesn't make any difference to the userland.
    
    * Sanity check on KERNFS_REMOVED in kernfs_put() is replaced with
      checks on the active ref.
    
    * Some comment style updates in the affected area.
    
    v2: Reordered before removal path restructuring.  kernfs_active()
        dropped and kernfs_get/put_active() used instead.  RB_EMPTY_NODE()
        used in the lookup paths.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index bdd38854ef65..231a171f48b6 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -856,9 +856,13 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 	if (ops->mmap)
 		kn->flags |= KERNFS_HAS_MMAP;
 
-	kernfs_addrm_start(&acxt);
-	rc = kernfs_add_one(&acxt, kn, parent);
-	kernfs_addrm_finish(&acxt);
+	rc = -ENOENT;
+	if (kernfs_get_active(parent)) {
+		kernfs_addrm_start(&acxt);
+		rc = kernfs_add_one(&acxt, kn, parent);
+		kernfs_addrm_finish(&acxt);
+		kernfs_put_active(parent);
+	}
 
 	if (rc) {
 		kernfs_put(kn);

commit d92d2e6bd72b653f9811e0c9c46307c743b3fc58
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:18 2014 -0500

    kernfs: fix get_active failure handling in kernfs_seq_*()
    
    When kernfs_seq_start() fails to obtain an active reference, it
    returns ERR_PTR(-ENODEV).  kernfs_seq_stop() is then invoked with the
    error pointer value; however, it still proceeds to invoke
    kernfs_put_active() on the node leading to unbalanced put.
    
    If kernfs_seq_stop() is called even after active ref failure, it
    should skip invocation of @ops->seq_stop() and put_active.
    Unfortunately, this is a bit complicated because active ref failure
    isn't the only thing which may fail with ERR_PTR(-ENODEV).
    @ops->seq_start/next() may also fail with the error value and
    kernfs_seq_stop() doesn't have a way to tell apart those failures.
    
    Work it around by factoring out the active part of kernfs_seq_stop()
    into kernfs_seq_stop_active() and invoking it directly if
    @ops->seq_start/next() fail with ERR_PTR(-ENODEV) and updating
    kernfs_seq_stop() to skip kernfs_seq_stop_active() on
    ERR_PTR(-ENODEV).  This is a bit nasty but ensures that the active put
    is skipped iff get_active failed in kernfs_seq_start().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 316604cc3a1c..bdd38854ef65 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -54,6 +54,38 @@ static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)
 	return kn->attr.ops;
 }
 
+/*
+ * As kernfs_seq_stop() is also called after kernfs_seq_start() or
+ * kernfs_seq_next() failure, it needs to distinguish whether it's stopping
+ * a seq_file iteration which is fully initialized with an active reference
+ * or an aborted kernfs_seq_start() due to get_active failure.  The
+ * position pointer is the only context for each seq_file iteration and
+ * thus the stop condition should be encoded in it.  As the return value is
+ * directly visible to userland, ERR_PTR(-ENODEV) is the only acceptable
+ * choice to indicate get_active failure.
+ *
+ * Unfortunately, this is complicated due to the optional custom seq_file
+ * operations which may return ERR_PTR(-ENODEV) too.  kernfs_seq_stop()
+ * can't distinguish whether ERR_PTR(-ENODEV) is from get_active failure or
+ * custom seq_file operations and thus can't decide whether put_active
+ * should be performed or not only on ERR_PTR(-ENODEV).
+ *
+ * This is worked around by factoring out the custom seq_stop() and
+ * put_active part into kernfs_seq_stop_active(), skipping it from
+ * kernfs_seq_stop() if ERR_PTR(-ENODEV) while invoking it directly after
+ * custom seq_file operations fail with ERR_PTR(-ENODEV) - this ensures
+ * that kernfs_seq_stop_active() is skipped only after get_active failure.
+ */
+static void kernfs_seq_stop_active(struct seq_file *sf, void *v)
+{
+	struct kernfs_open_file *of = sf->private;
+	const struct kernfs_ops *ops = kernfs_ops(of->kn);
+
+	if (ops->seq_stop)
+		ops->seq_stop(sf, v);
+	kernfs_put_active(of->kn);
+}
+
 static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 {
 	struct kernfs_open_file *of = sf->private;
@@ -69,7 +101,11 @@ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 
 	ops = kernfs_ops(of->kn);
 	if (ops->seq_start) {
-		return ops->seq_start(sf, ppos);
+		void *next = ops->seq_start(sf, ppos);
+		/* see the comment above kernfs_seq_stop_active() */
+		if (next == ERR_PTR(-ENODEV))
+			kernfs_seq_stop_active(sf, next);
+		return next;
 	} else {
 		/*
 		 * The same behavior and code as single_open().  Returns
@@ -85,7 +121,11 @@ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
 	if (ops->seq_next) {
-		return ops->seq_next(sf, v, ppos);
+		void *next = ops->seq_next(sf, v, ppos);
+		/* see the comment above kernfs_seq_stop_active() */
+		if (next == ERR_PTR(-ENODEV))
+			kernfs_seq_stop_active(sf, next);
+		return next;
 	} else {
 		/*
 		 * The same behavior and code as single_open(), always
@@ -99,12 +139,9 @@ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 static void kernfs_seq_stop(struct seq_file *sf, void *v)
 {
 	struct kernfs_open_file *of = sf->private;
-	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
-	if (ops->seq_stop)
-		ops->seq_stop(sf, v);
-
-	kernfs_put_active(of->kn);
+	if (v != ERR_PTR(-ENODEV))
+		kernfs_seq_stop_active(sf, v);
 	mutex_unlock(&of->mutex);
 }
 

commit 2063d608f5110d120db60e896ec2c70c95bb7978
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 16:02:57 2013 -0500

    kernfs: mark static names with KERNFS_STATIC_NAME
    
    Because sysfs used struct attribute which are supposed to stay
    constant, sysfs didn't copy names when creating regular files.  The
    specified string for name was supposed to stay constant.  Such
    distinction isn't inherent for kernfs.  kernfs_create_file[_ns]()
    should be able to take the same @name as kernfs_create_dir[_ns]()
    
    As there can be huge number of sysfs attributes, we still want to be
    able to use static names for sysfs attributes.  This patch renames
    kernfs_create_file_ns_key() to __kernfs_create_file() and adds
    @name_is_static parameter so that the caller can explicitly indicate
    that @name can be used without copying.  kernfs is updated to use
    KERNFS_STATIC_NAME to distinguish static and copied names.
    
    This patch doesn't introduce any behavior changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 053cfd9a6a40..316604cc3a1c 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -762,7 +762,7 @@ const struct file_operations kernfs_file_fops = {
 };
 
 /**
- * kernfs_create_file_ns_key - create a file
+ * __kernfs_create_file - kernfs internal function to create a file
  * @parent: directory to create the file in
  * @name: name of the file
  * @mode: mode of the file
@@ -770,23 +770,30 @@ const struct file_operations kernfs_file_fops = {
  * @ops: kernfs operations for the file
  * @priv: private data for the file
  * @ns: optional namespace tag of the file
+ * @static_name: don't copy file name
  * @key: lockdep key for the file's active_ref, %NULL to disable lockdep
  *
  * Returns the created node on success, ERR_PTR() value on error.
  */
-struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
-					      const char *name,
-					      umode_t mode, loff_t size,
-					      const struct kernfs_ops *ops,
-					      void *priv, const void *ns,
-					      struct lock_class_key *key)
+struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
+					 const char *name,
+					 umode_t mode, loff_t size,
+					 const struct kernfs_ops *ops,
+					 void *priv, const void *ns,
+					 bool name_is_static,
+					 struct lock_class_key *key)
 {
 	struct kernfs_addrm_cxt acxt;
 	struct kernfs_node *kn;
+	unsigned flags;
 	int rc;
 
+	flags = KERNFS_FILE;
+	if (name_is_static)
+		flags |= KERNFS_STATIC_NAME;
+
 	kn = kernfs_new_node(kernfs_root(parent), name,
-			     (mode & S_IALLUGO) | S_IFREG, KERNFS_FILE);
+			     (mode & S_IALLUGO) | S_IFREG, flags);
 	if (!kn)
 		return ERR_PTR(-ENOMEM);
 

commit c637b8acbe079edb477d887041755b489036f146
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:58 2013 -0500

    kernfs: s/sysfs/kernfs/ in internal functions and whatever is left
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_*()/kernfs_*()/ in all internal functions
    * s/sysfs/kernfs/ in internal strings, comments and whatever is remaining
    * Uniformly rename various vfs operations so that they're consistently
      named and distinguishable.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 32364ddb24de..053cfd9a6a40 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -64,7 +64,7 @@ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		return ERR_PTR(-ENODEV);
 
 	ops = kernfs_ops(of->kn);
@@ -104,7 +104,7 @@ static void kernfs_seq_stop(struct seq_file *sf, void *v)
 	if (ops->seq_stop)
 		ops->seq_stop(sf, v);
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 }
 
@@ -147,7 +147,7 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
-	if (!sysfs_get_active(of->kn)) {
+	if (!kernfs_get_active(of->kn)) {
 		len = -ENODEV;
 		mutex_unlock(&of->mutex);
 		goto out_free;
@@ -159,7 +159,7 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 	else
 		len = -EINVAL;
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 
 	if (len < 0)
@@ -178,14 +178,14 @@ static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 }
 
 /**
- * kernfs_file_read - kernfs vfs read callback
+ * kernfs_fop_read - kernfs vfs read callback
  * @file: file pointer
  * @user_buf: data to write
  * @count: number of bytes
  * @ppos: starting offset
  */
-static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
-				size_t count, loff_t *ppos)
+static ssize_t kernfs_fop_read(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
 {
 	struct kernfs_open_file *of = kernfs_of(file);
 
@@ -196,7 +196,7 @@ static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
 }
 
 /**
- * kernfs_file_write - kernfs vfs write callback
+ * kernfs_fop_write - kernfs vfs write callback
  * @file: file pointer
  * @user_buf: data to write
  * @count: number of bytes
@@ -211,8 +211,8 @@ static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
  * modify only the the value you're changing, then write entire buffer
  * back.
  */
-static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
-				 size_t count, loff_t *ppos)
+static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,
+				size_t count, loff_t *ppos)
 {
 	struct kernfs_open_file *of = kernfs_of(file);
 	ssize_t len = min_t(size_t, count, PAGE_SIZE);
@@ -234,7 +234,7 @@ static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
 	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
-	if (!sysfs_get_active(of->kn)) {
+	if (!kernfs_get_active(of->kn)) {
 		mutex_unlock(&of->mutex);
 		len = -ENODEV;
 		goto out_free;
@@ -246,7 +246,7 @@ static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
 	else
 		len = -EINVAL;
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 
 	if (len > 0)
@@ -264,13 +264,13 @@ static void kernfs_vma_open(struct vm_area_struct *vma)
 	if (!of->vm_ops)
 		return;
 
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		return;
 
 	if (of->vm_ops->open)
 		of->vm_ops->open(vma);
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 }
 
 static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
@@ -282,14 +282,14 @@ static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 	if (!of->vm_ops)
 		return VM_FAULT_SIGBUS;
 
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		return VM_FAULT_SIGBUS;
 
 	ret = VM_FAULT_SIGBUS;
 	if (of->vm_ops->fault)
 		ret = of->vm_ops->fault(vma, vmf);
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	return ret;
 }
 
@@ -303,7 +303,7 @@ static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
 	if (!of->vm_ops)
 		return VM_FAULT_SIGBUS;
 
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		return VM_FAULT_SIGBUS;
 
 	ret = 0;
@@ -312,7 +312,7 @@ static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
 	else
 		file_update_time(file);
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	return ret;
 }
 
@@ -326,14 +326,14 @@ static int kernfs_vma_access(struct vm_area_struct *vma, unsigned long addr,
 	if (!of->vm_ops)
 		return -EINVAL;
 
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		return -EINVAL;
 
 	ret = -EINVAL;
 	if (of->vm_ops->access)
 		ret = of->vm_ops->access(vma, addr, buf, len, write);
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	return ret;
 }
 
@@ -348,14 +348,14 @@ static int kernfs_vma_set_policy(struct vm_area_struct *vma,
 	if (!of->vm_ops)
 		return 0;
 
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		return -EINVAL;
 
 	ret = 0;
 	if (of->vm_ops->set_policy)
 		ret = of->vm_ops->set_policy(vma, new);
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	return ret;
 }
 
@@ -369,14 +369,14 @@ static struct mempolicy *kernfs_vma_get_policy(struct vm_area_struct *vma,
 	if (!of->vm_ops)
 		return vma->vm_policy;
 
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		return vma->vm_policy;
 
 	pol = vma->vm_policy;
 	if (of->vm_ops->get_policy)
 		pol = of->vm_ops->get_policy(vma, addr);
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	return pol;
 }
 
@@ -391,14 +391,14 @@ static int kernfs_vma_migrate(struct vm_area_struct *vma,
 	if (!of->vm_ops)
 		return 0;
 
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		return 0;
 
 	ret = 0;
 	if (of->vm_ops->migrate)
 		ret = of->vm_ops->migrate(vma, from, to, flags);
 
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 	return ret;
 }
 #endif
@@ -415,7 +415,7 @@ static const struct vm_operations_struct kernfs_vm_ops = {
 #endif
 };
 
-static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
+static int kernfs_fop_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	struct kernfs_open_file *of = kernfs_of(file);
 	const struct kernfs_ops *ops;
@@ -434,7 +434,7 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	mutex_lock(&of->mutex);
 
 	rc = -ENODEV;
-	if (!sysfs_get_active(of->kn))
+	if (!kernfs_get_active(of->kn))
 		goto out_unlock;
 
 	ops = kernfs_ops(of->kn);
@@ -465,7 +465,7 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	of->vm_ops = vma->vm_ops;
 	vma->vm_ops = &kernfs_vm_ops;
 out_put:
-	sysfs_put_active(of->kn);
+	kernfs_put_active(of->kn);
 out_unlock:
 	mutex_unlock(&of->mutex);
 
@@ -473,7 +473,7 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 }
 
 /**
- *	sysfs_get_open_dirent - get or create kernfs_open_node
+ *	kernfs_get_open_node - get or create kernfs_open_node
  *	@kn: target kernfs_node
  *	@of: kernfs_open_file for this instance of open
  *
@@ -486,8 +486,8 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
  *	RETURNS:
  *	0 on success, -errno on failure.
  */
-static int sysfs_get_open_dirent(struct kernfs_node *kn,
-				 struct kernfs_open_file *of)
+static int kernfs_get_open_node(struct kernfs_node *kn,
+				struct kernfs_open_file *of)
 {
 	struct kernfs_open_node *on, *new_on = NULL;
 
@@ -527,7 +527,7 @@ static int sysfs_get_open_dirent(struct kernfs_node *kn,
 }
 
 /**
- *	sysfs_put_open_dirent - put kernfs_open_node
+ *	kernfs_put_open_node - put kernfs_open_node
  *	@kn: target kernfs_nodet
  *	@of: associated kernfs_open_file
  *
@@ -537,8 +537,8 @@ static int sysfs_get_open_dirent(struct kernfs_node *kn,
  *	LOCKING:
  *	None.
  */
-static void sysfs_put_open_dirent(struct kernfs_node *kn,
-				  struct kernfs_open_file *of)
+static void kernfs_put_open_node(struct kernfs_node *kn,
+				 struct kernfs_open_file *of)
 {
 	struct kernfs_open_node *on = kn->attr.open;
 	unsigned long flags;
@@ -560,7 +560,7 @@ static void sysfs_put_open_dirent(struct kernfs_node *kn,
 	kfree(on);
 }
 
-static int kernfs_file_open(struct inode *inode, struct file *file)
+static int kernfs_fop_open(struct inode *inode, struct file *file)
 {
 	struct kernfs_node *kn = file->f_path.dentry->d_fsdata;
 	const struct kernfs_ops *ops;
@@ -568,7 +568,7 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 	bool has_read, has_write, has_mmap;
 	int error = -EACCES;
 
-	if (!sysfs_get_active(kn))
+	if (!kernfs_get_active(kn))
 		return -ENODEV;
 
 	ops = kernfs_ops(kn);
@@ -633,13 +633,13 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 	if (file->f_mode & FMODE_WRITE)
 		file->f_mode |= FMODE_PWRITE;
 
-	/* make sure we have open dirent struct */
-	error = sysfs_get_open_dirent(kn, of);
+	/* make sure we have open node struct */
+	error = kernfs_get_open_node(kn, of);
 	if (error)
 		goto err_close;
 
 	/* open succeeded, put active references */
-	sysfs_put_active(kn);
+	kernfs_put_active(kn);
 	return 0;
 
 err_close:
@@ -647,23 +647,23 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 err_free:
 	kfree(of);
 err_out:
-	sysfs_put_active(kn);
+	kernfs_put_active(kn);
 	return error;
 }
 
-static int kernfs_file_release(struct inode *inode, struct file *filp)
+static int kernfs_fop_release(struct inode *inode, struct file *filp)
 {
 	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
 	struct kernfs_open_file *of = kernfs_of(filp);
 
-	sysfs_put_open_dirent(kn, of);
+	kernfs_put_open_node(kn, of);
 	seq_release(inode, filp);
 	kfree(of);
 
 	return 0;
 }
 
-void sysfs_unmap_bin_file(struct kernfs_node *kn)
+void kernfs_unmap_bin_file(struct kernfs_node *kn)
 {
 	struct kernfs_open_node *on;
 	struct kernfs_open_file *of;
@@ -686,10 +686,11 @@ void sysfs_unmap_bin_file(struct kernfs_node *kn)
 	}
 	mutex_unlock(&kernfs_open_file_mutex);
 
-	sysfs_put_open_dirent(kn, NULL);
+	kernfs_put_open_node(kn, NULL);
 }
 
-/* Sysfs attribute files are pollable.  The idea is that you read
+/*
+ * Kernfs attribute files are pollable.  The idea is that you read
  * the content and then you use 'poll' or 'select' to wait for
  * the content to change.  When the content changes (assuming the
  * manager for the kobject supports notification), poll will
@@ -702,19 +703,19 @@ void sysfs_unmap_bin_file(struct kernfs_node *kn)
  * to see if it supports poll (Neither 'poll' nor 'select' return
  * an appropriate error code).  When in doubt, set a suitable timeout value.
  */
-static unsigned int kernfs_file_poll(struct file *filp, poll_table *wait)
+static unsigned int kernfs_fop_poll(struct file *filp, poll_table *wait)
 {
 	struct kernfs_open_file *of = kernfs_of(filp);
 	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
 	struct kernfs_open_node *on = kn->attr.open;
 
 	/* need parent for the kobj, grab both */
-	if (!sysfs_get_active(kn))
+	if (!kernfs_get_active(kn))
 		goto trigger;
 
 	poll_wait(filp, &on->poll, wait);
 
-	sysfs_put_active(kn);
+	kernfs_put_active(kn);
 
 	if (of->event != atomic_read(&on->event))
 		goto trigger;
@@ -751,13 +752,13 @@ void kernfs_notify(struct kernfs_node *kn)
 EXPORT_SYMBOL_GPL(kernfs_notify);
 
 const struct file_operations kernfs_file_fops = {
-	.read		= kernfs_file_read,
-	.write		= kernfs_file_write,
+	.read		= kernfs_fop_read,
+	.write		= kernfs_fop_write,
 	.llseek		= generic_file_llseek,
-	.mmap		= kernfs_file_mmap,
-	.open		= kernfs_file_open,
-	.release	= kernfs_file_release,
-	.poll		= kernfs_file_poll,
+	.mmap		= kernfs_fop_mmap,
+	.open		= kernfs_fop_open,
+	.release	= kernfs_fop_release,
+	.poll		= kernfs_fop_poll,
 };
 
 /**
@@ -784,8 +785,8 @@ struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
 	struct kernfs_node *kn;
 	int rc;
 
-	kn = sysfs_new_dirent(kernfs_root(parent), name,
-			      (mode & S_IALLUGO) | S_IFREG, KERNFS_FILE);
+	kn = kernfs_new_node(kernfs_root(parent), name,
+			     (mode & S_IALLUGO) | S_IFREG, KERNFS_FILE);
 	if (!kn)
 		return ERR_PTR(-ENOMEM);
 
@@ -811,9 +812,9 @@ struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
 	if (ops->mmap)
 		kn->flags |= KERNFS_HAS_MMAP;
 
-	sysfs_addrm_start(&acxt);
-	rc = sysfs_add_one(&acxt, kn, parent);
-	sysfs_addrm_finish(&acxt);
+	kernfs_addrm_start(&acxt);
+	rc = kernfs_add_one(&acxt, kn, parent);
+	kernfs_addrm_finish(&acxt);
 
 	if (rc) {
 		kernfs_put(kn);

commit a797bfc30532388e8a11ca726df60cdd77aa8675
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:57 2013 -0500

    kernfs: s/sysfs/kernfs/ in global variables
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_mutex/kernfs_mutex/
    * s/sysfs_dentry_ops/kernfs_dops/
    * s/sysfs_dir_operations/kernfs_dir_fops/
    * s/sysfs_dir_inode_operations/kernfs_dir_iops/
    * s/kernfs_file_operations/kernfs_file_fops/ - renamed for consistency
    * s/sysfs_symlink_inode_operations/kernfs_symlink_iops/
    * s/sysfs_aops/kernfs_aops/
    * s/sysfs_backing_dev_info/kernfs_bdi/
    * s/sysfs_inode_operations/kernfs_iops/
    * s/sysfs_dir_cachep/kernfs_node_cache/
    * s/sysfs_ops/kernfs_sops/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index abe93e12089c..32364ddb24de 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -750,7 +750,7 @@ void kernfs_notify(struct kernfs_node *kn)
 }
 EXPORT_SYMBOL_GPL(kernfs_notify);
 
-const struct file_operations kernfs_file_operations = {
+const struct file_operations kernfs_file_fops = {
 	.read		= kernfs_file_read,
 	.write		= kernfs_file_write,
 	.llseek		= generic_file_llseek,

commit df23fc39bce03bb26e63bea57fc5f5bf6882d74b
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:56 2013 -0500

    kernfs: s/sysfs/kernfs/ in constants
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/SYSFS_DIR/KERNFS_DIR/
    * s/SYSFS_KOBJ_ATTR/KERNFS_FILE/
    * s/SYSFS_KOBJ_LINK/KERNFS_LINK/
    * s/SYSFS_{TYPE_FLAGS}/KERNFS_{TYPE_FLAGS}/
    * s/SYSFS_FLAG_{FLAG}/KERNFS_{FLAG}/
    * s/sysfs_type()/kernfs_type()/
    * s/SD_DEACTIVATED_BIAS/KN_DEACTIVATED_BIAS/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 2714a394cd81..abe93e12089c 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -49,7 +49,7 @@ static struct kernfs_open_file *kernfs_of(struct file *file)
  */
 static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)
 {
-	if (kn->flags & SYSFS_FLAG_LOCKDEP)
+	if (kn->flags & KERNFS_LOCKDEP)
 		lockdep_assert_held(kn);
 	return kn->attr.ops;
 }
@@ -189,7 +189,7 @@ static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
 {
 	struct kernfs_open_file *of = kernfs_of(file);
 
-	if (of->kn->flags & SYSFS_FLAG_HAS_SEQ_SHOW)
+	if (of->kn->flags & KERNFS_HAS_SEQ_SHOW)
 		return seq_read(file, user_buf, count, ppos);
 	else
 		return kernfs_file_direct_read(of, user_buf, count, ppos);
@@ -428,7 +428,7 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	 * without grabbing @of->mutex by testing HAS_MMAP flag.  See the
 	 * comment in kernfs_file_open() for more details.
 	 */
-	if (!(of->kn->flags & SYSFS_FLAG_HAS_MMAP))
+	if (!(of->kn->flags & KERNFS_HAS_MMAP))
 		return -ENODEV;
 
 	mutex_lock(&of->mutex);
@@ -668,7 +668,7 @@ void sysfs_unmap_bin_file(struct kernfs_node *kn)
 	struct kernfs_open_node *on;
 	struct kernfs_open_file *of;
 
-	if (!(kn->flags & SYSFS_FLAG_HAS_MMAP))
+	if (!(kn->flags & KERNFS_HAS_MMAP))
 		return;
 
 	spin_lock_irq(&kernfs_open_node_lock);
@@ -738,7 +738,7 @@ void kernfs_notify(struct kernfs_node *kn)
 
 	spin_lock_irqsave(&kernfs_open_node_lock, flags);
 
-	if (!WARN_ON(sysfs_type(kn) != SYSFS_KOBJ_ATTR)) {
+	if (!WARN_ON(kernfs_type(kn) != KERNFS_FILE)) {
 		on = kn->attr.open;
 		if (on) {
 			atomic_inc(&on->event);
@@ -785,7 +785,7 @@ struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
 	int rc;
 
 	kn = sysfs_new_dirent(kernfs_root(parent), name,
-			      (mode & S_IALLUGO) | S_IFREG, SYSFS_KOBJ_ATTR);
+			      (mode & S_IALLUGO) | S_IFREG, KERNFS_FILE);
 	if (!kn)
 		return ERR_PTR(-ENOMEM);
 
@@ -797,7 +797,7 @@ struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	if (key) {
 		lockdep_init_map(&kn->dep_map, "s_active", key, 0);
-		kn->flags |= SYSFS_FLAG_LOCKDEP;
+		kn->flags |= KERNFS_LOCKDEP;
 	}
 #endif
 
@@ -807,9 +807,9 @@ struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
 	 * ref.  Cache their existence in flags.
 	 */
 	if (ops->seq_show)
-		kn->flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
+		kn->flags |= KERNFS_HAS_SEQ_SHOW;
 	if (ops->mmap)
-		kn->flags |= SYSFS_FLAG_HAS_MMAP;
+		kn->flags |= KERNFS_HAS_MMAP;
 
 	sysfs_addrm_start(&acxt);
 	rc = sysfs_add_one(&acxt, kn, parent);

commit c525aaddc366df23eb095d58a2bdf11cce62a98b
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:55 2013 -0500

    kernfs: s/sysfs/kernfs/ in various data structures
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_open_dirent/kernfs_open_node/
    * s/sysfs_open_file/kernfs_open_file/
    * s/sysfs_inode_attrs/kernfs_iattrs/
    * s/sysfs_addrm_cxt/kernfs_addrm_cxt/
    * s/sysfs_super_info/kernfs_super_info/
    * s/sysfs_info()/kernfs_info()/
    * s/sysfs_open_dirent_lock/kernfs_open_node_lock/
    * s/sysfs_open_file_mutex/kernfs_open_file_mutex/
    * s/sysfs_of()/kernfs_of()/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 5277021196a7..2714a394cd81 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -18,27 +18,27 @@
 #include "kernfs-internal.h"
 
 /*
- * There's one sysfs_open_file for each open file and one sysfs_open_dirent
+ * There's one kernfs_open_file for each open file and one kernfs_open_node
  * for each kernfs_node with one or more open files.
  *
- * kernfs_node->attr.open points to sysfs_open_dirent.  attr.open is
- * protected by sysfs_open_dirent_lock.
+ * kernfs_node->attr.open points to kernfs_open_node.  attr.open is
+ * protected by kernfs_open_node_lock.
  *
  * filp->private_data points to seq_file whose ->private points to
- * sysfs_open_file.  sysfs_open_files are chained at
- * sysfs_open_dirent->files, which is protected by sysfs_open_file_mutex.
+ * kernfs_open_file.  kernfs_open_files are chained at
+ * kernfs_open_node->files, which is protected by kernfs_open_file_mutex.
  */
-static DEFINE_SPINLOCK(sysfs_open_dirent_lock);
-static DEFINE_MUTEX(sysfs_open_file_mutex);
+static DEFINE_SPINLOCK(kernfs_open_node_lock);
+static DEFINE_MUTEX(kernfs_open_file_mutex);
 
-struct sysfs_open_dirent {
+struct kernfs_open_node {
 	atomic_t		refcnt;
 	atomic_t		event;
 	wait_queue_head_t	poll;
-	struct list_head	files; /* goes through sysfs_open_file.list */
+	struct list_head	files; /* goes through kernfs_open_file.list */
 };
 
-static struct sysfs_open_file *sysfs_of(struct file *file)
+static struct kernfs_open_file *kernfs_of(struct file *file)
 {
 	return ((struct seq_file *)file->private_data)->private;
 }
@@ -56,7 +56,7 @@ static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)
 
 static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 {
-	struct sysfs_open_file *of = sf->private;
+	struct kernfs_open_file *of = sf->private;
 	const struct kernfs_ops *ops;
 
 	/*
@@ -81,7 +81,7 @@ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 
 static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 {
-	struct sysfs_open_file *of = sf->private;
+	struct kernfs_open_file *of = sf->private;
 	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
 	if (ops->seq_next) {
@@ -98,7 +98,7 @@ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 
 static void kernfs_seq_stop(struct seq_file *sf, void *v)
 {
-	struct sysfs_open_file *of = sf->private;
+	struct kernfs_open_file *of = sf->private;
 	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
 	if (ops->seq_stop)
@@ -110,7 +110,7 @@ static void kernfs_seq_stop(struct seq_file *sf, void *v)
 
 static int kernfs_seq_show(struct seq_file *sf, void *v)
 {
-	struct sysfs_open_file *of = sf->private;
+	struct kernfs_open_file *of = sf->private;
 
 	of->event = atomic_read(&of->kn->attr.open->event);
 
@@ -130,7 +130,7 @@ static const struct seq_operations kernfs_seq_ops = {
  * it difficult to use seq_file.  Implement simplistic custom buffering for
  * bin files.
  */
-static ssize_t kernfs_file_direct_read(struct sysfs_open_file *of,
+static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,
 				       char __user *user_buf, size_t count,
 				       loff_t *ppos)
 {
@@ -187,7 +187,7 @@ static ssize_t kernfs_file_direct_read(struct sysfs_open_file *of,
 static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
 				size_t count, loff_t *ppos)
 {
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 
 	if (of->kn->flags & SYSFS_FLAG_HAS_SEQ_SHOW)
 		return seq_read(file, user_buf, count, ppos);
@@ -214,7 +214,7 @@ static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
 static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
 				 size_t count, loff_t *ppos)
 {
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 	ssize_t len = min_t(size_t, count, PAGE_SIZE);
 	const struct kernfs_ops *ops;
 	char *buf;
@@ -259,7 +259,7 @@ static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
 static void kernfs_vma_open(struct vm_area_struct *vma)
 {
 	struct file *file = vma->vm_file;
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 
 	if (!of->vm_ops)
 		return;
@@ -276,7 +276,7 @@ static void kernfs_vma_open(struct vm_area_struct *vma)
 static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 	struct file *file = vma->vm_file;
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 	int ret;
 
 	if (!of->vm_ops)
@@ -297,7 +297,7 @@ static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
 				   struct vm_fault *vmf)
 {
 	struct file *file = vma->vm_file;
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 	int ret;
 
 	if (!of->vm_ops)
@@ -320,7 +320,7 @@ static int kernfs_vma_access(struct vm_area_struct *vma, unsigned long addr,
 			     void *buf, int len, int write)
 {
 	struct file *file = vma->vm_file;
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 	int ret;
 
 	if (!of->vm_ops)
@@ -342,7 +342,7 @@ static int kernfs_vma_set_policy(struct vm_area_struct *vma,
 				 struct mempolicy *new)
 {
 	struct file *file = vma->vm_file;
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 	int ret;
 
 	if (!of->vm_ops)
@@ -363,7 +363,7 @@ static struct mempolicy *kernfs_vma_get_policy(struct vm_area_struct *vma,
 					       unsigned long addr)
 {
 	struct file *file = vma->vm_file;
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 	struct mempolicy *pol;
 
 	if (!of->vm_ops)
@@ -385,7 +385,7 @@ static int kernfs_vma_migrate(struct vm_area_struct *vma,
 			      unsigned long flags)
 {
 	struct file *file = vma->vm_file;
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 	int ret;
 
 	if (!of->vm_ops)
@@ -417,7 +417,7 @@ static const struct vm_operations_struct kernfs_vm_ops = {
 
 static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct sysfs_open_file *of = sysfs_of(file);
+	struct kernfs_open_file *of = kernfs_of(file);
 	const struct kernfs_ops *ops;
 	int rc;
 
@@ -473,9 +473,9 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 }
 
 /**
- *	sysfs_get_open_dirent - get or create sysfs_open_dirent
+ *	sysfs_get_open_dirent - get or create kernfs_open_node
  *	@kn: target kernfs_node
- *	@of: sysfs_open_file for this instance of open
+ *	@of: kernfs_open_file for this instance of open
  *
  *	If @kn->attr.open exists, increment its reference count; otherwise,
  *	create one.  @of is chained to the files list.
@@ -487,49 +487,49 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
  *	0 on success, -errno on failure.
  */
 static int sysfs_get_open_dirent(struct kernfs_node *kn,
-				 struct sysfs_open_file *of)
+				 struct kernfs_open_file *of)
 {
-	struct sysfs_open_dirent *od, *new_od = NULL;
+	struct kernfs_open_node *on, *new_on = NULL;
 
  retry:
-	mutex_lock(&sysfs_open_file_mutex);
-	spin_lock_irq(&sysfs_open_dirent_lock);
+	mutex_lock(&kernfs_open_file_mutex);
+	spin_lock_irq(&kernfs_open_node_lock);
 
-	if (!kn->attr.open && new_od) {
-		kn->attr.open = new_od;
-		new_od = NULL;
+	if (!kn->attr.open && new_on) {
+		kn->attr.open = new_on;
+		new_on = NULL;
 	}
 
-	od = kn->attr.open;
-	if (od) {
-		atomic_inc(&od->refcnt);
-		list_add_tail(&of->list, &od->files);
+	on = kn->attr.open;
+	if (on) {
+		atomic_inc(&on->refcnt);
+		list_add_tail(&of->list, &on->files);
 	}
 
-	spin_unlock_irq(&sysfs_open_dirent_lock);
-	mutex_unlock(&sysfs_open_file_mutex);
+	spin_unlock_irq(&kernfs_open_node_lock);
+	mutex_unlock(&kernfs_open_file_mutex);
 
-	if (od) {
-		kfree(new_od);
+	if (on) {
+		kfree(new_on);
 		return 0;
 	}
 
 	/* not there, initialize a new one and retry */
-	new_od = kmalloc(sizeof(*new_od), GFP_KERNEL);
-	if (!new_od)
+	new_on = kmalloc(sizeof(*new_on), GFP_KERNEL);
+	if (!new_on)
 		return -ENOMEM;
 
-	atomic_set(&new_od->refcnt, 0);
-	atomic_set(&new_od->event, 1);
-	init_waitqueue_head(&new_od->poll);
-	INIT_LIST_HEAD(&new_od->files);
+	atomic_set(&new_on->refcnt, 0);
+	atomic_set(&new_on->event, 1);
+	init_waitqueue_head(&new_on->poll);
+	INIT_LIST_HEAD(&new_on->files);
 	goto retry;
 }
 
 /**
- *	sysfs_put_open_dirent - put sysfs_open_dirent
+ *	sysfs_put_open_dirent - put kernfs_open_node
  *	@kn: target kernfs_nodet
- *	@of: associated sysfs_open_file
+ *	@of: associated kernfs_open_file
  *
  *	Put @kn->attr.open and unlink @of from the files list.  If
  *	reference count reaches zero, disassociate and free it.
@@ -538,33 +538,33 @@ static int sysfs_get_open_dirent(struct kernfs_node *kn,
  *	None.
  */
 static void sysfs_put_open_dirent(struct kernfs_node *kn,
-				  struct sysfs_open_file *of)
+				  struct kernfs_open_file *of)
 {
-	struct sysfs_open_dirent *od = kn->attr.open;
+	struct kernfs_open_node *on = kn->attr.open;
 	unsigned long flags;
 
-	mutex_lock(&sysfs_open_file_mutex);
-	spin_lock_irqsave(&sysfs_open_dirent_lock, flags);
+	mutex_lock(&kernfs_open_file_mutex);
+	spin_lock_irqsave(&kernfs_open_node_lock, flags);
 
 	if (of)
 		list_del(&of->list);
 
-	if (atomic_dec_and_test(&od->refcnt))
+	if (atomic_dec_and_test(&on->refcnt))
 		kn->attr.open = NULL;
 	else
-		od = NULL;
+		on = NULL;
 
-	spin_unlock_irqrestore(&sysfs_open_dirent_lock, flags);
-	mutex_unlock(&sysfs_open_file_mutex);
+	spin_unlock_irqrestore(&kernfs_open_node_lock, flags);
+	mutex_unlock(&kernfs_open_file_mutex);
 
-	kfree(od);
+	kfree(on);
 }
 
 static int kernfs_file_open(struct inode *inode, struct file *file)
 {
 	struct kernfs_node *kn = file->f_path.dentry->d_fsdata;
 	const struct kernfs_ops *ops;
-	struct sysfs_open_file *of;
+	struct kernfs_open_file *of;
 	bool has_read, has_write, has_mmap;
 	int error = -EACCES;
 
@@ -586,9 +586,9 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 	    (!(inode->i_mode & S_IRUGO) || !has_read))
 		goto err_out;
 
-	/* allocate a sysfs_open_file for the file */
+	/* allocate a kernfs_open_file for the file */
 	error = -ENOMEM;
-	of = kzalloc(sizeof(struct sysfs_open_file), GFP_KERNEL);
+	of = kzalloc(sizeof(struct kernfs_open_file), GFP_KERNEL);
 	if (!of)
 		goto err_out;
 
@@ -654,7 +654,7 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 static int kernfs_file_release(struct inode *inode, struct file *filp)
 {
 	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
-	struct sysfs_open_file *of = sysfs_of(filp);
+	struct kernfs_open_file *of = kernfs_of(filp);
 
 	sysfs_put_open_dirent(kn, of);
 	seq_release(inode, filp);
@@ -665,26 +665,26 @@ static int kernfs_file_release(struct inode *inode, struct file *filp)
 
 void sysfs_unmap_bin_file(struct kernfs_node *kn)
 {
-	struct sysfs_open_dirent *od;
-	struct sysfs_open_file *of;
+	struct kernfs_open_node *on;
+	struct kernfs_open_file *of;
 
 	if (!(kn->flags & SYSFS_FLAG_HAS_MMAP))
 		return;
 
-	spin_lock_irq(&sysfs_open_dirent_lock);
-	od = kn->attr.open;
-	if (od)
-		atomic_inc(&od->refcnt);
-	spin_unlock_irq(&sysfs_open_dirent_lock);
-	if (!od)
+	spin_lock_irq(&kernfs_open_node_lock);
+	on = kn->attr.open;
+	if (on)
+		atomic_inc(&on->refcnt);
+	spin_unlock_irq(&kernfs_open_node_lock);
+	if (!on)
 		return;
 
-	mutex_lock(&sysfs_open_file_mutex);
-	list_for_each_entry(of, &od->files, list) {
+	mutex_lock(&kernfs_open_file_mutex);
+	list_for_each_entry(of, &on->files, list) {
 		struct inode *inode = file_inode(of->file);
 		unmap_mapping_range(inode->i_mapping, 0, 0, 1);
 	}
-	mutex_unlock(&sysfs_open_file_mutex);
+	mutex_unlock(&kernfs_open_file_mutex);
 
 	sysfs_put_open_dirent(kn, NULL);
 }
@@ -704,19 +704,19 @@ void sysfs_unmap_bin_file(struct kernfs_node *kn)
  */
 static unsigned int kernfs_file_poll(struct file *filp, poll_table *wait)
 {
-	struct sysfs_open_file *of = sysfs_of(filp);
+	struct kernfs_open_file *of = kernfs_of(filp);
 	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
-	struct sysfs_open_dirent *od = kn->attr.open;
+	struct kernfs_open_node *on = kn->attr.open;
 
 	/* need parent for the kobj, grab both */
 	if (!sysfs_get_active(kn))
 		goto trigger;
 
-	poll_wait(filp, &od->poll, wait);
+	poll_wait(filp, &on->poll, wait);
 
 	sysfs_put_active(kn);
 
-	if (of->event != atomic_read(&od->event))
+	if (of->event != atomic_read(&on->event))
 		goto trigger;
 
 	return DEFAULT_POLLMASK;
@@ -733,20 +733,20 @@ static unsigned int kernfs_file_poll(struct file *filp, poll_table *wait)
  */
 void kernfs_notify(struct kernfs_node *kn)
 {
-	struct sysfs_open_dirent *od;
+	struct kernfs_open_node *on;
 	unsigned long flags;
 
-	spin_lock_irqsave(&sysfs_open_dirent_lock, flags);
+	spin_lock_irqsave(&kernfs_open_node_lock, flags);
 
 	if (!WARN_ON(sysfs_type(kn) != SYSFS_KOBJ_ATTR)) {
-		od = kn->attr.open;
-		if (od) {
-			atomic_inc(&od->event);
-			wake_up_interruptible(&od->poll);
+		on = kn->attr.open;
+		if (on) {
+			atomic_inc(&on->event);
+			wake_up_interruptible(&on->poll);
 		}
 	}
 
-	spin_unlock_irqrestore(&sysfs_open_dirent_lock, flags);
+	spin_unlock_irqrestore(&kernfs_open_node_lock, flags);
 }
 EXPORT_SYMBOL_GPL(kernfs_notify);
 
@@ -780,7 +780,7 @@ struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
 					      void *priv, const void *ns,
 					      struct lock_class_key *key)
 {
-	struct sysfs_addrm_cxt acxt;
+	struct kernfs_addrm_cxt acxt;
 	struct kernfs_node *kn;
 	int rc;
 

commit adc5e8b58f4886d45f79f4ff41a09001a76a6b12
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:54 2013 -0500

    kernfs: drop s_ prefix from kernfs_node members
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    s_ prefix for kernfs members is used inconsistently and a misnomer
    now.  It's not like kernfs_node is used widely across the kernel
    making the ability to grep for the members particularly useful.  Let's
    just drop the prefix.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 1bf07ded826a..5277021196a7 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -21,7 +21,7 @@
  * There's one sysfs_open_file for each open file and one sysfs_open_dirent
  * for each kernfs_node with one or more open files.
  *
- * kernfs_node->s_attr.open points to sysfs_open_dirent.  s_attr.open is
+ * kernfs_node->attr.open points to sysfs_open_dirent.  attr.open is
  * protected by sysfs_open_dirent_lock.
  *
  * filp->private_data points to seq_file whose ->private points to
@@ -49,9 +49,9 @@ static struct sysfs_open_file *sysfs_of(struct file *file)
  */
 static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)
 {
-	if (kn->s_flags & SYSFS_FLAG_LOCKDEP)
+	if (kn->flags & SYSFS_FLAG_LOCKDEP)
 		lockdep_assert_held(kn);
-	return kn->s_attr.ops;
+	return kn->attr.ops;
 }
 
 static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
@@ -112,9 +112,9 @@ static int kernfs_seq_show(struct seq_file *sf, void *v)
 {
 	struct sysfs_open_file *of = sf->private;
 
-	of->event = atomic_read(&of->kn->s_attr.open->event);
+	of->event = atomic_read(&of->kn->attr.open->event);
 
-	return of->kn->s_attr.ops->seq_show(sf, v);
+	return of->kn->attr.ops->seq_show(sf, v);
 }
 
 static const struct seq_operations kernfs_seq_ops = {
@@ -189,7 +189,7 @@ static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
 {
 	struct sysfs_open_file *of = sysfs_of(file);
 
-	if (of->kn->s_flags & SYSFS_FLAG_HAS_SEQ_SHOW)
+	if (of->kn->flags & SYSFS_FLAG_HAS_SEQ_SHOW)
 		return seq_read(file, user_buf, count, ppos);
 	else
 		return kernfs_file_direct_read(of, user_buf, count, ppos);
@@ -428,7 +428,7 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	 * without grabbing @of->mutex by testing HAS_MMAP flag.  See the
 	 * comment in kernfs_file_open() for more details.
 	 */
-	if (!(of->kn->s_flags & SYSFS_FLAG_HAS_MMAP))
+	if (!(of->kn->flags & SYSFS_FLAG_HAS_MMAP))
 		return -ENODEV;
 
 	mutex_lock(&of->mutex);
@@ -477,8 +477,8 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
  *	@kn: target kernfs_node
  *	@of: sysfs_open_file for this instance of open
  *
- *	If @kn->s_attr.open exists, increment its reference count;
- *	otherwise, create one.  @of is chained to the files list.
+ *	If @kn->attr.open exists, increment its reference count; otherwise,
+ *	create one.  @of is chained to the files list.
  *
  *	LOCKING:
  *	Kernel thread context (may sleep).
@@ -495,12 +495,12 @@ static int sysfs_get_open_dirent(struct kernfs_node *kn,
 	mutex_lock(&sysfs_open_file_mutex);
 	spin_lock_irq(&sysfs_open_dirent_lock);
 
-	if (!kn->s_attr.open && new_od) {
-		kn->s_attr.open = new_od;
+	if (!kn->attr.open && new_od) {
+		kn->attr.open = new_od;
 		new_od = NULL;
 	}
 
-	od = kn->s_attr.open;
+	od = kn->attr.open;
 	if (od) {
 		atomic_inc(&od->refcnt);
 		list_add_tail(&of->list, &od->files);
@@ -531,7 +531,7 @@ static int sysfs_get_open_dirent(struct kernfs_node *kn,
  *	@kn: target kernfs_nodet
  *	@of: associated sysfs_open_file
  *
- *	Put @kn->s_attr.open and unlink @of from the files list.  If
+ *	Put @kn->attr.open and unlink @of from the files list.  If
  *	reference count reaches zero, disassociate and free it.
  *
  *	LOCKING:
@@ -540,7 +540,7 @@ static int sysfs_get_open_dirent(struct kernfs_node *kn,
 static void sysfs_put_open_dirent(struct kernfs_node *kn,
 				  struct sysfs_open_file *of)
 {
-	struct sysfs_open_dirent *od = kn->s_attr.open;
+	struct sysfs_open_dirent *od = kn->attr.open;
 	unsigned long flags;
 
 	mutex_lock(&sysfs_open_file_mutex);
@@ -550,7 +550,7 @@ static void sysfs_put_open_dirent(struct kernfs_node *kn,
 		list_del(&of->list);
 
 	if (atomic_dec_and_test(&od->refcnt))
-		kn->s_attr.open = NULL;
+		kn->attr.open = NULL;
 	else
 		od = NULL;
 
@@ -668,11 +668,11 @@ void sysfs_unmap_bin_file(struct kernfs_node *kn)
 	struct sysfs_open_dirent *od;
 	struct sysfs_open_file *of;
 
-	if (!(kn->s_flags & SYSFS_FLAG_HAS_MMAP))
+	if (!(kn->flags & SYSFS_FLAG_HAS_MMAP))
 		return;
 
 	spin_lock_irq(&sysfs_open_dirent_lock);
-	od = kn->s_attr.open;
+	od = kn->attr.open;
 	if (od)
 		atomic_inc(&od->refcnt);
 	spin_unlock_irq(&sysfs_open_dirent_lock);
@@ -706,7 +706,7 @@ static unsigned int kernfs_file_poll(struct file *filp, poll_table *wait)
 {
 	struct sysfs_open_file *of = sysfs_of(filp);
 	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
-	struct sysfs_open_dirent *od = kn->s_attr.open;
+	struct sysfs_open_dirent *od = kn->attr.open;
 
 	/* need parent for the kobj, grab both */
 	if (!sysfs_get_active(kn))
@@ -739,7 +739,7 @@ void kernfs_notify(struct kernfs_node *kn)
 	spin_lock_irqsave(&sysfs_open_dirent_lock, flags);
 
 	if (!WARN_ON(sysfs_type(kn) != SYSFS_KOBJ_ATTR)) {
-		od = kn->s_attr.open;
+		od = kn->attr.open;
 		if (od) {
 			atomic_inc(&od->event);
 			wake_up_interruptible(&od->poll);
@@ -789,27 +789,27 @@ struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
 	if (!kn)
 		return ERR_PTR(-ENOMEM);
 
-	kn->s_attr.ops = ops;
-	kn->s_attr.size = size;
-	kn->s_ns = ns;
+	kn->attr.ops = ops;
+	kn->attr.size = size;
+	kn->ns = ns;
 	kn->priv = priv;
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	if (key) {
 		lockdep_init_map(&kn->dep_map, "s_active", key, 0);
-		kn->s_flags |= SYSFS_FLAG_LOCKDEP;
+		kn->flags |= SYSFS_FLAG_LOCKDEP;
 	}
 #endif
 
 	/*
-	 * kn->s_attr.ops is accesible only while holding active ref.  We
+	 * kn->attr.ops is accesible only while holding active ref.  We
 	 * need to know whether some ops are implemented outside active
 	 * ref.  Cache their existence in flags.
 	 */
 	if (ops->seq_show)
-		kn->s_flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
+		kn->flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
 	if (ops->mmap)
-		kn->s_flags |= SYSFS_FLAG_HAS_MMAP;
+		kn->flags |= SYSFS_FLAG_HAS_MMAP;
 
 	sysfs_addrm_start(&acxt);
 	rc = sysfs_add_one(&acxt, kn, parent);

commit 324a56e16e44baecac3ca799fd216154145c14bf
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:53 2013 -0500

    kernfs: s/sysfs_dirent/kernfs_node/ and rename its friends accordingly
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_elem_dir/kernfs_elem_dir/
    * s/sysfs_elem_symlink/kernfs_elem_symlink/
    * s/sysfs_elem_attr/kernfs_elem_file/
    * s/sysfs_dirent/kernfs_node/
    * s/sd/kn/ in kernfs proper
    * s/parent_sd/parent/
    * s/target_sd/target/
    * s/dir_sd/parent/
    * s/to_sysfs_dirent()/rb_to_kn()/
    * misc renames of local vars when they conflict with the above
    
    Because md, mic and gpio dig into sysfs details, this patch ends up
    modifying them.  All are sysfs_dirent renames and trivial.  While we
    can avoid these by introducing a dummy wrapping struct sysfs_dirent
    around kernfs_node, given the limited usage outside kernfs and sysfs
    proper, I don't think such workaround is called for.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    - mic / gpio renames were missing.  Spotted by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index fa053151fa96..1bf07ded826a 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -19,9 +19,9 @@
 
 /*
  * There's one sysfs_open_file for each open file and one sysfs_open_dirent
- * for each sysfs_dirent with one or more open files.
+ * for each kernfs_node with one or more open files.
  *
- * sysfs_dirent->s_attr.open points to sysfs_open_dirent.  s_attr.open is
+ * kernfs_node->s_attr.open points to sysfs_open_dirent.  s_attr.open is
  * protected by sysfs_open_dirent_lock.
  *
  * filp->private_data points to seq_file whose ->private points to
@@ -44,14 +44,14 @@ static struct sysfs_open_file *sysfs_of(struct file *file)
 }
 
 /*
- * Determine the kernfs_ops for the given sysfs_dirent.  This function must
+ * Determine the kernfs_ops for the given kernfs_node.  This function must
  * be called while holding an active reference.
  */
-static const struct kernfs_ops *kernfs_ops(struct sysfs_dirent *sd)
+static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)
 {
-	if (sd->s_flags & SYSFS_FLAG_LOCKDEP)
-		lockdep_assert_held(sd);
-	return sd->s_attr.ops;
+	if (kn->s_flags & SYSFS_FLAG_LOCKDEP)
+		lockdep_assert_held(kn);
+	return kn->s_attr.ops;
 }
 
 static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
@@ -64,10 +64,10 @@ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		return ERR_PTR(-ENODEV);
 
-	ops = kernfs_ops(of->sd);
+	ops = kernfs_ops(of->kn);
 	if (ops->seq_start) {
 		return ops->seq_start(sf, ppos);
 	} else {
@@ -82,7 +82,7 @@ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
 static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 {
 	struct sysfs_open_file *of = sf->private;
-	const struct kernfs_ops *ops = kernfs_ops(of->sd);
+	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
 	if (ops->seq_next) {
 		return ops->seq_next(sf, v, ppos);
@@ -99,12 +99,12 @@ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
 static void kernfs_seq_stop(struct seq_file *sf, void *v)
 {
 	struct sysfs_open_file *of = sf->private;
-	const struct kernfs_ops *ops = kernfs_ops(of->sd);
+	const struct kernfs_ops *ops = kernfs_ops(of->kn);
 
 	if (ops->seq_stop)
 		ops->seq_stop(sf, v);
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 }
 
@@ -112,9 +112,9 @@ static int kernfs_seq_show(struct seq_file *sf, void *v)
 {
 	struct sysfs_open_file *of = sf->private;
 
-	of->event = atomic_read(&of->sd->s_attr.open->event);
+	of->event = atomic_read(&of->kn->s_attr.open->event);
 
-	return of->sd->s_attr.ops->seq_show(sf, v);
+	return of->kn->s_attr.ops->seq_show(sf, v);
 }
 
 static const struct seq_operations kernfs_seq_ops = {
@@ -147,19 +147,19 @@ static ssize_t kernfs_file_direct_read(struct sysfs_open_file *of,
 	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
-	if (!sysfs_get_active(of->sd)) {
+	if (!sysfs_get_active(of->kn)) {
 		len = -ENODEV;
 		mutex_unlock(&of->mutex);
 		goto out_free;
 	}
 
-	ops = kernfs_ops(of->sd);
+	ops = kernfs_ops(of->kn);
 	if (ops->read)
 		len = ops->read(of, buf, len, *ppos);
 	else
 		len = -EINVAL;
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 
 	if (len < 0)
@@ -189,7 +189,7 @@ static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
 {
 	struct sysfs_open_file *of = sysfs_of(file);
 
-	if (of->sd->s_flags & SYSFS_FLAG_HAS_SEQ_SHOW)
+	if (of->kn->s_flags & SYSFS_FLAG_HAS_SEQ_SHOW)
 		return seq_read(file, user_buf, count, ppos);
 	else
 		return kernfs_file_direct_read(of, user_buf, count, ppos);
@@ -234,19 +234,19 @@ static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
 	 * the ops aren't called concurrently for the same open file.
 	 */
 	mutex_lock(&of->mutex);
-	if (!sysfs_get_active(of->sd)) {
+	if (!sysfs_get_active(of->kn)) {
 		mutex_unlock(&of->mutex);
 		len = -ENODEV;
 		goto out_free;
 	}
 
-	ops = kernfs_ops(of->sd);
+	ops = kernfs_ops(of->kn);
 	if (ops->write)
 		len = ops->write(of, buf, len, *ppos);
 	else
 		len = -EINVAL;
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	mutex_unlock(&of->mutex);
 
 	if (len > 0)
@@ -264,13 +264,13 @@ static void kernfs_vma_open(struct vm_area_struct *vma)
 	if (!of->vm_ops)
 		return;
 
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		return;
 
 	if (of->vm_ops->open)
 		of->vm_ops->open(vma);
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 }
 
 static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
@@ -282,14 +282,14 @@ static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 	if (!of->vm_ops)
 		return VM_FAULT_SIGBUS;
 
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		return VM_FAULT_SIGBUS;
 
 	ret = VM_FAULT_SIGBUS;
 	if (of->vm_ops->fault)
 		ret = of->vm_ops->fault(vma, vmf);
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	return ret;
 }
 
@@ -303,7 +303,7 @@ static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
 	if (!of->vm_ops)
 		return VM_FAULT_SIGBUS;
 
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		return VM_FAULT_SIGBUS;
 
 	ret = 0;
@@ -312,7 +312,7 @@ static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
 	else
 		file_update_time(file);
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	return ret;
 }
 
@@ -326,14 +326,14 @@ static int kernfs_vma_access(struct vm_area_struct *vma, unsigned long addr,
 	if (!of->vm_ops)
 		return -EINVAL;
 
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		return -EINVAL;
 
 	ret = -EINVAL;
 	if (of->vm_ops->access)
 		ret = of->vm_ops->access(vma, addr, buf, len, write);
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	return ret;
 }
 
@@ -348,14 +348,14 @@ static int kernfs_vma_set_policy(struct vm_area_struct *vma,
 	if (!of->vm_ops)
 		return 0;
 
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		return -EINVAL;
 
 	ret = 0;
 	if (of->vm_ops->set_policy)
 		ret = of->vm_ops->set_policy(vma, new);
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	return ret;
 }
 
@@ -369,14 +369,14 @@ static struct mempolicy *kernfs_vma_get_policy(struct vm_area_struct *vma,
 	if (!of->vm_ops)
 		return vma->vm_policy;
 
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		return vma->vm_policy;
 
 	pol = vma->vm_policy;
 	if (of->vm_ops->get_policy)
 		pol = of->vm_ops->get_policy(vma, addr);
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	return pol;
 }
 
@@ -391,14 +391,14 @@ static int kernfs_vma_migrate(struct vm_area_struct *vma,
 	if (!of->vm_ops)
 		return 0;
 
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		return 0;
 
 	ret = 0;
 	if (of->vm_ops->migrate)
 		ret = of->vm_ops->migrate(vma, from, to, flags);
 
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 	return ret;
 }
 #endif
@@ -428,16 +428,16 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	 * without grabbing @of->mutex by testing HAS_MMAP flag.  See the
 	 * comment in kernfs_file_open() for more details.
 	 */
-	if (!(of->sd->s_flags & SYSFS_FLAG_HAS_MMAP))
+	if (!(of->kn->s_flags & SYSFS_FLAG_HAS_MMAP))
 		return -ENODEV;
 
 	mutex_lock(&of->mutex);
 
 	rc = -ENODEV;
-	if (!sysfs_get_active(of->sd))
+	if (!sysfs_get_active(of->kn))
 		goto out_unlock;
 
-	ops = kernfs_ops(of->sd);
+	ops = kernfs_ops(of->kn);
 	rc = ops->mmap(of, vma);
 
 	/*
@@ -465,7 +465,7 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	of->vm_ops = vma->vm_ops;
 	vma->vm_ops = &kernfs_vm_ops;
 out_put:
-	sysfs_put_active(of->sd);
+	sysfs_put_active(of->kn);
 out_unlock:
 	mutex_unlock(&of->mutex);
 
@@ -474,10 +474,10 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 
 /**
  *	sysfs_get_open_dirent - get or create sysfs_open_dirent
- *	@sd: target sysfs_dirent
+ *	@kn: target kernfs_node
  *	@of: sysfs_open_file for this instance of open
  *
- *	If @sd->s_attr.open exists, increment its reference count;
+ *	If @kn->s_attr.open exists, increment its reference count;
  *	otherwise, create one.  @of is chained to the files list.
  *
  *	LOCKING:
@@ -486,7 +486,7 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
  *	RETURNS:
  *	0 on success, -errno on failure.
  */
-static int sysfs_get_open_dirent(struct sysfs_dirent *sd,
+static int sysfs_get_open_dirent(struct kernfs_node *kn,
 				 struct sysfs_open_file *of)
 {
 	struct sysfs_open_dirent *od, *new_od = NULL;
@@ -495,12 +495,12 @@ static int sysfs_get_open_dirent(struct sysfs_dirent *sd,
 	mutex_lock(&sysfs_open_file_mutex);
 	spin_lock_irq(&sysfs_open_dirent_lock);
 
-	if (!sd->s_attr.open && new_od) {
-		sd->s_attr.open = new_od;
+	if (!kn->s_attr.open && new_od) {
+		kn->s_attr.open = new_od;
 		new_od = NULL;
 	}
 
-	od = sd->s_attr.open;
+	od = kn->s_attr.open;
 	if (od) {
 		atomic_inc(&od->refcnt);
 		list_add_tail(&of->list, &od->files);
@@ -528,19 +528,19 @@ static int sysfs_get_open_dirent(struct sysfs_dirent *sd,
 
 /**
  *	sysfs_put_open_dirent - put sysfs_open_dirent
- *	@sd: target sysfs_dirent
+ *	@kn: target kernfs_nodet
  *	@of: associated sysfs_open_file
  *
- *	Put @sd->s_attr.open and unlink @of from the files list.  If
+ *	Put @kn->s_attr.open and unlink @of from the files list.  If
  *	reference count reaches zero, disassociate and free it.
  *
  *	LOCKING:
  *	None.
  */
-static void sysfs_put_open_dirent(struct sysfs_dirent *sd,
+static void sysfs_put_open_dirent(struct kernfs_node *kn,
 				  struct sysfs_open_file *of)
 {
-	struct sysfs_open_dirent *od = sd->s_attr.open;
+	struct sysfs_open_dirent *od = kn->s_attr.open;
 	unsigned long flags;
 
 	mutex_lock(&sysfs_open_file_mutex);
@@ -550,7 +550,7 @@ static void sysfs_put_open_dirent(struct sysfs_dirent *sd,
 		list_del(&of->list);
 
 	if (atomic_dec_and_test(&od->refcnt))
-		sd->s_attr.open = NULL;
+		kn->s_attr.open = NULL;
 	else
 		od = NULL;
 
@@ -562,16 +562,16 @@ static void sysfs_put_open_dirent(struct sysfs_dirent *sd,
 
 static int kernfs_file_open(struct inode *inode, struct file *file)
 {
-	struct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;
+	struct kernfs_node *kn = file->f_path.dentry->d_fsdata;
 	const struct kernfs_ops *ops;
 	struct sysfs_open_file *of;
 	bool has_read, has_write, has_mmap;
 	int error = -EACCES;
 
-	if (!sysfs_get_active(attr_sd))
+	if (!sysfs_get_active(kn))
 		return -ENODEV;
 
-	ops = kernfs_ops(attr_sd);
+	ops = kernfs_ops(kn);
 
 	has_read = ops->seq_show || ops->read || ops->mmap;
 	has_write = ops->write || ops->mmap;
@@ -612,7 +612,7 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 	else
 		mutex_init(&of->mutex);
 
-	of->sd = attr_sd;
+	of->kn = kn;
 	of->file = file;
 
 	/*
@@ -634,12 +634,12 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 		file->f_mode |= FMODE_PWRITE;
 
 	/* make sure we have open dirent struct */
-	error = sysfs_get_open_dirent(attr_sd, of);
+	error = sysfs_get_open_dirent(kn, of);
 	if (error)
 		goto err_close;
 
 	/* open succeeded, put active references */
-	sysfs_put_active(attr_sd);
+	sysfs_put_active(kn);
 	return 0;
 
 err_close:
@@ -647,32 +647,32 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 err_free:
 	kfree(of);
 err_out:
-	sysfs_put_active(attr_sd);
+	sysfs_put_active(kn);
 	return error;
 }
 
 static int kernfs_file_release(struct inode *inode, struct file *filp)
 {
-	struct sysfs_dirent *sd = filp->f_path.dentry->d_fsdata;
+	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
 	struct sysfs_open_file *of = sysfs_of(filp);
 
-	sysfs_put_open_dirent(sd, of);
+	sysfs_put_open_dirent(kn, of);
 	seq_release(inode, filp);
 	kfree(of);
 
 	return 0;
 }
 
-void sysfs_unmap_bin_file(struct sysfs_dirent *sd)
+void sysfs_unmap_bin_file(struct kernfs_node *kn)
 {
 	struct sysfs_open_dirent *od;
 	struct sysfs_open_file *of;
 
-	if (!(sd->s_flags & SYSFS_FLAG_HAS_MMAP))
+	if (!(kn->s_flags & SYSFS_FLAG_HAS_MMAP))
 		return;
 
 	spin_lock_irq(&sysfs_open_dirent_lock);
-	od = sd->s_attr.open;
+	od = kn->s_attr.open;
 	if (od)
 		atomic_inc(&od->refcnt);
 	spin_unlock_irq(&sysfs_open_dirent_lock);
@@ -686,7 +686,7 @@ void sysfs_unmap_bin_file(struct sysfs_dirent *sd)
 	}
 	mutex_unlock(&sysfs_open_file_mutex);
 
-	sysfs_put_open_dirent(sd, NULL);
+	sysfs_put_open_dirent(kn, NULL);
 }
 
 /* Sysfs attribute files are pollable.  The idea is that you read
@@ -705,16 +705,16 @@ void sysfs_unmap_bin_file(struct sysfs_dirent *sd)
 static unsigned int kernfs_file_poll(struct file *filp, poll_table *wait)
 {
 	struct sysfs_open_file *of = sysfs_of(filp);
-	struct sysfs_dirent *attr_sd = filp->f_path.dentry->d_fsdata;
-	struct sysfs_open_dirent *od = attr_sd->s_attr.open;
+	struct kernfs_node *kn = filp->f_path.dentry->d_fsdata;
+	struct sysfs_open_dirent *od = kn->s_attr.open;
 
 	/* need parent for the kobj, grab both */
-	if (!sysfs_get_active(attr_sd))
+	if (!sysfs_get_active(kn))
 		goto trigger;
 
 	poll_wait(filp, &od->poll, wait);
 
-	sysfs_put_active(attr_sd);
+	sysfs_put_active(kn);
 
 	if (of->event != atomic_read(&od->event))
 		goto trigger;
@@ -727,19 +727,19 @@ static unsigned int kernfs_file_poll(struct file *filp, poll_table *wait)
 
 /**
  * kernfs_notify - notify a kernfs file
- * @sd: file to notify
+ * @kn: file to notify
  *
- * Notify @sd such that poll(2) on @sd wakes up.
+ * Notify @kn such that poll(2) on @kn wakes up.
  */
-void kernfs_notify(struct sysfs_dirent *sd)
+void kernfs_notify(struct kernfs_node *kn)
 {
 	struct sysfs_open_dirent *od;
 	unsigned long flags;
 
 	spin_lock_irqsave(&sysfs_open_dirent_lock, flags);
 
-	if (!WARN_ON(sysfs_type(sd) != SYSFS_KOBJ_ATTR)) {
-		od = sd->s_attr.open;
+	if (!WARN_ON(sysfs_type(kn) != SYSFS_KOBJ_ATTR)) {
+		od = kn->s_attr.open;
 		if (od) {
 			atomic_inc(&od->event);
 			wake_up_interruptible(&od->poll);
@@ -773,51 +773,51 @@ const struct file_operations kernfs_file_operations = {
  *
  * Returns the created node on success, ERR_PTR() value on error.
  */
-struct sysfs_dirent *kernfs_create_file_ns_key(struct sysfs_dirent *parent,
-					       const char *name,
-					       umode_t mode, loff_t size,
-					       const struct kernfs_ops *ops,
-					       void *priv, const void *ns,
-					       struct lock_class_key *key)
+struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
+					      const char *name,
+					      umode_t mode, loff_t size,
+					      const struct kernfs_ops *ops,
+					      void *priv, const void *ns,
+					      struct lock_class_key *key)
 {
 	struct sysfs_addrm_cxt acxt;
-	struct sysfs_dirent *sd;
+	struct kernfs_node *kn;
 	int rc;
 
-	sd = sysfs_new_dirent(kernfs_root(parent), name,
+	kn = sysfs_new_dirent(kernfs_root(parent), name,
 			      (mode & S_IALLUGO) | S_IFREG, SYSFS_KOBJ_ATTR);
-	if (!sd)
+	if (!kn)
 		return ERR_PTR(-ENOMEM);
 
-	sd->s_attr.ops = ops;
-	sd->s_attr.size = size;
-	sd->s_ns = ns;
-	sd->priv = priv;
+	kn->s_attr.ops = ops;
+	kn->s_attr.size = size;
+	kn->s_ns = ns;
+	kn->priv = priv;
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	if (key) {
-		lockdep_init_map(&sd->dep_map, "s_active", key, 0);
-		sd->s_flags |= SYSFS_FLAG_LOCKDEP;
+		lockdep_init_map(&kn->dep_map, "s_active", key, 0);
+		kn->s_flags |= SYSFS_FLAG_LOCKDEP;
 	}
 #endif
 
 	/*
-	 * sd->s_attr.ops is accesible only while holding active ref.  We
+	 * kn->s_attr.ops is accesible only while holding active ref.  We
 	 * need to know whether some ops are implemented outside active
 	 * ref.  Cache their existence in flags.
 	 */
 	if (ops->seq_show)
-		sd->s_flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
+		kn->s_flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
 	if (ops->mmap)
-		sd->s_flags |= SYSFS_FLAG_HAS_MMAP;
+		kn->s_flags |= SYSFS_FLAG_HAS_MMAP;
 
 	sysfs_addrm_start(&acxt);
-	rc = sysfs_add_one(&acxt, sd, parent);
+	rc = sysfs_add_one(&acxt, kn, parent);
 	sysfs_addrm_finish(&acxt);
 
 	if (rc) {
-		kernfs_put(sd);
+		kernfs_put(kn);
 		return ERR_PTR(rc);
 	}
-	return sd;
+	return kn;
 }

commit 9b2db6e1894577d48f4e290381bac6e573593838
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Dec 10 09:29:17 2013 -0500

    sysfs: bail early from kernfs_file_mmap() to avoid spurious lockdep warning
    
    This is v3.14 fix for the same issue that a8b14744429f ("sysfs: give
    different locking key to regular and bin files") addresses for v3.13.
    Due to the extensive kernfs reorganization in v3.14 branch, the same
    fix couldn't be ported as-is.  The v3.13 fix was ignored while merging
    it into v3.14 branch.
    
    027a485d12e0 ("sysfs: use a separate locking class for open files
    depending on mmap") assigned different lockdep key to
    sysfs_open_file->mutex depending on whether the file implements mmap
    or not in an attempt to avoid spurious lockdep warning caused by
    merging of regular and bin file paths.
    
    While this restored some of the original behavior of using different
    locks (at least lockdep is concerned) for the different clases of
    files.  The restoration wasn't full because now the lockdep key
    assignment depends on whether the file has mmap or not instead of
    whether it's a regular file or not.
    
    This means that bin files which don't implement mmap will get assigned
    the same lockdep class as regular files.  This is problematic because
    file_operations for bin files still implements the mmap file operation
    and checking whether the sysfs file actually implements mmap happens
    in the file operation after grabbing @sysfs_open_file->mutex.  We
    still end up adding locking dependency from mmap locking to
    sysfs_open_file->mutex to the regular file mutex which triggers
    spurious circular locking warning.
    
    For v3.13, a8b14744429f ("sysfs: give different locking key to regular
    and bin files") fixed it by giving sysfs_open_file->mutex different
    lockdep keys depending on whether the file is regular or bin instead
    of whether mmap exists or not; however, due to the way sysfs is now
    layered behind kernfs, this approach is no longer viable.  kernfs can
    tell whether a sysfs node has mmap implemented or not but can't tell
    whether a bin file from a regular one.
    
    This patch updates kernfs such that kernfs_file_mmap() checks
    SYSFS_FLAG_HAS_MMAP and bail before grabbing sysfs_open_file->mutex so
    that it doesn't add spurious locking dependency from mmap to
    sysfs_open_file->mutex and changes sysfs so that it specifies
    kernfs_ops->mmap iff the sysfs file implements mmap.  Combined, this
    ensures that sysfs_open_file->mutex is grabbed under mmap path iff the
    sysfs file actually implements mmap.  As sysfs_open_file->mutex is
    already given a different lockdep key if mmap is implemented, this
    removes the spurious locking dependency.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Dave Jones <davej@redhat.com>
    Link: http://lkml.kernel.org/g/20131203184324.GA11320@redhat.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 4a5863b79de9..fa053151fa96 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -421,6 +421,16 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	const struct kernfs_ops *ops;
 	int rc;
 
+	/*
+	 * mmap path and of->mutex are prone to triggering spurious lockdep
+	 * warnings and we don't want to add spurious locking dependency
+	 * between the two.  Check whether mmap is actually implemented
+	 * without grabbing @of->mutex by testing HAS_MMAP flag.  See the
+	 * comment in kernfs_file_open() for more details.
+	 */
+	if (!(of->sd->s_flags & SYSFS_FLAG_HAS_MMAP))
+		return -ENODEV;
+
 	mutex_lock(&of->mutex);
 
 	rc = -ENODEV;
@@ -428,10 +438,7 @@ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 		goto out_unlock;
 
 	ops = kernfs_ops(of->sd);
-	if (ops->mmap)
-		rc = ops->mmap(of, vma);
-	if (rc)
-		goto out_put;
+	rc = ops->mmap(of, vma);
 
 	/*
 	 * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()
@@ -596,6 +603,9 @@ static int kernfs_file_open(struct inode *inode, struct file *file)
 	 * happen on the same file.  At this point, we can't easily give
 	 * each file a separate locking class.  Let's differentiate on
 	 * whether the file has mmap or not for now.
+	 *
+	 * Both paths of the branch look the same.  They're supposed to
+	 * look that way and give @of->mutex different static lockdep keys.
 	 */
 	if (has_mmap)
 		mutex_init(&of->mutex);

commit 21d71662f895462abaa3054d504af55a306f42ba
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Sat Dec 7 14:07:36 2013 +0800

    sysfs, kernfs: remove duplicated include from file.c
    
    Remove duplicated include.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 990c97fa7045..4a5863b79de9 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -13,7 +13,6 @@
 #include <linux/slab.h>
 #include <linux/poll.h>
 #include <linux/pagemap.h>
-#include <linux/poll.h>
 #include <linux/sched.h>
 
 #include "kernfs-internal.h"

commit bc755553df9ab33f389c1a0a8bd0b4f4646e80ef
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:41 2013 -0500

    sysfs, kernfs: make inode number ida per kernfs_root
    
    kernfs is being updated to allow multiple sysfs_dirent hierarchies so
    that it can also be used by other users.  Currently, inode number is
    allocated using a global ida, sysfs_ino_ida; however, inos for
    different hierarchies should be handled separately.
    
    This patch makes ino allocation per kernfs_root.  sysfs_ino_ida is
    replaced by kernfs_root->ino_ida and sysfs_new_dirent() is updated to
    take @root and allocate ino from it.  ida_simple_get/remove() are used
    instead of sysfs_ino_lock and sysfs_alloc/free_ino().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index fa172e86047f..990c97fa7045 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -775,8 +775,8 @@ struct sysfs_dirent *kernfs_create_file_ns_key(struct sysfs_dirent *parent,
 	struct sysfs_dirent *sd;
 	int rc;
 
-	sd = sysfs_new_dirent(name, (mode & S_IALLUGO) | S_IFREG,
-			      SYSFS_KOBJ_ATTR);
+	sd = sysfs_new_dirent(kernfs_root(parent), name,
+			      (mode & S_IALLUGO) | S_IFREG, SYSFS_KOBJ_ATTR);
 	if (!sd)
 		return ERR_PTR(-ENOMEM);
 

commit 414985ae23c031efbd6d16d484dea8b5de28b8f7
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:34 2013 -0500

    sysfs, kernfs: move file core code to fs/kernfs/file.c
    
    Move core file code to fs/kernfs/file.c.  fs/sysfs/file.c now contains
    sysfs kernfs_ops callbacks, sysfs wrappers around kernfs interfaces,
    and sysfs_schedule_callback().  The respective declarations in
    fs/sysfs/sysfs.h are moved to fs/kernfs/kernfs-internal.h.
    
    This is pure relocation.
    
    v2: Refreshed on top of the v2 of "sysfs, kernfs: prepare read path
        for kernfs".
    
    v3: Refreshed on top of the v3 of "sysfs, kernfs: prepare read path
        for kernfs".
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
index 90b1e88dad44..fa172e86047f 100644
--- a/fs/kernfs/file.c
+++ b/fs/kernfs/file.c
@@ -7,3 +7,808 @@
  *
  * This file is released under the GPLv2.
  */
+
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/pagemap.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+
+#include "kernfs-internal.h"
+
+/*
+ * There's one sysfs_open_file for each open file and one sysfs_open_dirent
+ * for each sysfs_dirent with one or more open files.
+ *
+ * sysfs_dirent->s_attr.open points to sysfs_open_dirent.  s_attr.open is
+ * protected by sysfs_open_dirent_lock.
+ *
+ * filp->private_data points to seq_file whose ->private points to
+ * sysfs_open_file.  sysfs_open_files are chained at
+ * sysfs_open_dirent->files, which is protected by sysfs_open_file_mutex.
+ */
+static DEFINE_SPINLOCK(sysfs_open_dirent_lock);
+static DEFINE_MUTEX(sysfs_open_file_mutex);
+
+struct sysfs_open_dirent {
+	atomic_t		refcnt;
+	atomic_t		event;
+	wait_queue_head_t	poll;
+	struct list_head	files; /* goes through sysfs_open_file.list */
+};
+
+static struct sysfs_open_file *sysfs_of(struct file *file)
+{
+	return ((struct seq_file *)file->private_data)->private;
+}
+
+/*
+ * Determine the kernfs_ops for the given sysfs_dirent.  This function must
+ * be called while holding an active reference.
+ */
+static const struct kernfs_ops *kernfs_ops(struct sysfs_dirent *sd)
+{
+	if (sd->s_flags & SYSFS_FLAG_LOCKDEP)
+		lockdep_assert_held(sd);
+	return sd->s_attr.ops;
+}
+
+static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
+{
+	struct sysfs_open_file *of = sf->private;
+	const struct kernfs_ops *ops;
+
+	/*
+	 * @of->mutex nests outside active ref and is just to ensure that
+	 * the ops aren't called concurrently for the same open file.
+	 */
+	mutex_lock(&of->mutex);
+	if (!sysfs_get_active(of->sd))
+		return ERR_PTR(-ENODEV);
+
+	ops = kernfs_ops(of->sd);
+	if (ops->seq_start) {
+		return ops->seq_start(sf, ppos);
+	} else {
+		/*
+		 * The same behavior and code as single_open().  Returns
+		 * !NULL if pos is at the beginning; otherwise, NULL.
+		 */
+		return NULL + !*ppos;
+	}
+}
+
+static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
+{
+	struct sysfs_open_file *of = sf->private;
+	const struct kernfs_ops *ops = kernfs_ops(of->sd);
+
+	if (ops->seq_next) {
+		return ops->seq_next(sf, v, ppos);
+	} else {
+		/*
+		 * The same behavior and code as single_open(), always
+		 * terminate after the initial read.
+		 */
+		++*ppos;
+		return NULL;
+	}
+}
+
+static void kernfs_seq_stop(struct seq_file *sf, void *v)
+{
+	struct sysfs_open_file *of = sf->private;
+	const struct kernfs_ops *ops = kernfs_ops(of->sd);
+
+	if (ops->seq_stop)
+		ops->seq_stop(sf, v);
+
+	sysfs_put_active(of->sd);
+	mutex_unlock(&of->mutex);
+}
+
+static int kernfs_seq_show(struct seq_file *sf, void *v)
+{
+	struct sysfs_open_file *of = sf->private;
+
+	of->event = atomic_read(&of->sd->s_attr.open->event);
+
+	return of->sd->s_attr.ops->seq_show(sf, v);
+}
+
+static const struct seq_operations kernfs_seq_ops = {
+	.start = kernfs_seq_start,
+	.next = kernfs_seq_next,
+	.stop = kernfs_seq_stop,
+	.show = kernfs_seq_show,
+};
+
+/*
+ * As reading a bin file can have side-effects, the exact offset and bytes
+ * specified in read(2) call should be passed to the read callback making
+ * it difficult to use seq_file.  Implement simplistic custom buffering for
+ * bin files.
+ */
+static ssize_t kernfs_file_direct_read(struct sysfs_open_file *of,
+				       char __user *user_buf, size_t count,
+				       loff_t *ppos)
+{
+	ssize_t len = min_t(size_t, count, PAGE_SIZE);
+	const struct kernfs_ops *ops;
+	char *buf;
+
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/*
+	 * @of->mutex nests outside active ref and is just to ensure that
+	 * the ops aren't called concurrently for the same open file.
+	 */
+	mutex_lock(&of->mutex);
+	if (!sysfs_get_active(of->sd)) {
+		len = -ENODEV;
+		mutex_unlock(&of->mutex);
+		goto out_free;
+	}
+
+	ops = kernfs_ops(of->sd);
+	if (ops->read)
+		len = ops->read(of, buf, len, *ppos);
+	else
+		len = -EINVAL;
+
+	sysfs_put_active(of->sd);
+	mutex_unlock(&of->mutex);
+
+	if (len < 0)
+		goto out_free;
+
+	if (copy_to_user(user_buf, buf, len)) {
+		len = -EFAULT;
+		goto out_free;
+	}
+
+	*ppos += len;
+
+ out_free:
+	kfree(buf);
+	return len;
+}
+
+/**
+ * kernfs_file_read - kernfs vfs read callback
+ * @file: file pointer
+ * @user_buf: data to write
+ * @count: number of bytes
+ * @ppos: starting offset
+ */
+static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct sysfs_open_file *of = sysfs_of(file);
+
+	if (of->sd->s_flags & SYSFS_FLAG_HAS_SEQ_SHOW)
+		return seq_read(file, user_buf, count, ppos);
+	else
+		return kernfs_file_direct_read(of, user_buf, count, ppos);
+}
+
+/**
+ * kernfs_file_write - kernfs vfs write callback
+ * @file: file pointer
+ * @user_buf: data to write
+ * @count: number of bytes
+ * @ppos: starting offset
+ *
+ * Copy data in from userland and pass it to the matching kernfs write
+ * operation.
+ *
+ * There is no easy way for us to know if userspace is only doing a partial
+ * write, so we don't support them. We expect the entire buffer to come on
+ * the first write.  Hint: if you're writing a value, first read the file,
+ * modify only the the value you're changing, then write entire buffer
+ * back.
+ */
+static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct sysfs_open_file *of = sysfs_of(file);
+	ssize_t len = min_t(size_t, count, PAGE_SIZE);
+	const struct kernfs_ops *ops;
+	char *buf;
+
+	buf = kmalloc(len + 1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, user_buf, len)) {
+		len = -EFAULT;
+		goto out_free;
+	}
+	buf[len] = '\0';	/* guarantee string termination */
+
+	/*
+	 * @of->mutex nests outside active ref and is just to ensure that
+	 * the ops aren't called concurrently for the same open file.
+	 */
+	mutex_lock(&of->mutex);
+	if (!sysfs_get_active(of->sd)) {
+		mutex_unlock(&of->mutex);
+		len = -ENODEV;
+		goto out_free;
+	}
+
+	ops = kernfs_ops(of->sd);
+	if (ops->write)
+		len = ops->write(of, buf, len, *ppos);
+	else
+		len = -EINVAL;
+
+	sysfs_put_active(of->sd);
+	mutex_unlock(&of->mutex);
+
+	if (len > 0)
+		*ppos += len;
+out_free:
+	kfree(buf);
+	return len;
+}
+
+static void kernfs_vma_open(struct vm_area_struct *vma)
+{
+	struct file *file = vma->vm_file;
+	struct sysfs_open_file *of = sysfs_of(file);
+
+	if (!of->vm_ops)
+		return;
+
+	if (!sysfs_get_active(of->sd))
+		return;
+
+	if (of->vm_ops->open)
+		of->vm_ops->open(vma);
+
+	sysfs_put_active(of->sd);
+}
+
+static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	struct file *file = vma->vm_file;
+	struct sysfs_open_file *of = sysfs_of(file);
+	int ret;
+
+	if (!of->vm_ops)
+		return VM_FAULT_SIGBUS;
+
+	if (!sysfs_get_active(of->sd))
+		return VM_FAULT_SIGBUS;
+
+	ret = VM_FAULT_SIGBUS;
+	if (of->vm_ops->fault)
+		ret = of->vm_ops->fault(vma, vmf);
+
+	sysfs_put_active(of->sd);
+	return ret;
+}
+
+static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
+				   struct vm_fault *vmf)
+{
+	struct file *file = vma->vm_file;
+	struct sysfs_open_file *of = sysfs_of(file);
+	int ret;
+
+	if (!of->vm_ops)
+		return VM_FAULT_SIGBUS;
+
+	if (!sysfs_get_active(of->sd))
+		return VM_FAULT_SIGBUS;
+
+	ret = 0;
+	if (of->vm_ops->page_mkwrite)
+		ret = of->vm_ops->page_mkwrite(vma, vmf);
+	else
+		file_update_time(file);
+
+	sysfs_put_active(of->sd);
+	return ret;
+}
+
+static int kernfs_vma_access(struct vm_area_struct *vma, unsigned long addr,
+			     void *buf, int len, int write)
+{
+	struct file *file = vma->vm_file;
+	struct sysfs_open_file *of = sysfs_of(file);
+	int ret;
+
+	if (!of->vm_ops)
+		return -EINVAL;
+
+	if (!sysfs_get_active(of->sd))
+		return -EINVAL;
+
+	ret = -EINVAL;
+	if (of->vm_ops->access)
+		ret = of->vm_ops->access(vma, addr, buf, len, write);
+
+	sysfs_put_active(of->sd);
+	return ret;
+}
+
+#ifdef CONFIG_NUMA
+static int kernfs_vma_set_policy(struct vm_area_struct *vma,
+				 struct mempolicy *new)
+{
+	struct file *file = vma->vm_file;
+	struct sysfs_open_file *of = sysfs_of(file);
+	int ret;
+
+	if (!of->vm_ops)
+		return 0;
+
+	if (!sysfs_get_active(of->sd))
+		return -EINVAL;
+
+	ret = 0;
+	if (of->vm_ops->set_policy)
+		ret = of->vm_ops->set_policy(vma, new);
+
+	sysfs_put_active(of->sd);
+	return ret;
+}
+
+static struct mempolicy *kernfs_vma_get_policy(struct vm_area_struct *vma,
+					       unsigned long addr)
+{
+	struct file *file = vma->vm_file;
+	struct sysfs_open_file *of = sysfs_of(file);
+	struct mempolicy *pol;
+
+	if (!of->vm_ops)
+		return vma->vm_policy;
+
+	if (!sysfs_get_active(of->sd))
+		return vma->vm_policy;
+
+	pol = vma->vm_policy;
+	if (of->vm_ops->get_policy)
+		pol = of->vm_ops->get_policy(vma, addr);
+
+	sysfs_put_active(of->sd);
+	return pol;
+}
+
+static int kernfs_vma_migrate(struct vm_area_struct *vma,
+			      const nodemask_t *from, const nodemask_t *to,
+			      unsigned long flags)
+{
+	struct file *file = vma->vm_file;
+	struct sysfs_open_file *of = sysfs_of(file);
+	int ret;
+
+	if (!of->vm_ops)
+		return 0;
+
+	if (!sysfs_get_active(of->sd))
+		return 0;
+
+	ret = 0;
+	if (of->vm_ops->migrate)
+		ret = of->vm_ops->migrate(vma, from, to, flags);
+
+	sysfs_put_active(of->sd);
+	return ret;
+}
+#endif
+
+static const struct vm_operations_struct kernfs_vm_ops = {
+	.open		= kernfs_vma_open,
+	.fault		= kernfs_vma_fault,
+	.page_mkwrite	= kernfs_vma_page_mkwrite,
+	.access		= kernfs_vma_access,
+#ifdef CONFIG_NUMA
+	.set_policy	= kernfs_vma_set_policy,
+	.get_policy	= kernfs_vma_get_policy,
+	.migrate	= kernfs_vma_migrate,
+#endif
+};
+
+static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct sysfs_open_file *of = sysfs_of(file);
+	const struct kernfs_ops *ops;
+	int rc;
+
+	mutex_lock(&of->mutex);
+
+	rc = -ENODEV;
+	if (!sysfs_get_active(of->sd))
+		goto out_unlock;
+
+	ops = kernfs_ops(of->sd);
+	if (ops->mmap)
+		rc = ops->mmap(of, vma);
+	if (rc)
+		goto out_put;
+
+	/*
+	 * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()
+	 * to satisfy versions of X which crash if the mmap fails: that
+	 * substitutes a new vm_file, and we don't then want bin_vm_ops.
+	 */
+	if (vma->vm_file != file)
+		goto out_put;
+
+	rc = -EINVAL;
+	if (of->mmapped && of->vm_ops != vma->vm_ops)
+		goto out_put;
+
+	/*
+	 * It is not possible to successfully wrap close.
+	 * So error if someone is trying to use close.
+	 */
+	rc = -EINVAL;
+	if (vma->vm_ops && vma->vm_ops->close)
+		goto out_put;
+
+	rc = 0;
+	of->mmapped = 1;
+	of->vm_ops = vma->vm_ops;
+	vma->vm_ops = &kernfs_vm_ops;
+out_put:
+	sysfs_put_active(of->sd);
+out_unlock:
+	mutex_unlock(&of->mutex);
+
+	return rc;
+}
+
+/**
+ *	sysfs_get_open_dirent - get or create sysfs_open_dirent
+ *	@sd: target sysfs_dirent
+ *	@of: sysfs_open_file for this instance of open
+ *
+ *	If @sd->s_attr.open exists, increment its reference count;
+ *	otherwise, create one.  @of is chained to the files list.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep).
+ *
+ *	RETURNS:
+ *	0 on success, -errno on failure.
+ */
+static int sysfs_get_open_dirent(struct sysfs_dirent *sd,
+				 struct sysfs_open_file *of)
+{
+	struct sysfs_open_dirent *od, *new_od = NULL;
+
+ retry:
+	mutex_lock(&sysfs_open_file_mutex);
+	spin_lock_irq(&sysfs_open_dirent_lock);
+
+	if (!sd->s_attr.open && new_od) {
+		sd->s_attr.open = new_od;
+		new_od = NULL;
+	}
+
+	od = sd->s_attr.open;
+	if (od) {
+		atomic_inc(&od->refcnt);
+		list_add_tail(&of->list, &od->files);
+	}
+
+	spin_unlock_irq(&sysfs_open_dirent_lock);
+	mutex_unlock(&sysfs_open_file_mutex);
+
+	if (od) {
+		kfree(new_od);
+		return 0;
+	}
+
+	/* not there, initialize a new one and retry */
+	new_od = kmalloc(sizeof(*new_od), GFP_KERNEL);
+	if (!new_od)
+		return -ENOMEM;
+
+	atomic_set(&new_od->refcnt, 0);
+	atomic_set(&new_od->event, 1);
+	init_waitqueue_head(&new_od->poll);
+	INIT_LIST_HEAD(&new_od->files);
+	goto retry;
+}
+
+/**
+ *	sysfs_put_open_dirent - put sysfs_open_dirent
+ *	@sd: target sysfs_dirent
+ *	@of: associated sysfs_open_file
+ *
+ *	Put @sd->s_attr.open and unlink @of from the files list.  If
+ *	reference count reaches zero, disassociate and free it.
+ *
+ *	LOCKING:
+ *	None.
+ */
+static void sysfs_put_open_dirent(struct sysfs_dirent *sd,
+				  struct sysfs_open_file *of)
+{
+	struct sysfs_open_dirent *od = sd->s_attr.open;
+	unsigned long flags;
+
+	mutex_lock(&sysfs_open_file_mutex);
+	spin_lock_irqsave(&sysfs_open_dirent_lock, flags);
+
+	if (of)
+		list_del(&of->list);
+
+	if (atomic_dec_and_test(&od->refcnt))
+		sd->s_attr.open = NULL;
+	else
+		od = NULL;
+
+	spin_unlock_irqrestore(&sysfs_open_dirent_lock, flags);
+	mutex_unlock(&sysfs_open_file_mutex);
+
+	kfree(od);
+}
+
+static int kernfs_file_open(struct inode *inode, struct file *file)
+{
+	struct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;
+	const struct kernfs_ops *ops;
+	struct sysfs_open_file *of;
+	bool has_read, has_write, has_mmap;
+	int error = -EACCES;
+
+	if (!sysfs_get_active(attr_sd))
+		return -ENODEV;
+
+	ops = kernfs_ops(attr_sd);
+
+	has_read = ops->seq_show || ops->read || ops->mmap;
+	has_write = ops->write || ops->mmap;
+	has_mmap = ops->mmap;
+
+	/* check perms and supported operations */
+	if ((file->f_mode & FMODE_WRITE) &&
+	    (!(inode->i_mode & S_IWUGO) || !has_write))
+		goto err_out;
+
+	if ((file->f_mode & FMODE_READ) &&
+	    (!(inode->i_mode & S_IRUGO) || !has_read))
+		goto err_out;
+
+	/* allocate a sysfs_open_file for the file */
+	error = -ENOMEM;
+	of = kzalloc(sizeof(struct sysfs_open_file), GFP_KERNEL);
+	if (!of)
+		goto err_out;
+
+	/*
+	 * The following is done to give a different lockdep key to
+	 * @of->mutex for files which implement mmap.  This is a rather
+	 * crude way to avoid false positive lockdep warning around
+	 * mm->mmap_sem - mmap nests @of->mutex under mm->mmap_sem and
+	 * reading /sys/block/sda/trace/act_mask grabs sr_mutex, under
+	 * which mm->mmap_sem nests, while holding @of->mutex.  As each
+	 * open file has a separate mutex, it's okay as long as those don't
+	 * happen on the same file.  At this point, we can't easily give
+	 * each file a separate locking class.  Let's differentiate on
+	 * whether the file has mmap or not for now.
+	 */
+	if (has_mmap)
+		mutex_init(&of->mutex);
+	else
+		mutex_init(&of->mutex);
+
+	of->sd = attr_sd;
+	of->file = file;
+
+	/*
+	 * Always instantiate seq_file even if read access doesn't use
+	 * seq_file or is not requested.  This unifies private data access
+	 * and readable regular files are the vast majority anyway.
+	 */
+	if (ops->seq_show)
+		error = seq_open(file, &kernfs_seq_ops);
+	else
+		error = seq_open(file, NULL);
+	if (error)
+		goto err_free;
+
+	((struct seq_file *)file->private_data)->private = of;
+
+	/* seq_file clears PWRITE unconditionally, restore it if WRITE */
+	if (file->f_mode & FMODE_WRITE)
+		file->f_mode |= FMODE_PWRITE;
+
+	/* make sure we have open dirent struct */
+	error = sysfs_get_open_dirent(attr_sd, of);
+	if (error)
+		goto err_close;
+
+	/* open succeeded, put active references */
+	sysfs_put_active(attr_sd);
+	return 0;
+
+err_close:
+	seq_release(inode, file);
+err_free:
+	kfree(of);
+err_out:
+	sysfs_put_active(attr_sd);
+	return error;
+}
+
+static int kernfs_file_release(struct inode *inode, struct file *filp)
+{
+	struct sysfs_dirent *sd = filp->f_path.dentry->d_fsdata;
+	struct sysfs_open_file *of = sysfs_of(filp);
+
+	sysfs_put_open_dirent(sd, of);
+	seq_release(inode, filp);
+	kfree(of);
+
+	return 0;
+}
+
+void sysfs_unmap_bin_file(struct sysfs_dirent *sd)
+{
+	struct sysfs_open_dirent *od;
+	struct sysfs_open_file *of;
+
+	if (!(sd->s_flags & SYSFS_FLAG_HAS_MMAP))
+		return;
+
+	spin_lock_irq(&sysfs_open_dirent_lock);
+	od = sd->s_attr.open;
+	if (od)
+		atomic_inc(&od->refcnt);
+	spin_unlock_irq(&sysfs_open_dirent_lock);
+	if (!od)
+		return;
+
+	mutex_lock(&sysfs_open_file_mutex);
+	list_for_each_entry(of, &od->files, list) {
+		struct inode *inode = file_inode(of->file);
+		unmap_mapping_range(inode->i_mapping, 0, 0, 1);
+	}
+	mutex_unlock(&sysfs_open_file_mutex);
+
+	sysfs_put_open_dirent(sd, NULL);
+}
+
+/* Sysfs attribute files are pollable.  The idea is that you read
+ * the content and then you use 'poll' or 'select' to wait for
+ * the content to change.  When the content changes (assuming the
+ * manager for the kobject supports notification), poll will
+ * return POLLERR|POLLPRI, and select will return the fd whether
+ * it is waiting for read, write, or exceptions.
+ * Once poll/select indicates that the value has changed, you
+ * need to close and re-open the file, or seek to 0 and read again.
+ * Reminder: this only works for attributes which actively support
+ * it, and it is not possible to test an attribute from userspace
+ * to see if it supports poll (Neither 'poll' nor 'select' return
+ * an appropriate error code).  When in doubt, set a suitable timeout value.
+ */
+static unsigned int kernfs_file_poll(struct file *filp, poll_table *wait)
+{
+	struct sysfs_open_file *of = sysfs_of(filp);
+	struct sysfs_dirent *attr_sd = filp->f_path.dentry->d_fsdata;
+	struct sysfs_open_dirent *od = attr_sd->s_attr.open;
+
+	/* need parent for the kobj, grab both */
+	if (!sysfs_get_active(attr_sd))
+		goto trigger;
+
+	poll_wait(filp, &od->poll, wait);
+
+	sysfs_put_active(attr_sd);
+
+	if (of->event != atomic_read(&od->event))
+		goto trigger;
+
+	return DEFAULT_POLLMASK;
+
+ trigger:
+	return DEFAULT_POLLMASK|POLLERR|POLLPRI;
+}
+
+/**
+ * kernfs_notify - notify a kernfs file
+ * @sd: file to notify
+ *
+ * Notify @sd such that poll(2) on @sd wakes up.
+ */
+void kernfs_notify(struct sysfs_dirent *sd)
+{
+	struct sysfs_open_dirent *od;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sysfs_open_dirent_lock, flags);
+
+	if (!WARN_ON(sysfs_type(sd) != SYSFS_KOBJ_ATTR)) {
+		od = sd->s_attr.open;
+		if (od) {
+			atomic_inc(&od->event);
+			wake_up_interruptible(&od->poll);
+		}
+	}
+
+	spin_unlock_irqrestore(&sysfs_open_dirent_lock, flags);
+}
+EXPORT_SYMBOL_GPL(kernfs_notify);
+
+const struct file_operations kernfs_file_operations = {
+	.read		= kernfs_file_read,
+	.write		= kernfs_file_write,
+	.llseek		= generic_file_llseek,
+	.mmap		= kernfs_file_mmap,
+	.open		= kernfs_file_open,
+	.release	= kernfs_file_release,
+	.poll		= kernfs_file_poll,
+};
+
+/**
+ * kernfs_create_file_ns_key - create a file
+ * @parent: directory to create the file in
+ * @name: name of the file
+ * @mode: mode of the file
+ * @size: size of the file
+ * @ops: kernfs operations for the file
+ * @priv: private data for the file
+ * @ns: optional namespace tag of the file
+ * @key: lockdep key for the file's active_ref, %NULL to disable lockdep
+ *
+ * Returns the created node on success, ERR_PTR() value on error.
+ */
+struct sysfs_dirent *kernfs_create_file_ns_key(struct sysfs_dirent *parent,
+					       const char *name,
+					       umode_t mode, loff_t size,
+					       const struct kernfs_ops *ops,
+					       void *priv, const void *ns,
+					       struct lock_class_key *key)
+{
+	struct sysfs_addrm_cxt acxt;
+	struct sysfs_dirent *sd;
+	int rc;
+
+	sd = sysfs_new_dirent(name, (mode & S_IALLUGO) | S_IFREG,
+			      SYSFS_KOBJ_ATTR);
+	if (!sd)
+		return ERR_PTR(-ENOMEM);
+
+	sd->s_attr.ops = ops;
+	sd->s_attr.size = size;
+	sd->s_ns = ns;
+	sd->priv = priv;
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	if (key) {
+		lockdep_init_map(&sd->dep_map, "s_active", key, 0);
+		sd->s_flags |= SYSFS_FLAG_LOCKDEP;
+	}
+#endif
+
+	/*
+	 * sd->s_attr.ops is accesible only while holding active ref.  We
+	 * need to know whether some ops are implemented outside active
+	 * ref.  Cache their existence in flags.
+	 */
+	if (ops->seq_show)
+		sd->s_flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
+	if (ops->mmap)
+		sd->s_flags |= SYSFS_FLAG_HAS_MMAP;
+
+	sysfs_addrm_start(&acxt);
+	rc = sysfs_add_one(&acxt, sd, parent);
+	sysfs_addrm_finish(&acxt);
+
+	if (rc) {
+		kernfs_put(sd);
+		return ERR_PTR(rc);
+	}
+	return sd;
+}

commit b8441ed279bff09a0a5ddeacf8f4087d2fb424ca
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Nov 24 09:54:58 2013 -0500

    sysfs, kernfs: add skeletons for kernfs
    
    Core sysfs implementation will be separated into kernfs so that it can
    be used by other non-kobject users.
    
    This patch creates fs/kernfs/ directory and makes boilerplate changes.
    kernfs interface will be directly based on sysfs_dirent and its
    forward declaration is moved to include/linux/kernfs.h which is
    included from include/linux/sysfs.h.  sysfs core implementation will
    be gradually separated out and moved to kernfs.
    
    This patch doesn't introduce any functional changes.
    
    v2: mount.c added.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c
new file mode 100644
index 000000000000..90b1e88dad44
--- /dev/null
+++ b/fs/kernfs/file.c
@@ -0,0 +1,9 @@
+/*
+ * fs/kernfs/file.c - kernfs file implementation
+ *
+ * Copyright (c) 2001-3 Patrick Mochel
+ * Copyright (c) 2007 SUSE Linux Products GmbH
+ * Copyright (c) 2007, 2013 Tejun Heo <tj@kernel.org>
+ *
+ * This file is released under the GPLv2.
+ */
