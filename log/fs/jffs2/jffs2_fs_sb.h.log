commit 5817b9dc9cc1225feedd9e1282707165fc64c384
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Feb 1 12:00:25 2016 +0000

    jffs2: Improve post-mount CRC scan efficiency
    
    We need to finish doing the CRC checks before we can allow writes to
    happen, and we currently process the inodes in order. This means a call
    to jffs2_get_ino_cache() for each possible inode# up to c->highest_ino.
    
    There may be a lot of lookups which fail, if the inode# space is used
    sparsely. And the inode# space is *often* used sparsely, if a file
    system contains a lot of stuff that was put there in the original
    image, followed by lots of creation and deletion of new files.
    
    Instead of processing them numerically with a lookup each time, just
    walk the hash buckets instead.
    
    [fix locking typo reported by Dan Carpenter]
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 046fee8b6e9b..778275f48a87 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -49,7 +49,7 @@ struct jffs2_sb_info {
 	struct mtd_info *mtd;
 
 	uint32_t highest_ino;
-	uint32_t checked_ino;
+	uint32_t check_ino;		/* *NEXT* inode to be checked */
 
 	unsigned int flags;
 

commit 99358a1ca53e8e6ce09423500191396f0e6584d2
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Fri Aug 1 20:13:40 2014 +0100

    [jffs2] kill wbuf_queued/wbuf_dwork_lock
    
    schedule_delayed_work() happening when the work is already pending is
    a cheap no-op.  Don't bother with ->wbuf_queued logics - it's both
    broken (cancelling ->wbuf_dwork leaves it set, as spotted by Jeff Harris)
    and pointless.  It's cheaper to let schedule_delayed_work() handle that
    case.
    
    Reported-by: Jeff Harris <jefftharris@gmail.com>
    Tested-by: Jeff Harris <jefftharris@gmail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 413ef89c2d1b..046fee8b6e9b 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -134,8 +134,6 @@ struct jffs2_sb_info {
 	struct rw_semaphore wbuf_sem;	/* Protects the write buffer */
 
 	struct delayed_work wbuf_dwork; /* write-buffer write-out work */
-	int wbuf_queued;                /* non-zero delayed work is queued */
-	spinlock_t wbuf_dwork_lock;     /* protects wbuf_dwork and and wbuf_queued */
 
 	unsigned char *oobbuf;
 	int oobavail; /* How many bytes are available for JFFS2 in OOB */

commit 208b14e507c00ff7f108e1a388dd3d8cc805a443
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon May 7 19:02:46 2012 +0300

    jffs2: get rid of jffs2_sync_super
    
    Currently JFFS2 file-system maps the VFS "superblock" abstraction to the
    write-buffer. Namely, it uses VFS services to synchronize the write-buffer
    periodically.
    
    The whole "superblock write-out" VFS infrastructure is served by the
    'sync_supers()' kernel thread, which wakes up every 5 (by default) seconds and
    writes out all dirty superblock using the '->write_super()' call-back. But the
    problem with this thread is that it wastes power by waking up the system every
    5 seconds no matter what. So we want to kill it completely and thus, we need to
    make file-systems to stop using the '->write_super' VFS service, and then
    remove it together with the kernel thread.
    
    This patch switches the JFFS2 write-buffer management from
    '->write_super()'/'->s_dirt' to a delayed work. Instead of setting the 's_dirt'
    flag we just schedule a delayed work for synchronizing the write-buffer.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 0d00bf26923b..413ef89c2d1b 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -133,6 +133,10 @@ struct jffs2_sb_info {
 	struct jffs2_inodirty *wbuf_inodes;
 	struct rw_semaphore wbuf_sem;	/* Protects the write buffer */
 
+	struct delayed_work wbuf_dwork; /* write-buffer write-out work */
+	int wbuf_queued;                /* non-zero delayed work is queued */
+	spinlock_t wbuf_dwork_lock;     /* protects wbuf_dwork and and wbuf_queued */
+
 	unsigned char *oobbuf;
 	int oobavail; /* How many bytes are available for JFFS2 in OOB */
 #endif

commit 8da8ba2ea6ad52ea8558384f38586b0c1a516e9d
Author: Daniel Drake <dsd@laptop.org>
Date:   Tue Apr 10 22:22:35 2012 +0100

    JFFS2: Add parameter to reserve disk space for root
    
    Add a new rp_size= parameter which creates a "reserved pool" of disk
    space which can only be used by root. Other users are not permitted
    to write to disk when the available space is less than the pool size.
    
    Based on original code by Artem Bityutskiy in
    https://dev.laptop.org/ticket/5317
    
    [dwmw2: use capable(CAP_SYS_RESOURCE) not uid/gid check, fix debug prints]
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 55a0c1dceadf..0d00bf26923b 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -32,6 +32,13 @@ struct jffs2_inodirty;
 struct jffs2_mount_opts {
 	bool override_compr;
 	unsigned int compr;
+
+	/* The size of the reserved pool. The reserved pool is the JFFS2 flash
+	 * space which may only be used by root cannot be used by the other
+	 * users. This is implemented simply by means of not allowing the
+	 * latter users to write to the file system if the amount if the
+	 * available space is less then 'rp_size'. */
+	unsigned int rp_size;
 };
 
 /* A struct for the overall file system control.  Pointers to

commit 92abc475d8de1c29373f6d96ed63d8ecaa199d25
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Oct 16 18:15:16 2011 -0700

    jffs2: implement mount option parsing and compression overriding
    
    Currently jffs2 has compile-time constants (and .config options)
    controlling whether or not the various compression/decompression
    drivers are built in and enabled.  This is fine for embedded
    systems, but it clashes with distribution kernels.  Distro kernels
    tend to turn on everything; this causes OpenFirmware to fall
    over, as it understands ZLIB-compressed inodes.  Booting a kernel
    that has LZO compression enabled, writing to the boot partition,
    and then rebooting causes OFW to fail to read the kernel from
    the filesystem.  This is because LZO compression has priority
    when writing new data to jffs2, if LZO is enabled.
    
    This patch adds mount option parsing, and a single supported
    option ("compr=none").  This adds the flexibility of being
    able to specify which compressor overrides on a per-superblock
    basis.  For now, we can simply disable compression;
    additional flexibility coming soon.
    
    v2: kill some printks, and implement show_options as suggested
    by Artem Bityutskiy.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 0bc6a6c80a56..55a0c1dceadf 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -29,6 +29,11 @@
 
 struct jffs2_inodirty;
 
+struct jffs2_mount_opts {
+	bool override_compr;
+	unsigned int compr;
+};
+
 /* A struct for the overall file system control.  Pointers to
    jffs2_sb_info structs are named `c' in the source code.
    Nee jffs_control
@@ -126,6 +131,7 @@ struct jffs2_sb_info {
 #endif
 
 	struct jffs2_summary *summary;		/* Summary information */
+	struct jffs2_mount_opts mount_opts;
 
 #ifdef CONFIG_JFFS2_FS_XATTR
 #define XATTRINDEX_HASHSIZE	(57)

commit 027d9ac2c8de9f70b7319e08dee121b8b85c8d88
Author: Dan Carpenter <error27@gmail.com>
Date:   Mon Nov 15 21:20:05 2010 +0300

    jffs2: typo in comment
    
    It says FB instead of FS (file system).
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index f864005de64c..0bc6a6c80a56 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -144,4 +144,4 @@ struct jffs2_sb_info {
 	void *os_priv;
 };
 
-#endif /* _JFFS2_FB_SB */
+#endif /* _JFFS2_FS_SB */

commit 65e5a0e18e5fb5bc6cfabd8ef4b9fc1c8569ba62
Author: Daniel Drake <dsd@laptop.org>
Date:   Thu Oct 7 19:14:02 2010 +0100

    jffs2: Dynamically choose inocache hash size
    
    When JFFS2 is used for large volumes, the mount times are quite long.
    Increasing the hash size provides a significant speed boost on the OLPC
    XO-1 laptop.
    
    Add logic that dynamically selects a hash size based on the size of
    the medium. A 64mb medium will result in a hash size of 128, and a 512mb
    medium will result in a hash size of 1024.
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 6784bc89add1..f864005de64c 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -100,6 +100,7 @@ struct jffs2_sb_info {
 	wait_queue_head_t erase_wait;		/* For waiting for erases to complete */
 
 	wait_queue_head_t inocache_wq;
+	int inocache_hashsize;
 	struct jffs2_inode_cache **inocache_list;
 	spinlock_t inocache_lock;
 

commit 6088c0587706b2cf21ce50c11576718bff5fae0c
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 14:15:22 2010 +0100

    jffs2: Update copyright notices
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 85ef6dbb1be7..6784bc89add1 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -2,6 +2,7 @@
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
  * Copyright © 2001-2007 Red Hat, Inc.
+ * Copyright © 2004-2010 David Woodhouse <dwmw2@infradead.org>
  *
  * Created by David Woodhouse <dwmw2@infradead.org>
  *

commit e2bc322bf05936ec7160d62bc3fd45cbf4aa405a
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 23 14:15:24 2008 +0100

    [JFFS2] Add erase_checking_list to hold blocks being marked.
    
    Just to keep the debug code happy when it's adding all the blocks up.
    Otherwise, they disappear for a while while the locks are dropped to
    check them and write the cleanmarker.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index d9c4b27575e8..85ef6dbb1be7 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -87,6 +87,7 @@ struct jffs2_sb_info {
 	struct list_head erasable_list;		/* Blocks which are completely dirty, and need erasing */
 	struct list_head erasable_pending_wbuf_list;	/* Blocks which need erasing but only after the current wbuf is flushed */
 	struct list_head erasing_list;		/* Blocks which are currently erasing */
+	struct list_head erase_checking_list;	/* Blocks which are being checked and marked */
 	struct list_head erase_pending_list;	/* Blocks which need erasing now */
 	struct list_head erase_complete_list;	/* Blocks which are erased and need the clean marker written to them */
 	struct list_head free_list;		/* Blocks which are free and ready to be used */

commit ced22070363ef50e4a47aadd003a81ebeaa3f917
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Apr 22 15:13:40 2008 +0100

    [JFFS2] semaphore->mutex conversion
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 18fca2b9e531..d9c4b27575e8 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -16,7 +16,7 @@
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
 #include <linux/completion.h>
-#include <linux/semaphore.h>
+#include <linux/mutex.h>
 #include <linux/timer.h>
 #include <linux/wait.h>
 #include <linux/list.h>
@@ -44,7 +44,7 @@ struct jffs2_sb_info {
 	struct completion gc_thread_start; /* GC thread start completion */
 	struct completion gc_thread_exit; /* GC thread exit completion port */
 
-	struct semaphore alloc_sem;	/* Used to protect all the following
+	struct mutex alloc_sem;		/* Used to protect all the following
 					   fields, and also to protect against
 					   out-of-order writing of nodes. And GC. */
 	uint32_t cleanmarker_size;	/* Size of an _inline_ CLEANMARKER
@@ -104,7 +104,7 @@ struct jffs2_sb_info {
 	/* Sem to allow jffs2_garbage_collect_deletion_dirent to
 	   drop the erase_completion_lock while it's holding a pointer
 	   to an obsoleted node. I don't like this. Alternatives welcomed. */
-	struct semaphore erase_free_sem;
+	struct mutex erase_free_sem;
 
 	uint32_t wbuf_pagesize; /* 0 for NOR and other flashes with no wbuf */
 

commit 6188e10d38b8d7244ee7776d5f1f88c837b4b93f
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Apr 18 22:21:05 2008 -0400

    Convert asm/semaphore.h users to linux/semaphore.h
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 3a2197f3c812..18fca2b9e531 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -16,7 +16,7 @@
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
 #include <linux/completion.h>
-#include <asm/semaphore.h>
+#include <linux/semaphore.h>
 #include <linux/timer.h>
 #include <linux/wait.h>
 #include <linux/list.h>

commit 8fb870df5a1f261294b833dd807bcba3bacface6
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat Oct 6 15:12:58 2007 -0400

    [JFFS2] Trigger garbage collection when very_dirty_list size becomes excessive
    
    With huge amounts of free space, we weren't bothering to GC for while a
    while, and pathological numbers of obsolete nodes were accumulating,
    seriously affecting performance on NAND flash (OLPC trac #3978)
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index ae99cd7fd43b..3a2197f3c812 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -69,6 +69,8 @@ struct jffs2_sb_info {
 	uint8_t resv_blocks_gctrigger;	/* ... wake up the GC thread */
 	uint8_t resv_blocks_gcbad;	/* ... pick a block from the bad_list to GC */
 	uint8_t resv_blocks_gcmerge;	/* ... merge pages when garbage collecting */
+	/* Number of 'very dirty' blocks before we trigger immediate GC */
+	uint8_t vdirty_blocks_gctrigger;
 
 	uint32_t nospc_dirty_size;
 

commit a6bc432e296dfa1f05d4b586ca5ca3085a2d42d7
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Jul 11 14:23:54 2007 +0100

    [JFFS2] Add support for write-buffer verification.
    
    We've seen some evil corruption issues, where the corruption seems to be
    introduced after the JFFS2 crc32 is calculated but before the NAND
    controller calculates the ECC. So it's in RAM or in the PCI DMA
    transfer; not on the flash. Attempt to catch it earlier by (optionally)
    reading back from the flash immediately after writing it.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index b13298a824ed..ae99cd7fd43b 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -106,6 +106,9 @@ struct jffs2_sb_info {
 
 	uint32_t wbuf_pagesize; /* 0 for NOR and other flashes with no wbuf */
 
+#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY
+	unsigned char *wbuf_verify; /* read-back buffer for verification */
+#endif
 #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
 	unsigned char *wbuf; /* Write-behind buffer for NAND flash */
 	uint32_t wbuf_ofs;

commit c00c310eac04a28d2143368ae988716792ed53ce
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 25 14:16:47 2007 +0100

    [JFFS2] Tidy up licensing/copyright boilerplate.
    
    In particular, remove the bit in the LICENCE file about contacting
    Red Hat for alternative arrangements. Their errant IS department broke
    that arrangement a long time ago -- the policy of collecting copyright
    assignments from contributors came to an end when the plug was pulled on
    the servers hosting the project, without notice or reason.
    
    We do still dual-license it for use with eCos, with the GPL+exception
    licence approved by the FSF as being GPL-compatible. It's just that nobody
    has the right to license it differently.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index ea88f69af130..b13298a824ed 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -1,4 +1,13 @@
-/* $Id: jffs2_fs_sb.h,v 1.54 2005/09/21 13:37:34 dedekind Exp $ */
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright © 2001-2007 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@infradead.org>
+ *
+ * For licensing information, see the file 'LICENCE' in this directory.
+ *
+ */
 
 #ifndef _JFFS2_FS_SB
 #define _JFFS2_FS_SB

commit a7a6ace1406f95c3edb8365788f85984377f3832
Author: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date:   Wed Jan 31 11:38:53 2007 +0200

    [JFFS2] Use MTD_OOB_AUTO to automatically place cleanmarker on NAND
    
    Nowadays MTD supports an MTD_OOB_AUTO option which allows users
    to access free bytes in NAND's OOB as a contiguous buffer, although
    it may be highly discontinuous.
    
    This patch teaches JFFS2 to use this nice feature instead of the
    old MTD_OOB_PLACE option. This for example caused problems with
    OneNAND. Now JFFS2 does not care how are the free bytes situated.
    
    This may change position of the clean marker on some flashes,
    but this is not a problem. JFFS2 will just re-erase the empty
    eraseblocks and write the new (correct) clean marker.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index b98594992eed..ea88f69af130 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -98,20 +98,14 @@ struct jffs2_sb_info {
 	uint32_t wbuf_pagesize; /* 0 for NOR and other flashes with no wbuf */
 
 #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
-	/* Write-behind buffer for NAND flash */
-	unsigned char *wbuf;
-	unsigned char *oobbuf;
+	unsigned char *wbuf; /* Write-behind buffer for NAND flash */
 	uint32_t wbuf_ofs;
 	uint32_t wbuf_len;
 	struct jffs2_inodirty *wbuf_inodes;
-
 	struct rw_semaphore wbuf_sem;	/* Protects the write buffer */
 
-	/* Information about out-of-band area usage... */
-	struct nand_ecclayout *ecclayout;
-	uint32_t badblock_pos;
-	uint32_t fsdata_pos;
-	uint32_t fsdata_len;
+	unsigned char *oobbuf;
+	int oobavail; /* How many bytes are available for JFFS2 in OOB */
 #endif
 
 	struct jffs2_summary *summary;		/* Summary information */

commit c9f700f840bd481b3e01fcad1ba8da01794a6726
Author: KaiGai Kohei <kaigai@ak.jp.nec.com>
Date:   Sun Jun 11 10:35:15 2006 +0900

    [JFFS2][XATTR] using 'delete marker' for xdatum/xref deletion
    
    - When xdatum is removed, a new xdatum with 'delete marker' is
      written. (version==0xffffffff means 'delete marker')
    - When xref is removed, a new xref with 'delete marker' is written.
      (odd-numbered xseqno means 'delete marker')
    
    - delete_xattr_(datum/xref)_delay() are new deletion functions
      are added. We can only use them if we can detect the target
      obsolete xdatum/xref as a orphan or errir one.
      (e.g when inode deletion, or detecting crc error)
    
    [1/3] jffs2-xattr-v6-01-delete_marker.patch
    
    Signed-off-by: KaiGai Kohei <kaigai@ak.jp.nec.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 935fec1b1201..b98594992eed 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -119,8 +119,11 @@ struct jffs2_sb_info {
 #ifdef CONFIG_JFFS2_FS_XATTR
 #define XATTRINDEX_HASHSIZE	(57)
 	uint32_t highest_xid;
+	uint32_t highest_xseqno;
 	struct list_head xattrindex[XATTRINDEX_HASHSIZE];
 	struct list_head xattr_unchecked;
+	struct list_head xattr_dead_list;
+	struct jffs2_xattr_ref *xref_dead_list;
 	struct jffs2_xattr_ref *xref_temp;
 	struct rw_semaphore xattr_sem;
 	uint32_t xdatum_mem_usage;

commit 8593fbc68b0df1168995de76d1af38eb62fd6b62
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Mon May 29 03:26:58 2006 +0200

    [MTD] Rework the out of band handling completely
    
    Hopefully the last iteration on this!
    
    The handling of out of band data on NAND was accompanied by tons of fruitless
    discussions and halfarsed patches to make it work for a particular
    problem. Sufficiently annoyed by I all those "I know it better" mails and the
    resonable amount of discarded "it solves my problem" patches, I finally decided
    to go for the big rework. After removing the _ecc variants of mtd read/write
    functions the solution to satisfy the various requirements was to refactor the
    read/write _oob functions in mtd.
    
    The major change is that read/write_oob now takes a pointer to an operation
    descriptor structure "struct mtd_oob_ops".instead of having a function with at
    least seven arguments.
    
    read/write_oob which should probably renamed to a more descriptive name, can do
    the following tasks:
    
    - read/write out of band data
    - read/write data content and out of band data
    - read/write raw data content and out of band data (ecc disabled)
    
    struct mtd_oob_ops has a mode field, which determines the oob handling mode.
    
    Aside of the MTD_OOB_RAW mode, which is intended to be especially for
    diagnostic purposes and some internal functions e.g. bad block table creation,
    the other two modes are for mtd clients:
    
    MTD_OOB_PLACE puts/gets the given oob data exactly to/from the place which is
    described by the ooboffs and ooblen fields of the mtd_oob_ops strcuture. It's
    up to the caller to make sure that the byte positions are not used by the ECC
    placement algorithms.
    
    MTD_OOB_AUTO puts/gets the given oob data automaticaly to/from the places in
    the out of band area which are described by the oobfree tuples in the ecclayout
    data structre which is associated to the devicee.
    
    The decision whether data plus oob or oob only handling is done depends on the
    setting of the datbuf member of the data structure. When datbuf == NULL then
    the internal read/write_oob functions are selected, otherwise the read/write
    data routines are invoked.
    
    Tested on a few platforms with all variants. Please be aware of possible
    regressions for your particular device / application scenario
    
    Disclaimer: Any whining will be ignored from those who just contributed "hot
    air blurb" and never sat down to tackle the underlying problem of the mess in
    the NAND driver grown over time and the big chunk of work to fix up the
    existing users. The problem was not the holiness of the existing MTD
    interfaces. The problems was the lack of time to go for the big overhaul. It's
    easy to add more mess to the existing one, but it takes alot of effort to go
    for a real solution.
    
    Improvements and bugfixes are welcome!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 506690cc9a78..935fec1b1201 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -100,6 +100,7 @@ struct jffs2_sb_info {
 #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
 	/* Write-behind buffer for NAND flash */
 	unsigned char *wbuf;
+	unsigned char *oobbuf;
 	uint32_t wbuf_ofs;
 	uint32_t wbuf_len;
 	struct jffs2_inodirty *wbuf_inodes;

commit 5bd34c091a044d130601370c370f84b1c59f1627
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Sat May 27 22:16:10 2006 +0200

    [MTD] NAND Replace oobinfo by ecclayout
    
    The nand_oobinfo structure is not fitting the newer error correction
    demands anymore. Replace it by struct nand_ecclayout and fixup the users
    all over the place. Keep the nand_oobinfo based ioctl for user space
    compability reasons.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 272fbea55192..506690cc9a78 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -107,7 +107,7 @@ struct jffs2_sb_info {
 	struct rw_semaphore wbuf_sem;	/* Protects the write buffer */
 
 	/* Information about out-of-band area usage... */
-	struct nand_oobinfo *oobinfo;
+	struct nand_ecclayout *ecclayout;
 	uint32_t badblock_pos;
 	uint32_t fsdata_pos;
 	uint32_t fsdata_len;

commit 9bfeb691e75b21fdaa80ffae719083200b190381
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Fri May 26 21:19:05 2006 +0100

    [JFFS2] Switch to using an array of jffs2_raw_node_refs instead of a list.
    
    This allows us to drop another pointer from the struct jffs2_raw_node_ref,
    shrinking it to 8 bytes on 32-bit machines (if the TEST_TOTLEN) paranoia
    check is turned off, which will be committed soon).
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 67529f0a44dd..272fbea55192 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -26,9 +26,6 @@ struct jffs2_inodirty;
 struct jffs2_sb_info {
 	struct mtd_info *mtd;
 
-	struct jffs2_raw_node_ref *refs;
-	int reserved_refs;
-
 	uint32_t highest_ino;
 	uint32_t checked_ino;
 

commit 2f785402f39b96a077b6e62bf26164bfb8e0c980
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed May 24 02:04:45 2006 +0100

    [JFFS2] Reduce visibility of raw_node_ref to upper layers of JFFS2 code.
    
    As the first step towards eliminating the ref->next_phys member and saving
    memory by using an _array_ of struct jffs2_raw_node_ref per eraseblock,
    stop the write functions from allocating their own refs; have them just
    _reserve_ the appropriate number instead. Then jffs2_link_node_ref() can
    just fill them in.
    
    Use a linked list of pre-allocated refs in the superblock, for now. Once
    we switch to an array, it'll just be a case of extending that array.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 272fbea55192..67529f0a44dd 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -26,6 +26,9 @@ struct jffs2_inodirty;
 struct jffs2_sb_info {
 	struct mtd_info *mtd;
 
+	struct jffs2_raw_node_ref *refs;
+	int reserved_refs;
+
 	uint32_t highest_ino;
 	uint32_t checked_ino;
 

commit 8f2b6f49c656dd4597904f8c20661d6b73cdbbeb
Author: KaiGai Kohei <kaigai@ak.jp.nec.com>
Date:   Sat May 13 15:15:07 2006 +0900

    [JFFS2][XATTR] Remove 'struct list_head ilist' from jffs2_inode_cache.
    
    This patch can reduce 4-byte of memory usage per inode_cache.
    
    [4/10] jffs2-xattr-v5.1-04-remove_ilist_from_ic.patch
    
    Signed-off-by: KaiGai Kohei <kaigai@ak.jp.nec.com>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 3b4e0edd6dbb..272fbea55192 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -119,8 +119,8 @@ struct jffs2_sb_info {
 #define XATTRINDEX_HASHSIZE	(57)
 	uint32_t highest_xid;
 	struct list_head xattrindex[XATTRINDEX_HASHSIZE];
-	struct list_head xattr_temp;
 	struct list_head xattr_unchecked;
+	struct jffs2_xattr_ref *xref_temp;
 	struct rw_semaphore xattr_sem;
 	uint32_t xdatum_mem_usage;
 	uint32_t xdatum_mem_threshold;

commit aa98d7cf59b5b0764d3502662053489585faf2fe
Author: KaiGai Kohei <kaigai@ak.jp.nec.com>
Date:   Sat May 13 15:09:47 2006 +0900

    [JFFS2][XATTR] XATTR support on JFFS2 (version. 5)
    
    This attached patches provide xattr support including POSIX-ACL and
    SELinux support on JFFS2 (version.5).
    
    There are some significant differences from previous version posted
    at last December.
    The biggest change is addition of EBS(Erase Block Summary) support.
    Currently, both kernel and usermode utility (sumtool) can recognize
    xattr nodes which have JFFS2_NODETYPE_XATTR/_XREF nodetype.
    
    In addition, some bugs are fixed.
    - A potential race condition was fixed.
    - Unexpected fail when updating a xattr by same name/value pair was fixed.
    - A bug when removing xattr name/value pair was fixed.
    
    The fundamental structures (such as using two new nodetypes and exclusion
    mechanism by rwsem) are unchanged. But most of implementation were reviewed
    and updated if necessary.
    Espacially, we had to change several internal implementations related to
    load_xattr_datum() to avoid a potential race condition.
    
    [1/2] xattr_on_jffs2.kernel.version-5.patch
    [2/2] xattr_on_jffs2.utils.version-5.patch
    
    Signed-off-by: KaiGai Kohei <kaigai@ak.jp.nec.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
index 4bcfb5570221..3b4e0edd6dbb 100644
--- a/fs/jffs2/jffs2_fs_sb.h
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -115,6 +115,16 @@ struct jffs2_sb_info {
 
 	struct jffs2_summary *summary;		/* Summary information */
 
+#ifdef CONFIG_JFFS2_FS_XATTR
+#define XATTRINDEX_HASHSIZE	(57)
+	uint32_t highest_xid;
+	struct list_head xattrindex[XATTRINDEX_HASHSIZE];
+	struct list_head xattr_temp;
+	struct list_head xattr_unchecked;
+	struct rw_semaphore xattr_sem;
+	uint32_t xdatum_mem_usage;
+	uint32_t xdatum_mem_threshold;
+#endif
 	/* OS-private pointer for getting back to master superblock info */
 	void *os_priv;
 };

commit cbb9a56177b16294ed347ba7fcb1c66c8adb5dc4
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed May 3 13:07:27 2006 +0100

    Move jffs2_fs_i.h and jffs2_fs_sb.h from include/linux/ to fs/jffs2/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/jffs2_fs_sb.h b/fs/jffs2/jffs2_fs_sb.h
new file mode 100644
index 000000000000..4bcfb5570221
--- /dev/null
+++ b/fs/jffs2/jffs2_fs_sb.h
@@ -0,0 +1,122 @@
+/* $Id: jffs2_fs_sb.h,v 1.54 2005/09/21 13:37:34 dedekind Exp $ */
+
+#ifndef _JFFS2_FS_SB
+#define _JFFS2_FS_SB
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+#include <asm/semaphore.h>
+#include <linux/timer.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/rwsem.h>
+
+#define JFFS2_SB_FLAG_RO 1
+#define JFFS2_SB_FLAG_SCANNING 2 /* Flash scanning is in progress */
+#define JFFS2_SB_FLAG_BUILDING 4 /* File system building is in progress */
+
+struct jffs2_inodirty;
+
+/* A struct for the overall file system control.  Pointers to
+   jffs2_sb_info structs are named `c' in the source code.
+   Nee jffs_control
+*/
+struct jffs2_sb_info {
+	struct mtd_info *mtd;
+
+	uint32_t highest_ino;
+	uint32_t checked_ino;
+
+	unsigned int flags;
+
+	struct task_struct *gc_task;	/* GC task struct */
+	struct completion gc_thread_start; /* GC thread start completion */
+	struct completion gc_thread_exit; /* GC thread exit completion port */
+
+	struct semaphore alloc_sem;	/* Used to protect all the following
+					   fields, and also to protect against
+					   out-of-order writing of nodes. And GC. */
+	uint32_t cleanmarker_size;	/* Size of an _inline_ CLEANMARKER
+					 (i.e. zero for OOB CLEANMARKER */
+
+	uint32_t flash_size;
+	uint32_t used_size;
+	uint32_t dirty_size;
+	uint32_t wasted_size;
+	uint32_t free_size;
+	uint32_t erasing_size;
+	uint32_t bad_size;
+	uint32_t sector_size;
+	uint32_t unchecked_size;
+
+	uint32_t nr_free_blocks;
+	uint32_t nr_erasing_blocks;
+
+	/* Number of free blocks there must be before we... */
+	uint8_t resv_blocks_write;	/* ... allow a normal filesystem write */
+	uint8_t resv_blocks_deletion;	/* ... allow a normal filesystem deletion */
+	uint8_t resv_blocks_gctrigger;	/* ... wake up the GC thread */
+	uint8_t resv_blocks_gcbad;	/* ... pick a block from the bad_list to GC */
+	uint8_t resv_blocks_gcmerge;	/* ... merge pages when garbage collecting */
+
+	uint32_t nospc_dirty_size;
+
+	uint32_t nr_blocks;
+	struct jffs2_eraseblock *blocks;	/* The whole array of blocks. Used for getting blocks
+						 * from the offset (blocks[ofs / sector_size]) */
+	struct jffs2_eraseblock *nextblock;	/* The block we're currently filling */
+
+	struct jffs2_eraseblock *gcblock;	/* The block we're currently garbage-collecting */
+
+	struct list_head clean_list;		/* Blocks 100% full of clean data */
+	struct list_head very_dirty_list;	/* Blocks with lots of dirty space */
+	struct list_head dirty_list;		/* Blocks with some dirty space */
+	struct list_head erasable_list;		/* Blocks which are completely dirty, and need erasing */
+	struct list_head erasable_pending_wbuf_list;	/* Blocks which need erasing but only after the current wbuf is flushed */
+	struct list_head erasing_list;		/* Blocks which are currently erasing */
+	struct list_head erase_pending_list;	/* Blocks which need erasing now */
+	struct list_head erase_complete_list;	/* Blocks which are erased and need the clean marker written to them */
+	struct list_head free_list;		/* Blocks which are free and ready to be used */
+	struct list_head bad_list;		/* Bad blocks. */
+	struct list_head bad_used_list;		/* Bad blocks with valid data in. */
+
+	spinlock_t erase_completion_lock;	/* Protect free_list and erasing_list
+						   against erase completion handler */
+	wait_queue_head_t erase_wait;		/* For waiting for erases to complete */
+
+	wait_queue_head_t inocache_wq;
+	struct jffs2_inode_cache **inocache_list;
+	spinlock_t inocache_lock;
+
+	/* Sem to allow jffs2_garbage_collect_deletion_dirent to
+	   drop the erase_completion_lock while it's holding a pointer
+	   to an obsoleted node. I don't like this. Alternatives welcomed. */
+	struct semaphore erase_free_sem;
+
+	uint32_t wbuf_pagesize; /* 0 for NOR and other flashes with no wbuf */
+
+#ifdef CONFIG_JFFS2_FS_WRITEBUFFER
+	/* Write-behind buffer for NAND flash */
+	unsigned char *wbuf;
+	uint32_t wbuf_ofs;
+	uint32_t wbuf_len;
+	struct jffs2_inodirty *wbuf_inodes;
+
+	struct rw_semaphore wbuf_sem;	/* Protects the write buffer */
+
+	/* Information about out-of-band area usage... */
+	struct nand_oobinfo *oobinfo;
+	uint32_t badblock_pos;
+	uint32_t fsdata_pos;
+	uint32_t fsdata_len;
+#endif
+
+	struct jffs2_summary *summary;		/* Summary information */
+
+	/* OS-private pointer for getting back to master superblock info */
+	void *os_priv;
+};
+
+#endif /* _JFFS2_FB_SB */
