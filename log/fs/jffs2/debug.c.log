commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 1090eb64b90d..9d26b1b9fc01 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -95,15 +95,15 @@ __jffs2_dbg_fragtree_paranoia_check_nolock(struct jffs2_inode_info *f)
 			   rather than mucking around with actually reading the node
 			   and checking the compression type, which is the real way
 			   to tell a hole node. */
-			if (frag->ofs & (PAGE_CACHE_SIZE-1) && frag_prev(frag)
-					&& frag_prev(frag)->size < PAGE_CACHE_SIZE && frag_prev(frag)->node) {
+			if (frag->ofs & (PAGE_SIZE-1) && frag_prev(frag)
+					&& frag_prev(frag)->size < PAGE_SIZE && frag_prev(frag)->node) {
 				JFFS2_ERROR("REF_PRISTINE node at 0x%08x had a previous non-hole frag in the same page. Tell dwmw2.\n",
 					ref_offset(fn->raw));
 				bitched = 1;
 			}
 
-			if ((frag->ofs+frag->size) & (PAGE_CACHE_SIZE-1) && frag_next(frag)
-					&& frag_next(frag)->size < PAGE_CACHE_SIZE && frag_next(frag)->node) {
+			if ((frag->ofs+frag->size) & (PAGE_SIZE-1) && frag_next(frag)
+					&& frag_next(frag)->size < PAGE_SIZE && frag_next(frag)->node) {
 				JFFS2_ERROR("REF_PRISTINE node at 0x%08x (%08x-%08x) had a following non-hole frag in the same page. Tell dwmw2.\n",
 				       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);
 				bitched = 1;

commit 9bbf29e4757fb152c8673eda0b1e9d507b953df9
Author: Joe Perches <joe@perches.com>
Date:   Wed Feb 15 15:56:46 2012 -0800

    jffs2: Standardize JFFS_<LEVEL> uses
    
    Use pr_<level> to prefix KBUILD_MODNAME via pr_fmt.
    
    Remove obfuscating defines and use constants in pr_<level>
    No need for a do {} while (0) for single statements.
    
    Form of JFFS_<LEVEL> output changes from
    "JFFS2 notice: " to "jffs2: notice: "
    
    Added pr_fmt to xattr.c
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index f8a99a371508..1090eb64b90d 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -267,7 +267,7 @@ void __jffs2_dbg_superblock_counts(struct jffs2_sb_info *c)
 do {									\
 	if (sz != c->sz##_size) {					\
 		pr_warn("%s_size mismatch counted 0x%x, c->%s_size 0x%x\n", \
-			#sz, #sz, sz, c->sz##_size);			\
+			#sz, sz, #sz, c->sz##_size);			\
 		dump = 1;						\
 	}								\
 } while (0)

commit 5a528957e7c74f1fed73fe20424b7a3421658877
Author: Joe Perches <joe@perches.com>
Date:   Wed Feb 15 15:56:45 2012 -0800

    jffs2: Use pr_fmt and remove jffs: from formats
    
    Use pr_fmt to prefix KBUILD_MODNAME to appropriate logging messages.
    
    Remove now unnecessary internal prefixes from formats.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 6cac7d6aad69..f8a99a371508 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -10,6 +10,8 @@
  *
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/pagemap.h>

commit da320f055a8818269c008e30b887cdcf09d8e4bd
Author: Joe Perches <joe@perches.com>
Date:   Wed Feb 15 15:56:44 2012 -0800

    jffs2: Convert printks to pr_<level>
    
    Use the more current logging style.
    
    Coalesce formats, align arguments.
    Convert uses of embedded function names to %s, __func__.
    
    A couple of long line checkpatch errors I don't care about exist.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index e0b76c87a91a..6cac7d6aad69 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -261,12 +261,15 @@ void __jffs2_dbg_superblock_counts(struct jffs2_sb_info *c)
 		bad += c->sector_size;
 	}
 
-#define check(sz) \
-	if (sz != c->sz##_size) {			\
-		printk(KERN_WARNING #sz "_size mismatch counted 0x%x, c->" #sz "_size 0x%x\n", \
-		       sz, c->sz##_size);		\
-		dump = 1;				\
-	}
+#define check(sz)							\
+do {									\
+	if (sz != c->sz##_size) {					\
+		pr_warn("%s_size mismatch counted 0x%x, c->%s_size 0x%x\n", \
+			#sz, #sz, sz, c->sz##_size);			\
+		dump = 1;						\
+	}								\
+} while (0)
+
 	check(free);
 	check(dirty);
 	check(used);
@@ -274,11 +277,12 @@ void __jffs2_dbg_superblock_counts(struct jffs2_sb_info *c)
 	check(unchecked);
 	check(bad);
 	check(erasing);
+
 #undef check
 
 	if (nr_counted != c->nr_blocks) {
-		printk(KERN_WARNING "%s counted only 0x%x blocks of 0x%x. Where are the others?\n",
-		       __func__, nr_counted, c->nr_blocks);
+		pr_warn("%s counted only 0x%x blocks of 0x%x. Where are the others?\n",
+			__func__, nr_counted, c->nr_blocks);
 		dump = 1;
 	}
 

commit 6088c0587706b2cf21ce50c11576718bff5fae0c
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 14:15:22 2010 +0100

    jffs2: Update copyright notices
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index ec3538413926..e0b76c87a91a 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -2,6 +2,7 @@
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
  * Copyright © 2001-2007 Red Hat, Inc.
+ * Copyright © 2004-2010 David Woodhouse <dwmw2@infradead.org>
  *
  * Created by David Woodhouse <dwmw2@infradead.org>
  *

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 5544d31c066b..ec3538413926 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -15,6 +15,7 @@
 #include <linux/crc32.h>
 #include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
+#include <linux/slab.h>
 #include "nodelist.h"
 #include "debug.h"
 

commit e2bc322bf05936ec7160d62bc3fd45cbf4aa405a
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 23 14:15:24 2008 +0100

    [JFFS2] Add erase_checking_list to hold blocks being marked.
    
    Just to keep the debug code happy when it's adding all the blocks up.
    Otherwise, they disappear for a while while the locks are dropped to
    check them and write the cleanmarker.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index e198468a8c68..5544d31c066b 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -246,6 +246,10 @@ void __jffs2_dbg_superblock_counts(struct jffs2_sb_info *c)
 		nr_counted++;
 		erasing += c->sector_size;
 	}
+	list_for_each_entry(jeb, &c->erase_checking_list, list) {
+		nr_counted++;
+		erasing += c->sector_size;
+	}
 	list_for_each_entry(jeb, &c->erase_complete_list, list) {
 		nr_counted++;
 		erasing += c->sector_size;
@@ -582,6 +586,21 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			}
 		}
 	}
+	if (list_empty(&c->erase_checking_list)) {
+		printk(JFFS2_DBG "erase_checking_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->erase_checking_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(JFFS2_DBG "erase_checking_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
+			}
+		}
+	}
 
 	if (list_empty(&c->erase_pending_list)) {
 		printk(JFFS2_DBG "erase_pending_list: empty\n");

commit 27e6b8e388fffb332476ddab00bbe05cd5da5f32
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 23 01:25:33 2008 +0100

    [JFFS2] Honour TEST_TOTLEN macro in debugging code. ref->__totlen is going!
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 590bdd6e0147..e198468a8c68 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -400,7 +400,10 @@ __jffs2_dbg_dump_node_refs_nolock(struct jffs2_sb_info *c,
 
 	printk(JFFS2_DBG);
 	for (ref = jeb->first_node; ; ref = ref_next(ref)) {
-		printk("%#08x(%#x)", ref_offset(ref), ref->__totlen);
+		printk("%#08x", ref_offset(ref));
+#ifdef TEST_TOTLEN
+		printk("(%x)", ref->__totlen);
+#endif
 		if (ref_next(ref))
 			printk("->");
 		else

commit 85a62db6245a82f07a31b387915ee2180b9ea11a
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 23 01:17:51 2008 +0100

    [JFFS2] Add paranoia debugging for superblock counts
    
    The problem fixed in commit 014b164e1392a166fe96e003d2f0e7ad2e2a0bb7
    (space leak with in-band cleanmarkers) would have been caught a lot
    quicker if our paranoid debugging mode had included adding up the size
    counts from all the eraseblocks and comparing the totals with the counts
    in the superblock. Add that.
    
    Make jffs2_mark_erased_block() file the newly-erased block on the
    free_list before calling the debug function, to make it happy.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 660793107e92..590bdd6e0147 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -153,6 +153,135 @@ __jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c,
 	kfree(buf);
 }
 
+void __jffs2_dbg_superblock_counts(struct jffs2_sb_info *c)
+{
+	struct jffs2_eraseblock *jeb;
+	uint32_t free = 0, dirty = 0, used = 0, wasted = 0,
+		erasing = 0, bad = 0, unchecked = 0;
+	int nr_counted = 0;
+	int dump = 0;
+
+	if (c->gcblock) {
+		nr_counted++;
+		free += c->gcblock->free_size;
+		dirty += c->gcblock->dirty_size;
+		used += c->gcblock->used_size;
+		wasted += c->gcblock->wasted_size;
+		unchecked += c->gcblock->unchecked_size;
+	}
+	if (c->nextblock) {
+		nr_counted++;
+		free += c->nextblock->free_size;
+		dirty += c->nextblock->dirty_size;
+		used += c->nextblock->used_size;
+		wasted += c->nextblock->wasted_size;
+		unchecked += c->nextblock->unchecked_size;
+	}
+	list_for_each_entry(jeb, &c->clean_list, list) {
+		nr_counted++;
+		free += jeb->free_size;
+		dirty += jeb->dirty_size;
+		used += jeb->used_size;
+		wasted += jeb->wasted_size;
+		unchecked += jeb->unchecked_size;
+	}
+	list_for_each_entry(jeb, &c->very_dirty_list, list) {
+		nr_counted++;
+		free += jeb->free_size;
+		dirty += jeb->dirty_size;
+		used += jeb->used_size;
+		wasted += jeb->wasted_size;
+		unchecked += jeb->unchecked_size;
+	}
+	list_for_each_entry(jeb, &c->dirty_list, list) {
+		nr_counted++;
+		free += jeb->free_size;
+		dirty += jeb->dirty_size;
+		used += jeb->used_size;
+		wasted += jeb->wasted_size;
+		unchecked += jeb->unchecked_size;
+	}
+	list_for_each_entry(jeb, &c->erasable_list, list) {
+		nr_counted++;
+		free += jeb->free_size;
+		dirty += jeb->dirty_size;
+		used += jeb->used_size;
+		wasted += jeb->wasted_size;
+		unchecked += jeb->unchecked_size;
+	}
+	list_for_each_entry(jeb, &c->erasable_pending_wbuf_list, list) {
+		nr_counted++;
+		free += jeb->free_size;
+		dirty += jeb->dirty_size;
+		used += jeb->used_size;
+		wasted += jeb->wasted_size;
+		unchecked += jeb->unchecked_size;
+	}
+	list_for_each_entry(jeb, &c->erase_pending_list, list) {
+		nr_counted++;
+		free += jeb->free_size;
+		dirty += jeb->dirty_size;
+		used += jeb->used_size;
+		wasted += jeb->wasted_size;
+		unchecked += jeb->unchecked_size;
+	}
+	list_for_each_entry(jeb, &c->free_list, list) {
+		nr_counted++;
+		free += jeb->free_size;
+		dirty += jeb->dirty_size;
+		used += jeb->used_size;
+		wasted += jeb->wasted_size;
+		unchecked += jeb->unchecked_size;
+	}
+	list_for_each_entry(jeb, &c->bad_used_list, list) {
+		nr_counted++;
+		free += jeb->free_size;
+		dirty += jeb->dirty_size;
+		used += jeb->used_size;
+		wasted += jeb->wasted_size;
+		unchecked += jeb->unchecked_size;
+	}
+
+	list_for_each_entry(jeb, &c->erasing_list, list) {
+		nr_counted++;
+		erasing += c->sector_size;
+	}
+	list_for_each_entry(jeb, &c->erase_complete_list, list) {
+		nr_counted++;
+		erasing += c->sector_size;
+	}
+	list_for_each_entry(jeb, &c->bad_list, list) {
+		nr_counted++;
+		bad += c->sector_size;
+	}
+
+#define check(sz) \
+	if (sz != c->sz##_size) {			\
+		printk(KERN_WARNING #sz "_size mismatch counted 0x%x, c->" #sz "_size 0x%x\n", \
+		       sz, c->sz##_size);		\
+		dump = 1;				\
+	}
+	check(free);
+	check(dirty);
+	check(used);
+	check(wasted);
+	check(unchecked);
+	check(bad);
+	check(erasing);
+#undef check
+
+	if (nr_counted != c->nr_blocks) {
+		printk(KERN_WARNING "%s counted only 0x%x blocks of 0x%x. Where are the others?\n",
+		       __func__, nr_counted, c->nr_blocks);
+		dump = 1;
+	}
+
+	if (dump) {
+		__jffs2_dbg_dump_block_lists_nolock(c);
+		BUG();
+	}
+}
+
 /*
  * Check the space accounting and node_ref list correctness for the JFFS2 erasable block 'jeb'.
  */
@@ -229,6 +358,9 @@ __jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,
 	}
 #endif
 
+	if (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))
+		__jffs2_dbg_superblock_counts(c);
+
 	return;
 
 error:

commit ced22070363ef50e4a47aadd003a81ebeaa3f917
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Apr 22 15:13:40 2008 +0100

    [JFFS2] semaphore->mutex conversion
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 3a32c64ed497..660793107e92 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -62,9 +62,9 @@ __jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,
 void
 __jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
 {
-	down(&f->sem);
+	mutex_lock(&f->sem);
 	__jffs2_dbg_fragtree_paranoia_check_nolock(f);
-	up(&f->sem);
+	mutex_unlock(&f->sem);
 }
 
 void
@@ -532,9 +532,9 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 void
 __jffs2_dbg_dump_fragtree(struct jffs2_inode_info *f)
 {
-	down(&f->sem);
+	mutex_lock(&f->sem);
 	jffs2_dbg_dump_fragtree_nolock(f);
-	up(&f->sem);
+	mutex_unlock(&f->sem);
 }
 
 void

commit c00c310eac04a28d2143368ae988716792ed53ce
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 25 14:16:47 2007 +0100

    [JFFS2] Tidy up licensing/copyright boilerplate.
    
    In particular, remove the bit in the LICENCE file about contacting
    Red Hat for alternative arrangements. Their errant IS department broke
    that arrangement a long time ago -- the policy of collecting copyright
    assignments from contributors came to an end when the plug was pulled on
    the servers hosting the project, without notice or reason.
    
    We do still dual-license it for use with eCos, with the GPL+exception
    licence approved by the FSF as being GPL-compatible. It's just that nobody
    has the right to license it differently.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 4189e4a36050..3a32c64ed497 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -1,15 +1,14 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001-2003 Red Hat, Inc.
+ * Copyright © 2001-2007 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@infradead.org>
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: debug.c,v 1.12 2005/11/07 11:14:39 gleixner Exp $
- *
  */
+
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/pagemap.h>

commit abb536e7ac8719243cfc4b40b39bf3eefd028f82
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri Dec 22 16:39:30 2006 +0900

    [JFFS2] use the ref_offset macro
    
    Don't use ref->flash_offset directly in debugging code, use the ref_offset macro instead.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Artem Bityutskiy <dedekind@infradead.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 72b4fc13a106..4189e4a36050 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -178,8 +178,8 @@ __jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,
 	while (ref2) {
 		uint32_t totlen = ref_totlen(c, jeb, ref2);
 
-		if (ref2->flash_offset < jeb->offset ||
-				ref2->flash_offset > jeb->offset + c->sector_size) {
+		if (ref_offset(ref2) < jeb->offset ||
+				ref_offset(ref2) > jeb->offset + c->sector_size) {
 			JFFS2_ERROR("node_ref %#08x shouldn't be in block at %#08x.\n",
 				ref_offset(ref2), jeb->offset);
 			goto error;

commit 99988f7bbd16b861590dda4631c4db6cb17b5091
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed May 24 09:04:17 2006 +0100

    [JFFS2] Introduce ref_next() macro for finding next physical node
    
    Another part of the preparation for switching to an array...
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 1fe17de713e8..72b4fc13a106 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -192,13 +192,13 @@ __jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,
 		else
 			my_dirty_size += totlen;
 
-		if ((!ref2->next_phys) != (ref2 == jeb->last_node)) {
-			JFFS2_ERROR("node_ref for node at %#08x (mem %p) has next_phys at %#08x (mem %p), last_node is at %#08x (mem %p).\n",
-				ref_offset(ref2), ref2, ref_offset(ref2->next_phys), ref2->next_phys,
-				ref_offset(jeb->last_node), jeb->last_node);
+		if ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {
+			JFFS2_ERROR("node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\n",
+				    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),
+				    ref_offset(jeb->last_node), jeb->last_node);
 			goto error;
 		}
-		ref2 = ref2->next_phys;
+		ref2 = ref_next(ref2);
 	}
 
 	if (my_used_size != jeb->used_size) {
@@ -268,9 +268,9 @@ __jffs2_dbg_dump_node_refs_nolock(struct jffs2_sb_info *c,
 	}
 
 	printk(JFFS2_DBG);
-	for (ref = jeb->first_node; ; ref = ref->next_phys) {
+	for (ref = jeb->first_node; ; ref = ref_next(ref)) {
 		printk("%#08x(%#x)", ref_offset(ref), ref->__totlen);
-		if (ref->next_phys)
+		if (ref_next(ref))
 			printk("->");
 		else
 			break;

commit 182ec4eee397543101a6db8906ed88727d3f7e53
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:16:07 2005 +0000

    [JFFS2] Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 0947284f45dd..1fe17de713e8 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: debug.c,v 1.11 2005/09/21 13:28:35 dedekind Exp $
+ * $Id: debug.c,v 1.12 2005/11/07 11:14:39 gleixner Exp $
  *
  */
 #include <linux/kernel.h>
@@ -67,7 +67,7 @@ __jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
 	__jffs2_dbg_fragtree_paranoia_check_nolock(f);
 	up(&f->sem);
 }
-	
+
 void
 __jffs2_dbg_fragtree_paranoia_check_nolock(struct jffs2_inode_info *f)
 {
@@ -165,7 +165,7 @@ __jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c,
 	__jffs2_dbg_acct_paranoia_check_nolock(c, jeb);
 	spin_unlock(&c->erase_completion_lock);
 }
-	
+
 void
 __jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,
 				       struct jffs2_eraseblock *jeb)
@@ -237,7 +237,7 @@ __jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,
 	__jffs2_dbg_dump_jeb_nolock(jeb);
 	__jffs2_dbg_dump_block_lists_nolock(c);
 	BUG();
-	
+
 }
 #endif /* JFFS2_DBG_PARANOIA_CHECKS */
 
@@ -321,7 +321,7 @@ void
 __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 {
 	printk(JFFS2_DBG_MSG_PREFIX " dump JFFS2 blocks lists:\n");
-	
+
 	printk(JFFS2_DBG "flash_size: %#08x\n",		c->flash_size);
 	printk(JFFS2_DBG "used_size: %#08x\n",		c->used_size);
 	printk(JFFS2_DBG "dirty_size: %#08x\n",		c->dirty_size);
@@ -577,15 +577,15 @@ __jffs2_dbg_dump_buffer(unsigned char *buf, int len, uint32_t offs)
 {
 	int skip;
 	int i;
-	
+
 	printk(JFFS2_DBG_MSG_PREFIX " dump from offset %#08x to offset %#08x (%x bytes).\n",
 		offs, offs + len, len);
 	i = skip = offs % JFFS2_BUFDUMP_BYTES_PER_LINE;
 	offs = offs & ~(JFFS2_BUFDUMP_BYTES_PER_LINE - 1);
-	
+
 	if (skip != 0)
 		printk(JFFS2_DBG "%#08x: ", offs);
-	
+
 	while (skip--)
 		printk("   ");
 
@@ -598,7 +598,7 @@ __jffs2_dbg_dump_buffer(unsigned char *buf, int len, uint32_t offs)
 		}
 
 		printk("%02x ", buf[i]);
-		
+
 		i += 1;
 	}
 
@@ -616,7 +616,7 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 	size_t retlen;
 	uint32_t crc;
 	int ret;
-	
+
 	printk(JFFS2_DBG_MSG_PREFIX " dump node at offset %#08x.\n", ofs);
 
 	ret = jffs2_flash_read(c, ofs, len, &retlen, (unsigned char *)&node);
@@ -630,13 +630,13 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 	printk(JFFS2_DBG "nodetype:\t%#04x\n", je16_to_cpu(node.u.nodetype));
 	printk(JFFS2_DBG "totlen:\t%#08x\n", je32_to_cpu(node.u.totlen));
 	printk(JFFS2_DBG "hdr_crc:\t%#08x\n", je32_to_cpu(node.u.hdr_crc));
-	
+
 	crc = crc32(0, &node.u, sizeof(node.u) - 4);
 	if (crc != je32_to_cpu(node.u.hdr_crc)) {
 		JFFS2_ERROR("wrong common header CRC.\n");
 		return;
 	}
-	
+
 	if (je16_to_cpu(node.u.magic) != JFFS2_MAGIC_BITMASK &&
 		je16_to_cpu(node.u.magic) != JFFS2_OLD_MAGIC_BITMASK)
 	{
@@ -668,7 +668,7 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 		printk(JFFS2_DBG "data_crc:\t%#08x\n", je32_to_cpu(node.i.data_crc));
 		printk(JFFS2_DBG "node_crc:\t%#08x\n", je32_to_cpu(node.i.node_crc));
 
-		crc = crc32(0, &node.i, sizeof(node.i) - 8); 
+		crc = crc32(0, &node.i, sizeof(node.i) - 8);
 		if (crc != je32_to_cpu(node.i.node_crc)) {
 			JFFS2_ERROR("wrong node header CRC.\n");
 			return;
@@ -686,11 +686,11 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 		printk(JFFS2_DBG "type:\t%#02x\n", node.d.type);
 		printk(JFFS2_DBG "node_crc:\t%#08x\n", je32_to_cpu(node.d.node_crc));
 		printk(JFFS2_DBG "name_crc:\t%#08x\n", je32_to_cpu(node.d.name_crc));
-		
+
 		node.d.name[node.d.nsize] = '\0';
 		printk(JFFS2_DBG "name:\t\"%s\"\n", node.d.name);
 
-		crc = crc32(0, &node.d, sizeof(node.d) - 8); 
+		crc = crc32(0, &node.d, sizeof(node.d) - 8);
 		if (crc != je32_to_cpu(node.d.node_crc)) {
 			JFFS2_ERROR("wrong node header CRC.\n");
 			return;

commit 733802d974e5af42acb7cd61b16c0ce6dd03b7ed
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Thu Sep 22 12:25:00 2005 +0100

    [JFFS2] Debug code simplification, update TODO
    
    Simplify the debugging code further.
    Update the TODO list
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 28983501bcef..0947284f45dd 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: debug.c,v 1.10 2005/09/14 16:57:32 dedekind Exp $
+ * $Id: debug.c,v 1.11 2005/09/21 13:28:35 dedekind Exp $
  *
  */
 #include <linux/kernel.h>
@@ -15,6 +15,7 @@
 #include <linux/pagemap.h>
 #include <linux/crc32.h>
 #include <linux/jffs2.h>
+#include <linux/mtd/mtd.h>
 #include "nodelist.h"
 #include "debug.h"
 

commit 81e39cf0297c7f32fb8869af9ae199130208ae6f
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Wed Sep 14 17:57:35 2005 +0100

    [JFFS2] Debug message format clean up
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 9b776b5a7604..28983501bcef 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: debug.c,v 1.9 2005/08/05 10:42:24 dedekind Exp $
+ * $Id: debug.c,v 1.10 2005/09/14 16:57:32 dedekind Exp $
  *
  */
 #include <linux/kernel.h>
@@ -28,8 +28,8 @@ __jffs2_dbg_acct_sanity_check_nolock(struct jffs2_sb_info *c,
 			jeb->free_size + jeb->wasted_size +
 			jeb->unchecked_size != c->sector_size)) {
 		JFFS2_ERROR("eeep, space accounting for block at 0x%08x is screwed.\n", jeb->offset);
-		JFFS2_ERROR("free %#08x + dirty %#08x + used %#08x + wasted %#08x + unchecked "
-			"%#08x != total %#08x.\n", jeb->free_size, jeb->dirty_size, jeb->used_size,
+		JFFS2_ERROR("free %#08x + dirty %#08x + used %#08x + wasted %#08x + unchecked %#08x != total %#08x.\n",
+			jeb->free_size, jeb->dirty_size, jeb->used_size,
 			jeb->wasted_size, jeb->unchecked_size, c->sector_size);
 		BUG();
 	}
@@ -37,8 +37,7 @@ __jffs2_dbg_acct_sanity_check_nolock(struct jffs2_sb_info *c,
 	if (unlikely(c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size
 				+ c->wasted_size + c->unchecked_size != c->flash_size)) {
 		JFFS2_ERROR("eeep, space accounting superblock info is screwed.\n");
-		JFFS2_ERROR("free %#08x + dirty %#08x + used %#08x + erasing %#08x + bad %#08x + "
-			"wasted %#08x + unchecked %#08x != total %#08x.\n",
+		JFFS2_ERROR("free %#08x + dirty %#08x + used %#08x + erasing %#08x + bad %#08x + wasted %#08x + unchecked %#08x != total %#08x.\n",
 			c->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,
 			c->wasted_size, c->unchecked_size, c->flash_size);
 		BUG();
@@ -83,7 +82,7 @@ __jffs2_dbg_fragtree_paranoia_check_nolock(struct jffs2_inode_info *f)
 		if (ref_flags(fn->raw) == REF_PRISTINE) {
 			if (fn->frags > 1) {
 				JFFS2_ERROR("REF_PRISTINE node at 0x%08x had %d frags. Tell dwmw2.\n",
-						ref_offset(fn->raw), fn->frags);
+					ref_offset(fn->raw), fn->frags);
 				bitched = 1;
 			}
 
@@ -94,16 +93,15 @@ __jffs2_dbg_fragtree_paranoia_check_nolock(struct jffs2_inode_info *f)
 			   to tell a hole node. */
 			if (frag->ofs & (PAGE_CACHE_SIZE-1) && frag_prev(frag)
 					&& frag_prev(frag)->size < PAGE_CACHE_SIZE && frag_prev(frag)->node) {
-				JFFS2_ERROR("REF_PRISTINE node at 0x%08x had a previous non-hole frag "
-						"in the same page. Tell dwmw2.\n", ref_offset(fn->raw));
+				JFFS2_ERROR("REF_PRISTINE node at 0x%08x had a previous non-hole frag in the same page. Tell dwmw2.\n",
+					ref_offset(fn->raw));
 				bitched = 1;
 			}
 
 			if ((frag->ofs+frag->size) & (PAGE_CACHE_SIZE-1) && frag_next(frag)
 					&& frag_next(frag)->size < PAGE_CACHE_SIZE && frag_next(frag)->node) {
-				JFFS2_ERROR("REF_PRISTINE node at 0x%08x (%08x-%08x) had a following "
-						"non-hole frag in the same page. Tell dwmw2.\n",
-					       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);
+				JFFS2_ERROR("REF_PRISTINE node at 0x%08x (%08x-%08x) had a following non-hole frag in the same page. Tell dwmw2.\n",
+				       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);
 				bitched = 1;
 			}
 		}
@@ -145,8 +143,8 @@ __jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c,
 			ret = 1;
 
 	if (ret) {
-		JFFS2_ERROR("argh, about to write node to %#08x on flash, but there are data "
-			"already there. The first corrupted byte is at %#08x offset.\n", ofs, ofs + i);
+		JFFS2_ERROR("argh, about to write node to %#08x on flash, but there are data already there. The first corrupted byte is at %#08x offset.\n",
+			ofs, ofs + i);
 		__jffs2_dbg_dump_buffer(buf, len, ofs);
 		kfree(buf);
 		BUG();
@@ -194,8 +192,7 @@ __jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,
 			my_dirty_size += totlen;
 
 		if ((!ref2->next_phys) != (ref2 == jeb->last_node)) {
-			JFFS2_ERROR("node_ref for node at %#08x (mem %p) has next_phys at %#08x (mem %p), "
-				"last_node is at %#08x (mem %p).\n",
+			JFFS2_ERROR("node_ref for node at %#08x (mem %p) has next_phys at %#08x (mem %p), last_node is at %#08x (mem %p).\n",
 				ref_offset(ref2), ref2, ref_offset(ref2->next_phys), ref2->next_phys,
 				ref_offset(jeb->last_node), jeb->last_node);
 			goto error;
@@ -263,13 +260,13 @@ __jffs2_dbg_dump_node_refs_nolock(struct jffs2_sb_info *c,
 	struct jffs2_raw_node_ref *ref;
 	int i = 0;
 
-	JFFS2_DEBUG("Dump node_refs of the eraseblock %#08x\n", jeb->offset);
+	printk(JFFS2_DBG_MSG_PREFIX " Dump node_refs of the eraseblock %#08x\n", jeb->offset);
 	if (!jeb->first_node) {
-		JFFS2_DEBUG("no nodes in the eraseblock %#08x\n", jeb->offset);
+		printk(JFFS2_DBG_MSG_PREFIX " no nodes in the eraseblock %#08x\n", jeb->offset);
 		return;
 	}
 
-	printk(JFFS2_DBG_LVL);
+	printk(JFFS2_DBG);
 	for (ref = jeb->first_node; ; ref = ref->next_phys) {
 		printk("%#08x(%#x)", ref_offset(ref), ref->__totlen);
 		if (ref->next_phys)
@@ -278,7 +275,7 @@ __jffs2_dbg_dump_node_refs_nolock(struct jffs2_sb_info *c,
 			break;
 		if (++i == 4) {
 			i = 0;
-			printk("\n" JFFS2_DBG_LVL);
+			printk("\n" JFFS2_DBG);
 		}
 	}
 	printk("\n");
@@ -301,14 +298,14 @@ __jffs2_dbg_dump_jeb_nolock(struct jffs2_eraseblock *jeb)
 	if (!jeb)
 		return;
 
-	JFFS2_DEBUG("dump space accounting for the eraseblock at %#08x:\n",
+	printk(JFFS2_DBG_MSG_PREFIX " dump space accounting for the eraseblock at %#08x:\n",
 			jeb->offset);
 
-	printk(JFFS2_DBG_LVL "used_size: %#08x\n",	jeb->used_size);
-	printk(JFFS2_DBG_LVL "dirty_size: %#08x\n",	jeb->dirty_size);
-	printk(JFFS2_DBG_LVL "wasted_size: %#08x\n",	jeb->wasted_size);
-	printk(JFFS2_DBG_LVL "unchecked_size: %#08x\n",	jeb->unchecked_size);
-	printk(JFFS2_DBG_LVL "free_size: %#08x\n",	jeb->free_size);
+	printk(JFFS2_DBG "used_size: %#08x\n",		jeb->used_size);
+	printk(JFFS2_DBG "dirty_size: %#08x\n",		jeb->dirty_size);
+	printk(JFFS2_DBG "wasted_size: %#08x\n",	jeb->wasted_size);
+	printk(JFFS2_DBG "unchecked_size: %#08x\n",	jeb->unchecked_size);
+	printk(JFFS2_DBG "free_size: %#08x\n",		jeb->free_size);
 }
 
 void
@@ -322,39 +319,37 @@ __jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 void
 __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 {
-	JFFS2_DEBUG("dump JFFS2 blocks lists:\n");
+	printk(JFFS2_DBG_MSG_PREFIX " dump JFFS2 blocks lists:\n");
 	
-	printk(JFFS2_DBG_LVL "flash_size: %#08x\n",	c->flash_size);
-	printk(JFFS2_DBG_LVL "used_size: %#08x\n",	c->used_size);
-	printk(JFFS2_DBG_LVL "dirty_size: %#08x\n",	c->dirty_size);
-	printk(JFFS2_DBG_LVL "wasted_size: %#08x\n",	c->wasted_size);
-	printk(JFFS2_DBG_LVL "unchecked_size: %#08x\n",	c->unchecked_size);
-	printk(JFFS2_DBG_LVL "free_size: %#08x\n",	c->free_size);
-	printk(JFFS2_DBG_LVL "erasing_size: %#08x\n",	c->erasing_size);
-	printk(JFFS2_DBG_LVL "bad_size: %#08x\n",	c->bad_size);
-	printk(JFFS2_DBG_LVL "sector_size: %#08x\n",	c->sector_size);
-	printk(JFFS2_DBG_LVL "jffs2_reserved_blocks size: %#08x\n",
+	printk(JFFS2_DBG "flash_size: %#08x\n",		c->flash_size);
+	printk(JFFS2_DBG "used_size: %#08x\n",		c->used_size);
+	printk(JFFS2_DBG "dirty_size: %#08x\n",		c->dirty_size);
+	printk(JFFS2_DBG "wasted_size: %#08x\n",	c->wasted_size);
+	printk(JFFS2_DBG "unchecked_size: %#08x\n",	c->unchecked_size);
+	printk(JFFS2_DBG "free_size: %#08x\n",		c->free_size);
+	printk(JFFS2_DBG "erasing_size: %#08x\n",	c->erasing_size);
+	printk(JFFS2_DBG "bad_size: %#08x\n",		c->bad_size);
+	printk(JFFS2_DBG "sector_size: %#08x\n",	c->sector_size);
+	printk(JFFS2_DBG "jffs2_reserved_blocks size: %#08x\n",
 				c->sector_size * c->resv_blocks_write);
 
 	if (c->nextblock)
-		printk(JFFS2_DBG_LVL "nextblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-			"unchecked %#08x, free %#08x)\n",
+		printk(JFFS2_DBG "nextblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 			c->nextblock->offset, c->nextblock->used_size,
 			c->nextblock->dirty_size, c->nextblock->wasted_size,
 			c->nextblock->unchecked_size, c->nextblock->free_size);
 	else
-		printk(JFFS2_DBG_LVL "nextblock: NULL\n");
+		printk(JFFS2_DBG "nextblock: NULL\n");
 
 	if (c->gcblock)
-		printk(JFFS2_DBG_LVL "gcblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-			"unchecked %#08x, free %#08x)\n",
+		printk(JFFS2_DBG "gcblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 			c->gcblock->offset, c->gcblock->used_size, c->gcblock->dirty_size,
 			c->gcblock->wasted_size, c->gcblock->unchecked_size, c->gcblock->free_size);
 	else
-		printk(JFFS2_DBG_LVL "gcblock: NULL\n");
+		printk(JFFS2_DBG "gcblock: NULL\n");
 
 	if (list_empty(&c->clean_list)) {
-		printk(JFFS2_DBG_LVL "clean_list: empty\n");
+		printk(JFFS2_DBG "clean_list: empty\n");
 	} else {
 		struct list_head *this;
 		int numblocks = 0;
@@ -365,19 +360,18 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			numblocks ++;
 			dirty += jeb->wasted_size;
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "clean_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "clean_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 
-		printk (JFFS2_DBG_LVL "Contains %d blocks with total wasted size %u, average wasted size: %u\n",
+		printk (JFFS2_DBG "Contains %d blocks with total wasted size %u, average wasted size: %u\n",
 			numblocks, dirty, dirty / numblocks);
 	}
 
 	if (list_empty(&c->very_dirty_list)) {
-		printk(JFFS2_DBG_LVL "very_dirty_list: empty\n");
+		printk(JFFS2_DBG "very_dirty_list: empty\n");
 	} else {
 		struct list_head *this;
 		int numblocks = 0;
@@ -389,19 +383,18 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			numblocks ++;
 			dirty += jeb->dirty_size;
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "very_dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "very_dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 
-		printk (JFFS2_DBG_LVL "Contains %d blocks with total dirty size %u, average dirty size: %u\n",
+		printk (JFFS2_DBG "Contains %d blocks with total dirty size %u, average dirty size: %u\n",
 			numblocks, dirty, dirty / numblocks);
 	}
 
 	if (list_empty(&c->dirty_list)) {
-		printk(JFFS2_DBG_LVL "dirty_list: empty\n");
+		printk(JFFS2_DBG "dirty_list: empty\n");
 	} else {
 		struct list_head *this;
 		int numblocks = 0;
@@ -413,19 +406,18 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			numblocks ++;
 			dirty += jeb->dirty_size;
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 
-		printk (JFFS2_DBG_LVL "contains %d blocks with total dirty size %u, average dirty size: %u\n",
+		printk (JFFS2_DBG "contains %d blocks with total dirty size %u, average dirty size: %u\n",
 			numblocks, dirty, dirty / numblocks);
 	}
 
 	if (list_empty(&c->erasable_list)) {
-		printk(JFFS2_DBG_LVL "erasable_list: empty\n");
+		printk(JFFS2_DBG "erasable_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -433,8 +425,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "erasable_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "erasable_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
@@ -442,7 +433,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 	}
 
 	if (list_empty(&c->erasing_list)) {
-		printk(JFFS2_DBG_LVL "erasing_list: empty\n");
+		printk(JFFS2_DBG "erasing_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -450,8 +441,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "erasing_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "erasing_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
@@ -459,7 +449,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 	}
 
 	if (list_empty(&c->erase_pending_list)) {
-		printk(JFFS2_DBG_LVL "erase_pending_list: empty\n");
+		printk(JFFS2_DBG "erase_pending_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -467,8 +457,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "erase_pending_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "erase_pending_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
@@ -476,7 +465,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 	}
 
 	if (list_empty(&c->erasable_pending_wbuf_list)) {
-		printk(JFFS2_DBG_LVL "erasable_pending_wbuf_list: empty\n");
+		printk(JFFS2_DBG "erasable_pending_wbuf_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -484,8 +473,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "erasable_pending_wbuf_list: %#08x (used %#08x, dirty %#08x, "
-					"wasted %#08x, unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "erasable_pending_wbuf_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
@@ -493,7 +481,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 	}
 
 	if (list_empty(&c->free_list)) {
-		printk(JFFS2_DBG_LVL "free_list: empty\n");
+		printk(JFFS2_DBG "free_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -501,8 +489,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "free_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "free_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
@@ -510,7 +497,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 	}
 
 	if (list_empty(&c->bad_list)) {
-		printk(JFFS2_DBG_LVL "bad_list: empty\n");
+		printk(JFFS2_DBG "bad_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -518,8 +505,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "bad_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "bad_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
@@ -527,7 +513,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 	}
 
 	if (list_empty(&c->bad_used_list)) {
-		printk(JFFS2_DBG_LVL "bad_used_list: empty\n");
+		printk(JFFS2_DBG "bad_used_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -535,8 +521,7 @@ __jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(JFFS2_DBG_LVL "bad_used_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-					"unchecked %#08x, free %#08x)\n",
+				printk(JFFS2_DBG "bad_used_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, unchecked %#08x, free %#08x)\n",
 					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
 					jeb->unchecked_size, jeb->free_size);
 			}
@@ -559,16 +544,15 @@ __jffs2_dbg_dump_fragtree_nolock(struct jffs2_inode_info *f)
 	uint32_t lastofs = 0;
 	int buggy = 0;
 
-	JFFS2_DEBUG("dump fragtree of ino #%u\n", f->inocache->ino);
+	printk(JFFS2_DBG_MSG_PREFIX " dump fragtree of ino #%u\n", f->inocache->ino);
 	while(this) {
 		if (this->node)
-			printk(JFFS2_DBG_LVL "frag %#04x-%#04x: %#08x(%d) on flash (*%p), left (%p), "
-				"right (%p), parent (%p)\n",
+			printk(JFFS2_DBG "frag %#04x-%#04x: %#08x(%d) on flash (*%p), left (%p), right (%p), parent (%p)\n",
 				this->ofs, this->ofs+this->size, ref_offset(this->node->raw),
 				ref_flags(this->node->raw), this, frag_left(this), frag_right(this),
 				frag_parent(this));
 		else
-			printk(JFFS2_DBG_LVL "frag %#04x-%#04x: hole (*%p). left (%p), right (%p), parent (%p)\n",
+			printk(JFFS2_DBG "frag %#04x-%#04x: hole (*%p). left (%p), right (%p), parent (%p)\n",
 				this->ofs, this->ofs+this->size, this, frag_left(this),
 				frag_right(this), frag_parent(this));
 		if (this->ofs != lastofs)
@@ -578,7 +562,7 @@ __jffs2_dbg_dump_fragtree_nolock(struct jffs2_inode_info *f)
 	}
 
 	if (f->metadata)
-		printk(JFFS2_DBG_LVL "metadata at 0x%08x\n", ref_offset(f->metadata->raw));
+		printk(JFFS2_DBG "metadata at 0x%08x\n", ref_offset(f->metadata->raw));
 
 	if (buggy) {
 		JFFS2_ERROR("frag tree got a hole in it.\n");
@@ -593,13 +577,13 @@ __jffs2_dbg_dump_buffer(unsigned char *buf, int len, uint32_t offs)
 	int skip;
 	int i;
 	
-	JFFS2_DEBUG("dump from offset %#08x to offset %#08x (%x bytes).\n",
+	printk(JFFS2_DBG_MSG_PREFIX " dump from offset %#08x to offset %#08x (%x bytes).\n",
 		offs, offs + len, len);
 	i = skip = offs % JFFS2_BUFDUMP_BYTES_PER_LINE;
 	offs = offs & ~(JFFS2_BUFDUMP_BYTES_PER_LINE - 1);
 	
 	if (skip != 0)
-		printk(JFFS2_DBG_LVL "%#08x: ", offs);
+		printk(JFFS2_DBG "%#08x: ", offs);
 	
 	while (skip--)
 		printk("   ");
@@ -609,7 +593,7 @@ __jffs2_dbg_dump_buffer(unsigned char *buf, int len, uint32_t offs)
 			if (i != 0)
 				printk("\n");
 			offs += JFFS2_BUFDUMP_BYTES_PER_LINE;
-			printk(JFFS2_DBG_LVL "%0#8x: ", offs);
+			printk(JFFS2_DBG "%0#8x: ", offs);
 		}
 
 		printk("%02x ", buf[i]);
@@ -632,7 +616,7 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 	uint32_t crc;
 	int ret;
 	
-	JFFS2_DEBUG("dump node at offset %#08x.\n", ofs);
+	printk(JFFS2_DBG_MSG_PREFIX " dump node at offset %#08x.\n", ofs);
 
 	ret = jffs2_flash_read(c, ofs, len, &retlen, (unsigned char *)&node);
 	if (ret || (retlen != len)) {
@@ -641,14 +625,10 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 		return;
 	}
 
-	printk(JFFS2_DBG_LVL "magic:\t%#04x\n",
-		je16_to_cpu(node.u.magic));
-	printk(JFFS2_DBG_LVL "nodetype:\t%#04x\n",
-		je16_to_cpu(node.u.nodetype));
-	printk(JFFS2_DBG_LVL "totlen:\t%#08x\n",
-		je32_to_cpu(node.u.totlen));
-	printk(JFFS2_DBG_LVL "hdr_crc:\t%#08x\n",
-		je32_to_cpu(node.u.hdr_crc));
+	printk(JFFS2_DBG "magic:\t%#04x\n", je16_to_cpu(node.u.magic));
+	printk(JFFS2_DBG "nodetype:\t%#04x\n", je16_to_cpu(node.u.nodetype));
+	printk(JFFS2_DBG "totlen:\t%#08x\n", je32_to_cpu(node.u.totlen));
+	printk(JFFS2_DBG "hdr_crc:\t%#08x\n", je32_to_cpu(node.u.hdr_crc));
 	
 	crc = crc32(0, &node.u, sizeof(node.u) - 4);
 	if (crc != je32_to_cpu(node.u.hdr_crc)) {
@@ -668,41 +648,25 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 
 	case JFFS2_NODETYPE_INODE:
 
-		printk(JFFS2_DBG_LVL "the node is inode node\n");
-		printk(JFFS2_DBG_LVL "ino:\t%#08x\n",
-				je32_to_cpu(node.i.ino));
-		printk(JFFS2_DBG_LVL "version:\t%#08x\n",
-				je32_to_cpu(node.i.version));
-		printk(JFFS2_DBG_LVL "mode:\t%#08x\n",
-				node.i.mode.m);
-		printk(JFFS2_DBG_LVL "uid:\t%#04x\n",
-				je16_to_cpu(node.i.uid));
-		printk(JFFS2_DBG_LVL "gid:\t%#04x\n",
-				je16_to_cpu(node.i.gid));
-		printk(JFFS2_DBG_LVL "isize:\t%#08x\n",
-				je32_to_cpu(node.i.isize));
-		printk(JFFS2_DBG_LVL "atime:\t%#08x\n",
-				je32_to_cpu(node.i.atime));
-		printk(JFFS2_DBG_LVL "mtime:\t%#08x\n",
-				je32_to_cpu(node.i.mtime));
-		printk(JFFS2_DBG_LVL "ctime:\t%#08x\n",
-				je32_to_cpu(node.i.ctime));
-		printk(JFFS2_DBG_LVL "offset:\t%#08x\n",
-				je32_to_cpu(node.i.offset));
-		printk(JFFS2_DBG_LVL "csize:\t%#08x\n",
-				je32_to_cpu(node.i.csize));
-		printk(JFFS2_DBG_LVL "dsize:\t%#08x\n",
-				je32_to_cpu(node.i.dsize));
-		printk(JFFS2_DBG_LVL "compr:\t%#02x\n",
-				node.i.compr);
-		printk(JFFS2_DBG_LVL "usercompr:\t%#02x\n",
-				node.i.usercompr);
-		printk(JFFS2_DBG_LVL "flags:\t%#04x\n",
-				je16_to_cpu(node.i.flags));
-		printk(JFFS2_DBG_LVL "data_crc:\t%#08x\n",
-				je32_to_cpu(node.i.data_crc));
-		printk(JFFS2_DBG_LVL "node_crc:\t%#08x\n",
-				je32_to_cpu(node.i.node_crc));
+		printk(JFFS2_DBG "the node is inode node\n");
+		printk(JFFS2_DBG "ino:\t%#08x\n", je32_to_cpu(node.i.ino));
+		printk(JFFS2_DBG "version:\t%#08x\n", je32_to_cpu(node.i.version));
+		printk(JFFS2_DBG "mode:\t%#08x\n", node.i.mode.m);
+		printk(JFFS2_DBG "uid:\t%#04x\n", je16_to_cpu(node.i.uid));
+		printk(JFFS2_DBG "gid:\t%#04x\n", je16_to_cpu(node.i.gid));
+		printk(JFFS2_DBG "isize:\t%#08x\n", je32_to_cpu(node.i.isize));
+		printk(JFFS2_DBG "atime:\t%#08x\n", je32_to_cpu(node.i.atime));
+		printk(JFFS2_DBG "mtime:\t%#08x\n", je32_to_cpu(node.i.mtime));
+		printk(JFFS2_DBG "ctime:\t%#08x\n", je32_to_cpu(node.i.ctime));
+		printk(JFFS2_DBG "offset:\t%#08x\n", je32_to_cpu(node.i.offset));
+		printk(JFFS2_DBG "csize:\t%#08x\n", je32_to_cpu(node.i.csize));
+		printk(JFFS2_DBG "dsize:\t%#08x\n", je32_to_cpu(node.i.dsize));
+		printk(JFFS2_DBG "compr:\t%#02x\n", node.i.compr);
+		printk(JFFS2_DBG "usercompr:\t%#02x\n", node.i.usercompr);
+		printk(JFFS2_DBG "flags:\t%#04x\n", je16_to_cpu(node.i.flags));
+		printk(JFFS2_DBG "data_crc:\t%#08x\n", je32_to_cpu(node.i.data_crc));
+		printk(JFFS2_DBG "node_crc:\t%#08x\n", je32_to_cpu(node.i.node_crc));
+
 		crc = crc32(0, &node.i, sizeof(node.i) - 8); 
 		if (crc != je32_to_cpu(node.i.node_crc)) {
 			JFFS2_ERROR("wrong node header CRC.\n");
@@ -712,26 +676,18 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 
 	case JFFS2_NODETYPE_DIRENT:
 
-		printk(JFFS2_DBG_LVL "the node is dirent node\n");
-		printk(JFFS2_DBG_LVL "pino:\t%#08x\n",
-				je32_to_cpu(node.d.pino));
-		printk(JFFS2_DBG_LVL "version:\t%#08x\n",
-				je32_to_cpu(node.d.version));
-		printk(JFFS2_DBG_LVL "ino:\t%#08x\n",
-				je32_to_cpu(node.d.ino));
-		printk(JFFS2_DBG_LVL "mctime:\t%#08x\n",
-				je32_to_cpu(node.d.mctime));
-		printk(JFFS2_DBG_LVL "nsize:\t%#02x\n",
-				node.d.nsize);
-		printk(JFFS2_DBG_LVL "type:\t%#02x\n",
-				node.d.type);
-		printk(JFFS2_DBG_LVL "node_crc:\t%#08x\n",
-				je32_to_cpu(node.d.node_crc));
-		printk(JFFS2_DBG_LVL "name_crc:\t%#08x\n",
-				je32_to_cpu(node.d.name_crc));
+		printk(JFFS2_DBG "the node is dirent node\n");
+		printk(JFFS2_DBG "pino:\t%#08x\n", je32_to_cpu(node.d.pino));
+		printk(JFFS2_DBG "version:\t%#08x\n", je32_to_cpu(node.d.version));
+		printk(JFFS2_DBG "ino:\t%#08x\n", je32_to_cpu(node.d.ino));
+		printk(JFFS2_DBG "mctime:\t%#08x\n", je32_to_cpu(node.d.mctime));
+		printk(JFFS2_DBG "nsize:\t%#02x\n", node.d.nsize);
+		printk(JFFS2_DBG "type:\t%#02x\n", node.d.type);
+		printk(JFFS2_DBG "node_crc:\t%#08x\n", je32_to_cpu(node.d.node_crc));
+		printk(JFFS2_DBG "name_crc:\t%#08x\n", je32_to_cpu(node.d.name_crc));
 		
 		node.d.name[node.d.nsize] = '\0';
-		printk(JFFS2_DBG_LVL "name:\t\"%s\"\n", node.d.name);
+		printk(JFFS2_DBG "name:\t\"%s\"\n", node.d.name);
 
 		crc = crc32(0, &node.d, sizeof(node.d) - 8); 
 		if (crc != je32_to_cpu(node.d.node_crc)) {
@@ -741,7 +697,7 @@ __jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
 		break;
 
 	default:
-		printk(JFFS2_DBG_LVL "node type is unknown\n");
+		printk(JFFS2_DBG "node type is unknown\n");
 		break;
 	}
 }

commit 45ca1b509ea156e87c99e529821fb3b548e14fe3
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Fri Aug 5 12:43:47 2005 +0100

    [JFFS2] Debug code clean up - step 7
    
    Remove more noisy debugs. Add current->pid to debug messages.
    Remove bogus includes.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 80ac9b6514bf..9b776b5a7604 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: debug.c,v 1.8 2005/07/30 15:27:05 lunn Exp $
+ * $Id: debug.c,v 1.9 2005/08/05 10:42:24 dedekind Exp $
  *
  */
 #include <linux/kernel.h>
@@ -18,6 +18,44 @@
 #include "nodelist.h"
 #include "debug.h"
 
+#ifdef JFFS2_DBG_SANITY_CHECKS
+
+void
+__jffs2_dbg_acct_sanity_check_nolock(struct jffs2_sb_info *c,
+				     struct jffs2_eraseblock *jeb)
+{
+	if (unlikely(jeb && jeb->used_size + jeb->dirty_size +
+			jeb->free_size + jeb->wasted_size +
+			jeb->unchecked_size != c->sector_size)) {
+		JFFS2_ERROR("eeep, space accounting for block at 0x%08x is screwed.\n", jeb->offset);
+		JFFS2_ERROR("free %#08x + dirty %#08x + used %#08x + wasted %#08x + unchecked "
+			"%#08x != total %#08x.\n", jeb->free_size, jeb->dirty_size, jeb->used_size,
+			jeb->wasted_size, jeb->unchecked_size, c->sector_size);
+		BUG();
+	}
+
+	if (unlikely(c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size
+				+ c->wasted_size + c->unchecked_size != c->flash_size)) {
+		JFFS2_ERROR("eeep, space accounting superblock info is screwed.\n");
+		JFFS2_ERROR("free %#08x + dirty %#08x + used %#08x + erasing %#08x + bad %#08x + "
+			"wasted %#08x + unchecked %#08x != total %#08x.\n",
+			c->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,
+			c->wasted_size, c->unchecked_size, c->flash_size);
+		BUG();
+	}
+}
+
+void
+__jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,
+			      struct jffs2_eraseblock *jeb)
+{
+	spin_lock(&c->erase_completion_lock);
+	jffs2_dbg_acct_sanity_check_nolock(c, jeb);
+	spin_unlock(&c->erase_completion_lock);
+}
+
+#endif /* JFFS2_DBG_SANITY_CHECKS */
+
 #ifdef JFFS2_DBG_PARANOIA_CHECKS
 /*
  * Check the fragtree.

commit 737b7661e059680a68afb3df0a088fd976f666b7
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Jul 30 16:29:30 2005 +0100

    [JFFS2] Fix up new debug code for eCos build
    
    The debug code cleanup broke the eCos build.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index fb88eb19711b..80ac9b6514bf 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -7,10 +7,11 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: debug.c,v 1.7 2005/07/24 15:14:14 dedekind Exp $
+ * $Id: debug.c,v 1.8 2005/07/30 15:27:05 lunn Exp $
  *
  */
 #include <linux/kernel.h>
+#include <linux/types.h>
 #include <linux/pagemap.h>
 #include <linux/crc32.h>
 #include <linux/jffs2.h>

commit e0c8e42f8f218063ff6838b25038ccef7ddf257e
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Sun Jul 24 16:14:17 2005 +0100

    [JFFS2] Debug code clean up - step 3
    
    Various simplifiactions. printk format corrections.
    Convert more code to use the new debug functions.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
index 9da524ca4e66..fb88eb19711b 100644
--- a/fs/jffs2/debug.c
+++ b/fs/jffs2/debug.c
@@ -7,18 +7,30 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: debug.c,v 1.1 2005/07/17 06:56:20 dedekind Exp $
+ * $Id: debug.c,v 1.7 2005/07/24 15:14:14 dedekind Exp $
  *
  */
 #include <linux/kernel.h>
 #include <linux/pagemap.h>
+#include <linux/crc32.h>
+#include <linux/jffs2.h>
 #include "nodelist.h"
 #include "debug.h"
 
 #ifdef JFFS2_DBG_PARANOIA_CHECKS
-
+/*
+ * Check the fragtree.
+ */
 void
-jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
+__jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
+{
+	down(&f->sem);
+	__jffs2_dbg_fragtree_paranoia_check_nolock(f);
+	up(&f->sem);
+}
+	
+void
+__jffs2_dbg_fragtree_paranoia_check_nolock(struct jffs2_inode_info *f)
 {
 	struct jffs2_node_frag *frag;
 	int bitched = 0;
@@ -31,7 +43,7 @@ jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
 
 		if (ref_flags(fn->raw) == REF_PRISTINE) {
 			if (fn->frags > 1) {
-				printk(KERN_ERR "REF_PRISTINE node at 0x%08x had %d frags. Tell dwmw2\n",
+				JFFS2_ERROR("REF_PRISTINE node at 0x%08x had %d frags. Tell dwmw2.\n",
 						ref_offset(fn->raw), fn->frags);
 				bitched = 1;
 			}
@@ -43,15 +55,15 @@ jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
 			   to tell a hole node. */
 			if (frag->ofs & (PAGE_CACHE_SIZE-1) && frag_prev(frag)
 					&& frag_prev(frag)->size < PAGE_CACHE_SIZE && frag_prev(frag)->node) {
-				printk(KERN_ERR "REF_PRISTINE node at 0x%08x had a previous non-hole frag "
-						"in the same page. Tell dwmw2\n", ref_offset(fn->raw));
+				JFFS2_ERROR("REF_PRISTINE node at 0x%08x had a previous non-hole frag "
+						"in the same page. Tell dwmw2.\n", ref_offset(fn->raw));
 				bitched = 1;
 			}
 
 			if ((frag->ofs+frag->size) & (PAGE_CACHE_SIZE-1) && frag_next(frag)
 					&& frag_next(frag)->size < PAGE_CACHE_SIZE && frag_next(frag)->node) {
-				printk(KERN_ERR "REF_PRISTINE node at 0x%08x (%08x-%08x) had a following "
-						"non-hole frag in the same page. Tell dwmw2\n",
+				JFFS2_ERROR("REF_PRISTINE node at 0x%08x (%08x-%08x) had a following "
+						"non-hole frag in the same page. Tell dwmw2.\n",
 					       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);
 				bitched = 1;
 			}
@@ -59,8 +71,8 @@ jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
 	}
 
 	if (bitched) {
-		printk(KERN_ERR "Fragtree is corrupted. Fragtree dump:\n");
-		jffs2_dbg_dump_fragtree(f);
+		JFFS2_ERROR("fragtree is corrupted.\n");
+		__jffs2_dbg_dump_fragtree_nolock(f);
 		BUG();
 	}
 }
@@ -69,7 +81,8 @@ jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
  * Check if the flash contains all 0xFF before we start writing.
  */
 void
-jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c, uint32_t ofs, int len)
+__jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c,
+				    uint32_t ofs, int len)
 {
 	size_t retlen;
 	int ret, i;
@@ -81,8 +94,8 @@ jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c, uint32_t ofs, int len
 
 	ret = jffs2_flash_read(c, ofs, len, &retlen, buf);
 	if (ret || (retlen != len)) {
-		printk(KERN_WARNING "read %d bytes failed or short in %s(). ret %d, retlen %zd\n",
-				len, __FUNCTION__, ret, retlen);
+		JFFS2_WARNING("read %d bytes failed or short. ret %d, retlen %zd.\n",
+				len, ret, retlen);
 		kfree(buf);
 		return;
 	}
@@ -93,9 +106,9 @@ jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c, uint32_t ofs, int len
 			ret = 1;
 
 	if (ret) {
-		printk(KERN_ERR "ARGH. About to write node to %#08x on flash, but there are data "
-				"already there. The first corrupted byte is at %#08x.\n", ofs, ofs + i);
-		jffs2_dbg_dump_buffer(buf, len, ofs);
+		JFFS2_ERROR("argh, about to write node to %#08x on flash, but there are data "
+			"already there. The first corrupted byte is at %#08x offset.\n", ofs, ofs + i);
+		__jffs2_dbg_dump_buffer(buf, len, ofs);
 		kfree(buf);
 		BUG();
 	}
@@ -107,7 +120,17 @@ jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c, uint32_t ofs, int len
  * Check the space accounting and node_ref list correctness for the JFFS2 erasable block 'jeb'.
  */
 void
-jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
+__jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c,
+				struct jffs2_eraseblock *jeb)
+{
+	spin_lock(&c->erase_completion_lock);
+	__jffs2_dbg_acct_paranoia_check_nolock(c, jeb);
+	spin_unlock(&c->erase_completion_lock);
+}
+	
+void
+__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,
+				       struct jffs2_eraseblock *jeb)
 {
 	uint32_t my_used_size = 0;
 	uint32_t my_unchecked_size = 0;
@@ -119,11 +142,9 @@ jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c, struct jffs2_eraseblock *
 
 		if (ref2->flash_offset < jeb->offset ||
 				ref2->flash_offset > jeb->offset + c->sector_size) {
-			printk(KERN_ERR "node_ref %#08x shouldn't be in block at %#08x!\n",
+			JFFS2_ERROR("node_ref %#08x shouldn't be in block at %#08x.\n",
 				ref_offset(ref2), jeb->offset);
-			jffs2_dbg_dump_node_refs(c, jeb);
-			jffs2_dbg_dump_block_lists(c);
-			BUG();
+			goto error;
 
 		}
 		if (ref_flags(ref2) == REF_UNCHECKED)
@@ -134,69 +155,82 @@ jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c, struct jffs2_eraseblock *
 			my_dirty_size += totlen;
 
 		if ((!ref2->next_phys) != (ref2 == jeb->last_node)) {
-			printk(KERN_ERR "node_ref for node at %#08x (mem %p) has next_phys at %#08x (mem %p), "
-					"last_node is at %#08x (mem %p)\n",
-					ref_offset(ref2), ref2, ref_offset(ref2->next_phys), ref2->next_phys,
-					ref_offset(jeb->last_node), jeb->last_node);
-			jffs2_dbg_dump_node_refs(c, jeb);
-			jffs2_dbg_dump_block_lists(c);
-			BUG();
+			JFFS2_ERROR("node_ref for node at %#08x (mem %p) has next_phys at %#08x (mem %p), "
+				"last_node is at %#08x (mem %p).\n",
+				ref_offset(ref2), ref2, ref_offset(ref2->next_phys), ref2->next_phys,
+				ref_offset(jeb->last_node), jeb->last_node);
+			goto error;
 		}
 		ref2 = ref2->next_phys;
 	}
 
 	if (my_used_size != jeb->used_size) {
-		printk(KERN_ERR "Calculated used size %#08x != stored used size %#08x\n",
-				my_used_size, jeb->used_size);
-		jffs2_dbg_dump_node_refs(c, jeb);
-		jffs2_dbg_dump_block_lists(c);
-		BUG();
+		JFFS2_ERROR("Calculated used size %#08x != stored used size %#08x.\n",
+			my_used_size, jeb->used_size);
+		goto error;
 	}
 
 	if (my_unchecked_size != jeb->unchecked_size) {
-		printk(KERN_ERR "Calculated unchecked size %#08x != stored unchecked size %#08x\n",
-				my_unchecked_size, jeb->unchecked_size);
-		jffs2_dbg_dump_node_refs(c, jeb);
-		jffs2_dbg_dump_block_lists(c);
-		BUG();
+		JFFS2_ERROR("Calculated unchecked size %#08x != stored unchecked size %#08x.\n",
+			my_unchecked_size, jeb->unchecked_size);
+		goto error;
 	}
 
+#if 0
+	/* This should work when we implement ref->__totlen elemination */
 	if (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {
-		printk(KERN_ERR "Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\n",
+		JFFS2_ERROR("Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\n",
 			my_dirty_size, jeb->dirty_size + jeb->wasted_size);
-		jffs2_dbg_dump_node_refs(c, jeb);
-		jffs2_dbg_dump_block_lists(c);
-		BUG();
+		goto error;
 	}
 
 	if (jeb->free_size == 0
 		&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {
-		printk(KERN_ERR "The sum of all nodes in block (%#x) != size of block (%#x)\n",
+		JFFS2_ERROR("The sum of all nodes in block (%#x) != size of block (%#x)\n",
 			my_used_size + my_unchecked_size + my_dirty_size,
 			c->sector_size);
-		jffs2_dbg_dump_node_refs(c, jeb);
-		jffs2_dbg_dump_block_lists(c);
-		BUG();
+		goto error;
 	}
+#endif
+
+	return;
+
+error:
+	__jffs2_dbg_dump_node_refs_nolock(c, jeb);
+	__jffs2_dbg_dump_jeb_nolock(jeb);
+	__jffs2_dbg_dump_block_lists_nolock(c);
+	BUG();
+	
 }
-#endif /* JFFS2_PARANOIA_CHECKS */
+#endif /* JFFS2_DBG_PARANOIA_CHECKS */
 
-#if defined(JFFS2_PARANOIA_CHECKS) || (CONFIG_JFFS2_FS_DEBUG > 0)
+#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)
 /*
  * Dump the node_refs of the 'jeb' JFFS2 eraseblock.
  */
 void
-jffs2_dbg_dump_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
+__jffs2_dbg_dump_node_refs(struct jffs2_sb_info *c,
+			   struct jffs2_eraseblock *jeb)
+{
+	spin_lock(&c->erase_completion_lock);
+	__jffs2_dbg_dump_node_refs_nolock(c, jeb);
+	spin_unlock(&c->erase_completion_lock);
+}
+
+void
+__jffs2_dbg_dump_node_refs_nolock(struct jffs2_sb_info *c,
+				  struct jffs2_eraseblock *jeb)
 {
 	struct jffs2_raw_node_ref *ref;
 	int i = 0;
 
+	JFFS2_DEBUG("Dump node_refs of the eraseblock %#08x\n", jeb->offset);
 	if (!jeb->first_node) {
-		printk(KERN_DEBUG "no nodes in block %#08x\n", jeb->offset);
+		JFFS2_DEBUG("no nodes in the eraseblock %#08x\n", jeb->offset);
 		return;
 	}
 
-	printk(KERN_DEBUG);
+	printk(JFFS2_DBG_LVL);
 	for (ref = jeb->first_node; ; ref = ref->next_phys) {
 		printk("%#08x(%#x)", ref_offset(ref), ref->__totlen);
 		if (ref->next_phys)
@@ -205,46 +239,83 @@ jffs2_dbg_dump_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
 			break;
 		if (++i == 4) {
 			i = 0;
-			printk("\n" KERN_DEBUG);
+			printk("\n" JFFS2_DBG_LVL);
 		}
 	}
 	printk("\n");
 }
 
+/*
+ * Dump an eraseblock's space accounting.
+ */
+void
+__jffs2_dbg_dump_jeb(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
+{
+	spin_lock(&c->erase_completion_lock);
+	__jffs2_dbg_dump_jeb_nolock(jeb);
+	spin_unlock(&c->erase_completion_lock);
+}
+
 void
-jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
+__jffs2_dbg_dump_jeb_nolock(struct jffs2_eraseblock *jeb)
 {
-	printk(KERN_DEBUG "flash_size: %#08x\n",	c->flash_size);
-	printk(KERN_DEBUG "used_size: %#08x\n",		c->used_size);
-	printk(KERN_DEBUG "dirty_size: %#08x\n",	c->dirty_size);
-	printk(KERN_DEBUG "wasted_size: %#08x\n",	c->wasted_size);
-	printk(KERN_DEBUG "unchecked_size: %#08x\n",	c->unchecked_size);
-	printk(KERN_DEBUG "free_size: %#08x\n",		c->free_size);
-	printk(KERN_DEBUG "erasing_size: %#08x\n",	c->erasing_size);
-	printk(KERN_DEBUG "bad_size: %#08x\n",		c->bad_size);
-	printk(KERN_DEBUG "sector_size: %#08x\n",	c->sector_size);
-	printk(KERN_DEBUG "jffs2_reserved_blocks size: %#08x\n",
+	if (!jeb)
+		return;
+
+	JFFS2_DEBUG("dump space accounting for the eraseblock at %#08x:\n",
+			jeb->offset);
+
+	printk(JFFS2_DBG_LVL "used_size: %#08x\n",	jeb->used_size);
+	printk(JFFS2_DBG_LVL "dirty_size: %#08x\n",	jeb->dirty_size);
+	printk(JFFS2_DBG_LVL "wasted_size: %#08x\n",	jeb->wasted_size);
+	printk(JFFS2_DBG_LVL "unchecked_size: %#08x\n",	jeb->unchecked_size);
+	printk(JFFS2_DBG_LVL "free_size: %#08x\n",	jeb->free_size);
+}
+
+void
+__jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
+{
+	spin_lock(&c->erase_completion_lock);
+	__jffs2_dbg_dump_block_lists_nolock(c);
+	spin_unlock(&c->erase_completion_lock);
+}
+
+void
+__jffs2_dbg_dump_block_lists_nolock(struct jffs2_sb_info *c)
+{
+	JFFS2_DEBUG("dump JFFS2 blocks lists:\n");
+	
+	printk(JFFS2_DBG_LVL "flash_size: %#08x\n",	c->flash_size);
+	printk(JFFS2_DBG_LVL "used_size: %#08x\n",	c->used_size);
+	printk(JFFS2_DBG_LVL "dirty_size: %#08x\n",	c->dirty_size);
+	printk(JFFS2_DBG_LVL "wasted_size: %#08x\n",	c->wasted_size);
+	printk(JFFS2_DBG_LVL "unchecked_size: %#08x\n",	c->unchecked_size);
+	printk(JFFS2_DBG_LVL "free_size: %#08x\n",	c->free_size);
+	printk(JFFS2_DBG_LVL "erasing_size: %#08x\n",	c->erasing_size);
+	printk(JFFS2_DBG_LVL "bad_size: %#08x\n",	c->bad_size);
+	printk(JFFS2_DBG_LVL "sector_size: %#08x\n",	c->sector_size);
+	printk(JFFS2_DBG_LVL "jffs2_reserved_blocks size: %#08x\n",
 				c->sector_size * c->resv_blocks_write);
 
 	if (c->nextblock)
-		printk(KERN_DEBUG "nextblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-				"unchecked %#08x, free %#08x)\n",
-				c->nextblock->offset, c->nextblock->used_size,
-				c->nextblock->dirty_size, c->nextblock->wasted_size,
-				c->nextblock->unchecked_size, c->nextblock->free_size);
+		printk(JFFS2_DBG_LVL "nextblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+			"unchecked %#08x, free %#08x)\n",
+			c->nextblock->offset, c->nextblock->used_size,
+			c->nextblock->dirty_size, c->nextblock->wasted_size,
+			c->nextblock->unchecked_size, c->nextblock->free_size);
 	else
-		printk(KERN_DEBUG "nextblock: NULL\n");
+		printk(JFFS2_DBG_LVL "nextblock: NULL\n");
 
 	if (c->gcblock)
-		printk(KERN_DEBUG "gcblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-				"unchecked %#08x, free %#08x)\n",
-				c->gcblock->offset, c->gcblock->used_size, c->gcblock->dirty_size,
-				c->gcblock->wasted_size, c->gcblock->unchecked_size, c->gcblock->free_size);
+		printk(JFFS2_DBG_LVL "gcblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+			"unchecked %#08x, free %#08x)\n",
+			c->gcblock->offset, c->gcblock->used_size, c->gcblock->dirty_size,
+			c->gcblock->wasted_size, c->gcblock->unchecked_size, c->gcblock->free_size);
 	else
-		printk(KERN_DEBUG "gcblock: NULL\n");
+		printk(JFFS2_DBG_LVL "gcblock: NULL\n");
 
 	if (list_empty(&c->clean_list)) {
-		printk(KERN_DEBUG "clean_list: empty\n");
+		printk(JFFS2_DBG_LVL "clean_list: empty\n");
 	} else {
 		struct list_head *this;
 		int numblocks = 0;
@@ -255,19 +326,19 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			numblocks ++;
 			dirty += jeb->wasted_size;
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "clean_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "clean_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 
-		printk (KERN_DEBUG "Contains %d blocks with total wasted size %u, average wasted size: %u\n",
-				numblocks, dirty, dirty / numblocks);
+		printk (JFFS2_DBG_LVL "Contains %d blocks with total wasted size %u, average wasted size: %u\n",
+			numblocks, dirty, dirty / numblocks);
 	}
 
 	if (list_empty(&c->very_dirty_list)) {
-		printk(KERN_DEBUG "very_dirty_list: empty\n");
+		printk(JFFS2_DBG_LVL "very_dirty_list: empty\n");
 	} else {
 		struct list_head *this;
 		int numblocks = 0;
@@ -279,19 +350,19 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			numblocks ++;
 			dirty += jeb->dirty_size;
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "very_dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "very_dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 
-		printk (KERN_DEBUG "Contains %d blocks with total dirty size %u, average dirty size: %u\n",
-				numblocks, dirty, dirty / numblocks);
+		printk (JFFS2_DBG_LVL "Contains %d blocks with total dirty size %u, average dirty size: %u\n",
+			numblocks, dirty, dirty / numblocks);
 	}
 
 	if (list_empty(&c->dirty_list)) {
-		printk(KERN_DEBUG "dirty_list: empty\n");
+		printk(JFFS2_DBG_LVL "dirty_list: empty\n");
 	} else {
 		struct list_head *this;
 		int numblocks = 0;
@@ -303,19 +374,19 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			numblocks ++;
 			dirty += jeb->dirty_size;
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 
-		printk (KERN_DEBUG "Contains %d blocks with total dirty size %u, average dirty size: %u\n",
+		printk (JFFS2_DBG_LVL "contains %d blocks with total dirty size %u, average dirty size: %u\n",
 			numblocks, dirty, dirty / numblocks);
 	}
 
 	if (list_empty(&c->erasable_list)) {
-		printk(KERN_DEBUG "erasable_list: empty\n");
+		printk(JFFS2_DBG_LVL "erasable_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -323,16 +394,16 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "erasable_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "erasable_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 	}
 
 	if (list_empty(&c->erasing_list)) {
-		printk(KERN_DEBUG "erasing_list: empty\n");
+		printk(JFFS2_DBG_LVL "erasing_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -340,16 +411,16 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "erasing_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "erasing_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 	}
 
 	if (list_empty(&c->erase_pending_list)) {
-		printk(KERN_DEBUG "erase_pending_list: empty\n");
+		printk(JFFS2_DBG_LVL "erase_pending_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -357,16 +428,16 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "erase_pending_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "erase_pending_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 	}
 
 	if (list_empty(&c->erasable_pending_wbuf_list)) {
-		printk(KERN_DEBUG "erasable_pending_wbuf_list: empty\n");
+		printk(JFFS2_DBG_LVL "erasable_pending_wbuf_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -374,16 +445,16 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "erasable_pending_wbuf_list: %#08x (used %#08x, dirty %#08x, "
-						"wasted %#08x, unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "erasable_pending_wbuf_list: %#08x (used %#08x, dirty %#08x, "
+					"wasted %#08x, unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 	}
 
 	if (list_empty(&c->free_list)) {
-		printk(KERN_DEBUG "free_list: empty\n");
+		printk(JFFS2_DBG_LVL "free_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -391,16 +462,16 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "free_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "free_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 	}
 
 	if (list_empty(&c->bad_list)) {
-		printk(KERN_DEBUG "bad_list: empty\n");
+		printk(JFFS2_DBG_LVL "bad_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -408,16 +479,16 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "bad_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "bad_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 	}
 
 	if (list_empty(&c->bad_used_list)) {
-		printk(KERN_DEBUG "bad_used_list: empty\n");
+		printk(JFFS2_DBG_LVL "bad_used_list: empty\n");
 	} else {
 		struct list_head *this;
 
@@ -425,34 +496,42 @@ jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
 			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
 
 			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
-				printk(KERN_DEBUG "bad_used_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
-						"unchecked %#08x, free %#08x)\n",
-						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
-						jeb->unchecked_size, jeb->free_size);
+				printk(JFFS2_DBG_LVL "bad_used_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+					"unchecked %#08x, free %#08x)\n",
+					jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+					jeb->unchecked_size, jeb->free_size);
 			}
 		}
 	}
 }
 
 void
-jffs2_dbg_dump_fragtree(struct jffs2_inode_info *f)
+__jffs2_dbg_dump_fragtree(struct jffs2_inode_info *f)
+{
+	down(&f->sem);
+	jffs2_dbg_dump_fragtree_nolock(f);
+	up(&f->sem);
+}
+
+void
+__jffs2_dbg_dump_fragtree_nolock(struct jffs2_inode_info *f)
 {
 	struct jffs2_node_frag *this = frag_first(&f->fragtree);
 	uint32_t lastofs = 0;
 	int buggy = 0;
 
-	printk(KERN_DEBUG "inode is ino #%u\n", f->inocache->ino);
+	JFFS2_DEBUG("dump fragtree of ino #%u\n", f->inocache->ino);
 	while(this) {
 		if (this->node)
-			printk(KERN_DEBUG "frag %#04x-%#04x: %#08x(%d) on flash (*%p), left (%p), "
-					"right (%p), parent (%p)\n",
-					this->ofs, this->ofs+this->size, ref_offset(this->node->raw),
-					ref_flags(this->node->raw), this, frag_left(this), frag_right(this),
-					frag_parent(this));
+			printk(JFFS2_DBG_LVL "frag %#04x-%#04x: %#08x(%d) on flash (*%p), left (%p), "
+				"right (%p), parent (%p)\n",
+				this->ofs, this->ofs+this->size, ref_offset(this->node->raw),
+				ref_flags(this->node->raw), this, frag_left(this), frag_right(this),
+				frag_parent(this));
 		else
-			printk(KERN_DEBUG "frag %#04x-%#04x: hole (*%p). left (%p), right (%p), parent (%p)\n",
-					this->ofs, this->ofs+this->size, this, frag_left(this),
-					frag_right(this), frag_parent(this));
+			printk(JFFS2_DBG_LVL "frag %#04x-%#04x: hole (*%p). left (%p), right (%p), parent (%p)\n",
+				this->ofs, this->ofs+this->size, this, frag_left(this),
+				frag_right(this), frag_parent(this));
 		if (this->ofs != lastofs)
 			buggy = 1;
 		lastofs = this->ofs + this->size;
@@ -460,36 +539,171 @@ jffs2_dbg_dump_fragtree(struct jffs2_inode_info *f)
 	}
 
 	if (f->metadata)
-		printk(KERN_DEBUG "metadata at 0x%08x\n", ref_offset(f->metadata->raw));
+		printk(JFFS2_DBG_LVL "metadata at 0x%08x\n", ref_offset(f->metadata->raw));
 
 	if (buggy) {
-		printk(KERN_ERR "Error! %s(): Frag tree got a hole in it\n", __FUNCTION__);
+		JFFS2_ERROR("frag tree got a hole in it.\n");
 		BUG();
 	}
 }
 
-#define JFFS3_BUFDUMP_BYTES_PER_LINE	8
+#define JFFS2_BUFDUMP_BYTES_PER_LINE	32
 void
-jffs2_dbg_dump_buffer(char *buf, int len, uint32_t offs)
+__jffs2_dbg_dump_buffer(unsigned char *buf, int len, uint32_t offs)
 {
-	int i = 0;
-	int skip = offs & ~(JFFS3_BUFDUMP_BYTES_PER_LINE - 1);
+	int skip;
+	int i;
+	
+	JFFS2_DEBUG("dump from offset %#08x to offset %#08x (%x bytes).\n",
+		offs, offs + len, len);
+	i = skip = offs % JFFS2_BUFDUMP_BYTES_PER_LINE;
+	offs = offs & ~(JFFS2_BUFDUMP_BYTES_PER_LINE - 1);
+	
+	if (skip != 0)
+		printk(JFFS2_DBG_LVL "%#08x: ", offs);
+	
+	while (skip--)
+		printk("   ");
 
 	while (i < len) {
-		int j = 0;
-
-		printk(KERN_DEBUG "0x#x: \n");
-		while (skip) {
-			printk("   ");
-			skip -= 1;
+		if ((i % JFFS2_BUFDUMP_BYTES_PER_LINE) == 0 && i != len -1) {
+			if (i != 0)
+				printk("\n");
+			offs += JFFS2_BUFDUMP_BYTES_PER_LINE;
+			printk(JFFS2_DBG_LVL "%0#8x: ", offs);
 		}
 
-		while (j < JFFS3_BUFDUMP_BYTES_PER_LINE) {
-			if (i + j < len)
-				printk(" %#02x", buf[i + j++]);
+		printk("%02x ", buf[i]);
+		
+		i += 1;
+	}
+
+	printk("\n");
+}
+
+/*
+ * Dump a JFFS2 node.
+ */
+void
+__jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)
+{
+	union jffs2_node_union node;
+	int len = sizeof(union jffs2_node_union);
+	size_t retlen;
+	uint32_t crc;
+	int ret;
+	
+	JFFS2_DEBUG("dump node at offset %#08x.\n", ofs);
+
+	ret = jffs2_flash_read(c, ofs, len, &retlen, (unsigned char *)&node);
+	if (ret || (retlen != len)) {
+		JFFS2_ERROR("read %d bytes failed or short. ret %d, retlen %zd.\n",
+			len, ret, retlen);
+		return;
+	}
+
+	printk(JFFS2_DBG_LVL "magic:\t%#04x\n",
+		je16_to_cpu(node.u.magic));
+	printk(JFFS2_DBG_LVL "nodetype:\t%#04x\n",
+		je16_to_cpu(node.u.nodetype));
+	printk(JFFS2_DBG_LVL "totlen:\t%#08x\n",
+		je32_to_cpu(node.u.totlen));
+	printk(JFFS2_DBG_LVL "hdr_crc:\t%#08x\n",
+		je32_to_cpu(node.u.hdr_crc));
+	
+	crc = crc32(0, &node.u, sizeof(node.u) - 4);
+	if (crc != je32_to_cpu(node.u.hdr_crc)) {
+		JFFS2_ERROR("wrong common header CRC.\n");
+		return;
+	}
+	
+	if (je16_to_cpu(node.u.magic) != JFFS2_MAGIC_BITMASK &&
+		je16_to_cpu(node.u.magic) != JFFS2_OLD_MAGIC_BITMASK)
+	{
+		JFFS2_ERROR("wrong node magic: %#04x instead of %#04x.\n",
+			je16_to_cpu(node.u.magic), JFFS2_MAGIC_BITMASK);
+		return;
+	}
+
+	switch(je16_to_cpu(node.u.nodetype)) {
+
+	case JFFS2_NODETYPE_INODE:
+
+		printk(JFFS2_DBG_LVL "the node is inode node\n");
+		printk(JFFS2_DBG_LVL "ino:\t%#08x\n",
+				je32_to_cpu(node.i.ino));
+		printk(JFFS2_DBG_LVL "version:\t%#08x\n",
+				je32_to_cpu(node.i.version));
+		printk(JFFS2_DBG_LVL "mode:\t%#08x\n",
+				node.i.mode.m);
+		printk(JFFS2_DBG_LVL "uid:\t%#04x\n",
+				je16_to_cpu(node.i.uid));
+		printk(JFFS2_DBG_LVL "gid:\t%#04x\n",
+				je16_to_cpu(node.i.gid));
+		printk(JFFS2_DBG_LVL "isize:\t%#08x\n",
+				je32_to_cpu(node.i.isize));
+		printk(JFFS2_DBG_LVL "atime:\t%#08x\n",
+				je32_to_cpu(node.i.atime));
+		printk(JFFS2_DBG_LVL "mtime:\t%#08x\n",
+				je32_to_cpu(node.i.mtime));
+		printk(JFFS2_DBG_LVL "ctime:\t%#08x\n",
+				je32_to_cpu(node.i.ctime));
+		printk(JFFS2_DBG_LVL "offset:\t%#08x\n",
+				je32_to_cpu(node.i.offset));
+		printk(JFFS2_DBG_LVL "csize:\t%#08x\n",
+				je32_to_cpu(node.i.csize));
+		printk(JFFS2_DBG_LVL "dsize:\t%#08x\n",
+				je32_to_cpu(node.i.dsize));
+		printk(JFFS2_DBG_LVL "compr:\t%#02x\n",
+				node.i.compr);
+		printk(JFFS2_DBG_LVL "usercompr:\t%#02x\n",
+				node.i.usercompr);
+		printk(JFFS2_DBG_LVL "flags:\t%#04x\n",
+				je16_to_cpu(node.i.flags));
+		printk(JFFS2_DBG_LVL "data_crc:\t%#08x\n",
+				je32_to_cpu(node.i.data_crc));
+		printk(JFFS2_DBG_LVL "node_crc:\t%#08x\n",
+				je32_to_cpu(node.i.node_crc));
+		crc = crc32(0, &node.i, sizeof(node.i) - 8); 
+		if (crc != je32_to_cpu(node.i.node_crc)) {
+			JFFS2_ERROR("wrong node header CRC.\n");
+			return;
+		}
+		break;
+
+	case JFFS2_NODETYPE_DIRENT:
+
+		printk(JFFS2_DBG_LVL "the node is dirent node\n");
+		printk(JFFS2_DBG_LVL "pino:\t%#08x\n",
+				je32_to_cpu(node.d.pino));
+		printk(JFFS2_DBG_LVL "version:\t%#08x\n",
+				je32_to_cpu(node.d.version));
+		printk(JFFS2_DBG_LVL "ino:\t%#08x\n",
+				je32_to_cpu(node.d.ino));
+		printk(JFFS2_DBG_LVL "mctime:\t%#08x\n",
+				je32_to_cpu(node.d.mctime));
+		printk(JFFS2_DBG_LVL "nsize:\t%#02x\n",
+				node.d.nsize);
+		printk(JFFS2_DBG_LVL "type:\t%#02x\n",
+				node.d.type);
+		printk(JFFS2_DBG_LVL "node_crc:\t%#08x\n",
+				je32_to_cpu(node.d.node_crc));
+		printk(JFFS2_DBG_LVL "name_crc:\t%#08x\n",
+				je32_to_cpu(node.d.name_crc));
+		
+		node.d.name[node.d.nsize] = '\0';
+		printk(JFFS2_DBG_LVL "name:\t\"%s\"\n", node.d.name);
+
+		crc = crc32(0, &node.d, sizeof(node.d) - 8); 
+		if (crc != je32_to_cpu(node.d.node_crc)) {
+			JFFS2_ERROR("wrong node header CRC.\n");
+			return;
 		}
+		break;
 
-		i += JFFS3_BUFDUMP_BYTES_PER_LINE;
+	default:
+		printk(JFFS2_DBG_LVL "node type is unknown\n");
+		break;
 	}
 }
-#endif /* JFFS2_PARANOIA_CHECKS || CONFIG_JFFS2_FS_DEBUG > 0 */
+#endif /* JFFS2_DBG_DUMPS || JFFS2_DBG_PARANOIA_CHECKS */

commit 730554d94607572ef8300c5c9848540b42394897
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Sun Jul 17 07:56:26 2005 +0100

    [JFFS2] Debug code clean up - step 1
    
    Move debug functions into a seperate source file
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/debug.c b/fs/jffs2/debug.c
new file mode 100644
index 000000000000..9da524ca4e66
--- /dev/null
+++ b/fs/jffs2/debug.c
@@ -0,0 +1,495 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001-2003 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@infradead.org>
+ *
+ * For licensing information, see the file 'LICENCE' in this directory.
+ *
+ * $Id: debug.c,v 1.1 2005/07/17 06:56:20 dedekind Exp $
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/pagemap.h>
+#include "nodelist.h"
+#include "debug.h"
+
+#ifdef JFFS2_DBG_PARANOIA_CHECKS
+
+void
+jffs2_dbg_fragtree_paranoia_check(struct jffs2_inode_info *f)
+{
+	struct jffs2_node_frag *frag;
+	int bitched = 0;
+
+	for (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {
+		struct jffs2_full_dnode *fn = frag->node;
+
+		if (!fn || !fn->raw)
+			continue;
+
+		if (ref_flags(fn->raw) == REF_PRISTINE) {
+			if (fn->frags > 1) {
+				printk(KERN_ERR "REF_PRISTINE node at 0x%08x had %d frags. Tell dwmw2\n",
+						ref_offset(fn->raw), fn->frags);
+				bitched = 1;
+			}
+
+			/* A hole node which isn't multi-page should be garbage-collected
+			   and merged anyway, so we just check for the frag size here,
+			   rather than mucking around with actually reading the node
+			   and checking the compression type, which is the real way
+			   to tell a hole node. */
+			if (frag->ofs & (PAGE_CACHE_SIZE-1) && frag_prev(frag)
+					&& frag_prev(frag)->size < PAGE_CACHE_SIZE && frag_prev(frag)->node) {
+				printk(KERN_ERR "REF_PRISTINE node at 0x%08x had a previous non-hole frag "
+						"in the same page. Tell dwmw2\n", ref_offset(fn->raw));
+				bitched = 1;
+			}
+
+			if ((frag->ofs+frag->size) & (PAGE_CACHE_SIZE-1) && frag_next(frag)
+					&& frag_next(frag)->size < PAGE_CACHE_SIZE && frag_next(frag)->node) {
+				printk(KERN_ERR "REF_PRISTINE node at 0x%08x (%08x-%08x) had a following "
+						"non-hole frag in the same page. Tell dwmw2\n",
+					       ref_offset(fn->raw), frag->ofs, frag->ofs+frag->size);
+				bitched = 1;
+			}
+		}
+	}
+
+	if (bitched) {
+		printk(KERN_ERR "Fragtree is corrupted. Fragtree dump:\n");
+		jffs2_dbg_dump_fragtree(f);
+		BUG();
+	}
+}
+
+/*
+ * Check if the flash contains all 0xFF before we start writing.
+ */
+void
+jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c, uint32_t ofs, int len)
+{
+	size_t retlen;
+	int ret, i;
+	unsigned char *buf;
+
+	buf = kmalloc(len, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	ret = jffs2_flash_read(c, ofs, len, &retlen, buf);
+	if (ret || (retlen != len)) {
+		printk(KERN_WARNING "read %d bytes failed or short in %s(). ret %d, retlen %zd\n",
+				len, __FUNCTION__, ret, retlen);
+		kfree(buf);
+		return;
+	}
+
+	ret = 0;
+	for (i = 0; i < len; i++)
+		if (buf[i] != 0xff)
+			ret = 1;
+
+	if (ret) {
+		printk(KERN_ERR "ARGH. About to write node to %#08x on flash, but there are data "
+				"already there. The first corrupted byte is at %#08x.\n", ofs, ofs + i);
+		jffs2_dbg_dump_buffer(buf, len, ofs);
+		kfree(buf);
+		BUG();
+	}
+
+	kfree(buf);
+}
+
+/*
+ * Check the space accounting and node_ref list correctness for the JFFS2 erasable block 'jeb'.
+ */
+void
+jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
+{
+	uint32_t my_used_size = 0;
+	uint32_t my_unchecked_size = 0;
+	uint32_t my_dirty_size = 0;
+	struct jffs2_raw_node_ref *ref2 = jeb->first_node;
+
+	while (ref2) {
+		uint32_t totlen = ref_totlen(c, jeb, ref2);
+
+		if (ref2->flash_offset < jeb->offset ||
+				ref2->flash_offset > jeb->offset + c->sector_size) {
+			printk(KERN_ERR "node_ref %#08x shouldn't be in block at %#08x!\n",
+				ref_offset(ref2), jeb->offset);
+			jffs2_dbg_dump_node_refs(c, jeb);
+			jffs2_dbg_dump_block_lists(c);
+			BUG();
+
+		}
+		if (ref_flags(ref2) == REF_UNCHECKED)
+			my_unchecked_size += totlen;
+		else if (!ref_obsolete(ref2))
+			my_used_size += totlen;
+		else
+			my_dirty_size += totlen;
+
+		if ((!ref2->next_phys) != (ref2 == jeb->last_node)) {
+			printk(KERN_ERR "node_ref for node at %#08x (mem %p) has next_phys at %#08x (mem %p), "
+					"last_node is at %#08x (mem %p)\n",
+					ref_offset(ref2), ref2, ref_offset(ref2->next_phys), ref2->next_phys,
+					ref_offset(jeb->last_node), jeb->last_node);
+			jffs2_dbg_dump_node_refs(c, jeb);
+			jffs2_dbg_dump_block_lists(c);
+			BUG();
+		}
+		ref2 = ref2->next_phys;
+	}
+
+	if (my_used_size != jeb->used_size) {
+		printk(KERN_ERR "Calculated used size %#08x != stored used size %#08x\n",
+				my_used_size, jeb->used_size);
+		jffs2_dbg_dump_node_refs(c, jeb);
+		jffs2_dbg_dump_block_lists(c);
+		BUG();
+	}
+
+	if (my_unchecked_size != jeb->unchecked_size) {
+		printk(KERN_ERR "Calculated unchecked size %#08x != stored unchecked size %#08x\n",
+				my_unchecked_size, jeb->unchecked_size);
+		jffs2_dbg_dump_node_refs(c, jeb);
+		jffs2_dbg_dump_block_lists(c);
+		BUG();
+	}
+
+	if (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {
+		printk(KERN_ERR "Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\n",
+			my_dirty_size, jeb->dirty_size + jeb->wasted_size);
+		jffs2_dbg_dump_node_refs(c, jeb);
+		jffs2_dbg_dump_block_lists(c);
+		BUG();
+	}
+
+	if (jeb->free_size == 0
+		&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {
+		printk(KERN_ERR "The sum of all nodes in block (%#x) != size of block (%#x)\n",
+			my_used_size + my_unchecked_size + my_dirty_size,
+			c->sector_size);
+		jffs2_dbg_dump_node_refs(c, jeb);
+		jffs2_dbg_dump_block_lists(c);
+		BUG();
+	}
+}
+#endif /* JFFS2_PARANOIA_CHECKS */
+
+#if defined(JFFS2_PARANOIA_CHECKS) || (CONFIG_JFFS2_FS_DEBUG > 0)
+/*
+ * Dump the node_refs of the 'jeb' JFFS2 eraseblock.
+ */
+void
+jffs2_dbg_dump_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
+{
+	struct jffs2_raw_node_ref *ref;
+	int i = 0;
+
+	if (!jeb->first_node) {
+		printk(KERN_DEBUG "no nodes in block %#08x\n", jeb->offset);
+		return;
+	}
+
+	printk(KERN_DEBUG);
+	for (ref = jeb->first_node; ; ref = ref->next_phys) {
+		printk("%#08x(%#x)", ref_offset(ref), ref->__totlen);
+		if (ref->next_phys)
+			printk("->");
+		else
+			break;
+		if (++i == 4) {
+			i = 0;
+			printk("\n" KERN_DEBUG);
+		}
+	}
+	printk("\n");
+}
+
+void
+jffs2_dbg_dump_block_lists(struct jffs2_sb_info *c)
+{
+	printk(KERN_DEBUG "flash_size: %#08x\n",	c->flash_size);
+	printk(KERN_DEBUG "used_size: %#08x\n",		c->used_size);
+	printk(KERN_DEBUG "dirty_size: %#08x\n",	c->dirty_size);
+	printk(KERN_DEBUG "wasted_size: %#08x\n",	c->wasted_size);
+	printk(KERN_DEBUG "unchecked_size: %#08x\n",	c->unchecked_size);
+	printk(KERN_DEBUG "free_size: %#08x\n",		c->free_size);
+	printk(KERN_DEBUG "erasing_size: %#08x\n",	c->erasing_size);
+	printk(KERN_DEBUG "bad_size: %#08x\n",		c->bad_size);
+	printk(KERN_DEBUG "sector_size: %#08x\n",	c->sector_size);
+	printk(KERN_DEBUG "jffs2_reserved_blocks size: %#08x\n",
+				c->sector_size * c->resv_blocks_write);
+
+	if (c->nextblock)
+		printk(KERN_DEBUG "nextblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+				"unchecked %#08x, free %#08x)\n",
+				c->nextblock->offset, c->nextblock->used_size,
+				c->nextblock->dirty_size, c->nextblock->wasted_size,
+				c->nextblock->unchecked_size, c->nextblock->free_size);
+	else
+		printk(KERN_DEBUG "nextblock: NULL\n");
+
+	if (c->gcblock)
+		printk(KERN_DEBUG "gcblock: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+				"unchecked %#08x, free %#08x)\n",
+				c->gcblock->offset, c->gcblock->used_size, c->gcblock->dirty_size,
+				c->gcblock->wasted_size, c->gcblock->unchecked_size, c->gcblock->free_size);
+	else
+		printk(KERN_DEBUG "gcblock: NULL\n");
+
+	if (list_empty(&c->clean_list)) {
+		printk(KERN_DEBUG "clean_list: empty\n");
+	} else {
+		struct list_head *this;
+		int numblocks = 0;
+		uint32_t dirty = 0;
+
+		list_for_each(this, &c->clean_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+			numblocks ++;
+			dirty += jeb->wasted_size;
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "clean_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+
+		printk (KERN_DEBUG "Contains %d blocks with total wasted size %u, average wasted size: %u\n",
+				numblocks, dirty, dirty / numblocks);
+	}
+
+	if (list_empty(&c->very_dirty_list)) {
+		printk(KERN_DEBUG "very_dirty_list: empty\n");
+	} else {
+		struct list_head *this;
+		int numblocks = 0;
+		uint32_t dirty = 0;
+
+		list_for_each(this, &c->very_dirty_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			numblocks ++;
+			dirty += jeb->dirty_size;
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "very_dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+
+		printk (KERN_DEBUG "Contains %d blocks with total dirty size %u, average dirty size: %u\n",
+				numblocks, dirty, dirty / numblocks);
+	}
+
+	if (list_empty(&c->dirty_list)) {
+		printk(KERN_DEBUG "dirty_list: empty\n");
+	} else {
+		struct list_head *this;
+		int numblocks = 0;
+		uint32_t dirty = 0;
+
+		list_for_each(this, &c->dirty_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			numblocks ++;
+			dirty += jeb->dirty_size;
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "dirty_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+
+		printk (KERN_DEBUG "Contains %d blocks with total dirty size %u, average dirty size: %u\n",
+			numblocks, dirty, dirty / numblocks);
+	}
+
+	if (list_empty(&c->erasable_list)) {
+		printk(KERN_DEBUG "erasable_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->erasable_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "erasable_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+	}
+
+	if (list_empty(&c->erasing_list)) {
+		printk(KERN_DEBUG "erasing_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->erasing_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "erasing_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+	}
+
+	if (list_empty(&c->erase_pending_list)) {
+		printk(KERN_DEBUG "erase_pending_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->erase_pending_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "erase_pending_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+	}
+
+	if (list_empty(&c->erasable_pending_wbuf_list)) {
+		printk(KERN_DEBUG "erasable_pending_wbuf_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->erasable_pending_wbuf_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "erasable_pending_wbuf_list: %#08x (used %#08x, dirty %#08x, "
+						"wasted %#08x, unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+	}
+
+	if (list_empty(&c->free_list)) {
+		printk(KERN_DEBUG "free_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->free_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "free_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+	}
+
+	if (list_empty(&c->bad_list)) {
+		printk(KERN_DEBUG "bad_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->bad_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "bad_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+	}
+
+	if (list_empty(&c->bad_used_list)) {
+		printk(KERN_DEBUG "bad_used_list: empty\n");
+	} else {
+		struct list_head *this;
+
+		list_for_each(this, &c->bad_used_list) {
+			struct jffs2_eraseblock *jeb = list_entry(this, struct jffs2_eraseblock, list);
+
+			if (!(jeb->used_size == 0 && jeb->dirty_size == 0 && jeb->wasted_size == 0)) {
+				printk(KERN_DEBUG "bad_used_list: %#08x (used %#08x, dirty %#08x, wasted %#08x, "
+						"unchecked %#08x, free %#08x)\n",
+						jeb->offset, jeb->used_size, jeb->dirty_size, jeb->wasted_size,
+						jeb->unchecked_size, jeb->free_size);
+			}
+		}
+	}
+}
+
+void
+jffs2_dbg_dump_fragtree(struct jffs2_inode_info *f)
+{
+	struct jffs2_node_frag *this = frag_first(&f->fragtree);
+	uint32_t lastofs = 0;
+	int buggy = 0;
+
+	printk(KERN_DEBUG "inode is ino #%u\n", f->inocache->ino);
+	while(this) {
+		if (this->node)
+			printk(KERN_DEBUG "frag %#04x-%#04x: %#08x(%d) on flash (*%p), left (%p), "
+					"right (%p), parent (%p)\n",
+					this->ofs, this->ofs+this->size, ref_offset(this->node->raw),
+					ref_flags(this->node->raw), this, frag_left(this), frag_right(this),
+					frag_parent(this));
+		else
+			printk(KERN_DEBUG "frag %#04x-%#04x: hole (*%p). left (%p), right (%p), parent (%p)\n",
+					this->ofs, this->ofs+this->size, this, frag_left(this),
+					frag_right(this), frag_parent(this));
+		if (this->ofs != lastofs)
+			buggy = 1;
+		lastofs = this->ofs + this->size;
+		this = frag_next(this);
+	}
+
+	if (f->metadata)
+		printk(KERN_DEBUG "metadata at 0x%08x\n", ref_offset(f->metadata->raw));
+
+	if (buggy) {
+		printk(KERN_ERR "Error! %s(): Frag tree got a hole in it\n", __FUNCTION__);
+		BUG();
+	}
+}
+
+#define JFFS3_BUFDUMP_BYTES_PER_LINE	8
+void
+jffs2_dbg_dump_buffer(char *buf, int len, uint32_t offs)
+{
+	int i = 0;
+	int skip = offs & ~(JFFS3_BUFDUMP_BYTES_PER_LINE - 1);
+
+	while (i < len) {
+		int j = 0;
+
+		printk(KERN_DEBUG "0x#x: \n");
+		while (skip) {
+			printk("   ");
+			skip -= 1;
+		}
+
+		while (j < JFFS3_BUFDUMP_BYTES_PER_LINE) {
+			if (i + j < len)
+				printk(" %#02x", buf[i + j++]);
+		}
+
+		i += JFFS3_BUFDUMP_BYTES_PER_LINE;
+	}
+}
+#endif /* JFFS2_PARANOIA_CHECKS || CONFIG_JFFS2_FS_DEBUG > 0 */
