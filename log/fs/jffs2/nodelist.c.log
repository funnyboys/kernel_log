commit 6e78c01fde9023e0701f3af880c1fd9de6e4e8e3
Author: Joel Stanley <joel@jms.id.au>
Date:   Fri Nov 29 10:49:30 2019 +1030

    Revert "jffs2: Fix possible null-pointer dereferences in jffs2_add_frag_to_fragtree()"
    
    This reverts commit f2538f999345405f7d2e1194c0c8efa4e11f7b3a. The patch
    stopped JFFS2 from being able to mount an existing filesystem with the
    following errors:
    
     jffs2: error: (77) jffs2_build_inode_fragtree: Add node to tree failed -22
     jffs2: error: (77) jffs2_do_read_inode_internal: Failed to build final fragtree for inode #5377: error -22
    
    Fixes: f2538f999345 ("jffs2: Fix possible null-pointer dereferences...")
    Cc: stable@vger.kernel.org
    Suggested-by: Hou Tao <houtao1@huawei.com>
    Signed-off-by: Joel Stanley <joel@jms.id.au>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 021a4a2190ee..b86c78d178c6 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -226,7 +226,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 		lastend = this->ofs + this->size;
 	} else {
 		dbg_fragtree2("lookup gave no frag\n");
-		return -EINVAL;
+		lastend = 0;
 	}
 
 	/* See if we ran off the end of the fragtree */

commit f2538f999345405f7d2e1194c0c8efa4e11f7b3a
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Wed Jul 24 10:46:58 2019 +0800

    jffs2: Fix possible null-pointer dereferences in jffs2_add_frag_to_fragtree()
    
    In jffs2_add_frag_to_fragtree(), there is an if statement on line 223 to
    check whether "this" is NULL:
        if (this)
    
    When "this" is NULL, it is used at several places, such as on line 249:
        if (this->node)
    and on line 260:
        if (newfrag->ofs > this->ofs)
    
    Thus possible null-pointer dereferences may occur.
    
    To fix these bugs, -EINVAL is returned when "this" is NULL.
    
    These bugs are found by a static analysis tool STCheck written by us.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index b86c78d178c6..021a4a2190ee 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -226,7 +226,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 		lastend = this->ofs + this->size;
 	} else {
 		dbg_fragtree2("lookup gave no frag\n");
-		lastend = 0;
+		return -EINVAL;
 	}
 
 	/* See if we ran off the end of the fragtree */

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 9a5449bc3afb..b86c78d178c6 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -90,7 +90,7 @@ uint32_t jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list,
 
 	/* If the last fragment starts at the RAM page boundary, it is
 	 * REF_PRISTINE irrespective of its size. */
-	if (frag->node && (frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {
+	if (frag->node && (frag->ofs & (PAGE_SIZE - 1)) == 0) {
 		dbg_fragtree2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",
 			frag->ofs, frag->ofs + frag->size);
 		frag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;
@@ -237,7 +237,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 		   If so, both 'this' and the new node get marked REF_NORMAL so
 		   the GC can take a look.
 		*/
-		if (lastend && (lastend-1) >> PAGE_CACHE_SHIFT == newfrag->ofs >> PAGE_CACHE_SHIFT) {
+		if (lastend && (lastend-1) >> PAGE_SHIFT == newfrag->ofs >> PAGE_SHIFT) {
 			if (this->node)
 				mark_ref_normal(this->node->raw);
 			mark_ref_normal(newfrag->node->raw);
@@ -382,7 +382,7 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 
 	/* If we now share a page with other nodes, mark either previous
 	   or next node REF_NORMAL, as appropriate.  */
-	if (newfrag->ofs & (PAGE_CACHE_SIZE-1)) {
+	if (newfrag->ofs & (PAGE_SIZE-1)) {
 		struct jffs2_node_frag *prev = frag_prev(newfrag);
 
 		mark_ref_normal(fn->raw);
@@ -391,7 +391,7 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 			mark_ref_normal(prev->node->raw);
 	}
 
-	if ((newfrag->ofs+newfrag->size) & (PAGE_CACHE_SIZE-1)) {
+	if ((newfrag->ofs+newfrag->size) & (PAGE_SIZE-1)) {
 		struct jffs2_node_frag *next = frag_next(newfrag);
 
 		if (next) {

commit e8bbeeb755a077cfc0f814b07739f9225642d65c
Author: Cody P Schafer <cody@linux.vnet.ibm.com>
Date:   Thu Jan 23 15:56:11 2014 -0800

    fs/jffs2: use rbtree postorder iteration helper instead of opencoding
    
    Use rbtree_postorder_for_each_entry_safe() to destroy the rbtree instead
    of opencoding an alternate postorder iteration that modifies the tree
    
    Signed-off-by: Cody P Schafer <cody@linux.vnet.ibm.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 975a1f562c10..9a5449bc3afb 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -564,25 +564,10 @@ struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_
    they're killed. */
 void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 {
-	struct jffs2_node_frag *frag;
-	struct jffs2_node_frag *parent;
-
-	if (!root->rb_node)
-		return;
+	struct jffs2_node_frag *frag, *next;
 
 	dbg_fragtree("killing\n");
-
-	frag = (rb_entry(root->rb_node, struct jffs2_node_frag, rb));
-	while(frag) {
-		if (frag->rb.rb_left) {
-			frag = frag_left(frag);
-			continue;
-		}
-		if (frag->rb.rb_right) {
-			frag = frag_right(frag);
-			continue;
-		}
-
+	rbtree_postorder_for_each_entry_safe(frag, next, root, rb) {
 		if (frag->node && !(--frag->node->frags)) {
 			/* Not a hole, and it's the final remaining frag
 			   of this node. Free the node */
@@ -591,17 +576,8 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 
 			jffs2_free_full_dnode(frag->node);
 		}
-		parent = frag_parent(frag);
-		if (parent) {
-			if (frag_left(parent) == frag)
-				parent->rb.rb_left = NULL;
-			else
-				parent->rb.rb_right = NULL;
-		}
 
 		jffs2_free_node_frag(frag);
-		frag = parent;
-
 		cond_resched();
 	}
 }

commit 5a528957e7c74f1fed73fe20424b7a3421658877
Author: Joe Perches <joe@perches.com>
Date:   Wed Feb 15 15:56:45 2012 -0800

    jffs2: Use pr_fmt and remove jffs: from formats
    
    Use pr_fmt to prefix KBUILD_MODNAME to appropriate logging messages.
    
    Remove now unnecessary internal prefixes from formats.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index fc16761d72e4..975a1f562c10 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -9,6 +9,8 @@
  *
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/fs.h>

commit da320f055a8818269c008e30b887cdcf09d8e4bd
Author: Joe Perches <joe@perches.com>
Date:   Wed Feb 15 15:56:44 2012 -0800

    jffs2: Convert printks to pr_<level>
    
    Use the more current logging style.
    
    Coalesce formats, align arguments.
    Convert uses of embedded function names to %s, __func__.
    
    A couple of long line checkpatch errors I don't care about exist.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 5e03233c2363..fc16761d72e4 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -687,8 +687,8 @@ int jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb
 	if (!size)
 		return 0;
 	if (unlikely(size > jeb->free_size)) {
-		printk(KERN_CRIT "Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\n",
-		       size, jeb->free_size, jeb->wasted_size);
+		pr_crit("Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\n",
+			size, jeb->free_size, jeb->wasted_size);
 		BUG();
 	}
 	/* REF_EMPTY_NODE is !obsolete, so that works OK */
@@ -726,8 +726,10 @@ static inline uint32_t __ref_totlen(struct jffs2_sb_info *c,
 
 		/* Last node in block. Use free_space */
 		if (unlikely(ref != jeb->last_node)) {
-			printk(KERN_CRIT "ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\n",
-			       ref, ref_offset(ref), jeb->last_node, jeb->last_node?ref_offset(jeb->last_node):0);
+			pr_crit("ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\n",
+				ref, ref_offset(ref), jeb->last_node,
+				jeb->last_node ?
+				ref_offset(jeb->last_node) : 0);
 			BUG();
 		}
 		ref_end = jeb->offset + c->sector_size - jeb->free_size;
@@ -747,16 +749,20 @@ uint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *je
 		if (!jeb)
 			jeb = &c->blocks[ref->flash_offset / c->sector_size];
 
-		printk(KERN_CRIT "Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\n",
-		       ref, ref_offset(ref), ref_offset(ref)+ref->__totlen,
-		       ret, ref->__totlen);
+		pr_crit("Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\n",
+			ref, ref_offset(ref), ref_offset(ref) + ref->__totlen,
+			ret, ref->__totlen);
 		if (ref_next(ref)) {
-			printk(KERN_CRIT "next %p (0x%08x-0x%08x)\n", ref_next(ref), ref_offset(ref_next(ref)),
-			       ref_offset(ref_next(ref))+ref->__totlen);
+			pr_crit("next %p (0x%08x-0x%08x)\n",
+				ref_next(ref), ref_offset(ref_next(ref)),
+				ref_offset(ref_next(ref)) + ref->__totlen);
 		} else 
-			printk(KERN_CRIT "No next ref. jeb->last_node is %p\n", jeb->last_node);
+			pr_crit("No next ref. jeb->last_node is %p\n",
+				jeb->last_node);
 
-		printk(KERN_CRIT "jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\n", jeb->wasted_size, jeb->dirty_size, jeb->used_size, jeb->free_size);
+		pr_crit("jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\n",
+			jeb->wasted_size, jeb->dirty_size, jeb->used_size,
+			jeb->free_size);
 
 #if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)
 		__jffs2_dbg_dump_node_refs_nolock(c, jeb);

commit 65e5a0e18e5fb5bc6cfabd8ef4b9fc1c8569ba62
Author: Daniel Drake <dsd@laptop.org>
Date:   Thu Oct 7 19:14:02 2010 +0100

    jffs2: Dynamically choose inocache hash size
    
    When JFFS2 is used for large volumes, the mount times are quite long.
    Increasing the hash size provides a significant speed boost on the OLPC
    XO-1 laptop.
    
    Add logic that dynamically selects a hash size based on the size of
    the medium. A 64mb medium will result in a hash size of 128, and a 512mb
    medium will result in a hash size of 1024.
    
    Signed-off-by: Daniel Drake <dsd@laptop.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index af02bd138469..5e03233c2363 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -420,7 +420,7 @@ struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t
 {
 	struct jffs2_inode_cache *ret;
 
-	ret = c->inocache_list[ino % INOCACHE_HASHSIZE];
+	ret = c->inocache_list[ino % c->inocache_hashsize];
 	while (ret && ret->ino < ino) {
 		ret = ret->next;
 	}
@@ -441,7 +441,7 @@ void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new
 
 	dbg_inocache("add %p (ino #%u)\n", new, new->ino);
 
-	prev = &c->inocache_list[new->ino % INOCACHE_HASHSIZE];
+	prev = &c->inocache_list[new->ino % c->inocache_hashsize];
 
 	while ((*prev) && (*prev)->ino < new->ino) {
 		prev = &(*prev)->next;
@@ -462,7 +462,7 @@ void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
 	dbg_inocache("del %p (ino #%u)\n", old, old->ino);
 	spin_lock(&c->inocache_lock);
 
-	prev = &c->inocache_list[old->ino % INOCACHE_HASHSIZE];
+	prev = &c->inocache_list[old->ino % c->inocache_hashsize];
 
 	while ((*prev) && (*prev)->ino < old->ino) {
 		prev = &(*prev)->next;
@@ -487,7 +487,7 @@ void jffs2_free_ino_caches(struct jffs2_sb_info *c)
 	int i;
 	struct jffs2_inode_cache *this, *next;
 
-	for (i=0; i<INOCACHE_HASHSIZE; i++) {
+	for (i=0; i < c->inocache_hashsize; i++) {
 		this = c->inocache_list[i];
 		while (this) {
 			next = this->next;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 87c6f555e1a0..af02bd138469 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -15,7 +15,6 @@
 #include <linux/mtd/mtd.h>
 #include <linux/rbtree.h>
 #include <linux/crc32.h>
-#include <linux/slab.h>
 #include <linux/pagemap.h>
 #include "nodelist.h"
 

commit 15953580e79b58caefb107e77f218e009b9992e6
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Nov 1 16:25:56 2007 -0400

    [JFFS2] Improve getdents vs. f_pos handling on NOR flash.
    
    Commit a491486a2087ac3dfc00efb4f838c8d684afaf54 started obliterating
    dirents directly on the medium, when jffs2_can_mark_obsolete(). Removing
    them immediately from the f->dents list, however, screws up handling of
    f_pos within a directory -- because the offset is equivalent to the
    number of entries through the list we are, and the existence of
    deletion dirents served to provide 'placeholders' for unlinked
    entries. Now, 'rm -r' doesn't even manage to unlink everything in the
    directory.
    
    Revert to keeping 'deletion' dirents in the list, at least in memory
    even though we no longer write anything to the medium.
    
    Spotted, debugged and mostly fixed by Joakim Tjernlund
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 4bf86088b3ae..87c6f555e1a0 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -32,15 +32,18 @@ void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new
 		if ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {
 			/* Duplicate. Free one */
 			if (new->version < (*prev)->version) {
-				dbg_dentlist("Eep! Marking new dirent node is obsolete, old is \"%s\", ino #%u\n",
+				dbg_dentlist("Eep! Marking new dirent node obsolete, old is \"%s\", ino #%u\n",
 					(*prev)->name, (*prev)->ino);
 				jffs2_mark_node_obsolete(c, new->raw);
 				jffs2_free_full_dirent(new);
 			} else {
-				dbg_dentlist("marking old dirent \"%s\", ino #%u bsolete\n",
+				dbg_dentlist("marking old dirent \"%s\", ino #%u obsolete\n",
 					(*prev)->name, (*prev)->ino);
 				new->next = (*prev)->next;
-				jffs2_mark_node_obsolete(c, ((*prev)->raw));
+				/* It may have been a 'placeholder' deletion dirent, 
+				   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */
+				if ((*prev)->raw)
+					jffs2_mark_node_obsolete(c, ((*prev)->raw));
 				jffs2_free_full_dirent(*prev);
 				*prev = new;
 			}

commit 61c4b23770d1b0cef7c06a23378ab544eb0c64b4
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 25 17:04:23 2007 +0100

    [JFFS2] Handle inodes with only a single metadata node with non-zero isize
    
    This should never happen unless there's corruption on the medium and the
    actual data nodes go missing. But the failure mode (an oops when we assume
    the fragtree isn't empty and go looking for its last node) isn't useful.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index ac2a4c422e32..4bf86088b3ae 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -52,7 +52,7 @@ void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new
 	*prev = new;
 }
 
-void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)
+uint32_t jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)
 {
 	struct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);
 
@@ -74,18 +74,24 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 	}
 
 	if (size == 0)
-		return;
+		return 0;
 
-	/*
-	 * If the last fragment starts at the RAM page boundary, it is
-	 * REF_PRISTINE irrespective of its size.
-	 */
 	frag = frag_last(list);
+
+	/* Sanity check for truncation to longer than we started with... */
+	if (!frag)
+		return 0;
+	if (frag->ofs + frag->size < size)
+		return frag->ofs + frag->size;
+
+	/* If the last fragment starts at the RAM page boundary, it is
+	 * REF_PRISTINE irrespective of its size. */
 	if (frag->node && (frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {
 		dbg_fragtree2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",
 			frag->ofs, frag->ofs + frag->size);
 		frag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;
 	}
+	return size;
 }
 
 static void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,

commit c00c310eac04a28d2143368ae988716792ed53ce
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 25 14:16:47 2007 +0100

    [JFFS2] Tidy up licensing/copyright boilerplate.
    
    In particular, remove the bit in the LICENCE file about contacting
    Red Hat for alternative arrangements. Their errant IS department broke
    that arrangement a long time ago -- the policy of collecting copyright
    assignments from contributors came to an end when the plug was pulled on
    the servers hosting the project, without notice or reason.
    
    We do still dual-license it for use with eCos, with the GPL+exception
    licence approved by the FSF as being GPL-compatible. It's just that nobody
    has the right to license it differently.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index fecffbc63552..ac2a4c422e32 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -1,14 +1,12 @@
 /*
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
- * Copyright (C) 2001-2003 Red Hat, Inc.
+ * Copyright © 2001-2007 Red Hat, Inc.
  *
  * Created by David Woodhouse <dwmw2@infradead.org>
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.115 2005/11/07 11:14:40 gleixner Exp $
- *
  */
 
 #include <linux/kernel.h>

commit df8e96f39103adf5a13332d784040a2c62667243
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 25 03:23:42 2007 +0100

    [JFFS2] Improve read_inode memory usage, v2.
    
    We originally used to read every node and allocate a jffs2_tmp_dnode_info
    structure for each, before processing them in (reverse) version order
    and discarding the ones which are obsoleted by later nodes.
    
    With huge logfiles, this behaviour caused memory problems. For example, a
    file involved in OLPC trac #1292 has 1822391 nodes, and would cause the XO
    machine to run out of memory during the first stage of read_inode().
    
    Instead of just inserting nodes into a tree in version order as we find
    them, we now put them into a tree in order of their offset within the
    file, which allows us to immediately discard nodes which are completely
    obsoleted.
    
    We don't use a full tree with 'fragments' pointing to the real data
    structure, as we do in the normal fragtree. We sort only on the start
    address, and add an 'overlapped' flag to the tmp_dnode_info to indicate
    that the node in question is (partially) overlapped by another.
    
    When the scan is complete, we start at the end of the file, adding each
    node to a real fragtree as before. Where the node is non-overlapped, we
    just add it (it doesn't matter that it's not the latest version; there is
    no overlap). When the node at the end of the tree _is_ overlapped, we sort
    it and all its overlapping nodes into version order and then add them to
    the fragtree in that order.
    
    This 'early discard' reduces the peak allocation of tmp_dnode_info
    structures from 1.8M to a mere 62872 (3.5%) in the degenerate case
    referenced above.
    
    This version of the patch also correctly rememembers the highest node
    version# seen for an inode when it's scanned.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 5a6b4d64206c..fecffbc63552 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -397,466 +397,6 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 	return 0;
 }
 
-/*
- * Check the data CRC of the node.
- *
- * Returns: 0 if the data CRC is correct;
- * 	    1 - if incorrect;
- *	    error code if an error occured.
- */
-static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)
-{
-	struct jffs2_raw_node_ref *ref = tn->fn->raw;
-	int err = 0, pointed = 0;
-	struct jffs2_eraseblock *jeb;
-	unsigned char *buffer;
-	uint32_t crc, ofs, len;
-	size_t retlen;
-
-	BUG_ON(tn->csize == 0);
-
-	if (!jffs2_is_writebuffered(c))
-		goto adj_acc;
-
-	/* Calculate how many bytes were already checked */
-	ofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);
-	len = ofs % c->wbuf_pagesize;
-	if (likely(len))
-		len = c->wbuf_pagesize - len;
-
-	if (len >= tn->csize) {
-		dbg_readinode("no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\n",
-			ref_offset(ref), tn->csize, ofs);
-		goto adj_acc;
-	}
-
-	ofs += len;
-	len = tn->csize - len;
-
-	dbg_readinode("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",
-		ref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);
-
-#ifndef __ECOS
-	/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),
-	 * adding and jffs2_flash_read_end() interface. */
-	if (c->mtd->point) {
-		err = c->mtd->point(c->mtd, ofs, len, &retlen, &buffer);
-		if (!err && retlen < tn->csize) {
-			JFFS2_WARNING("MTD point returned len too short: %zu instead of %u.\n", retlen, tn->csize);
-			c->mtd->unpoint(c->mtd, buffer, ofs, len);
-		} else if (err)
-			JFFS2_WARNING("MTD point failed: error code %d.\n", err);
-		else
-			pointed = 1; /* succefully pointed to device */
-	}
-#endif
-
-	if (!pointed) {
-		buffer = kmalloc(len, GFP_KERNEL);
-		if (unlikely(!buffer))
-			return -ENOMEM;
-
-		/* TODO: this is very frequent pattern, make it a separate
-		 * routine */
-		err = jffs2_flash_read(c, ofs, len, &retlen, buffer);
-		if (err) {
-			JFFS2_ERROR("can not read %d bytes from 0x%08x, error code: %d.\n", len, ofs, err);
-			goto free_out;
-		}
-
-		if (retlen != len) {
-			JFFS2_ERROR("short read at %#08x: %zd instead of %d.\n", ofs, retlen, len);
-			err = -EIO;
-			goto free_out;
-		}
-	}
-
-	/* Continue calculating CRC */
-	crc = crc32(tn->partial_crc, buffer, len);
-	if(!pointed)
-		kfree(buffer);
-#ifndef __ECOS
-	else
-		c->mtd->unpoint(c->mtd, buffer, ofs, len);
-#endif
-
-	if (crc != tn->data_crc) {
-		JFFS2_NOTICE("wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",
-			ofs, tn->data_crc, crc);
-		return 1;
-	}
-
-adj_acc:
-	jeb = &c->blocks[ref->flash_offset / c->sector_size];
-	len = ref_totlen(c, jeb, ref);
-
-	/*
-	 * Mark the node as having been checked and fix the
-	 * accounting accordingly.
-	 */
-	spin_lock(&c->erase_completion_lock);
-	jeb->used_size += len;
-	jeb->unchecked_size -= len;
-	c->used_size += len;
-	c->unchecked_size -= len;
-	spin_unlock(&c->erase_completion_lock);
-
-	return 0;
-
-free_out:
-	if(!pointed)
-		kfree(buffer);
-#ifndef __ECOS
-	else
-		c->mtd->unpoint(c->mtd, buffer, ofs, len);
-#endif
-	return err;
-}
-
-/*
- * Helper function for jffs2_add_older_frag_to_fragtree().
- *
- * Checks the node if we are in the checking stage.
- */
-static int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn)
-{
-	int ret;
-
-	BUG_ON(ref_obsolete(tn->fn->raw));
-
-	/* We only check the data CRC of unchecked nodes */
-	if (ref_flags(tn->fn->raw) != REF_UNCHECKED)
-		return 0;
-
-	dbg_fragtree2("check node %#04x-%#04x, phys offs %#08x.\n",
-		tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));
-
-	ret = check_node_data(c, tn);
-	if (unlikely(ret < 0)) {
-		JFFS2_ERROR("check_node_data() returned error: %d.\n",
-			ret);
-	} else if (unlikely(ret > 0)) {
-		dbg_fragtree2("CRC error, mark it obsolete.\n");
-		jffs2_mark_node_obsolete(c, tn->fn->raw);
-	}
-
-	return ret;
-}
-
-/*
- * Helper function for jffs2_add_older_frag_to_fragtree().
- *
- * Called when the new fragment that is being inserted
- * splits a hole fragment.
- */
-static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
-		      struct jffs2_node_frag *newfrag, struct jffs2_node_frag *hole)
-{
-	dbg_fragtree2("fragment %#04x-%#04x splits the hole %#04x-%#04x\n",
-		newfrag->ofs, newfrag->ofs + newfrag->size, hole->ofs, hole->ofs + hole->size);
-
-	if (hole->ofs == newfrag->ofs) {
-		/*
-		 * Well, the new fragment actually starts at the same offset as
-		 * the hole.
-		 */
-		if (hole->ofs + hole->size > newfrag->ofs + newfrag->size) {
-			/*
-			 * We replace the overlapped left part of the hole by
-			 * the new node.
-			 */
-
-			dbg_fragtree2("insert fragment %#04x-%#04x and cut the left part of the hole\n",
-				newfrag->ofs, newfrag->ofs + newfrag->size);
-			rb_replace_node(&hole->rb, &newfrag->rb, root);
-
-			hole->ofs += newfrag->size;
-			hole->size -= newfrag->size;
-
-			/*
-			 * We know that 'hole' should be the right hand
-			 * fragment.
-			 */
-			jffs2_fragtree_insert(hole, newfrag);
-			rb_insert_color(&hole->rb, root);
-		} else {
-			/*
-			 * Ah, the new fragment is of the same size as the hole.
-			 * Relace the hole by it.
-			 */
-			dbg_fragtree2("insert fragment %#04x-%#04x and overwrite hole\n",
-				newfrag->ofs, newfrag->ofs + newfrag->size);
-			rb_replace_node(&hole->rb, &newfrag->rb, root);
-			jffs2_free_node_frag(hole);
-		}
-	} else {
-		/* The new fragment lefts some hole space at the left */
-
-		struct jffs2_node_frag * newfrag2 = NULL;
-
-		if (hole->ofs + hole->size > newfrag->ofs + newfrag->size) {
-			/* The new frag also lefts some space at the right */
-			newfrag2 = new_fragment(NULL, newfrag->ofs +
-				newfrag->size, hole->ofs + hole->size
-				- newfrag->ofs - newfrag->size);
-			if (unlikely(!newfrag2)) {
-				jffs2_free_node_frag(newfrag);
-				return -ENOMEM;
-			}
-		}
-
-		hole->size = newfrag->ofs - hole->ofs;
-		dbg_fragtree2("left the hole %#04x-%#04x at the left and inserd fragment %#04x-%#04x\n",
-			hole->ofs, hole->ofs + hole->size, newfrag->ofs, newfrag->ofs + newfrag->size);
-
-		jffs2_fragtree_insert(newfrag, hole);
-		rb_insert_color(&newfrag->rb, root);
-
-		if (newfrag2) {
-			dbg_fragtree2("left the hole %#04x-%#04x at the right\n",
-				newfrag2->ofs, newfrag2->ofs + newfrag2->size);
-			jffs2_fragtree_insert(newfrag2, newfrag);
-			rb_insert_color(&newfrag2->rb, root);
-		}
-	}
-
-	return 0;
-}
-
-/*
- * This function is used when we build inode. It expects the nodes are passed
- * in the decreasing version order. The whole point of this is to improve the
- * inodes checking on NAND: we check the nodes' data CRC only when they are not
- * obsoleted. Previously, add_frag_to_fragtree() function was used and
- * nodes were passed to it in the increasing version ordes and CRCs of all
- * nodes were checked.
- *
- * Note: tn->fn->size shouldn't be zero.
- *
- * Returns 0 if the node was inserted
- *         1 if it wasn't inserted (since it is obsolete)
- *         < 0 an if error occured
- */
-int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-				     struct jffs2_tmp_dnode_info *tn)
-{
-	struct jffs2_node_frag *this, *newfrag;
-	uint32_t lastend;
-	struct jffs2_full_dnode *fn = tn->fn;
-	struct rb_root *root = &f->fragtree;
-	uint32_t fn_size = fn->size, fn_ofs = fn->ofs;
-	int err, checked = 0;
-	int ref_flag;
-
-	dbg_fragtree("insert fragment %#04x-%#04x, ver %u\n", fn_ofs, fn_ofs + fn_size, tn->version);
-
-	/* Skip all the nodes which are completed before this one starts */
-	this = jffs2_lookup_node_frag(root, fn_ofs);
-	if (this)
-		dbg_fragtree2("'this' found %#04x-%#04x (%s)\n", this->ofs, this->ofs + this->size, this->node ? "data" : "hole");
-
-	if (this)
-		lastend = this->ofs + this->size;
-	else
-		lastend = 0;
-
-	/* Detect the preliminary type of node */
-	if (fn->size >= PAGE_CACHE_SIZE)
-		ref_flag = REF_PRISTINE;
-	else
-		ref_flag = REF_NORMAL;
-
-	/* See if we ran off the end of the root */
-	if (lastend <= fn_ofs) {
-		/* We did */
-
-		/*
-		 * We are going to insert the new node into the
-		 * fragment tree, so check it.
-		 */
-		err = check_node(c, f, tn);
-		if (err != 0)
-			return err;
-
-		fn->frags = 1;
-
-		newfrag = new_fragment(fn, fn_ofs, fn_size);
-		if (unlikely(!newfrag))
-			return -ENOMEM;
-
-		err = no_overlapping_node(c, root, newfrag, this, lastend);
-		if (unlikely(err != 0)) {
-			jffs2_free_node_frag(newfrag);
-			return err;
-		}
-
-		goto out_ok;
-	}
-
-	fn->frags = 0;
-
-	while (1) {
-		/*
-		 * Here we have:
-		 * fn_ofs < this->ofs + this->size && fn_ofs >= this->ofs.
-		 *
-		 * Remember, 'this' has higher version, any non-hole node
-		 * which is already in the fragtree is newer then the newly
-		 * inserted.
-		 */
-		if (!this->node) {
-			/*
-			 * 'this' is the hole fragment, so at least the
-			 * beginning of the new fragment is valid.
-			 */
-
-			/*
-			 * We are going to insert the new node into the
-			 * fragment tree, so check it.
-			 */
-			if (!checked) {
-				err = check_node(c, f, tn);
-				if (unlikely(err != 0))
-					return err;
-				checked = 1;
-			}
-
-			if (this->ofs + this->size >= fn_ofs + fn_size) {
-				/* We split the hole on two parts */
-
-				fn->frags += 1;
-				newfrag = new_fragment(fn, fn_ofs, fn_size);
-				if (unlikely(!newfrag))
-					return -ENOMEM;
-
-				err = split_hole(c, root, newfrag, this);
-				if (unlikely(err))
-					return err;
-				goto out_ok;
-			}
-
-			/*
-			 * The beginning of the new fragment is valid since it
-			 * overlaps the hole node.
-			 */
-
-			ref_flag = REF_NORMAL;
-
-			fn->frags += 1;
-			newfrag = new_fragment(fn, fn_ofs,
-					this->ofs + this->size - fn_ofs);
-			if (unlikely(!newfrag))
-				return -ENOMEM;
-
-			if (fn_ofs == this->ofs) {
-				/*
-				 * The new node starts at the same offset as
-				 * the hole and supersieds the hole.
-				 */
-				dbg_fragtree2("add the new fragment instead of hole %#04x-%#04x, refcnt %d\n",
-					fn_ofs, fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
-
-				rb_replace_node(&this->rb, &newfrag->rb, root);
-				jffs2_free_node_frag(this);
-			} else {
-				/*
-				 * The hole becomes shorter as its right part
-				 * is supersieded by the new fragment.
-				 */
-				dbg_fragtree2("reduce size of hole %#04x-%#04x to %#04x-%#04x\n",
-					this->ofs, this->ofs + this->size, this->ofs, this->ofs + this->size - newfrag->size);
-
-				dbg_fragtree2("add new fragment %#04x-%#04x, refcnt %d\n", fn_ofs,
-					fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
-
-				this->size -= newfrag->size;
-				jffs2_fragtree_insert(newfrag, this);
-				rb_insert_color(&newfrag->rb, root);
-			}
-
-			fn_ofs += newfrag->size;
-			fn_size -= newfrag->size;
-			this = rb_entry(rb_next(&newfrag->rb),
-					struct jffs2_node_frag, rb);
-
-			dbg_fragtree2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
-				this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
-		}
-
-		/*
-		 * 'This' node is not the hole so it obsoletes the new fragment
-		 * either fully or partially.
-		 */
-		if (this->ofs + this->size >= fn_ofs + fn_size) {
-			/* The new node is obsolete, drop it */
-			if (fn->frags == 0) {
-				dbg_fragtree2("%#04x-%#04x is obsolete, mark it obsolete\n", fn_ofs, fn_ofs + fn_size);
-				ref_flag = REF_OBSOLETE;
-			}
-			goto out_ok;
-		} else {
-			struct jffs2_node_frag *new_this;
-
-			/* 'This' node obsoletes the beginning of the new node */
-			dbg_fragtree2("the beginning %#04x-%#04x is obsolete\n", fn_ofs, this->ofs + this->size);
-
-			ref_flag = REF_NORMAL;
-
-			fn_size -= this->ofs + this->size - fn_ofs;
-			fn_ofs = this->ofs + this->size;
-			dbg_fragtree2("now considering %#04x-%#04x\n", fn_ofs, fn_ofs + fn_size);
-
-			new_this = rb_entry(rb_next(&this->rb), struct jffs2_node_frag, rb);
-			if (!new_this) {
-				/*
-				 * There is no next fragment. Add the rest of
-				 * the new node as the right-hand child.
-				 */
-				if (!checked) {
-					err = check_node(c, f, tn);
-					if (unlikely(err != 0))
-						return err;
-					checked = 1;
-				}
-
-				fn->frags += 1;
-				newfrag = new_fragment(fn, fn_ofs, fn_size);
-				if (unlikely(!newfrag))
-					return -ENOMEM;
-
-				dbg_fragtree2("there are no more fragments, insert %#04x-%#04x\n",
-					newfrag->ofs, newfrag->ofs + newfrag->size);
-				rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);
-				rb_insert_color(&newfrag->rb, root);
-				goto out_ok;
-			} else {
-				this = new_this;
-				dbg_fragtree2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
-					this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
-			}
-		}
-	}
-
-out_ok:
-	BUG_ON(fn->size < PAGE_CACHE_SIZE && ref_flag == REF_PRISTINE);
-
-	if (ref_flag == REF_OBSOLETE) {
-		dbg_fragtree2("the node is obsolete now\n");
-		/* jffs2_mark_node_obsolete() will adjust space accounting */
-		jffs2_mark_node_obsolete(c, fn->raw);
-		return 1;
-	}
-
-	dbg_fragtree2("the node is \"%s\" now\n", ref_flag == REF_NORMAL ? "REF_NORMAL" : "REF_PRISTINE");
-
-	/* Space accounting was adjusted at check_node_data() */
-	spin_lock(&c->erase_completion_lock);
-	fn->raw->flash_offset = ref_offset(fn->raw) | ref_flag;
-	spin_unlock(&c->erase_completion_lock);
-
-	return 0;
-}
-
 void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)
 {
 	spin_lock(&c->inocache_lock);

commit 90a18fab4ae07b77bf053b75a4d1285cd94faa79
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jul 6 22:37:43 2006 +0200

    make fs/jffs2/nodelist.c:jffs2_obsolete_node_frag() static
    
    This patch makes the needlessly global jffs2_obsolete_node_frag()
    static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 7675b33396c7..5a6b4d64206c 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -21,6 +21,9 @@
 #include <linux/pagemap.h>
 #include "nodelist.h"
 
+static void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,
+				     struct jffs2_node_frag *this);
+
 void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)
 {
 	struct jffs2_full_dirent **prev = list;
@@ -87,7 +90,8 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 	}
 }
 
-void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *this)
+static void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,
+				     struct jffs2_node_frag *this)
 {
 	if (this->node) {
 		this->node->frags--;

commit 355ed4e141203fd7266ef9d90d57be0c61bd1aa4
Author: KaiGai Kohei <kaigai@ak.jp.nec.com>
Date:   Sat Jun 24 09:15:36 2006 +0900

    [JFFS2][XATTR] Fix memory leak with jffs2_xattr_ref
    
    If xattr_ref is associated with an orphan inode_cache
    on filesystem mounting, those xattr_refs are not
    released even if this inode_cache is released.
    
    This patch enables to call jffs2_xattr_delete_inode()
    for such a irregular inode_cachde too.
    
    Signed-off-by: KaiGai Kohei <kaigai@ak.jp.nec.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 927dfe42ba76..7675b33396c7 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -906,6 +906,9 @@ void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
 {
 	struct jffs2_inode_cache **prev;
 
+#ifdef CONFIG_JFFS2_FS_XATTR
+	BUG_ON(old->xref);
+#endif
 	dbg_inocache("del %p (ino #%u)\n", old, old->ino);
 	spin_lock(&c->inocache_lock);
 

commit 2ebf09c2491433a499e0ae7723d04e9e810afa84
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sun May 28 22:13:25 2006 +0100

    [JFFS2] Fix oops when marking space dirty in scan, but no previous node exists.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 5d36e9b4d7c5..927dfe42ba76 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -1139,7 +1139,7 @@ int jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb
 		BUG();
 	}
 	/* REF_EMPTY_NODE is !obsolete, so that works OK */
-	if (ref_obsolete(jeb->last_node)) {
+	if (jeb->last_node && ref_obsolete(jeb->last_node)) {
 #ifdef TEST_TOTLEN
 		jeb->last_node->__totlen += size;
 #endif

commit 9bfeb691e75b21fdaa80ffae719083200b190381
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Fri May 26 21:19:05 2006 +0100

    [JFFS2] Switch to using an array of jffs2_raw_node_refs instead of a list.
    
    This allows us to drop another pointer from the struct jffs2_raw_node_ref,
    shrinking it to 8 bytes on 32-bit machines (if the TEST_TOTLEN) paranoia
    check is turned off, which will be committed soon).
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 0e82979c741c..5d36e9b4d7c5 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -954,18 +954,16 @@ void jffs2_free_raw_node_refs(struct jffs2_sb_info *c)
 	for (i=0; i<c->nr_blocks; i++) {
 		this = c->blocks[i].first_node;
 		while (this) {
-			next = this->next_phys;
-			__jffs2_free_raw_node_ref(this);
+			if (this[REFS_PER_BLOCK].flash_offset == REF_LINK_NODE)
+				next = this[REFS_PER_BLOCK].next_in_ino;
+			else
+				next = NULL;
+
+			jffs2_free_refblock(this);
 			this = next;
 		}
 		c->blocks[i].first_node = c->blocks[i].last_node = NULL;
 	}
-	this = c->refs;
-	while (this) {
-		next = this->next_in_ino;
-		__jffs2_free_raw_node_ref(this);
-		this = next;
-	}
 }
 
 struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)
@@ -1060,32 +1058,37 @@ struct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,
 {
 	struct jffs2_raw_node_ref *ref;
 
-	/* These will be preallocated _very_ shortly. */
-	ref = c->refs;
-	if (!c->refs) {
-		JFFS2_WARNING("Using non-preallocated refs!\n");
-		ref = __jffs2_alloc_raw_node_ref();
-		BUG_ON(!ref);
-		WARN_ON(1);
-	} else {
-		c->refs = ref->next_in_ino;
+	BUG_ON(!jeb->allocated_refs);
+	jeb->allocated_refs--;
+
+	ref = jeb->last_node;
+
+	dbg_noderef("Last node at %p is (%08x,%p)\n", ref, ref->flash_offset,
+		    ref->next_in_ino);
+
+	while (ref->flash_offset != REF_EMPTY_NODE) {
+		if (ref->flash_offset == REF_LINK_NODE)
+			ref = ref->next_in_ino;
+		else
+			ref++;
 	}
 
-	ref->next_phys = NULL;
+	dbg_noderef("New ref is %p (%08x becomes %08x,%p) len 0x%x\n", ref, 
+		    ref->flash_offset, ofs, ref->next_in_ino, len);
+
 	ref->flash_offset = ofs;
 
-	if (!jeb->first_node)
+	if (!jeb->first_node) {
 		jeb->first_node = ref;
-	if (jeb->last_node) {
-		jeb->last_node->next_phys = ref;
-#ifdef TEST_TOTLEN
-		if (ref_offset(jeb->last_node) + jeb->last_node->__totlen != ref_offset(ref)) {
-			printk(KERN_CRIT "Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\n",
-			       ref, ref_offset(ref), ref_offset(ref)+ref->__totlen,
-			       ref_offset(jeb->last_node), ref_offset(jeb->last_node)+jeb->last_node->__totlen);
-			WARN_ON(1);
-		}
-#endif
+		BUG_ON(ref_offset(ref) != jeb->offset);
+	} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {
+		uint32_t last_len = ref_totlen(c, jeb, jeb->last_node);
+
+		JFFS2_ERROR("Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\n",
+			    ref, ref_offset(ref), ref_offset(ref)+len,
+			    ref_offset(jeb->last_node), 
+			    ref_offset(jeb->last_node)+last_len);
+		BUG();
 	}
 	jeb->last_node = ref;
 
@@ -1130,12 +1133,13 @@ int jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb
 {
 	if (!size)
 		return 0;
-	if (size > c->sector_size - jeb->used_size) {
-		printk(KERN_CRIT "Dirty space 0x%x larger then used_size 0x%x (wasted 0x%x)\n",
-		       size, jeb->used_size, jeb->wasted_size);
+	if (unlikely(size > jeb->free_size)) {
+		printk(KERN_CRIT "Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\n",
+		       size, jeb->free_size, jeb->wasted_size);
 		BUG();
 	}
-	if (jeb->last_node && ref_obsolete(jeb->last_node)) {
+	/* REF_EMPTY_NODE is !obsolete, so that works OK */
+	if (ref_obsolete(jeb->last_node)) {
 #ifdef TEST_TOTLEN
 		jeb->last_node->__totlen += size;
 #endif
@@ -1168,7 +1172,7 @@ static inline uint32_t __ref_totlen(struct jffs2_sb_info *c,
 			jeb = &c->blocks[ref->flash_offset / c->sector_size];
 
 		/* Last node in block. Use free_space */
-		if (ref != jeb->last_node) {
+		if (unlikely(ref != jeb->last_node)) {
 			printk(KERN_CRIT "ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\n",
 			       ref, ref_offset(ref), jeb->last_node, jeb->last_node?ref_offset(jeb->last_node):0);
 			BUG();
@@ -1183,17 +1187,13 @@ uint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *je
 {
 	uint32_t ret;
 
-#if CONFIG_JFFS2_FS_DEBUG > 0
-	if (jeb && jeb != &c->blocks[ref->flash_offset / c->sector_size]) {
-		printk(KERN_CRIT "ref_totlen called with wrong block -- at 0x%08x instead of 0x%08x; ref 0x%08x\n",
-		       jeb->offset, c->blocks[ref->flash_offset / c->sector_size].offset, ref_offset(ref));
-		BUG();
-	}
-#endif
-
 	ret = __ref_totlen(c, jeb, ref);
+
 #ifdef TEST_TOTLEN
-	if (ret != ref->__totlen) {
+	if (unlikely(ret != ref->__totlen)) {
+		if (!jeb)
+			jeb = &c->blocks[ref->flash_offset / c->sector_size];
+
 		printk(KERN_CRIT "Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\n",
 		       ref, ref_offset(ref), ref_offset(ref)+ref->__totlen,
 		       ret, ref->__totlen);
@@ -1204,13 +1204,14 @@ uint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *je
 			printk(KERN_CRIT "No next ref. jeb->last_node is %p\n", jeb->last_node);
 
 		printk(KERN_CRIT "jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\n", jeb->wasted_size, jeb->dirty_size, jeb->used_size, jeb->free_size);
-		ret = ref->__totlen;
-		if (!jeb)
-			jeb = &c->blocks[ref->flash_offset / c->sector_size];
+
 #if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)
 		__jffs2_dbg_dump_node_refs_nolock(c, jeb);
 #endif
+
 		WARN_ON(1);
+
+		ret = ref->__totlen;
 	}
 #endif /* TEST_TOTLEN */
 	return ret;

commit 99988f7bbd16b861590dda4631c4db6cb17b5091
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed May 24 09:04:17 2006 +0100

    [JFFS2] Introduce ref_next() macro for finding next physical node
    
    Another part of the preparation for switching to an array...
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 1e6eabd730f2..0e82979c741c 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -1159,9 +1159,10 @@ static inline uint32_t __ref_totlen(struct jffs2_sb_info *c,
 				    struct jffs2_raw_node_ref *ref)
 {
 	uint32_t ref_end;
+	struct jffs2_raw_node_ref *next_ref = ref_next(ref);
 
-	if (ref->next_phys)
-		ref_end = ref_offset(ref->next_phys);
+	if (next_ref)
+		ref_end = ref_offset(next_ref);
 	else {
 		if (!jeb)
 			jeb = &c->blocks[ref->flash_offset / c->sector_size];
@@ -1196,11 +1197,11 @@ uint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *je
 		printk(KERN_CRIT "Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\n",
 		       ref, ref_offset(ref), ref_offset(ref)+ref->__totlen,
 		       ret, ref->__totlen);
-		if (ref->next_phys) {
-			printk(KERN_CRIT "next_phys %p (0x%08x-0x%08x)\n", ref->next_phys, ref_offset(ref->next_phys),
-			       ref_offset(ref->next_phys)+ref->__totlen);
+		if (ref_next(ref)) {
+			printk(KERN_CRIT "next %p (0x%08x-0x%08x)\n", ref_next(ref), ref_offset(ref_next(ref)),
+			       ref_offset(ref_next(ref))+ref->__totlen);
 		} else 
-			printk(KERN_CRIT "No next_phys. jeb->last_node is %p\n", jeb->last_node);
+			printk(KERN_CRIT "No next ref. jeb->last_node is %p\n", jeb->last_node);
 
 		printk(KERN_CRIT "jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\n", jeb->wasted_size, jeb->dirty_size, jeb->used_size, jeb->free_size);
 		ret = ref->__totlen;

commit 2f785402f39b96a077b6e62bf26164bfb8e0c980
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed May 24 02:04:45 2006 +0100

    [JFFS2] Reduce visibility of raw_node_ref to upper layers of JFFS2 code.
    
    As the first step towards eliminating the ref->next_phys member and saving
    memory by using an _array_ of struct jffs2_raw_node_ref per eraseblock,
    stop the write functions from allocating their own refs; have them just
    _reserve_ the appropriate number instead. Then jffs2_link_node_ref() can
    just fill them in.
    
    Use a linked list of pre-allocated refs in the superblock, for now. Once
    we switch to an array, it'll just be a case of extending that array.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index d25d4919ca97..1e6eabd730f2 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -953,13 +953,19 @@ void jffs2_free_raw_node_refs(struct jffs2_sb_info *c)
 
 	for (i=0; i<c->nr_blocks; i++) {
 		this = c->blocks[i].first_node;
-		while(this) {
+		while (this) {
 			next = this->next_phys;
-			jffs2_free_raw_node_ref(this);
+			__jffs2_free_raw_node_ref(this);
 			this = next;
 		}
 		c->blocks[i].first_node = c->blocks[i].last_node = NULL;
 	}
+	this = c->refs;
+	while (this) {
+		next = this->next_in_ino;
+		__jffs2_free_raw_node_ref(this);
+		this = next;
+	}
 }
 
 struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)
@@ -1047,10 +1053,27 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 	}
 }
 
-void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-			 struct jffs2_raw_node_ref *ref, uint32_t len,
-			 struct jffs2_inode_cache *ic)
+struct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,
+					       struct jffs2_eraseblock *jeb,
+					       uint32_t ofs, uint32_t len,
+					       struct jffs2_inode_cache *ic)
 {
+	struct jffs2_raw_node_ref *ref;
+
+	/* These will be preallocated _very_ shortly. */
+	ref = c->refs;
+	if (!c->refs) {
+		JFFS2_WARNING("Using non-preallocated refs!\n");
+		ref = __jffs2_alloc_raw_node_ref();
+		BUG_ON(!ref);
+		WARN_ON(1);
+	} else {
+		c->refs = ref->next_in_ino;
+	}
+
+	ref->next_phys = NULL;
+	ref->flash_offset = ofs;
+
 	if (!jeb->first_node)
 		jeb->first_node = ref;
 	if (jeb->last_node) {
@@ -1093,15 +1116,15 @@ void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
 	c->free_size -= len;
 	jeb->free_size -= len;
 
-	ref->next_phys = NULL;
 #ifdef TEST_TOTLEN
 	/* Set (and test) __totlen field... for now */
 	ref->__totlen = len;
 	ref_totlen(c, jeb, ref);
 #endif
+	return ref;
 }
 
-/* No locking. Do not use on a live file system */
+/* No locking, no reservation of 'ref'. Do not use on a live file system */
 int jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
 			   uint32_t size)
 {
@@ -1121,18 +1144,10 @@ int jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb
 		jeb->dirty_size += size;
 		jeb->free_size -= size;
 	} else {
-		struct jffs2_raw_node_ref *ref;
-		ref = jffs2_alloc_raw_node_ref();
-		if (!ref)
-			return -ENOMEM;
-
-		ref->flash_offset = jeb->offset + c->sector_size - jeb->free_size;
-		ref->flash_offset |= REF_OBSOLETE;
-#ifdef TEST_TOTLEN
-		ref->__totlen = size;
-#endif
+		uint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;
+		ofs |= REF_OBSOLETE;
 
-		jffs2_link_node_ref(c, jeb, ref, size, NULL);
+		jffs2_link_node_ref(c, jeb, ofs, size, NULL);
 	}
 
 	return 0;

commit fcb7578719529898aef9edce8e409e457a1c2d15
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Mon May 22 15:23:10 2006 +0100

    [JFFS2] Extend jffs2_link_node_ref() to link into per-inode list too.
    
    Let's avoid the potential for forgetting to set ref->next_in_ino, by doing
    it within jffs2_link_node_ref() instead.
    
    This highlights the ugliness of what we're currently doing with
    xattr_datum and xattr_ref structures -- we should find a nicer way of
    dealing with that.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 7d563f938b1c..d25d4919ca97 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -1048,7 +1048,8 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 }
 
 void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
-			 struct jffs2_raw_node_ref *ref, uint32_t len)
+			 struct jffs2_raw_node_ref *ref, uint32_t len,
+			 struct jffs2_inode_cache *ic)
 {
 	if (!jeb->first_node)
 		jeb->first_node = ref;
@@ -1065,6 +1066,13 @@ void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
 	}
 	jeb->last_node = ref;
 
+	if (ic) {
+		ref->next_in_ino = ic->nodes;
+		ic->nodes = ref;
+	} else {
+		ref->next_in_ino = NULL;
+	}
+
 	switch(ref_flags(ref)) {
 	case REF_UNCHECKED:
 		c->unchecked_size += len;
@@ -1120,12 +1128,11 @@ int jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb
 
 		ref->flash_offset = jeb->offset + c->sector_size - jeb->free_size;
 		ref->flash_offset |= REF_OBSOLETE;
-		ref->next_in_ino = 0;
 #ifdef TEST_TOTLEN
 		ref->__totlen = size;
 #endif
 
-		jffs2_link_node_ref(c, jeb, ref, size);
+		jffs2_link_node_ref(c, jeb, ref, size, NULL);
 	}
 
 	return 0;

commit 3b79673cfae93d0ed63eceb058bb26aba602a278
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Mon May 22 12:15:47 2006 +0100

    [JFFS2] Fix accounting error in jffs2_link_node_ref()
    
    When filing REF_OBSOLETE nodes, we'd add their size to the global
    'dirty_size' count, but then to the eraseblock's 'used_size' count.
    That's not clever.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 9a6ced05f894..7d563f938b1c 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -1079,7 +1079,7 @@ void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
 
 	case REF_OBSOLETE:
 		c->dirty_size += len;
-		jeb->used_size += len;
+		jeb->dirty_size += len;
 		break;
 	}
 	c->free_size -= len;

commit ca89a517fa577e6f26621463d3aa4f3c3d530b1e
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sun May 21 13:29:11 2006 +0100

    [JFFS2] Finally eliminate __totlen field from struct jffs2_raw_node_ref
    
    Well, almost. We'll actually keep a 'TEST_TOTLEN' macro set for now, and keep
    doing some paranoia checks to make sure it's all working correctly. But if
    TEST_TOTLEN is unset, the size of struct jffs2_raw_node_ref drops from 16
    bytes to 12 on 32-bit machines. That's a saving of about half a megabyte of
    memory on the OLPC prototype board, with 125K or so nodes in its 512MiB of
    flash.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 00506857eabc..9a6ced05f894 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -1052,8 +1052,17 @@ void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
 {
 	if (!jeb->first_node)
 		jeb->first_node = ref;
-	if (jeb->last_node)
+	if (jeb->last_node) {
 		jeb->last_node->next_phys = ref;
+#ifdef TEST_TOTLEN
+		if (ref_offset(jeb->last_node) + jeb->last_node->__totlen != ref_offset(ref)) {
+			printk(KERN_CRIT "Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\n",
+			       ref, ref_offset(ref), ref_offset(ref)+ref->__totlen,
+			       ref_offset(jeb->last_node), ref_offset(jeb->last_node)+jeb->last_node->__totlen);
+			WARN_ON(1);
+		}
+#endif
+	}
 	jeb->last_node = ref;
 
 	switch(ref_flags(ref)) {
@@ -1076,18 +1085,110 @@ void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
 	c->free_size -= len;
 	jeb->free_size -= len;
 
-	/* Set __totlen field... for now */
-	ref->__totlen = len;
 	ref->next_phys = NULL;
+#ifdef TEST_TOTLEN
+	/* Set (and test) __totlen field... for now */
+	ref->__totlen = len;
+	ref_totlen(c, jeb, ref);
+#endif
 }
 
+/* No locking. Do not use on a live file system */
 int jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
 			   uint32_t size)
 {
-	c->dirty_size += size;
-	c->free_size -= size;
-	jeb->dirty_size += size;
-	jeb->free_size -= size;
+	if (!size)
+		return 0;
+	if (size > c->sector_size - jeb->used_size) {
+		printk(KERN_CRIT "Dirty space 0x%x larger then used_size 0x%x (wasted 0x%x)\n",
+		       size, jeb->used_size, jeb->wasted_size);
+		BUG();
+	}
+	if (jeb->last_node && ref_obsolete(jeb->last_node)) {
+#ifdef TEST_TOTLEN
+		jeb->last_node->__totlen += size;
+#endif
+		c->dirty_size += size;
+		c->free_size -= size;
+		jeb->dirty_size += size;
+		jeb->free_size -= size;
+	} else {
+		struct jffs2_raw_node_ref *ref;
+		ref = jffs2_alloc_raw_node_ref();
+		if (!ref)
+			return -ENOMEM;
+
+		ref->flash_offset = jeb->offset + c->sector_size - jeb->free_size;
+		ref->flash_offset |= REF_OBSOLETE;
+		ref->next_in_ino = 0;
+#ifdef TEST_TOTLEN
+		ref->__totlen = size;
+#endif
+
+		jffs2_link_node_ref(c, jeb, ref, size);
+	}
 
 	return 0;
 }
+
+/* Calculate totlen from surrounding nodes or eraseblock */
+static inline uint32_t __ref_totlen(struct jffs2_sb_info *c,
+				    struct jffs2_eraseblock *jeb,
+				    struct jffs2_raw_node_ref *ref)
+{
+	uint32_t ref_end;
+
+	if (ref->next_phys)
+		ref_end = ref_offset(ref->next_phys);
+	else {
+		if (!jeb)
+			jeb = &c->blocks[ref->flash_offset / c->sector_size];
+
+		/* Last node in block. Use free_space */
+		if (ref != jeb->last_node) {
+			printk(KERN_CRIT "ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\n",
+			       ref, ref_offset(ref), jeb->last_node, jeb->last_node?ref_offset(jeb->last_node):0);
+			BUG();
+		}
+		ref_end = jeb->offset + c->sector_size - jeb->free_size;
+	}
+	return ref_end - ref_offset(ref);
+}
+
+uint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
+			    struct jffs2_raw_node_ref *ref)
+{
+	uint32_t ret;
+
+#if CONFIG_JFFS2_FS_DEBUG > 0
+	if (jeb && jeb != &c->blocks[ref->flash_offset / c->sector_size]) {
+		printk(KERN_CRIT "ref_totlen called with wrong block -- at 0x%08x instead of 0x%08x; ref 0x%08x\n",
+		       jeb->offset, c->blocks[ref->flash_offset / c->sector_size].offset, ref_offset(ref));
+		BUG();
+	}
+#endif
+
+	ret = __ref_totlen(c, jeb, ref);
+#ifdef TEST_TOTLEN
+	if (ret != ref->__totlen) {
+		printk(KERN_CRIT "Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\n",
+		       ref, ref_offset(ref), ref_offset(ref)+ref->__totlen,
+		       ret, ref->__totlen);
+		if (ref->next_phys) {
+			printk(KERN_CRIT "next_phys %p (0x%08x-0x%08x)\n", ref->next_phys, ref_offset(ref->next_phys),
+			       ref_offset(ref->next_phys)+ref->__totlen);
+		} else 
+			printk(KERN_CRIT "No next_phys. jeb->last_node is %p\n", jeb->last_node);
+
+		printk(KERN_CRIT "jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\n", jeb->wasted_size, jeb->dirty_size, jeb->used_size, jeb->free_size);
+		ret = ref->__totlen;
+		if (!jeb)
+			jeb = &c->blocks[ref->flash_offset / c->sector_size];
+#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)
+		__jffs2_dbg_dump_node_refs_nolock(c, jeb);
+#endif
+		WARN_ON(1);
+	}
+#endif /* TEST_TOTLEN */
+	return ret;
+}

commit 68270995f29f1a82b3eaab01df63ea7e721e2fa6
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sun May 21 03:46:05 2006 +0100

    [JFFS2] Introduce jffs2_scan_dirty_space() function.
    
    To eliminate the __totlen field from struct jffs2_raw_node_ref, we need
    to allocate nodes for dirty space instead of just tweaking the accounting
    data. Introduce jffs2_scan_dirty_space() in preparation for that.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 1fc8aedb56fb..00506857eabc 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -1080,3 +1080,14 @@ void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
 	ref->__totlen = len;
 	ref->next_phys = NULL;
 }
+
+int jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
+			   uint32_t size)
+{
+	c->dirty_size += size;
+	c->free_size -= size;
+	jeb->dirty_size += size;
+	jeb->free_size -= size;
+
+	return 0;
+}

commit f1f9671bd8f7d2ac6a918bad806ab5bdc0daaf4e
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat May 20 19:45:26 2006 +0100

    [JFFS2] Introduce jffs2_link_node_ref() function to reduce code duplication
    
    The same sequence of code was repeated in many places, to add a new
    struct jffs2_raw_node_ref to an eraseblock and adjust the space accounting
    accordingly. Move it out-of-line.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 4973cd648ba8..1fc8aedb56fb 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -1046,3 +1046,37 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 		cond_resched();
 	}
 }
+
+void jffs2_link_node_ref(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,
+			 struct jffs2_raw_node_ref *ref, uint32_t len)
+{
+	if (!jeb->first_node)
+		jeb->first_node = ref;
+	if (jeb->last_node)
+		jeb->last_node->next_phys = ref;
+	jeb->last_node = ref;
+
+	switch(ref_flags(ref)) {
+	case REF_UNCHECKED:
+		c->unchecked_size += len;
+		jeb->unchecked_size += len;
+		break;
+
+	case REF_NORMAL:
+	case REF_PRISTINE:
+		c->used_size += len;
+		jeb->used_size += len;
+		break;
+
+	case REF_OBSOLETE:
+		c->dirty_size += len;
+		jeb->used_size += len;
+		break;
+	}
+	c->free_size -= len;
+	jeb->free_size -= len;
+
+	/* Set __totlen field... for now */
+	ref->__totlen = len;
+	ref->next_phys = NULL;
+}

commit 20a92fc74c5c91c7bc5693d51acc2b99aceb0465
Merge: 21b9879bf281 f6a673b3f4f9
Author: KaiGai Kohei <kaigai@ak.jp.nec.com>
Date:   Fri May 19 00:43:53 2006 +0900

    Merge git://git.infradead.org/mtd-2.6

commit 184f565210c6c8a852c53ffc070f9add61e0f331
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon May 15 13:45:58 2006 +0100

    [JFFS2] Fix printk format in some error messages.
    
    fs/jffs2/nodelist.c: In function `check_node_data':
    fs/jffs2/nodelist.c:441: warning: unsigned int format, different type arg (arg 4)
    fs/jffs2/nodelist.c:464: warning: int format, different type arg (arg 5)
    
    Modified from Andrew's original fix because while his terminal may indeed
    only have eighty columns, mine only has _TWENTYFOUR_ lines. So the
    cosmetic fluff is perfectly OK out past column 80 where it was -- the
    casual reader doesn't _care_ about anything more than the fact that it
    goes 'if (foo) JFFS2_WARNING...', and there's no point wasting a whole
    line to display the tail end of the printk which nobody actually cares
    about.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index d4d0c41490cd..7d71593d7fd3 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -438,7 +438,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 	if (c->mtd->point) {
 		err = c->mtd->point(c->mtd, ofs, len, &retlen, &buffer);
 		if (!err && retlen < tn->csize) {
-			JFFS2_WARNING("MTD point returned len too short: %u instead of %u.\n", retlen, tn->csize);
+			JFFS2_WARNING("MTD point returned len too short: %zu instead of %u.\n", retlen, tn->csize);
 			c->mtd->unpoint(c->mtd, buffer, ofs, len);
 		} else if (err)
 			JFFS2_WARNING("MTD point failed: error code %d.\n", err);
@@ -461,7 +461,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 		}
 
 		if (retlen != len) {
-			JFFS2_ERROR("short read at %#08x: %d instead of %d.\n", ofs, retlen, len);
+			JFFS2_ERROR("short read at %#08x: %zd instead of %d.\n", ofs, retlen, len);
 			err = -EIO;
 			goto free_out;
 		}

commit aa98d7cf59b5b0764d3502662053489585faf2fe
Author: KaiGai Kohei <kaigai@ak.jp.nec.com>
Date:   Sat May 13 15:09:47 2006 +0900

    [JFFS2][XATTR] XATTR support on JFFS2 (version. 5)
    
    This attached patches provide xattr support including POSIX-ACL and
    SELinux support on JFFS2 (version.5).
    
    There are some significant differences from previous version posted
    at last December.
    The biggest change is addition of EBS(Erase Block Summary) support.
    Currently, both kernel and usermode utility (sumtool) can recognize
    xattr nodes which have JFFS2_NODETYPE_XATTR/_XREF nodetype.
    
    In addition, some bugs are fixed.
    - A potential race condition was fixed.
    - Unexpected fail when updating a xattr by same name/value pair was fixed.
    - A bug when removing xattr name/value pair was fixed.
    
    The fundamental structures (such as using two new nodetypes and exclusion
    mechanism by rwsem) are unchanged. But most of implementation were reviewed
    and updated if necessary.
    Espacially, we had to change several internal implementations related to
    load_xattr_datum() to avoid a potential race condition.
    
    [1/2] xattr_on_jffs2.kernel.version-5.patch
    [2/2] xattr_on_jffs2.utils.version-5.patch
    
    Signed-off-by: KaiGai Kohei <kaigai@ak.jp.nec.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index d4d0c41490cd..9c575733659b 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -938,6 +938,7 @@ void jffs2_free_ino_caches(struct jffs2_sb_info *c)
 		this = c->inocache_list[i];
 		while (this) {
 			next = this->next;
+			jffs2_xattr_free_inode(c, this);
 			jffs2_free_inode_cache(this);
 			this = next;
 		}

commit 0ef675d491bd65028fa838015ebc6ce8abefab6f
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Mar 9 17:33:38 2006 -0800

    [PATCH] mtd: 64 bit fixes
    
    Fix some bugs in mtd/jffs2 on 64bit platform.
    
    The MEMGETBADBLOCK/MEMSETBADBLOCK ioctl are not listed in compat_ioctl.h.
    
    And some variables in jffs2 are declared as uint32_t but used to hold
    size_t values.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index b635e167a3fa..d4d0c41490cd 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -406,7 +406,8 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 	int err = 0, pointed = 0;
 	struct jffs2_eraseblock *jeb;
 	unsigned char *buffer;
-	uint32_t crc, ofs, retlen, len;
+	uint32_t crc, ofs, len;
+	size_t retlen;
 
 	BUG_ON(tn->csize == 0);
 

commit 858119e159384308a5dde67776691a2ebf70df0f
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Sat Jan 14 13:20:43 2006 -0800

    [PATCH] Unlinline a bunch of other functions
    
    Remove the "inline" keyword from a bunch of big functions in the kernel with
    the goal of shrinking it by 30kb to 40kb
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index c79eebb8ab32..b635e167a3fa 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -134,7 +134,7 @@ static void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_
 /*
  * Allocate and initializes a new fragment.
  */
-static inline struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)
+static struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)
 {
 	struct jffs2_node_frag *newfrag;
 
@@ -513,7 +513,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
  *
  * Checks the node if we are in the checking stage.
  */
-static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn)
+static int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn)
 {
 	int ret;
 

commit 182ec4eee397543101a6db8906ed88727d3f7e53
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:16:07 2005 +0000

    [JFFS2] Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 80fe8feffb4d..c79eebb8ab32 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.114 2005/09/21 13:28:35 dedekind Exp $
+ * $Id: nodelist.c,v 1.115 2005/11/07 11:14:40 gleixner Exp $
  *
  */
 
@@ -24,7 +24,7 @@
 void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)
 {
 	struct jffs2_full_dirent **prev = list;
-	
+
 	dbg_dentlist("add dirent \"%s\", ino #%u\n", new->name, new->ino);
 
 	while ((*prev) && (*prev)->nhash <= new->nhash) {
@@ -75,14 +75,14 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 	if (size == 0)
 		return;
 
-	/* 
+	/*
 	 * If the last fragment starts at the RAM page boundary, it is
 	 * REF_PRISTINE irrespective of its size.
 	 */
 	frag = frag_last(list);
 	if (frag->node && (frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {
 		dbg_fragtree2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",
-			frag->ofs, frag->ofs + frag->size); 
+			frag->ofs, frag->ofs + frag->size);
 		frag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;
 	}
 }
@@ -102,7 +102,7 @@ void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *t
 				ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);
 			mark_ref_normal(this->node->raw);
 		}
-		
+
 	}
 	jffs2_free_node_frag(this);
 }
@@ -117,7 +117,7 @@ static void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_
 	while (*link) {
 		parent = *link;
 		base = rb_entry(parent, struct jffs2_node_frag, rb);
-	
+
 		if (newfrag->ofs > base->ofs)
 			link = &base->rb.rb_right;
 		else if (newfrag->ofs < base->ofs)
@@ -137,7 +137,7 @@ static void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_
 static inline struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)
 {
 	struct jffs2_node_frag *newfrag;
-	
+
 	newfrag = jffs2_alloc_node_frag();
 	if (likely(newfrag)) {
 		newfrag->ofs = ofs;
@@ -169,7 +169,7 @@ static int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,
 		}
 
 		if (this) {
-			/* By definition, the 'this' node has no right-hand child, 
+			/* By definition, the 'this' node has no right-hand child,
 			   because there are no frags with offset greater than it.
 			   So that's where we want to put the hole */
 			dbg_fragtree2("add hole frag %#04x-%#04x on the right of the new frag.\n",
@@ -183,13 +183,13 @@ static int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,
 		rb_insert_color(&holefrag->rb, root);
 		this = holefrag;
 	}
-	
+
 	if (this) {
-		/* By definition, the 'this' node has no right-hand child, 
+		/* By definition, the 'this' node has no right-hand child,
 		   because there are no frags with offset greater than it.
 		   So that's where we want to put new fragment */
 		dbg_fragtree2("add the new node at the right\n");
-		rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
+		rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);
 	} else {
 		dbg_fragtree2("insert the new node at the root of the tree\n");
 		rb_link_node(&newfrag->rb, NULL, &root->rb_node);
@@ -216,7 +216,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 		dbg_fragtree2("lookup gave no frag\n");
 		lastend = 0;
 	}
-			  
+
 	/* See if we ran off the end of the fragtree */
 	if (lastend <= newfrag->ofs) {
 		/* We did */
@@ -243,7 +243,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 		this->ofs, this->ofs + this->size);
 
 	/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,
-	 * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs  
+	 * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs
 	 */
 	if (newfrag->ofs > this->ofs) {
 		/* This node isn't completely obsoleted. The start of it remains valid */
@@ -261,10 +261,10 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 			if (this->node)
 				dbg_fragtree2("split old frag 0x%04x-0x%04x, phys 0x%08x\n",
 					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
-			else 
+			else
 				dbg_fragtree2("split old hole frag 0x%04x-0x%04x\n",
 					this->ofs, this->ofs+this->size);
-			
+
 			/* New second frag pointing to this's node */
 			newfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,
 						this->ofs + this->size - newfrag->ofs - newfrag->size);
@@ -284,10 +284,10 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 			   from newfrag to insert newfrag2. */
 			jffs2_fragtree_insert(newfrag, this);
 			rb_insert_color(&newfrag->rb, root);
-			
+
 			jffs2_fragtree_insert(newfrag2, newfrag);
 			rb_insert_color(&newfrag2->rb, root);
-			
+
 			return 0;
 		}
 		/* New node just reduces 'this' frag in size, doesn't split it */
@@ -297,13 +297,13 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 		jffs2_fragtree_insert(newfrag, this);
 		rb_insert_color(&newfrag->rb, root);
 	} else {
-		/* New frag starts at the same point as 'this' used to. Replace 
+		/* New frag starts at the same point as 'this' used to. Replace
 		   it in the tree without doing a delete and insertion */
 		dbg_fragtree2("inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",
 			  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);
-	
+
 		rb_replace_node(&this->rb, &newfrag->rb, root);
-		
+
 		if (newfrag->ofs + newfrag->size >= this->ofs+this->size) {
 			dbg_fragtree2("obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size);
 			jffs2_obsolete_node_frag(c, this);
@@ -317,7 +317,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 		}
 	}
 	/* OK, now we have newfrag added in the correct place in the tree, but
-	   frag_next(newfrag) may be a fragment which is overlapped by it 
+	   frag_next(newfrag) may be a fragment which is overlapped by it
 	*/
 	while ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {
 		/* 'this' frag is obsoleted completely. */
@@ -326,7 +326,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 		rb_erase(&this->rb, root);
 		jffs2_obsolete_node_frag(c, this);
 	}
-	/* Now we're pointing at the first frag which isn't totally obsoleted by 
+	/* Now we're pointing at the first frag which isn't totally obsoleted by
 	   the new frag */
 
 	if (!this || newfrag->ofs + newfrag->size == this->ofs)
@@ -344,7 +344,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 	return 0;
 }
 
-/* 
+/*
  * Given an inode, probably with existing tree of fragments, add the new node
  * to the fragment tree.
  */
@@ -363,7 +363,7 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 
 	dbg_fragtree("adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\n",
 		  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);
-	
+
 	ret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);
 	if (unlikely(ret))
 		return ret;
@@ -374,14 +374,14 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 		struct jffs2_node_frag *prev = frag_prev(newfrag);
 
 		mark_ref_normal(fn->raw);
-		/* If we don't start at zero there's _always_ a previous */	
+		/* If we don't start at zero there's _always_ a previous */
 		if (prev->node)
 			mark_ref_normal(prev->node->raw);
 	}
 
 	if ((newfrag->ofs+newfrag->size) & (PAGE_CACHE_SIZE-1)) {
 		struct jffs2_node_frag *next = frag_next(newfrag);
-		
+
 		if (next) {
 			mark_ref_normal(fn->raw);
 			if (next->node)
@@ -412,7 +412,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 
 	if (!jffs2_is_writebuffered(c))
 		goto adj_acc;
-	
+
 	/* Calculate how many bytes were already checked */
 	ofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);
 	len = ofs % c->wbuf_pagesize;
@@ -424,13 +424,13 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 			ref_offset(ref), tn->csize, ofs);
 		goto adj_acc;
 	}
-	
+
 	ofs += len;
 	len = tn->csize - len;
-	
+
 	dbg_readinode("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",
 		ref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);
-	
+
 #ifndef __ECOS
 	/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),
 	 * adding and jffs2_flash_read_end() interface. */
@@ -445,12 +445,12 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 			pointed = 1; /* succefully pointed to device */
 	}
 #endif
-	
+
 	if (!pointed) {
 		buffer = kmalloc(len, GFP_KERNEL);
 		if (unlikely(!buffer))
 			return -ENOMEM;
-			
+
 		/* TODO: this is very frequent pattern, make it a separate
 		 * routine */
 		err = jffs2_flash_read(c, ofs, len, &retlen, buffer);
@@ -458,7 +458,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 			JFFS2_ERROR("can not read %d bytes from 0x%08x, error code: %d.\n", len, ofs, err);
 			goto free_out;
 		}
-			
+
 		if (retlen != len) {
 			JFFS2_ERROR("short read at %#08x: %d instead of %d.\n", ofs, retlen, len);
 			err = -EIO;
@@ -485,7 +485,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 	jeb = &c->blocks[ref->flash_offset / c->sector_size];
 	len = ref_totlen(c, jeb, ref);
 
-	/* 
+	/*
 	 * Mark the node as having been checked and fix the
 	 * accounting accordingly.
 	 */
@@ -516,13 +516,13 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn)
 {
 	int ret;
-	
+
 	BUG_ON(ref_obsolete(tn->fn->raw));
 
 	/* We only check the data CRC of unchecked nodes */
 	if (ref_flags(tn->fn->raw) != REF_UNCHECKED)
 		return 0;
-	
+
 	dbg_fragtree2("check node %#04x-%#04x, phys offs %#08x.\n",
 		tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));
 
@@ -538,7 +538,7 @@ static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f
 	return ret;
 }
 
-/* 
+/*
  * Helper function for jffs2_add_older_frag_to_fragtree().
  *
  * Called when the new fragment that is being inserted
@@ -551,31 +551,31 @@ static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
 		newfrag->ofs, newfrag->ofs + newfrag->size, hole->ofs, hole->ofs + hole->size);
 
 	if (hole->ofs == newfrag->ofs) {
-		/* 
+		/*
 		 * Well, the new fragment actually starts at the same offset as
 		 * the hole.
 		 */
 		if (hole->ofs + hole->size > newfrag->ofs + newfrag->size) {
-			/* 
+			/*
 			 * We replace the overlapped left part of the hole by
 			 * the new node.
 			 */
-			
+
 			dbg_fragtree2("insert fragment %#04x-%#04x and cut the left part of the hole\n",
 				newfrag->ofs, newfrag->ofs + newfrag->size);
 			rb_replace_node(&hole->rb, &newfrag->rb, root);
-			
+
 			hole->ofs += newfrag->size;
 			hole->size -= newfrag->size;
-			
-			/* 
+
+			/*
 			 * We know that 'hole' should be the right hand
 			 * fragment.
 			 */
 			jffs2_fragtree_insert(hole, newfrag);
 			rb_insert_color(&hole->rb, root);
 		} else {
-			/* 
+			/*
 			 * Ah, the new fragment is of the same size as the hole.
 			 * Relace the hole by it.
 			 */
@@ -586,7 +586,7 @@ static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
 		}
 	} else {
 		/* The new fragment lefts some hole space at the left */
-		
+
 		struct jffs2_node_frag * newfrag2 = NULL;
 
 		if (hole->ofs + hole->size > newfrag->ofs + newfrag->size) {
@@ -606,7 +606,7 @@ static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
 
 		jffs2_fragtree_insert(newfrag, hole);
 		rb_insert_color(&newfrag->rb, root);
-		
+
 		if (newfrag2) {
 			dbg_fragtree2("left the hole %#04x-%#04x at the right\n",
 				newfrag2->ofs, newfrag2->ofs + newfrag2->size);
@@ -654,18 +654,18 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 		lastend = this->ofs + this->size;
 	else
 		lastend = 0;
-	
+
 	/* Detect the preliminary type of node */
 	if (fn->size >= PAGE_CACHE_SIZE)
 		ref_flag = REF_PRISTINE;
 	else
 		ref_flag = REF_NORMAL;
-	
+
 	/* See if we ran off the end of the root */
 	if (lastend <= fn_ofs) {
 		/* We did */
-		
-		/* 
+
+		/*
 		 * We are going to insert the new node into the
 		 * fragment tree, so check it.
 		 */
@@ -691,21 +691,21 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 	fn->frags = 0;
 
 	while (1) {
-		/* 
+		/*
 		 * Here we have:
 		 * fn_ofs < this->ofs + this->size && fn_ofs >= this->ofs.
-		 * 
+		 *
 		 * Remember, 'this' has higher version, any non-hole node
 		 * which is already in the fragtree is newer then the newly
 		 * inserted.
 		 */
 		if (!this->node) {
-			/* 
+			/*
 			 * 'this' is the hole fragment, so at least the
 			 * beginning of the new fragment is valid.
 			 */
-			
-			/* 
+
+			/*
 			 * We are going to insert the new node into the
 			 * fragment tree, so check it.
 			 */
@@ -715,7 +715,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 					return err;
 				checked = 1;
 			}
-			
+
 			if (this->ofs + this->size >= fn_ofs + fn_size) {
 				/* We split the hole on two parts */
 
@@ -730,7 +730,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 				goto out_ok;
 			}
 
-			/* 
+			/*
 			 * The beginning of the new fragment is valid since it
 			 * overlaps the hole node.
 			 */
@@ -742,9 +742,9 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 					this->ofs + this->size - fn_ofs);
 			if (unlikely(!newfrag))
 				return -ENOMEM;
-			
+
 			if (fn_ofs == this->ofs) {
-				/* 
+				/*
 				 * The new node starts at the same offset as
 				 * the hole and supersieds the hole.
 				 */
@@ -754,21 +754,21 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 				rb_replace_node(&this->rb, &newfrag->rb, root);
 				jffs2_free_node_frag(this);
 			} else {
-				/* 
+				/*
 				 * The hole becomes shorter as its right part
 				 * is supersieded by the new fragment.
 				 */
 				dbg_fragtree2("reduce size of hole %#04x-%#04x to %#04x-%#04x\n",
 					this->ofs, this->ofs + this->size, this->ofs, this->ofs + this->size - newfrag->size);
-				
+
 				dbg_fragtree2("add new fragment %#04x-%#04x, refcnt %d\n", fn_ofs,
 					fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
-	
+
 				this->size -= newfrag->size;
 				jffs2_fragtree_insert(newfrag, this);
 				rb_insert_color(&newfrag->rb, root);
 			}
-			
+
 			fn_ofs += newfrag->size;
 			fn_size -= newfrag->size;
 			this = rb_entry(rb_next(&newfrag->rb),
@@ -778,7 +778,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 				this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
 		}
 
-		/* 
+		/*
 		 * 'This' node is not the hole so it obsoletes the new fragment
 		 * either fully or partially.
 		 */
@@ -791,19 +791,19 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 			goto out_ok;
 		} else {
 			struct jffs2_node_frag *new_this;
-			
+
 			/* 'This' node obsoletes the beginning of the new node */
 			dbg_fragtree2("the beginning %#04x-%#04x is obsolete\n", fn_ofs, this->ofs + this->size);
 
 			ref_flag = REF_NORMAL;
-			
+
 			fn_size -= this->ofs + this->size - fn_ofs;
 			fn_ofs = this->ofs + this->size;
 			dbg_fragtree2("now considering %#04x-%#04x\n", fn_ofs, fn_ofs + fn_size);
-			
+
 			new_this = rb_entry(rb_next(&this->rb), struct jffs2_node_frag, rb);
 			if (!new_this) {
-				/* 
+				/*
 				 * There is no next fragment. Add the rest of
 				 * the new node as the right-hand child.
 				 */
@@ -813,7 +813,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 						return err;
 					checked = 1;
 				}
-				
+
 				fn->frags += 1;
 				newfrag = new_fragment(fn, fn_ofs, fn_size);
 				if (unlikely(!newfrag))
@@ -821,7 +821,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 
 				dbg_fragtree2("there are no more fragments, insert %#04x-%#04x\n",
 					newfrag->ofs, newfrag->ofs + newfrag->size);
-				rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
+				rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);
 				rb_insert_color(&newfrag->rb, root);
 				goto out_ok;
 			} else {
@@ -862,9 +862,9 @@ void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache
 
 /* During mount, this needs no locking. During normal operation, its
    callers want to do other stuff while still holding the inocache_lock.
-   Rather than introducing special case get_ino_cache functions or 
+   Rather than introducing special case get_ino_cache functions or
    callbacks, we just let the caller do the locking itself. */
-   
+
 struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)
 {
 	struct jffs2_inode_cache *ret;
@@ -873,7 +873,7 @@ struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t
 	while (ret && ret->ino < ino) {
 		ret = ret->next;
 	}
-	
+
 	if (ret && ret->ino != ino)
 		ret = NULL;
 
@@ -907,9 +907,9 @@ void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
 
 	dbg_inocache("del %p (ino #%u)\n", old, old->ino);
 	spin_lock(&c->inocache_lock);
-	
+
 	prev = &c->inocache_list[old->ino % INOCACHE_HASHSIZE];
-	
+
 	while ((*prev) && (*prev)->ino < old->ino) {
 		prev = &(*prev)->next;
 	}
@@ -919,7 +919,7 @@ void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
 
 	/* Free it now unless it's in READING or CLEARING state, which
 	   are the transitions upon read_inode() and clear_inode(). The
-	   rest of the time we know nobody else is looking at it, and 
+	   rest of the time we know nobody else is looking at it, and
 	   if it's held by read_inode() or clear_inode() they'll free it
 	   for themselves. */
 	if (old->state != INO_STATE_READING && old->state != INO_STATE_CLEARING)
@@ -932,7 +932,7 @@ void jffs2_free_ino_caches(struct jffs2_sb_info *c)
 {
 	int i;
 	struct jffs2_inode_cache *this, *next;
-	
+
 	for (i=0; i<INOCACHE_HASHSIZE; i++) {
 		this = c->inocache_list[i];
 		while (this) {
@@ -959,10 +959,10 @@ void jffs2_free_raw_node_refs(struct jffs2_sb_info *c)
 		c->blocks[i].first_node = c->blocks[i].last_node = NULL;
 	}
 }
-	
+
 struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)
 {
-	/* The common case in lookup is that there will be a node 
+	/* The common case in lookup is that there will be a node
 	   which precisely matches. So we go looking for that first */
 	struct rb_node *next;
 	struct jffs2_node_frag *prev = NULL;
@@ -993,9 +993,9 @@ struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_
 	if (prev)
 		dbg_fragtree2("no match. Returning frag %#04x-%#04x, closest previous\n",
 			  prev->ofs, prev->ofs+prev->size);
-	else 
+	else
 		dbg_fragtree2("returning NULL, empty fragtree\n");
-	
+
 	return prev;
 }
 
@@ -1010,7 +1010,7 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 		return;
 
 	dbg_fragtree("killing\n");
-	
+
 	frag = (rb_entry(root->rb_node, struct jffs2_node_frag, rb));
 	while(frag) {
 		if (frag->rb.rb_left) {
@@ -1023,18 +1023,18 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 		}
 
 		if (frag->node && !(--frag->node->frags)) {
-			/* Not a hole, and it's the final remaining frag 
+			/* Not a hole, and it's the final remaining frag
 			   of this node. Free the node */
 			if (c)
 				jffs2_mark_node_obsolete(c, frag->node->raw);
-			
+
 			jffs2_free_full_dnode(frag->node);
 		}
 		parent = frag_parent(frag);
 		if (parent) {
 			if (frag_left(parent) == frag)
 				parent->rb.rb_left = NULL;
-			else 
+			else
 				parent->rb.rb_right = NULL;
 		}
 

commit 733802d974e5af42acb7cd61b16c0ce6dd03b7ed
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Thu Sep 22 12:25:00 2005 +0100

    [JFFS2] Debug code simplification, update TODO
    
    Simplify the debugging code further.
    Update the TODO list
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 9abb5f4cfd75..80fe8feffb4d 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.112 2005/08/22 09:07:09 dedekind Exp $
+ * $Id: nodelist.c,v 1.114 2005/09/21 13:28:35 dedekind Exp $
  *
  */
 
@@ -25,18 +25,18 @@ void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new
 {
 	struct jffs2_full_dirent **prev = list;
 	
-	JFFS2_DBG_DENTLIST("add dirent \"%s\", ino #%u\n", new->name, new->ino);
+	dbg_dentlist("add dirent \"%s\", ino #%u\n", new->name, new->ino);
 
 	while ((*prev) && (*prev)->nhash <= new->nhash) {
 		if ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {
 			/* Duplicate. Free one */
 			if (new->version < (*prev)->version) {
-				JFFS2_DBG_DENTLIST("Eep! Marking new dirent node is obsolete, old is \"%s\", ino #%u\n",
+				dbg_dentlist("Eep! Marking new dirent node is obsolete, old is \"%s\", ino #%u\n",
 					(*prev)->name, (*prev)->ino);
 				jffs2_mark_node_obsolete(c, new->raw);
 				jffs2_free_full_dirent(new);
 			} else {
-				JFFS2_DBG_DENTLIST("marking old dirent \"%s\", ino #%u bsolete\n",
+				dbg_dentlist("marking old dirent \"%s\", ino #%u bsolete\n",
 					(*prev)->name, (*prev)->ino);
 				new->next = (*prev)->next;
 				jffs2_mark_node_obsolete(c, ((*prev)->raw));
@@ -55,7 +55,7 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 {
 	struct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);
 
-	JFFS2_DBG_FRAGTREE("truncating fragtree to 0x%08x bytes\n", size);
+	dbg_fragtree("truncating fragtree to 0x%08x bytes\n", size);
 
 	/* We know frag->ofs <= size. That's what lookup does for us */
 	if (frag && frag->ofs != size) {
@@ -81,7 +81,7 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 	 */
 	frag = frag_last(list);
 	if (frag->node && (frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {
-		JFFS2_DBG_FRAGTREE2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",
+		dbg_fragtree2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",
 			frag->ofs, frag->ofs + frag->size); 
 		frag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;
 	}
@@ -93,12 +93,12 @@ void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *t
 		this->node->frags--;
 		if (!this->node->frags) {
 			/* The node has no valid frags left. It's totally obsoleted */
-			JFFS2_DBG_FRAGTREE2("marking old node @0x%08x (0x%04x-0x%04x) obsolete\n",
+			dbg_fragtree2("marking old node @0x%08x (0x%04x-0x%04x) obsolete\n",
 				ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);
 			jffs2_mark_node_obsolete(c, this->node->raw);
 			jffs2_free_full_dnode(this->node);
 		} else {
-			JFFS2_DBG_FRAGTREE2("marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\n",
+			dbg_fragtree2("marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\n",
 				ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);
 			mark_ref_normal(this->node->raw);
 		}
@@ -112,7 +112,7 @@ static void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_
 	struct rb_node *parent = &base->rb;
 	struct rb_node **link = &parent;
 
-	JFFS2_DBG_FRAGTREE2("insert frag (0x%04x-0x%04x)\n", newfrag->ofs, newfrag->ofs + newfrag->size);
+	dbg_fragtree2("insert frag (0x%04x-0x%04x)\n", newfrag->ofs, newfrag->ofs + newfrag->size);
 
 	while (*link) {
 		parent = *link;
@@ -172,11 +172,11 @@ static int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,
 			/* By definition, the 'this' node has no right-hand child, 
 			   because there are no frags with offset greater than it.
 			   So that's where we want to put the hole */
-			JFFS2_DBG_FRAGTREE2("add hole frag %#04x-%#04x on the right of the new frag.\n",
+			dbg_fragtree2("add hole frag %#04x-%#04x on the right of the new frag.\n",
 				holefrag->ofs, holefrag->ofs + holefrag->size);
 			rb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);
 		} else {
-			JFFS2_DBG_FRAGTREE2("Add hole frag %#04x-%#04x to the root of the tree.\n",
+			dbg_fragtree2("Add hole frag %#04x-%#04x to the root of the tree.\n",
 				holefrag->ofs, holefrag->ofs + holefrag->size);
 			rb_link_node(&holefrag->rb, NULL, &root->rb_node);
 		}
@@ -188,10 +188,10 @@ static int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,
 		/* By definition, the 'this' node has no right-hand child, 
 		   because there are no frags with offset greater than it.
 		   So that's where we want to put new fragment */
-		JFFS2_DBG_FRAGTREE2("add the new node at the right\n");
+		dbg_fragtree2("add the new node at the right\n");
 		rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
 	} else {
-		JFFS2_DBG_FRAGTREE2("insert the new node at the root of the tree\n");
+		dbg_fragtree2("insert the new node at the root of the tree\n");
 		rb_link_node(&newfrag->rb, NULL, &root->rb_node);
 	}
 	rb_insert_color(&newfrag->rb, root);
@@ -209,11 +209,11 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 	this = jffs2_lookup_node_frag(root, newfrag->node->ofs);
 
 	if (this) {
-		JFFS2_DBG_FRAGTREE2("lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n",
+		dbg_fragtree2("lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n",
 			  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);
 		lastend = this->ofs + this->size;
 	} else {
-		JFFS2_DBG_FRAGTREE2("lookup gave no frag\n");
+		dbg_fragtree2("lookup gave no frag\n");
 		lastend = 0;
 	}
 			  
@@ -235,11 +235,11 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 	}
 
 	if (this->node)
-		JFFS2_DBG_FRAGTREE2("dealing with frag %u-%u, phys %#08x(%d).\n",
+		dbg_fragtree2("dealing with frag %u-%u, phys %#08x(%d).\n",
 		this->ofs, this->ofs + this->size,
 		ref_offset(this->node->raw), ref_flags(this->node->raw));
 	else
-		JFFS2_DBG_FRAGTREE2("dealing with hole frag %u-%u.\n",
+		dbg_fragtree2("dealing with hole frag %u-%u.\n",
 		this->ofs, this->ofs + this->size);
 
 	/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,
@@ -259,10 +259,10 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 			struct jffs2_node_frag *newfrag2;
 
 			if (this->node)
-				JFFS2_DBG_FRAGTREE2("split old frag 0x%04x-0x%04x, phys 0x%08x\n",
+				dbg_fragtree2("split old frag 0x%04x-0x%04x, phys 0x%08x\n",
 					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
 			else 
-				JFFS2_DBG_FRAGTREE2("split old hole frag 0x%04x-0x%04x\n",
+				dbg_fragtree2("split old hole frag 0x%04x-0x%04x\n",
 					this->ofs, this->ofs+this->size);
 			
 			/* New second frag pointing to this's node */
@@ -299,13 +299,13 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 	} else {
 		/* New frag starts at the same point as 'this' used to. Replace 
 		   it in the tree without doing a delete and insertion */
-		JFFS2_DBG_FRAGTREE2("inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",
+		dbg_fragtree2("inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",
 			  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);
 	
 		rb_replace_node(&this->rb, &newfrag->rb, root);
 		
 		if (newfrag->ofs + newfrag->size >= this->ofs+this->size) {
-			JFFS2_DBG_FRAGTREE2("obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size);
+			dbg_fragtree2("obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size);
 			jffs2_obsolete_node_frag(c, this);
 		} else {
 			this->ofs += newfrag->size;
@@ -321,7 +321,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 	*/
 	while ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {
 		/* 'this' frag is obsoleted completely. */
-		JFFS2_DBG_FRAGTREE2("obsoleting node frag %p (%x-%x) and removing from tree\n",
+		dbg_fragtree2("obsoleting node frag %p (%x-%x) and removing from tree\n",
 			this, this->ofs, this->ofs+this->size);
 		rb_erase(&this->rb, root);
 		jffs2_obsolete_node_frag(c, this);
@@ -361,7 +361,7 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 		return -ENOMEM;
 	newfrag->node->frags = 1;
 
-	JFFS2_DBG_FRAGTREE("adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\n",
+	dbg_fragtree("adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\n",
 		  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);
 	
 	ret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);
@@ -410,14 +410,17 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 
 	BUG_ON(tn->csize == 0);
 
+	if (!jffs2_is_writebuffered(c))
+		goto adj_acc;
+	
 	/* Calculate how many bytes were already checked */
 	ofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);
-	len = ofs & (c->wbuf_pagesize - 1);
+	len = ofs % c->wbuf_pagesize;
 	if (likely(len))
 		len = c->wbuf_pagesize - len;
 
 	if (len >= tn->csize) {
-		JFFS2_DBG_READINODE("no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\n",
+		dbg_readinode("no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\n",
 			ref_offset(ref), tn->csize, ofs);
 		goto adj_acc;
 	}
@@ -425,7 +428,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 	ofs += len;
 	len = tn->csize - len;
 	
-	JFFS2_DBG_READINODE("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",
+	dbg_readinode("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",
 		ref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);
 	
 #ifndef __ECOS
@@ -520,7 +523,7 @@ static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f
 	if (ref_flags(tn->fn->raw) != REF_UNCHECKED)
 		return 0;
 	
-	JFFS2_DBG_FRAGTREE2("check node %#04x-%#04x, phys offs %#08x.\n",
+	dbg_fragtree2("check node %#04x-%#04x, phys offs %#08x.\n",
 		tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));
 
 	ret = check_node_data(c, tn);
@@ -528,7 +531,7 @@ static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f
 		JFFS2_ERROR("check_node_data() returned error: %d.\n",
 			ret);
 	} else if (unlikely(ret > 0)) {
-		JFFS2_DBG_FRAGTREE2("CRC error, mark it obsolete.\n");
+		dbg_fragtree2("CRC error, mark it obsolete.\n");
 		jffs2_mark_node_obsolete(c, tn->fn->raw);
 	}
 
@@ -544,7 +547,7 @@ static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f
 static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
 		      struct jffs2_node_frag *newfrag, struct jffs2_node_frag *hole)
 {
-	JFFS2_DBG_FRAGTREE2("fragment %#04x-%#04x splits the hole %#04x-%#04x\n",
+	dbg_fragtree2("fragment %#04x-%#04x splits the hole %#04x-%#04x\n",
 		newfrag->ofs, newfrag->ofs + newfrag->size, hole->ofs, hole->ofs + hole->size);
 
 	if (hole->ofs == newfrag->ofs) {
@@ -558,7 +561,7 @@ static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
 			 * the new node.
 			 */
 			
-			JFFS2_DBG_FRAGTREE2("insert fragment %#04x-%#04x and cut the left part of the hole\n",
+			dbg_fragtree2("insert fragment %#04x-%#04x and cut the left part of the hole\n",
 				newfrag->ofs, newfrag->ofs + newfrag->size);
 			rb_replace_node(&hole->rb, &newfrag->rb, root);
 			
@@ -576,7 +579,7 @@ static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
 			 * Ah, the new fragment is of the same size as the hole.
 			 * Relace the hole by it.
 			 */
-			JFFS2_DBG_FRAGTREE2("insert fragment %#04x-%#04x and overwrite hole\n",
+			dbg_fragtree2("insert fragment %#04x-%#04x and overwrite hole\n",
 				newfrag->ofs, newfrag->ofs + newfrag->size);
 			rb_replace_node(&hole->rb, &newfrag->rb, root);
 			jffs2_free_node_frag(hole);
@@ -598,14 +601,14 @@ static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
 		}
 
 		hole->size = newfrag->ofs - hole->ofs;
-		JFFS2_DBG_FRAGTREE2("left the hole %#04x-%#04x at the left and inserd fragment %#04x-%#04x\n",
+		dbg_fragtree2("left the hole %#04x-%#04x at the left and inserd fragment %#04x-%#04x\n",
 			hole->ofs, hole->ofs + hole->size, newfrag->ofs, newfrag->ofs + newfrag->size);
 
 		jffs2_fragtree_insert(newfrag, hole);
 		rb_insert_color(&newfrag->rb, root);
 		
 		if (newfrag2) {
-			JFFS2_DBG_FRAGTREE2("left the hole %#04x-%#04x at the right\n",
+			dbg_fragtree2("left the hole %#04x-%#04x at the right\n",
 				newfrag2->ofs, newfrag2->ofs + newfrag2->size);
 			jffs2_fragtree_insert(newfrag2, newfrag);
 			rb_insert_color(&newfrag2->rb, root);
@@ -640,12 +643,12 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 	int err, checked = 0;
 	int ref_flag;
 
-	JFFS2_DBG_FRAGTREE("insert fragment %#04x-%#04x, ver %u\n", fn_ofs, fn_ofs + fn_size, tn->version);
+	dbg_fragtree("insert fragment %#04x-%#04x, ver %u\n", fn_ofs, fn_ofs + fn_size, tn->version);
 
 	/* Skip all the nodes which are completed before this one starts */
 	this = jffs2_lookup_node_frag(root, fn_ofs);
 	if (this)
-		JFFS2_DBG_FRAGTREE2("'this' found %#04x-%#04x (%s)\n", this->ofs, this->ofs + this->size, this->node ? "data" : "hole");
+		dbg_fragtree2("'this' found %#04x-%#04x (%s)\n", this->ofs, this->ofs + this->size, this->node ? "data" : "hole");
 
 	if (this)
 		lastend = this->ofs + this->size;
@@ -745,7 +748,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 				 * The new node starts at the same offset as
 				 * the hole and supersieds the hole.
 				 */
-				JFFS2_DBG_FRAGTREE2("add the new fragment instead of hole %#04x-%#04x, refcnt %d\n",
+				dbg_fragtree2("add the new fragment instead of hole %#04x-%#04x, refcnt %d\n",
 					fn_ofs, fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
 
 				rb_replace_node(&this->rb, &newfrag->rb, root);
@@ -755,10 +758,10 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 				 * The hole becomes shorter as its right part
 				 * is supersieded by the new fragment.
 				 */
-				JFFS2_DBG_FRAGTREE2("reduce size of hole %#04x-%#04x to %#04x-%#04x\n",
+				dbg_fragtree2("reduce size of hole %#04x-%#04x to %#04x-%#04x\n",
 					this->ofs, this->ofs + this->size, this->ofs, this->ofs + this->size - newfrag->size);
 				
-				JFFS2_DBG_FRAGTREE2("add new fragment %#04x-%#04x, refcnt %d\n", fn_ofs,
+				dbg_fragtree2("add new fragment %#04x-%#04x, refcnt %d\n", fn_ofs,
 					fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
 	
 				this->size -= newfrag->size;
@@ -771,7 +774,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 			this = rb_entry(rb_next(&newfrag->rb),
 					struct jffs2_node_frag, rb);
 
-			JFFS2_DBG_FRAGTREE2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
+			dbg_fragtree2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
 				this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
 		}
 
@@ -782,7 +785,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 		if (this->ofs + this->size >= fn_ofs + fn_size) {
 			/* The new node is obsolete, drop it */
 			if (fn->frags == 0) {
-				JFFS2_DBG_FRAGTREE2("%#04x-%#04x is obsolete, mark it obsolete\n", fn_ofs, fn_ofs + fn_size);
+				dbg_fragtree2("%#04x-%#04x is obsolete, mark it obsolete\n", fn_ofs, fn_ofs + fn_size);
 				ref_flag = REF_OBSOLETE;
 			}
 			goto out_ok;
@@ -790,13 +793,13 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 			struct jffs2_node_frag *new_this;
 			
 			/* 'This' node obsoletes the beginning of the new node */
-			JFFS2_DBG_FRAGTREE2("the beginning %#04x-%#04x is obsolete\n", fn_ofs, this->ofs + this->size);
+			dbg_fragtree2("the beginning %#04x-%#04x is obsolete\n", fn_ofs, this->ofs + this->size);
 
 			ref_flag = REF_NORMAL;
 			
 			fn_size -= this->ofs + this->size - fn_ofs;
 			fn_ofs = this->ofs + this->size;
-			JFFS2_DBG_FRAGTREE2("now considering %#04x-%#04x\n", fn_ofs, fn_ofs + fn_size);
+			dbg_fragtree2("now considering %#04x-%#04x\n", fn_ofs, fn_ofs + fn_size);
 			
 			new_this = rb_entry(rb_next(&this->rb), struct jffs2_node_frag, rb);
 			if (!new_this) {
@@ -816,14 +819,14 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 				if (unlikely(!newfrag))
 					return -ENOMEM;
 
-				JFFS2_DBG_FRAGTREE2("there are no more fragments, insert %#04x-%#04x\n",
+				dbg_fragtree2("there are no more fragments, insert %#04x-%#04x\n",
 					newfrag->ofs, newfrag->ofs + newfrag->size);
 				rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
 				rb_insert_color(&newfrag->rb, root);
 				goto out_ok;
 			} else {
 				this = new_this;
-				JFFS2_DBG_FRAGTREE2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
+				dbg_fragtree2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
 					this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
 			}
 		}
@@ -833,13 +836,13 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 	BUG_ON(fn->size < PAGE_CACHE_SIZE && ref_flag == REF_PRISTINE);
 
 	if (ref_flag == REF_OBSOLETE) {
-		JFFS2_DBG_FRAGTREE2("the node is obsolete now\n");
+		dbg_fragtree2("the node is obsolete now\n");
 		/* jffs2_mark_node_obsolete() will adjust space accounting */
 		jffs2_mark_node_obsolete(c, fn->raw);
 		return 1;
 	}
 
-	JFFS2_DBG_FRAGTREE2("the node is \"%s\" now\n", ref_flag == REF_NORMAL ? "REF_NORMAL" : "REF_PRISTINE");
+	dbg_fragtree2("the node is \"%s\" now\n", ref_flag == REF_NORMAL ? "REF_NORMAL" : "REF_PRISTINE");
 
 	/* Space accounting was adjusted at check_node_data() */
 	spin_lock(&c->erase_completion_lock);
@@ -885,7 +888,7 @@ void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new
 	if (!new->ino)
 		new->ino = ++c->highest_ino;
 
-	JFFS2_DBG_INOCACHE("add %p (ino #%u)\n", new, new->ino);
+	dbg_inocache("add %p (ino #%u)\n", new, new->ino);
 
 	prev = &c->inocache_list[new->ino % INOCACHE_HASHSIZE];
 
@@ -902,7 +905,7 @@ void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
 {
 	struct jffs2_inode_cache **prev;
 
-	JFFS2_DBG_INOCACHE("del %p (ino #%u)\n", old, old->ino);
+	dbg_inocache("del %p (ino #%u)\n", old, old->ino);
 	spin_lock(&c->inocache_lock);
 	
 	prev = &c->inocache_list[old->ino % INOCACHE_HASHSIZE];
@@ -965,7 +968,7 @@ struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_
 	struct jffs2_node_frag *prev = NULL;
 	struct jffs2_node_frag *frag = NULL;
 
-	JFFS2_DBG_FRAGTREE2("root %p, offset %d\n", fragtree, offset);
+	dbg_fragtree2("root %p, offset %d\n", fragtree, offset);
 
 	next = fragtree->rb_node;
 
@@ -988,10 +991,10 @@ struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_
 	   and return the closest smaller one */
 
 	if (prev)
-		JFFS2_DBG_FRAGTREE2("no match. Returning frag %#04x-%#04x, closest previous\n",
+		dbg_fragtree2("no match. Returning frag %#04x-%#04x, closest previous\n",
 			  prev->ofs, prev->ofs+prev->size);
 	else 
-		JFFS2_DBG_FRAGTREE2("returning NULL, empty fragtree\n");
+		dbg_fragtree2("returning NULL, empty fragtree\n");
 	
 	return prev;
 }
@@ -1006,7 +1009,7 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 	if (!root->rb_node)
 		return;
 
-	JFFS2_DBG_FRAGTREE("killing\n");
+	dbg_fragtree("killing\n");
 	
 	frag = (rb_entry(root->rb_node, struct jffs2_node_frag, rb));
 	while(frag) {

commit f0507530cbedf37515e0d803c332cdb81b34e71a
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Mon Aug 22 10:07:12 2005 +0100

    [JFFS2] Solve BUG caused by frag->node representing a hole in fragtree
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index fd21f109fbd2..9abb5f4cfd75 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.111 2005/08/17 14:57:39 dedekind Exp $
+ * $Id: nodelist.c,v 1.112 2005/08/22 09:07:09 dedekind Exp $
  *
  */
 
@@ -80,7 +80,7 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 	 * REF_PRISTINE irrespective of its size.
 	 */
 	frag = frag_last(list);
-	if ((frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {
+	if (frag->node && (frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {
 		JFFS2_DBG_FRAGTREE2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",
 			frag->ofs, frag->ofs + frag->size); 
 		frag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;

commit 280562b2104c9a0ca7efc5e716b6452a7ba820fa
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Wed Aug 17 15:57:43 2005 +0100

    [JFFS2] Calculate CRC check starting point correctly
    
    When data starts from the beginning of NAND page, 'len' must be zero, not
    c->wbuf_page.
    
    Thanks to Zoltan Sogor for reporting this problem.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 0393d27eafc7..fd21f109fbd2 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.110 2005/08/17 14:13:45 dedekind Exp $
+ * $Id: nodelist.c,v 1.111 2005/08/17 14:57:39 dedekind Exp $
  *
  */
 
@@ -413,7 +413,8 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 	/* Calculate how many bytes were already checked */
 	ofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);
 	len = ofs & (c->wbuf_pagesize - 1);
-	len = c->wbuf_pagesize - len;
+	if (likely(len))
+		len = c->wbuf_pagesize - len;
 
 	if (len >= tn->csize) {
 		JFFS2_DBG_READINODE("no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\n",

commit 8d5df40954281a8e0f788b311f9c08f96e530ffa
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Wed Aug 17 15:13:48 2005 +0100

    [JFFS2] More message formatting cleanups
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index cd366ab1f020..0393d27eafc7 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.109 2005/08/04 11:41:30 dedekind Exp $
+ * $Id: nodelist.c,v 1.110 2005/08/17 14:13:45 dedekind Exp $
  *
  */
 
@@ -263,7 +263,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *r
 					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
 			else 
 				JFFS2_DBG_FRAGTREE2("split old hole frag 0x%04x-0x%04x\n",
-					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
+					this->ofs, this->ofs+this->size);
 			
 			/* New second frag pointing to this's node */
 			newfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,

commit 45ca1b509ea156e87c99e529821fb3b548e14fe3
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Fri Aug 5 12:43:47 2005 +0100

    [JFFS2] Debug code clean up - step 7
    
    Remove more noisy debugs. Add current->pid to debug messages.
    Remove bogus includes.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index b5f73ab6553c..cd366ab1f020 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.108 2005/08/04 11:39:59 dedekind Exp $
+ * $Id: nodelist.c,v 1.109 2005/08/04 11:41:30 dedekind Exp $
  *
  */
 
@@ -1010,21 +1010,14 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 	frag = (rb_entry(root->rb_node, struct jffs2_node_frag, rb));
 	while(frag) {
 		if (frag->rb.rb_left) {
-			JFFS2_DBG_FRAGTREE2("going left from frag (%p) %#04x-%#04x\n",
-				frag, frag->ofs, frag->ofs+frag->size);
 			frag = frag_left(frag);
 			continue;
 		}
 		if (frag->rb.rb_right) {
-			JFFS2_DBG_FRAGTREE2("going right from frag (%p) %#04x-%#04x\n", 
-				  frag, frag->ofs, frag->ofs+frag->size);
 			frag = frag_right(frag);
 			continue;
 		}
 
-		JFFS2_DBG_FRAGTREE2("frag %#04x-%#04x: node %p, frags %d\n",
-			  frag->ofs, frag->ofs+frag->size, frag->node, frag->node?frag->node->frags:0);
-			
 		if (frag->node && !(--frag->node->frags)) {
 			/* Not a hole, and it's the final remaining frag 
 			   of this node. Free the node */

commit 3c09133739beff0d5ad457dfcfc85c7c350d3661
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Thu Aug 4 12:40:02 2005 +0100

    [JFFS2] Correct buggy length checks
    
    The previous changes introduced wrong length calculations.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 007d52f394dd..b5f73ab6553c 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.107 2005/08/03 09:26:46 dedekind Exp $
+ * $Id: nodelist.c,v 1.108 2005/08/04 11:39:59 dedekind Exp $
  *
  */
 
@@ -412,7 +412,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 
 	/* Calculate how many bytes were already checked */
 	ofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);
-	len = ofs - (ofs & (PAGE_CACHE_SIZE - 1));
+	len = ofs & (c->wbuf_pagesize - 1);
 	len = c->wbuf_pagesize - len;
 
 	if (len >= tn->csize) {

commit 392435081e8cc6e02bdc4fa998050abb11d331b4
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Wed Aug 3 10:26:50 2005 +0100

    [JFFS2] Debug code clean up - step 6
    
    Remove extra noisy debugs
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 390ce06ab1a7..007d52f394dd 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.104 2005/08/01 12:05:19 dedekind Exp $
+ * $Id: nodelist.c,v 1.107 2005/08/03 09:26:46 dedekind Exp $
  *
  */
 
@@ -60,7 +60,6 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 	/* We know frag->ofs <= size. That's what lookup does for us */
 	if (frag && frag->ofs != size) {
 		if (frag->ofs+frag->size > size) {
-			JFFS2_DBG_FRAGTREE2("truncating frag 0x%08x-0x%08x\n", frag->ofs, frag->ofs+frag->size);
 			frag->size = size - frag->ofs;
 		}
 		frag = frag_next(frag);
@@ -68,7 +67,6 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 	while (frag && frag->ofs >= size) {
 		struct jffs2_node_frag *next = frag_next(frag);
 
-		JFFS2_DBG_FRAGTREE("removing frag 0x%08x-0x%08x\n", frag->ofs, frag->ofs+frag->size);
 		frag_erase(frag, list);
 		jffs2_obsolete_node_frag(c, frag);
 		frag = next;
@@ -120,7 +118,6 @@ static void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_
 		parent = *link;
 		base = rb_entry(parent, struct jffs2_node_frag, rb);
 	
-		JFFS2_DBG_FRAGTREE2("considering frag at 0x%08x\n", base->ofs);
 		if (newfrag->ofs > base->ofs)
 			link = &base->rb.rb_right;
 		else if (newfrag->ofs < base->ofs)
@@ -175,11 +172,11 @@ static int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,
 			/* By definition, the 'this' node has no right-hand child, 
 			   because there are no frags with offset greater than it.
 			   So that's where we want to put the hole */
-			JFFS2_DBG_FRAGTREE2("add hole frag %u-%u on the right of the new frag.\n",
+			JFFS2_DBG_FRAGTREE2("add hole frag %#04x-%#04x on the right of the new frag.\n",
 				holefrag->ofs, holefrag->ofs + holefrag->size);
 			rb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);
 		} else {
-			JFFS2_DBG_FRAGTREE2("Add hole frag %u-%u to the root of the tree.\n",
+			JFFS2_DBG_FRAGTREE2("Add hole frag %#04x-%#04x to the root of the tree.\n",
 				holefrag->ofs, holefrag->ofs + holefrag->size);
 			rb_link_node(&holefrag->rb, NULL, &root->rb_node);
 		}
@@ -475,7 +472,7 @@ static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info
 #endif
 
 	if (crc != tn->data_crc) {
-		JFFS2_NOTICE("drong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",
+		JFFS2_NOTICE("wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",
 			ofs, tn->data_crc, crc);
 		return 1;
 	}
@@ -522,9 +519,8 @@ static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f
 	if (ref_flags(tn->fn->raw) != REF_UNCHECKED)
 		return 0;
 	
-	JFFS2_DBG_FRAGTREE2("check node %u-%u, phys offs %#08x.\n",
-		tn->fn->ofs, tn->fn->ofs + tn->fn->size,
-		ref_offset(tn->fn->raw));
+	JFFS2_DBG_FRAGTREE2("check node %#04x-%#04x, phys offs %#08x.\n",
+		tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));
 
 	ret = check_node_data(c, tn);
 	if (unlikely(ret < 0)) {
@@ -643,7 +639,7 @@ int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode
 	int err, checked = 0;
 	int ref_flag;
 
-	JFFS2_DBG_FRAGTREE("insert fragment %#04x-%#04x\n", fn_ofs, fn_ofs + fn_size);
+	JFFS2_DBG_FRAGTREE("insert fragment %#04x-%#04x, ver %u\n", fn_ofs, fn_ofs + fn_size, tn->version);
 
 	/* Skip all the nodes which are completed before this one starts */
 	this = jffs2_lookup_node_frag(root, fn_ofs);
@@ -975,22 +971,14 @@ struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_
 	while(next) {
 		frag = rb_entry(next, struct jffs2_node_frag, rb);
 
-		JFFS2_DBG_FRAGTREE2("considering frag %#04x-%#04x (%p). left %p, right %p\n",
-			  frag->ofs, frag->ofs+frag->size, frag, frag->rb.rb_left, frag->rb.rb_right);
 		if (frag->ofs + frag->size <= offset) {
-			JFFS2_DBG_FRAGTREE2("going right from frag %#04x-%#04x, before the region we care about\n",
-				  frag->ofs, frag->ofs+frag->size);
 			/* Remember the closest smaller match on the way down */
 			if (!prev || frag->ofs > prev->ofs)
 				prev = frag;
 			next = frag->rb.rb_right;
 		} else if (frag->ofs > offset) {
-			JFFS2_DBG_FRAGTREE2("going left from frag %#04x-%#04x, after the region we care about\n",
-				  frag->ofs, frag->ofs+frag->size);
 			next = frag->rb.rb_left;
 		} else {
-			JFFS2_DBG_FRAGTREE2("returning frag %#04x-%#04x, matched\n",
-				  frag->ofs, frag->ofs+frag->size);
 			return frag;
 		}
 	}

commit 1e0da3cb6cd4a909c64c870344183185bd6815b1
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Mon Aug 1 13:05:22 2005 +0100

    [JFFS2] Build fragtree in reverse order
    
    Instead of building fragtree starting from node with the smallest version
    number, start from the highest. This helps to avoid reading and checking
    obsolete nodes.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 0cf5e6f11989..390ce06ab1a7 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.103 2005/07/31 08:20:44 dedekind Exp $
+ * $Id: nodelist.c,v 1.104 2005/08/01 12:05:19 dedekind Exp $
  *
  */
 
@@ -59,7 +59,7 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 
 	/* We know frag->ofs <= size. That's what lookup does for us */
 	if (frag && frag->ofs != size) {
-		if (frag->ofs+frag->size >= size) {
+		if (frag->ofs+frag->size > size) {
 			JFFS2_DBG_FRAGTREE2("truncating frag 0x%08x-0x%08x\n", frag->ofs, frag->ofs+frag->size);
 			frag->size = size - frag->ofs;
 		}
@@ -73,6 +73,20 @@ void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint
 		jffs2_obsolete_node_frag(c, frag);
 		frag = next;
 	}
+
+	if (size == 0)
+		return;
+
+	/* 
+	 * If the last fragment starts at the RAM page boundary, it is
+	 * REF_PRISTINE irrespective of its size.
+	 */
+	frag = frag_last(list);
+	if ((frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {
+		JFFS2_DBG_FRAGTREE2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",
+			frag->ofs, frag->ofs + frag->size); 
+		frag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;
+	}
 }
 
 void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *this)
@@ -120,14 +134,82 @@ static void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_
 	rb_link_node(&newfrag->rb, &base->rb, link);
 }
 
+/*
+ * Allocate and initializes a new fragment.
+ */
+static inline struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)
+{
+	struct jffs2_node_frag *newfrag;
+	
+	newfrag = jffs2_alloc_node_frag();
+	if (likely(newfrag)) {
+		newfrag->ofs = ofs;
+		newfrag->size = size;
+		newfrag->node = fn;
+	} else {
+		JFFS2_ERROR("cannot allocate a jffs2_node_frag object\n");
+	}
+
+	return newfrag;
+}
+
+/*
+ * Called when there is no overlapping fragment exist. Inserts a hole before the new
+ * fragment and inserts the new fragment to the fragtree.
+ */
+static int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,
+		 	       struct jffs2_node_frag *newfrag,
+			       struct jffs2_node_frag *this, uint32_t lastend)
+{
+	if (lastend < newfrag->node->ofs) {
+		/* put a hole in before the new fragment */
+		struct jffs2_node_frag *holefrag;
+
+		holefrag= new_fragment(NULL, lastend, newfrag->node->ofs - lastend);
+		if (unlikely(!holefrag)) {
+			jffs2_free_node_frag(newfrag);
+			return -ENOMEM;
+		}
+
+		if (this) {
+			/* By definition, the 'this' node has no right-hand child, 
+			   because there are no frags with offset greater than it.
+			   So that's where we want to put the hole */
+			JFFS2_DBG_FRAGTREE2("add hole frag %u-%u on the right of the new frag.\n",
+				holefrag->ofs, holefrag->ofs + holefrag->size);
+			rb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);
+		} else {
+			JFFS2_DBG_FRAGTREE2("Add hole frag %u-%u to the root of the tree.\n",
+				holefrag->ofs, holefrag->ofs + holefrag->size);
+			rb_link_node(&holefrag->rb, NULL, &root->rb_node);
+		}
+		rb_insert_color(&holefrag->rb, root);
+		this = holefrag;
+	}
+	
+	if (this) {
+		/* By definition, the 'this' node has no right-hand child, 
+		   because there are no frags with offset greater than it.
+		   So that's where we want to put new fragment */
+		JFFS2_DBG_FRAGTREE2("add the new node at the right\n");
+		rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
+	} else {
+		JFFS2_DBG_FRAGTREE2("insert the new node at the root of the tree\n");
+		rb_link_node(&newfrag->rb, NULL, &root->rb_node);
+	}
+	rb_insert_color(&newfrag->rb, root);
+
+	return 0;
+}
+
 /* Doesn't set inode->i_size */
-static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *list, struct jffs2_node_frag *newfrag)
+static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *root, struct jffs2_node_frag *newfrag)
 {
 	struct jffs2_node_frag *this;
 	uint32_t lastend;
 
 	/* Skip all the nodes which are completed before this one starts */
-	this = jffs2_lookup_node_frag(list, newfrag->node->ofs);
+	this = jffs2_lookup_node_frag(root, newfrag->node->ofs);
 
 	if (this) {
 		JFFS2_DBG_FRAGTREE2("lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n",
@@ -138,7 +220,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 		lastend = 0;
 	}
 			  
-	/* See if we ran off the end of the list */
+	/* See if we ran off the end of the fragtree */
 	if (lastend <= newfrag->ofs) {
 		/* We did */
 
@@ -152,45 +234,16 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 			mark_ref_normal(newfrag->node->raw);
 		}
 
-		if (lastend < newfrag->node->ofs) {
-			/* ... and we need to put a hole in before the new node */
-			struct jffs2_node_frag *holefrag = jffs2_alloc_node_frag();
-			if (!holefrag) {
-				jffs2_free_node_frag(newfrag);
-				return -ENOMEM;
-			}
-			holefrag->ofs = lastend;
-			holefrag->size = newfrag->node->ofs - lastend;
-			holefrag->node = NULL;
-			if (this) {
-				/* By definition, the 'this' node has no right-hand child, 
-				   because there are no frags with offset greater than it.
-				   So that's where we want to put the hole */
-				JFFS2_DBG_FRAGTREE2("adding hole frag (%p) on right of node at (%p)\n", holefrag, this);
-				rb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);
-			} else {
-				JFFS2_DBG_FRAGTREE2("adding hole frag (%p) at root of tree\n", holefrag);
-				rb_link_node(&holefrag->rb, NULL, &list->rb_node);
-			}
-			rb_insert_color(&holefrag->rb, list);
-			this = holefrag;
-		}
-		if (this) {
-			/* By definition, the 'this' node has no right-hand child, 
-			   because there are no frags with offset greater than it.
-			   So that's where we want to put new fragment */
-			JFFS2_DBG_FRAGTREE2("adding new frag (%p) on right of node at (%p)\n", newfrag, this);
-			rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
-		} else {
-			JFFS2_DBG_FRAGTREE2("adding new frag (%p) at root of tree\n", newfrag);
-			rb_link_node(&newfrag->rb, NULL, &list->rb_node);
-		}
-		rb_insert_color(&newfrag->rb, list);
-		return 0;
+		return no_overlapping_node(c, root, newfrag, this, lastend);
 	}
 
-	JFFS2_DBG_FRAGTREE2("dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n", 
-		  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);
+	if (this->node)
+		JFFS2_DBG_FRAGTREE2("dealing with frag %u-%u, phys %#08x(%d).\n",
+		this->ofs, this->ofs + this->size,
+		ref_offset(this->node->raw), ref_flags(this->node->raw));
+	else
+		JFFS2_DBG_FRAGTREE2("dealing with hole frag %u-%u.\n",
+		this->ofs, this->ofs + this->size);
 
 	/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,
 	 * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs  
@@ -206,11 +259,8 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 
 		if (this->ofs + this->size > newfrag->ofs + newfrag->size) {
 			/* The new node splits 'this' frag into two */
-			struct jffs2_node_frag *newfrag2 = jffs2_alloc_node_frag();
-			if (!newfrag2) {
-				jffs2_free_node_frag(newfrag);
-				return -ENOMEM;
-			}
+			struct jffs2_node_frag *newfrag2;
+
 			if (this->node)
 				JFFS2_DBG_FRAGTREE2("split old frag 0x%04x-0x%04x, phys 0x%08x\n",
 					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
@@ -219,9 +269,10 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
 			
 			/* New second frag pointing to this's node */
-			newfrag2->ofs = newfrag->ofs + newfrag->size;
-			newfrag2->size = (this->ofs+this->size) - newfrag2->ofs;
-			newfrag2->node = this->node;
+			newfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,
+						this->ofs + this->size - newfrag->ofs - newfrag->size);
+			if (unlikely(!newfrag2))
+				return -ENOMEM;
 			if (this->node)
 				this->node->frags++;
 
@@ -235,10 +286,10 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 			   'this' to insert newfrag, and a tree insert
 			   from newfrag to insert newfrag2. */
 			jffs2_fragtree_insert(newfrag, this);
-			rb_insert_color(&newfrag->rb, list);
+			rb_insert_color(&newfrag->rb, root);
 			
 			jffs2_fragtree_insert(newfrag2, newfrag);
-			rb_insert_color(&newfrag2->rb, list);
+			rb_insert_color(&newfrag2->rb, root);
 			
 			return 0;
 		}
@@ -247,14 +298,14 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 
 		/* Again, we know it lives down here in the tree */
 		jffs2_fragtree_insert(newfrag, this);
-		rb_insert_color(&newfrag->rb, list);
+		rb_insert_color(&newfrag->rb, root);
 	} else {
 		/* New frag starts at the same point as 'this' used to. Replace 
 		   it in the tree without doing a delete and insertion */
 		JFFS2_DBG_FRAGTREE2("inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",
 			  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);
 	
-		rb_replace_node(&this->rb, &newfrag->rb, list);
+		rb_replace_node(&this->rb, &newfrag->rb, root);
 		
 		if (newfrag->ofs + newfrag->size >= this->ofs+this->size) {
 			JFFS2_DBG_FRAGTREE2("obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size);
@@ -264,7 +315,7 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 			this->size -= newfrag->size;
 
 			jffs2_fragtree_insert(this, newfrag);
-			rb_insert_color(&this->rb, list);
+			rb_insert_color(&this->rb, root);
 			return 0;
 		}
 	}
@@ -275,15 +326,15 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 		/* 'this' frag is obsoleted completely. */
 		JFFS2_DBG_FRAGTREE2("obsoleting node frag %p (%x-%x) and removing from tree\n",
 			this, this->ofs, this->ofs+this->size);
-		rb_erase(&this->rb, list);
+		rb_erase(&this->rb, root);
 		jffs2_obsolete_node_frag(c, this);
 	}
 	/* Now we're pointing at the first frag which isn't totally obsoleted by 
 	   the new frag */
 
-	if (!this || newfrag->ofs + newfrag->size == this->ofs) {
+	if (!this || newfrag->ofs + newfrag->size == this->ofs)
 		return 0;
-	}
+
 	/* Still some overlap but we don't need to move it in the tree */
 	this->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);
 	this->ofs = newfrag->ofs + newfrag->size;
@@ -296,8 +347,9 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 	return 0;
 }
 
-/* Given an inode, probably with existing list of fragments, add the new node
- * to the fragment list.
+/* 
+ * Given an inode, probably with existing tree of fragments, add the new node
+ * to the fragment tree.
  */
 int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)
 {
@@ -307,18 +359,14 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 	if (unlikely(!fn->size))
 		return 0;
 
-	newfrag = jffs2_alloc_node_frag();
+	newfrag = new_fragment(fn, fn->ofs, fn->size);
 	if (unlikely(!newfrag))
 		return -ENOMEM;
+	newfrag->node->frags = 1;
 
 	JFFS2_DBG_FRAGTREE("adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\n",
 		  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);
 	
-	newfrag->ofs = fn->ofs;
-	newfrag->size = fn->size;
-	newfrag->node = fn;
-	newfrag->node->frags = 1;
-
 	ret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);
 	if (unlikely(ret))
 		return ret;
@@ -344,10 +392,465 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 		}
 	}
 	jffs2_dbg_fragtree_paranoia_check_nolock(f);
-	jffs2_dbg_dump_fragtree_nolock(f);
+
+	return 0;
+}
+
+/*
+ * Check the data CRC of the node.
+ *
+ * Returns: 0 if the data CRC is correct;
+ * 	    1 - if incorrect;
+ *	    error code if an error occured.
+ */
+static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)
+{
+	struct jffs2_raw_node_ref *ref = tn->fn->raw;
+	int err = 0, pointed = 0;
+	struct jffs2_eraseblock *jeb;
+	unsigned char *buffer;
+	uint32_t crc, ofs, retlen, len;
+
+	BUG_ON(tn->csize == 0);
+
+	/* Calculate how many bytes were already checked */
+	ofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);
+	len = ofs - (ofs & (PAGE_CACHE_SIZE - 1));
+	len = c->wbuf_pagesize - len;
+
+	if (len >= tn->csize) {
+		JFFS2_DBG_READINODE("no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\n",
+			ref_offset(ref), tn->csize, ofs);
+		goto adj_acc;
+	}
+	
+	ofs += len;
+	len = tn->csize - len;
+	
+	JFFS2_DBG_READINODE("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",
+		ref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);
+	
+#ifndef __ECOS
+	/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),
+	 * adding and jffs2_flash_read_end() interface. */
+	if (c->mtd->point) {
+		err = c->mtd->point(c->mtd, ofs, len, &retlen, &buffer);
+		if (!err && retlen < tn->csize) {
+			JFFS2_WARNING("MTD point returned len too short: %u instead of %u.\n", retlen, tn->csize);
+			c->mtd->unpoint(c->mtd, buffer, ofs, len);
+		} else if (err)
+			JFFS2_WARNING("MTD point failed: error code %d.\n", err);
+		else
+			pointed = 1; /* succefully pointed to device */
+	}
+#endif
+	
+	if (!pointed) {
+		buffer = kmalloc(len, GFP_KERNEL);
+		if (unlikely(!buffer))
+			return -ENOMEM;
+			
+		/* TODO: this is very frequent pattern, make it a separate
+		 * routine */
+		err = jffs2_flash_read(c, ofs, len, &retlen, buffer);
+		if (err) {
+			JFFS2_ERROR("can not read %d bytes from 0x%08x, error code: %d.\n", len, ofs, err);
+			goto free_out;
+		}
+			
+		if (retlen != len) {
+			JFFS2_ERROR("short read at %#08x: %d instead of %d.\n", ofs, retlen, len);
+			err = -EIO;
+			goto free_out;
+		}
+	}
+
+	/* Continue calculating CRC */
+	crc = crc32(tn->partial_crc, buffer, len);
+	if(!pointed)
+		kfree(buffer);
+#ifndef __ECOS
+	else
+		c->mtd->unpoint(c->mtd, buffer, ofs, len);
+#endif
+
+	if (crc != tn->data_crc) {
+		JFFS2_NOTICE("drong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",
+			ofs, tn->data_crc, crc);
+		return 1;
+	}
+
+adj_acc:
+	jeb = &c->blocks[ref->flash_offset / c->sector_size];
+	len = ref_totlen(c, jeb, ref);
+
+	/* 
+	 * Mark the node as having been checked and fix the
+	 * accounting accordingly.
+	 */
+	spin_lock(&c->erase_completion_lock);
+	jeb->used_size += len;
+	jeb->unchecked_size -= len;
+	c->used_size += len;
+	c->unchecked_size -= len;
+	spin_unlock(&c->erase_completion_lock);
+
 	return 0;
+
+free_out:
+	if(!pointed)
+		kfree(buffer);
+#ifndef __ECOS
+	else
+		c->mtd->unpoint(c->mtd, buffer, ofs, len);
+#endif
+	return err;
 }
 
+/*
+ * Helper function for jffs2_add_older_frag_to_fragtree().
+ *
+ * Checks the node if we are in the checking stage.
+ */
+static inline int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn)
+{
+	int ret;
+	
+	BUG_ON(ref_obsolete(tn->fn->raw));
+
+	/* We only check the data CRC of unchecked nodes */
+	if (ref_flags(tn->fn->raw) != REF_UNCHECKED)
+		return 0;
+	
+	JFFS2_DBG_FRAGTREE2("check node %u-%u, phys offs %#08x.\n",
+		tn->fn->ofs, tn->fn->ofs + tn->fn->size,
+		ref_offset(tn->fn->raw));
+
+	ret = check_node_data(c, tn);
+	if (unlikely(ret < 0)) {
+		JFFS2_ERROR("check_node_data() returned error: %d.\n",
+			ret);
+	} else if (unlikely(ret > 0)) {
+		JFFS2_DBG_FRAGTREE2("CRC error, mark it obsolete.\n");
+		jffs2_mark_node_obsolete(c, tn->fn->raw);
+	}
+
+	return ret;
+}
+
+/* 
+ * Helper function for jffs2_add_older_frag_to_fragtree().
+ *
+ * Called when the new fragment that is being inserted
+ * splits a hole fragment.
+ */
+static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
+		      struct jffs2_node_frag *newfrag, struct jffs2_node_frag *hole)
+{
+	JFFS2_DBG_FRAGTREE2("fragment %#04x-%#04x splits the hole %#04x-%#04x\n",
+		newfrag->ofs, newfrag->ofs + newfrag->size, hole->ofs, hole->ofs + hole->size);
+
+	if (hole->ofs == newfrag->ofs) {
+		/* 
+		 * Well, the new fragment actually starts at the same offset as
+		 * the hole.
+		 */
+		if (hole->ofs + hole->size > newfrag->ofs + newfrag->size) {
+			/* 
+			 * We replace the overlapped left part of the hole by
+			 * the new node.
+			 */
+			
+			JFFS2_DBG_FRAGTREE2("insert fragment %#04x-%#04x and cut the left part of the hole\n",
+				newfrag->ofs, newfrag->ofs + newfrag->size);
+			rb_replace_node(&hole->rb, &newfrag->rb, root);
+			
+			hole->ofs += newfrag->size;
+			hole->size -= newfrag->size;
+			
+			/* 
+			 * We know that 'hole' should be the right hand
+			 * fragment.
+			 */
+			jffs2_fragtree_insert(hole, newfrag);
+			rb_insert_color(&hole->rb, root);
+		} else {
+			/* 
+			 * Ah, the new fragment is of the same size as the hole.
+			 * Relace the hole by it.
+			 */
+			JFFS2_DBG_FRAGTREE2("insert fragment %#04x-%#04x and overwrite hole\n",
+				newfrag->ofs, newfrag->ofs + newfrag->size);
+			rb_replace_node(&hole->rb, &newfrag->rb, root);
+			jffs2_free_node_frag(hole);
+		}
+	} else {
+		/* The new fragment lefts some hole space at the left */
+		
+		struct jffs2_node_frag * newfrag2 = NULL;
+
+		if (hole->ofs + hole->size > newfrag->ofs + newfrag->size) {
+			/* The new frag also lefts some space at the right */
+			newfrag2 = new_fragment(NULL, newfrag->ofs +
+				newfrag->size, hole->ofs + hole->size
+				- newfrag->ofs - newfrag->size);
+			if (unlikely(!newfrag2)) {
+				jffs2_free_node_frag(newfrag);
+				return -ENOMEM;
+			}
+		}
+
+		hole->size = newfrag->ofs - hole->ofs;
+		JFFS2_DBG_FRAGTREE2("left the hole %#04x-%#04x at the left and inserd fragment %#04x-%#04x\n",
+			hole->ofs, hole->ofs + hole->size, newfrag->ofs, newfrag->ofs + newfrag->size);
+
+		jffs2_fragtree_insert(newfrag, hole);
+		rb_insert_color(&newfrag->rb, root);
+		
+		if (newfrag2) {
+			JFFS2_DBG_FRAGTREE2("left the hole %#04x-%#04x at the right\n",
+				newfrag2->ofs, newfrag2->ofs + newfrag2->size);
+			jffs2_fragtree_insert(newfrag2, newfrag);
+			rb_insert_color(&newfrag2->rb, root);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * This function is used when we build inode. It expects the nodes are passed
+ * in the decreasing version order. The whole point of this is to improve the
+ * inodes checking on NAND: we check the nodes' data CRC only when they are not
+ * obsoleted. Previously, add_frag_to_fragtree() function was used and
+ * nodes were passed to it in the increasing version ordes and CRCs of all
+ * nodes were checked.
+ *
+ * Note: tn->fn->size shouldn't be zero.
+ *
+ * Returns 0 if the node was inserted
+ *         1 if it wasn't inserted (since it is obsolete)
+ *         < 0 an if error occured
+ */
+int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
+				     struct jffs2_tmp_dnode_info *tn)
+{
+	struct jffs2_node_frag *this, *newfrag;
+	uint32_t lastend;
+	struct jffs2_full_dnode *fn = tn->fn;
+	struct rb_root *root = &f->fragtree;
+	uint32_t fn_size = fn->size, fn_ofs = fn->ofs;
+	int err, checked = 0;
+	int ref_flag;
+
+	JFFS2_DBG_FRAGTREE("insert fragment %#04x-%#04x\n", fn_ofs, fn_ofs + fn_size);
+
+	/* Skip all the nodes which are completed before this one starts */
+	this = jffs2_lookup_node_frag(root, fn_ofs);
+	if (this)
+		JFFS2_DBG_FRAGTREE2("'this' found %#04x-%#04x (%s)\n", this->ofs, this->ofs + this->size, this->node ? "data" : "hole");
+
+	if (this)
+		lastend = this->ofs + this->size;
+	else
+		lastend = 0;
+	
+	/* Detect the preliminary type of node */
+	if (fn->size >= PAGE_CACHE_SIZE)
+		ref_flag = REF_PRISTINE;
+	else
+		ref_flag = REF_NORMAL;
+	
+	/* See if we ran off the end of the root */
+	if (lastend <= fn_ofs) {
+		/* We did */
+		
+		/* 
+		 * We are going to insert the new node into the
+		 * fragment tree, so check it.
+		 */
+		err = check_node(c, f, tn);
+		if (err != 0)
+			return err;
+
+		fn->frags = 1;
+
+		newfrag = new_fragment(fn, fn_ofs, fn_size);
+		if (unlikely(!newfrag))
+			return -ENOMEM;
+
+		err = no_overlapping_node(c, root, newfrag, this, lastend);
+		if (unlikely(err != 0)) {
+			jffs2_free_node_frag(newfrag);
+			return err;
+		}
+
+		goto out_ok;
+	}
+
+	fn->frags = 0;
+
+	while (1) {
+		/* 
+		 * Here we have:
+		 * fn_ofs < this->ofs + this->size && fn_ofs >= this->ofs.
+		 * 
+		 * Remember, 'this' has higher version, any non-hole node
+		 * which is already in the fragtree is newer then the newly
+		 * inserted.
+		 */
+		if (!this->node) {
+			/* 
+			 * 'this' is the hole fragment, so at least the
+			 * beginning of the new fragment is valid.
+			 */
+			
+			/* 
+			 * We are going to insert the new node into the
+			 * fragment tree, so check it.
+			 */
+			if (!checked) {
+				err = check_node(c, f, tn);
+				if (unlikely(err != 0))
+					return err;
+				checked = 1;
+			}
+			
+			if (this->ofs + this->size >= fn_ofs + fn_size) {
+				/* We split the hole on two parts */
+
+				fn->frags += 1;
+				newfrag = new_fragment(fn, fn_ofs, fn_size);
+				if (unlikely(!newfrag))
+					return -ENOMEM;
+
+				err = split_hole(c, root, newfrag, this);
+				if (unlikely(err))
+					return err;
+				goto out_ok;
+			}
+
+			/* 
+			 * The beginning of the new fragment is valid since it
+			 * overlaps the hole node.
+			 */
+
+			ref_flag = REF_NORMAL;
+
+			fn->frags += 1;
+			newfrag = new_fragment(fn, fn_ofs,
+					this->ofs + this->size - fn_ofs);
+			if (unlikely(!newfrag))
+				return -ENOMEM;
+			
+			if (fn_ofs == this->ofs) {
+				/* 
+				 * The new node starts at the same offset as
+				 * the hole and supersieds the hole.
+				 */
+				JFFS2_DBG_FRAGTREE2("add the new fragment instead of hole %#04x-%#04x, refcnt %d\n",
+					fn_ofs, fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
+
+				rb_replace_node(&this->rb, &newfrag->rb, root);
+				jffs2_free_node_frag(this);
+			} else {
+				/* 
+				 * The hole becomes shorter as its right part
+				 * is supersieded by the new fragment.
+				 */
+				JFFS2_DBG_FRAGTREE2("reduce size of hole %#04x-%#04x to %#04x-%#04x\n",
+					this->ofs, this->ofs + this->size, this->ofs, this->ofs + this->size - newfrag->size);
+				
+				JFFS2_DBG_FRAGTREE2("add new fragment %#04x-%#04x, refcnt %d\n", fn_ofs,
+					fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
+	
+				this->size -= newfrag->size;
+				jffs2_fragtree_insert(newfrag, this);
+				rb_insert_color(&newfrag->rb, root);
+			}
+			
+			fn_ofs += newfrag->size;
+			fn_size -= newfrag->size;
+			this = rb_entry(rb_next(&newfrag->rb),
+					struct jffs2_node_frag, rb);
+
+			JFFS2_DBG_FRAGTREE2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
+				this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
+		}
+
+		/* 
+		 * 'This' node is not the hole so it obsoletes the new fragment
+		 * either fully or partially.
+		 */
+		if (this->ofs + this->size >= fn_ofs + fn_size) {
+			/* The new node is obsolete, drop it */
+			if (fn->frags == 0) {
+				JFFS2_DBG_FRAGTREE2("%#04x-%#04x is obsolete, mark it obsolete\n", fn_ofs, fn_ofs + fn_size);
+				ref_flag = REF_OBSOLETE;
+			}
+			goto out_ok;
+		} else {
+			struct jffs2_node_frag *new_this;
+			
+			/* 'This' node obsoletes the beginning of the new node */
+			JFFS2_DBG_FRAGTREE2("the beginning %#04x-%#04x is obsolete\n", fn_ofs, this->ofs + this->size);
+
+			ref_flag = REF_NORMAL;
+			
+			fn_size -= this->ofs + this->size - fn_ofs;
+			fn_ofs = this->ofs + this->size;
+			JFFS2_DBG_FRAGTREE2("now considering %#04x-%#04x\n", fn_ofs, fn_ofs + fn_size);
+			
+			new_this = rb_entry(rb_next(&this->rb), struct jffs2_node_frag, rb);
+			if (!new_this) {
+				/* 
+				 * There is no next fragment. Add the rest of
+				 * the new node as the right-hand child.
+				 */
+				if (!checked) {
+					err = check_node(c, f, tn);
+					if (unlikely(err != 0))
+						return err;
+					checked = 1;
+				}
+				
+				fn->frags += 1;
+				newfrag = new_fragment(fn, fn_ofs, fn_size);
+				if (unlikely(!newfrag))
+					return -ENOMEM;
+
+				JFFS2_DBG_FRAGTREE2("there are no more fragments, insert %#04x-%#04x\n",
+					newfrag->ofs, newfrag->ofs + newfrag->size);
+				rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
+				rb_insert_color(&newfrag->rb, root);
+				goto out_ok;
+			} else {
+				this = new_this;
+				JFFS2_DBG_FRAGTREE2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
+					this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
+			}
+		}
+	}
+
+out_ok:
+	BUG_ON(fn->size < PAGE_CACHE_SIZE && ref_flag == REF_PRISTINE);
+
+	if (ref_flag == REF_OBSOLETE) {
+		JFFS2_DBG_FRAGTREE2("the node is obsolete now\n");
+		/* jffs2_mark_node_obsolete() will adjust space accounting */
+		jffs2_mark_node_obsolete(c, fn->raw);
+		return 1;
+	}
+
+	JFFS2_DBG_FRAGTREE2("the node is \"%s\" now\n", ref_flag == REF_NORMAL ? "REF_NORMAL" : "REF_PRISTINE");
+
+	/* Space accounting was adjusted at check_node_data() */
+	spin_lock(&c->erase_completion_lock);
+	fn->raw->flash_offset = ref_offset(fn->raw) | ref_flag;
+	spin_unlock(&c->erase_completion_lock);
+
+	return 0;
+}
 
 void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)
 {

commit 1e900979a7e6c2abbfd1b86bffd226d2d6115f66
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Sun Jul 31 09:20:48 2005 +0100

    [JFFS2] Move another fragtree-related function to nodelist.c
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 7997f526c94b..0cf5e6f11989 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.102 2005/07/28 12:45:10 dedekind Exp $
+ * $Id: nodelist.c,v 1.103 2005/07/31 08:20:44 dedekind Exp $
  *
  */
 
@@ -51,6 +51,30 @@ void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new
 	*prev = new;
 }
 
+void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)
+{
+	struct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);
+
+	JFFS2_DBG_FRAGTREE("truncating fragtree to 0x%08x bytes\n", size);
+
+	/* We know frag->ofs <= size. That's what lookup does for us */
+	if (frag && frag->ofs != size) {
+		if (frag->ofs+frag->size >= size) {
+			JFFS2_DBG_FRAGTREE2("truncating frag 0x%08x-0x%08x\n", frag->ofs, frag->ofs+frag->size);
+			frag->size = size - frag->ofs;
+		}
+		frag = frag_next(frag);
+	}
+	while (frag && frag->ofs >= size) {
+		struct jffs2_node_frag *next = frag_next(frag);
+
+		JFFS2_DBG_FRAGTREE("removing frag 0x%08x-0x%08x\n", frag->ofs, frag->ofs+frag->size);
+		frag_erase(frag, list);
+		jffs2_obsolete_node_frag(c, frag);
+		frag = next;
+	}
+}
+
 void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *this)
 {
 	if (this->node) {

commit e0d601373b1123ea43b1fdec08d9e58a079ae35c
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Thu Jul 28 15:46:43 2005 +0100

    [JFFS2] Debug code clean up - step 5
    
    Replace the D1(printk()) style debugging with the new debug macros
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 8373d312b195..7997f526c94b 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.101 2005/07/27 14:46:11 dedekind Exp $
+ * $Id: nodelist.c,v 1.102 2005/07/28 12:45:10 dedekind Exp $
  *
  */
 
@@ -24,35 +24,31 @@
 void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)
 {
 	struct jffs2_full_dirent **prev = list;
-	D1(printk(KERN_DEBUG "jffs2_add_fd_to_list( %p, %p (->%p))\n", new, list, *list));
+	
+	JFFS2_DBG_DENTLIST("add dirent \"%s\", ino #%u\n", new->name, new->ino);
 
 	while ((*prev) && (*prev)->nhash <= new->nhash) {
 		if ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {
 			/* Duplicate. Free one */
 			if (new->version < (*prev)->version) {
-				D1(printk(KERN_DEBUG "Eep! Marking new dirent node obsolete\n"));
-				D1(printk(KERN_DEBUG "New dirent is \"%s\"->ino #%u. Old is \"%s\"->ino #%u\n", new->name, new->ino, (*prev)->name, (*prev)->ino));
+				JFFS2_DBG_DENTLIST("Eep! Marking new dirent node is obsolete, old is \"%s\", ino #%u\n",
+					(*prev)->name, (*prev)->ino);
 				jffs2_mark_node_obsolete(c, new->raw);
 				jffs2_free_full_dirent(new);
 			} else {
-				D1(printk(KERN_DEBUG "Marking old dirent node (ino #%u) obsolete\n", (*prev)->ino));
+				JFFS2_DBG_DENTLIST("marking old dirent \"%s\", ino #%u bsolete\n",
+					(*prev)->name, (*prev)->ino);
 				new->next = (*prev)->next;
 				jffs2_mark_node_obsolete(c, ((*prev)->raw));
 				jffs2_free_full_dirent(*prev);
 				*prev = new;
 			}
-			goto out;
+			return;
 		}
 		prev = &((*prev)->next);
 	}
 	new->next = *prev;
 	*prev = new;
-
- out:
-	D2(while(*list) {
-		printk(KERN_DEBUG "Dirent \"%s\" (hash 0x%08x, ino #%u\n", (*list)->name, (*list)->nhash, (*list)->ino);
-		list = &(*list)->next;
-	});
 }
 
 void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *this)
@@ -61,14 +57,13 @@ void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *t
 		this->node->frags--;
 		if (!this->node->frags) {
 			/* The node has no valid frags left. It's totally obsoleted */
-			D2(printk(KERN_DEBUG "Marking old node @0x%08x (0x%04x-0x%04x) obsolete\n",
-				  ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size));
+			JFFS2_DBG_FRAGTREE2("marking old node @0x%08x (0x%04x-0x%04x) obsolete\n",
+				ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);
 			jffs2_mark_node_obsolete(c, this->node->raw);
 			jffs2_free_full_dnode(this->node);
 		} else {
-			D2(printk(KERN_DEBUG "Marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\n",
-				  ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size,
-				  this->node->frags));
+			JFFS2_DBG_FRAGTREE2("marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\n",
+				ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);
 			mark_ref_normal(this->node->raw);
 		}
 		
@@ -81,20 +76,19 @@ static void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_
 	struct rb_node *parent = &base->rb;
 	struct rb_node **link = &parent;
 
-	D2(printk(KERN_DEBUG "jffs2_fragtree_insert(%p; %d-%d, %p)\n", newfrag, 
-		  newfrag->ofs, newfrag->ofs+newfrag->size, base));
+	JFFS2_DBG_FRAGTREE2("insert frag (0x%04x-0x%04x)\n", newfrag->ofs, newfrag->ofs + newfrag->size);
 
 	while (*link) {
 		parent = *link;
 		base = rb_entry(parent, struct jffs2_node_frag, rb);
 	
-		D2(printk(KERN_DEBUG "fragtree_insert considering frag at 0x%x\n", base->ofs));
+		JFFS2_DBG_FRAGTREE2("considering frag at 0x%08x\n", base->ofs);
 		if (newfrag->ofs > base->ofs)
 			link = &base->rb.rb_right;
 		else if (newfrag->ofs < base->ofs)
 			link = &base->rb.rb_left;
 		else {
-			printk(KERN_CRIT "Duplicate frag at %08x (%p,%p)\n", newfrag->ofs, newfrag, base);
+			JFFS2_ERROR("duplicate frag at %08x (%p,%p)\n", newfrag->ofs, newfrag, base);
 			BUG();
 		}
 	}
@@ -112,11 +106,11 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 	this = jffs2_lookup_node_frag(list, newfrag->node->ofs);
 
 	if (this) {
-		D2(printk(KERN_DEBUG "j_a_f_d_t_f: Lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n",
-			  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this));
+		JFFS2_DBG_FRAGTREE2("lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n",
+			  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);
 		lastend = this->ofs + this->size;
 	} else {
-		D2(printk(KERN_DEBUG "j_a_f_d_t_f: Lookup gave no frag\n"));
+		JFFS2_DBG_FRAGTREE2("lookup gave no frag\n");
 		lastend = 0;
 	}
 			  
@@ -148,10 +142,10 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 				/* By definition, the 'this' node has no right-hand child, 
 				   because there are no frags with offset greater than it.
 				   So that's where we want to put the hole */
-				D2(printk(KERN_DEBUG "Adding hole frag (%p) on right of node at (%p)\n", holefrag, this));
+				JFFS2_DBG_FRAGTREE2("adding hole frag (%p) on right of node at (%p)\n", holefrag, this);
 				rb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);
 			} else {
-				D2(printk(KERN_DEBUG "Adding hole frag (%p) at root of tree\n", holefrag));
+				JFFS2_DBG_FRAGTREE2("adding hole frag (%p) at root of tree\n", holefrag);
 				rb_link_node(&holefrag->rb, NULL, &list->rb_node);
 			}
 			rb_insert_color(&holefrag->rb, list);
@@ -161,18 +155,18 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 			/* By definition, the 'this' node has no right-hand child, 
 			   because there are no frags with offset greater than it.
 			   So that's where we want to put new fragment */
-			D2(printk(KERN_DEBUG "Adding new frag (%p) on right of node at (%p)\n", newfrag, this));
+			JFFS2_DBG_FRAGTREE2("adding new frag (%p) on right of node at (%p)\n", newfrag, this);
 			rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
 		} else {
-			D2(printk(KERN_DEBUG "Adding new frag (%p) at root of tree\n", newfrag));
+			JFFS2_DBG_FRAGTREE2("adding new frag (%p) at root of tree\n", newfrag);
 			rb_link_node(&newfrag->rb, NULL, &list->rb_node);
 		}
 		rb_insert_color(&newfrag->rb, list);
 		return 0;
 	}
 
-	D2(printk(KERN_DEBUG "j_a_f_d_t_f: dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n", 
-		  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this));
+	JFFS2_DBG_FRAGTREE2("dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n", 
+		  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);
 
 	/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,
 	 * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs  
@@ -193,12 +187,12 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 				jffs2_free_node_frag(newfrag);
 				return -ENOMEM;
 			}
-			D2(printk(KERN_DEBUG "split old frag 0x%04x-0x%04x -->", this->ofs, this->ofs+this->size);
 			if (this->node)
-				printk("phys 0x%08x\n", ref_offset(this->node->raw));
+				JFFS2_DBG_FRAGTREE2("split old frag 0x%04x-0x%04x, phys 0x%08x\n",
+					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
 			else 
-				printk("hole\n");
-			   )
+				JFFS2_DBG_FRAGTREE2("split old hole frag 0x%04x-0x%04x\n",
+					this->ofs, this->ofs+this->size, ref_offset(this->node->raw));
 			
 			/* New second frag pointing to this's node */
 			newfrag2->ofs = newfrag->ofs + newfrag->size;
@@ -233,14 +227,13 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 	} else {
 		/* New frag starts at the same point as 'this' used to. Replace 
 		   it in the tree without doing a delete and insertion */
-		D2(printk(KERN_DEBUG "Inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",
-			  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size,
-			  this, this->ofs, this->ofs+this->size));
+		JFFS2_DBG_FRAGTREE2("inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",
+			  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);
 	
 		rb_replace_node(&this->rb, &newfrag->rb, list);
 		
 		if (newfrag->ofs + newfrag->size >= this->ofs+this->size) {
-			D2(printk(KERN_DEBUG "Obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size));
+			JFFS2_DBG_FRAGTREE2("obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size);
 			jffs2_obsolete_node_frag(c, this);
 		} else {
 			this->ofs += newfrag->size;
@@ -256,7 +249,8 @@ static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *l
 	*/
 	while ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {
 		/* 'this' frag is obsoleted completely. */
-		D2(printk(KERN_DEBUG "Obsoleting node frag %p (%x-%x) and removing from tree\n", this, this->ofs, this->ofs+this->size));
+		JFFS2_DBG_FRAGTREE2("obsoleting node frag %p (%x-%x) and removing from tree\n",
+			this, this->ofs, this->ofs+this->size);
 		rb_erase(&this->rb, list);
 		jffs2_obsolete_node_frag(c, this);
 	}
@@ -286,8 +280,6 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 	int ret;
 	struct jffs2_node_frag *newfrag;
 
-	D1(printk(KERN_DEBUG "jffs2_add_full_dnode_to_inode(ino #%u, f %p, fn %p)\n", f->inocache->ino, f, fn));
-
 	if (unlikely(!fn->size))
 		return 0;
 
@@ -295,8 +287,8 @@ int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_in
 	if (unlikely(!newfrag))
 		return -ENOMEM;
 
-	D2(printk(KERN_DEBUG "adding node %04x-%04x @0x%08x on flash, newfrag *%p\n",
-		  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag));
+	JFFS2_DBG_FRAGTREE("adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\n",
+		  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);
 	
 	newfrag->ofs = fn->ofs;
 	newfrag->size = fn->size;
@@ -350,8 +342,6 @@ struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t
 {
 	struct jffs2_inode_cache *ret;
 
-	D2(printk(KERN_DEBUG "jffs2_get_ino_cache(): ino %u\n", ino));
-
 	ret = c->inocache_list[ino % INOCACHE_HASHSIZE];
 	while (ret && ret->ino < ino) {
 		ret = ret->next;
@@ -360,7 +350,6 @@ struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t
 	if (ret && ret->ino != ino)
 		ret = NULL;
 
-	D2(printk(KERN_DEBUG "jffs2_get_ino_cache found %p for ino %u\n", ret, ino));
 	return ret;
 }
 
@@ -372,7 +361,7 @@ void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new
 	if (!new->ino)
 		new->ino = ++c->highest_ino;
 
-	D2(printk(KERN_DEBUG "jffs2_add_ino_cache: Add %p (ino #%u)\n", new, new->ino));
+	JFFS2_DBG_INOCACHE("add %p (ino #%u)\n", new, new->ino);
 
 	prev = &c->inocache_list[new->ino % INOCACHE_HASHSIZE];
 
@@ -388,7 +377,8 @@ void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new
 void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
 {
 	struct jffs2_inode_cache **prev;
-	D1(printk(KERN_DEBUG "jffs2_del_ino_cache: Del %p (ino #%u)\n", old, old->ino));
+
+	JFFS2_DBG_INOCACHE("del %p (ino #%u)\n", old, old->ino);
 	spin_lock(&c->inocache_lock);
 	
 	prev = &c->inocache_list[old->ino % INOCACHE_HASHSIZE];
@@ -451,29 +441,29 @@ struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_
 	struct jffs2_node_frag *prev = NULL;
 	struct jffs2_node_frag *frag = NULL;
 
-	D2(printk(KERN_DEBUG "jffs2_lookup_node_frag(%p, %d)\n", fragtree, offset));
+	JFFS2_DBG_FRAGTREE2("root %p, offset %d\n", fragtree, offset);
 
 	next = fragtree->rb_node;
 
 	while(next) {
 		frag = rb_entry(next, struct jffs2_node_frag, rb);
 
-		D2(printk(KERN_DEBUG "Considering frag %d-%d (%p). left %p, right %p\n",
-			  frag->ofs, frag->ofs+frag->size, frag, frag->rb.rb_left, frag->rb.rb_right));
+		JFFS2_DBG_FRAGTREE2("considering frag %#04x-%#04x (%p). left %p, right %p\n",
+			  frag->ofs, frag->ofs+frag->size, frag, frag->rb.rb_left, frag->rb.rb_right);
 		if (frag->ofs + frag->size <= offset) {
-			D2(printk(KERN_DEBUG "Going right from frag %d-%d, before the region we care about\n",
-				  frag->ofs, frag->ofs+frag->size));
+			JFFS2_DBG_FRAGTREE2("going right from frag %#04x-%#04x, before the region we care about\n",
+				  frag->ofs, frag->ofs+frag->size);
 			/* Remember the closest smaller match on the way down */
 			if (!prev || frag->ofs > prev->ofs)
 				prev = frag;
 			next = frag->rb.rb_right;
 		} else if (frag->ofs > offset) {
-			D2(printk(KERN_DEBUG "Going left from frag %d-%d, after the region we care about\n",
-				  frag->ofs, frag->ofs+frag->size));
+			JFFS2_DBG_FRAGTREE2("going left from frag %#04x-%#04x, after the region we care about\n",
+				  frag->ofs, frag->ofs+frag->size);
 			next = frag->rb.rb_left;
 		} else {
-			D2(printk(KERN_DEBUG "Returning frag %d,%d, matched\n",
-				  frag->ofs, frag->ofs+frag->size));
+			JFFS2_DBG_FRAGTREE2("returning frag %#04x-%#04x, matched\n",
+				  frag->ofs, frag->ofs+frag->size);
 			return frag;
 		}
 	}
@@ -482,10 +472,10 @@ struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_
 	   and return the closest smaller one */
 
 	if (prev)
-		D2(printk(KERN_DEBUG "No match. Returning frag %d,%d, closest previous\n",
-			  prev->ofs, prev->ofs+prev->size));
+		JFFS2_DBG_FRAGTREE2("no match. Returning frag %#04x-%#04x, closest previous\n",
+			  prev->ofs, prev->ofs+prev->size);
 	else 
-		D2(printk(KERN_DEBUG "Returning NULL, empty fragtree\n"));
+		JFFS2_DBG_FRAGTREE2("returning NULL, empty fragtree\n");
 	
 	return prev;
 }
@@ -500,25 +490,25 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 	if (!root->rb_node)
 		return;
 
+	JFFS2_DBG_FRAGTREE("killing\n");
+	
 	frag = (rb_entry(root->rb_node, struct jffs2_node_frag, rb));
-
 	while(frag) {
 		if (frag->rb.rb_left) {
-			D2(printk(KERN_DEBUG "Going left from frag (%p) %d-%d\n", 
-				  frag, frag->ofs, frag->ofs+frag->size));
+			JFFS2_DBG_FRAGTREE2("going left from frag (%p) %#04x-%#04x\n",
+				frag, frag->ofs, frag->ofs+frag->size);
 			frag = frag_left(frag);
 			continue;
 		}
 		if (frag->rb.rb_right) {
-			D2(printk(KERN_DEBUG "Going right from frag (%p) %d-%d\n", 
-				  frag, frag->ofs, frag->ofs+frag->size));
+			JFFS2_DBG_FRAGTREE2("going right from frag (%p) %#04x-%#04x\n", 
+				  frag, frag->ofs, frag->ofs+frag->size);
 			frag = frag_right(frag);
 			continue;
 		}
 
-		D2(printk(KERN_DEBUG "jffs2_kill_fragtree: frag at 0x%x-0x%x: node %p, frags %d--\n",
-			  frag->ofs, frag->ofs+frag->size, frag->node,
-			  frag->node?frag->node->frags:0));
+		JFFS2_DBG_FRAGTREE2("frag %#04x-%#04x: node %p, frags %d\n",
+			  frag->ofs, frag->ofs+frag->size, frag->node, frag->node?frag->node->frags:0);
 			
 		if (frag->node && !(--frag->node->frags)) {
 			/* Not a hole, and it's the final remaining frag 

commit f97117d15361b3a6aeaf9e347a287ef3f54b58f9
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Wed Jul 27 15:46:14 2005 +0100

    [JFFS2] Move scattered function into related files
    
    Move functions to read inodes into readinode.c
    Move functions to handle fragtree and dentry lists into nodelist.[ch]
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 9d08d3388186..8373d312b195 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.100 2005/07/22 10:32:08 dedekind Exp $
+ * $Id: nodelist.c,v 1.101 2005/07/27 14:46:11 dedekind Exp $
  *
  */
 
@@ -55,515 +55,284 @@ void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new
 	});
 }
 
-/* 
- * Put a new tmp_dnode_info into the temporaty RB-tree, keeping the list in 
- * order of increasing version.
- */
-static void jffs2_add_tn_to_tree(struct jffs2_tmp_dnode_info *tn, struct rb_root *list)
+void jffs2_obsolete_node_frag(struct jffs2_sb_info *c, struct jffs2_node_frag *this)
 {
-	struct rb_node **p = &list->rb_node;
-	struct rb_node * parent = NULL;
-	struct jffs2_tmp_dnode_info *this;
-
-	while (*p) {
-		parent = *p;
-		this = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);
-
-		/* There may actually be a collision here, but it doesn't
-		   actually matter. As long as the two nodes with the same
-		   version are together, it's all fine. */
-		if (tn->version < this->version)
-			p = &(*p)->rb_left;
-		else
-			p = &(*p)->rb_right;
-        }
-
-	rb_link_node(&tn->rb, parent, p);
-	rb_insert_color(&tn->rb, list);
+	if (this->node) {
+		this->node->frags--;
+		if (!this->node->frags) {
+			/* The node has no valid frags left. It's totally obsoleted */
+			D2(printk(KERN_DEBUG "Marking old node @0x%08x (0x%04x-0x%04x) obsolete\n",
+				  ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size));
+			jffs2_mark_node_obsolete(c, this->node->raw);
+			jffs2_free_full_dnode(this->node);
+		} else {
+			D2(printk(KERN_DEBUG "Marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\n",
+				  ref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size,
+				  this->node->frags));
+			mark_ref_normal(this->node->raw);
+		}
+		
+	}
+	jffs2_free_node_frag(this);
 }
 
-static void jffs2_free_tmp_dnode_info_list(struct rb_root *list)
+static void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)
 {
-	struct rb_node *this;
-	struct jffs2_tmp_dnode_info *tn;
+	struct rb_node *parent = &base->rb;
+	struct rb_node **link = &parent;
 
-	this = list->rb_node;
+	D2(printk(KERN_DEBUG "jffs2_fragtree_insert(%p; %d-%d, %p)\n", newfrag, 
+		  newfrag->ofs, newfrag->ofs+newfrag->size, base));
 
-	/* Now at bottom of tree */
-	while (this) {
-		if (this->rb_left)
-			this = this->rb_left;
-		else if (this->rb_right)
-			this = this->rb_right;
+	while (*link) {
+		parent = *link;
+		base = rb_entry(parent, struct jffs2_node_frag, rb);
+	
+		D2(printk(KERN_DEBUG "fragtree_insert considering frag at 0x%x\n", base->ofs));
+		if (newfrag->ofs > base->ofs)
+			link = &base->rb.rb_right;
+		else if (newfrag->ofs < base->ofs)
+			link = &base->rb.rb_left;
 		else {
-			tn = rb_entry(this, struct jffs2_tmp_dnode_info, rb);
-			jffs2_free_full_dnode(tn->fn);
-			jffs2_free_tmp_dnode_info(tn);
-
-			this = this->rb_parent;
-			if (!this)
-				break;
-
-			if (this->rb_left == &tn->rb)
-				this->rb_left = NULL;
-			else if (this->rb_right == &tn->rb)
-				this->rb_right = NULL;
-			else BUG();
+			printk(KERN_CRIT "Duplicate frag at %08x (%p,%p)\n", newfrag->ofs, newfrag, base);
+			BUG();
 		}
 	}
-	list->rb_node = NULL;
+
+	rb_link_node(&newfrag->rb, &base->rb, link);
 }
 
-static void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)
+/* Doesn't set inode->i_size */
+static int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *list, struct jffs2_node_frag *newfrag)
 {
-	struct jffs2_full_dirent *next;
+	struct jffs2_node_frag *this;
+	uint32_t lastend;
 
-	while (fd) {
-		next = fd->next;
-		jffs2_free_full_dirent(fd);
-		fd = next;
-	}
-}
+	/* Skip all the nodes which are completed before this one starts */
+	this = jffs2_lookup_node_frag(list, newfrag->node->ofs);
 
-/* Returns first valid node after 'ref'. May return 'ref' */
-static struct jffs2_raw_node_ref *jffs2_first_valid_node(struct jffs2_raw_node_ref *ref)
-{
-	while (ref && ref->next_in_ino) {
-		if (!ref_obsolete(ref))
-			return ref;
-		D1(printk(KERN_DEBUG "node at 0x%08x is obsoleted. Ignoring.\n", ref_offset(ref)));
-		ref = ref->next_in_ino;
+	if (this) {
+		D2(printk(KERN_DEBUG "j_a_f_d_t_f: Lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n",
+			  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this));
+		lastend = this->ofs + this->size;
+	} else {
+		D2(printk(KERN_DEBUG "j_a_f_d_t_f: Lookup gave no frag\n"));
+		lastend = 0;
 	}
-	return NULL;
-}
+			  
+	/* See if we ran off the end of the list */
+	if (lastend <= newfrag->ofs) {
+		/* We did */
+
+		/* Check if 'this' node was on the same page as the new node.
+		   If so, both 'this' and the new node get marked REF_NORMAL so
+		   the GC can take a look.
+		*/
+		if (lastend && (lastend-1) >> PAGE_CACHE_SHIFT == newfrag->ofs >> PAGE_CACHE_SHIFT) {
+			if (this->node)
+				mark_ref_normal(this->node->raw);
+			mark_ref_normal(newfrag->node->raw);
+		}
 
-/*
- * Helper function for jffs2_get_inode_nodes().
- * It is called every time an directory entry node is found.
- *
- * Returns: 0 on succes;
- * 	    1 if the node should be marked obsolete;
- * 	    negative error code on failure.
- */
-static inline int
-read_direntry(struct jffs2_sb_info *c,
-	      struct jffs2_raw_node_ref *ref,
-	      struct jffs2_raw_dirent *rd,
-	      uint32_t read,
-	      struct jffs2_full_dirent **fdp,
-	      int32_t *latest_mctime,
-	      uint32_t *mctime_ver)
-{
-	struct jffs2_full_dirent *fd;
-	
-	/* The direntry nodes are checked during the flash scanning */
-	BUG_ON(ref_flags(ref) == REF_UNCHECKED);
-	/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
-	BUG_ON(ref_obsolete(ref));
-			
-	/* Sanity check */
-	if (unlikely(PAD((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen)))) {
-		printk(KERN_ERR "Error! Illegal nsize in node at %#08x: nsize %#02x, totlen %#04x\n",
-		       ref_offset(ref), rd->nsize, je32_to_cpu(rd->totlen));
-		return 1;
+		if (lastend < newfrag->node->ofs) {
+			/* ... and we need to put a hole in before the new node */
+			struct jffs2_node_frag *holefrag = jffs2_alloc_node_frag();
+			if (!holefrag) {
+				jffs2_free_node_frag(newfrag);
+				return -ENOMEM;
+			}
+			holefrag->ofs = lastend;
+			holefrag->size = newfrag->node->ofs - lastend;
+			holefrag->node = NULL;
+			if (this) {
+				/* By definition, the 'this' node has no right-hand child, 
+				   because there are no frags with offset greater than it.
+				   So that's where we want to put the hole */
+				D2(printk(KERN_DEBUG "Adding hole frag (%p) on right of node at (%p)\n", holefrag, this));
+				rb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);
+			} else {
+				D2(printk(KERN_DEBUG "Adding hole frag (%p) at root of tree\n", holefrag));
+				rb_link_node(&holefrag->rb, NULL, &list->rb_node);
+			}
+			rb_insert_color(&holefrag->rb, list);
+			this = holefrag;
+		}
+		if (this) {
+			/* By definition, the 'this' node has no right-hand child, 
+			   because there are no frags with offset greater than it.
+			   So that's where we want to put new fragment */
+			D2(printk(KERN_DEBUG "Adding new frag (%p) on right of node at (%p)\n", newfrag, this));
+			rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);			
+		} else {
+			D2(printk(KERN_DEBUG "Adding new frag (%p) at root of tree\n", newfrag));
+			rb_link_node(&newfrag->rb, NULL, &list->rb_node);
+		}
+		rb_insert_color(&newfrag->rb, list);
+		return 0;
 	}
-	
-	fd = jffs2_alloc_full_dirent(rd->nsize + 1);
-	if (unlikely(!fd))
-		return -ENOMEM;
-
-	fd->raw = ref;
-	fd->version = je32_to_cpu(rd->version);
-	fd->ino = je32_to_cpu(rd->ino);
-	fd->type = rd->type;
 
-	/* Pick out the mctime of the latest dirent */
-	if(fd->version > *mctime_ver) {
-		*mctime_ver = fd->version;
-		*latest_mctime = je32_to_cpu(rd->mctime);
-	}
+	D2(printk(KERN_DEBUG "j_a_f_d_t_f: dealing with frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n", 
+		  this->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this));
 
-	/* 
-	 * Copy as much of the name as possible from the raw
-	 * dirent we've already read from the flash.
+	/* OK. 'this' is pointing at the first frag that newfrag->ofs at least partially obsoletes,
+	 * - i.e. newfrag->ofs < this->ofs+this->size && newfrag->ofs >= this->ofs  
 	 */
-	if (read > sizeof(*rd))
-		memcpy(&fd->name[0], &rd->name[0],
-		       min_t(uint32_t, rd->nsize, (read - sizeof(*rd)) ));
-		
-	/* Do we need to copy any more of the name directly from the flash? */
-	if (rd->nsize + sizeof(*rd) > read) {
-		/* FIXME: point() */
-		int err;
-		int already = read - sizeof(*rd);
+	if (newfrag->ofs > this->ofs) {
+		/* This node isn't completely obsoleted. The start of it remains valid */
+
+		/* Mark the new node and the partially covered node REF_NORMAL -- let
+		   the GC take a look at them */
+		mark_ref_normal(newfrag->node->raw);
+		if (this->node)
+			mark_ref_normal(this->node->raw);
+
+		if (this->ofs + this->size > newfrag->ofs + newfrag->size) {
+			/* The new node splits 'this' frag into two */
+			struct jffs2_node_frag *newfrag2 = jffs2_alloc_node_frag();
+			if (!newfrag2) {
+				jffs2_free_node_frag(newfrag);
+				return -ENOMEM;
+			}
+			D2(printk(KERN_DEBUG "split old frag 0x%04x-0x%04x -->", this->ofs, this->ofs+this->size);
+			if (this->node)
+				printk("phys 0x%08x\n", ref_offset(this->node->raw));
+			else 
+				printk("hole\n");
+			   )
+			
+			/* New second frag pointing to this's node */
+			newfrag2->ofs = newfrag->ofs + newfrag->size;
+			newfrag2->size = (this->ofs+this->size) - newfrag2->ofs;
+			newfrag2->node = this->node;
+			if (this->node)
+				this->node->frags++;
+
+			/* Adjust size of original 'this' */
+			this->size = newfrag->ofs - this->ofs;
+
+			/* Now, we know there's no node with offset
+			   greater than this->ofs but smaller than
+			   newfrag2->ofs or newfrag->ofs, for obvious
+			   reasons. So we can do a tree insert from
+			   'this' to insert newfrag, and a tree insert
+			   from newfrag to insert newfrag2. */
+			jffs2_fragtree_insert(newfrag, this);
+			rb_insert_color(&newfrag->rb, list);
 			
-		err = jffs2_flash_read(c, (ref_offset(ref)) + read, 
-				rd->nsize - already, &read, &fd->name[already]);
-		if (unlikely(read != rd->nsize - already) && likely(!err))
-			return -EIO;
+			jffs2_fragtree_insert(newfrag2, newfrag);
+			rb_insert_color(&newfrag2->rb, list);
 			
-		if (unlikely(err)) {
-			printk(KERN_WARNING "Read remainder of name: error %d\n", err);
-			jffs2_free_full_dirent(fd);
-			return -EIO;
+			return 0;
 		}
-	}
-	
-	fd->nhash = full_name_hash(fd->name, rd->nsize);
-	fd->next = NULL;
-	fd->name[rd->nsize] = '\0';
-	
-	/*
-	 * Wheee. We now have a complete jffs2_full_dirent structure, with
-	 * the name in it and everything. Link it into the list 
-	 */
-	D1(printk(KERN_DEBUG "Adding fd \"%s\", ino #%u\n", fd->name, fd->ino));
-
-	jffs2_add_fd_to_list(c, fd, fdp);
+		/* New node just reduces 'this' frag in size, doesn't split it */
+		this->size = newfrag->ofs - this->ofs;
 
-	return 0;
-}
-
-/*
- * Helper function for jffs2_get_inode_nodes().
- * It is called every time an inode node is found.
- *
- * Returns: 0 on succes;
- * 	    1 if the node should be marked obsolete;
- * 	    negative error code on failure.
- */
-static inline int
-read_dnode(struct jffs2_sb_info *c,
-	   struct jffs2_raw_node_ref *ref,
-	   struct jffs2_raw_inode *rd,
-	   uint32_t read,
-	   struct rb_root *tnp,
-	   int32_t *latest_mctime,
-	   uint32_t *mctime_ver)
-{
-	struct jffs2_eraseblock *jeb;
-	struct jffs2_tmp_dnode_info *tn;
+		/* Again, we know it lives down here in the tree */
+		jffs2_fragtree_insert(newfrag, this);
+		rb_insert_color(&newfrag->rb, list);
+	} else {
+		/* New frag starts at the same point as 'this' used to. Replace 
+		   it in the tree without doing a delete and insertion */
+		D2(printk(KERN_DEBUG "Inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",
+			  newfrag, newfrag->ofs, newfrag->ofs+newfrag->size,
+			  this, this->ofs, this->ofs+this->size));
 	
-	/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
-	BUG_ON(ref_obsolete(ref));
-
-	/* If we've never checked the CRCs on this node, check them now */
-	if (ref_flags(ref) == REF_UNCHECKED) {
-		uint32_t crc, len;
-
-		crc = crc32(0, rd, sizeof(*rd) - 8);
-		if (unlikely(crc != je32_to_cpu(rd->node_crc))) {
-			printk(KERN_WARNING "Header CRC failed on node at %#08x: read %#08x, calculated %#08x\n",
-					ref_offset(ref), je32_to_cpu(rd->node_crc), crc);
-			return 1;
-		}
+		rb_replace_node(&this->rb, &newfrag->rb, list);
 		
-		/* Sanity checks */
-		if (unlikely(je32_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) ||
-		    unlikely(PAD(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen)))) {
-			printk(KERN_WARNING "Inode corrupted at %#08x, totlen %d, #ino  %d, version %d, "
-				"isize %d, csize %d, dsize %d \n",
-				ref_offset(ref),  je32_to_cpu(rd->totlen),  je32_to_cpu(rd->ino),
-				je32_to_cpu(rd->version),  je32_to_cpu(rd->isize), 
-				je32_to_cpu(rd->csize), je32_to_cpu(rd->dsize));
-			return 1;
-		}
-
-		if (rd->compr != JFFS2_COMPR_ZERO && je32_to_cpu(rd->csize)) {
-			unsigned char *buf = NULL;
-			uint32_t pointed = 0;
-			int err;
-#ifndef __ECOS
-			if (c->mtd->point) {
-				err = c->mtd->point (c->mtd, ref_offset(ref) + sizeof(*rd), je32_to_cpu(rd->csize),
-						     &read, &buf);
-				if (unlikely(read < je32_to_cpu(rd->csize)) && likely(!err)) {
-					D1(printk(KERN_DEBUG "MTD point returned len too short: 0x%zx\n", read));
-					c->mtd->unpoint(c->mtd, buf, ref_offset(ref) + sizeof(*rd),
-							je32_to_cpu(rd->csize));
-				} else if (unlikely(err)){
-					D1(printk(KERN_DEBUG "MTD point failed %d\n", err));
-				} else
-					pointed = 1; /* succefully pointed to device */
-			}
-#endif					
-			if(!pointed){
-				buf = kmalloc(je32_to_cpu(rd->csize), GFP_KERNEL);
-				if (!buf)
-					return -ENOMEM;
-				
-				err = jffs2_flash_read(c, ref_offset(ref) + sizeof(*rd), je32_to_cpu(rd->csize),
-							&read, buf);
-				if (unlikely(read != je32_to_cpu(rd->csize)) && likely(!err))
-					err = -EIO;
-				if (err) {
-					kfree(buf);
-					return err;
-				}
-			}
-			crc = crc32(0, buf, je32_to_cpu(rd->csize));
-			if(!pointed)
-				kfree(buf);
-#ifndef __ECOS
-			else
-				c->mtd->unpoint(c->mtd, buf, ref_offset(ref) + sizeof(*rd), je32_to_cpu(rd->csize));
-#endif
-
-			if (crc != je32_to_cpu(rd->data_crc)) {
-				printk(KERN_NOTICE "Data CRC failed on node at %#08x: read %#08x, calculated %#08x\n",
-				       ref_offset(ref), je32_to_cpu(rd->data_crc), crc);
-				return 1;
-			}
-			
-		}
-
-		/* Mark the node as having been checked and fix the accounting accordingly */
-		jeb = &c->blocks[ref->flash_offset / c->sector_size];
-		len = ref_totlen(c, jeb, ref);
-
-		spin_lock(&c->erase_completion_lock);
-		jeb->used_size += len;
-		jeb->unchecked_size -= len;
-		c->used_size += len;
-		c->unchecked_size -= len;
-
-		/* If node covers at least a whole page, or if it starts at the 
-		   beginning of a page and runs to the end of the file, or if 
-		   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL. 
-
-		   If it's actually overlapped, it'll get made NORMAL (or OBSOLETE) 
-		   when the overlapping node(s) get added to the tree anyway. 
-		*/
-		if ((je32_to_cpu(rd->dsize) >= PAGE_CACHE_SIZE) ||
-		    ( ((je32_to_cpu(rd->offset) & (PAGE_CACHE_SIZE-1))==0) &&
-		      (je32_to_cpu(rd->dsize) + je32_to_cpu(rd->offset) == je32_to_cpu(rd->isize)))) {
-			D1(printk(KERN_DEBUG "Marking node at %#08x REF_PRISTINE\n", ref_offset(ref)));
-			ref->flash_offset = ref_offset(ref) | REF_PRISTINE;
+		if (newfrag->ofs + newfrag->size >= this->ofs+this->size) {
+			D2(printk(KERN_DEBUG "Obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size));
+			jffs2_obsolete_node_frag(c, this);
 		} else {
-			D1(printk(KERN_DEBUG "Marking node at %#08x REF_NORMAL\n", ref_offset(ref)));
-			ref->flash_offset = ref_offset(ref) | REF_NORMAL;
+			this->ofs += newfrag->size;
+			this->size -= newfrag->size;
+
+			jffs2_fragtree_insert(this, newfrag);
+			rb_insert_color(&this->rb, list);
+			return 0;
 		}
-		spin_unlock(&c->erase_completion_lock);
 	}
-
-	tn = jffs2_alloc_tmp_dnode_info();
-	if (!tn) {
-		D1(printk(KERN_DEBUG "alloc tn failed\n"));
-		return -ENOMEM;
+	/* OK, now we have newfrag added in the correct place in the tree, but
+	   frag_next(newfrag) may be a fragment which is overlapped by it 
+	*/
+	while ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {
+		/* 'this' frag is obsoleted completely. */
+		D2(printk(KERN_DEBUG "Obsoleting node frag %p (%x-%x) and removing from tree\n", this, this->ofs, this->ofs+this->size));
+		rb_erase(&this->rb, list);
+		jffs2_obsolete_node_frag(c, this);
 	}
+	/* Now we're pointing at the first frag which isn't totally obsoleted by 
+	   the new frag */
 
-	tn->fn = jffs2_alloc_full_dnode();
-	if (!tn->fn) {
-		D1(printk(KERN_DEBUG "alloc fn failed\n"));
-		jffs2_free_tmp_dnode_info(tn);
-		return -ENOMEM;
+	if (!this || newfrag->ofs + newfrag->size == this->ofs) {
+		return 0;
 	}
-	
-	tn->version = je32_to_cpu(rd->version);
-	tn->fn->ofs = je32_to_cpu(rd->offset);
-	tn->fn->raw = ref;
-	
-	/* There was a bug where we wrote hole nodes out with
-	   csize/dsize swapped. Deal with it */
-	if (rd->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(rd->dsize) && je32_to_cpu(rd->csize))
-		tn->fn->size = je32_to_cpu(rd->csize);
-	else // normal case...
-		tn->fn->size = je32_to_cpu(rd->dsize);
-
-	D1(printk(KERN_DEBUG "dnode @%08x: ver %u, offset %#04x, dsize %#04x\n",
-		  ref_offset(ref), je32_to_cpu(rd->version),
-		  je32_to_cpu(rd->offset), je32_to_cpu(rd->dsize)));
-	
-	jffs2_add_tn_to_tree(tn, tnp);
+	/* Still some overlap but we don't need to move it in the tree */
+	this->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);
+	this->ofs = newfrag->ofs + newfrag->size;
+
+	/* And mark them REF_NORMAL so the GC takes a look at them */
+	if (this->node)
+		mark_ref_normal(this->node->raw);
+	mark_ref_normal(newfrag->node->raw);
 
 	return 0;
 }
 
-/*
- * Helper function for jffs2_get_inode_nodes().
- * It is called every time an unknown node is found.
- *
- * Returns: 0 on succes;
- * 	    1 if the node should be marked obsolete;
- * 	    negative error code on failure.
+/* Given an inode, probably with existing list of fragments, add the new node
+ * to the fragment list.
  */
-static inline int
-read_unknown(struct jffs2_sb_info *c,
-	     struct jffs2_raw_node_ref *ref,
-	     struct jffs2_unknown_node *un,
-	     uint32_t read)
+int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)
 {
-	/* We don't mark unknown nodes as REF_UNCHECKED */
-	BUG_ON(ref_flags(ref) == REF_UNCHECKED);
-	
-	un->nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(un->nodetype));
+	int ret;
+	struct jffs2_node_frag *newfrag;
 
-	if (crc32(0, un, sizeof(struct jffs2_unknown_node) - 4) != je32_to_cpu(un->hdr_crc)) {
+	D1(printk(KERN_DEBUG "jffs2_add_full_dnode_to_inode(ino #%u, f %p, fn %p)\n", f->inocache->ino, f, fn));
 
-		/* Hmmm. This should have been caught at scan time. */
-		printk(KERN_WARNING "Warning! Node header CRC failed at %#08x. "
-				"But it must have been OK earlier.\n", ref_offset(ref));
-		D1(printk(KERN_DEBUG "Node was: { %#04x, %#04x, %#08x, %#08x }\n", 
-			je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),
-			je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc)));
-		return 1;
-	} else {
-		switch(je16_to_cpu(un->nodetype) & JFFS2_COMPAT_MASK) {
+	if (unlikely(!fn->size))
+		return 0;
 
-		case JFFS2_FEATURE_INCOMPAT:
-			printk(KERN_NOTICE "Unknown INCOMPAT nodetype %#04X at %#08x\n",
-					je16_to_cpu(un->nodetype), ref_offset(ref));
-			/* EEP */
-			BUG();
-			break;
-
-		case JFFS2_FEATURE_ROCOMPAT:
-			printk(KERN_NOTICE "Unknown ROCOMPAT nodetype %#04X at %#08x\n",
-					je16_to_cpu(un->nodetype), ref_offset(ref));
-			BUG_ON(!(c->flags & JFFS2_SB_FLAG_RO));
-			break;
-
-		case JFFS2_FEATURE_RWCOMPAT_COPY:
-			printk(KERN_NOTICE "Unknown RWCOMPAT_COPY nodetype %#04X at %#08x\n",
-					je16_to_cpu(un->nodetype), ref_offset(ref));
-			break;
-
-		case JFFS2_FEATURE_RWCOMPAT_DELETE:
-			printk(KERN_NOTICE "Unknown RWCOMPAT_DELETE nodetype %#04X at %#08x\n",
-					je16_to_cpu(un->nodetype), ref_offset(ref));
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-/* Get tmp_dnode_info and full_dirent for all non-obsolete nodes associated
-   with this ino, returning the former in order of version */
+	newfrag = jffs2_alloc_node_frag();
+	if (unlikely(!newfrag))
+		return -ENOMEM;
 
-int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-			  struct rb_root *tnp, struct jffs2_full_dirent **fdp,
-			  uint32_t *highest_version, uint32_t *latest_mctime,
-			  uint32_t *mctime_ver)
-{
-	struct jffs2_raw_node_ref *ref, *valid_ref;
-	struct rb_root ret_tn = RB_ROOT;
-	struct jffs2_full_dirent *ret_fd = NULL;
-	union jffs2_node_union node;
-	size_t retlen;
-	int err;
-
-	*mctime_ver = 0;
+	D2(printk(KERN_DEBUG "adding node %04x-%04x @0x%08x on flash, newfrag *%p\n",
+		  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag));
 	
-	D1(printk(KERN_DEBUG "jffs2_get_inode_nodes(): ino #%u\n", f->inocache->ino));
-
-	spin_lock(&c->erase_completion_lock);
-
-	valid_ref = jffs2_first_valid_node(f->inocache->nodes);
-
-	if (!valid_ref && (f->inocache->ino != 1))
-		printk(KERN_WARNING "Eep. No valid nodes for ino #%u\n", f->inocache->ino);
-
-	while (valid_ref) {
-		/* We can hold a pointer to a non-obsolete node without the spinlock,
-		   but _obsolete_ nodes may disappear at any time, if the block
-		   they're in gets erased. So if we mark 'ref' obsolete while we're
-		   not holding the lock, it can go away immediately. For that reason,
-		   we find the next valid node first, before processing 'ref'.
-		*/
-		ref = valid_ref;
-		valid_ref = jffs2_first_valid_node(ref->next_in_ino);
-		spin_unlock(&c->erase_completion_lock);
-
-		cond_resched();
-
-		/* FIXME: point() */
-		err = jffs2_flash_read(c, (ref_offset(ref)), 
-				       min_t(uint32_t, ref_totlen(c, NULL, ref), sizeof(node)),
-				       &retlen, (void *)&node);
-		if (err) {
-			printk(KERN_WARNING "error %d reading node at 0x%08x in get_inode_nodes()\n", err, ref_offset(ref));
-			goto free_out;
-		}
-			
-		switch (je16_to_cpu(node.u.nodetype)) {
-			
-		case JFFS2_NODETYPE_DIRENT:
-			D1(printk(KERN_DEBUG "Node at %08x (%d) is a dirent node\n", ref_offset(ref), ref_flags(ref)));
-			
-			if (retlen < sizeof(node.d)) {
-				printk(KERN_WARNING "Warning! Short read dirent at %#08x\n", ref_offset(ref));
-				err = -EIO;
-				goto free_out;
-			}
-
-			err = read_direntry(c, ref, &node.d, retlen, &ret_fd, latest_mctime, mctime_ver);
-			if (err == 1) {
-				jffs2_mark_node_obsolete(c, ref);
-				break;
-			} else if (unlikely(err))
-				goto free_out;
-			
-			if (je32_to_cpu(node.d.version) > *highest_version)
-				*highest_version = je32_to_cpu(node.d.version);
-
-			break;
-
-		case JFFS2_NODETYPE_INODE:
-			D1(printk(KERN_DEBUG "Node at %08x (%d) is a data node\n", ref_offset(ref), ref_flags(ref)));
-			
-			if (retlen < sizeof(node.i)) {
-				printk(KERN_WARNING "Warning! Short read dnode at %#08x\n", ref_offset(ref));
-				err = -EIO;
-				goto free_out;
-			}
-
-			err = read_dnode(c, ref, &node.i, retlen, &ret_tn, latest_mctime, mctime_ver);
-			if (err == 1) {
-				jffs2_mark_node_obsolete(c, ref);
-				break;
-			} else if (unlikely(err))
-				goto free_out;
-
-			if (je32_to_cpu(node.i.version) > *highest_version)
-				*highest_version = je32_to_cpu(node.i.version);
-			
-			D1(printk(KERN_DEBUG "version %d, highest_version now %d\n",
-					je32_to_cpu(node.i.version), *highest_version));
-
-			break;
-
-		default:
-			/* Check we've managed to read at least the common node header */
-			if (retlen < sizeof(struct jffs2_unknown_node)) {
-				printk(KERN_WARNING "Warning! Short read unknown node at %#08x\n",
-						ref_offset(ref));
-				return -EIO;
-			}
-
-			err = read_unknown(c, ref, &node.u, retlen);
-			if (err == 1) {
-				jffs2_mark_node_obsolete(c, ref);
-				break;
-			} else if (unlikely(err))
-				goto free_out;
+	newfrag->ofs = fn->ofs;
+	newfrag->size = fn->size;
+	newfrag->node = fn;
+	newfrag->node->frags = 1;
+
+	ret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);
+	if (unlikely(ret))
+		return ret;
+
+	/* If we now share a page with other nodes, mark either previous
+	   or next node REF_NORMAL, as appropriate.  */
+	if (newfrag->ofs & (PAGE_CACHE_SIZE-1)) {
+		struct jffs2_node_frag *prev = frag_prev(newfrag);
+
+		mark_ref_normal(fn->raw);
+		/* If we don't start at zero there's _always_ a previous */	
+		if (prev->node)
+			mark_ref_normal(prev->node->raw);
+	}
 
+	if ((newfrag->ofs+newfrag->size) & (PAGE_CACHE_SIZE-1)) {
+		struct jffs2_node_frag *next = frag_next(newfrag);
+		
+		if (next) {
+			mark_ref_normal(fn->raw);
+			if (next->node)
+				mark_ref_normal(next->node->raw);
 		}
-		spin_lock(&c->erase_completion_lock);
-
 	}
-	spin_unlock(&c->erase_completion_lock);
-	*tnp = ret_tn;
-	*fdp = ret_fd;
-
+	jffs2_dbg_fragtree_paranoia_check_nolock(f);
+	jffs2_dbg_dump_fragtree_nolock(f);
 	return 0;
-
- free_out:
-	jffs2_free_tmp_dnode_info_list(&ret_tn);
-	jffs2_free_full_dirent_list(ret_fd);
-	return err;
 }
 
+
 void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)
 {
 	spin_lock(&c->inocache_lock);
@@ -773,29 +542,3 @@ void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
 		cond_resched();
 	}
 }
-
-void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)
-{
-	struct rb_node *parent = &base->rb;
-	struct rb_node **link = &parent;
-
-	D2(printk(KERN_DEBUG "jffs2_fragtree_insert(%p; %d-%d, %p)\n", newfrag, 
-		  newfrag->ofs, newfrag->ofs+newfrag->size, base));
-
-	while (*link) {
-		parent = *link;
-		base = rb_entry(parent, struct jffs2_node_frag, rb);
-	
-		D2(printk(KERN_DEBUG "fragtree_insert considering frag at 0x%x\n", base->ofs));
-		if (newfrag->ofs > base->ofs)
-			link = &base->rb.rb_right;
-		else if (newfrag->ofs < base->ofs)
-			link = &base->rb.rb_left;
-		else {
-			printk(KERN_CRIT "Duplicate frag at %08x (%p,%p)\n", newfrag->ofs, newfrag, base);
-			BUG();
-		}
-	}
-
-	rb_link_node(&newfrag->rb, &base->rb, link);
-}

commit e0c8e42f8f218063ff6838b25038ccef7ddf257e
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Sun Jul 24 16:14:17 2005 +0100

    [JFFS2] Debug code clean up - step 3
    
    Various simplifiactions. printk format corrections.
    Convert more code to use the new debug functions.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index a04111530f4d..9d08d3388186 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.99 2005/07/15 10:13:54 dedekind Exp $
+ * $Id: nodelist.c,v 1.100 2005/07/22 10:32:08 dedekind Exp $
  *
  */
 
@@ -203,7 +203,7 @@ read_direntry(struct jffs2_sb_info *c,
 			return -EIO;
 			
 		if (unlikely(err)) {
-			printk(KERN_WARNING "Read remainder of name in jffs2_get_inode_nodes(): error %d\n", err);
+			printk(KERN_WARNING "Read remainder of name: error %d\n", err);
 			jffs2_free_full_dirent(fd);
 			return -EIO;
 		}

commit dae6227f71fedb40b2478d3062397d3ab54e7556
Author: Artem B. Bityutskiy <dedekind@infradead.org>
Date:   Fri Jul 15 11:13:57 2005 +0100

    [JFFS2] Split a large routine on several smaller.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 4991c348f6ec..a04111530f4d 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.98 2005/07/10 15:15:32 dedekind Exp $
+ * $Id: nodelist.c,v 1.99 2005/07/15 10:13:54 dedekind Exp $
  *
  */
 
@@ -137,6 +137,307 @@ static struct jffs2_raw_node_ref *jffs2_first_valid_node(struct jffs2_raw_node_r
 	return NULL;
 }
 
+/*
+ * Helper function for jffs2_get_inode_nodes().
+ * It is called every time an directory entry node is found.
+ *
+ * Returns: 0 on succes;
+ * 	    1 if the node should be marked obsolete;
+ * 	    negative error code on failure.
+ */
+static inline int
+read_direntry(struct jffs2_sb_info *c,
+	      struct jffs2_raw_node_ref *ref,
+	      struct jffs2_raw_dirent *rd,
+	      uint32_t read,
+	      struct jffs2_full_dirent **fdp,
+	      int32_t *latest_mctime,
+	      uint32_t *mctime_ver)
+{
+	struct jffs2_full_dirent *fd;
+	
+	/* The direntry nodes are checked during the flash scanning */
+	BUG_ON(ref_flags(ref) == REF_UNCHECKED);
+	/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
+	BUG_ON(ref_obsolete(ref));
+			
+	/* Sanity check */
+	if (unlikely(PAD((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen)))) {
+		printk(KERN_ERR "Error! Illegal nsize in node at %#08x: nsize %#02x, totlen %#04x\n",
+		       ref_offset(ref), rd->nsize, je32_to_cpu(rd->totlen));
+		return 1;
+	}
+	
+	fd = jffs2_alloc_full_dirent(rd->nsize + 1);
+	if (unlikely(!fd))
+		return -ENOMEM;
+
+	fd->raw = ref;
+	fd->version = je32_to_cpu(rd->version);
+	fd->ino = je32_to_cpu(rd->ino);
+	fd->type = rd->type;
+
+	/* Pick out the mctime of the latest dirent */
+	if(fd->version > *mctime_ver) {
+		*mctime_ver = fd->version;
+		*latest_mctime = je32_to_cpu(rd->mctime);
+	}
+
+	/* 
+	 * Copy as much of the name as possible from the raw
+	 * dirent we've already read from the flash.
+	 */
+	if (read > sizeof(*rd))
+		memcpy(&fd->name[0], &rd->name[0],
+		       min_t(uint32_t, rd->nsize, (read - sizeof(*rd)) ));
+		
+	/* Do we need to copy any more of the name directly from the flash? */
+	if (rd->nsize + sizeof(*rd) > read) {
+		/* FIXME: point() */
+		int err;
+		int already = read - sizeof(*rd);
+			
+		err = jffs2_flash_read(c, (ref_offset(ref)) + read, 
+				rd->nsize - already, &read, &fd->name[already]);
+		if (unlikely(read != rd->nsize - already) && likely(!err))
+			return -EIO;
+			
+		if (unlikely(err)) {
+			printk(KERN_WARNING "Read remainder of name in jffs2_get_inode_nodes(): error %d\n", err);
+			jffs2_free_full_dirent(fd);
+			return -EIO;
+		}
+	}
+	
+	fd->nhash = full_name_hash(fd->name, rd->nsize);
+	fd->next = NULL;
+	fd->name[rd->nsize] = '\0';
+	
+	/*
+	 * Wheee. We now have a complete jffs2_full_dirent structure, with
+	 * the name in it and everything. Link it into the list 
+	 */
+	D1(printk(KERN_DEBUG "Adding fd \"%s\", ino #%u\n", fd->name, fd->ino));
+
+	jffs2_add_fd_to_list(c, fd, fdp);
+
+	return 0;
+}
+
+/*
+ * Helper function for jffs2_get_inode_nodes().
+ * It is called every time an inode node is found.
+ *
+ * Returns: 0 on succes;
+ * 	    1 if the node should be marked obsolete;
+ * 	    negative error code on failure.
+ */
+static inline int
+read_dnode(struct jffs2_sb_info *c,
+	   struct jffs2_raw_node_ref *ref,
+	   struct jffs2_raw_inode *rd,
+	   uint32_t read,
+	   struct rb_root *tnp,
+	   int32_t *latest_mctime,
+	   uint32_t *mctime_ver)
+{
+	struct jffs2_eraseblock *jeb;
+	struct jffs2_tmp_dnode_info *tn;
+	
+	/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
+	BUG_ON(ref_obsolete(ref));
+
+	/* If we've never checked the CRCs on this node, check them now */
+	if (ref_flags(ref) == REF_UNCHECKED) {
+		uint32_t crc, len;
+
+		crc = crc32(0, rd, sizeof(*rd) - 8);
+		if (unlikely(crc != je32_to_cpu(rd->node_crc))) {
+			printk(KERN_WARNING "Header CRC failed on node at %#08x: read %#08x, calculated %#08x\n",
+					ref_offset(ref), je32_to_cpu(rd->node_crc), crc);
+			return 1;
+		}
+		
+		/* Sanity checks */
+		if (unlikely(je32_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) ||
+		    unlikely(PAD(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen)))) {
+			printk(KERN_WARNING "Inode corrupted at %#08x, totlen %d, #ino  %d, version %d, "
+				"isize %d, csize %d, dsize %d \n",
+				ref_offset(ref),  je32_to_cpu(rd->totlen),  je32_to_cpu(rd->ino),
+				je32_to_cpu(rd->version),  je32_to_cpu(rd->isize), 
+				je32_to_cpu(rd->csize), je32_to_cpu(rd->dsize));
+			return 1;
+		}
+
+		if (rd->compr != JFFS2_COMPR_ZERO && je32_to_cpu(rd->csize)) {
+			unsigned char *buf = NULL;
+			uint32_t pointed = 0;
+			int err;
+#ifndef __ECOS
+			if (c->mtd->point) {
+				err = c->mtd->point (c->mtd, ref_offset(ref) + sizeof(*rd), je32_to_cpu(rd->csize),
+						     &read, &buf);
+				if (unlikely(read < je32_to_cpu(rd->csize)) && likely(!err)) {
+					D1(printk(KERN_DEBUG "MTD point returned len too short: 0x%zx\n", read));
+					c->mtd->unpoint(c->mtd, buf, ref_offset(ref) + sizeof(*rd),
+							je32_to_cpu(rd->csize));
+				} else if (unlikely(err)){
+					D1(printk(KERN_DEBUG "MTD point failed %d\n", err));
+				} else
+					pointed = 1; /* succefully pointed to device */
+			}
+#endif					
+			if(!pointed){
+				buf = kmalloc(je32_to_cpu(rd->csize), GFP_KERNEL);
+				if (!buf)
+					return -ENOMEM;
+				
+				err = jffs2_flash_read(c, ref_offset(ref) + sizeof(*rd), je32_to_cpu(rd->csize),
+							&read, buf);
+				if (unlikely(read != je32_to_cpu(rd->csize)) && likely(!err))
+					err = -EIO;
+				if (err) {
+					kfree(buf);
+					return err;
+				}
+			}
+			crc = crc32(0, buf, je32_to_cpu(rd->csize));
+			if(!pointed)
+				kfree(buf);
+#ifndef __ECOS
+			else
+				c->mtd->unpoint(c->mtd, buf, ref_offset(ref) + sizeof(*rd), je32_to_cpu(rd->csize));
+#endif
+
+			if (crc != je32_to_cpu(rd->data_crc)) {
+				printk(KERN_NOTICE "Data CRC failed on node at %#08x: read %#08x, calculated %#08x\n",
+				       ref_offset(ref), je32_to_cpu(rd->data_crc), crc);
+				return 1;
+			}
+			
+		}
+
+		/* Mark the node as having been checked and fix the accounting accordingly */
+		jeb = &c->blocks[ref->flash_offset / c->sector_size];
+		len = ref_totlen(c, jeb, ref);
+
+		spin_lock(&c->erase_completion_lock);
+		jeb->used_size += len;
+		jeb->unchecked_size -= len;
+		c->used_size += len;
+		c->unchecked_size -= len;
+
+		/* If node covers at least a whole page, or if it starts at the 
+		   beginning of a page and runs to the end of the file, or if 
+		   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL. 
+
+		   If it's actually overlapped, it'll get made NORMAL (or OBSOLETE) 
+		   when the overlapping node(s) get added to the tree anyway. 
+		*/
+		if ((je32_to_cpu(rd->dsize) >= PAGE_CACHE_SIZE) ||
+		    ( ((je32_to_cpu(rd->offset) & (PAGE_CACHE_SIZE-1))==0) &&
+		      (je32_to_cpu(rd->dsize) + je32_to_cpu(rd->offset) == je32_to_cpu(rd->isize)))) {
+			D1(printk(KERN_DEBUG "Marking node at %#08x REF_PRISTINE\n", ref_offset(ref)));
+			ref->flash_offset = ref_offset(ref) | REF_PRISTINE;
+		} else {
+			D1(printk(KERN_DEBUG "Marking node at %#08x REF_NORMAL\n", ref_offset(ref)));
+			ref->flash_offset = ref_offset(ref) | REF_NORMAL;
+		}
+		spin_unlock(&c->erase_completion_lock);
+	}
+
+	tn = jffs2_alloc_tmp_dnode_info();
+	if (!tn) {
+		D1(printk(KERN_DEBUG "alloc tn failed\n"));
+		return -ENOMEM;
+	}
+
+	tn->fn = jffs2_alloc_full_dnode();
+	if (!tn->fn) {
+		D1(printk(KERN_DEBUG "alloc fn failed\n"));
+		jffs2_free_tmp_dnode_info(tn);
+		return -ENOMEM;
+	}
+	
+	tn->version = je32_to_cpu(rd->version);
+	tn->fn->ofs = je32_to_cpu(rd->offset);
+	tn->fn->raw = ref;
+	
+	/* There was a bug where we wrote hole nodes out with
+	   csize/dsize swapped. Deal with it */
+	if (rd->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(rd->dsize) && je32_to_cpu(rd->csize))
+		tn->fn->size = je32_to_cpu(rd->csize);
+	else // normal case...
+		tn->fn->size = je32_to_cpu(rd->dsize);
+
+	D1(printk(KERN_DEBUG "dnode @%08x: ver %u, offset %#04x, dsize %#04x\n",
+		  ref_offset(ref), je32_to_cpu(rd->version),
+		  je32_to_cpu(rd->offset), je32_to_cpu(rd->dsize)));
+	
+	jffs2_add_tn_to_tree(tn, tnp);
+
+	return 0;
+}
+
+/*
+ * Helper function for jffs2_get_inode_nodes().
+ * It is called every time an unknown node is found.
+ *
+ * Returns: 0 on succes;
+ * 	    1 if the node should be marked obsolete;
+ * 	    negative error code on failure.
+ */
+static inline int
+read_unknown(struct jffs2_sb_info *c,
+	     struct jffs2_raw_node_ref *ref,
+	     struct jffs2_unknown_node *un,
+	     uint32_t read)
+{
+	/* We don't mark unknown nodes as REF_UNCHECKED */
+	BUG_ON(ref_flags(ref) == REF_UNCHECKED);
+	
+	un->nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(un->nodetype));
+
+	if (crc32(0, un, sizeof(struct jffs2_unknown_node) - 4) != je32_to_cpu(un->hdr_crc)) {
+
+		/* Hmmm. This should have been caught at scan time. */
+		printk(KERN_WARNING "Warning! Node header CRC failed at %#08x. "
+				"But it must have been OK earlier.\n", ref_offset(ref));
+		D1(printk(KERN_DEBUG "Node was: { %#04x, %#04x, %#08x, %#08x }\n", 
+			je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),
+			je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc)));
+		return 1;
+	} else {
+		switch(je16_to_cpu(un->nodetype) & JFFS2_COMPAT_MASK) {
+
+		case JFFS2_FEATURE_INCOMPAT:
+			printk(KERN_NOTICE "Unknown INCOMPAT nodetype %#04X at %#08x\n",
+					je16_to_cpu(un->nodetype), ref_offset(ref));
+			/* EEP */
+			BUG();
+			break;
+
+		case JFFS2_FEATURE_ROCOMPAT:
+			printk(KERN_NOTICE "Unknown ROCOMPAT nodetype %#04X at %#08x\n",
+					je16_to_cpu(un->nodetype), ref_offset(ref));
+			BUG_ON(!(c->flags & JFFS2_SB_FLAG_RO));
+			break;
+
+		case JFFS2_FEATURE_RWCOMPAT_COPY:
+			printk(KERN_NOTICE "Unknown RWCOMPAT_COPY nodetype %#04X at %#08x\n",
+					je16_to_cpu(un->nodetype), ref_offset(ref));
+			break;
+
+		case JFFS2_FEATURE_RWCOMPAT_DELETE:
+			printk(KERN_NOTICE "Unknown RWCOMPAT_DELETE nodetype %#04X at %#08x\n",
+					je16_to_cpu(un->nodetype), ref_offset(ref));
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
 /* Get tmp_dnode_info and full_dirent for all non-obsolete nodes associated
    with this ino, returning the former in order of version */
 
@@ -146,9 +447,8 @@ int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 			  uint32_t *mctime_ver)
 {
 	struct jffs2_raw_node_ref *ref, *valid_ref;
-	struct jffs2_tmp_dnode_info *tn;
 	struct rb_root ret_tn = RB_ROOT;
-	struct jffs2_full_dirent *fd, *ret_fd = NULL;
+	struct jffs2_full_dirent *ret_fd = NULL;
 	union jffs2_node_union node;
 	size_t retlen;
 	int err;
@@ -186,292 +486,67 @@ int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 			goto free_out;
 		}
 			
-
-			/* Check we've managed to read at least the common node header */
-		if (retlen < min_t(uint32_t, ref_totlen(c, NULL, ref), sizeof(node.u))) {
-			printk(KERN_WARNING "short read in get_inode_nodes()\n");
-			err = -EIO;
-			goto free_out;
-		}
-			
 		switch (je16_to_cpu(node.u.nodetype)) {
+			
 		case JFFS2_NODETYPE_DIRENT:
 			D1(printk(KERN_DEBUG "Node at %08x (%d) is a dirent node\n", ref_offset(ref), ref_flags(ref)));
-			if (ref_flags(ref) == REF_UNCHECKED) {
-				printk(KERN_WARNING "BUG: Dirent node at 0x%08x never got checked? How?\n", ref_offset(ref));
-				BUG();
-			}
+			
 			if (retlen < sizeof(node.d)) {
-				printk(KERN_WARNING "short read in get_inode_nodes()\n");
+				printk(KERN_WARNING "Warning! Short read dirent at %#08x\n", ref_offset(ref));
 				err = -EIO;
 				goto free_out;
 			}
-			/* sanity check */
-			if (PAD((node.d.nsize + sizeof (node.d))) != PAD(je32_to_cpu (node.d.totlen))) {
-				printk(KERN_NOTICE "jffs2_get_inode_nodes(): Illegal nsize in node at 0x%08x: nsize 0x%02x, totlen %04x\n",
-				       ref_offset(ref), node.d.nsize, je32_to_cpu(node.d.totlen));
+
+			err = read_direntry(c, ref, &node.d, retlen, &ret_fd, latest_mctime, mctime_ver);
+			if (err == 1) {
 				jffs2_mark_node_obsolete(c, ref);
-				spin_lock(&c->erase_completion_lock);
-				continue;
-			}
+				break;
+			} else if (unlikely(err))
+				goto free_out;
+			
 			if (je32_to_cpu(node.d.version) > *highest_version)
 				*highest_version = je32_to_cpu(node.d.version);
-			if (ref_obsolete(ref)) {
-				/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
-				printk(KERN_ERR "Dirent node at 0x%08x became obsolete while we weren't looking\n",
-				       ref_offset(ref));
-				BUG();
-			}
-			
-			fd = jffs2_alloc_full_dirent(node.d.nsize+1);
-			if (!fd) {
-				err = -ENOMEM;
-				goto free_out;
-			}
-			fd->raw = ref;
-			fd->version = je32_to_cpu(node.d.version);
-			fd->ino = je32_to_cpu(node.d.ino);
-			fd->type = node.d.type;
-
-			/* Pick out the mctime of the latest dirent */
-			if(fd->version > *mctime_ver) {
-				*mctime_ver = fd->version;
-				*latest_mctime = je32_to_cpu(node.d.mctime);
-			}
 
-			/* memcpy as much of the name as possible from the raw
-			   dirent we've already read from the flash
-			*/
-			if (retlen > sizeof(struct jffs2_raw_dirent))
-				memcpy(&fd->name[0], &node.d.name[0], min_t(uint32_t, node.d.nsize, (retlen-sizeof(struct jffs2_raw_dirent))));
-				
-			/* Do we need to copy any more of the name directly
-			   from the flash?
-			*/
-			if (node.d.nsize + sizeof(struct jffs2_raw_dirent) > retlen) {
-				/* FIXME: point() */
-				int already = retlen - sizeof(struct jffs2_raw_dirent);
-					
-				err = jffs2_flash_read(c, (ref_offset(ref)) + retlen, 
-						   node.d.nsize - already, &retlen, &fd->name[already]);
-				if (!err && retlen != node.d.nsize - already)
-					err = -EIO;
-					
-				if (err) {
-					printk(KERN_WARNING "Read remainder of name in jffs2_get_inode_nodes(): error %d\n", err);
-					jffs2_free_full_dirent(fd);
-					goto free_out;
-				}
-			}
-			fd->nhash = full_name_hash(fd->name, node.d.nsize);
-			fd->next = NULL;
-			fd->name[node.d.nsize] = '\0';
-				/* Wheee. We now have a complete jffs2_full_dirent structure, with
-				   the name in it and everything. Link it into the list 
-				*/
-			D1(printk(KERN_DEBUG "Adding fd \"%s\", ino #%u\n", fd->name, fd->ino));
-			jffs2_add_fd_to_list(c, fd, &ret_fd);
 			break;
 
 		case JFFS2_NODETYPE_INODE:
 			D1(printk(KERN_DEBUG "Node at %08x (%d) is a data node\n", ref_offset(ref), ref_flags(ref)));
+			
 			if (retlen < sizeof(node.i)) {
-				printk(KERN_WARNING "read too short for dnode\n");
+				printk(KERN_WARNING "Warning! Short read dnode at %#08x\n", ref_offset(ref));
 				err = -EIO;
 				goto free_out;
 			}
-			if (je32_to_cpu(node.i.version) > *highest_version)
-				*highest_version = je32_to_cpu(node.i.version);
-			D1(printk(KERN_DEBUG "version %d, highest_version now %d\n", je32_to_cpu(node.i.version), *highest_version));
-
-			if (ref_obsolete(ref)) {
-				/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
-				printk(KERN_ERR "Inode node at 0x%08x became obsolete while we weren't looking\n",
-				       ref_offset(ref));
-				BUG();
-			}
-
-			/* If we've never checked the CRCs on this node, check them now. */
-			if (ref_flags(ref) == REF_UNCHECKED) {
-				uint32_t crc, len;
-				struct jffs2_eraseblock *jeb;
-
-				crc = crc32(0, &node, sizeof(node.i)-8);
-				if (crc != je32_to_cpu(node.i.node_crc)) {
-					printk(KERN_NOTICE "jffs2_get_inode_nodes(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
-					       ref_offset(ref), je32_to_cpu(node.i.node_crc), crc);
-					jffs2_mark_node_obsolete(c, ref);
-					spin_lock(&c->erase_completion_lock);
-					continue;
-				}
-				
-				/* sanity checks */
-				if ( je32_to_cpu(node.i.offset) > je32_to_cpu(node.i.isize) ||
-				     PAD(je32_to_cpu(node.i.csize) + sizeof (node.i)) != PAD(je32_to_cpu(node.i.totlen))) {
-					printk(KERN_NOTICE "jffs2_get_inode_nodes(): Inode corrupted at 0x%08x, totlen %d, #ino  %d, version %d, isize %d, csize %d, dsize %d \n",
-						ref_offset(ref),  je32_to_cpu(node.i.totlen),  je32_to_cpu(node.i.ino),
-						je32_to_cpu(node.i.version),  je32_to_cpu(node.i.isize), 
-						je32_to_cpu(node.i.csize), je32_to_cpu(node.i.dsize));
-					jffs2_mark_node_obsolete(c, ref);
-					spin_lock(&c->erase_completion_lock);
-					continue;
-				}
 
-				if (node.i.compr != JFFS2_COMPR_ZERO && je32_to_cpu(node.i.csize)) {
-					unsigned char *buf=NULL;
-					uint32_t pointed = 0;
-#ifndef __ECOS
-					if (c->mtd->point) {
-						err = c->mtd->point (c->mtd, ref_offset(ref) + sizeof(node.i), je32_to_cpu(node.i.csize),
-								     &retlen, &buf);
-						if (!err && retlen < je32_to_cpu(node.i.csize)) {
-							D1(printk(KERN_DEBUG "MTD point returned len too short: 0x%zx\n", retlen));
-							c->mtd->unpoint(c->mtd, buf, ref_offset(ref) + sizeof(node.i), je32_to_cpu(node.i.csize));
-						} else if (err){
-							D1(printk(KERN_DEBUG "MTD point failed %d\n", err));
-						} else
-							pointed = 1; /* succefully pointed to device */
-					}
-#endif					
-					if(!pointed){
-						buf = kmalloc(je32_to_cpu(node.i.csize), GFP_KERNEL);
-						if (!buf)
-							return -ENOMEM;
-						
-						err = jffs2_flash_read(c, ref_offset(ref) + sizeof(node.i), je32_to_cpu(node.i.csize),
-								       &retlen, buf);
-						if (!err && retlen != je32_to_cpu(node.i.csize))
-							err = -EIO;
-						if (err) {
-							kfree(buf);
-							return err;
-						}
-					}
-					crc = crc32(0, buf, je32_to_cpu(node.i.csize));
-					if(!pointed)
-						kfree(buf);
-#ifndef __ECOS
-					else
-						c->mtd->unpoint(c->mtd, buf, ref_offset(ref) + sizeof(node.i), je32_to_cpu(node.i.csize));
-#endif
-
-					if (crc != je32_to_cpu(node.i.data_crc)) {
-						printk(KERN_NOTICE "jffs2_get_inode_nodes(): Data CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
-						       ref_offset(ref), je32_to_cpu(node.i.data_crc), crc);
-						jffs2_mark_node_obsolete(c, ref);
-						spin_lock(&c->erase_completion_lock);
-						continue;
-					}
-					
-				}
-
-				/* Mark the node as having been checked and fix the accounting accordingly */
-				spin_lock(&c->erase_completion_lock);
-				jeb = &c->blocks[ref->flash_offset / c->sector_size];
-				len = ref_totlen(c, jeb, ref);
-
-				jeb->used_size += len;
-				jeb->unchecked_size -= len;
-				c->used_size += len;
-				c->unchecked_size -= len;
-
-				/* If node covers at least a whole page, or if it starts at the 
-				   beginning of a page and runs to the end of the file, or if 
-				   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL. 
-
-				   If it's actually overlapped, it'll get made NORMAL (or OBSOLETE) 
-				   when the overlapping node(s) get added to the tree anyway. 
-				*/
-				if ((je32_to_cpu(node.i.dsize) >= PAGE_CACHE_SIZE) ||
-				    ( ((je32_to_cpu(node.i.offset)&(PAGE_CACHE_SIZE-1))==0) &&
-				      (je32_to_cpu(node.i.dsize)+je32_to_cpu(node.i.offset) ==  je32_to_cpu(node.i.isize)))) {
-					D1(printk(KERN_DEBUG "Marking node at 0x%08x REF_PRISTINE\n", ref_offset(ref)));
-					ref->flash_offset = ref_offset(ref) | REF_PRISTINE;
-				} else {
-					D1(printk(KERN_DEBUG "Marking node at 0x%08x REF_NORMAL\n", ref_offset(ref)));
-					ref->flash_offset = ref_offset(ref) | REF_NORMAL;
-				}
-				spin_unlock(&c->erase_completion_lock);
-			}
-
-			tn = jffs2_alloc_tmp_dnode_info();
-			if (!tn) {
-				D1(printk(KERN_DEBUG "alloc tn failed\n"));
-				err = -ENOMEM;
+			err = read_dnode(c, ref, &node.i, retlen, &ret_tn, latest_mctime, mctime_ver);
+			if (err == 1) {
+				jffs2_mark_node_obsolete(c, ref);
+				break;
+			} else if (unlikely(err))
 				goto free_out;
-			}
 
-			tn->fn = jffs2_alloc_full_dnode();
-			if (!tn->fn) {
-				D1(printk(KERN_DEBUG "alloc fn failed\n"));
-				err = -ENOMEM;
-				jffs2_free_tmp_dnode_info(tn);
-				goto free_out;
-			}
-			tn->version = je32_to_cpu(node.i.version);
-			tn->fn->ofs = je32_to_cpu(node.i.offset);
-			/* There was a bug where we wrote hole nodes out with
-			   csize/dsize swapped. Deal with it */
-			if (node.i.compr == JFFS2_COMPR_ZERO && !je32_to_cpu(node.i.dsize) && je32_to_cpu(node.i.csize))
-				tn->fn->size = je32_to_cpu(node.i.csize);
-			else // normal case...
-				tn->fn->size = je32_to_cpu(node.i.dsize);
-			tn->fn->raw = ref;
-			D1(printk(KERN_DEBUG "dnode @%08x: ver %u, offset %04x, dsize %04x\n",
-				  ref_offset(ref), je32_to_cpu(node.i.version),
-				  je32_to_cpu(node.i.offset), je32_to_cpu(node.i.dsize)));
-			jffs2_add_tn_to_tree(tn, &ret_tn);
+			if (je32_to_cpu(node.i.version) > *highest_version)
+				*highest_version = je32_to_cpu(node.i.version);
+			
+			D1(printk(KERN_DEBUG "version %d, highest_version now %d\n",
+					je32_to_cpu(node.i.version), *highest_version));
+
 			break;
 
 		default:
-			if (ref_flags(ref) == REF_UNCHECKED) {
-				struct jffs2_eraseblock *jeb;
-				uint32_t len;
-
-				printk(KERN_ERR "Eep. Unknown node type %04x at %08x was marked REF_UNCHECKED\n",
-				       je16_to_cpu(node.u.nodetype), ref_offset(ref));
-
-				/* Mark the node as having been checked and fix the accounting accordingly */
-				spin_lock(&c->erase_completion_lock);
-				jeb = &c->blocks[ref->flash_offset / c->sector_size];
-				len = ref_totlen(c, jeb, ref);
-
-				jeb->used_size += len;
-				jeb->unchecked_size -= len;
-				c->used_size += len;
-				c->unchecked_size -= len;
-
-				mark_ref_normal(ref);
-				spin_unlock(&c->erase_completion_lock);
+			/* Check we've managed to read at least the common node header */
+			if (retlen < sizeof(struct jffs2_unknown_node)) {
+				printk(KERN_WARNING "Warning! Short read unknown node at %#08x\n",
+						ref_offset(ref));
+				return -EIO;
 			}
-			node.u.nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(node.u.nodetype));
-			if (crc32(0, &node, sizeof(struct jffs2_unknown_node)-4) != je32_to_cpu(node.u.hdr_crc)) {
-				/* Hmmm. This should have been caught at scan time. */
-				printk(KERN_ERR "Node header CRC failed at %08x. But it must have been OK earlier.\n",
-				       ref_offset(ref));
-				printk(KERN_ERR "Node was: { %04x, %04x, %08x, %08x }\n", 
-				       je16_to_cpu(node.u.magic), je16_to_cpu(node.u.nodetype), je32_to_cpu(node.u.totlen),
-				       je32_to_cpu(node.u.hdr_crc));
-				jffs2_mark_node_obsolete(c, ref);
-			} else switch(je16_to_cpu(node.u.nodetype) & JFFS2_COMPAT_MASK) {
-			case JFFS2_FEATURE_INCOMPAT:
-				printk(KERN_NOTICE "Unknown INCOMPAT nodetype %04X at %08x\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
-				/* EEP */
-				BUG();
-				break;
-			case JFFS2_FEATURE_ROCOMPAT:
-				printk(KERN_NOTICE "Unknown ROCOMPAT nodetype %04X at %08x\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
-				if (!(c->flags & JFFS2_SB_FLAG_RO))
-					BUG();
-				break;
-			case JFFS2_FEATURE_RWCOMPAT_COPY:
-				printk(KERN_NOTICE "Unknown RWCOMPAT_COPY nodetype %04X at %08x\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
-				break;
-			case JFFS2_FEATURE_RWCOMPAT_DELETE:
-				printk(KERN_NOTICE "Unknown RWCOMPAT_DELETE nodetype %04X at %08x\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+
+			err = read_unknown(c, ref, &node.u, retlen);
+			if (err == 1) {
 				jffs2_mark_node_obsolete(c, ref);
 				break;
-			}
+			} else if (unlikely(err))
+				goto free_out;
 
 		}
 		spin_lock(&c->erase_completion_lock);

commit e4fef6618992bea48b7856ebbd236796b744964f
Author: Artem B. Bityuckiy <dedekind@infradead.org>
Date:   Sun Jul 10 16:15:36 2005 +0100

    [JFFS2] Rename function and update comments
    
    We recently changed the method of collecting and sorting of
    tmp_dnode objects to use a temporary RB-tree instead of a
    temporary list. Rename function and update comments.
    
    Signed-off-by: Artem B. Bityuckiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index c7bbdeec93a6..4991c348f6ec 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.97 2005/07/06 15:18:41 dwmw2 Exp $
+ * $Id: nodelist.c,v 1.98 2005/07/10 15:15:32 dedekind Exp $
  *
  */
 
@@ -55,11 +55,11 @@ void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new
 	});
 }
 
-/* Put a new tmp_dnode_info into the list, keeping the list in 
-   order of increasing version
-*/
-
-static void jffs2_add_tn_to_list(struct jffs2_tmp_dnode_info *tn, struct rb_root *list)
+/* 
+ * Put a new tmp_dnode_info into the temporaty RB-tree, keeping the list in 
+ * order of increasing version.
+ */
+static void jffs2_add_tn_to_tree(struct jffs2_tmp_dnode_info *tn, struct rb_root *list)
 {
 	struct rb_node **p = &list->rb_node;
 	struct rb_node * parent = NULL;
@@ -420,7 +420,7 @@ int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 			D1(printk(KERN_DEBUG "dnode @%08x: ver %u, offset %04x, dsize %04x\n",
 				  ref_offset(ref), je32_to_cpu(node.i.version),
 				  je32_to_cpu(node.i.offset), je32_to_cpu(node.i.dsize)));
-			jffs2_add_tn_to_list(tn, &ret_tn);
+			jffs2_add_tn_to_tree(tn, &ret_tn);
 			break;
 
 		default:

commit 6430a8def12edebc1c9c7c2621d33ca0e8653c33
Author: Artem B. Bityuckiy <dedekind@infradead.org>
Date:   Wed Jul 6 15:43:18 2005 +0100

    [JFFS2] Simplify the tree insert code.
    
    It isn't _normal_ that we allow key collision in rbtrees,
    but it does not matter as long as the two nodes with the same
    version are together.
    
    Signed-off-by: Artem B. Bityuckiy <dedekind@infradead.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index be38cc5c35cd..c7bbdeec93a6 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.95 2005/07/05 21:03:07 dwmw2 Exp $
+ * $Id: nodelist.c,v 1.97 2005/07/06 15:18:41 dwmw2 Exp $
  *
  */
 
@@ -69,12 +69,11 @@ static void jffs2_add_tn_to_list(struct jffs2_tmp_dnode_info *tn, struct rb_root
 		parent = *p;
 		this = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);
 
+		/* There may actually be a collision here, but it doesn't
+		   actually matter. As long as the two nodes with the same
+		   version are together, it's all fine. */
 		if (tn->version < this->version)
 			p = &(*p)->rb_left;
-		else if (tn->version > this->version)
-			p = &(*p)->rb_right;
-		else if (tn < this)
-			p = &(*p)->rb_left;
 		else
 			p = &(*p)->rb_right;
         }

commit 9dee7503ce3fc38911b9873216619190cf688128
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Jul 5 22:03:10 2005 +0100

    [JFFS2] Optimise jffs2_add_tn_to_list
    
    Use an rbtree instead of a simple linked list. We were wasting
    an amazing amount of time in jffs2_add_tn_to_list().
    Thanks to Artem Bityuckiy and Jarkko Jlavinen  for noticing.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 8a8e4b863824..be38cc5c35cd 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.94 2005/04/13 13:22:35 dwmw2 Exp $
+ * $Id: nodelist.c,v 1.95 2005/07/05 21:03:07 dwmw2 Exp $
  *
  */
 
@@ -58,27 +58,61 @@ void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new
 /* Put a new tmp_dnode_info into the list, keeping the list in 
    order of increasing version
 */
-static void jffs2_add_tn_to_list(struct jffs2_tmp_dnode_info *tn, struct jffs2_tmp_dnode_info **list)
+
+static void jffs2_add_tn_to_list(struct jffs2_tmp_dnode_info *tn, struct rb_root *list)
 {
-	struct jffs2_tmp_dnode_info **prev = list;
-	
-	while ((*prev) && (*prev)->version < tn->version) {
-		prev = &((*prev)->next);
-	}
-	tn->next = (*prev);
-        *prev = tn;
+	struct rb_node **p = &list->rb_node;
+	struct rb_node * parent = NULL;
+	struct jffs2_tmp_dnode_info *this;
+
+	while (*p) {
+		parent = *p;
+		this = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);
+
+		if (tn->version < this->version)
+			p = &(*p)->rb_left;
+		else if (tn->version > this->version)
+			p = &(*p)->rb_right;
+		else if (tn < this)
+			p = &(*p)->rb_left;
+		else
+			p = &(*p)->rb_right;
+        }
+
+	rb_link_node(&tn->rb, parent, p);
+	rb_insert_color(&tn->rb, list);
 }
 
-static void jffs2_free_tmp_dnode_info_list(struct jffs2_tmp_dnode_info *tn)
+static void jffs2_free_tmp_dnode_info_list(struct rb_root *list)
 {
-	struct jffs2_tmp_dnode_info *next;
+	struct rb_node *this;
+	struct jffs2_tmp_dnode_info *tn;
+
+	this = list->rb_node;
 
-	while (tn) {
-		next = tn;
-		tn = tn->next;
-		jffs2_free_full_dnode(next->fn);
-		jffs2_free_tmp_dnode_info(next);
+	/* Now at bottom of tree */
+	while (this) {
+		if (this->rb_left)
+			this = this->rb_left;
+		else if (this->rb_right)
+			this = this->rb_right;
+		else {
+			tn = rb_entry(this, struct jffs2_tmp_dnode_info, rb);
+			jffs2_free_full_dnode(tn->fn);
+			jffs2_free_tmp_dnode_info(tn);
+
+			this = this->rb_parent;
+			if (!this)
+				break;
+
+			if (this->rb_left == &tn->rb)
+				this->rb_left = NULL;
+			else if (this->rb_right == &tn->rb)
+				this->rb_right = NULL;
+			else BUG();
+		}
 	}
+	list->rb_node = NULL;
 }
 
 static void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)
@@ -108,12 +142,13 @@ static struct jffs2_raw_node_ref *jffs2_first_valid_node(struct jffs2_raw_node_r
    with this ino, returning the former in order of version */
 
 int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-			  struct jffs2_tmp_dnode_info **tnp, struct jffs2_full_dirent **fdp,
+			  struct rb_root *tnp, struct jffs2_full_dirent **fdp,
 			  uint32_t *highest_version, uint32_t *latest_mctime,
 			  uint32_t *mctime_ver)
 {
 	struct jffs2_raw_node_ref *ref, *valid_ref;
-	struct jffs2_tmp_dnode_info *tn, *ret_tn = NULL;
+	struct jffs2_tmp_dnode_info *tn;
+	struct rb_root ret_tn = RB_ROOT;
 	struct jffs2_full_dirent *fd, *ret_fd = NULL;
 	union jffs2_node_union node;
 	size_t retlen;
@@ -450,7 +485,7 @@ int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 	return 0;
 
  free_out:
-	jffs2_free_tmp_dnode_info_list(ret_tn);
+	jffs2_free_tmp_dnode_info_list(&ret_tn);
 	jffs2_free_full_dirent_list(ret_fd);
 	return err;
 }

commit 7d27c8143c8234e1cae8285fd2d43c19dad69bde
Author: Thomas Gleixner <tglx@tglx.tec.linutronix.de>
Date:   Sun May 22 21:47:19 2005 +0200

    [JFFS2] Whitespace cleanup. Fix missing debug message
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index c9157e1ea40a..8a8e4b863824 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -489,13 +489,13 @@ struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t
 void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new)
 {
 	struct jffs2_inode_cache **prev;
-	D2(printk(KERN_DEBUG "jffs2_add_ino_cache: Add %p (ino #%u)\n", new, new->ino));
+
 	spin_lock(&c->inocache_lock);
- 	if (!new->ino)
- 		new->ino = ++c->highest_ino;
- 
- 	D2(printk(KERN_DEBUG "jffs2_add_ino_cache: Add %p (ino #%u)\n", new, new->ino));
-	
+	if (!new->ino)
+		new->ino = ++c->highest_ino;
+
+	D2(printk(KERN_DEBUG "jffs2_add_ino_cache: Add %p (ino #%u)\n", new, new->ino));
+
 	prev = &c->inocache_list[new->ino % INOCACHE_HASHSIZE];
 
 	while ((*prev) && (*prev)->ino < new->ino) {

commit 7d200960d4f3d1b50c3b9e9688408d9f81c66ff4
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 13 14:22:38 2005 +0100

    [JFFS2] Fix inode allocation race
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index b835a8652623..c9157e1ea40a 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.93 2005/02/27 23:01:32 dwmw2 Exp $
+ * $Id: nodelist.c,v 1.94 2005/04/13 13:22:35 dwmw2 Exp $
  *
  */
 
@@ -491,6 +491,10 @@ void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new
 	struct jffs2_inode_cache **prev;
 	D2(printk(KERN_DEBUG "jffs2_add_ino_cache: Add %p (ino #%u)\n", new, new->ino));
 	spin_lock(&c->inocache_lock);
+ 	if (!new->ino)
+ 		new->ino = ++c->highest_ino;
+ 
+ 	D2(printk(KERN_DEBUG "jffs2_add_ino_cache: Add %p (ino #%u)\n", new, new->ino));
 	
 	prev = &c->inocache_list[new->ino % INOCACHE_HASHSIZE];
 

commit 67e345d17ff8c2085a54c293001ae548f7be7b21
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sun Feb 27 23:01:36 2005 +0000

    [JFFS2] Prevent ino cache removal for inodes in use
    
    Don't remove inocache for inodes which are in read_inode() or
    clear_inode() until they're done.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index 3c6d93c8ea0a..b835a8652623 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.92 2005/01/19 19:22:00 tpoynor Exp $
+ * $Id: nodelist.c,v 1.93 2005/02/27 23:01:32 dwmw2 Exp $
  *
  */
 
@@ -506,7 +506,7 @@ void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new
 void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
 {
 	struct jffs2_inode_cache **prev;
-	D2(printk(KERN_DEBUG "jffs2_del_ino_cache: Del %p (ino #%u)\n", old, old->ino));
+	D1(printk(KERN_DEBUG "jffs2_del_ino_cache: Del %p (ino #%u)\n", old, old->ino));
 	spin_lock(&c->inocache_lock);
 	
 	prev = &c->inocache_list[old->ino % INOCACHE_HASHSIZE];
@@ -518,6 +518,14 @@ void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
 		*prev = old->next;
 	}
 
+	/* Free it now unless it's in READING or CLEARING state, which
+	   are the transitions upon read_inode() and clear_inode(). The
+	   rest of the time we know nobody else is looking at it, and 
+	   if it's held by read_inode() or clear_inode() they'll free it
+	   for themselves. */
+	if (old->state != INO_STATE_READING && old->state != INO_STATE_CLEARING)
+		jffs2_free_inode_cache(old);
+
 	spin_unlock(&c->inocache_lock);
 }
 
@@ -530,7 +538,6 @@ void jffs2_free_ino_caches(struct jffs2_sb_info *c)
 		this = c->inocache_list[i];
 		while (this) {
 			next = this->next;
-			D2(printk(KERN_DEBUG "jffs2_free_ino_caches: Freeing ino #%u at %p\n", this->ino, this));
 			jffs2_free_inode_cache(this);
 			this = next;
 		}

commit 8fabed4a0f78623236c035de0984beeacb8096d8
Author: Todd Poynor <tpoynor@mvista.com>
Date:   Wed Jan 19 19:22:04 2005 +0000

    [JFFS2] Avoid warning for empty filesystems
    
    Avoid "Eep. No valid nodes for ino #1" message for just-created filesystem.
    
    Signed-off-by: Todd Poynor <tpoynor@mvista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
index cd6a8bd13e0b..3c6d93c8ea0a 100644
--- a/fs/jffs2/nodelist.c
+++ b/fs/jffs2/nodelist.c
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: nodelist.c,v 1.90 2004/12/08 17:59:20 dwmw2 Exp $
+ * $Id: nodelist.c,v 1.92 2005/01/19 19:22:00 tpoynor Exp $
  *
  */
 
@@ -127,7 +127,7 @@ int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 
 	valid_ref = jffs2_first_valid_node(f->inocache->nodes);
 
-	if (!valid_ref)
+	if (!valid_ref && (f->inocache->ino != 1))
 		printk(KERN_WARNING "Eep. No valid nodes for ino #%u\n", f->inocache->ino);
 
 	while (valid_ref) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/fs/jffs2/nodelist.c b/fs/jffs2/nodelist.c
new file mode 100644
index 000000000000..cd6a8bd13e0b
--- /dev/null
+++ b/fs/jffs2/nodelist.c
@@ -0,0 +1,681 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001-2003 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@infradead.org>
+ *
+ * For licensing information, see the file 'LICENCE' in this directory.
+ *
+ * $Id: nodelist.c,v 1.90 2004/12/08 17:59:20 dwmw2 Exp $
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/mtd/mtd.h>
+#include <linux/rbtree.h>
+#include <linux/crc32.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include "nodelist.h"
+
+void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)
+{
+	struct jffs2_full_dirent **prev = list;
+	D1(printk(KERN_DEBUG "jffs2_add_fd_to_list( %p, %p (->%p))\n", new, list, *list));
+
+	while ((*prev) && (*prev)->nhash <= new->nhash) {
+		if ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {
+			/* Duplicate. Free one */
+			if (new->version < (*prev)->version) {
+				D1(printk(KERN_DEBUG "Eep! Marking new dirent node obsolete\n"));
+				D1(printk(KERN_DEBUG "New dirent is \"%s\"->ino #%u. Old is \"%s\"->ino #%u\n", new->name, new->ino, (*prev)->name, (*prev)->ino));
+				jffs2_mark_node_obsolete(c, new->raw);
+				jffs2_free_full_dirent(new);
+			} else {
+				D1(printk(KERN_DEBUG "Marking old dirent node (ino #%u) obsolete\n", (*prev)->ino));
+				new->next = (*prev)->next;
+				jffs2_mark_node_obsolete(c, ((*prev)->raw));
+				jffs2_free_full_dirent(*prev);
+				*prev = new;
+			}
+			goto out;
+		}
+		prev = &((*prev)->next);
+	}
+	new->next = *prev;
+	*prev = new;
+
+ out:
+	D2(while(*list) {
+		printk(KERN_DEBUG "Dirent \"%s\" (hash 0x%08x, ino #%u\n", (*list)->name, (*list)->nhash, (*list)->ino);
+		list = &(*list)->next;
+	});
+}
+
+/* Put a new tmp_dnode_info into the list, keeping the list in 
+   order of increasing version
+*/
+static void jffs2_add_tn_to_list(struct jffs2_tmp_dnode_info *tn, struct jffs2_tmp_dnode_info **list)
+{
+	struct jffs2_tmp_dnode_info **prev = list;
+	
+	while ((*prev) && (*prev)->version < tn->version) {
+		prev = &((*prev)->next);
+	}
+	tn->next = (*prev);
+        *prev = tn;
+}
+
+static void jffs2_free_tmp_dnode_info_list(struct jffs2_tmp_dnode_info *tn)
+{
+	struct jffs2_tmp_dnode_info *next;
+
+	while (tn) {
+		next = tn;
+		tn = tn->next;
+		jffs2_free_full_dnode(next->fn);
+		jffs2_free_tmp_dnode_info(next);
+	}
+}
+
+static void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)
+{
+	struct jffs2_full_dirent *next;
+
+	while (fd) {
+		next = fd->next;
+		jffs2_free_full_dirent(fd);
+		fd = next;
+	}
+}
+
+/* Returns first valid node after 'ref'. May return 'ref' */
+static struct jffs2_raw_node_ref *jffs2_first_valid_node(struct jffs2_raw_node_ref *ref)
+{
+	while (ref && ref->next_in_ino) {
+		if (!ref_obsolete(ref))
+			return ref;
+		D1(printk(KERN_DEBUG "node at 0x%08x is obsoleted. Ignoring.\n", ref_offset(ref)));
+		ref = ref->next_in_ino;
+	}
+	return NULL;
+}
+
+/* Get tmp_dnode_info and full_dirent for all non-obsolete nodes associated
+   with this ino, returning the former in order of version */
+
+int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
+			  struct jffs2_tmp_dnode_info **tnp, struct jffs2_full_dirent **fdp,
+			  uint32_t *highest_version, uint32_t *latest_mctime,
+			  uint32_t *mctime_ver)
+{
+	struct jffs2_raw_node_ref *ref, *valid_ref;
+	struct jffs2_tmp_dnode_info *tn, *ret_tn = NULL;
+	struct jffs2_full_dirent *fd, *ret_fd = NULL;
+	union jffs2_node_union node;
+	size_t retlen;
+	int err;
+
+	*mctime_ver = 0;
+	
+	D1(printk(KERN_DEBUG "jffs2_get_inode_nodes(): ino #%u\n", f->inocache->ino));
+
+	spin_lock(&c->erase_completion_lock);
+
+	valid_ref = jffs2_first_valid_node(f->inocache->nodes);
+
+	if (!valid_ref)
+		printk(KERN_WARNING "Eep. No valid nodes for ino #%u\n", f->inocache->ino);
+
+	while (valid_ref) {
+		/* We can hold a pointer to a non-obsolete node without the spinlock,
+		   but _obsolete_ nodes may disappear at any time, if the block
+		   they're in gets erased. So if we mark 'ref' obsolete while we're
+		   not holding the lock, it can go away immediately. For that reason,
+		   we find the next valid node first, before processing 'ref'.
+		*/
+		ref = valid_ref;
+		valid_ref = jffs2_first_valid_node(ref->next_in_ino);
+		spin_unlock(&c->erase_completion_lock);
+
+		cond_resched();
+
+		/* FIXME: point() */
+		err = jffs2_flash_read(c, (ref_offset(ref)), 
+				       min_t(uint32_t, ref_totlen(c, NULL, ref), sizeof(node)),
+				       &retlen, (void *)&node);
+		if (err) {
+			printk(KERN_WARNING "error %d reading node at 0x%08x in get_inode_nodes()\n", err, ref_offset(ref));
+			goto free_out;
+		}
+			
+
+			/* Check we've managed to read at least the common node header */
+		if (retlen < min_t(uint32_t, ref_totlen(c, NULL, ref), sizeof(node.u))) {
+			printk(KERN_WARNING "short read in get_inode_nodes()\n");
+			err = -EIO;
+			goto free_out;
+		}
+			
+		switch (je16_to_cpu(node.u.nodetype)) {
+		case JFFS2_NODETYPE_DIRENT:
+			D1(printk(KERN_DEBUG "Node at %08x (%d) is a dirent node\n", ref_offset(ref), ref_flags(ref)));
+			if (ref_flags(ref) == REF_UNCHECKED) {
+				printk(KERN_WARNING "BUG: Dirent node at 0x%08x never got checked? How?\n", ref_offset(ref));
+				BUG();
+			}
+			if (retlen < sizeof(node.d)) {
+				printk(KERN_WARNING "short read in get_inode_nodes()\n");
+				err = -EIO;
+				goto free_out;
+			}
+			/* sanity check */
+			if (PAD((node.d.nsize + sizeof (node.d))) != PAD(je32_to_cpu (node.d.totlen))) {
+				printk(KERN_NOTICE "jffs2_get_inode_nodes(): Illegal nsize in node at 0x%08x: nsize 0x%02x, totlen %04x\n",
+				       ref_offset(ref), node.d.nsize, je32_to_cpu(node.d.totlen));
+				jffs2_mark_node_obsolete(c, ref);
+				spin_lock(&c->erase_completion_lock);
+				continue;
+			}
+			if (je32_to_cpu(node.d.version) > *highest_version)
+				*highest_version = je32_to_cpu(node.d.version);
+			if (ref_obsolete(ref)) {
+				/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
+				printk(KERN_ERR "Dirent node at 0x%08x became obsolete while we weren't looking\n",
+				       ref_offset(ref));
+				BUG();
+			}
+			
+			fd = jffs2_alloc_full_dirent(node.d.nsize+1);
+			if (!fd) {
+				err = -ENOMEM;
+				goto free_out;
+			}
+			fd->raw = ref;
+			fd->version = je32_to_cpu(node.d.version);
+			fd->ino = je32_to_cpu(node.d.ino);
+			fd->type = node.d.type;
+
+			/* Pick out the mctime of the latest dirent */
+			if(fd->version > *mctime_ver) {
+				*mctime_ver = fd->version;
+				*latest_mctime = je32_to_cpu(node.d.mctime);
+			}
+
+			/* memcpy as much of the name as possible from the raw
+			   dirent we've already read from the flash
+			*/
+			if (retlen > sizeof(struct jffs2_raw_dirent))
+				memcpy(&fd->name[0], &node.d.name[0], min_t(uint32_t, node.d.nsize, (retlen-sizeof(struct jffs2_raw_dirent))));
+				
+			/* Do we need to copy any more of the name directly
+			   from the flash?
+			*/
+			if (node.d.nsize + sizeof(struct jffs2_raw_dirent) > retlen) {
+				/* FIXME: point() */
+				int already = retlen - sizeof(struct jffs2_raw_dirent);
+					
+				err = jffs2_flash_read(c, (ref_offset(ref)) + retlen, 
+						   node.d.nsize - already, &retlen, &fd->name[already]);
+				if (!err && retlen != node.d.nsize - already)
+					err = -EIO;
+					
+				if (err) {
+					printk(KERN_WARNING "Read remainder of name in jffs2_get_inode_nodes(): error %d\n", err);
+					jffs2_free_full_dirent(fd);
+					goto free_out;
+				}
+			}
+			fd->nhash = full_name_hash(fd->name, node.d.nsize);
+			fd->next = NULL;
+			fd->name[node.d.nsize] = '\0';
+				/* Wheee. We now have a complete jffs2_full_dirent structure, with
+				   the name in it and everything. Link it into the list 
+				*/
+			D1(printk(KERN_DEBUG "Adding fd \"%s\", ino #%u\n", fd->name, fd->ino));
+			jffs2_add_fd_to_list(c, fd, &ret_fd);
+			break;
+
+		case JFFS2_NODETYPE_INODE:
+			D1(printk(KERN_DEBUG "Node at %08x (%d) is a data node\n", ref_offset(ref), ref_flags(ref)));
+			if (retlen < sizeof(node.i)) {
+				printk(KERN_WARNING "read too short for dnode\n");
+				err = -EIO;
+				goto free_out;
+			}
+			if (je32_to_cpu(node.i.version) > *highest_version)
+				*highest_version = je32_to_cpu(node.i.version);
+			D1(printk(KERN_DEBUG "version %d, highest_version now %d\n", je32_to_cpu(node.i.version), *highest_version));
+
+			if (ref_obsolete(ref)) {
+				/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
+				printk(KERN_ERR "Inode node at 0x%08x became obsolete while we weren't looking\n",
+				       ref_offset(ref));
+				BUG();
+			}
+
+			/* If we've never checked the CRCs on this node, check them now. */
+			if (ref_flags(ref) == REF_UNCHECKED) {
+				uint32_t crc, len;
+				struct jffs2_eraseblock *jeb;
+
+				crc = crc32(0, &node, sizeof(node.i)-8);
+				if (crc != je32_to_cpu(node.i.node_crc)) {
+					printk(KERN_NOTICE "jffs2_get_inode_nodes(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
+					       ref_offset(ref), je32_to_cpu(node.i.node_crc), crc);
+					jffs2_mark_node_obsolete(c, ref);
+					spin_lock(&c->erase_completion_lock);
+					continue;
+				}
+				
+				/* sanity checks */
+				if ( je32_to_cpu(node.i.offset) > je32_to_cpu(node.i.isize) ||
+				     PAD(je32_to_cpu(node.i.csize) + sizeof (node.i)) != PAD(je32_to_cpu(node.i.totlen))) {
+					printk(KERN_NOTICE "jffs2_get_inode_nodes(): Inode corrupted at 0x%08x, totlen %d, #ino  %d, version %d, isize %d, csize %d, dsize %d \n",
+						ref_offset(ref),  je32_to_cpu(node.i.totlen),  je32_to_cpu(node.i.ino),
+						je32_to_cpu(node.i.version),  je32_to_cpu(node.i.isize), 
+						je32_to_cpu(node.i.csize), je32_to_cpu(node.i.dsize));
+					jffs2_mark_node_obsolete(c, ref);
+					spin_lock(&c->erase_completion_lock);
+					continue;
+				}
+
+				if (node.i.compr != JFFS2_COMPR_ZERO && je32_to_cpu(node.i.csize)) {
+					unsigned char *buf=NULL;
+					uint32_t pointed = 0;
+#ifndef __ECOS
+					if (c->mtd->point) {
+						err = c->mtd->point (c->mtd, ref_offset(ref) + sizeof(node.i), je32_to_cpu(node.i.csize),
+								     &retlen, &buf);
+						if (!err && retlen < je32_to_cpu(node.i.csize)) {
+							D1(printk(KERN_DEBUG "MTD point returned len too short: 0x%zx\n", retlen));
+							c->mtd->unpoint(c->mtd, buf, ref_offset(ref) + sizeof(node.i), je32_to_cpu(node.i.csize));
+						} else if (err){
+							D1(printk(KERN_DEBUG "MTD point failed %d\n", err));
+						} else
+							pointed = 1; /* succefully pointed to device */
+					}
+#endif					
+					if(!pointed){
+						buf = kmalloc(je32_to_cpu(node.i.csize), GFP_KERNEL);
+						if (!buf)
+							return -ENOMEM;
+						
+						err = jffs2_flash_read(c, ref_offset(ref) + sizeof(node.i), je32_to_cpu(node.i.csize),
+								       &retlen, buf);
+						if (!err && retlen != je32_to_cpu(node.i.csize))
+							err = -EIO;
+						if (err) {
+							kfree(buf);
+							return err;
+						}
+					}
+					crc = crc32(0, buf, je32_to_cpu(node.i.csize));
+					if(!pointed)
+						kfree(buf);
+#ifndef __ECOS
+					else
+						c->mtd->unpoint(c->mtd, buf, ref_offset(ref) + sizeof(node.i), je32_to_cpu(node.i.csize));
+#endif
+
+					if (crc != je32_to_cpu(node.i.data_crc)) {
+						printk(KERN_NOTICE "jffs2_get_inode_nodes(): Data CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
+						       ref_offset(ref), je32_to_cpu(node.i.data_crc), crc);
+						jffs2_mark_node_obsolete(c, ref);
+						spin_lock(&c->erase_completion_lock);
+						continue;
+					}
+					
+				}
+
+				/* Mark the node as having been checked and fix the accounting accordingly */
+				spin_lock(&c->erase_completion_lock);
+				jeb = &c->blocks[ref->flash_offset / c->sector_size];
+				len = ref_totlen(c, jeb, ref);
+
+				jeb->used_size += len;
+				jeb->unchecked_size -= len;
+				c->used_size += len;
+				c->unchecked_size -= len;
+
+				/* If node covers at least a whole page, or if it starts at the 
+				   beginning of a page and runs to the end of the file, or if 
+				   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL. 
+
+				   If it's actually overlapped, it'll get made NORMAL (or OBSOLETE) 
+				   when the overlapping node(s) get added to the tree anyway. 
+				*/
+				if ((je32_to_cpu(node.i.dsize) >= PAGE_CACHE_SIZE) ||
+				    ( ((je32_to_cpu(node.i.offset)&(PAGE_CACHE_SIZE-1))==0) &&
+				      (je32_to_cpu(node.i.dsize)+je32_to_cpu(node.i.offset) ==  je32_to_cpu(node.i.isize)))) {
+					D1(printk(KERN_DEBUG "Marking node at 0x%08x REF_PRISTINE\n", ref_offset(ref)));
+					ref->flash_offset = ref_offset(ref) | REF_PRISTINE;
+				} else {
+					D1(printk(KERN_DEBUG "Marking node at 0x%08x REF_NORMAL\n", ref_offset(ref)));
+					ref->flash_offset = ref_offset(ref) | REF_NORMAL;
+				}
+				spin_unlock(&c->erase_completion_lock);
+			}
+
+			tn = jffs2_alloc_tmp_dnode_info();
+			if (!tn) {
+				D1(printk(KERN_DEBUG "alloc tn failed\n"));
+				err = -ENOMEM;
+				goto free_out;
+			}
+
+			tn->fn = jffs2_alloc_full_dnode();
+			if (!tn->fn) {
+				D1(printk(KERN_DEBUG "alloc fn failed\n"));
+				err = -ENOMEM;
+				jffs2_free_tmp_dnode_info(tn);
+				goto free_out;
+			}
+			tn->version = je32_to_cpu(node.i.version);
+			tn->fn->ofs = je32_to_cpu(node.i.offset);
+			/* There was a bug where we wrote hole nodes out with
+			   csize/dsize swapped. Deal with it */
+			if (node.i.compr == JFFS2_COMPR_ZERO && !je32_to_cpu(node.i.dsize) && je32_to_cpu(node.i.csize))
+				tn->fn->size = je32_to_cpu(node.i.csize);
+			else // normal case...
+				tn->fn->size = je32_to_cpu(node.i.dsize);
+			tn->fn->raw = ref;
+			D1(printk(KERN_DEBUG "dnode @%08x: ver %u, offset %04x, dsize %04x\n",
+				  ref_offset(ref), je32_to_cpu(node.i.version),
+				  je32_to_cpu(node.i.offset), je32_to_cpu(node.i.dsize)));
+			jffs2_add_tn_to_list(tn, &ret_tn);
+			break;
+
+		default:
+			if (ref_flags(ref) == REF_UNCHECKED) {
+				struct jffs2_eraseblock *jeb;
+				uint32_t len;
+
+				printk(KERN_ERR "Eep. Unknown node type %04x at %08x was marked REF_UNCHECKED\n",
+				       je16_to_cpu(node.u.nodetype), ref_offset(ref));
+
+				/* Mark the node as having been checked and fix the accounting accordingly */
+				spin_lock(&c->erase_completion_lock);
+				jeb = &c->blocks[ref->flash_offset / c->sector_size];
+				len = ref_totlen(c, jeb, ref);
+
+				jeb->used_size += len;
+				jeb->unchecked_size -= len;
+				c->used_size += len;
+				c->unchecked_size -= len;
+
+				mark_ref_normal(ref);
+				spin_unlock(&c->erase_completion_lock);
+			}
+			node.u.nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(node.u.nodetype));
+			if (crc32(0, &node, sizeof(struct jffs2_unknown_node)-4) != je32_to_cpu(node.u.hdr_crc)) {
+				/* Hmmm. This should have been caught at scan time. */
+				printk(KERN_ERR "Node header CRC failed at %08x. But it must have been OK earlier.\n",
+				       ref_offset(ref));
+				printk(KERN_ERR "Node was: { %04x, %04x, %08x, %08x }\n", 
+				       je16_to_cpu(node.u.magic), je16_to_cpu(node.u.nodetype), je32_to_cpu(node.u.totlen),
+				       je32_to_cpu(node.u.hdr_crc));
+				jffs2_mark_node_obsolete(c, ref);
+			} else switch(je16_to_cpu(node.u.nodetype) & JFFS2_COMPAT_MASK) {
+			case JFFS2_FEATURE_INCOMPAT:
+				printk(KERN_NOTICE "Unknown INCOMPAT nodetype %04X at %08x\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+				/* EEP */
+				BUG();
+				break;
+			case JFFS2_FEATURE_ROCOMPAT:
+				printk(KERN_NOTICE "Unknown ROCOMPAT nodetype %04X at %08x\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+				if (!(c->flags & JFFS2_SB_FLAG_RO))
+					BUG();
+				break;
+			case JFFS2_FEATURE_RWCOMPAT_COPY:
+				printk(KERN_NOTICE "Unknown RWCOMPAT_COPY nodetype %04X at %08x\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+				break;
+			case JFFS2_FEATURE_RWCOMPAT_DELETE:
+				printk(KERN_NOTICE "Unknown RWCOMPAT_DELETE nodetype %04X at %08x\n", je16_to_cpu(node.u.nodetype), ref_offset(ref));
+				jffs2_mark_node_obsolete(c, ref);
+				break;
+			}
+
+		}
+		spin_lock(&c->erase_completion_lock);
+
+	}
+	spin_unlock(&c->erase_completion_lock);
+	*tnp = ret_tn;
+	*fdp = ret_fd;
+
+	return 0;
+
+ free_out:
+	jffs2_free_tmp_dnode_info_list(ret_tn);
+	jffs2_free_full_dirent_list(ret_fd);
+	return err;
+}
+
+void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)
+{
+	spin_lock(&c->inocache_lock);
+	ic->state = state;
+	wake_up(&c->inocache_wq);
+	spin_unlock(&c->inocache_lock);
+}
+
+/* During mount, this needs no locking. During normal operation, its
+   callers want to do other stuff while still holding the inocache_lock.
+   Rather than introducing special case get_ino_cache functions or 
+   callbacks, we just let the caller do the locking itself. */
+   
+struct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)
+{
+	struct jffs2_inode_cache *ret;
+
+	D2(printk(KERN_DEBUG "jffs2_get_ino_cache(): ino %u\n", ino));
+
+	ret = c->inocache_list[ino % INOCACHE_HASHSIZE];
+	while (ret && ret->ino < ino) {
+		ret = ret->next;
+	}
+	
+	if (ret && ret->ino != ino)
+		ret = NULL;
+
+	D2(printk(KERN_DEBUG "jffs2_get_ino_cache found %p for ino %u\n", ret, ino));
+	return ret;
+}
+
+void jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new)
+{
+	struct jffs2_inode_cache **prev;
+	D2(printk(KERN_DEBUG "jffs2_add_ino_cache: Add %p (ino #%u)\n", new, new->ino));
+	spin_lock(&c->inocache_lock);
+	
+	prev = &c->inocache_list[new->ino % INOCACHE_HASHSIZE];
+
+	while ((*prev) && (*prev)->ino < new->ino) {
+		prev = &(*prev)->next;
+	}
+	new->next = *prev;
+	*prev = new;
+
+	spin_unlock(&c->inocache_lock);
+}
+
+void jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)
+{
+	struct jffs2_inode_cache **prev;
+	D2(printk(KERN_DEBUG "jffs2_del_ino_cache: Del %p (ino #%u)\n", old, old->ino));
+	spin_lock(&c->inocache_lock);
+	
+	prev = &c->inocache_list[old->ino % INOCACHE_HASHSIZE];
+	
+	while ((*prev) && (*prev)->ino < old->ino) {
+		prev = &(*prev)->next;
+	}
+	if ((*prev) == old) {
+		*prev = old->next;
+	}
+
+	spin_unlock(&c->inocache_lock);
+}
+
+void jffs2_free_ino_caches(struct jffs2_sb_info *c)
+{
+	int i;
+	struct jffs2_inode_cache *this, *next;
+	
+	for (i=0; i<INOCACHE_HASHSIZE; i++) {
+		this = c->inocache_list[i];
+		while (this) {
+			next = this->next;
+			D2(printk(KERN_DEBUG "jffs2_free_ino_caches: Freeing ino #%u at %p\n", this->ino, this));
+			jffs2_free_inode_cache(this);
+			this = next;
+		}
+		c->inocache_list[i] = NULL;
+	}
+}
+
+void jffs2_free_raw_node_refs(struct jffs2_sb_info *c)
+{
+	int i;
+	struct jffs2_raw_node_ref *this, *next;
+
+	for (i=0; i<c->nr_blocks; i++) {
+		this = c->blocks[i].first_node;
+		while(this) {
+			next = this->next_phys;
+			jffs2_free_raw_node_ref(this);
+			this = next;
+		}
+		c->blocks[i].first_node = c->blocks[i].last_node = NULL;
+	}
+}
+	
+struct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)
+{
+	/* The common case in lookup is that there will be a node 
+	   which precisely matches. So we go looking for that first */
+	struct rb_node *next;
+	struct jffs2_node_frag *prev = NULL;
+	struct jffs2_node_frag *frag = NULL;
+
+	D2(printk(KERN_DEBUG "jffs2_lookup_node_frag(%p, %d)\n", fragtree, offset));
+
+	next = fragtree->rb_node;
+
+	while(next) {
+		frag = rb_entry(next, struct jffs2_node_frag, rb);
+
+		D2(printk(KERN_DEBUG "Considering frag %d-%d (%p). left %p, right %p\n",
+			  frag->ofs, frag->ofs+frag->size, frag, frag->rb.rb_left, frag->rb.rb_right));
+		if (frag->ofs + frag->size <= offset) {
+			D2(printk(KERN_DEBUG "Going right from frag %d-%d, before the region we care about\n",
+				  frag->ofs, frag->ofs+frag->size));
+			/* Remember the closest smaller match on the way down */
+			if (!prev || frag->ofs > prev->ofs)
+				prev = frag;
+			next = frag->rb.rb_right;
+		} else if (frag->ofs > offset) {
+			D2(printk(KERN_DEBUG "Going left from frag %d-%d, after the region we care about\n",
+				  frag->ofs, frag->ofs+frag->size));
+			next = frag->rb.rb_left;
+		} else {
+			D2(printk(KERN_DEBUG "Returning frag %d,%d, matched\n",
+				  frag->ofs, frag->ofs+frag->size));
+			return frag;
+		}
+	}
+
+	/* Exact match not found. Go back up looking at each parent,
+	   and return the closest smaller one */
+
+	if (prev)
+		D2(printk(KERN_DEBUG "No match. Returning frag %d,%d, closest previous\n",
+			  prev->ofs, prev->ofs+prev->size));
+	else 
+		D2(printk(KERN_DEBUG "Returning NULL, empty fragtree\n"));
+	
+	return prev;
+}
+
+/* Pass 'c' argument to indicate that nodes should be marked obsolete as
+   they're killed. */
+void jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)
+{
+	struct jffs2_node_frag *frag;
+	struct jffs2_node_frag *parent;
+
+	if (!root->rb_node)
+		return;
+
+	frag = (rb_entry(root->rb_node, struct jffs2_node_frag, rb));
+
+	while(frag) {
+		if (frag->rb.rb_left) {
+			D2(printk(KERN_DEBUG "Going left from frag (%p) %d-%d\n", 
+				  frag, frag->ofs, frag->ofs+frag->size));
+			frag = frag_left(frag);
+			continue;
+		}
+		if (frag->rb.rb_right) {
+			D2(printk(KERN_DEBUG "Going right from frag (%p) %d-%d\n", 
+				  frag, frag->ofs, frag->ofs+frag->size));
+			frag = frag_right(frag);
+			continue;
+		}
+
+		D2(printk(KERN_DEBUG "jffs2_kill_fragtree: frag at 0x%x-0x%x: node %p, frags %d--\n",
+			  frag->ofs, frag->ofs+frag->size, frag->node,
+			  frag->node?frag->node->frags:0));
+			
+		if (frag->node && !(--frag->node->frags)) {
+			/* Not a hole, and it's the final remaining frag 
+			   of this node. Free the node */
+			if (c)
+				jffs2_mark_node_obsolete(c, frag->node->raw);
+			
+			jffs2_free_full_dnode(frag->node);
+		}
+		parent = frag_parent(frag);
+		if (parent) {
+			if (frag_left(parent) == frag)
+				parent->rb.rb_left = NULL;
+			else 
+				parent->rb.rb_right = NULL;
+		}
+
+		jffs2_free_node_frag(frag);
+		frag = parent;
+
+		cond_resched();
+	}
+}
+
+void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)
+{
+	struct rb_node *parent = &base->rb;
+	struct rb_node **link = &parent;
+
+	D2(printk(KERN_DEBUG "jffs2_fragtree_insert(%p; %d-%d, %p)\n", newfrag, 
+		  newfrag->ofs, newfrag->ofs+newfrag->size, base));
+
+	while (*link) {
+		parent = *link;
+		base = rb_entry(parent, struct jffs2_node_frag, rb);
+	
+		D2(printk(KERN_DEBUG "fragtree_insert considering frag at 0x%x\n", base->ofs));
+		if (newfrag->ofs > base->ofs)
+			link = &base->rb.rb_right;
+		else if (newfrag->ofs < base->ofs)
+			link = &base->rb.rb_left;
+		else {
+			printk(KERN_CRIT "Duplicate frag at %08x (%p,%p)\n", newfrag->ofs, newfrag, base);
+			BUG();
+		}
+	}
+
+	rb_link_node(&newfrag->rb, &base->rb, link);
+}
