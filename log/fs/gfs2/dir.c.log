commit 88dca4ca5a93d2c09e5bbc6a62fbfc3af83c4fca
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jun 1 21:51:40 2020 -0700

    mm: remove the pgprot argument to __vmalloc
    
    The pgprot argument to __vmalloc is always PAGE_KERNEL now, so remove it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com> [hyperv]
    Acked-by: Gao Xiang <xiang@kernel.org> [erofs]
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Wei Liu <wei.liu@kernel.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Laura Abbott <labbott@redhat.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Nitin Gupta <ngupta@vflare.org>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Sakari Ailus <sakari.ailus@linux.intel.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Sumit Semwal <sumit.semwal@linaro.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mackerras <paulus@ozlabs.org>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Will Deacon <will@kernel.org>
    Link: http://lkml.kernel.org/r/20200414131348.444715-22-hch@lst.de
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c3f7732415be..c0f2875c946c 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -354,7 +354,7 @@ static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)
 
 	hc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);
 	if (hc == NULL)
-		hc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);
+		hc = __vmalloc(hsize, GFP_NOFS);
 
 	if (hc == NULL)
 		return ERR_PTR(-ENOMEM);
@@ -1166,7 +1166,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 
 	hc2 = kmalloc_array(hsize_bytes, 2, GFP_NOFS | __GFP_NOWARN);
 	if (hc2 == NULL)
-		hc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS, PAGE_KERNEL);
+		hc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS);
 
 	if (!hc2)
 		return -ENOMEM;
@@ -1327,7 +1327,7 @@ static void *gfs2_alloc_sort_buffer(unsigned size)
 	if (size < KMALLOC_MAX_SIZE)
 		ptr = kmalloc(size, GFP_NOFS | __GFP_NOWARN);
 	if (!ptr)
-		ptr = __vmalloc(size, GFP_NOFS, PAGE_KERNEL);
+		ptr = __vmalloc(size, GFP_NOFS);
 	return ptr;
 }
 
@@ -1987,8 +1987,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 
 	ht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);
 	if (ht == NULL)
-		ht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO,
-			       PAGE_KERNEL);
+		ht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO);
 	if (!ht)
 		return -ENOMEM;
 

commit cc44457f16296809e40aae31415cd081a8352433
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Jan 3 08:48:43 2020 -0600

    gfs2: leaf_dealloc needs to allocate one more revoke
    
    Function leaf_dealloc was not allocating enough journal space for
    revokes. Before, it allocated 'l_blocks' revokes, but it needs one
    more for the revoke of the dinode that is modified. This patch adds
    the needed revoke entry to function leaf_dealloc.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c8b62577e2f2..c3f7732415be 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2028,7 +2028,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 
 	error = gfs2_trans_begin(sdp,
 			rg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +
-			RES_DINODE + RES_STATFS + RES_QUOTA, l_blocks);
+			RES_DINODE + RES_STATFS + RES_QUOTA, RES_DINODE +
+				 l_blocks);
 	if (error)
 		goto out_rg_gunlock;
 

commit b3ca4e447dba6c30c7867a1353712e3507dc5110
Author: Alex Shi <alex.shi@linux.alibaba.com>
Date:   Tue Jan 21 16:49:12 2020 +0800

    fs/gfs2: remove unused IS_DINODE and IS_LEAF macros
    
    Since commit 1579343a73e3 ("GFS2: Remove dirent_first() function"),
    these macros aren't used any more, so remove them.
    
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index eb9c0578978f..c8b62577e2f2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -73,9 +73,6 @@
 #include "bmap.h"
 #include "util.h"
 
-#define IS_LEAF     1 /* Hashed (leaf) directory */
-#define IS_DINODE   2 /* Linear (stuffed dinode block) directory */
-
 #define MAX_RA_BLOCKS 32 /* max read-ahead blocks */
 
 #define gfs2_disk_hash2offset(h) (((u64)(h)) >> 1)

commit bccaef90738581038ee609e946f36812bd6fb1b3
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Sep 3 15:10:05 2019 +0200

    gfs2: Delete an unnecessary check before brelse()
    
    The brelse() function tests whether its argument is NULL and then
    returns immediately.  Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    [The same applies to brelse() in gfs2_dir_no_add (which Coccinelle
    apparently missed), so fix that as well.]
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 6f35d19eec25..eb9c0578978f 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1463,8 +1463,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 				sort_offset : entries, copied);
 out_free:
 	for(i = 0; i < leaf; i++)
-		if (larr[i])
-			brelse(larr[i]);
+		brelse(larr[i]);
 	kvfree(larr);
 out:
 	return error;

commit 15a798f7deb3931dd569f5734a04be47b97435cc
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Wed Jun 5 22:24:24 2019 +0800

    gfs2: Use IS_ERR_OR_NULL
    
    Use IS_ERR_OR_NULL where appropriate.
    
    (Several more places converted by Andreas.)
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 88e4f955c518..6f35d19eec25 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -750,7 +750,7 @@ static struct gfs2_dirent *gfs2_dirent_split_alloc(struct inode *inode,
 	struct gfs2_dirent *dent;
 	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,
 				gfs2_dirent_find_offset, name, ptr);
-	if (!dent || IS_ERR(dent))
+	if (IS_ERR_OR_NULL(dent))
 		return dent;
 	return do_init_dirent(inode, dent, name, bh,
 			      (unsigned)(ptr - (void *)dent));
@@ -854,7 +854,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 		return ERR_PTR(error);
 	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);
 got_dent:
-	if (unlikely(dent == NULL || IS_ERR(dent))) {
+	if (IS_ERR_OR_NULL(dent)) {
 		brelse(bh);
 		bh = NULL;
 	}

commit 7336d0e654f7acc0ecee33a8ae68c4fd1c1c44b5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 398
    
    Based on 1 normalized pattern(s):
    
      this copyrighted material is made available to anyone wishing to use
      modify copy or redistribute it subject to the terms and conditions
      of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081038.653000175@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index db9a05244a35..88e4f955c518 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1,10 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
  * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.
- *
- * This copyrighted material is made available to anyone wishing to use,
- * modify, copy, or redistribute it subject to the terms and conditions
- * of the GNU General Public License version 2.
  */
 
 /*

commit fbb27873f21d5fb9bf556edcaa67e9891636e5d4
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Apr 5 12:18:23 2019 +0100

    gfs2: Rename gfs2_trans_{add_unrevoke => remove_revoke}
    
    Rename gfs2_trans_add_unrevoke to gfs2_trans_remove_revoke: there is no
    such thing as an "unrevoke" object; all this function does is remove
    existing revoke objects plus some bookkeeping.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index daa14ab4e31b..db9a05244a35 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -883,7 +883,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	if (!bh)
 		return NULL;
 
-	gfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);
+	gfs2_trans_remove_revoke(GFS2_SB(inode), bn, 1);
 	gfs2_trans_add_meta(ip->i_gl, bh);
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	leaf = (struct gfs2_leaf *)bh->b_data;

commit 0ddeded4ae768882e5c3a5558f77f27e4e445a6a
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Oct 4 15:36:02 2018 +0100

    gfs2: Pass resource group to rgblk_free
    
    Function rgblk_free can only deal with one resource group at a time, so
    pass that resource group is as a parameter.  Several of the callers
    already have the resource group at hand, so we only need additional
    lookup code in a few places.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 87a6dee88a62..daa14ab4e31b 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2042,6 +2042,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	bh = leaf_bh;
 
 	for (blk = leaf_no; blk; blk = nblk) {
+		struct gfs2_rgrpd *rgd;
+
 		if (blk != leaf_no) {
 			error = get_leaf(dip, blk, &bh);
 			if (error)
@@ -2052,7 +2054,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		if (blk != leaf_no)
 			brelse(bh);
 
-		gfs2_free_meta(dip, blk, 1);
+		rgd = gfs2_blk2rgrpd(sdp, blk, true);
+		gfs2_free_meta(dip, rgd, blk, 1);
 		gfs2_add_inode_blocks(&dip->i_inode, -1);
 	}
 

commit c3abc29e54a14953ddb26feeb62dd02d57925e52
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Oct 4 00:06:23 2018 +0100

    gfs2: Remove unnecessary gfs2_rlist_alloc parameter
    
    The state parameter of gfs2_rlist_alloc is set to LM_ST_EXCLUSIVE in all
    calls, so remove it and hardcode that state in gfs2_rlist_alloc instead.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 2e28fc947f7f..87a6dee88a62 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2021,7 +2021,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		l_blocks++;
 	}
 
-	gfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);
+	gfs2_rlist_alloc(&rlist);
 
 	for (x = 0; x < rlist.rl_rgrps; x++) {
 		struct gfs2_rgrpd *rgd = gfs2_glock2rgrp(rlist.rl_ghs[x].gh_gl);

commit e54c78a27fcdef406af799f360a93e6754adeefe
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Oct 3 08:47:36 2018 -0500

    gfs2: Use fs_* functions instead of pr_* function where we can
    
    Before this patch, various errors and messages were reported using
    the pr_* functions: pr_err, pr_warn, pr_info, etc., but that does
    not tell you which gfs2 mount had the problem, which is often vital
    to debugging. This patch changes the calls from pr_* to fs_* in
    most of the messages so that the file system id is printed along
    with the message.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index e37002560c11..2e28fc947f7f 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -506,7 +506,8 @@ static int gfs2_dirent_gather(const struct gfs2_dirent *dent,
  * For now the most important thing is to check that the various sizes
  * are correct.
  */
-static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,
+static int gfs2_check_dirent(struct gfs2_sbd *sdp,
+			     struct gfs2_dirent *dent, unsigned int offset,
 			     unsigned int size, unsigned int len, int first)
 {
 	const char *msg = "gfs2_dirent too small";
@@ -528,12 +529,12 @@ static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,
 		goto error;
 	return 0;
 error:
-	pr_warn("%s: %s (%s)\n",
+	fs_warn(sdp, "%s: %s (%s)\n",
 		__func__, msg, first ? "first in block" : "not first in block");
 	return -EIO;
 }
 
-static int gfs2_dirent_offset(const void *buf)
+static int gfs2_dirent_offset(struct gfs2_sbd *sdp, const void *buf)
 {
 	const struct gfs2_meta_header *h = buf;
 	int offset;
@@ -552,7 +553,8 @@ static int gfs2_dirent_offset(const void *buf)
 	}
 	return offset;
 wrong_type:
-	pr_warn("%s: wrong block type %u\n", __func__, be32_to_cpu(h->mh_type));
+	fs_warn(sdp, "%s: wrong block type %u\n", __func__,
+		be32_to_cpu(h->mh_type));
 	return -1;
 }
 
@@ -566,7 +568,7 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,
 	unsigned size;
 	int ret = 0;
 
-	ret = gfs2_dirent_offset(buf);
+	ret = gfs2_dirent_offset(GFS2_SB(inode), buf);
 	if (ret < 0)
 		goto consist_inode;
 
@@ -574,7 +576,7 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,
 	prev = NULL;
 	dent = buf + offset;
 	size = be16_to_cpu(dent->de_rec_len);
-	if (gfs2_check_dirent(dent, offset, size, len, 1))
+	if (gfs2_check_dirent(GFS2_SB(inode), dent, offset, size, len, 1))
 		goto consist_inode;
 	do {
 		ret = scan(dent, name, opaque);
@@ -586,7 +588,8 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,
 		prev = dent;
 		dent = buf + offset;
 		size = be16_to_cpu(dent->de_rec_len);
-		if (gfs2_check_dirent(dent, offset, size, len, 0))
+		if (gfs2_check_dirent(GFS2_SB(inode), dent, offset, size,
+				      len, 0))
 			goto consist_inode;
 	} while(1);
 
@@ -1043,7 +1046,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	len = BIT(dip->i_depth - be16_to_cpu(oleaf->lf_depth));
 	half_len = len >> 1;
 	if (!half_len) {
-		pr_warn("i_depth %u lf_depth %u index %u\n",
+		fs_warn(GFS2_SB(inode), "i_depth %u lf_depth %u index %u\n",
 			dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
 		gfs2_consist_inode(dip);
 		error = -EIO;
@@ -1351,7 +1354,7 @@ static int gfs2_set_cookies(struct gfs2_sbd *sdp, struct buffer_head *bh,
 		if (!sdp->sd_args.ar_loccookie)
 			continue;
 		offset = (char *)(darr[i]) -
-			 (bh->b_data + gfs2_dirent_offset(bh->b_data));
+			(bh->b_data + gfs2_dirent_offset(sdp, bh->b_data));
 		offset /= GFS2_MIN_DIRENT_SIZE;
 		offset += leaf_nr * sdp->sd_max_dents_per_leaf;
 		if (offset >= GFS2_USE_HASH_FLAG ||

commit d1b0cb933c8e638947ea72f3ab4e3dad4325bb96
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jul 17 15:59:28 2018 +0100

    gfs2: remove redundant variable 'moved'
    
    Variable 'moved' s being assigned but is never used hence it is
    redundant and can be removed.  This has been the case ever since commit
    c752666c.
    
    Cleans up clang warning:
    warning: variable 'moved' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d97ad89955d1..e37002560c11 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1011,7 +1011,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	u64 bn, leaf_no;
 	__be64 *lp;
 	u32 index;
-	int x, moved = 0;
+	int x;
 	int error;
 
 	index = name->hash >> (32 - dip->i_depth);
@@ -1113,8 +1113,6 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 			if (!prev)
 				prev = dent;
-
-			moved = 1;
 		} else {
 			prev = dent;
 		}

commit 7a932516f55cdf430c7cce78df2010ff7db6b874
Merge: dc594c39f7a9 e264abeaf9da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 15 07:31:07 2018 +0900

    Merge tag 'vfs-timespec64' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground
    
    Pull inode timestamps conversion to timespec64 from Arnd Bergmann:
     "This is a late set of changes from Deepa Dinamani doing an automated
      treewide conversion of the inode and iattr structures from 'timespec'
      to 'timespec64', to push the conversion from the VFS layer into the
      individual file systems.
    
      As Deepa writes:
    
       'The series aims to switch vfs timestamps to use struct timespec64.
        Currently vfs uses struct timespec, which is not y2038 safe.
    
        The series involves the following:
        1. Add vfs helper functions for supporting struct timepec64
           timestamps.
        2. Cast prints of vfs timestamps to avoid warnings after the switch.
        3. Simplify code using vfs timestamps so that the actual replacement
           becomes easy.
        4. Convert vfs timestamps to use struct timespec64 using a script.
           This is a flag day patch.
    
        Next steps:
        1. Convert APIs that can handle timespec64, instead of converting
           timestamps at the boundaries.
        2. Update internal data structures to avoid timestamp conversions'
    
      Thomas Gleixner adds:
    
       'I think there is no point to drag that out for the next merge
        window. The whole thing needs to be done in one go for the core
        changes which means that you're going to play that catchup game
        forever. Let's get over with it towards the end of the merge window'"
    
    * tag 'vfs-timespec64' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground:
      pstore: Remove bogus format string definition
      vfs: change inode times to use struct timespec64
      pstore: Convert internal records to timespec64
      udf: Simplify calls to udf_disk_stamp_to_time
      fs: nfs: get rid of memcpys for inode times
      ceph: make inode time prints to be long long
      lustre: Use long long type to print inode time
      fs: add timespec64_truncate()

commit 6da2ec56059c3c7a7e5f729e6349e74ace1e5c57
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 13:55:00 2018 -0700

    treewide: kmalloc() -> kmalloc_array()
    
    The kmalloc() function has a 2-factor argument form, kmalloc_array(). This
    patch replaces cases of:
    
            kmalloc(a * b, gfp)
    
    with:
            kmalloc_array(a * b, gfp)
    
    as well as handling cases of:
    
            kmalloc(a * b * c, gfp)
    
    with:
    
            kmalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kmalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kmalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The tools/ directory was manually excluded, since it has its own
    implementation of kmalloc().
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kmalloc
    + kmalloc_array
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(sizeof(THING) * C2, ...)
    |
      kmalloc(sizeof(TYPE) * C2, ...)
    |
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(C1 * C2, ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d9fb0ad6cc30..3090c445e8fc 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1055,7 +1055,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	/* Change the pointers.
 	   Don't bother distinguishing stuffed from non-stuffed.
 	   This code is complicated enough already. */
-	lp = kmalloc(half_len * sizeof(__be64), GFP_NOFS);
+	lp = kmalloc_array(half_len, sizeof(__be64), GFP_NOFS);
 	if (!lp) {
 		error = -ENOMEM;
 		goto fail_brelse;
@@ -1169,7 +1169,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	if (IS_ERR(hc))
 		return PTR_ERR(hc);
 
-	hc2 = kmalloc(hsize_bytes * 2, GFP_NOFS | __GFP_NOWARN);
+	hc2 = kmalloc_array(hsize_bytes, 2, GFP_NOFS | __GFP_NOWARN);
 	if (hc2 == NULL)
 		hc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS, PAGE_KERNEL);
 
@@ -1596,7 +1596,7 @@ int gfs2_dir_read(struct inode *inode, struct dir_context *ctx,
 
 	error = -ENOMEM;
 	/* 96 is max number of dirents which can be stuffed into an inode */
-	darr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_NOFS);
+	darr = kmalloc_array(96, sizeof(struct gfs2_dirent *), GFP_NOFS);
 	if (darr) {
 		g.pdent = (const struct gfs2_dirent **)darr;
 		g.offset = 0;

commit 95582b00838837fc07e042979320caf917ce3fe6
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Tue May 8 19:36:02 2018 -0700

    vfs: change inode times to use struct timespec64
    
    struct timespec is not y2038 safe. Transition vfs to use
    y2038 safe struct timespec64 instead.
    
    The change was made with the help of the following cocinelle
    script. This catches about 80% of the changes.
    All the header file and logic changes are included in the
    first 5 rules. The rest are trivial substitutions.
    I avoid changing any of the function signatures or any other
    filesystem specific data structures to keep the patch simple
    for review.
    
    The script can be a little shorter by combining different cases.
    But, this version was sufficient for my usecase.
    
    virtual patch
    
    @ depends on patch @
    identifier now;
    @@
    - struct timespec
    + struct timespec64
      current_time ( ... )
      {
    - struct timespec now = current_kernel_time();
    + struct timespec64 now = current_kernel_time64();
      ...
    - return timespec_trunc(
    + return timespec64_trunc(
      ... );
      }
    
    @ depends on patch @
    identifier xtime;
    @@
     struct \( iattr \| inode \| kstat \) {
     ...
    -       struct timespec xtime;
    +       struct timespec64 xtime;
     ...
     }
    
    @ depends on patch @
    identifier t;
    @@
     struct inode_operations {
     ...
    int (*update_time) (...,
    -       struct timespec t,
    +       struct timespec64 t,
    ...);
     ...
     }
    
    @ depends on patch @
    identifier t;
    identifier fn_update_time =~ "update_time$";
    @@
     fn_update_time (...,
    - struct timespec *t,
    + struct timespec64 *t,
     ...) { ... }
    
    @ depends on patch @
    identifier t;
    @@
    lease_get_mtime( ... ,
    - struct timespec *t
    + struct timespec64 *t
      ) { ... }
    
    @te depends on patch forall@
    identifier ts;
    local idexpression struct inode *inode_node;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn_update_time =~ "update_time$";
    identifier fn;
    expression e, E3;
    local idexpression struct inode *node1;
    local idexpression struct inode *node2;
    local idexpression struct iattr *attr1;
    local idexpression struct iattr *attr2;
    local idexpression struct iattr attr;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    @@
    (
    (
    - struct timespec ts;
    + struct timespec64 ts;
    |
    - struct timespec ts = current_time(inode_node);
    + struct timespec64 ts = current_time(inode_node);
    )
    
    <+... when != ts
    (
    - timespec_equal(&inode_node->i_xtime, &ts)
    + timespec64_equal(&inode_node->i_xtime, &ts)
    |
    - timespec_equal(&ts, &inode_node->i_xtime)
    + timespec64_equal(&ts, &inode_node->i_xtime)
    |
    - timespec_compare(&inode_node->i_xtime, &ts)
    + timespec64_compare(&inode_node->i_xtime, &ts)
    |
    - timespec_compare(&ts, &inode_node->i_xtime)
    + timespec64_compare(&ts, &inode_node->i_xtime)
    |
    ts = current_time(e)
    |
    fn_update_time(..., &ts,...)
    |
    inode_node->i_xtime = ts
    |
    node1->i_xtime = ts
    |
    ts = inode_node->i_xtime
    |
    <+... attr1->ia_xtime ...+> = ts
    |
    ts = attr1->ia_xtime
    |
    ts.tv_sec
    |
    ts.tv_nsec
    |
    btrfs_set_stack_timespec_sec(..., ts.tv_sec)
    |
    btrfs_set_stack_timespec_nsec(..., ts.tv_nsec)
    |
    - ts = timespec64_to_timespec(
    + ts =
    ...
    -)
    |
    - ts = ktime_to_timespec(
    + ts = ktime_to_timespec64(
    ...)
    |
    - ts = E3
    + ts = timespec_to_timespec64(E3)
    |
    - ktime_get_real_ts(&ts)
    + ktime_get_real_ts64(&ts)
    |
    fn(...,
    - ts
    + timespec64_to_timespec(ts)
    ,...)
    )
    ...+>
    (
    <... when != ts
    - return ts;
    + return timespec64_to_timespec(ts);
    ...>
    )
    |
    - timespec_equal(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_equal(&node1->i_xtime2, &node2->i_xtime2)
    |
    - timespec_equal(&node1->i_xtime1, &attr2->ia_xtime2)
    + timespec64_equal(&node1->i_xtime2, &attr2->ia_xtime2)
    |
    - timespec_compare(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_compare(&node1->i_xtime1, &node2->i_xtime2)
    |
    node1->i_xtime1 =
    - timespec_trunc(attr1->ia_xtime1,
    + timespec64_trunc(attr1->ia_xtime1,
    ...)
    |
    - attr1->ia_xtime1 = timespec_trunc(attr2->ia_xtime2,
    + attr1->ia_xtime1 =  timespec64_trunc(attr2->ia_xtime2,
    ...)
    |
    - ktime_get_real_ts(&attr1->ia_xtime1)
    + ktime_get_real_ts64(&attr1->ia_xtime1)
    |
    - ktime_get_real_ts(&attr.ia_xtime1)
    + ktime_get_real_ts64(&attr.ia_xtime1)
    )
    
    @ depends on patch @
    struct inode *node;
    struct iattr *attr;
    identifier fn;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    expression e;
    @@
    (
    - fn(node->i_xtime);
    + fn(timespec64_to_timespec(node->i_xtime));
    |
     fn(...,
    - node->i_xtime);
    + timespec64_to_timespec(node->i_xtime));
    |
    - e = fn(attr->ia_xtime);
    + e = fn(timespec64_to_timespec(attr->ia_xtime));
    )
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    )
    ...+>
    }
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    struct kstat *stat;
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier i_xtime =~ "^i_[acm]time$";
    identifier xtime =~ "^[acm]time$";
    identifier fn, ret;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(stat->xtime);
    ret = fn (...,
    - &stat->xtime);
    + &ts);
    )
    ...+>
    }
    
    @ depends on patch @
    struct inode *node;
    struct inode *node2;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier i_xtime3 =~ "^i_[acm]time$";
    struct iattr *attrp;
    struct iattr *attrp2;
    struct iattr attr ;
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    struct kstat *stat;
    struct kstat stat1;
    struct timespec64 ts;
    identifier xtime =~ "^[acmb]time$";
    expression e;
    @@
    (
    ( node->i_xtime2 \| attrp->ia_xtime2 \| attr.ia_xtime2 \) = node->i_xtime1  ;
    |
     node->i_xtime2 = \( node2->i_xtime1 \| timespec64_trunc(...) \);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     stat->xtime = node2->i_xtime1;
    |
     stat1.xtime = node2->i_xtime1;
    |
    ( node->i_xtime2 \| attrp->ia_xtime2 \) = attrp->ia_xtime1  ;
    |
    ( attrp->ia_xtime1 \| attr.ia_xtime1 \) = attrp2->ia_xtime2;
    |
    - e = node->i_xtime1;
    + e = timespec64_to_timespec( node->i_xtime1 );
    |
    - e = attrp->ia_xtime1;
    + e = timespec64_to_timespec( attrp->ia_xtime1 );
    |
    node->i_xtime1 = current_time(...);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
     node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
    - node->i_xtime1 = e;
    + node->i_xtime1 = timespec_to_timespec64(e);
    )
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: <anton@tuxera.com>
    Cc: <balbi@kernel.org>
    Cc: <bfields@fieldses.org>
    Cc: <darrick.wong@oracle.com>
    Cc: <dhowells@redhat.com>
    Cc: <dsterba@suse.com>
    Cc: <dwmw2@infradead.org>
    Cc: <hch@lst.de>
    Cc: <hirofumi@mail.parknet.co.jp>
    Cc: <hubcap@omnibond.com>
    Cc: <jack@suse.com>
    Cc: <jaegeuk@kernel.org>
    Cc: <jaharkes@cs.cmu.edu>
    Cc: <jslaby@suse.com>
    Cc: <keescook@chromium.org>
    Cc: <mark@fasheh.com>
    Cc: <miklos@szeredi.hu>
    Cc: <nico@linaro.org>
    Cc: <reiserfs-devel@vger.kernel.org>
    Cc: <richard@nod.at>
    Cc: <sage@redhat.com>
    Cc: <sfrench@samba.org>
    Cc: <swhiteho@redhat.com>
    Cc: <tj@kernel.org>
    Cc: <trond.myklebust@primarydata.com>
    Cc: <tytso@mit.edu>
    Cc: <viro@zeniv.linux.org.uk>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d9fb0ad6cc30..c22090e97ff0 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -871,7 +871,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct buffer_head *bh;
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;
-	struct timespec tv = current_time(inode);
+	struct timespec64 tv = current_time(inode);
 
 	error = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);
 	if (error)
@@ -1802,7 +1802,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh = da->bh;
 	struct gfs2_dirent *dent = da->dent;
-	struct timespec tv;
+	struct timespec64 tv;
 	struct gfs2_leaf *leaf;
 	int error;
 
@@ -1880,7 +1880,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)
 	const struct qstr *name = &dentry->d_name;
 	struct gfs2_dirent *dent, *prev = NULL;
 	struct buffer_head *bh;
-	struct timespec tv = current_time(&dip->i_inode);
+	struct timespec64 tv = current_time(&dip->i_inode);
 
 	/* Returns _either_ the entry (if its first in block) or the
 	   previous entry otherwise */

commit 83998ccd9bfff881f04ce03f6964f8a83e6c5b54
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Feb 28 12:48:53 2018 -0700

    gfs2: Dirty source inode during rename
    
    Mark the source inode dirty during a rename instead of just updating the
    underlying buffer head.  Otherwise, fsync may find the inode clean and
    will then skip flushing the journal.  A subsequent power failure will
    cause the rename to be lost.  This happens in command sequences like:
    
      xfs_io -f -c 'pwrite 0 4096' -c 'fsync' foo
      mv foo bar
      xfs_io -c 'fsync' bar
      # power failure
    
    Fixes xfstests generic/322, generic/376.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 7c21aea0266b..d9fb0ad6cc30 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1940,7 +1940,6 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 {
 	struct buffer_head *bh;
 	struct gfs2_dirent *dent;
-	int error;
 
 	dent = gfs2_dirent_search(&dip->i_inode, filename, gfs2_dirent_find, &bh);
 	if (!dent) {
@@ -1953,18 +1952,10 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 	gfs2_trans_add_meta(dip->i_gl, bh);
 	gfs2_inum_out(nip, dent);
 	dent->de_type = cpu_to_be16(new_type);
-
-	if (dip->i_diskflags & GFS2_DIF_EXHASH) {
-		brelse(bh);
-		error = gfs2_meta_inode_buffer(dip, &bh);
-		if (error)
-			return error;
-		gfs2_trans_add_meta(dip->i_gl, bh);
-	}
+	brelse(bh);
 
 	dip->i_inode.i_mtime = dip->i_inode.i_ctime = current_time(&dip->i_inode);
-	gfs2_dinode_out(dip, bh->b_data);
-	brelse(bh);
+	mark_inode_dirty_sync(&dip->i_inode);
 	return 0;
 }
 

commit 235628c5c76040b0ec206ea9ab9e017771e0d78e
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Tue Nov 14 16:53:12 2017 +0100

    gfs2: Add gfs2_max_stuffed_size
    
    Add a small inline function for computing the maximum size of a stuffed
    inode instead of open coding that in several places throughout the code.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 06a0d1947c77..7c21aea0266b 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -170,8 +170,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	if (!size)
 		return 0;
 
-	if (gfs2_is_stuffed(ip) &&
-	    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))
+	if (gfs2_is_stuffed(ip) && offset + size <= gfs2_max_stuffed_size(ip))
 		return gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,
 					      size);
 

commit 77d0ab600af4bf5152bc98d0ac1edbc34c1e5fdf
Merge: e7d0c41ecc2e 309e8cda596f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 6 11:42:31 2017 -0700

    Merge tag 'gfs2-4.14.fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/gfs2/linux-gfs2
    
    Pull GFS2 updates from Bob Peterson:
     "We've got a whopping 29 GFS2 patches for this merge window, mainly
      because we held some back from the previous merge window until we
      could get them perfected and well tested. We have a couple patch sets,
      including my patch set for protecting glock gl_object and Andreas
      Gruenbacher's patch set to fix the long-standing shrink- slab hang,
      plus a bunch of assorted bugs and cleanups.
    
      Summary:
    
       - I fixed a bug whereby an IO error would lead to a double-brelse.
    
       - Andreas Gruenbacher made a minor cleanup to call his relatively new
         function, gfs2_holder_initialized, rather than doing it manually.
         This was just missed by a previous patch set.
    
       - Jan Kara fixed a bug whereby the SGID was being cleared when
         inheriting ACLs.
    
       - Andreas found a bug and fixed it in his previous patch, "Get rid of
         flush_delayed_work in gfs2_evict_inode". A call to
         flush_delayed_work was deleted from *gfs2_inode_lookup and added to
         gfs2_create_inode.
    
       - Wang Xibo found and fixed a list_add call in inode_go_lock that
         specified the parameters in the wrong order.
    
       - Coly Li submitted a patch to add the REQ_PRIO to some of GFS2's
         metadata reads that were accidentally missing them.
    
       - I submitted a 4-patch set to protect the glock gl_object field.
         GFS2 was setting and checking gl_object with no locking mechanism,
         so the value was occasionally stomped on, which caused file system
         corruption.
    
       - I submitted a small cleanup to function gfs2_clear_rgrpd. It was
         needlessly adding rgrp glocks to the lru list, then pulling them
         back off immediately. The rgrp glocks don't use the lru list
         anyway, so doing so was just a waste of time.
    
       - I submitted a patch that checks the GLOF_LRU flag on a glock before
         trying to remove it from the lru_list. This avoids a lot of
         unnecessary spin_lock contention.
    
       - I submitted a patch to delete GFS2's debugfs files only after we
         evict all the glocks. Before this patch, GFS2 would delete the
         debugfs files, and if unmount hung waiting for a glock, there was
         no way to debug the problem. Now, if a hang occurs during umount,
         we can examine the debugfs files to figure out why it's hung.
    
       - Andreas Gruenbacher submitted a patch to fix some trivial typos.
    
       - Andreas also submitted a five-part patch set to fix the
         longstanding hang involving the slab shrinker: dlm requires memory,
         calls the inode shrinker, which calls gfs2's evict, which calls
         back into DLM before it can evict an inode.
    
       - Abhi Das submitted a patch to forcibly flush the active items list
         to relieve memory pressure. This fixes a long-standing bug whereby
         GFS2 was getting hung permanently in balance_dirty_pages.
    
       - Thomas Tai submitted a patch to fix a slab corruption problem due
         to a residual pointer left in the lock_dlm lockstruct.
    
       - I submitted a patch to withdraw the file system if IO errors are
         encountered while writing to the journals or statfs system file
         which were previously not being sent back up. Before, some IO
         errors were sometimes not be detected for several hours, and at
         recovery time, the journal errors made journal replay impossible.
    
       - Andreas has a patch to fix an annoying format-truncation compiler
         warning so GFS2 compiles cleanly.
    
       - I have a patch that fixes a handful of sparse compiler warnings.
    
       - Andreas fixed up an useless gl_object warning caused by an earlier
         patch.
    
       - Arvind Yadav added a patch to properly constify our rhashtable
         params declare.
    
       - I added a patch to fix a regression caused by the non-recursive
         delete and truncate patch that caused file system blocks to not be
         properly freed.
    
       - Ernesto A. Fernández added a patch to fix a place where GFS2 would
         send back the wrong return code setting extended attributes.
    
       - Ernesto also added a patch to fix a case in which GFS2 was
         improperly setting an inode's i_mode, potentially granting access
         to the wrong users"
    
    * tag 'gfs2-4.14.fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/gfs2/linux-gfs2: (29 commits)
      gfs2: preserve i_mode if __gfs2_set_acl() fails
      gfs2: don't return ENODATA in __gfs2_xattr_set unless replacing
      GFS2: Fix non-recursive truncate bug
      gfs2: constify rhashtable_params
      GFS2: Fix gl_object warnings
      GFS2: Fix up some sparse warnings
      gfs2: Silence gcc format-truncation warning
      GFS2: Withdraw for IO errors writing to the journal or statfs
      gfs2: fix slab corruption during mounting and umounting gfs file system
      gfs2: forcibly flush ail to relieve memory pressure
      gfs2: Clean up waiting on glocks
      gfs2: Defer deleting inodes under memory pressure
      gfs2: gfs2_evict_inode: Put glocks asynchronously
      gfs2: Get rid of gfs2_set_nlink
      gfs2: gfs2_glock_get: Wait on freeing glocks
      gfs2: Fix trivial typos
      GFS2: Delete debugfs files only after we evict the glocks
      GFS2: Don't waste time locking lru_lock for non-lru glocks
      GFS2: Don't bother trying to add rgrps to the lru list
      GFS2: Clear gl_object when deleting an inode in gfs2_delete_inode
      ...

commit e477b24b507998bc6568316a2e034025960d2404
Author: Coly Li <colyli@suse.de>
Date:   Fri Jul 21 07:48:22 2017 -0500

    gfs2: add flag REQ_PRIO for metadata I/O
    
    When gfs2 does metadata I/O, only REQ_META is used as a metadata hint of
    the bio. But flag REQ_META is just a hint for block trace, not for block
    layer code to handle a bio as metadata request.
    
    For some of metadata I/Os of gfs2, A REQ_PRIO flag on the metadata bio
    would be very informative to block layer code. For example, if bcache is
    used as a I/O cache for gfs2, it will be possible for bcache code to get
    the hint and cache the pre-fetched metadata blocks on cache device. This
    behavior may be helpful to improve metadata I/O performance if the
    following requests hit the cache.
    
    Here are the locations in gfs2 code where a REQ_PRIO flag should be added,
    - All places where REQ_READAHEAD is used, gfs2 code uses this flag for
      metadata read ahead.
    - In gfs2_meta_rq() where the first metadata block is read in.
    - In gfs2_write_buf_to_page(), read in quota metadata blocks to have them
      up to date.
    These metadata blocks are probably to be accessed again in future, adding
    a REQ_PRIO flag may have bcache to keep such metadata in fast cache
    device. For system without a cache layer, REQ_PRIO can still provide hint
    to block layer to handle metadata requests more properly.
    
    Signed-off-by: Coly Li <colyli@suse.de>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index db427658ccd9..0741e4018f8c 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1514,7 +1514,9 @@ static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,
 				continue;
 			}
 			bh->b_end_io = end_buffer_read_sync;
-			submit_bh(REQ_OP_READ, REQ_RAHEAD | REQ_META, bh);
+			submit_bh(REQ_OP_READ,
+				  REQ_RAHEAD | REQ_META | REQ_PRIO,
+				  bh);
 			continue;
 		}
 		brelse(bh);

commit 78dcf73421a879d22319d3889119945b85954a68
Merge: 93ff81859733 fdb254db21bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 15 12:00:42 2017 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull ->s_options removal from Al Viro:
     "Preparations for fsmount/fsopen stuff (coming next cycle). Everything
      gets moved to explicit ->show_options(), killing ->s_options off +
      some cosmetic bits around fs/namespace.c and friends. Basically, the
      stuff needed to work with fsmount series with minimum of conflicts
      with other work.
    
      It's not strictly required for this merge window, but it would reduce
      the PITA during the coming cycle, so it would be nice to have those
      bits and pieces out of the way"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      isofs: Fix isofs_show_options()
      VFS: Kill off s_options and helpers
      orangefs: Implement show_options
      9p: Implement show_options
      isofs: Implement show_options
      afs: Implement show_options
      affs: Implement show_options
      befs: Implement show_options
      spufs: Implement show_options
      bpf: Implement show_options
      ramfs: Implement show_options
      pstore: Implement show_options
      omfs: Implement show_options
      hugetlbfs: Implement show_options
      VFS: Don't use save/replace_mount_options if not using generic_show_options
      VFS: Provide empty name qstr
      VFS: Make get_filesystem() return the affected filesystem
      VFS: Clean up whitespace in fs/namespace.c and fs/super.c
      Provide a function to create a NUL-terminated string from unterminated data

commit cdf01226b26e98c79c13b335fbe0cbbbe850cf44
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 4 17:25:22 2017 +0100

    VFS: Provide empty name qstr
    
    Provide an empty name (ie. "") qstr for general use.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 79113219be5f..a5dfff6a033e 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -872,7 +872,6 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct buffer_head *bh;
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;
-	struct qstr name = { .name = "" };
 	struct timespec tv = current_time(inode);
 
 	error = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);
@@ -896,7 +895,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	leaf->lf_sec = cpu_to_be64(tv.tv_sec);
 	memset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));
 	dent = (struct gfs2_dirent *)(leaf+1);
-	gfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);
+	gfs2_qstr2dirent(&empty_name, bh->b_size - sizeof(struct gfs2_leaf), dent);
 	*pbh = bh;
 	return leaf;
 }

commit 6f6597baae206c544c49ad7f1129d5adc1e9019d
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Jun 30 07:55:08 2017 -0500

    gfs2: Protect gl->gl_object by spin lock
    
    Put all remaining accesses to gl->gl_object under the
    gl->gl_lockref.lock spinlock to prevent races.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 96a7487b09b6..db427658ccd9 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2032,8 +2032,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	gfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);
 
 	for (x = 0; x < rlist.rl_rgrps; x++) {
-		struct gfs2_rgrpd *rgd;
-		rgd = rlist.rl_ghs[x].gh_gl->gl_object;
+		struct gfs2_rgrpd *rgd = gfs2_glock2rgrp(rlist.rl_ghs[x].gh_gl);
+
 		rg_blocks += rgd->rd_length;
 	}
 

commit d87d62b75dfd8d33dc1baf0c4d3792788b554661
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri May 26 08:28:56 2017 -0500

    GFS2: Withdraw when directory entry inconsistencies are detected
    
    This patch prints an inode consistency error and withdraws the file
    system when directory entry counts are mismatched.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 79113219be5f..96a7487b09b6 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1444,7 +1444,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 						"g.offset (%u)\n",
 					(unsigned long long)bh->b_blocknr,
 					entries2, g.offset);
-					
+				gfs2_consist_inode(ip);
 				error = -EIO;
 				goto out_free;
 			}
@@ -1612,6 +1612,7 @@ int gfs2_dir_read(struct inode *inode, struct dir_context *ctx,
 				(unsigned long long)dip->i_no_addr,
 				dip->i_entries,
 				g.offset);
+			gfs2_consist_inode(dip);
 			error = -EIO;
 			goto out;
 		}

commit 2f8b544477e627a42e66902e948d87f86554aeca
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:13 2016 -0600

    block,fs: untangle fs.h and blk_types.h
    
    Nothing in fs.h should require blk_types.h to be included.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 3cdde5f5d399..79113219be5f 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -62,6 +62,7 @@
 #include <linux/gfs2_ondisk.h>
 #include <linux/crc32.h>
 #include <linux/vmalloc.h>
+#include <linux/bio.h>
 
 #include "gfs2.h"
 #include "incore.h"

commit 101105b1717f536ca741f940033996302d4ef191
Merge: 35ff96dfd3c9 3873691e5ab3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 20:16:43 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     ">rename2() work from Miklos + current_time() from Deepa"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: Replace current_fs_time() with current_time()
      fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
      fs: Replace CURRENT_TIME with current_time() for inode timestamps
      fs: proc: Delete inode time initializations in proc_alloc_inode()
      vfs: Add current_time() api
      vfs: add note about i_op->rename changes to porting
      fs: rename "rename2" i_op to "rename"
      vfs: remove unused i_op->rename
      fs: make remaining filesystems use .rename2
      libfs: support RENAME_NOREPLACE in simple_rename()
      fs: support RENAME_NOREPLACE for local filesystems
      ncpfs: fix unused variable warning

commit 078cd8279e659989b103359bb22373cc79445bde
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Sep 14 07:48:04 2016 -0700

    fs: Replace CURRENT_TIME with current_time() for inode timestamps
    
    CURRENT_TIME macro is not appropriate for filesystems as it
    doesn't use the right granularity for filesystem timestamps.
    Use current_time() instead.
    
    CURRENT_TIME is also not y2038 safe.
    
    This is also in preparation for the patch that transitions
    vfs timestamps to use 64 bit time and hence make them
    y2038 safe. As part of the effort current_time() will be
    extended to do range checks. Hence, it is necessary for all
    file system timestamps to use current_time(). Also,
    current_time() will be transitioned along with vfs to be
    y2038 safe.
    
    Note that whenever a single call to current_time() is used
    to change timestamps in different inodes, it is because they
    share the same time granularity.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Felipe Balbi <balbi@kernel.org>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>
    Acked-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Acked-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index fcb59b23f1e3..f75c9aef9f94 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -135,7 +135,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
 	if (ip->i_inode.i_size < offset + size)
 		i_size_write(&ip->i_inode, offset + size);
-	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
+	ip->i_inode.i_mtime = ip->i_inode.i_ctime = current_time(&ip->i_inode);
 	gfs2_dinode_out(ip, dibh->b_data);
 
 	brelse(dibh);
@@ -233,7 +233,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 
 	if (ip->i_inode.i_size < offset + copied)
 		i_size_write(&ip->i_inode, offset + copied);
-	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
+	ip->i_inode.i_mtime = ip->i_inode.i_ctime = current_time(&ip->i_inode);
 
 	gfs2_trans_add_meta(ip->i_gl, dibh);
 	gfs2_dinode_out(ip, dibh->b_data);
@@ -872,7 +872,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;
 	struct qstr name = { .name = "" };
-	struct timespec tv = CURRENT_TIME;
+	struct timespec tv = current_time(inode);
 
 	error = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);
 	if (error)
@@ -1816,7 +1816,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			gfs2_inum_out(nip, dent);
 			dent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));
 			dent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));
-			tv = CURRENT_TIME;
+			tv = current_time(&ip->i_inode);
 			if (ip->i_diskflags & GFS2_DIF_EXHASH) {
 				leaf = (struct gfs2_leaf *)bh->b_data;
 				be16_add_cpu(&leaf->lf_entries, 1);
@@ -1878,7 +1878,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)
 	const struct qstr *name = &dentry->d_name;
 	struct gfs2_dirent *dent, *prev = NULL;
 	struct buffer_head *bh;
-	struct timespec tv = CURRENT_TIME;
+	struct timespec tv = current_time(&dip->i_inode);
 
 	/* Returns _either_ the entry (if its first in block) or the
 	   previous entry otherwise */
@@ -1960,7 +1960,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 		gfs2_trans_add_meta(dip->i_gl, bh);
 	}
 
-	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
+	dip->i_inode.i_mtime = dip->i_inode.i_ctime = current_time(&dip->i_inode);
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	return 0;

commit 47a9a527946842dd8d83d4c8c8be22b2615b65f5
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue Aug 2 12:05:27 2016 -0500

    GFS2: use BIT() macro
    
    Replace 1 << value shift by more explicit BIT() macro
    
    Also fixes two bare unsigned definitions:
    
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    +               unsigned hsize = BIT(ip->i_depth);
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index fcb59b23f1e3..db8fbeb62483 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -351,7 +351,7 @@ static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)
 	if (hc)
 		return hc;
 
-	hsize = 1 << ip->i_depth;
+	hsize = BIT(ip->i_depth);
 	hsize *= sizeof(__be64);
 	if (hsize != i_size_read(&ip->i_inode)) {
 		gfs2_consist_inode(ip);
@@ -819,8 +819,8 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 
 	if (ip->i_diskflags & GFS2_DIF_EXHASH) {
 		struct gfs2_leaf *leaf;
-		unsigned hsize = 1 << ip->i_depth;
-		unsigned index;
+		unsigned int hsize = BIT(ip->i_depth);
+		unsigned int index;
 		u64 ln;
 		if (hsize * sizeof(u64) != i_size_read(inode)) {
 			gfs2_consist_inode(ip);
@@ -932,7 +932,7 @@ static int dir_make_exhash(struct inode *inode)
 		return -ENOSPC;
 	bn = bh->b_blocknr;
 
-	gfs2_assert(sdp, dip->i_entries < (1 << 16));
+	gfs2_assert(sdp, dip->i_entries < BIT(16));
 	leaf->lf_entries = cpu_to_be16(dip->i_entries);
 
 	/*  Copy dirents  */
@@ -1041,7 +1041,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	bn = nbh->b_blocknr;
 
 	/*  Compute the start and len of leaf pointers in the hash table.  */
-	len = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));
+	len = BIT(dip->i_depth - be16_to_cpu(oleaf->lf_depth));
 	half_len = len >> 1;
 	if (!half_len) {
 		pr_warn("i_depth %u lf_depth %u index %u\n",
@@ -1163,7 +1163,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	int x;
 	int error = 0;
 
-	hsize = 1 << dip->i_depth;
+	hsize = BIT(dip->i_depth);
 	hsize_bytes = hsize * sizeof(__be64);
 
 	hc = gfs2_dir_get_hash_table(dip);
@@ -1539,7 +1539,7 @@ static int dir_e_read(struct inode *inode, struct dir_context *ctx,
 	int error = 0;
 	unsigned depth = 0;
 
-	hsize = 1 << dip->i_depth;
+	hsize = BIT(dip->i_depth);
 	hash = gfs2_dir_offset2hash(ctx->pos);
 	index = hash >> (32 - dip->i_depth);
 
@@ -1558,7 +1558,7 @@ static int dir_e_read(struct inode *inode, struct dir_context *ctx,
 		if (error)
 			break;
 
-		len = 1 << (dip->i_depth - depth);
+		len = BIT(dip->i_depth - depth);
 		index = (index & ~(len - 1)) + len;
 	}
 
@@ -2113,7 +2113,7 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 	u64 leaf_no;
 	int error = 0, last;
 
-	hsize = 1 << dip->i_depth;
+	hsize = BIT(dip->i_depth);
 
 	lp = gfs2_dir_get_hash_table(dip);
 	if (IS_ERR(lp))
@@ -2126,7 +2126,7 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 			if (error)
 				goto out;
 			leaf = (struct gfs2_leaf *)bh->b_data;
-			len = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));
+			len = BIT(dip->i_depth - be16_to_cpu(leaf->lf_depth));
 
 			next_index = (index & ~(len - 1)) + len;
 			last = ((next_index >= hsize) ? 1 : 0);

commit 3fc9d690936fb2e20e180710965ba2cc3a0881f8
Merge: d05d7f40791c 13880f5b57ad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 26 15:37:51 2016 -0700

    Merge branch 'for-4.8/drivers' of git://git.kernel.dk/linux-block
    
    Pull block driver updates from Jens Axboe:
     "This branch also contains core changes.  I've come to the conclusion
      that from 4.9 and forward, I'll be doing just a single branch.  We
      often have dependencies between core and drivers, and it's hard to
      always split them up appropriately without pulling core into drivers
      when that happens.
    
      That said, this contains:
    
       - separate secure erase type for the core block layer, from
         Christoph.
    
       - set of discard fixes, from Christoph.
    
       - bio shrinking fixes from Christoph, as a followup up to the
         op/flags change in the core branch.
    
       - map and append request fixes from Christoph.
    
       - NVMeF (NVMe over Fabrics) code from Christoph.  This is pretty
         exciting!
    
       - nvme-loop fixes from Arnd.
    
       - removal of ->driverfs_dev from Dan, after providing a
         device_add_disk() helper.
    
       - bcache fixes from Bhaktipriya and Yijing.
    
       - cdrom subchannel read fix from Vchannaiah.
    
       - set of lightnvm updates from Wenwei, Matias, Johannes, and Javier.
    
       - set of drbd updates and fixes from Fabian, Lars, and Philipp.
    
       - mg_disk error path fix from Bart.
    
       - user notification for failed device add for loop, from Minfei.
    
       - NVMe in general:
            + NVMe delay quirk from Guilherme.
            + SR-IOV support and command retry limits from Keith.
            + fix for memory-less NUMA node from Masayoshi.
            + use UINT_MAX for discard sectors, from Minfei.
            + cancel IO fixes from Ming.
            + don't allocate unused major, from Neil.
            + error code fixup from Dan.
            + use constants for PSDT/FUSE from James.
            + variable init fix from Jay.
            + fabrics fixes from Ming, Sagi, and Wei.
            + various fixes"
    
    * 'for-4.8/drivers' of git://git.kernel.dk/linux-block: (115 commits)
      nvme/pci: Provide SR-IOV support
      nvme: initialize variable before logical OR'ing it
      block: unexport various bio mapping helpers
      scsi/osd: open code blk_make_request
      target: stop using blk_make_request
      block: simplify and export blk_rq_append_bio
      block: ensure bios return from blk_get_request are properly initialized
      virtio_blk: use blk_rq_map_kern
      memstick: don't allow REQ_TYPE_BLOCK_PC requests
      block: shrink bio size again
      block: simplify and cleanup bvec pool handling
      block: get rid of bio_rw and READA
      block: don't ignore -EOPNOTSUPP blkdev_issue_write_same
      block: introduce BLKDEV_DISCARD_ZERO to fix zeroout
      NVMe: don't allocate unused nvme_major
      nvme: avoid crashes when node 0 is memoryless node.
      nvme: Limit command retries
      loop: Make user notify for adding loop device failed
      nvme-loop: fix nvme-loop Kconfig dependencies
      nvmet: fix return value check in nvmet_subsys_alloc()
      ...

commit d05d7f40791ccbb6e543cc5dd6a6aa08fc71d635
Merge: 75a442efb1ca 17007f3994cd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 26 15:03:07 2016 -0700

    Merge branch 'for-4.8/core' of git://git.kernel.dk/linux-block
    
    Pull core block updates from Jens Axboe:
    
       - the big change is the cleanup from Mike Christie, cleaning up our
         uses of command types and modified flags.  This is what will throw
         some merge conflicts
    
       - regression fix for the above for btrfs, from Vincent
    
       - following up to the above, better packing of struct request from
         Christoph
    
       - a 2038 fix for blktrace from Arnd
    
       - a few trivial/spelling fixes from Bart Van Assche
    
       - a front merge check fix from Damien, which could cause issues on
         SMR drives
    
       - Atari partition fix from Gabriel
    
       - convert cfq to highres timers, since jiffies isn't granular enough
         for some devices these days.  From Jan and Jeff
    
       - CFQ priority boost fix idle classes, from me
    
       - cleanup series from Ming, improving our bio/bvec iteration
    
       - a direct issue fix for blk-mq from Omar
    
       - fix for plug merging not involving the IO scheduler, like we do for
         other types of merges.  From Tahsin
    
       - expose DAX type internally and through sysfs.  From Toshi and Yigal
    
    * 'for-4.8/core' of git://git.kernel.dk/linux-block: (76 commits)
      block: Fix front merge check
      block: do not merge requests without consulting with io scheduler
      block: Fix spelling in a source code comment
      block: expose QUEUE_FLAG_DAX in sysfs
      block: add QUEUE_FLAG_DAX for devices to advertise their DAX support
      Btrfs: fix comparison in __btrfs_map_block()
      block: atari: Return early for unsupported sector size
      Doc: block: Fix a typo in queue-sysfs.txt
      cfq-iosched: Charge at least 1 jiffie instead of 1 ns
      cfq-iosched: Fix regression in bonnie++ rewrite performance
      cfq-iosched: Convert slice_resid from u64 to s64
      block: Convert fifo_time from ulong to u64
      blktrace: avoid using timespec
      block/blk-cgroup.c: Declare local symbols static
      block/bio-integrity.c: Add #include "blk.h"
      block/partition-generic.c: Remove a set-but-not-used variable
      block: bio: kill BIO_MAX_SIZE
      cfq-iosched: temporarily boost queue priority for idle classes
      block: drbd: avoid to use BIO_MAX_SIZE
      block: bio: remove BIO_MAX_SECTORS
      ...

commit b403f230448ed687edcc460cd46de652bc686b12
Merge: 523d939ef98f e1cb6be9e142
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 24 16:07:52 2016 -0700

    Merge tag 'gfs2-4.7.fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/gfs2/linux-gfs2
    
    Pull gfs2 updates from Bob Peterson:
     "We've got ten patches this time, half of which are related to a
      plethora of nasty outcomes when inodes are transitioned from the
      unlinked state to the free state.  Small file systems are particularly
      vulnerable to these problems, and it can manifest as mainly hangs, but
      also file system corruption.  The patches have been tested for
      literally many weeks, with a very gruelling test, so I have a high
      level of confidence.
    
       - Andreas Gruenbacher wrote a series of five patches for various
         lockups during the transition of inodes from unlinked to free.
    
         The main patch is titled "Fix gfs2_lookup_by_inum lock inversion"
         and the other four are support and cleanup patches related to that.
    
       - Ben Marzinski contributed two patches with regard to a recreatable
         problem when gfs2 tries to write a page to a file that is being
         truncated, resulting in a BUG() in gfs2_remove_from_journal.
    
         Note that Ben had to export vfs function __block_write_full_page to
         get this to work properly.  It's been posted a long time and he
         talked to various VFS people about it, and nobody seemed to mind.
    
       - I contributed 3 patches:
           o The first one fixes a memory corruptor: a race in which one
             process can overwrite the gl_object pointer set by another
             process, causing kernel panic and other symptoms.
           o The second patch fixes another race that resulted in a
             false-positive BUG_ON.  This occurred when resource group
             reservations were freed by one process while another process
             was trying to grab a new reservation in the same resource
             group.
           o The third patch fixes a problem with doing journal replay when
             the journals are not all the same size"
    
    * tag 'gfs2-4.7.fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/gfs2/linux-gfs2:
      GFS2: Fix gfs2_replay_incr_blk for multiple journal sizes
      GFS2: Check rs_free with rd_rsspin protection
      gfs2: writeout truncated pages
      fs: export __block_write_full_page
      gfs2: Lock holder cleanup
      gfs2: Large-filesystem fix for 32-bit systems
      gfs2: Get rid of gfs2_ilookup
      gfs2: Fix gfs2_lookup_by_inum lock inversion
      gfs2: Initialize iopen glock holder for new inodes
      GFS2: don't set rgrp gl_object until it's inserted into rgrp tree

commit 70246286e94c335b5bea0cbc68a17a96dd620281
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jul 19 11:28:41 2016 +0200

    block: get rid of bio_rw and READA
    
    These two are confusing leftover of the old world order, combining
    values of the REQ_OP_ and REQ_ namespaces.  For callers that don't
    special case we mostly just replace bi_rw with bio_data_dir or
    op_is_write, except for the few cases where a switch over the REQ_OP_
    values makes more sense.  Any check for READA is replaced with an
    explicit check for REQ_RAHEAD.  Also remove the READA alias for
    REQ_RAHEAD.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Mike Christie <mchristi@redhat.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 0fbb42679cef..f077cf5796ee 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1513,7 +1513,7 @@ static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,
 				continue;
 			}
 			bh->b_end_io = end_buffer_read_sync;
-			submit_bh(REQ_OP_READ, READA | REQ_META, bh);
+			submit_bh(REQ_OP_READ, REQ_RAHEAD | REQ_META, bh);
 			continue;
 		}
 		brelse(bh);

commit 3ce37b2cb4917674fa5b776e857dcea94c0e0835
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Tue Jun 14 12:22:27 2016 -0500

    gfs2: Fix gfs2_lookup_by_inum lock inversion
    
    The current gfs2_lookup_by_inum takes the glock of a presumed inode
    identified by block number, verifies that the block is indeed an inode,
    and then instantiates and reads the new inode via gfs2_inode_lookup.
    
    However, instantiating a new inode may block on freeing a previous
    instance of that inode (__wait_on_freeing_inode), and freeing an inode
    requires to take the glock already held, leading to lock inversion and
    deadlock.
    
    Fix this by first instantiating the new inode, then verifying that the
    block is an inode (if required), and then reading in the new inode, all
    in gfs2_inode_lookup.
    
    If the block we are looking for is not an inode, we discard the new
    inode via iget_failed, which marks inodes as bad and unhashes them.
    Other tasks waiting on that inode will get back a bad inode back from
    ilookup or iget_locked; in that case, retry the lookup.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 4a01f30e9995..1b02665357b2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1660,7 +1660,8 @@ struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,
 		brelse(bh);
 		if (fail_on_exist)
 			return ERR_PTR(-EEXIST);
-		inode = gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino);
+		inode = gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino,
+					  GFS2_BLKST_FREE /* ignore */);
 		if (!IS_ERR(inode))
 			GFS2_I(inode)->i_rahead = rahead;
 		return inode;

commit 2a222ca992c35aee1e83af428f3dd26a3f5d5d94
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:31:43 2016 -0500

    fs: have submit_bh users pass in op and flags separately
    
    This has submit_bh users pass in the operation and flags separately,
    so submit_bh_wbc can setup the bio op and bi_rw flags on the bio that
    is submitted.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 271d93905bac..0fbb42679cef 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1513,7 +1513,7 @@ static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,
 				continue;
 			}
 			bh->b_end_io = end_buffer_read_sync;
-			submit_bh(READA | REQ_META, bh);
+			submit_bh(REQ_OP_READ, READA | REQ_META, bh);
 			continue;
 		}
 		brelse(bh);

commit 287980e49ffc0f6d911601e7e352a812ed27768e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri May 27 23:23:25 2016 +0200

    remove lots of IS_ERR_VALUE abuses
    
    Most users of IS_ERR_VALUE() in the kernel are wrong, as they
    pass an 'int' into a function that takes an 'unsigned long'
    argument. This happens to work because the type is sign-extended
    on 64-bit architectures before it gets converted into an
    unsigned type.
    
    However, anything that passes an 'unsigned short' or 'unsigned int'
    argument into IS_ERR_VALUE() is guaranteed to be broken, as are
    8-bit integers and types that are wider than 'unsigned long'.
    
    Andrzej Hajda has already fixed a lot of the worst abusers that
    were causing actual bugs, but it would be nice to prevent any
    users that are not passing 'unsigned long' arguments.
    
    This patch changes all users of IS_ERR_VALUE() that I could find
    on 32-bit ARM randconfig builds and x86 allmodconfig. For the
    moment, this doesn't change the definition of IS_ERR_VALUE()
    because there are probably still architecture specific users
    elsewhere.
    
    Almost all the warnings I got are for files that are better off
    using 'if (err)' or 'if (err < 0)'.
    The only legitimate user I could find that we get a warning for
    is the (32-bit only) freescale fman driver, so I did not remove
    the IS_ERR_VALUE() there but changed the type to 'unsigned long'.
    For 9pfs, I just worked around one user whose calling conventions
    are so obscure that I did not dare change the behavior.
    
    I was using this definition for testing:
    
     #define IS_ERR_VALUE(x) ((unsigned long*)NULL == (typeof (x)*)NULL && \
           unlikely((unsigned long long)(x) >= (unsigned long long)(typeof(x))-MAX_ERRNO))
    
    which ends up making all 16-bit or wider types work correctly with
    the most plausible interpretation of what IS_ERR_VALUE() was supposed
    to return according to its users, but also causes a compile-time
    warning for any users that do not pass an 'unsigned long' argument.
    
    I suggested this approach earlier this year, but back then we ended
    up deciding to just fix the users that are obviously broken. After
    the initial warning that caused me to get involved in the discussion
    (fs/gfs2/dir.c) showed up again in the mainline kernel, Linus
    asked me to send the whole thing again.
    
    [ Updated the 9p parts as per Al Viro  - Linus ]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: https://lkml.org/lkml/2016/1/7/363
    Link: https://lkml.org/lkml/2016/5/27/486
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org> # For nvmem part
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 4a01f30e9995..271d93905bac 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -783,12 +783,15 @@ static int get_leaf_nr(struct gfs2_inode *dip, u32 index,
 		       u64 *leaf_out)
 {
 	__be64 *hash;
+	int error;
 
 	hash = gfs2_dir_get_hash_table(dip);
-	if (IS_ERR(hash))
-		return PTR_ERR(hash);
-	*leaf_out = be64_to_cpu(*(hash + index));
-	return 0;
+	error = PTR_ERR_OR_ZERO(hash);
+
+	if (!error)
+		*leaf_out = be64_to_cpu(*(hash + index));
+
+	return error;
 }
 
 static int get_first_leaf(struct gfs2_inode *dip, u32 index,
@@ -798,7 +801,7 @@ static int get_first_leaf(struct gfs2_inode *dip, u32 index,
 	int error;
 
 	error = get_leaf_nr(dip, index, &leaf_no);
-	if (!IS_ERR_VALUE(error))
+	if (!error)
 		error = get_leaf(dip, leaf_no, bh_out);
 
 	return error;
@@ -1014,7 +1017,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 	index = name->hash >> (32 - dip->i_depth);
 	error = get_leaf_nr(dip, index, &leaf_no);
-	if (IS_ERR_VALUE(error))
+	if (error)
 		return error;
 
 	/*  Get the old leaf block  */

commit 73b462d2808d7cbca4d7886cf6aaed850640e6cd
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Dec 18 11:44:49 2015 -0600

    GFS2: Eliminate parameter non_block on gfs2_inode_lookup
    
    Now that we're not filtering out I_FREEING inodes from our lookups
    anymore, we can eliminate the non_block parameter from the lookup
    function.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d4014af4f064..4a01f30e9995 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1660,7 +1660,7 @@ struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,
 		brelse(bh);
 		if (fail_on_exist)
 			return ERR_PTR(-EEXIST);
-		inode = gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);
+		inode = gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino);
 		if (!IS_ERR(inode))
 			GFS2_I(inode)->i_rahead = rahead;
 		return inode;

commit 67893f12e5374bbcaaffbc6e570acbc2714ea884
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jan 26 13:08:10 2016 -0500

    gfs2: avoid uninitialized variable warning
    
    We get a bogus warning about a potential uninitialized variable
    use in gfs2, because the compiler does not figure out that we
    never use the leaf number if get_leaf_nr() returns an error:
    
    fs/gfs2/dir.c: In function 'get_first_leaf':
    fs/gfs2/dir.c:802:9: warning: 'leaf_no' may be used uninitialized in this function [-Wmaybe-uninitialized]
    fs/gfs2/dir.c: In function 'dir_split_leaf':
    fs/gfs2/dir.c:1021:8: warning: 'leaf_no' may be used uninitialized in this function [-Wmaybe-uninitialized]
    
    Changing the 'if (!error)' to 'if (!IS_ERR_VALUE(error))' is
    sufficient to let gcc understand that this is exactly the same
    condition as in IS_ERR() so it can optimize the code path enough
    to understand it.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 6a92592304fb..d4014af4f064 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -798,7 +798,7 @@ static int get_first_leaf(struct gfs2_inode *dip, u32 index,
 	int error;
 
 	error = get_leaf_nr(dip, index, &leaf_no);
-	if (!error)
+	if (!IS_ERR_VALUE(error))
 		error = get_leaf(dip, leaf_no, bh_out);
 
 	return error;
@@ -1014,7 +1014,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 	index = name->hash >> (32 - dip->i_depth);
 	error = get_leaf_nr(dip, index, &leaf_no);
-	if (error)
+	if (IS_ERR_VALUE(error))
 		return error;
 
 	/*  Get the old leaf block  */

commit 471f3db2786bc32011d6693413eb93b0c3da2579
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue Dec 1 08:46:55 2015 -0600

    gfs2: change gfs2 readdir cookie
    
    gfs2 currently returns 31 bits of filename hash as a cookie that readdir
    uses for an offset into the directory.  When there are a large number of
    directory entries, the likelihood of a collision goes up way too
    quickly.  GFS2 will now return cookies that are guaranteed unique for a
    while, and then fail back to using 30 bits of filename hash.
    Specifically, the directory leaf blocks are divided up into chunks based
    on the minimum size of a gfs2 directory entry (48 bytes). Each entry's
    cookie is based off the chunk where it starts, in the linked list of
    leaf blocks that it hashes to (there are 131072 hash buckets). Directory
    entries will have unique names until they take reach chunk 8192.
    Assuming the largest filenames possible, and the least efficient spacing
    possible, this new method will still be able to return unique names when
    the previous method has statistically more than a 99% chance of a
    collision.  The non-unique names it fails back to are guaranteed to not
    collide with the unique names.
    
    unique cookies will be in this format:
    - 1 bit "0" to make sure the the returned cookie is positive
    - 17 bits for the hash table index
    - 1 bit for the mode "0"
    - 13 bits for the offset
    
    non-unique cookies will be in this format:
    - 1 bit "0" to make sure the the returned cookie is positive
    - 17 bits for the hash table index
    - 1 bit for the mode "1"
    - 13 more bits of the name hash
    
    Another benefit of location based cookies, is that once a directory's
    exhash table is fully extended (so that multiple hash table indexs do
    not use the same leaf blocks), gfs2 can skip sorting the directory
    entries until it reaches the non-unique ones, and then it only needs to
    sort these. This provides a significant speed up for directory reads of
    very large directories.
    
    The only issue is that for these cookies to continue to point to the
    correct entry as files are added and removed from the directory, gfs2
    must keep the entries at the same offset in the leaf block when they are
    split (see my previous patch). This means that until all the nodes in a
    cluster are running with code that will split the directory leaf blocks
    this way, none of the nodes can use the new cookie code. To deal with
    this, gfs2 now has the mount option loccookie, which, if set, will make
    it return these new location based cookies.  This option must not be set
    until all nodes in the cluster are at least running this version of the
    kernel code, and you have guaranteed that there are no outstanding
    cookies required by other software, such as NFS.
    
    gfs2 uses some of the extra space at the end of the gfs2_dirent
    structure to store the calculated readdir cookies. This keeps us from
    needing to allocate a seperate array to hold these values.  gfs2
    recomputes the cookie stored in de_cookie for every readdir call.  The
    time it takes to do so is small, and if gfs2 expected this value to be
    saved on disk, the new code wouldn't work correctly on filesystems
    created with an earlier version of gfs2.
    
    One issue with adding de_cookie to the union in the gfs2_dirent
    structure is that it caused the union to align itself to a 4 byte
    boundary, instead of its previous 2 byte boundary. This changed the
    offset of de_rahead. To solve that, I pulled de_rahead out of the union,
    since it does not need to be there.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 4ee008c6d64b..6a92592304fb 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -82,6 +82,8 @@
 
 #define gfs2_disk_hash2offset(h) (((u64)(h)) >> 1)
 #define gfs2_dir_offset2hash(p) ((u32)(((u64)(p)) << 1))
+#define GFS2_HASH_INDEX_MASK 0xffffc000
+#define GFS2_USE_HASH_FLAG 0x2000
 
 struct qstr gfs2_qdot __read_mostly;
 struct qstr gfs2_qdotdot __read_mostly;
@@ -1223,10 +1225,10 @@ static int compare_dents(const void *a, const void *b)
 	int ret = 0;
 
 	dent_a = *(const struct gfs2_dirent **)a;
-	hash_a = be32_to_cpu(dent_a->de_hash);
+	hash_a = dent_a->de_cookie;
 
 	dent_b = *(const struct gfs2_dirent **)b;
-	hash_b = be32_to_cpu(dent_b->de_hash);
+	hash_b = dent_b->de_cookie;
 
 	if (hash_a > hash_b)
 		ret = 1;
@@ -1264,19 +1266,20 @@ static int compare_dents(const void *a, const void *b)
  */
 
 static int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,
-			   const struct gfs2_dirent **darr, u32 entries,
-			   int *copied)
+			   struct gfs2_dirent **darr, u32 entries,
+			   u32 sort_start, int *copied)
 {
 	const struct gfs2_dirent *dent, *dent_next;
 	u64 off, off_next;
 	unsigned int x, y;
 	int run = 0;
 
-	sort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);
+	if (sort_start < entries)
+		sort(&darr[sort_start], entries - sort_start,
+		     sizeof(struct gfs2_dirent *), compare_dents, NULL);
 
 	dent_next = darr[0];
-	off_next = be32_to_cpu(dent_next->de_hash);
-	off_next = gfs2_disk_hash2offset(off_next);
+	off_next = dent_next->de_cookie;
 
 	for (x = 0, y = 1; x < entries; x++, y++) {
 		dent = dent_next;
@@ -1284,8 +1287,7 @@ static int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,
 
 		if (y < entries) {
 			dent_next = darr[y];
-			off_next = be32_to_cpu(dent_next->de_hash);
-			off_next = gfs2_disk_hash2offset(off_next);
+			off_next = dent_next->de_cookie;
 
 			if (off < ctx->pos)
 				continue;
@@ -1332,6 +1334,40 @@ static void *gfs2_alloc_sort_buffer(unsigned size)
 	return ptr;
 }
 
+
+static int gfs2_set_cookies(struct gfs2_sbd *sdp, struct buffer_head *bh,
+			    unsigned leaf_nr, struct gfs2_dirent **darr,
+			    unsigned entries)
+{
+	int sort_id = -1;
+	int i;
+	
+	for (i = 0; i < entries; i++) {
+		unsigned offset;
+
+		darr[i]->de_cookie = be32_to_cpu(darr[i]->de_hash);
+		darr[i]->de_cookie = gfs2_disk_hash2offset(darr[i]->de_cookie);
+
+		if (!sdp->sd_args.ar_loccookie)
+			continue;
+		offset = (char *)(darr[i]) -
+			 (bh->b_data + gfs2_dirent_offset(bh->b_data));
+		offset /= GFS2_MIN_DIRENT_SIZE;
+		offset += leaf_nr * sdp->sd_max_dents_per_leaf;
+		if (offset >= GFS2_USE_HASH_FLAG ||
+		    leaf_nr >= GFS2_USE_HASH_FLAG) {
+			darr[i]->de_cookie |= GFS2_USE_HASH_FLAG;
+			if (sort_id < 0)
+				sort_id = i;
+			continue;
+		}
+		darr[i]->de_cookie &= GFS2_HASH_INDEX_MASK;
+		darr[i]->de_cookie |= offset;
+	}
+	return sort_id;
+}	
+
+
 static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 			      int *copied, unsigned *depth,
 			      u64 leaf_no)
@@ -1341,12 +1377,11 @@ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 	struct buffer_head *bh;
 	struct gfs2_leaf *lf;
 	unsigned entries = 0, entries2 = 0;
-	unsigned leaves = 0;
-	const struct gfs2_dirent **darr, *dent;
+	unsigned leaves = 0, leaf = 0, offset, sort_offset;
+	struct gfs2_dirent **darr, *dent;
 	struct dirent_gather g;
 	struct buffer_head **larr;
-	int leaf = 0;
-	int error, i;
+	int error, i, need_sort = 0, sort_id;
 	u64 lfn = leaf_no;
 
 	do {
@@ -1362,6 +1397,11 @@ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 		brelse(bh);
 	} while(lfn);
 
+	if (*depth < GFS2_DIR_MAX_DEPTH || !sdp->sd_args.ar_loccookie) {
+		need_sort = 1;
+		sort_offset = 0;
+	}
+
 	if (!entries)
 		return 0;
 
@@ -1375,8 +1415,8 @@ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 	larr = gfs2_alloc_sort_buffer((leaves + entries + 99) * sizeof(void *));
 	if (!larr)
 		goto out;
-	darr = (const struct gfs2_dirent **)(larr + leaves);
-	g.pdent = darr;
+	darr = (struct gfs2_dirent **)(larr + leaves);
+	g.pdent = (const struct gfs2_dirent **)darr;
 	g.offset = 0;
 	lfn = leaf_no;
 
@@ -1387,6 +1427,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 		lf = (struct gfs2_leaf *)bh->b_data;
 		lfn = be64_to_cpu(lf->lf_next);
 		if (lf->lf_entries) {
+			offset = g.offset;
 			entries2 += be16_to_cpu(lf->lf_entries);
 			dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,
 						gfs2_dirent_gather, NULL, &g);
@@ -1404,17 +1445,26 @@ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 				goto out_free;
 			}
 			error = 0;
+			sort_id = gfs2_set_cookies(sdp, bh, leaf, &darr[offset],
+						   be16_to_cpu(lf->lf_entries));
+			if (!need_sort && sort_id >= 0) {
+				need_sort = 1;
+				sort_offset = offset + sort_id;
+			}
 			larr[leaf++] = bh;
 		} else {
+			larr[leaf++] = NULL;
 			brelse(bh);
 		}
 	} while(lfn);
 
 	BUG_ON(entries2 != entries);
-	error = do_filldir_main(ip, ctx, darr, entries, copied);
+	error = do_filldir_main(ip, ctx, darr, entries, need_sort ?
+				sort_offset : entries, copied);
 out_free:
 	for(i = 0; i < leaf; i++)
-		brelse(larr[i]);
+		if (larr[i])
+			brelse(larr[i]);
 	kvfree(larr);
 out:
 	return error;
@@ -1520,7 +1570,7 @@ int gfs2_dir_read(struct inode *inode, struct dir_context *ctx,
 	struct gfs2_inode *dip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct dirent_gather g;
-	const struct gfs2_dirent **darr, *dent;
+	struct gfs2_dirent **darr, *dent;
 	struct buffer_head *dibh;
 	int copied = 0;
 	int error;
@@ -1544,7 +1594,7 @@ int gfs2_dir_read(struct inode *inode, struct dir_context *ctx,
 	/* 96 is max number of dirents which can be stuffed into an inode */
 	darr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_NOFS);
 	if (darr) {
-		g.pdent = darr;
+		g.pdent = (const struct gfs2_dirent **)darr;
 		g.offset = 0;
 		dent = gfs2_dirent_scan(inode, dibh->b_data, dibh->b_size,
 					gfs2_dirent_gather, NULL, &g);
@@ -1561,8 +1611,9 @@ int gfs2_dir_read(struct inode *inode, struct dir_context *ctx,
 			error = -EIO;
 			goto out;
 		}
+		gfs2_set_cookies(sdp, dibh, 0, darr, dip->i_entries);
 		error = do_filldir_main(dip, ctx, darr,
-					dip->i_entries, &copied);
+					dip->i_entries, 0, &copied);
 out:
 		kfree(darr);
 	}

commit 340174722929d80a107120400bab527cfc7e47f1
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue Dec 1 08:30:34 2015 -0600

    gfs2: keep offset when splitting dir leaf blocks
    
    Currently, when gfs2 splits a directory leaf block, the dirents that
    need to be copied to the new leaf block are packed into the start of it.
    This is good for space efficiency. However, if gfs2 were to copy those
    dirents into the exact same offset in the new leaf block as they had in
    the old block, it would be able to generate a readdir cookie based on
    the dirent location, that would be guaranteed to be unique up well past
    where the current code is statistically almost guaranteed to have
    collisions. So, gfs2 now keeps the dirent's offset in the block the
    same when it copies it to the new leaf block.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c2486598fb87..4ee008c6d64b 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -443,6 +443,27 @@ static int gfs2_dirent_last(const struct gfs2_dirent *dent,
 	return 0;
 }
 
+/* Look for the dirent that contains the offset specified in data. Once we
+ * find that dirent, there must be space available there for the new dirent */
+static int gfs2_dirent_find_offset(const struct gfs2_dirent *dent,
+				  const struct qstr *name,
+				  void *ptr)
+{
+	unsigned required = GFS2_DIRENT_SIZE(name->len);
+	unsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
+	unsigned totlen = be16_to_cpu(dent->de_rec_len);
+
+	if (ptr < (void *)dent || ptr >= (void *)dent + totlen)
+		return 0;
+	if (gfs2_dirent_sentinel(dent))
+		actual = 0;
+	if (ptr < (void *)dent + actual)
+		return -1;
+	if ((void *)dent + totlen >= ptr + required)
+		return 1;
+	return -1;
+}
+
 static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,
 				  const struct qstr *name,
 				  void *opaque)
@@ -682,6 +703,27 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 	prev->de_rec_len = cpu_to_be16(prev_rec_len);
 }
 
+
+static struct gfs2_dirent *do_init_dirent(struct inode *inode,
+					  struct gfs2_dirent *dent,
+					  const struct qstr *name,
+					  struct buffer_head *bh,
+					  unsigned offset)
+{
+	struct gfs2_inode *ip = GFS2_I(inode);
+	struct gfs2_dirent *ndent;
+	unsigned totlen;
+
+	totlen = be16_to_cpu(dent->de_rec_len);
+	BUG_ON(offset + name->len > totlen);
+	gfs2_trans_add_meta(ip->i_gl, bh);
+	ndent = (struct gfs2_dirent *)((char *)dent + offset);
+	dent->de_rec_len = cpu_to_be16(offset);
+	gfs2_qstr2dirent(name, totlen - offset, ndent);
+	return ndent;
+}
+
+
 /*
  * Takes a dent from which to grab space as an argument. Returns the
  * newly created dent.
@@ -691,31 +733,25 @@ static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,
 					    const struct qstr *name,
 					    struct buffer_head *bh)
 {
-	struct gfs2_inode *ip = GFS2_I(inode);
-	struct gfs2_dirent *ndent;
-	unsigned offset = 0, totlen;
+	unsigned offset = 0;
 
 	if (!gfs2_dirent_sentinel(dent))
 		offset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
-	totlen = be16_to_cpu(dent->de_rec_len);
-	BUG_ON(offset + name->len > totlen);
-	gfs2_trans_add_meta(ip->i_gl, bh);
-	ndent = (struct gfs2_dirent *)((char *)dent + offset);
-	dent->de_rec_len = cpu_to_be16(offset);
-	gfs2_qstr2dirent(name, totlen - offset, ndent);
-	return ndent;
+	return do_init_dirent(inode, dent, name, bh, offset);
 }
 
-static struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,
-					     struct buffer_head *bh,
-					     const struct qstr *name)
+static struct gfs2_dirent *gfs2_dirent_split_alloc(struct inode *inode,
+						   struct buffer_head *bh,
+						   const struct qstr *name,
+						   void *ptr)
 {
 	struct gfs2_dirent *dent;
 	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,
-				gfs2_dirent_find_space, name, NULL);
+				gfs2_dirent_find_offset, name, ptr);
 	if (!dent || IS_ERR(dent))
 		return dent;
-	return gfs2_init_dirent(inode, dent, name, bh);
+	return do_init_dirent(inode, dent, name, bh,
+			      (unsigned)(ptr - (void *)dent));
 }
 
 static int get_leaf(struct gfs2_inode *dip, u64 leaf_no,
@@ -1051,10 +1087,11 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 		if (!gfs2_dirent_sentinel(dent) &&
 		    be32_to_cpu(dent->de_hash) < divider) {
 			struct qstr str;
+			void *ptr = ((char *)dent - obh->b_data) + nbh->b_data;
 			str.name = (char*)(dent+1);
 			str.len = be16_to_cpu(dent->de_name_len);
 			str.hash = be32_to_cpu(dent->de_hash);
-			new = gfs2_dirent_alloc(inode, nbh, &str);
+			new = gfs2_dirent_split_alloc(inode, nbh, &str, ptr);
 			if (IS_ERR(new)) {
 				error = PTR_ERR(new);
 				break;

commit c8d577038449a718ad0027d1790b6ef4441715d4
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Nov 11 15:00:35 2015 -0600

    gfs2: Extended attribute readahead
    
    When gfs2 allocates an inode and its extended attribute block next to
    each other at inode create time, the inode's directory entry indicates
    that in de_rahead.  In that case, we can readahead the extended
    attribute block when we read in the inode.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ad8a5b757cc7..c2486598fb87 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -108,7 +108,7 @@ static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,
 	struct buffer_head *bh;
 	int error;
 
-	error = gfs2_meta_read(ip->i_gl, block, DIO_WAIT, &bh);
+	error = gfs2_meta_read(ip->i_gl, block, DIO_WAIT, 0, &bh);
 	if (error)
 		return error;
 	if (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_JD)) {
@@ -305,7 +305,7 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, __be64 *buf,
 			BUG_ON(extlen < 1);
 			bh = gfs2_meta_ra(ip->i_gl, dblock, extlen);
 		} else {
-			error = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, &bh);
+			error = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, 0, &bh);
 			if (error)
 				goto fail;
 		}
@@ -723,7 +723,7 @@ static int get_leaf(struct gfs2_inode *dip, u64 leaf_no,
 {
 	int error;
 
-	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, bhp);
+	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, 0, bhp);
 	if (!error && gfs2_metatype_check(GFS2_SB(&dip->i_inode), *bhp, GFS2_METATYPE_LF)) {
 		/* pr_info("block num=%llu\n", leaf_no); */
 		error = -EIO;
@@ -1560,15 +1560,22 @@ struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,
 
 	dent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);
 	if (dent) {
+		struct inode *inode;
+		u16 rahead;
+
 		if (IS_ERR(dent))
 			return ERR_CAST(dent);
 		dtype = be16_to_cpu(dent->de_type);
+		rahead = be16_to_cpu(dent->de_rahead);
 		addr = be64_to_cpu(dent->de_inum.no_addr);
 		formal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);
 		brelse(bh);
 		if (fail_on_exist)
 			return ERR_PTR(-EEXIST);
-		return gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);
+		inode = gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);
+		if (!IS_ERR(inode))
+			GFS2_I(inode)->i_rahead = rahead;
+		return inode;
 	}
 	return ERR_PTR(-ENOENT);
 }

commit c36b97e9430defab4b52ee370c18745343d92f6d
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Oct 29 10:03:41 2015 -0500

    GFS2: Protect freeing directory hash table with i_lock spin_lock
    
    This patch changes function gfs2_dir_hash_inval so it uses the
    i_lock spin_lock to protect the in-core hash table, i_hash_cache.
    This will prevent double-frees due to a race between gfs2_evict_inode
    and inode invalidation.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 487527b42d94..ad8a5b757cc7 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -388,8 +388,13 @@ static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)
  */
 void gfs2_dir_hash_inval(struct gfs2_inode *ip)
 {
-	__be64 *hc = ip->i_hash_cache;
+	__be64 *hc;
+
+	spin_lock(&ip->i_inode.i_lock);
+	hc = ip->i_hash_cache;
 	ip->i_hash_cache = NULL;
+	spin_unlock(&ip->i_inode.i_lock);
+
 	kvfree(hc);
 }
 

commit e36cb0b89ce20b4f8786a57e8a6bc8476f577650
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jan 29 12:02:35 2015 +0000

    VFS: (Scripted) Convert S_ISLNK/DIR/REG(dentry->d_inode) to d_is_*(dentry)
    
    Convert the following where appropriate:
    
     (1) S_ISLNK(dentry->d_inode) to d_is_symlink(dentry).
    
     (2) S_ISREG(dentry->d_inode) to d_is_reg(dentry).
    
     (3) S_ISDIR(dentry->d_inode) to d_is_dir(dentry).  This is actually more
         complicated than it appears as some calls should be converted to
         d_can_lookup() instead.  The difference is whether the directory in
         question is a real dir with a ->lookup op or whether it's a fake dir with
         a ->d_automount op.
    
    In some circumstances, we can subsume checks for dentry->d_inode not being
    NULL into this, provided we the code isn't in a filesystem that expects
    d_inode to be NULL if the dirent really *is* negative (ie. if we're going to
    use d_inode() rather than d_backing_inode() to get the inode pointer).
    
    Note that the dentry type field may be set to something other than
    DCACHE_MISS_TYPE when d_inode is NULL in the case of unionmount, where the VFS
    manages the fall-through from a negative dentry to a lower layer.  In such a
    case, the dentry type of the negative union dentry is set to the same as the
    type of the lower dentry.
    
    However, if you know d_inode is not NULL at the call site, then you can use
    the d_is_xxx() functions even in a filesystem.
    
    There is one further complication: a 0,0 chardev dentry may be labelled
    DCACHE_WHITEOUT_TYPE rather than DCACHE_SPECIAL_TYPE.  Strictly, this was
    intended for special directory entry types that don't have attached inodes.
    
    The following perl+coccinelle script was used:
    
    use strict;
    
    my @callers;
    open($fd, 'git grep -l \'S_IS[A-Z].*->d_inode\' |') ||
        die "Can't grep for S_ISDIR and co. callers";
    @callers = <$fd>;
    close($fd);
    unless (@callers) {
        print "No matches\n";
        exit(0);
    }
    
    my @cocci = (
        '@@',
        'expression E;',
        '@@',
        '',
        '- S_ISLNK(E->d_inode->i_mode)',
        '+ d_is_symlink(E)',
        '',
        '@@',
        'expression E;',
        '@@',
        '',
        '- S_ISDIR(E->d_inode->i_mode)',
        '+ d_is_dir(E)',
        '',
        '@@',
        'expression E;',
        '@@',
        '',
        '- S_ISREG(E->d_inode->i_mode)',
        '+ d_is_reg(E)' );
    
    my $coccifile = "tmp.sp.cocci";
    open($fd, ">$coccifile") || die $coccifile;
    print($fd "$_\n") || die $coccifile foreach (@cocci);
    close($fd);
    
    foreach my $file (@callers) {
        chomp $file;
        print "Processing ", $file, "\n";
        system("spatch", "--sp-file", $coccifile, $file, "--in-place", "--no-show-diff") == 0 ||
            die "spatch failed";
    }
    
    [AV: overlayfs parts skipped]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 6371192961e2..487527b42d94 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1809,7 +1809,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)
 		gfs2_consist_inode(dip);
 	dip->i_entries--;
 	dip->i_inode.i_mtime = dip->i_inode.i_ctime = tv;
-	if (S_ISDIR(dentry->d_inode->i_mode))
+	if (d_is_dir(dentry))
 		drop_nlink(&dip->i_inode);
 	mark_inode_dirty(&dip->i_inode);
 

commit 7456a37d55ced3928fd96615fde0dd739985f0dc
Author: Oleg Drokin <green@linuxhacker.ru>
Date:   Sun Feb 1 22:59:54 2015 -0500

    GFS2: use __vmalloc GFP_NOFS for fs-related allocations.
    
    leaf_dealloc uses vzalloc as a fallback to kzalloc(GFP_NOFS), so
    it clearly does not want any shrinker activity within the fs itself.
    convert vzalloc into __vmalloc(GFP_NOFS|__GFP_ZERO) to better achieve
    this goal.
    
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c5a34f09e228..6371192961e2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1896,7 +1896,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 
 	ht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);
 	if (ht == NULL)
-		ht = vzalloc(size);
+		ht = __vmalloc(size, GFP_NOFS | __GFP_NOWARN | __GFP_ZERO,
+			       PAGE_KERNEL);
 	if (!ht)
 		return -ENOMEM;
 

commit 9265f1d0c7593e3e7e1e94a4a83a6dea34230a35
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Thu Nov 20 05:19:47 2014 +0000

    GFS2: gfs2_dir_get_hash_table(): avoiding deferred vfree() is easy here...
    
    vfree() is allowed under spinlock these days, but it's cheaper when
    it doesn't step into deferred case and here it's very easy to avoid.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c247fed4a9a6..c5a34f09e228 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -370,11 +370,12 @@ static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)
 	}
 
 	spin_lock(&inode->i_lock);
-	if (ip->i_hash_cache)
-		kvfree(hc);
-	else
+	if (likely(!ip->i_hash_cache)) {
 		ip->i_hash_cache = hc;
+		hc = NULL;
+	}
 	spin_unlock(&inode->i_lock);
+	kvfree(hc);
 
 	return ip->i_hash_cache;
 }

commit 3cdcf63ed2d169c82d70a506f3569e484cd9e7a0
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Thu Nov 20 05:18:38 2014 +0000

    GFS2: use kvfree() instead of open-coding it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 5d4261ff5d23..c247fed4a9a6 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -365,22 +365,15 @@ static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)
 
 	ret = gfs2_dir_read_data(ip, hc, hsize);
 	if (ret < 0) {
-		if (is_vmalloc_addr(hc))
-			vfree(hc);
-		else
-			kfree(hc);
+		kvfree(hc);
 		return ERR_PTR(ret);
 	}
 
 	spin_lock(&inode->i_lock);
-	if (ip->i_hash_cache) {
-		if (is_vmalloc_addr(hc))
-			vfree(hc);
-		else
-			kfree(hc);
-	} else {
+	if (ip->i_hash_cache)
+		kvfree(hc);
+	else
 		ip->i_hash_cache = hc;
-	}
 	spin_unlock(&inode->i_lock);
 
 	return ip->i_hash_cache;
@@ -396,10 +389,7 @@ void gfs2_dir_hash_inval(struct gfs2_inode *ip)
 {
 	__be64 *hc = ip->i_hash_cache;
 	ip->i_hash_cache = NULL;
-	if (is_vmalloc_addr(hc))
-		vfree(hc);
-	else
-		kfree(hc);
+	kvfree(hc);
 }
 
 static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)
@@ -1168,10 +1158,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	gfs2_dinode_out(dip, dibh->b_data);
 	brelse(dibh);
 out_kfree:
-	if (is_vmalloc_addr(hc2))
-		vfree(hc2);
-	else
-		kfree(hc2);
+	kvfree(hc2);
 	return error;
 }
 
@@ -1302,14 +1289,6 @@ static void *gfs2_alloc_sort_buffer(unsigned size)
 	return ptr;
 }
 
-static void gfs2_free_sort_buffer(void *ptr)
-{
-	if (is_vmalloc_addr(ptr))
-		vfree(ptr);
-	else
-		kfree(ptr);
-}
-
 static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 			      int *copied, unsigned *depth,
 			      u64 leaf_no)
@@ -1393,7 +1372,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
 out_free:
 	for(i = 0; i < leaf; i++)
 		brelse(larr[i]);
-	gfs2_free_sort_buffer(larr);
+	kvfree(larr);
 out:
 	return error;
 }
@@ -2004,10 +1983,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	gfs2_rlist_free(&rlist);
 	gfs2_quota_unhold(dip);
 out:
-	if (is_vmalloc_addr(ht))
-		vfree(ht);
-	else
-		kfree(ht);
+	kvfree(ht);
 	return error;
 }
 

commit 19aeb5a65f1a6504fc665466c188241e7393d66f
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Sep 29 08:52:04 2014 -0400

    GFS2: Make rename not save dirent location
    
    This patch fixes a regression in the patch "GFS2: Remember directory
    insert point", commit 2b47dad866d04f14c328f888ba5406057b8c7d33.
    The problem had to do with the rename function: The function found
    space for the new dirent, and remembered that location. But then the
    old dirent was removed, which often moved the eligible location for
    the renamed dirent. Putting the new dirent at the saved location
    caused file system corruption.
    
    This patch adds a new "save_loc" variable to struct gfs2_diradd.
    If 1, the dirent location is saved. If 0, the dirent location is not
    saved and the buffer_head is released as per previous behavior.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 1a349f9a9685..5d4261ff5d23 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2100,8 +2100,13 @@ int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,
 	}
 	if (IS_ERR(dent))
 		return PTR_ERR(dent);
-	da->bh = bh;
-	da->dent = dent;
+
+	if (da->save_loc) {
+		da->bh = bh;
+		da->dent = dent;
+	} else {
+		brelse(bh);
+	}
 	return 0;
 }
 

commit d77d1b58aaf4456946b8502c67f16b52fda60303
Author: Joe Perches <joe@perches.com>
Date:   Thu Mar 6 12:10:45 2014 -0800

    GFS2: Use pr_<level> more consistently
    
    Add pr_fmt, remove embedded "GFS2: " prefixes.
    This now consistently emits lower case "gfs2: " for each message.
    
    Other miscellanea around these changes:
    
    o Add missing newlines
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 39c7081e4c12..1a349f9a9685 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -53,6 +53,8 @@
  * but never before the maximum hash table size has been reached.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/buffer_head.h>
@@ -507,8 +509,8 @@ static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,
 		goto error;
 	return 0;
 error:
-	pr_warn("gfs2_check_dirent: %s (%s)\n", msg,
-	       first ? "first in block" : "not first in block");
+	pr_warn("%s: %s (%s)\n",
+		__func__, msg, first ? "first in block" : "not first in block");
 	return -EIO;
 }
 
@@ -531,8 +533,7 @@ static int gfs2_dirent_offset(const void *buf)
 	}
 	return offset;
 wrong_type:
-	pr_warn("gfs2_scan_dirent: wrong block type %u\n",
-	        be32_to_cpu(h->mh_type));
+	pr_warn("%s: wrong block type %u\n", __func__, be32_to_cpu(h->mh_type));
 	return -1;
 }
 
@@ -728,7 +729,7 @@ static int get_leaf(struct gfs2_inode *dip, u64 leaf_no,
 
 	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, bhp);
 	if (!error && gfs2_metatype_check(GFS2_SB(&dip->i_inode), *bhp, GFS2_METATYPE_LF)) {
-		/* printk(KERN_INFO "block num=%llu\n", leaf_no); */
+		/* pr_info("block num=%llu\n", leaf_no); */
 		error = -EIO;
 	}
 
@@ -1006,7 +1007,8 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	len = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));
 	half_len = len >> 1;
 	if (!half_len) {
-		pr_warn("i_depth %u lf_depth %u index %u\n", dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
+		pr_warn("i_depth %u lf_depth %u index %u\n",
+			dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
 		gfs2_consist_inode(dip);
 		error = -EIO;
 		goto fail_brelse;

commit fc554ed3d89d220b9d0c020e19aa52fb6bf1d673
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Mar 5 22:06:42 2014 +0800

    GFS2: global conversion to pr_foo()
    
    -All printk(KERN_foo converted to pr_foo().
    -Messages updated to fit in 80 columns.
    -fs_macros converted as well.
    -fs_printk removed.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ffcfdd18d485..39c7081e4c12 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -507,7 +507,7 @@ static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,
 		goto error;
 	return 0;
 error:
-	printk(KERN_WARNING "gfs2_check_dirent: %s (%s)\n", msg,
+	pr_warn("gfs2_check_dirent: %s (%s)\n", msg,
 	       first ? "first in block" : "not first in block");
 	return -EIO;
 }
@@ -531,8 +531,8 @@ static int gfs2_dirent_offset(const void *buf)
 	}
 	return offset;
 wrong_type:
-	printk(KERN_WARNING "gfs2_scan_dirent: wrong block type %u\n",
-	       be32_to_cpu(h->mh_type));
+	pr_warn("gfs2_scan_dirent: wrong block type %u\n",
+	        be32_to_cpu(h->mh_type));
 	return -1;
 }
 
@@ -1006,7 +1006,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	len = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));
 	half_len = len >> 1;
 	if (!half_len) {
-		printk(KERN_WARNING "i_depth %u lf_depth %u index %u\n", dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
+		pr_warn("i_depth %u lf_depth %u index %u\n", dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
 		gfs2_consist_inode(dip);
 		error = -EIO;
 		goto fail_brelse;

commit 44aaada9d144a46d3de48ad81093f69d17fae96f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 7 11:23:22 2014 +0000

    GFS2: Add meta readahead field in directory entries
    
    The intent of this new field in the directory entry is to
    allow a subsequent lookup to know how many blocks, which
    are contiguous with the inode, contain metadata which relates
    to the inode. This will then allow the issuing of a single
    read to read these blocks, rather than reading the inode
    first, and then issuing a second read for the metadata.
    
    This only works under some fairly strict conditions, since
    we do not have back pointers from inodes to directory entries
    we must ensure that the blocks referenced in this way will
    always belong to the inode.
    
    This rules out being able to use this system for indirect
    blocks, as these can change as a result of truncate/rewrite.
    
    So the idea here is to restrict this to xattr blocks only
    for the time being. For most inodes, that means only a
    single block. Also, when using ACLs and/or SELinux or
    other LSMs, these will be added at inode creation time
    so that they will be contiguous with the inode on disk and
    also will almost always be needed when we read the inode in
    for permissions checks.
    
    Once an xattr block for an inode is allocated, it will never
    change until the inode is deallocated.
    
    This patch adds the new field, a further patch will add the
    readahead in due course.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index fa32655449c8..ffcfdd18d485 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1684,6 +1684,14 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 	return 0;
 }
 
+static u16 gfs2_inode_ra_len(const struct gfs2_inode *ip)
+{
+	u64 where = ip->i_no_addr + 1;
+	if (ip->i_eattr == where)
+		return 1;
+	return 0;
+}
+
 /**
  * gfs2_dir_add - Add new filename into directory
  * @inode: The directory inode
@@ -1721,6 +1729,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			dent = gfs2_init_dirent(inode, dent, name, bh);
 			gfs2_inum_out(nip, dent);
 			dent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));
+			dent->de_rahead = cpu_to_be16(gfs2_inode_ra_len(nip));
 			tv = CURRENT_TIME;
 			if (ip->i_diskflags & GFS2_DIF_EXHASH) {
 				leaf = (struct gfs2_leaf *)bh->b_data;

commit 01bcb0dedbcd77a5ebb4f2dfd7d3196e3ad5cea5
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jan 8 12:14:57 2014 +0000

    GFS2: Add hints to directory leaf blocks
    
    This patch adds four new fields to directory leaf blocks.
    The intent is not to use them in the kernel itself, although
    perhaps we may be able to use them as hints at some later date,
    but instead to provide more information for debug/fsck use.
    
    One new field adds a pointer to the inode to which the leaf
    belongs. This can be useful if the pointer to the leaf block
    has become corrupt, as it will allow us to know which inode
    this block should be associated with. This field is set when
    the leaf is created and never changed over its lifetime.
    
    The second field is a "distance from the hash table" field.
    The meaning is as follows:
     0  = An old leaf in which this value has not been set
     1  = This leaf is pointed to directly from the hash table
     2+ = This leaf is part of a chain, pointed to by another leaf
          block, the value gives the position in the chain.
    
    The third and fourth fields combine to give a time stamp of
    the most recent directory insertion or deletion from this
    leaf block. The time stamp is not updated when a new leaf
    block is chained from the current one. The code is currently
    written such that the timestamp on the dir inode will match
    that of the leaf block for the most recent insertion/deletion.
    
    For backwards compatibility, any of these new fields which is
    zero should be considered to be "unknown".
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index b2e5ebfb4bb1..fa32655449c8 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -834,6 +834,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;
 	struct qstr name = { .name = "" };
+	struct timespec tv = CURRENT_TIME;
 
 	error = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);
 	if (error)
@@ -850,7 +851,11 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	leaf->lf_entries = 0;
 	leaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);
 	leaf->lf_next = 0;
-	memset(leaf->lf_reserved, 0, sizeof(leaf->lf_reserved));
+	leaf->lf_inode = cpu_to_be64(ip->i_no_addr);
+	leaf->lf_dist = cpu_to_be32(1);
+	leaf->lf_nsec = cpu_to_be32(tv.tv_nsec);
+	leaf->lf_sec = cpu_to_be64(tv.tv_sec);
+	memset(leaf->lf_reserved2, 0, sizeof(leaf->lf_reserved2));
 	dent = (struct gfs2_dirent *)(leaf+1);
 	gfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);
 	*pbh = bh;
@@ -1612,11 +1617,31 @@ int gfs2_dir_check(struct inode *dir, const struct qstr *name,
 	return ret;
 }
 
+/**
+ * dir_new_leaf - Add a new leaf onto hash chain
+ * @inode: The directory
+ * @name: The name we are adding
+ *
+ * This adds a new dir leaf onto an existing leaf when there is not
+ * enough space to add a new dir entry. This is a last resort after
+ * we've expanded the hash table to max size and also split existing
+ * leaf blocks, so it will only occur for very large directories.
+ *
+ * The dist parameter is set to 1 for leaf blocks directly attached
+ * to the hash table, 2 for one layer of indirection, 3 for two layers
+ * etc. We are thus able to tell the difference between an old leaf
+ * with dist set to zero (i.e. "don't know") and a new one where we
+ * set this information for debug/fsck purposes.
+ *
+ * Returns: 0 on success, or -ve on error
+ */
+
 static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 {
 	struct buffer_head *bh, *obh;
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_leaf *leaf, *oleaf;
+	u32 dist = 1;
 	int error;
 	u32 index;
 	u64 bn;
@@ -1626,6 +1651,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 	if (error)
 		return error;
 	do {
+		dist++;
 		oleaf = (struct gfs2_leaf *)obh->b_data;
 		bn = be64_to_cpu(oleaf->lf_next);
 		if (!bn)
@@ -1643,6 +1669,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 		brelse(obh);
 		return -ENOSPC;
 	}
+	leaf->lf_dist = cpu_to_be32(dist);
 	oleaf->lf_next = cpu_to_be64(bh->b_blocknr);
 	brelse(bh);
 	brelse(obh);
@@ -1679,6 +1706,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh = da->bh;
 	struct gfs2_dirent *dent = da->dent;
+	struct timespec tv;
 	struct gfs2_leaf *leaf;
 	int error;
 
@@ -1693,15 +1721,18 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			dent = gfs2_init_dirent(inode, dent, name, bh);
 			gfs2_inum_out(nip, dent);
 			dent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));
+			tv = CURRENT_TIME;
 			if (ip->i_diskflags & GFS2_DIF_EXHASH) {
 				leaf = (struct gfs2_leaf *)bh->b_data;
 				be16_add_cpu(&leaf->lf_entries, 1);
+				leaf->lf_nsec = cpu_to_be32(tv.tv_nsec);
+				leaf->lf_sec = cpu_to_be64(tv.tv_sec);
 			}
 			da->dent = NULL;
 			da->bh = NULL;
 			brelse(bh);
 			ip->i_entries++;
-			ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
+			ip->i_inode.i_mtime = ip->i_inode.i_ctime = tv;
 			if (S_ISDIR(nip->i_inode.i_mode))
 				inc_nlink(&ip->i_inode);
 			mark_inode_dirty(inode);
@@ -1752,6 +1783,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)
 	const struct qstr *name = &dentry->d_name;
 	struct gfs2_dirent *dent, *prev = NULL;
 	struct buffer_head *bh;
+	struct timespec tv = CURRENT_TIME;
 
 	/* Returns _either_ the entry (if its first in block) or the
 	   previous entry otherwise */
@@ -1777,13 +1809,15 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)
 		if (!entries)
 			gfs2_consist_inode(dip);
 		leaf->lf_entries = cpu_to_be16(--entries);
+		leaf->lf_nsec = cpu_to_be32(tv.tv_nsec);
+		leaf->lf_sec = cpu_to_be64(tv.tv_sec);
 	}
 	brelse(bh);
 
 	if (!dip->i_entries)
 		gfs2_consist_inode(dip);
 	dip->i_entries--;
-	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
+	dip->i_inode.i_mtime = dip->i_inode.i_ctime = tv;
 	if (S_ISDIR(dentry->d_inode->i_mode))
 		drop_nlink(&dip->i_inode);
 	mark_inode_dirty(&dip->i_inode);

commit 22b5a6c0c0cd5eb524d31c949d113c6683e37ec9
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jan 8 11:05:29 2014 +0000

    GFS2: For exhash conversion, only one block is needed
    
    For most cases, only a single new block is needed when we reach
    the point of converting from stuffed to exhash directory. The
    exception being when the file name is so long that it will not
    fit within the new leaf block.
    
    So this patch adds a simple test for that situation so that we
    do not need to request the full reservation size in this case.
    
    Potentially we could calculate more accurately the value to use
    in other cases too, but that is much more complicated to do and
    it is doubtful that the benefit would outweigh the extra cost
    in code complexity.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d5988aafaa74..b2e5ebfb4bb1 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2035,7 +2035,9 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,
 			       struct gfs2_diradd *da)
 {
+	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+	const unsigned int extra = sizeof(struct gfs2_dinode) - sizeof(struct gfs2_leaf);
 	struct gfs2_dirent *dent;
 	struct buffer_head *bh;
 
@@ -2046,6 +2048,9 @@ int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,
 	dent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);
 	if (!dent) {
 		da->nr_blocks = sdp->sd_max_dirres;
+		if (!(ip->i_diskflags & GFS2_DIF_EXHASH) &&
+		    (GFS2_DIRENT_SIZE(name->len) < extra))
+			da->nr_blocks = 1;
 		return 0;
 	}
 	if (IS_ERR(dent))

commit 2b47dad866d04f14c328f888ba5406057b8c7d33
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 6 12:49:43 2014 +0000

    GFS2: Remember directory insert point
    
    When we look to see if there is enough space to add a dir
    entry without allocation, we have then been repeating the
    same search later when we do the actual insertion. This
    patch caches the details of the location in the gfs2_diradd
    structure, so that we do not have to repeat the search.
    
    This will provide a performance improvement which will be
    greater as the size of the directory increases.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 0b6be202a82c..d5988aafaa74 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1659,26 +1659,34 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 
 /**
  * gfs2_dir_add - Add new filename into directory
- * @dip: The GFS2 inode
- * @filename: The new name
- * @inode: The inode number of the entry
- * @type: The type of the entry
+ * @inode: The directory inode
+ * @name: The new name
+ * @nip: The GFS2 inode to be linked in to the directory
+ * @da: The directory addition info
+ *
+ * If the call to gfs2_diradd_alloc_required resulted in there being
+ * no need to allocate any new directory blocks, then it will contain
+ * a pointer to the directory entry and the bh in which it resides. We
+ * can use that without having to repeat the search. If there was no
+ * free space, then we must now create more space.
  *
  * Returns: 0 on success, error code on failure
  */
 
 int gfs2_dir_add(struct inode *inode, const struct qstr *name,
-		 const struct gfs2_inode *nip)
+		 const struct gfs2_inode *nip, struct gfs2_diradd *da)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
-	struct buffer_head *bh;
-	struct gfs2_dirent *dent;
+	struct buffer_head *bh = da->bh;
+	struct gfs2_dirent *dent = da->dent;
 	struct gfs2_leaf *leaf;
 	int error;
 
 	while(1) {
-		dent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space,
-					  &bh);
+		if (da->bh == NULL) {
+			dent = gfs2_dirent_search(inode, name,
+						  gfs2_dirent_find_space, &bh);
+		}
 		if (dent) {
 			if (IS_ERR(dent))
 				return PTR_ERR(dent);
@@ -1689,6 +1697,8 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 				leaf = (struct gfs2_leaf *)bh->b_data;
 				be16_add_cpu(&leaf->lf_entries, 1);
 			}
+			da->dent = NULL;
+			da->bh = NULL;
 			brelse(bh);
 			ip->i_entries++;
 			ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
@@ -2030,6 +2040,8 @@ int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,
 	struct buffer_head *bh;
 
 	da->nr_blocks = 0;
+	da->bh = NULL;
+	da->dent = NULL;
 
 	dent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);
 	if (!dent) {
@@ -2038,7 +2050,8 @@ int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,
 	}
 	if (IS_ERR(dent))
 		return PTR_ERR(dent);
-	brelse(bh);
+	da->bh = bh;
+	da->dent = dent;
 	return 0;
 }
 

commit 3c1c0ae1db74b1f3e606f42158b5dadd89105c1f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 6 11:28:41 2014 +0000

    GFS2: Add directory addition info structure
    
    The intent is that this structure will hold the information
    required when adding entries to a directory (linking). To
    start with, it will contain only the number of blocks which
    are required to link the new entry into the directory. The
    current calculation returns either 0 or the maximim number of
    blocks that can ever be requested by such a transaction.
    
    The intent is that in a later patch, we can update the dir
    code to calculate this value more accurately. In addition
    further patches will also add further fields to the new
    structure to increase its utility.
    
    In addition this patch fixes a bug where the link used during
    inode creation was adding requesting too many blocks in
    some cases. This is harmless unless the fs is close to being
    full.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 2e5fc268d324..0b6be202a82c 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2017,18 +2017,24 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
  * gfs2_diradd_alloc_required - find if adding entry will require an allocation
  * @ip: the file being written to
  * @filname: the filename that's going to be added
+ * @da: The structure to return dir alloc info
  *
- * Returns: 1 if alloc required, 0 if not, -ve on error
+ * Returns: 0 if ok, -ve on error
  */
 
-int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name)
+int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name,
+			       struct gfs2_diradd *da)
 {
+	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct gfs2_dirent *dent;
 	struct buffer_head *bh;
 
+	da->nr_blocks = 0;
+
 	dent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);
 	if (!dent) {
-		return 1;
+		da->nr_blocks = sdp->sd_max_dirres;
+		return 0;
 	}
 	if (IS_ERR(dent))
 		return PTR_ERR(dent);

commit 8be04b9374e59923fa337766aaa74151b95b7099
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 19 12:15:53 2013 -0700

    treewide: Add __GFP_NOWARN to k.alloc calls with v.alloc fallbacks
    
    Don't emit OOM warnings when k.alloc calls fail when
    there there is a v.alloc immediately afterwards.
    
    Converted a kmalloc/vmalloc with memset to kzalloc/vzalloc.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 0cb4c1557f20..2e5fc268d324 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1859,7 +1859,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 
 	memset(&rlist, 0, sizeof(struct gfs2_rgrp_list));
 
-	ht = kzalloc(size, GFP_NOFS);
+	ht = kzalloc(size, GFP_NOFS | __GFP_NOWARN);
 	if (ht == NULL)
 		ht = vzalloc(size);
 	if (!ht)

commit c4eb1b07303ad9e00aba842aa90d5521293ac857
Merge: 9e239bb93914 a01aedfe2163
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 2 09:41:18 2013 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/steve/gfs2-3.0-nmw
    
    Pull GFS2 updates from Steven Whitehouse:
     "There are a few bug fixes for various, mostly very minor corner cases,
      plus some interesting new features.
    
      The new features include atomic_open whose main benefit will be the
      reduction in locking overhead in case of combined lookup/create and
      open operations, sorting the log buffer lists by block number to
      improve the efficiency of AIL writeback, and aggressively issuing
      revokes in gfs2_log_flush to reduce overhead when dropping glocks."
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/steve/gfs2-3.0-nmw:
      GFS2: Reserve journal space for quota change in do_grow
      GFS2: Fix fstrim boundary conditions
      GFS2: fix warning message
      GFS2: aggressively issue revokes in gfs2_log_flush
      GFS2: fix regression in dir_double_exhash
      GFS2: Add atomic_open support
      GFS2: Only do one directory search on create
      GFS2: fix error propagation in init_threads()
      GFS2: Remove no-op wrapper function
      GFS2: Cocci spatch "ptr_ret.spatch"
      GFS2: Eliminate gfs2_rg_lops
      GFS2: Sort buffer lists by inplace block number

commit d81a8ef59802d2d8908466d631573a3644c313d5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 16 14:14:48 2013 -0400

    [readdir] convert gfs2
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index b631c9043460..e0449c10286a 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1212,9 +1212,7 @@ static int compare_dents(const void *a, const void *b)
 /**
  * do_filldir_main - read out directory entries
  * @dip: The GFS2 inode
- * @offset: The offset in the file to read from
- * @opaque: opaque data to pass to filldir
- * @filldir: The function to pass entries to
+ * @ctx: what to feed the entries to
  * @darr: an array of struct gfs2_dirent pointers to read
  * @entries: the number of entries in darr
  * @copied: pointer to int that's non-zero if a entry has been copied out
@@ -1224,11 +1222,10 @@ static int compare_dents(const void *a, const void *b)
  * the possibility that they will fall into different readdir buffers or
  * that someone will want to seek to that location.
  *
- * Returns: errno, >0 on exception from filldir
+ * Returns: errno, >0 if the actor tells you to stop
  */
 
-static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
-			   void *opaque, filldir_t filldir,
+static int do_filldir_main(struct gfs2_inode *dip, struct dir_context *ctx,
 			   const struct gfs2_dirent **darr, u32 entries,
 			   int *copied)
 {
@@ -1236,7 +1233,6 @@ static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 	u64 off, off_next;
 	unsigned int x, y;
 	int run = 0;
-	int error = 0;
 
 	sort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);
 
@@ -1253,9 +1249,9 @@ static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 			off_next = be32_to_cpu(dent_next->de_hash);
 			off_next = gfs2_disk_hash2offset(off_next);
 
-			if (off < *offset)
+			if (off < ctx->pos)
 				continue;
-			*offset = off;
+			ctx->pos = off;
 
 			if (off_next == off) {
 				if (*copied && !run)
@@ -1264,26 +1260,25 @@ static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 			} else
 				run = 0;
 		} else {
-			if (off < *offset)
+			if (off < ctx->pos)
 				continue;
-			*offset = off;
+			ctx->pos = off;
 		}
 
-		error = filldir(opaque, (const char *)(dent + 1),
+		if (!dir_emit(ctx, (const char *)(dent + 1),
 				be16_to_cpu(dent->de_name_len),
-				off, be64_to_cpu(dent->de_inum.no_addr),
-				be16_to_cpu(dent->de_type));
-		if (error)
+				be64_to_cpu(dent->de_inum.no_addr),
+				be16_to_cpu(dent->de_type)))
 			return 1;
 
 		*copied = 1;
 	}
 
-	/* Increment the *offset by one, so the next time we come into the
+	/* Increment the ctx->pos by one, so the next time we come into the
 	   do_filldir fxn, we get the next entry instead of the last one in the
 	   current leaf */
 
-	(*offset)++;
+	ctx->pos++;
 
 	return 0;
 }
@@ -1307,8 +1302,8 @@ static void gfs2_free_sort_buffer(void *ptr)
 		kfree(ptr);
 }
 
-static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
-			      filldir_t filldir, int *copied, unsigned *depth,
+static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
+			      int *copied, unsigned *depth,
 			      u64 leaf_no)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
@@ -1386,8 +1381,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 	} while(lfn);
 
 	BUG_ON(entries2 != entries);
-	error = do_filldir_main(ip, offset, opaque, filldir, darr,
-				entries, copied);
+	error = do_filldir_main(ip, ctx, darr, entries, copied);
 out_free:
 	for(i = 0; i < leaf; i++)
 		brelse(larr[i]);
@@ -1446,15 +1440,13 @@ static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,
 /**
  * dir_e_read - Reads the entries from a directory into a filldir buffer
  * @dip: dinode pointer
- * @offset: the hash of the last entry read shifted to the right once
- * @opaque: buffer for the filldir function to fill
- * @filldir: points to the filldir function to use
+ * @ctx: actor to feed the entries to
  *
  * Returns: errno
  */
 
-static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
-		      filldir_t filldir, struct file_ra_state *f_ra)
+static int dir_e_read(struct inode *inode, struct dir_context *ctx,
+		      struct file_ra_state *f_ra)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
 	u32 hsize, len = 0;
@@ -1465,7 +1457,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	unsigned depth = 0;
 
 	hsize = 1 << dip->i_depth;
-	hash = gfs2_dir_offset2hash(*offset);
+	hash = gfs2_dir_offset2hash(ctx->pos);
 	index = hash >> (32 - dip->i_depth);
 
 	if (dip->i_hash_cache == NULL)
@@ -1477,7 +1469,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	gfs2_dir_readahead(inode, hsize, index, f_ra);
 
 	while (index < hsize) {
-		error = gfs2_dir_read_leaf(inode, offset, opaque, filldir,
+		error = gfs2_dir_read_leaf(inode, ctx,
 					   &copied, &depth,
 					   be64_to_cpu(lp[index]));
 		if (error)
@@ -1492,8 +1484,8 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	return error;
 }
 
-int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
-		  filldir_t filldir, struct file_ra_state *f_ra)
+int gfs2_dir_read(struct inode *inode, struct dir_context *ctx,
+		  struct file_ra_state *f_ra)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
@@ -1507,7 +1499,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 		return 0;
 
 	if (dip->i_diskflags & GFS2_DIF_EXHASH)
-		return dir_e_read(inode, offset, opaque, filldir, f_ra);
+		return dir_e_read(inode, ctx, f_ra);
 
 	if (!gfs2_is_stuffed(dip)) {
 		gfs2_consist_inode(dip);
@@ -1539,7 +1531,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 			error = -EIO;
 			goto out;
 		}
-		error = do_filldir_main(dip, offset, opaque, filldir, darr,
+		error = do_filldir_main(dip, ctx, darr,
 					dip->i_entries, &copied);
 out:
 		kfree(darr);

commit 512cbf02fde42b747c5752f135afd3f3f6d598e2
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Jun 14 08:39:18 2013 -0400

    GFS2: fix regression in dir_double_exhash
    
    Recent commit e8830d8 introduced a bug in function dir_double_exhash;
    it was failing to set h in the fall-back case. This patch corrects it.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f0c70529948f..147fcc557299 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1125,13 +1125,14 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	if (IS_ERR(hc))
 		return PTR_ERR(hc);
 
-	h = hc2 = kmalloc(hsize_bytes * 2, GFP_NOFS | __GFP_NOWARN);
+	hc2 = kmalloc(hsize_bytes * 2, GFP_NOFS | __GFP_NOWARN);
 	if (hc2 == NULL)
 		hc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS, PAGE_KERNEL);
 
 	if (!hc2)
 		return -ENOMEM;
 
+	h = hc2;
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (error)
 		goto out_kfree;

commit 5a00f3cc978be45b9d2597851bedaa40630bc597
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jun 11 13:45:29 2013 +0100

    GFS2: Only do one directory search on create
    
    Creation of a new inode requires a directory search in order to ensure
    that we are not trying to create an inode with the same name as an
    existing one. This was hidden away inside the create_ok() function.
    
    In the case that there was an existing inode, and a lookup can be
    substituted for a create (which is the case with regular files
    when the O_EXCL flag is not in use) then we were doing a second
    lookup in order to return the inode.
    
    This patch merges these two lookups into one. This can be done by
    passing a flag to gfs2_dir_search() to tell it to just return -EEXIST
    in the cases where we don't actually want to look up the inode.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index b631c9043460..f0c70529948f 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1555,9 +1555,9 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 
 /**
  * gfs2_dir_search - Search a directory
- * @dip: The GFS2 inode
- * @filename:
- * @inode:
+ * @dip: The GFS2 dir inode
+ * @name: The name we are looking up
+ * @fail_on_exist: Fail if the name exists rather than looking it up
  *
  * This routine searches a directory for a file or another directory.
  * Assumes a glock is held on dip.
@@ -1565,22 +1565,25 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
  * Returns: errno
  */
 
-struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name)
+struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name,
+			      bool fail_on_exist)
 {
 	struct buffer_head *bh;
 	struct gfs2_dirent *dent;
-	struct inode *inode;
+	u64 addr, formal_ino;
+	u16 dtype;
 
 	dent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);
 	if (dent) {
 		if (IS_ERR(dent))
 			return ERR_CAST(dent);
-		inode = gfs2_inode_lookup(dir->i_sb, 
-				be16_to_cpu(dent->de_type),
-				be64_to_cpu(dent->de_inum.no_addr),
-				be64_to_cpu(dent->de_inum.no_formal_ino), 0);
+		dtype = be16_to_cpu(dent->de_type);
+		addr = be64_to_cpu(dent->de_inum.no_addr);
+		formal_ino = be64_to_cpu(dent->de_inum.no_formal_ino);
 		brelse(bh);
-		return inode;
+		if (fail_on_exist)
+			return ERR_PTR(-EEXIST);
+		return gfs2_inode_lookup(dir->i_sb, dtype, addr, formal_ino, 0);
 	}
 	return ERR_PTR(-ENOENT);
 }

commit e8830d8856e3ad61067dd46c05438b0d75a0441a
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu May 30 09:48:56 2013 -0400

    GFS2: Fall back to vmalloc if kmalloc fails for dir hash tables
    
    This version has one more correction: the vmalloc calls are replaced
    by __vmalloc calls to preserve the GFP_NOFS flag.
    
    When GFS2's directory management code allocates buffers for a
    directory hash table, if it can't get the memory it needs, it
    currently gives a bad return code. Rather than giving an error,
    this patch allows it to use virtual memory rather than kernel
    memory for the hash table. This should make it possible for
    directories to function properly, even when kernel memory becomes
    very fragmented.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c3e82bd23179..b631c9043460 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -354,22 +354,31 @@ static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)
 		return ERR_PTR(-EIO);
 	}
 
-	hc = kmalloc(hsize, GFP_NOFS);
-	ret = -ENOMEM;
+	hc = kmalloc(hsize, GFP_NOFS | __GFP_NOWARN);
+	if (hc == NULL)
+		hc = __vmalloc(hsize, GFP_NOFS, PAGE_KERNEL);
+
 	if (hc == NULL)
 		return ERR_PTR(-ENOMEM);
 
 	ret = gfs2_dir_read_data(ip, hc, hsize);
 	if (ret < 0) {
-		kfree(hc);
+		if (is_vmalloc_addr(hc))
+			vfree(hc);
+		else
+			kfree(hc);
 		return ERR_PTR(ret);
 	}
 
 	spin_lock(&inode->i_lock);
-	if (ip->i_hash_cache)
-		kfree(hc);
-	else
+	if (ip->i_hash_cache) {
+		if (is_vmalloc_addr(hc))
+			vfree(hc);
+		else
+			kfree(hc);
+	} else {
 		ip->i_hash_cache = hc;
+	}
 	spin_unlock(&inode->i_lock);
 
 	return ip->i_hash_cache;
@@ -385,7 +394,10 @@ void gfs2_dir_hash_inval(struct gfs2_inode *ip)
 {
 	__be64 *hc = ip->i_hash_cache;
 	ip->i_hash_cache = NULL;
-	kfree(hc);
+	if (is_vmalloc_addr(hc))
+		vfree(hc);
+	else
+		kfree(hc);
 }
 
 static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)
@@ -1113,7 +1125,10 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	if (IS_ERR(hc))
 		return PTR_ERR(hc);
 
-	h = hc2 = kmalloc(hsize_bytes * 2, GFP_NOFS);
+	h = hc2 = kmalloc(hsize_bytes * 2, GFP_NOFS | __GFP_NOWARN);
+	if (hc2 == NULL)
+		hc2 = __vmalloc(hsize_bytes * 2, GFP_NOFS, PAGE_KERNEL);
+
 	if (!hc2)
 		return -ENOMEM;
 
@@ -1145,7 +1160,10 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	gfs2_dinode_out(dip, dibh->b_data);
 	brelse(dibh);
 out_kfree:
-	kfree(hc2);
+	if (is_vmalloc_addr(hc2))
+		vfree(hc2);
+	else
+		kfree(hc2);
 	return error;
 }
 
@@ -1846,6 +1864,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	memset(&rlist, 0, sizeof(struct gfs2_rgrp_list));
 
 	ht = kzalloc(size, GFP_NOFS);
+	if (ht == NULL)
+		ht = vzalloc(size);
 	if (!ht)
 		return -ENOMEM;
 
@@ -1933,7 +1953,10 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	gfs2_rlist_free(&rlist);
 	gfs2_quota_unhold(dip);
 out:
-	kfree(ht);
+	if (is_vmalloc_addr(ht))
+		vfree(ht);
+	else
+		kfree(ht);
 	return error;
 }
 

commit 94f2f14234178f118545a0be60a6371ddeb229b7
Merge: 8d168f71551e 139321c65c05
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 16:00:49 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace and namespace infrastructure changes from Eric W Biederman:
     "This set of changes starts with a few small enhnacements to the user
      namespace.  reboot support, allowing more arbitrary mappings, and
      support for mounting devpts, ramfs, tmpfs, and mqueuefs as just the
      user namespace root.
    
      I do my best to document that if you care about limiting your
      unprivileged users that when you have the user namespace support
      enabled you will need to enable memory control groups.
    
      There is a minor bug fix to prevent overflowing the stack if someone
      creates way too many user namespaces.
    
      The bulk of the changes are a continuation of the kuid/kgid push down
      work through the filesystems.  These changes make using uids and gids
      typesafe which ensures that these filesystems are safe to use when
      multiple user namespaces are in use.  The filesystems converted for
      3.9 are ceph, 9p, afs, ocfs2, gfs2, ncpfs, nfs, nfsd, and cifs.  The
      changes for these filesystems were a little more involved so I split
      the changes into smaller hopefully obviously correct changes.
    
      XFS is the only filesystem that remains.  I was hoping I could get
      that in this release so that user namespace support would be enabled
      with an allyesconfig or an allmodconfig but it looks like the xfs
      changes need another couple of days before it they are ready."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (93 commits)
      cifs: Enable building with user namespaces enabled.
      cifs: Convert struct cifs_ses to use a kuid_t and a kgid_t
      cifs: Convert struct cifs_sb_info to use kuids and kgids
      cifs: Modify struct smb_vol to use kuids and kgids
      cifs: Convert struct cifsFileInfo to use a kuid
      cifs: Convert struct cifs_fattr to use kuid and kgids
      cifs: Convert struct tcon_link to use a kuid.
      cifs: Modify struct cifs_unix_set_info_args to hold a kuid_t and a kgid_t
      cifs: Convert from a kuid before printing current_fsuid
      cifs: Use kuids and kgids SID to uid/gid mapping
      cifs: Pass GLOBAL_ROOT_UID and GLOBAL_ROOT_GID to keyring_alloc
      cifs: Use BUILD_BUG_ON to validate uids and gids are the same size
      cifs: Override unmappable incoming uids and gids
      nfsd: Enable building with user namespaces enabled.
      nfsd: Properly compare and initialize kuids and kgids
      nfsd: Store ex_anon_uid and ex_anon_gid as kuids and kgids
      nfsd: Modify nfsd4_cb_sec to use kuids and kgids
      nfsd: Handle kuids and kgids in the nfs4acl to posix_acl conversion
      nfsd: Convert nfsxdr to use kuids and kgids
      nfsd: Convert nfs3xdr to use kuids and kgids
      ...

commit f4108a607f75b073423eed229ee4f95e5fc10631
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jan 31 17:49:26 2013 -0800

    gfs2: Split NO_QUOTA_CHANGE inot NO_UID_QUTOA_CHANGE and NO_GID_QUTOA_CHANGE
    
    Split NO_QUOTA_CHANGE into NO_UID_QUTOA_CHANGE and NO_GID_QUTOA_CHANGE
    so the constants may be well typed.
    
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 9a35670fdc38..6d3e3e2cabf8 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1849,7 +1849,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (!ht)
 		return -ENOMEM;
 
-	error = gfs2_quota_hold(dip, NO_QUOTA_CHANGE, NO_QUOTA_CHANGE);
+	error = gfs2_quota_hold(dip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);
 	if (error)
 		goto out;
 

commit 350a9b0a7269c6f4b99eca34d0e773c3c2072520
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Dec 14 12:36:02 2012 +0000

    GFS2: Split gfs2_trans_add_bh() into two
    
    There is little common content in gfs2_trans_add_bh() between the data
    and meta classes by the time that the functions which it calls are
    taken into account. The intent here is to split this into two
    separate functions. Stage one is to introduce gfs2_trans_add_data()
    and gfs2_trans_add_meta() and update the callers accordingly.
    
    Later patches will then pull in the content of gfs2_trans_add_bh()
    and its dependent functions in order to clean up the code in this
    area.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 9a35670fdc38..7179478e5a28 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -93,7 +93,7 @@ int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,
 	struct buffer_head *bh;
 
 	bh = gfs2_meta_new(ip->i_gl, block);
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	gfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);
 	gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
 	*bhp = bh;
@@ -127,7 +127,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 	if (error)
 		return error;
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
 	if (ip->i_inode.i_size < offset + size)
 		i_size_write(&ip->i_inode, offset + size);
@@ -209,7 +209,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 		if (error)
 			goto fail;
 
-		gfs2_trans_add_bh(ip->i_gl, bh, 1);
+		gfs2_trans_add_meta(ip->i_gl, bh);
 		memcpy(bh->b_data + o, buf, amount);
 		brelse(bh);
 
@@ -231,7 +231,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 		i_size_write(&ip->i_inode, offset + copied);
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 
-	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(ip->i_gl, dibh);
 	gfs2_dinode_out(ip, dibh->b_data);
 	brelse(dibh);
 
@@ -647,7 +647,7 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 		return;
 	}
 
-	gfs2_trans_add_bh(dip->i_gl, bh, 1);
+	gfs2_trans_add_meta(dip->i_gl, bh);
 
 	/* If there is no prev entry, this is the first entry in the block.
 	   The de_rec_len is already as big as it needs to be.  Just zero
@@ -690,7 +690,7 @@ static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,
 		offset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
 	totlen = be16_to_cpu(dent->de_rec_len);
 	BUG_ON(offset + name->len > totlen);
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	ndent = (struct gfs2_dirent *)((char *)dent + offset);
 	dent->de_rec_len = cpu_to_be16(offset);
 	gfs2_qstr2dirent(name, totlen - offset, ndent);
@@ -831,7 +831,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 		return NULL;
 
 	gfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	leaf = (struct gfs2_leaf *)bh->b_data;
 	leaf->lf_depth = cpu_to_be16(depth);
@@ -916,7 +916,7 @@ static int dir_make_exhash(struct inode *inode)
 	/*  We're done with the new leaf block, now setup the new
 	    hash table.  */
 
-	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(dip->i_gl, dibh);
 	gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
 
 	lp = (__be64 *)(dibh->b_data + sizeof(struct gfs2_dinode));
@@ -976,7 +976,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 		return 1; /* can't split */
 	}
 
-	gfs2_trans_add_bh(dip->i_gl, obh, 1);
+	gfs2_trans_add_meta(dip->i_gl, obh);
 
 	nleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);
 	if (!nleaf) {
@@ -1069,7 +1069,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {
-		gfs2_trans_add_bh(dip->i_gl, dibh, 1);
+		gfs2_trans_add_meta(dip->i_gl, dibh);
 		gfs2_add_inode_blocks(&dip->i_inode, 1);
 		gfs2_dinode_out(dip, dibh->b_data);
 		brelse(dibh);
@@ -1622,7 +1622,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 			return error;
 	} while(1);
 
-	gfs2_trans_add_bh(ip->i_gl, obh, 1);
+	gfs2_trans_add_meta(ip->i_gl, obh);
 
 	leaf = new_leaf(inode, &bh, be16_to_cpu(oleaf->lf_depth));
 	if (!leaf) {
@@ -1636,7 +1636,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 	error = gfs2_meta_inode_buffer(ip, &bh);
 	if (error)
 		return error;
-	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_trans_add_meta(ip->i_gl, bh);
 	gfs2_add_inode_blocks(&ip->i_inode, 1);
 	gfs2_dinode_out(ip, bh->b_data);
 	brelse(bh);
@@ -1795,7 +1795,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 	if (IS_ERR(dent))
 		return PTR_ERR(dent);
 
-	gfs2_trans_add_bh(dip->i_gl, bh, 1);
+	gfs2_trans_add_meta(dip->i_gl, bh);
 	gfs2_inum_out(nip, dent);
 	dent->de_type = cpu_to_be16(new_type);
 
@@ -1804,7 +1804,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 		error = gfs2_meta_inode_buffer(dip, &bh);
 		if (error)
 			return error;
-		gfs2_trans_add_bh(dip->i_gl, bh, 1);
+		gfs2_trans_add_meta(dip->i_gl, bh);
 	}
 
 	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
@@ -1917,7 +1917,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (error)
 		goto out_end_trans;
 
-	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
+	gfs2_trans_add_meta(dip->i_gl, dibh);
 	/* On the last dealloc, make this a regular file in case we crash.
 	   (We don't want to free these blocks a second time.)  */
 	if (last_dealloc)

commit 343cd8f0d78515da38e41e9351f5ba306cdec84a
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Nov 12 13:04:54 2012 -0500

    GFS2: Use dirty_inode in gfs2_dir_add
    
    This patch changes the gfs2_dir_add function so that it uses
    the dirty_inode function (via mark_inode_dirty) rather than manually
    updating the dinode.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 259b088cfc4c..9a35670fdc38 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1676,16 +1676,11 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 				be16_add_cpu(&leaf->lf_entries, 1);
 			}
 			brelse(bh);
-			error = gfs2_meta_inode_buffer(ip, &bh);
-			if (error)
-				break;
-			gfs2_trans_add_bh(ip->i_gl, bh, 1);
 			ip->i_entries++;
 			ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 			if (S_ISDIR(nip->i_inode.i_mode))
 				inc_nlink(&ip->i_inode);
-			gfs2_dinode_out(ip, bh->b_data);
-			brelse(bh);
+			mark_inode_dirty(inode);
 			error = 0;
 			break;
 		}

commit 5407e24229408d7586ee451a384fc13e4a2332be
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri May 18 09:28:23 2012 -0400

    GFS2: Fold quota data into the reservations struct
    
    This patch moves the ancillary quota data structures into the
    block reservations structure. This saves GFS2 some time and
    effort in allocating and deallocating the qadata structure.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 8aaeb07a07b5..259b088cfc4c 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1854,14 +1854,9 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (!ht)
 		return -ENOMEM;
 
-	if (!gfs2_qadata_get(dip)) {
-		error = -ENOMEM;
-		goto out;
-	}
-
 	error = gfs2_quota_hold(dip, NO_QUOTA_CHANGE, NO_QUOTA_CHANGE);
 	if (error)
-		goto out_put;
+		goto out;
 
 	/*  Count the number of leaves  */
 	bh = leaf_bh;
@@ -1942,8 +1937,6 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 out_rlist:
 	gfs2_rlist_free(&rlist);
 	gfs2_quota_unhold(dip);
-out_put:
-	gfs2_qadata_put(dip);
 out:
 	kfree(ht);
 	return error;

commit 26fe575028703948880fce4355a210c76bb0536e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 10 13:14:12 2012 -0700

    vfs: make it possible to access the dentry hash/len as one 64-bit entry
    
    This allows comparing hash and len in one operation on 64-bit
    architectures.  Right now only __d_lookup_rcu() takes advantage of this,
    since that is the case we care most about.
    
    The use of anonymous struct/unions hides the alternate 64-bit approach
    from most users, the exception being a few cases where we initialize a
    'struct qstr' with a static initializer.  This makes the problematic
    cases use a new QSTR_INIT() helper function for that (but initializing
    just the name pointer with a "{ .name = xyzzy }" initializer remains
    valid, as does just copying another qstr structure).
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index a836056343f0..8aaeb07a07b5 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -821,7 +821,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct buffer_head *bh;
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;
-	struct qstr name = { .name = "", .len = 0, .hash = 0 };
+	struct qstr name = { .name = "" };
 
 	error = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);
 	if (error)

commit 5e2f7d617b574dadf3ad125e4821ce1b180b1626
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Apr 4 22:11:16 2012 -0400

    GFS2: Make sure rindex is uptodate before starting transactions
    
    This patch removes the call from gfs2_blk2rgrd to function
    gfs2_rindex_update and replaces it with individual calls.
    The former way turned out to be too problematic.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c35573abd371..a836056343f0 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1844,6 +1844,10 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	unsigned int x, size = len * sizeof(u64);
 	int error;
 
+	error = gfs2_rindex_update(sdp);
+	if (error)
+		return error;
+
 	memset(&rlist, 0, sizeof(struct gfs2_rgrp_list));
 
 	ht = kzalloc(size, GFP_NOFS);

commit 564e12b1157215171e7f3af5b70611ec7154327c
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Nov 21 13:36:17 2011 -0500

    GFS2: decouple quota allocations from block allocations
    
    This patch separates the code pertaining to allocations into two
    parts: quota-related information and block reservations.
    This patch also moves all the block reservation structure allocations to
    function gfs2_inplace_reserve to simplify the code, and moves
    the frees to function gfs2_inplace_release.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f8485da3b853..c35573abd371 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1850,7 +1850,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (!ht)
 		return -ENOMEM;
 
-	if (!gfs2_alloc_get(dip)) {
+	if (!gfs2_qadata_get(dip)) {
 		error = -ENOMEM;
 		goto out;
 	}
@@ -1939,7 +1939,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	gfs2_rlist_free(&rlist);
 	gfs2_quota_unhold(dip);
 out_put:
-	gfs2_alloc_put(dip);
+	gfs2_qadata_put(dip);
 out:
 	kfree(ht);
 	return error;

commit 6e87ed0fc93ffbe2aec296e6912b1dcb19034d6c
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Nov 18 10:58:32 2011 -0500

    GFS2: move toward a generic multi-block allocator
    
    This patch is a revision of the one I previously posted.
    I tried to integrate all the suggestions Steve gave.
    The purpose of the patch is to change function gfs2_alloc_block
    (allocate either a dinode block or an extent of data blocks)
    to a more generic gfs2_alloc_blocks function that can
    allocate both a dinode _and_ an extent of data blocks in the
    same call. This will ultimately help us create a multi-block
    reservation scheme to reduce file fragmentation.
    
    This patch moves more toward a generic multi-block allocator that
    takes a pointer to the number of data blocks to allocate, plus whether
    or not to allocate a dinode. In theory, it could be called to allocate
    (1) a single dinode block, (2) a group of one or more data blocks, or
    (3) a dinode plus several data blocks.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ae75319b65e8..f8485da3b853 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -823,7 +823,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct gfs2_dirent *dent;
 	struct qstr name = { .name = "", .len = 0, .hash = 0 };
 
-	error = gfs2_alloc_block(ip, &bn, &n, 0, NULL);
+	error = gfs2_alloc_blocks(ip, &bn, &n, 0, NULL);
 	if (error)
 		return NULL;
 	bh = gfs2_meta_new(ip->i_gl, bn);

commit 3c5d785acfda7dffa63477951bb6864c6a49ed2e
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Nov 14 11:17:08 2011 -0500

    GFS2: combine gfs2_alloc_block and gfs2_alloc_di
    
    GFS2 functions gfs2_alloc_block and gfs2_alloc_di do basically
    the same things, with a few exceptions. This patch combines
    the two functions into a slightly more generic gfs2_alloc_block.
    Having one centralized block allocation function will reduce
    code redundancy and make it easier to implement multi-block
    reservations to reduce file fragmentation in the future.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 946b6f88939e..ae75319b65e8 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -823,7 +823,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct gfs2_dirent *dent;
 	struct qstr name = { .name = "", .len = 0, .hash = 0 };
 
-	error = gfs2_alloc_block(ip, &bn, &n);
+	error = gfs2_alloc_block(ip, &bn, &n, 0, NULL);
 	if (error)
 		return NULL;
 	bh = gfs2_meta_new(ip->i_gl, bn);

commit 79c4c379c8f16a12c28ea2084db5138e33d17ebd
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Nov 9 13:46:06 2011 +0000

    GFS2: f_ra is always valid in dir readahead function
    
    As a result, we don't need to test it each time.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 91441171bf25..946b6f88939e 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1378,12 +1378,14 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 	return error;
 }
 
-/* gfs2_dir_readahead - Issue read-ahead requests for leaf blocks.
+/**
+ * gfs2_dir_readahead - Issue read-ahead requests for leaf blocks.
  *
  * Note: we can't calculate each index like dir_e_read can because we don't
  * have the leaf, and therefore we don't have the depth, and therefore we
  * don't have the length. So we have to just read enough ahead to make up
- * for the loss of information. */
+ * for the loss of information.
+ */
 static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,
 			       struct file_ra_state *f_ra)
 {
@@ -1394,7 +1396,7 @@ static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,
 	unsigned count;
 
 	/* First check if we've already read-ahead for the whole range. */
-	if (!f_ra || index + MAX_RA_BLOCKS < f_ra->start)
+	if (index + MAX_RA_BLOCKS < f_ra->start)
 		return;
 
 	f_ra->start = max((pgoff_t)index, f_ra->start);
@@ -1448,7 +1450,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	hash = gfs2_dir_offset2hash(*offset);
 	index = hash >> (32 - dip->i_depth);
 
-	if (f_ra && dip->i_hash_cache == NULL)
+	if (dip->i_hash_cache == NULL)
 		f_ra->start = 0;
 	lp = gfs2_dir_get_hash_table(dip);
 	if (IS_ERR(lp))

commit dfe4d34b39b80faff52489f950a18523da7581bf
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Oct 27 12:16:06 2011 -0400

    GFS2: Add readahead to sequential directory traversal
    
    This patch adds read-ahead capability to GFS2's
    directory hash table management.  It greatly improves
    performance for some directory operations.  For example:
    In one of my file systems that has 1000 directories, each
    of which has 1000 files, time to execute a recursive
    ls (time ls -fR /mnt/gfs2 > /dev/null) was reduced
    from 2m2.814s on a stock kernel to 0m45.938s.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 8ccad2467cb6..91441171bf25 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -76,6 +76,8 @@
 #define IS_LEAF     1 /* Hashed (leaf) directory */
 #define IS_DINODE   2 /* Linear (stuffed dinode block) directory */
 
+#define MAX_RA_BLOCKS 32 /* max read-ahead blocks */
+
 #define gfs2_disk_hash2offset(h) (((u64)(h)) >> 1)
 #define gfs2_dir_offset2hash(p) ((u32)(((u64)(p)) << 1))
 
@@ -1376,6 +1378,50 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 	return error;
 }
 
+/* gfs2_dir_readahead - Issue read-ahead requests for leaf blocks.
+ *
+ * Note: we can't calculate each index like dir_e_read can because we don't
+ * have the leaf, and therefore we don't have the depth, and therefore we
+ * don't have the length. So we have to just read enough ahead to make up
+ * for the loss of information. */
+static void gfs2_dir_readahead(struct inode *inode, unsigned hsize, u32 index,
+			       struct file_ra_state *f_ra)
+{
+	struct gfs2_inode *ip = GFS2_I(inode);
+	struct gfs2_glock *gl = ip->i_gl;
+	struct buffer_head *bh;
+	u64 blocknr = 0, last;
+	unsigned count;
+
+	/* First check if we've already read-ahead for the whole range. */
+	if (!f_ra || index + MAX_RA_BLOCKS < f_ra->start)
+		return;
+
+	f_ra->start = max((pgoff_t)index, f_ra->start);
+	for (count = 0; count < MAX_RA_BLOCKS; count++) {
+		if (f_ra->start >= hsize) /* if exceeded the hash table */
+			break;
+
+		last = blocknr;
+		blocknr = be64_to_cpu(ip->i_hash_cache[f_ra->start]);
+		f_ra->start++;
+		if (blocknr == last)
+			continue;
+
+		bh = gfs2_getbuf(gl, blocknr, 1);
+		if (trylock_buffer(bh)) {
+			if (buffer_uptodate(bh)) {
+				unlock_buffer(bh);
+				brelse(bh);
+				continue;
+			}
+			bh->b_end_io = end_buffer_read_sync;
+			submit_bh(READA | REQ_META, bh);
+			continue;
+		}
+		brelse(bh);
+	}
+}
 
 /**
  * dir_e_read - Reads the entries from a directory into a filldir buffer
@@ -1388,7 +1434,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
  */
 
 static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
-		      filldir_t filldir)
+		      filldir_t filldir, struct file_ra_state *f_ra)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
 	u32 hsize, len = 0;
@@ -1402,10 +1448,14 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	hash = gfs2_dir_offset2hash(*offset);
 	index = hash >> (32 - dip->i_depth);
 
+	if (f_ra && dip->i_hash_cache == NULL)
+		f_ra->start = 0;
 	lp = gfs2_dir_get_hash_table(dip);
 	if (IS_ERR(lp))
 		return PTR_ERR(lp);
 
+	gfs2_dir_readahead(inode, hsize, index, f_ra);
+
 	while (index < hsize) {
 		error = gfs2_dir_read_leaf(inode, offset, opaque, filldir,
 					   &copied, &depth,
@@ -1423,7 +1473,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 }
 
 int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
-		  filldir_t filldir)
+		  filldir_t filldir, struct file_ra_state *f_ra)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
@@ -1437,7 +1487,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 		return 0;
 
 	if (dip->i_diskflags & GFS2_DIF_EXHASH)
-		return dir_e_read(inode, offset, opaque, filldir);
+		return dir_e_read(inode, offset, opaque, filldir, f_ra);
 
 	if (!gfs2_is_stuffed(dip)) {
 		gfs2_consist_inode(dip);

commit 70b0c3656f12964a6dac104214c904c66e626058
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 2 16:08:09 2011 +0100

    GFS2: Use cached rgrp in gfs2_rlist_add()
    
    Each block which is deallocated, requires a call to gfs2_rlist_add()
    and each of those calls was calling gfs2_blk2rgrpd() in order to
    figure out which rgrp the block belonged in. This can be speeded up
    by making use of the rgrp cached in the inode. We also reset this
    cached rgrp in case the block has changed rgrp. This should provide
    a big reduction in gfs2_blk2rgrpd() calls during deallocation.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 90b877b464ca..8ccad2467cb6 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1821,7 +1821,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		if (blk != leaf_no)
 			brelse(bh);
 
-		gfs2_rlist_add(sdp, &rlist, blk);
+		gfs2_rlist_add(dip, &rlist, blk);
 		l_blocks++;
 	}
 

commit 8339ee543ece6e2dcc1bbd97d5350163c198cf00
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 31 16:38:29 2011 +0100

    GFS2: Make resource groups "append only" during life of fs
    
    Since we have ruled out supporting online filesystem shrink,
    it is possible to make the resource group list append only
    during the life of a super block. This gives several benefits:
    
    Firstly, we only need to read new rindex elements as they are added
    rather than needing to reread the whole rindex file each time one
    element is added.
    
    Secondly, the rindex glock can be held for much shorter periods of
    time, and is completely removed from the fast path for allocations.
    The lock is taken in shared mode only when updating the resource
    groups when the first allocation occurs, and after a grow has
    taken place.
    
    Thirdly, this results in a reduction in code size, and everything
    gets a lot simpler to understand in this area.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 898e62ed5b85..90b877b464ca 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1807,10 +1807,6 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (error)
 		goto out_put;
 
-	error = gfs2_rindex_hold(sdp, &dip->i_alloc->al_ri_gh);
-	if (error)
-		goto out_qs;
-
 	/*  Count the number of leaves  */
 	bh = leaf_bh;
 
@@ -1889,8 +1885,6 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	gfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);
 out_rlist:
 	gfs2_rlist_free(&rlist);
-	gfs2_glock_dq_uninit(&dip->i_alloc->al_ri_gh);
-out_qs:
 	gfs2_quota_unhold(dip);
 out_put:
 	gfs2_alloc_put(dip);

commit ab9bbda0204dfd0e5342562d9979d1241b14ea5f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Aug 15 14:20:36 2011 +0100

    GFS2: Use ->dirty_inode()
    
    The aim of this patch is to use the newly enhanced ->dirty_inode()
    super block operation to deal with atime updates, rather than
    piggy backing that code into ->write_inode() as is currently
    done.
    
    The net result is a simplification of the code in various places
    and a reduction of the number of gfs2_dinode_out() calls since
    this is now implied by ->dirty_inode().
    
    Some of the mark_inode_dirty() calls have been moved under glocks
    in order to take advantage of then being able to avoid locking in
    ->dirty_inode() when we already have suitable locks.
    
    One consequence is that generic_write_end() now correctly deals
    with file size updates, so that we do not need a separate check
    for that afterwards. This also, indirectly, means that fdatasync
    should work correctly on GFS2 - the current code always syncs the
    metadata whether it needs to or not.
    
    Has survived testing with postmark (with and without atime) and
    also fsx.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 2045d70753f1..898e62ed5b85 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1681,7 +1681,6 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)
 	const struct qstr *name = &dentry->d_name;
 	struct gfs2_dirent *dent, *prev = NULL;
 	struct buffer_head *bh;
-	int error;
 
 	/* Returns _either_ the entry (if its first in block) or the
 	   previous entry otherwise */
@@ -1710,22 +1709,15 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)
 	}
 	brelse(bh);
 
-	error = gfs2_meta_inode_buffer(dip, &bh);
-	if (error)
-		return error;
-
 	if (!dip->i_entries)
 		gfs2_consist_inode(dip);
-	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	dip->i_entries--;
 	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
 	if (S_ISDIR(dentry->d_inode->i_mode))
 		drop_nlink(&dip->i_inode);
-	gfs2_dinode_out(dip, bh->b_data);
-	brelse(bh);
 	mark_inode_dirty(&dip->i_inode);
 
-	return error;
+	return 0;
 }
 
 /**

commit 4c28d33803d4aeaff32b4ac502af11a9b2aed8f4
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jul 26 09:17:28 2011 +0100

    GFS2: Clean up dir hash table reading
    
    Since there is now only a single caller to gfs2_dir_read_data()
    and it has a number of constant arguments, we can factor
    those out. Also some tests relating to the inode size were
    being done twice.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 1cc2f8ec52a2..2045d70753f1 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -240,16 +240,15 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	return error;
 }
 
-static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, char *buf,
-				 u64 offset, unsigned int size)
+static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, __be64 *buf,
+				 unsigned int size)
 {
 	struct buffer_head *dibh;
 	int error;
 
 	error = gfs2_meta_inode_buffer(ip, &dibh);
 	if (!error) {
-		offset += sizeof(struct gfs2_dinode);
-		memcpy(buf, dibh->b_data + offset, size);
+		memcpy(buf, dibh->b_data + sizeof(struct gfs2_dinode), size);
 		brelse(dibh);
 	}
 
@@ -261,13 +260,12 @@ static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, char *buf,
  * gfs2_dir_read_data - Read a data from a directory inode
  * @ip: The GFS2 Inode
  * @buf: The buffer to place result into
- * @offset: File offset to begin jdata_readng from
  * @size: Amount of data to transfer
  *
  * Returns: The amount of data actually copied or the error
  */
-static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
-			      unsigned int size, unsigned ra)
+static int gfs2_dir_read_data(struct gfs2_inode *ip, __be64 *buf,
+			      unsigned int size)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 	u64 lblock, dblock;
@@ -275,24 +273,14 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 	unsigned int o;
 	int copied = 0;
 	int error = 0;
-	u64 disksize = i_size_read(&ip->i_inode);
-
-	if (offset >= disksize)
-		return 0;
-
-	if (offset + size > disksize)
-		size = disksize - offset;
-
-	if (!size)
-		return 0;
 
 	if (gfs2_is_stuffed(ip))
-		return gfs2_dir_read_stuffed(ip, buf, offset, size);
+		return gfs2_dir_read_stuffed(ip, buf, size);
 
 	if (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))
 		return -EINVAL;
 
-	lblock = offset;
+	lblock = 0;
 	o = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);
 
 	while (copied < size) {
@@ -311,8 +299,6 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 			if (error || !dblock)
 				goto fail;
 			BUG_ON(extlen < 1);
-			if (!ra)
-				extlen = 1;
 			bh = gfs2_meta_ra(ip->i_gl, dblock, extlen);
 		} else {
 			error = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, &bh);
@@ -328,7 +314,7 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 		extlen--;
 		memcpy(buf, bh->b_data + o, amount);
 		brelse(bh);
-		buf += amount;
+		buf += (amount/sizeof(__be64));
 		copied += amount;
 		lblock++;
 		o = sizeof(struct gfs2_meta_header);
@@ -371,7 +357,7 @@ static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)
 	if (hc == NULL)
 		return ERR_PTR(-ENOMEM);
 
-	ret = gfs2_dir_read_data(ip, (char *)hc, 0, hsize, 1);
+	ret = gfs2_dir_read_data(ip, hc, hsize);
 	if (ret < 0) {
 		kfree(hc);
 		return ERR_PTR(ret);

commit 17d539f0499fa2c0321b7c260831cca2bb36d119
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jun 15 10:29:37 2011 +0100

    GFS2: Cache dir hash table in a contiguous buffer
    
    This patch adds a cache for the hash table to the directory code
    in order to help simplify the way in which the hash table is
    accessed. This is intended to be a first step towards introducing
    some performance improvements in the directory code.
    
    There are two follow ups that I'm hoping to see fairly shortly. One
    is to simplify the hash table reading code now that we always read the
    complete hash table, whether we want one entry or all of them. The
    other is to introduce readahead on the heads of the hash chains
    which are referred to from the table.
    
    The hash table is a maximum of 128k in size, so it is not worth trying
    to read it in small chunks.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 091ee4779538..1cc2f8ec52a2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -339,6 +339,67 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 	return (copied) ? copied : error;
 }
 
+/**
+ * gfs2_dir_get_hash_table - Get pointer to the dir hash table
+ * @ip: The inode in question
+ *
+ * Returns: The hash table or an error
+ */
+
+static __be64 *gfs2_dir_get_hash_table(struct gfs2_inode *ip)
+{
+	struct inode *inode = &ip->i_inode;
+	int ret;
+	u32 hsize;
+	__be64 *hc;
+
+	BUG_ON(!(ip->i_diskflags & GFS2_DIF_EXHASH));
+
+	hc = ip->i_hash_cache;
+	if (hc)
+		return hc;
+
+	hsize = 1 << ip->i_depth;
+	hsize *= sizeof(__be64);
+	if (hsize != i_size_read(&ip->i_inode)) {
+		gfs2_consist_inode(ip);
+		return ERR_PTR(-EIO);
+	}
+
+	hc = kmalloc(hsize, GFP_NOFS);
+	ret = -ENOMEM;
+	if (hc == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	ret = gfs2_dir_read_data(ip, (char *)hc, 0, hsize, 1);
+	if (ret < 0) {
+		kfree(hc);
+		return ERR_PTR(ret);
+	}
+
+	spin_lock(&inode->i_lock);
+	if (ip->i_hash_cache)
+		kfree(hc);
+	else
+		ip->i_hash_cache = hc;
+	spin_unlock(&inode->i_lock);
+
+	return ip->i_hash_cache;
+}
+
+/**
+ * gfs2_dir_hash_inval - Invalidate dir hash
+ * @ip: The directory inode
+ *
+ * Must be called with an exclusive glock, or during glock invalidation.
+ */
+void gfs2_dir_hash_inval(struct gfs2_inode *ip)
+{
+	__be64 *hc = ip->i_hash_cache;
+	ip->i_hash_cache = NULL;
+	kfree(hc);
+}
+
 static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)
 {
 	return dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;
@@ -686,17 +747,12 @@ static int get_leaf(struct gfs2_inode *dip, u64 leaf_no,
 static int get_leaf_nr(struct gfs2_inode *dip, u32 index,
 		       u64 *leaf_out)
 {
-	__be64 leaf_no;
-	int error;
-
-	error = gfs2_dir_read_data(dip, (char *)&leaf_no,
-				    index * sizeof(__be64),
-				    sizeof(__be64), 0);
-	if (error != sizeof(u64))
-		return (error < 0) ? error : -EIO;
-
-	*leaf_out = be64_to_cpu(leaf_no);
+	__be64 *hash;
 
+	hash = gfs2_dir_get_hash_table(dip);
+	if (IS_ERR(hash))
+		return PTR_ERR(hash);
+	*leaf_out = be64_to_cpu(*(hash + index));
 	return 0;
 }
 
@@ -966,6 +1022,8 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	for (x = 0; x < half_len; x++)
 		lp[x] = cpu_to_be64(bn);
 
+	gfs2_dir_hash_inval(dip);
+
 	error = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(u64),
 				    half_len * sizeof(u64));
 	if (error != half_len * sizeof(u64)) {
@@ -1052,70 +1110,54 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 static int dir_double_exhash(struct gfs2_inode *dip)
 {
-	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct buffer_head *dibh;
 	u32 hsize;
-	u64 *buf;
-	u64 *from, *to;
-	u64 block;
-	u64 disksize = i_size_read(&dip->i_inode);
+	u32 hsize_bytes;
+	__be64 *hc;
+	__be64 *hc2, *h;
 	int x;
 	int error = 0;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != disksize) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
+	hsize_bytes = hsize * sizeof(__be64);
 
-	/*  Allocate both the "from" and "to" buffers in one big chunk  */
+	hc = gfs2_dir_get_hash_table(dip);
+	if (IS_ERR(hc))
+		return PTR_ERR(hc);
 
-	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_NOFS);
-	if (!buf)
+	h = hc2 = kmalloc(hsize_bytes * 2, GFP_NOFS);
+	if (!hc2)
 		return -ENOMEM;
 
-	for (block = disksize >> sdp->sd_hash_bsize_shift; block--;) {
-		error = gfs2_dir_read_data(dip, (char *)buf,
-					    block * sdp->sd_hash_bsize,
-					    sdp->sd_hash_bsize, 1);
-		if (error != sdp->sd_hash_bsize) {
-			if (error >= 0)
-				error = -EIO;
-			goto fail;
-		}
-
-		from = buf;
-		to = (u64 *)((char *)buf + sdp->sd_hash_bsize);
-
-		for (x = sdp->sd_hash_ptrs; x--; from++) {
-			*to++ = *from;	/*  No endianess worries  */
-			*to++ = *from;
-		}
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		goto out_kfree;
 
-		error = gfs2_dir_write_data(dip,
-					     (char *)buf + sdp->sd_hash_bsize,
-					     block * sdp->sd_sb.sb_bsize,
-					     sdp->sd_sb.sb_bsize);
-		if (error != sdp->sd_sb.sb_bsize) {
-			if (error >= 0)
-				error = -EIO;
-			goto fail;
-		}
+	for (x = 0; x < hsize; x++) {
+		*h++ = *hc;
+		*h++ = *hc;
+		hc++;
 	}
 
-	kfree(buf);
-
-	error = gfs2_meta_inode_buffer(dip, &dibh);
-	if (!gfs2_assert_withdraw(sdp, !error)) {
-		dip->i_depth++;
-		gfs2_dinode_out(dip, dibh->b_data);
-		brelse(dibh);
-	}
+	error = gfs2_dir_write_data(dip, (char *)hc2, 0, hsize_bytes * 2);
+	if (error != (hsize_bytes * 2))
+		goto fail;
 
-	return error;
+	gfs2_dir_hash_inval(dip);
+	dip->i_hash_cache = hc2;
+	dip->i_depth++;
+	gfs2_dinode_out(dip, dibh->b_data);
+	brelse(dibh);
+	return 0;
 
 fail:
-	kfree(buf);
+	/* Replace original hash table & size */
+	gfs2_dir_write_data(dip, (char *)hc, 0, hsize_bytes);
+	i_size_write(&dip->i_inode, hsize_bytes);
+	gfs2_dinode_out(dip, dibh->b_data);
+	brelse(dibh);
+out_kfree:
+	kfree(hc2);
 	return error;
 }
 
@@ -1348,6 +1390,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 	return error;
 }
 
+
 /**
  * dir_e_read - Reads the entries from a directory into a filldir buffer
  * @dip: dinode pointer
@@ -1362,9 +1405,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 		      filldir_t filldir)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
-	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	u32 hsize, len = 0;
-	u32 ht_offset, lp_offset, ht_offset_cur = -1;
 	u32 hash, index;
 	__be64 *lp;
 	int copied = 0;
@@ -1372,37 +1413,17 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	unsigned depth = 0;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != i_size_read(inode)) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-
 	hash = gfs2_dir_offset2hash(*offset);
 	index = hash >> (32 - dip->i_depth);
 
-	lp = kmalloc(sdp->sd_hash_bsize, GFP_NOFS);
-	if (!lp)
-		return -ENOMEM;
+	lp = gfs2_dir_get_hash_table(dip);
+	if (IS_ERR(lp))
+		return PTR_ERR(lp);
 
 	while (index < hsize) {
-		lp_offset = index & (sdp->sd_hash_ptrs - 1);
-		ht_offset = index - lp_offset;
-
-		if (ht_offset_cur != ht_offset) {
-			error = gfs2_dir_read_data(dip, (char *)lp,
-						ht_offset * sizeof(__be64),
-						sdp->sd_hash_bsize, 1);
-			if (error != sdp->sd_hash_bsize) {
-				if (error >= 0)
-					error = -EIO;
-				goto out;
-			}
-			ht_offset_cur = ht_offset;
-		}
-
 		error = gfs2_dir_read_leaf(inode, offset, opaque, filldir,
 					   &copied, &depth,
-					   be64_to_cpu(lp[lp_offset]));
+					   be64_to_cpu(lp[index]));
 		if (error)
 			break;
 
@@ -1410,8 +1431,6 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 		index = (index & ~(len - 1)) + len;
 	}
 
-out:
-	kfree(lp);
 	if (error > 0)
 		error = 0;
 	return error;
@@ -1914,43 +1933,22 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 
 int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 {
-	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct buffer_head *bh;
 	struct gfs2_leaf *leaf;
 	u32 hsize, len;
-	u32 ht_offset, lp_offset, ht_offset_cur = -1;
 	u32 index = 0, next_index;
 	__be64 *lp;
 	u64 leaf_no;
 	int error = 0, last;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != i_size_read(&dip->i_inode)) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
 
-	lp = kmalloc(sdp->sd_hash_bsize, GFP_NOFS);
-	if (!lp)
-		return -ENOMEM;
+	lp = gfs2_dir_get_hash_table(dip);
+	if (IS_ERR(lp))
+		return PTR_ERR(lp);
 
 	while (index < hsize) {
-		lp_offset = index & (sdp->sd_hash_ptrs - 1);
-		ht_offset = index - lp_offset;
-
-		if (ht_offset_cur != ht_offset) {
-			error = gfs2_dir_read_data(dip, (char *)lp,
-						ht_offset * sizeof(__be64),
-						sdp->sd_hash_bsize, 1);
-			if (error != sdp->sd_hash_bsize) {
-				if (error >= 0)
-					error = -EIO;
-				goto out;
-			}
-			ht_offset_cur = ht_offset;
-		}
-
-		leaf_no = be64_to_cpu(lp[lp_offset]);
+		leaf_no = be64_to_cpu(lp[index]);
 		if (leaf_no) {
 			error = get_leaf(dip, leaf_no, &bh);
 			if (error)
@@ -1976,7 +1974,6 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 	}
 
 out:
-	kfree(lp);
 
 	return error;
 }

commit 3d6ecb7d16fd4248fce58387a982a0756ad3fcc2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon May 9 13:30:08 2011 +0100

    GFS2: When adding a new dir entry, inc link count if it is a subdir
    
    This adds an increment of the link count when we add a new directory
    entry, if that entry is itself a directory. This means that we no
    longer need separate code to perform this operation.
    
    Now that both adding and removing directory entries automatically
    update the parent directory's link count if required, that makes
    the code shorter and simpler than before.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 410265151ad1..091ee4779538 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1597,7 +1597,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
  */
 
 int gfs2_dir_add(struct inode *inode, const struct qstr *name,
-		 const struct gfs2_inode *nip, unsigned type)
+		 const struct gfs2_inode *nip)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh;
@@ -1613,7 +1613,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 				return PTR_ERR(dent);
 			dent = gfs2_init_dirent(inode, dent, name, bh);
 			gfs2_inum_out(nip, dent);
-			dent->de_type = cpu_to_be16(type);
+			dent->de_type = cpu_to_be16(IF2DT(nip->i_inode.i_mode));
 			if (ip->i_diskflags & GFS2_DIF_EXHASH) {
 				leaf = (struct gfs2_leaf *)bh->b_data;
 				be16_add_cpu(&leaf->lf_entries, 1);
@@ -1625,6 +1625,8 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			gfs2_trans_add_bh(ip->i_gl, bh, 1);
 			ip->i_entries++;
 			ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
+			if (S_ISDIR(nip->i_inode.i_mode))
+				inc_nlink(&ip->i_inode);
 			gfs2_dinode_out(ip, bh->b_data);
 			brelse(bh);
 			error = 0;

commit 855d23ce2665c56437bd88fa6a0d45b6713bd194
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon May 9 16:42:37 2011 +0100

    GFS2: Make gfs2_dir_del update link count when required
    
    When we remove an entry from a directory, we can save ourselves
    some trouble if we know the type of the entry in question, since
    if it is itself a directory, we can update the link count of the
    parent at the same time as removing the directory entry.
    
    In addition this patch also merges the rmdir and unlink code which
    was almost identical anyway. This eliminates the calls to remove
    the . and .. directory entries on each rmdir (not needed since the
    directory will be deallocated, anyway) which was the only thing preventing
    passing the dentry to gfs2_dir_del(). The passing of the dentry
    rather than just the name allows us to figure out the type of the entry
    which is being removed, and thus adjust the link count when required.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f7a31374ff82..410265151ad1 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1669,8 +1669,9 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
  * Returns: 0 on success, error code on failure
  */
 
-int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
+int gfs2_dir_del(struct gfs2_inode *dip, const struct dentry *dentry)
 {
+	const struct qstr *name = &dentry->d_name;
 	struct gfs2_dirent *dent, *prev = NULL;
 	struct buffer_head *bh;
 	int error;
@@ -1711,6 +1712,8 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	dip->i_entries--;
 	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
+	if (S_ISDIR(dentry->d_inode->i_mode))
+		drop_nlink(&dip->i_inode);
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	mark_inode_dirty(&dip->i_inode);

commit 556bb17998a37dabf7e9e96aa545bcea899be745
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Mar 22 13:56:37 2011 -0400

    GFS2: move function foreach_leaf to gfs2_dir_exhash_dealloc
    
    The previous patches made function gfs2_dir_exhash_dealloc do nothing
    but call function foreach_leaf.  This patch simplifies the code by
    moving the entire function foreach_leaf into gfs2_dir_exhash_dealloc.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 1f5a7ac97f7d..f7a31374ff82 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -85,10 +85,6 @@ struct qstr gfs2_qdotdot __read_mostly;
 typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
 			    const struct qstr *name, void *opaque);
 
-static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
-			u64 leaf_no, struct buffer_head *leaf_bh,
-			int last_dealloc);
-
 int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,
 			    struct buffer_head **bhp)
 {
@@ -1768,81 +1764,6 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 	return 0;
 }
 
-/**
- * foreach_leaf - call a function for each leaf in a directory
- * @dip: the directory
- *
- * Returns: errno
- */
-
-static int foreach_leaf(struct gfs2_inode *dip)
-{
-	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
-	struct buffer_head *bh;
-	struct gfs2_leaf *leaf;
-	u32 hsize, len;
-	u32 ht_offset, lp_offset, ht_offset_cur = -1;
-	u32 index = 0, next_index;
-	__be64 *lp;
-	u64 leaf_no;
-	int error = 0, last;
-
-	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != i_size_read(&dip->i_inode)) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-
-	lp = kmalloc(sdp->sd_hash_bsize, GFP_NOFS);
-	if (!lp)
-		return -ENOMEM;
-
-	while (index < hsize) {
-		lp_offset = index & (sdp->sd_hash_ptrs - 1);
-		ht_offset = index - lp_offset;
-
-		if (ht_offset_cur != ht_offset) {
-			error = gfs2_dir_read_data(dip, (char *)lp,
-						ht_offset * sizeof(__be64),
-						sdp->sd_hash_bsize, 1);
-			if (error != sdp->sd_hash_bsize) {
-				if (error >= 0)
-					error = -EIO;
-				goto out;
-			}
-			ht_offset_cur = ht_offset;
-		}
-
-		leaf_no = be64_to_cpu(lp[lp_offset]);
-		if (leaf_no) {
-			error = get_leaf(dip, leaf_no, &bh);
-			if (error)
-				goto out;
-			leaf = (struct gfs2_leaf *)bh->b_data;
-			len = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));
-			next_index = (index & ~(len - 1)) + len;
-			last = ((next_index >= hsize) ? 1 : 0);
-			error = leaf_dealloc(dip, index, len, leaf_no, bh,
-					     last);
-			brelse(bh);
-			if (error)
-				goto out;
-			index = next_index;
-		} else
-			index++;
-	}
-
-	if (index != hsize) {
-		gfs2_consist_inode(dip);
-		error = -EIO;
-	}
-
-out:
-	kfree(lp);
-
-	return error;
-}
-
 /**
  * leaf_dealloc - Deallocate a directory leaf
  * @dip: the directory
@@ -1988,8 +1909,71 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 
 int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 {
-	/* Dealloc on-disk leaves to FREEMETA state */
-	return foreach_leaf(dip);
+	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
+	struct buffer_head *bh;
+	struct gfs2_leaf *leaf;
+	u32 hsize, len;
+	u32 ht_offset, lp_offset, ht_offset_cur = -1;
+	u32 index = 0, next_index;
+	__be64 *lp;
+	u64 leaf_no;
+	int error = 0, last;
+
+	hsize = 1 << dip->i_depth;
+	if (hsize * sizeof(u64) != i_size_read(&dip->i_inode)) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	lp = kmalloc(sdp->sd_hash_bsize, GFP_NOFS);
+	if (!lp)
+		return -ENOMEM;
+
+	while (index < hsize) {
+		lp_offset = index & (sdp->sd_hash_ptrs - 1);
+		ht_offset = index - lp_offset;
+
+		if (ht_offset_cur != ht_offset) {
+			error = gfs2_dir_read_data(dip, (char *)lp,
+						ht_offset * sizeof(__be64),
+						sdp->sd_hash_bsize, 1);
+			if (error != sdp->sd_hash_bsize) {
+				if (error >= 0)
+					error = -EIO;
+				goto out;
+			}
+			ht_offset_cur = ht_offset;
+		}
+
+		leaf_no = be64_to_cpu(lp[lp_offset]);
+		if (leaf_no) {
+			error = get_leaf(dip, leaf_no, &bh);
+			if (error)
+				goto out;
+			leaf = (struct gfs2_leaf *)bh->b_data;
+			len = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));
+
+			next_index = (index & ~(len - 1)) + len;
+			last = ((next_index >= hsize) ? 1 : 0);
+			error = leaf_dealloc(dip, index, len, leaf_no, bh,
+					     last);
+			brelse(bh);
+			if (error)
+				goto out;
+			index = next_index;
+		} else
+			index++;
+	}
+
+	if (index != hsize) {
+		gfs2_consist_inode(dip);
+		error = -EIO;
+	}
+
+out:
+	kfree(lp);
+
+	return error;
 }
 
 /**

commit ec038c826b5c3c163ad1673390f10e869020c28c
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Mar 22 13:55:23 2011 -0400

    GFS2: pass leaf_bh into leaf_dealloc
    
    Function foreach_leaf used to look up the leaf block address and get
    a buffer_head.  Then it would call leaf_dealloc which did the same
    lookup.  This patch combines the two operations by making foreach_leaf
    pass the leaf bh to leaf_dealloc.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index bd575871f0f2..1f5a7ac97f7d 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -86,7 +86,8 @@ typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
 			    const struct qstr *name, void *opaque);
 
 static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
-			u64 leaf_no, int last_dealloc);
+			u64 leaf_no, struct buffer_head *leaf_bh,
+			int last_dealloc);
 
 int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,
 			    struct buffer_head **bhp)
@@ -1821,8 +1822,9 @@ static int foreach_leaf(struct gfs2_inode *dip)
 			len = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));
 			next_index = (index & ~(len - 1)) + len;
 			last = ((next_index >= hsize) ? 1 : 0);
+			error = leaf_dealloc(dip, index, len, leaf_no, bh,
+					     last);
 			brelse(bh);
-			error = leaf_dealloc(dip, index, len, leaf_no, last);
 			if (error)
 				goto out;
 			index = next_index;
@@ -1847,13 +1849,15 @@ static int foreach_leaf(struct gfs2_inode *dip)
  * @index: the hash table offset in the directory
  * @len: the number of pointers to this leaf
  * @leaf_no: the leaf number
+ * @leaf_bh: buffer_head for the starting leaf
  * last_dealloc: 1 if this is the final dealloc for the leaf, else 0
  *
  * Returns: errno
  */
 
 static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
-			u64 leaf_no, int last_dealloc)
+			u64 leaf_no, struct buffer_head *leaf_bh,
+			int last_dealloc)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct gfs2_leaf *tmp_leaf;
@@ -1885,14 +1889,18 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		goto out_qs;
 
 	/*  Count the number of leaves  */
+	bh = leaf_bh;
 
 	for (blk = leaf_no; blk; blk = nblk) {
-		error = get_leaf(dip, blk, &bh);
-		if (error)
-			goto out_rlist;
+		if (blk != leaf_no) {
+			error = get_leaf(dip, blk, &bh);
+			if (error)
+				goto out_rlist;
+		}
 		tmp_leaf = (struct gfs2_leaf *)bh->b_data;
 		nblk = be64_to_cpu(tmp_leaf->lf_next);
-		brelse(bh);
+		if (blk != leaf_no)
+			brelse(bh);
 
 		gfs2_rlist_add(sdp, &rlist, blk);
 		l_blocks++;
@@ -1916,13 +1924,18 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (error)
 		goto out_rg_gunlock;
 
+	bh = leaf_bh;
+
 	for (blk = leaf_no; blk; blk = nblk) {
-		error = get_leaf(dip, blk, &bh);
-		if (error)
-			goto out_end_trans;
+		if (blk != leaf_no) {
+			error = get_leaf(dip, blk, &bh);
+			if (error)
+				goto out_end_trans;
+		}
 		tmp_leaf = (struct gfs2_leaf *)bh->b_data;
 		nblk = be64_to_cpu(tmp_leaf->lf_next);
-		brelse(bh);
+		if (blk != leaf_no)
+			brelse(bh);
 
 		gfs2_free_meta(dip, blk, 1);
 		gfs2_add_inode_blocks(&dip->i_inode, -1);

commit d24a7a439a329b60f8e168c03e80566519e09be2
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Mar 22 13:54:03 2011 -0400

    GFS2: Combine transaction from gfs2_dir_exhash_dealloc
    
    At the end of function gfs2_dir_exhash_dealloc, it was setting the dinode
    type to "file" to prevent directory corruption in case of a crash.
    It was doing so in its own journal transaction.  This patch makes the
    change occur when the last call is make to leaf_dealloc, since it needs
    to rewrite the directory dinode at that time anyway.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 0bb5f6bed591..bd575871f0f2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -86,7 +86,7 @@ typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
 			    const struct qstr *name, void *opaque);
 
 static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
-			u64 leaf_no);
+			u64 leaf_no, int last_dealloc);
 
 int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,
 			    struct buffer_head **bhp)
@@ -1781,10 +1781,10 @@ static int foreach_leaf(struct gfs2_inode *dip)
 	struct gfs2_leaf *leaf;
 	u32 hsize, len;
 	u32 ht_offset, lp_offset, ht_offset_cur = -1;
-	u32 index = 0;
+	u32 index = 0, next_index;
 	__be64 *lp;
 	u64 leaf_no;
-	int error = 0;
+	int error = 0, last;
 
 	hsize = 1 << dip->i_depth;
 	if (hsize * sizeof(u64) != i_size_read(&dip->i_inode)) {
@@ -1819,13 +1819,13 @@ static int foreach_leaf(struct gfs2_inode *dip)
 				goto out;
 			leaf = (struct gfs2_leaf *)bh->b_data;
 			len = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));
+			next_index = (index & ~(len - 1)) + len;
+			last = ((next_index >= hsize) ? 1 : 0);
 			brelse(bh);
-
-			error = leaf_dealloc(dip, index, len, leaf_no);
+			error = leaf_dealloc(dip, index, len, leaf_no, last);
 			if (error)
 				goto out;
-
-			index = (index & ~(len - 1)) + len;
+			index = next_index;
 		} else
 			index++;
 	}
@@ -1847,13 +1847,13 @@ static int foreach_leaf(struct gfs2_inode *dip)
  * @index: the hash table offset in the directory
  * @len: the number of pointers to this leaf
  * @leaf_no: the leaf number
- * @data: not used
+ * last_dealloc: 1 if this is the final dealloc for the leaf, else 0
  *
  * Returns: errno
  */
 
 static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
-			u64 leaf_no)
+			u64 leaf_no, int last_dealloc)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct gfs2_leaf *tmp_leaf;
@@ -1940,6 +1940,10 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		goto out_end_trans;
 
 	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
+	/* On the last dealloc, make this a regular file in case we crash.
+	   (We don't want to free these blocks a second time.)  */
+	if (last_dealloc)
+		dip->i_inode.i_mode = S_IFREG;
 	gfs2_dinode_out(dip, dibh->b_data);
 	brelse(dibh);
 
@@ -1971,33 +1975,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 
 int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 {
-	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
-	struct buffer_head *bh;
-	int error;
-
 	/* Dealloc on-disk leaves to FREEMETA state */
-	error = foreach_leaf(dip);
-	if (error)
-		return error;
-
-	/* Make this a regular file in case we crash.
-	   (We don't want to free these blocks a second time.)  */
-
-	error = gfs2_trans_begin(sdp, RES_DINODE, 0);
-	if (error)
-		return error;
-
-	error = gfs2_meta_inode_buffer(dip, &bh);
-	if (!error) {
-		gfs2_trans_add_bh(dip->i_gl, bh, 1);
-		((struct gfs2_dinode *)bh->b_data)->di_mode =
-						cpu_to_be32(S_IFREG);
-		brelse(bh);
-	}
-
-	gfs2_trans_end(sdp);
-
-	return error;
+	return foreach_leaf(dip);
 }
 
 /**

commit 0d95326d9bd39f6eae80b91392b308c5fa8b1a0f
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Mar 22 13:52:44 2011 -0400

    GFS2: remove *leaf_call_t and simplify leaf_dealloc
    
    Since foreach_leaf is only called with leaf_dealloc as its only possible
    call function, we can simplify the code by making it call leaf_dealloc
    directly.  This simplifies the code and eliminates the need for
    leaf_call_t, the generic call method.  This is a first small step in
    simplifying the directory leaf deallocation code.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f789c5732b7c..0bb5f6bed591 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -82,11 +82,11 @@
 struct qstr gfs2_qdot __read_mostly;
 struct qstr gfs2_qdotdot __read_mostly;
 
-typedef int (*leaf_call_t) (struct gfs2_inode *dip, u32 index, u32 len,
-			    u64 leaf_no, void *data);
 typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
 			    const struct qstr *name, void *opaque);
 
+static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
+			u64 leaf_no);
 
 int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,
 			    struct buffer_head **bhp)
@@ -1770,13 +1770,11 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 /**
  * foreach_leaf - call a function for each leaf in a directory
  * @dip: the directory
- * @lc: the function to call for each each
- * @data: private data to pass to it
  *
  * Returns: errno
  */
 
-static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
+static int foreach_leaf(struct gfs2_inode *dip)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct buffer_head *bh;
@@ -1823,7 +1821,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 			len = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));
 			brelse(bh);
 
-			error = lc(dip, index, len, leaf_no, data);
+			error = leaf_dealloc(dip, index, len, leaf_no);
 			if (error)
 				goto out;
 
@@ -1855,7 +1853,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
  */
 
 static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
-			u64 leaf_no, void *data)
+			u64 leaf_no)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct gfs2_leaf *tmp_leaf;
@@ -1978,7 +1976,7 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 	int error;
 
 	/* Dealloc on-disk leaves to FREEMETA state */
-	error = foreach_leaf(dip, leaf_dealloc, NULL);
+	error = foreach_leaf(dip);
 	if (error)
 		return error;
 

commit 44ad37d69b2cc421d5b5c7ad7fed16230685b092
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Mar 17 16:19:58 2011 -0400

    GFS2: filesystem hang caused by incorrect lock order
    
    This patch fixes a deadlock in GFS2 where two processes are trying
    to reclaim an unlinked dinode:
    One holds the inode glock and calls gfs2_lookup_by_inum trying to look
    up the inode, which it can't, due to I_FREEING.  The other has set
    I_FREEING from vfs and is at the beginning of gfs2_delete_inode
    waiting for the glock, which is held by the first.  The solution is to
    add a new non_block parameter to the gfs2_iget function that causes it
    to return -ENOENT if the inode is being freed.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 5c356d09c321..f789c5732b7c 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1506,7 +1506,7 @@ struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name)
 		inode = gfs2_inode_lookup(dir->i_sb, 
 				be16_to_cpu(dent->de_type),
 				be64_to_cpu(dent->de_inum.no_addr),
-				be64_to_cpu(dent->de_inum.no_formal_ino));
+				be64_to_cpu(dent->de_inum.no_formal_ino), 0);
 		brelse(bh);
 		return inode;
 	}

commit 8d1235852b462cfb66aa036bd4a2686763c69ed4
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 17 12:30:23 2010 +0100

    GFS2: Make . and .. qstrs constant
    
    Rather than calculating the qstrs for . and .. each time
    we need them, its better to keep a constant version of
    these and just refer to them when required.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c1042ae438cc..5c356d09c321 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -79,6 +79,9 @@
 #define gfs2_disk_hash2offset(h) (((u64)(h)) >> 1)
 #define gfs2_dir_offset2hash(p) ((u32)(((u64)(p)) << 1))
 
+struct qstr gfs2_qdot __read_mostly;
+struct qstr gfs2_qdotdot __read_mostly;
+
 typedef int (*leaf_call_t) (struct gfs2_inode *dip, u32 index, u32 len,
 			    u64 leaf_no, void *data);
 typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,

commit a2e0f79939e09e74698564b88dee709db208e1e2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 11 09:53:11 2010 +0100

    GFS2: Remove i_disksize
    
    With the update of the truncate code, ip->i_disksize and
    inode->i_size are merely copies of each other. This means
    we can remove ip->i_disksize and use inode->i_size exclusively
    reducing the size of a GFS2 inode by 8 bytes.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index b9dd88a78dd4..c1042ae438cc 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -127,8 +127,8 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
 	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
-	if (ip->i_disksize < offset + size)
-		ip->i_disksize = offset + size;
+	if (ip->i_inode.i_size < offset + size)
+		i_size_write(&ip->i_inode, offset + size);
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 	gfs2_dinode_out(ip, dibh->b_data);
 
@@ -225,8 +225,8 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	if (error)
 		return error;
 
-	if (ip->i_disksize < offset + copied)
-		ip->i_disksize = offset + copied;
+	if (ip->i_inode.i_size < offset + copied)
+		i_size_write(&ip->i_inode, offset + copied);
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
@@ -275,12 +275,13 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 	unsigned int o;
 	int copied = 0;
 	int error = 0;
+	u64 disksize = i_size_read(&ip->i_inode);
 
-	if (offset >= ip->i_disksize)
+	if (offset >= disksize)
 		return 0;
 
-	if (offset + size > ip->i_disksize)
-		size = ip->i_disksize - offset;
+	if (offset + size > disksize)
+		size = disksize - offset;
 
 	if (!size)
 		return 0;
@@ -727,7 +728,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 		unsigned hsize = 1 << ip->i_depth;
 		unsigned index;
 		u64 ln;
-		if (hsize * sizeof(u64) != ip->i_disksize) {
+		if (hsize * sizeof(u64) != i_size_read(inode)) {
 			gfs2_consist_inode(ip);
 			return ERR_PTR(-EIO);
 		}
@@ -879,7 +880,7 @@ static int dir_make_exhash(struct inode *inode)
 	for (x = sdp->sd_hash_ptrs; x--; lp++)
 		*lp = cpu_to_be64(bn);
 
-	dip->i_disksize = sdp->sd_sb.sb_bsize / 2;
+	i_size_write(inode, sdp->sd_sb.sb_bsize / 2);
 	gfs2_add_inode_blocks(&dip->i_inode, 1);
 	dip->i_diskflags |= GFS2_DIF_EXHASH;
 
@@ -1057,11 +1058,12 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	u64 *buf;
 	u64 *from, *to;
 	u64 block;
+	u64 disksize = i_size_read(&dip->i_inode);
 	int x;
 	int error = 0;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != dip->i_disksize) {
+	if (hsize * sizeof(u64) != disksize) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1072,7 +1074,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	if (!buf)
 		return -ENOMEM;
 
-	for (block = dip->i_disksize >> sdp->sd_hash_bsize_shift; block--;) {
+	for (block = disksize >> sdp->sd_hash_bsize_shift; block--;) {
 		error = gfs2_dir_read_data(dip, (char *)buf,
 					    block * sdp->sd_hash_bsize,
 					    sdp->sd_hash_bsize, 1);
@@ -1370,7 +1372,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	unsigned depth = 0;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != dip->i_disksize) {
+	if (hsize * sizeof(u64) != i_size_read(inode)) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1784,7 +1786,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 	int error = 0;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != dip->i_disksize) {
+	if (hsize * sizeof(u64) != i_size_read(&dip->i_inode)) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}

commit 4244b52e18be959ced77b984f268e46a0a7654e3
Author: David Rientjes <rientjes@google.com>
Date:   Tue Jul 20 19:45:03 2010 -0700

    GFS2: remove dependency on __GFP_NOFAIL
    
    The k[mc]allocs in dr_split_leaf() and dir_double_exhash() are failable,
    so remove __GFP_NOFAIL from their masks.
    
    Cc: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: David Rientjes <rientjes@google.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 6b48d7c268b2..b9dd88a78dd4 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -955,7 +955,12 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	/* Change the pointers.
 	   Don't bother distinguishing stuffed from non-stuffed.
 	   This code is complicated enough already. */
-	lp = kmalloc(half_len * sizeof(__be64), GFP_NOFS | __GFP_NOFAIL);
+	lp = kmalloc(half_len * sizeof(__be64), GFP_NOFS);
+	if (!lp) {
+		error = -ENOMEM;
+		goto fail_brelse;
+	}
+
 	/*  Change the pointers  */
 	for (x = 0; x < half_len; x++)
 		lp[x] = cpu_to_be64(bn);
@@ -1063,7 +1068,9 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 
 	/*  Allocate both the "from" and "to" buffers in one big chunk  */
 
-	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_NOFS | __GFP_NOFAIL);
+	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_NOFS);
+	if (!buf)
+		return -ENOMEM;
 
 	for (block = dip->i_disksize >> sdp->sd_hash_bsize_shift; block--;) {
 		error = gfs2_dir_read_data(dip, (char *)buf,

commit d2a97a4e99ff0ffdccd1fc46f22fb34270ef1e56
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jul 28 17:56:23 2010 +0100

    GFS2: Use kmalloc when possible for ->readdir()
    
    If we don't need a huge amount of memory in ->readdir() then
    we can use kmalloc rather than vmalloc to allocate it. This
    should cut down on the greater overheads associated with
    vmalloc for smaller directories.
    
    We may be able to eliminate vmalloc entirely at some stage,
    but this is easy to do right away.
    
    Also using GFP_NOFS to avoid any issues wrt to deleting inodes
    while under a glock, and suggestion from Linus to factor out
    the alloc/dealloc.
    
    I've given this a test with a variety of different sized
    directories and it seems to work ok.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Nick Piggin <npiggin@suse.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 26ca3361a8bc..6b48d7c268b2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1231,6 +1231,25 @@ static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 	return 0;
 }
 
+static void *gfs2_alloc_sort_buffer(unsigned size)
+{
+	void *ptr = NULL;
+
+	if (size < KMALLOC_MAX_SIZE)
+		ptr = kmalloc(size, GFP_NOFS | __GFP_NOWARN);
+	if (!ptr)
+		ptr = __vmalloc(size, GFP_NOFS, PAGE_KERNEL);
+	return ptr;
+}
+
+static void gfs2_free_sort_buffer(void *ptr)
+{
+	if (is_vmalloc_addr(ptr))
+		vfree(ptr);
+	else
+		kfree(ptr);
+}
+
 static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 			      filldir_t filldir, int *copied, unsigned *depth,
 			      u64 leaf_no)
@@ -1271,7 +1290,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 	 * 99 is the maximum number of entries that can fit in a single
 	 * leaf block.
 	 */
-	larr = vmalloc((leaves + entries + 99) * sizeof(void *));
+	larr = gfs2_alloc_sort_buffer((leaves + entries + 99) * sizeof(void *));
 	if (!larr)
 		goto out;
 	darr = (const struct gfs2_dirent **)(larr + leaves);
@@ -1282,7 +1301,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 	do {
 		error = get_leaf(ip, lfn, &bh);
 		if (error)
-			goto out_kfree;
+			goto out_free;
 		lf = (struct gfs2_leaf *)bh->b_data;
 		lfn = be64_to_cpu(lf->lf_next);
 		if (lf->lf_entries) {
@@ -1291,7 +1310,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 						gfs2_dirent_gather, NULL, &g);
 			error = PTR_ERR(dent);
 			if (IS_ERR(dent))
-				goto out_kfree;
+				goto out_free;
 			if (entries2 != g.offset) {
 				fs_warn(sdp, "Number of entries corrupt in dir "
 						"leaf %llu, entries2 (%u) != "
@@ -1300,7 +1319,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 					entries2, g.offset);
 					
 				error = -EIO;
-				goto out_kfree;
+				goto out_free;
 			}
 			error = 0;
 			larr[leaf++] = bh;
@@ -1312,10 +1331,10 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 	BUG_ON(entries2 != entries);
 	error = do_filldir_main(ip, offset, opaque, filldir, darr,
 				entries, copied);
-out_kfree:
+out_free:
 	for(i = 0; i < leaf; i++)
 		brelse(larr[i]);
-	vfree(larr);
+	gfs2_free_sort_buffer(larr);
 out:
 	return error;
 }

commit 728a756b8fcd22d80e2dbba8117a8a3aafd3f203
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Jul 14 18:12:26 2010 -0400

    GFS2: rename causes kernel Oops
    
    This patch fixes a kernel Oops in the GFS2 rename code.
    
    The problem was in the way the gfs2 directory code was trying
    to re-use sentinel directory entries.
    
    In the failing case, gfs2's rename function was renaming a
    file to another name that had the same non-trivial length.
    The file being renamed happened to be the first directory
    entry on the leaf block.
    
    First, the rename code (gfs2_rename in ops_inode.c) found the
    original directory entry and decided it could do its job by
    simply replacing the directory entry with another.  Therefore
    it determined correctly that no block allocations were needed.
    
    Next, the rename code deleted the old directory entry prior to
    replacing it with the new name.  Therefore, the soon-to-be
    replaced directory entry was temporarily made into a directory
    entry "sentinel" or a place holder at the start of a leaf block.
    
    Lastly, it went to re-add the replacement directory entry in
    that leaf block.  However, when gfs2_dirent_find_space was
    looking for space in the leaf block, it used the wrong value
    for the sentinel.  That threw off its calculations so later
    it decides it can't really re-use the sentinel and therefore
    must allocate a new leaf block.  But because it previously decided
    to re-use the directory entry, it didn't waste the time to
    grab a new block allocation for the inode.  Therefore, the
    inode's i_alloc pointer was still NULL and it crashes trying to
    reference it.
    
    In the case of sentinel directory entries, the entire dirent is
    reused, not just the "free space" portion of it, and therefore
    the function gfs2_dirent_find_space should use the value 0
    rather than GFS2_DIRENT_SIZE(0) for the actual dirent size.
    
    Fixing this calculation enables the reproducer programs to work
    properly.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 8295c5b5d4a9..26ca3361a8bc 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -392,7 +392,7 @@ static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,
 	unsigned totlen = be16_to_cpu(dent->de_rec_len);
 
 	if (gfs2_dirent_sentinel(dent))
-		actual = GFS2_DIRENT_SIZE(0);
+		actual = 0;
 	if (totlen - actual >= required)
 		return 1;
 	return 0;

commit 1a0eae8848cde6e0734360f6456496c995ee1e23
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Apr 14 11:58:16 2010 -0400

    GFS2: glock livelock
    
    This patch fixes a couple gfs2 problems with the reclaiming of
    unlinked dinodes.  First, there were a couple of livelocks where
    everything would come to a halt waiting for a glock that was
    seemingly held by a process that no longer existed.  In fact, the
    process did exist, it just had the wrong pid number in the holder
    information.  Second, there was a lock ordering problem between
    inode locking and glock locking.  Third, glock/inode contention
    could sometimes cause inodes to be improperly marked invalid by
    iget_failed.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 25fddc100f18..8295c5b5d4a9 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1475,7 +1475,7 @@ struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name)
 		inode = gfs2_inode_lookup(dir->i_sb, 
 				be16_to_cpu(dent->de_type),
 				be64_to_cpu(dent->de_inum.no_addr),
-				be64_to_cpu(dent->de_inum.no_formal_ino), 0);
+				be64_to_cpu(dent->de_inum.no_formal_ino));
 		brelse(bh);
 		return inode;
 	}

commit 1579343a73e32b5886e186e8f3e4db85e420ed3f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Nov 6 11:06:37 2009 +0000

    GFS2: Remove dirent_first() function
    
    This function only had one caller left, and that caller only
    called it for leaf blocks, hence one branch of the "if" was
    never taken. In addition the call to get_left had already
    verified the metadata type, so the function can be reduced
    to a single line of code in its caller.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 297d7e5cebad..25fddc100f18 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -525,38 +525,6 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,
 	return ERR_PTR(-EIO);
 }
 
-
-/**
- * dirent_first - Return the first dirent
- * @dip: the directory
- * @bh: The buffer
- * @dent: Pointer to list of dirents
- *
- * return first dirent whether bh points to leaf or stuffed dinode
- *
- * Returns: IS_LEAF, IS_DINODE, or -errno
- */
-
-static int dirent_first(struct gfs2_inode *dip, struct buffer_head *bh,
-			struct gfs2_dirent **dent)
-{
-	struct gfs2_meta_header *h = (struct gfs2_meta_header *)bh->b_data;
-
-	if (be32_to_cpu(h->mh_type) == GFS2_METATYPE_LF) {
-		if (gfs2_meta_check(GFS2_SB(&dip->i_inode), bh))
-			return -EIO;
-		*dent = (struct gfs2_dirent *)(bh->b_data +
-					       sizeof(struct gfs2_leaf));
-		return IS_LEAF;
-	} else {
-		if (gfs2_metatype_check(GFS2_SB(&dip->i_inode), bh, GFS2_METATYPE_DI))
-			return -EIO;
-		*dent = (struct gfs2_dirent *)(bh->b_data +
-					       sizeof(struct gfs2_dinode));
-		return IS_DINODE;
-	}
-}
-
 static int dirent_check_reclen(struct gfs2_inode *dip,
 			       const struct gfs2_dirent *d, const void *end_p)
 {
@@ -1006,7 +974,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	divider = (start + half_len) << (32 - dip->i_depth);
 
 	/*  Copy the entries  */
-	dirent_first(dip, obh, &dent);
+	dent = (struct gfs2_dirent *)(obh->b_data + sizeof(struct gfs2_leaf));
 
 	do {
 		next = dent;

commit 09010978345e8883003bf411bb99753710eb5a3a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed May 20 10:48:47 2009 +0100

    GFS2: Improve resource group error handling
    
    This patch improves the error handling in the case where we
    discover that the summary information in the resource group
    doesn't match the bitmap information while in the process of
    allocating blocks. Originally this resulted in a kernel bug,
    but this patch changes that so that we return -EIO and print
    some messages explaining what went wrong, and how to fix it.
    
    We also remember locally not to try and allocate from the
    same rgrp again, so that a subsequent allocation in a
    different rgrp should succeed.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index aef4d0c06748..297d7e5cebad 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -803,13 +803,20 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
 	unsigned int n = 1;
-	u64 bn = gfs2_alloc_block(ip, &n);
-	struct buffer_head *bh = gfs2_meta_new(ip->i_gl, bn);
+	u64 bn;
+	int error;
+	struct buffer_head *bh;
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;
 	struct qstr name = { .name = "", .len = 0, .hash = 0 };
+
+	error = gfs2_alloc_block(ip, &bn, &n);
+	if (error)
+		return NULL;
+	bh = gfs2_meta_new(ip->i_gl, bn);
 	if (!bh)
 		return NULL;
+
 	gfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);
 	gfs2_trans_add_bh(ip->i_gl, bh, 1);
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);

commit f057f6cdf64175db1151b1f5d110e29904f119a1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 12 10:43:39 2009 +0000

    GFS2: Merge lock_dlm module into GFS2
    
    This is the big patch that I've been working on for some time
    now. There are many reasons for wanting to make this change
    such as:
     o Reducing overhead by eliminating duplicated fields between structures
     o Simplifcation of the code (reduces the code size by a fair bit)
     o The locking interface is now the DLM interface itself as proposed
       some time ago.
     o Fewer lookups of glocks when processing replies from the DLM
     o Fewer memory allocations/deallocations for each glock
     o Scope to do further optimisations in the future (but this patch is
       more than big enough for now!)
    
    Please note that (a) this patch relates to the lock_dlm module and
    not the DLM itself, that is still a separate module; and (b) that
    we retain the ability to build GFS2 as a standalone single node
    filesystem with out requiring the DLM.
    
    This patch needs a lot of testing, hence my keeping it I restarted
    my -git tree after the last merge window. That way, this has the maximum
    exposure before its merged. This is (modulo a few minor bug fixes) the
    same patch that I've been posting on and off the the last three months
    and its passed a number of different tests so far.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index b7c8e5c70791..aef4d0c06748 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -60,7 +60,6 @@
 #include <linux/gfs2_ondisk.h>
 #include <linux/crc32.h>
 #include <linux/vmalloc.h>
-#include <linux/lm_interface.h>
 
 #include "gfs2.h"
 #include "incore.h"

commit 383f01fbf4a701b73f5e35ea805ed1700b4b4db9
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 4 10:05:22 2008 +0000

    GFS2: Banish struct gfs2_dinode_host
    
    The final field in gfs2_dinode_host was the i_flags field. Thats
    renamed to i_diskflags in order to avoid confusion with the existing
    inode flags, and moved into the inode proper at a suitable location
    to avoid creating a "hole".
    
    At that point struct gfs2_dinode_host is no longer needed and as
    promised (quite some time ago!) it can now be removed completely.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d8d823240542..b7c8e5c70791 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -36,7 +36,7 @@
  * the block.  In leaves, they begin at offset sizeof(struct gfs2_leaf) from the
  * beginning of the leaf block. The dirents reside in leaves when
  *
- * dip->i_di.di_flags & GFS2_DIF_EXHASH is true
+ * dip->i_diskflags & GFS2_DIF_EXHASH is true
  *
  * Otherwise, the dirents are "linear", within a single stuffed dinode block.
  *
@@ -755,7 +755,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 	struct gfs2_inode *ip = GFS2_I(inode);
 	int error;
 
-	if (ip->i_di.di_flags & GFS2_DIF_EXHASH) {
+	if (ip->i_diskflags & GFS2_DIF_EXHASH) {
 		struct gfs2_leaf *leaf;
 		unsigned hsize = 1 << ip->i_depth;
 		unsigned index;
@@ -907,7 +907,7 @@ static int dir_make_exhash(struct inode *inode)
 
 	dip->i_disksize = sdp->sd_sb.sb_bsize / 2;
 	gfs2_add_inode_blocks(&dip->i_inode, 1);
-	dip->i_di.di_flags |= GFS2_DIF_EXHASH;
+	dip->i_diskflags |= GFS2_DIF_EXHASH;
 
 	for (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;
 	dip->i_depth = y;
@@ -1429,7 +1429,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 	if (!dip->i_entries)
 		return 0;
 
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
+	if (dip->i_diskflags & GFS2_DIF_EXHASH)
 		return dir_e_read(inode, offset, opaque, filldir);
 
 	if (!gfs2_is_stuffed(dip)) {
@@ -1612,7 +1612,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			dent = gfs2_init_dirent(inode, dent, name, bh);
 			gfs2_inum_out(nip, dent);
 			dent->de_type = cpu_to_be16(type);
-			if (ip->i_di.di_flags & GFS2_DIF_EXHASH) {
+			if (ip->i_diskflags & GFS2_DIF_EXHASH) {
 				leaf = (struct gfs2_leaf *)bh->b_data;
 				be16_add_cpu(&leaf->lf_entries, 1);
 			}
@@ -1628,7 +1628,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			error = 0;
 			break;
 		}
-		if (!(ip->i_di.di_flags & GFS2_DIF_EXHASH)) {
+		if (!(ip->i_diskflags & GFS2_DIF_EXHASH)) {
 			error = dir_make_exhash(inode);
 			if (error)
 				break;
@@ -1691,7 +1691,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 	}
 
 	dirent_del(dip, bh, prev, dent);
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH) {
+	if (dip->i_diskflags & GFS2_DIF_EXHASH) {
 		struct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;
 		u16 entries = be16_to_cpu(leaf->lf_entries);
 		if (!entries)
@@ -1748,7 +1748,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 	gfs2_inum_out(nip, dent);
 	dent->de_type = cpu_to_be16(new_type);
 
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH) {
+	if (dip->i_diskflags & GFS2_DIF_EXHASH) {
 		brelse(bh);
 		error = gfs2_meta_inode_buffer(dip, &bh);
 		if (error)

commit c9e98886776386f1f7828d9685e78cd341849867
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 4 09:47:33 2008 +0000

    GFS2: Move i_size from gfs2_dinode_host and rename it to i_disksize
    
    This patch moved the i_size field from the gfs2_dinode_host and
    following the ext3 convention renames it i_disksize.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 830cf48184e3..d8d823240542 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -128,8 +128,8 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
 	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
-	if (ip->i_di.di_size < offset + size)
-		ip->i_di.di_size = offset + size;
+	if (ip->i_disksize < offset + size)
+		ip->i_disksize = offset + size;
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 	gfs2_dinode_out(ip, dibh->b_data);
 
@@ -226,8 +226,8 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	if (error)
 		return error;
 
-	if (ip->i_di.di_size < offset + copied)
-		ip->i_di.di_size = offset + copied;
+	if (ip->i_disksize < offset + copied)
+		ip->i_disksize = offset + copied;
 	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
@@ -277,11 +277,11 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 	int copied = 0;
 	int error = 0;
 
-	if (offset >= ip->i_di.di_size)
+	if (offset >= ip->i_disksize)
 		return 0;
 
-	if (offset + size > ip->i_di.di_size)
-		size = ip->i_di.di_size - offset;
+	if (offset + size > ip->i_disksize)
+		size = ip->i_disksize - offset;
 
 	if (!size)
 		return 0;
@@ -760,7 +760,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 		unsigned hsize = 1 << ip->i_depth;
 		unsigned index;
 		u64 ln;
-		if (hsize * sizeof(u64) != ip->i_di.di_size) {
+		if (hsize * sizeof(u64) != ip->i_disksize) {
 			gfs2_consist_inode(ip);
 			return ERR_PTR(-EIO);
 		}
@@ -905,7 +905,7 @@ static int dir_make_exhash(struct inode *inode)
 	for (x = sdp->sd_hash_ptrs; x--; lp++)
 		*lp = cpu_to_be64(bn);
 
-	dip->i_di.di_size = sdp->sd_sb.sb_bsize / 2;
+	dip->i_disksize = sdp->sd_sb.sb_bsize / 2;
 	gfs2_add_inode_blocks(&dip->i_inode, 1);
 	dip->i_di.di_flags |= GFS2_DIF_EXHASH;
 
@@ -1082,7 +1082,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	int error = 0;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != dip->i_di.di_size) {
+	if (hsize * sizeof(u64) != dip->i_disksize) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1091,7 +1091,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 
 	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_NOFS | __GFP_NOFAIL);
 
-	for (block = dip->i_di.di_size >> sdp->sd_hash_bsize_shift; block--;) {
+	for (block = dip->i_disksize >> sdp->sd_hash_bsize_shift; block--;) {
 		error = gfs2_dir_read_data(dip, (char *)buf,
 					    block * sdp->sd_hash_bsize,
 					    sdp->sd_hash_bsize, 1);
@@ -1370,7 +1370,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	unsigned depth = 0;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != dip->i_di.di_size) {
+	if (hsize * sizeof(u64) != dip->i_disksize) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1784,7 +1784,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 	int error = 0;
 
 	hsize = 1 << dip->i_depth;
-	if (hsize * sizeof(u64) != dip->i_di.di_size) {
+	if (hsize * sizeof(u64) != dip->i_disksize) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}

commit ad6203f2b46c2217f74b2e88299640eef5889e72
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Nov 3 13:59:19 2008 +0000

    GFS2: Move "entries" into "proper" inode
    
    This moves the directory entry count into the proper inode.
    Potentially we could get this to share the space used by
    something else in the future, but this is one more step
    on the way to removing the gfs2_dinode_host structure.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index eed040d8ba3a..830cf48184e3 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -858,8 +858,8 @@ static int dir_make_exhash(struct inode *inode)
 		return -ENOSPC;
 	bn = bh->b_blocknr;
 
-	gfs2_assert(sdp, dip->i_di.di_entries < (1 << 16));
-	leaf->lf_entries = cpu_to_be16(dip->i_di.di_entries);
+	gfs2_assert(sdp, dip->i_entries < (1 << 16));
+	leaf->lf_entries = cpu_to_be16(dip->i_entries);
 
 	/*  Copy dirents  */
 
@@ -1426,7 +1426,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 	int copied = 0;
 	int error;
 
-	if (!dip->i_di.di_entries)
+	if (!dip->i_entries)
 		return 0;
 
 	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
@@ -1453,17 +1453,17 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 			error = PTR_ERR(dent);
 			goto out;
 		}
-		if (dip->i_di.di_entries != g.offset) {
+		if (dip->i_entries != g.offset) {
 			fs_warn(sdp, "Number of entries corrupt in dir %llu, "
-				"ip->i_di.di_entries (%u) != g.offset (%u)\n",
+				"ip->i_entries (%u) != g.offset (%u)\n",
 				(unsigned long long)dip->i_no_addr,
-				dip->i_di.di_entries,
+				dip->i_entries,
 				g.offset);
 			error = -EIO;
 			goto out;
 		}
 		error = do_filldir_main(dip, offset, opaque, filldir, darr,
-					dip->i_di.di_entries, &copied);
+					dip->i_entries, &copied);
 out:
 		kfree(darr);
 	}
@@ -1621,7 +1621,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			if (error)
 				break;
 			gfs2_trans_add_bh(ip->i_gl, bh, 1);
-			ip->i_di.di_entries++;
+			ip->i_entries++;
 			ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 			gfs2_dinode_out(ip, bh->b_data);
 			brelse(bh);
@@ -1704,10 +1704,10 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 	if (error)
 		return error;
 
-	if (!dip->i_di.di_entries)
+	if (!dip->i_entries)
 		gfs2_consist_inode(dip);
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
-	dip->i_di.di_entries--;
+	dip->i_entries--;
 	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);

commit 16c5f06f15ad4e5a5d6e90b78ffb1ac14319e445
Author: Josef Bacik <jbacik@redhat.com>
Date:   Wed Apr 9 09:33:41 2008 -0400

    [GFS2] fix GFP_KERNEL misuses
    
    There are several places where GFP_KERNEL allocations happen under a glock,
    which will result in hangs if we're under memory pressure and go to re-enter the
    fs in order to flush stuff out.  This patch changes the culprits to GFS_NOFS to
    keep this problem from happening.  Thank you,
    
    Signed-off-by: Josef Bacik <jbacik@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 94070ad8826b..eed040d8ba3a 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1089,7 +1089,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 
 	/*  Allocate both the "from" and "to" buffers in one big chunk  */
 
-	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_KERNEL | __GFP_NOFAIL);
+	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_NOFS | __GFP_NOFAIL);
 
 	for (block = dip->i_di.di_size >> sdp->sd_hash_bsize_shift; block--;) {
 		error = gfs2_dir_read_data(dip, (char *)buf,
@@ -1378,7 +1378,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	hash = gfs2_dir_offset2hash(*offset);
 	index = hash >> (32 - dip->i_depth);
 
-	lp = kmalloc(sdp->sd_hash_bsize, GFP_KERNEL);
+	lp = kmalloc(sdp->sd_hash_bsize, GFP_NOFS);
 	if (!lp)
 		return -ENOMEM;
 
@@ -1443,7 +1443,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 
 	error = -ENOMEM;
 	/* 96 is max number of dirents which can be stuffed into an inode */
-	darr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_KERNEL);
+	darr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_NOFS);
 	if (darr) {
 		g.pdent = darr;
 		g.offset = 0;
@@ -1789,7 +1789,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 		return -EIO;
 	}
 
-	lp = kmalloc(sdp->sd_hash_bsize, GFP_KERNEL);
+	lp = kmalloc(sdp->sd_hash_bsize, GFP_NOFS);
 	if (!lp)
 		return -ENOMEM;
 
@@ -1864,7 +1864,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 
 	memset(&rlist, 0, sizeof(struct gfs2_rgrp_list));
 
-	ht = kzalloc(size, GFP_KERNEL);
+	ht = kzalloc(size, GFP_NOFS);
 	if (!ht)
 		return -ENOMEM;
 

commit 182fe5abd8ebbb3a00c1be91f44e4783e139918c
Author: Cyrill Gorcunov <gorcunov@gmail.com>
Date:   Mon Mar 3 21:54:21 2008 +0300

    [GFS2] possible null pointer dereference fixup
    
    gfs2_alloc_get may fail so we have to check it to prevent
    NULL pointer dereference.
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@gamil.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index a3753c7989f7..94070ad8826b 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1868,11 +1868,14 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (!ht)
 		return -ENOMEM;
 
-	gfs2_alloc_get(dip);
+	if (!gfs2_alloc_get(dip)) {
+		error = -ENOMEM;
+		goto out;
+	}
 
 	error = gfs2_quota_hold(dip, NO_QUOTA_CHANGE, NO_QUOTA_CHANGE);
 	if (error)
-		goto out;
+		goto out_put;
 
 	error = gfs2_rindex_hold(sdp, &dip->i_alloc->al_ri_gh);
 	if (error)
@@ -1946,8 +1949,9 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	gfs2_glock_dq_uninit(&dip->i_alloc->al_ri_gh);
 out_qs:
 	gfs2_quota_unhold(dip);
-out:
+out_put:
 	gfs2_alloc_put(dip);
+out:
 	kfree(ht);
 	return error;
 }

commit 9b8c81d1de49943ec69d157234b8981008c30d31
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 22 16:09:31 2008 +0000

    [GFS2] Allow bmap to allocate extents
    
    We've supported mapping of extents when no block allocation is required
    for some time. This patch extends that to mapping of extents when an
    allocation has been requested. In that case we try to allocate as many
    blocks as are requested, but we might return fewer in case there is
    something preventing us from returning the complete amount (e.g. an
    already allocated block is in the way).
    
    Currently the only code path which can actually request multiple data
    blocks in a single bmap call is the page_mkwrite path and even then it
    only happens if there are multiple blocks per page. What this patch does
    do however, is merge the allocation requests for metadata (growing the
    metadata tree in either height or depth) with the allocation of the data
    blocks in the case that both are needed. This results in lower overheads
    even in the single block allocation case.
    
    The one thing which we can't handle here at the moment is unstuffing. I
    would like to be able to do that, but the problem which arises is that
    in order to unstuff one has to get a locked page from the page cache
    which results in locking problems in the (usual) case that the caller is
    holding the page lock on the page it wishes to map. So that case will
    have to be addressed in future patches.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 34dc8dfaba12..a3753c7989f7 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -159,6 +159,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	unsigned int o;
 	int copied = 0;
 	int error = 0;
+	int new = 0;
 
 	if (!size)
 		return 0;
@@ -183,7 +184,6 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	while (copied < size) {
 		unsigned int amount;
 		struct buffer_head *bh;
-		int new = 0;
 
 		amount = size - copied;
 		if (amount > sdp->sd_sb.sb_bsize - o)

commit bb16b342b2e2c83fa47dbb042400db91b748ded7
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Wed Feb 13 00:06:10 2008 +0100

    [GFS2] be*_add_cpu conversion
    
    replace all:
    big_endian_variable = cpu_to_beX(beX_to_cpu(big_endian_variable) +
                                            expression_in_cpu_byteorder);
    with:
            beX_add_cpu(&big_endian_variable, expression_in_cpu_byteorder);
    generated with semantic patch
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 862aa3228f7a..34dc8dfaba12 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1021,13 +1021,13 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 			new->de_inum = dent->de_inum; /* No endian worries */
 			new->de_type = dent->de_type; /* No endian worries */
-			nleaf->lf_entries = cpu_to_be16(be16_to_cpu(nleaf->lf_entries)+1);
+			be16_add_cpu(&nleaf->lf_entries, 1);
 
 			dirent_del(dip, obh, prev, dent);
 
 			if (!oleaf->lf_entries)
 				gfs2_consist_inode(dip);
-			oleaf->lf_entries = cpu_to_be16(be16_to_cpu(oleaf->lf_entries)-1);
+			be16_add_cpu(&oleaf->lf_entries, -1);
 
 			if (!prev)
 				prev = dent;
@@ -1614,7 +1614,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			dent->de_type = cpu_to_be16(type);
 			if (ip->i_di.di_flags & GFS2_DIF_EXHASH) {
 				leaf = (struct gfs2_leaf *)bh->b_data;
-				leaf->lf_entries = cpu_to_be16(be16_to_cpu(leaf->lf_entries) + 1);
+				be16_add_cpu(&leaf->lf_entries, 1);
 			}
 			brelse(bh);
 			error = gfs2_meta_inode_buffer(ip, &bh);

commit 77658aad226866fb94097236d14d41a88aaab2ec
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Feb 12 14:17:27 2008 +0000

    [GFS2] Eliminate (almost) duplicate field from gfs2_inode
    
    The blocks counter is almost a duplicate of the i_blocks
    field in the VFS inode. The only difference is that i_blocks
    can be only 32bits long for 32bit arch without large single file
    support. Since GFS2 doesn't handle the non-large single file
    case (for 32 bit anyway) this adds a new config dependency on
    64BIT || LSF. This has always been the case, however we've never
    explicitly said so before.
    
    Even if we do add support for the non-LSF case, we will still
    not require this field to be duplicated since we will not be
    able to access oversized files anyway.
    
    So the net result of all this is that we shave 8 bytes from a gfs2_inode
    and get our config deps correct.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 93a2e6afbd81..862aa3228f7a 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -906,8 +906,7 @@ static int dir_make_exhash(struct inode *inode)
 		*lp = cpu_to_be64(bn);
 
 	dip->i_di.di_size = sdp->sd_sb.sb_bsize / 2;
-	dip->i_di.di_blocks++;
-	gfs2_set_inode_blocks(&dip->i_inode);
+	gfs2_add_inode_blocks(&dip->i_inode, 1);
 	dip->i_di.di_flags |= GFS2_DIF_EXHASH;
 
 	for (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;
@@ -1045,8 +1044,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {
 		gfs2_trans_add_bh(dip->i_gl, dibh, 1);
-		dip->i_di.di_blocks++;
-		gfs2_set_inode_blocks(&dip->i_inode);
+		gfs2_add_inode_blocks(&dip->i_inode, 1);
 		gfs2_dinode_out(dip, dibh->b_data);
 		brelse(dibh);
 	}
@@ -1580,8 +1578,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 	if (error)
 		return error;
 	gfs2_trans_add_bh(ip->i_gl, bh, 1);
-	ip->i_di.di_blocks++;
-	gfs2_set_inode_blocks(&ip->i_inode);
+	gfs2_add_inode_blocks(&ip->i_inode, 1);
 	gfs2_dinode_out(ip, bh->b_data);
 	brelse(bh);
 	return 0;
@@ -1922,11 +1919,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		brelse(bh);
 
 		gfs2_free_meta(dip, blk, 1);
-
-		if (!dip->i_di.di_blocks)
-			gfs2_consist_inode(dip);
-		dip->i_di.di_blocks--;
-		gfs2_set_inode_blocks(&dip->i_inode);
+		gfs2_add_inode_blocks(&dip->i_inode, -1);
 	}
 
 	error = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);

commit b45e41d7d56dfef1ae9e02e6c59990066ba82e5c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Feb 6 10:11:15 2008 +0000

    [GFS2] Add extent allocation to block allocator
    
    Rather than having to allocate a single block at a time, this patch
    allows the block allocator to allocate an extent. Since there is
    no difference (so far as the block allocator is concerned) between
    data blocks and indirect blocks, it is posible to allocate a single
    extent and for the caller to unrevoke just the blocks required
    for indirect blocks.
    
    Currently the only bit of GFS2 to make use of this feature is the
    build height function. The intention is that gfs2_block_map will
    be changed to make use of this feature in future patches.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index fbdf31957cb5..93a2e6afbd81 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -803,7 +803,8 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
-	u64 bn = gfs2_alloc_block(ip);
+	unsigned int n = 1;
+	u64 bn = gfs2_alloc_block(ip, &n);
 	struct buffer_head *bh = gfs2_meta_new(ip->i_gl, bn);
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;

commit 1639431a3f57b43da1e15e9268a1d691ac01ba26
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 1 14:52:30 2008 +0000

    [GFS2] Merge gfs2_alloc_meta and gfs2_alloc_data
    
    Thanks to the preceeding patches, the only difference between
    these two functions is their name. We can thus merge them
    and call the new function gfs2_alloc_block to reflect the
    fact that it can allocate either kind of block.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 55514ee06dd8..fbdf31957cb5 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -803,7 +803,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
-	u64 bn = gfs2_alloc_meta(ip);
+	u64 bn = gfs2_alloc_block(ip);
 	struct buffer_head *bh = gfs2_meta_new(ip->i_gl, bn);
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;

commit 5731be53e3d82aedd06e02574f833a57b07a08d2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 1 13:16:55 2008 +0000

    [GFS2] Update gfs2_trans_add_unrevoke to accept extents
    
    By adding an extra argument to gfs2_trans_add_unrevoke we can now
    specify an extent length of blocks to unrevoke. This means that
    we only need to make one pass through the list for each extent
    rather than each block. Currently the only extent length which
    is used is 1, but that will change in the future.
    
    Also gfs2_trans_add_unrevoke is removed from gfs2_alloc_meta
    since its the only difference between this and gfs2_alloc_data
    which is left. This will allow a future patch to merge these
    two functions into one (i.e. one call to allocate both data
    and metadata in a single extent in the future).
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 081daa96a9d9..55514ee06dd8 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -810,7 +810,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct qstr name = { .name = "", .len = 0, .hash = 0 };
 	if (!bh)
 		return NULL;
-
+	gfs2_trans_add_unrevoke(GFS2_SB(inode), bn, 1);
 	gfs2_trans_add_bh(ip->i_gl, bh, 1);
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	leaf = (struct gfs2_leaf *)bh->b_data;

commit 9a0045088d888c9c539c8c626a366cb52c0fbdab
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 1 09:23:44 2008 +0000

    [GFS2] Shrink & rename di_depth
    
    This patch forms a pair with the previous patch which shrunk
    di_height. Like that patch di_depth is renamed i_depth and moved
    into struct gfs2_inode directly. Also the field goes from 16 bits
    to 8 bits since it is also limited to a max value which is rather
    small (17 in this case). In addition we also now validate the field
    against this maximum value when its read in.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 78c236fb34ec..081daa96a9d9 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -757,7 +757,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 
 	if (ip->i_di.di_flags & GFS2_DIF_EXHASH) {
 		struct gfs2_leaf *leaf;
-		unsigned hsize = 1 << ip->i_di.di_depth;
+		unsigned hsize = 1 << ip->i_depth;
 		unsigned index;
 		u64 ln;
 		if (hsize * sizeof(u64) != ip->i_di.di_size) {
@@ -765,7 +765,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 			return ERR_PTR(-EIO);
 		}
 
-		index = name->hash >> (32 - ip->i_di.di_depth);
+		index = name->hash >> (32 - ip->i_depth);
 		error = get_first_leaf(ip, index, &bh);
 		if (error)
 			return ERR_PTR(error);
@@ -910,7 +910,7 @@ static int dir_make_exhash(struct inode *inode)
 	dip->i_di.di_flags |= GFS2_DIF_EXHASH;
 
 	for (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;
-	dip->i_di.di_depth = y;
+	dip->i_depth = y;
 
 	gfs2_dinode_out(dip, dibh->b_data);
 
@@ -941,7 +941,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	int x, moved = 0;
 	int error;
 
-	index = name->hash >> (32 - dip->i_di.di_depth);
+	index = name->hash >> (32 - dip->i_depth);
 	error = get_leaf_nr(dip, index, &leaf_no);
 	if (error)
 		return error;
@@ -952,7 +952,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 		return error;
 
 	oleaf = (struct gfs2_leaf *)obh->b_data;
-	if (dip->i_di.di_depth == be16_to_cpu(oleaf->lf_depth)) {
+	if (dip->i_depth == be16_to_cpu(oleaf->lf_depth)) {
 		brelse(obh);
 		return 1; /* can't split */
 	}
@@ -967,10 +967,10 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	bn = nbh->b_blocknr;
 
 	/*  Compute the start and len of leaf pointers in the hash table.  */
-	len = 1 << (dip->i_di.di_depth - be16_to_cpu(oleaf->lf_depth));
+	len = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));
 	half_len = len >> 1;
 	if (!half_len) {
-		printk(KERN_WARNING "di_depth %u lf_depth %u index %u\n", dip->i_di.di_depth, be16_to_cpu(oleaf->lf_depth), index);
+		printk(KERN_WARNING "i_depth %u lf_depth %u index %u\n", dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
 		gfs2_consist_inode(dip);
 		error = -EIO;
 		goto fail_brelse;
@@ -997,7 +997,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	kfree(lp);
 
 	/*  Compute the divider  */
-	divider = (start + half_len) << (32 - dip->i_di.di_depth);
+	divider = (start + half_len) << (32 - dip->i_depth);
 
 	/*  Copy the entries  */
 	dirent_first(dip, obh, &dent);
@@ -1082,7 +1082,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	int x;
 	int error = 0;
 
-	hsize = 1 << dip->i_di.di_depth;
+	hsize = 1 << dip->i_depth;
 	if (hsize * sizeof(u64) != dip->i_di.di_size) {
 		gfs2_consist_inode(dip);
 		return -EIO;
@@ -1125,7 +1125,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(sdp, !error)) {
-		dip->i_di.di_depth++;
+		dip->i_depth++;
 		gfs2_dinode_out(dip, dibh->b_data);
 		brelse(dibh);
 	}
@@ -1370,14 +1370,14 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	int error = 0;
 	unsigned depth = 0;
 
-	hsize = 1 << dip->i_di.di_depth;
+	hsize = 1 << dip->i_depth;
 	if (hsize * sizeof(u64) != dip->i_di.di_size) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
 
 	hash = gfs2_dir_offset2hash(*offset);
-	index = hash >> (32 - dip->i_di.di_depth);
+	index = hash >> (32 - dip->i_depth);
 
 	lp = kmalloc(sdp->sd_hash_bsize, GFP_KERNEL);
 	if (!lp)
@@ -1405,7 +1405,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 		if (error)
 			break;
 
-		len = 1 << (dip->i_di.di_depth - depth);
+		len = 1 << (dip->i_depth - depth);
 		index = (index & ~(len - 1)) + len;
 	}
 
@@ -1549,7 +1549,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 	u32 index;
 	u64 bn;
 
-	index = name->hash >> (32 - ip->i_di.di_depth);
+	index = name->hash >> (32 - ip->i_depth);
 	error = get_first_leaf(ip, index, &obh);
 	if (error)
 		return error;
@@ -1641,7 +1641,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			continue;
 		if (error < 0)
 			break;
-		if (ip->i_di.di_depth < GFS2_DIR_MAX_DEPTH) {
+		if (ip->i_depth < GFS2_DIR_MAX_DEPTH) {
 			error = dir_double_exhash(ip);
 			if (error)
 				break;
@@ -1785,7 +1785,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 	u64 leaf_no;
 	int error = 0;
 
-	hsize = 1 << dip->i_di.di_depth;
+	hsize = 1 << dip->i_depth;
 	if (hsize * sizeof(u64) != dip->i_di.di_size) {
 		gfs2_consist_inode(dip);
 		return -EIO;
@@ -1817,7 +1817,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 			if (error)
 				goto out;
 			leaf = (struct gfs2_leaf *)bh->b_data;
-			len = 1 << (dip->i_di.di_depth - be16_to_cpu(leaf->lf_depth));
+			len = 1 << (dip->i_depth - be16_to_cpu(leaf->lf_depth));
 			brelse(bh);
 
 			error = lc(dip, index, len, leaf_no, data);

commit fe6c991c52a0dd07d4a19d392fd65048226cb1bc
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Jan 28 11:13:02 2008 -0600

    [GFS2] Get rid of unneeded parameter in gfs2_rlist_alloc
    
    This patch removed the unnecessary parameter from function
    gfs2_rlist_alloc.  The parameter was always passed in as 0.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c34709512b19..78c236fb34ec 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1894,7 +1894,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		l_blocks++;
 	}
 
-	gfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE, 0);
+	gfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);
 
 	for (x = 0; x < rlist.rl_rgrps; x++) {
 		struct gfs2_rgrpd *rgd;

commit e231c2ee64eb1c5cd3c63c31da9dac7d888dcf7f
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 7 00:15:26 2008 -0800

    Convert ERR_PTR(PTR_ERR(p)) instances to ERR_CAST(p)
    
    Convert instances of ERR_PTR(PTR_ERR(p)) to ERR_CAST(p) using:
    
    perl -spi -e 's/ERR_PTR[(]PTR_ERR[(](.*)[)][)]/ERR_CAST(\1)/' `grep -rl 'ERR_PTR[(]*PTR_ERR' fs crypto net security`
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 57e2ed932adc..c34709512b19 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1498,7 +1498,7 @@ struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name)
 	dent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);
 	if (dent) {
 		if (IS_ERR(dent))
-			return ERR_PTR(PTR_ERR(dent));
+			return ERR_CAST(dent);
 		inode = gfs2_inode_lookup(dir->i_sb, 
 				be16_to_cpu(dent->de_type),
 				be64_to_cpu(dent->de_inum.no_addr),

commit 6dbd822487d0a9f14432cb4680415b80656b63a2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jan 10 15:18:55 2008 +0000

    [GFS2] Reduce inode size by moving i_alloc out of line
    
    It is possible to reduce the size of GFS2 inodes by taking the i_alloc
    structure out of the gfs2_inode. This patch allocates the i_alloc
    structure whenever its needed, and frees it afterward. This decreases
    the amount of low memory we use at the expense of requiring a memory
    allocation for each page or partial page that we write. A quick test
    with postmark shows that the overhead is not measurable and I also note
    that OCFS2 use the same approach.
    
    In the future I'd like to solve the problem by shrinking down the size
    of the members of the i_alloc structure, but for now, this reduces the
    immediate problem of using too much low-memory on x86 and doesn't add
    too much overhead.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 9949bb746a52..57e2ed932adc 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1876,7 +1876,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	if (error)
 		goto out;
 
-	error = gfs2_rindex_hold(sdp, &dip->i_alloc.al_ri_gh);
+	error = gfs2_rindex_hold(sdp, &dip->i_alloc->al_ri_gh);
 	if (error)
 		goto out_qs;
 
@@ -1949,7 +1949,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	gfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);
 out_rlist:
 	gfs2_rlist_free(&rlist);
-	gfs2_glock_dq_uninit(&dip->i_alloc.al_ri_gh);
+	gfs2_glock_dq_uninit(&dip->i_alloc->al_ri_gh);
 out_qs:
 	gfs2_quota_unhold(dip);
 out:

commit 7a9f53b3c1875bef22ad4588e818bc046ef183da
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue Sep 18 13:33:18 2007 -0500

    [GFS2] Alternate gfs2_iget to avoid looking up inodes being freed
    
    There is a possible deadlock between two processes on the same node, where one
    process is deleting an inode, and another process is looking for allocated but
    unused inodes to delete in order to create more space.
    
    process A does an iput() on inode X, and it's i_count drops to 0. This causes
    iput_final() to be called, which puts an inode into state I_FREEING at
    generic_delete_inode(). There no point between when iput_final() is called, and
    when I_FREEING is set where GFS2 could acquire any glocks. Once I_FREEING is
    set, no other process on that node can successfully look up that inode until
    the delete finishes.
    
    process B locks the the resource group for the same inode in get_local_rgrp(),
    which is called by gfs2_inplace_reserve_i()
    
    process A tries to lock the resource group for the inode in
    gfs2_dinode_dealloc(), but it's already locked by process B
    
    process B waits in find_inode for the inode to have the I_FREEING state cleared.
    
    Deadlock.
    
    This patch solves the problem by adding an alternative to gfs2_iget(),
    gfs2_iget_skip(), that simply skips any inodes that are in the I_FREEING
    state.o The alternate test function is just like the original one, except that
    it fails if the inode is being freed, and sets a skipped flag. The alternate
    set function is just like the original, except that it fails if the skipped
    flag is set. Only try_rgrp_unlink() calls gfs2_iget_skip() instead of
    gfs2_iget().
    
    Signed-off-by: Benjamin E. Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 08c6dd0c6713..9949bb746a52 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1502,7 +1502,7 @@ struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name)
 		inode = gfs2_inode_lookup(dir->i_sb, 
 				be16_to_cpu(dent->de_type),
 				be64_to_cpu(dent->de_inum.no_addr),
-				be64_to_cpu(dent->de_inum.no_formal_ino));
+				be64_to_cpu(dent->de_inum.no_formal_ino), 0);
 		brelse(bh);
 		return inode;
 	}

commit 382e6e256b0cb1a84a45a520cef75d1b8ff44663
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Aug 16 17:08:20 2007 +0100

    [GFS2] Add a missing gfs2_trans_add_bh()
    
    This was missing from the dir_split_leaf() function although in
    most cases its not a problem due to other functions having
    already previously called gfs2_trans_add_bh. This makes certain
    that it is correct.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Wendy Cheng <wcheng@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 2beb2f401aa2..08c6dd0c6713 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1043,6 +1043,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {
+		gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 		dip->i_di.di_blocks++;
 		gfs2_set_inode_blocks(&dip->i_inode);
 		gfs2_dinode_out(dip, dibh->b_data);

commit bb9bcf061660661c57ddcf31337529f82414b937
Author: Wendy Cheng <wcheng@redhat.com>
Date:   Wed Jun 27 17:07:08 2007 -0400

    [GFS2] Obtaining no_formal_ino from directory entry
    
    GFS2 lookup code doesn't ask for inode shared glock. This implies during
    in-memory inode creation for existing file, GFS2 will not disk-read in
    the inode contents. This leaves no_formal_ino un-initialized during
    lookup time. The un-initialized no_formal_ino is subsequently encoded
    into file handle. Clients will get ESTALE error whenever it tries to
    access these files.
    
    Signed-off-by: S. Wendy Cheng <wcheng@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f793e31a050e..2beb2f401aa2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1498,9 +1498,10 @@ struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name)
 	if (dent) {
 		if (IS_ERR(dent))
 			return ERR_PTR(PTR_ERR(dent));
-		inode = gfs2_inode_lookup(dir->i_sb,
-					  be64_to_cpu(dent->de_inum.no_addr),
-					  be16_to_cpu(dent->de_type));
+		inode = gfs2_inode_lookup(dir->i_sb, 
+				be16_to_cpu(dent->de_type),
+				be64_to_cpu(dent->de_inum.no_addr),
+				be64_to_cpu(dent->de_inum.no_formal_ino));
 		brelse(bh);
 		return inode;
 	}

commit 4bd91ba18198eee42c39d4c334c825d1a0a4b445
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jun 5 09:39:18 2007 +0100

    [GFS2] Add nanosecond timestamp feature
    
    This adds a nanosecond timestamp feature to the GFS2 filesystem. Due
    to the way that the on-disk format works, older filesystems will just
    appear to have this field set to zero. When mounted by an older version
    of GFS2, the filesystem will simply ignore the extra fields so that
    it will again appear to have whole second resolution, so that its
    trivially backward compatible.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 2f154049b59d..f793e31a050e 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -130,7 +130,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
 	if (ip->i_di.di_size < offset + size)
 		ip->i_di.di_size = offset + size;
-	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME_SEC;
+	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 	gfs2_dinode_out(ip, dibh->b_data);
 
 	brelse(dibh);
@@ -228,7 +228,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 
 	if (ip->i_di.di_size < offset + copied)
 		ip->i_di.di_size = offset + copied;
-	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME_SEC;
+	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
 	gfs2_dinode_out(ip, dibh->b_data);
@@ -1622,7 +1622,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 				break;
 			gfs2_trans_add_bh(ip->i_gl, bh, 1);
 			ip->i_di.di_entries++;
-			ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME_SEC;
+			ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME;
 			gfs2_dinode_out(ip, bh->b_data);
 			brelse(bh);
 			error = 0;
@@ -1708,7 +1708,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 		gfs2_consist_inode(dip);
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	dip->i_di.di_entries--;
-	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME_SEC;
+	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	mark_inode_dirty(&dip->i_inode);
@@ -1756,7 +1756,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 		gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	}
 
-	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME_SEC;
+	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	return 0;

commit bb8d8a6f54c1c84d7c74623491bab043b36a38c5
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Jun 1 14:11:58 2007 +0100

    [GFS2] Fix sign problem in quota/statfs and cleanup _host structures
    
    This patch fixes some sign issues which were accidentally introduced
    into the quota & statfs code during the endianess annotation process.
    Also included is a general clean up which moves all of the _host
    structures out of gfs2_ondisk.h (where they should not have been to
    start with) and into the places where they are actually used (often only
    one place). Also those _host structures which are not required any more
    are removed entirely (which is the eventual plan for all of them).
    
    The conversion routines from ondisk.c are also moved into the places
    where they are actually used, which for almost every one, was just one
    single place, so all those are now static functions. This also cleans up
    the end of gfs2_ondisk.h which no longer needs the #ifdef __KERNEL__.
    
    The net result is a reduction of about 100 lines of code, many functions
    now marked static plus the bug fixes as mentioned above. For good
    measure I ran the code through sparse after making these changes to
    check that there are no warnings generated.
    
    This fixes Red Hat bz #239686
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 9cdd71cef59c..2f154049b59d 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1897,7 +1897,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	for (x = 0; x < rlist.rl_rgrps; x++) {
 		struct gfs2_rgrpd *rgd;
 		rgd = rlist.rl_ghs[x].gh_gl->gl_object;
-		rg_blocks += rgd->rd_ri.ri_length;
+		rg_blocks += rgd->rd_length;
 	}
 
 	error = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);

commit dbb7cae2a36170cd17ffbe286ec0c91a998740ff
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue May 15 15:37:50 2007 +0100

    [GFS2] Clean up inode number handling
    
    This patch cleans up the inode number handling code. The main difference
    is that instead of looking up the inodes using a struct gfs2_inum_host
    we now use just the no_addr member of this structure. The tests relating
    to no_formal_ino can then be done by the calling code. This has
    advantages in that we want to do different things in different code
    paths if the no_formal_ino doesn't match. In the NFS patch we want to
    return -ESTALE, but in the ->lookup() path, its a bug in the fs if the
    no_formal_ino doesn't match and thus we can withdraw in this case.
    
    In order to later fix bz #201012, we need to be able to look up an inode
    without knowing no_formal_ino, as the only information that is known to
    us is the on-disk location of the inode in question.
    
    This patch will also help us to fix bz #236099 at a later date by
    cleaning up a lot of the code in that area.
    
    There are no user visible changes as a result of this patch and there
    are no changes to the on-disk format either.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index a96fa07b3f3b..9cdd71cef59c 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1456,7 +1456,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 		if (dip->i_di.di_entries != g.offset) {
 			fs_warn(sdp, "Number of entries corrupt in dir %llu, "
 				"ip->i_di.di_entries (%u) != g.offset (%u)\n",
-				(unsigned long long)dip->i_num.no_addr,
+				(unsigned long long)dip->i_no_addr,
 				dip->i_di.di_entries,
 				g.offset);
 			error = -EIO;
@@ -1488,24 +1488,54 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
  * Returns: errno
  */
 
-int gfs2_dir_search(struct inode *dir, const struct qstr *name,
-		    struct gfs2_inum_host *inum, unsigned int *type)
+struct inode *gfs2_dir_search(struct inode *dir, const struct qstr *name)
 {
 	struct buffer_head *bh;
 	struct gfs2_dirent *dent;
+	struct inode *inode;
+
+	dent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);
+	if (dent) {
+		if (IS_ERR(dent))
+			return ERR_PTR(PTR_ERR(dent));
+		inode = gfs2_inode_lookup(dir->i_sb,
+					  be64_to_cpu(dent->de_inum.no_addr),
+					  be16_to_cpu(dent->de_type));
+		brelse(bh);
+		return inode;
+	}
+	return ERR_PTR(-ENOENT);
+}
+
+int gfs2_dir_check(struct inode *dir, const struct qstr *name,
+		   const struct gfs2_inode *ip)
+{
+	struct buffer_head *bh;
+	struct gfs2_dirent *dent;
+	int ret = -ENOENT;
 
 	dent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);
 	if (dent) {
 		if (IS_ERR(dent))
 			return PTR_ERR(dent);
-		if (inum)
-			gfs2_inum_in(inum, (char *)&dent->de_inum);
-		if (type)
-			*type = be16_to_cpu(dent->de_type);
+		if (ip) {
+			if (be64_to_cpu(dent->de_inum.no_addr) != ip->i_no_addr)
+				goto out;
+			if (be64_to_cpu(dent->de_inum.no_formal_ino) !=
+			    ip->i_no_formal_ino)
+				goto out;
+			if (unlikely(IF2DT(ip->i_inode.i_mode) !=
+			    be16_to_cpu(dent->de_type))) {
+				gfs2_consist_inode(GFS2_I(dir));
+				ret = -EIO;
+				goto out;
+			}
+		}
+		ret = 0;
+out:
 		brelse(bh);
-		return 0;
 	}
-	return -ENOENT;
+	return ret;
 }
 
 static int dir_new_leaf(struct inode *inode, const struct qstr *name)
@@ -1565,7 +1595,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
  */
 
 int gfs2_dir_add(struct inode *inode, const struct qstr *name,
-		 const struct gfs2_inum_host *inum, unsigned type)
+		 const struct gfs2_inode *nip, unsigned type)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh;
@@ -1580,7 +1610,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			if (IS_ERR(dent))
 				return PTR_ERR(dent);
 			dent = gfs2_init_dirent(inode, dent, name, bh);
-			gfs2_inum_out(inum, (char *)&dent->de_inum);
+			gfs2_inum_out(nip, dent);
 			dent->de_type = cpu_to_be16(type);
 			if (ip->i_di.di_flags & GFS2_DIF_EXHASH) {
 				leaf = (struct gfs2_leaf *)bh->b_data;
@@ -1700,7 +1730,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
  */
 
 int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
-		   struct gfs2_inum_host *inum, unsigned int new_type)
+		   const struct gfs2_inode *nip, unsigned int new_type)
 {
 	struct buffer_head *bh;
 	struct gfs2_dirent *dent;
@@ -1715,7 +1745,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 		return PTR_ERR(dent);
 
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
-	gfs2_inum_out(inum, (char *)&dent->de_inum);
+	gfs2_inum_out(nip, dent);
 	dent->de_type = cpu_to_be16(new_type);
 
 	if (dip->i_di.di_flags & GFS2_DIF_EXHASH) {

commit f391a4ead61e4510ff385815ddaf3c0777fbad1b
Author: akpm@linux-foundation.org <akpm@linux-foundation.org>
Date:   Wed Apr 25 21:08:02 2007 -0700

    [GFS2] printk warning fixes
    
    alpha:
    
    fs/gfs2/dir.c: In function 'gfs2_dir_read_leaf':
    fs/gfs2/dir.c:1322: warning: format '%llu' expects type 'long long unsigned int', but argument 3 has type 'sector_t'
    fs/gfs2/dir.c: In function 'gfs2_dir_read':
    fs/gfs2/dir.c:1455: warning: format '%llu' expects type 'long long unsigned int', but argument 3 has type '__u64'
    
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 6c3ed7674a9f..a96fa07b3f3b 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1319,9 +1319,11 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 			if (IS_ERR(dent))
 				goto out_kfree;
 			if (entries2 != g.offset) {
-				fs_warn(sdp, "Number of entries corrupt in dir leaf %llu, "
-				        "entries2 (%u) != g.offset (%u)\n",
-					(u64)bh->b_blocknr, entries2, g.offset);
+				fs_warn(sdp, "Number of entries corrupt in dir "
+						"leaf %llu, entries2 (%u) != "
+						"g.offset (%u)\n",
+					(unsigned long long)bh->b_blocknr,
+					entries2, g.offset);
 					
 				error = -EIO;
 				goto out_kfree;
@@ -1454,7 +1456,8 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 		if (dip->i_di.di_entries != g.offset) {
 			fs_warn(sdp, "Number of entries corrupt in dir %llu, "
 				"ip->i_di.di_entries (%u) != g.offset (%u)\n",
-				dip->i_num.no_addr, dip->i_di.di_entries,
+				(unsigned long long)dip->i_num.no_addr,
+				dip->i_di.di_entries,
 				g.offset);
 			error = -EIO;
 			goto out;

commit bdd19a22f85a7039e01accd8717eaec4addd9dfd
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Apr 18 09:38:42 2007 +0100

    [GFS2] Patch to detect corrupt number of dir entries in leaf and/or inode blocks
    
    This patch detects when the number of entries in a leaf block or inode
    block (in the case of stuffed directories) is corrupt and informs the
    user. It prevents us from running off the end of the array thats been
    allocated for the sorting in this case,
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 82a1ac7895a2..6c3ed7674a9f 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1262,9 +1262,10 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 			      u64 leaf_no)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
+	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct buffer_head *bh;
 	struct gfs2_leaf *lf;
-	unsigned entries = 0;
+	unsigned entries = 0, entries2 = 0;
 	unsigned leaves = 0;
 	const struct gfs2_dirent **darr, *dent;
 	struct dirent_gather g;
@@ -1290,7 +1291,13 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 		return 0;
 
 	error = -ENOMEM;
-	larr = vmalloc((leaves + entries) * sizeof(void *));
+	/*
+	 * The extra 99 entries are not normally used, but are a buffer
+	 * zone in case the number of entries in the leaf is corrupt.
+	 * 99 is the maximum number of entries that can fit in a single
+	 * leaf block.
+	 */
+	larr = vmalloc((leaves + entries + 99) * sizeof(void *));
 	if (!larr)
 		goto out;
 	darr = (const struct gfs2_dirent **)(larr + leaves);
@@ -1305,10 +1312,18 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 		lf = (struct gfs2_leaf *)bh->b_data;
 		lfn = be64_to_cpu(lf->lf_next);
 		if (lf->lf_entries) {
+			entries2 += be16_to_cpu(lf->lf_entries);
 			dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,
 						gfs2_dirent_gather, NULL, &g);
 			error = PTR_ERR(dent);
-			if (IS_ERR(dent)) {
+			if (IS_ERR(dent))
+				goto out_kfree;
+			if (entries2 != g.offset) {
+				fs_warn(sdp, "Number of entries corrupt in dir leaf %llu, "
+				        "entries2 (%u) != g.offset (%u)\n",
+					(u64)bh->b_blocknr, entries2, g.offset);
+					
+				error = -EIO;
 				goto out_kfree;
 			}
 			error = 0;
@@ -1318,6 +1333,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 		}
 	} while(lfn);
 
+	BUG_ON(entries2 != entries);
 	error = do_filldir_main(ip, offset, opaque, filldir, darr,
 				entries, copied);
 out_kfree:
@@ -1401,6 +1417,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 		  filldir_t filldir)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
+	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct dirent_gather g;
 	const struct gfs2_dirent **darr, *dent;
 	struct buffer_head *dibh;
@@ -1423,8 +1440,8 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 		return error;
 
 	error = -ENOMEM;
-	darr = kmalloc(dip->i_di.di_entries * sizeof(struct gfs2_dirent *),
-		       GFP_KERNEL);
+	/* 96 is max number of dirents which can be stuffed into an inode */
+	darr = kmalloc(96 * sizeof(struct gfs2_dirent *), GFP_KERNEL);
 	if (darr) {
 		g.pdent = darr;
 		g.offset = 0;
@@ -1434,6 +1451,14 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 			error = PTR_ERR(dent);
 			goto out;
 		}
+		if (dip->i_di.di_entries != g.offset) {
+			fs_warn(sdp, "Number of entries corrupt in dir %llu, "
+				"ip->i_di.di_entries (%u) != g.offset (%u)\n",
+				dip->i_num.no_addr, dip->i_di.di_entries,
+				g.offset);
+			error = -EIO;
+			goto out;
+		}
 		error = do_filldir_main(dip, offset, opaque, filldir, darr,
 					dip->i_di.di_entries, &copied);
 out:

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c93ca8f361b5..82a1ac7895a2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -53,7 +53,6 @@
  * but never before the maximum hash table size has been reached.
  */
 
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/buffer_head.h>

commit ddfe0627838ca0c0e8babb0dd2bd7f4b35e25bff
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Jan 18 16:41:23 2007 -0600

    [GFS2] use CURRENT_TIME_SEC instead of get_seconds in gfs2
    
    I was looking something else up and came across this...
    
    I don't honestly have a good reason to change it other than to make it
    like every other Linux filesystem in this regard.  ;-)  It doesn't
    functionally change anything, but makes some lines shorter. :)
    
    I'm also curious; why does gfs2 have 64-bits of on-disk timestamps, but
    not in timespec_t format, and only stores second resolutions?  Seems like
    you're halfway to sub-second resolutions already.
    
    I suppose if that gets implemented then all of the below should
    instead be CURRENT_TIME not CURRENT_TIME_SEC.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 0eceb051084f..c93ca8f361b5 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -131,7 +131,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
 	if (ip->i_di.di_size < offset + size)
 		ip->i_di.di_size = offset + size;
-	ip->i_inode.i_mtime.tv_sec = ip->i_inode.i_ctime.tv_sec = get_seconds();
+	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME_SEC;
 	gfs2_dinode_out(ip, dibh->b_data);
 
 	brelse(dibh);
@@ -229,7 +229,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 
 	if (ip->i_di.di_size < offset + copied)
 		ip->i_di.di_size = offset + copied;
-	ip->i_inode.i_mtime.tv_sec = ip->i_inode.i_ctime.tv_sec = get_seconds();
+	ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME_SEC;
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
 	gfs2_dinode_out(ip, dibh->b_data);
@@ -1565,7 +1565,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 				break;
 			gfs2_trans_add_bh(ip->i_gl, bh, 1);
 			ip->i_di.di_entries++;
-			ip->i_inode.i_mtime.tv_sec = ip->i_inode.i_ctime.tv_sec = get_seconds();
+			ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME_SEC;
 			gfs2_dinode_out(ip, bh->b_data);
 			brelse(bh);
 			error = 0;
@@ -1651,7 +1651,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 		gfs2_consist_inode(dip);
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	dip->i_di.di_entries--;
-	dip->i_inode.i_mtime.tv_sec = dip->i_inode.i_ctime.tv_sec = get_seconds();
+	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME_SEC;
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	mark_inode_dirty(&dip->i_inode);
@@ -1699,7 +1699,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 		gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	}
 
-	dip->i_inode.i_mtime.tv_sec = dip->i_inode.i_ctime.tv_sec = get_seconds();
+	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME_SEC;
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	return 0;

commit 3699e3a44bf56e0cd58c97e8655f375ad9b65d9d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jan 17 15:09:20 2007 +0000

    [GFS2] Clean up/speed up readdir
    
    This removes the extra filldir callback which gfs2 was using to
    enclose an attempt at readahead for inodes during readdir. The
    code was too complicated and also hurts performance badly in the
    case that the getdents64/readdir call isn't being followed by
    stat() and it wasn't even getting it right all the time when it
    was.
    
    As a result, on my test box an "ls" of a directory containing 250000
    files fell from about 7mins (freshly mounted, so nothing cached) to
    between about 15 to 25 seconds. When the directory content was cached,
    the time taken fell from about 3mins to about 4 or 5 seconds.
    
    Interestingly in the cached case, running "ls -l" once reduced the time
    taken for subsequent runs of "ls" to about 6 secs even without this
    patch. Now it turns out that there was a special case of glocks being
    used for prefetching the metadata, but because of the timeouts for these
    locks (set to 10 secs) the metadata was being timed out before it was
    being used and this the prefetch code was constantly trying to prefetch
    the same data over and over.
    
    Calling "ls -l" meant that the inodes were brought into memory and once
    the inodes are cached, the glocks are not disposed of until the inodes
    are pushed out of the cache, thus extending the lifetime of the glocks,
    and thus bringing down the time for subsequent runs of "ls"
    considerably.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 0fdcb7713cd9..0eceb051084f 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1198,12 +1198,11 @@ static int compare_dents(const void *a, const void *b)
  */
 
 static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
-			   void *opaque, gfs2_filldir_t filldir,
+			   void *opaque, filldir_t filldir,
 			   const struct gfs2_dirent **darr, u32 entries,
 			   int *copied)
 {
 	const struct gfs2_dirent *dent, *dent_next;
-	struct gfs2_inum_host inum;
 	u64 off, off_next;
 	unsigned int x, y;
 	int run = 0;
@@ -1240,11 +1239,9 @@ static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 			*offset = off;
 		}
 
-		gfs2_inum_in(&inum, (char *)&dent->de_inum);
-
 		error = filldir(opaque, (const char *)(dent + 1),
 				be16_to_cpu(dent->de_name_len),
-				off, &inum,
+				off, be64_to_cpu(dent->de_inum.no_addr),
 				be16_to_cpu(dent->de_type));
 		if (error)
 			return 1;
@@ -1262,8 +1259,8 @@ static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 }
 
 static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
-			      gfs2_filldir_t filldir, int *copied,
-			      unsigned *depth, u64 leaf_no)
+			      filldir_t filldir, int *copied, unsigned *depth,
+			      u64 leaf_no)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh;
@@ -1343,7 +1340,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
  */
 
 static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
-		      gfs2_filldir_t filldir)
+		      filldir_t filldir)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
@@ -1402,7 +1399,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 }
 
 int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
-		  gfs2_filldir_t filldir)
+		  filldir_t filldir)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
 	struct dirent_gather g;

commit 5e7d65cd9d3819512b059f4260de0119b985454c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Nov 17 12:27:44 2006 -0500

    [GFS2] Make sentinel dirents compatible with gfs1
    
    When deleting directory entries, we set the inum.no_addr to zero
    in a dirent when its the first dirent in a block and thus cannot
    be merged into the previous dirent as is the usual case. In gfs1,
    inum.no_formal_ino was used instead.
    
    This patch changes gfs2 to set both inum.no_addr and inum.no_formal_ino
    to zero. It also changes the test from just looking at inum.no_addr to
    look at both inum.no_addr and inum.no_formal_ino and a sentinel is
    now considered to be a dirent in which _either_ (or both) of them
    is set to zero.
    
    This resolves Red Hat bugzillas: #215809, #211465
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index a2923fb91bba..0fdcb7713cd9 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -340,10 +340,15 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 	return (copied) ? copied : error;
 }
 
+static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)
+{
+	return dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;
+}
+
 static inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,
 				     const struct qstr *name, int ret)
 {
-	if (dent->de_inum.no_addr != 0 &&
+	if (!gfs2_dirent_sentinel(dent) &&
 	    be32_to_cpu(dent->de_hash) == name->hash &&
 	    be16_to_cpu(dent->de_name_len) == name->len &&
 	    memcmp(dent+1, name->name, name->len) == 0)
@@ -388,7 +393,7 @@ static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,
 	unsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
 	unsigned totlen = be16_to_cpu(dent->de_rec_len);
 
-	if (!dent->de_inum.no_addr)
+	if (gfs2_dirent_sentinel(dent))
 		actual = GFS2_DIRENT_SIZE(0);
 	if (totlen - actual >= required)
 		return 1;
@@ -405,7 +410,7 @@ static int gfs2_dirent_gather(const struct gfs2_dirent *dent,
 			      void *opaque)
 {
 	struct dirent_gather *g = opaque;
-	if (dent->de_inum.no_addr) {
+	if (!gfs2_dirent_sentinel(dent)) {
 		g->pdent[g->offset++] = dent;
 	}
 	return 0;
@@ -433,10 +438,10 @@ static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,
 	if (unlikely(offset + size > len))
 		goto error;
 	msg = "zero inode number";
-	if (unlikely(!first && !dent->de_inum.no_addr))
+	if (unlikely(!first && gfs2_dirent_sentinel(dent)))
 		goto error;
 	msg = "name length is greater than space in dirent";
-	if (dent->de_inum.no_addr &&
+	if (!gfs2_dirent_sentinel(dent) &&
 	    unlikely(sizeof(struct gfs2_dirent)+be16_to_cpu(dent->de_name_len) >
 		     size))
 		goto error;
@@ -598,7 +603,7 @@ static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 		return ret;
 
         /* Only the first dent could ever have de_inum.no_addr == 0 */
-	if (!tmp->de_inum.no_addr) {
+	if (gfs2_dirent_sentinel(tmp)) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -621,7 +626,7 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 {
 	u16 cur_rec_len, prev_rec_len;
 
-	if (!cur->de_inum.no_addr) {
+	if (gfs2_dirent_sentinel(cur)) {
 		gfs2_consist_inode(dip);
 		return;
 	}
@@ -633,7 +638,8 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 	   out the inode number and return.  */
 
 	if (!prev) {
-		cur->de_inum.no_addr = 0;	/* No endianess worries */
+		cur->de_inum.no_addr = 0;
+		cur->de_inum.no_formal_ino = 0;
 		return;
 	}
 
@@ -664,7 +670,7 @@ static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,
 	struct gfs2_dirent *ndent;
 	unsigned offset = 0, totlen;
 
-	if (dent->de_inum.no_addr)
+	if (!gfs2_dirent_sentinel(dent))
 		offset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
 	totlen = be16_to_cpu(dent->de_rec_len);
 	BUG_ON(offset + name->len > totlen);
@@ -1002,7 +1008,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 		if (dirent_next(dip, obh, &next))
 			next = NULL;
 
-		if (dent->de_inum.no_addr &&
+		if (!gfs2_dirent_sentinel(dent) &&
 		    be32_to_cpu(dent->de_hash) < divider) {
 			struct qstr str;
 			str.name = (char*)(dent+1);

commit 9e2dbdac3df300516ffdd9a8631f23164d068a50
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Nov 8 15:45:46 2006 -0500

    [GFS2] Remove gfs2_inode_attr_in
    
    This function wasn't really doing the right thing. There was no need
    to update the inode size at this point and the updating of the
    i_blocks field has now been moved to the places where di_blocks is
    updated. A result of this patch and some those preceeding it is that
    unlocking a glock is now a much more efficient process, since there
    is no longer any requirement to copy data from the gfs2 inode into
    the vfs inode at this point.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c82d7cb4a654..a2923fb91bba 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -901,6 +901,7 @@ static int dir_make_exhash(struct inode *inode)
 
 	dip->i_di.di_size = sdp->sd_sb.sb_bsize / 2;
 	dip->i_di.di_blocks++;
+	gfs2_set_inode_blocks(&dip->i_inode);
 	dip->i_di.di_flags |= GFS2_DIF_EXHASH;
 
 	for (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;
@@ -1038,6 +1039,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {
 		dip->i_di.di_blocks++;
+		gfs2_set_inode_blocks(&dip->i_inode);
 		gfs2_dinode_out(dip, dibh->b_data);
 		brelse(dibh);
 	}
@@ -1516,6 +1518,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 		return error;
 	gfs2_trans_add_bh(ip->i_gl, bh, 1);
 	ip->i_di.di_blocks++;
+	gfs2_set_inode_blocks(&ip->i_inode);
 	gfs2_dinode_out(ip, bh->b_data);
 	brelse(bh);
 	return 0;
@@ -1860,6 +1863,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		if (!dip->i_di.di_blocks)
 			gfs2_consist_inode(dip);
 		dip->i_di.di_blocks--;
+		gfs2_set_inode_blocks(&dip->i_inode);
 	}
 
 	error = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);

commit a9583c7983cbba9726bfe64ee46613d654fc9e26
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Nov 1 20:09:14 2006 -0500

    [GFS2] Shrink gfs2_inode (7) - di_payload_format
    
    This is almost never used. Its there for backward
    compatibility with GFS1. It doesn't need its own
    field since it can always be calculated from the
    inode mode & flags. This saves a bit more space
    in the gfs2_inode.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ca23c8beb3f0..c82d7cb4a654 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -902,7 +902,6 @@ static int dir_make_exhash(struct inode *inode)
 	dip->i_di.di_size = sdp->sd_sb.sb_bsize / 2;
 	dip->i_di.di_blocks++;
 	dip->i_di.di_flags |= GFS2_DIF_EXHASH;
-	dip->i_di.di_payload_format = 0;
 
 	for (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;
 	dip->i_di.di_depth = y;

commit 1a7b1eed5802502fd649e04784becd58557fdcf1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Nov 1 14:35:17 2006 -0500

    [GFS2] Shrink gfs2_inode (6) - di_atime/di_mtime/di_ctime
    
    Remove the di_[amc]time fields and use inode->i_[amc]time
    fields instead. This saves 24 bytes from the gfs2_inode.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 0742761e1e02..ca23c8beb3f0 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -131,7 +131,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
 	if (ip->i_di.di_size < offset + size)
 		ip->i_di.di_size = offset + size;
-	ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
+	ip->i_inode.i_mtime.tv_sec = ip->i_inode.i_ctime.tv_sec = get_seconds();
 	gfs2_dinode_out(ip, dibh->b_data);
 
 	brelse(dibh);
@@ -229,7 +229,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 
 	if (ip->i_di.di_size < offset + copied)
 		ip->i_di.di_size = offset + copied;
-	ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
+	ip->i_inode.i_mtime.tv_sec = ip->i_inode.i_ctime.tv_sec = get_seconds();
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
 	gfs2_dinode_out(ip, dibh->b_data);
@@ -1560,7 +1560,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 				break;
 			gfs2_trans_add_bh(ip->i_gl, bh, 1);
 			ip->i_di.di_entries++;
-			ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
+			ip->i_inode.i_mtime.tv_sec = ip->i_inode.i_ctime.tv_sec = get_seconds();
 			gfs2_dinode_out(ip, bh->b_data);
 			brelse(bh);
 			error = 0;
@@ -1646,7 +1646,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 		gfs2_consist_inode(dip);
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	dip->i_di.di_entries--;
-	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+	dip->i_inode.i_mtime.tv_sec = dip->i_inode.i_ctime.tv_sec = get_seconds();
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	mark_inode_dirty(&dip->i_inode);
@@ -1694,7 +1694,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 		gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	}
 
-	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+	dip->i_inode.i_mtime.tv_sec = dip->i_inode.i_ctime.tv_sec = get_seconds();
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	return 0;

commit 539e5d6b7ae8612c0393fe940d2da5b591318d3d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Oct 31 15:07:05 2006 -0500

    [GFS2] Change argument of gfs2_dinode_out
    
    Everywhere this was called, a struct gfs2_inode was available,
    but despite that, it was always called with a struct gfs2_dinode
    as an argument. By making this change it paves the way to start
    eliminating fields duplicated between the kernel's struct inode
    and the struct gfs2_dinode.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 59dc823c2833..0742761e1e02 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -132,7 +132,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 	if (ip->i_di.di_size < offset + size)
 		ip->i_di.di_size = offset + size;
 	ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
-	gfs2_dinode_out(&ip->i_di, dibh->b_data);
+	gfs2_dinode_out(ip, dibh->b_data);
 
 	brelse(dibh);
 
@@ -232,7 +232,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
-	gfs2_dinode_out(&ip->i_di, dibh->b_data);
+	gfs2_dinode_out(ip, dibh->b_data);
 	brelse(dibh);
 
 	return copied;
@@ -907,7 +907,7 @@ static int dir_make_exhash(struct inode *inode)
 	for (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;
 	dip->i_di.di_depth = y;
 
-	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+	gfs2_dinode_out(dip, dibh->b_data);
 
 	brelse(dibh);
 
@@ -1039,7 +1039,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {
 		dip->i_di.di_blocks++;
-		gfs2_dinode_out(&dip->i_di, dibh->b_data);
+		gfs2_dinode_out(dip, dibh->b_data);
 		brelse(dibh);
 	}
 
@@ -1119,7 +1119,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(sdp, !error)) {
 		dip->i_di.di_depth++;
-		gfs2_dinode_out(&dip->i_di, dibh->b_data);
+		gfs2_dinode_out(dip, dibh->b_data);
 		brelse(dibh);
 	}
 
@@ -1517,7 +1517,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 		return error;
 	gfs2_trans_add_bh(ip->i_gl, bh, 1);
 	ip->i_di.di_blocks++;
-	gfs2_dinode_out(&ip->i_di, bh->b_data);
+	gfs2_dinode_out(ip, bh->b_data);
 	brelse(bh);
 	return 0;
 }
@@ -1561,7 +1561,7 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 			gfs2_trans_add_bh(ip->i_gl, bh, 1);
 			ip->i_di.di_entries++;
 			ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
-			gfs2_dinode_out(&ip->i_di, bh->b_data);
+			gfs2_dinode_out(ip, bh->b_data);
 			brelse(bh);
 			error = 0;
 			break;
@@ -1647,7 +1647,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	dip->i_di.di_entries--;
 	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
-	gfs2_dinode_out(&dip->i_di, bh->b_data);
+	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	mark_inode_dirty(&dip->i_inode);
 
@@ -1695,7 +1695,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 	}
 
 	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
-	gfs2_dinode_out(&dip->i_di, bh->b_data);
+	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
 	return 0;
 }
@@ -1875,7 +1875,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		goto out_end_trans;
 
 	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
-	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+	gfs2_dinode_out(dip, dibh->b_data);
 	brelse(dibh);
 
 out_end_trans:

commit b44b84d765b02f813a67b96bf79e3b5d4d621631
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 14 10:46:30 2006 -0400

    [GFS2] gfs2 misc endianness annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d67a3760ca30..59dc823c2833 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -713,12 +713,12 @@ static int get_leaf(struct gfs2_inode *dip, u64 leaf_no,
 static int get_leaf_nr(struct gfs2_inode *dip, u32 index,
 		       u64 *leaf_out)
 {
-	u64 leaf_no;
+	__be64 leaf_no;
 	int error;
 
 	error = gfs2_dir_read_data(dip, (char *)&leaf_no,
-				    index * sizeof(u64),
-				    sizeof(u64), 0);
+				    index * sizeof(__be64),
+				    sizeof(__be64), 0);
 	if (error != sizeof(u64))
 		return (error < 0) ? error : -EIO;
 
@@ -837,7 +837,8 @@ static int dir_make_exhash(struct inode *inode)
 	struct gfs2_leaf *leaf;
 	int y;
 	u32 x;
-	u64 *lp, bn;
+	__be64 *lp;
+	u64 bn;
 	int error;
 
 	error = gfs2_meta_inode_buffer(dip, &dibh);
@@ -893,7 +894,7 @@ static int dir_make_exhash(struct inode *inode)
 	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 	gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
 
-	lp = (u64 *)(dibh->b_data + sizeof(struct gfs2_dinode));
+	lp = (__be64 *)(dibh->b_data + sizeof(struct gfs2_dinode));
 
 	for (x = sdp->sd_hash_ptrs; x--; lp++)
 		*lp = cpu_to_be64(bn);
@@ -929,7 +930,8 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	struct gfs2_leaf *nleaf, *oleaf;
 	struct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;
 	u32 start, len, half_len, divider;
-	u64 bn, *lp, leaf_no;
+	u64 bn, leaf_no;
+	__be64 *lp;
 	u32 index;
 	int x, moved = 0;
 	int error;
@@ -974,7 +976,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	/* Change the pointers.
 	   Don't bother distinguishing stuffed from non-stuffed.
 	   This code is complicated enough already. */
-	lp = kmalloc(half_len * sizeof(u64), GFP_NOFS | __GFP_NOFAIL);
+	lp = kmalloc(half_len * sizeof(__be64), GFP_NOFS | __GFP_NOFAIL);
 	/*  Change the pointers  */
 	for (x = 0; x < half_len; x++)
 		lp[x] = cpu_to_be64(bn);
@@ -1341,7 +1343,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 	u32 hsize, len = 0;
 	u32 ht_offset, lp_offset, ht_offset_cur = -1;
 	u32 hash, index;
-	u64 *lp;
+	__be64 *lp;
 	int copied = 0;
 	int error = 0;
 	unsigned depth = 0;
@@ -1365,7 +1367,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 
 		if (ht_offset_cur != ht_offset) {
 			error = gfs2_dir_read_data(dip, (char *)lp,
-						ht_offset * sizeof(u64),
+						ht_offset * sizeof(__be64),
 						sdp->sd_hash_bsize, 1);
 			if (error != sdp->sd_hash_bsize) {
 				if (error >= 0)
@@ -1715,7 +1717,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 	u32 hsize, len;
 	u32 ht_offset, lp_offset, ht_offset_cur = -1;
 	u32 index = 0;
-	u64 *lp;
+	__be64 *lp;
 	u64 leaf_no;
 	int error = 0;
 
@@ -1735,7 +1737,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 
 		if (ht_offset_cur != ht_offset) {
 			error = gfs2_dir_read_data(dip, (char *)lp,
-						ht_offset * sizeof(u64),
+						ht_offset * sizeof(__be64),
 						sdp->sd_hash_bsize, 1);
 			if (error != sdp->sd_hash_bsize) {
 				if (error >= 0)

commit 629a21e7ecedf779c68dcaa9a186069f57a7c652
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 13 22:51:24 2006 -0400

    [GFS2] split and annotate gfs2_inum
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index e24af28b1a12..d67a3760ca30 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1194,7 +1194,7 @@ static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 			   int *copied)
 {
 	const struct gfs2_dirent *dent, *dent_next;
-	struct gfs2_inum inum;
+	struct gfs2_inum_host inum;
 	u64 off, off_next;
 	unsigned int x, y;
 	int run = 0;
@@ -1456,7 +1456,7 @@ int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
  */
 
 int gfs2_dir_search(struct inode *dir, const struct qstr *name,
-		    struct gfs2_inum *inum, unsigned int *type)
+		    struct gfs2_inum_host *inum, unsigned int *type)
 {
 	struct buffer_head *bh;
 	struct gfs2_dirent *dent;
@@ -1531,7 +1531,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
  */
 
 int gfs2_dir_add(struct inode *inode, const struct qstr *name,
-		 const struct gfs2_inum *inum, unsigned type)
+		 const struct gfs2_inum_host *inum, unsigned type)
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh;
@@ -1666,7 +1666,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
  */
 
 int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
-		   struct gfs2_inum *inum, unsigned int new_type)
+		   struct gfs2_inum_host *inum, unsigned int new_type)
 {
 	struct buffer_head *bh;
 	struct gfs2_dirent *dent;

commit b7d8ac3e1779c30ddef0a8f38042076c5007a23d
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Oct 19 16:02:07 2006 +0200

    [GFS2] gfs2_dir_read_data(): fix uninitialized variable usage
    
    In the "if (extlen)" case, "bh" was used uninitialized.
    
    This patch changes the code to what seems to have been intended.
    
    Spotted by the Coverity checker.
    
    This patch also removes a pointless "bh = NULL" asignment (the variable
    is never accessed again after this point).
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ead7df066853..e24af28b1a12 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -315,8 +315,7 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 			if (!ra)
 				extlen = 1;
 			bh = gfs2_meta_ra(ip->i_gl, dblock, extlen);
-		}
-		if (!bh) {
+		} else {
 			error = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, &bh);
 			if (error)
 				goto fail;
@@ -330,7 +329,6 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
 		extlen--;
 		memcpy(buf, bh->b_data + o, amount);
 		brelse(bh);
-		bh = NULL;
 		buf += amount;
 		copied += amount;
 		lblock++;

commit 348acd48f050f5ba7fa917b1421ae34443be97dd
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Oct 19 15:20:04 2006 +0200

    [GFS2] fs/gfs2/dir.c:gfs2_dir_write_data(): don't use an uninitialized variable
    
    In the "if (extlen)" case, "new" might be used uninitialized.
    
    Looking at the code, it should be initialized to 0.
    
    Spotted by the Coverity checker.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ce52bd954df6..ead7df066853 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -184,7 +184,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	while (copied < size) {
 		unsigned int amount;
 		struct buffer_head *bh;
-		int new;
+		int new = 0;
 
 		amount = size - copied;
 		if (amount > sdp->sd_sb.sb_bsize - o)

commit abbdbd2065e74411dc2c401501c2c85a82f60e06
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Oct 19 15:12:24 2006 +0200

    [GFS2] fs/gfs2/dir.c:gfs2_dir_write_data(): remove dead code
    
    The Coverity checker spotted this obviously dead code.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d43caf04bb68..ce52bd954df6 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -212,8 +212,6 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 		gfs2_trans_add_bh(ip->i_gl, bh, 1);
 		memcpy(bh->b_data + o, buf, amount);
 		brelse(bh);
-		if (error)
-			goto fail;
 
 		buf += amount;
 		copied += amount;

commit a2d7d021d78dbc00d24d9c809c64a7f3e61fa773
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 14 16:49:30 2006 +0100

    [GFS2] gfs2 endianness bug: be16 assigned to be32 field
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 459498cac93b..d43caf04bb68 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -815,7 +815,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	leaf = (struct gfs2_leaf *)bh->b_data;
 	leaf->lf_depth = cpu_to_be16(depth);
 	leaf->lf_entries = 0;
-	leaf->lf_dirent_format = cpu_to_be16(GFS2_FORMAT_DE);
+	leaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);
 	leaf->lf_next = 0;
 	memset(leaf->lf_reserved, 0, sizeof(leaf->lf_reserved));
 	dent = (struct gfs2_dirent *)(leaf+1);

commit 907b9bceb41fa46beae93f79cc4a2247df502c0f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 25 09:26:04 2006 -0400

    [GFS2/DLM] Fix trailing whitespace
    
    As per Andrew Morton's request, removed trailing whitespace.
    
    Cc: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 40e94ac0b93d..459498cac93b 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -81,7 +81,7 @@
 #define gfs2_disk_hash2offset(h) (((u64)(h)) >> 1)
 #define gfs2_dir_offset2hash(p) ((u32)(((u64)(p)) << 1))
 
-typedef int (*leaf_call_t) (struct gfs2_inode *dip, u32 index, u32 len, 
+typedef int (*leaf_call_t) (struct gfs2_inode *dip, u32 index, u32 len,
 			    u64 leaf_no, void *data);
 typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
 			    const struct qstr *name, void *opaque);
@@ -119,7 +119,6 @@ static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,
 
 static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 				  unsigned int offset, unsigned int size)
-                               
 {
 	struct buffer_head *dibh;
 	int error;
@@ -685,7 +684,7 @@ static struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,
 					     const struct qstr *name)
 {
 	struct gfs2_dirent *dent;
-	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, 
+	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,
 				gfs2_dirent_find_space, name, NULL);
 	if (!dent || IS_ERR(dent))
 		return dent;
@@ -764,7 +763,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 			gfs2_consist_inode(ip);
 			return ERR_PTR(-EIO);
 		}
-		
+
 		index = name->hash >> (32 - ip->i_di.di_depth);
 		error = get_first_leaf(ip, index, &bh);
 		if (error)
@@ -779,14 +778,14 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 			brelse(bh);
 			if (!ln)
 				break;
-			
+
 			error = get_leaf(ip, ln, &bh);
 		} while(!error);
 
 		return error ? ERR_PTR(error) : NULL;
 	}
 
-	
+
 	error = gfs2_meta_inode_buffer(ip, &bh);
 	if (error)
 		return ERR_PTR(error);
@@ -810,7 +809,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct qstr name = { .name = "", .len = 0, .hash = 0 };
 	if (!bh)
 		return NULL;
-	
+
 	gfs2_trans_add_bh(ip->i_gl, bh, 1);
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	leaf = (struct gfs2_leaf *)bh->b_data;

commit 7276b3b0c77101f8b3f4e45e89a29cf9045e831a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Sep 21 17:05:23 2006 -0400

    [GFS2] Tidy up meta_io code
    
    Fix a bug in the directory reading code, where we might have dereferenced
    a NULL pointer in case of OOM. Updated the directory code to use the new
    & improved version of gfs2_meta_ra() which now returns the first block
    that was being read. Previously it was releasing it requiring following
    code to grab the block again at each point it was called.
    
    Also turned off readahead on directory lookups since we are reading a
    hash table, and therefore reading the entries in order is very
    unlikely. Readahead is still used for all other calls to the
    directory reading function (e.g. when growing the hash table).
    
    Removed the DIO_START constant. Everywhere this was used, it was
    used to unconditionally start i/o aside from a couple of places, so
    I've removed it and made the couple of exceptions to this rule into
    separate functions.
    
    Also hunted through the other DIO flags and removed them as arguments
    from functions which were always called with the same combination of
    arguments.
    
    Updated gfs2_meta_indirect_buffer to be a bit more efficient and
    hopefully also be a bit easier to read.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 739028688270..40e94ac0b93d 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -106,7 +106,7 @@ static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,
 	struct buffer_head *bh;
 	int error;
 
-	error = gfs2_meta_read(ip->i_gl, block, DIO_START | DIO_WAIT, &bh);
+	error = gfs2_meta_read(ip->i_gl, block, DIO_WAIT, &bh);
 	if (error)
 		return error;
 	if (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_JD)) {
@@ -246,7 +246,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 }
 
 static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, char *buf,
-				 unsigned int offset, unsigned int size)
+				 u64 offset, unsigned int size)
 {
 	struct buffer_head *dibh;
 	int error;
@@ -271,8 +271,8 @@ static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, char *buf,
  *
  * Returns: The amount of data actually copied or the error
  */
-static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
-			      u64 offset, unsigned int size)
+static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf, u64 offset,
+			      unsigned int size, unsigned ra)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 	u64 lblock, dblock;
@@ -291,8 +291,7 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 		return 0;
 
 	if (gfs2_is_stuffed(ip))
-		return gfs2_dir_read_stuffed(ip, buf, (unsigned int)offset,
-					     size);
+		return gfs2_dir_read_stuffed(ip, buf, offset, size);
 
 	if (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))
 		return -EINVAL;
@@ -313,34 +312,31 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 			new = 0;
 			error = gfs2_extent_map(&ip->i_inode, lblock, &new,
 						&dblock, &extlen);
-			if (error)
+			if (error || !dblock)
 				goto fail;
+			BUG_ON(extlen < 1);
+			if (!ra)
+				extlen = 1;
+			bh = gfs2_meta_ra(ip->i_gl, dblock, extlen);
 		}
-
-		if (extlen > 1)
-			gfs2_meta_ra(ip->i_gl, dblock, extlen);
-
-		if (dblock) {
-			if (new)
-				error = gfs2_dir_get_new_buffer(ip, dblock, &bh);
-			else
-				error = gfs2_dir_get_existing_buffer(ip, dblock, &bh);
+		if (!bh) {
+			error = gfs2_meta_read(ip->i_gl, dblock, DIO_WAIT, &bh);
 			if (error)
 				goto fail;
-			dblock++;
-			extlen--;
-		} else
-			bh = NULL;
-
+		}
+		error = gfs2_metatype_check(sdp, bh, GFS2_METATYPE_JD);
+		if (error) {
+			brelse(bh);
+			goto fail;
+		}
+		dblock++;
+		extlen--;
 		memcpy(buf, bh->b_data + o, amount);
 		brelse(bh);
-		if (error)
-			goto fail;
-
+		bh = NULL;
 		buf += amount;
 		copied += amount;
 		lblock++;
-
 		o = sizeof(struct gfs2_meta_header);
 	}
 
@@ -701,7 +697,7 @@ static int get_leaf(struct gfs2_inode *dip, u64 leaf_no,
 {
 	int error;
 
-	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_START | DIO_WAIT, bhp);
+	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, bhp);
 	if (!error && gfs2_metatype_check(GFS2_SB(&dip->i_inode), *bhp, GFS2_METATYPE_LF)) {
 		/* printk(KERN_INFO "block num=%llu\n", leaf_no); */
 		error = -EIO;
@@ -727,7 +723,7 @@ static int get_leaf_nr(struct gfs2_inode *dip, u32 index,
 
 	error = gfs2_dir_read_data(dip, (char *)&leaf_no,
 				    index * sizeof(u64),
-				    sizeof(u64));
+				    sizeof(u64), 0);
 	if (error != sizeof(u64))
 		return (error < 0) ? error : -EIO;
 
@@ -1095,7 +1091,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	for (block = dip->i_di.di_size >> sdp->sd_hash_bsize_shift; block--;) {
 		error = gfs2_dir_read_data(dip, (char *)buf,
 					    block * sdp->sd_hash_bsize,
-					    sdp->sd_hash_bsize);
+					    sdp->sd_hash_bsize, 1);
 		if (error != sdp->sd_hash_bsize) {
 			if (error >= 0)
 				error = -EIO;
@@ -1375,7 +1371,7 @@ static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 		if (ht_offset_cur != ht_offset) {
 			error = gfs2_dir_read_data(dip, (char *)lp,
 						ht_offset * sizeof(u64),
-						sdp->sd_hash_bsize);
+						sdp->sd_hash_bsize, 1);
 			if (error != sdp->sd_hash_bsize) {
 				if (error >= 0)
 					error = -EIO;
@@ -1745,7 +1741,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 		if (ht_offset_cur != ht_offset) {
 			error = gfs2_dir_read_data(dip, (char *)lp,
 						ht_offset * sizeof(u64),
-						sdp->sd_hash_bsize);
+						sdp->sd_hash_bsize, 1);
 			if (error != sdp->sd_hash_bsize) {
 				if (error >= 0)
 					error = -EIO;

commit 7d308590ae60d1f038a54a94e78a385c5c163452
Author: Fabio Massimo Di Nitto <fabbione@ubuntu.com>
Date:   Tue Sep 19 07:56:29 2006 +0200

    [GFS2] Export lm_interface to kernel headers
    
    
    lm_interface.h has a few out of the tree clients such as GFS1
    and userland tools.
    
    Right now, these clients keeps a copy of the file in their build tree
    that can go out of sync.
    
    Move lm_interface.h to include/linux, export it to userland and
    clean up fs/gfs2 to use the new location.
    
    Signed-off-by: Fabio M. Di Nitto <fabbione@ubuntu.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f3dbda216caf..739028688270 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -61,9 +61,9 @@
 #include <linux/gfs2_ondisk.h>
 #include <linux/crc32.h>
 #include <linux/vmalloc.h>
+#include <linux/lm_interface.h>
 
 #include "gfs2.h"
-#include "lm_interface.h"
 #include "incore.h"
 #include "dir.h"
 #include "glock.h"

commit c53921248c79197befa7caa4c17b1af5c077a2c2
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Tue Sep 5 14:30:40 2006 +0200

    [GFS2] More style changes
    
    Remove redundant brackets
    
    Signed-off-by: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index d74a52bda540..f3dbda216caf 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -284,7 +284,7 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 	if (offset >= ip->i_di.di_size)
 		return 0;
 
-	if ((offset + size) > ip->i_di.di_size)
+	if (offset + size > ip->i_di.di_size)
 		size = ip->i_di.di_size - offset;
 
 	if (!size)
@@ -399,7 +399,7 @@ static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,
 
 	if (!dent->de_inum.no_addr)
 		actual = GFS2_DIRENT_SIZE(0);
-	if ((totlen - actual) >= required)
+	if (totlen - actual >= required)
 		return 1;
 	return 0;
 }

commit 2bdbc5d73961c040fdc9b30d985fab3047d697a0
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Sep 5 09:34:20 2006 -0400

    [GFS2] Directory code style changes
    
    As per comments from Jan Engelhardt, remove redundant casts, redundant
    endian conversions, add a smattering of const and rewrite the
    dirent_next function in order to avoid as many casts as possible.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 2023dc4ea306..d74a52bda540 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -81,9 +81,10 @@
 #define gfs2_disk_hash2offset(h) (((u64)(h)) >> 1)
 #define gfs2_dir_offset2hash(p) ((u32)(((u64)(p)) << 1))
 
-typedef int (*leaf_call_t) (struct gfs2_inode *dip,
-			    u32 index, u32 len, u64 leaf_no,
-			    void *data);
+typedef int (*leaf_call_t) (struct gfs2_inode *dip, u32 index, u32 len, 
+			    u64 leaf_no, void *data);
+typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
+			    const struct qstr *name, void *opaque);
 
 
 int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,
@@ -348,17 +349,13 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 	return (copied) ? copied : error;
 }
 
-typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
-			    const struct qstr *name,
-			    void *opaque);
-
 static inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,
 				     const struct qstr *name, int ret)
 {
 	if (dent->de_inum.no_addr != 0 &&
 	    be32_to_cpu(dent->de_hash) == name->hash &&
 	    be16_to_cpu(dent->de_name_len) == name->len &&
-	    memcmp((char *)(dent+1), name->name, name->len) == 0)
+	    memcmp(dent+1, name->name, name->len) == 0)
 		return ret;
 	return 0;
 }
@@ -483,8 +480,7 @@ static int gfs2_dirent_offset(const void *buf)
 	return -1;
 }
 
-static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
-					    void *buf,
+static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode, void *buf,
 					    unsigned int len, gfs2_dscan_t scan,
 					    const struct qstr *name,
 					    void *opaque)
@@ -500,7 +496,7 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
 
 	offset = ret;
 	prev = NULL;
-	dent = (struct gfs2_dirent *)(buf + offset);
+	dent = buf + offset;
 	size = be16_to_cpu(dent->de_rec_len);
 	if (gfs2_check_dirent(dent, offset, size, len, 1))
 		goto consist_inode;
@@ -512,7 +508,7 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
 		if (offset == len)
 			break;
 		prev = dent;
-		dent = (struct gfs2_dirent *)(buf + offset);
+		dent = buf + offset;
 		size = be16_to_cpu(dent->de_rec_len);
 		if (gfs2_check_dirent(dent, offset, size, len, 0))
 			goto consist_inode;
@@ -567,6 +563,24 @@ static int dirent_first(struct gfs2_inode *dip, struct buffer_head *bh,
 	}
 }
 
+static int dirent_check_reclen(struct gfs2_inode *dip,
+			       const struct gfs2_dirent *d, const void *end_p)
+{
+	const void *ptr = d;
+	u16 rec_len = be16_to_cpu(d->de_rec_len);
+
+	if (unlikely(rec_len < sizeof(struct gfs2_dirent)))
+		goto broken;
+	ptr += rec_len;
+	if (ptr < end_p)
+		return rec_len;
+	if (ptr == end_p)
+		return -ENOENT;
+broken:
+	gfs2_consist_inode(dip);
+	return -EIO;
+}
+
 /**
  * dirent_next - Next dirent
  * @dip: the directory
@@ -579,33 +593,18 @@ static int dirent_first(struct gfs2_inode *dip, struct buffer_head *bh,
 static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 		       struct gfs2_dirent **dent)
 {
-	struct gfs2_dirent *tmp, *cur;
-	char *bh_end;
-	u16 cur_rec_len;
-
-	cur = *dent;
-	bh_end = bh->b_data + bh->b_size;
-	cur_rec_len = be16_to_cpu(cur->de_rec_len);
-
-	if ((char *)cur + cur_rec_len >= bh_end) {
-		if ((char *)cur + cur_rec_len > bh_end) {
-			gfs2_consist_inode(dip);
-			return -EIO;
-		}
-		return -ENOENT;
-	}
-
-	tmp = (struct gfs2_dirent *)((char *)cur + cur_rec_len);
+	struct gfs2_dirent *cur = *dent, *tmp;
+	char *bh_end = bh->b_data + bh->b_size;
+	int ret;
 
-	if ((char *)tmp + be16_to_cpu(tmp->de_rec_len) > bh_end) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
+	ret = dirent_check_reclen(dip, cur, bh_end);
+	if (ret < 0)
+		return ret;
 
-	if (cur_rec_len == 0) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
+	tmp = (void *)cur + ret;
+	ret = dirent_check_reclen(dip, tmp, bh_end);
+	if (ret == -EIO)
+		return ret;
 
         /* Only the first dent could ever have de_inum.no_addr == 0 */
 	if (!tmp->de_inum.no_addr) {
@@ -614,7 +613,6 @@ static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 	}
 
 	*dent = tmp;
-
 	return 0;
 }
 
@@ -821,9 +819,9 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	leaf = (struct gfs2_leaf *)bh->b_data;
 	leaf->lf_depth = cpu_to_be16(depth);
-	leaf->lf_entries = cpu_to_be16(0);
+	leaf->lf_entries = 0;
 	leaf->lf_dirent_format = cpu_to_be16(GFS2_FORMAT_DE);
-	leaf->lf_next = cpu_to_be64(0);
+	leaf->lf_next = 0;
 	memset(leaf->lf_reserved, 0, sizeof(leaf->lf_reserved));
 	dent = (struct gfs2_dirent *)(leaf+1);
 	gfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);
@@ -1152,14 +1150,14 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 
 static int compare_dents(const void *a, const void *b)
 {
-	struct gfs2_dirent *dent_a, *dent_b;
+	const struct gfs2_dirent *dent_a, *dent_b;
 	u32 hash_a, hash_b;
 	int ret = 0;
 
-	dent_a = *(struct gfs2_dirent **)a;
+	dent_a = *(const struct gfs2_dirent **)a;
 	hash_a = be32_to_cpu(dent_a->de_hash);
 
-	dent_b = *(struct gfs2_dirent **)b;
+	dent_b = *(const struct gfs2_dirent **)b;
 	hash_b = be32_to_cpu(dent_b->de_hash);
 
 	if (hash_a > hash_b)
@@ -1175,9 +1173,7 @@ static int compare_dents(const void *a, const void *b)
 		else if (len_a < len_b)
 			ret = -1;
 		else
-			ret = memcmp((char *)(dent_a + 1),
-				     (char *)(dent_b + 1),
-				     len_a);
+			ret = memcmp(dent_a + 1, dent_b + 1, len_a);
 	}
 
 	return ret;
@@ -1246,7 +1242,7 @@ static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 
 		gfs2_inum_in(&inum, (char *)&dent->de_inum);
 
-		error = filldir(opaque, (char *)(dent + 1),
+		error = filldir(opaque, (const char *)(dent + 1),
 				be16_to_cpu(dent->de_name_len),
 				off, &inum,
 				be16_to_cpu(dent->de_type));
@@ -1298,7 +1294,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 		return 0;
 
 	error = -ENOMEM;
-	larr = vmalloc((leaves + entries) * sizeof(void*));
+	larr = vmalloc((leaves + entries) * sizeof(void *));
 	if (!larr)
 		goto out;
 	darr = (const struct gfs2_dirent **)(larr + leaves);

commit cd915493fce912f1bd838ee1250737ecf33b8fae
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 4 12:49:07 2006 -0400

    [GFS2] Change all types to uX style
    
    This makes all fixed size types have consistent names.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 59d0cbcaecff..2023dc4ea306 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -78,15 +78,15 @@
 #define IS_LEAF     1 /* Hashed (leaf) directory */
 #define IS_DINODE   2 /* Linear (stuffed dinode block) directory */
 
-#define gfs2_disk_hash2offset(h) (((uint64_t)(h)) >> 1)
-#define gfs2_dir_offset2hash(p) ((uint32_t)(((uint64_t)(p)) << 1))
+#define gfs2_disk_hash2offset(h) (((u64)(h)) >> 1)
+#define gfs2_dir_offset2hash(p) ((u32)(((u64)(p)) << 1))
 
 typedef int (*leaf_call_t) (struct gfs2_inode *dip,
-			    uint32_t index, uint32_t len, uint64_t leaf_no,
+			    u32 index, u32 len, u64 leaf_no,
 			    void *data);
 
 
-int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, uint64_t block,
+int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, u64 block,
 			    struct buffer_head **bhp)
 {
 	struct buffer_head *bh;
@@ -99,7 +99,7 @@ int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, uint64_t block,
 	return 0;
 }
 
-static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, uint64_t block,
+static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, u64 block,
 					struct buffer_head **bhp)
 {
 	struct buffer_head *bh;
@@ -151,12 +151,12 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
  * Returns: The number of bytes correctly written or error code
  */
 static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
-			       uint64_t offset, unsigned int size)
+			       u64 offset, unsigned int size)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 	struct buffer_head *dibh;
-	uint64_t lblock, dblock;
-	uint32_t extlen = 0;
+	u64 lblock, dblock;
+	u32 extlen = 0;
 	unsigned int o;
 	int copied = 0;
 	int error = 0;
@@ -271,11 +271,11 @@ static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, char *buf,
  * Returns: The amount of data actually copied or the error
  */
 static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
-			      uint64_t offset, unsigned int size)
+			      u64 offset, unsigned int size)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
-	uint64_t lblock, dblock;
-	uint32_t extlen = 0;
+	u64 lblock, dblock;
+	u32 extlen = 0;
 	unsigned int o;
 	int copied = 0;
 	int error = 0;
@@ -581,7 +581,7 @@ static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 {
 	struct gfs2_dirent *tmp, *cur;
 	char *bh_end;
-	uint16_t cur_rec_len;
+	u16 cur_rec_len;
 
 	cur = *dent;
 	bh_end = bh->b_data + bh->b_size;
@@ -630,7 +630,7 @@ static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 		       struct gfs2_dirent *prev, struct gfs2_dirent *cur)
 {
-	uint16_t cur_rec_len, prev_rec_len;
+	u16 cur_rec_len, prev_rec_len;
 
 	if (!cur->de_inum.no_addr) {
 		gfs2_consist_inode(dip);
@@ -698,7 +698,7 @@ static struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,
 	return gfs2_init_dirent(inode, dent, name, bh);
 }
 
-static int get_leaf(struct gfs2_inode *dip, uint64_t leaf_no,
+static int get_leaf(struct gfs2_inode *dip, u64 leaf_no,
 		    struct buffer_head **bhp)
 {
 	int error;
@@ -721,16 +721,16 @@ static int get_leaf(struct gfs2_inode *dip, uint64_t leaf_no,
  * Returns: 0 on success, error code otherwise
  */
 
-static int get_leaf_nr(struct gfs2_inode *dip, uint32_t index,
-		       uint64_t *leaf_out)
+static int get_leaf_nr(struct gfs2_inode *dip, u32 index,
+		       u64 *leaf_out)
 {
-	uint64_t leaf_no;
+	u64 leaf_no;
 	int error;
 
 	error = gfs2_dir_read_data(dip, (char *)&leaf_no,
-				    index * sizeof(uint64_t),
-				    sizeof(uint64_t));
-	if (error != sizeof(uint64_t))
+				    index * sizeof(u64),
+				    sizeof(u64));
+	if (error != sizeof(u64))
 		return (error < 0) ? error : -EIO;
 
 	*leaf_out = be64_to_cpu(leaf_no);
@@ -738,10 +738,10 @@ static int get_leaf_nr(struct gfs2_inode *dip, uint32_t index,
 	return 0;
 }
 
-static int get_first_leaf(struct gfs2_inode *dip, uint32_t index,
+static int get_first_leaf(struct gfs2_inode *dip, u32 index,
 			  struct buffer_head **bh_out)
 {
-	uint64_t leaf_no;
+	u64 leaf_no;
 	int error;
 
 	error = get_leaf_nr(dip, index, &leaf_no);
@@ -847,8 +847,8 @@ static int dir_make_exhash(struct inode *inode)
 	struct buffer_head *bh, *dibh;
 	struct gfs2_leaf *leaf;
 	int y;
-	uint32_t x;
-	uint64_t *lp, bn;
+	u32 x;
+	u64 *lp, bn;
 	int error;
 
 	error = gfs2_meta_inode_buffer(dip, &dibh);
@@ -904,7 +904,7 @@ static int dir_make_exhash(struct inode *inode)
 	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 	gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
 
-	lp = (uint64_t *)(dibh->b_data + sizeof(struct gfs2_dinode));
+	lp = (u64 *)(dibh->b_data + sizeof(struct gfs2_dinode));
 
 	for (x = sdp->sd_hash_ptrs; x--; lp++)
 		*lp = cpu_to_be64(bn);
@@ -939,9 +939,9 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	struct buffer_head *nbh, *obh, *dibh;
 	struct gfs2_leaf *nleaf, *oleaf;
 	struct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;
-	uint32_t start, len, half_len, divider;
-	uint64_t bn, *lp, leaf_no;
-	uint32_t index;
+	u32 start, len, half_len, divider;
+	u64 bn, *lp, leaf_no;
+	u32 index;
 	int x, moved = 0;
 	int error;
 
@@ -985,14 +985,14 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	/* Change the pointers.
 	   Don't bother distinguishing stuffed from non-stuffed.
 	   This code is complicated enough already. */
-	lp = kmalloc(half_len * sizeof(uint64_t), GFP_NOFS | __GFP_NOFAIL);
+	lp = kmalloc(half_len * sizeof(u64), GFP_NOFS | __GFP_NOFAIL);
 	/*  Change the pointers  */
 	for (x = 0; x < half_len; x++)
 		lp[x] = cpu_to_be64(bn);
 
-	error = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(uint64_t),
-				    half_len * sizeof(uint64_t));
-	if (error != half_len * sizeof(uint64_t)) {
+	error = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(u64),
+				    half_len * sizeof(u64));
+	if (error != half_len * sizeof(u64)) {
 		if (error >= 0)
 			error = -EIO;
 		goto fail_lpfree;
@@ -1077,15 +1077,15 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct buffer_head *dibh;
-	uint32_t hsize;
-	uint64_t *buf;
-	uint64_t *from, *to;
-	uint64_t block;
+	u32 hsize;
+	u64 *buf;
+	u64 *from, *to;
+	u64 block;
 	int x;
 	int error = 0;
 
 	hsize = 1 << dip->i_di.di_depth;
-	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+	if (hsize * sizeof(u64) != dip->i_di.di_size) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1105,7 +1105,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 		}
 
 		from = buf;
-		to = (uint64_t *)((char *)buf + sdp->sd_hash_bsize);
+		to = (u64 *)((char *)buf + sdp->sd_hash_bsize);
 
 		for (x = sdp->sd_hash_ptrs; x--; from++) {
 			*to++ = *from;	/*  No endianess worries  */
@@ -1153,7 +1153,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 static int compare_dents(const void *a, const void *b)
 {
 	struct gfs2_dirent *dent_a, *dent_b;
-	uint32_t hash_a, hash_b;
+	u32 hash_a, hash_b;
 	int ret = 0;
 
 	dent_a = *(struct gfs2_dirent **)a;
@@ -1201,14 +1201,14 @@ static int compare_dents(const void *a, const void *b)
  * Returns: errno, >0 on exception from filldir
  */
 
-static int do_filldir_main(struct gfs2_inode *dip, uint64_t *offset,
+static int do_filldir_main(struct gfs2_inode *dip, u64 *offset,
 			   void *opaque, gfs2_filldir_t filldir,
-			   const struct gfs2_dirent **darr, uint32_t entries,
+			   const struct gfs2_dirent **darr, u32 entries,
 			   int *copied)
 {
 	const struct gfs2_dirent *dent, *dent_next;
 	struct gfs2_inum inum;
-	uint64_t off, off_next;
+	u64 off, off_next;
 	unsigned int x, y;
 	int run = 0;
 	int error = 0;
@@ -1346,21 +1346,21 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
  * Returns: errno
  */
 
-static int dir_e_read(struct inode *inode, uint64_t *offset, void *opaque,
+static int dir_e_read(struct inode *inode, u64 *offset, void *opaque,
 		      gfs2_filldir_t filldir)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
-	uint32_t hsize, len = 0;
-	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
-	uint32_t hash, index;
-	uint64_t *lp;
+	u32 hsize, len = 0;
+	u32 ht_offset, lp_offset, ht_offset_cur = -1;
+	u32 hash, index;
+	u64 *lp;
 	int copied = 0;
 	int error = 0;
 	unsigned depth = 0;
 
 	hsize = 1 << dip->i_di.di_depth;
-	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+	if (hsize * sizeof(u64) != dip->i_di.di_size) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1378,7 +1378,7 @@ static int dir_e_read(struct inode *inode, uint64_t *offset, void *opaque,
 
 		if (ht_offset_cur != ht_offset) {
 			error = gfs2_dir_read_data(dip, (char *)lp,
-						ht_offset * sizeof(uint64_t),
+						ht_offset * sizeof(u64),
 						sdp->sd_hash_bsize);
 			if (error != sdp->sd_hash_bsize) {
 				if (error >= 0)
@@ -1405,7 +1405,7 @@ static int dir_e_read(struct inode *inode, uint64_t *offset, void *opaque,
 	return error;
 }
 
-int gfs2_dir_read(struct inode *inode, uint64_t *offset, void *opaque,
+int gfs2_dir_read(struct inode *inode, u64 *offset, void *opaque,
 		  gfs2_filldir_t filldir)
 {
 	struct gfs2_inode *dip = GFS2_I(inode);
@@ -1725,15 +1725,15 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct buffer_head *bh;
 	struct gfs2_leaf *leaf;
-	uint32_t hsize, len;
-	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
-	uint32_t index = 0;
-	uint64_t *lp;
-	uint64_t leaf_no;
+	u32 hsize, len;
+	u32 ht_offset, lp_offset, ht_offset_cur = -1;
+	u32 index = 0;
+	u64 *lp;
+	u64 leaf_no;
 	int error = 0;
 
 	hsize = 1 << dip->i_di.di_depth;
-	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+	if (hsize * sizeof(u64) != dip->i_di.di_size) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1748,7 +1748,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 
 		if (ht_offset_cur != ht_offset) {
 			error = gfs2_dir_read_data(dip, (char *)lp,
-						ht_offset * sizeof(uint64_t),
+						ht_offset * sizeof(u64),
 						sdp->sd_hash_bsize);
 			if (error != sdp->sd_hash_bsize) {
 				if (error >= 0)
@@ -1798,17 +1798,17 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
  * Returns: errno
  */
 
-static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
-			uint64_t leaf_no, void *data)
+static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
+			u64 leaf_no, void *data)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct gfs2_leaf *tmp_leaf;
 	struct gfs2_rgrp_list rlist;
 	struct buffer_head *bh, *dibh;
-	uint64_t blk, nblk;
+	u64 blk, nblk;
 	unsigned int rg_blocks = 0, l_blocks = 0;
 	char *ht;
-	unsigned int x, size = len * sizeof(uint64_t);
+	unsigned int x, size = len * sizeof(u64);
 	int error;
 
 	memset(&rlist, 0, sizeof(struct gfs2_rgrp_list));
@@ -1874,7 +1874,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 		dip->i_di.di_blocks--;
 	}
 
-	error = gfs2_dir_write_data(dip, ht, index * sizeof(uint64_t), size);
+	error = gfs2_dir_write_data(dip, ht, index * sizeof(u64), size);
 	if (error != size) {
 		if (error >= 0)
 			error = -EIO;

commit a91ea69ffd3f8a0b7139bfd44042ab384461e631
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 4 12:04:26 2006 -0400

    [GFS2] Align all labels against LH side
    
    This makes everything consistent.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 7b8a38eaa41a..59d0cbcaecff 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1134,9 +1134,8 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 
 	return error;
 
- fail:
+fail:
 	kfree(buf);
-
 	return error;
 }
 
@@ -1890,23 +1889,18 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 	gfs2_dinode_out(&dip->i_di, dibh->b_data);
 	brelse(dibh);
 
- out_end_trans:
+out_end_trans:
 	gfs2_trans_end(sdp);
-
- out_rg_gunlock:
+out_rg_gunlock:
 	gfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);
-
- out_rlist:
+out_rlist:
 	gfs2_rlist_free(&rlist);
 	gfs2_glock_dq_uninit(&dip->i_alloc.al_ri_gh);
-
- out_qs:
+out_qs:
 	gfs2_quota_unhold(dip);
-
- out:
+out:
 	gfs2_alloc_put(dip);
 	kfree(ht);
-
 	return error;
 }
 

commit e9fc2aa091ab8fa46e60d4c9d06a89305c441652
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 1 11:05:15 2006 -0400

    [GFS2] Update copyright, tidy up incore.h
    
    As per comments from Jan Engelhardt <jengelh@linux01.gwdg.de> this
    updates the copyright message to say "version" in full rather than
    "v.2". Also incore.h has been updated to remove forward structure
    declarations which are not required.
    
    The gfs2_quota_lvb structure has now had endianess annotations added
    to it. Also quota.c has been updated so that we now store the
    lvb data locally in endian independant format to avoid needing
    a structure in host endianess too. As a result the endianess
    conversions are done as required at various points and thus the
    conversion routines in lvb.[ch] are no longer required. I've
    moved the one remaining constant in lvb.h thats used into lm.h
    and removed the unused lvb.[ch].
    
    I have not changed the HIF_ constants. That is left to a later patch
    which I hope will unify the gh_flags and gh_iflags fields of the
    struct gfs2_holder.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 76a23c172eeb..7b8a38eaa41a 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -4,7 +4,7 @@
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
- * of the GNU General Public License v.2.
+ * of the GNU General Public License version 2.
  */
 
 /*

commit 899bb264507cfed83922bf14cd66a073494601ba
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Aug 1 15:28:57 2006 -0400

    [GFS2] Fix bug in directory code
    
    This was a nasty bug which resulted in corruption of hash tables
    in the directory code with larger directories. We forgot to
    increment a pointer in the read/write routines internal to the
    directory code.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 563b99e419b6..76a23c172eeb 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -215,6 +215,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 		if (error)
 			goto fail;
 
+		buf += amount;
 		copied += amount;
 		lblock++;
 		dblock++;
@@ -335,6 +336,7 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 		if (error)
 			goto fail;
 
+		buf += amount;
 		copied += amount;
 		lblock++;
 

commit f25ef0c1b4e032b2641857ac4cff3315c6eb90e3
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jul 26 10:51:20 2006 -0400

    [GFS2] Tidy gfs2_unstuffer_page
    
    Tidy up gfs2_unstuffer_page by:
    
     a) Moving it into bmap.c
     b) Making it static
     c) Calling it directly from gfs2_unstuff_dinode
     d) Updating all callers of gfs2_unstuff_dinode due to one less
        required argument.
    
    It doesn't change the behaviour at all.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f62223b9e53d..563b99e419b6 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -173,7 +173,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 		return -EINVAL;
 
 	if (gfs2_is_stuffed(ip)) {
-		error = gfs2_unstuff_dinode(ip, NULL, NULL);
+		error = gfs2_unstuff_dinode(ip, NULL);
 		if (error)
 			return error;
 	}

commit 634ee0b9f458f3530b9c0ea7e6951dd03db7d678
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jul 17 09:32:37 2006 -0400

    [GFS2] Fix use after free bug in dir.c
    
    Fix a use after free bug in dir.c spotted by Kevin Anderson.
    
    Cc: Kevin Anderson <kanderso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index e96b5322c843..f62223b9e53d 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1763,9 +1763,8 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 			if (error)
 				goto out;
 			leaf = (struct gfs2_leaf *)bh->b_data;
-			brelse(bh);
-
 			len = 1 << (dip->i_di.di_depth - be16_to_cpu(leaf->lf_depth));
+			brelse(bh);
 
 			error = lc(dip, index, len, leaf_no, data);
 			if (error)
@@ -1781,7 +1780,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 		error = -EIO;
 	}
 
- out:
+out:
 	kfree(lp);
 
 	return error;

commit 4da3c6463ef6759fb50d12c8652bc29c5c1730a4
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jul 11 13:19:13 2006 -0400

    [GFS2] Fix a coupls of warnings in dir.c
    
    Fix a couple of compiler warnings in dir.c caused by
    potentially uninitialised variables.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 13d3709e0c0b..e96b5322c843 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -936,7 +936,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	struct gfs2_inode *dip = GFS2_I(inode);
 	struct buffer_head *nbh, *obh, *dibh;
 	struct gfs2_leaf *nleaf, *oleaf;
-	struct gfs2_dirent *dent, *prev = NULL, *next = NULL, *new;
+	struct gfs2_dirent *dent = NULL, *prev = NULL, *next = NULL, *new;
 	uint32_t start, len, half_len, divider;
 	uint64_t bn, *lp, leaf_no;
 	uint32_t index;
@@ -1356,7 +1356,7 @@ static int dir_e_read(struct inode *inode, uint64_t *offset, void *opaque,
 	uint64_t *lp;
 	int copied = 0;
 	int error = 0;
-	unsigned depth;
+	unsigned depth = 0;
 
 	hsize = 1 << dip->i_di.di_depth;
 	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {

commit dc3e130a08996e2b56381365a5ac7bb1ce2a9f47
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jul 10 11:19:29 2006 -0400

    [GFS2] Remove unused code from dir.c
    
    Remove a couple of commented out, and unused lines of
    code.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index b0353884dd7d..13d3709e0c0b 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -78,13 +78,8 @@
 #define IS_LEAF     1 /* Hashed (leaf) directory */
 #define IS_DINODE   2 /* Linear (stuffed dinode block) directory */
 
-#if 1
 #define gfs2_disk_hash2offset(h) (((uint64_t)(h)) >> 1)
 #define gfs2_dir_offset2hash(p) ((uint32_t)(((uint64_t)(p)) << 1))
-#else
-#define gfs2_disk_hash2offset(h) (((uint64_t)(h)))
-#define gfs2_dir_offset2hash(p) ((uint32_t)(((uint64_t)(p))))
-#endif
 
 typedef int (*leaf_call_t) (struct gfs2_inode *dip,
 			    uint32_t index, uint32_t len, uint64_t leaf_no,

commit feaa7bba026c181ce071d5a4884f7f9dd26207a1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jun 14 15:32:57 2006 -0400

    [GFS2] Fix unlinked file handling
    
    This patch fixes the way we have been dealing with unlinked,
    but still open files. It removes all limits (other than memory
    for inodes, as per every other filesystem) on numbers of these
    which we can support on GFS2. It also means that (like other
    fs) its the responsibility of the last process to close the file
    to deallocate the storage, rather than the person who did the
    unlinking. Note that with GFS2, those two events might take place
    on different nodes.
    
    Also there are a number of other changes:
    
     o We use the Linux inode subsystem as it was intended to be
    used, wrt allocating GFS2 inodes
     o The Linux inode cache is now the point which we use for
    local enforcement of only holding one copy of the inode in
    core at once (previous to this we used the glock layer).
     o We no longer use the unlinked "special" file. We just ignore it
    completely. This makes unlinking more efficient.
     o We now use the 4th block allocation state. The previously unused
    state is used to track unlinked but still open inodes.
     o gfs2_inoded is no longer needed
     o Several fields are now no longer needed (and removed) from the in
    core struct gfs2_inode
     o Several fields are no longer needed (and removed) from the in core
    superblock
    
    There are a number of future possible optimisations and clean ups
    which have been made possible by this patch.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 6918a58261e2..b0353884dd7d 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -113,7 +113,7 @@ static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, uint64_t block,
 	error = gfs2_meta_read(ip->i_gl, block, DIO_START | DIO_WAIT, &bh);
 	if (error)
 		return error;
-	if (gfs2_metatype_check(ip->i_sbd, bh, GFS2_METATYPE_JD)) {
+	if (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_JD)) {
 		brelse(bh);
 		return -EIO;
 	}
@@ -158,7 +158,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 			       uint64_t offset, unsigned int size)
 {
-	struct gfs2_sbd *sdp = ip->i_sbd;
+	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 	struct buffer_head *dibh;
 	uint64_t lblock, dblock;
 	uint32_t extlen = 0;
@@ -197,7 +197,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 
 		if (!extlen) {
 			new = 1;
-			error = gfs2_extent_map(ip->i_vnode, lblock, &new,
+			error = gfs2_extent_map(&ip->i_inode, lblock, &new,
 						&dblock, &extlen);
 			if (error)
 				goto fail;
@@ -277,7 +277,7 @@ static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, char *buf,
 static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 			      uint64_t offset, unsigned int size)
 {
-	struct gfs2_sbd *sdp = ip->i_sbd;
+	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 	uint64_t lblock, dblock;
 	uint32_t extlen = 0;
 	unsigned int o;
@@ -314,7 +314,7 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 
 		if (!extlen) {
 			new = 0;
-			error = gfs2_extent_map(ip->i_vnode, lblock, &new,
+			error = gfs2_extent_map(&ip->i_inode, lblock, &new,
 						&dblock, &extlen);
 			if (error)
 				goto fail;
@@ -534,7 +534,7 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
 	}
 
 consist_inode:
-	gfs2_consist_inode(inode->u.generic_ip);
+	gfs2_consist_inode(GFS2_I(inode));
 	return ERR_PTR(-EIO);
 }
 
@@ -556,13 +556,13 @@ static int dirent_first(struct gfs2_inode *dip, struct buffer_head *bh,
 	struct gfs2_meta_header *h = (struct gfs2_meta_header *)bh->b_data;
 
 	if (be32_to_cpu(h->mh_type) == GFS2_METATYPE_LF) {
-		if (gfs2_meta_check(dip->i_sbd, bh))
+		if (gfs2_meta_check(GFS2_SB(&dip->i_inode), bh))
 			return -EIO;
 		*dent = (struct gfs2_dirent *)(bh->b_data +
 					       sizeof(struct gfs2_leaf));
 		return IS_LEAF;
 	} else {
-		if (gfs2_metatype_check(dip->i_sbd, bh, GFS2_METATYPE_DI))
+		if (gfs2_metatype_check(GFS2_SB(&dip->i_inode), bh, GFS2_METATYPE_DI))
 			return -EIO;
 		*dent = (struct gfs2_dirent *)(bh->b_data +
 					       sizeof(struct gfs2_dinode));
@@ -674,7 +674,7 @@ static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,
 					    const struct qstr *name,
 					    struct buffer_head *bh)
 {
-	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_dirent *ndent;
 	unsigned offset = 0, totlen;
 
@@ -707,8 +707,10 @@ static int get_leaf(struct gfs2_inode *dip, uint64_t leaf_no,
 	int error;
 
 	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_START | DIO_WAIT, bhp);
-	if (!error && gfs2_metatype_check(dip->i_sbd, *bhp, GFS2_METATYPE_LF))
+	if (!error && gfs2_metatype_check(GFS2_SB(&dip->i_inode), *bhp, GFS2_METATYPE_LF)) {
+		/* printk(KERN_INFO "block num=%llu\n", leaf_no); */
 		error = -EIO;
+	}
 
 	return error;
 }
@@ -759,7 +761,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 {
 	struct buffer_head *bh;
 	struct gfs2_dirent *dent;
-	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct gfs2_inode *ip = GFS2_I(inode);
 	int error;
 
 	if (ip->i_di.di_flags & GFS2_DIF_EXHASH) {
@@ -771,7 +773,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 			gfs2_consist_inode(ip);
 			return ERR_PTR(-EIO);
 		}
-
+		
 		index = name->hash >> (32 - ip->i_di.di_depth);
 		error = get_first_leaf(ip, index, &bh);
 		if (error)
@@ -786,12 +788,14 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 			brelse(bh);
 			if (!ln)
 				break;
+			
 			error = get_leaf(ip, ln, &bh);
 		} while(!error);
 
 		return error ? ERR_PTR(error) : NULL;
 	}
 
+	
 	error = gfs2_meta_inode_buffer(ip, &bh);
 	if (error)
 		return ERR_PTR(error);
@@ -807,7 +811,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 
 static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)
 {
-	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct gfs2_inode *ip = GFS2_I(inode);
 	u64 bn = gfs2_alloc_meta(ip);
 	struct buffer_head *bh = gfs2_meta_new(ip->i_gl, bn);
 	struct gfs2_leaf *leaf;
@@ -815,6 +819,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct qstr name = { .name = "", .len = 0, .hash = 0 };
 	if (!bh)
 		return NULL;
+	
 	gfs2_trans_add_bh(ip->i_gl, bh, 1);
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	leaf = (struct gfs2_leaf *)bh->b_data;
@@ -838,8 +843,8 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 
 static int dir_make_exhash(struct inode *inode)
 {
-	struct gfs2_inode *dip = inode->u.generic_ip;
-	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct gfs2_inode *dip = GFS2_I(inode);
+	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct gfs2_dirent *dent;
 	struct qstr args;
 	struct buffer_head *bh, *dibh;
@@ -874,7 +879,7 @@ static int dir_make_exhash(struct inode *inode)
 	args.len = bh->b_size - sizeof(struct gfs2_dinode) +
 		   sizeof(struct gfs2_leaf);
 	args.name = bh->b_data;
-	dent = gfs2_dirent_scan(dip->i_vnode, bh->b_data, bh->b_size,
+	dent = gfs2_dirent_scan(&dip->i_inode, bh->b_data, bh->b_size,
 				gfs2_dirent_last, &args, NULL);
 	if (!dent) {
 		brelse(bh);
@@ -933,7 +938,7 @@ static int dir_make_exhash(struct inode *inode)
 
 static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 {
-	struct gfs2_inode *dip = inode->u.generic_ip;
+	struct gfs2_inode *dip = GFS2_I(inode);
 	struct buffer_head *nbh, *obh, *dibh;
 	struct gfs2_leaf *nleaf, *oleaf;
 	struct gfs2_dirent *dent, *prev = NULL, *next = NULL, *new;
@@ -1044,7 +1049,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	oleaf->lf_depth = nleaf->lf_depth;
 
 	error = gfs2_meta_inode_buffer(dip, &dibh);
-	if (!gfs2_assert_withdraw(dip->i_sbd, !error)) {
+	if (!gfs2_assert_withdraw(GFS2_SB(&dip->i_inode), !error)) {
 		dip->i_di.di_blocks++;
 		gfs2_dinode_out(&dip->i_di, dibh->b_data);
 		brelse(dibh);
@@ -1073,7 +1078,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 static int dir_double_exhash(struct gfs2_inode *dip)
 {
-	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct buffer_head *dibh;
 	uint32_t hsize;
 	uint64_t *buf;
@@ -1268,7 +1273,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 			      gfs2_filldir_t filldir, int *copied,
 			      unsigned *depth, u64 leaf_no)
 {
-	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh;
 	struct gfs2_leaf *lf;
 	unsigned entries = 0;
@@ -1348,8 +1353,8 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 static int dir_e_read(struct inode *inode, uint64_t *offset, void *opaque,
 		      gfs2_filldir_t filldir)
 {
-	struct gfs2_inode *dip = inode->u.generic_ip;
-	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct gfs2_inode *dip = GFS2_I(inode);
+	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	uint32_t hsize, len = 0;
 	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
 	uint32_t hash, index;
@@ -1407,7 +1412,7 @@ static int dir_e_read(struct inode *inode, uint64_t *offset, void *opaque,
 int gfs2_dir_read(struct inode *inode, uint64_t *offset, void *opaque,
 		  gfs2_filldir_t filldir)
 {
-	struct gfs2_inode *dip = inode->u.generic_ip;
+	struct gfs2_inode *dip = GFS2_I(inode);
 	struct dirent_gather g;
 	const struct gfs2_dirent **darr, *dent;
 	struct buffer_head *dibh;
@@ -1490,7 +1495,7 @@ int gfs2_dir_search(struct inode *dir, const struct qstr *name,
 static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 {
 	struct buffer_head *bh, *obh;
-	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_leaf *leaf, *oleaf;
 	int error;
 	u32 index;
@@ -1545,7 +1550,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 		 const struct gfs2_inum *inum, unsigned type)
 {
-	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh;
 	struct gfs2_dirent *dent;
 	struct gfs2_leaf *leaf;
@@ -1623,7 +1628,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 
 	/* Returns _either_ the entry (if its first in block) or the
 	   previous entry otherwise */
-	dent = gfs2_dirent_search(dip->i_vnode, name, gfs2_dirent_prev, &bh);
+	dent = gfs2_dirent_search(&dip->i_inode, name, gfs2_dirent_prev, &bh);
 	if (!dent) {
 		gfs2_consist_inode(dip);
 		return -EIO;
@@ -1659,6 +1664,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
 	gfs2_dinode_out(&dip->i_di, bh->b_data);
 	brelse(bh);
+	mark_inode_dirty(&dip->i_inode);
 
 	return error;
 }
@@ -1683,7 +1689,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 	struct gfs2_dirent *dent;
 	int error;
 
-	dent = gfs2_dirent_search(dip->i_vnode, filename, gfs2_dirent_find, &bh);
+	dent = gfs2_dirent_search(&dip->i_inode, filename, gfs2_dirent_find, &bh);
 	if (!dent) {
 		gfs2_consist_inode(dip);
 		return -EIO;
@@ -1720,7 +1726,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 
 static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 {
-	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct buffer_head *bh;
 	struct gfs2_leaf *leaf;
 	uint32_t hsize, len;
@@ -1800,7 +1806,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 			uint64_t leaf_no, void *data)
 {
-	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct gfs2_leaf *tmp_leaf;
 	struct gfs2_rgrp_list rlist;
 	struct buffer_head *bh, *dibh;
@@ -1920,7 +1926,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 
 int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 {
-	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);
 	struct buffer_head *bh;
 	int error;
 

commit 3a8a9a1034813aa99f5ae3150f652d490c5ff10d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu May 18 15:09:15 2006 -0400

    [GFS2] Update copyright date to 2006
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 7f8b27e40916..6918a58261e2 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
- * Copyright (C) 2004-2005 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions

commit fd88de569b802c4a04aaa6ee74667775f4aed8c6
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri May 5 16:59:11 2006 -0400

    [GFS2] Readpages support
    
    This adds readpages support (and also corrects a small bug in
    the readpage error path at the same time). Hopefully this will
    improve performance by allowing GFS to submit larger lumps of
    I/O at a time.
    
    In order to simplify the setting of BH_Boundary, it currently gets
    set when we hit the end of a indirect pointer block. There is
    always a boundary at this point with the current allocation code.
    It doesn't get all the boundaries right though, so there is still
    room for improvement in this.
    
    See comments in fs/gfs2/ops_address.c for further information about
    readpages with GFS2.
    
    Signed-off-by: Steven Whitehouse

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 0404783f39b3..7f8b27e40916 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -197,8 +197,8 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 
 		if (!extlen) {
 			new = 1;
-			error = gfs2_block_map(ip, lblock, &new, &dblock,
-					       &extlen);
+			error = gfs2_extent_map(ip->i_vnode, lblock, &new,
+						&dblock, &extlen);
 			if (error)
 				goto fail;
 			error = -EIO;
@@ -314,8 +314,8 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 
 		if (!extlen) {
 			new = 0;
-			error = gfs2_block_map(ip, lblock, &new, &dblock,
-					       &extlen);
+			error = gfs2_extent_map(ip->i_vnode, lblock, &new,
+						&dblock, &extlen);
 			if (error)
 				goto fail;
 		}

commit 08bc2dbc7327e89b9d5b9c8ef9401d1df2622fca
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Apr 28 10:59:12 2006 -0400

    [GFS2] [-mm patch] fs/gfs2/: possible cleanups
    
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 unused functions
    - remove the following global function that was both unused and
      unimplemented:
      - super.c: gfs2_do_upgrade()
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ffc1beff6703..0404783f39b3 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -669,10 +669,10 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
  * Takes a dent from which to grab space as an argument. Returns the
  * newly created dent.
  */
-struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,
-				     struct gfs2_dirent *dent,
-				     const struct qstr *name,
-				     struct buffer_head *bh)
+static struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,
+					    struct gfs2_dirent *dent,
+					    const struct qstr *name,
+					    struct buffer_head *bh)
 {
 	struct gfs2_inode *ip = inode->u.generic_ip;
 	struct gfs2_dirent *ndent;

commit 61e085a88cb59232eb8ff5b446d70491c7bf2c68
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Apr 24 10:07:13 2006 -0400

    [GFS2] Tidy up dir code as per Christoph Hellwig's comments
    
    1. Comment whitespace fix
    2. Removed unused header files from dir.c
    3. Split the gfs2_dir_get_buffer() function into two functions
    
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index eb68cdd41d48..ffc1beff6703 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -8,61 +8,59 @@
  */
 
 /*
-* Implements Extendible Hashing as described in:
-*   "Extendible Hashing" by Fagin, et al in
-*     __ACM Trans. on Database Systems__, Sept 1979.
-*
-*
-* Here's the layout of dirents which is essentially the same as that of ext2
-* within a single block. The field de_name_len is the number of bytes
-* actually required for the name (no null terminator). The field de_rec_len
-* is the number of bytes allocated to the dirent. The offset of the next
-* dirent in the block is (dirent + dirent->de_rec_len). When a dirent is
-* deleted, the preceding dirent inherits its allocated space, ie
-* prev->de_rec_len += deleted->de_rec_len. Since the next dirent is obtained
-* by adding de_rec_len to the current dirent, this essentially causes the
-* deleted dirent to get jumped over when iterating through all the dirents.
-*
-* When deleting the first dirent in a block, there is no previous dirent so
-* the field de_ino is set to zero to designate it as deleted. When allocating
-* a dirent, gfs2_dirent_alloc iterates through the dirents in a block. If the
-* first dirent has (de_ino == 0) and de_rec_len is large enough, this first
-* dirent is allocated. Otherwise it must go through all the 'used' dirents
-* searching for one in which the amount of total space minus the amount of
-* used space will provide enough space for the new dirent.
-*
-* There are two types of blocks in which dirents reside. In a stuffed dinode,
-* the dirents begin at offset sizeof(struct gfs2_dinode) from the beginning of
-* the block.  In leaves, they begin at offset sizeof(struct gfs2_leaf) from the
-* beginning of the leaf block. The dirents reside in leaves when
-*
-* dip->i_di.di_flags & GFS2_DIF_EXHASH is true
-*
-* Otherwise, the dirents are "linear", within a single stuffed dinode block.
-*
-* When the dirents are in leaves, the actual contents of the directory file are
-* used as an array of 64-bit block pointers pointing to the leaf blocks. The
-* dirents are NOT in the directory file itself. There can be more than one block
-* pointer in the array that points to the same leaf. In fact, when a directory
-* is first converted from linear to exhash, all of the pointers point to the
-* same leaf.
-*
-* When a leaf is completely full, the size of the hash table can be
-* doubled unless it is already at the maximum size which is hard coded into
-* GFS2_DIR_MAX_DEPTH. After that, leaves are chained together in a linked list,
-* but never before the maximum hash table size has been reached.
-*/
+ * Implements Extendible Hashing as described in:
+ *   "Extendible Hashing" by Fagin, et al in
+ *     __ACM Trans. on Database Systems__, Sept 1979.
+ *
+ *
+ * Here's the layout of dirents which is essentially the same as that of ext2
+ * within a single block. The field de_name_len is the number of bytes
+ * actually required for the name (no null terminator). The field de_rec_len
+ * is the number of bytes allocated to the dirent. The offset of the next
+ * dirent in the block is (dirent + dirent->de_rec_len). When a dirent is
+ * deleted, the preceding dirent inherits its allocated space, ie
+ * prev->de_rec_len += deleted->de_rec_len. Since the next dirent is obtained
+ * by adding de_rec_len to the current dirent, this essentially causes the
+ * deleted dirent to get jumped over when iterating through all the dirents.
+ *
+ * When deleting the first dirent in a block, there is no previous dirent so
+ * the field de_ino is set to zero to designate it as deleted. When allocating
+ * a dirent, gfs2_dirent_alloc iterates through the dirents in a block. If the
+ * first dirent has (de_ino == 0) and de_rec_len is large enough, this first
+ * dirent is allocated. Otherwise it must go through all the 'used' dirents
+ * searching for one in which the amount of total space minus the amount of
+ * used space will provide enough space for the new dirent.
+ *
+ * There are two types of blocks in which dirents reside. In a stuffed dinode,
+ * the dirents begin at offset sizeof(struct gfs2_dinode) from the beginning of
+ * the block.  In leaves, they begin at offset sizeof(struct gfs2_leaf) from the
+ * beginning of the leaf block. The dirents reside in leaves when
+ *
+ * dip->i_di.di_flags & GFS2_DIF_EXHASH is true
+ *
+ * Otherwise, the dirents are "linear", within a single stuffed dinode block.
+ *
+ * When the dirents are in leaves, the actual contents of the directory file are
+ * used as an array of 64-bit block pointers pointing to the leaf blocks. The
+ * dirents are NOT in the directory file itself. There can be more than one
+ * block pointer in the array that points to the same leaf. In fact, when a
+ * directory is first converted from linear to exhash, all of the pointers
+ * point to the same leaf.
+ *
+ * When a leaf is completely full, the size of the hash table can be
+ * doubled unless it is already at the maximum size which is hard coded into
+ * GFS2_DIR_MAX_DEPTH. After that, leaves are chained together in a linked list,
+ * but never before the maximum hash table size has been reached.
+ */
 
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
-#include <linux/completion.h>
 #include <linux/buffer_head.h>
 #include <linux/sort.h>
 #include <linux/gfs2_ondisk.h>
 #include <linux/crc32.h>
 #include <linux/vmalloc.h>
-#include <asm/semaphore.h>
 
 #include "gfs2.h"
 #include "lm_interface.h"
@@ -92,33 +90,36 @@ typedef int (*leaf_call_t) (struct gfs2_inode *dip,
 			    uint32_t index, uint32_t len, uint64_t leaf_no,
 			    void *data);
 
-int gfs2_dir_get_buffer(struct gfs2_inode *ip, uint64_t block, int new,
-		         struct buffer_head **bhp)
+
+int gfs2_dir_get_new_buffer(struct gfs2_inode *ip, uint64_t block,
+			    struct buffer_head **bhp)
 {
 	struct buffer_head *bh;
-	int error = 0;
-
-	if (new) {
-		bh = gfs2_meta_new(ip->i_gl, block);
-		gfs2_trans_add_bh(ip->i_gl, bh, 1);
-		gfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);
-		gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
-	} else {
-		error = gfs2_meta_read(ip->i_gl, block, DIO_START | DIO_WAIT,
-				       &bh);
-		if (error)
-			return error;
-		if (gfs2_metatype_check(ip->i_sbd, bh, GFS2_METATYPE_JD)) {
-			brelse(bh);
-			return -EIO;
-		}
-	}
 
+	bh = gfs2_meta_new(ip->i_gl, block);
+	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);
+	gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
 	*bhp = bh;
 	return 0;
 }
 
+static int gfs2_dir_get_existing_buffer(struct gfs2_inode *ip, uint64_t block,
+					struct buffer_head **bhp)
+{
+	struct buffer_head *bh;
+	int error;
 
+	error = gfs2_meta_read(ip->i_gl, block, DIO_START | DIO_WAIT, &bh);
+	if (error)
+		return error;
+	if (gfs2_metatype_check(ip->i_sbd, bh, GFS2_METATYPE_JD)) {
+		brelse(bh);
+		return -EIO;
+	}
+	*bhp = bh;
+	return 0;
+}
 
 static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 				  unsigned int offset, unsigned int size)
@@ -205,9 +206,11 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 				goto fail;
 		}
 
-		error = gfs2_dir_get_buffer(ip, dblock,
-					    (amount == sdp->sd_jbsize) ?
-					    1 : new, &bh);
+		if (amount == sdp->sd_jbsize || new)
+			error = gfs2_dir_get_new_buffer(ip, dblock, &bh);
+		else
+			error = gfs2_dir_get_existing_buffer(ip, dblock, &bh);
+
 		if (error)
 			goto fail;
 
@@ -321,7 +324,10 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 			gfs2_meta_ra(ip->i_gl, dblock, extlen);
 
 		if (dblock) {
-			error = gfs2_dir_get_buffer(ip, dblock, new, &bh);
+			if (new)
+				error = gfs2_dir_get_new_buffer(ip, dblock, &bh);
+			else
+				error = gfs2_dir_get_existing_buffer(ip, dblock, &bh);
 			if (error)
 				goto fail;
 			dblock++;

commit fe1bdedc6c16adedc6fd3636185ea91596b1d6eb
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Apr 18 10:09:15 2006 -0400

    [GFS2] Use vmalloc() in dir code
    
    When allocating memory to sort directory entries, use vmalloc()
    rather than kmalloc() since for larger directories, the required
    size can easily be graeter than the 128k maximum of kmalloc().
    
    Also adding the first steps towards getting the AOP_TRUNCATED_PAGE
    return code get in the glock code by flagging all places where we
    request a glock and we are holding a page lock.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index fe6c5adc5df0..eb68cdd41d48 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -61,6 +61,7 @@
 #include <linux/sort.h>
 #include <linux/gfs2_ondisk.h>
 #include <linux/crc32.h>
+#include <linux/vmalloc.h>
 #include <asm/semaphore.h>
 
 #include "gfs2.h"
@@ -1290,7 +1291,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 		return 0;
 
 	error = -ENOMEM;
-	larr = kmalloc((leaves + entries) * sizeof(void*), GFP_KERNEL);
+	larr = vmalloc((leaves + entries) * sizeof(void*));
 	if (!larr)
 		goto out;
 	darr = (const struct gfs2_dirent **)(larr + leaves);
@@ -1323,7 +1324,7 @@ static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 out_kfree:
 	for(i = 0; i < leaf; i++)
 		brelse(larr[i]);
-	kfree(larr);
+	vfree(larr);
 out:
 	return error;
 }

commit 4d8012b60e0f0e0217e65f67da7d97276d1824e9
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Apr 12 17:39:45 2006 -0400

    [GFS2] Fix bug which was causing postmark to fail
    
    A typo in the directory code was causing postmark to fail
    somewhere in the allocation code, since it was unable to
    find newly allocated directory leaf blocks under certain
    circumstances.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 01f89c727cc8..fe6c5adc5df0 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -1511,7 +1511,7 @@ static int dir_new_leaf(struct inode *inode, const struct qstr *name)
 		brelse(obh);
 		return -ENOSPC;
 	}
-	oleaf->lf_next = cpu_to_be64(bn);
+	oleaf->lf_next = cpu_to_be64(bh->b_blocknr);
 	brelse(bh);
 	brelse(obh);
 
@@ -1950,8 +1950,7 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
  * Returns: 1 if alloc required, 0 if not, -ve on error
  */
 
-int gfs2_diradd_alloc_required(struct inode *inode,
-			       const struct qstr *name)
+int gfs2_diradd_alloc_required(struct inode *inode, const struct qstr *name)
 {
 	struct gfs2_dirent *dent;
 	struct buffer_head *bh;

commit f4154ea039bbf45c52840b30c68143a2dc28d4b4
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Apr 11 14:49:06 2006 -0400

    [GFS2] Update journal accounting code.
    
    A small update to the journaling code to change the way that
    the "extra" blocks are accounted for in the journal. These are
    used at a rate of one per 503 metadata blocks or one per 251
    journaled data blocks (or just one if the total number of journaled
    blocks in the transaction is smaller). Since we are using them at
    two different rates the old method of accounting for them no longer
    works and we count them up as required.
    
    Since the "per transaction" accounting can't handle this (there is no
    fixed number of header blocks per transaction) we have to account for
    it in the general journal code. We now require that each transaction
    reserves more blocks than it actually needs to take account of the
    possible extra blocks.
    
    Also a final fix to dir.c to ensure that all ref counts are handled
    correctly.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 100672d2c6c5..01f89c727cc8 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -776,9 +776,9 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 				goto got_dent;
 			leaf = (struct gfs2_leaf *)bh->b_data;
 			ln = be64_to_cpu(leaf->lf_next);
+			brelse(bh);
 			if (!ln)
 				break;
-			brelse(bh);
 			error = get_leaf(ip, ln, &bh);
 		} while(!error);
 
@@ -790,7 +790,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 		return ERR_PTR(error);
 	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);
 got_dent:
-	if (unlikely(IS_ERR(dent))) {
+	if (unlikely(dent == NULL || IS_ERR(dent))) {
 		brelse(bh);
 		bh = NULL;
 	}
@@ -1477,7 +1477,6 @@ int gfs2_dir_search(struct inode *dir, const struct qstr *name,
 		brelse(bh);
 		return 0;
 	}
-	brelse(bh);
 	return -ENOENT;
 }
 
@@ -1619,7 +1618,6 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 	   previous entry otherwise */
 	dent = gfs2_dirent_search(dip->i_vnode, name, gfs2_dirent_prev, &bh);
 	if (!dent) {
-		brelse(bh);
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1680,7 +1678,6 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 
 	dent = gfs2_dirent_search(dip->i_vnode, filename, gfs2_dirent_find, &bh);
 	if (!dent) {
-		brelse(bh);
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1961,7 +1958,6 @@ int gfs2_diradd_alloc_required(struct inode *inode,
 
 	dent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);
 	if (!dent) {
-		brelse(bh);
 		return 1;
 	}
 	if (IS_ERR(dent))

commit ed3865079b573ef55dc13ab0bfb242ed5ebab4c1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Apr 7 16:28:07 2006 -0400

    [GFS2] Finally get ref counting correct
    
    The last patch missed some other instances of incorrect ref counting,
    this fixes all of those too.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 316eed688f8e..100672d2c6c5 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -776,9 +776,9 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 				goto got_dent;
 			leaf = (struct gfs2_leaf *)bh->b_data;
 			ln = be64_to_cpu(leaf->lf_next);
-			brelse(bh);
 			if (!ln)
 				break;
+			brelse(bh);
 			error = get_leaf(ip, ln, &bh);
 		} while(!error);
 
@@ -789,9 +789,11 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 	if (error)
 		return ERR_PTR(error);
 	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);
-	brelse(bh);
-
 got_dent:
+	if (unlikely(IS_ERR(dent))) {
+		brelse(bh);
+		bh = NULL;
+	}
 	*pbh = bh;
 	return dent;
 }
@@ -1475,6 +1477,7 @@ int gfs2_dir_search(struct inode *dir, const struct qstr *name,
 		brelse(bh);
 		return 0;
 	}
+	brelse(bh);
 	return -ENOENT;
 }
 
@@ -1616,6 +1619,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 	   previous entry otherwise */
 	dent = gfs2_dirent_search(dip->i_vnode, name, gfs2_dirent_prev, &bh);
 	if (!dent) {
+		brelse(bh);
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1636,8 +1640,8 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 		if (!entries)
 			gfs2_consist_inode(dip);
 		leaf->lf_entries = cpu_to_be16(--entries);
-		brelse(bh);
 	}
+	brelse(bh);
 
 	error = gfs2_meta_inode_buffer(dip, &bh);
 	if (error)
@@ -1676,6 +1680,7 @@ int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 
 	dent = gfs2_dirent_search(dip->i_vnode, filename, gfs2_dirent_find, &bh);
 	if (!dent) {
+		brelse(bh);
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -1955,8 +1960,10 @@ int gfs2_diradd_alloc_required(struct inode *inode,
 	struct buffer_head *bh;
 
 	dent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);
-	if (!dent)
+	if (!dent) {
+		brelse(bh);
 		return 1;
+	}
 	if (IS_ERR(dent))
 		return PTR_ERR(dent);
 	brelse(bh);

commit b09e593d799560f1a0782c20ac5900058390a26f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Apr 7 11:17:32 2006 -0400

    [GFS2] Fix a ref count bug and other clean ups
    
    This fixes a ref count bug that sometimes showed up a umount time
    (causing it to hang) but it otherwise mostly harmless. At the same
    time there are some clean ups including making the log operations
    structures const, moving a memory allocation so that its not done
    in the fast path of checking to see if there is an outstanding
    transaction related to a particular glock.
    
    Removes the sd_log_wrap varaible which was updated, but never actually
    used anywhere. Updates the gfs2 ioctl() to run without the kernel lock
    (which it never needed anyway). Removes the "invalidate inodes" loop
    from GFS2's put_super routine. This is done in kill super anyway so
    we don't need to do it here. The loop was also bogus in that if there
    are any inodes "stuck" at this point its a bug and we need to know
    about it rather than hide it by hanging forever.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 66917f2c64aa..316eed688f8e 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -789,6 +789,8 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 	if (error)
 		return ERR_PTR(error);
 	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);
+	brelse(bh);
+
 got_dent:
 	*pbh = bh;
 	return dent;

commit e3167ded1f1b16424bc14d5673cdc5414f179970
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Mar 30 15:46:23 2006 -0500

    [GFS] Fix bug in endian conversion for metadata header
    
    In some cases 16 bit functions were being used rather than 32 bit
    functions.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 9f17e7d05af1..66917f2c64aa 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -462,7 +462,7 @@ static int gfs2_dirent_offset(const void *buf)
 
 	BUG_ON(buf == NULL);
 
-	switch(be16_to_cpu(h->mh_type)) {
+	switch(be32_to_cpu(h->mh_type)) {
 	case GFS2_METATYPE_LF:
 		offset = sizeof(struct gfs2_leaf);
 		break;
@@ -475,7 +475,7 @@ static int gfs2_dirent_offset(const void *buf)
 	return offset;
 wrong_type:
 	printk(KERN_WARNING "gfs2_scan_dirent: wrong block type %u\n",
-	       be16_to_cpu(h->mh_type));
+	       be32_to_cpu(h->mh_type));
 	return -1;
 }
 
@@ -548,7 +548,7 @@ static int dirent_first(struct gfs2_inode *dip, struct buffer_head *bh,
 {
 	struct gfs2_meta_header *h = (struct gfs2_meta_header *)bh->b_data;
 
-	if (be16_to_cpu(h->mh_type) == GFS2_METATYPE_LF) {
+	if (be32_to_cpu(h->mh_type) == GFS2_METATYPE_LF) {
 		if (gfs2_meta_check(dip->i_sbd, bh))
 			return -EIO;
 		*dent = (struct gfs2_dirent *)(bh->b_data +

commit e90deff5336ac500c65f873484c326cfa8a9d379
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Mar 29 19:02:15 2006 -0500

    [GFS2] Fix bug in directory expansion code
    
    We didn't properly check that leaf splitting was allowed. We do
    now.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ba3438553f33..9f17e7d05af1 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -940,10 +940,15 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	/*  Get the old leaf block  */
 	error = get_leaf(dip, leaf_no, &obh);
 	if (error)
-		goto fail;
+		return error;
 
-	gfs2_trans_add_bh(dip->i_gl, obh, 1);
 	oleaf = (struct gfs2_leaf *)obh->b_data;
+	if (dip->i_di.di_depth == be16_to_cpu(oleaf->lf_depth)) {
+		brelse(obh);
+		return 1; /* can't split */
+	}
+
+	gfs2_trans_add_bh(dip->i_gl, obh, 1);
 
 	nleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);
 	if (!nleaf) {
@@ -956,6 +961,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 	len = 1 << (dip->i_di.di_depth - be16_to_cpu(oleaf->lf_depth));
 	half_len = len >> 1;
 	if (!half_len) {
+		printk(KERN_WARNING "di_depth %u lf_depth %u index %u\n", dip->i_di.di_depth, be16_to_cpu(oleaf->lf_depth), index);
 		gfs2_consist_inode(dip);
 		error = -EIO;
 		goto fail_brelse;
@@ -1038,13 +1044,11 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 
 	return error;
 
- fail_lpfree:
+fail_lpfree:
 	kfree(lp);
 
- fail_brelse:
+fail_brelse:
 	brelse(obh);
-
- fail:
 	brelse(nbh);
 	return error;
 }
@@ -1570,16 +1574,17 @@ int gfs2_dir_add(struct inode *inode, const struct qstr *name,
 		error = dir_split_leaf(inode, name);
 		if (error == 0)
 			continue;
-		if (error != -ENOSPC)
+		if (error < 0)
 			break;
 		if (ip->i_di.di_depth < GFS2_DIR_MAX_DEPTH) {
 			error = dir_double_exhash(ip);
 			if (error)
 				break;
 			error = dir_split_leaf(inode, name);
-			if (error)
+			if (error < 0)
 				break;
-			continue;
+			if (error == 0)
+				continue;
 		}
 		error = dir_new_leaf(inode, name);
 		if (!error)

commit 71b86f562b5eb6f94ea00bba060caa64d0137969
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Mar 28 14:14:04 2006 -0500

    [GFS2] Further updates to dir and logging code
    
    This reduces the size of the directory code by about 3k and gets
    readdir() to use the functions which were introduced in the previous
    directory code update.
    
    Two memory allocations are merged into one. Eliminates zeroing of some
    buffers which were never used before they were initialised by
    other data.
    
    There is still scope for further improvement in the directory code.
    
    On the logging side, a hand created mutex has been replaced by a
    standard Linux mutex in the log allocation code.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f31f163da1a1..ba3438553f33 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -60,6 +60,7 @@
 #include <linux/buffer_head.h>
 #include <linux/sort.h>
 #include <linux/gfs2_ondisk.h>
+#include <linux/crc32.h>
 #include <asm/semaphore.h>
 
 #include "gfs2.h"
@@ -344,7 +345,8 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 }
 
 typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
-			    const struct qstr *name);
+			    const struct qstr *name,
+			    void *opaque);
 
 static inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,
 				     const struct qstr *name, int ret)
@@ -358,13 +360,15 @@ static inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,
 }
 
 static int gfs2_dirent_find(const struct gfs2_dirent *dent,
-			    const struct qstr *name)
+			    const struct qstr *name,
+			    void *opaque)
 {
 	return __gfs2_dirent_find(dent, name, 1);
 }
 
 static int gfs2_dirent_prev(const struct gfs2_dirent *dent,
-			    const struct qstr *name)
+			    const struct qstr *name,
+			    void *opaque)
 {
 	return __gfs2_dirent_find(dent, name, 2);
 }
@@ -374,7 +378,8 @@ static int gfs2_dirent_prev(const struct gfs2_dirent *dent,
  * name->len holds size of block.
  */
 static int gfs2_dirent_last(const struct gfs2_dirent *dent,
-			    const struct qstr *name)
+			    const struct qstr *name,
+			    void *opaque)
 {
 	const char *start = name->name;
 	const char *end = (const char *)dent + be16_to_cpu(dent->de_rec_len);
@@ -384,17 +389,36 @@ static int gfs2_dirent_last(const struct gfs2_dirent *dent,
 }
 
 static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,
-				  const struct qstr *name)
+				  const struct qstr *name,
+				  void *opaque)
 {
 	unsigned required = GFS2_DIRENT_SIZE(name->len);
 	unsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
 	unsigned totlen = be16_to_cpu(dent->de_rec_len);
 
+	if (!dent->de_inum.no_addr)
+		actual = GFS2_DIRENT_SIZE(0);
 	if ((totlen - actual) >= required)
 		return 1;
 	return 0;
 }
 
+struct dirent_gather {
+	const struct gfs2_dirent **pdent;
+	unsigned offset;
+};
+
+static int gfs2_dirent_gather(const struct gfs2_dirent *dent,
+			      const struct qstr *name,
+			      void *opaque)
+{
+	struct dirent_gather *g = opaque;
+	if (dent->de_inum.no_addr) {
+		g->pdent[g->offset++] = dent;
+	}
+	return 0;
+}
+
 /*
  * Other possible things to check:
  * - Inode located within filesystem size (and on valid block)
@@ -431,19 +455,12 @@ static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,
 	return -EIO;
 }
 
-static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
-					    void *buf,
-					    unsigned int len, gfs2_dscan_t scan,
-					    const struct qstr *name)
+static int gfs2_dirent_offset(const void *buf)
 {
-	struct gfs2_meta_header *h = buf;
-	struct gfs2_dirent *dent, *prev;
-	unsigned offset;
-	unsigned size;
-	int ret = 0;
+	const struct gfs2_meta_header *h = buf;
+	int offset;
 
 	BUG_ON(buf == NULL);
-	BUG_ON(name == NULL);
 
 	switch(be16_to_cpu(h->mh_type)) {
 	case GFS2_METATYPE_LF:
@@ -455,14 +472,36 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
 	default:
 		goto wrong_type;
 	}
+	return offset;
+wrong_type:
+	printk(KERN_WARNING "gfs2_scan_dirent: wrong block type %u\n",
+	       be16_to_cpu(h->mh_type));
+	return -1;
+}
 
+static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
+					    void *buf,
+					    unsigned int len, gfs2_dscan_t scan,
+					    const struct qstr *name,
+					    void *opaque)
+{
+	struct gfs2_dirent *dent, *prev;
+	unsigned offset;
+	unsigned size;
+	int ret = 0;
+
+	ret = gfs2_dirent_offset(buf);
+	if (ret < 0)
+		goto consist_inode;
+
+	offset = ret;
 	prev = NULL;
 	dent = (struct gfs2_dirent *)(buf + offset);
 	size = be16_to_cpu(dent->de_rec_len);
 	if (gfs2_check_dirent(dent, offset, size, len, 1))
 		goto consist_inode;
 	do {
-		ret = scan(dent, name);
+		ret = scan(dent, name, opaque);
 		if (ret)
 			break;
 		offset += size;
@@ -487,9 +526,6 @@ static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
 		return ERR_PTR(ret);
 	}
 
-wrong_type:
-	printk(KERN_WARNING "gfs2_scan_dirent: %p wrong block type %u\n", scan,
-	       be16_to_cpu(h->mh_type));
 consist_inode:
 	gfs2_consist_inode(inode->u.generic_ip);
 	return ERR_PTR(-EIO);
@@ -651,7 +687,8 @@ static struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,
 					     const struct qstr *name)
 {
 	struct gfs2_dirent *dent;
-	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, gfs2_dirent_find_space, name);
+	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, 
+				gfs2_dirent_find_space, name, NULL);
 	if (!dent || IS_ERR(dent))
 		return dent;
 	return gfs2_init_dirent(inode, dent, name, bh);
@@ -734,7 +771,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 			return ERR_PTR(error);
 		do {
 			dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,
-						scan, name);
+						scan, name, NULL);
 			if (dent)
 				goto got_dent;
 			leaf = (struct gfs2_leaf *)bh->b_data;
@@ -751,7 +788,7 @@ static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
 	error = gfs2_meta_inode_buffer(ip, &bh);
 	if (error)
 		return ERR_PTR(error);
-	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name);
+	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name, NULL);
 got_dent:
 	*pbh = bh;
 	return dent;
@@ -764,6 +801,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	struct buffer_head *bh = gfs2_meta_new(ip->i_gl, bn);
 	struct gfs2_leaf *leaf;
 	struct gfs2_dirent *dent;
+	struct qstr name = { .name = "", .len = 0, .hash = 0 };
 	if (!bh)
 		return NULL;
 	gfs2_trans_add_bh(ip->i_gl, bh, 1);
@@ -775,12 +813,7 @@ static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh,
 	leaf->lf_next = cpu_to_be64(0);
 	memset(leaf->lf_reserved, 0, sizeof(leaf->lf_reserved));
 	dent = (struct gfs2_dirent *)(leaf+1);
-	dent->de_inum.no_formal_ino = cpu_to_be64(0);
-	dent->de_inum.no_addr = cpu_to_be64(0);
-	dent->de_hash = cpu_to_be32(0);
-	dent->de_rec_len = cpu_to_be16(bh->b_size - sizeof(struct gfs2_leaf));
-	dent->de_name_len = cpu_to_be16(0);
-	dent->de_type = cpu_to_be16(0);
+	gfs2_qstr2dirent(&name, bh->b_size - sizeof(struct gfs2_leaf), dent);
 	*pbh = bh;
 	return leaf;
 }
@@ -831,7 +864,7 @@ static int dir_make_exhash(struct inode *inode)
 		   sizeof(struct gfs2_leaf);
 	args.name = bh->b_data;
 	dent = gfs2_dirent_scan(dip->i_vnode, bh->b_data, bh->b_size,
-				gfs2_dirent_last, &args);
+				gfs2_dirent_last, &args, NULL);
 	if (!dent) {
 		brelse(bh);
 		brelse(dibh);
@@ -939,7 +972,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 		lp[x] = cpu_to_be64(bn);
 
 	error = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(uint64_t),
-				     half_len * sizeof(uint64_t));
+				    half_len * sizeof(uint64_t));
 	if (error != half_len * sizeof(uint64_t)) {
 		if (error >= 0)
 			error = -EIO;
@@ -965,7 +998,7 @@ static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 			str.name = (char*)(dent+1);
 			str.len = be16_to_cpu(dent->de_name_len);
 			str.hash = be32_to_cpu(dent->de_hash);
-			new = gfs2_dirent_alloc(dip->i_vnode, nbh, &str);
+			new = gfs2_dirent_alloc(inode, nbh, &str);
 			if (IS_ERR(new)) {
 				error = PTR_ERR(new);
 				break;
@@ -1154,10 +1187,10 @@ static int compare_dents(const void *a, const void *b)
 
 static int do_filldir_main(struct gfs2_inode *dip, uint64_t *offset,
 			   void *opaque, gfs2_filldir_t filldir,
-			   struct gfs2_dirent **darr, uint32_t entries,
+			   const struct gfs2_dirent **darr, uint32_t entries,
 			   int *copied)
 {
-	struct gfs2_dirent *dent, *dent_next;
+	const struct gfs2_dirent *dent, *dent_next;
 	struct gfs2_inum inum;
 	uint64_t off, off_next;
 	unsigned int x, y;
@@ -1216,189 +1249,74 @@ static int do_filldir_main(struct gfs2_inode *dip, uint64_t *offset,
 	return 0;
 }
 
-/**
- * do_filldir_single - Read directory entries out of a single block
- * @dip: The GFS2 inode
- * @offset: The offset in the file to read from
- * @opaque: opaque data to pass to filldir
- * @filldir: The function to pass entries to
- * @bh: the block
- * @entries: the number of entries in the block
- * @copied: pointer to int that's non-zero if a entry has been copied out
- *
- * Returns: errno, >0 on exception from filldir
- */
-
-static int do_filldir_single(struct gfs2_inode *dip, uint64_t *offset,
-			     void *opaque, gfs2_filldir_t filldir,
-			     struct buffer_head *bh, uint32_t entries,
-			     int *copied)
+static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
+			      gfs2_filldir_t filldir, int *copied,
+			      unsigned *depth, u64 leaf_no)
 {
-	struct gfs2_dirent **darr;
-	struct gfs2_dirent *de;
-	unsigned int e = 0;
-	int error;
-
-	if (!entries)
-		return 0;
-
-	darr = kcalloc(entries, sizeof(struct gfs2_dirent *), GFP_KERNEL);
-	if (!darr)
-		return -ENOMEM;
+	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct buffer_head *bh;
+	struct gfs2_leaf *lf;
+	unsigned entries = 0;
+	unsigned leaves = 0;
+	const struct gfs2_dirent **darr, *dent;
+	struct dirent_gather g;
+	struct buffer_head **larr;
+	int leaf = 0;
+	int error, i;
+	u64 lfn = leaf_no;
 
-	dirent_first(dip, bh, &de);
 	do {
-		if (!de->de_inum.no_addr)
-			continue;
-		if (e >= entries) {
-			gfs2_consist_inode(dip);
-			error = -EIO;
-			goto out;
-		}
-		darr[e++] = de;
-	} while (dirent_next(dip, bh, &de) == 0);
-
-	if (e != entries) {
-		gfs2_consist_inode(dip);
-		error = -EIO;
-		goto out;
-	}
-
-	error = do_filldir_main(dip, offset, opaque, filldir, darr,
-				entries, copied);
-
- out:
-	kfree(darr);
-
-	return error;
-}
-
-/**
- * do_filldir_multi - Read directory entries out of a linked leaf list
- * @dip: The GFS2 inode
- * @offset: The offset in the file to read from
- * @opaque: opaque data to pass to filldir
- * @filldir: The function to pass entries to
- * @bh: the first leaf in the list
- * @copied: pointer to int that's non-zero if a entry has been copied out
- *
- * Returns: errno, >0 on exception from filldir
- */
-
-static int do_filldir_multi(struct gfs2_inode *dip, uint64_t *offset,
-			    void *opaque, gfs2_filldir_t filldir,
-			    struct buffer_head *bh, int *copied)
-{
-	struct buffer_head **larr = NULL;
-	struct gfs2_dirent **darr;
-	struct gfs2_leaf *leaf;
-	struct buffer_head *tmp_bh;
-	struct gfs2_dirent *de;
-	unsigned int entries, e = 0;
-	unsigned int leaves = 0, l = 0;
-	unsigned int x;
-	uint64_t ln;
-	int error = 0;
-
-	/*  Count leaves and entries  */
-
-	leaf = (struct gfs2_leaf *)bh->b_data;
-	entries = be16_to_cpu(leaf->lf_entries);
-	ln = be64_to_cpu(leaf->lf_next);
-
-	while (ln) {
-		error = get_leaf(dip, ln, &tmp_bh);
+		error = get_leaf(ip, lfn, &bh);
 		if (error)
-			return error;
-
-		leaf = (struct gfs2_leaf *)tmp_bh->b_data;
-		if (leaf->lf_entries) {
-			entries += be16_to_cpu(leaf->lf_entries);
-			leaves++;
-		}
-		ln = be64_to_cpu(leaf->lf_next);
-
-		brelse(tmp_bh);
-	}
+			goto out;
+		lf = (struct gfs2_leaf *)bh->b_data;
+		if (leaves == 0)
+			*depth = be16_to_cpu(lf->lf_depth);
+		entries += be16_to_cpu(lf->lf_entries);
+		leaves++;
+		lfn = be64_to_cpu(lf->lf_next);
+		brelse(bh);
+	} while(lfn);
 
 	if (!entries)
 		return 0;
 
-	if (leaves) {
-		larr = kcalloc(leaves, sizeof(struct buffer_head *),GFP_KERNEL);
-		if (!larr)
-			return -ENOMEM;
-	}
-
-	darr = kcalloc(entries, sizeof(struct gfs2_dirent *), GFP_KERNEL);
-	if (!darr) {
-		kfree(larr);
-		return -ENOMEM;
-	}
-
-	leaf = (struct gfs2_leaf *)bh->b_data;
-	if (leaf->lf_entries) {
-		dirent_first(dip, bh, &de);
-		do {
-			if (!de->de_inum.no_addr)
-				continue;
-			if (e >= entries) {
-				gfs2_consist_inode(dip);
-				error = -EIO;
-				goto out;
-			}
-			darr[e++] = de;
-		} while (dirent_next(dip, bh, &de) == 0);
-	}
-	ln = be64_to_cpu(leaf->lf_next);
+	error = -ENOMEM;
+	larr = kmalloc((leaves + entries) * sizeof(void*), GFP_KERNEL);
+	if (!larr)
+		goto out;
+	darr = (const struct gfs2_dirent **)(larr + leaves);
+	g.pdent = darr;
+	g.offset = 0;
+	lfn = leaf_no;
 
-	while (ln) {
-		error = get_leaf(dip, ln, &tmp_bh);
+	do {
+		error = get_leaf(ip, lfn, &bh);
 		if (error)
-			goto out;
-
-		leaf = (struct gfs2_leaf *)tmp_bh->b_data;
-		if (leaf->lf_entries) {
-			dirent_first(dip, tmp_bh, &de);
-			do {
-				if (!de->de_inum.no_addr)
-					continue;
-				if (e >= entries) {
-					gfs2_consist_inode(dip);
-					error = -EIO;
-					goto out;
-				}
-				darr[e++] = de;
-			} while (dirent_next(dip, tmp_bh, &de) == 0);
-
-			larr[l++] = tmp_bh;
-
-			ln = be64_to_cpu(leaf->lf_next);
+			goto out_kfree;
+		lf = (struct gfs2_leaf *)bh->b_data;
+		lfn = be64_to_cpu(lf->lf_next);
+		if (lf->lf_entries) {
+			dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,
+						gfs2_dirent_gather, NULL, &g);
+			error = PTR_ERR(dent);
+			if (IS_ERR(dent)) {
+				goto out_kfree;
+			}
+			error = 0;
+			larr[leaf++] = bh;
 		} else {
-			ln = be64_to_cpu(leaf->lf_next);
-			brelse(tmp_bh);
+			brelse(bh);
 		}
-	}
+	} while(lfn);
 
-	if (gfs2_assert_withdraw(dip->i_sbd, l == leaves)) {
-		error = -EIO;
-		goto out;
-	}
-	if (e != entries) {
-		gfs2_consist_inode(dip);
-		error = -EIO;
-		goto out;
-	}
-
-	error = do_filldir_main(dip, offset, opaque, filldir, darr,
+	error = do_filldir_main(ip, offset, opaque, filldir, darr,
 				entries, copied);
-
- out:
-	kfree(darr);
-	for (x = 0; x < l; x++)
-		brelse(larr[x]);
+out_kfree:
+	for(i = 0; i < leaf; i++)
+		brelse(larr[i]);
 	kfree(larr);
-
+out:
 	return error;
 }
 
@@ -1412,18 +1330,18 @@ static int do_filldir_multi(struct gfs2_inode *dip, uint64_t *offset,
  * Returns: errno
  */
 
-static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
+static int dir_e_read(struct inode *inode, uint64_t *offset, void *opaque,
 		      gfs2_filldir_t filldir)
 {
+	struct gfs2_inode *dip = inode->u.generic_ip;
 	struct gfs2_sbd *sdp = dip->i_sbd;
-	struct buffer_head *bh;
-	struct gfs2_leaf *leaf;
-	uint32_t hsize, len;
+	uint32_t hsize, len = 0;
 	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
 	uint32_t hash, index;
 	uint64_t *lp;
 	int copied = 0;
 	int error = 0;
+	unsigned depth;
 
 	hsize = 1 << dip->i_di.di_depth;
 	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
@@ -1454,61 +1372,66 @@ static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
 			ht_offset_cur = ht_offset;
 		}
 
-		error = get_leaf(dip, be64_to_cpu(lp[lp_offset]), &bh);
+		error = gfs2_dir_read_leaf(inode, offset, opaque, filldir,
+					   &copied, &depth,
+					   be64_to_cpu(lp[lp_offset]));
 		if (error)
-			goto out;
-
-		leaf = (struct gfs2_leaf *)bh->b_data;
-		if (leaf->lf_next)
-			error = do_filldir_multi(dip, offset, opaque, filldir,
-						 bh, &copied);
-		else
-			error = do_filldir_single(dip, offset, opaque, filldir,
-						  bh, 
-						  be16_to_cpu(leaf->lf_entries),
-						  &copied);
-
-		brelse(bh);
-
-		if (error) {
-			if (error > 0)
-				error = 0;
-			goto out;
-		}
+			break;
 
-		len = 1 << (dip->i_di.di_depth - be16_to_cpu(leaf->lf_depth));
+		len = 1 << (dip->i_di.di_depth - depth);
 		index = (index & ~(len - 1)) + len;
 	}
 
- out:
+out:
 	kfree(lp);
-
+	if (error > 0)
+		error = 0;
 	return error;
 }
 
-static int dir_l_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
-		      gfs2_filldir_t filldir)
+int gfs2_dir_read(struct inode *inode, uint64_t *offset, void *opaque,
+		  gfs2_filldir_t filldir)
 {
+	struct gfs2_inode *dip = inode->u.generic_ip;
+	struct dirent_gather g;
+	const struct gfs2_dirent **darr, *dent;
 	struct buffer_head *dibh;
 	int copied = 0;
 	int error;
 
+	if (!dip->i_di.di_entries)
+		return 0;
+
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
+		return dir_e_read(inode, offset, opaque, filldir);
+
 	if (!gfs2_is_stuffed(dip)) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
 
-	if (!dip->i_di.di_entries)
-		return 0;
-
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (error)
 		return error;
 
-	error = do_filldir_single(dip, offset,
-				  opaque, filldir,
-				  dibh, dip->i_di.di_entries,
-				  &copied);
+	error = -ENOMEM;
+	darr = kmalloc(dip->i_di.di_entries * sizeof(struct gfs2_dirent *),
+		       GFP_KERNEL);
+	if (darr) {
+		g.pdent = darr;
+		g.offset = 0;
+		dent = gfs2_dirent_scan(inode, dibh->b_data, dibh->b_size,
+					gfs2_dirent_gather, NULL, &g);
+		if (IS_ERR(dent)) {
+			error = PTR_ERR(dent);
+			goto out;
+		}
+		error = do_filldir_main(dip, offset, opaque, filldir, darr,
+					dip->i_di.di_entries, &copied);
+out:
+		kfree(darr);
+	}
+
 	if (error > 0)
 		error = 0;
 
@@ -1694,7 +1617,7 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 		return PTR_ERR(dent);
 	}
 	/* If not first in block, adjust pointers accordingly */
-	if (gfs2_dirent_find(dent, name) == 0) {
+	if (gfs2_dirent_find(dent, name, NULL) == 0) {
 		prev = dent;
 		dent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));
 	}
@@ -1724,19 +1647,6 @@ int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 	return error;
 }
 
-int gfs2_dir_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
-		  gfs2_filldir_t filldir)
-{
-	int error;
-
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
-		error = dir_e_read(dip, offset, opaque, filldir);
-	else
-		error = dir_l_read(dip, offset, opaque, filldir);
-
-	return error;
-}
-
 /**
  * gfs2_dir_mvino - Change inode number of directory entry
  * @dip: The GFS2 inode

commit c752666c17f870fa8ae9f16804dd457e9e6daaec
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Mar 20 12:30:04 2006 -0500

    [GFS2] Fix bug in directory code and tidy up
    
    Due to a typo, the dir leaf split operation was (for the first
    split in a directory) writing the new hash vaules at the
    wrong offset. This is now fixed.
    
    Also some other tidy ups are included:
    
     - We use GFS2's hash function for dentries (see ops_dentry.c) so that
       we don't have to keep recalculating the hash values.
     - A lot of common code is eliminated between the various directory
       lookup routines.
     - Better error checking on directory lookup (previously different
       routines checked for different errors)
     - The leaf split operation has a couple of redundant operations
       removed from it, so it should be faster.
    
    There is still further scope for further clean ups in the directory
    code, and readdir in particular could do with slimming down a bit.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 37f70ca558cc..f31f163da1a1 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -130,7 +130,7 @@ static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
 		return error;
 
 	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
-	memcpy(dibh->b_data + offset + sizeof(struct gfs2_inode), buf, size);
+	memcpy(dibh->b_data + offset + sizeof(struct gfs2_dinode), buf, size);
 	if (ip->i_di.di_size < offset + size)
 		ip->i_di.di_size = offset + size;
 	ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
@@ -177,7 +177,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 	if (gfs2_is_stuffed(ip)) {
 		error = gfs2_unstuff_dinode(ip, NULL, NULL);
 		if (error)
-		return error;
+			return error;
 	}
 
 	lblock = offset;
@@ -244,7 +244,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 }
 
 static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, char *buf,
-				unsigned int offset, unsigned int size)
+				 unsigned int offset, unsigned int size)
 {
 	struct buffer_head *dibh;
 	int error;
@@ -343,26 +343,159 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 	return (copied) ? copied : error;
 }
 
-/**
- * int gfs2_filecmp - Compare two filenames
- * @file1: The first filename
- * @file2: The second filename
- * @len_of_file2: The length of the second file
- *
- * This routine compares two filenames and returns 1 if they are equal.
- *
- * Returns: 1 if the files are the same, otherwise 0.
+typedef int (*gfs2_dscan_t)(const struct gfs2_dirent *dent,
+			    const struct qstr *name);
+
+static inline int __gfs2_dirent_find(const struct gfs2_dirent *dent,
+				     const struct qstr *name, int ret)
+{
+	if (dent->de_inum.no_addr != 0 &&
+	    be32_to_cpu(dent->de_hash) == name->hash &&
+	    be16_to_cpu(dent->de_name_len) == name->len &&
+	    memcmp((char *)(dent+1), name->name, name->len) == 0)
+		return ret;
+	return 0;
+}
+
+static int gfs2_dirent_find(const struct gfs2_dirent *dent,
+			    const struct qstr *name)
+{
+	return __gfs2_dirent_find(dent, name, 1);
+}
+
+static int gfs2_dirent_prev(const struct gfs2_dirent *dent,
+			    const struct qstr *name)
+{
+	return __gfs2_dirent_find(dent, name, 2);
+}
+
+/*
+ * name->name holds ptr to start of block.
+ * name->len holds size of block.
  */
+static int gfs2_dirent_last(const struct gfs2_dirent *dent,
+			    const struct qstr *name)
+{
+	const char *start = name->name;
+	const char *end = (const char *)dent + be16_to_cpu(dent->de_rec_len);
+	if (name->len == (end - start))
+		return 1;
+	return 0;
+}
 
-int gfs2_filecmp(struct qstr *file1, char *file2, int len_of_file2)
+static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,
+				  const struct qstr *name)
 {
-	if (file1->len != len_of_file2)
-		return 0;
-	if (memcmp(file1->name, file2, file1->len))
-		return 0;
-	return 1;
+	unsigned required = GFS2_DIRENT_SIZE(name->len);
+	unsigned actual = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
+	unsigned totlen = be16_to_cpu(dent->de_rec_len);
+
+	if ((totlen - actual) >= required)
+		return 1;
+	return 0;
+}
+
+/*
+ * Other possible things to check:
+ * - Inode located within filesystem size (and on valid block)
+ * - Valid directory entry type
+ * Not sure how heavy-weight we want to make this... could also check
+ * hash is correct for example, but that would take a lot of extra time.
+ * For now the most important thing is to check that the various sizes
+ * are correct.
+ */
+static int gfs2_check_dirent(struct gfs2_dirent *dent, unsigned int offset,
+			     unsigned int size, unsigned int len, int first)
+{
+	const char *msg = "gfs2_dirent too small";
+	if (unlikely(size < sizeof(struct gfs2_dirent)))
+		goto error;
+	msg = "gfs2_dirent misaligned";
+	if (unlikely(offset & 0x7))
+		goto error;
+	msg = "gfs2_dirent points beyond end of block";
+	if (unlikely(offset + size > len))
+		goto error;
+	msg = "zero inode number";
+	if (unlikely(!first && !dent->de_inum.no_addr))
+		goto error;
+	msg = "name length is greater than space in dirent";
+	if (dent->de_inum.no_addr &&
+	    unlikely(sizeof(struct gfs2_dirent)+be16_to_cpu(dent->de_name_len) >
+		     size))
+		goto error;
+	return 0;
+error:
+	printk(KERN_WARNING "gfs2_check_dirent: %s (%s)\n", msg,
+	       first ? "first in block" : "not first in block");
+	return -EIO;
 }
 
+static struct gfs2_dirent *gfs2_dirent_scan(struct inode *inode,
+					    void *buf,
+					    unsigned int len, gfs2_dscan_t scan,
+					    const struct qstr *name)
+{
+	struct gfs2_meta_header *h = buf;
+	struct gfs2_dirent *dent, *prev;
+	unsigned offset;
+	unsigned size;
+	int ret = 0;
+
+	BUG_ON(buf == NULL);
+	BUG_ON(name == NULL);
+
+	switch(be16_to_cpu(h->mh_type)) {
+	case GFS2_METATYPE_LF:
+		offset = sizeof(struct gfs2_leaf);
+		break;
+	case GFS2_METATYPE_DI:
+		offset = sizeof(struct gfs2_dinode);
+		break;
+	default:
+		goto wrong_type;
+	}
+
+	prev = NULL;
+	dent = (struct gfs2_dirent *)(buf + offset);
+	size = be16_to_cpu(dent->de_rec_len);
+	if (gfs2_check_dirent(dent, offset, size, len, 1))
+		goto consist_inode;
+	do {
+		ret = scan(dent, name);
+		if (ret)
+			break;
+		offset += size;
+		if (offset == len)
+			break;
+		prev = dent;
+		dent = (struct gfs2_dirent *)(buf + offset);
+		size = be16_to_cpu(dent->de_rec_len);
+		if (gfs2_check_dirent(dent, offset, size, len, 0))
+			goto consist_inode;
+	} while(1);
+
+	switch(ret) {
+	case 0:
+		return NULL;
+	case 1:
+		return dent;
+	case 2:
+		return prev ? prev : dent;
+	default:
+		BUG_ON(ret > 0);
+		return ERR_PTR(ret);
+	}
+
+wrong_type:
+	printk(KERN_WARNING "gfs2_scan_dirent: %p wrong block type %u\n", scan,
+	       be16_to_cpu(h->mh_type));
+consist_inode:
+	gfs2_consist_inode(inode->u.generic_ip);
+	return ERR_PTR(-EIO);
+}
+
+
 /**
  * dirent_first - Return the first dirent
  * @dip: the directory
@@ -489,180 +622,39 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 	prev->de_rec_len = cpu_to_be16(prev_rec_len);
 }
 
-/**
- * gfs2_dirent_alloc - Allocate a directory entry
- * @dip: The GFS2 inode
- * @bh: The buffer
- * @name_len: The length of the name
- * @dent_out: Pointer to list of dirents
- *
- * Returns: 0 on success, error code otherwise
+/*
+ * Takes a dent from which to grab space as an argument. Returns the
+ * newly created dent.
  */
-
-int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
-		      int name_len, struct gfs2_dirent **dent_out)
+struct gfs2_dirent *gfs2_init_dirent(struct inode *inode,
+				     struct gfs2_dirent *dent,
+				     const struct qstr *name,
+				     struct buffer_head *bh)
 {
-	struct gfs2_dirent *dent, *new;
-	unsigned int rec_len = GFS2_DIRENT_SIZE(name_len);
-	unsigned int entries = 0, offset = 0;
-	int type;
-
-	type = dirent_first(dip, bh, &dent);
-	if (type < 0)
-		return type;
-
-	if (type == IS_LEAF) {
-		struct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;
-		entries = be16_to_cpu(leaf->lf_entries);
-		offset = sizeof(struct gfs2_leaf);
-	} else {
-		struct gfs2_dinode *dinode = (struct gfs2_dinode *)bh->b_data;
-		entries = be32_to_cpu(dinode->di_entries);
-		offset = sizeof(struct gfs2_dinode);
-	}
-
-	if (!entries) {
-		if (dent->de_inum.no_addr) {
-			gfs2_consist_inode(dip);
-			return -EIO;
-		}
-
-		gfs2_trans_add_bh(dip->i_gl, bh, 1);
-
-		dent->de_rec_len = cpu_to_be16(bh->b_size - offset);
-		dent->de_name_len = cpu_to_be16(name_len);
-
-		*dent_out = dent;
-		return 0;
-	}
-
-	do {
-		uint16_t cur_rec_len;
-		uint16_t cur_name_len;
-
-		cur_rec_len = be16_to_cpu(dent->de_rec_len);
-		cur_name_len = be16_to_cpu(dent->de_name_len);
-
-		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
-		    (cur_rec_len >= GFS2_DIRENT_SIZE(cur_name_len) + rec_len)) {
-			gfs2_trans_add_bh(dip->i_gl, bh, 1);
-
-			if (dent->de_inum.no_addr) {
-				new = (struct gfs2_dirent *)((char *)dent +
-					    GFS2_DIRENT_SIZE(cur_name_len));
-				memset(new, 0, sizeof(struct gfs2_dirent));
-
-				new->de_rec_len = cpu_to_be16(cur_rec_len -
-						GFS2_DIRENT_SIZE(cur_name_len));
-				new->de_name_len = cpu_to_be16(name_len);
-
-				dent->de_rec_len = cpu_to_be16(cur_rec_len -
-						be16_to_cpu(new->de_rec_len));
-
-				*dent_out = new;
-				return 0;
-			}
-
-			dent->de_name_len = cpu_to_be16(name_len);
-
-			*dent_out = dent;
-			return 0;
-		}
-	} while (dirent_next(dip, bh, &dent) == 0);
-
-	return -ENOSPC;
+	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct gfs2_dirent *ndent;
+	unsigned offset = 0, totlen;
+
+	if (dent->de_inum.no_addr)
+		offset = GFS2_DIRENT_SIZE(be16_to_cpu(dent->de_name_len));
+	totlen = be16_to_cpu(dent->de_rec_len);
+	BUG_ON(offset + name->len > totlen);
+	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	ndent = (struct gfs2_dirent *)((char *)dent + offset);
+	dent->de_rec_len = cpu_to_be16(offset);
+	gfs2_qstr2dirent(name, totlen - offset, ndent);
+	return ndent;
 }
 
-/**
- * dirent_fits - See if we can fit a entry in this buffer
- * @dip: The GFS2 inode
- * @bh: The buffer
- * @name_len: The length of the name
- *
- * Returns: 1 if it can fit, 0 otherwise
- */
-
-static int dirent_fits(struct gfs2_inode *dip, struct buffer_head *bh,
-		       int name_len)
+static struct gfs2_dirent *gfs2_dirent_alloc(struct inode *inode,
+					     struct buffer_head *bh,
+					     const struct qstr *name)
 {
 	struct gfs2_dirent *dent;
-	unsigned int rec_len = GFS2_DIRENT_SIZE(name_len);
-	unsigned int entries = 0;
-	int type;
-
-	type = dirent_first(dip, bh, &dent);
-	if (type < 0)
-		return type;
-
-	if (type == IS_LEAF) {
-		struct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;
-		entries = be16_to_cpu(leaf->lf_entries);
-	} else {
-		struct gfs2_dinode *dinode = (struct gfs2_dinode *)bh->b_data;
-		entries = be32_to_cpu(dinode->di_entries);
-	}
-
-	if (!entries)
-		return 1;
-
-	do {
-		uint16_t cur_rec_len;
-		uint32_t cur_name_len;
-
-		cur_rec_len = be16_to_cpu(dent->de_rec_len);
-		cur_name_len = be16_to_cpu(dent->de_name_len);
-
-		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
-		    (cur_rec_len >= GFS2_DIRENT_SIZE(cur_name_len) + rec_len))
-			return 1;
-	} while (dirent_next(dip, bh, &dent) == 0);
-
-	return 0;
-}
-
-static int leaf_search(struct gfs2_inode *dip, struct buffer_head *bh,
-		       struct qstr *filename, struct gfs2_dirent **dent_out,
-		       struct gfs2_dirent **dent_prev)
-{
-	uint32_t hash;
-	struct gfs2_dirent *dent, *prev = NULL;
-	unsigned int entries = 0;
-	int type;
-
-	type = dirent_first(dip, bh, &dent);
-	if (type < 0)
-		return type;
-
-	if (type == IS_LEAF) {
-		struct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;
-		entries = be16_to_cpu(leaf->lf_entries);
-	} else if (type == IS_DINODE) {
-		struct gfs2_dinode *dinode = (struct gfs2_dinode *)bh->b_data;
-		entries = be32_to_cpu(dinode->di_entries);
-	}
-
-	hash = gfs2_disk_hash(filename->name, filename->len);
-
-	do {
-		if (!dent->de_inum.no_addr) {
-			prev = dent;
-			continue;
-		}
-
-		if (be32_to_cpu(dent->de_hash) == hash &&
-		    gfs2_filecmp(filename, (char *)(dent + 1),
-				 be16_to_cpu(dent->de_name_len))) {
-			*dent_out = dent;
-			if (dent_prev)
-				*dent_prev = prev;
-
-			return 0;
-		}
-
-		prev = dent;
-	} while (dirent_next(dip, bh, &dent) == 0);
-
-	return -ENOENT;
+	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, gfs2_dirent_find_space, name);
+	if (!dent || IS_ERR(dent))
+		return dent;
+	return gfs2_init_dirent(inode, dent, name, bh);
 }
 
 static int get_leaf(struct gfs2_inode *dip, uint64_t leaf_no,
@@ -716,75 +708,81 @@ static int get_first_leaf(struct gfs2_inode *dip, uint32_t index,
 	return error;
 }
 
-static int get_next_leaf(struct gfs2_inode *dip, struct buffer_head *bh_in,
-			 struct buffer_head **bh_out)
-{
-	struct gfs2_leaf *leaf;
-	int error;
-
-	leaf = (struct gfs2_leaf *)bh_in->b_data;
-
-	if (!leaf->lf_next)
-		error = -ENOENT;
-	else
-		error = get_leaf(dip, be64_to_cpu(leaf->lf_next), bh_out);
-
-	return error;
-}
-
-static int linked_leaf_search(struct gfs2_inode *dip, struct qstr *filename,
-			      struct gfs2_dirent **dent_out,
-			      struct gfs2_dirent **dent_prev,
-			      struct buffer_head **bh_out)
+static struct gfs2_dirent *gfs2_dirent_search(struct inode *inode,
+					      const struct qstr *name,
+					      gfs2_dscan_t scan,
+					      struct buffer_head **pbh)
 {
-	struct buffer_head *bh = NULL, *bh_next;
-	uint32_t hsize, index;
-	uint32_t hash;
+	struct buffer_head *bh;
+	struct gfs2_dirent *dent;
+	struct gfs2_inode *ip = inode->u.generic_ip;
 	int error;
 
-	hsize = 1 << dip->i_di.di_depth;
-	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-
-	/*  Figure out the address of the leaf node.  */
-
-	hash = gfs2_disk_hash(filename->name, filename->len);
-	index = hash >> (32 - dip->i_di.di_depth);
-
-	error = get_first_leaf(dip, index, &bh_next);
-	if (error)
-		return error;
-
-	/*  Find the entry  */
-
-	do {
-		brelse(bh);
-
-		bh = bh_next;
-
-		error = leaf_search(dip, bh, filename, dent_out, dent_prev);
-		switch (error) {
-		case 0:
-			*bh_out = bh;
-			return 0;
-
-		case -ENOENT:
-			break;
+	if (ip->i_di.di_flags & GFS2_DIF_EXHASH) {
+		struct gfs2_leaf *leaf;
+		unsigned hsize = 1 << ip->i_di.di_depth;
+		unsigned index;
+		u64 ln;
+		if (hsize * sizeof(u64) != ip->i_di.di_size) {
+			gfs2_consist_inode(ip);
+			return ERR_PTR(-EIO);
+		}
 
-		default:
+		index = name->hash >> (32 - ip->i_di.di_depth);
+		error = get_first_leaf(ip, index, &bh);
+		if (error)
+			return ERR_PTR(error);
+		do {
+			dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size,
+						scan, name);
+			if (dent)
+				goto got_dent;
+			leaf = (struct gfs2_leaf *)bh->b_data;
+			ln = be64_to_cpu(leaf->lf_next);
 			brelse(bh);
-			return error;
-		}
+			if (!ln)
+				break;
+			error = get_leaf(ip, ln, &bh);
+		} while(!error);
 
-		error = get_next_leaf(dip, bh, &bh_next);
+		return error ? ERR_PTR(error) : NULL;
 	}
-	while (!error);
 
-	brelse(bh);
+	error = gfs2_meta_inode_buffer(ip, &bh);
+	if (error)
+		return ERR_PTR(error);
+	dent = gfs2_dirent_scan(inode, bh->b_data, bh->b_size, scan, name);
+got_dent:
+	*pbh = bh;
+	return dent;
+}
 
-	return error;
+static struct gfs2_leaf *new_leaf(struct inode *inode, struct buffer_head **pbh, u16 depth)
+{
+	struct gfs2_inode *ip = inode->u.generic_ip;
+	u64 bn = gfs2_alloc_meta(ip);
+	struct buffer_head *bh = gfs2_meta_new(ip->i_gl, bn);
+	struct gfs2_leaf *leaf;
+	struct gfs2_dirent *dent;
+	if (!bh)
+		return NULL;
+	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
+	leaf = (struct gfs2_leaf *)bh->b_data;
+	leaf->lf_depth = cpu_to_be16(depth);
+	leaf->lf_entries = cpu_to_be16(0);
+	leaf->lf_dirent_format = cpu_to_be16(GFS2_FORMAT_DE);
+	leaf->lf_next = cpu_to_be64(0);
+	memset(leaf->lf_reserved, 0, sizeof(leaf->lf_reserved));
+	dent = (struct gfs2_dirent *)(leaf+1);
+	dent->de_inum.no_formal_ino = cpu_to_be64(0);
+	dent->de_inum.no_addr = cpu_to_be64(0);
+	dent->de_hash = cpu_to_be32(0);
+	dent->de_rec_len = cpu_to_be16(bh->b_size - sizeof(struct gfs2_leaf));
+	dent->de_name_len = cpu_to_be16(0);
+	dent->de_type = cpu_to_be16(0);
+	*pbh = bh;
+	return leaf;
 }
 
 /**
@@ -794,10 +792,12 @@ static int linked_leaf_search(struct gfs2_inode *dip, struct qstr *filename,
  * Returns: 0 on success, error code otherwise
  */
 
-static int dir_make_exhash(struct gfs2_inode *dip)
+static int dir_make_exhash(struct inode *inode)
 {
+	struct gfs2_inode *dip = inode->u.generic_ip;
 	struct gfs2_sbd *sdp = dip->i_sbd;
 	struct gfs2_dirent *dent;
+	struct qstr args;
 	struct buffer_head *bh, *dibh;
 	struct gfs2_leaf *leaf;
 	int y;
@@ -809,24 +809,14 @@ static int dir_make_exhash(struct gfs2_inode *dip)
 	if (error)
 		return error;
 
-	/*  Allocate a new block for the first leaf node  */
-
-	bn = gfs2_alloc_meta(dip);
-
 	/*  Turn over a new leaf  */
 
-	bh = gfs2_meta_new(dip->i_gl, bn);
-	gfs2_trans_add_bh(dip->i_gl, bh, 1);
-	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
-	gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
-
-	/*  Fill in the leaf structure  */
-
-	leaf = (struct gfs2_leaf *)bh->b_data;
+	leaf = new_leaf(inode, &bh, 0);
+	if (!leaf)
+		return -ENOSPC;
+	bn = bh->b_blocknr;
 
 	gfs2_assert(sdp, dip->i_di.di_entries < (1 << 16));
-
-	leaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);
 	leaf->lf_entries = cpu_to_be16(dip->i_di.di_entries);
 
 	/*  Copy dirents  */
@@ -837,15 +827,21 @@ static int dir_make_exhash(struct gfs2_inode *dip)
 	/*  Find last entry  */
 
 	x = 0;
-	dirent_first(dip, bh, &dent);
-
-	do {
-		if (!dent->de_inum.no_addr)
-			continue;
-		if (++x == dip->i_di.di_entries)
-			break;
+	args.len = bh->b_size - sizeof(struct gfs2_dinode) +
+		   sizeof(struct gfs2_leaf);
+	args.name = bh->b_data;
+	dent = gfs2_dirent_scan(dip->i_vnode, bh->b_data, bh->b_size,
+				gfs2_dirent_last, &args);
+	if (!dent) {
+		brelse(bh);
+		brelse(dibh);
+		return -EIO;
+	}
+	if (IS_ERR(dent)) {
+		brelse(bh);
+		brelse(dibh);
+		return PTR_ERR(dent);
 	}
-	while (dirent_next(dip, bh, &dent) == 0);
 
 	/*  Adjust the last dirent's record length
 	   (Remember that dent still points to the last entry.)  */
@@ -891,45 +887,39 @@ static int dir_make_exhash(struct gfs2_inode *dip)
  * Returns: 0 on success, error code on failure
  */
 
-static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
-			  uint64_t leaf_no)
+static int dir_split_leaf(struct inode *inode, const struct qstr *name)
 {
+	struct gfs2_inode *dip = inode->u.generic_ip;
 	struct buffer_head *nbh, *obh, *dibh;
 	struct gfs2_leaf *nleaf, *oleaf;
 	struct gfs2_dirent *dent, *prev = NULL, *next = NULL, *new;
 	uint32_t start, len, half_len, divider;
-	uint64_t bn, *lp;
-	uint32_t name_len;
+	uint64_t bn, *lp, leaf_no;
+	uint32_t index;
 	int x, moved = 0;
 	int error;
 
-	/*  Allocate the new leaf block  */
-
-	bn = gfs2_alloc_meta(dip);
-
-	/*  Get the new leaf block  */
-
-	nbh = gfs2_meta_new(dip->i_gl, bn);
-	gfs2_trans_add_bh(dip->i_gl, nbh, 1);
-	gfs2_metatype_set(nbh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
-	gfs2_buffer_clear_tail(nbh, sizeof(struct gfs2_meta_header));
-
-	nleaf = (struct gfs2_leaf *)nbh->b_data;
-
-	nleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);
+	index = name->hash >> (32 - dip->i_di.di_depth);
+	error = get_leaf_nr(dip, index, &leaf_no);
+	if (error)
+		return error;
 
 	/*  Get the old leaf block  */
-
 	error = get_leaf(dip, leaf_no, &obh);
 	if (error)
 		goto fail;
 
 	gfs2_trans_add_bh(dip->i_gl, obh, 1);
-
 	oleaf = (struct gfs2_leaf *)obh->b_data;
 
-	/*  Compute the start and len of leaf pointers in the hash table.  */
+	nleaf = new_leaf(inode, &nbh, be16_to_cpu(oleaf->lf_depth) + 1);
+	if (!nleaf) {
+		brelse(obh);
+		return -ENOSPC;
+	}
+	bn = nbh->b_blocknr;
 
+	/*  Compute the start and len of leaf pointers in the hash table.  */
 	len = 1 << (dip->i_di.di_depth - be16_to_cpu(oleaf->lf_depth));
 	half_len = len >> 1;
 	if (!half_len) {
@@ -943,19 +933,8 @@ static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
 	/* Change the pointers.
 	   Don't bother distinguishing stuffed from non-stuffed.
 	   This code is complicated enough already. */
-
-	lp = kcalloc(half_len, sizeof(uint64_t), GFP_KERNEL | __GFP_NOFAIL);
-
-	error = gfs2_dir_read_data(dip, (char *)lp, start * sizeof(uint64_t),
-				    half_len * sizeof(uint64_t));
-	if (error != half_len * sizeof(uint64_t)) {
-		if (error >= 0)
-			error = -EIO;
-		goto fail_lpfree;
-	}
-
+	lp = kmalloc(half_len * sizeof(uint64_t), GFP_NOFS | __GFP_NOFAIL);
 	/*  Change the pointers  */
-
 	for (x = 0; x < half_len; x++)
 		lp[x] = cpu_to_be64(bn);
 
@@ -970,11 +949,9 @@ static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
 	kfree(lp);
 
 	/*  Compute the divider  */
-
 	divider = (start + half_len) << (32 - dip->i_di.di_depth);
 
 	/*  Copy the entries  */
-
 	dirent_first(dip, obh, &dent);
 
 	do {
@@ -984,48 +961,37 @@ static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
 
 		if (dent->de_inum.no_addr &&
 		    be32_to_cpu(dent->de_hash) < divider) {
-			name_len = be16_to_cpu(dent->de_name_len);
-
-			gfs2_dirent_alloc(dip, nbh, name_len, &new);
+			struct qstr str;
+			str.name = (char*)(dent+1);
+			str.len = be16_to_cpu(dent->de_name_len);
+			str.hash = be32_to_cpu(dent->de_hash);
+			new = gfs2_dirent_alloc(dip->i_vnode, nbh, &str);
+			if (IS_ERR(new)) {
+				error = PTR_ERR(new);
+				break;
+			}
 
 			new->de_inum = dent->de_inum; /* No endian worries */
-			new->de_hash = dent->de_hash; /* No endian worries */
 			new->de_type = dent->de_type; /* No endian worries */
-			memcpy((char *)(new + 1), (char *)(dent + 1),
-			       name_len);
-
-			nleaf->lf_entries = be16_to_cpu(nleaf->lf_entries)+1;
-			nleaf->lf_entries = cpu_to_be16(nleaf->lf_entries);
+			nleaf->lf_entries = cpu_to_be16(be16_to_cpu(nleaf->lf_entries)+1);
 
 			dirent_del(dip, obh, prev, dent);
 
 			if (!oleaf->lf_entries)
 				gfs2_consist_inode(dip);
-			oleaf->lf_entries = be16_to_cpu(oleaf->lf_entries)-1;
-			oleaf->lf_entries = cpu_to_be16(oleaf->lf_entries);
+			oleaf->lf_entries = cpu_to_be16(be16_to_cpu(oleaf->lf_entries)-1);
 
 			if (!prev)
 				prev = dent;
 
 			moved = 1;
-		} else
+		} else {
 			prev = dent;
-
+		}
 		dent = next;
-	}
-	while (dent);
-
-	/* If none of the entries got moved into the new leaf,
-	   artificially fill in the first entry. */
-
-	if (!moved) {
-		gfs2_dirent_alloc(dip, nbh, 0, &new);
-		new->de_inum.no_addr = 0;
-	}
+	} while (dent);
 
-	oleaf->lf_depth = be16_to_cpu(oleaf->lf_depth) + 1;
-	oleaf->lf_depth = cpu_to_be16(oleaf->lf_depth);
-	nleaf->lf_depth = oleaf->lf_depth;
+	oleaf->lf_depth = nleaf->lf_depth;
 
 	error = gfs2_meta_inode_buffer(dip, &dibh);
 	if (!gfs2_assert_withdraw(dip->i_sbd, !error)) {
@@ -1142,12 +1108,10 @@ static int compare_dents(const void *a, const void *b)
 	int ret = 0;
 
 	dent_a = *(struct gfs2_dirent **)a;
-	hash_a = dent_a->de_hash;
-	hash_a = be32_to_cpu(hash_a);
+	hash_a = be32_to_cpu(dent_a->de_hash);
 
 	dent_b = *(struct gfs2_dirent **)b;
-	hash_b = dent_b->de_hash;
-	hash_b = be32_to_cpu(hash_b);
+	hash_b = be32_to_cpu(dent_b->de_hash);
 
 	if (hash_a > hash_b)
 		ret = 1;
@@ -1292,8 +1256,7 @@ static int do_filldir_single(struct gfs2_inode *dip, uint64_t *offset,
 			goto out;
 		}
 		darr[e++] = de;
-	}
-	while (dirent_next(dip, bh, &de) == 0);
+	} while (dirent_next(dip, bh, &de) == 0);
 
 	if (e != entries) {
 		gfs2_consist_inode(dip);
@@ -1341,11 +1304,9 @@ static int do_filldir_multi(struct gfs2_inode *dip, uint64_t *offset,
 
 	leaf = (struct gfs2_leaf *)bh->b_data;
 	entries = be16_to_cpu(leaf->lf_entries);
-	ln = leaf->lf_next;
+	ln = be64_to_cpu(leaf->lf_next);
 
 	while (ln) {
-		ln = be64_to_cpu(ln);
-
 		error = get_leaf(dip, ln, &tmp_bh);
 		if (error)
 			return error;
@@ -1355,7 +1316,7 @@ static int do_filldir_multi(struct gfs2_inode *dip, uint64_t *offset,
 			entries += be16_to_cpu(leaf->lf_entries);
 			leaves++;
 		}
-		ln = leaf->lf_next;
+		ln = be64_to_cpu(leaf->lf_next);
 
 		brelse(tmp_bh);
 	}
@@ -1387,14 +1348,11 @@ static int do_filldir_multi(struct gfs2_inode *dip, uint64_t *offset,
 				goto out;
 			}
 			darr[e++] = de;
-		}
-		while (dirent_next(dip, bh, &de) == 0);
+		} while (dirent_next(dip, bh, &de) == 0);
 	}
-	ln = leaf->lf_next;
+	ln = be64_to_cpu(leaf->lf_next);
 
 	while (ln) {
-		ln = be64_to_cpu(ln);
-
 		error = get_leaf(dip, ln, &tmp_bh);
 		if (error)
 			goto out;
@@ -1411,14 +1369,13 @@ static int do_filldir_multi(struct gfs2_inode *dip, uint64_t *offset,
 					goto out;
 				}
 				darr[e++] = de;
-			}
-			while (dirent_next(dip, tmp_bh, &de) == 0);
+			} while (dirent_next(dip, tmp_bh, &de) == 0);
 
 			larr[l++] = tmp_bh;
 
-			ln = leaf->lf_next;
+			ln = be64_to_cpu(leaf->lf_next);
 		} else {
-			ln = leaf->lf_next;
+			ln = be64_to_cpu(leaf->lf_next);
 			brelse(tmp_bh);
 		}
 	}
@@ -1446,228 +1403,27 @@ static int do_filldir_multi(struct gfs2_inode *dip, uint64_t *offset,
 }
 
 /**
- * dir_e_search - Search exhash (leaf) dir for inode matching name
- * @dip: The GFS2 inode
- * @filename: Filename string
- * @inode: If non-NULL, function fills with formal inode # and block address
- * @type: If non-NULL, function fills with DT_... dinode type
+ * dir_e_read - Reads the entries from a directory into a filldir buffer
+ * @dip: dinode pointer
+ * @offset: the hash of the last entry read shifted to the right once
+ * @opaque: buffer for the filldir function to fill
+ * @filldir: points to the filldir function to use
  *
- * Returns:
+ * Returns: errno
  */
 
-static int dir_e_search(struct gfs2_inode *dip, struct qstr *filename,
-			struct gfs2_inum *inum, unsigned int *type)
+static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
+		      gfs2_filldir_t filldir)
 {
+	struct gfs2_sbd *sdp = dip->i_sbd;
 	struct buffer_head *bh;
-	struct gfs2_dirent *dent;
-	int error;
-
-	error = linked_leaf_search(dip, filename, &dent, NULL, &bh);
-	if (error)
-		return error;
-
-	if (inum)
-		gfs2_inum_in(inum, (char *)&dent->de_inum);
-	if (type)
-		*type = be16_to_cpu(dent->de_type);
-
-	brelse(bh);
-
-	return 0;
-}
-
-static int dir_e_add(struct gfs2_inode *dip, struct qstr *filename,
-		     struct gfs2_inum *inum, unsigned int type)
-{
-	struct buffer_head *bh, *nbh, *dibh;
-	struct gfs2_leaf *leaf, *nleaf;
-	struct gfs2_dirent *dent;
-	uint32_t hsize, index;
-	uint32_t hash;
-	uint64_t leaf_no, bn;
-	int error;
-
- restart:
-	hsize = 1 << dip->i_di.di_depth;
-	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-
-	/*  Figure out the address of the leaf node.  */
-
-	hash = gfs2_disk_hash(filename->name, filename->len);
-	index = hash >> (32 - dip->i_di.di_depth);
-
-	error = get_leaf_nr(dip, index, &leaf_no);
-	if (error)
-		return error;
-
-	/*  Add entry to the leaf  */
-
-	for (;;) {
-		error = get_leaf(dip, leaf_no, &bh);
-		if (error)
-			return error;
-
-		leaf = (struct gfs2_leaf *)bh->b_data;
-
-		if (gfs2_dirent_alloc(dip, bh, filename->len, &dent)) {
-
-			if (be16_to_cpu(leaf->lf_depth) < dip->i_di.di_depth) {
-				/* Can we split the leaf? */
-
-				brelse(bh);
-
-				error = dir_split_leaf(dip, index, leaf_no);
-				if (error)
-					return error;
-
-				goto restart;
-
-			} else if (dip->i_di.di_depth < GFS2_DIR_MAX_DEPTH) {
-				/* Can we double the hash table? */
-
-				brelse(bh);
-
-				error = dir_double_exhash(dip);
-				if (error)
-					return error;
-
-				goto restart;
-
-			} else if (leaf->lf_next) {
-				/* Can we try the next leaf in the list? */
-				leaf_no = be64_to_cpu(leaf->lf_next);
-				brelse(bh);
-				continue;
-
-			} else {
-				/* Create a new leaf and add it to the list. */
-
-				bn = gfs2_alloc_meta(dip);
-
-				nbh = gfs2_meta_new(dip->i_gl, bn);
-				gfs2_trans_add_bh(dip->i_gl, nbh, 1);
-				gfs2_metatype_set(nbh,
-						 GFS2_METATYPE_LF,
-						 GFS2_FORMAT_LF);
-				gfs2_buffer_clear_tail(nbh,
-					sizeof(struct gfs2_meta_header));
-
-				gfs2_trans_add_bh(dip->i_gl, bh, 1);
-				leaf->lf_next = cpu_to_be64(bn);
-
-				nleaf = (struct gfs2_leaf *)nbh->b_data;
-				nleaf->lf_depth = leaf->lf_depth;
-				nleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);
-
-				gfs2_dirent_alloc(dip, nbh, filename->len,
-						  &dent);
-
-				dip->i_di.di_blocks++;
-
-				brelse(bh);
-
-				bh = nbh;
-				leaf = nleaf;
-			}
-		}
-
-		/* If the gfs2_dirent_alloc() succeeded, it pinned the "bh" */
-
-		gfs2_inum_out(inum, (char *)&dent->de_inum);
-		dent->de_hash = cpu_to_be32(hash);
-		dent->de_type = cpu_to_be16(type);
-		memcpy((char *)(dent + 1), filename->name, filename->len);
-
-		leaf->lf_entries = be16_to_cpu(leaf->lf_entries) + 1;
-		leaf->lf_entries = cpu_to_be16(leaf->lf_entries);
-
-		brelse(bh);
-
-		error = gfs2_meta_inode_buffer(dip, &dibh);
-		if (error)
-			return error;
-
-		dip->i_di.di_entries++;
-		dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
-
-		gfs2_trans_add_bh(dip->i_gl, dibh, 1);
-		gfs2_dinode_out(&dip->i_di, dibh->b_data);
-		brelse(dibh);
-
-		return 0;
-	}
-
-	return -ENOENT;
-}
-
-static int dir_e_del(struct gfs2_inode *dip, struct qstr *filename)
-{
-	struct buffer_head *bh, *dibh;
-	struct gfs2_dirent *dent, *prev;
-	struct gfs2_leaf *leaf;
-	unsigned int entries;
-	int error;
-
-	error = linked_leaf_search(dip, filename, &dent, &prev, &bh);
-	if (error == -ENOENT) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-	if (error)
-		return error;
-
-	dirent_del(dip, bh, prev, dent); /* Pins bh */
-
-	leaf = (struct gfs2_leaf *)bh->b_data;
-	entries = be16_to_cpu(leaf->lf_entries);
-	if (!entries)
-		gfs2_consist_inode(dip);
-	entries--;
-	leaf->lf_entries = cpu_to_be16(entries);
-
-	brelse(bh);
-
-	error = gfs2_meta_inode_buffer(dip, &dibh);
-	if (error)
-		return error;
-
-	if (!dip->i_di.di_entries)
-		gfs2_consist_inode(dip);
-	dip->i_di.di_entries--;
-	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
-
-	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
-	gfs2_dinode_out(&dip->i_di, dibh->b_data);
-	brelse(dibh);
-
-	return 0;
-}
-
-/**
- * dir_e_read - Reads the entries from a directory into a filldir buffer
- * @dip: dinode pointer
- * @offset: the hash of the last entry read shifted to the right once
- * @opaque: buffer for the filldir function to fill
- * @filldir: points to the filldir function to use
- *
- * Returns: errno
- */
-
-static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
-		      gfs2_filldir_t filldir)
-{
-	struct gfs2_sbd *sdp = dip->i_sbd;
-	struct buffer_head *bh;
-	struct gfs2_leaf leaf;
-	uint32_t hsize, len;
-	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
-	uint32_t hash, index;
-	uint64_t *lp;
-	int copied = 0;
-	int error = 0;
+	struct gfs2_leaf *leaf;
+	uint32_t hsize, len;
+	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
+	uint32_t hash, index;
+	uint64_t *lp;
+	int copied = 0;
+	int error = 0;
 
 	hsize = 1 << dip->i_di.di_depth;
 	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
@@ -1702,14 +1458,15 @@ static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
 		if (error)
 			goto out;
 
-		gfs2_leaf_in(&leaf, bh->b_data);
-
-		if (leaf.lf_next)
+		leaf = (struct gfs2_leaf *)bh->b_data;
+		if (leaf->lf_next)
 			error = do_filldir_multi(dip, offset, opaque, filldir,
 						 bh, &copied);
 		else
 			error = do_filldir_single(dip, offset, opaque, filldir,
-						  bh, leaf.lf_entries, &copied);
+						  bh, 
+						  be16_to_cpu(leaf->lf_entries),
+						  &copied);
 
 		brelse(bh);
 
@@ -1719,7 +1476,7 @@ static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
 			goto out;
 		}
 
-		len = 1 << (dip->i_di.di_depth - leaf.lf_depth);
+		len = 1 << (dip->i_di.di_depth - be16_to_cpu(leaf->lf_depth));
 		index = (index & ~(len - 1)) + len;
 	}
 
@@ -1729,165 +1486,6 @@ static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
 	return error;
 }
 
-static int dir_e_mvino(struct gfs2_inode *dip, struct qstr *filename,
-		       struct gfs2_inum *inum, unsigned int new_type)
-{
-	struct buffer_head *bh, *dibh;
-	struct gfs2_dirent *dent;
-	int error;
-
-	error = linked_leaf_search(dip, filename, &dent, NULL, &bh);
-	if (error == -ENOENT) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-	if (error)
-		return error;
-
-	gfs2_trans_add_bh(dip->i_gl, bh, 1);
-
-	gfs2_inum_out(inum, (char *)&dent->de_inum);
-	dent->de_type = cpu_to_be16(new_type);
-
-	brelse(bh);
-
-	error = gfs2_meta_inode_buffer(dip, &dibh);
-	if (error)
-		return error;
-
-	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
-
-	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
-	gfs2_dinode_out(&dip->i_di, dibh->b_data);
-	brelse(dibh);
-
-	return 0;
-}
-
-/**
- * dir_l_search - Search linear (stuffed dinode) dir for inode matching name
- * @dip: The GFS2 inode
- * @filename: Filename string
- * @inode: If non-NULL, function fills with formal inode # and block address
- * @type: If non-NULL, function fills with DT_... dinode type
- *
- * Returns:
- */
-
-static int dir_l_search(struct gfs2_inode *dip, struct qstr *filename,
-			struct gfs2_inum *inum, unsigned int *type)
-{
-	struct buffer_head *dibh;
-	struct gfs2_dirent *dent;
-	int error;
-
-	if (!gfs2_is_stuffed(dip)) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-
-	error = gfs2_meta_inode_buffer(dip, &dibh);
-	if (error)
-		return error;
-
-	error = leaf_search(dip, dibh, filename, &dent, NULL);
-	if (!error) {
-		if (inum)
-			gfs2_inum_in(inum, (char *)&dent->de_inum);
-		if (type)
-			*type = be16_to_cpu(dent->de_type);
-	}
-
-	brelse(dibh);
-
-	return error;
-}
-
-static int dir_l_add(struct gfs2_inode *dip, struct qstr *filename,
-		     struct gfs2_inum *inum, unsigned int type)
-{
-	struct buffer_head *dibh;
-	struct gfs2_dirent *dent;
-	int error;
-
-	if (!gfs2_is_stuffed(dip)) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-
-	error = gfs2_meta_inode_buffer(dip, &dibh);
-	if (error)
-		return error;
-
-	if (gfs2_dirent_alloc(dip, dibh, filename->len, &dent)) {
-		brelse(dibh);
-
-		error = dir_make_exhash(dip);
-		if (!error)
-			error = dir_e_add(dip, filename, inum, type);
-
-		return error;
-	}
-
-	/*  gfs2_dirent_alloc() pins  */
-
-	gfs2_inum_out(inum, (char *)&dent->de_inum);
-	dent->de_hash = gfs2_disk_hash(filename->name, filename->len);
-	dent->de_hash = cpu_to_be32(dent->de_hash);
-	dent->de_type = cpu_to_be16(type);
-	memcpy((char *)(dent + 1), filename->name, filename->len);
-
-	dip->i_di.di_entries++;
-	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
-
-	gfs2_dinode_out(&dip->i_di, dibh->b_data);
-	brelse(dibh);
-
-	return 0;
-}
-
-static int dir_l_del(struct gfs2_inode *dip, struct qstr *filename)
-{
-	struct buffer_head *dibh;
-	struct gfs2_dirent *dent, *prev;
-	int error;
-
-	if (!gfs2_is_stuffed(dip)) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-
-	error = gfs2_meta_inode_buffer(dip, &dibh);
-	if (error)
-		return error;
-
-	error = leaf_search(dip, dibh, filename, &dent, &prev);
-	if (error == -ENOENT) {
-		gfs2_consist_inode(dip);
-		error = -EIO;
-		goto out;
-	}
-	if (error)
-		goto out;
-
-	dirent_del(dip, dibh, prev, dent);
-
-	/*  dirent_del() pins  */
-
-	if (!dip->i_di.di_entries)
-		gfs2_consist_inode(dip);
-	dip->i_di.di_entries--;
-
-	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
-
-	gfs2_dinode_out(&dip->i_di, dibh->b_data);
-
- out:
-	brelse(dibh);
-
-	return error;
-}
-
 static int dir_l_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
 		      gfs2_filldir_t filldir)
 {
@@ -1919,46 +1517,6 @@ static int dir_l_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
 	return error;
 }
 
-static int dir_l_mvino(struct gfs2_inode *dip, struct qstr *filename,
-		       struct gfs2_inum *inum, unsigned int new_type)
-{
-	struct buffer_head *dibh;
-	struct gfs2_dirent *dent;
-	int error;
-
-	if (!gfs2_is_stuffed(dip)) {
-		gfs2_consist_inode(dip);
-		return -EIO;
-	}
-
-	error = gfs2_meta_inode_buffer(dip, &dibh);
-	if (error)
-		return error;
-
-	error = leaf_search(dip, dibh, filename, &dent, NULL);
-	if (error == -ENOENT) {
-		gfs2_consist_inode(dip);
-		error = -EIO;
-		goto out;
-	}
-	if (error)
-		goto out;
-
-	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
-
-	gfs2_inum_out(inum, (char *)&dent->de_inum);
-	dent->de_type = cpu_to_be16(new_type);
-
-	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
-
-	gfs2_dinode_out(&dip->i_di, dibh->b_data);
-
- out:
-	brelse(dibh);
-
-	return error;
-}
-
 /**
  * gfs2_dir_search - Search a directory
  * @dip: The GFS2 inode
@@ -1971,17 +1529,69 @@ static int dir_l_mvino(struct gfs2_inode *dip, struct qstr *filename,
  * Returns: errno
  */
 
-int gfs2_dir_search(struct gfs2_inode *dip, struct qstr *filename,
+int gfs2_dir_search(struct inode *dir, const struct qstr *name,
 		    struct gfs2_inum *inum, unsigned int *type)
 {
+	struct buffer_head *bh;
+	struct gfs2_dirent *dent;
+
+	dent = gfs2_dirent_search(dir, name, gfs2_dirent_find, &bh);
+	if (dent) {
+		if (IS_ERR(dent))
+			return PTR_ERR(dent);
+		if (inum)
+			gfs2_inum_in(inum, (char *)&dent->de_inum);
+		if (type)
+			*type = be16_to_cpu(dent->de_type);
+		brelse(bh);
+		return 0;
+	}
+	return -ENOENT;
+}
+
+static int dir_new_leaf(struct inode *inode, const struct qstr *name)
+{
+	struct buffer_head *bh, *obh;
+	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct gfs2_leaf *leaf, *oleaf;
 	int error;
+	u32 index;
+	u64 bn;
 
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
-		error = dir_e_search(dip, filename, inum, type);
-	else
-		error = dir_l_search(dip, filename, inum, type);
+	index = name->hash >> (32 - ip->i_di.di_depth);
+	error = get_first_leaf(ip, index, &obh);
+	if (error)
+		return error;
+	do {
+		oleaf = (struct gfs2_leaf *)obh->b_data;
+		bn = be64_to_cpu(oleaf->lf_next);
+		if (!bn)
+			break;
+		brelse(obh);
+		error = get_leaf(ip, bn, &obh);
+		if (error)
+			return error;
+	} while(1);
 
-	return error;
+	gfs2_trans_add_bh(ip->i_gl, obh, 1);
+
+	leaf = new_leaf(inode, &bh, be16_to_cpu(oleaf->lf_depth));
+	if (!leaf) {
+		brelse(obh);
+		return -ENOSPC;
+	}
+	oleaf->lf_next = cpu_to_be64(bn);
+	brelse(bh);
+	brelse(obh);
+
+	error = gfs2_meta_inode_buffer(ip, &bh);
+	if (error)
+		return error;
+	gfs2_trans_add_bh(ip->i_gl, bh, 1);
+	ip->i_di.di_blocks++;
+	gfs2_dinode_out(&ip->i_di, bh->b_data);
+	brelse(bh);
+	return 0;
 }
 
 /**
@@ -1994,19 +1604,70 @@ int gfs2_dir_search(struct gfs2_inode *dip, struct qstr *filename,
  * Returns: 0 on success, error code on failure
  */
 
-int gfs2_dir_add(struct gfs2_inode *dip, struct qstr *filename,
-		 struct gfs2_inum *inum, unsigned int type)
+int gfs2_dir_add(struct inode *inode, const struct qstr *name,
+		 const struct gfs2_inum *inum, unsigned type)
 {
+	struct gfs2_inode *ip = inode->u.generic_ip;
+	struct buffer_head *bh;
+	struct gfs2_dirent *dent;
+	struct gfs2_leaf *leaf;
 	int error;
 
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
-		error = dir_e_add(dip, filename, inum, type);
-	else
-		error = dir_l_add(dip, filename, inum, type);
-
+	while(1) {
+		dent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space,
+					  &bh);
+		if (dent) {
+			if (IS_ERR(dent))
+				return PTR_ERR(dent);
+			dent = gfs2_init_dirent(inode, dent, name, bh);
+			gfs2_inum_out(inum, (char *)&dent->de_inum);
+			dent->de_type = cpu_to_be16(type);
+			if (ip->i_di.di_flags & GFS2_DIF_EXHASH) {
+				leaf = (struct gfs2_leaf *)bh->b_data;
+				leaf->lf_entries = cpu_to_be16(be16_to_cpu(leaf->lf_entries) + 1);
+			}
+			brelse(bh);
+			error = gfs2_meta_inode_buffer(ip, &bh);
+			if (error)
+				break;
+			gfs2_trans_add_bh(ip->i_gl, bh, 1);
+			ip->i_di.di_entries++;
+			ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
+			gfs2_dinode_out(&ip->i_di, bh->b_data);
+			brelse(bh);
+			error = 0;
+			break;
+		}
+		if (!(ip->i_di.di_flags & GFS2_DIF_EXHASH)) {
+			error = dir_make_exhash(inode);
+			if (error)
+				break;
+			continue;
+		}
+		error = dir_split_leaf(inode, name);
+		if (error == 0)
+			continue;
+		if (error != -ENOSPC)
+			break;
+		if (ip->i_di.di_depth < GFS2_DIR_MAX_DEPTH) {
+			error = dir_double_exhash(ip);
+			if (error)
+				break;
+			error = dir_split_leaf(inode, name);
+			if (error)
+				break;
+			continue;
+		}
+		error = dir_new_leaf(inode, name);
+		if (!error)
+			continue;
+		error = -ENOSPC;
+		break;
+	}
 	return error;
 }
 
+
 /**
  * gfs2_dir_del - Delete a directory entry
  * @dip: The GFS2 inode
@@ -2015,14 +1676,50 @@ int gfs2_dir_add(struct gfs2_inode *dip, struct qstr *filename,
  * Returns: 0 on success, error code on failure
  */
 
-int gfs2_dir_del(struct gfs2_inode *dip, struct qstr *filename)
+int gfs2_dir_del(struct gfs2_inode *dip, const struct qstr *name)
 {
+	struct gfs2_dirent *dent, *prev = NULL;
+	struct buffer_head *bh;
 	int error;
 
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
-		error = dir_e_del(dip, filename);
-	else
-		error = dir_l_del(dip, filename);
+	/* Returns _either_ the entry (if its first in block) or the
+	   previous entry otherwise */
+	dent = gfs2_dirent_search(dip->i_vnode, name, gfs2_dirent_prev, &bh);
+	if (!dent) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+	if (IS_ERR(dent)) {
+		gfs2_consist_inode(dip);
+		return PTR_ERR(dent);
+	}
+	/* If not first in block, adjust pointers accordingly */
+	if (gfs2_dirent_find(dent, name) == 0) {
+		prev = dent;
+		dent = (struct gfs2_dirent *)((char *)dent + be16_to_cpu(prev->de_rec_len));
+	}
+
+	dirent_del(dip, bh, prev, dent);
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH) {
+		struct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;
+		u16 entries = be16_to_cpu(leaf->lf_entries);
+		if (!entries)
+			gfs2_consist_inode(dip);
+		leaf->lf_entries = cpu_to_be16(--entries);
+		brelse(bh);
+	}
+
+	error = gfs2_meta_inode_buffer(dip, &bh);
+	if (error)
+		return error;
+
+	if (!dip->i_di.di_entries)
+		gfs2_consist_inode(dip);
+	gfs2_trans_add_bh(dip->i_gl, bh, 1);
+	dip->i_di.di_entries--;
+	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+	gfs2_dinode_out(&dip->i_di, bh->b_data);
+	brelse(bh);
 
 	return error;
 }
@@ -2053,17 +1750,37 @@ int gfs2_dir_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
  * Returns: errno
  */
 
-int gfs2_dir_mvino(struct gfs2_inode *dip, struct qstr *filename,
+int gfs2_dir_mvino(struct gfs2_inode *dip, const struct qstr *filename,
 		   struct gfs2_inum *inum, unsigned int new_type)
 {
+	struct buffer_head *bh;
+	struct gfs2_dirent *dent;
 	int error;
 
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
-		error = dir_e_mvino(dip, filename, inum, new_type);
-	else
-		error = dir_l_mvino(dip, filename, inum, new_type);
+	dent = gfs2_dirent_search(dip->i_vnode, filename, gfs2_dirent_find, &bh);
+	if (!dent) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+	if (IS_ERR(dent))
+		return PTR_ERR(dent);
 
-	return error;
+	gfs2_trans_add_bh(dip->i_gl, bh, 1);
+	gfs2_inum_out(inum, (char *)&dent->de_inum);
+	dent->de_type = cpu_to_be16(new_type);
+
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH) {
+		brelse(bh);
+		error = gfs2_meta_inode_buffer(dip, &bh);
+		if (error)
+			return error;
+		gfs2_trans_add_bh(dip->i_gl, bh, 1);
+	}
+
+	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+	gfs2_dinode_out(&dip->i_di, bh->b_data);
+	brelse(bh);
+	return 0;
 }
 
 /**
@@ -2079,7 +1796,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 {
 	struct gfs2_sbd *sdp = dip->i_sbd;
 	struct buffer_head *bh;
-	struct gfs2_leaf leaf;
+	struct gfs2_leaf *leaf;
 	uint32_t hsize, len;
 	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
 	uint32_t index = 0;
@@ -2118,10 +1835,10 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 			error = get_leaf(dip, leaf_no, &bh);
 			if (error)
 				goto out;
-			gfs2_leaf_in(&leaf, bh->b_data);
+			leaf = (struct gfs2_leaf *)bh->b_data;
 			brelse(bh);
 
-			len = 1 << (dip->i_di.di_depth - leaf.lf_depth);
+			len = 1 << (dip->i_di.di_depth - be16_to_cpu(leaf->lf_depth));
 
 			error = lc(dip, index, len, leaf_no, data);
 			if (error)
@@ -2158,10 +1875,10 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 			uint64_t leaf_no, void *data)
 {
 	struct gfs2_sbd *sdp = dip->i_sbd;
-	struct gfs2_leaf tmp_leaf;
+	struct gfs2_leaf *tmp_leaf;
 	struct gfs2_rgrp_list rlist;
 	struct buffer_head *bh, *dibh;
-	uint64_t blk;
+	uint64_t blk, nblk;
 	unsigned int rg_blocks = 0, l_blocks = 0;
 	char *ht;
 	unsigned int x, size = len * sizeof(uint64_t);
@@ -2185,11 +1902,12 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 
 	/*  Count the number of leaves  */
 
-	for (blk = leaf_no; blk; blk = tmp_leaf.lf_next) {
+	for (blk = leaf_no; blk; blk = nblk) {
 		error = get_leaf(dip, blk, &bh);
 		if (error)
 			goto out_rlist;
-		gfs2_leaf_in(&tmp_leaf, (bh)->b_data);
+		tmp_leaf = (struct gfs2_leaf *)bh->b_data;
+		nblk = be64_to_cpu(tmp_leaf->lf_next);
 		brelse(bh);
 
 		gfs2_rlist_add(sdp, &rlist, blk);
@@ -2214,11 +1932,12 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 	if (error)
 		goto out_rg_gunlock;
 
-	for (blk = leaf_no; blk; blk = tmp_leaf.lf_next) {
+	for (blk = leaf_no; blk; blk = nblk) {
 		error = get_leaf(dip, blk, &bh);
 		if (error)
 			goto out_end_trans;
-		gfs2_leaf_in(&tmp_leaf, bh->b_data);
+		tmp_leaf = (struct gfs2_leaf *)bh->b_data;
+		nblk = be64_to_cpu(tmp_leaf->lf_next);
 		brelse(bh);
 
 		gfs2_free_meta(dip, blk, 1);
@@ -2308,63 +2027,22 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
  * gfs2_diradd_alloc_required - find if adding entry will require an allocation
  * @ip: the file being written to
  * @filname: the filename that's going to be added
- * @alloc_required: set to 1 if an alloc is required, 0 otherwise
  *
- * Returns: errno
+ * Returns: 1 if alloc required, 0 if not, -ve on error
  */
 
-int gfs2_diradd_alloc_required(struct gfs2_inode *dip, struct qstr *filename,
-			       int *alloc_required)
+int gfs2_diradd_alloc_required(struct inode *inode,
+			       const struct qstr *name)
 {
-	struct buffer_head *bh = NULL, *bh_next;
-	uint32_t hsize, hash, index;
-	int error = 0;
-
-	*alloc_required = 0;
-
-	if (dip->i_di.di_flags & GFS2_DIF_EXHASH) {
-		hsize = 1 << dip->i_di.di_depth;
-		if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
-			gfs2_consist_inode(dip);
-			return -EIO;
-		}
-
-		hash = gfs2_disk_hash(filename->name, filename->len);
-		index = hash >> (32 - dip->i_di.di_depth);
-
-		error = get_first_leaf(dip, index, &bh_next);
-		if (error)
-			return error;
-
-		do {
-			brelse(bh);
-
-			bh = bh_next;
-
-			if (dirent_fits(dip, bh, filename->len))
-				break;
-
-			error = get_next_leaf(dip, bh, &bh_next);
-			if (error == -ENOENT) {
-				*alloc_required = 1;
-				error = 0;
-				break;
-			}
-		}
-		while (!error);
-
-		brelse(bh);
-	} else {
-		error = gfs2_meta_inode_buffer(dip, &bh);
-		if (error)
-			return error;
-
-		if (!dirent_fits(dip, bh, filename->len))
-			*alloc_required = 1;
-
-		brelse(bh);
-	}
+	struct gfs2_dirent *dent;
+	struct buffer_head *bh;
 
-	return error;
+	dent = gfs2_dirent_search(inode, name, gfs2_dirent_find_space, &bh);
+	if (!dent)
+		return 1;
+	if (IS_ERR(dent))
+		return PTR_ERR(dent);
+	brelse(bh);
+	return 0;
 }
 

commit 5c676f6d359b0404d53f542f02e1359583cb2895
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Feb 27 17:23:27 2006 -0500

    [GFS2] Macros removal in gfs2.h
    
    As suggested by Pekka Enberg <penberg@cs.helsinki.fi>.
    
    The DIV_RU macro is renamed DIV_ROUND_UP and and moved to kernel.h
    The other macros are gone from gfs2.h as (although not requested
    by Pekka Enberg) are a number of included header file which are now
    included individually. The inode number comparison function is
    now an inline function.
    
    The DT2IF and IF2DT may be addressed in a future patch.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 56683788a6cf..37f70ca558cc 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -59,9 +59,12 @@
 #include <linux/completion.h>
 #include <linux/buffer_head.h>
 #include <linux/sort.h>
+#include <linux/gfs2_ondisk.h>
 #include <asm/semaphore.h>
 
 #include "gfs2.h"
+#include "lm_interface.h"
+#include "incore.h"
 #include "dir.h"
 #include "glock.h"
 #include "inode.h"
@@ -70,6 +73,7 @@
 #include "rgrp.h"
 #include "trans.h"
 #include "bmap.h"
+#include "util.h"
 
 #define IS_LEAF     1 /* Hashed (leaf) directory */
 #define IS_DINODE   2 /* Linear (stuffed dinode block) directory */
@@ -2196,7 +2200,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 
 	for (x = 0; x < rlist.rl_rgrps; x++) {
 		struct gfs2_rgrpd *rgd;
-		rgd = get_gl2rgd(rlist.rl_ghs[x].gh_gl);
+		rgd = rlist.rl_ghs[x].gh_gl->gl_object;
 		rg_blocks += rgd->rd_ri.ri_length;
 	}
 
@@ -2205,7 +2209,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 		goto out_rlist;
 
 	error = gfs2_trans_begin(sdp,
-			rg_blocks + (DIV_RU(size, sdp->sd_jbsize) + 1) +
+			rg_blocks + (DIV_ROUND_UP(size, sdp->sd_jbsize) + 1) +
 			RES_DINODE + RES_STATFS + RES_QUOTA, l_blocks);
 	if (error)
 		goto out_rg_gunlock;

commit 568f4c9659a2225b0d29cf86feecbcf25c9045c8
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Feb 27 12:00:42 2006 -0500

    [GFS2] 80 Column audit of GFS2
    
    Requested by:
    Prarit Bhargava <prarit@redhat.com>
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 65871a2b460e..56683788a6cf 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -98,7 +98,8 @@ int gfs2_dir_get_buffer(struct gfs2_inode *ip, uint64_t block, int new,
 		gfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);
 		gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
 	} else {
-		error = gfs2_meta_read(ip->i_gl, block, DIO_START | DIO_WAIT, &bh);
+		error = gfs2_meta_read(ip->i_gl, block, DIO_START | DIO_WAIT,
+				       &bh);
 		if (error)
 			return error;
 		if (gfs2_metatype_check(ip->i_sbd, bh, GFS2_METATYPE_JD)) {
@@ -163,7 +164,8 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 
 	if (gfs2_is_stuffed(ip) &&
 	    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))
-		return gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset, size);
+		return gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset,
+					      size);
 
 	if (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))
 		return -EINVAL;
@@ -188,7 +190,8 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 
 		if (!extlen) {
 			new = 1;
-			error = gfs2_block_map(ip, lblock, &new, &dblock, &extlen);
+			error = gfs2_block_map(ip, lblock, &new, &dblock,
+					       &extlen);
 			if (error)
 				goto fail;
 			error = -EIO;
@@ -196,7 +199,9 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 				goto fail;
 		}
 
-		error = gfs2_dir_get_buffer(ip, dblock, (amount == sdp->sd_jbsize) ? 1 : new, &bh);
+		error = gfs2_dir_get_buffer(ip, dblock,
+					    (amount == sdp->sd_jbsize) ?
+					    1 : new, &bh);
 		if (error)
 			goto fail;
 
@@ -280,7 +285,8 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 		return 0;
 
 	if (gfs2_is_stuffed(ip))
-		return gfs2_dir_read_stuffed(ip, buf, (unsigned int)offset, size);
+		return gfs2_dir_read_stuffed(ip, buf, (unsigned int)offset,
+					     size);
 
 	if (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))
 		return -EINVAL;
@@ -299,7 +305,8 @@ static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
 
 		if (!extlen) {
 			new = 0;
-			error = gfs2_block_map(ip, lblock, &new, &dblock, &extlen);
+			error = gfs2_block_map(ip, lblock, &new, &dblock,
+					       &extlen);
 			if (error)
 				goto fail;
 		}
@@ -538,13 +545,15 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 
 			if (dent->de_inum.no_addr) {
 				new = (struct gfs2_dirent *)((char *)dent +
-							    GFS2_DIRENT_SIZE(cur_name_len));
+					    GFS2_DIRENT_SIZE(cur_name_len));
 				memset(new, 0, sizeof(struct gfs2_dirent));
 
-				new->de_rec_len = cpu_to_be16(cur_rec_len - GFS2_DIRENT_SIZE(cur_name_len));
+				new->de_rec_len = cpu_to_be16(cur_rec_len -
+						GFS2_DIRENT_SIZE(cur_name_len));
 				new->de_name_len = cpu_to_be16(name_len);
 
-				dent->de_rec_len = cpu_to_be16(cur_rec_len - be16_to_cpu(new->de_rec_len));
+				dent->de_rec_len = cpu_to_be16(cur_rec_len -
+						be16_to_cpu(new->de_rec_len));
 
 				*dent_out = new;
 				return 0;
@@ -2281,7 +2290,8 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 	error = gfs2_meta_inode_buffer(dip, &bh);
 	if (!error) {
 		gfs2_trans_add_bh(dip->i_gl, bh, 1);
-		((struct gfs2_dinode *)bh->b_data)->di_mode = cpu_to_be32(S_IFREG);
+		((struct gfs2_dinode *)bh->b_data)->di_mode =
+						cpu_to_be32(S_IFREG);
 		brelse(bh);
 	}
 

commit 4dd651adbb4898d3200426c197b26c99d2209d8d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Feb 14 15:56:44 2006 +0000

    [GFS2] Fix the bugs I introduced in the last patch but one
    
    Various endianess changes required in the directory code.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c32f7b3de662..65871a2b460e 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -417,6 +417,12 @@ static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
+
+	if (cur_rec_len == 0) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
         /* Only the first dent could ever have de_inum.no_addr == 0 */
 	if (!tmp->de_inum.no_addr) {
 		gfs2_consist_inode(dip);
@@ -512,9 +518,8 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 
 		gfs2_trans_add_bh(dip->i_gl, bh, 1);
 
-		dent->de_rec_len = bh->b_size - offset;
-		dent->de_rec_len = cpu_to_be16(dent->de_rec_len);
-		dent->de_name_len = name_len;
+		dent->de_rec_len = cpu_to_be16(bh->b_size - offset);
+		dent->de_name_len = cpu_to_be16(name_len);
 
 		*dent_out = dent;
 		return 0;
@@ -522,10 +527,10 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 
 	do {
 		uint16_t cur_rec_len;
-		uint32_t cur_name_len;
+		uint16_t cur_name_len;
 
 		cur_rec_len = be16_to_cpu(dent->de_rec_len);
-		cur_name_len = dent->de_name_len;
+		cur_name_len = be16_to_cpu(dent->de_name_len);
 
 		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
 		    (cur_rec_len >= GFS2_DIRENT_SIZE(cur_name_len) + rec_len)) {
@@ -536,18 +541,16 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 							    GFS2_DIRENT_SIZE(cur_name_len));
 				memset(new, 0, sizeof(struct gfs2_dirent));
 
-				new->de_rec_len = cur_rec_len - GFS2_DIRENT_SIZE(cur_name_len);
-				new->de_rec_len = cpu_to_be16(new->de_rec_len);
-				new->de_name_len = name_len;
+				new->de_rec_len = cpu_to_be16(cur_rec_len - GFS2_DIRENT_SIZE(cur_name_len));
+				new->de_name_len = cpu_to_be16(name_len);
 
-				dent->de_rec_len = cur_rec_len - be16_to_cpu(new->de_rec_len);
-				dent->de_rec_len = cpu_to_be16(dent->de_rec_len);
+				dent->de_rec_len = cpu_to_be16(cur_rec_len - be16_to_cpu(new->de_rec_len));
 
 				*dent_out = new;
 				return 0;
 			}
 
-			dent->de_name_len = name_len;
+			dent->de_name_len = cpu_to_be16(name_len);
 
 			*dent_out = dent;
 			return 0;
@@ -594,7 +597,7 @@ static int dirent_fits(struct gfs2_inode *dip, struct buffer_head *bh,
 		uint32_t cur_name_len;
 
 		cur_rec_len = be16_to_cpu(dent->de_rec_len);
-		cur_name_len = dent->de_name_len;
+		cur_name_len = be16_to_cpu(dent->de_name_len);
 
 		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
 		    (cur_rec_len >= GFS2_DIRENT_SIZE(cur_name_len) + rec_len))
@@ -635,7 +638,7 @@ static int leaf_search(struct gfs2_inode *dip, struct buffer_head *bh,
 
 		if (be32_to_cpu(dent->de_hash) == hash &&
 		    gfs2_filecmp(filename, (char *)(dent + 1),
-				 dent->de_name_len)) {
+				 be16_to_cpu(dent->de_name_len))) {
 			*dent_out = dent;
 			if (dent_prev)
 				*dent_prev = prev;
@@ -834,10 +837,9 @@ static int dir_make_exhash(struct gfs2_inode *dip)
 	/*  Adjust the last dirent's record length
 	   (Remember that dent still points to the last entry.)  */
 
-	dent->de_rec_len = be16_to_cpu(dent->de_rec_len) +
+	dent->de_rec_len = cpu_to_be16(be16_to_cpu(dent->de_rec_len) +
 		sizeof(struct gfs2_dinode) -
-		sizeof(struct gfs2_leaf);
-	dent->de_rec_len = cpu_to_be16(dent->de_rec_len);
+		sizeof(struct gfs2_leaf));
 
 	brelse(bh);
 
@@ -969,7 +971,7 @@ static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
 
 		if (dent->de_inum.no_addr &&
 		    be32_to_cpu(dent->de_hash) < divider) {
-			name_len = dent->de_name_len;
+			name_len = be16_to_cpu(dent->de_name_len);
 
 			gfs2_dirent_alloc(dip, nbh, name_len, &new);
 
@@ -1139,8 +1141,8 @@ static int compare_dents(const void *a, const void *b)
 	else if (hash_a < hash_b)
 		ret = -1;
 	else {
-		unsigned int len_a = dent_a->de_name_len;
-		unsigned int len_b = dent_b->de_name_len;
+		unsigned int len_a = be16_to_cpu(dent_a->de_name_len);
+		unsigned int len_b = be16_to_cpu(dent_b->de_name_len);
 
 		if (len_a > len_b)
 			ret = 1;
@@ -1219,9 +1221,9 @@ static int do_filldir_main(struct gfs2_inode *dip, uint64_t *offset,
 		gfs2_inum_in(&inum, (char *)&dent->de_inum);
 
 		error = filldir(opaque, (char *)(dent + 1),
-				dent->de_name_len,
+				be16_to_cpu(dent->de_name_len),
 				off, &inum,
-				dent->de_type);
+				be16_to_cpu(dent->de_type));
 		if (error)
 			return 1;
 
@@ -1454,7 +1456,7 @@ static int dir_e_search(struct gfs2_inode *dip, struct qstr *filename,
 	if (inum)
 		gfs2_inum_in(inum, (char *)&dent->de_inum);
 	if (type)
-		*type = dent->de_type;
+		*type = be16_to_cpu(dent->de_type);
 
 	brelse(bh);
 
@@ -1563,7 +1565,7 @@ static int dir_e_add(struct gfs2_inode *dip, struct qstr *filename,
 
 		gfs2_inum_out(inum, (char *)&dent->de_inum);
 		dent->de_hash = cpu_to_be32(hash);
-		dent->de_type = type;
+		dent->de_type = cpu_to_be16(type);
 		memcpy((char *)(dent + 1), filename->name, filename->len);
 
 		leaf->lf_entries = be16_to_cpu(leaf->lf_entries) + 1;
@@ -1732,7 +1734,7 @@ static int dir_e_mvino(struct gfs2_inode *dip, struct qstr *filename,
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 
 	gfs2_inum_out(inum, (char *)&dent->de_inum);
-	dent->de_type = new_type;
+	dent->de_type = cpu_to_be16(new_type);
 
 	brelse(bh);
 
@@ -1780,7 +1782,7 @@ static int dir_l_search(struct gfs2_inode *dip, struct qstr *filename,
 		if (inum)
 			gfs2_inum_in(inum, (char *)&dent->de_inum);
 		if (type)
-			*type = dent->de_type;
+			*type = be16_to_cpu(dent->de_type);
 	}
 
 	brelse(dibh);
@@ -1819,7 +1821,7 @@ static int dir_l_add(struct gfs2_inode *dip, struct qstr *filename,
 	gfs2_inum_out(inum, (char *)&dent->de_inum);
 	dent->de_hash = gfs2_disk_hash(filename->name, filename->len);
 	dent->de_hash = cpu_to_be32(dent->de_hash);
-	dent->de_type = type;
+	dent->de_type = cpu_to_be16(type);
 	memcpy((char *)(dent + 1), filename->name, filename->len);
 
 	dip->i_di.di_entries++;
@@ -1932,7 +1934,7 @@ static int dir_l_mvino(struct gfs2_inode *dip, struct qstr *filename,
 	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 
 	gfs2_inum_out(inum, (char *)&dent->de_inum);
-	dent->de_type = new_type;
+	dent->de_type = cpu_to_be16(new_type);
 
 	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
 

commit fc69d0d336214219abb521d8ff060f786d7f369e
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Feb 13 16:21:47 2006 +0000

    [GFS2] Change ondisk format (hopefully for the last time)
    
    There were one or two fields in structures which didn't get changed
    last time back to their gfs1 sizes and alignments. One or two constants
    have also changed back to their original values which were missed the
    first time.
    
    Its possible that indirect pointer blocks might need to change. If
    they don't we'll have to rewrite them all on upgrade due to a change
    in the amount of padding that they use.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c77e18048d98..c32f7b3de662 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -397,11 +397,11 @@ static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 {
 	struct gfs2_dirent *tmp, *cur;
 	char *bh_end;
-	uint32_t cur_rec_len;
+	uint16_t cur_rec_len;
 
 	cur = *dent;
 	bh_end = bh->b_data + bh->b_size;
-	cur_rec_len = be32_to_cpu(cur->de_rec_len);
+	cur_rec_len = be16_to_cpu(cur->de_rec_len);
 
 	if ((char *)cur + cur_rec_len >= bh_end) {
 		if ((char *)cur + cur_rec_len > bh_end) {
@@ -413,7 +413,7 @@ static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 
 	tmp = (struct gfs2_dirent *)((char *)cur + cur_rec_len);
 
-	if ((char *)tmp + be32_to_cpu(tmp->de_rec_len) > bh_end) {
+	if ((char *)tmp + be16_to_cpu(tmp->de_rec_len) > bh_end) {
 		gfs2_consist_inode(dip);
 		return -EIO;
 	}
@@ -440,7 +440,7 @@ static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
 static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 		       struct gfs2_dirent *prev, struct gfs2_dirent *cur)
 {
-	uint32_t cur_rec_len, prev_rec_len;
+	uint16_t cur_rec_len, prev_rec_len;
 
 	if (!cur->de_inum.no_addr) {
 		gfs2_consist_inode(dip);
@@ -460,8 +460,8 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 
 	/*  Combine this dentry with the previous one.  */
 
-	prev_rec_len = be32_to_cpu(prev->de_rec_len);
-	cur_rec_len = be32_to_cpu(cur->de_rec_len);
+	prev_rec_len = be16_to_cpu(prev->de_rec_len);
+	cur_rec_len = be16_to_cpu(cur->de_rec_len);
 
 	if ((char *)prev + prev_rec_len != (char *)cur)
 		gfs2_consist_inode(dip);
@@ -469,7 +469,7 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 		gfs2_consist_inode(dip);
 
 	prev_rec_len += cur_rec_len;
-	prev->de_rec_len = cpu_to_be32(prev_rec_len);
+	prev->de_rec_len = cpu_to_be16(prev_rec_len);
 }
 
 /**
@@ -513,7 +513,7 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 		gfs2_trans_add_bh(dip->i_gl, bh, 1);
 
 		dent->de_rec_len = bh->b_size - offset;
-		dent->de_rec_len = cpu_to_be32(dent->de_rec_len);
+		dent->de_rec_len = cpu_to_be16(dent->de_rec_len);
 		dent->de_name_len = name_len;
 
 		*dent_out = dent;
@@ -521,9 +521,10 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 	}
 
 	do {
-		uint32_t cur_rec_len, cur_name_len;
+		uint16_t cur_rec_len;
+		uint32_t cur_name_len;
 
-		cur_rec_len = be32_to_cpu(dent->de_rec_len);
+		cur_rec_len = be16_to_cpu(dent->de_rec_len);
 		cur_name_len = dent->de_name_len;
 
 		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
@@ -536,11 +537,11 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 				memset(new, 0, sizeof(struct gfs2_dirent));
 
 				new->de_rec_len = cur_rec_len - GFS2_DIRENT_SIZE(cur_name_len);
-				new->de_rec_len = cpu_to_be32(new->de_rec_len);
+				new->de_rec_len = cpu_to_be16(new->de_rec_len);
 				new->de_name_len = name_len;
 
-				dent->de_rec_len = cur_rec_len - be32_to_cpu(new->de_rec_len);
-				dent->de_rec_len = cpu_to_be32(dent->de_rec_len);
+				dent->de_rec_len = cur_rec_len - be16_to_cpu(new->de_rec_len);
+				dent->de_rec_len = cpu_to_be16(dent->de_rec_len);
 
 				*dent_out = new;
 				return 0;
@@ -589,9 +590,10 @@ static int dirent_fits(struct gfs2_inode *dip, struct buffer_head *bh,
 		return 1;
 
 	do {
-		uint32_t cur_rec_len, cur_name_len;
+		uint16_t cur_rec_len;
+		uint32_t cur_name_len;
 
-		cur_rec_len = be32_to_cpu(dent->de_rec_len);
+		cur_rec_len = be16_to_cpu(dent->de_rec_len);
 		cur_name_len = dent->de_name_len;
 
 		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
@@ -832,10 +834,10 @@ static int dir_make_exhash(struct gfs2_inode *dip)
 	/*  Adjust the last dirent's record length
 	   (Remember that dent still points to the last entry.)  */
 
-	dent->de_rec_len = be32_to_cpu(dent->de_rec_len) +
+	dent->de_rec_len = be16_to_cpu(dent->de_rec_len) +
 		sizeof(struct gfs2_dinode) -
 		sizeof(struct gfs2_leaf);
-	dent->de_rec_len = cpu_to_be32(dent->de_rec_len);
+	dent->de_rec_len = cpu_to_be16(dent->de_rec_len);
 
 	brelse(bh);
 

commit 18ec7d5c3f434aed9661ed10a9e1f48cdeb4981d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Feb 8 11:50:51 2006 +0000

    [GFS2] Make journaled data files identical to normal files on disk
    
    This is a very large patch, with a few still to be resolved issues
    so you might want to check out the previous head of the tree since
    this is known to be unstable. Fixes for the various bugs will be
    forthcoming shortly.
    
    This patch removes the special data format which has been used
    up till now for journaled data files. Directories still retain the
    old format so that they will remain on disk compatible with earlier
    releases. As a result you can now do the following with journaled
    data files:
    
     1) mmap them
     2) export them over NFS
     3) convert to/from normal files whenever you want to (the zero length
        restriction is gone)
    
    In addition the level at which GFS' locking is done has changed for all
    files (since they all now use the page cache) such that the locking is
    done at the page cache level rather than the level of the fs operations.
    This should mean that things like loopback mounts and other things which
    touch the page cache directly should now work.
    
    Current known issues:
    
     1. There is a lock mode inversion problem related to the resource
        group hold function which needs to be resolved.
     2. Any significant amount of I/O causes an oops with an offset of hex 320
        (NULL pointer dereference) which appears to be related to a journaled data
        buffer appearing on a list where it shouldn't be.
     3. Direct I/O writes are disabled for the time being (will reappear later)
     4. There is probably a deadlock between the page lock and GFS' locks under
        certain combinations of mmap and fs operation I/O.
     5. Issue relating to ref counting on internally used inodes causes a hang
        on umount (discovered before this patch, and not fixed by it)
     6. One part of the directory metadata is different from GFS1 and will need
        to be resolved before next release.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index ada283a0f5f3..c77e18048d98 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -86,8 +86,8 @@ typedef int (*leaf_call_t) (struct gfs2_inode *dip,
 			    uint32_t index, uint32_t len, uint64_t leaf_no,
 			    void *data);
 
-static int gfs2_dir_get_buffer(struct gfs2_inode *ip, uint64_t block, int new,
-			       struct buffer_head **bhp)
+int gfs2_dir_get_buffer(struct gfs2_inode *ip, uint64_t block, int new,
+		         struct buffer_head **bhp)
 {
 	struct buffer_head *bh;
 	int error = 0;

commit e13940ba56157a663944f2a827be96b6b787e260
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 30 13:31:50 2006 +0000

    [GFS2] Make dir.c independant of jdata.c
    
    Copy & rename various jdata functions into dir.c. The plan
    being that directory metadata format will not change although
    the journalled data format for "normal" files will change.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 93d3704ac58c..ada283a0f5f3 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -65,11 +65,11 @@
 #include "dir.h"
 #include "glock.h"
 #include "inode.h"
-#include "jdata.h"
 #include "meta_io.h"
 #include "quota.h"
 #include "rgrp.h"
 #include "trans.h"
+#include "bmap.h"
 
 #define IS_LEAF     1 /* Hashed (leaf) directory */
 #define IS_DINODE   2 /* Linear (stuffed dinode block) directory */
@@ -86,6 +86,252 @@ typedef int (*leaf_call_t) (struct gfs2_inode *dip,
 			    uint32_t index, uint32_t len, uint64_t leaf_no,
 			    void *data);
 
+static int gfs2_dir_get_buffer(struct gfs2_inode *ip, uint64_t block, int new,
+			       struct buffer_head **bhp)
+{
+	struct buffer_head *bh;
+	int error = 0;
+
+	if (new) {
+		bh = gfs2_meta_new(ip->i_gl, block);
+		gfs2_trans_add_bh(ip->i_gl, bh, 1);
+		gfs2_metatype_set(bh, GFS2_METATYPE_JD, GFS2_FORMAT_JD);
+		gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
+	} else {
+		error = gfs2_meta_read(ip->i_gl, block, DIO_START | DIO_WAIT, &bh);
+		if (error)
+			return error;
+		if (gfs2_metatype_check(ip->i_sbd, bh, GFS2_METATYPE_JD)) {
+			brelse(bh);
+			return -EIO;
+		}
+	}
+
+	*bhp = bh;
+	return 0;
+}
+
+
+
+static int gfs2_dir_write_stuffed(struct gfs2_inode *ip, const char *buf,
+				  unsigned int offset, unsigned int size)
+                               
+{
+	struct buffer_head *dibh;
+	int error;
+
+	error = gfs2_meta_inode_buffer(ip, &dibh);
+	if (error)
+		return error;
+
+	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	memcpy(dibh->b_data + offset + sizeof(struct gfs2_inode), buf, size);
+	if (ip->i_di.di_size < offset + size)
+		ip->i_di.di_size = offset + size;
+	ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
+	gfs2_dinode_out(&ip->i_di, dibh->b_data);
+
+	brelse(dibh);
+
+	return size;
+}
+
+
+
+/**
+ * gfs2_dir_write_data - Write directory information to the inode
+ * @ip: The GFS2 inode
+ * @buf: The buffer containing information to be written
+ * @offset: The file offset to start writing at
+ * @size: The amount of data to write
+ *
+ * Returns: The number of bytes correctly written or error code
+ */
+static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
+			       uint64_t offset, unsigned int size)
+{
+	struct gfs2_sbd *sdp = ip->i_sbd;
+	struct buffer_head *dibh;
+	uint64_t lblock, dblock;
+	uint32_t extlen = 0;
+	unsigned int o;
+	int copied = 0;
+	int error = 0;
+
+	if (!size)
+		return 0;
+
+	if (gfs2_is_stuffed(ip) &&
+	    offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))
+		return gfs2_dir_write_stuffed(ip, buf, (unsigned int)offset, size);
+
+	if (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))
+		return -EINVAL;
+
+	if (gfs2_is_stuffed(ip)) {
+		error = gfs2_unstuff_dinode(ip, NULL, NULL);
+		if (error)
+		return error;
+	}
+
+	lblock = offset;
+	o = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);
+
+	while (copied < size) {
+		unsigned int amount;
+		struct buffer_head *bh;
+		int new;
+
+		amount = size - copied;
+		if (amount > sdp->sd_sb.sb_bsize - o)
+			amount = sdp->sd_sb.sb_bsize - o;
+
+		if (!extlen) {
+			new = 1;
+			error = gfs2_block_map(ip, lblock, &new, &dblock, &extlen);
+			if (error)
+				goto fail;
+			error = -EIO;
+			if (gfs2_assert_withdraw(sdp, dblock))
+				goto fail;
+		}
+
+		error = gfs2_dir_get_buffer(ip, dblock, (amount == sdp->sd_jbsize) ? 1 : new, &bh);
+		if (error)
+			goto fail;
+
+		gfs2_trans_add_bh(ip->i_gl, bh, 1);
+		memcpy(bh->b_data + o, buf, amount);
+		brelse(bh);
+		if (error)
+			goto fail;
+
+		copied += amount;
+		lblock++;
+		dblock++;
+		extlen--;
+
+		o = sizeof(struct gfs2_meta_header);
+	}
+
+out:
+	error = gfs2_meta_inode_buffer(ip, &dibh);
+	if (error)
+		return error;
+
+	if (ip->i_di.di_size < offset + copied)
+		ip->i_di.di_size = offset + copied;
+	ip->i_di.di_mtime = ip->i_di.di_ctime = get_seconds();
+
+	gfs2_trans_add_bh(ip->i_gl, dibh, 1);
+	gfs2_dinode_out(&ip->i_di, dibh->b_data);
+	brelse(dibh);
+
+	return copied;
+fail:
+	if (copied)
+		goto out;
+	return error;
+}
+
+static int gfs2_dir_read_stuffed(struct gfs2_inode *ip, char *buf,
+				unsigned int offset, unsigned int size)
+{
+	struct buffer_head *dibh;
+	int error;
+
+	error = gfs2_meta_inode_buffer(ip, &dibh);
+	if (!error) {
+		offset += sizeof(struct gfs2_dinode);
+		memcpy(buf, dibh->b_data + offset, size);
+		brelse(dibh);
+	}
+
+	return (error) ? error : size;
+}
+
+
+/**
+ * gfs2_dir_read_data - Read a data from a directory inode
+ * @ip: The GFS2 Inode
+ * @buf: The buffer to place result into
+ * @offset: File offset to begin jdata_readng from
+ * @size: Amount of data to transfer
+ *
+ * Returns: The amount of data actually copied or the error
+ */
+static int gfs2_dir_read_data(struct gfs2_inode *ip, char *buf,
+			      uint64_t offset, unsigned int size)
+{
+	struct gfs2_sbd *sdp = ip->i_sbd;
+	uint64_t lblock, dblock;
+	uint32_t extlen = 0;
+	unsigned int o;
+	int copied = 0;
+	int error = 0;
+
+	if (offset >= ip->i_di.di_size)
+		return 0;
+
+	if ((offset + size) > ip->i_di.di_size)
+		size = ip->i_di.di_size - offset;
+
+	if (!size)
+		return 0;
+
+	if (gfs2_is_stuffed(ip))
+		return gfs2_dir_read_stuffed(ip, buf, (unsigned int)offset, size);
+
+	if (gfs2_assert_warn(sdp, gfs2_is_jdata(ip)))
+		return -EINVAL;
+
+	lblock = offset;
+	o = do_div(lblock, sdp->sd_jbsize) + sizeof(struct gfs2_meta_header);
+
+	while (copied < size) {
+		unsigned int amount;
+		struct buffer_head *bh;
+		int new;
+
+		amount = size - copied;
+		if (amount > sdp->sd_sb.sb_bsize - o)
+			amount = sdp->sd_sb.sb_bsize - o;
+
+		if (!extlen) {
+			new = 0;
+			error = gfs2_block_map(ip, lblock, &new, &dblock, &extlen);
+			if (error)
+				goto fail;
+		}
+
+		if (extlen > 1)
+			gfs2_meta_ra(ip->i_gl, dblock, extlen);
+
+		if (dblock) {
+			error = gfs2_dir_get_buffer(ip, dblock, new, &bh);
+			if (error)
+				goto fail;
+			dblock++;
+			extlen--;
+		} else
+			bh = NULL;
+
+		memcpy(buf, bh->b_data + o, amount);
+		brelse(bh);
+		if (error)
+			goto fail;
+
+		copied += amount;
+		lblock++;
+
+		o = sizeof(struct gfs2_meta_header);
+	}
+
+	return copied;
+fail:
+	return (copied) ? copied : error;
+}
+
 /**
  * int gfs2_filecmp - Compare two filenames
  * @file1: The first filename
@@ -428,7 +674,7 @@ static int get_leaf_nr(struct gfs2_inode *dip, uint32_t index,
 	uint64_t leaf_no;
 	int error;
 
-	error = gfs2_jdata_read_mem(dip, (char *)&leaf_no,
+	error = gfs2_dir_read_data(dip, (char *)&leaf_no,
 				    index * sizeof(uint64_t),
 				    sizeof(uint64_t));
 	if (error != sizeof(uint64_t))
@@ -683,7 +929,7 @@ static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
 
 	lp = kcalloc(half_len, sizeof(uint64_t), GFP_KERNEL | __GFP_NOFAIL);
 
-	error = gfs2_jdata_read_mem(dip, (char *)lp, start * sizeof(uint64_t),
+	error = gfs2_dir_read_data(dip, (char *)lp, start * sizeof(uint64_t),
 				    half_len * sizeof(uint64_t));
 	if (error != half_len * sizeof(uint64_t)) {
 		if (error >= 0)
@@ -696,7 +942,7 @@ static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
 	for (x = 0; x < half_len; x++)
 		lp[x] = cpu_to_be64(bn);
 
-	error = gfs2_jdata_write_mem(dip, (char *)lp, start * sizeof(uint64_t),
+	error = gfs2_dir_write_data(dip, (char *)lp, start * sizeof(uint64_t),
 				     half_len * sizeof(uint64_t));
 	if (error != half_len * sizeof(uint64_t)) {
 		if (error >= 0)
@@ -816,7 +1062,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_KERNEL | __GFP_NOFAIL);
 
 	for (block = dip->i_di.di_size >> sdp->sd_hash_bsize_shift; block--;) {
-		error = gfs2_jdata_read_mem(dip, (char *)buf,
+		error = gfs2_dir_read_data(dip, (char *)buf,
 					    block * sdp->sd_hash_bsize,
 					    sdp->sd_hash_bsize);
 		if (error != sdp->sd_hash_bsize) {
@@ -833,7 +1079,7 @@ static int dir_double_exhash(struct gfs2_inode *dip)
 			*to++ = *from;
 		}
 
-		error = gfs2_jdata_write_mem(dip,
+		error = gfs2_dir_write_data(dip,
 					     (char *)buf + sdp->sd_hash_bsize,
 					     block * sdp->sd_sb.sb_bsize,
 					     sdp->sd_sb.sb_bsize);
@@ -1424,7 +1670,7 @@ static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
 		ht_offset = index - lp_offset;
 
 		if (ht_offset_cur != ht_offset) {
-			error = gfs2_jdata_read_mem(dip, (char *)lp,
+			error = gfs2_dir_read_data(dip, (char *)lp,
 						ht_offset * sizeof(uint64_t),
 						sdp->sd_hash_bsize);
 			if (error != sdp->sd_hash_bsize) {
@@ -1839,7 +2085,7 @@ static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
 		ht_offset = index - lp_offset;
 
 		if (ht_offset_cur != ht_offset) {
-			error = gfs2_jdata_read_mem(dip, (char *)lp,
+			error = gfs2_dir_read_data(dip, (char *)lp,
 						ht_offset * sizeof(uint64_t),
 						sdp->sd_hash_bsize);
 			if (error != sdp->sd_hash_bsize) {
@@ -1965,7 +2211,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 		dip->i_di.di_blocks--;
 	}
 
-	error = gfs2_jdata_write_mem(dip, ht, index * sizeof(uint64_t), size);
+	error = gfs2_dir_write_data(dip, ht, index * sizeof(uint64_t), size);
 	if (error != size) {
 		if (error >= 0)
 			error = -EIO;

commit d4e9c4c3bf861ef2ac96e0de659c75a00da92b28
Author: Steven Whitehouse <steve@chygwyn.com>
Date:   Wed Jan 18 11:19:28 2006 +0000

    [GFS2] Add an additional argument to gfs2_trans_add_bh()
    
    This adds an extra argument to gfs2_trans_add_bh() to indicate whether the
    bh being added to the transaction is metadata or data. Its currently unused
    since all existing callers set it to 1 (metadata) but following patches will
    make use of it.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index f6304e55dbc1..93d3704ac58c 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -201,7 +201,7 @@ static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
 		return;
 	}
 
-	gfs2_trans_add_bh(dip->i_gl, bh);
+	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 
 	/* If there is no prev entry, this is the first entry in the block.
 	   The de_rec_len is already as big as it needs to be.  Just zero
@@ -264,7 +264,7 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 			return -EIO;
 		}
 
-		gfs2_trans_add_bh(dip->i_gl, bh);
+		gfs2_trans_add_bh(dip->i_gl, bh, 1);
 
 		dent->de_rec_len = bh->b_size - offset;
 		dent->de_rec_len = cpu_to_be32(dent->de_rec_len);
@@ -282,7 +282,7 @@ int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
 
 		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
 		    (cur_rec_len >= GFS2_DIRENT_SIZE(cur_name_len) + rec_len)) {
-			gfs2_trans_add_bh(dip->i_gl, bh);
+			gfs2_trans_add_bh(dip->i_gl, bh, 1);
 
 			if (dent->de_inum.no_addr) {
 				new = (struct gfs2_dirent *)((char *)dent +
@@ -552,7 +552,7 @@ static int dir_make_exhash(struct gfs2_inode *dip)
 	/*  Turn over a new leaf  */
 
 	bh = gfs2_meta_new(dip->i_gl, bn);
-	gfs2_trans_add_bh(dip->i_gl, bh);
+	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
 
@@ -596,7 +596,7 @@ static int dir_make_exhash(struct gfs2_inode *dip)
 	/*  We're done with the new leaf block, now setup the new
 	    hash table.  */
 
-	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 	gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
 
 	lp = (uint64_t *)(dibh->b_data + sizeof(struct gfs2_dinode));
@@ -647,7 +647,7 @@ static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
 	/*  Get the new leaf block  */
 
 	nbh = gfs2_meta_new(dip->i_gl, bn);
-	gfs2_trans_add_bh(dip->i_gl, nbh);
+	gfs2_trans_add_bh(dip->i_gl, nbh, 1);
 	gfs2_metatype_set(nbh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
 	gfs2_buffer_clear_tail(nbh, sizeof(struct gfs2_meta_header));
 
@@ -661,7 +661,7 @@ static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
 	if (error)
 		goto fail;
 
-	gfs2_trans_add_bh(dip->i_gl, obh);
+	gfs2_trans_add_bh(dip->i_gl, obh, 1);
 
 	oleaf = (struct gfs2_leaf *)obh->b_data;
 
@@ -1285,14 +1285,14 @@ static int dir_e_add(struct gfs2_inode *dip, struct qstr *filename,
 				bn = gfs2_alloc_meta(dip);
 
 				nbh = gfs2_meta_new(dip->i_gl, bn);
-				gfs2_trans_add_bh(dip->i_gl, nbh);
+				gfs2_trans_add_bh(dip->i_gl, nbh, 1);
 				gfs2_metatype_set(nbh,
 						 GFS2_METATYPE_LF,
 						 GFS2_FORMAT_LF);
 				gfs2_buffer_clear_tail(nbh,
 					sizeof(struct gfs2_meta_header));
 
-				gfs2_trans_add_bh(dip->i_gl, bh);
+				gfs2_trans_add_bh(dip->i_gl, bh, 1);
 				leaf->lf_next = cpu_to_be64(bn);
 
 				nleaf = (struct gfs2_leaf *)nbh->b_data;
@@ -1330,7 +1330,7 @@ static int dir_e_add(struct gfs2_inode *dip, struct qstr *filename,
 		dip->i_di.di_entries++;
 		dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
 
-		gfs2_trans_add_bh(dip->i_gl, dibh);
+		gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 		gfs2_dinode_out(&dip->i_di, dibh->b_data);
 		brelse(dibh);
 
@@ -1376,7 +1376,7 @@ static int dir_e_del(struct gfs2_inode *dip, struct qstr *filename)
 	dip->i_di.di_entries--;
 	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
 
-	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 	gfs2_dinode_out(&dip->i_di, dibh->b_data);
 	brelse(dibh);
 
@@ -1481,7 +1481,7 @@ static int dir_e_mvino(struct gfs2_inode *dip, struct qstr *filename,
 	if (error)
 		return error;
 
-	gfs2_trans_add_bh(dip->i_gl, bh);
+	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 
 	gfs2_inum_out(inum, (char *)&dent->de_inum);
 	dent->de_type = new_type;
@@ -1494,7 +1494,7 @@ static int dir_e_mvino(struct gfs2_inode *dip, struct qstr *filename,
 
 	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
 
-	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 	gfs2_dinode_out(&dip->i_di, dibh->b_data);
 	brelse(dibh);
 
@@ -1681,7 +1681,7 @@ static int dir_l_mvino(struct gfs2_inode *dip, struct qstr *filename,
 	if (error)
 		goto out;
 
-	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 
 	gfs2_inum_out(inum, (char *)&dent->de_inum);
 	dent->de_type = new_type;
@@ -1976,7 +1976,7 @@ static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
 	if (error)
 		goto out_end_trans;
 
-	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_trans_add_bh(dip->i_gl, dibh, 1);
 	gfs2_dinode_out(&dip->i_di, dibh->b_data);
 	brelse(dibh);
 
@@ -2030,7 +2030,7 @@ int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
 
 	error = gfs2_meta_inode_buffer(dip, &bh);
 	if (!error) {
-		gfs2_trans_add_bh(dip->i_gl, bh);
+		gfs2_trans_add_bh(dip->i_gl, bh, 1);
 		((struct gfs2_dinode *)bh->b_data)->di_mode = cpu_to_be32(S_IFREG);
 		brelse(bh);
 	}

commit 666a2c534cc6238932296a95c9e9c06ca3b73d97
Author: Steven Whitehouse <steve@chygwyn.com>
Date:   Wed Jan 18 10:29:04 2006 +0000

    [GFS2] Remove unused code from various files
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 6b1dc3dc3a2d..f6304e55dbc1 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2104,54 +2104,3 @@ int gfs2_diradd_alloc_required(struct gfs2_inode *dip, struct qstr *filename,
 	return error;
 }
 
-/**
- * do_gdm - copy out one leaf (or list of leaves)
- * @dip: the directory
- * @index: the hash table offset in the directory
- * @len: the number of pointers to this leaf
- * @leaf_no: the leaf number
- * @data: a pointer to a struct gfs2_user_buffer structure
- *
- * Returns: errno
- */
-
-static int do_gdm(struct gfs2_inode *dip, uint32_t index, uint32_t len,
-		  uint64_t leaf_no, void *data)
-{
-	struct gfs2_user_buffer *ub = (struct gfs2_user_buffer *)data;
-	struct gfs2_leaf leaf;
-	struct buffer_head *bh;
-	uint64_t blk;
-	int error = 0;
-
-	for (blk = leaf_no; blk; blk = leaf.lf_next) {
-		error = get_leaf(dip, blk, &bh);
-		if (error)
-			break;
-
-		gfs2_leaf_in(&leaf, bh->b_data);
-
-		error = gfs2_add_bh_to_ub(ub, bh);
-
-		brelse(bh);
-
-		if (error)
-			break;
-	}
-
-	return error;
-}
-
-/**
- * gfs2_get_dir_meta - return all the leaf blocks of a directory
- * @dip: the directory
- * @ub: the structure representing the meta
- *
- * Returns: errno
- */
-
-int gfs2_get_dir_meta(struct gfs2_inode *dip, struct gfs2_user_buffer *ub)
-{
-	return foreach_leaf(dip, do_gdm, ub);
-}
-

commit b3b94faa5fe5968827ba0640ee9fba4b3e7f736e
Author: David Teigland <teigland@redhat.com>
Date:   Mon Jan 16 16:50:04 2006 +0000

    [GFS2] The core of GFS2
    
    This patch contains all the core files for GFS2.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
new file mode 100644
index 000000000000..6b1dc3dc3a2d
--- /dev/null
+++ b/fs/gfs2/dir.c
@@ -0,0 +1,2157 @@
+/*
+ * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
+ * Copyright (C) 2004-2005 Red Hat, Inc.  All rights reserved.
+ *
+ * This copyrighted material is made available to anyone wishing to use,
+ * modify, copy, or redistribute it subject to the terms and conditions
+ * of the GNU General Public License v.2.
+ */
+
+/*
+* Implements Extendible Hashing as described in:
+*   "Extendible Hashing" by Fagin, et al in
+*     __ACM Trans. on Database Systems__, Sept 1979.
+*
+*
+* Here's the layout of dirents which is essentially the same as that of ext2
+* within a single block. The field de_name_len is the number of bytes
+* actually required for the name (no null terminator). The field de_rec_len
+* is the number of bytes allocated to the dirent. The offset of the next
+* dirent in the block is (dirent + dirent->de_rec_len). When a dirent is
+* deleted, the preceding dirent inherits its allocated space, ie
+* prev->de_rec_len += deleted->de_rec_len. Since the next dirent is obtained
+* by adding de_rec_len to the current dirent, this essentially causes the
+* deleted dirent to get jumped over when iterating through all the dirents.
+*
+* When deleting the first dirent in a block, there is no previous dirent so
+* the field de_ino is set to zero to designate it as deleted. When allocating
+* a dirent, gfs2_dirent_alloc iterates through the dirents in a block. If the
+* first dirent has (de_ino == 0) and de_rec_len is large enough, this first
+* dirent is allocated. Otherwise it must go through all the 'used' dirents
+* searching for one in which the amount of total space minus the amount of
+* used space will provide enough space for the new dirent.
+*
+* There are two types of blocks in which dirents reside. In a stuffed dinode,
+* the dirents begin at offset sizeof(struct gfs2_dinode) from the beginning of
+* the block.  In leaves, they begin at offset sizeof(struct gfs2_leaf) from the
+* beginning of the leaf block. The dirents reside in leaves when
+*
+* dip->i_di.di_flags & GFS2_DIF_EXHASH is true
+*
+* Otherwise, the dirents are "linear", within a single stuffed dinode block.
+*
+* When the dirents are in leaves, the actual contents of the directory file are
+* used as an array of 64-bit block pointers pointing to the leaf blocks. The
+* dirents are NOT in the directory file itself. There can be more than one block
+* pointer in the array that points to the same leaf. In fact, when a directory
+* is first converted from linear to exhash, all of the pointers point to the
+* same leaf.
+*
+* When a leaf is completely full, the size of the hash table can be
+* doubled unless it is already at the maximum size which is hard coded into
+* GFS2_DIR_MAX_DEPTH. After that, leaves are chained together in a linked list,
+* but never before the maximum hash table size has been reached.
+*/
+
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/completion.h>
+#include <linux/buffer_head.h>
+#include <linux/sort.h>
+#include <asm/semaphore.h>
+
+#include "gfs2.h"
+#include "dir.h"
+#include "glock.h"
+#include "inode.h"
+#include "jdata.h"
+#include "meta_io.h"
+#include "quota.h"
+#include "rgrp.h"
+#include "trans.h"
+
+#define IS_LEAF     1 /* Hashed (leaf) directory */
+#define IS_DINODE   2 /* Linear (stuffed dinode block) directory */
+
+#if 1
+#define gfs2_disk_hash2offset(h) (((uint64_t)(h)) >> 1)
+#define gfs2_dir_offset2hash(p) ((uint32_t)(((uint64_t)(p)) << 1))
+#else
+#define gfs2_disk_hash2offset(h) (((uint64_t)(h)))
+#define gfs2_dir_offset2hash(p) ((uint32_t)(((uint64_t)(p))))
+#endif
+
+typedef int (*leaf_call_t) (struct gfs2_inode *dip,
+			    uint32_t index, uint32_t len, uint64_t leaf_no,
+			    void *data);
+
+/**
+ * int gfs2_filecmp - Compare two filenames
+ * @file1: The first filename
+ * @file2: The second filename
+ * @len_of_file2: The length of the second file
+ *
+ * This routine compares two filenames and returns 1 if they are equal.
+ *
+ * Returns: 1 if the files are the same, otherwise 0.
+ */
+
+int gfs2_filecmp(struct qstr *file1, char *file2, int len_of_file2)
+{
+	if (file1->len != len_of_file2)
+		return 0;
+	if (memcmp(file1->name, file2, file1->len))
+		return 0;
+	return 1;
+}
+
+/**
+ * dirent_first - Return the first dirent
+ * @dip: the directory
+ * @bh: The buffer
+ * @dent: Pointer to list of dirents
+ *
+ * return first dirent whether bh points to leaf or stuffed dinode
+ *
+ * Returns: IS_LEAF, IS_DINODE, or -errno
+ */
+
+static int dirent_first(struct gfs2_inode *dip, struct buffer_head *bh,
+			struct gfs2_dirent **dent)
+{
+	struct gfs2_meta_header *h = (struct gfs2_meta_header *)bh->b_data;
+
+	if (be16_to_cpu(h->mh_type) == GFS2_METATYPE_LF) {
+		if (gfs2_meta_check(dip->i_sbd, bh))
+			return -EIO;
+		*dent = (struct gfs2_dirent *)(bh->b_data +
+					       sizeof(struct gfs2_leaf));
+		return IS_LEAF;
+	} else {
+		if (gfs2_metatype_check(dip->i_sbd, bh, GFS2_METATYPE_DI))
+			return -EIO;
+		*dent = (struct gfs2_dirent *)(bh->b_data +
+					       sizeof(struct gfs2_dinode));
+		return IS_DINODE;
+	}
+}
+
+/**
+ * dirent_next - Next dirent
+ * @dip: the directory
+ * @bh: The buffer
+ * @dent: Pointer to list of dirents
+ *
+ * Returns: 0 on success, error code otherwise
+ */
+
+static int dirent_next(struct gfs2_inode *dip, struct buffer_head *bh,
+		       struct gfs2_dirent **dent)
+{
+	struct gfs2_dirent *tmp, *cur;
+	char *bh_end;
+	uint32_t cur_rec_len;
+
+	cur = *dent;
+	bh_end = bh->b_data + bh->b_size;
+	cur_rec_len = be32_to_cpu(cur->de_rec_len);
+
+	if ((char *)cur + cur_rec_len >= bh_end) {
+		if ((char *)cur + cur_rec_len > bh_end) {
+			gfs2_consist_inode(dip);
+			return -EIO;
+		}
+		return -ENOENT;
+	}
+
+	tmp = (struct gfs2_dirent *)((char *)cur + cur_rec_len);
+
+	if ((char *)tmp + be32_to_cpu(tmp->de_rec_len) > bh_end) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+        /* Only the first dent could ever have de_inum.no_addr == 0 */
+	if (!tmp->de_inum.no_addr) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	*dent = tmp;
+
+	return 0;
+}
+
+/**
+ * dirent_del - Delete a dirent
+ * @dip: The GFS2 inode
+ * @bh: The buffer
+ * @prev: The previous dirent
+ * @cur: The current dirent
+ *
+ */
+
+static void dirent_del(struct gfs2_inode *dip, struct buffer_head *bh,
+		       struct gfs2_dirent *prev, struct gfs2_dirent *cur)
+{
+	uint32_t cur_rec_len, prev_rec_len;
+
+	if (!cur->de_inum.no_addr) {
+		gfs2_consist_inode(dip);
+		return;
+	}
+
+	gfs2_trans_add_bh(dip->i_gl, bh);
+
+	/* If there is no prev entry, this is the first entry in the block.
+	   The de_rec_len is already as big as it needs to be.  Just zero
+	   out the inode number and return.  */
+
+	if (!prev) {
+		cur->de_inum.no_addr = 0;	/* No endianess worries */
+		return;
+	}
+
+	/*  Combine this dentry with the previous one.  */
+
+	prev_rec_len = be32_to_cpu(prev->de_rec_len);
+	cur_rec_len = be32_to_cpu(cur->de_rec_len);
+
+	if ((char *)prev + prev_rec_len != (char *)cur)
+		gfs2_consist_inode(dip);
+	if ((char *)cur + cur_rec_len > bh->b_data + bh->b_size)
+		gfs2_consist_inode(dip);
+
+	prev_rec_len += cur_rec_len;
+	prev->de_rec_len = cpu_to_be32(prev_rec_len);
+}
+
+/**
+ * gfs2_dirent_alloc - Allocate a directory entry
+ * @dip: The GFS2 inode
+ * @bh: The buffer
+ * @name_len: The length of the name
+ * @dent_out: Pointer to list of dirents
+ *
+ * Returns: 0 on success, error code otherwise
+ */
+
+int gfs2_dirent_alloc(struct gfs2_inode *dip, struct buffer_head *bh,
+		      int name_len, struct gfs2_dirent **dent_out)
+{
+	struct gfs2_dirent *dent, *new;
+	unsigned int rec_len = GFS2_DIRENT_SIZE(name_len);
+	unsigned int entries = 0, offset = 0;
+	int type;
+
+	type = dirent_first(dip, bh, &dent);
+	if (type < 0)
+		return type;
+
+	if (type == IS_LEAF) {
+		struct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;
+		entries = be16_to_cpu(leaf->lf_entries);
+		offset = sizeof(struct gfs2_leaf);
+	} else {
+		struct gfs2_dinode *dinode = (struct gfs2_dinode *)bh->b_data;
+		entries = be32_to_cpu(dinode->di_entries);
+		offset = sizeof(struct gfs2_dinode);
+	}
+
+	if (!entries) {
+		if (dent->de_inum.no_addr) {
+			gfs2_consist_inode(dip);
+			return -EIO;
+		}
+
+		gfs2_trans_add_bh(dip->i_gl, bh);
+
+		dent->de_rec_len = bh->b_size - offset;
+		dent->de_rec_len = cpu_to_be32(dent->de_rec_len);
+		dent->de_name_len = name_len;
+
+		*dent_out = dent;
+		return 0;
+	}
+
+	do {
+		uint32_t cur_rec_len, cur_name_len;
+
+		cur_rec_len = be32_to_cpu(dent->de_rec_len);
+		cur_name_len = dent->de_name_len;
+
+		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
+		    (cur_rec_len >= GFS2_DIRENT_SIZE(cur_name_len) + rec_len)) {
+			gfs2_trans_add_bh(dip->i_gl, bh);
+
+			if (dent->de_inum.no_addr) {
+				new = (struct gfs2_dirent *)((char *)dent +
+							    GFS2_DIRENT_SIZE(cur_name_len));
+				memset(new, 0, sizeof(struct gfs2_dirent));
+
+				new->de_rec_len = cur_rec_len - GFS2_DIRENT_SIZE(cur_name_len);
+				new->de_rec_len = cpu_to_be32(new->de_rec_len);
+				new->de_name_len = name_len;
+
+				dent->de_rec_len = cur_rec_len - be32_to_cpu(new->de_rec_len);
+				dent->de_rec_len = cpu_to_be32(dent->de_rec_len);
+
+				*dent_out = new;
+				return 0;
+			}
+
+			dent->de_name_len = name_len;
+
+			*dent_out = dent;
+			return 0;
+		}
+	} while (dirent_next(dip, bh, &dent) == 0);
+
+	return -ENOSPC;
+}
+
+/**
+ * dirent_fits - See if we can fit a entry in this buffer
+ * @dip: The GFS2 inode
+ * @bh: The buffer
+ * @name_len: The length of the name
+ *
+ * Returns: 1 if it can fit, 0 otherwise
+ */
+
+static int dirent_fits(struct gfs2_inode *dip, struct buffer_head *bh,
+		       int name_len)
+{
+	struct gfs2_dirent *dent;
+	unsigned int rec_len = GFS2_DIRENT_SIZE(name_len);
+	unsigned int entries = 0;
+	int type;
+
+	type = dirent_first(dip, bh, &dent);
+	if (type < 0)
+		return type;
+
+	if (type == IS_LEAF) {
+		struct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;
+		entries = be16_to_cpu(leaf->lf_entries);
+	} else {
+		struct gfs2_dinode *dinode = (struct gfs2_dinode *)bh->b_data;
+		entries = be32_to_cpu(dinode->di_entries);
+	}
+
+	if (!entries)
+		return 1;
+
+	do {
+		uint32_t cur_rec_len, cur_name_len;
+
+		cur_rec_len = be32_to_cpu(dent->de_rec_len);
+		cur_name_len = dent->de_name_len;
+
+		if ((!dent->de_inum.no_addr && cur_rec_len >= rec_len) ||
+		    (cur_rec_len >= GFS2_DIRENT_SIZE(cur_name_len) + rec_len))
+			return 1;
+	} while (dirent_next(dip, bh, &dent) == 0);
+
+	return 0;
+}
+
+static int leaf_search(struct gfs2_inode *dip, struct buffer_head *bh,
+		       struct qstr *filename, struct gfs2_dirent **dent_out,
+		       struct gfs2_dirent **dent_prev)
+{
+	uint32_t hash;
+	struct gfs2_dirent *dent, *prev = NULL;
+	unsigned int entries = 0;
+	int type;
+
+	type = dirent_first(dip, bh, &dent);
+	if (type < 0)
+		return type;
+
+	if (type == IS_LEAF) {
+		struct gfs2_leaf *leaf = (struct gfs2_leaf *)bh->b_data;
+		entries = be16_to_cpu(leaf->lf_entries);
+	} else if (type == IS_DINODE) {
+		struct gfs2_dinode *dinode = (struct gfs2_dinode *)bh->b_data;
+		entries = be32_to_cpu(dinode->di_entries);
+	}
+
+	hash = gfs2_disk_hash(filename->name, filename->len);
+
+	do {
+		if (!dent->de_inum.no_addr) {
+			prev = dent;
+			continue;
+		}
+
+		if (be32_to_cpu(dent->de_hash) == hash &&
+		    gfs2_filecmp(filename, (char *)(dent + 1),
+				 dent->de_name_len)) {
+			*dent_out = dent;
+			if (dent_prev)
+				*dent_prev = prev;
+
+			return 0;
+		}
+
+		prev = dent;
+	} while (dirent_next(dip, bh, &dent) == 0);
+
+	return -ENOENT;
+}
+
+static int get_leaf(struct gfs2_inode *dip, uint64_t leaf_no,
+		    struct buffer_head **bhp)
+{
+	int error;
+
+	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_START | DIO_WAIT, bhp);
+	if (!error && gfs2_metatype_check(dip->i_sbd, *bhp, GFS2_METATYPE_LF))
+		error = -EIO;
+
+	return error;
+}
+
+/**
+ * get_leaf_nr - Get a leaf number associated with the index
+ * @dip: The GFS2 inode
+ * @index:
+ * @leaf_out:
+ *
+ * Returns: 0 on success, error code otherwise
+ */
+
+static int get_leaf_nr(struct gfs2_inode *dip, uint32_t index,
+		       uint64_t *leaf_out)
+{
+	uint64_t leaf_no;
+	int error;
+
+	error = gfs2_jdata_read_mem(dip, (char *)&leaf_no,
+				    index * sizeof(uint64_t),
+				    sizeof(uint64_t));
+	if (error != sizeof(uint64_t))
+		return (error < 0) ? error : -EIO;
+
+	*leaf_out = be64_to_cpu(leaf_no);
+
+	return 0;
+}
+
+static int get_first_leaf(struct gfs2_inode *dip, uint32_t index,
+			  struct buffer_head **bh_out)
+{
+	uint64_t leaf_no;
+	int error;
+
+	error = get_leaf_nr(dip, index, &leaf_no);
+	if (!error)
+		error = get_leaf(dip, leaf_no, bh_out);
+
+	return error;
+}
+
+static int get_next_leaf(struct gfs2_inode *dip, struct buffer_head *bh_in,
+			 struct buffer_head **bh_out)
+{
+	struct gfs2_leaf *leaf;
+	int error;
+
+	leaf = (struct gfs2_leaf *)bh_in->b_data;
+
+	if (!leaf->lf_next)
+		error = -ENOENT;
+	else
+		error = get_leaf(dip, be64_to_cpu(leaf->lf_next), bh_out);
+
+	return error;
+}
+
+static int linked_leaf_search(struct gfs2_inode *dip, struct qstr *filename,
+			      struct gfs2_dirent **dent_out,
+			      struct gfs2_dirent **dent_prev,
+			      struct buffer_head **bh_out)
+{
+	struct buffer_head *bh = NULL, *bh_next;
+	uint32_t hsize, index;
+	uint32_t hash;
+	int error;
+
+	hsize = 1 << dip->i_di.di_depth;
+	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	/*  Figure out the address of the leaf node.  */
+
+	hash = gfs2_disk_hash(filename->name, filename->len);
+	index = hash >> (32 - dip->i_di.di_depth);
+
+	error = get_first_leaf(dip, index, &bh_next);
+	if (error)
+		return error;
+
+	/*  Find the entry  */
+
+	do {
+		brelse(bh);
+
+		bh = bh_next;
+
+		error = leaf_search(dip, bh, filename, dent_out, dent_prev);
+		switch (error) {
+		case 0:
+			*bh_out = bh;
+			return 0;
+
+		case -ENOENT:
+			break;
+
+		default:
+			brelse(bh);
+			return error;
+		}
+
+		error = get_next_leaf(dip, bh, &bh_next);
+	}
+	while (!error);
+
+	brelse(bh);
+
+	return error;
+}
+
+/**
+ * dir_make_exhash - Convert a stuffed directory into an ExHash directory
+ * @dip: The GFS2 inode
+ *
+ * Returns: 0 on success, error code otherwise
+ */
+
+static int dir_make_exhash(struct gfs2_inode *dip)
+{
+	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct gfs2_dirent *dent;
+	struct buffer_head *bh, *dibh;
+	struct gfs2_leaf *leaf;
+	int y;
+	uint32_t x;
+	uint64_t *lp, bn;
+	int error;
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		return error;
+
+	/*  Allocate a new block for the first leaf node  */
+
+	bn = gfs2_alloc_meta(dip);
+
+	/*  Turn over a new leaf  */
+
+	bh = gfs2_meta_new(dip->i_gl, bn);
+	gfs2_trans_add_bh(dip->i_gl, bh);
+	gfs2_metatype_set(bh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
+	gfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));
+
+	/*  Fill in the leaf structure  */
+
+	leaf = (struct gfs2_leaf *)bh->b_data;
+
+	gfs2_assert(sdp, dip->i_di.di_entries < (1 << 16));
+
+	leaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);
+	leaf->lf_entries = cpu_to_be16(dip->i_di.di_entries);
+
+	/*  Copy dirents  */
+
+	gfs2_buffer_copy_tail(bh, sizeof(struct gfs2_leaf), dibh,
+			     sizeof(struct gfs2_dinode));
+
+	/*  Find last entry  */
+
+	x = 0;
+	dirent_first(dip, bh, &dent);
+
+	do {
+		if (!dent->de_inum.no_addr)
+			continue;
+		if (++x == dip->i_di.di_entries)
+			break;
+	}
+	while (dirent_next(dip, bh, &dent) == 0);
+
+	/*  Adjust the last dirent's record length
+	   (Remember that dent still points to the last entry.)  */
+
+	dent->de_rec_len = be32_to_cpu(dent->de_rec_len) +
+		sizeof(struct gfs2_dinode) -
+		sizeof(struct gfs2_leaf);
+	dent->de_rec_len = cpu_to_be32(dent->de_rec_len);
+
+	brelse(bh);
+
+	/*  We're done with the new leaf block, now setup the new
+	    hash table.  */
+
+	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));
+
+	lp = (uint64_t *)(dibh->b_data + sizeof(struct gfs2_dinode));
+
+	for (x = sdp->sd_hash_ptrs; x--; lp++)
+		*lp = cpu_to_be64(bn);
+
+	dip->i_di.di_size = sdp->sd_sb.sb_bsize / 2;
+	dip->i_di.di_blocks++;
+	dip->i_di.di_flags |= GFS2_DIF_EXHASH;
+	dip->i_di.di_payload_format = 0;
+
+	for (x = sdp->sd_hash_ptrs, y = -1; x; x >>= 1, y++) ;
+	dip->i_di.di_depth = y;
+
+	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+
+	brelse(dibh);
+
+	return 0;
+}
+
+/**
+ * dir_split_leaf - Split a leaf block into two
+ * @dip: The GFS2 inode
+ * @index:
+ * @leaf_no:
+ *
+ * Returns: 0 on success, error code on failure
+ */
+
+static int dir_split_leaf(struct gfs2_inode *dip, uint32_t index,
+			  uint64_t leaf_no)
+{
+	struct buffer_head *nbh, *obh, *dibh;
+	struct gfs2_leaf *nleaf, *oleaf;
+	struct gfs2_dirent *dent, *prev = NULL, *next = NULL, *new;
+	uint32_t start, len, half_len, divider;
+	uint64_t bn, *lp;
+	uint32_t name_len;
+	int x, moved = 0;
+	int error;
+
+	/*  Allocate the new leaf block  */
+
+	bn = gfs2_alloc_meta(dip);
+
+	/*  Get the new leaf block  */
+
+	nbh = gfs2_meta_new(dip->i_gl, bn);
+	gfs2_trans_add_bh(dip->i_gl, nbh);
+	gfs2_metatype_set(nbh, GFS2_METATYPE_LF, GFS2_FORMAT_LF);
+	gfs2_buffer_clear_tail(nbh, sizeof(struct gfs2_meta_header));
+
+	nleaf = (struct gfs2_leaf *)nbh->b_data;
+
+	nleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);
+
+	/*  Get the old leaf block  */
+
+	error = get_leaf(dip, leaf_no, &obh);
+	if (error)
+		goto fail;
+
+	gfs2_trans_add_bh(dip->i_gl, obh);
+
+	oleaf = (struct gfs2_leaf *)obh->b_data;
+
+	/*  Compute the start and len of leaf pointers in the hash table.  */
+
+	len = 1 << (dip->i_di.di_depth - be16_to_cpu(oleaf->lf_depth));
+	half_len = len >> 1;
+	if (!half_len) {
+		gfs2_consist_inode(dip);
+		error = -EIO;
+		goto fail_brelse;
+	}
+
+	start = (index & ~(len - 1));
+
+	/* Change the pointers.
+	   Don't bother distinguishing stuffed from non-stuffed.
+	   This code is complicated enough already. */
+
+	lp = kcalloc(half_len, sizeof(uint64_t), GFP_KERNEL | __GFP_NOFAIL);
+
+	error = gfs2_jdata_read_mem(dip, (char *)lp, start * sizeof(uint64_t),
+				    half_len * sizeof(uint64_t));
+	if (error != half_len * sizeof(uint64_t)) {
+		if (error >= 0)
+			error = -EIO;
+		goto fail_lpfree;
+	}
+
+	/*  Change the pointers  */
+
+	for (x = 0; x < half_len; x++)
+		lp[x] = cpu_to_be64(bn);
+
+	error = gfs2_jdata_write_mem(dip, (char *)lp, start * sizeof(uint64_t),
+				     half_len * sizeof(uint64_t));
+	if (error != half_len * sizeof(uint64_t)) {
+		if (error >= 0)
+			error = -EIO;
+		goto fail_lpfree;
+	}
+
+	kfree(lp);
+
+	/*  Compute the divider  */
+
+	divider = (start + half_len) << (32 - dip->i_di.di_depth);
+
+	/*  Copy the entries  */
+
+	dirent_first(dip, obh, &dent);
+
+	do {
+		next = dent;
+		if (dirent_next(dip, obh, &next))
+			next = NULL;
+
+		if (dent->de_inum.no_addr &&
+		    be32_to_cpu(dent->de_hash) < divider) {
+			name_len = dent->de_name_len;
+
+			gfs2_dirent_alloc(dip, nbh, name_len, &new);
+
+			new->de_inum = dent->de_inum; /* No endian worries */
+			new->de_hash = dent->de_hash; /* No endian worries */
+			new->de_type = dent->de_type; /* No endian worries */
+			memcpy((char *)(new + 1), (char *)(dent + 1),
+			       name_len);
+
+			nleaf->lf_entries = be16_to_cpu(nleaf->lf_entries)+1;
+			nleaf->lf_entries = cpu_to_be16(nleaf->lf_entries);
+
+			dirent_del(dip, obh, prev, dent);
+
+			if (!oleaf->lf_entries)
+				gfs2_consist_inode(dip);
+			oleaf->lf_entries = be16_to_cpu(oleaf->lf_entries)-1;
+			oleaf->lf_entries = cpu_to_be16(oleaf->lf_entries);
+
+			if (!prev)
+				prev = dent;
+
+			moved = 1;
+		} else
+			prev = dent;
+
+		dent = next;
+	}
+	while (dent);
+
+	/* If none of the entries got moved into the new leaf,
+	   artificially fill in the first entry. */
+
+	if (!moved) {
+		gfs2_dirent_alloc(dip, nbh, 0, &new);
+		new->de_inum.no_addr = 0;
+	}
+
+	oleaf->lf_depth = be16_to_cpu(oleaf->lf_depth) + 1;
+	oleaf->lf_depth = cpu_to_be16(oleaf->lf_depth);
+	nleaf->lf_depth = oleaf->lf_depth;
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (!gfs2_assert_withdraw(dip->i_sbd, !error)) {
+		dip->i_di.di_blocks++;
+		gfs2_dinode_out(&dip->i_di, dibh->b_data);
+		brelse(dibh);
+	}
+
+	brelse(obh);
+	brelse(nbh);
+
+	return error;
+
+ fail_lpfree:
+	kfree(lp);
+
+ fail_brelse:
+	brelse(obh);
+
+ fail:
+	brelse(nbh);
+	return error;
+}
+
+/**
+ * dir_double_exhash - Double size of ExHash table
+ * @dip: The GFS2 dinode
+ *
+ * Returns: 0 on success, error code on failure
+ */
+
+static int dir_double_exhash(struct gfs2_inode *dip)
+{
+	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct buffer_head *dibh;
+	uint32_t hsize;
+	uint64_t *buf;
+	uint64_t *from, *to;
+	uint64_t block;
+	int x;
+	int error = 0;
+
+	hsize = 1 << dip->i_di.di_depth;
+	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	/*  Allocate both the "from" and "to" buffers in one big chunk  */
+
+	buf = kcalloc(3, sdp->sd_hash_bsize, GFP_KERNEL | __GFP_NOFAIL);
+
+	for (block = dip->i_di.di_size >> sdp->sd_hash_bsize_shift; block--;) {
+		error = gfs2_jdata_read_mem(dip, (char *)buf,
+					    block * sdp->sd_hash_bsize,
+					    sdp->sd_hash_bsize);
+		if (error != sdp->sd_hash_bsize) {
+			if (error >= 0)
+				error = -EIO;
+			goto fail;
+		}
+
+		from = buf;
+		to = (uint64_t *)((char *)buf + sdp->sd_hash_bsize);
+
+		for (x = sdp->sd_hash_ptrs; x--; from++) {
+			*to++ = *from;	/*  No endianess worries  */
+			*to++ = *from;
+		}
+
+		error = gfs2_jdata_write_mem(dip,
+					     (char *)buf + sdp->sd_hash_bsize,
+					     block * sdp->sd_sb.sb_bsize,
+					     sdp->sd_sb.sb_bsize);
+		if (error != sdp->sd_sb.sb_bsize) {
+			if (error >= 0)
+				error = -EIO;
+			goto fail;
+		}
+	}
+
+	kfree(buf);
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (!gfs2_assert_withdraw(sdp, !error)) {
+		dip->i_di.di_depth++;
+		gfs2_dinode_out(&dip->i_di, dibh->b_data);
+		brelse(dibh);
+	}
+
+	return error;
+
+ fail:
+	kfree(buf);
+
+	return error;
+}
+
+/**
+ * compare_dents - compare directory entries by hash value
+ * @a: first dent
+ * @b: second dent
+ *
+ * When comparing the hash entries of @a to @b:
+ *   gt: returns 1
+ *   lt: returns -1
+ *   eq: returns 0
+ */
+
+static int compare_dents(const void *a, const void *b)
+{
+	struct gfs2_dirent *dent_a, *dent_b;
+	uint32_t hash_a, hash_b;
+	int ret = 0;
+
+	dent_a = *(struct gfs2_dirent **)a;
+	hash_a = dent_a->de_hash;
+	hash_a = be32_to_cpu(hash_a);
+
+	dent_b = *(struct gfs2_dirent **)b;
+	hash_b = dent_b->de_hash;
+	hash_b = be32_to_cpu(hash_b);
+
+	if (hash_a > hash_b)
+		ret = 1;
+	else if (hash_a < hash_b)
+		ret = -1;
+	else {
+		unsigned int len_a = dent_a->de_name_len;
+		unsigned int len_b = dent_b->de_name_len;
+
+		if (len_a > len_b)
+			ret = 1;
+		else if (len_a < len_b)
+			ret = -1;
+		else
+			ret = memcmp((char *)(dent_a + 1),
+				     (char *)(dent_b + 1),
+				     len_a);
+	}
+
+	return ret;
+}
+
+/**
+ * do_filldir_main - read out directory entries
+ * @dip: The GFS2 inode
+ * @offset: The offset in the file to read from
+ * @opaque: opaque data to pass to filldir
+ * @filldir: The function to pass entries to
+ * @darr: an array of struct gfs2_dirent pointers to read
+ * @entries: the number of entries in darr
+ * @copied: pointer to int that's non-zero if a entry has been copied out
+ *
+ * Jump through some hoops to make sure that if there are hash collsions,
+ * they are read out at the beginning of a buffer.  We want to minimize
+ * the possibility that they will fall into different readdir buffers or
+ * that someone will want to seek to that location.
+ *
+ * Returns: errno, >0 on exception from filldir
+ */
+
+static int do_filldir_main(struct gfs2_inode *dip, uint64_t *offset,
+			   void *opaque, gfs2_filldir_t filldir,
+			   struct gfs2_dirent **darr, uint32_t entries,
+			   int *copied)
+{
+	struct gfs2_dirent *dent, *dent_next;
+	struct gfs2_inum inum;
+	uint64_t off, off_next;
+	unsigned int x, y;
+	int run = 0;
+	int error = 0;
+
+	sort(darr, entries, sizeof(struct gfs2_dirent *), compare_dents, NULL);
+
+	dent_next = darr[0];
+	off_next = be32_to_cpu(dent_next->de_hash);
+	off_next = gfs2_disk_hash2offset(off_next);
+
+	for (x = 0, y = 1; x < entries; x++, y++) {
+		dent = dent_next;
+		off = off_next;
+
+		if (y < entries) {
+			dent_next = darr[y];
+			off_next = be32_to_cpu(dent_next->de_hash);
+			off_next = gfs2_disk_hash2offset(off_next);
+
+			if (off < *offset)
+				continue;
+			*offset = off;
+
+			if (off_next == off) {
+				if (*copied && !run)
+					return 1;
+				run = 1;
+			} else
+				run = 0;
+		} else {
+			if (off < *offset)
+				continue;
+			*offset = off;
+		}
+
+		gfs2_inum_in(&inum, (char *)&dent->de_inum);
+
+		error = filldir(opaque, (char *)(dent + 1),
+				dent->de_name_len,
+				off, &inum,
+				dent->de_type);
+		if (error)
+			return 1;
+
+		*copied = 1;
+	}
+
+	/* Increment the *offset by one, so the next time we come into the
+	   do_filldir fxn, we get the next entry instead of the last one in the
+	   current leaf */
+
+	(*offset)++;
+
+	return 0;
+}
+
+/**
+ * do_filldir_single - Read directory entries out of a single block
+ * @dip: The GFS2 inode
+ * @offset: The offset in the file to read from
+ * @opaque: opaque data to pass to filldir
+ * @filldir: The function to pass entries to
+ * @bh: the block
+ * @entries: the number of entries in the block
+ * @copied: pointer to int that's non-zero if a entry has been copied out
+ *
+ * Returns: errno, >0 on exception from filldir
+ */
+
+static int do_filldir_single(struct gfs2_inode *dip, uint64_t *offset,
+			     void *opaque, gfs2_filldir_t filldir,
+			     struct buffer_head *bh, uint32_t entries,
+			     int *copied)
+{
+	struct gfs2_dirent **darr;
+	struct gfs2_dirent *de;
+	unsigned int e = 0;
+	int error;
+
+	if (!entries)
+		return 0;
+
+	darr = kcalloc(entries, sizeof(struct gfs2_dirent *), GFP_KERNEL);
+	if (!darr)
+		return -ENOMEM;
+
+	dirent_first(dip, bh, &de);
+	do {
+		if (!de->de_inum.no_addr)
+			continue;
+		if (e >= entries) {
+			gfs2_consist_inode(dip);
+			error = -EIO;
+			goto out;
+		}
+		darr[e++] = de;
+	}
+	while (dirent_next(dip, bh, &de) == 0);
+
+	if (e != entries) {
+		gfs2_consist_inode(dip);
+		error = -EIO;
+		goto out;
+	}
+
+	error = do_filldir_main(dip, offset, opaque, filldir, darr,
+				entries, copied);
+
+ out:
+	kfree(darr);
+
+	return error;
+}
+
+/**
+ * do_filldir_multi - Read directory entries out of a linked leaf list
+ * @dip: The GFS2 inode
+ * @offset: The offset in the file to read from
+ * @opaque: opaque data to pass to filldir
+ * @filldir: The function to pass entries to
+ * @bh: the first leaf in the list
+ * @copied: pointer to int that's non-zero if a entry has been copied out
+ *
+ * Returns: errno, >0 on exception from filldir
+ */
+
+static int do_filldir_multi(struct gfs2_inode *dip, uint64_t *offset,
+			    void *opaque, gfs2_filldir_t filldir,
+			    struct buffer_head *bh, int *copied)
+{
+	struct buffer_head **larr = NULL;
+	struct gfs2_dirent **darr;
+	struct gfs2_leaf *leaf;
+	struct buffer_head *tmp_bh;
+	struct gfs2_dirent *de;
+	unsigned int entries, e = 0;
+	unsigned int leaves = 0, l = 0;
+	unsigned int x;
+	uint64_t ln;
+	int error = 0;
+
+	/*  Count leaves and entries  */
+
+	leaf = (struct gfs2_leaf *)bh->b_data;
+	entries = be16_to_cpu(leaf->lf_entries);
+	ln = leaf->lf_next;
+
+	while (ln) {
+		ln = be64_to_cpu(ln);
+
+		error = get_leaf(dip, ln, &tmp_bh);
+		if (error)
+			return error;
+
+		leaf = (struct gfs2_leaf *)tmp_bh->b_data;
+		if (leaf->lf_entries) {
+			entries += be16_to_cpu(leaf->lf_entries);
+			leaves++;
+		}
+		ln = leaf->lf_next;
+
+		brelse(tmp_bh);
+	}
+
+	if (!entries)
+		return 0;
+
+	if (leaves) {
+		larr = kcalloc(leaves, sizeof(struct buffer_head *),GFP_KERNEL);
+		if (!larr)
+			return -ENOMEM;
+	}
+
+	darr = kcalloc(entries, sizeof(struct gfs2_dirent *), GFP_KERNEL);
+	if (!darr) {
+		kfree(larr);
+		return -ENOMEM;
+	}
+
+	leaf = (struct gfs2_leaf *)bh->b_data;
+	if (leaf->lf_entries) {
+		dirent_first(dip, bh, &de);
+		do {
+			if (!de->de_inum.no_addr)
+				continue;
+			if (e >= entries) {
+				gfs2_consist_inode(dip);
+				error = -EIO;
+				goto out;
+			}
+			darr[e++] = de;
+		}
+		while (dirent_next(dip, bh, &de) == 0);
+	}
+	ln = leaf->lf_next;
+
+	while (ln) {
+		ln = be64_to_cpu(ln);
+
+		error = get_leaf(dip, ln, &tmp_bh);
+		if (error)
+			goto out;
+
+		leaf = (struct gfs2_leaf *)tmp_bh->b_data;
+		if (leaf->lf_entries) {
+			dirent_first(dip, tmp_bh, &de);
+			do {
+				if (!de->de_inum.no_addr)
+					continue;
+				if (e >= entries) {
+					gfs2_consist_inode(dip);
+					error = -EIO;
+					goto out;
+				}
+				darr[e++] = de;
+			}
+			while (dirent_next(dip, tmp_bh, &de) == 0);
+
+			larr[l++] = tmp_bh;
+
+			ln = leaf->lf_next;
+		} else {
+			ln = leaf->lf_next;
+			brelse(tmp_bh);
+		}
+	}
+
+	if (gfs2_assert_withdraw(dip->i_sbd, l == leaves)) {
+		error = -EIO;
+		goto out;
+	}
+	if (e != entries) {
+		gfs2_consist_inode(dip);
+		error = -EIO;
+		goto out;
+	}
+
+	error = do_filldir_main(dip, offset, opaque, filldir, darr,
+				entries, copied);
+
+ out:
+	kfree(darr);
+	for (x = 0; x < l; x++)
+		brelse(larr[x]);
+	kfree(larr);
+
+	return error;
+}
+
+/**
+ * dir_e_search - Search exhash (leaf) dir for inode matching name
+ * @dip: The GFS2 inode
+ * @filename: Filename string
+ * @inode: If non-NULL, function fills with formal inode # and block address
+ * @type: If non-NULL, function fills with DT_... dinode type
+ *
+ * Returns:
+ */
+
+static int dir_e_search(struct gfs2_inode *dip, struct qstr *filename,
+			struct gfs2_inum *inum, unsigned int *type)
+{
+	struct buffer_head *bh;
+	struct gfs2_dirent *dent;
+	int error;
+
+	error = linked_leaf_search(dip, filename, &dent, NULL, &bh);
+	if (error)
+		return error;
+
+	if (inum)
+		gfs2_inum_in(inum, (char *)&dent->de_inum);
+	if (type)
+		*type = dent->de_type;
+
+	brelse(bh);
+
+	return 0;
+}
+
+static int dir_e_add(struct gfs2_inode *dip, struct qstr *filename,
+		     struct gfs2_inum *inum, unsigned int type)
+{
+	struct buffer_head *bh, *nbh, *dibh;
+	struct gfs2_leaf *leaf, *nleaf;
+	struct gfs2_dirent *dent;
+	uint32_t hsize, index;
+	uint32_t hash;
+	uint64_t leaf_no, bn;
+	int error;
+
+ restart:
+	hsize = 1 << dip->i_di.di_depth;
+	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	/*  Figure out the address of the leaf node.  */
+
+	hash = gfs2_disk_hash(filename->name, filename->len);
+	index = hash >> (32 - dip->i_di.di_depth);
+
+	error = get_leaf_nr(dip, index, &leaf_no);
+	if (error)
+		return error;
+
+	/*  Add entry to the leaf  */
+
+	for (;;) {
+		error = get_leaf(dip, leaf_no, &bh);
+		if (error)
+			return error;
+
+		leaf = (struct gfs2_leaf *)bh->b_data;
+
+		if (gfs2_dirent_alloc(dip, bh, filename->len, &dent)) {
+
+			if (be16_to_cpu(leaf->lf_depth) < dip->i_di.di_depth) {
+				/* Can we split the leaf? */
+
+				brelse(bh);
+
+				error = dir_split_leaf(dip, index, leaf_no);
+				if (error)
+					return error;
+
+				goto restart;
+
+			} else if (dip->i_di.di_depth < GFS2_DIR_MAX_DEPTH) {
+				/* Can we double the hash table? */
+
+				brelse(bh);
+
+				error = dir_double_exhash(dip);
+				if (error)
+					return error;
+
+				goto restart;
+
+			} else if (leaf->lf_next) {
+				/* Can we try the next leaf in the list? */
+				leaf_no = be64_to_cpu(leaf->lf_next);
+				brelse(bh);
+				continue;
+
+			} else {
+				/* Create a new leaf and add it to the list. */
+
+				bn = gfs2_alloc_meta(dip);
+
+				nbh = gfs2_meta_new(dip->i_gl, bn);
+				gfs2_trans_add_bh(dip->i_gl, nbh);
+				gfs2_metatype_set(nbh,
+						 GFS2_METATYPE_LF,
+						 GFS2_FORMAT_LF);
+				gfs2_buffer_clear_tail(nbh,
+					sizeof(struct gfs2_meta_header));
+
+				gfs2_trans_add_bh(dip->i_gl, bh);
+				leaf->lf_next = cpu_to_be64(bn);
+
+				nleaf = (struct gfs2_leaf *)nbh->b_data;
+				nleaf->lf_depth = leaf->lf_depth;
+				nleaf->lf_dirent_format = cpu_to_be32(GFS2_FORMAT_DE);
+
+				gfs2_dirent_alloc(dip, nbh, filename->len,
+						  &dent);
+
+				dip->i_di.di_blocks++;
+
+				brelse(bh);
+
+				bh = nbh;
+				leaf = nleaf;
+			}
+		}
+
+		/* If the gfs2_dirent_alloc() succeeded, it pinned the "bh" */
+
+		gfs2_inum_out(inum, (char *)&dent->de_inum);
+		dent->de_hash = cpu_to_be32(hash);
+		dent->de_type = type;
+		memcpy((char *)(dent + 1), filename->name, filename->len);
+
+		leaf->lf_entries = be16_to_cpu(leaf->lf_entries) + 1;
+		leaf->lf_entries = cpu_to_be16(leaf->lf_entries);
+
+		brelse(bh);
+
+		error = gfs2_meta_inode_buffer(dip, &dibh);
+		if (error)
+			return error;
+
+		dip->i_di.di_entries++;
+		dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+
+		gfs2_trans_add_bh(dip->i_gl, dibh);
+		gfs2_dinode_out(&dip->i_di, dibh->b_data);
+		brelse(dibh);
+
+		return 0;
+	}
+
+	return -ENOENT;
+}
+
+static int dir_e_del(struct gfs2_inode *dip, struct qstr *filename)
+{
+	struct buffer_head *bh, *dibh;
+	struct gfs2_dirent *dent, *prev;
+	struct gfs2_leaf *leaf;
+	unsigned int entries;
+	int error;
+
+	error = linked_leaf_search(dip, filename, &dent, &prev, &bh);
+	if (error == -ENOENT) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+	if (error)
+		return error;
+
+	dirent_del(dip, bh, prev, dent); /* Pins bh */
+
+	leaf = (struct gfs2_leaf *)bh->b_data;
+	entries = be16_to_cpu(leaf->lf_entries);
+	if (!entries)
+		gfs2_consist_inode(dip);
+	entries--;
+	leaf->lf_entries = cpu_to_be16(entries);
+
+	brelse(bh);
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		return error;
+
+	if (!dip->i_di.di_entries)
+		gfs2_consist_inode(dip);
+	dip->i_di.di_entries--;
+	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+
+	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+	brelse(dibh);
+
+	return 0;
+}
+
+/**
+ * dir_e_read - Reads the entries from a directory into a filldir buffer
+ * @dip: dinode pointer
+ * @offset: the hash of the last entry read shifted to the right once
+ * @opaque: buffer for the filldir function to fill
+ * @filldir: points to the filldir function to use
+ *
+ * Returns: errno
+ */
+
+static int dir_e_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
+		      gfs2_filldir_t filldir)
+{
+	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct buffer_head *bh;
+	struct gfs2_leaf leaf;
+	uint32_t hsize, len;
+	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
+	uint32_t hash, index;
+	uint64_t *lp;
+	int copied = 0;
+	int error = 0;
+
+	hsize = 1 << dip->i_di.di_depth;
+	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	hash = gfs2_dir_offset2hash(*offset);
+	index = hash >> (32 - dip->i_di.di_depth);
+
+	lp = kmalloc(sdp->sd_hash_bsize, GFP_KERNEL);
+	if (!lp)
+		return -ENOMEM;
+
+	while (index < hsize) {
+		lp_offset = index & (sdp->sd_hash_ptrs - 1);
+		ht_offset = index - lp_offset;
+
+		if (ht_offset_cur != ht_offset) {
+			error = gfs2_jdata_read_mem(dip, (char *)lp,
+						ht_offset * sizeof(uint64_t),
+						sdp->sd_hash_bsize);
+			if (error != sdp->sd_hash_bsize) {
+				if (error >= 0)
+					error = -EIO;
+				goto out;
+			}
+			ht_offset_cur = ht_offset;
+		}
+
+		error = get_leaf(dip, be64_to_cpu(lp[lp_offset]), &bh);
+		if (error)
+			goto out;
+
+		gfs2_leaf_in(&leaf, bh->b_data);
+
+		if (leaf.lf_next)
+			error = do_filldir_multi(dip, offset, opaque, filldir,
+						 bh, &copied);
+		else
+			error = do_filldir_single(dip, offset, opaque, filldir,
+						  bh, leaf.lf_entries, &copied);
+
+		brelse(bh);
+
+		if (error) {
+			if (error > 0)
+				error = 0;
+			goto out;
+		}
+
+		len = 1 << (dip->i_di.di_depth - leaf.lf_depth);
+		index = (index & ~(len - 1)) + len;
+	}
+
+ out:
+	kfree(lp);
+
+	return error;
+}
+
+static int dir_e_mvino(struct gfs2_inode *dip, struct qstr *filename,
+		       struct gfs2_inum *inum, unsigned int new_type)
+{
+	struct buffer_head *bh, *dibh;
+	struct gfs2_dirent *dent;
+	int error;
+
+	error = linked_leaf_search(dip, filename, &dent, NULL, &bh);
+	if (error == -ENOENT) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+	if (error)
+		return error;
+
+	gfs2_trans_add_bh(dip->i_gl, bh);
+
+	gfs2_inum_out(inum, (char *)&dent->de_inum);
+	dent->de_type = new_type;
+
+	brelse(bh);
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		return error;
+
+	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+
+	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+	brelse(dibh);
+
+	return 0;
+}
+
+/**
+ * dir_l_search - Search linear (stuffed dinode) dir for inode matching name
+ * @dip: The GFS2 inode
+ * @filename: Filename string
+ * @inode: If non-NULL, function fills with formal inode # and block address
+ * @type: If non-NULL, function fills with DT_... dinode type
+ *
+ * Returns:
+ */
+
+static int dir_l_search(struct gfs2_inode *dip, struct qstr *filename,
+			struct gfs2_inum *inum, unsigned int *type)
+{
+	struct buffer_head *dibh;
+	struct gfs2_dirent *dent;
+	int error;
+
+	if (!gfs2_is_stuffed(dip)) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		return error;
+
+	error = leaf_search(dip, dibh, filename, &dent, NULL);
+	if (!error) {
+		if (inum)
+			gfs2_inum_in(inum, (char *)&dent->de_inum);
+		if (type)
+			*type = dent->de_type;
+	}
+
+	brelse(dibh);
+
+	return error;
+}
+
+static int dir_l_add(struct gfs2_inode *dip, struct qstr *filename,
+		     struct gfs2_inum *inum, unsigned int type)
+{
+	struct buffer_head *dibh;
+	struct gfs2_dirent *dent;
+	int error;
+
+	if (!gfs2_is_stuffed(dip)) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		return error;
+
+	if (gfs2_dirent_alloc(dip, dibh, filename->len, &dent)) {
+		brelse(dibh);
+
+		error = dir_make_exhash(dip);
+		if (!error)
+			error = dir_e_add(dip, filename, inum, type);
+
+		return error;
+	}
+
+	/*  gfs2_dirent_alloc() pins  */
+
+	gfs2_inum_out(inum, (char *)&dent->de_inum);
+	dent->de_hash = gfs2_disk_hash(filename->name, filename->len);
+	dent->de_hash = cpu_to_be32(dent->de_hash);
+	dent->de_type = type;
+	memcpy((char *)(dent + 1), filename->name, filename->len);
+
+	dip->i_di.di_entries++;
+	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+
+	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+	brelse(dibh);
+
+	return 0;
+}
+
+static int dir_l_del(struct gfs2_inode *dip, struct qstr *filename)
+{
+	struct buffer_head *dibh;
+	struct gfs2_dirent *dent, *prev;
+	int error;
+
+	if (!gfs2_is_stuffed(dip)) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		return error;
+
+	error = leaf_search(dip, dibh, filename, &dent, &prev);
+	if (error == -ENOENT) {
+		gfs2_consist_inode(dip);
+		error = -EIO;
+		goto out;
+	}
+	if (error)
+		goto out;
+
+	dirent_del(dip, dibh, prev, dent);
+
+	/*  dirent_del() pins  */
+
+	if (!dip->i_di.di_entries)
+		gfs2_consist_inode(dip);
+	dip->i_di.di_entries--;
+
+	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+
+	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+
+ out:
+	brelse(dibh);
+
+	return error;
+}
+
+static int dir_l_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
+		      gfs2_filldir_t filldir)
+{
+	struct buffer_head *dibh;
+	int copied = 0;
+	int error;
+
+	if (!gfs2_is_stuffed(dip)) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	if (!dip->i_di.di_entries)
+		return 0;
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		return error;
+
+	error = do_filldir_single(dip, offset,
+				  opaque, filldir,
+				  dibh, dip->i_di.di_entries,
+				  &copied);
+	if (error > 0)
+		error = 0;
+
+	brelse(dibh);
+
+	return error;
+}
+
+static int dir_l_mvino(struct gfs2_inode *dip, struct qstr *filename,
+		       struct gfs2_inum *inum, unsigned int new_type)
+{
+	struct buffer_head *dibh;
+	struct gfs2_dirent *dent;
+	int error;
+
+	if (!gfs2_is_stuffed(dip)) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		return error;
+
+	error = leaf_search(dip, dibh, filename, &dent, NULL);
+	if (error == -ENOENT) {
+		gfs2_consist_inode(dip);
+		error = -EIO;
+		goto out;
+	}
+	if (error)
+		goto out;
+
+	gfs2_trans_add_bh(dip->i_gl, dibh);
+
+	gfs2_inum_out(inum, (char *)&dent->de_inum);
+	dent->de_type = new_type;
+
+	dip->i_di.di_mtime = dip->i_di.di_ctime = get_seconds();
+
+	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+
+ out:
+	brelse(dibh);
+
+	return error;
+}
+
+/**
+ * gfs2_dir_search - Search a directory
+ * @dip: The GFS2 inode
+ * @filename:
+ * @inode:
+ *
+ * This routine searches a directory for a file or another directory.
+ * Assumes a glock is held on dip.
+ *
+ * Returns: errno
+ */
+
+int gfs2_dir_search(struct gfs2_inode *dip, struct qstr *filename,
+		    struct gfs2_inum *inum, unsigned int *type)
+{
+	int error;
+
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
+		error = dir_e_search(dip, filename, inum, type);
+	else
+		error = dir_l_search(dip, filename, inum, type);
+
+	return error;
+}
+
+/**
+ * gfs2_dir_add - Add new filename into directory
+ * @dip: The GFS2 inode
+ * @filename: The new name
+ * @inode: The inode number of the entry
+ * @type: The type of the entry
+ *
+ * Returns: 0 on success, error code on failure
+ */
+
+int gfs2_dir_add(struct gfs2_inode *dip, struct qstr *filename,
+		 struct gfs2_inum *inum, unsigned int type)
+{
+	int error;
+
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
+		error = dir_e_add(dip, filename, inum, type);
+	else
+		error = dir_l_add(dip, filename, inum, type);
+
+	return error;
+}
+
+/**
+ * gfs2_dir_del - Delete a directory entry
+ * @dip: The GFS2 inode
+ * @filename: The filename
+ *
+ * Returns: 0 on success, error code on failure
+ */
+
+int gfs2_dir_del(struct gfs2_inode *dip, struct qstr *filename)
+{
+	int error;
+
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
+		error = dir_e_del(dip, filename);
+	else
+		error = dir_l_del(dip, filename);
+
+	return error;
+}
+
+int gfs2_dir_read(struct gfs2_inode *dip, uint64_t *offset, void *opaque,
+		  gfs2_filldir_t filldir)
+{
+	int error;
+
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
+		error = dir_e_read(dip, offset, opaque, filldir);
+	else
+		error = dir_l_read(dip, offset, opaque, filldir);
+
+	return error;
+}
+
+/**
+ * gfs2_dir_mvino - Change inode number of directory entry
+ * @dip: The GFS2 inode
+ * @filename:
+ * @new_inode:
+ *
+ * This routine changes the inode number of a directory entry.  It's used
+ * by rename to change ".." when a directory is moved.
+ * Assumes a glock is held on dvp.
+ *
+ * Returns: errno
+ */
+
+int gfs2_dir_mvino(struct gfs2_inode *dip, struct qstr *filename,
+		   struct gfs2_inum *inum, unsigned int new_type)
+{
+	int error;
+
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH)
+		error = dir_e_mvino(dip, filename, inum, new_type);
+	else
+		error = dir_l_mvino(dip, filename, inum, new_type);
+
+	return error;
+}
+
+/**
+ * foreach_leaf - call a function for each leaf in a directory
+ * @dip: the directory
+ * @lc: the function to call for each each
+ * @data: private data to pass to it
+ *
+ * Returns: errno
+ */
+
+static int foreach_leaf(struct gfs2_inode *dip, leaf_call_t lc, void *data)
+{
+	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct buffer_head *bh;
+	struct gfs2_leaf leaf;
+	uint32_t hsize, len;
+	uint32_t ht_offset, lp_offset, ht_offset_cur = -1;
+	uint32_t index = 0;
+	uint64_t *lp;
+	uint64_t leaf_no;
+	int error = 0;
+
+	hsize = 1 << dip->i_di.di_depth;
+	if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+		gfs2_consist_inode(dip);
+		return -EIO;
+	}
+
+	lp = kmalloc(sdp->sd_hash_bsize, GFP_KERNEL);
+	if (!lp)
+		return -ENOMEM;
+
+	while (index < hsize) {
+		lp_offset = index & (sdp->sd_hash_ptrs - 1);
+		ht_offset = index - lp_offset;
+
+		if (ht_offset_cur != ht_offset) {
+			error = gfs2_jdata_read_mem(dip, (char *)lp,
+						ht_offset * sizeof(uint64_t),
+						sdp->sd_hash_bsize);
+			if (error != sdp->sd_hash_bsize) {
+				if (error >= 0)
+					error = -EIO;
+				goto out;
+			}
+			ht_offset_cur = ht_offset;
+		}
+
+		leaf_no = be64_to_cpu(lp[lp_offset]);
+		if (leaf_no) {
+			error = get_leaf(dip, leaf_no, &bh);
+			if (error)
+				goto out;
+			gfs2_leaf_in(&leaf, bh->b_data);
+			brelse(bh);
+
+			len = 1 << (dip->i_di.di_depth - leaf.lf_depth);
+
+			error = lc(dip, index, len, leaf_no, data);
+			if (error)
+				goto out;
+
+			index = (index & ~(len - 1)) + len;
+		} else
+			index++;
+	}
+
+	if (index != hsize) {
+		gfs2_consist_inode(dip);
+		error = -EIO;
+	}
+
+ out:
+	kfree(lp);
+
+	return error;
+}
+
+/**
+ * leaf_dealloc - Deallocate a directory leaf
+ * @dip: the directory
+ * @index: the hash table offset in the directory
+ * @len: the number of pointers to this leaf
+ * @leaf_no: the leaf number
+ * @data: not used
+ *
+ * Returns: errno
+ */
+
+static int leaf_dealloc(struct gfs2_inode *dip, uint32_t index, uint32_t len,
+			uint64_t leaf_no, void *data)
+{
+	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct gfs2_leaf tmp_leaf;
+	struct gfs2_rgrp_list rlist;
+	struct buffer_head *bh, *dibh;
+	uint64_t blk;
+	unsigned int rg_blocks = 0, l_blocks = 0;
+	char *ht;
+	unsigned int x, size = len * sizeof(uint64_t);
+	int error;
+
+	memset(&rlist, 0, sizeof(struct gfs2_rgrp_list));
+
+	ht = kzalloc(size, GFP_KERNEL);
+	if (!ht)
+		return -ENOMEM;
+
+	gfs2_alloc_get(dip);
+
+	error = gfs2_quota_hold(dip, NO_QUOTA_CHANGE, NO_QUOTA_CHANGE);
+	if (error)
+		goto out;
+
+	error = gfs2_rindex_hold(sdp, &dip->i_alloc.al_ri_gh);
+	if (error)
+		goto out_qs;
+
+	/*  Count the number of leaves  */
+
+	for (blk = leaf_no; blk; blk = tmp_leaf.lf_next) {
+		error = get_leaf(dip, blk, &bh);
+		if (error)
+			goto out_rlist;
+		gfs2_leaf_in(&tmp_leaf, (bh)->b_data);
+		brelse(bh);
+
+		gfs2_rlist_add(sdp, &rlist, blk);
+		l_blocks++;
+	}
+
+	gfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE, 0);
+
+	for (x = 0; x < rlist.rl_rgrps; x++) {
+		struct gfs2_rgrpd *rgd;
+		rgd = get_gl2rgd(rlist.rl_ghs[x].gh_gl);
+		rg_blocks += rgd->rd_ri.ri_length;
+	}
+
+	error = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);
+	if (error)
+		goto out_rlist;
+
+	error = gfs2_trans_begin(sdp,
+			rg_blocks + (DIV_RU(size, sdp->sd_jbsize) + 1) +
+			RES_DINODE + RES_STATFS + RES_QUOTA, l_blocks);
+	if (error)
+		goto out_rg_gunlock;
+
+	for (blk = leaf_no; blk; blk = tmp_leaf.lf_next) {
+		error = get_leaf(dip, blk, &bh);
+		if (error)
+			goto out_end_trans;
+		gfs2_leaf_in(&tmp_leaf, bh->b_data);
+		brelse(bh);
+
+		gfs2_free_meta(dip, blk, 1);
+
+		if (!dip->i_di.di_blocks)
+			gfs2_consist_inode(dip);
+		dip->i_di.di_blocks--;
+	}
+
+	error = gfs2_jdata_write_mem(dip, ht, index * sizeof(uint64_t), size);
+	if (error != size) {
+		if (error >= 0)
+			error = -EIO;
+		goto out_end_trans;
+	}
+
+	error = gfs2_meta_inode_buffer(dip, &dibh);
+	if (error)
+		goto out_end_trans;
+
+	gfs2_trans_add_bh(dip->i_gl, dibh);
+	gfs2_dinode_out(&dip->i_di, dibh->b_data);
+	brelse(dibh);
+
+ out_end_trans:
+	gfs2_trans_end(sdp);
+
+ out_rg_gunlock:
+	gfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);
+
+ out_rlist:
+	gfs2_rlist_free(&rlist);
+	gfs2_glock_dq_uninit(&dip->i_alloc.al_ri_gh);
+
+ out_qs:
+	gfs2_quota_unhold(dip);
+
+ out:
+	gfs2_alloc_put(dip);
+	kfree(ht);
+
+	return error;
+}
+
+/**
+ * gfs2_dir_exhash_dealloc - free all the leaf blocks in a directory
+ * @dip: the directory
+ *
+ * Dealloc all on-disk directory leaves to FREEMETA state
+ * Change on-disk inode type to "regular file"
+ *
+ * Returns: errno
+ */
+
+int gfs2_dir_exhash_dealloc(struct gfs2_inode *dip)
+{
+	struct gfs2_sbd *sdp = dip->i_sbd;
+	struct buffer_head *bh;
+	int error;
+
+	/* Dealloc on-disk leaves to FREEMETA state */
+	error = foreach_leaf(dip, leaf_dealloc, NULL);
+	if (error)
+		return error;
+
+	/* Make this a regular file in case we crash.
+	   (We don't want to free these blocks a second time.)  */
+
+	error = gfs2_trans_begin(sdp, RES_DINODE, 0);
+	if (error)
+		return error;
+
+	error = gfs2_meta_inode_buffer(dip, &bh);
+	if (!error) {
+		gfs2_trans_add_bh(dip->i_gl, bh);
+		((struct gfs2_dinode *)bh->b_data)->di_mode = cpu_to_be32(S_IFREG);
+		brelse(bh);
+	}
+
+	gfs2_trans_end(sdp);
+
+	return error;
+}
+
+/**
+ * gfs2_diradd_alloc_required - find if adding entry will require an allocation
+ * @ip: the file being written to
+ * @filname: the filename that's going to be added
+ * @alloc_required: set to 1 if an alloc is required, 0 otherwise
+ *
+ * Returns: errno
+ */
+
+int gfs2_diradd_alloc_required(struct gfs2_inode *dip, struct qstr *filename,
+			       int *alloc_required)
+{
+	struct buffer_head *bh = NULL, *bh_next;
+	uint32_t hsize, hash, index;
+	int error = 0;
+
+	*alloc_required = 0;
+
+	if (dip->i_di.di_flags & GFS2_DIF_EXHASH) {
+		hsize = 1 << dip->i_di.di_depth;
+		if (hsize * sizeof(uint64_t) != dip->i_di.di_size) {
+			gfs2_consist_inode(dip);
+			return -EIO;
+		}
+
+		hash = gfs2_disk_hash(filename->name, filename->len);
+		index = hash >> (32 - dip->i_di.di_depth);
+
+		error = get_first_leaf(dip, index, &bh_next);
+		if (error)
+			return error;
+
+		do {
+			brelse(bh);
+
+			bh = bh_next;
+
+			if (dirent_fits(dip, bh, filename->len))
+				break;
+
+			error = get_next_leaf(dip, bh, &bh_next);
+			if (error == -ENOENT) {
+				*alloc_required = 1;
+				error = 0;
+				break;
+			}
+		}
+		while (!error);
+
+		brelse(bh);
+	} else {
+		error = gfs2_meta_inode_buffer(dip, &bh);
+		if (error)
+			return error;
+
+		if (!dirent_fits(dip, bh, filename->len))
+			*alloc_required = 1;
+
+		brelse(bh);
+	}
+
+	return error;
+}
+
+/**
+ * do_gdm - copy out one leaf (or list of leaves)
+ * @dip: the directory
+ * @index: the hash table offset in the directory
+ * @len: the number of pointers to this leaf
+ * @leaf_no: the leaf number
+ * @data: a pointer to a struct gfs2_user_buffer structure
+ *
+ * Returns: errno
+ */
+
+static int do_gdm(struct gfs2_inode *dip, uint32_t index, uint32_t len,
+		  uint64_t leaf_no, void *data)
+{
+	struct gfs2_user_buffer *ub = (struct gfs2_user_buffer *)data;
+	struct gfs2_leaf leaf;
+	struct buffer_head *bh;
+	uint64_t blk;
+	int error = 0;
+
+	for (blk = leaf_no; blk; blk = leaf.lf_next) {
+		error = get_leaf(dip, blk, &bh);
+		if (error)
+			break;
+
+		gfs2_leaf_in(&leaf, bh->b_data);
+
+		error = gfs2_add_bh_to_ub(ub, bh);
+
+		brelse(bh);
+
+		if (error)
+			break;
+	}
+
+	return error;
+}
+
+/**
+ * gfs2_get_dir_meta - return all the leaf blocks of a directory
+ * @dip: the directory
+ * @ub: the structure representing the meta
+ *
+ * Returns: errno
+ */
+
+int gfs2_get_dir_meta(struct gfs2_inode *dip, struct gfs2_user_buffer *ub)
+{
+	return foreach_leaf(dip, do_gdm, ub);
+}
+
