commit 1595548fe72ca834abe75fb3df47e300a087d563
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Mar 6 10:32:35 2020 -0600

    gfs2: Split gfs2_rsqa_delete into gfs2_rs_delete and gfs2_qa_put
    
    Keeping reservations and quotas separate helps reviewing the code.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 92cebb785996..a1d7e14fc55b 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -45,7 +45,7 @@ extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 			     bool dinode, u64 *generation);
 
 extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
-extern void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount);
+extern void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,
 			       u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,

commit d580712a37272182cb63002878f3bb7bcebbb8bd
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Mar 6 10:18:44 2020 -0600

    gfs2: eliminate gfs2_rsqa_alloc in favor of gfs2_qa_alloc
    
    Before this patch, multiple callers called gfs2_rsqa_alloc to force
    the existence of a reservations structure and a quota data structure
    if needed. However, now the reservations are handled separately, so
    the quota data is only the quota data. So we eliminate the one in
    favor of just calling gfs2_qa_alloc directly.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index a584f3096418..92cebb785996 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -44,7 +44,6 @@ extern void gfs2_inplace_release(struct gfs2_inode *ip);
 extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 			     bool dinode, u64 *generation);
 
-extern int gfs2_rsqa_alloc(struct gfs2_inode *ip);
 extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
 extern void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,

commit b3422cacdd7e623e473b4c3977f3ee65e1fed62f
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Nov 13 11:50:30 2019 -0600

    gfs2: Rework how rgrp buffer_heads are managed
    
    Before this patch, the rgrp code had a serious problem related to
    how it managed buffer_heads for resource groups. The problem caused
    file system corruption, especially in cases of journal replay.
    
    When an rgrp glock was demoted to transfer ownership to a
    different cluster node, do_xmote() first calls rgrp_go_sync and then
    rgrp_go_inval, as expected. When it calls rgrp_go_sync, that called
    gfs2_rgrp_brelse() that dropped the buffer_head reference count.
    In most cases, the reference count went to zero, which is right.
    However, there were other places where the buffers are handled
    differently.
    
    After rgrp_go_sync, do_xmote called rgrp_go_inval which called
    gfs2_rgrp_brelse a second time, then rgrp_go_inval's call to
    truncate_inode_pages_range would get rid of the pages in memory,
    but only if the reference count drops to 0.
    
    Unfortunately, gfs2_rgrp_brelse was setting bi->bi_bh = NULL.
    So when rgrp_go_sync called gfs2_rgrp_brelse, it lost the pointer
    to the buffer_heads in cases where the reference count was still 1.
    Therefore, when rgrp_go_inval called gfs2_rgrp_brelse a second time,
    it failed the check for "if (bi->bi_bh)" and thus failed to call
    brelse a second time. Because of that, the reference count on those
    buffers sometimes failed to drop from 1 to 0. And that caused
    function truncate_inode_pages_range to keep the pages in page cache
    rather than freeing them.
    
    The next time the rgrp glock was acquired, the metadata read of
    the rgrp buffers re-used the pages in memory, which were now
    wrong because they were likely modified by the other node who
    acquired the glock in EX (which is why we demoted the glock).
    This re-use of the page cache caused corruption because changes
    made by the other nodes were never seen, so the bitmaps were
    inaccurate.
    
    For some reason, the problem became most apparent when journal
    replay forced the replay of rgrps in memory, which caused newer
    rgrp data to be overwritten by the older in-core pages.
    
    A big part of the problem was that the rgrp buffer were released
    in multiple places: The go_unlock function would release them when
    the glock was released rather than when the glock is demoted,
    which is clearly wrong because our intent was to cache them until
    the glock is demoted from SH or EX.
    
    This patch attempts to clean up the mess and make one consistent
    and centralized mechanism for managing the rgrp buffer_heads by
    implementing several changes:
    
    1. It eliminates the call to gfs2_rgrp_brelse() from rgrp_go_sync.
       We don't want to release the buffers or zero the pointers when
       syncing for the reasons stated above. It only makes sense to
       release them when the glock is actually invalidated (go_inval).
       And when we do, then we set the bh pointers to NULL.
    2. The go_unlock function (which was only used for rgrps) is
       eliminated, as we've talked about doing many times before.
       The go_unlock function was called too early in the glock dq
       process, and should not happen until the glock is invalidated.
    3. It also eliminates the call to rgrp_brelse in gfs2_clear_rgrpd.
       That will now happen automatically when the rgrp glocks are
       demoted, and shouldn't happen any sooner or later than that.
       Instead, function gfs2_clear_rgrpd has been modified to demote
       the rgrp glocks, and therefore, free those pages, before the
       remaining glocks are culled by gfs2_gl_hash_clear. This
       prevents the gl_object from hanging around when the glocks are
       culled.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index c14a673ae36f..a584f3096418 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -33,7 +33,6 @@ extern int gfs2_rindex_update(struct gfs2_sbd *sdp);
 extern void gfs2_free_clones(struct gfs2_rgrpd *rgd);
 extern int gfs2_rgrp_go_lock(struct gfs2_holder *gh);
 extern void gfs2_rgrp_brelse(struct gfs2_rgrpd *rgd);
-extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 
 extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
 

commit 3792ce973f07a2644fd81424b9acacb12530a3cf
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu May 9 09:21:48 2019 -0500

    gfs2: dump fsid when dumping glock problems
    
    Before this patch, if a glock error was encountered, the glock with
    the problem was dumped. But sometimes you may have lots of file systems
    mounted, and that doesn't tell you which file system it was for.
    
    This patch adds a new boolean parameter fsid to the dump_glock family
    of functions. For non-error cases, such as dumping the glocks debugfs
    file, the fsid is not dumped in order to keep lock dumps and glocktop
    as clean as possible. For all error cases, such as GLOCK_BUG_ON, the
    file system id is now printed. This will make it easier to debug.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 6a3adf0ee0b7..c14a673ae36f 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -69,7 +69,8 @@ extern void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,
 extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist);
 extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
 extern u64 gfs2_ri_total(struct gfs2_sbd *sdp);
-extern void gfs2_rgrp_dump(struct seq_file *seq, struct gfs2_glock *gl);
+extern void gfs2_rgrp_dump(struct seq_file *seq, struct gfs2_glock *gl,
+			   const char *fs_id_buf);
 extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 				   struct buffer_head *bh,
 				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);

commit 7336d0e654f7acc0ecee33a8ae68c4fd1c1c44b5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 398
    
    Based on 1 normalized pattern(s):
    
      this copyrighted material is made available to anyone wishing to use
      modify copy or redistribute it subject to the terms and conditions
      of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081038.653000175@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 499079a9dbbe..6a3adf0ee0b7 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
  * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.
- *
- * This copyrighted material is made available to anyone wishing to use,
- * modify, copy, or redistribute it subject to the terms and conditions
- * of the GNU General Public License version 2.
  */
 
 #ifndef __RGRP_DOT_H__

commit 27a2660f1ef944724956d92e8a312b6da0936fae
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Apr 18 12:05:01 2018 -0700

    gfs2: Dump nrpages for inodes and their glocks
    
    This patch is based on an idea from Steve Whitehouse. The idea is
    to dump the number of pages for inodes in the glock dumps.
    The additional locking required me to drop const from quite a few
    places.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index b596c3d17988..499079a9dbbe 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -72,7 +72,7 @@ extern void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,
 extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist);
 extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
 extern u64 gfs2_ri_total(struct gfs2_sbd *sdp);
-extern void gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl);
+extern void gfs2_rgrp_dump(struct seq_file *seq, struct gfs2_glock *gl);
 extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 				   struct buffer_head *bh,
 				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);

commit 0ddeded4ae768882e5c3a5558f77f27e4e445a6a
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Oct 4 15:36:02 2018 +0100

    gfs2: Pass resource group to rgblk_free
    
    Function rgblk_free can only deal with one resource group at a time, so
    pass that resource group is as a parameter.  Several of the callers
    already have the resource group at hand, so we only need additional
    lookup code in a few places.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 09519ae10fb6..b596c3d17988 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -51,8 +51,10 @@ extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 extern int gfs2_rsqa_alloc(struct gfs2_inode *ip);
 extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
 extern void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount);
-extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
-extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
+extern void __gfs2_free_blocks(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,
+			       u64 bstart, u32 blen, int meta);
+extern void gfs2_free_meta(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,
+			   u64 bstart, u32 blen);
 extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
 extern void gfs2_unlink_di(struct inode *inode);
 extern int gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr,

commit c3abc29e54a14953ddb26feeb62dd02d57925e52
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Oct 4 00:06:23 2018 +0100

    gfs2: Remove unnecessary gfs2_rlist_alloc parameter
    
    The state parameter of gfs2_rlist_alloc is set to LM_ST_EXCLUSIVE in all
    calls, so remove it and hardcode that state in gfs2_rlist_alloc instead.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 6bb5ee112324..09519ae10fb6 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -67,7 +67,7 @@ struct gfs2_rgrp_list {
 
 extern void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,
 			   u64 block);
-extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
+extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist);
 extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
 extern u64 gfs2_ri_total(struct gfs2_sbd *sdp);
 extern void gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl);

commit ad8994581815ac08123c7eeceb2ef160a96d186d
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Tue Sep 25 12:59:31 2018 +0100

    gfs2: Remove unused RGRP_RSRV_MINBYTES definition
    
    This definition is only used to define RGRP_RSRV_MINBLKS, with no
    benefit over defining RGRP_RSRV_MINBLKS directly.
    
    In addition, instead of forcing RGRP_RSRV_MINBLKS to be of type u32,
    cast it to that type where that type is required.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index e90478e2f545..6bb5ee112324 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -18,8 +18,7 @@
  * By reserving 32 blocks at a time, we can optimize / shortcut how we search
  * through the bitmaps by looking a word at a time.
  */
-#define RGRP_RSRV_MINBYTES 8
-#define RGRP_RSRV_MINBLKS ((u32)(RGRP_RSRV_MINBYTES * GFS2_NBBY))
+#define RGRP_RSRV_MINBLKS 32
 #define RGRP_RSRV_ADDBLKS 64
 
 struct gfs2_rgrpd;

commit d552a2b9b33eafdb5eb16c643e745deb564dda7f
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Feb 6 08:28:32 2017 -0500

    GFS2: Non-recursive delete
    
    Implement truncate/delete as a non-recursive algorithm. The older
    algorithm was implemented with recursion to strip off each layer
    at a time (going by height, starting with the maximum height.
    This version tries to do the same thing but without recursion,
    and without needing to allocate new structures or lists in memory.
    
    For example, say you want to truncate a very large file to 1 byte,
    and its end-of-file metapath is: 0.505.463.428. The starting
    metapath would be 0.0.0.0. Since it's a truncate to non-zero, it
    needs to preserve that byte, and all metadata pointing to it.
    So it would start at 0.0.0.0, look up all its metadata buffers,
    then free all data blocks pointed to at the highest level.
    After that buffer is "swept", it moves on to 0.0.0.1, then
    0.0.0.2, etc., reading in buffers and sweeping them clean.
    When it gets to the end of the 0.0.0 metadata buffer (for 4K
    blocks the last valid one is 0.0.0.508), it backs up to the
    previous height and starts working on 0.0.1.0, then 0.0.1.1,
    and so forth. After it reaches the end and sweeps 0.0.1.508,
    it continues with 0.0.2.0, and so on. When that height is
    exhausted, and it reaches 0.0.508.508 it backs up another level,
    to 0.1.0.0, then 0.1.0.1, through 0.1.0.508. So it has to keep
    marching backwards and forwards through the metadata until it's
    all swept clean. Once it has all the data blocks freed, it
    lowers the strip height, and begins the process all over again,
    but with one less height. This time it sweeps 0.0.0 through
    0.505.463. When that's clean, it lowers the strip height again
    and works to free 0.505. Eventually it strips the lowest height, 0.
    For a delete or truncate to 0, all metadata for all heights of
    0.0.0.0 would be freed. For a truncate to 1 byte, 0.0.0.0 would
    be preserved.
    
    This isn't much different from normal integer incrementing,
    where an integer gets incremented from 0000 (0.0.0.0) to 3021
    (3.0.2.1). So 0000 gets increments to 0001, 0002, up to 0009,
    then on to 0010, 0011 up to 0099, then 0100 and so forth. It's
    just that each "digit" goes from 0 to 508 (for a total of 509
    pointers) rather than from 0 to 9.
    
    Note that the dinode will only have 483 pointers due to the
    dinode structure itself.
    
    Also note: this is just an example. These numbers (509 and 483)
    are based on a standard 4K block size. Smaller block sizes will
    yield smaller numbers of indirect pointers accordingly.
    
    The truncation process is accomplished with the help of two
    major functions and a few helper functions.
    
    Functions do_strip and recursive_scan are obsolete, so removed.
    
    New function sweep_bh_for_rgrps cleans a buffer_head pointed to
    by the given metapath and height. By cleaning, I mean it frees
    all blocks starting at the offset passed in metapath. It starts
    at the first block in the buffer pointed to by the metapath and
    identifies its resource group (rgrp). From there it frees all
    subsequent block pointers that lie within that rgrp. If it's
    already inside a transaction, it stays within it as long as it
    can. In other words, it doesn't close a transaction until it knows
    it's freed what it can from the resource group. In this way,
    multiple buffers may be cleaned in a single transaction, as long
    as those blocks in the buffer all lie within the same rgrp.
    
    If it's not in a transaction, it starts one. If the buffer_head
    has references to blocks within multiple rgrps, it frees all the
    blocks inside the first rgrp it finds, then closes the
    transaction. Then it repeats the cycle: identifies the next
    unfreed block, uses it to find its rgrp, then starts a new
    transaction for that set. It repeats this process repeatedly
    until the buffer_head contains no more references to any blocks
    past the given metapath.
    
    Function trunc_dealloc has been reworked into a finite state
    automaton. It has basically 3 active states:
    DEALLOC_MP_FULL, DEALLOC_MP_LOWER, and DEALLOC_FILL_MP:
    
    The DEALLOC_MP_FULL state implies the metapath has a full set
    of buffers out to the "shrink height", and therefore, it can
    call function sweep_bh_for_rgrps to free the blocks within the
    highest height of the metapath. If it's just swept the lowest
    level (or an error has occurred) the state machine is ended.
    Otherwise it proceeds to the DEALLOC_MP_LOWER state.
    
    The DEALLOC_MP_LOWER state implies we are finished with a given
    buffer_head, which may now be released, and therefore we are
    then missing some buffer information from the metapath. So we
    need to find more buffers to read in. In most cases, this is
    just a matter of releasing the buffer_head and moving to the
    next pointer from the previous height, so it may be read in and
    swept as well. If it can't find another non-null pointer to
    process, it checks whether it's reached the end of a height
    and needs to lower the strip height, or whether it still needs
    move forward through the previous height's metadata. In this
    state, all zero-pointers are skipped. From this state, it can
    only loop around (once more backing up another height) or,
    once a valid metapath is found (one that has non-zero
    pointers), proceed to state DEALLOC_FILL_MP.
    
    The DEALLOC_FILL_MP state implies that we have a metapath
    but not all its buffers are read in. So we must proceed to read
    in buffer_heads until the metapath has a valid buffer for every
    height. If the previous state backed us up 3 heights, we may
    need to read in a buffer, increment the height, then repeat the
    process until buffers have been read in for all required heights.
    If it's successful reading a buffer, and it's at the highest
    height we need, it proceeds back to the DEALLOC_MP_FULL state.
    If it's unable to fill in a buffer, (encounters a hole, etc.)
    it tries to find another non-zero block pointer. If they're all
    zero, it lowers the height and returns to the DEALLOC_MP_LOWER
    state. If it finds a good non-null pointer, it loops around and
    reads it in, while keeping the metapath in lock-step with the
    pointers it examines.
    
    The state machine runs until the truncation request is
    satisfied. Then any transactions are ended, the quota and
    statfs data are updated, and the function is complete.
    
    Helper function metaptr1 was introduced to be an easy way to
    determine the start of a buffer_head's indirect pointers.
    
    Helper function lookup_mp_height was introduced to find a
    metapath index and read in the buffer that corresponds to it.
    In this way, function lookup_metapath becomes a simple loop to
    call it for every height.
    
    Helper function fillup_metapath is similar to lookup_metapath
    except it can do partial lookups. If the state machine
    backed up multiple levels (like 2999 wrapping to 3000) it
    needs to find out the next starting point and start issuing
    metadata reads at that point.
    
    Helper function hptrs is a shortcut to determine how many
    pointers should be expected in a buffer. Height 0 is the dinode
    which has fewer pointers than the others.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 66b51cf66dfa..e90478e2f545 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -83,5 +83,12 @@ static inline bool gfs2_rs_active(const struct gfs2_blkreserv *rs)
 	return rs && !RB_EMPTY_NODE(&rs->rs_node);
 }
 
+static inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)
+{
+	u64 first = rgd->rd_data0;
+	u64 last = first + rgd->rd_data;
+	return first <= block && block < last;
+}
+
 extern void check_and_update_goal(struct gfs2_inode *ip);
 #endif /* __RGRP_DOT_H__ */

commit a097dc7e24cba7980bc5e2df461a4ef228e97e59
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Jul 16 08:28:04 2015 -0500

    GFS2: Make rgrp reservations part of the gfs2_inode structure
    
    Before this patch, multi-block reservation structures were allocated
    from a special slab. This patch folds the structure into the gfs2_inode
    structure. The disadvantage is that the gfs2_inode needs more memory,
    even when a file is opened read-only. The advantages are: (a) we don't
    need the special slab and the extra time it takes to allocate and
    deallocate from it. (b) we no longer need to worry that the structure
    exists for things like quota management. (c) This also allows us to
    remove the calls to get_write_access and put_write_access since we
    know the structure will exist.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 06bbefaabc31..66b51cf66dfa 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -78,7 +78,7 @@ extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 extern int gfs2_fitrim(struct file *filp, void __user *argp);
 
 /* This is how to tell if a reservation is in the rgrp tree: */
-static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)
+static inline bool gfs2_rs_active(const struct gfs2_blkreserv *rs)
 {
 	return rs && !RB_EMPTY_NODE(&rs->rs_node);
 }

commit b54e9a0b92d44843f6719ae22b0f6daf5b9b23b4
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Oct 26 10:40:28 2015 -0500

    GFS2: Extract quota data from reservations structure (revert 5407e24)
    
    This patch basically reverts the majority of patch 5407e24.
    That patch eliminated the gfs2_qadata structure in favor of just
    using the reservations structure. The problem with doing that is that
    it increases the size of the reservations structure. That is not an
    issue until it comes time to fold the reservations structure into the
    inode in memory so we know it's always there. By separating out the
    quota structure again, we aren't punishing the non-quota users by
    making all the inodes bigger, requiring more slab space. This patch
    creates a new slab area to allocate the quota stuff so it's managed
    a little more sanely.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index c0ab33fa3eed..06bbefaabc31 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -49,9 +49,9 @@ extern void gfs2_inplace_release(struct gfs2_inode *ip);
 extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 			     bool dinode, u64 *generation);
 
-extern int gfs2_rs_alloc(struct gfs2_inode *ip);
+extern int gfs2_rsqa_alloc(struct gfs2_inode *ip);
 extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
-extern void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount);
+extern void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);

commit 39b0f1e9290880a6c905f639e7db6b646e302a4f
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Jun 5 08:38:57 2015 -0500

    GFS2: Don't brelse rgrp buffer_heads every allocation
    
    This patch allows the block allocation code to retain the buffers
    for the resource groups so they don't need to be re-read from buffer
    cache with every request. This is a performance improvement that's
    especially noticeable when resource groups are very large. For
    example, with 2GB resource groups and 4K blocks, there can be 33
    blocks for every resource group. This patch allows those 33 buffers
    to be kept around and not read in and thrown away with every
    operation. The buffers are released when the resource group is
    either synced or invalidated.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>
    Reviewed-by: Benjamin Marzinski <bmarzins@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 68972ecfbb01..c0ab33fa3eed 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -36,6 +36,7 @@ extern void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);
 extern int gfs2_rindex_update(struct gfs2_sbd *sdp);
 extern void gfs2_free_clones(struct gfs2_rgrpd *rgd);
 extern int gfs2_rgrp_go_lock(struct gfs2_holder *gh);
+extern void gfs2_rgrp_brelse(struct gfs2_rgrpd *rgd);
 extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 
 extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);

commit 25435e5ed611f310dda889940cbc4c45b3ecd9ec
Author: Abhi Das <adas@redhat.com>
Date:   Wed Mar 18 12:04:37 2015 -0500

    gfs2: allow quota_check and inplace_reserve to return available blocks
    
    struct gfs2_alloc_parms is passed to gfs2_quota_check() and
    gfs2_inplace_reserve() with ap->target containing the number of
    blocks being requested for allocation in the current operation.
    
    We add a new field to struct gfs2_alloc_parms called 'allowed'.
    gfs2_quota_check() and gfs2_inplace_reserve() return the max
    blocks allowed by quota and the max blocks allowed by the chosen
    rgrp respectively in 'allowed'.
    
    A new field 'min_target', when non-zero, tells gfs2_quota_check()
    and gfs2_inplace_reserve() to not return -EDQUOT/-ENOSPC when
    there are atleast 'min_target' blocks allowable/available. The
    assumption is that the caller is ok with just 'min_target' blocks
    and will likely proceed with allocating them.
    
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index b104f4af3afd..68972ecfbb01 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -41,7 +41,8 @@ extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
 
 #define GFS2_AF_ORLOV 1
-extern int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap);
+extern int gfs2_inplace_reserve(struct gfs2_inode *ip,
+				struct gfs2_alloc_parms *ap);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
 extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,

commit 1a8550332a7f0111306b6b34e44a7c696ef68c4d
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Oct 29 08:02:30 2014 -0500

    GFS2: If we use up our block reservation, request more next time
    
    If we run out of blocks for a given multi-block allocation, we obviously
    did not reserve enough. We should reserve more blocks for the next
    reservation to reduce fragmentation. This patch increases the size hint
    for reservations when they run out.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 5d8f085f7ade..b104f4af3afd 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -20,6 +20,7 @@
  */
 #define RGRP_RSRV_MINBYTES 8
 #define RGRP_RSRV_MINBLKS ((u32)(RGRP_RSRV_MINBYTES * GFS2_NBBY))
+#define RGRP_RSRV_ADDBLKS 64
 
 struct gfs2_rgrpd;
 struct gfs2_sbd;

commit 00a158be83839f2d5370612d633eb2643ddf844e
Author: Abhi Das <adas@redhat.com>
Date:   Thu Sep 18 21:40:28 2014 -0500

    GFS2: fix bad inode i_goal values during block allocation
    
    This patch checks if i_goal is either zero or if doesn't exist
    within any rgrp (i.e gfs2_blk2rgrpd() returns NULL). If so, it
    assigns the ip->i_no_addr block as the i_goal.
    
    There are two scenarios where a bad i_goal can result in a
    -EBADSLT error.
    
    1. Attempting to allocate to an existing inode:
    Control reaches gfs2_inplace_reserve() and ip->i_goal is bad.
    We need to fix i_goal here.
    
    2. A new inode is created in a directory whose i_goal is hosed:
    In this case, the parent dir's i_goal is copied onto the new
    inode. Since the new inode is not yet created, the ip->i_no_addr
    field is invalid and so, the fix in gfs2_inplace_reserve() as per
    1) won't work in this scenario. We need to catch and fix it sooner
    in the parent dir itself (gfs2_create_inode()), before it is
    copied to the new inode.
    
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 463ab2e95d1c..5d8f085f7ade 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -80,4 +80,5 @@ static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)
 	return rs && !RB_EMPTY_NODE(&rs->rs_node);
 }
 
+extern void check_and_update_goal(struct gfs2_inode *ip);
 #endif /* __RGRP_DOT_H__ */

commit ac3beb6a5de048e7c0676f630ad2048a7b37b305
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jan 16 10:31:13 2014 +0000

    GFS2: Don't use ENOBUFS when ENOMEM is the correct error code
    
    Al Viro has tactfully pointed out that we are using the incorrect
    error code in some cases. This patch fixes that, and also removes
    the (unused) return value for glock dumping.
    
    >        * gfs2_iget() - ENOBUFS instead of ENOMEM.  ENOBUFS is
    > "No buffer space available (POSIX.1 (XSI STREAMS option))" and since
    > we don't support STREAMS it's probably fair game, but... what the hell?
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 3a10d2ffbbe7..463ab2e95d1c 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -68,7 +68,7 @@ extern void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,
 extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
 extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
 extern u64 gfs2_ri_total(struct gfs2_sbd *sdp);
-extern int gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl);
+extern void gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl);
 extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 				   struct buffer_head *bh,
 				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);

commit 7b9cff467144c8c62268db1b0948df089caa0999
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Oct 2 11:13:25 2013 +0100

    GFS2: Add allocation parameters structure
    
    This patch adds a structure to contain allocation parameters with
    the intention of future expansion of this structure. The idea is
    that we should be able to add more information about the allocation
    in the future in order to allow the allocator to make a better job
    of placing the requests on-disk.
    
    There is no functional difference from applying this patch.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 57ea16ba3414..3a10d2ffbbe7 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -40,7 +40,7 @@ extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
 
 #define GFS2_AF_ORLOV 1
-extern int gfs2_inplace_reserve(struct gfs2_inode *ip, u32 requested, u32 flags);
+extern int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
 extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,

commit af5c269799feaef110e59ce55b497cdd08712b0c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 27 12:49:33 2013 +0100

    GFS2: Clean up reservation removal
    
    The reservation for an inode should be cleared when it is truncated so
    that we can start again at a different offset for future allocations.
    We could try and do better than that, by resetting the search based on
    where the truncation started from, but this is only a first step.
    
    In addition, there are three callers of gfs2_rs_delete() but only one
    of those should really be testing the value of i_writecount. While
    we get away with that in the other cases currently, I think it would
    be better if we made that test specific to the one case which
    requires it.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 5b3f4a896e6c..57ea16ba3414 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -48,7 +48,7 @@ extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 
 extern int gfs2_rs_alloc(struct gfs2_inode *ip);
 extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
-extern void gfs2_rs_delete(struct gfs2_inode *ip);
+extern void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);

commit 20095218fb882139527c0e04b8e63869fa057b14
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Mar 13 10:26:38 2013 -0400

    GFS2: Remove vestigial parameter ip from function rs_deltree
    
    The functions that delete block reservations from the rgrp block
    reservations rbtree no longer use the ip parameter. This patch
    eliminates the parameter.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 842185853f6b..5b3f4a896e6c 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -47,7 +47,7 @@ extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 			     bool dinode, u64 *generation);
 
 extern int gfs2_rs_alloc(struct gfs2_inode *ip);
-extern void gfs2_rs_deltree(struct gfs2_inode *ip, struct gfs2_blkreserv *rs);
+extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
 extern void gfs2_rs_delete(struct gfs2_inode *ip);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);

commit 9dbe9610b9df4efe0946299804ed46bb8f91dec2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Oct 31 10:37:10 2012 +0000

    GFS2: Add Orlov allocator
    
    Just like ext3, this works on the root directory and any directory
    with the +T flag set. Also, just like ext3, any subdirectory created
    in one of the just mentioned cases will be allocated to a random
    resource group (GFS2 equivalent of a block group).
    
    If you are creating a set of directories, each of which will contain a
    job running on a different node, then by setting +T on the parent
    directory before creating the subdirectories, each will land up in a
    different resource group, and thus resource group contention between
    nodes will be kept to a minimum.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 24077958dcf6..842185853f6b 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -39,7 +39,8 @@ extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 
 extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
 
-extern int gfs2_inplace_reserve(struct gfs2_inode *ip, u32 requested);
+#define GFS2_AF_ORLOV 1
+extern int gfs2_inplace_reserve(struct gfs2_inode *ip, u32 requested, u32 flags);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
 extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,

commit ff7f4cb461163967a9dbb8c569e2447b7520654f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 10 10:03:50 2012 +0100

    GFS2: Consolidate free block searching functions
    
    With the recently added block reservation code, an additional function
    was added to search for free blocks. This had a restriction of only being
    able to search for aligned extents of free blocks. As a result the
    allocation patterns when reserving blocks were suboptimal when the
    existing allocation of blocks for an inode was not aligned to the same
    boundary.
    
    This patch resolves that problem by adding the ability for gfs2_rbm_find
    to search for extents of a particular minimum size. We can then use
    gfs2_rbm_find for both looking for reservations, and also looking for
    free blocks on an individual basis when we actually come to do the
    allocation later on. As a result we only need a single set of code
    to deal with both situations.
    
    The function gfs2_rbm_from_block() is moved up rgrp.c so that it
    occurs before all of its callers.
    
    Many thanks are due to Bob for helping track down the final issue in
    this patch. That fix to the rb_tree traversal and to not share
    block reservations from a dirctory to its children is included here.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index c98f6af07e1c..24077958dcf6 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -79,10 +79,4 @@ static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)
 	return rs && !RB_EMPTY_NODE(&rs->rs_node);
 }
 
-
-static inline u32 gfs2_bi2rgd_blk(const struct gfs2_bitmap *bi, u32 blk)
-{
-	return (bi->bi_start * GFS2_NBBY) + blk;
-}
-
 #endif /* __RGRP_DOT_H__ */

commit 4a993fb1503d11496974bd86c0b7123f63d9c8a2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jul 31 15:21:20 2012 +0100

    GFS2: Add structure to contain rgrp, bitmap, offset tuple
    
    This patch introduces a new structure, gfs2_rbm, which is a
    tuple of a resource group, a bitmap within the resource group
    and an offset within that bitmap. This is designed to make
    manipulating these sets of variables easier. There is also a
    new helper function which converts this representation back
    to a disk block address.
    
    In addition, the rbtree nodes which are used for the reservations
    were not being correctly initialised, which is now fixed. Also,
    the tracing was not passing through the inode where it should
    have been. That is mostly fixed aside from one corner case. This
    needs to be revisited since there can also be a NULL rgrp in
    some cases which results in the device being incorrect in the
    trace.
    
    This is intended to be the first step towards cleaning up some
    of the allocation code, and some further bug fixes.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 0b0e9cc7e3d9..c98f6af07e1c 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -46,7 +46,7 @@ extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 			     bool dinode, u64 *generation);
 
 extern int gfs2_rs_alloc(struct gfs2_inode *ip);
-extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
+extern void gfs2_rs_deltree(struct gfs2_inode *ip, struct gfs2_blkreserv *rs);
 extern void gfs2_rs_delete(struct gfs2_inode *ip);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
@@ -73,22 +73,16 @@ extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);
 extern int gfs2_fitrim(struct file *filp, void __user *argp);
 
-/* This is how to tell if a multi-block reservation is in the rgrp tree: */
-static inline int gfs2_rs_active(struct gfs2_blkreserv *rs)
+/* This is how to tell if a reservation is in the rgrp tree: */
+static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)
 {
-	if (rs && rs->rs_bi)
-		return 1;
-	return 0;
+	return rs && !RB_EMPTY_NODE(&rs->rs_node);
 }
 
+
 static inline u32 gfs2_bi2rgd_blk(const struct gfs2_bitmap *bi, u32 blk)
 {
 	return (bi->bi_start * GFS2_NBBY) + blk;
 }
 
-static inline u64 gfs2_rs_startblk(const struct gfs2_blkreserv *rs)
-{
-	return gfs2_bi2rgd_blk(rs->rs_bi, rs->rs_biblk) + rs->rs_rgd->rd_data0;
-}
-
 #endif /* __RGRP_DOT_H__ */

commit 71f890f7f758f340215d48fed5223f9cce05b652
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jul 30 14:53:19 2012 +0100

    GFS2: Remove rs_requested field from reservations
    
    The rs_requested field is left over from the original allocation
    code, however this should have been a parameter passed to the
    various functions from gfs2_inplace_reserve() and not a member of the
    reservation structure as the value is not required after the
    initial allocation.
    
    This also helps simplify the code since we no longer need to set
    the rs_requested to zero. Also the gfs2_inplace_release()
    function can also be simplified since the reservation structure
    will always be defined when it is called, and the only remaining
    task is to unlock the rgrp if required. It can also now be
    called unconditionally too, resulting in a further simplification.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index ca6e26729b86..0b0e9cc7e3d9 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -73,14 +73,6 @@ extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);
 extern int gfs2_fitrim(struct file *filp, void __user *argp);
 
-/* This is how to tell if a multi-block reservation is "inplace" reserved: */
-static inline int gfs2_mb_reserved(struct gfs2_inode *ip)
-{
-	if (ip->i_res && ip->i_res->rs_requested)
-		return 1;
-	return 0;
-}
-
 /* This is how to tell if a multi-block reservation is in the rgrp tree: */
 static inline int gfs2_rs_active(struct gfs2_blkreserv *rs)
 {

commit 8e2e00473598dd5379d8408cb974dade000acafc
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Jul 19 08:12:40 2012 -0400

    GFS2: Reduce file fragmentation
    
    This patch reduces GFS2 file fragmentation by pre-reserving blocks. The
    resulting improved on disk layout greatly speeds up operations in cases
    which would have resulted in interlaced allocation of blocks previously.
    A typical example of this is 10 parallel dd processes, each writing to a
    file in a common dirctory.
    
    The implementation uses an rbtree of reservations attached to each
    resource group (and each inode).
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 5d8314dbc899..ca6e26729b86 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -13,6 +13,14 @@
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
+/* Since each block in the file system is represented by two bits in the
+ * bitmap, one 64-bit word in the bitmap will represent 32 blocks.
+ * By reserving 32 blocks at a time, we can optimize / shortcut how we search
+ * through the bitmaps by looking a word at a time.
+ */
+#define RGRP_RSRV_MINBYTES 8
+#define RGRP_RSRV_MINBLKS ((u32)(RGRP_RSRV_MINBYTES * GFS2_NBBY))
+
 struct gfs2_rgrpd;
 struct gfs2_sbd;
 struct gfs2_holder;
@@ -29,6 +37,8 @@ extern void gfs2_free_clones(struct gfs2_rgrpd *rgd);
 extern int gfs2_rgrp_go_lock(struct gfs2_holder *gh);
 extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 
+extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
+
 extern int gfs2_inplace_reserve(struct gfs2_inode *ip, u32 requested);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
@@ -36,6 +46,7 @@ extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 			     bool dinode, u64 *generation);
 
 extern int gfs2_rs_alloc(struct gfs2_inode *ip);
+extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
 extern void gfs2_rs_delete(struct gfs2_inode *ip);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
@@ -62,7 +73,7 @@ extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);
 extern int gfs2_fitrim(struct file *filp, void __user *argp);
 
-/* This is how to tell if a reservation is "inplace" reserved: */
+/* This is how to tell if a multi-block reservation is "inplace" reserved: */
 static inline int gfs2_mb_reserved(struct gfs2_inode *ip)
 {
 	if (ip->i_res && ip->i_res->rs_requested)
@@ -70,4 +81,22 @@ static inline int gfs2_mb_reserved(struct gfs2_inode *ip)
 	return 0;
 }
 
+/* This is how to tell if a multi-block reservation is in the rgrp tree: */
+static inline int gfs2_rs_active(struct gfs2_blkreserv *rs)
+{
+	if (rs && rs->rs_bi)
+		return 1;
+	return 0;
+}
+
+static inline u32 gfs2_bi2rgd_blk(const struct gfs2_bitmap *bi, u32 blk)
+{
+	return (bi->bi_start * GFS2_NBBY) + blk;
+}
+
+static inline u64 gfs2_rs_startblk(const struct gfs2_blkreserv *rs)
+{
+	return gfs2_bi2rgd_blk(rs->rs_bi, rs->rs_biblk) + rs->rs_rgd->rd_data0;
+}
+
 #endif /* __RGRP_DOT_H__ */

commit 5407e24229408d7586ee451a384fc13e4a2332be
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri May 18 09:28:23 2012 -0400

    GFS2: Fold quota data into the reservations struct
    
    This patch moves the ancillary quota data structures into the
    block reservations structure. This saves GFS2 some time and
    effort in allocating and deallocating the qadata structure.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index d9eda5f9ef2a..5d8314dbc899 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -29,14 +29,6 @@ extern void gfs2_free_clones(struct gfs2_rgrpd *rgd);
 extern int gfs2_rgrp_go_lock(struct gfs2_holder *gh);
 extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 
-extern struct gfs2_qadata *gfs2_qadata_get(struct gfs2_inode *ip);
-static inline void gfs2_qadata_put(struct gfs2_inode *ip)
-{
-	BUG_ON(ip->i_qadata == NULL);
-	kfree(ip->i_qadata);
-	ip->i_qadata = NULL;
-}
-
 extern int gfs2_inplace_reserve(struct gfs2_inode *ip, u32 requested);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 

commit 0a305e496059a113f93bdd3ad27a5aaa917fe34d
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Jun 6 11:17:59 2012 +0100

    GFS2: Extend the life of the reservations
    
    This patch lengthens the lifespan of the reservations structure for
    inodes. Before, they were allocated and deallocated for every write
    operation. With this patch, they are allocated when the first write
    occurs, and deallocated when the last process closes the file.
    It's more efficient to do it this way because it saves GFS2 a lot of
    unnecessary allocates and frees. It also gives us more flexibility
    for the future: (1) we can now fold the qadata structure back into
    the structure and save those alloc/frees, (2) we can use this for
    multi-block reservations.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index b4b10f4de25f..d9eda5f9ef2a 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -43,6 +43,8 @@ extern void gfs2_inplace_release(struct gfs2_inode *ip);
 extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
 			     bool dinode, u64 *generation);
 
+extern int gfs2_rs_alloc(struct gfs2_inode *ip);
+extern void gfs2_rs_delete(struct gfs2_inode *ip);
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
@@ -68,4 +70,12 @@ extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
 				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);
 extern int gfs2_fitrim(struct file *filp, void __user *argp);
 
+/* This is how to tell if a reservation is "inplace" reserved: */
+static inline int gfs2_mb_reserved(struct gfs2_inode *ip)
+{
+	if (ip->i_res && ip->i_res->rs_requested)
+		return 1;
+	return 0;
+}
+
 #endif /* __RGRP_DOT_H__ */

commit 66fc061bda3526650328b73f69985da3518c4256
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Feb 8 12:58:32 2012 +0000

    GFS2: FITRIM ioctl support
    
    The FITRIM ioctl provides an alternative way to send discard requests to
    the underlying device. Using the discard mount option results in every
    freed block generating a discard request to the block device. This can
    be slow, since many block devices can only process discard requests of
    larger sizes, and also such operations can be time consuming.
    
    Rather than using the discard mount option, FITRIM allows a sweep of the
    filesystem on an occasional basis, and also to optionally avoid sending
    down discard requests for smaller regions.
    
    In GFS2 FITRIM will work at resource group granularity. There is a flag
    for each resource group which keeps track of which resource groups have
    been trimmed. This flag is reset whenever a deallocation occurs in the
    resource group, and set whenever a successful FITRIM of that resource
    group has taken place. This helps to reduce repeated discard requests
    for the same block ranges, again improving performance.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index ceec9106cdf4..b4b10f4de25f 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -11,6 +11,7 @@
 #define __RGRP_DOT_H__
 
 #include <linux/slab.h>
+#include <linux/uaccess.h>
 
 struct gfs2_rgrpd;
 struct gfs2_sbd;
@@ -18,7 +19,7 @@ struct gfs2_holder;
 
 extern void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd);
 
-extern struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk);
+extern struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact);
 extern struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp);
 extern struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
 
@@ -62,8 +63,9 @@ extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
 extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
 extern u64 gfs2_ri_total(struct gfs2_sbd *sdp);
 extern int gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl);
-extern void gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
-				    struct buffer_head *bh,
-				    const struct gfs2_bitmap *bi);
+extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
+				   struct buffer_head *bh,
+				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);
+extern int gfs2_fitrim(struct file *filp, void __user *argp);
 
 #endif /* __RGRP_DOT_H__ */

commit 564e12b1157215171e7f3af5b70611ec7154327c
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Nov 21 13:36:17 2011 -0500

    GFS2: decouple quota allocations from block allocations
    
    This patch separates the code pertaining to allocations into two
    parts: quota-related information and block reservations.
    This patch also moves all the block reservation structure allocations to
    function gfs2_inplace_reserve to simplify the code, and moves
    the frees to function gfs2_inplace_release.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index b3b61b8f6d8f..ceec9106cdf4 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -28,15 +28,15 @@ extern void gfs2_free_clones(struct gfs2_rgrpd *rgd);
 extern int gfs2_rgrp_go_lock(struct gfs2_holder *gh);
 extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 
-extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
-static inline void gfs2_alloc_put(struct gfs2_inode *ip)
+extern struct gfs2_qadata *gfs2_qadata_get(struct gfs2_inode *ip);
+static inline void gfs2_qadata_put(struct gfs2_inode *ip)
 {
-	BUG_ON(ip->i_alloc == NULL);
-	kfree(ip->i_alloc);
-	ip->i_alloc = NULL;
+	BUG_ON(ip->i_qadata == NULL);
+	kfree(ip->i_qadata);
+	ip->i_qadata = NULL;
 }
 
-extern int gfs2_inplace_reserve(struct gfs2_inode *ip);
+extern int gfs2_inplace_reserve(struct gfs2_inode *ip, u32 requested);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
 extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,

commit 6e87ed0fc93ffbe2aec296e6912b1dcb19034d6c
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Nov 18 10:58:32 2011 -0500

    GFS2: move toward a generic multi-block allocator
    
    This patch is a revision of the one I previously posted.
    I tried to integrate all the suggestions Steve gave.
    The purpose of the patch is to change function gfs2_alloc_block
    (allocate either a dinode block or an extent of data blocks)
    to a more generic gfs2_alloc_blocks function that can
    allocate both a dinode _and_ an extent of data blocks in the
    same call. This will ultimately help us create a multi-block
    reservation scheme to reduce file fragmentation.
    
    This patch moves more toward a generic multi-block allocator that
    takes a pointer to the number of data blocks to allocate, plus whether
    or not to allocate a dinode. In theory, it could be called to allocate
    (1) a single dinode block, (2) a group of one or more data blocks, or
    (3) a dinode plus several data blocks.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 4cb560813973..b3b61b8f6d8f 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -39,8 +39,8 @@ static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 extern int gfs2_inplace_reserve(struct gfs2_inode *ip);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
-extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
-			    int dinode, u64 *generation);
+extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
+			     bool dinode, u64 *generation);
 
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);

commit 3c5d785acfda7dffa63477951bb6864c6a49ed2e
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Nov 14 11:17:08 2011 -0500

    GFS2: combine gfs2_alloc_block and gfs2_alloc_di
    
    GFS2 functions gfs2_alloc_block and gfs2_alloc_di do basically
    the same things, with a few exceptions. This patch combines
    the two functions into a slightly more generic gfs2_alloc_block.
    Having one centralized block allocation function will reduce
    code redundancy and make it easier to implement multi-block
    reservations to reduce file fragmentation in the future.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index cf5c50180192..4cb560813973 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -39,8 +39,8 @@ static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 extern int gfs2_inplace_reserve(struct gfs2_inode *ip);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
-extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);
-extern int gfs2_alloc_di(struct gfs2_inode *ip, u64 *bn, u64 *generation);
+extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
+			    int dinode, u64 *generation);
 
 extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);

commit 9ae32429fe036fcfce036ec57b28fc59f3911976
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Sep 20 12:16:11 2011 +0100

    GFS2: Remove two unused variables
    
    The two variables being initialised in gfs2_inplace_reserve
    to track the file & line number of the caller are never
    used, so we might as well remove them.
    
    If something does go wrong, then a stack trace is probably
    more useful anyway.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 0e886d830784..cf5c50180192 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -36,11 +36,7 @@ static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 	ip->i_alloc = NULL;
 }
 
-extern int gfs2_inplace_reserve_i(struct gfs2_inode *ip,
-				  char *file, unsigned int line);
-#define gfs2_inplace_reserve(ip) \
-	gfs2_inplace_reserve_i((ip),  __FILE__, __LINE__)
-
+extern int gfs2_inplace_reserve(struct gfs2_inode *ip);
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
 extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);

commit 70b0c3656f12964a6dac104214c904c66e626058
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 2 16:08:09 2011 +0100

    GFS2: Use cached rgrp in gfs2_rlist_add()
    
    Each block which is deallocated, requires a call to gfs2_rlist_add()
    and each of those calls was calling gfs2_blk2rgrpd() in order to
    figure out which rgrp the block belonged in. This can be speeded up
    by making use of the rgrp cached in the inode. We also reset this
    cached rgrp in case the block has changed rgrp. This should provide
    a big reduction in gfs2_blk2rgrpd() calls during deallocation.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 0439fca18f08..0e886d830784 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -60,7 +60,7 @@ struct gfs2_rgrp_list {
 	struct gfs2_holder *rl_ghs;
 };
 
-extern void gfs2_rlist_add(struct gfs2_sbd *sdp, struct gfs2_rgrp_list *rlist,
+extern void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,
 			   u64 block);
 extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
 extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);

commit 8339ee543ece6e2dcc1bbd97d5350163c198cf00
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 31 16:38:29 2011 +0100

    GFS2: Make resource groups "append only" during life of fs
    
    Since we have ruled out supporting online filesystem shrink,
    it is possible to make the resource group list append only
    during the life of a super block. This gives several benefits:
    
    Firstly, we only need to read new rindex elements as they are added
    rather than needing to reread the whole rindex file each time one
    element is added.
    
    Secondly, the rindex glock can be held for much shorter periods of
    time, and is completely removed from the fast path for allocations.
    The lock is taken in shared mode only when updating the resource
    groups when the first allocation occurs, and after a grow has
    taken place.
    
    Thirdly, this results in a reduction in code size, and everything
    gets a lot simpler to understand in this area.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 59b950f43ccf..0439fca18f08 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -18,13 +18,13 @@ struct gfs2_holder;
 
 extern void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd);
 
-struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk);
-struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp);
-struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
+extern struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk);
+extern struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp);
+extern struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
 
 extern void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);
-extern int gfs2_rindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ri_gh);
-
+extern int gfs2_rindex_update(struct gfs2_sbd *sdp);
+extern void gfs2_free_clones(struct gfs2_rgrpd *rgd);
 extern int gfs2_rgrp_go_lock(struct gfs2_holder *gh);
 extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 
@@ -36,16 +36,13 @@ static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 	ip->i_alloc = NULL;
 }
 
-extern int gfs2_inplace_reserve_i(struct gfs2_inode *ip, int hold_rindex,
+extern int gfs2_inplace_reserve_i(struct gfs2_inode *ip,
 				  char *file, unsigned int line);
 #define gfs2_inplace_reserve(ip) \
-	gfs2_inplace_reserve_i((ip), 1, __FILE__, __LINE__)
-#define gfs2_inplace_reserve_ri(ip) \
-	gfs2_inplace_reserve_i((ip), 0, __FILE__, __LINE__)
+	gfs2_inplace_reserve_i((ip),  __FILE__, __LINE__)
 
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
-extern int gfs2_ri_update(struct gfs2_inode *ip);
 extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);
 extern int gfs2_alloc_di(struct gfs2_inode *ip, u64 *bn, u64 *generation);
 

commit 7c9ca621137cde26be05448133fc1a554345f4f8
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Aug 31 09:53:19 2011 +0100

    GFS2: Use rbtree for resource groups and clean up bitmap buffer ref count scheme
    
    Here is an update of Bob's original rbtree patch which, in addition, also
    resolves the rather strange ref counting that was being done relating to
    the bitmap blocks.
    
    Originally we had a dual system for journaling resource groups. The metadata
    blocks were journaled and also the rgrp itself was added to a list. The reason
    for adding the rgrp to the list in the journal was so that the "repolish
    clones" code could be run to update the free space, and potentially send any
    discard requests when the log was flushed. This was done by comparing the
    "cloned" bitmap with what had been written back on disk during the transaction
    commit.
    
    Due to this, there was a requirement to hang on to the rgrps' bitmap buffers
    until the journal had been flushed. For that reason, there was a rather
    complicated set up in the ->go_lock ->go_unlock functions for rgrps involving
    both a mutex and a spinlock (the ->sd_rindex_spin) to maintain a reference
    count on the buffers.
    
    However, the journal maintains a reference count on the buffers anyway, since
    they are being journaled as metadata buffers. So by moving the code which deals
    with the post-journal accounting for bitmap blocks to the metadata journaling
    code, we can entirely dispense with the rather strange buffer ref counting
    scheme and also the requirement to journal the rgrps.
    
    The net result of all this is that the ->sd_rindex_spin is left to do exactly
    one job, and that is to look after the rbtree or rgrps.
    
    This patch is designed to be a stepping stone towards using RCU for the rbtree
    of resource groups, however the reduction in the number of uses of the
    ->sd_rindex_spin is likely to have benefits for multi-threaded workloads,
    anyway.
    
    The patch retains ->go_lock and ->go_unlock for rgrps, however these maybe also
    be removed in future in favour of calling the functions directly where required
    in the code. That will allow locking of resource groups without needing to
    actually read them in - something that could be useful in speeding up statfs.
    
    In the mean time though it is valid to dereference ->bi_bh only when the rgrp
    is locked. This is basically the same rule as before, modulo the references not
    being valid until the following journal flush.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Cc: Benjamin Marzinski <bmarzins@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index d253f9a8c70e..59b950f43ccf 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -25,11 +25,8 @@ struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
 extern void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);
 extern int gfs2_rindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ri_gh);
 
-extern int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd);
-extern void gfs2_rgrp_bh_hold(struct gfs2_rgrpd *rgd);
-extern void gfs2_rgrp_bh_put(struct gfs2_rgrpd *rgd);
-
-extern void gfs2_rgrp_repolish_clones(struct gfs2_rgrpd *rgd);
+extern int gfs2_rgrp_go_lock(struct gfs2_holder *gh);
+extern void gfs2_rgrp_go_unlock(struct gfs2_holder *gh);
 
 extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
 static inline void gfs2_alloc_put(struct gfs2_inode *ip)
@@ -72,5 +69,8 @@ extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
 extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
 extern u64 gfs2_ri_total(struct gfs2_sbd *sdp);
 extern int gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl);
+extern void gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
+				    struct buffer_head *bh,
+				    const struct gfs2_bitmap *bi);
 
 #endif /* __RGRP_DOT_H__ */

commit 46fcb2ed29ff7a9ec34c4ae67b631743eb7e756f
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Jun 23 10:39:34 2011 -0500

    GFS2: combine duplicated block freeing routines
    
    __gfs2_free_data and __gfs2_free_meta are almost identical, and
    can be trivially combined.
    
    [This is as per Eric's original patch minus gfs2_free_data() which had
     no callers left and plus the conversion of the bmap.c calls to these
     functions. All in all, a nice clean up]
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index a80e3034ac47..d253f9a8c70e 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -52,9 +52,7 @@ extern int gfs2_ri_update(struct gfs2_inode *ip);
 extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);
 extern int gfs2_alloc_di(struct gfs2_inode *ip, u64 *bn, u64 *generation);
 
-extern void __gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
-extern void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
-extern void __gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
+extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
 extern void gfs2_unlink_di(struct inode *inode);

commit 4c16c36ad62fff8485215bd803d778eb2bd0b8bd
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Feb 23 16:11:33 2011 -0500

    GFS2: deallocation performance patch
    
    This patch is a performance improvement to GFS2's dealloc code.
    Rather than update the quota file and statfs file for every
    single block that's stripped off in unlink function do_strip,
    this patch keeps track and updates them once for every layer
    that's stripped.  This is done entirely inside the existing
    transaction, so there should be no risk of corruption.
    The other functions that deallocate blocks will be unaffected
    because they are using wrapper functions that do the same
    thing that they do today.
    
    I tested this code on my roth cluster by creating 200
    files in a directory, each of which is 100MB, then on
    four nodes, I simultaneously deleted the files, thus competing
    for GFS2 resources (but different files).  The commands
    I used were:
    
    [root@roth-01]# time for i in `seq 1 4 200` ; do rm /mnt/gfs2/bigdir/gfs2.$i; done
    [root@roth-02]# time for i in `seq 2 4 200` ; do rm /mnt/gfs2/bigdir/gfs2.$i; done
    [root@roth-03]# time for i in `seq 3 4 200` ; do rm /mnt/gfs2/bigdir/gfs2.$i; done
    [root@roth-05]# time for i in `seq 4 4 200` ; do rm /mnt/gfs2/bigdir/gfs2.$i; done
    
    The performance increase was significant:
    
                 roth-01     roth-02     roth-03     roth-05
                 ---------   ---------   ---------   ---------
    old: real    0m34.027    0m25.021s   0m23.906s   0m35.646s
    new: real    0m22.379s   0m24.362s   0m24.133s   0m18.562s
    
    Total time spent deleting:
    old: 118.6s
    new:  89.4
    
    For this particular case, this showed a 25% performance increase for
    GFS2 unlinks.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 50c2bb04369c..a80e3034ac47 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -52,7 +52,9 @@ extern int gfs2_ri_update(struct gfs2_inode *ip);
 extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);
 extern int gfs2_alloc_di(struct gfs2_inode *ip, u64 *bn, u64 *generation);
 
+extern void __gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
+extern void __gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
 extern void gfs2_unlink_di(struct inode *inode);

commit 086d8334cf73b3bb695b82dd864a7a8b00d96b7e
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue Nov 23 23:52:55 2010 -0600

    GFS2: fix recursive locking during rindex truncates
    
    When you truncate the rindex file, you need to avoid calling gfs2_rindex_hold,
    since you already hold it.  However, if you haven't already read in the
    resource groups, you need to do that.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 0e35c0466f9a..50c2bb04369c 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -48,6 +48,7 @@ extern int gfs2_inplace_reserve_i(struct gfs2_inode *ip, int hold_rindex,
 
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
+extern int gfs2_ri_update(struct gfs2_inode *ip);
 extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);
 extern int gfs2_alloc_di(struct gfs2_inode *ip, u64 *bn, u64 *generation);
 

commit 46290341cd649c2bfb69e5067c1804c0395c83a1
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Sep 30 10:34:00 2010 -0400

    GFS2 fatal: filesystem consistency error on rename
    
    This patch fixes a GFS2 problem whereby the first rename after a
    mount can result in a file system consistency error being flagged
    improperly and cause the file system to withdraw.  The problem is
    that the rename code tries to run the rgrp list with function
    gfs2_blk2rgrpd before the rgrp list is guaranteed to be read in
    from disk.  The patch makes the rename function hold the rindex
    glock (as the gfs2_unlink code does today) which reads in the rgrp
    list if need be.  There were a total of three places in the rename
    code that improperly referenced the rgrp list without the rindex
    glock and this patch fixes all three.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index f07119d89557..0e35c0466f9a 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -39,10 +39,12 @@ static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 	ip->i_alloc = NULL;
 }
 
-extern int gfs2_inplace_reserve_i(struct gfs2_inode *ip, char *file,
-				  unsigned int line);
+extern int gfs2_inplace_reserve_i(struct gfs2_inode *ip, int hold_rindex,
+				  char *file, unsigned int line);
 #define gfs2_inplace_reserve(ip) \
-gfs2_inplace_reserve_i((ip), __FILE__, __LINE__)
+	gfs2_inplace_reserve_i((ip), 1, __FILE__, __LINE__)
+#define gfs2_inplace_reserve_ri(ip) \
+	gfs2_inplace_reserve_i((ip), 0, __FILE__, __LINE__)
 
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index b4106ddaaa98..f07119d89557 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -10,6 +10,8 @@
 #ifndef __RGRP_DOT_H__
 #define __RGRP_DOT_H__
 
+#include <linux/slab.h>
+
 struct gfs2_rgrpd;
 struct gfs2_sbd;
 struct gfs2_holder;

commit acf7e2444acfaf4c8540603b76d71010eea3fc24
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Sep 8 18:00:30 2009 +0100

    GFS2: Be extra careful about deallocating inodes
    
    There is a potential race in the inode deallocation code if two
    nodes try to deallocate the same inode at the same time. Most of
    the issue is solved by the iopen locking. There is still a small
    window which is not covered by the iopen lock. This patches fixes
    that and also makes the deallocation code more robust in the face of
    any errors in the rgrp bitmaps, or erroneous iopen callbacks from
    other nodes.
    
    This does introduce one extra disk read, but that is generally not
    an issue since its the same block that must be written to later
    in the deallocation process. The total disk accesses therefore stay
    the same,
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index a8dedd78245b..b4106ddaaa98 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -44,8 +44,6 @@ gfs2_inplace_reserve_i((ip), __FILE__, __LINE__)
 
 extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
-extern unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block);
-
 extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);
 extern int gfs2_alloc_di(struct gfs2_inode *ip, u64 *bn, u64 *generation);
 
@@ -53,6 +51,8 @@ extern void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
 extern void gfs2_unlink_di(struct inode *inode);
+extern int gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr,
+			       unsigned int type);
 
 struct gfs2_rgrp_list {
 	unsigned int rl_rgrps;

commit 6050b9c74f24513191fc6b5e4b3583e38d146bf5
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Jul 31 16:19:40 2009 +0100

    GFS2: Improve error handling in inode allocation
    
    A little while back, block allocation was given some improved
    error handling which meant that -EIO was returned in the case
    of there being a problem in the resource group data. In addition
    a message is printed explaning what went wrong and how to fix it.
    This extends that error handling so that it also covers inode
    allocation too.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 1e76ff0f3e00..a8dedd78245b 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -47,7 +47,7 @@ extern void gfs2_inplace_release(struct gfs2_inode *ip);
 extern unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block);
 
 extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);
-extern u64 gfs2_alloc_di(struct gfs2_inode *ip, u64 *generation);
+extern int gfs2_alloc_di(struct gfs2_inode *ip, u64 *bn, u64 *generation);
 
 extern void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
 extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);

commit 09010978345e8883003bf411bb99753710eb5a3a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed May 20 10:48:47 2009 +0100

    GFS2: Improve resource group error handling
    
    This patch improves the error handling in the case where we
    discover that the summary information in the resource group
    doesn't match the bitmap information while in the process of
    allocating blocks. Originally this resulted in a kernel bug,
    but this patch changes that so that we return -EIO and print
    some messages explaining what went wrong, and how to fix it.
    
    We also remember locally not to try and allocate from the
    same rgrp again, so that a subsequent allocation in a
    different rgrp should succeed.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 3181c7e624bf..1e76ff0f3e00 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -14,22 +14,22 @@ struct gfs2_rgrpd;
 struct gfs2_sbd;
 struct gfs2_holder;
 
-void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd);
+extern void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd);
 
 struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk);
 struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp);
 struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
 
-void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);
-int gfs2_rindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ri_gh);
+extern void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);
+extern int gfs2_rindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ri_gh);
 
-int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd);
-void gfs2_rgrp_bh_hold(struct gfs2_rgrpd *rgd);
-void gfs2_rgrp_bh_put(struct gfs2_rgrpd *rgd);
+extern int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd);
+extern void gfs2_rgrp_bh_hold(struct gfs2_rgrpd *rgd);
+extern void gfs2_rgrp_bh_put(struct gfs2_rgrpd *rgd);
 
-void gfs2_rgrp_repolish_clones(struct gfs2_rgrpd *rgd);
+extern void gfs2_rgrp_repolish_clones(struct gfs2_rgrpd *rgd);
 
-struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
+extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
 static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 {
 	BUG_ON(ip->i_alloc == NULL);
@@ -37,22 +37,22 @@ static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 	ip->i_alloc = NULL;
 }
 
-int gfs2_inplace_reserve_i(struct gfs2_inode *ip,
-			 char *file, unsigned int line);
+extern int gfs2_inplace_reserve_i(struct gfs2_inode *ip, char *file,
+				  unsigned int line);
 #define gfs2_inplace_reserve(ip) \
 gfs2_inplace_reserve_i((ip), __FILE__, __LINE__)
 
-void gfs2_inplace_release(struct gfs2_inode *ip);
+extern void gfs2_inplace_release(struct gfs2_inode *ip);
 
-unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block);
+extern unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block);
 
-u64 gfs2_alloc_block(struct gfs2_inode *ip, unsigned int *n);
-u64 gfs2_alloc_di(struct gfs2_inode *ip, u64 *generation);
+extern int gfs2_alloc_block(struct gfs2_inode *ip, u64 *bn, unsigned int *n);
+extern u64 gfs2_alloc_di(struct gfs2_inode *ip, u64 *generation);
 
-void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
-void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
-void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
-void gfs2_unlink_di(struct inode *inode);
+extern void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
+extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
+extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
+extern void gfs2_unlink_di(struct inode *inode);
 
 struct gfs2_rgrp_list {
 	unsigned int rl_rgrps;
@@ -61,10 +61,11 @@ struct gfs2_rgrp_list {
 	struct gfs2_holder *rl_ghs;
 };
 
-void gfs2_rlist_add(struct gfs2_sbd *sdp, struct gfs2_rgrp_list *rlist,
-		    u64 block);
-void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
-void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
-u64 gfs2_ri_total(struct gfs2_sbd *sdp);
+extern void gfs2_rlist_add(struct gfs2_sbd *sdp, struct gfs2_rgrp_list *rlist,
+			   u64 block);
+extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
+extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
+extern u64 gfs2_ri_total(struct gfs2_sbd *sdp);
+extern int gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl);
 
 #endif /* __RGRP_DOT_H__ */

commit b45e41d7d56dfef1ae9e02e6c59990066ba82e5c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Feb 6 10:11:15 2008 +0000

    [GFS2] Add extent allocation to block allocator
    
    Rather than having to allocate a single block at a time, this patch
    allows the block allocator to allocate an extent. Since there is
    no difference (so far as the block allocator is concerned) between
    data blocks and indirect blocks, it is posible to allocate a single
    extent and for the caller to unrevoke just the blocks required
    for indirect blocks.
    
    Currently the only bit of GFS2 to make use of this feature is the
    build height function. The intention is that gfs2_block_map will
    be changed to make use of this feature in future patches.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 5e66613b33db..3181c7e624bf 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -46,7 +46,7 @@ void gfs2_inplace_release(struct gfs2_inode *ip);
 
 unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block);
 
-u64 gfs2_alloc_block(struct gfs2_inode *ip);
+u64 gfs2_alloc_block(struct gfs2_inode *ip, unsigned int *n);
 u64 gfs2_alloc_di(struct gfs2_inode *ip, u64 *generation);
 
 void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);

commit 1639431a3f57b43da1e15e9268a1d691ac01ba26
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 1 14:52:30 2008 +0000

    [GFS2] Merge gfs2_alloc_meta and gfs2_alloc_data
    
    Thanks to the preceeding patches, the only difference between
    these two functions is their name. We can thus merge them
    and call the new function gfs2_alloc_block to reflect the
    fact that it can allocate either kind of block.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 5683605695fd..5e66613b33db 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -46,8 +46,7 @@ void gfs2_inplace_release(struct gfs2_inode *ip);
 
 unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block);
 
-u64 gfs2_alloc_data(struct gfs2_inode *ip);
-u64 gfs2_alloc_meta(struct gfs2_inode *ip);
+u64 gfs2_alloc_block(struct gfs2_inode *ip);
 u64 gfs2_alloc_di(struct gfs2_inode *ip, u64 *generation);
 
 void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);

commit fe6c991c52a0dd07d4a19d392fd65048226cb1bc
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Jan 28 11:13:02 2008 -0600

    [GFS2] Get rid of unneeded parameter in gfs2_rlist_alloc
    
    This patch removed the unnecessary parameter from function
    gfs2_rlist_alloc.  The parameter was always passed in as 0.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 149bb161f4b6..5683605695fd 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
- * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
@@ -64,8 +64,7 @@ struct gfs2_rgrp_list {
 
 void gfs2_rlist_add(struct gfs2_sbd *sdp, struct gfs2_rgrp_list *rlist,
 		    u64 block);
-void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state,
-		      int flags);
+void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
 void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
 u64 gfs2_ri_total(struct gfs2_sbd *sdp);
 

commit 6dbd822487d0a9f14432cb4680415b80656b63a2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jan 10 15:18:55 2008 +0000

    [GFS2] Reduce inode size by moving i_alloc out of line
    
    It is possible to reduce the size of GFS2 inodes by taking the i_alloc
    structure out of the gfs2_inode. This patch allocates the i_alloc
    structure whenever its needed, and frees it afterward. This decreases
    the amount of low memory we use at the expense of requiring a memory
    allocation for each page or partial page that we write. A quick test
    with postmark shows that the overhead is not measurable and I also note
    that OCFS2 use the same approach.
    
    In the future I'd like to solve the problem by shrinking down the size
    of the members of the i_alloc structure, but for now, this reduces the
    immediate problem of using too much low-memory on x86 and doesn't add
    too much overhead.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index b4c6adfc6f2e..149bb161f4b6 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -32,7 +32,9 @@ void gfs2_rgrp_repolish_clones(struct gfs2_rgrpd *rgd);
 struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
 static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 {
-	return; /* So we can see where ip->i_alloc is used */
+	BUG_ON(ip->i_alloc == NULL);
+	kfree(ip->i_alloc);
+	ip->i_alloc = NULL;
 }
 
 int gfs2_inplace_reserve_i(struct gfs2_inode *ip,

commit cd81a4bac67d44742ab0aa1848f4a78e9d7e1093
Author: Robert Peterson <rpeterso@redhat.com>
Date:   Mon May 14 12:42:18 2007 -0500

    [GFS2] Addendum patch 2 for gfs2_grow
    
    This addendum patch 2 corrects three things:
    
    1. It fixes a stupid mistake in the previous addendum that broke gfs2.
       Ref: https://www.redhat.com/archives/cluster-devel/2007-May/msg00162.html
    2. It fixes a problem that Dave Teigland pointed out regarding the
       external declarations in ops_address.h being in the wrong place.
    3. It recasts a couple more %llu printks to (unsigned long long)
       as requested by Steve Whitehouse.
    
    I would have loved to put this all in one revised patch, but there was
    a rush to get some patches for RHEL5.   Therefore, the previous patches
    were applied to the git tree "as is" and therefore, I'm posting another
    addendum.  Sorry.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index b01e0cfc99b5..b4c6adfc6f2e 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -65,5 +65,6 @@ void gfs2_rlist_add(struct gfs2_sbd *sdp, struct gfs2_rgrp_list *rlist,
 void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state,
 		      int flags);
 void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
+u64 gfs2_ri_total(struct gfs2_sbd *sdp);
 
 #endif /* __RGRP_DOT_H__ */

commit f5c54804d9e3bb23d8924af09d9ca1c8de9560b6
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Oct 10 13:45:15 2006 -0400

    [GFS2] Fix uninitialised variable
    
    This fixes a bug where, in certain cases an uninitialised variable
    could cause a dereference of a NULL pointer in gfs2_commit_write().
    Also a typo in a comment is fixed at the same time.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 9eedfd12bfff..b01e0cfc99b5 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -32,7 +32,7 @@ void gfs2_rgrp_repolish_clones(struct gfs2_rgrpd *rgd);
 struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
 static inline void gfs2_alloc_put(struct gfs2_inode *ip)
 {
-	return; /* Se we can see where ip->i_alloc is used */
+	return; /* So we can see where ip->i_alloc is used */
 }
 
 int gfs2_inplace_reserve_i(struct gfs2_inode *ip,

commit 2c1e52aa905f2223dc600cfeda6c0dc94fac8b81
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Sep 5 15:41:57 2006 -0400

    [GFS2] More style fixes
    
    As per Jan Engelhardt's follow up emails, here are a few small
    fixes which were missed earlier.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 355895767387..9eedfd12bfff 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -30,7 +30,10 @@ void gfs2_rgrp_bh_put(struct gfs2_rgrpd *rgd);
 void gfs2_rgrp_repolish_clones(struct gfs2_rgrpd *rgd);
 
 struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
-void gfs2_alloc_put(struct gfs2_inode *ip);
+static inline void gfs2_alloc_put(struct gfs2_inode *ip)
+{
+	return; /* Se we can see where ip->i_alloc is used */
+}
 
 int gfs2_inplace_reserve_i(struct gfs2_inode *ip,
 			 char *file, unsigned int line);

commit f2f7ba5237e2fe10ba3e328a4f728b9e1ff141da
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Sep 5 10:39:21 2006 -0400

    [GFS2] Make headers compile on their own
    
    As per Jan Engelhardt's comments, this should make all the headers
    compile on their own by including and/or declaring structures
    early.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 3d6ae37e85df..355895767387 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -10,6 +10,10 @@
 #ifndef __RGRP_DOT_H__
 #define __RGRP_DOT_H__
 
+struct gfs2_rgrpd;
+struct gfs2_sbd;
+struct gfs2_holder;
+
 void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd);
 
 struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk);

commit cd915493fce912f1bd838ee1250737ecf33b8fae
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 4 12:49:07 2006 -0400

    [GFS2] Change all types to uX style
    
    This makes all fixed size types have consistent names.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index f94761bf3460..3d6ae37e85df 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -12,7 +12,7 @@
 
 void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd);
 
-struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, uint64_t blk);
+struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk);
 struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp);
 struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
 
@@ -35,14 +35,14 @@ gfs2_inplace_reserve_i((ip), __FILE__, __LINE__)
 
 void gfs2_inplace_release(struct gfs2_inode *ip);
 
-unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, uint64_t block);
+unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block);
 
 u64 gfs2_alloc_data(struct gfs2_inode *ip);
 u64 gfs2_alloc_meta(struct gfs2_inode *ip);
 u64 gfs2_alloc_di(struct gfs2_inode *ip, u64 *generation);
 
-void gfs2_free_data(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
-void gfs2_free_meta(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
+void gfs2_free_data(struct gfs2_inode *ip, u64 bstart, u32 blen);
+void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
 void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
 void gfs2_unlink_di(struct inode *inode);
 
@@ -54,7 +54,7 @@ struct gfs2_rgrp_list {
 };
 
 void gfs2_rlist_add(struct gfs2_sbd *sdp, struct gfs2_rgrp_list *rlist,
-		    uint64_t block);
+		    u64 block);
 void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state,
 		      int flags);
 void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);

commit e9fc2aa091ab8fa46e60d4c9d06a89305c441652
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 1 11:05:15 2006 -0400

    [GFS2] Update copyright, tidy up incore.h
    
    As per comments from Jan Engelhardt <jengelh@linux01.gwdg.de> this
    updates the copyright message to say "version" in full rather than
    "v.2". Also incore.h has been updated to remove forward structure
    declarations which are not required.
    
    The gfs2_quota_lvb structure has now had endianess annotations added
    to it. Also quota.c has been updated so that we now store the
    lvb data locally in endian independant format to avoid needing
    a structure in host endianess too. As a result the endianess
    conversions are done as required at various points and thus the
    conversion routines in lvb.[ch] are no longer required. I've
    moved the one remaining constant in lvb.h thats used into lm.h
    and removed the unused lvb.[ch].
    
    I have not changed the HIF_ constants. That is left to a later patch
    which I hope will unify the gh_flags and gh_iflags fields of the
    struct gfs2_holder.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 14600944d184..f94761bf3460 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -4,7 +4,7 @@
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
- * of the GNU General Public License v.2.
+ * of the GNU General Public License version 2.
  */
 
 #ifndef __RGRP_DOT_H__

commit 4340fe62531f7d1dafb6f5359ffe0378bdb0db80
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jul 11 09:46:33 2006 -0400

    [GFS2] Add generation number
    
    This adds a generation number for the eventual use of NFS to the
    ondisk inode. Its backward compatible with the current code since
    it doesn't really matter what the generation number is to start with,
    and indeed since its set to zero, due to it being taken from padding
    in both the inode and rgrp header, it should be fine.
    
    The eventual plan is to use this rather than no_formal_ino in the
    NFS filehandles. At that point no_formal_ino will be unused.
    
    At the same time we also add a releasepages call back to the
    "normal" address space for gfs2 inodes. Also I've removed a
    one-linrer function thats not required any more.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 9c42d2252ddd..14600944d184 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -37,9 +37,9 @@ void gfs2_inplace_release(struct gfs2_inode *ip);
 
 unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, uint64_t block);
 
-uint64_t gfs2_alloc_data(struct gfs2_inode *ip);
-uint64_t gfs2_alloc_meta(struct gfs2_inode *ip);
-uint64_t gfs2_alloc_di(struct gfs2_inode *ip);
+u64 gfs2_alloc_data(struct gfs2_inode *ip);
+u64 gfs2_alloc_meta(struct gfs2_inode *ip);
+u64 gfs2_alloc_di(struct gfs2_inode *ip, u64 *generation);
 
 void gfs2_free_data(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
 void gfs2_free_meta(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);

commit 43f5d210a02dcf9d8bafb147044f27add10a459a
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jun 22 11:16:40 2006 -0400

    [GFS2] [-mm patch] fs/gfs2/: make code static
    
    This patch makes the following needlessly global code static:
    - eaops.c: struct gfs2_security_eaops
    - rgrp.c: gfs2_free_uninit_di()
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index e86a532cc159..9c42d2252ddd 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -43,7 +43,6 @@ uint64_t gfs2_alloc_di(struct gfs2_inode *ip);
 
 void gfs2_free_data(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
 void gfs2_free_meta(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
-void gfs2_free_uninit_di(struct gfs2_rgrpd *rgd, uint64_t blkno);
 void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
 void gfs2_unlink_di(struct inode *inode);
 

commit feaa7bba026c181ce071d5a4884f7f9dd26207a1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jun 14 15:32:57 2006 -0400

    [GFS2] Fix unlinked file handling
    
    This patch fixes the way we have been dealing with unlinked,
    but still open files. It removes all limits (other than memory
    for inodes, as per every other filesystem) on numbers of these
    which we can support on GFS2. It also means that (like other
    fs) its the responsibility of the last process to close the file
    to deallocate the storage, rather than the person who did the
    unlinking. Note that with GFS2, those two events might take place
    on different nodes.
    
    Also there are a number of other changes:
    
     o We use the Linux inode subsystem as it was intended to be
    used, wrt allocating GFS2 inodes
     o The Linux inode cache is now the point which we use for
    local enforcement of only holding one copy of the inode in
    core at once (previous to this we used the glock layer).
     o We no longer use the unlinked "special" file. We just ignore it
    completely. This makes unlinking more efficient.
     o We now use the 4th block allocation state. The previously unused
    state is used to track unlinked but still open inodes.
     o gfs2_inoded is no longer needed
     o Several fields are now no longer needed (and removed) from the in
    core struct gfs2_inode
     o Several fields are no longer needed (and removed) from the in core
    superblock
    
    There are a number of future possible optimisations and clean ups
    which have been made possible by this patch.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index d2db3719cc0f..e86a532cc159 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -45,6 +45,7 @@ void gfs2_free_data(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
 void gfs2_free_meta(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
 void gfs2_free_uninit_di(struct gfs2_rgrpd *rgd, uint64_t blkno);
 void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
+void gfs2_unlink_di(struct inode *inode);
 
 struct gfs2_rgrp_list {
 	unsigned int rl_rgrps;

commit 3a8a9a1034813aa99f5ae3150f652d490c5ff10d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu May 18 15:09:15 2006 -0400

    [GFS2] Update copyright date to 2006
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 4c44a191b1c1..d2db3719cc0f 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
- * Copyright (C) 2004-2005 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions

commit b3b94faa5fe5968827ba0640ee9fba4b3e7f736e
Author: David Teigland <teigland@redhat.com>
Date:   Mon Jan 16 16:50:04 2006 +0000

    [GFS2] The core of GFS2
    
    This patch contains all the core files for GFS2.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
new file mode 100644
index 000000000000..4c44a191b1c1
--- /dev/null
+++ b/fs/gfs2/rgrp.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
+ * Copyright (C) 2004-2005 Red Hat, Inc.  All rights reserved.
+ *
+ * This copyrighted material is made available to anyone wishing to use,
+ * modify, copy, or redistribute it subject to the terms and conditions
+ * of the GNU General Public License v.2.
+ */
+
+#ifndef __RGRP_DOT_H__
+#define __RGRP_DOT_H__
+
+void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd);
+
+struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, uint64_t blk);
+struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp);
+struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
+
+void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);
+int gfs2_rindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ri_gh);
+
+int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd);
+void gfs2_rgrp_bh_hold(struct gfs2_rgrpd *rgd);
+void gfs2_rgrp_bh_put(struct gfs2_rgrpd *rgd);
+
+void gfs2_rgrp_repolish_clones(struct gfs2_rgrpd *rgd);
+
+struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
+void gfs2_alloc_put(struct gfs2_inode *ip);
+
+int gfs2_inplace_reserve_i(struct gfs2_inode *ip,
+			 char *file, unsigned int line);
+#define gfs2_inplace_reserve(ip) \
+gfs2_inplace_reserve_i((ip), __FILE__, __LINE__)
+
+void gfs2_inplace_release(struct gfs2_inode *ip);
+
+unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, uint64_t block);
+
+uint64_t gfs2_alloc_data(struct gfs2_inode *ip);
+uint64_t gfs2_alloc_meta(struct gfs2_inode *ip);
+uint64_t gfs2_alloc_di(struct gfs2_inode *ip);
+
+void gfs2_free_data(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
+void gfs2_free_meta(struct gfs2_inode *ip, uint64_t bstart, uint32_t blen);
+void gfs2_free_uninit_di(struct gfs2_rgrpd *rgd, uint64_t blkno);
+void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
+
+struct gfs2_rgrp_list {
+	unsigned int rl_rgrps;
+	unsigned int rl_space;
+	struct gfs2_rgrpd **rl_rgd;
+	struct gfs2_holder *rl_ghs;
+};
+
+void gfs2_rlist_add(struct gfs2_sbd *sdp, struct gfs2_rgrp_list *rlist,
+		    uint64_t block);
+void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state,
+		      int flags);
+void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
+
+#endif /* __RGRP_DOT_H__ */
