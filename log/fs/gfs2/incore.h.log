commit 7542486b89b2e321ffe0de82163b425d6a38bc72
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Jun 17 07:47:34 2020 -0500

    gfs2: eliminate GIF_ORDERED in favor of list_empty
    
    In several places, we used the GIF_ORDERED inode flag to determine
    if an inode was on the ordered writes list. However, since we always
    held the sd_ordered_lock spin_lock during the manipulation, we can
    just as easily check list_empty(&ip->i_ordered) instead.
    This allows us to keep more than one ordered writes list to make
    journal writing improvements.
    
    This patch eliminates GIF_ORDERED in favor of checking list_empty.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 03ab11fab962..ca2ec02436ec 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -399,7 +399,6 @@ enum {
 	GIF_QD_LOCKED		= 1,
 	GIF_ALLOC_FAILED	= 2,
 	GIF_SW_PAGED		= 3,
-	GIF_ORDERED		= 4,
 	GIF_FREE_VFS_INODE      = 5,
 	GIF_GLOP_PENDING	= 6,
 	GIF_DEFERRED_DELETE	= 7,

commit b0dcffd8da3339ad0300587ce7030efdf2e914a9
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Jan 15 09:54:14 2020 +0100

    gfs2: Check inode generation number in delete_work_func
    
    In delete_work_func, if the iopen glock still has an inode attached,
    limit the inode lookup to that specific generation number: in the likely
    case that the inode was deleted on the node on which the inode's link
    count dropped to zero, we can skip verifying the on-disk block type and
    reading in the inode.  The same applies if another node that had the
    inode open managed to delete the inode before us.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 76ac2578e658..03ab11fab962 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -380,7 +380,10 @@ struct gfs2_glock {
 	struct delayed_work gl_work;
 	union {
 		/* For iopen glocks only */
-		struct delayed_work gl_delete;
+		struct {
+			struct delayed_work gl_delete;
+			u64 gl_no_formal_ino;
+		};
 		/* For rgrp glocks only */
 		struct {
 			loff_t start;

commit 8c7b9262a8607636ecd7250f29c7aac17f08901c
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon Jan 13 22:16:17 2020 +0100

    gfs2: Give up the iopen glock on contention
    
    When there's contention on the iopen glock, it means that the link count
    of the corresponding inode has dropped to zero on a remote node which is
    now trying to delete the inode.  In that case, try to evict the inode so
    that the iopen glock will be released, which will allow the remote node
    to do its job.
    
    When the inode is still open locally, the inode's reference count won't
    drop to zero and so we'll keep holding the inode and its iopen glock.
    The remote node will time out its request to grab the iopen glock, and
    when the inode is finally closed locally, we'll try to delete it
    ourself.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index fdcf7a2f06c5..76ac2578e658 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -399,6 +399,7 @@ enum {
 	GIF_ORDERED		= 4,
 	GIF_FREE_VFS_INODE      = 5,
 	GIF_GLOP_PENDING	= 6,
+	GIF_DEFERRED_DELETE	= 7,
 };
 
 struct gfs2_inode {

commit a0e3cc65fa29f497cc97a069c318532c2a48d148
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Jan 16 20:12:26 2020 +0100

    gfs2: Turn gl_delete into a delayed work
    
    This requires flushing delayed work items in gfs2_make_fs_ro (which is called
    before unmounting a filesystem).
    
    When inodes are deleted and then recreated, pending gl_delete work items would
    have no effect because the inode generations will have changed, so we can
    cancel any pending gl_delete works before reusing iopen glocks.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 84a824293a78..fdcf7a2f06c5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -345,6 +345,7 @@ enum {
 	GLF_OBJECT			= 14, /* Used only for tracing */
 	GLF_BLOCKING			= 15,
 	GLF_INODE_CREATING		= 16, /* Inode creation occurring */
+	GLF_PENDING_DELETE		= 17,
 	GLF_FREEING			= 18, /* Wait for glock to be freed */
 };
 
@@ -378,8 +379,8 @@ struct gfs2_glock {
 	atomic_t gl_revokes;
 	struct delayed_work gl_work;
 	union {
-		/* For inode and iopen glocks only */
-		struct work_struct gl_delete;
+		/* For iopen glocks only */
+		struct delayed_work gl_delete;
 		/* For rgrp glocks only */
 		struct {
 			loff_t start;

commit 2fba46a04c383f91e7fe837d43bf1ab33ce32b6a
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Feb 27 12:47:53 2020 -0600

    gfs2: Change inode qa_data to allow multiple users
    
    Before this patch, multiple users called gfs2_qa_alloc which allocated
    a qadata structure to the inode, if quotas are turned on. Later, in
    file close or evict, the structure was deleted with gfs2_qa_delete.
    But there can be several competing processes who need access to the
    structure. There were races between file close (release) and the others.
    Thus, a release could delete the structure out from under a process
    that relied upon its existence. For example, chown.
    
    This patch changes the management of the qadata structures to be
    a get/put scheme. Function gfs2_qa_alloc has been changed to gfs2_qa_get
    and if the structure is allocated, the count essentially starts out at
    1. Function gfs2_qa_delete has been renamed to gfs2_qa_put, and the
    last guy to decrement the count to 0 frees the memory.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 04549a8cae7e..84a824293a78 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -295,6 +295,7 @@ struct gfs2_qadata { /* quota allocation data */
 	struct gfs2_quota_data *qa_qd[2 * GFS2_MAXQUOTAS];
 	struct gfs2_holder qa_qd_ghs[2 * GFS2_MAXQUOTAS];
 	unsigned int qa_qd_num;
+	int qa_ref;
 };
 
 /* Resource group multi-block reservation, in order of appearance:

commit 1c634f94c3da39115270d35b3075af970810a927
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Nov 13 14:09:28 2019 -0600

    gfs2: Do proper error checking for go_sync family of glops functions
    
    Before this patch, function do_xmote would try to sync out the glock
    dirty data by calling the appropriate glops function XXX_go_sync()
    but it did not check for a good return code. If the sync was not
    possible due to an io error or whatever, do_xmote would continue on
    and call go_inval and release the glock to other cluster nodes.
    When those nodes go to replay the journal, they may already be holding
    glocks for the journal records that should have been synced, but were
    not due to the ignored error.
    
    This patch introduces proper error code checking to the go_sync
    family of glops functions.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8cd564bcf5e6..04549a8cae7e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -234,7 +234,7 @@ struct lm_lockname {
 
 
 struct gfs2_glock_operations {
-	void (*go_sync) (struct gfs2_glock *gl);
+	int (*go_sync) (struct gfs2_glock *gl);
 	int (*go_xmote_bh) (struct gfs2_glock *gl, struct gfs2_holder *gh);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (const struct gfs2_glock *gl);

commit 601ef0d52e9617588fcff3df26953592f2eb44ac
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Jan 28 20:23:45 2020 +0100

    gfs2: Force withdraw to replay journals and wait for it to finish
    
    When a node withdraws from a file system, it often leaves its journal
    in an incomplete state. This is especially true when the withdraw is
    caused by io errors writing to the journal. Before this patch, a
    withdraw would try to write a "shutdown" record to the journal, tell
    dlm it's done with the file system, and none of the other nodes
    know about the problem. Later, when the problem is fixed and the
    withdrawn node is rebooted, it would then discover that its own
    journal was incomplete, and replay it. However, replaying it at this
    point is almost guaranteed to introduce corruption because the other
    nodes are likely to have used affected resource groups that appeared
    in the journal since the time of the withdraw. Replaying the journal
    later will overwrite any changes made, and not through any fault of
    dlm, which was instructed during the withdraw to release those
    resources.
    
    This patch makes file system withdraws seen by the entire cluster.
    Withdrawing nodes dequeue their journal glock to allow recovery.
    
    The remaining nodes check all the journals to see if they are
    clean or in need of replay. They try to replay dirty journals, but
    only the journals of withdrawn nodes will be "not busy" and
    therefore available for replay.
    
    Until the journal replay is complete, no i/o related glocks may be
    given out, to ensure that the replay does not cause the
    aforementioned corruption: We cannot allow any journal replay to
    overwrite blocks associated with a glock once it is held.
    
    The "live" glock which is now used to signal when a withdraw
    occurs. When a withdraw occurs, the node signals its withdraw by
    dequeueing the "live" glock and trying to enqueue it in EX mode,
    thus forcing the other nodes to all see a demote request, by way
    of a "1CB" (one callback) try lock. The "live" glock is not
    granted in EX; the callback is only just used to indicate a
    withdraw has occurred.
    
    Note that all nodes in the cluster must wait for the recovering
    node to finish replaying the withdrawing node's journal before
    continuing. To this end, it checks that the journals are clean
    multiple times in a retry loop.
    
    Also note that the withdraw function may be called from a wide
    variety of situations, and therefore, we need to take extra
    precautions to make sure pointers are valid before using them in
    many circumstances.
    
    We also need to take care when glocks decide to withdraw, since
    the withdraw code now uses glocks.
    
    Also, before this patch, if a process encountered an error and
    decided to withdraw, if another process was already withdrawing,
    the second withdraw would be silently ignored, which set it free
    to unlock its glocks. That's correct behavior if the original
    withdrawer encounters further errors down the road. But if
    secondary waiters don't wait for the journal replay, unlocking
    glocks will allow other nodes to use them, despite the fact that
    the journal containing those blocks is being replayed. The
    replay needs to finish before our glocks are released to other
    nodes. IOW, secondary withdraws need to wait for the first
    withdraw to finish.
    
    For example, if an rgrp glock is unlocked by a process that didn't
    wait for the first withdraw, a journal replay could introduce file
    system corruption by replaying a rgrp block that has already been
    granted to a different cluster node.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3072707aff7a..8cd564bcf5e6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -242,6 +242,7 @@ struct gfs2_glock_operations {
 	void (*go_dump)(struct seq_file *seq, struct gfs2_glock *gl,
 			const char *fs_id_buf);
 	void (*go_callback)(struct gfs2_glock *gl, bool remote);
+	void (*go_free)(struct gfs2_glock *gl);
 	const int go_type;
 	const unsigned long go_flags;
 #define GLOF_ASPACE 1 /* address space attached */
@@ -343,6 +344,7 @@ enum {
 	GLF_OBJECT			= 14, /* Used only for tracing */
 	GLF_BLOCKING			= 15,
 	GLF_INODE_CREATING		= 16, /* Inode creation occurring */
+	GLF_FREEING			= 18, /* Wait for glock to be freed */
 };
 
 struct gfs2_glock {
@@ -619,6 +621,10 @@ enum {
 	SDF_FORCE_AIL_FLUSH     = 9,
 	SDF_FS_FROZEN           = 10,
 	SDF_WITHDRAWING		= 11, /* Will withdraw eventually */
+	SDF_WITHDRAW_IN_PROG	= 12, /* Withdraw is in progress */
+	SDF_REMOTE_WITHDRAW	= 13, /* Performing remote recovery */
+	SDF_WITHDRAW_RECOVERY	= 14, /* Wait for journal recovery when we are
+					 withdrawing */
 };
 
 enum gfs2_freeze_state {
@@ -769,6 +775,7 @@ struct gfs2_sbd {
 	struct gfs2_jdesc *sd_jdesc;
 	struct gfs2_holder sd_journal_gh;
 	struct gfs2_holder sd_jinode_gh;
+	struct gfs2_glock *sd_jinode_gl;
 
 	struct gfs2_holder sd_sc_gh;
 	struct gfs2_holder sd_qc_gh;
@@ -830,6 +837,7 @@ struct gfs2_sbd {
 	struct bio *sd_log_bio;
 	wait_queue_head_t sd_log_flush_wait;
 	int sd_log_error; /* First log error */
+	wait_queue_head_t sd_withdraw_wait;
 
 	atomic_t sd_reserving_log;
 	wait_queue_head_t sd_reserving_log_wait;
@@ -853,6 +861,7 @@ struct gfs2_sbd {
 
 	unsigned long sd_last_warning;
 	struct dentry *debugfs_dir;    /* debugfs directory */
+	unsigned long sd_glock_dqs_held;
 };
 
 static inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)

commit a72d2401f54b7db41c77ab971238a06eafe929fb
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Jun 13 13:28:45 2019 -0500

    gfs2: Allow some glocks to be used during withdraw
    
    We need to allow some glocks to be enqueued, dequeued, promoted, and demoted
    when we're withdrawn. For example, to maintain metadata integrity, we should
    disallow the use of inode and rgrp glocks when withdrawn. Other glocks, like
    iopen or the transaction glocks may be safely used because none of their
    metadata goes through the journal. So in general, we should disallow all
    glocks with an address space, and allow all the others. One exception is:
    we need to allow our active journal to be demoted so others may recover it.
    
    Allowing glocks after withdraw gives us the ability to take appropriate
    action (in a following patch) to have our journal properly replayed by
    another node rather than just abandoning the current transactions and
    pretending nothing bad happened, leaving the other nodes free to modify
    the blocks we had in our journal, which may result in file system
    corruption.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index ab89f746b3b6..3072707aff7a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -244,9 +244,10 @@ struct gfs2_glock_operations {
 	void (*go_callback)(struct gfs2_glock *gl, bool remote);
 	const int go_type;
 	const unsigned long go_flags;
-#define GLOF_ASPACE 1
-#define GLOF_LVB    2
-#define GLOF_LRU    4
+#define GLOF_ASPACE 1 /* address space attached */
+#define GLOF_LVB    2 /* Lock Value Block attached */
+#define GLOF_LRU    4 /* LRU managed */
+#define GLOF_NONDISK   8 /* not I/O related */
 };
 
 enum {
@@ -541,6 +542,7 @@ struct gfs2_jdesc {
 	struct list_head jd_revoke_list;
 	unsigned int jd_replay_tail;
 
+	u64 jd_no_addr;
 };
 
 struct gfs2_statfs_change_host {

commit 036330c914365f449ead353ef152fb29411cd4cb
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Apr 10 11:46:35 2019 -0600

    gfs2: log error reform
    
    Before this patch, gfs2 kept track of journal io errors in two
    places sd_log_error and the SDF_AIL1_IO_ERROR flag in sd_flags.
    This patch consolidates the two into sd_log_error so that it
    reflects the first error encountered writing to the journal.
    In future patches, we will take advantage of this by checking
    this value rather than having to check both when reacting to
    io errors.
    
    In addition, this fixes a tight loop in unmount: If buffers
    get on the ail1 list and an io error occurs elsewhere, the
    ail1 list would never be cleared because they were always busy.
    So unmount would hang, waiting for the ail1 list to empty.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b95c8a31d309..ab89f746b3b6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -615,9 +615,8 @@ enum {
 	SDF_RORECOVERY		= 7, /* read only recovery */
 	SDF_SKIP_DLM_UNLOCK	= 8,
 	SDF_FORCE_AIL_FLUSH     = 9,
-	SDF_AIL1_IO_ERROR	= 10,
-	SDF_FS_FROZEN           = 11,
-	SDF_WITHDRAWING		= 12, /* Will withdraw eventually */
+	SDF_FS_FROZEN           = 10,
+	SDF_WITHDRAWING		= 11, /* Will withdraw eventually */
 };
 
 enum gfs2_freeze_state {
@@ -828,7 +827,7 @@ struct gfs2_sbd {
 	atomic_t sd_log_in_flight;
 	struct bio *sd_log_bio;
 	wait_queue_head_t sd_log_flush_wait;
-	int sd_log_error;
+	int sd_log_error; /* First log error */
 
 	atomic_t sd_reserving_log;
 	wait_queue_head_t sd_reserving_log_wait;

commit b3422cacdd7e623e473b4c3977f3ee65e1fed62f
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Nov 13 11:50:30 2019 -0600

    gfs2: Rework how rgrp buffer_heads are managed
    
    Before this patch, the rgrp code had a serious problem related to
    how it managed buffer_heads for resource groups. The problem caused
    file system corruption, especially in cases of journal replay.
    
    When an rgrp glock was demoted to transfer ownership to a
    different cluster node, do_xmote() first calls rgrp_go_sync and then
    rgrp_go_inval, as expected. When it calls rgrp_go_sync, that called
    gfs2_rgrp_brelse() that dropped the buffer_head reference count.
    In most cases, the reference count went to zero, which is right.
    However, there were other places where the buffers are handled
    differently.
    
    After rgrp_go_sync, do_xmote called rgrp_go_inval which called
    gfs2_rgrp_brelse a second time, then rgrp_go_inval's call to
    truncate_inode_pages_range would get rid of the pages in memory,
    but only if the reference count drops to 0.
    
    Unfortunately, gfs2_rgrp_brelse was setting bi->bi_bh = NULL.
    So when rgrp_go_sync called gfs2_rgrp_brelse, it lost the pointer
    to the buffer_heads in cases where the reference count was still 1.
    Therefore, when rgrp_go_inval called gfs2_rgrp_brelse a second time,
    it failed the check for "if (bi->bi_bh)" and thus failed to call
    brelse a second time. Because of that, the reference count on those
    buffers sometimes failed to drop from 1 to 0. And that caused
    function truncate_inode_pages_range to keep the pages in page cache
    rather than freeing them.
    
    The next time the rgrp glock was acquired, the metadata read of
    the rgrp buffers re-used the pages in memory, which were now
    wrong because they were likely modified by the other node who
    acquired the glock in EX (which is why we demoted the glock).
    This re-use of the page cache caused corruption because changes
    made by the other nodes were never seen, so the bitmaps were
    inaccurate.
    
    For some reason, the problem became most apparent when journal
    replay forced the replay of rgrps in memory, which caused newer
    rgrp data to be overwritten by the older in-core pages.
    
    A big part of the problem was that the rgrp buffer were released
    in multiple places: The go_unlock function would release them when
    the glock was released rather than when the glock is demoted,
    which is clearly wrong because our intent was to cache them until
    the glock is demoted from SH or EX.
    
    This patch attempts to clean up the mess and make one consistent
    and centralized mechanism for managing the rgrp buffer_heads by
    implementing several changes:
    
    1. It eliminates the call to gfs2_rgrp_brelse() from rgrp_go_sync.
       We don't want to release the buffers or zero the pointers when
       syncing for the reasons stated above. It only makes sense to
       release them when the glock is actually invalidated (go_inval).
       And when we do, then we set the bh pointers to NULL.
    2. The go_unlock function (which was only used for rgrps) is
       eliminated, as we've talked about doing many times before.
       The go_unlock function was called too early in the glock dq
       process, and should not happen until the glock is invalidated.
    3. It also eliminates the call to rgrp_brelse in gfs2_clear_rgrpd.
       That will now happen automatically when the rgrp glocks are
       demoted, and shouldn't happen any sooner or later than that.
       Instead, function gfs2_clear_rgrpd has been modified to demote
       the rgrp glocks, and therefore, free those pages, before the
       remaining glocks are culled by gfs2_gl_hash_clear. This
       prevents the gl_object from hanging around when the glocks are
       culled.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3cd2de3db40a..b95c8a31d309 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -239,7 +239,6 @@ struct gfs2_glock_operations {
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (const struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);
-	void (*go_unlock) (struct gfs2_holder *gh);
 	void (*go_dump)(struct seq_file *seq, struct gfs2_glock *gl,
 			const char *fs_id_buf);
 	void (*go_callback)(struct gfs2_glock *gl, bool remote);

commit 69511080bd6efd34f4e020fcde6cf73bb4a61af6
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Feb 12 13:43:55 2019 -0700

    gfs2: Introduce concept of a pending withdraw
    
    File system withdraws can be delayed when inconsistencies are
    discovered when we cannot withdraw immediately, for example, when
    critical spin_locks are held. But delaying the withdraw can cause
    gfs2 to ignore the error and keep running for a short period of time.
    For example, an rgrp glock may be dequeued and demoted while there
    are still buffers that haven't been properly revoked, due to io
    errors writing to the journal.
    
    This patch introduces a new concept of a pending withdraw, which
    means an inconsistency has been discovered and we need to withdraw
    at the earliest possible opportunity. In these cases, we aren't
    quite withdrawn yet, but we still need to not dequeue glocks and
    other critical things. If we dequeue the glocks and the withdraw
    results in our journal being replayed, the replay could overwrite
    data that's been modified by a different node that acquired the
    glock in the meantime.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9fd88ed18807..3cd2de3db40a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -618,6 +618,7 @@ enum {
 	SDF_FORCE_AIL_FLUSH     = 9,
 	SDF_AIL1_IO_ERROR	= 10,
 	SDF_FS_FROZEN           = 11,
+	SDF_WITHDRAWING		= 12, /* Will withdraw eventually */
 };
 
 enum gfs2_freeze_state {

commit a31b4ec539e966515f1f97f4000d0e2a399930ce
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Jan 20 15:49:28 2020 +0100

    Revert "gfs2: eliminate tr_num_revoke_rm"
    
    This reverts commit e955537e3262de8e56f070b13817f525f472fa00.
    
    Before patch e955537e32, tr_num_revoke tracked the number of revokes
    added to the transaction, and tr_num_revoke_rm tracked how many
    revokes were removed. But since revokes are queued off the sdp
    (superblock) pointer, some transactions could remove more revokes
    than they added. (e.g. revokes added by a different process).
    Commit e955537e32 eliminated transaction variable tr_num_revoke_rm,
    but in order to do so, it changed the accounting to always use
    tr_num_revoke for its math. Since you can remove more revokes than
    you add, tr_num_revoke could now become a negative value.
    This negative value broke the assert in function gfs2_trans_end:
    
            if (gfs2_assert_withdraw(sdp, (nbuf <=3D tr->tr_blocks) &&
                                   (tr->tr_num_revoke <=3D tr->tr_revokes)))
    
    One way to fix this is to simply remove the tr_num_revoke clause
    from the assert and allow the value to become negative. Andreas
    didn't like that idea, so instead, we decided to revert e955537e32.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 68d67d38a09d..9fd88ed18807 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -503,6 +503,7 @@ struct gfs2_trans {
 	unsigned int tr_num_buf_rm;
 	unsigned int tr_num_databuf_rm;
 	unsigned int tr_num_revoke;
+	unsigned int tr_num_revoke_rm;
 
 	struct list_head tr_list;
 	struct list_head tr_databuf;

commit f7be987b825434e2cac5027d47501ae1102881b4
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Jan 16 00:25:32 2020 +0100

    gfs2: Remove GFS2_MIN_LVB_SIZE define
    
    The dlm lockspace is set up to have lock value blocks of GDLM_LVB_SIZE bytes,
    and dlm is the only lock manager we support, so there is no point in claiming
    that the lock value block could have any other size.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e9254e2fbc20..68d67d38a09d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -387,8 +387,6 @@ struct gfs2_glock {
 	struct rhash_head gl_node;
 };
 
-#define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */
-
 enum {
 	GIF_INVALID		= 0,
 	GIF_QD_LOCKED		= 1,

commit 5d43975859bf4fa5a27d568f37091f46a73a9725
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Jan 9 13:54:36 2020 +0100

    gfs2: Fix incorrect variable name
    
    Rename sd_log_commited_revoke to sd_log_committed_revoke.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b5d9c11f4901..e9254e2fbc20 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -804,7 +804,7 @@ struct gfs2_sbd {
 
 	struct gfs2_trans *sd_log_tr;
 	unsigned int sd_log_blks_reserved;
-	int sd_log_commited_revoke;
+	int sd_log_committed_revoke;
 
 	atomic_t sd_log_pinned;
 	unsigned int sd_log_num_revoke;

commit 2e9eeaa1175112ac494ba3c2ea4b71b1febeb6ab
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Dec 13 08:10:51 2019 -0600

    gfs2: eliminate ssize parameter from gfs2_struct2blk
    
    Every caller of function gfs2_struct2blk specified sizeof(u64).
    
    This patch eliminates the unnecessary parameter and replaces the
    size calculation with a new superblock variable that is computed
    to be the maximum number of block pointers we can fit inside a
    log descriptor, as is done for pointers per dinode and indirect
    block.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Andrew Price <anprice@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5f89c515f5bb..b5d9c11f4901 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -703,6 +703,7 @@ struct gfs2_sbd {
 	u32 sd_fsb2bb_shift;
 	u32 sd_diptrs;	/* Number of pointers in a dinode */
 	u32 sd_inptrs;	/* Number of pointers in a indirect block */
+	u32 sd_ldptrs;  /* Number of pointers in a log descriptor block */
 	u32 sd_jbsize;	/* Size of a journaled data block */
 	u32 sd_hash_bsize;	/* sizeof(exhash block) */
 	u32 sd_hash_bsize_shift;

commit 0b36c9eed232760fbf51921818f48b3699f1f1ca
Merge: 722e6f500ac7 1f52aa08d12f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 24 12:33:34 2019 -0700

    Merge branch 'work.mount3' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more mount API conversions from Al Viro:
     "Assorted conversions of options parsing to new API.
    
      gfs2 is probably the most serious one here; the rest is trivial stuff.
    
      Other things in what used to be #work.mount are going to wait for the
      next cycle (and preferably go via git trees of the filesystems
      involved)"
    
    * 'work.mount3' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      gfs2: Convert gfs2 to fs_context
      vfs: Convert spufs to use the new mount API
      vfs: Convert hypfs to use the new mount API
      hypfs: Fix error number left in struct pointer member
      vfs: Convert functionfs to use the new mount API
      vfs: Convert bpf to use the new mount API

commit 1f52aa08d12f8d359e71b4bfd73ca9d5d668e4da
Author: Andrew Price <anprice@redhat.com>
Date:   Wed Mar 27 14:46:00 2019 +0000

    gfs2: Convert gfs2 to fs_context
    
    Convert gfs2 and gfs2meta to fs_context. Removes the duplicated vfs code
    from gfs2_mount and instead uses the new vfs_get_block_super() before
    switching the ->root to the appropriate dentry.
    
    The mount option parsing has been converted to the new API and error
    reporting for invalid options has been made more precise at the same
    time.
    
    All of the mount/remount code has been moved into ops_fstype.c
    
    Signed-off-by: Andrew Price <anprice@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: cluster-devel@redhat.com
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7a993d7c022e..0662747353e7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -584,10 +584,10 @@ struct gfs2_args {
 	unsigned int ar_rgrplvb:1;		/* use lvbs for rgrp info */
 	unsigned int ar_loccookie:1;		/* use location based readdir
 						   cookies */
-	int ar_commit;				/* Commit interval */
-	int ar_statfs_quantum;			/* The fast statfs interval */
-	int ar_quota_quantum;			/* The quota interval */
-	int ar_statfs_percent;			/* The % change to force sync */
+	s32 ar_commit;				/* Commit interval */
+	s32 ar_statfs_quantum;			/* The fast statfs interval */
+	s32 ar_quota_quantum;			/* The quota interval */
+	s32 ar_statfs_percent;			/* The % change to force sync */
 };
 
 struct gfs2_tune {

commit ad26967b9afa7faee22c3b79370cb5d9ab553493
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Aug 30 12:31:02 2019 -0500

    gfs2: Use async glocks for rename
    
    Because s_vfs_rename_mutex is not cluster-wide, multiple nodes can
    reverse the roles of which directories are "old" and which are "new" for
    the purposes of rename. This can cause deadlocks where two nodes end up
    waiting for each other.
    
    There can be several layers of directory dependencies across many nodes.
    
    This patch fixes the problem by acquiring all gfs2_rename's inode glocks
    asychronously and waiting for all glocks to be acquired.  That way all
    inodes are locked regardless of the order.
    
    The timeout value for multiple asynchronous glocks is calculated to be
    the total of the individual wait times for each glock times two.
    
    Since gfs2_exchange is very similar to gfs2_rename, both functions are
    patched in the same way.
    
    A new async glock wait queue, sd_async_glock_wait, keeps a list of
    waiters for these events. If gfs2's holder_wake function detects an
    async holder, it wakes up any waiters for the event. The waiter only
    tests whether any of its requests are still pending.
    
    Since the glocks are sent to dlm asychronously, the wait function needs
    to check to see which glocks, if any, were granted.
    
    If a glock is granted by dlm (and therefore held), its minimum hold time
    is checked and adjusted as necessary, as other glock grants do.
    
    If the event times out, all glocks held thus far must be dequeued to
    resolve any existing deadlocks.  Then, if there are any outstanding
    locking requests, we need to loop around and wait for dlm to respond to
    those requests too.  After we release all requests, we return -ESTALE to
    the caller (vfs rename) which loops around and retries the request.
    
        Node1           Node2
        ---------       ---------
    1.  Enqueue A       Enqueue B
    2.  Enqueue B       Enqueue A
    3.  A granted
    6.                  B granted
    7.  Wait for B
    8.                  Wait for A
    9.                  A times out (since Node 1 holds A)
    10.                 Dequeue B (since it was granted)
    11.                 Wait for all requests from DLM
    12. B Granted (since Node2 released it in step 10)
    13. Rename
    14. Dequeue A
    15.                 DLM Grants A
    16.                 Dequeue A (due to the timeout and since we
                        no longer have B held for our task).
    17. Dequeue B
    18.                 Return -ESTALE to vfs
    19.                 VFS retries the operation, goto step 1.
    
    This release-all-locks / acquire-all-locks may slow rename / exchange
    down as both nodes struggle in the same way and do the same thing.
    However, this will only happen when there is contention for the same
    inodes, which ought to be rare.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7a993d7c022e..6b450065b9d5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -725,6 +725,7 @@ struct gfs2_sbd {
 	struct gfs2_glock *sd_freeze_gl;
 	struct work_struct sd_freeze_work;
 	wait_queue_head_t sd_glock_wait;
+	wait_queue_head_t sd_async_glock_wait;
 	atomic_t sd_glock_disposal;
 	struct completion sd_locking_init;
 	struct completion sd_wdack;

commit 3792ce973f07a2644fd81424b9acacb12530a3cf
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu May 9 09:21:48 2019 -0500

    gfs2: dump fsid when dumping glock problems
    
    Before this patch, if a glock error was encountered, the glock with
    the problem was dumped. But sometimes you may have lots of file systems
    mounted, and that doesn't tell you which file system it was for.
    
    This patch adds a new boolean parameter fsid to the dump_glock family
    of functions. For non-error cases, such as dumping the glocks debugfs
    file, the fsid is not dumped in order to keep lock dumps and glocktop
    as clean as possible. For all error cases, such as GLOCK_BUG_ON, the
    file system id is now printed. This will make it easier to debug.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3ac57afa694a..7a993d7c022e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -240,7 +240,8 @@ struct gfs2_glock_operations {
 	int (*go_demote_ok) (const struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
-	void (*go_dump)(struct seq_file *seq, struct gfs2_glock *gl);
+	void (*go_dump)(struct seq_file *seq, struct gfs2_glock *gl,
+			const char *fs_id_buf);
 	void (*go_callback)(struct gfs2_glock *gl, bool remote);
 	const int go_type;
 	const unsigned long go_flags;

commit 04aea0ca14f025828c22d8ef586ff59d0be2f98b
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue May 7 13:27:44 2019 -0500

    gfs2: Rename SDF_SHUTDOWN to SDF_WITHDRAWN
    
    Before this patch, the superblock flag indicating when a file system
    is withdrawn was called SDF_SHUTDOWN. This patch simply renames it to
    the more obvious SDF_WITHDRAWN.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6b7cfc278ce2..3ac57afa694a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -608,7 +608,7 @@ struct gfs2_tune {
 enum {
 	SDF_JOURNAL_CHECKED	= 0,
 	SDF_JOURNAL_LIVE	= 1,
-	SDF_SHUTDOWN		= 2,
+	SDF_WITHDRAWN		= 2,
 	SDF_NOBARRIERS		= 3,
 	SDF_NORECOVERY		= 4,
 	SDF_DEMOTE		= 5,

commit e955537e3262de8e56f070b13817f525f472fa00
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Mar 26 13:51:48 2019 -0600

    gfs2: eliminate tr_num_revoke_rm
    
    For its journal processing, gfs2 kept track of the number of buffers
    added and removed on a per-transaction basis. These values are used
    to calculate space needed in the journal. But while these calculations
    make sense for the number of buffers, they make no sense for revokes.
    Revokes are managed in their own list, linked from the superblock.
    So it's entirely unnecessary to keep separate per-transaction counts
    for revokes added and removed. A single count will do the same job.
    Therefore, this patch combines the transaction revokes into a single
    count.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c9af93ac6c73..6b7cfc278ce2 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -504,7 +504,6 @@ struct gfs2_trans {
 	unsigned int tr_num_buf_rm;
 	unsigned int tr_num_databuf_rm;
 	unsigned int tr_num_revoke;
-	unsigned int tr_num_revoke_rm;
 
 	struct list_head tr_list;
 	struct list_head tr_databuf;

commit 9331b6740f86163908de69f4008e434fe0c27691
Merge: 1ce2c85137b1 d925da5c7b09
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 8 12:52:42 2019 -0700

    Merge tag 'spdx-5.2-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull yet more SPDX updates from Greg KH:
     "Another round of SPDX header file fixes for 5.2-rc4
    
      These are all more "GPL-2.0-or-later" or "GPL-2.0-only" tags being
      added, based on the text in the files. We are slowly chipping away at
      the 700+ different ways people tried to write the license text. All of
      these were reviewed on the spdx mailing list by a number of different
      people.
    
      We now have over 60% of the kernel files covered with SPDX tags:
            $ ./scripts/spdxcheck.py -v 2>&1 | grep Files
            Files checked:            64533
            Files with SPDX:          40392
            Files with errors:            0
    
      I think the majority of the "easy" fixups are now done, it's now the
      start of the longer-tail of crazy variants to wade through"
    
    * tag 'spdx-5.2-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (159 commits)
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 450
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 449
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 448
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 446
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 445
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 444
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 443
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 442
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 440
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 438
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 437
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 436
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 435
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 434
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 433
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 432
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 431
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 430
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 429
      ...

commit 638803d4568121d73a266e440530f880ffa2dacc
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Jun 6 07:33:38 2019 -0500

    Revert "gfs2: Replace gl_revokes with a GLF flag"
    
    Commit 73118ca8baf7 introduced a glock reference counting bug in
    gfs2_trans_remove_revoke.  Given that, replacing gl_revokes with a GLF flag is
    no longer useful, so revert that commit.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b15755068593..1d35e0da0ef8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -345,7 +345,6 @@ enum {
 	GLF_OBJECT			= 14, /* Used only for tracing */
 	GLF_BLOCKING			= 15,
 	GLF_INODE_CREATING		= 16, /* Inode creation occurring */
-	GLF_REVOKES			= 17, /* Glock has revokes in queue */
 };
 
 struct gfs2_glock {
@@ -375,6 +374,7 @@ struct gfs2_glock {
 	struct list_head gl_lru;
 	struct list_head gl_ail_list;
 	atomic_t gl_ail_count;
+	atomic_t gl_revokes;
 	struct delayed_work gl_work;
 	union {
 		/* For inode and iopen glocks only */

commit 7336d0e654f7acc0ecee33a8ae68c4fd1c1c44b5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 398
    
    Based on 1 normalized pattern(s):
    
      this copyrighted material is made available to anyone wishing to use
      modify copy or redistribute it subject to the terms and conditions
      of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081038.653000175@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b15755068593..8c4b334d1be4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
  * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.
- *
- * This copyrighted material is made available to anyone wishing to use,
- * modify, copy, or redistribute it subject to the terms and conditions
- * of the GNU General Public License version 2.
  */
 
 #ifndef __INCORE_DOT_H__

commit 8f91821990fd6f170a5dca79697a441181a41b16
Author: Abhi Das <adas@redhat.com>
Date:   Tue Apr 30 16:53:47 2019 -0500

    gfs2: fix race between gfs2_freeze_func and unmount
    
    As part of the freeze operation, gfs2_freeze_func() is left blocking
    on a request to hold the sd_freeze_gl in SH. This glock is held in EX
    by the gfs2_freeze() code.
    
    A subsequent call to gfs2_unfreeze() releases the EXclusively held
    sd_freeze_gl, which allows gfs2_freeze_func() to acquire it in SH and
    resume its operation.
    
    gfs2_unfreeze(), however, doesn't wait for gfs2_freeze_func() to complete.
    If a umount is issued right after unfreeze, it could result in an
    inconsistent filesystem because some journal data (statfs update) isn't
    written out.
    
    Refer to commit 24972557b12c for a more detailed explanation of how
    freeze/unfreeze work.
    
    This patch causes gfs2_unfreeze() to wait for gfs2_freeze_func() to
    complete before returning to the user.
    
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 78c8e761b321..b15755068593 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -621,6 +621,7 @@ enum {
 	SDF_SKIP_DLM_UNLOCK	= 8,
 	SDF_FORCE_AIL_FLUSH     = 9,
 	SDF_AIL1_IO_ERROR	= 10,
+	SDF_FS_FROZEN           = 11,
 };
 
 enum gfs2_freeze_state {

commit a5b1d3fc503164bb04e2b720054ab07d8a0004fc
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Apr 5 12:16:14 2019 +0100

    gfs2: Rename sd_log_le_{revoke,ordered}
    
    Rename sd_log_le_revoke to sd_log_revokes and sd_log_le_ordered to
    sd_log_ordered: not sure what le stands for here, but it doesn't add
    clarity, and if it stands for list entry, it's actually confusing as
    those are both list heads but not list entries.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6a94b094a904..78c8e761b321 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -809,8 +809,8 @@ struct gfs2_sbd {
 	atomic_t sd_log_pinned;
 	unsigned int sd_log_num_revoke;
 
-	struct list_head sd_log_le_revoke;
-	struct list_head sd_log_le_ordered;
+	struct list_head sd_log_revokes;
+	struct list_head sd_log_ordered;
 	spinlock_t sd_ordered_lock;
 
 	atomic_t sd_log_thresh1;

commit 73118ca8baf78dddd1f9c8ac67c1d80b47d9830e
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Apr 5 04:41:38 2019 +0100

    gfs2: Replace gl_revokes with a GLF flag
    
    The gl_revokes value determines how many outstanding revokes a glock has
    on the superblock revokes list; this is used to avoid unnecessary log
    flushes.  However, gl_revokes is only ever tested for being zero, and it's
    only decremented in revoke_lo_after_commit, which removes all revokes
    from the list, so we know that the gl_revoke values of all the glocks on
    the list will reach zero.  Therefore, we can replace gl_revokes with a
    bit flag. This saves an atomic counter in struct gfs2_glock.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 86840a70ee1a..6a94b094a904 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -345,6 +345,7 @@ enum {
 	GLF_OBJECT			= 14, /* Used only for tracing */
 	GLF_BLOCKING			= 15,
 	GLF_INODE_CREATING		= 16, /* Inode creation occurring */
+	GLF_REVOKES			= 17, /* Glock has revokes in queue */
 };
 
 struct gfs2_glock {
@@ -374,7 +375,6 @@ struct gfs2_glock {
 	struct list_head gl_lru;
 	struct list_head gl_ail_list;
 	atomic_t gl_ail_count;
-	atomic_t gl_revokes;
 	struct delayed_work gl_work;
 	union {
 		/* For inode and iopen glocks only */

commit 7c70b896951c84d63e6d71b82668f9c8b8bbd440
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Mar 25 09:34:19 2019 -0600

    gfs2: clean_journal improperly set sd_log_flush_head
    
    This patch fixes regressions in 588bff95c94efc05f9e1a0b19015c9408ed7c0ef.
    Due to that patch, function clean_journal was setting the value of
    sd_log_flush_head, but that's only valid if it is replaying the node's
    own journal. If it's replaying another node's journal, that's completely
    wrong and will lead to multiple problems. This patch tries to clean up
    the mess by passing the value of the logical journal block number into
    gfs2_write_log_header so the function can treat non-owned journals
    generically. For the local journal, the journal extent map is used for
    best performance. For other nodes from other journals, new function
    gfs2_lblk_to_dblk is called to figure it out using gfs2_iomap_get.
    
    This patch also tries to establish more consistency when passing journal
    block parameters by changing several unsigned int types to a consistent
    u32.
    
    Fixes: 588bff95c94e ("GFS2: Reduce code redundancy writing log headers")
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index cdf07b408f54..86840a70ee1a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -535,7 +535,7 @@ struct gfs2_jdesc {
 	unsigned long jd_flags;
 #define JDF_RECOVERY 1
 	unsigned int jd_jid;
-	unsigned int jd_blocks;
+	u32 jd_blocks;
 	int jd_recover_error;
 	/* Replay stuff */
 

commit 2abbf9a4d262511999ac11b4ddc8521c9ee72b88
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 22 16:21:51 2019 +0100

    gfs: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    There is no need to save the dentries for the debugfs files, so drop
    those variables to save a bit of space and make the code simpler.
    
    Cc: Bob Peterson <rpeterso@redhat.com>
    Cc: Andreas Gruenbacher <agruenba@redhat.com>
    Cc: cluster-devel@redhat.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e10e0b0a7cd5..cdf07b408f54 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -853,9 +853,6 @@ struct gfs2_sbd {
 
 	unsigned long sd_last_warning;
 	struct dentry *debugfs_dir;    /* debugfs directory */
-	struct dentry *debugfs_dentry_glocks;
-	struct dentry *debugfs_dentry_glstats;
-	struct dentry *debugfs_dentry_sbstats;
 };
 
 static inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)

commit 27a2660f1ef944724956d92e8a312b6da0936fae
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Apr 18 12:05:01 2018 -0700

    gfs2: Dump nrpages for inodes and their glocks
    
    This patch is based on an idea from Steve Whitehouse. The idea is
    to dump the number of pages for inodes in the glock dumps.
    The additional locking required me to drop const from quite a few
    places.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 663759abe60d..e10e0b0a7cd5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -243,7 +243,7 @@ struct gfs2_glock_operations {
 	int (*go_demote_ok) (const struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
-	void (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
+	void (*go_dump)(struct seq_file *seq, struct gfs2_glock *gl);
 	void (*go_callback)(struct gfs2_glock *gl, bool remote);
 	const int go_type;
 	const unsigned long go_flags;

commit cbbe76c8bb27c0bea4bfa6cac56b5d4073b90687
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Nov 16 14:18:32 2018 -0600

    gfs2: Remove vestigial bd_ops
    
    Field bd_ops was set but never used, so I removed it, and all
    code supporting it.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 888b62cfd6d1..663759abe60d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -165,7 +165,6 @@ struct gfs2_bufdata {
 	u64 bd_blkno;
 
 	struct list_head bd_list;
-	const struct gfs2_log_operations *bd_ops;
 
 	struct gfs2_trans *bd_tr;
 	struct list_head bd_ail_st_list;

commit 281b4952d185a3ba0340b412faa47fd745565552
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Sep 26 23:32:46 2018 +0100

    gfs2: Rename bitmap.bi_{len => bytes}
    
    This field indicates the size of the bitmap in bytes, similar to how the
    bi_blocks field indicates the size of the bitmap in blocks.
    
    In count_unlinked, replace an instance of bi_bytes * GFS2_NBBY by
    bi_blocks.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 997a3a19f77d..888b62cfd6d1 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -92,7 +92,7 @@ struct gfs2_bitmap {
 	unsigned long bi_flags;
 	u32 bi_offset;
 	u32 bi_start;
-	u32 bi_len;
+	u32 bi_bytes;
 	u32 bi_blocks;
 };
 

commit 21f09c4395c95dfaa0598d20d41cb2a669e1967e
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Aug 30 16:01:50 2018 +0100

    gfs2: Move rs_{sizehint, rgd_gh} fields into the inode
    
    Move the rs_sizehint and rs_rgd_gh fields from struct gfs2_blkreserv
    into the inode: they are more closely related to the inode than to a
    particular reservation.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5d72e8b66a26..997a3a19f77d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -309,10 +309,6 @@ struct gfs2_qadata { /* quota allocation data */
 */
 
 struct gfs2_blkreserv {
-	/* components used during write (step 1): */
-	atomic_t rs_sizehint;         /* hint of the write size */
-
-	struct gfs2_holder rs_rgd_gh; /* Filled in by get_local_rgrp */
 	struct rb_node rs_node;       /* link to other block reservations */
 	struct gfs2_rbm rs_rbm;       /* Start of reservation */
 	u32 rs_free;                  /* how many blocks are still free */
@@ -417,8 +413,10 @@ struct gfs2_inode {
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
 	struct gfs2_qadata *i_qadata; /* quota allocation data */
+	struct gfs2_holder i_rgd_gh;
 	struct gfs2_blkreserv i_res; /* rgrp multi-block reservation */
 	u64 i_goal;	/* goal block for allocations */
+	atomic_t i_sizehint;  /* hint of the write size */
 	struct rw_semaphore i_rw_mutex;
 	struct list_head i_ordered;
 	struct list_head i_trunc_list;

commit b524abcc01483b2ac093cc6a8a2a7375558d2b64
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Oct 4 10:21:07 2018 -0500

    gfs2: slow the deluge of io error messages
    
    When an io error is hit, it calls gfs2_io_error_bh_i for every
    journal buffer it can't write. Since we changed gfs2_io_error_bh_i
    recently to withdraw later in the cycle, it sends a flood of
    errors to the console. This patch checks for the file system already
    being withdrawn, and if so, doesn't send more messages. It doesn't
    stop the flood of messages, but it slows it down and keeps it more
    reasonable.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b96d39c28e17..5d72e8b66a26 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -623,6 +623,7 @@ enum {
 	SDF_RORECOVERY		= 7, /* read only recovery */
 	SDF_SKIP_DLM_UNLOCK	= 8,
 	SDF_FORCE_AIL_FLUSH     = 9,
+	SDF_AIL1_IO_ERROR	= 10,
 };
 
 enum gfs2_freeze_state {

commit dffe12a82826082d2129ef91b17b257254cb60fc
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Aug 7 10:07:00 2018 -0500

    gfs2: Fix gfs2_testbit to use clone bitmaps
    
    Function gfs2_testbit is called in three places. Two of those places,
    gfs2_alloc_extent and gfs2_unaligned_extlen, should be using the clone
    bitmaps, not the "real" bitmaps. Function gfs2_unaligned_extlen is used
    by the block reservations scheme to determine the length of an extent of
    free blocks. Before this patch, it wasn't using the clone bitmap, which
    means recently-freed blocks were treated as free blocks for the purposes
    of an allocation.
    
    This patch adds a new parameter to gfs2_testbit to indicate whether or
    not the clone bitmaps should be used (if available).
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b50908211b69..b96d39c28e17 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -65,6 +65,27 @@ struct gfs2_log_operations {
 
 #define GBF_FULL 1
 
+/**
+ * Clone bitmaps (bi_clone):
+ *
+ * - When a block is freed, we remember the previous state of the block in the
+ *   clone bitmap, and only mark the block as free in the real bitmap.
+ *
+ * - When looking for a block to allocate, we check for a free block in the
+ *   clone bitmap, and if no clone bitmap exists, in the real bitmap.
+ *
+ * - For allocating a block, we mark it as allocated in the real bitmap, and if
+ *   a clone bitmap exists, also in the clone bitmap.
+ *
+ * - At the end of a log_flush, we copy the real bitmap into the clone bitmap
+ *   to make the clone bitmap reflect the current allocation state.
+ *   (Alternatively, we could remove the clone bitmap.)
+ *
+ * The clone bitmaps are in-core only, and is never written to disk.
+ *
+ * These steps ensure that blocks which have been freed in a transaction cannot
+ * be reallocated in that same transaction.
+ */
 struct gfs2_bitmap {
 	struct buffer_head *bi_bh;
 	char *bi_clone;

commit b7eba890a228f591fea2889b901267ba5de7839b
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Jun 21 07:42:37 2018 -0500

    gfs2: Eliminate redundant ip->i_rgd
    
    GFS2 remembers the last rgrp used for allocations in ip->i_rgd.
    However, block allocations are made by way of a reservations structure,
    ip->i_res, which keeps the last rgrp in ip->i_res.rs_rgd, and ip->i_res
    is kept in sync with ip->i_res.rs_rgd, so it's redundant.  Get rid of
    ip->i_rgd and just use ip->i_res.rs_rgd in its place.
    
    Based on patches by Robert Peterson.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e9cd2cc292d3..b50908211b69 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -397,7 +397,6 @@ struct gfs2_inode {
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
 	struct gfs2_qadata *i_qadata; /* quota allocation data */
 	struct gfs2_blkreserv i_res; /* rgrp multi-block reservation */
-	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
 	struct list_head i_ordered;

commit f85c10e24ab9fd8ccb6de3d6061a3110ff3581df
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Jun 13 08:52:47 2018 -0500

    gfs2: eliminate rs_inum and reduce the size of gfs2 inodes
    
    Before this patch, block reservations kept track of the inode
    number. At one point, that was a valid thing to do. However, since
    we made the reservation a part of the inode (rather than a pointer
    to a separate allocated object) the reservation can determine the
    inode number by using container_of. This saves us a little memory
    in our inode.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>
    Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index d2ad817e089f..e9cd2cc292d3 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -295,7 +295,6 @@ struct gfs2_blkreserv {
 	struct rb_node rs_node;       /* link to other block reservations */
 	struct gfs2_rbm rs_rbm;       /* Start of reservation */
 	u32 rs_free;                  /* how many blocks are still free */
-	u64 rs_inum;                  /* Inode number for reservation */
 };
 
 /*

commit dc8fbb03dcd6df78027ccec61ff2a0bba436d38e
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Jun 1 22:09:50 2018 -0500

    GFS2: gfs2_free_extlen can return an extent that is too long
    
    Function gfs2_free_extlen calculates the length of an extent of
    free blocks that may be reserved. The end pointer was calculated as
    end = start + bh->b_size but b_size is incorrect because the
    bitmap usually stops prior to the end of the buffer data on
    the last bitmap.
    
    What this means is that when you do a write, you can reserve a
    chunk of blocks that runs off the end of the last bitmap. For
    example, I've got a file system where there is only one bitmap
    for each rgrp, so ri_length==1. I saw cases in which iozone
    tried to do a big write, grabbed a large block reservation,
    chose rgrp 5464152, which has ri_data0 5464153 and ri_data 8188.
    So 5464153 + 8188 = 5472341 which is the end of the rgrp.
    
    When it grabbed a reservation it got back: 5470936, length 7229.
    But 5470936 + 7229 = 5478165. So the reservation starts inside
    the rgrp but runs 5824 blocks past the end of the bitmap.
    
    This patch fixes the calculation so it won't exceed the last
    bitmap. It also adds a BUG_ON to guard against overflows in the
    future.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 0bbbaa9b05cb..d2ad817e089f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -116,6 +116,7 @@ static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)
 
 static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)
 {
+	BUG_ON(rbm->offset >= rbm->rgd->rd_data);
 	return rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +
 		rbm->offset;
 }

commit 9a38662ba4e2682f3f3e9f3ce02a243b837aa8c6
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon Apr 16 09:25:21 2018 -0700

    gfs2: Remove sdp->sd_jheightsize
    
    GFS2 keeps two arrarys in the superblock that define the maximum size of
    an inode depending on the inode's height: sdp->sd_heightsize defines the
    heights in units of sb->s_blocksize; sdp->sd_jheightsize defines them in
    units of sb->s_blocksize - sizeof(struct gfs2_meta_header).  These
    arrays are used to determine when additional layers of indirect blocks
    are needed.  The second array is used for directories which have an
    additional gfs2_meta_header at the beginning of each block.
    
    Distinguishing between these two cases makes no sense: the height
    required for representing N blocks will come out the same no matter if
    the calculation is done in gross (sb->s_blocksize) or net
    (sb->s_blocksize - sizeof(struct gfs2_meta_header)) units.
    
    Stuffed directories don't have an additional gfs2_meta_header, but the
    stuffed case is handled separately for both files and directories,
    anyway.
    
    Remove the unncessary sdp->sd_jheightsize array.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1b6b1e3f5caf..0bbbaa9b05cb 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -696,8 +696,6 @@ struct gfs2_sbd {
 	u32 sd_max_dirres;	/* Max blocks needed to add a directory entry */
 	u32 sd_max_height;	/* Max height of a file's metadata tree */
 	u64 sd_heightsize[GFS2_MAX_META_HEIGHT + 1];
-	u32 sd_max_jheight; /* Max height of journaled file's meta tree */
-	u64 sd_jheightsize[GFS2_MAX_META_HEIGHT + 1];
 	u32 sd_max_dents_per_leaf; /* Max number of dirents in a leaf block */
 
 	struct gfs2_args sd_args;	/* Mount arguments */

commit fffb64127adc3eea6a19ceefdc88d171f68b9d34
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Mar 29 06:50:32 2018 -0700

    gfs2: Zero out fallocated blocks in fallocate_chunk
    
    Instead of zeroing out fallocated blocks in gfs2_iomap_alloc, zero them
    out in fallocate_chunk, much higher up the call stack.  This gets rid of
    gfs2's abuse of the IOMAP_ZERO flag as well as the gfs2 specific zeronew
    buffer flag.  I can't think of a reason why zeroing out the blocks in
    gfs2_iomap_alloc would have any benefits: there is no additional locking
    at that level that would add protection to the newly allocated blocks.
    
    While at it, change fallocate over from gs2_block_map to gfs2_iomap_begin.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e0557b8a590a..1b6b1e3f5caf 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -130,15 +130,12 @@ static inline bool gfs2_rbm_eq(const struct gfs2_rbm *rbm1,
 enum gfs2_state_bits {
 	BH_Pinned = BH_PrivateStart,
 	BH_Escaped = BH_PrivateStart + 1,
-	BH_Zeronew = BH_PrivateStart + 2,
 };
 
 BUFFER_FNS(Pinned, pinned)
 TAS_BUFFER_FNS(Pinned, pinned)
 BUFFER_FNS(Escaped, escaped)
 TAS_BUFFER_FNS(Escaped, escaped)
-BUFFER_FNS(Zeronew, zeronew)
-TAS_BUFFER_FNS(Zeronew, zeronew)
 
 struct gfs2_bufdata {
 	struct buffer_head *bd_bh;

commit 0ff5916ad4eb857e03e7586665d1c022ef3277f6
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Tue Jan 16 23:07:57 2018 +0100

    gfs2: Get rid of gfs2_log_header_in
    
    Get rid of gfs2_log_header_in by integrating it into get_log_header.
    Clean up the crc32 computations and use the same functions for encoding
    and decoding to make things less confusing.  Eliminate lh_hash from
    gfs2_log_header_host which is completely useless.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9d4d7367175f..e0557b8a590a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -44,7 +44,6 @@ struct gfs2_log_header_host {
 	u32 lh_flags;		/* GFS2_LOG_HEAD_... */
 	u32 lh_tail;		/* Block number of log tail */
 	u32 lh_blkno;
-	u32 lh_hash;
 };
 
 /*

commit 235628c5c76040b0ec206ea9ab9e017771e0d78e
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Tue Nov 14 16:53:12 2017 +0100

    gfs2: Add gfs2_max_stuffed_size
    
    Add a small inline function for computing the maximum size of a stuffed
    inode instead of open coding that in several places throughout the code.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6e18e9793ec4..9d4d7367175f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -861,5 +861,10 @@ static inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)
 
 extern struct gfs2_rgrpd *gfs2_glock2rgrp(struct gfs2_glock *gl);
 
+static inline unsigned gfs2_max_stuffed_size(const struct gfs2_inode *ip)
+{
+	return GFS2_SB(&ip->i_inode)->sd_sb.sb_bsize - sizeof(struct gfs2_dinode);
+}
+
 #endif /* __INCORE_DOT_H__ */
 

commit 561b796987af8b169c47375194527219ef5b0974
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Tue Aug 22 12:17:35 2017 -0500

    gfs2: Silence gcc format-truncation warning
    
    Enlarge sd_fsname to be big enough for the longest long lock table name
    and an arbitrary journal number.  This silences two -Wformat-truncation
    warnings with gcc 7.1.1.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 0ce0b334f412..6e18e9793ec4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -833,7 +833,7 @@ struct gfs2_sbd {
 	atomic_t sd_freeze_state;
 	struct mutex sd_freeze_mutex;
 
-	char sd_fsname[GFS2_FSNAME_LEN];
+	char sd_fsname[GFS2_FSNAME_LEN + 3 * sizeof(int) + 2];
 	char sd_table_name[GFS2_FSNAME_LEN];
 	char sd_proto_name[GFS2_FSNAME_LEN];
 

commit 942b0cddfbf66295effc9fd879ca85ae10638565
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Aug 16 11:30:06 2017 -0500

    GFS2: Withdraw for IO errors writing to the journal or statfs
    
    Before this patch, if GFS2 encountered IO errors while writing to
    the journal, it would not report the problem, so they would go
    unnoticed, sometimes for many hours. Sometimes this would only be
    noticed later, when recovery tried to do journal replay and failed
    due to invalid metadata at the blocks that resulted in IO errors.
    
    This patch makes GFS2's log daemon check for IO errors. If it
    encounters one, it withdraws from the file system and reports
    why in dmesg. A similar action is taken when IO errors occur when
    writing to the system statfs file.
    
    These errors are also reported back to any callers of fsync, since
    that requires the journal to be flushed. Therefore, any IO errors
    that would previously go unnoticed are now noticed and the file
    system is withdrawn as early as possible, thus preventing further
    file system damage.
    
    Also note that this reintroduces superblock variable sd_log_error,
    which Christoph removed with commit f729b66fca.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a7b0331c549d..0ce0b334f412 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -817,6 +817,7 @@ struct gfs2_sbd {
 	atomic_t sd_log_in_flight;
 	struct bio *sd_log_bio;
 	wait_queue_head_t sd_log_flush_wait;
+	int sd_log_error;
 
 	atomic_t sd_reserving_log;
 	wait_queue_head_t sd_reserving_log_wait;

commit b066a4eebd4f5ea77f7e5c7d13104d38e1a1d4bf
Author: Abhi Das <adas@redhat.com>
Date:   Fri Aug 4 12:15:32 2017 -0500

    gfs2: forcibly flush ail to relieve memory pressure
    
    On systems with low memory, it is possible for gfs2 to infinitely
    loop in balance_dirty_pages() under heavy IO (creating sparse files).
    
    balance_dirty_pages() attempts to write out the dirty pages via
    gfs2_writepages() but none are found because these dirty pages are
    being used by the journaling code in the ail. Normally, the journal
    has an upper threshold which when hit triggers an automatic flush
    of the ail. But this threshold can be higher than the number of
    allowable dirty pages and result in the ail never being flushed.
    
    This patch forces an ail flush when gfs2_writepages() fails to write
    anything. This is a good indication that the ail might be holding
    some dirty pages.
    
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 73fce76e67ee..a7b0331c549d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -606,6 +606,7 @@ enum {
 	SDF_NOJOURNALID		= 6,
 	SDF_RORECOVERY		= 7, /* read only recovery */
 	SDF_SKIP_DLM_UNLOCK	= 8,
+	SDF_FORCE_AIL_FLUSH     = 9,
 };
 
 enum gfs2_freeze_state {

commit 961ae1d83d055a4b9ebbfb4cc8ca62ec1a7a3b74
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Jul 7 13:22:05 2017 -0500

    gfs2: Fix glock rhashtable rcu bug
    
    Before commit 88ffbf3e03 "GFS2: Use resizable hash table for glocks",
    glocks were freed via call_rcu to allow reading the glock hashtable
    locklessly using rcu.  This was then changed to free glocks immediately,
    which made reading the glock hashtable unsafe.  Bring back the original
    code for freeing glocks via call_rcu.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Cc: stable@vger.kernel.org # 4.3+

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 790e73984288..73fce76e67ee 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -373,6 +373,7 @@ struct gfs2_glock {
 			loff_t end;
 		} gl_vm;
 	};
+	struct rcu_head gl_rcu;
 	struct rhash_head gl_node;
 };
 

commit c96e6dabfbdb241e32b3c588dbfa1ccb87d2c95a
Merge: 8c27cb356676 29695254ec51
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 5 16:57:08 2017 -0700

    Merge tag 'gfs2-4.13.fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/gfs2/linux-gfs2
    
    Pull GFS2 updates from Bob Peterson:
     "We've got eight GFS2 patches for this merge window:
    
       - Andreas Gruenbacher has four patches related to cleaning up the
         GFS2 inode evict process. This is about half of his patches
         designed to fix a long-standing GFS2 hang related to the inode
         shrinker: Shrinker calls gfs2 evict, evict calls DLM, DLM requires
         memory and blocks on the shrinker.
    
         These four patches have been well tested. His second set of patches
         are still being tested, so I plan to hold them until the next merge
         window, after we have more weeks of testing. The first patch
         eliminates the flush_delayed_work, which can block.
    
       - Andreas's second patch protects setting of gl_object for rgrps with
         a spin_lock to prevent proven races.
    
       - His third patch introduces a centralized mechanism for queueing
         glock work with better reference counting, to prevent more races.
    
        -His fourth patch retains a reference to inode glocks when an error
         occurs while creating an inode. This keeps the subsequent evict
         from needing to reacquire the glock, which might call into DLM and
         block in low memory conditions.
    
       - Arvind Yadav has a patch to add const to attribute_group
         structures.
    
       - I have a patch to detect directory entry inconsistencies and
         withdraw the file system if any are found. Better that than silent
         corruption.
    
       - I have a patch to remove a vestigial variable from glock
         structures, saving some slab space.
    
       - I have another patch to remove a vestigial variable from the GFS2
         in-core superblock structure"
    
    * tag 'gfs2-4.13.fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/gfs2/linux-gfs2:
      GFS2: constify attribute_group structures.
      gfs2: gfs2_create_inode: Keep glock across iput
      gfs2: Clean up glock work enqueuing
      gfs2: Protect gl->gl_object by spin lock
      gfs2: Get rid of flush_delayed_work in gfs2_evict_inode
      GFS2: Eliminate vestigial sd_log_flush_wrapped
      GFS2: Remove gl_list from glock structure
      GFS2: Withdraw when directory entry inconsistencies are detected

commit 6f6597baae206c544c49ad7f1129d5adc1e9019d
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Jun 30 07:55:08 2017 -0500

    gfs2: Protect gl->gl_object by spin lock
    
    Put all remaining accesses to gl->gl_object under the
    gl->gl_lockref.lock spinlock to prevent races.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 01af34cb589d..de4238493d80 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -857,5 +857,7 @@ static inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)
 	preempt_enable();
 }
 
+extern struct gfs2_rgrpd *gfs2_glock2rgrp(struct gfs2_glock *gl);
+
 #endif /* __INCORE_DOT_H__ */
 

commit 4fd1a5795214bc6405f14691c1344ae8c3f17215
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Fri Jun 30 07:47:15 2017 -0500

    gfs2: Get rid of flush_delayed_work in gfs2_evict_inode
    
    So far, gfs2_evict_inode clears gl->gl_object and then flushes the glock
    work queue to make sure that inode glops which dereference gl->gl_object
    have finished running before the inode is destroyed.  However, flushing
    the work queue may do more work than needed, and in particular, it may
    call into DLM, which we want to avoid here.  Use a bit lock
    (GIF_GLOP_PENDING) to synchronize between the inode glops and
    gfs2_evict_inode instead to get rid of the flushing.
    
    In addition, flush the work queues of existing glocks before reusing
    them for new inodes to get those glocks into a known state: the glock
    state engine currently doesn't handle glock re-appropriation correctly.
    (We may be able to fix the glock state engine instead later.)
    
    Based on a patch by Steven Whitehouse <swhiteho@redhat.com>.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 638c0203f242..01af34cb589d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -385,6 +385,7 @@ enum {
 	GIF_SW_PAGED		= 3,
 	GIF_ORDERED		= 4,
 	GIF_FREE_VFS_INODE      = 5,
+	GIF_GLOP_PENDING	= 6,
 };
 
 struct gfs2_inode {

commit 722f6f62a563108dc0f311bd86120b8fbfa0c6df
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Jun 20 09:52:57 2017 -0500

    GFS2: Eliminate vestigial sd_log_flush_wrapped
    
    Superblock variable sd_log_flush_wrapped is set, but never referenced,
    so this patch eliminates it.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 097adb1b3188..638c0203f242 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -820,7 +820,6 @@ struct gfs2_sbd {
 	wait_queue_head_t sd_reserving_log_wait;
 
 	unsigned int sd_log_flush_head;
-	u64 sd_log_flush_wrapped;
 
 	spinlock_t sd_ail_lock;
 	struct list_head sd_ail1_list;

commit df68f20f56084cffd15add2d7652bcdfb38cd875
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Jun 5 13:14:16 2017 -0500

    GFS2: Remove gl_list from glock structure
    
    The gl_list is no longer used nor needed in the glock structure,
    so this patch eliminates it.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b7cf65d13561..097adb1b3188 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -336,7 +336,6 @@ enum {
 };
 
 struct gfs2_glock {
-	struct hlist_bl_node gl_list;
 	unsigned long gl_flags;		/* GLF_... */
 	struct lm_lockname gl_name;
 

commit f729b66fca43d850d564b264c2033980c00a14b0
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 09:37:56 2017 +0200

    gfs2: remove the unused sd_log_error field
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b7cf65d13561..aa3d44527fa2 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -815,7 +815,6 @@ struct gfs2_sbd {
 	atomic_t sd_log_in_flight;
 	struct bio *sd_log_bio;
 	wait_queue_head_t sd_log_flush_wait;
-	int sd_log_error;
 
 	atomic_t sd_reserving_log;
 	wait_queue_head_t sd_reserving_log_wait;

commit 972b044eeca582ef173d063773e292bd9e8633d6
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Mar 16 09:54:57 2017 -0400

    gfs2: Don't pack struct lm_lockname
    
    As per a suggestion by Linus, don't pack struct lm_lockname: we did that
    because the struct is used as a rhashtable key, but packing tells the
    compiler that the 64-bit fields in the struct may be unaligned, causing
    it to generate worse code on some architectures.  Instead, rearrange the
    fields in the struct so that there is no padding between fields, and
    exclude any tail padding from the hash key size.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 511e1ed7e2de..b7cf65d13561 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -203,11 +203,15 @@ enum {
 	DFL_DLM_RECOVERY	= 6,
 };
 
+/*
+ * We are using struct lm_lockname as an rhashtable key.  Avoid holes within
+ * the struct; padding at the end is fine.
+ */
 struct lm_lockname {
-	struct gfs2_sbd *ln_sbd;
 	u64 ln_number;
+	struct gfs2_sbd *ln_sbd;
 	unsigned int ln_type;
-} __packed __aligned(sizeof(int));
+};
 
 #define lm_name_equal(name1, name2) \
         (((name1)->ln_number == (name2)->ln_number) &&	\

commit 28ea06c46fbcab63fd9a55531387b7928a18a590
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon Mar 6 12:58:42 2017 -0500

    gfs2: Avoid alignment hole in struct lm_lockname
    
    Commit 88ffbf3e03 switches to using rhashtables for glocks, hashing over
    the entire struct lm_lockname instead of its individual fields.  On some
    architectures, struct lm_lockname contains a hole of uninitialized
    memory due to alignment rules, which now leads to incorrect hash values.
    Get rid of that hole.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    CC: <stable@vger.kernel.org> #v4.3+

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c45084ac642d..511e1ed7e2de 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -207,7 +207,7 @@ struct lm_lockname {
 	struct gfs2_sbd *ln_sbd;
 	u64 ln_number;
 	unsigned int ln_type;
-};
+} __packed __aligned(sizeof(int));
 
 #define lm_name_equal(name1, name2) \
         (((name1)->ln_number == (name2)->ln_number) &&	\

commit 9862ca056e654633e521b303f74fb123f7f17e98
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Jan 25 12:50:47 2017 -0500

    GFS2: Switch tr_touched to flag in transaction
    
    This patch eliminates the int variable tr_touched in favor of a
    new flag in the transaction. This is a step toward reducing contention
    on the gfs2_log_lock spin_lock.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 00d8dc20ea3a..c45084ac642d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -470,15 +470,19 @@ struct gfs2_quota_data {
 	struct rcu_head qd_rcu;
 };
 
+enum {
+	TR_TOUCHED = 1,
+	TR_ATTACHED = 2,
+	TR_ALLOCED = 3,
+};
+
 struct gfs2_trans {
 	unsigned long tr_ip;
 
 	unsigned int tr_blocks;
 	unsigned int tr_revokes;
 	unsigned int tr_reserved;
-	unsigned int tr_touched:1;
-	unsigned int tr_attached:1;
-	unsigned int tr_alloced:1;
+	unsigned long tr_flags;
 
 	unsigned int tr_num_buf_new;
 	unsigned int tr_num_databuf_new;

commit f07b352021483a3a38f081dc284928400a9c1d2c
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Jan 5 16:01:45 2017 -0500

    GFS2: Made logd daemon take into account log demand
    
    Before this patch, the logd daemon only tried to flush things when
    the log blocks pinned exceeded a certain threshold. But when we're
    deleting very large files, it may require a huge number of journal
    blocks, and that, in turn, may exceed the threshold. This patch
    factors that into account.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a6a3389a07fc..00d8dc20ea3a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -794,6 +794,7 @@ struct gfs2_sbd {
 	atomic_t sd_log_thresh1;
 	atomic_t sd_log_thresh2;
 	atomic_t sd_log_blks_free;
+	atomic_t sd_log_blks_needed;
 	wait_queue_head_t sd_log_waitq;
 	wait_queue_head_t sd_logd_waitq;
 

commit a4923865ea071b0bd708339df7a83c76732fa2db
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Dec 7 16:24:27 2015 -0600

    GFS2: Prevent delete work from occurring on glocks used for create
    
    This patch tries to prevent delete work (queued via iopen callback)
    from executing if the glock is currently being used to create
    a new inode.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 845fb09cc606..a6a3389a07fc 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -328,6 +328,7 @@ enum {
 	GLF_LRU				= 13,
 	GLF_OBJECT			= 14, /* Used only for tracing */
 	GLF_BLOCKING			= 15,
+	GLF_INODE_CREATING		= 16, /* Inode creation occurring */
 };
 
 struct gfs2_glock {

commit 471f3db2786bc32011d6693413eb93b0c3da2579
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue Dec 1 08:46:55 2015 -0600

    gfs2: change gfs2 readdir cookie
    
    gfs2 currently returns 31 bits of filename hash as a cookie that readdir
    uses for an offset into the directory.  When there are a large number of
    directory entries, the likelihood of a collision goes up way too
    quickly.  GFS2 will now return cookies that are guaranteed unique for a
    while, and then fail back to using 30 bits of filename hash.
    Specifically, the directory leaf blocks are divided up into chunks based
    on the minimum size of a gfs2 directory entry (48 bytes). Each entry's
    cookie is based off the chunk where it starts, in the linked list of
    leaf blocks that it hashes to (there are 131072 hash buckets). Directory
    entries will have unique names until they take reach chunk 8192.
    Assuming the largest filenames possible, and the least efficient spacing
    possible, this new method will still be able to return unique names when
    the previous method has statistically more than a 99% chance of a
    collision.  The non-unique names it fails back to are guaranteed to not
    collide with the unique names.
    
    unique cookies will be in this format:
    - 1 bit "0" to make sure the the returned cookie is positive
    - 17 bits for the hash table index
    - 1 bit for the mode "0"
    - 13 bits for the offset
    
    non-unique cookies will be in this format:
    - 1 bit "0" to make sure the the returned cookie is positive
    - 17 bits for the hash table index
    - 1 bit for the mode "1"
    - 13 more bits of the name hash
    
    Another benefit of location based cookies, is that once a directory's
    exhash table is fully extended (so that multiple hash table indexs do
    not use the same leaf blocks), gfs2 can skip sorting the directory
    entries until it reaches the non-unique ones, and then it only needs to
    sort these. This provides a significant speed up for directory reads of
    very large directories.
    
    The only issue is that for these cookies to continue to point to the
    correct entry as files are added and removed from the directory, gfs2
    must keep the entries at the same offset in the leaf block when they are
    split (see my previous patch). This means that until all the nodes in a
    cluster are running with code that will split the directory leaf blocks
    this way, none of the nodes can use the new cookie code. To deal with
    this, gfs2 now has the mount option loccookie, which, if set, will make
    it return these new location based cookies.  This option must not be set
    until all nodes in the cluster are at least running this version of the
    kernel code, and you have guaranteed that there are no outstanding
    cookies required by other software, such as NFS.
    
    gfs2 uses some of the extra space at the end of the gfs2_dirent
    structure to store the calculated readdir cookies. This keeps us from
    needing to allocate a seperate array to hold these values.  gfs2
    recomputes the cookie stored in de_cookie for every readdir call.  The
    time it takes to do so is small, and if gfs2 expected this value to be
    saved on disk, the new code wouldn't work correctly on filesystems
    created with an earlier version of gfs2.
    
    One issue with adding de_cookie to the union in the gfs2_dirent
    structure is that it caused the union to align itself to a 4 byte
    boundary, instead of its previous 2 byte boundary. This changed the
    offset of de_rahead. To solve that, I pulled de_rahead out of the union,
    since it does not need to be there.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 921304e1d785..845fb09cc606 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -562,6 +562,8 @@ struct gfs2_args {
 	unsigned int ar_errors:2;               /* errors=withdraw | panic */
 	unsigned int ar_nobarrier:1;            /* do not send barriers */
 	unsigned int ar_rgrplvb:1;		/* use lvbs for rgrp info */
+	unsigned int ar_loccookie:1;		/* use location based readdir
+						   cookies */
 	int ar_commit;				/* Commit interval */
 	int ar_statfs_quantum;			/* The fast statfs interval */
 	int ar_quota_quantum;			/* The quota interval */
@@ -689,6 +691,7 @@ struct gfs2_sbd {
 	u64 sd_heightsize[GFS2_MAX_META_HEIGHT + 1];
 	u32 sd_max_jheight; /* Max height of journaled file's meta tree */
 	u64 sd_jheightsize[GFS2_MAX_META_HEIGHT + 1];
+	u32 sd_max_dents_per_leaf; /* Max number of dirents in a leaf block */
 
 	struct gfs2_args sd_args;	/* Mount arguments */
 	struct gfs2_tune sd_tune;	/* Filesystem tuning structure */

commit b58bf407ca4669a2dfcc00f5888ee719d9c34150
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Jul 24 09:45:43 2015 -0500

    GFS2: Reduce size of incore inode
    
    This patch makes no functional changes. Its goal is to reduce the
    size of the gfs2 inode in memory by rearranging structures and
    changing the size of some variables within the structure.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 25d0f12aaec5..921304e1d785 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -259,8 +259,8 @@ struct gfs2_holder {
 
 	struct gfs2_glock *gh_gl;
 	struct pid *gh_owner_pid;
-	unsigned int gh_state;
-	unsigned gh_flags;
+	u16 gh_flags;
+	u16 gh_state;
 
 	int gh_error;
 	unsigned long gh_iflags; /* HIF_... */

commit a097dc7e24cba7980bc5e2df461a4ef228e97e59
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Jul 16 08:28:04 2015 -0500

    GFS2: Make rgrp reservations part of the gfs2_inode structure
    
    Before this patch, multi-block reservation structures were allocated
    from a special slab. This patch folds the structure into the gfs2_inode
    structure. The disadvantage is that the gfs2_inode needs more memory,
    even when a file is opened read-only. The advantages are: (a) we don't
    need the special slab and the extra time it takes to allocate and
    deallocate from it. (b) we no longer need to worry that the structure
    exists for things like quota management. (c) This also allows us to
    remove the calls to get_write_access and put_write_access since we
    know the structure will exist.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6a22f66f058d..25d0f12aaec5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -394,7 +394,7 @@ struct gfs2_inode {
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
 	struct gfs2_qadata *i_qadata; /* quota allocation data */
-	struct gfs2_blkreserv *i_res; /* rgrp multi-block reservation */
+	struct gfs2_blkreserv i_res; /* rgrp multi-block reservation */
 	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;

commit b54e9a0b92d44843f6719ae22b0f6daf5b9b23b4
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Oct 26 10:40:28 2015 -0500

    GFS2: Extract quota data from reservations structure (revert 5407e24)
    
    This patch basically reverts the majority of patch 5407e24.
    That patch eliminated the gfs2_qadata structure in favor of just
    using the reservations structure. The problem with doing that is that
    it increases the size of the reservations structure. That is not an
    issue until it comes time to fold the reservations structure into the
    inode in memory so we know it's always there. By separating out the
    quota structure again, we aren't punishing the non-quota users by
    making all the inodes bigger, requiring more slab space. This patch
    creates a new slab area to allocate the quota stuff so it's managed
    a little more sanely.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 77e778496903..6a22f66f058d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -270,6 +270,13 @@ struct gfs2_holder {
 /* Number of quota types we support */
 #define GFS2_MAXQUOTAS 2
 
+struct gfs2_qadata { /* quota allocation data */
+	/* Quota stuff */
+	struct gfs2_quota_data *qa_qd[2 * GFS2_MAXQUOTAS];
+	struct gfs2_holder qa_qd_ghs[2 * GFS2_MAXQUOTAS];
+	unsigned int qa_qd_num;
+};
+
 /* Resource group multi-block reservation, in order of appearance:
 
    Step 1. Function prepares to write, allocates a mb, sets the size hint.
@@ -288,11 +295,6 @@ struct gfs2_blkreserv {
 	struct gfs2_rbm rs_rbm;       /* Start of reservation */
 	u32 rs_free;                  /* how many blocks are still free */
 	u64 rs_inum;                  /* Inode number for reservation */
-
-	/* ancillary quota stuff */
-	struct gfs2_quota_data *rs_qa_qd[2 * GFS2_MAXQUOTAS];
-	struct gfs2_holder rs_qa_qd_ghs[2 * GFS2_MAXQUOTAS];
-	unsigned int rs_qa_qd_num;
 };
 
 /*
@@ -391,6 +393,7 @@ struct gfs2_inode {
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
+	struct gfs2_qadata *i_qadata; /* quota allocation data */
 	struct gfs2_blkreserv *i_res; /* rgrp multi-block reservation */
 	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */

commit c8d577038449a718ad0027d1790b6ef4441715d4
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Nov 11 15:00:35 2015 -0600

    gfs2: Extended attribute readahead
    
    When gfs2 allocates an inode and its extended attribute block next to
    each other at inode create time, the inode's directory entry indicates
    that in de_rahead.  In that case, we can readahead the extended
    attribute block when we read in the inode.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index de7b4f97ac75..77e778496903 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -402,6 +402,7 @@ struct gfs2_inode {
 	u32 i_diskflags;
 	u8 i_height;
 	u8 i_depth;
+	u16 i_rahead;
 };
 
 /*

commit f3dd1649122b9e73f869e5304d5fa8554e128b7a
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Oct 29 10:58:09 2015 -0500

    gfs2: Remove gl_spin define
    
    Commit e66cf161 replaced the gl_spin spinlock in struct gfs2_glock with a
    gl_lockref lockref and defined gl_spin as gl_lockref.lock (the spinlock in
    gl_lockref).  Remove that define to make the references to gl_lockref.lock more
    obvious.
    
    Signed-off-by: Andreas Gruenbacher <andreas.gruenbacher@gmail.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 121ed08d9d9f..de7b4f97ac75 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -334,9 +334,8 @@ struct gfs2_glock {
 	struct lm_lockname gl_name;
 
 	struct lockref gl_lockref;
-#define gl_spin gl_lockref.lock
 
-	/* State fields protected by gl_spin */
+	/* State fields protected by gl_lockref.lock */
 	unsigned int gl_state:2,	/* Current state */
 		     gl_target:2,	/* Target state */
 		     gl_demote_state:2,	/* State requested by remote node */

commit 4d207133e9c362bc05a3bb6701d63eeb75cc4b77
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Thu Aug 27 12:51:45 2015 -0500

    gfs2: Make statistics unsigned, suitable for use with do_div()
    
    None of these statistics can meaningfully be negative, and the
    numerator for do_div() must have the type u64.  The generic
    implementation of do_div() used on some 32-bit architectures asserts
    that, resulting in a compiler error in gfs2_rgrp_congested().
    
    Fixes: 0166b197c2ed ("GFS2: Average in only non-zero round-trip times ...")
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e300f7419090..121ed08d9d9f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -244,7 +244,7 @@ enum {
 };
 
 struct gfs2_lkstats {
-	s64 stats[GFS2_NR_LKSTATS];
+	u64 stats[GFS2_NR_LKSTATS];
 };
 
 enum {

commit 88ffbf3e037e67b52c46d528aca1618489c21f68
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Mar 16 11:02:46 2015 -0500

    GFS2: Use resizable hash table for glocks
    
    This patch changes the glock hash table from a normal hash table to
    a resizable hash table, which scales better. This also simplifies
    a lot of code.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 35a55f3d6d3b..e300f7419090 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -22,6 +22,7 @@
 #include <linux/ktime.h>
 #include <linux/percpu.h>
 #include <linux/lockref.h>
+#include <linux/rhashtable.h>
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
@@ -342,7 +343,6 @@ struct gfs2_glock {
 		     gl_req:2,		/* State in last dlm request */
 		     gl_reply:8;	/* Last reply from the dlm */
 
-	unsigned int gl_hash;
 	unsigned long gl_demote_time; /* time of first demote request */
 	long gl_hold_time;
 	struct list_head gl_holders;
@@ -368,7 +368,7 @@ struct gfs2_glock {
 			loff_t end;
 		} gl_vm;
 	};
-	struct rcu_head gl_rcu;
+	struct rhash_head gl_node;
 };
 
 #define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */

commit 15562c439d0a1850b71aa1c0d92d1f4fb9503c8d
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Mar 16 11:52:05 2015 -0500

    GFS2: Move glock superblock pointer to field gl_name
    
    What uniquely identifies a glock in the glock hash table is not
    gl_name, but gl_name and its superblock pointer. This patch makes
    the gl_name field correspond to a unique glock identifier. That will
    allow us to simplify hashing with a future patch, since the hash
    algorithm can then take the gl_name and hash its components in one
    operation.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a1ec7c20e498..35a55f3d6d3b 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -203,13 +203,15 @@ enum {
 };
 
 struct lm_lockname {
+	struct gfs2_sbd *ln_sbd;
 	u64 ln_number;
 	unsigned int ln_type;
 };
 
 #define lm_name_equal(name1, name2) \
-        (((name1)->ln_number == (name2)->ln_number) && \
-         ((name1)->ln_type == (name2)->ln_type))
+        (((name1)->ln_number == (name2)->ln_number) &&	\
+	 ((name1)->ln_type == (name2)->ln_type) &&	\
+	 ((name1)->ln_sbd == (name2)->ln_sbd))
 
 
 struct gfs2_glock_operations {
@@ -327,7 +329,6 @@ enum {
 
 struct gfs2_glock {
 	struct hlist_bl_node gl_list;
-	struct gfs2_sbd *gl_sbd;
 	unsigned long gl_flags;		/* GLF_... */
 	struct lm_lockname gl_name;
 
@@ -835,7 +836,7 @@ static inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)
 
 static inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)
 {
-	const struct gfs2_sbd *sdp = gl->gl_sbd;
+	const struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
 	preempt_disable();
 	this_cpu_ptr(sdp->sd_lkstats)->lkstats[gl->gl_name.ln_type].stats[which]++;
 	preempt_enable();

commit e7ccaf5fe1590667b3fa2f8df5c5ec9ba0dc5b85
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Jun 12 13:15:54 2015 -0500

    GFS2: Don't add all glocks to the lru
    
    The glocks used for resource groups often come and go hundreds of
    thousands of times per second. Adding them to the lru list just
    adds unnecessary contention for the lru_lock spin_lock, especially
    considering we're almost certainly going to re-use the glock and
    take it back off the lru microseconds later. We never want the
    glock shrinker to cull them anyway. This patch adds a new bit in
    the glops that determines which glock types get put onto the lru
    list and which ones don't.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 304a22315448..a1ec7c20e498 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -225,6 +225,7 @@ struct gfs2_glock_operations {
 	const unsigned long go_flags;
 #define GLOF_ASPACE 1
 #define GLOF_LVB    2
+#define GLOF_LRU    4
 };
 
 enum {

commit 9cde2898d04595c3bf24828822b3ea7acff181dd
Author: Abhi Das <adas@redhat.com>
Date:   Tue Jun 2 11:03:04 2015 -0500

    gfs2: limit quota log messages
    
    This patch makes the quota subsystem only report once that a
    particular user/group has exceeded their allotted quota.
    
    Previously, it was possible for a program to continuously try
    exceeding quota (despite receiving EDQUOT) and in turn trigger
    gfs2 to issue a kernel log message about quota exceed. In theory,
    this could get out of hand and flood the log and the filesystem
    hosting the log files.
    
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 58b75abf6ab2..304a22315448 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -432,6 +432,7 @@ enum {
 	QDF_CHANGE		= 1,
 	QDF_LOCKED		= 2,
 	QDF_REFRESH		= 3,
+	QDF_QMSG_QUIET          = 4,
 };
 
 struct gfs2_quota_data {

commit 25435e5ed611f310dda889940cbc4c45b3ecd9ec
Author: Abhi Das <adas@redhat.com>
Date:   Wed Mar 18 12:04:37 2015 -0500

    gfs2: allow quota_check and inplace_reserve to return available blocks
    
    struct gfs2_alloc_parms is passed to gfs2_quota_check() and
    gfs2_inplace_reserve() with ap->target containing the number of
    blocks being requested for allocation in the current operation.
    
    We add a new field to struct gfs2_alloc_parms called 'allowed'.
    gfs2_quota_check() and gfs2_inplace_reserve() return the max
    blocks allowed by quota and the max blocks allowed by the chosen
    rgrp respectively in 'allowed'.
    
    A new field 'min_target', when non-zero, tells gfs2_quota_check()
    and gfs2_inplace_reserve() to not return -EDQUOT/-ENOSPC when
    there are atleast 'min_target' blocks allowable/available. The
    assumption is that the caller is ok with just 'min_target' blocks
    and will likely proceed with allocating them.
    
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3a4ea50c9113..58b75abf6ab2 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -302,7 +302,9 @@ struct gfs2_blkreserv {
  */
 struct gfs2_alloc_parms {
 	u64 target;
+	u32 min_target;
 	u32 aflags;
+	u64 allowed;
 };
 
 enum {

commit b8fbf471edb3dbf441716fd2a52a7ca76c381381
Author: Abhi Das <adas@redhat.com>
Date:   Wed Mar 18 12:03:41 2015 -0500

    gfs2: perform quota checks against allocation parameters
    
    Use struct gfs2_alloc_parms as an argument to gfs2_quota_check()
    and gfs2_quota_lock_check() to check for quota violations while
    accounting for the new blocks requested by the current operation
    in ap->target.
    
    Previously, the number of new blocks requested during an operation
    were not accounted for during quota_check and would allow these
    operations to exceed quota. This was not very apparent since most
    operations allocated only 1 block at a time and quotas would get
    violated in the next operation. i.e. quota excess would only be by
    1 block or so. With fallocate, (where we allocate a bunch of blocks
    at once) the quota excess is non-trivial and is addressed by this
    patch.
    
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7a2dbbc0d634..3a4ea50c9113 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -301,7 +301,7 @@ struct gfs2_blkreserv {
  * to the allocation code.
  */
 struct gfs2_alloc_parms {
-	u32 target;
+	u64 target;
 	u32 aflags;
 };
 

commit 2e60d7683c8d2ea21317f6d9f4cd3bf5428ce162
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Thu Nov 13 20:42:04 2014 -0600

    GFS2: update freeze code to use freeze/thaw_super on all nodes
    
    The current gfs2 freezing code is considerably more complicated than it
    should be because it doesn't use the vfs freezing code on any node except
    the one that begins the freeze.  This is because it needs to acquire a
    cluster glock before calling the vfs code to prevent a deadlock, and
    without the new freeze_super and thaw_super hooks, that was impossible. To
    deal with the issue, gfs2 had to do some hacky locking tricks to make sure
    that a frozen node couldn't be holding on a lock it needed to do the
    unfreeze ioctl.
    
    This patch makes use of the new hooks to simply the gfs2 locking code. Now,
    all the nodes in the cluster freeze and thaw in exactly the same way. Every
    node in the cluster caches the freeze glock in the shared state.  The new
    freeze_super hook allows the freezing node to grab this freeze glock in
    the exclusive state without first calling the vfs freeze_super function.
    All the nodes in the cluster see this lock change, and call the vfs
    freeze_super function. The vfs locking code guarantees that the nodes can't
    get stuck holding the glocks necessary to unfreeze the system.  To
    unfreeze, the freezing node uses the new thaw_super hook to drop the freeze
    glock. Again, all the nodes notice this, reacquire the glock in shared mode
    and call the vfs thaw_super function.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1b899187be5a..7a2dbbc0d634 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -588,6 +588,12 @@ enum {
 	SDF_SKIP_DLM_UNLOCK	= 8,
 };
 
+enum gfs2_freeze_state {
+	SFS_UNFROZEN		= 0,
+	SFS_STARTING_FREEZE	= 1,
+	SFS_FROZEN		= 2,
+};
+
 #define GFS2_FSNAME_LEN		256
 
 struct gfs2_inum_host {
@@ -685,6 +691,7 @@ struct gfs2_sbd {
 	struct gfs2_holder sd_live_gh;
 	struct gfs2_glock *sd_rename_gl;
 	struct gfs2_glock *sd_freeze_gl;
+	struct work_struct sd_freeze_work;
 	wait_queue_head_t sd_glock_wait;
 	atomic_t sd_glock_disposal;
 	struct completion sd_locking_init;
@@ -789,6 +796,9 @@ struct gfs2_sbd {
 	wait_queue_head_t sd_log_flush_wait;
 	int sd_log_error;
 
+	atomic_t sd_reserving_log;
+	wait_queue_head_t sd_reserving_log_wait;
+
 	unsigned int sd_log_flush_head;
 	u64 sd_log_flush_wrapped;
 
@@ -798,12 +808,8 @@ struct gfs2_sbd {
 
 	/* For quiescing the filesystem */
 	struct gfs2_holder sd_freeze_gh;
-	struct gfs2_holder sd_freeze_root_gh;
-	struct gfs2_holder sd_thaw_gh;
-	atomic_t sd_log_freeze;
-	atomic_t sd_frozen_root;
-	wait_queue_head_t sd_frozen_root_wait;
-	wait_queue_head_t sd_log_frozen_wait;
+	atomic_t sd_freeze_state;
+	struct mutex sd_freeze_mutex;
 
 	char sd_fsname[GFS2_FSNAME_LEN];
 	char sd_table_name[GFS2_FSNAME_LEN];

commit 0e27c18c30f6850ecd0fb67143f202f0426d76d7
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Oct 29 08:02:28 2014 -0500

    GFS2: Set of distributed preferences for rgrps
    
    This patch tries to use the journal numbers to evenly distribute
    which node prefers which resource group for block allocations. This
    is to help performance.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 39e7e9959b74..1b899187be5a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -97,6 +97,7 @@ struct gfs2_rgrpd {
 #define GFS2_RDF_CHECK		0x10000000 /* check for unlinked inodes */
 #define GFS2_RDF_UPTODATE	0x20000000 /* rg is up to date */
 #define GFS2_RDF_ERROR		0x40000000 /* error in rg */
+#define GFS2_RDF_PREFERRED	0x80000000 /* This rgrp is preferred */
 #define GFS2_RDF_MASK		0xf0000000 /* mask for internal flags */
 	spinlock_t rd_rsspin;           /* protects reservation related vars */
 	struct rb_root rd_rstree;       /* multi-block reservation tree */

commit a937cca270c544c4319572b57b196b2251b07dd2
Author: Jan Kara <jack@suse.cz>
Date:   Wed Sep 10 21:22:51 2014 +0200

    GFS2: Don't use MAXQUOTAS value
    
    MAXQUOTAS value defines maximum number of quota types VFS supports.
    This isn't necessarily the number of types gfs2 supports and with
    addition of project quotas these two numbers stop matching. So make gfs2
    use its private definition.
    
    CC: cluster-devel@redhat.com
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 67d310c9ada3..39e7e9959b74 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -262,6 +262,9 @@ struct gfs2_holder {
 	unsigned long gh_ip;
 };
 
+/* Number of quota types we support */
+#define GFS2_MAXQUOTAS 2
+
 /* Resource group multi-block reservation, in order of appearance:
 
    Step 1. Function prepares to write, allocates a mb, sets the size hint.
@@ -282,8 +285,8 @@ struct gfs2_blkreserv {
 	u64 rs_inum;                  /* Inode number for reservation */
 
 	/* ancillary quota stuff */
-	struct gfs2_quota_data *rs_qa_qd[2 * MAXQUOTAS];
-	struct gfs2_holder rs_qa_qd_ghs[2 * MAXQUOTAS];
+	struct gfs2_quota_data *rs_qa_qd[2 * GFS2_MAXQUOTAS];
+	struct gfs2_holder rs_qa_qd_ghs[2 * GFS2_MAXQUOTAS];
 	unsigned int rs_qa_qd_num;
 };
 

commit 0e48e055a7dfc0cf17bbabe4d9b523ee0b1a9ed6
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Jun 2 09:40:25 2014 -0400

    GFS2: Prevent recovery before the local journal is set
    
    This patch uses a completion to prevent dlm's recovery process from
    referencing and trying to recover a journal before a journal has been
    opened.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 2434a96f95df..67d310c9ada3 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -728,6 +728,8 @@ struct gfs2_sbd {
 	struct gfs2_holder sd_sc_gh;
 	struct gfs2_holder sd_qc_gh;
 
+	struct completion sd_journal_ready;
+
 	/* Daemon stuff */
 
 	struct task_struct *sd_logd_process;

commit 24972557b12ce8fd5b6c6847d0e2ee1837ddc13b
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Thu May 1 22:26:55 2014 -0500

    GFS2: remove transaction glock
    
    GFS2 has a transaction glock, which must be grabbed for every
    transaction, whose purpose is to deal with freezing the filesystem.
    Aside from this involving a large amount of locking, it is very easy to
    make the current fsfreeze code hang on unfreezing.
    
    This patch rewrites how gfs2 handles freezing the filesystem. The
    transaction glock is removed. In it's place is a freeze glock, which is
    cached (but not held) in a shared state by every node in the cluster
    when the filesystem is mounted. This lock only needs to be grabbed on
    freezing, and actions which need to be safe from freezing, like
    recovery.
    
    When a node wants to freeze the filesystem, it grabs this glock
    exclusively.  When the freeze glock state changes on the nodes (either
    from shared to unlocked, or shared to exclusive), the filesystem does a
    special log flush.  gfs2_log_flush() does all the work for flushing out
    the and shutting down the incore log, and then it tries to grab the
    freeze glock in a shared state again.  Since the filesystem is stuck in
    gfs2_log_flush, no new transaction can start, and nothing can be written
    to disk. Unfreezing the filesytem simply involes dropping the freeze
    glock, allowing gfs2_log_flush() to grab and then release the shared
    lock, so it is cached for next time.
    
    However, in order for the unfreezing ioctl to occur, gfs2 needs to get a
    shared lock on the filesystem root directory inode to check permissions.
    If that glock has already been grabbed exclusively, fsfreeze will be
    unable to get the shared lock and unfreeze the filesystem.
    
    In order to allow the unfreeze, this patch makes gfs2 grab a shared lock
    on the filesystem root directory during the freeze, and hold it until it
    unfreezes the filesystem.  The functions which need to grab a shared
    lock in order to allow the unfreeze ioctl to be issued now use the lock
    grabbed by the freeze code instead.
    
    The freeze and unfreeze code take care to make sure that this shared
    lock will not be dropped while another process is using it.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index bdf70c18610c..2434a96f95df 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -465,9 +465,7 @@ struct gfs2_trans {
 	unsigned int tr_reserved;
 	unsigned int tr_touched:1;
 	unsigned int tr_attached:1;
-
-	struct gfs2_holder tr_t_gh;
-
+	unsigned int tr_alloced:1;
 
 	unsigned int tr_num_buf_new;
 	unsigned int tr_num_databuf_new;
@@ -682,7 +680,7 @@ struct gfs2_sbd {
 	struct lm_lockstruct sd_lockstruct;
 	struct gfs2_holder sd_live_gh;
 	struct gfs2_glock *sd_rename_gl;
-	struct gfs2_glock *sd_trans_gl;
+	struct gfs2_glock *sd_freeze_gl;
 	wait_queue_head_t sd_glock_wait;
 	atomic_t sd_glock_disposal;
 	struct completion sd_locking_init;
@@ -794,6 +792,12 @@ struct gfs2_sbd {
 
 	/* For quiescing the filesystem */
 	struct gfs2_holder sd_freeze_gh;
+	struct gfs2_holder sd_freeze_root_gh;
+	struct gfs2_holder sd_thaw_gh;
+	atomic_t sd_log_freeze;
+	atomic_t sd_frozen_root;
+	wait_queue_head_t sd_frozen_root_wait;
+	wait_queue_head_t sd_log_frozen_wait;
 
 	char sd_fsname[GFS2_FSNAME_LEN];
 	char sd_table_name[GFS2_FSNAME_LEN];

commit 059788039f1e6343f34f46d202f8d9f2158c2783
Author: Abhi Das <adas@redhat.com>
Date:   Mon Mar 31 10:33:17 2014 -0500

    GFS2: Fix uninitialized VFS inode in gfs2_create_inode
    
    When gfs2_create_inode() fails due to quota violation, the VFS
    inode is not completely uninitialized. This can cause a list
    corruption error.
    
    This patch correctly uninitializes the VFS inode when a quota
    violation occurs in the gfs2_create_inode codepath.
    
    Resolves: rhbz#1059808
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index ef26ed98e778..bdf70c18610c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -371,6 +371,7 @@ enum {
 	GIF_ALLOC_FAILED	= 2,
 	GIF_SW_PAGED		= 3,
 	GIF_ORDERED		= 4,
+	GIF_FREE_VFS_INODE      = 5,
 };
 
 struct gfs2_inode {

commit a17d758b661d6fa01a0d466d7bdda3c131bb68f9
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Mar 6 17:19:15 2014 -0500

    GFS2: Move recovery variables to journal structure in memory
    
    If multiple nodes fail and their recovery work runs simultaneously, they
    would use the same unprotected variables in the superblock. For example,
    they would stomp on each other's revoked blocks lists, which resulted
    in file system metadata corruption. This patch moves the necessary
    variables so that each journal has its own separate area for tracking
    its journal replay.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 456d8fa9da2b..ef26ed98e778 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -503,6 +503,15 @@ struct gfs2_jdesc {
 	unsigned int jd_jid;
 	unsigned int jd_blocks;
 	int jd_recover_error;
+	/* Replay stuff */
+
+	unsigned int jd_found_blocks;
+	unsigned int jd_found_revokes;
+	unsigned int jd_replayed_blocks;
+
+	struct list_head jd_revoke_list;
+	unsigned int jd_replay_tail;
+
 };
 
 struct gfs2_statfs_change_host {
@@ -782,15 +791,6 @@ struct gfs2_sbd {
 	struct list_head sd_ail1_list;
 	struct list_head sd_ail2_list;
 
-	/* Replay stuff */
-
-	struct list_head sd_revoke_list;
-	unsigned int sd_replay_tail;
-
-	unsigned int sd_found_blocks;
-	unsigned int sd_found_revokes;
-	unsigned int sd_replayed_blocks;
-
 	/* For quiescing the filesystem */
 	struct gfs2_holder sd_freeze_gh;
 

commit b50f227bddf110ae4ea2df1ebdf7e282ad481803
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Mar 3 13:35:57 2014 +0000

    GFS2: Clean up journal extent mapping
    
    This patch fixes a long standing issue in mapping the journal
    extents. Most journals will consist of only a single extent,
    and although the cache took account of that by merging extents,
    it did not actually map large extents, but instead was doing a
    block by block mapping. Since the journal was only being mapped
    on mount, this was not normally noticeable.
    
    With the updated code, it is now possible to use the same extent
    mapping system during journal recovery (which will be added in a
    later patch). This will allow checking of the integrity of the
    journal before any reply of the journal content is attempted. For
    this reason the code is moving to bmap.c, since it will be used
    more widely in due course.
    
    An exercise left for the reader is to compare the new function
    gfs2_map_journal_extents() with gfs2_write_alloc_required()
    
    Additionally, should there be a failure, the error reporting is
    also updated to show more detail about what went wrong.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index d0c3928b2dea..456d8fa9da2b 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -485,7 +485,7 @@ struct gfs2_trans {
 };
 
 struct gfs2_journal_extent {
-	struct list_head extent_list;
+	struct list_head list;
 
 	unsigned int lblock; /* First logical block */
 	u64 dblock; /* First disk block */
@@ -495,6 +495,7 @@ struct gfs2_journal_extent {
 struct gfs2_jdesc {
 	struct list_head jd_list;
 	struct list_head extent_list;
+	unsigned int nr_extents;
 	struct work_struct jd_work;
 	struct inode *jd_inode;
 	unsigned long jd_flags;

commit 022ef4feed0c648aeb72d0c8ad06d266de08f525
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 21 21:55:33 2014 +0000

    GFS2: Move log buffer accounting to transaction
    
    Now we have a master transaction into which other transactions
    are merged, the accounting can be done using this master
    transaction. We no longer require the superblock fields which
    were being used for this function.
    
    In addition, this allows for a clean up in calc_reserved()
    making it rather easier understand. Also, by reducing the
    number of variables used to track the buffers being added
    and removed from the journal, a number of error checks are
    now no longer required.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 99aab64c771a..d0c3928b2dea 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -748,15 +748,10 @@ struct gfs2_sbd {
 
 	struct gfs2_trans *sd_log_tr;
 	unsigned int sd_log_blks_reserved;
-	unsigned int sd_log_commited_buf;
-	unsigned int sd_log_commited_databuf;
 	int sd_log_commited_revoke;
 
 	atomic_t sd_log_pinned;
-	unsigned int sd_log_num_buf;
 	unsigned int sd_log_num_revoke;
-	unsigned int sd_log_num_rg;
-	unsigned int sd_log_num_databuf;
 
 	struct list_head sd_log_le_revoke;
 	struct list_head sd_log_le_ordered;

commit d69a3c6561362a53d1be908ca343d899161d602c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 21 15:22:35 2014 +0000

    GFS2: Move log buffer lists into transaction
    
    Over time, we hope to be able to improve the concurrency available
    in the log code. This is one small step towards that, by moving
    the buffer lists from the super block, and into the transaction
    structure, so that each transaction builds its own buffer lists.
    
    At transaction commit time, the buffer lists are merged into
    the currently accumulating transaction. That transaction then
    is passed into the before and after commit functions at journal
    flush time. Thus there should be no change in overall behaviour
    yet.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 645655cccdc8..99aab64c771a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -52,7 +52,7 @@ struct gfs2_log_header_host {
  */
 
 struct gfs2_log_operations {
-	void (*lo_before_commit) (struct gfs2_sbd *sdp);
+	void (*lo_before_commit) (struct gfs2_sbd *sdp, struct gfs2_trans *tr);
 	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_trans *tr);
 	void (*lo_before_scan) (struct gfs2_jdesc *jd,
 				struct gfs2_log_header_host *head, int pass);
@@ -476,6 +476,8 @@ struct gfs2_trans {
 	unsigned int tr_num_revoke_rm;
 
 	struct list_head tr_list;
+	struct list_head tr_databuf;
+	struct list_head tr_buf;
 
 	unsigned int tr_first;
 	struct list_head tr_ail1_list;
@@ -756,9 +758,7 @@ struct gfs2_sbd {
 	unsigned int sd_log_num_rg;
 	unsigned int sd_log_num_databuf;
 
-	struct list_head sd_log_le_buf;
 	struct list_head sd_log_le_revoke;
-	struct list_head sd_log_le_databuf;
 	struct list_head sd_log_le_ordered;
 	spinlock_t sd_ordered_lock;
 

commit 654a6d2f962edb7bf85973cfe93a04e24f56f902
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 21 11:52:00 2014 +0000

    GFS2: Reduce struct gfs2_trans in size
    
    A couple of "int" fields were being used as boolean values
    so we can make them bitfields of one bit, and put them in
    what might otherwise be a hole in the structure with 64
    bit alignment.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index cf0e34400f71..645655cccdc8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -462,11 +462,11 @@ struct gfs2_trans {
 	unsigned int tr_blocks;
 	unsigned int tr_revokes;
 	unsigned int tr_reserved;
+	unsigned int tr_touched:1;
+	unsigned int tr_attached:1;
 
 	struct gfs2_holder tr_t_gh;
 
-	int tr_touched;
-	int tr_attached;
 
 	unsigned int tr_num_buf_new;
 	unsigned int tr_num_databuf_new;

commit ac3beb6a5de048e7c0676f630ad2048a7b37b305
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jan 16 10:31:13 2014 +0000

    GFS2: Don't use ENOBUFS when ENOMEM is the correct error code
    
    Al Viro has tactfully pointed out that we are using the incorrect
    error code in some cases. This patch fixes that, and also removes
    the (unused) return value for glock dumping.
    
    >        * gfs2_iget() - ENOBUFS instead of ENOMEM.  ENOBUFS is
    > "No buffer space available (POSIX.1 (XSI STREAMS option))" and since
    > we don't support STREAMS it's probably fair game, but... what the hell?
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8c64e268b7ef..cf0e34400f71 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -218,7 +218,7 @@ struct gfs2_glock_operations {
 	int (*go_demote_ok) (const struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
-	int (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
+	void (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
 	void (*go_callback)(struct gfs2_glock *gl, bool remote);
 	const int go_type;
 	const unsigned long go_flags;

commit 2d9e72303d538024627fb1fe2cbde48aec12acc0
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Dec 13 11:46:28 2013 +0000

    GFS2: Move quota bitmap operations under their own lock
    
    Gradually, the global qd_lock is being used for less and less.
    After this patch it will only be used for the per super block
    list whose purpose is to allow syncing of changes back to the
    master quota file from the local quota changes file. Fixing
    up that process to make it more efficient will be the subject
    of a later patch, however this patch removes another barrier
    to doing that.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Abhijith Das <adas@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4b9aa5b6908c..8c64e268b7ef 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -734,6 +734,7 @@ struct gfs2_sbd {
 
 	unsigned int sd_quota_slots;
 	unsigned long *sd_quota_bitmap;
+	spinlock_t sd_bitmap_lock;
 
 	u64 sd_quota_sync_gen;
 

commit ee2411a8db49a21bc55dc124e1b434ba194c8903
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Dec 12 17:29:32 2013 +0000

    GFS2: Clean up quota slot allocation
    
    Quota slot allocation has historically used a vector of pages
    and a set of homegrown find/test/set/clear bit functions. Since
    the size of the bitmap is likely to be based on the default
    qc file size, thats a couple of pages at most. So we ought
    to be able to allocate that as a single chunk, with a vmalloc
    fallback, just in case of memory fragmentation.
    
    We are then able to use the kernel's own find/test/set/clear
    bit functions, rather than rolling our own.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Abhijith Das <adas@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 59d99ec9d875..4b9aa5b6908c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -733,8 +733,7 @@ struct gfs2_sbd {
 	spinlock_t sd_trunc_lock;
 
 	unsigned int sd_quota_slots;
-	unsigned int sd_quota_chunks;
-	unsigned char **sd_quota_bitmap;
+	unsigned long *sd_quota_bitmap;
 
 	u64 sd_quota_sync_gen;
 

commit c754fbbb1b6bf462c6ddba48b19f20adf2335cac
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Dec 12 10:47:59 2013 +0000

    GFS2: Use RCU/hlist_bl based hash for quotas
    
    Prior to this patch, GFS2 kept all the quotas for each
    super block in a single linked list. This is rather slow
    when there are large numbers of quotas.
    
    This patch introduces a hlist_bl based hash table, similar
    to the one used for glocks. The initial look up of the quota
    is now lockless in the case where it is already cached,
    although we still have to take the per quota spinlock in
    order to bump the ref count. Either way though, this is a
    big improvement on what was there before.
    
    The qd_lock and the per super block list is preserved, for
    the time being. However it is intended that since this is no
    longer used for its original role, it should be possible to
    shrink the number of items on that list in due course and
    remove the requirement to take qd_lock in qd_get.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Abhijith Das <adas@redhat.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a99f60c98845..59d99ec9d875 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -428,10 +428,13 @@ enum {
 };
 
 struct gfs2_quota_data {
+	struct hlist_bl_node qd_hlist;
 	struct list_head qd_list;
 	struct kqid qd_id;
+	struct gfs2_sbd *qd_sbd;
 	struct lockref qd_lockref;
 	struct list_head qd_lru;
+	unsigned qd_hash;
 
 	unsigned long qd_flags;		/* QDF_... */
 
@@ -450,6 +453,7 @@ struct gfs2_quota_data {
 
 	u64 qd_sync_gen;
 	unsigned long qd_last_warn;
+	struct rcu_head qd_rcu;
 };
 
 struct gfs2_trans {

commit 70d4ee94b370c5ef54d0870600f16bd92d18013c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Dec 6 16:19:54 2013 +0000

    GFS2: Use only a single address space for rgrps
    
    Prior to this patch, GFS2 had one address space for each rgrp,
    stored in the glock. This patch changes them to use a single
    address space in the super block. This therefore saves
    (sizeof(struct address_space) * nr_of_rgrps) bytes of memory
    and for large filesystems, that can be significant.
    
    It would be nice to be able to do something similar and merge
    the inode metadata address space into the same global
    address space. However, that is rather more complicated as the
    on-disk location doesn't have a 1:1 mapping with the inodes in
    general. So while it could be done, it will be a more complicated
    operation as it requires changing a lot more code paths.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e6544ee0c137..a99f60c98845 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -736,6 +736,8 @@ struct gfs2_sbd {
 
 	/* Log stuff */
 
+	struct address_space sd_aspace;
+
 	spinlock_t sd_log_lock;
 
 	struct gfs2_trans *sd_log_tr;

commit 7005c3e4ae42858dbb695b2d03d340af799b1f1b
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Dec 6 10:16:14 2013 +0000

    GFS2: Use range based functions for rgrp sync/invalidation
    
    Each rgrp header is represented as a single extent on disk, so we
    can calculate the position within the address space, since we are
    using address spaces mapped 1:1 to the disk. This means that it
    is possible to use the range based versions of filemap_fdatawrite/wait
    and for invalidating the page cache.
    
    Our eventual intent is to then be able to merge the address spaces
    used for rgrps into a single address space, rather than to have
    one for each glock, saving memory and reducing complexity.
    
    Since during umount, the rgrp structures are disposed of before
    the glocks, we need to store the extent information in the glock
    so that is is available for a final invalidation. This patch uses
    a field which is otherwise unused in rgrp glocks to do that, so
    that we do not have to expand the size of a glock.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 01328162c952..e6544ee0c137 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -351,7 +351,15 @@ struct gfs2_glock {
 	atomic_t gl_ail_count;
 	atomic_t gl_revokes;
 	struct delayed_work gl_work;
-	struct work_struct gl_delete;
+	union {
+		/* For inode and iopen glocks only */
+		struct work_struct gl_delete;
+		/* For rgrp glocks only */
+		struct {
+			loff_t start;
+			loff_t end;
+		} gl_vm;
+	};
 	struct rcu_head gl_rcu;
 };
 

commit 5ea5050cec9c02e86ceb5e707a889003f895a690
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Nov 25 11:16:25 2013 +0000

    GFS2: Implement a "rgrp has no extents longer than X" scheme
    
    With the preceding patch, we started accepting block reservations
    smaller than the ideal size, which requires a lot more parsing of the
    bitmaps. To reduce the amount of bitmap searching, this patch
    implements a scheme whereby each rgrp keeps track of the point
    at this multi-block reservations will fail.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index ba1ea67f4eeb..01328162c952 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -93,6 +93,7 @@ struct gfs2_rgrpd {
 	struct gfs2_rgrp_lvb *rd_rgl;
 	u32 rd_last_alloc;
 	u32 rd_flags;
+	u32 rd_extfail_pt;		/* extent failure point */
 #define GFS2_RDF_CHECK		0x10000000 /* check for unlinked inodes */
 #define GFS2_RDF_UPTODATE	0x20000000 /* rg is up to date */
 #define GFS2_RDF_ERROR		0x40000000 /* error in rg */

commit 2147dbfd059eb7fefcfd5934f74f25f0693d4a1f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Nov 4 10:15:08 2013 +0000

    GFS2: Use generic list_lru for quota
    
    By using the generic list_lru code, we can now separate the
    per sb quota list locking from the lru locking. The lru
    lock is made into the inner-most lock.
    
    As a result of this new lock order, we may occasionally see
    items on the per-sb quota list which are "dead" so that the
    two places where we traverse that list are updated to take
    account of that.
    
    As a result of this patch, the gfs2 quota shrinker is now
    NUMA zone aware, and we are also laying the foundations for
    further improvments in due course.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Abhijith Das <adas@redhat.com>
    Tested-by: Abhijith Das <adas@redhat.com>
    Cc: Dave Chinner <dchinner@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9d778044cc6e..ba1ea67f4eeb 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -420,11 +420,10 @@ enum {
 
 struct gfs2_quota_data {
 	struct list_head qd_list;
-	struct list_head qd_reclaim;
-
+	struct kqid qd_id;
 	struct lockref qd_lockref;
+	struct list_head qd_lru;
 
-	struct kqid qd_id;
 	unsigned long qd_flags;		/* QDF_... */
 
 	s64 qd_change;

commit 9b9f039d570bddc1653cda2e38f4331dcacfcde5
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Nov 1 14:52:06 2013 -0400

    GFS2: Use reflink for quota data cache
    
    This patch adds reflink support to the quota data cache. It
    looks a bit strange because we still don't have a sensible
    split in the lookup by id and the lru list. That is coming in
    later patches though.
    
    The intent here is just to swap the current ref count for
    reflinks in all cases with as little as possible other change.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Abhijith Das <adas@redhat.com>
    Tested-by: Abhijith Das <adas@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index bb88e417231f..9d778044cc6e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -422,7 +422,7 @@ struct gfs2_quota_data {
 	struct list_head qd_list;
 	struct list_head qd_reclaim;
 
-	atomic_t qd_count;
+	struct lockref qd_lockref;
 
 	struct kqid qd_id;
 	unsigned long qd_flags;		/* QDF_... */

commit e66cf161098a634dc96e32d0089c5767cf25668a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Oct 15 15:18:08 2013 +0100

    GFS2: Use lockref for glocks
    
    Currently glocks have an atomic reference count and also a spinlock
    which covers various internal fields, such as the state. This intent of
    this patch is to replace the spinlock and the atomic reference count
    with a lockref structure. This contains a spinlock which we can continue
    to use as before, and a reference counter which is used in conjuction
    with the spinlock to replace the previous atomic counter.
    
    As a result of this there are some new rules for reference counting on
    glocks. We need to distinguish between reference count changes under
    gl_spin (which are now just increment or decrement of the new counter,
    provided the count cannot hit zero) and those which are outside of
    gl_spin, but which now take gl_spin internally.
    
    The conversion is relatively straight forward. There is probably some
    further clean up which can be done, but the priority at this stage is to
    make the change in as simple a manner as possible.
    
    A consequence of this change is that the reference count is being
    decoupled from the lru list processing. This should allow future
    adoption of the lru_list code with glocks in due course.
    
    The reason for using the "dead" state and not just relying on 0 being
    the "invalid state" is so that in due course 0 ref counts can be
    allowable. The intent is to eventually be able to remove the ref count
    changes which are currently hidden away in state_change().
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 2ab4f8d8f4c4..bb88e417231f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -21,6 +21,7 @@
 #include <linux/rbtree.h>
 #include <linux/ktime.h>
 #include <linux/percpu.h>
+#include <linux/lockref.h>
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
@@ -321,9 +322,9 @@ struct gfs2_glock {
 	struct gfs2_sbd *gl_sbd;
 	unsigned long gl_flags;		/* GLF_... */
 	struct lm_lockname gl_name;
-	atomic_t gl_ref;
 
-	spinlock_t gl_spin;
+	struct lockref gl_lockref;
+#define gl_spin gl_lockref.lock
 
 	/* State fields protected by gl_spin */
 	unsigned int gl_state:2,	/* Current state */

commit e46c772dbafc2059b0c7ee87c6a7232baadaf6c7
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Oct 4 12:29:34 2013 +0100

    GFS2: Protect quota sync generation
    
    Now that gfs2_quota_sync can be potentially called from multiple
    threads, we should protect this bit of code, and the sync generation
    number in particular in order to ensure that there are no races
    when syncing quotas.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Abhijith Das <adas@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 37b3cd795d6c..2ab4f8d8f4c4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -714,6 +714,7 @@ struct gfs2_sbd {
 	struct list_head sd_quota_list;
 	atomic_t sd_quota_count;
 	struct mutex sd_quota_mutex;
+	struct mutex sd_quota_sync_mutex;
 	wait_queue_head_t sd_quota_wait;
 	struct list_head sd_trunc_list;
 	spinlock_t sd_trunc_lock;

commit bef292a72daf215c00aa20f68603de181afbb4d3
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Oct 3 18:43:20 2013 +0100

    GFS2: Remove obsolete quota tunable
    
    There is no need for a paramater which relates to the internals
    of quota to be exposed to users. The only possible use would be
    to turn it up so large that the memory allocation fails. So lets
    remove it and set it to a sensible value which ensures that we
    don't ask for multipage allocations.
    
    Currently the size of struct gfs2_holder means that the caluclated
    value is identical to the previous default value, so there should
    be no functional change.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Abhijith Das <adas@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 082c8fa7fab9..37b3cd795d6c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -537,7 +537,6 @@ struct gfs2_tune {
 
 	unsigned int gt_logd_secs;
 
-	unsigned int gt_quota_simul_sync; /* Max quotavals to sync at once */
 	unsigned int gt_quota_warn_period; /* Secs between quota warn msgs */
 	unsigned int gt_quota_scale_num; /* Numerator */
 	unsigned int gt_quota_scale_den; /* Denominator */

commit 7b9cff467144c8c62268db1b0948df089caa0999
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Oct 2 11:13:25 2013 +0100

    GFS2: Add allocation parameters structure
    
    This patch adds a structure to contain allocation parameters with
    the intention of future expansion of this structure. The idea is
    that we should be able to add more information about the allocation
    in the future in order to allow the allocator to make a better job
    of placing the requests on-disk.
    
    There is no functional difference from applying this patch.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8c8f110d8e35..082c8fa7fab9 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -285,6 +285,20 @@ struct gfs2_blkreserv {
 	unsigned int rs_qa_qd_num;
 };
 
+/*
+ * Allocation parameters
+ * @target: The number of blocks we'd ideally like to allocate
+ * @aflags: The flags (e.g. Orlov flag)
+ *
+ * The intent is to gradually expand this structure over time in
+ * order to give more information, e.g. alignment, min extent size
+ * to the allocation code.
+ */
+struct gfs2_alloc_parms {
+	u32 target;
+	u32 aflags;
+};
+
 enum {
 	GLF_LOCK			= 1,
 	GLF_DEMOTE			= 3,

commit e579ed4f446e64748a2d26eed8f8b28f728495bd
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Sep 17 13:12:15 2013 -0400

    GFS2: Introduce rbm field bii
    
    This is a respin of the original patch. As Steve pointed out, the
    introduction of field bii makes it easy to eliminate bi itself.
    This revised patch does just that, replacing bi with bii.
    
    This patch adds a new field to the rbm structure, called bii,
    which is an index into the array of bitmaps for an rgrp.
    This replaces *bi which was a pointer to the bitmap.
    This is being done for further optimizations.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index f1a3243dfaf2..8c8f110d8e35 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -102,19 +102,25 @@ struct gfs2_rgrpd {
 
 struct gfs2_rbm {
 	struct gfs2_rgrpd *rgd;
-	struct gfs2_bitmap *bi;	/* Bitmap must belong to the rgd */
 	u32 offset;		/* The offset is bitmap relative */
+	int bii;		/* Bitmap index */
 };
 
+static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)
+{
+	return rbm->rgd->rd_bits + rbm->bii;
+}
+
 static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)
 {
-	return rbm->rgd->rd_data0 + (rbm->bi->bi_start * GFS2_NBBY) + rbm->offset;
+	return rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +
+		rbm->offset;
 }
 
 static inline bool gfs2_rbm_eq(const struct gfs2_rbm *rbm1,
 			       const struct gfs2_rbm *rbm2)
 {
-	return (rbm1->rgd == rbm2->rgd) && (rbm1->bi == rbm2->bi) && 
+	return (rbm1->rgd == rbm2->rgd) && (rbm1->bii == rbm2->bii) &&
 	       (rbm1->offset == rbm2->offset);
 }
 

commit 7e230f5774336c5c180d8aeab0e2cb1326c73fa3
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Sep 11 13:44:02 2013 -0500

    GFS2: introduce bi_blocks for optimization
    
    This patch introduces a new field in the bitmap structure called
    bi_blocks. Its purpose is to save us from constantly multiplying
    bi_len by the constant GFS2_NBBY. It also paves the way for more
    optimization in a future patch.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 26aabd7caba7..f1a3243dfaf2 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -71,6 +71,7 @@ struct gfs2_bitmap {
 	u32 bi_offset;
 	u32 bi_start;
 	u32 bi_len;
+	u32 bi_blocks;
 };
 
 struct gfs2_rgrpd {

commit 81ffbf654f0cfeeb44e69832b3d301958a4108d8
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Apr 10 10:26:55 2013 +0100

    GFS2: Add origin indicator to glock callbacks
    
    This patch adds a bool indicating whether the demote
    request was originated locally or remotely. This is then
    used by the iopen ->go_callback() to make 100% sure that
    it will only respond to remote callbacks.
    
    Since ->evict_inode() uses GL_NOCACHE when it attempts to
    get an exclusive lock on the iopen lock, this may result
    in extra scheduling of the workqueue in case that the
    exclusive promotion request failed. This patch prevents
    that from happening.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 2532f7ec6b00..26aabd7caba7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -210,7 +210,7 @@ struct gfs2_glock_operations {
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
 	int (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
-	void (*go_callback) (struct gfs2_glock *gl);
+	void (*go_callback)(struct gfs2_glock *gl, bool remote);
 	const int go_type;
 	const unsigned long go_flags;
 #define GLOF_ASPACE 1

commit 16ca9412d8018188bddda29c3fee88471b94e3cb
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Fri Apr 5 20:31:46 2013 -0500

    GFS2: replace gfs2_ail structure with gfs2_trans
    
    In order to allow transactions and log flushes to happen at the same
    time, gfs2 needs to move the transaction accounting and active items
    list code into the gfs2_trans structure.  As a first step toward this,
    this patch removes the gfs2_ail structure, and handles the active items
    list in the gfs_trans structure.  This keeps gfs2 from allocating an ail
    structure on log flushes, and gives us a struture that can later be used
    to store the transaction accounting outside of the gfs2 superblock
    structure.
    
    With this patch, at the end of a transaction, gfs2 will add the
    gfs2_trans structure to the superblock if there is not one already.
    This structure now has the active items fields that were previously in
    gfs2_ail.  This is not necessary in the case where the transaction was
    simply used to add revokes, since these are never written outside of the
    journal, and thus, don't need an active items list.
    
    Also, in order to make sure that the transaction structure is not
    removed while it's still in use by gfs2_trans_end, unlocking the
    sd_log_flush_lock has to happen slightly later in ending the
    transaction.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5c29216e9cc1..2532f7ec6b00 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -31,7 +31,6 @@ struct gfs2_holder;
 struct gfs2_glock;
 struct gfs2_quota_data;
 struct gfs2_trans;
-struct gfs2_ail;
 struct gfs2_jdesc;
 struct gfs2_sbd;
 struct lm_lockops;
@@ -53,7 +52,7 @@ struct gfs2_log_header_host {
 
 struct gfs2_log_operations {
 	void (*lo_before_commit) (struct gfs2_sbd *sdp);
-	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_ail *ai);
+	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_trans *tr);
 	void (*lo_before_scan) (struct gfs2_jdesc *jd,
 				struct gfs2_log_header_host *head, int pass);
 	int (*lo_scan_elements) (struct gfs2_jdesc *jd, unsigned int start,
@@ -139,7 +138,7 @@ struct gfs2_bufdata {
 	struct list_head bd_list;
 	const struct gfs2_log_operations *bd_ops;
 
-	struct gfs2_ail *bd_ail;
+	struct gfs2_trans *bd_tr;
 	struct list_head bd_ail_st_list;
 	struct list_head bd_ail_gl_list;
 };
@@ -433,6 +432,7 @@ struct gfs2_trans {
 	struct gfs2_holder tr_t_gh;
 
 	int tr_touched;
+	int tr_attached;
 
 	unsigned int tr_num_buf_new;
 	unsigned int tr_num_databuf_new;
@@ -440,14 +440,12 @@ struct gfs2_trans {
 	unsigned int tr_num_databuf_rm;
 	unsigned int tr_num_revoke;
 	unsigned int tr_num_revoke_rm;
-};
 
-struct gfs2_ail {
-	struct list_head ai_list;
+	struct list_head tr_list;
 
-	unsigned int ai_first;
-	struct list_head ai_ail1_list;
-	struct list_head ai_ail2_list;
+	unsigned int tr_first;
+	struct list_head tr_ail1_list;
+	struct list_head tr_ail2_list;
 };
 
 struct gfs2_journal_extent {
@@ -710,6 +708,7 @@ struct gfs2_sbd {
 
 	spinlock_t sd_log_lock;
 
+	struct gfs2_trans *sd_log_tr;
 	unsigned int sd_log_blks_reserved;
 	unsigned int sd_log_commited_buf;
 	unsigned int sd_log_commited_databuf;

commit 57c7310b8eb96b0fe3b0aaa8dc194adbae03bef3
Author: David Teigland <teigland@redhat.com>
Date:   Tue Mar 5 16:01:47 2013 -0500

    GFS2: use kmalloc for lvb bitmap
    
    The temp lvb bitmap was on the stack, which could
    be an alignment problem for __set_bit_le.  Use
    kmalloc for it instead.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 156e42ec84ea..5c29216e9cc1 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -588,6 +588,7 @@ struct lm_lockstruct {
 	struct dlm_lksb ls_control_lksb; /* control_lock */
 	char ls_control_lvb[GDLM_LVB_SIZE]; /* control_lock lvb */
 	struct completion ls_sync_wait; /* {control,mounted}_{lock,unlock} */
+	char *ls_lvb_bits;
 
 	spinlock_t ls_recover_spin; /* protects following fields */
 	unsigned long ls_recover_flags; /* DFL_ */

commit 94f2f14234178f118545a0be60a6371ddeb229b7
Merge: 8d168f71551e 139321c65c05
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 16:00:49 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace and namespace infrastructure changes from Eric W Biederman:
     "This set of changes starts with a few small enhnacements to the user
      namespace.  reboot support, allowing more arbitrary mappings, and
      support for mounting devpts, ramfs, tmpfs, and mqueuefs as just the
      user namespace root.
    
      I do my best to document that if you care about limiting your
      unprivileged users that when you have the user namespace support
      enabled you will need to enable memory control groups.
    
      There is a minor bug fix to prevent overflowing the stack if someone
      creates way too many user namespaces.
    
      The bulk of the changes are a continuation of the kuid/kgid push down
      work through the filesystems.  These changes make using uids and gids
      typesafe which ensures that these filesystems are safe to use when
      multiple user namespaces are in use.  The filesystems converted for
      3.9 are ceph, 9p, afs, ocfs2, gfs2, ncpfs, nfs, nfsd, and cifs.  The
      changes for these filesystems were a little more involved so I split
      the changes into smaller hopefully obviously correct changes.
    
      XFS is the only filesystem that remains.  I was hoping I could get
      that in this release so that user namespace support would be enabled
      with an allyesconfig or an allmodconfig but it looks like the xfs
      changes need another couple of days before it they are ready."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (93 commits)
      cifs: Enable building with user namespaces enabled.
      cifs: Convert struct cifs_ses to use a kuid_t and a kgid_t
      cifs: Convert struct cifs_sb_info to use kuids and kgids
      cifs: Modify struct smb_vol to use kuids and kgids
      cifs: Convert struct cifsFileInfo to use a kuid
      cifs: Convert struct cifs_fattr to use kuid and kgids
      cifs: Convert struct tcon_link to use a kuid.
      cifs: Modify struct cifs_unix_set_info_args to hold a kuid_t and a kgid_t
      cifs: Convert from a kuid before printing current_fsuid
      cifs: Use kuids and kgids SID to uid/gid mapping
      cifs: Pass GLOBAL_ROOT_UID and GLOBAL_ROOT_GID to keyring_alloc
      cifs: Use BUILD_BUG_ON to validate uids and gids are the same size
      cifs: Override unmappable incoming uids and gids
      nfsd: Enable building with user namespaces enabled.
      nfsd: Properly compare and initialize kuids and kgids
      nfsd: Store ex_anon_uid and ex_anon_gid as kuids and kgids
      nfsd: Modify nfsd4_cb_sec to use kuids and kgids
      nfsd: Handle kuids and kgids in the nfs4acl to posix_acl conversion
      nfsd: Convert nfsxdr to use kuids and kgids
      nfsd: Convert nfs3xdr to use kuids and kgids
      ...

commit 05e0a60d8025e280e56b3fa36ea8facc7c1c65c2
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jan 31 19:52:08 2013 -0800

    gfs2: Store qd_id in struct gfs2_quota_data as a struct kqid
    
    - Change qd_id in struct gfs2_qutoa_data to struct kqid.
    - Remove the now unnecessary QDF_USER bit field in qd_flags.
    - Propopoage this change through the code generally making
      things simpler along the way.
    
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c373a24fedd9..5b298bdab90c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -391,7 +391,6 @@ struct gfs2_revoke_replay {
 };
 
 enum {
-	QDF_USER		= 0,
 	QDF_CHANGE		= 1,
 	QDF_LOCKED		= 2,
 	QDF_REFRESH		= 3,
@@ -403,7 +402,7 @@ struct gfs2_quota_data {
 
 	atomic_t qd_count;
 
-	u32 qd_id;
+	struct kqid qd_id;
 	unsigned long qd_flags;		/* QDF_... */
 
 	s64 qd_change;

commit fd95e81cb1c74c9acd2356821faa9f24c2fec365
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Feb 13 12:21:40 2013 +0000

    GFS2: Reinstate withdraw ack system
    
    This patch reinstates the ack system which withdraw should be using. It
    appears to have been accidentally forgotten when the lock module was
    merged into GFS2, due to two different sysfs files having the same name.
    
    Reported-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1533cf8b4269..e2601ba38ef5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -642,6 +642,7 @@ struct gfs2_sbd {
 	wait_queue_head_t sd_glock_wait;
 	atomic_t sd_glock_disposal;
 	struct completion sd_locking_init;
+	struct completion sd_wdack;
 	struct delayed_work sd_control_work;
 
 	/* Inode Stuff */

commit 4513899092b3254b3539f92a65d2839afa1d50f6
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 28 09:30:07 2013 +0000

    GFS2: Use ->writepages for ordered writes
    
    Instead of using a list of buffers to write ahead of the journal
    flush, this now uses a list of inodes and calls ->writepages
    via filemap_fdatawrite() in order to achieve the same thing. For
    most use cases this results in a shorter ordered write list,
    as well as much larger i/os being issued.
    
    The ordered write list is sorted by inode number before writing
    in order to retain the disk block ordering between inodes as
    per the previous code.
    
    The previous ordered write code used to conflict in its assumptions
    about how to write out the disk blocks with mpage_writepages()
    so that with this updated version we can also use mpage_writepages()
    for GFS2's ordered write, writepages implementation. So we will
    also send larger i/os from writeback too.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 19750bcb1ce7..1533cf8b4269 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -340,6 +340,7 @@ enum {
 	GIF_QD_LOCKED		= 1,
 	GIF_ALLOC_FAILED	= 2,
 	GIF_SW_PAGED		= 3,
+	GIF_ORDERED		= 4,
 };
 
 struct gfs2_inode {
@@ -356,6 +357,7 @@ struct gfs2_inode {
 	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
+	struct list_head i_ordered;
 	struct list_head i_trunc_list;
 	__be64 *i_hash_cache;
 	u32 i_entries;
@@ -722,6 +724,7 @@ struct gfs2_sbd {
 	struct list_head sd_log_le_revoke;
 	struct list_head sd_log_le_databuf;
 	struct list_head sd_log_le_ordered;
+	spinlock_t sd_ordered_lock;
 
 	atomic_t sd_log_thresh1;
 	atomic_t sd_log_thresh2;

commit d564053f074634e7a966359dc97d26900fa5f52d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Jan 11 10:49:34 2013 +0000

    GFS2: Clean up freeze code
    
    The freeze code has not been looked at a lot recently. Upstream has
    moved on, and this is an attempt to catch us back up again. There
    is a vfs level interface for the freeze code which can be called
    from our (obsolete, but kept for backward compatibility purposes)
    sysfs freeze interface. This means freezing this way vs. doing it
    from the ioctl should now work in identical fashion.
    
    As a result of this, the freeze function is only called once
    and we can drop our own special purpose code for counting the
    number of freezes.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5d129ab89733..19750bcb1ce7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -757,10 +757,7 @@ struct gfs2_sbd {
 	unsigned int sd_replayed_blocks;
 
 	/* For quiescing the filesystem */
-
 	struct gfs2_holder sd_freeze_gh;
-	struct mutex sd_freeze_lock;
-	unsigned int sd_freeze_count;
 
 	char sd_fsname[GFS2_FSNAME_LEN];
 	char sd_table_name[GFS2_FSNAME_LEN];

commit 767f433f346959d6a09b85478eb5db133ab25c6f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Dec 14 12:52:14 2012 +0000

    GFS2: Copy gfs2_trans_add_bh into new data/meta functions
    
    This patch copies the body of gfs2_trans_add_bh into the two newly
    added gfs2_trans_add_data and gfs2_trans_add_meta functions. We can
    then move the .lo_add functions from lops.c into trans.c and call
    them directly.
    
    As a result of this, we no longer need to use the .lo_add functions
    at all, so that is removed from the log operations structure.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c373a24fedd9..5d129ab89733 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -52,7 +52,6 @@ struct gfs2_log_header_host {
  */
 
 struct gfs2_log_operations {
-	void (*lo_add) (struct gfs2_sbd *sdp, struct gfs2_bufdata *bd);
 	void (*lo_before_commit) (struct gfs2_sbd *sdp);
 	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_ail *ai);
 	void (*lo_before_scan) (struct gfs2_jdesc *jd,

commit 4e2f8849def738092ad6c0fc2b34737381bc9d26
Author: David Teigland <teigland@redhat.com>
Date:   Wed Nov 14 13:47:37 2012 -0500

    GFS2: remove redundant lvb pointer
    
    The lksb struct already contains a pointer to the lvb,
    so another directly from the glock struct is not needed.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index bd577fc59e0b..c373a24fedd9 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -322,7 +322,6 @@ struct gfs2_glock {
 	ktime_t gl_dstamp;
 	struct gfs2_lkstats gl_stats;
 	struct dlm_lksb gl_lksb;
-	char *gl_lvb;
 	unsigned long gl_tchange;
 	void *gl_object;
 

commit dba2d70c5dc520fdb569d1fd8dbd45c0e330253e
Author: David Teigland <teigland@redhat.com>
Date:   Wed Nov 14 13:46:53 2012 -0500

    GFS2: only use lvb on glocks that need it
    
    Save the effort of allocating, reading and writing
    the lvb for most glocks that do not use it.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a35ef5cd1480..bd577fc59e0b 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -216,6 +216,7 @@ struct gfs2_glock_operations {
 	const int go_type;
 	const unsigned long go_flags;
 #define GLOF_ASPACE 1
+#define GLOF_LVB    2
 };
 
 enum {
@@ -321,7 +322,7 @@ struct gfs2_glock {
 	ktime_t gl_dstamp;
 	struct gfs2_lkstats gl_stats;
 	struct dlm_lksb gl_lksb;
-	char gl_lvb[32];
+	char *gl_lvb;
 	unsigned long gl_tchange;
 	void *gl_object;
 

commit fb6791d100d1bba20b5cdbc4912e1f7086ec60f8
Author: David Teigland <teigland@redhat.com>
Date:   Tue Nov 13 10:58:56 2012 -0500

    GFS2: skip dlm_unlock calls in unmount
    
    When unmounting, gfs2 does a full dlm_unlock operation on every
    cached lock.  This can create a very large amount of work and can
    take a long time to complete.  However, the vast majority of these
    dlm unlock operations are unnecessary because after all the unlocks
    are done, gfs2 leaves the dlm lockspace, which automatically clears
    the locks of the leaving node, without unlocking each one individually.
    So, gfs2 can skip explicit dlm unlocks, and use dlm_release_lockspace to
    remove the locks implicitly.  The one exception is when the lock's lvb is
    being used.  In this case, dlm_unlock is called because it may update the
    lvb of the resource.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a46f03485936..a35ef5cd1480 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -539,6 +539,7 @@ enum {
 	SDF_DEMOTE		= 5,
 	SDF_NOJOURNALID		= 6,
 	SDF_RORECOVERY		= 7, /* read only recovery */
+	SDF_SKIP_DLM_UNLOCK	= 8,
 };
 
 #define GFS2_FSNAME_LEN		256

commit 06dfc30641370094ed522bf5949b2a326fe2741b
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Oct 24 14:41:05 2012 -0400

    GFS2: Rename glops go_xmote_th to go_sync
    
    [Editorial: This is a nit, but has been a minor irritation for a long time:]
    
    This patch renames glops structure item for go_xmote_th to go_sync.
    The functionality is unchanged; it's just for readability.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 24bb0b857860..a46f03485936 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -205,7 +205,7 @@ struct lm_lockname {
 
 
 struct gfs2_glock_operations {
-	void (*go_xmote_th) (struct gfs2_glock *gl);
+	void (*go_sync) (struct gfs2_glock *gl);
 	int (*go_xmote_bh) (struct gfs2_glock *gl, struct gfs2_holder *gh);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (const struct gfs2_glock *gl);

commit a68a0a352a0209467268dfddffe02db08b97ddb4
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Oct 19 08:32:51 2012 -0400

    GFS2: Speed up gfs2_rbm_from_block
    
    This patch is a rewrite of function gfs2_rbm_from_block. Rather than
    looping to find the right bitmap, the code now does a few simple
    math calculations.
    
    I compared the performance of both algorithms side by side and the new
    algorithm is noticeably faster. Sample instrumentation output from a
    "fast" machine:
    
    5 million calls: millisec spent: Orig: 166 New: 113
    5 million calls: millisec spent: Orig: 189 New: 114
    
    In addition, I ran postmark (on a somewhat slowr CPU) before the after
    the new algorithm was put in place and postmark showed a decent
    improvement:
    
    Before the new algorithm:
    -------------------------
    Time:
            645 seconds total
            584 seconds of transactions (171 per second)
    
    Files:
            150087 created (232 per second)
                    Creation alone: 100000 files (2083 per second)
                    Mixed with transactions: 50087 files (85 per second)
            49995 read (85 per second)
            49991 appended (85 per second)
            150087 deleted (232 per second)
                    Deletion alone: 100174 files (7705 per second)
                    Mixed with transactions: 49913 files (85 per second)
    
    Data:
            273.42 megabytes read (434.08 kilobytes per second)
            852.13 megabytes written (1.32 megabytes per second)
    
    With the new algorithm:
    -----------------------
    Time:
            599 seconds total
            530 seconds of transactions (188 per second)
    
    Files:
            150087 created (250 per second)
                    Creation alone: 100000 files (1886 per second)
                    Mixed with transactions: 50087 files (94 per second)
            49995 read (94 per second)
            49991 appended (94 per second)
            150087 deleted (250 per second)
                    Deletion alone: 100174 files (6260 per second)
                    Mixed with transactions: 49913 files (94 per second)
    
    Data:
            273.42 megabytes read (467.42 kilobytes per second)
            852.13 megabytes written (1.42 megabytes per second)
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3d469d37345e..24bb0b857860 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -621,6 +621,7 @@ struct gfs2_sbd {
 	u32 sd_hash_bsize_shift;
 	u32 sd_hash_ptrs;	/* Number of pointers in a hash block */
 	u32 sd_qc_per_block;
+	u32 sd_blocks_per_bitmap;
 	u32 sd_max_dirres;	/* Max blocks needed to add a directory entry */
 	u32 sd_max_height;	/* Max height of a file's metadata tree */
 	u64 sd_heightsize[GFS2_MAX_META_HEIGHT + 1];

commit ff7f4cb461163967a9dbb8c569e2447b7520654f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 10 10:03:50 2012 +0100

    GFS2: Consolidate free block searching functions
    
    With the recently added block reservation code, an additional function
    was added to search for free blocks. This had a restriction of only being
    able to search for aligned extents of free blocks. As a result the
    allocation patterns when reserving blocks were suboptimal when the
    existing allocation of blocks for an inode was not aligned to the same
    boundary.
    
    This patch resolves that problem by adding the ability for gfs2_rbm_find
    to search for extents of a particular minimum size. We can then use
    gfs2_rbm_find for both looking for reservations, and also looking for
    free blocks on an individual basis when we actually come to do the
    allocation later on. As a result we only need a single set of code
    to deal with both situations.
    
    The function gfs2_rbm_from_block() is moved up rgrp.c so that it
    occurs before all of its callers.
    
    Many thanks are due to Bob for helping track down the final issue in
    this patch. That fix to the rb_tree traversal and to not share
    block reservations from a dirctory to its children is included here.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6aaa07c7c731..3d469d37345e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -99,7 +99,6 @@ struct gfs2_rgrpd {
 #define GFS2_RDF_MASK		0xf0000000 /* mask for internal flags */
 	spinlock_t rd_rsspin;           /* protects reservation related vars */
 	struct rb_root rd_rstree;       /* multi-block reservation tree */
-	u32 rd_rs_cnt;                  /* count of current reservations */
 };
 
 struct gfs2_rbm {

commit 9e733d3923fb0e4eeae7b827019332d246576a22
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Aug 23 15:37:59 2012 +0100

    GFS2: Improve block reservation tracing
    
    This patch improves the tracing of block reservations by
    removing some corner cases and also providing more useful
    detail in the traces.
    
    A new field is added to the reservation structure to contain
    the inode number. This is used since in certain contexts it is
    not possible to access the inode itself to obtain this information.
    As a result we can then display the inode number for all tracepoints
    and also in case we dump the resource group.
    
    The "del" tracepoint operation has been removed. This could be called
    with the reservation rgrp set to NULL. That resulted in not printing
    the device number, and thus making the information largely useless
    anyway. Also, the conditional on the rgrp being NULL can then be
    removed from the tracepoint. After this change, all the block
    reservation tracepoint calls will be called with the rgrp information.
    
    The existing ins,clm and tdel calls to the block reservation tracepoint
    are sufficient to track the entire life of the block reservation.
    
    In gfs2_block_alloc() the error detection is updated to print out
    the inode number of the problematic inode. This can then be compared
    against the information in the glock dump,tracepoints, etc.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 99d7c64b5091..6aaa07c7c731 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -268,13 +268,11 @@ struct gfs2_blkreserv {
 	/* components used during write (step 1): */
 	atomic_t rs_sizehint;         /* hint of the write size */
 
-	/* components used during get_local_rgrp (step 3): */
-	struct gfs2_rbm rs_rbm;
 	struct gfs2_holder rs_rgd_gh; /* Filled in by get_local_rgrp */
 	struct rb_node rs_node;       /* link to other block reservations */
-
-	/* components used during block searches and assignments (step 4): */
+	struct gfs2_rbm rs_rbm;       /* Start of reservation */
 	u32 rs_free;                  /* how many blocks are still free */
+	u64 rs_inum;                  /* Inode number for reservation */
 
 	/* ancillary quota stuff */
 	struct gfs2_quota_data *rs_qa_qd[2 * MAXQUOTAS];

commit 5b924ae2dcb1cc5e78445a0cedb5a3673bb5ad8a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 1 20:35:05 2012 +0100

    GFS2: Replace rgblk_search with gfs2_rbm_find
    
    This is part of a series of patches which are introducing the
    gfs2_rbm structure throughout the block allocation code. The
    main aim of this part is to create a search function which can
    deal directly with struct gfs2_rbm. In this case it specifies
    the initial position at which to start the search and also the
    point at which the search terminates.
    
    The net result of this is to clean up the search code and make
    it rather more readable, and the various possible exceptions which
    may occur during the search are partitioned into their own functions.
    
    There are some bug fixes too. We should not be checking the reservations
    while allocating extents - the time for that is when we are searching
    for where to put the extent, not when we've already made that decision.
    
    Also, rgblk_search had two uses, and in only one of those cases did
    it make sense to check for reservations. This is fixed in the new
    gfs2_rbm_find function, which has a cleaner interface.
    
    The reservation checking has been improved by always checking for
    contiguous reservations, and returning the first free block after
    all contiguous reservations. This is done under the spin lock to
    ensure consistancy of the tree.
    
    The allocation of extents is now in all cases done by the existing
    allocation code, and if there is an active reservation, that is updated
    after the fact. Again this is done under the spin lock, since it entails
    changing the lookup key for the reservation in question.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index d5e254604c72..99d7c64b5091 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -113,6 +113,13 @@ static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)
 	return rbm->rgd->rd_data0 + (rbm->bi->bi_start * GFS2_NBBY) + rbm->offset;
 }
 
+static inline bool gfs2_rbm_eq(const struct gfs2_rbm *rbm1,
+			       const struct gfs2_rbm *rbm2)
+{
+	return (rbm1->rgd == rbm2->rgd) && (rbm1->bi == rbm2->bi) && 
+	       (rbm1->offset == rbm2->offset);
+}
+
 enum gfs2_state_bits {
 	BH_Pinned = BH_PrivateStart,
 	BH_Escaped = BH_PrivateStart + 1,

commit 4a993fb1503d11496974bd86c0b7123f63d9c8a2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jul 31 15:21:20 2012 +0100

    GFS2: Add structure to contain rgrp, bitmap, offset tuple
    
    This patch introduces a new structure, gfs2_rbm, which is a
    tuple of a resource group, a bitmap within the resource group
    and an offset within that bitmap. This is designed to make
    manipulating these sets of variables easier. There is also a
    new helper function which converts this representation back
    to a disk block address.
    
    In addition, the rbtree nodes which are used for the reservations
    were not being correctly initialised, which is now fixed. Also,
    the tracing was not passing through the inode where it should
    have been. That is mostly fixed aside from one corner case. This
    needs to be revisited since there can also be a NULL rgrp in
    some cases which results in the device being incorrect in the
    trace.
    
    This is intended to be the first step towards cleaning up some
    of the allocation code, and some further bug fixes.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 52078a161ecd..d5e254604c72 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -102,6 +102,17 @@ struct gfs2_rgrpd {
 	u32 rd_rs_cnt;                  /* count of current reservations */
 };
 
+struct gfs2_rbm {
+	struct gfs2_rgrpd *rgd;
+	struct gfs2_bitmap *bi;	/* Bitmap must belong to the rgd */
+	u32 offset;		/* The offset is bitmap relative */
+};
+
+static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)
+{
+	return rbm->rgd->rd_data0 + (rbm->bi->bi_start * GFS2_NBBY) + rbm->offset;
+}
+
 enum gfs2_state_bits {
 	BH_Pinned = BH_PrivateStart,
 	BH_Escaped = BH_PrivateStart + 1,
@@ -251,13 +262,11 @@ struct gfs2_blkreserv {
 	atomic_t rs_sizehint;         /* hint of the write size */
 
 	/* components used during get_local_rgrp (step 3): */
-	struct gfs2_rgrpd *rs_rgd;    /* pointer to the gfs2_rgrpd */
+	struct gfs2_rbm rs_rbm;
 	struct gfs2_holder rs_rgd_gh; /* Filled in by get_local_rgrp */
 	struct rb_node rs_node;       /* link to other block reservations */
 
 	/* components used during block searches and assignments (step 4): */
-	struct gfs2_bitmap *rs_bi;    /* bitmap for the current allocation */
-	u32 rs_biblk;                 /* start block relative to the bi */
 	u32 rs_free;                  /* how many blocks are still free */
 
 	/* ancillary quota stuff */

commit 71f890f7f758f340215d48fed5223f9cce05b652
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jul 30 14:53:19 2012 +0100

    GFS2: Remove rs_requested field from reservations
    
    The rs_requested field is left over from the original allocation
    code, however this should have been a parameter passed to the
    various functions from gfs2_inplace_reserve() and not a member of the
    reservation structure as the value is not required after the
    initial allocation.
    
    This also helps simplify the code since we no longer need to set
    the rs_requested to zero. Also the gfs2_inplace_release()
    function can also be simplified since the reservation structure
    will always be defined when it is called, and the only remaining
    task is to unlock the rgrp if required. It can also now be
    called unconditionally too, resulting in a further simplification.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index aaecc8085fc5..52078a161ecd 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -250,9 +250,6 @@ struct gfs2_blkreserv {
 	/* components used during write (step 1): */
 	atomic_t rs_sizehint;         /* hint of the write size */
 
-	/* components used during inplace_reserve (step 2): */
-	u32 rs_requested; /* Filled in by caller of gfs2_inplace_reserve() */
-
 	/* components used during get_local_rgrp (step 3): */
 	struct gfs2_rgrpd *rs_rgd;    /* pointer to the gfs2_rgrpd */
 	struct gfs2_holder rs_rgd_gh; /* Filled in by get_local_rgrp */

commit 8e2e00473598dd5379d8408cb974dade000acafc
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Jul 19 08:12:40 2012 -0400

    GFS2: Reduce file fragmentation
    
    This patch reduces GFS2 file fragmentation by pre-reserving blocks. The
    resulting improved on disk layout greatly speeds up operations in cases
    which would have resulted in interlaced allocation of blocks previously.
    A typical example of this is 10 parallel dd processes, each writing to a
    file in a common dirctory.
    
    The implementation uses an rbtree of reservations attached to each
    resource group (and each inode).
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index dc730700b3b4..aaecc8085fc5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -84,6 +84,7 @@ struct gfs2_rgrpd {
 	u32 rd_data;			/* num of data blocks in rgrp */
 	u32 rd_bitbytes;		/* number of bytes in data bitmaps */
 	u32 rd_free;
+	u32 rd_reserved;                /* number of blocks reserved */
 	u32 rd_free_clone;
 	u32 rd_dinodes;
 	u64 rd_igeneration;
@@ -96,6 +97,9 @@ struct gfs2_rgrpd {
 #define GFS2_RDF_UPTODATE	0x20000000 /* rg is up to date */
 #define GFS2_RDF_ERROR		0x40000000 /* error in rg */
 #define GFS2_RDF_MASK		0xf0000000 /* mask for internal flags */
+	spinlock_t rd_rsspin;           /* protects reservation related vars */
+	struct rb_root rd_rstree;       /* multi-block reservation tree */
+	u32 rd_rs_cnt;                  /* count of current reservations */
 };
 
 enum gfs2_state_bits {
@@ -233,6 +237,38 @@ struct gfs2_holder {
 	unsigned long gh_ip;
 };
 
+/* Resource group multi-block reservation, in order of appearance:
+
+   Step 1. Function prepares to write, allocates a mb, sets the size hint.
+   Step 2. User calls inplace_reserve to target an rgrp, sets the rgrp info
+   Step 3. Function get_local_rgrp locks the rgrp, determines which bits to use
+   Step 4. Bits are assigned from the rgrp based on either the reservation
+           or wherever it can.
+*/
+
+struct gfs2_blkreserv {
+	/* components used during write (step 1): */
+	atomic_t rs_sizehint;         /* hint of the write size */
+
+	/* components used during inplace_reserve (step 2): */
+	u32 rs_requested; /* Filled in by caller of gfs2_inplace_reserve() */
+
+	/* components used during get_local_rgrp (step 3): */
+	struct gfs2_rgrpd *rs_rgd;    /* pointer to the gfs2_rgrpd */
+	struct gfs2_holder rs_rgd_gh; /* Filled in by get_local_rgrp */
+	struct rb_node rs_node;       /* link to other block reservations */
+
+	/* components used during block searches and assignments (step 4): */
+	struct gfs2_bitmap *rs_bi;    /* bitmap for the current allocation */
+	u32 rs_biblk;                 /* start block relative to the bi */
+	u32 rs_free;                  /* how many blocks are still free */
+
+	/* ancillary quota stuff */
+	struct gfs2_quota_data *rs_qa_qd[2 * MAXQUOTAS];
+	struct gfs2_holder rs_qa_qd_ghs[2 * MAXQUOTAS];
+	unsigned int rs_qa_qd_num;
+};
+
 enum {
 	GLF_LOCK			= 1,
 	GLF_DEMOTE			= 3,
@@ -290,16 +326,6 @@ struct gfs2_glock {
 
 #define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */
 
-struct gfs2_blkreserv {
-	u32 rs_requested; /* Filled in by caller of gfs2_inplace_reserve() */
-	struct gfs2_holder rs_rgd_gh; /* Filled in by gfs2_inplace_reserve() */
-
-	/* ancillary quota stuff */
-	struct gfs2_quota_data *rs_qa_qd[2 * MAXQUOTAS];
-	struct gfs2_holder rs_qa_qd_ghs[2 * MAXQUOTAS];
-	unsigned int rs_qa_qd_num;
-};
-
 enum {
 	GIF_INVALID		= 0,
 	GIF_QD_LOCKED		= 1,
@@ -307,7 +333,6 @@ enum {
 	GIF_SW_PAGED		= 3,
 };
 
-
 struct gfs2_inode {
 	struct inode i_inode;
 	u64 i_no_addr;
@@ -318,7 +343,7 @@ struct gfs2_inode {
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
-	struct gfs2_blkreserv *i_res; /* resource group block reservation */
+	struct gfs2_blkreserv *i_res; /* rgrp multi-block reservation */
 	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;

commit 90306c41dc3d8e5f12ecd0193dae99e0e7f6e896
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue May 29 23:01:09 2012 -0500

    GFS2: Use lvbs for storing rgrp information with mount option
    
    Instead of reading in the resource groups when gfs2 is checking
    for free space to allocate from, gfs2 can store the necessary infromation
    in the resource group's lvb.  Also, instead of searching for unlinked
    inodes in every resource group that's checked for free space, gfs2 can
    store the number of unlinked but inodes in the lvb, and only check for
    unlinked inodes if it will find some.
    
    The first time a resource group is locked, the lvb must initialized.
    Since this involves counting the unlinked inodes in the resource group,
    this takes a little extra time.  But after that, if the resource group
    is locked with GL_SKIP, the buffer head won't be read in unless it's
    actually needed.
    
    Enabling the resource groups lvbs is done via the rgrplvb mount option.  If
    this option isn't set, the lvbs will still be set and updated, but they won't
    be verfied or used by the filesystem.  To safely turn on this option, all of
    the nodes mounting the filesystem must be running code with this patch, and
    the filesystem must have been completely unmounted since they were updated.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5cda51a3e3bd..dc730700b3b4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -89,6 +89,7 @@ struct gfs2_rgrpd {
 	u64 rd_igeneration;
 	struct gfs2_bitmap *rd_bits;
 	struct gfs2_sbd *rd_sbd;
+	struct gfs2_rgrp_lvb *rd_rgl;
 	u32 rd_last_alloc;
 	u32 rd_flags;
 #define GFS2_RDF_CHECK		0x10000000 /* check for unlinked inodes */
@@ -470,6 +471,7 @@ struct gfs2_args {
 	unsigned int ar_discard:1;		/* discard requests */
 	unsigned int ar_errors:2;               /* errors=withdraw | panic */
 	unsigned int ar_nobarrier:1;            /* do not send barriers */
+	unsigned int ar_rgrplvb:1;		/* use lvbs for rgrp info */
 	int ar_commit;				/* Commit interval */
 	int ar_statfs_quantum;			/* The fast statfs interval */
 	int ar_quota_quantum;			/* The quota interval */

commit 5407e24229408d7586ee451a384fc13e4a2332be
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri May 18 09:28:23 2012 -0400

    GFS2: Fold quota data into the reservations struct
    
    This patch moves the ancillary quota data structures into the
    block reservations structure. This saves GFS2 some time and
    effort in allocating and deallocating the qadata structure.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 67fd6beffece..5cda51a3e3bd 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -289,16 +289,14 @@ struct gfs2_glock {
 
 #define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */
 
-struct gfs2_qadata { /* quota allocation data */
-	/* Quota stuff */
-	struct gfs2_quota_data *qa_qd[2*MAXQUOTAS];
-	struct gfs2_holder qa_qd_ghs[2*MAXQUOTAS];
-	unsigned int qa_qd_num;
-};
-
 struct gfs2_blkreserv {
 	u32 rs_requested; /* Filled in by caller of gfs2_inplace_reserve() */
 	struct gfs2_holder rs_rgd_gh; /* Filled in by gfs2_inplace_reserve() */
+
+	/* ancillary quota stuff */
+	struct gfs2_quota_data *rs_qa_qd[2 * MAXQUOTAS];
+	struct gfs2_holder rs_qa_qd_ghs[2 * MAXQUOTAS];
+	unsigned int rs_qa_qd_num;
 };
 
 enum {
@@ -319,7 +317,6 @@ struct gfs2_inode {
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
-	struct gfs2_qadata *i_qadata; /* quota allocation data */
 	struct gfs2_blkreserv *i_res; /* resource group block reservation */
 	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */

commit 6101167727932a929e37fb8a6eeb68bdbf54d58e
Merge: 6133308ad1a3 75af271ed5f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 22 19:31:38 2012 -0700

    Merge tag 'dlm-3.5' of git://git.kernel.org/pub/scm/linux/kernel/git/teigland/linux-dlm
    
    Pull dlm updates from David Teigland:
     "This set includes some minor fixes and improvements.  The one large
      patch addresses the special "nodir" mode, which has been a long
      neglected proof of concept, but with these fixes seems to be quite
      usable.  It allows the resource master to be assigned statically
      instead of dynamically, which can improve performance if there is
      little locality and most resources are shared."
    
    * tag 'dlm-3.5' of git://git.kernel.org/pub/scm/linux/kernel/git/teigland/linux-dlm:
      dlm: NULL dereference on failure in kmem_cache_create()
      gfs2: fix recovery during unmount
      dlm: fixes for nodir mode
      dlm: improve error and debug messages
      dlm: avoid unnecessary search in search_rsb
      dlm: limit rcom debug messages
      dlm: fix waiter recovery
      dlm: prevent connections during shutdown

commit 4875647a08e35f77274838d97ca8fa44158d50e2
Author: David Teigland <teigland@redhat.com>
Date:   Thu Apr 26 15:54:29 2012 -0500

    dlm: fixes for nodir mode
    
    The "nodir" mode (statically assign master nodes instead
    of using the resource directory) has always been highly
    experimental, and never seriously used.  This commit
    fixes a number of problems, making nodir much more usable.
    
    - Major change to recovery: recover all locks and restart
      all in-progress operations after recovery.  In some
      cases it's not possible to know which in-progess locks
      to recover, so recover all.  (Most require recovery
      in nodir mode anyway since rehashing changes most
      master nodes.)
    
    - Change the way nodir mode is enabled, from a command
      line mount arg passed through gfs2, into a sysfs
      file managed by dlm_controld, consistent with the
      other config settings.
    
    - Allow recovering MSTCPY locks on an rsb that has not
      yet been turned into a master copy.
    
    - Ignore RCOM_LOCK and RCOM_LOCK_REPLY recovery messages
      from a previous, aborted recovery cycle.  Base this
      on the local recovery status not being in the state
      where any nodes should be sending LOCK messages for the
      current recovery cycle.
    
    - Hold rsb lock around dlm_purge_mstcpy_locks() because it
      may run concurrently with dlm_recover_master_copy().
    
    - Maintain highbast on process-copy lkb's (in addition to
      the master as is usual), because the lkb can switch
      back and forth between being a master and being a
      process copy as the master node changes in recovery.
    
    - When recovering MSTCPY locks, flag rsb's that have
      non-empty convert or waiting queues for granting
      at the end of recovery.  (Rename flag from LOCKS_PURGED
      to RECOVER_GRANT and similar for the recovery function,
      because it's not only resources with purged locks
      that need grant a grant attempt.)
    
    - Replace a couple of unnecessary assertion panics with
      error messages.
    
    Signed-off-by: David Teigland <teigland@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 47d0bda5ac2b..c7975bf4fd43 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -556,7 +556,6 @@ struct gfs2_sb_host {
 struct lm_lockstruct {
 	int ls_jid;
 	unsigned int ls_first;
-	unsigned int ls_nodir;
 	const struct lm_lockops *ls_ops;
 	dlm_lockspace_t *ls_dlm;
 

commit c0752aa7e4d48cc19e167ccb0092bea8e5b6ca3a
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue May 1 12:00:34 2012 -0400

    GFS2: eliminate log elements and simplify
    
    This patch eliminates the gfs2_log_element data structure and
    rolls its two components into the gfs2_bufdata. This makes the code
    easier to understand and makes it easier to migrate to a rbtree
    to keep the list sorted.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index f1189a2cdb78..aa9949e5de26 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -26,7 +26,7 @@
 #define DIO_METADATA	0x00000020
 
 struct gfs2_log_operations;
-struct gfs2_log_element;
+struct gfs2_bufdata;
 struct gfs2_holder;
 struct gfs2_glock;
 struct gfs2_quota_data;
@@ -52,7 +52,7 @@ struct gfs2_log_header_host {
  */
 
 struct gfs2_log_operations {
-	void (*lo_add) (struct gfs2_sbd *sdp, struct gfs2_log_element *le);
+	void (*lo_add) (struct gfs2_sbd *sdp, struct gfs2_bufdata *bd);
 	void (*lo_before_commit) (struct gfs2_sbd *sdp);
 	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_ail *ai);
 	void (*lo_before_scan) (struct gfs2_jdesc *jd,
@@ -64,11 +64,6 @@ struct gfs2_log_operations {
 	const char *lo_name;
 };
 
-struct gfs2_log_element {
-	struct list_head le_list;
-	const struct gfs2_log_operations *le_ops;
-};
-
 #define GBF_FULL 1
 
 struct gfs2_bitmap {
@@ -120,7 +115,8 @@ struct gfs2_bufdata {
 	struct gfs2_glock *bd_gl;
 	u64 bd_blkno;
 
-	struct gfs2_log_element bd_le;
+	struct list_head bd_list;
+	const struct gfs2_log_operations *bd_ops;
 
 	struct gfs2_ail *bd_ail;
 	struct list_head bd_ail_st_list;

commit 1c47f09592148ba629edb2020d4dd94f81b16d11
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Apr 27 13:59:27 2012 -0400

    GFS2: Eliminate vestigial sd_log_le_rg
    
    This patch eliminates gfs2 superblock variable sd_log_le_rg which
    is no longer used.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e773fbc28f95..f1189a2cdb78 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -690,7 +690,6 @@ struct gfs2_sbd {
 
 	struct list_head sd_log_le_buf;
 	struct list_head sd_log_le_revoke;
-	struct list_head sd_log_le_rg;
 	struct list_head sd_log_le_databuf;
 	struct list_head sd_log_le_ordered;
 

commit c50b91c4bd511dfe844e2aa7be429b6b88406353
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Apr 16 16:40:56 2012 +0100

    GFS2: Remove bd_list_tr
    
    This is another clean up in the logging code. This per-transaction
    list was largely unused. Its main function was to ensure that the
    number of buffers in a transaction was correct, however that counter
    was only used to check the number of buffers in the bd_list_tr, plus
    an assert at the end of each transaction. With the assert now changed
    to use the calculated buffer counts, we can remove both bd_list_tr and
    its associated counter.
    
    This should make the code easier to understand as well as shrinking
    a couple of structures.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index dd97f64a8bd4..e773fbc28f95 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -118,13 +118,7 @@ TAS_BUFFER_FNS(Zeronew, zeronew)
 struct gfs2_bufdata {
 	struct buffer_head *bd_bh;
 	struct gfs2_glock *bd_gl;
-
-	union {
-		struct list_head list_tr;
-		u64 blkno;
-	} u;
-#define bd_list_tr u.list_tr
-#define bd_blkno u.blkno
+	u64 bd_blkno;
 
 	struct gfs2_log_element bd_le;
 
@@ -411,13 +405,10 @@ struct gfs2_trans {
 
 	int tr_touched;
 
-	unsigned int tr_num_buf;
 	unsigned int tr_num_buf_new;
 	unsigned int tr_num_databuf_new;
 	unsigned int tr_num_buf_rm;
 	unsigned int tr_num_databuf_rm;
-	struct list_head tr_list_buf;
-
 	unsigned int tr_num_revoke;
 	unsigned int tr_num_revoke_rm;
 };

commit e8c92ed769008cfc799497f0a34c8faf46243c4d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Apr 16 09:28:31 2012 +0100

    GFS2: Clean up log write code path
    
    Prior to this patch, we have two ways of sending i/o to the log.
    One of those is used when we need to allocate both the data
    to be written itself and also a buffer head to submit it. This
    is done via sb_getblk and friends. This is used mostly for writing
    log headers.
    
    The other method is used when writing blocks which have some
    in-place counterpart. This is the case for all the metadata
    blocks which are journalled, and when journaled data is in use,
    for unescaped journalled data blocks.
    
    This patch replaces both of those two methods, and about half
    a dozen separate i/o submission points with a single i/o
    submission function. We also go direct to bio rather than
    using buffer heads, since this allows us to build i/o
    requests of the maximum size for the block device in
    question. It also reduces the memory required for flushing
    the log, which can be very useful in low memory situations.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 47d0bda5ac2b..dd97f64a8bd4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -716,7 +716,9 @@ struct gfs2_sbd {
 
 	struct rw_semaphore sd_log_flush_lock;
 	atomic_t sd_log_in_flight;
+	struct bio *sd_log_bio;
 	wait_queue_head_t sd_log_flush_wait;
+	int sd_log_error;
 
 	unsigned int sd_log_flush_head;
 	u64 sd_log_flush_wrapped;

commit 6aad1c3d3eba3db38b3a1200e2b02ff3af501c5a
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Mar 5 09:20:59 2012 -0500

    GFS2: Eliminate sd_rindex_mutex
    
    Over time, we've slowly eliminated the use of sd_rindex_mutex.
    Up to this point, it was only used in two places: function
    gfs2_ri_total (which totals the file system size by reading
    and parsing the rindex file) and function gfs2_rindex_update
    which updates the rgrps in memory. Both of these functions have
    the rindex glock to protect them, so the rindex is unnecessary.
    Since gfs2_grow writes to the rindex via the meta_fs, the mutex
    is in the wrong order according to the normal rules. This patch
    eliminates the mutex entirely to avoid the problem.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4d546df58ac9..47d0bda5ac2b 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -644,7 +644,6 @@ struct gfs2_sbd {
 
 	int sd_rindex_uptodate;
 	spinlock_t sd_rindex_spin;
-	struct mutex sd_rindex_mutex;
 	struct rb_root sd_rindex_tree;
 	unsigned int sd_rgrps;
 	unsigned int sd_max_rg_data;

commit a245769f254bbbea868e2cf8dc42daa061cd276f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Jan 20 10:38:36 2012 +0000

    GFS2: glock statistics gathering
    
    The stats are divided into two sets: those relating to the
    super block and those relating to an individual glock. The
    super block stats are done on a per cpu basis in order to
    try and reduce the overhead of gathering them. They are also
    further divided by glock type.
    
    In the case of both the super block and glock statistics,
    the same information is gathered in each case. The super
    block statistics are used to provide default values for
    most of the glock statistics, so that newly created glocks
    should have, as far as possible, a sensible starting point.
    
    The statistics are divided into three pairs of mean and
    variance, plus two counters. The mean/variance pairs are
    smoothed exponential estimates and the algorithm used is
    one which will be very familiar to those used to calculation
    of round trip times in network code.
    
    The three pairs of mean/variance measure the following
    things:
    
     1. DLM lock time (non-blocking requests)
     2. DLM lock time (blocking requests)
     3. Inter-request time (again to the DLM)
    
    A non-blocking request is one which will complete right
    away, whatever the state of the DLM lock in question. That
    currently means any requests when (a) the current state of
    the lock is exclusive (b) the requested state is either null
    or unlocked or (c) the "try lock" flag is set. A blocking
    request covers all the other lock requests.
    
    There are two counters. The first is there primarily to show
    how many lock requests have been made, and thus how much data
    has gone into the mean/variance calculations. The other counter
    is counting queueing of holders at the top layer of the glock
    code. Hopefully that number will be a lot larger than the number
    of dlm lock requests issued.
    
    So why gather these statistics? There are several reasons
    we'd like to get a better idea of these timings:
    
    1. To be able to better set the glock "min hold time"
    2. To spot performance issues more easily
    3. To improve the algorithm for selecting resource groups for
    allocation (to base it on lock wait time, rather than blindly
    using a "try lock")
    Due to the smoothing action of the updates, a step change in
    some input quantity being sampled will only fully be taken
    into account after 8 samples (or 4 for the variance) and this
    needs to be carefully considered when interpreting the
    results.
    
    Knowing both the time it takes a lock request to complete and
    the average time between lock requests for a glock means we
    can compute the total percentage of the time for which the
    node is able to use a glock vs. time that the rest of the
    cluster has its share. That will be very useful when setting
    the lock min hold time.
    
    The other point to remember is that all times are in
    nanoseconds. Great care has been taken to ensure that we
    measure exactly the quantities that we want, as accurately
    as possible. There are always inaccuracies in any
    measuring system, but I hope this is as accurate as we
    can reasonably make it.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 97742a7ea9cc..4d546df58ac9 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -19,6 +19,8 @@
 #include <linux/rculist_bl.h>
 #include <linux/completion.h>
 #include <linux/rbtree.h>
+#include <linux/ktime.h>
+#include <linux/percpu.h>
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
@@ -204,6 +206,22 @@ struct gfs2_glock_operations {
 #define GLOF_ASPACE 1
 };
 
+enum {
+	GFS2_LKS_SRTT = 0,	/* Non blocking smoothed round trip time */
+	GFS2_LKS_SRTTVAR = 1,	/* Non blocking smoothed variance */
+	GFS2_LKS_SRTTB = 2,	/* Blocking smoothed round trip time */
+	GFS2_LKS_SRTTVARB = 3,	/* Blocking smoothed variance */
+	GFS2_LKS_SIRT = 4,	/* Smoothed Inter-request time */
+	GFS2_LKS_SIRTVAR = 5,	/* Smoothed Inter-request variance */
+	GFS2_LKS_DCOUNT = 6,	/* Count of dlm requests */
+	GFS2_LKS_QCOUNT = 7,	/* Count of gfs2_holder queues */
+	GFS2_NR_LKSTATS
+};
+
+struct gfs2_lkstats {
+	s64 stats[GFS2_NR_LKSTATS];
+};
+
 enum {
 	/* States */
 	HIF_HOLDER		= 6,  /* Set for gh that "holds" the glock */
@@ -238,10 +256,12 @@ enum {
 	GLF_QUEUED			= 12,
 	GLF_LRU				= 13,
 	GLF_OBJECT			= 14, /* Used only for tracing */
+	GLF_BLOCKING			= 15,
 };
 
 struct gfs2_glock {
 	struct hlist_bl_node gl_list;
+	struct gfs2_sbd *gl_sbd;
 	unsigned long gl_flags;		/* GLF_... */
 	struct lm_lockname gl_name;
 	atomic_t gl_ref;
@@ -261,16 +281,14 @@ struct gfs2_glock {
 	struct list_head gl_holders;
 
 	const struct gfs2_glock_operations *gl_ops;
-	char gl_strname[GDLM_STRNAME_BYTES];
+	ktime_t gl_dstamp;
+	struct gfs2_lkstats gl_stats;
 	struct dlm_lksb gl_lksb;
 	char gl_lvb[32];
 	unsigned long gl_tchange;
 	void *gl_object;
 
 	struct list_head gl_lru;
-
-	struct gfs2_sbd *gl_sbd;
-
 	struct list_head gl_ail_list;
 	atomic_t gl_ail_count;
 	atomic_t gl_revokes;
@@ -560,8 +578,14 @@ struct lm_lockstruct {
 	uint32_t *ls_recover_result; /* result of last jid recovery */
 };
 
+struct gfs2_pcpu_lkstats {
+	/* One struct for each glock type */
+	struct gfs2_lkstats lkstats[10];
+};
+
 struct gfs2_sbd {
 	struct super_block *sd_vfs;
+	struct gfs2_pcpu_lkstats __percpu *sd_lkstats;
 	struct kobject sd_kobj;
 	unsigned long sd_flags;	/* SDF_... */
 	struct gfs2_sb_host sd_sb;
@@ -725,8 +749,23 @@ struct gfs2_sbd {
 
 	unsigned long sd_last_warning;
 	struct dentry *debugfs_dir;    /* debugfs directory */
-	struct dentry *debugfs_dentry_glocks; /* for debugfs */
+	struct dentry *debugfs_dentry_glocks;
+	struct dentry *debugfs_dentry_glstats;
+	struct dentry *debugfs_dentry_sbstats;
 };
 
+static inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)
+{
+	gl->gl_stats.stats[which]++;
+}
+
+static inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)
+{
+	const struct gfs2_sbd *sdp = gl->gl_sbd;
+	preempt_disable();
+	this_cpu_ptr(sdp->sd_lkstats)->lkstats[gl->gl_name.ln_type].stats[which]++;
+	preempt_enable();
+}
+
 #endif /* __INCORE_DOT_H__ */
 

commit 376d37788b56bc2800e5bd56b7a36b3544d89f97
Author: David Teigland <teigland@redhat.com>
Date:   Mon Jan 9 15:29:20 2012 -0500

    GFS2: fail mount if journal recovery fails
    
    If the first mounter fails to recover one of the journals
    during mount, the mount should fail.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e5701c70f6fb..97742a7ea9cc 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -429,6 +429,7 @@ struct gfs2_jdesc {
 #define JDF_RECOVERY 1
 	unsigned int jd_jid;
 	unsigned int jd_blocks;
+	int jd_recover_error;
 };
 
 struct gfs2_statfs_change_host {

commit e8ca5cc571a60339491f8c273a01093096ff8704
Author: David Teigland <teigland@redhat.com>
Date:   Mon Jan 9 14:40:06 2012 -0500

    GFS2: let spectator mount do read only recovery
    
    Previously, a spectator mount would not even attempt to do
    journal recovery for a failed node.  This meant that if all
    mounted nodes were spectators, everyone would be stuck after
    a node failed, all waiting for recovery to be performed.
    This is unnecessary since the failed node had a clean journal.
    
    Instead, allow a spectator mount to do a partial "read only"
    recovery, which means it will check if the failed journal is
    clean, and if so, report a successful recovery.  If the failed
    journal is not clean, it reports that journal recovery failed.
    This makes it work the same as a read only mount on a read only
    block device.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b9422bc8e2fe..e5701c70f6fb 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -498,6 +498,7 @@ enum {
 	SDF_NORECOVERY		= 4,
 	SDF_DEMOTE		= 5,
 	SDF_NOJOURNALID		= 6,
+	SDF_RORECOVERY		= 7, /* read only recovery */
 };
 
 #define GFS2_FSNAME_LEN		256

commit e0c2a9aa1e68455dc3439e95d85cabcaff073666
Author: David Teigland <teigland@redhat.com>
Date:   Mon Jan 9 17:18:05 2012 -0500

    GFS2: dlm based recovery coordination
    
    This new method of managing recovery is an alternative to
    the previous approach of using the userland gfs_controld.
    
    - use dlm slot numbers to assign journal id's
    - use dlm recovery callbacks to initiate journal recovery
    - use a dlm lock to determine the first node to mount fs
    - use a dlm lock to track journals that need recovery
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e1d3bb59945c..b9422bc8e2fe 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -139,8 +139,45 @@ struct gfs2_bufdata {
 #define GDLM_STRNAME_BYTES	25
 #define GDLM_LVB_SIZE		32
 
+/*
+ * ls_recover_flags:
+ *
+ * DFL_BLOCK_LOCKS: dlm is in recovery and will grant locks that had been
+ * held by failed nodes whose journals need recovery.  Those locks should
+ * only be used for journal recovery until the journal recovery is done.
+ * This is set by the dlm recover_prep callback and cleared by the
+ * gfs2_control thread when journal recovery is complete.  To avoid
+ * races between recover_prep setting and gfs2_control clearing, recover_spin
+ * is held while changing this bit and reading/writing recover_block
+ * and recover_start.
+ *
+ * DFL_NO_DLM_OPS: dlm lockspace ops/callbacks are not being used.
+ *
+ * DFL_FIRST_MOUNT: this node is the first to mount this fs and is doing
+ * recovery of all journals before allowing other nodes to mount the fs.
+ * This is cleared when FIRST_MOUNT_DONE is set.
+ *
+ * DFL_FIRST_MOUNT_DONE: this node was the first mounter, and has finished
+ * recovery of all journals, and now allows other nodes to mount the fs.
+ *
+ * DFL_MOUNT_DONE: gdlm_mount has completed successfully and cleared
+ * BLOCK_LOCKS for the first time.  The gfs2_control thread should now
+ * control clearing BLOCK_LOCKS for further recoveries.
+ *
+ * DFL_UNMOUNT: gdlm_unmount sets to keep sdp off gfs2_control_wq.
+ *
+ * DFL_DLM_RECOVERY: set while dlm is in recovery, between recover_prep()
+ * and recover_done(), i.e. set while recover_block == recover_start.
+ */
+
 enum {
 	DFL_BLOCK_LOCKS		= 0,
+	DFL_NO_DLM_OPS		= 1,
+	DFL_FIRST_MOUNT		= 2,
+	DFL_FIRST_MOUNT_DONE	= 3,
+	DFL_MOUNT_DONE		= 4,
+	DFL_UNMOUNT		= 5,
+	DFL_DLM_RECOVERY	= 6,
 };
 
 struct lm_lockname {
@@ -499,14 +536,26 @@ struct gfs2_sb_host {
 struct lm_lockstruct {
 	int ls_jid;
 	unsigned int ls_first;
-	unsigned int ls_first_done;
 	unsigned int ls_nodir;
 	const struct lm_lockops *ls_ops;
-	unsigned long ls_flags;
 	dlm_lockspace_t *ls_dlm;
 
-	int ls_recover_jid_done;
-	int ls_recover_jid_status;
+	int ls_recover_jid_done;   /* These two are deprecated, */
+	int ls_recover_jid_status; /* used previously by gfs_controld */
+
+	struct dlm_lksb ls_mounted_lksb; /* mounted_lock */
+	struct dlm_lksb ls_control_lksb; /* control_lock */
+	char ls_control_lvb[GDLM_LVB_SIZE]; /* control_lock lvb */
+	struct completion ls_sync_wait; /* {control,mounted}_{lock,unlock} */
+
+	spinlock_t ls_recover_spin; /* protects following fields */
+	unsigned long ls_recover_flags; /* DFL_ */
+	uint32_t ls_recover_mount; /* gen in first recover_done cb */
+	uint32_t ls_recover_start; /* gen in last recover_done cb */
+	uint32_t ls_recover_block; /* copy recover_start in last recover_prep */
+	uint32_t ls_recover_size; /* size of recover_submit, recover_result */
+	uint32_t *ls_recover_submit; /* gen in last recover_slot cb per jid */
+	uint32_t *ls_recover_result; /* result of last jid recovery */
 };
 
 struct gfs2_sbd {
@@ -544,6 +593,7 @@ struct gfs2_sbd {
 	wait_queue_head_t sd_glock_wait;
 	atomic_t sd_glock_disposal;
 	struct completion sd_locking_init;
+	struct delayed_work sd_control_work;
 
 	/* Inode Stuff */
 

commit 564e12b1157215171e7f3af5b70611ec7154327c
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Nov 21 13:36:17 2011 -0500

    GFS2: decouple quota allocations from block allocations
    
    This patch separates the code pertaining to allocations into two
    parts: quota-related information and block reservations.
    This patch also moves all the block reservation structure allocations to
    function gfs2_inplace_reserve to simplify the code, and moves
    the frees to function gfs2_inplace_release.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 32f5beccb74b..e1d3bb59945c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -244,16 +244,16 @@ struct gfs2_glock {
 
 #define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */
 
-struct gfs2_alloc {
+struct gfs2_qadata { /* quota allocation data */
 	/* Quota stuff */
-	struct gfs2_quota_data *al_qd[2*MAXQUOTAS];
-	struct gfs2_holder al_qd_ghs[2*MAXQUOTAS];
-	unsigned int al_qd_num;
-
-	u32 al_requested; /* Filled in by caller of gfs2_inplace_reserve() */
+	struct gfs2_quota_data *qa_qd[2*MAXQUOTAS];
+	struct gfs2_holder qa_qd_ghs[2*MAXQUOTAS];
+	unsigned int qa_qd_num;
+};
 
-	/* Filled in by gfs2_inplace_reserve() */
-	struct gfs2_holder al_rgd_gh;
+struct gfs2_blkreserv {
+	u32 rs_requested; /* Filled in by caller of gfs2_inplace_reserve() */
+	struct gfs2_holder rs_rgd_gh; /* Filled in by gfs2_inplace_reserve() */
 };
 
 enum {
@@ -274,7 +274,8 @@ struct gfs2_inode {
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
-	struct gfs2_alloc *i_alloc;
+	struct gfs2_qadata *i_qadata; /* quota allocation data */
+	struct gfs2_blkreserv *i_res; /* resource group block reservation */
 	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;

commit b9f417f311a7141d0ba67e5c8e535010d2712f2d
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Nov 16 17:50:37 2011 -0500

    GFS2: remove vestigial al_alloced
    
    This patch removes the vestigial variable al_alloced from
    the gfs2_alloc structure. This is another baby step toward
    multi-block reservations.
    
    My next planned step is to decouple the quota variables
    from the gfs2_alloc structure so we can use a different
    method for allocations.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7389dfdcc9ef..32f5beccb74b 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -251,7 +251,6 @@ struct gfs2_alloc {
 	unsigned int al_qd_num;
 
 	u32 al_requested; /* Filled in by caller of gfs2_inplace_reserve() */
-	u32 al_alloced; /* Filled in by gfs2_alloc_*() */
 
 	/* Filled in by gfs2_inplace_reserve() */
 	struct gfs2_holder al_rgd_gh;

commit 9ae32429fe036fcfce036ec57b28fc59f3911976
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Sep 20 12:16:11 2011 +0100

    GFS2: Remove two unused variables
    
    The two variables being initialised in gfs2_inplace_reserve
    to track the file & line number of the caller are never
    used, so we might as well remove them.
    
    If something does go wrong, then a stack trace is probably
    more useful anyway.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6429aa4339ff..7389dfdcc9ef 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -246,7 +246,6 @@ struct gfs2_glock {
 
 struct gfs2_alloc {
 	/* Quota stuff */
-
 	struct gfs2_quota_data *al_qd[2*MAXQUOTAS];
 	struct gfs2_holder al_qd_ghs[2*MAXQUOTAS];
 	unsigned int al_qd_num;
@@ -255,9 +254,6 @@ struct gfs2_alloc {
 	u32 al_alloced; /* Filled in by gfs2_alloc_*() */
 
 	/* Filled in by gfs2_inplace_reserve() */
-
-	unsigned int al_line;
-	char *al_file;
 	struct gfs2_holder al_rgd_gh;
 };
 

commit 64dd153c83743af81f20924c6343652d731eeecb
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Mon Sep 12 18:15:24 2011 -0500

    GFS2: rewrite fallocate code to write blocks directly
    
    GFS2's fallocate code currently goes through the page cache. Since it's only
    writing to the end of the file or to holes in it, it doesn't need to, and it
    was causing issues on low memory environments. This patch pulls in some of
    Steve's block allocation work, and uses it to simply allocate the blocks for
    the file, and zero them out at allocation time.  It provides a slight
    performance increase, and it dramatically simplifies the code.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 55e335b52839..6429aa4339ff 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -103,12 +103,15 @@ struct gfs2_rgrpd {
 enum gfs2_state_bits {
 	BH_Pinned = BH_PrivateStart,
 	BH_Escaped = BH_PrivateStart + 1,
+	BH_Zeronew = BH_PrivateStart + 2,
 };
 
 BUFFER_FNS(Pinned, pinned)
 TAS_BUFFER_FNS(Pinned, pinned)
 BUFFER_FNS(Escaped, escaped)
 TAS_BUFFER_FNS(Escaped, escaped)
+BUFFER_FNS(Zeronew, zeronew)
+TAS_BUFFER_FNS(Zeronew, zeronew)
 
 struct gfs2_bufdata {
 	struct buffer_head *bd_bh;

commit 54335b1fca27b84baa75b1f45985d98262003837
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Sep 1 13:31:59 2011 +0100

    GFS2: Cache the most recently used resource group in the inode
    
    This means that after the initial allocation for any inode, the
    last used resource group is cached in the inode for future use.
    This drastically reduces the number of lookups of resource
    groups in the common case, and this the contention on that
    data structure.
    
    The allocation algorithm is the same as previously, except that we
    always check to see if the goal block is within the cached rgrp
    first before going to the rbtree to look one up.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 56847f5903ae..55e335b52839 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -256,8 +256,6 @@ struct gfs2_alloc {
 	unsigned int al_line;
 	char *al_file;
 	struct gfs2_holder al_rgd_gh;
-	struct gfs2_rgrpd *al_rgd;
-
 };
 
 enum {
@@ -279,6 +277,7 @@ struct gfs2_inode {
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
 	struct gfs2_alloc *i_alloc;
+	struct gfs2_rgrpd *i_rgd;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
 	struct list_head i_trunc_list;

commit 8339ee543ece6e2dcc1bbd97d5350163c198cf00
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 31 16:38:29 2011 +0100

    GFS2: Make resource groups "append only" during life of fs
    
    Since we have ruled out supporting online filesystem shrink,
    it is possible to make the resource group list append only
    during the life of a super block. This gives several benefits:
    
    Firstly, we only need to read new rindex elements as they are added
    rather than needing to reread the whole rindex file each time one
    element is added.
    
    Secondly, the rindex glock can be held for much shorter periods of
    time, and is completely removed from the fast path for allocations.
    The lock is taken in shared mode only when updating the resource
    groups when the first allocation occurs, and after a grow has
    taken place.
    
    Thirdly, this results in a reduction in code size, and everything
    gets a lot simpler to understand in this area.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9e753fc9e6a5..56847f5903ae 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -255,7 +255,6 @@ struct gfs2_alloc {
 
 	unsigned int al_line;
 	char *al_file;
-	struct gfs2_holder al_ri_gh;
 	struct gfs2_holder al_rgd_gh;
 	struct gfs2_rgrpd *al_rgd;
 

commit 7c9ca621137cde26be05448133fc1a554345f4f8
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Aug 31 09:53:19 2011 +0100

    GFS2: Use rbtree for resource groups and clean up bitmap buffer ref count scheme
    
    Here is an update of Bob's original rbtree patch which, in addition, also
    resolves the rather strange ref counting that was being done relating to
    the bitmap blocks.
    
    Originally we had a dual system for journaling resource groups. The metadata
    blocks were journaled and also the rgrp itself was added to a list. The reason
    for adding the rgrp to the list in the journal was so that the "repolish
    clones" code could be run to update the free space, and potentially send any
    discard requests when the log was flushed. This was done by comparing the
    "cloned" bitmap with what had been written back on disk during the transaction
    commit.
    
    Due to this, there was a requirement to hang on to the rgrps' bitmap buffers
    until the journal had been flushed. For that reason, there was a rather
    complicated set up in the ->go_lock ->go_unlock functions for rgrps involving
    both a mutex and a spinlock (the ->sd_rindex_spin) to maintain a reference
    count on the buffers.
    
    However, the journal maintains a reference count on the buffers anyway, since
    they are being journaled as metadata buffers. So by moving the code which deals
    with the post-journal accounting for bitmap blocks to the metadata journaling
    code, we can entirely dispense with the rather strange buffer ref counting
    scheme and also the requirement to journal the rgrps.
    
    The net result of all this is that the ->sd_rindex_spin is left to do exactly
    one job, and that is to look after the rbtree or rgrps.
    
    This patch is designed to be a stepping stone towards using RCU for the rbtree
    of resource groups, however the reduction in the number of uses of the
    ->sd_rindex_spin is likely to have benefits for multi-threaded workloads,
    anyway.
    
    The patch retains ->go_lock and ->go_unlock for rgrps, however these maybe also
    be removed in future in favour of calling the functions directly where required
    in the code. That will allow locking of resource groups without needing to
    actually read them in - something that could be useful in speeding up statfs.
    
    In the mean time though it is valid to dereference ->bi_bh only when the rgrp
    is locked. This is basically the same rule as before, modulo the references not
    being valid until the following journal flush.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Cc: Benjamin Marzinski <bmarzins@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index be5801a75406..9e753fc9e6a5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -18,6 +18,7 @@
 #include <linux/rcupdate.h>
 #include <linux/rculist_bl.h>
 #include <linux/completion.h>
+#include <linux/rbtree.h>
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
@@ -78,8 +79,7 @@ struct gfs2_bitmap {
 };
 
 struct gfs2_rgrpd {
-	struct list_head rd_list;	/* Link with superblock */
-	struct list_head rd_list_mru;
+	struct rb_node rd_node;		/* Link with superblock */
 	struct gfs2_glock *rd_gl;	/* Glock for this rgrp */
 	u64 rd_addr;			/* grp block disk address */
 	u64 rd_data0;			/* first data location */
@@ -91,10 +91,7 @@ struct gfs2_rgrpd {
 	u32 rd_dinodes;
 	u64 rd_igeneration;
 	struct gfs2_bitmap *rd_bits;
-	struct mutex rd_mutex;
-	struct gfs2_log_element rd_le;
 	struct gfs2_sbd *rd_sbd;
-	unsigned int rd_bh_count;
 	u32 rd_last_alloc;
 	u32 rd_flags;
 #define GFS2_RDF_CHECK		0x10000000 /* check for unlinked inodes */
@@ -575,9 +572,7 @@ struct gfs2_sbd {
 	int sd_rindex_uptodate;
 	spinlock_t sd_rindex_spin;
 	struct mutex sd_rindex_mutex;
-	struct list_head sd_rindex_list;
-	struct list_head sd_rindex_mru_list;
-	struct gfs2_rgrpd *sd_rindex_forward;
+	struct rb_root sd_rindex_tree;
 	unsigned int sd_rgrps;
 	unsigned int sd_max_rg_data;
 

commit 40ac218f52aa5cac7dc8082f28b61c8b2b29373c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Aug 2 13:17:27 2011 +0100

    GFS2: Fix inode allocation error path
    
    If we have got far enough through the inode allocation code
    path that an inode has already been allocated, then we must
    call iput to dispose of it, if an error occurs during a
    later part of the process. This will always be the final iput
    since there will be no other references to the inode.
    
    Unlike when the inode has been unlinked, its block state will
    be GFS2_BLKST_INODE rather than GFS2_BLKST_UNLINKED so we need
    to skip the test in ->evict_inode() for this one case in order
    to ensure that it will be deallocated correctly. This patch adds
    a new flag in order to ensure that this will happen correctly.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 892ac37de8ae..be5801a75406 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -267,6 +267,7 @@ struct gfs2_alloc {
 enum {
 	GIF_INVALID		= 0,
 	GIF_QD_LOCKED		= 1,
+	GIF_ALLOC_FAILED	= 2,
 	GIF_SW_PAGED		= 3,
 };
 

commit 7cf8dcd3b68a760d66fbc7f0d75d3fbb8f21775d
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Jun 15 11:41:48 2011 -0400

    GFS2: Automatically adjust glock min hold time
    
    This patch is a performance improvement for GFS2 in a clustered
    environment. It makes the glock hold time self-adjusting.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 24cd55f60e60..892ac37de8ae 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -163,7 +163,6 @@ struct gfs2_glock_operations {
 	int (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
 	void (*go_callback) (struct gfs2_glock *gl);
 	const int go_type;
-	const unsigned long go_min_hold_time;
 	const unsigned long go_flags;
 #define GLOF_ASPACE 1
 };
@@ -221,6 +220,7 @@ struct gfs2_glock {
 
 	unsigned int gl_hash;
 	unsigned long gl_demote_time; /* time of first demote request */
+	long gl_hold_time;
 	struct list_head gl_holders;
 
 	const struct gfs2_glock_operations *gl_ops;

commit 17d539f0499fa2c0321b7c260831cca2bb36d119
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jun 15 10:29:37 2011 +0100

    GFS2: Cache dir hash table in a contiguous buffer
    
    This patch adds a cache for the hash table to the directory code
    in order to help simplify the way in which the hash table is
    accessed. This is intended to be a first step towards introducing
    some performance improvements in the directory code.
    
    There are two follow ups that I'm hoping to see fairly shortly. One
    is to simplify the hash table reading code now that we always read the
    complete hash table, whether we want one entry or all of them. The
    other is to introduce readahead on the heads of the hash chains
    which are referred to from the table.
    
    The hash table is a maximum of 128k in size, so it is not worth trying
    to read it in small chunks.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 81206e70cbf6..24cd55f60e60 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -285,6 +285,7 @@ struct gfs2_inode {
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
 	struct list_head i_trunc_list;
+	__be64 *i_hash_cache;
 	u32 i_entries;
 	u32 i_diskflags;
 	u8 i_height;

commit 3942ae5319640ced5844b75f44884e4bcb8a2f16
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jul 11 08:53:30 2011 +0100

    GFS2: Fix race during filesystem mount
    
    There is a potential race during filesystem mounting which has recently
    been reported. It occurs when the userland gfs_controld is able to
    process requests fast enough that it tries to use the sysfs interface
    before the lock module is properly initialised. This is a pretty
    unusual case as normally the lock module initialisation is very quick
    compared with gfs_controld.
    
    This patch adds an interruptible completion which is used to ensure that
    userland will wait for the initialisation of the lock module to
    complete.
    
    There are other potential solutions to this problem, but this is the
    quickest at this stage and has been tested both with and without
    mount.gfs2 present in the system.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Reported-by: David Booher <dbooher@adams.net>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 0a064e91ac70..81206e70cbf6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -17,6 +17,7 @@
 #include <linux/buffer_head.h>
 #include <linux/rcupdate.h>
 #include <linux/rculist_bl.h>
+#include <linux/completion.h>
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
@@ -546,6 +547,7 @@ struct gfs2_sbd {
 	struct gfs2_glock *sd_trans_gl;
 	wait_queue_head_t sd_glock_wait;
 	atomic_t sd_glock_disposal;
+	struct completion sd_locking_init;
 
 	/* Inode Stuff */
 

commit 32e471ef1057e812856739d26b4a87d929fb8aa1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue May 10 15:01:59 2011 +0100

    GFS2: Use UUID field in generic superblock
    
    The VFS superblock structure now has a UUID field, so we can use that
    in preference to the UUID field in the GFS2 superblock now.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 69a63823f7c5..0a064e91ac70 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -488,7 +488,6 @@ struct gfs2_sb_host {
 
 	char sb_lockproto[GFS2_LOCKNAME_LEN];
 	char sb_locktable[GFS2_LOCKNAME_LEN];
-	u8 sb_uuid[16];
 };
 
 /*

commit 4667a0ec32867865fd4deccf834594b3ea831baf
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Apr 18 14:18:09 2011 +0100

    GFS2: Make writeback more responsive to system conditions
    
    This patch adds writeback_control to writing back the AIL
    list. This means that we can then take advantage of the
    information we get in ->write_inode() in order to set off
    some pre-emptive writeback.
    
    In addition, the AIL code is cleaned up a bit to make it
    a bit simpler to understand.
    
    There is still more which can usefully be done in this area,
    but this is a good start at least.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5067beaffa68..69a63823f7c5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -20,7 +20,6 @@
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
-#define DIO_ALL		0x00000100
 
 struct gfs2_log_operations;
 struct gfs2_log_element;
@@ -377,8 +376,6 @@ struct gfs2_ail {
 	unsigned int ai_first;
 	struct list_head ai_ail1_list;
 	struct list_head ai_ail2_list;
-
-	u64 ai_sync_gen;
 };
 
 struct gfs2_journal_extent {
@@ -657,7 +654,6 @@ struct gfs2_sbd {
 	spinlock_t sd_ail_lock;
 	struct list_head sd_ail1_list;
 	struct list_head sd_ail2_list;
-	u64 sd_ail_sync_gen;
 
 	/* Replay stuff */
 

commit f42ab0852946c1fb5103682c5897eb3da908e4b0
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Apr 14 16:50:31 2011 +0100

    GFS2: Optimise glock lru and end of life inodes
    
    The GLF_LRU flag introduced in the previous patch can be
    used to check if a glock is on the lru list when a new
    holder is queued and if so remove it, without having first
    to get the lru_lock.
    
    The main purpose of this patch however is to optimise the
    glocks left over when an inode at end of life is being
    evicted. Previously such glocks were left with the GLF_LFLUSH
    flag set, so that when reclaimed, each one required a log flush.
    This patch resets the GLF_LFLUSH flag when there is nothing
    left to flush thus preventing later log flushes as glocks are
    reused or demoted.
    
    In order to do this, we need to keep track of the number of
    revokes which are outstanding, and also to clear the GLF_LFLUSH
    bit after a log commit when only revokes have been processed.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 48eb1eed51b5..5067beaffa68 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -236,6 +236,7 @@ struct gfs2_glock {
 
 	struct list_head gl_ail_list;
 	atomic_t gl_ail_count;
+	atomic_t gl_revokes;
 	struct delayed_work gl_work;
 	struct work_struct gl_delete;
 	struct rcu_head gl_rcu;

commit 627c10b7e471b5dcfb7101d6cc74d219619c9bc4
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Apr 14 14:09:52 2011 +0100

    GFS2: Improve tracing support (adds two flags)
    
    This adds support for two new flags. One keeps track of whether
    the glock is on the LRU list or not. The other isn't really a
    flag as such, but an indication of whether the glock has an
    attached object or not. This indication is reported without
    any locking, which is ok since we do not dereference the object
    pointer but merely report whether it is NULL or not.
    
    Also, this fixes one place where a tracepoint was missing, which
    was at the point we remove deallocated blocks from the journal.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 870a89d6d4dc..48eb1eed51b5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -200,6 +200,8 @@ enum {
 	GLF_INITIAL			= 10,
 	GLF_FROZEN			= 11,
 	GLF_QUEUED			= 12,
+	GLF_LRU				= 13,
+	GLF_OBJECT			= 14, /* Used only for tracing */
 };
 
 struct gfs2_glock {

commit d6a079e82efd5fcbb1c7295f22e123c2cc748018
Author: Dave Chinner <dchinner@redhat.com>
Date:   Fri Mar 11 11:52:25 2011 +0000

    GFS2: introduce AIL lock
    
    The log lock is currently used to protect the AIL lists and
    the movements of buffers into and out of them. The lists
    are self contained and no log specific items outside the
    lists are accessed when starting or emptying the AIL lists.
    
    Hence the operation of the AIL does not require the protection
    of the log lock so split them out into a new AIL specific lock
    to reduce the amount of traffic on the log lock. This will
    also reduce the amount of serialisation that occurs when
    the gfs2_logd pushes on the AIL to move it forward.
    
    This reduces the impact of log pushing on sequential write
    throughput.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 59aaaa051136..870a89d6d4dc 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -651,6 +651,7 @@ struct gfs2_sbd {
 	unsigned int sd_log_flush_head;
 	u64 sd_log_flush_wrapped;
 
+	spinlock_t sd_ail_lock;
 	struct list_head sd_ail1_list;
 	struct list_head sd_ail2_list;
 	u64 sd_ail_sync_gen;

commit 662e3a551b468c7338f5291d7a00389fe85885e2
Author: Abhijith Das <adas@redhat.com>
Date:   Tue Mar 8 10:40:42 2011 -0500

    GFS2: quota allows exceeding hard limit
    
    Immediately after being synced to disk, cached quotas are zeroed out and a
    subsequent access of the cached quotas results in incorrect zero values. This
    meant that gfs2 assumed the actual usage to be the zero (or near-zero) usage
    values it found in the cached quotas and comparison against warn/limits never
    triggered a quota violation.
    
    This patch adds a new flag QDF_REFRESH that is set after a sync so that the
    cached quotas are forcefully refreshed from disk on a subsequent access on
    seeing this flag set.
    
    Resolves: rhbz#675944
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 720c1e66b343..59aaaa051136 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -317,6 +317,7 @@ enum {
 	QDF_USER		= 0,
 	QDF_CHANGE		= 1,
 	QDF_LOCKED		= 2,
+	QDF_REFRESH		= 3,
 };
 
 struct gfs2_quota_data {

commit bc015cb84129eb1451913cfebece270bf7a39e0f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jan 19 09:30:01 2011 +0000

    GFS2: Use RCU for glock hash table
    
    This has a number of advantages:
    
     - Reduces contention on the hash table lock
     - Makes the code smaller and simpler
     - Should speed up glock dumps when under load
     - Removes ref count changing in examine_bucket
     - No longer need hash chain lock in glock_put() in common case
    
    There are some further changes which this enables and which
    we may do in the future. One is to look at using SLAB_RCU,
    and another is to look at using a per-cpu counter for the
    per-sb glock counter, since that is touched twice in the
    lifetime of each glock (but only used at umount time).
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a79790c06275..720c1e66b343 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -15,6 +15,8 @@
 #include <linux/workqueue.h>
 #include <linux/dlm.h>
 #include <linux/buffer_head.h>
+#include <linux/rcupdate.h>
+#include <linux/rculist_bl.h>
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
@@ -201,7 +203,7 @@ enum {
 };
 
 struct gfs2_glock {
-	struct hlist_node gl_list;
+	struct hlist_bl_node gl_list;
 	unsigned long gl_flags;		/* GLF_... */
 	struct lm_lockname gl_name;
 	atomic_t gl_ref;
@@ -234,6 +236,7 @@ struct gfs2_glock {
 	atomic_t gl_ail_count;
 	struct delayed_work gl_work;
 	struct work_struct gl_delete;
+	struct rcu_head gl_rcu;
 };
 
 #define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */

commit 57cc7215b70856dc6bae8e55b00ecd7b1d7429b1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jan 10 08:18:25 2011 +0200

    headers: kobject.h redux
    
    Remove kobject.h from files which don't need it, notably,
    sched.h and fs.h.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8d3d2b4a0a7d..a79790c06275 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -11,6 +11,7 @@
 #define __INCORE_DOT_H__
 
 #include <linux/fs.h>
+#include <linux/kobject.h>
 #include <linux/workqueue.h>
 #include <linux/dlm.h>
 #include <linux/buffer_head.h>

commit 47a25380e37f44db7202093ca92e4af569c34f55
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 30 15:49:31 2010 +0000

    GFS2: Merge glock state fields into a bitfield
    
    We can only merge the fields into a bitfield if the locking
    rules for them are the same. In this case gl_spin covers all
    of the fields (write side) but a couple of them are used
    with GLF_LOCK as the read side lock, which should be ok
    since we know that the field in question won't be changing
    at the time.
    
    The gl_req setting has to be done earlier (in glock.c) in order
    to place it under gl_spin. The gl_reply setting also has to be
    brought under gl_spin in order to comply with the new rules.
    
    This saves 4*sizeof(unsigned int) per glock.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 764fbb49efc8..8d3d2b4a0a7d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -207,12 +207,14 @@ struct gfs2_glock {
 
 	spinlock_t gl_spin;
 
-	unsigned int gl_state;
-	unsigned int gl_target;
-	unsigned int gl_reply;
+	/* State fields protected by gl_spin */
+	unsigned int gl_state:2,	/* Current state */
+		     gl_target:2,	/* Target state */
+		     gl_demote_state:2,	/* State requested by remote node */
+		     gl_req:2,		/* State in last dlm request */
+		     gl_reply:8;	/* Last reply from the dlm */
+
 	unsigned int gl_hash;
-	unsigned int gl_req;
-	unsigned int gl_demote_state; /* state requested by remote node */
 	unsigned long gl_demote_time; /* time of first demote request */
 	struct list_head gl_holders;
 

commit feb47ca9314666d920855b8a235032dea2b2caa4
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Sep 29 15:04:18 2010 +0100

    GFS2: Improve journal allocation via sysfs
    
    Recently a feature was added to GFS2 to allow journal id allocation
    via sysfs. This patch builds upon that so that a negative journal id
    will be treated as an error code to be passed back as the return code
    from mount. This allows termination of the mount process if there is
    a failure.
    
    Also, the process has been updated so that the kernel will wait
    for a journal id, even in the "spectator" case. This is required
    in order to avoid mounting a filesystem in case there is an error
    while joining the cluster. In the spectator case, 0 is written into
    the file to indicate that all is well, and that mount should continue.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6f6ff8aba99a..764fbb49efc8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -494,7 +494,7 @@ struct gfs2_sb_host {
  */
 
 struct lm_lockstruct {
-	unsigned int ls_jid;
+	int ls_jid;
 	unsigned int ls_first;
 	unsigned int ls_first_done;
 	unsigned int ls_nodir;

commit c80dbb58f9c3f84372e37dfe80b41810052ad62f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 24 09:55:07 2010 +0100

    GFS2: Remove upgrade mount option
    
    This option has never done anything useful. Also at the same time
    this cleans up the sb checks which are done at mount time. The
    debug option will be accepted, but ignored in future. Since it
    didn't do anything, there didn't seem much point in retaining it.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 2990a0a57e61..6f6ff8aba99a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -418,7 +418,6 @@ struct gfs2_args {
 	unsigned int ar_spectator:1;		/* Don't get a journal */
 	unsigned int ar_localflocks:1;		/* Let the VFS do flock|fcntl */
 	unsigned int ar_debug:1;		/* Oops on errors */
-	unsigned int ar_upgrade:1;		/* Upgrade ondisk format */
 	unsigned int ar_posix_acl:1;		/* Enable posix acls */
 	unsigned int ar_quota:2;		/* off/account/on */
 	unsigned int ar_suiddir:1;		/* suiddir support */

commit c2048b003cfb840ad81bdc6eb55beb12a19a222e
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Sep 23 14:00:31 2010 +0100

    GFS2: Remove localcaching mount option
    
    This option defaulted to on for lock_nolock mounts and off
    otherwise. The only function was to avoid the revalidation of
    dentries. In the cluster case, that is entirely pointless and
    liable to cause coherency problems.
    
    The patch changes the revalidation to depend upon whether the
    fs is a local or cluster fs (i.e. it follows the existing default
    behaviour). I very much doubt anybody ever used this option as
    there is no reason to. Even so we will continue to accept it
    on the mount command line, but ignore it.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c8a2db1bfe65..2990a0a57e61 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -417,7 +417,6 @@ struct gfs2_args {
 	char ar_hostdata[GFS2_LOCKNAME_LEN];	/* Host specific data */
 	unsigned int ar_spectator:1;		/* Don't get a journal */
 	unsigned int ar_localflocks:1;		/* Let the VFS do flock|fcntl */
-	unsigned int ar_localcaching:1;		/* Local caching */
 	unsigned int ar_debug:1;		/* Oops on errors */
 	unsigned int ar_upgrade:1;		/* Upgrade ondisk format */
 	unsigned int ar_posix_acl:1;		/* Enable posix acls */

commit f57a024ed2ee00d62515ffd4040f5ded3e0eb853
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Sep 23 13:41:42 2010 +0100

    GFS2: Remove ignore_local_fs mount argument
    
    This is been a no-op for a very long time now. I'm pretty sure
    nobody uses it, but just in case we'll still accept it on the
    command line, but ignore it.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b12ca10481e7..c8a2db1bfe65 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -416,7 +416,6 @@ struct gfs2_args {
 	char ar_locktable[GFS2_LOCKNAME_LEN];	/* Name of the Lock Table */
 	char ar_hostdata[GFS2_LOCKNAME_LEN];	/* Host specific data */
 	unsigned int ar_spectator:1;		/* Don't get a journal */
-	unsigned int ar_ignore_local_fs:1;	/* Ignore optimisations */
 	unsigned int ar_localflocks:1;		/* Let the VFS do flock|fcntl */
 	unsigned int ar_localcaching:1;		/* Local caching */
 	unsigned int ar_debug:1;		/* Oops on errors */

commit 7b5e3d5fcf0d6fce66050bd0313a7dc2ae4abc62
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 3 09:39:20 2010 +0100

    GFS2: Don't enforce min hold time when two demotes occur in rapid succession
    
    Due to the design of the VFS, it is quite usual for operations on GFS2
    to consist of a lookup (requiring a shared lock) followed by an
    operation requiring an exclusive lock. If a remote node has cached an
    exclusive lock, then it will receive two demote events in rapid succession
    firstly for a shared lock and then to unlocked. The existing min hold time
    code was triggering in this case, even if the node was otherwise idle
    since the state change time was being updated by the initial demote.
    
    This patch introduces logic to skip the min hold timer in the case that
    a "double demote" of this kind has occurred. The min hold timer will
    still be used in all other cases.
    
    A new glock flag is introduced which is used to keep track of whether
    there have been any newly queued holders since the last glock state
    change. The min hold time is only applied if the flag is set.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Tested-by: Abhijith Das <adas@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 578234bb03f8..b12ca10481e7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -196,6 +196,7 @@ enum {
 	GLF_REPLY_PENDING		= 9,
 	GLF_INITIAL			= 10,
 	GLF_FROZEN			= 11,
+	GLF_QUEUED			= 12,
 };
 
 struct gfs2_glock {

commit 3921120e757f9167f3fcd3a1781239824471b14d
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Fri Aug 20 00:21:02 2010 -0500

    GFS2: fallocate support
    
    This patch adds support for fallocate to gfs2.  Since the gfs2 does not support
    uninitialized data blocks, it must write out zeros to all the blocks.  However,
    since it does not need to lock any pages to read from, gfs2 can write out the
    zero blocks much more efficiently.  On a moderately full filesystem, fallocate
    works around 5 times faster on average.  The fallocate call also allows gfs2 to
    add blocks to the file without changing the filesize, which will make it
    possible for gfs2 to preallocate space for the rindex file, so that gfs2 can
    grow a completely full filesystem.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c11971775275..578234bb03f8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -571,6 +571,7 @@ struct gfs2_sbd {
 	struct list_head sd_rindex_mru_list;
 	struct gfs2_rgrpd *sd_rindex_forward;
 	unsigned int sd_rgrps;
+	unsigned int sd_max_rg_data;
 
 	/* Journal index stuff */
 

commit a2e0f79939e09e74698564b88dee709db208e1e2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 11 09:53:11 2010 +0100

    GFS2: Remove i_disksize
    
    With the update of the truncate code, ip->i_disksize and
    inode->i_size are merely copies of each other. This means
    we can remove ip->i_disksize and use inode->i_size exclusively
    reducing the size of a GFS2 inode by 8 bytes.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index fdbf4b366fa5..c11971775275 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -267,7 +267,6 @@ struct gfs2_inode {
 	u64 i_no_formal_ino;
 	u64 i_generation;
 	u64 i_eattr;
-	loff_t i_disksize;
 	unsigned long i_flags;		/* GIF_... */
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;

commit 3b7433b8a8a83c87972065b1852b7dcae691e464
Merge: 4a386c3e177c 6ee0578b4daa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 12:42:58 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq: (55 commits)
      workqueue: mark init_workqueues() as early_initcall()
      workqueue: explain for_each_*cwq_cpu() iterators
      fscache: fix build on !CONFIG_SYSCTL
      slow-work: kill it
      gfs2: use workqueue instead of slow-work
      drm: use workqueue instead of slow-work
      cifs: use workqueue instead of slow-work
      fscache: drop references to slow-work
      fscache: convert operation to use workqueue instead of slow-work
      fscache: convert object to use workqueue instead of slow-work
      workqueue: fix how cpu number is stored in work->data
      workqueue: fix mayday_mask handling on UP
      workqueue: fix build problem on !CONFIG_SMP
      workqueue: fix locking in retry path of maybe_create_worker()
      async: use workqueue for worker pool
      workqueue: remove WQ_SINGLE_CPU and use WQ_UNBOUND instead
      workqueue: implement unbound workqueue
      workqueue: prepare for WQ_UNBOUND implementation
      libata: take advantage of cmwq and remove concurrency limitations
      workqueue: fix worker management invocation without pending works
      ...
    
    Fixed up conflicts in fs/cifs/* as per Tejun. Other trivial conflicts in
    include/linux/workqueue.h, kernel/trace/Kconfig and kernel/workqueue.c

commit ba6e93645f039bd357e04b7b9d18f4e67757725e
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jun 14 10:01:30 2010 +0100

    GFS2: Wait for journal id on mount if not specified on mount command line
    
    This patch implements a wait for the journal id in the case that it has
    not been specified on the command line. This is to allow the future
    removal of the mount.gfs2 helper. The journal id would instead be
    directly communicated by gfs_controld to the file system. Here is a
    comparison of the two systems:
    
    Current:
    1. mount calls mount.gfs2
    2. mount.gfs2 connects to gfs_controld to retrieve the journal id
    3. mount.gfs2 adds the journal id to the mount command line and calls
    the mount system call
    4. gfs_controld receives the status of the mount request via a uevent
    
    Proposed:
    1. mount calls the mount system call (no mount.gfs2 helper)
    2. gfs_controld receives a uevent for a gfs2 fs which it doesn't know
    about already
    3. gfs_controld assigns a journal id to it via sysfs
    4. the mount system call then completes as normal (sending a uevent
    according to status)
    
    The advantage of the proposed system is that it is completely backward
    compatible with the current system both at the kernel and at the
    userland levels. The "first" parameter can also be set the same way,
    with the restriction that it must be set before the journal id is
    assigned.
    
    In addition, if mount becomes stuck waiting for a reply from
    gfs_controld which never arrives, then it is killable and will abort the
    mount gracefully.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b5d7363b22da..8fcbce48a128 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -460,6 +460,7 @@ enum {
 	SDF_NOBARRIERS		= 3,
 	SDF_NORECOVERY		= 4,
 	SDF_DEMOTE		= 5,
+	SDF_NOJOURNALID		= 6,
 };
 
 #define GFS2_FSNAME_LEN		256

commit 6ecd7c2dd9f5dd4f6e8f65c8027159f9c73b0e4c
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 20 22:09:02 2010 +0200

    gfs2: use workqueue instead of slow-work
    
    Workqueue can now handle high concurrency.  Convert gfs to use
    workqueue instead of slow-work.
    
    * Steven pointed out that recovery path might be run from allocation
      path and thus requires forward progress guarantee without memory
      allocation.  Create and use gfs_recovery_wq with rescuer.  Please
      note that forward progress wasn't guaranteed with slow-work.
    
    * Updated to use non-reentrant workqueue.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b5d7363b22da..dd8f2e63d15a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -12,7 +12,6 @@
 
 #include <linux/fs.h>
 #include <linux/workqueue.h>
-#include <linux/slow-work.h>
 #include <linux/dlm.h>
 #include <linux/buffer_head.h>
 
@@ -383,7 +382,7 @@ struct gfs2_journal_extent {
 struct gfs2_jdesc {
 	struct list_head jd_list;
 	struct list_head extent_list;
-	struct slow_work jd_work;
+	struct work_struct jd_work;
 	struct inode *jd_inode;
 	unsigned long jd_flags;
 #define JDF_RECOVERY 1

commit 913a71d250803130eac523e7a2b6439e31a0bc83
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu May 6 11:03:29 2010 +0100

    GFS2: Add some useful messages
    
    The following patch adds a message to indicate when barriers have been
    disabled due to a block device which doesn't support them. You could
    already tell this via the mount options in /proc/mounts, but all the
    other filesystems also log a message at the same time.
    
    Also, the same mechanisms are used to indicate when the lock
    demote interface has been used (only ever used for debugging)
    which is a request from our support team.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 08dd65745473..b5d7363b22da 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -459,6 +459,7 @@ enum {
 	SDF_SHUTDOWN		= 2,
 	SDF_NOBARRIERS		= 3,
 	SDF_NORECOVERY		= 4,
+	SDF_DEMOTE		= 5,
 };
 
 #define GFS2_FSNAME_LEN		256

commit 5e687eac1bd31baed110d239ef827d3ba666f311
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue May 4 14:29:16 2010 -0500

    GFS2: Various gfs2_logd improvements
    
    This patch contains various tweaks to how log flushes and active item writeback
    work. gfs2_logd is now managed by a waitqueue, and gfs2_log_reseve now waits
    for gfs2_logd to do the log flushing.  Multiple functions were rewritten to
    remove the need to call gfs2_log_lock(). Instead of using one test to see if
    gfs2_logd had work to do, there are now seperate tests to check if there
    are two many buffers in the incore log or if there are two many items on the
    active items list.
    
    This patch is a port of a patch Steve Whitehouse wrote about a year ago, with
    some minor changes.  Since gfs2_ail1_start always submits all the active items,
    it no longer needs to keep track of the first ai submitted, so this has been
    removed. In gfs2_log_reserve(), the order of the calls to
    prepare_to_wait_exclusive() and wake_up() when firing off the logd thread has
    been switched.  If it called wake_up first there was a small window for a race,
    where logd could run and return before gfs2_log_reserve was ready to get woken
    up. If gfs2_logd ran, but did not free up enough blocks, gfs2_log_reserve()
    would be left waiting for gfs2_logd to eventualy run because it timed out.
    Finally, gt_logd_secs, which controls how long to wait before gfs2_logd times
    out, and flushes the log, can now be set on mount with ar_commit.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3aac46f6853e..08dd65745473 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -439,9 +439,6 @@ struct gfs2_args {
 struct gfs2_tune {
 	spinlock_t gt_spin;
 
-	unsigned int gt_incore_log_blocks;
-	unsigned int gt_log_flush_secs;
-
 	unsigned int gt_logd_secs;
 
 	unsigned int gt_quota_simul_sync; /* Max quotavals to sync at once */
@@ -618,6 +615,7 @@ struct gfs2_sbd {
 	unsigned int sd_log_commited_databuf;
 	int sd_log_commited_revoke;
 
+	atomic_t sd_log_pinned;
 	unsigned int sd_log_num_buf;
 	unsigned int sd_log_num_revoke;
 	unsigned int sd_log_num_rg;
@@ -629,15 +627,17 @@ struct gfs2_sbd {
 	struct list_head sd_log_le_databuf;
 	struct list_head sd_log_le_ordered;
 
+	atomic_t sd_log_thresh1;
+	atomic_t sd_log_thresh2;
 	atomic_t sd_log_blks_free;
-	struct mutex sd_log_reserve_mutex;
+	wait_queue_head_t sd_log_waitq;
+	wait_queue_head_t sd_logd_waitq;
 
 	u64 sd_log_sequence;
 	unsigned int sd_log_head;
 	unsigned int sd_log_tail;
 	int sd_log_idle;
 
-	unsigned long sd_log_flush_time;
 	struct rw_semaphore sd_log_flush_lock;
 	atomic_t sd_log_in_flight;
 	wait_queue_head_t sd_log_flush_wait;

commit 2e95e3f668c85276ce699993596d3b52b0fcf4c5
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Wed Mar 10 18:10:19 2010 -0600

    GFS2: Allow the number of committed revokes to temporarily be negative
    
    GFS2 tracks the number of revokes and unrevokes that are part of committed
    transactions via sd_log_commited_revoke. It is possible for one process to add
    revokes during its transaction, while another process unrevokes them during its
    transaction. If the second process finishes its transaction first,
    sd_log_commited_revoke will be decremented by the number of unrevokes that the
    second process did, without first being incremented by the number of revokes
    the first process did. This is fine, since all started transactions must be
    completed before the journal can be flushed.  However, sd_log_commited_revoke
    is an unsigned integer, and log_refund() causes an assertion failure if it
    would go negative at the end of a transaction.  This patch makes
    sd_log_commited_revoke a signed integer and allows it to go negative.
    __gfs2_log_flush() still checks that it mataches the actual number of revokes.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b8025e51cabf..3aac46f6853e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -616,7 +616,7 @@ struct gfs2_sbd {
 	unsigned int sd_log_blks_reserved;
 	unsigned int sd_log_commited_buf;
 	unsigned int sd_log_commited_databuf;
-	unsigned int sd_log_commited_revoke;
+	int sd_log_commited_revoke;
 
 	unsigned int sd_log_num_buf;
 	unsigned int sd_log_num_revoke;

commit c1184f8ab7ea26681f3cab18284a870aad678b0f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Jan 8 16:14:29 2010 +0000

    GFS2: Remove loopy umount code
    
    As a consequence of the previous patch, we can now remove the
    loop which used to be required due to the circular dependency
    between the inodes and glocks. Instead we can just invalidate
    the inodes, and then clear up any glocks which are left.
    
    Also we no longer need the rwsem since there is no longer any
    danger of the inode invalidation calling back into the glock
    code (and from there back into the inode code).
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1de7e1b7ce83..b8025e51cabf 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -451,7 +451,6 @@ struct gfs2_tune {
 	unsigned int gt_quota_quantum; /* Secs between syncs to quota file */
 	unsigned int gt_new_files_jdata;
 	unsigned int gt_max_readahead; /* Max bytes to read-ahead from disk */
-	unsigned int gt_stall_secs; /* Detects trouble! */
 	unsigned int gt_complain_secs;
 	unsigned int gt_statfs_quantum;
 	unsigned int gt_statfs_slow;

commit 009d851837ab26cab18adda6169a813f70b0b21b
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Dec 8 12:12:13 2009 +0000

    GFS2: Metadata address space clean up
    
    Since the start of GFS2, an "extra" inode has been used to store
    the metadata belonging to each inode. The only reason for using
    this inode was to have an extra address space, the other fields
    were unused. This means that the memory usage was rather inefficient.
    
    The reason for keeping each inode's metadata in a separate address
    space is that when glocks are requested on remote nodes, we need to
    be able to efficiently locate the data and metadata which relating
    to that glock (inode) in order to sync or sync and invalidate it
    (depending on the remotely requested lock mode).
    
    This patch adds a new type of glock, which has in addition to
    its normal fields, has an address space. This applies to all
    inode and rgrp glocks (but to no other glock types which remain
    as before). As a result, we no longer need to have the second
    inode.
    
    This results in three major improvements:
     1. A saving of approx 25% of memory used in caching inodes
     2. A removal of the circular dependency between inodes and glocks
     3. No confusion between "normal" and "metadata" inodes in super.c
    
    Although the first of these is the more immediately apparent, the
    second is just as important as it now enables a number of clean
    ups at umount time. Those will be the subject of future patches.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index bc0ad158e6b4..1de7e1b7ce83 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -162,6 +162,8 @@ struct gfs2_glock_operations {
 	void (*go_callback) (struct gfs2_glock *gl);
 	const int go_type;
 	const unsigned long go_min_hold_time;
+	const unsigned long go_flags;
+#define GLOF_ASPACE 1
 };
 
 enum {
@@ -225,7 +227,6 @@ struct gfs2_glock {
 
 	struct gfs2_sbd *gl_sbd;
 
-	struct inode *gl_aspace;
 	struct list_head gl_ail_list;
 	atomic_t gl_ail_count;
 	struct delayed_work gl_work;
@@ -258,7 +259,6 @@ enum {
 	GIF_INVALID		= 0,
 	GIF_QD_LOCKED		= 1,
 	GIF_SW_PAGED		= 3,
-	GIF_USER                = 4, /* user inode, not metadata addr space */
 };
 
 

commit e402746a945ceb9d0486a8e3d5917c9228fa4404
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 25 11:20:19 2010 +0000

    GFS2: Wait for unlock completion on umount
    
    This patch adds a wait on umount between the point at which we
    dispose of all glocks and the point at which we unmount the
    lock protocol. This ensures that we've received all the replies
    to our unlock requests before we stop the locking.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Reported-by: Fabio M. Di Nitto <fdinitto@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4792200978c8..bc0ad158e6b4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -544,6 +544,8 @@ struct gfs2_sbd {
 	struct gfs2_holder sd_live_gh;
 	struct gfs2_glock *sd_rename_gl;
 	struct gfs2_glock *sd_trans_gl;
+	wait_queue_head_t sd_glock_wait;
+	atomic_t sd_glock_disposal;
 
 	/* Inode Stuff */
 

commit f25934c5f88655a8d5c3c40a540daed1f0e6dedc
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Oct 30 08:03:27 2009 +0100

    GFS2: add barrier/nobarrier mount options
    
    Currently gfs2 issues barrier unconditionally.  There are various reasons
    to disable them, be that just for testing or for stupid devices flushing
    large battert backed caches.  Add a nobarrier option that matches xfs and
    btrfs for this.  Also add a symmetric barrier option to turn it back on
    at remount time.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c239b0f969c8..4792200978c8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -429,6 +429,7 @@ struct gfs2_args {
 	unsigned int ar_meta:1;			/* mount metafs */
 	unsigned int ar_discard:1;		/* discard requests */
 	unsigned int ar_errors:2;               /* errors=withdraw | panic */
+	unsigned int ar_nobarrier:1;            /* do not send barriers */
 	int ar_commit;				/* Commit interval */
 	int ar_statfs_quantum;			/* The fast statfs interval */
 	int ar_quota_quantum;			/* The quota interval */

commit 3d3c10f2ce80d2a19e5e02023c2b7ab7086c36d5
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue Oct 20 02:39:44 2009 -0500

    GFS2: Improve statfs and quota usability
    
    GFS2 now has three new mount options, statfs_quantum, quota_quantum and
    statfs_percent.  statfs_quantum and quota_quantum simply allow you to
    set the tunables of the same name.  Setting setting statfs_quantum to 0
    will also turn on the statfs_slow tunable.  statfs_percent accepts an
    integer between 0 and 100.  Numbers between 1 and 100 will cause GFS2 to
    do any early sync when the local number of blocks free changes by at
    least statfs_percent from the totoal number of blocks free.  Setting
    statfs_percent to 0 disables this.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6edb423f90b3..c239b0f969c8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -430,6 +430,9 @@ struct gfs2_args {
 	unsigned int ar_discard:1;		/* discard requests */
 	unsigned int ar_errors:2;               /* errors=withdraw | panic */
 	int ar_commit;				/* Commit interval */
+	int ar_statfs_quantum;			/* The fast statfs interval */
+	int ar_quota_quantum;			/* The quota interval */
+	int ar_statfs_percent;			/* The % change to force sync */
 };
 
 struct gfs2_tune {
@@ -558,6 +561,7 @@ struct gfs2_sbd {
 	spinlock_t sd_statfs_spin;
 	struct gfs2_statfs_change_host sd_statfs_master;
 	struct gfs2_statfs_change_host sd_statfs_local;
+	int sd_statfs_force_sync;
 
 	/* Resource group stuff */
 

commit 2b88f7c535a8125213def012a67c1b0a667ceb2e
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Sep 9 15:59:35 2009 +0100

    GFS2: Remove unused sysfs file
    
    The /sys/fs/gfs2/<fsname>/lock_module/id file has been unused for
    some time now, so we can remove it. We still accept the mount option
    though, as userspace still sends that.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 52436abc3b4d..6edb423f90b3 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -496,7 +496,6 @@ struct gfs2_sb_host {
  */
 
 struct lm_lockstruct {
-	u32 ls_id;
 	unsigned int ls_jid;
 	unsigned int ls_first;
 	unsigned int ls_first_done;

commit 8d8291ae93ecb4a246e87e452d55cca412373300
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Aug 27 15:51:07 2009 +0100

    GFS2: Remove no_formal_ino generating code
    
    The inum structure used throughout GFS2 has two fields. One
    no_addr is the disk block number of the inode in question and
    is used everywhere as the inode number. The other, no_formal_ino,
    is used only as the generation number for NFS.
    
    Historically the no_formal_ino field was set using a complicated
    system of one global and one per-node file containing inode numbers
    in order to ensure that each no_formal_ino was unique. Also this
    code made no provision for what would happen when eventually the
    (64 bit) numbers ran out. Now I know that is pretty unlikely to
    happen given the large space of numbers, but it is possible
    nevertheless.
    
    The only guarantee required for no_formal_ino is that, for any
    single inode, the same number doesn't get reused too quickly.
    
    We already have a generation number which is kept in the inode
    and initialised from a counter in the resource group (almost
    no overhead, since we have to touch the resource group anyway
    in order to allocate an inode in the first place). Aside from
    ensuring that we never use the value 0 in the no_formal_ino
    field, we can use that counter directly.
    
    As a result of that change, we lose about 200 lines of code and
    also gain about 10 creates/sec on the postmark benchmark (on
    my test machine).
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1d11e6e0373e..52436abc3b4d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -548,18 +548,12 @@ struct gfs2_sbd {
 	struct dentry *sd_root_dir;
 
 	struct inode *sd_jindex;
-	struct inode *sd_inum_inode;
 	struct inode *sd_statfs_inode;
-	struct inode *sd_ir_inode;
 	struct inode *sd_sc_inode;
 	struct inode *sd_qc_inode;
 	struct inode *sd_rindex;
 	struct inode *sd_quota_inode;
 
-	/* Inum stuff */
-
-	struct mutex sd_inum_mutex;
-
 	/* StatFS stuff */
 
 	spinlock_t sd_statfs_spin;
@@ -587,7 +581,6 @@ struct gfs2_sbd {
 	struct gfs2_holder sd_journal_gh;
 	struct gfs2_holder sd_jinode_gh;
 
-	struct gfs2_holder sd_ir_gh;
 	struct gfs2_holder sd_sc_gh;
 	struct gfs2_holder sd_qc_gh;
 

commit d34843d0c4a20872f3f3bfb510328bd043b939ff
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Aug 24 10:44:18 2009 +0100

    GFS2: Add "-o errors=panic|withdraw" mount options
    
    This patch adds "-o errors=panic" and "-o errors=withdraw" to the
    gfs2 mount options.  The "errors=withdraw" option is today's
    current behaviour, meaning to withdraw from the file system if a
    non-serious gfs2 error occurs.  The new "errors=panic" option
    tells gfs2 to force a kernel panic if a non-serious gfs2 file
    system error occurs.  This may be useful, for example, where
    fabric-level fencing is used that has no way to reboot (such as
    fence_scsi).
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 61801ada36f0..1d11e6e0373e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -406,6 +406,12 @@ struct gfs2_statfs_change_host {
 #define GFS2_DATA_WRITEBACK	1
 #define GFS2_DATA_ORDERED	2
 
+#define GFS2_ERRORS_DEFAULT     GFS2_ERRORS_WITHDRAW
+#define GFS2_ERRORS_WITHDRAW    0
+#define GFS2_ERRORS_CONTINUE    1 /* place holder for future feature */
+#define GFS2_ERRORS_RO          2 /* place holder for future feature */
+#define GFS2_ERRORS_PANIC       3
+
 struct gfs2_args {
 	char ar_lockproto[GFS2_LOCKNAME_LEN];	/* Name of the Lock Protocol */
 	char ar_locktable[GFS2_LOCKNAME_LEN];	/* Name of the Lock Table */
@@ -422,6 +428,7 @@ struct gfs2_args {
 	unsigned int ar_data:2;			/* ordered/writeback */
 	unsigned int ar_meta:1;			/* mount metafs */
 	unsigned int ar_discard:1;		/* discard requests */
+	unsigned int ar_errors:2;               /* errors=withdraw | panic */
 	int ar_commit;				/* Commit interval */
 };
 

commit b94a170e96dc416828af9d350ae2e34b70ae7347
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Thu Jul 23 18:52:34 2009 -0500

    GFS2: remove dcache entries for remote deleted inodes
    
    When a file is deleted from a gfs2 filesystem on one node, a dcache
    entry for it may still exist on other nodes in the cluster. If this
    happens, gfs2 will be unable to free this file on disk. Because of this,
    it's possible to have a gfs2 filesystem with no files on it and no free
    space. With this patch, when a node receives a callback notifying it
    that the file is being deleted on another node, it schedules a new
    workqueue thread to remove the file's dcache entry.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 225347fbff3c..61801ada36f0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -159,6 +159,7 @@ struct gfs2_glock_operations {
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
 	int (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
+	void (*go_callback) (struct gfs2_glock *gl);
 	const int go_type;
 	const unsigned long go_min_hold_time;
 };
@@ -228,6 +229,7 @@ struct gfs2_glock {
 	struct list_head gl_ail_list;
 	atomic_t gl_ail_count;
 	struct delayed_work gl_work;
+	struct work_struct gl_delete;
 };
 
 #define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */

commit 1ce97e564b628bee30b8dbb64e5e653a484308f6
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu May 21 15:18:19 2009 +0100

    GFS2: Be more aggressive in reclaiming unlinked inodes
    
    This patch increases the frequency with which gfs2 looks
    for unlinked, but still allocated inodes. Its the equivalent
    operation to ext3's orphan list, but done with bitmaps in
    the resource groups.
    
    This also fixes a bug where a field in the rgrp was too small.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index dd87379b61e6..225347fbff3c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -94,7 +94,7 @@ struct gfs2_rgrpd {
 	struct gfs2_sbd *rd_sbd;
 	unsigned int rd_bh_count;
 	u32 rd_last_alloc;
-	unsigned char rd_flags;
+	u32 rd_flags;
 #define GFS2_RDF_CHECK		0x10000000 /* check for unlinked inodes */
 #define GFS2_RDF_UPTODATE	0x20000000 /* rg is up to date */
 #define GFS2_RDF_ERROR		0x40000000 /* error in rg */

commit 60a0b8f93664621a07b93273fc8ebc29590c62f5
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu May 21 12:23:12 2009 +0100

    GFS2: Add a rgrp bitmap full flag
    
    During block allocation, it is useful to know if sections of disk
    are full on a finer grained basis than a single resource group.
    This can make a performance difference when resource groups have
    larger numbers of bitmap blocks, since we no longer have to search
    them all block by block in each individual bitmap.
    
    The full flag is set on a per-bitmap basis when it has been
    searched and found to have no free space. It is then skipped in
    subsequent searches until the flag is reset. The resetting
    occurs if we have to drop the glock on the resource group for any
    reason, or if we deallocate some blocks within that resource
    group and thus free up some space.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index de50d86fec12..dd87379b61e6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -64,9 +64,12 @@ struct gfs2_log_element {
 	const struct gfs2_log_operations *le_ops;
 };
 
+#define GBF_FULL 1
+
 struct gfs2_bitmap {
 	struct buffer_head *bi_bh;
 	char *bi_clone;
+	unsigned long bi_flags;
 	u32 bi_offset;
 	u32 bi_start;
 	u32 bi_len;

commit 09010978345e8883003bf411bb99753710eb5a3a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed May 20 10:48:47 2009 +0100

    GFS2: Improve resource group error handling
    
    This patch improves the error handling in the case where we
    discover that the summary information in the resource group
    doesn't match the bitmap information while in the process of
    allocating blocks. Originally this resulted in a kernel bug,
    but this patch changes that so that we return -EIO and print
    some messages explaining what went wrong, and how to fix it.
    
    We also remember locally not to try and allocate from the
    same rgrp again, so that a subsequent allocation in a
    different rgrp should succeed.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 0060e9564bb9..de50d86fec12 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -92,9 +92,10 @@ struct gfs2_rgrpd {
 	unsigned int rd_bh_count;
 	u32 rd_last_alloc;
 	unsigned char rd_flags;
-#define GFS2_RDF_CHECK        0x01      /* Need to check for unlinked inodes */
-#define GFS2_RDF_NOALLOC      0x02      /* rg prohibits allocation */
-#define GFS2_RDF_UPTODATE     0x04      /* rg is up to date */
+#define GFS2_RDF_CHECK		0x10000000 /* check for unlinked inodes */
+#define GFS2_RDF_UPTODATE	0x20000000 /* rg is up to date */
+#define GFS2_RDF_ERROR		0x40000000 /* error in rg */
+#define GFS2_RDF_MASK		0xf0000000 /* mask for internal flags */
 };
 
 enum gfs2_state_bits {

commit fe64d517df0970a68417184a12fcd4ba0589cc28
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue May 19 10:01:18 2009 +0100

    GFS2: Umount recovery race fix
    
    This patch fixes a race condition where we can receive recovery
    requests part way through processing a umount. This was causing
    problems since the recovery thread had already gone away.
    
    Looking in more detail at the recovery code, it was really trying
    to implement a slight variation on a work queue, and that happens to
    align nicely with the recently introduced slow-work subsystem. As a
    result I've updated the code to use slow-work, rather than its own home
    grown variety of work queue.
    
    When using the wait_on_bit() function, I noticed that the wait function
    that was supplied as an argument was appearing in the WCHAN field, so
    I've updated the function names in order to produce more meaningful
    output.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 65f438e9537a..0060e9564bb9 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -12,6 +12,7 @@
 
 #include <linux/fs.h>
 #include <linux/workqueue.h>
+#include <linux/slow-work.h>
 #include <linux/dlm.h>
 #include <linux/buffer_head.h>
 
@@ -376,11 +377,11 @@ struct gfs2_journal_extent {
 struct gfs2_jdesc {
 	struct list_head jd_list;
 	struct list_head extent_list;
-
+	struct slow_work jd_work;
 	struct inode *jd_inode;
+	unsigned long jd_flags;
+#define JDF_RECOVERY 1
 	unsigned int jd_jid;
-	int jd_dirty;
-
 	unsigned int jd_blocks;
 };
 
@@ -390,9 +391,6 @@ struct gfs2_statfs_change_host {
 	s64 sc_dinodes;
 };
 
-#define GFS2_GLOCKD_DEFAULT	1
-#define GFS2_GLOCKD_MAX		16
-
 #define GFS2_QUOTA_DEFAULT	GFS2_QUOTA_OFF
 #define GFS2_QUOTA_OFF		0
 #define GFS2_QUOTA_ACCOUNT	1
@@ -427,7 +425,6 @@ struct gfs2_tune {
 	unsigned int gt_incore_log_blocks;
 	unsigned int gt_log_flush_secs;
 
-	unsigned int gt_recoverd_secs;
 	unsigned int gt_logd_secs;
 
 	unsigned int gt_quota_simul_sync; /* Max quotavals to sync at once */
@@ -448,6 +445,7 @@ enum {
 	SDF_JOURNAL_LIVE	= 1,
 	SDF_SHUTDOWN		= 2,
 	SDF_NOBARRIERS		= 3,
+	SDF_NORECOVERY		= 4,
 };
 
 #define GFS2_FSNAME_LEN		256
@@ -494,7 +492,6 @@ struct lm_lockstruct {
 	unsigned long ls_flags;
 	dlm_lockspace_t *ls_dlm;
 
-	int ls_recover_jid;
 	int ls_recover_jid_done;
 	int ls_recover_jid_status;
 };
@@ -583,7 +580,6 @@ struct gfs2_sbd {
 
 	/* Daemon stuff */
 
-	struct task_struct *sd_recoverd_process;
 	struct task_struct *sd_logd_process;
 	struct task_struct *sd_quotad_process;
 

commit 48c2b613616235d7c97fda5982f50100a6c79166
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed May 13 14:49:48 2009 +0100

    GFS2: Add commit= mount option
    
    It has always been possible to adjust the gfs2 log commit
    interval, but only from the sysfs interface. This adds a
    mount option, commit=<nn>, which will be familar to ext3
    users.
    
    The sysfs interface continues to be available as well, although
    this might be removed in the future.
    
    Also this patch cleans up some duplicated structures in the GFS2
    sysfs code.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 399d1b978049..65f438e9537a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -418,6 +418,7 @@ struct gfs2_args {
 	unsigned int ar_data:2;			/* ordered/writeback */
 	unsigned int ar_meta:1;			/* mount metafs */
 	unsigned int ar_discard:1;		/* discard requests */
+	int ar_commit;				/* Commit interval */
 };
 
 struct gfs2_tune {

commit 02ffad08e838997fad3de05c85560a57e5fd92de
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Fri Mar 6 10:03:20 2009 -0600

    GFS2: Fix locking bug in failed shared to exclusive conversion
    
    After calling out to the dlm, GFS2 sets the new state of a glock to
    gl_target in gdlm_ast().  However, gl_target is not always the lock
    state that was requested. If a conversion from shared to exclusive
    fails, finish_xmote() will call do_xmote() with LM_ST_UNLOCKED, instead
    of gl->gl_target, so that it can reacquire the lock in exlusive the next
    time around.  In this case, setting the lock to gl_target in gdlm_ast()
    will make GFS2 think that it has the glock in exclusive mode, when
    really, it doesn't have the glock locked at all.  This patch adds a new
    field to the gfs2_glock structure, gl_req, to track the mode that was
    requested.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 980a0864ca6c..399d1b978049 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -203,6 +203,7 @@ struct gfs2_glock {
 	unsigned int gl_target;
 	unsigned int gl_reply;
 	unsigned int gl_hash;
+	unsigned int gl_req;
 	unsigned int gl_demote_state; /* state requested by remote node */
 	unsigned long gl_demote_time; /* time of first demote request */
 	struct list_head gl_holders;

commit 02e3cc70ecbd4352ae4d26459929f43ab1547251
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Feb 10 13:48:30 2009 +0000

    GFS2: Expose UUID via sysfs/uevent
    
    Since we have a UUID, we ought to expose it to the user via sysfs
    and uevents. We already have the fs name in both of these places
    (a combination of the lock proto and lock table name) so if we add
    the UUID as well, we have a full set.
    
    For older filesystems (i.e. those created before mkfs.gfs2 was writing
    UUIDs by default) the sysfs file will appear zero length, and no UUID
    env var will be added to the uevents.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3f29bd224ba1..980a0864ca6c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -470,6 +470,7 @@ struct gfs2_sb_host {
 
 	char sb_lockproto[GFS2_LOCKNAME_LEN];
 	char sb_locktable[GFS2_LOCKNAME_LEN];
+	u8 sb_uuid[16];
 };
 
 /*

commit f15ab5619d8068a321094f4705147764d689e88e
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Feb 9 09:25:01 2009 +0000

    GFS2: Support generation of discard requests
    
    This patch allows GFS2 to generate discard requests for blocks which are
    no longer useful to the filesystem (i.e. those which have been freed as
    the result of an unlink operation). The requests are generated at the
    time which those blocks become available for reuse in the filesystem.
    
    In order to use this new feature, you have to specify the "discard"
    mount option. The code coalesces adjacent blocks into a single extent
    when generating the discard requests, thus generating the minimum
    number.
    
    If an error occurs when the request has been sent to the block device,
    then it will print a message and turn off the requests for that
    filesystem. If the problem is temporary, then you can use remount to
    turn the option back on again. There is also a nodiscard mount option
    so that you can use remount to turn discard requests off, if required.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8fe0675120ac..3f29bd224ba1 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -416,7 +416,7 @@ struct gfs2_args {
 	unsigned int ar_suiddir:1;		/* suiddir support */
 	unsigned int ar_data:2;			/* ordered/writeback */
 	unsigned int ar_meta:1;			/* mount metafs */
-	unsigned int ar_num_glockd;		/* Number of glockd threads */
+	unsigned int ar_discard:1;		/* discard requests */
 };
 
 struct gfs2_tune {

commit ac2425e7d319dec0523e52ee120a158ce6668cbd
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jan 13 09:53:43 2009 +0000

    GFS2: Remove unused field from glock
    
    The time stamp field is unused in the glock now that we are
    using a shrinker, so that we can remove it and save sizeof(unsigned long)
    bytes in each glock.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 0af7c24de6a1..8fe0675120ac 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -211,7 +211,6 @@ struct gfs2_glock {
 	char gl_strname[GDLM_STRNAME_BYTES];
 	struct dlm_lksb gl_lksb;
 	char gl_lvb[32];
-	unsigned long gl_stamp;
 	unsigned long gl_tchange;
 	void *gl_object;
 

commit f057f6cdf64175db1151b1f5d110e29904f119a1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 12 10:43:39 2009 +0000

    GFS2: Merge lock_dlm module into GFS2
    
    This is the big patch that I've been working on for some time
    now. There are many reasons for wanting to make this change
    such as:
     o Reducing overhead by eliminating duplicated fields between structures
     o Simplifcation of the code (reduces the code size by a fair bit)
     o The locking interface is now the DLM interface itself as proposed
       some time ago.
     o Fewer lookups of glocks when processing replies from the DLM
     o Fewer memory allocations/deallocations for each glock
     o Scope to do further optimisations in the future (but this patch is
       more than big enough for now!)
    
    Please note that (a) this patch relates to the lock_dlm module and
    not the DLM itself, that is still a separate module; and (b) that
    we retain the ability to build GFS2 as a standalone single node
    filesystem with out requiring the DLM.
    
    This patch needs a lot of testing, hence my keeping it I restarted
    my -git tree after the last merge window. That way, this has the maximum
    exposure before its merged. This is (modulo a few minor bug fixes) the
    same patch that I've been posting on and off the the last three months
    and its passed a number of different tests so far.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a0117d6eb145..0af7c24de6a1 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -12,6 +12,8 @@
 
 #include <linux/fs.h>
 #include <linux/workqueue.h>
+#include <linux/dlm.h>
+#include <linux/buffer_head.h>
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
@@ -26,6 +28,7 @@ struct gfs2_trans;
 struct gfs2_ail;
 struct gfs2_jdesc;
 struct gfs2_sbd;
+struct lm_lockops;
 
 typedef void (*gfs2_glop_bh_t) (struct gfs2_glock *gl, unsigned int ret);
 
@@ -121,6 +124,28 @@ struct gfs2_bufdata {
 	struct list_head bd_ail_gl_list;
 };
 
+/*
+ * Internally, we prefix things with gdlm_ and GDLM_ (for gfs-dlm) since a
+ * prefix of lock_dlm_ gets awkward.
+ */
+
+#define GDLM_STRNAME_BYTES	25
+#define GDLM_LVB_SIZE		32
+
+enum {
+	DFL_BLOCK_LOCKS		= 0,
+};
+
+struct lm_lockname {
+	u64 ln_number;
+	unsigned int ln_type;
+};
+
+#define lm_name_equal(name1, name2) \
+        (((name1)->ln_number == (name2)->ln_number) && \
+         ((name1)->ln_type == (name2)->ln_type))
+
+
 struct gfs2_glock_operations {
 	void (*go_xmote_th) (struct gfs2_glock *gl);
 	int (*go_xmote_bh) (struct gfs2_glock *gl, struct gfs2_holder *gh);
@@ -162,6 +187,8 @@ enum {
 	GLF_LFLUSH			= 7,
 	GLF_INVALIDATE_IN_PROGRESS	= 8,
 	GLF_REPLY_PENDING		= 9,
+	GLF_INITIAL			= 10,
+	GLF_FROZEN			= 11,
 };
 
 struct gfs2_glock {
@@ -181,10 +208,9 @@ struct gfs2_glock {
 	struct list_head gl_holders;
 
 	const struct gfs2_glock_operations *gl_ops;
-	void *gl_lock;
-	char *gl_lvb;
-	atomic_t gl_lvb_count;
-
+	char gl_strname[GDLM_STRNAME_BYTES];
+	struct dlm_lksb gl_lksb;
+	char gl_lvb[32];
 	unsigned long gl_stamp;
 	unsigned long gl_tchange;
 	void *gl_object;
@@ -447,6 +473,30 @@ struct gfs2_sb_host {
 	char sb_locktable[GFS2_LOCKNAME_LEN];
 };
 
+/*
+ * lm_mount() return values
+ *
+ * ls_jid - the journal ID this node should use
+ * ls_first - this node is the first to mount the file system
+ * ls_lockspace - lock module's context for this file system
+ * ls_ops - lock module's functions
+ */
+
+struct lm_lockstruct {
+	u32 ls_id;
+	unsigned int ls_jid;
+	unsigned int ls_first;
+	unsigned int ls_first_done;
+	unsigned int ls_nodir;
+	const struct lm_lockops *ls_ops;
+	unsigned long ls_flags;
+	dlm_lockspace_t *ls_dlm;
+
+	int ls_recover_jid;
+	int ls_recover_jid_done;
+	int ls_recover_jid_status;
+};
+
 struct gfs2_sbd {
 	struct super_block *sd_vfs;
 	struct kobject sd_kobj;
@@ -520,7 +570,6 @@ struct gfs2_sbd {
 	spinlock_t sd_jindex_spin;
 	struct mutex sd_jindex_mutex;
 	unsigned int sd_journals;
-	unsigned long sd_jindex_refresh_time;
 
 	struct gfs2_jdesc *sd_jdesc;
 	struct gfs2_holder sd_journal_gh;

commit 22077f57dec8fcbeb1112b35313961c0902ff038
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jan 8 14:28:42 2009 +0000

    GFS2: Remove "double" locking in quota
    
    We only really need a single spin lock for the quota data, so
    lets just use the lru lock for now.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Abhijith Das <adas@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 592aa5040d29..a0117d6eb145 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -540,7 +540,6 @@ struct gfs2_sbd {
 
 	struct list_head sd_quota_list;
 	atomic_t sd_quota_count;
-	spinlock_t sd_quota_spin;
 	struct mutex sd_quota_mutex;
 	wait_queue_head_t sd_quota_wait;
 	struct list_head sd_trunc_list;

commit 0a7ab79c5b5a16035e09b466c9013c8afc3b4bff
Author: Abhijith Das <adas@redhat.com>
Date:   Wed Jan 7 16:03:37 2009 -0600

    GFS2: change gfs2_quota_scan into a shrinker
    
    Deallocation of gfs2_quota_data objects now happens on-demand through a
    shrinker instead of routinely deallocating through the quotad daemon.
    
    Signed-off-by: Abhijith Das <adas@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 608849d00021..592aa5040d29 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -283,7 +283,9 @@ enum {
 
 struct gfs2_quota_data {
 	struct list_head qd_list;
-	unsigned int qd_count;
+	struct list_head qd_reclaim;
+
+	atomic_t qd_count;
 
 	u32 qd_id;
 	unsigned long qd_flags;		/* QDF_... */
@@ -303,7 +305,6 @@ struct gfs2_quota_data {
 
 	u64 qd_sync_gen;
 	unsigned long qd_last_warn;
-	unsigned long qd_last_touched;
 };
 
 struct gfs2_trans {
@@ -406,7 +407,6 @@ struct gfs2_tune {
 	unsigned int gt_quota_warn_period; /* Secs between quota warn msgs */
 	unsigned int gt_quota_scale_num; /* Numerator */
 	unsigned int gt_quota_scale_den; /* Denominator */
-	unsigned int gt_quota_cache_secs;
 	unsigned int gt_quota_quantum; /* Secs between syncs to quota file */
 	unsigned int gt_new_files_jdata;
 	unsigned int gt_max_readahead; /* Max bytes to read-ahead from disk */

commit 97cc1025b1a91c52e84f12478dcf0f853abc6564
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Nov 20 13:39:47 2008 +0000

    GFS2: Kill two daemons with one patch
    
    This patch removes the two daemons, gfs2_scand and gfs2_glockd
    and replaces them with a shrinker which is called from the VM.
    
    The net result is that GFS2 responds better when there is memory
    pressure, since it shrinks the glock cache at the same rate
    as the VFS shrinks the dcache and icache. There are no longer
    any time based criteria for shrinking glocks, they are kept
    until such time as the VM asks for more memory and then we
    demote just as many glocks as required.
    
    There are potential future changes to this code, including the
    possibility of sorting the glocks which are to be written back
    into inode number order, to get a better I/O ordering. It would
    be very useful to have an elevator based workqueue implementation
    for this, as that would automatically deal with the read I/O cases
    at the same time.
    
    This patch is my answer to Andrew Morton's remark, made during
    the initial review of GFS2, asking why GFS2 needs so many kernel
    threads, the answer being that it doesn't :-) This patch is a
    net loss of about 200 lines of code.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index dd7d0f8f3575..608849d00021 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -125,7 +125,7 @@ struct gfs2_glock_operations {
 	void (*go_xmote_th) (struct gfs2_glock *gl);
 	int (*go_xmote_bh) (struct gfs2_glock *gl, struct gfs2_holder *gh);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
-	int (*go_demote_ok) (struct gfs2_glock *gl);
+	int (*go_demote_ok) (const struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
 	int (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
@@ -155,7 +155,6 @@ struct gfs2_holder {
 
 enum {
 	GLF_LOCK			= 1,
-	GLF_STICKY			= 2,
 	GLF_DEMOTE			= 3,
 	GLF_PENDING_DEMOTE		= 4,
 	GLF_DEMOTE_IN_PROGRESS		= 5,
@@ -190,7 +189,7 @@ struct gfs2_glock {
 	unsigned long gl_tchange;
 	void *gl_object;
 
-	struct list_head gl_reclaim;
+	struct list_head gl_lru;
 
 	struct gfs2_sbd *gl_sbd;
 
@@ -397,7 +396,6 @@ struct gfs2_args {
 struct gfs2_tune {
 	spinlock_t gt_spin;
 
-	unsigned int gt_demote_secs; /* Cache retention for unheld glock */
 	unsigned int gt_incore_log_blocks;
 	unsigned int gt_log_flush_secs;
 
@@ -478,10 +476,6 @@ struct gfs2_sbd {
 	/* Lock Stuff */
 
 	struct lm_lockstruct sd_lockstruct;
-	struct list_head sd_reclaim_list;
-	spinlock_t sd_reclaim_lock;
-	wait_queue_head_t sd_reclaim_wq;
-	atomic_t sd_reclaim_count;
 	struct gfs2_holder sd_live_gh;
 	struct gfs2_glock *sd_rename_gl;
 	struct gfs2_glock *sd_trans_gl;
@@ -541,8 +535,6 @@ struct gfs2_sbd {
 	struct task_struct *sd_recoverd_process;
 	struct task_struct *sd_logd_process;
 	struct task_struct *sd_quotad_process;
-	struct task_struct *sd_glockd_process[GFS2_GLOCKD_MAX];
-	unsigned int sd_glockd_num;
 
 	/* Quota stuff */
 
@@ -615,10 +607,6 @@ struct gfs2_sbd {
 	struct mutex sd_freeze_lock;
 	unsigned int sd_freeze_count;
 
-	/* Counters */
-
-	atomic_t sd_reclaimed;
-
 	char sd_fsname[GFS2_FSNAME_LEN];
 	char sd_table_name[GFS2_FSNAME_LEN];
 	char sd_proto_name[GFS2_FSNAME_LEN];

commit 813e0c46c9e2a0c6f0b6e774faac82afd7a2e812
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 18 13:38:48 2008 +0000

    GFS2: Fix "truncate in progress" hang
    
    Following on from the recent clean up of gfs2_quotad, this patch moves
    the processing of "truncate in progress" inodes from the glock workqueue
    into gfs2_quotad. This fixes a hang due to the "truncate in progress"
    processing requiring glocks in order to complete.
    
    It might seem odd to use gfs2_quotad for this particular item, but
    we have to use a pre-existing thread since creating a thread implies
    a GFP_KERNEL memory allocation which is not allowed from the glock
    workqueue context. Of the existing threads, gfs2_logd and gfs2_recoverd
    may deadlock if used for this operation. gfs2_scand and gfs2_glockd are
    both scheduled for removal at some (hopefully not too distant) future
    point. That leaves only gfs2_quotad whose workload is generally fairly
    light and is easily adapted for this extra task.
    
    Also, as a result of this change, it opens the way for a future patch to
    make the reading of the inode's information asynchronous with respect to
    the glock workqueue, which is another improvement that has been on the list
    for some time now.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index cfebc1793574..dd7d0f8f3575 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -244,6 +244,7 @@ struct gfs2_inode {
 	struct gfs2_alloc *i_alloc;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
+	struct list_head i_trunc_list;
 	u32 i_entries;
 	u32 i_diskflags;
 	u8 i_height;
@@ -550,6 +551,8 @@ struct gfs2_sbd {
 	spinlock_t sd_quota_spin;
 	struct mutex sd_quota_mutex;
 	wait_queue_head_t sd_quota_wait;
+	struct list_head sd_trunc_list;
+	spinlock_t sd_trunc_lock;
 
 	unsigned int sd_quota_slots;
 	unsigned int sd_quota_chunks;

commit 37b2c8377c98acb60cf4d0126e385ef2153bded9
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Nov 17 14:25:37 2008 +0000

    GFS2: Clean up & move gfs2_quotad
    
    This patch is a clean up of gfs2_quotad prior to giving it an
    extra job to do in addition to the current portfolio of updating
    the quota and statfs information from time to time.
    
    As a result it has been moved into quota.c allowing one of the
    functions it calls to be made static. Also the clean up allows
    the two existing functions to have separate timeouts and also
    to coexist with its future role of dealing with the "truncate in
    progress" inode flag.
    
    The (pointless) setting of gfs2_quotad_secs is removed since we
    arrange to only wake up quotad when one of the two timers expires.
    
    In addition the struct gfs2_quota_data is moved into a slab cache,
    mainly for easier debugging. It should also be possible to use
    a shrinker in the future, rather than the current scheme of scanning
    the quota data entries from time to time.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9e3b613d0bac..cfebc1793574 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -402,7 +402,6 @@ struct gfs2_tune {
 
 	unsigned int gt_recoverd_secs;
 	unsigned int gt_logd_secs;
-	unsigned int gt_quotad_secs;
 
 	unsigned int gt_quota_simul_sync; /* Max quotavals to sync at once */
 	unsigned int gt_quota_warn_period; /* Secs between quota warn msgs */
@@ -509,7 +508,6 @@ struct gfs2_sbd {
 	spinlock_t sd_statfs_spin;
 	struct gfs2_statfs_change_host sd_statfs_master;
 	struct gfs2_statfs_change_host sd_statfs_local;
-	unsigned long sd_statfs_sync_time;
 
 	/* Resource group stuff */
 
@@ -551,13 +549,13 @@ struct gfs2_sbd {
 	atomic_t sd_quota_count;
 	spinlock_t sd_quota_spin;
 	struct mutex sd_quota_mutex;
+	wait_queue_head_t sd_quota_wait;
 
 	unsigned int sd_quota_slots;
 	unsigned int sd_quota_chunks;
 	unsigned char **sd_quota_bitmap;
 
 	u64 sd_quota_sync_gen;
-	unsigned long sd_quota_sync_time;
 
 	/* Log stuff */
 

commit 73f749483ed18f3b5759909cc4187b1741f54b10
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 4 10:32:57 2008 +0000

    GFS2: Banish struct gfs2_rgrpd_host
    
    This patch moves the final field so that we can get rid
    of struct gfs2_rgrpd_host, as promised some time ago. Also
    by rearranging the fields slightly, we are able to reduce
    the size of the gfs2_rgrpd structure at the same time.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index f8d977362515..9e3b613d0bac 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -68,10 +68,6 @@ struct gfs2_bitmap {
 	u32 bi_len;
 };
 
-struct gfs2_rgrp_host {
-	u32 rg_dinodes;
-};
-
 struct gfs2_rgrpd {
 	struct list_head rd_list;	/* Link with superblock */
 	struct list_head rd_list_mru;
@@ -82,15 +78,15 @@ struct gfs2_rgrpd {
 	u32 rd_data;			/* num of data blocks in rgrp */
 	u32 rd_bitbytes;		/* number of bytes in data bitmaps */
 	u32 rd_free;
-	struct gfs2_rgrp_host rd_rg;
+	u32 rd_free_clone;
+	u32 rd_dinodes;
 	u64 rd_igeneration;
 	struct gfs2_bitmap *rd_bits;
-	unsigned int rd_bh_count;
 	struct mutex rd_mutex;
-	u32 rd_free_clone;
 	struct gfs2_log_element rd_le;
-	u32 rd_last_alloc;
 	struct gfs2_sbd *rd_sbd;
+	unsigned int rd_bh_count;
+	u32 rd_last_alloc;
 	unsigned char rd_flags;
 #define GFS2_RDF_CHECK        0x01      /* Need to check for unlinked inodes */
 #define GFS2_RDF_NOALLOC      0x02      /* rg prohibits allocation */

commit cfc8b54922db7b647b6d88914dc7ef8c63b6671d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 4 10:25:13 2008 +0000

    GFS2: Move rg_free from gfs2_rgrpd_host to gfs2_rgrpd
    
    The second of three fields which need to move, in order
    to remove the struct gfs2_rgrpd_host.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 869ac83297e6..f8d977362515 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -69,7 +69,6 @@ struct gfs2_bitmap {
 };
 
 struct gfs2_rgrp_host {
-	u32 rg_free;
 	u32 rg_dinodes;
 };
 
@@ -82,6 +81,7 @@ struct gfs2_rgrpd {
 	u32 rd_length;			/* length of rgrp header in fs blocks */
 	u32 rd_data;			/* num of data blocks in rgrp */
 	u32 rd_bitbytes;		/* number of bytes in data bitmaps */
+	u32 rd_free;
 	struct gfs2_rgrp_host rd_rg;
 	u64 rd_igeneration;
 	struct gfs2_bitmap *rd_bits;

commit d8b71f7381769177998acb2f59ddc73465a60fe0
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 4 10:19:03 2008 +0000

    GFS2: Move rg_igeneration into struct gfs2_rgrpd
    
    This moves one of the fields of struct gfs2_rgrpd_host into
    the struct gfs2_rgrpd with the eventual aim of removing
    the struct rgrpd_host completely.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 6f67e753f883..869ac83297e6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -71,7 +71,6 @@ struct gfs2_bitmap {
 struct gfs2_rgrp_host {
 	u32 rg_free;
 	u32 rg_dinodes;
-	u64 rg_igeneration;
 };
 
 struct gfs2_rgrpd {
@@ -84,6 +83,7 @@ struct gfs2_rgrpd {
 	u32 rd_data;			/* num of data blocks in rgrp */
 	u32 rd_bitbytes;		/* number of bytes in data bitmaps */
 	struct gfs2_rgrp_host rd_rg;
+	u64 rd_igeneration;
 	struct gfs2_bitmap *rd_bits;
 	unsigned int rd_bh_count;
 	struct mutex rd_mutex;

commit 383f01fbf4a701b73f5e35ea805ed1700b4b4db9
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 4 10:05:22 2008 +0000

    GFS2: Banish struct gfs2_dinode_host
    
    The final field in gfs2_dinode_host was the i_flags field. Thats
    renamed to i_diskflags in order to avoid confusion with the existing
    inode flags, and moved into the inode proper at a suitable location
    to avoid creating a "hole".
    
    At that point struct gfs2_dinode_host is no longer needed and as
    promised (quite some time ago!) it can now be removed completely.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4596cd254be6..6f67e753f883 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -233,9 +233,6 @@ enum {
 	GIF_USER                = 4, /* user inode, not metadata addr space */
 };
 
-struct gfs2_dinode_host {
-	u32 di_flags;		/* GFS2_DIF_... */
-};
 
 struct gfs2_inode {
 	struct inode i_inode;
@@ -245,9 +242,6 @@ struct gfs2_inode {
 	u64 i_eattr;
 	loff_t i_disksize;
 	unsigned long i_flags;		/* GIF_... */
-
-	struct gfs2_dinode_host i_di; /* To be replaced by ref to block */
-
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
@@ -255,6 +249,7 @@ struct gfs2_inode {
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
 	u32 i_entries;
+	u32 i_diskflags;
 	u8 i_height;
 	u8 i_depth;
 };

commit c9e98886776386f1f7828d9685e78cd341849867
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Nov 4 09:47:33 2008 +0000

    GFS2: Move i_size from gfs2_dinode_host and rename it to i_disksize
    
    This patch moved the i_size field from the gfs2_dinode_host and
    following the ext3 convention renames it i_disksize.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index fb2fd4adaae4..4596cd254be6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -234,7 +234,6 @@ enum {
 };
 
 struct gfs2_dinode_host {
-	u64 di_size;		/* number of bytes in file */
 	u32 di_flags;		/* GFS2_DIF_... */
 };
 
@@ -244,6 +243,7 @@ struct gfs2_inode {
 	u64 i_no_formal_ino;
 	u64 i_generation;
 	u64 i_eattr;
+	loff_t i_disksize;
 	unsigned long i_flags;		/* GIF_... */
 
 	struct gfs2_dinode_host i_di; /* To be replaced by ref to block */

commit 3767ac21f471fe669a7d9f6abef682ddac8fc3d8
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Nov 3 14:28:42 2008 +0000

    GFS2: Move di_eattr into "proper" inode
    
    This moves the di_eattr field out of gfs2_inode_host and
    into the inode proper.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 15ca3a75cf12..fb2fd4adaae4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -236,7 +236,6 @@ enum {
 struct gfs2_dinode_host {
 	u64 di_size;		/* number of bytes in file */
 	u32 di_flags;		/* GFS2_DIF_... */
-	u64 di_eattr;		/* extended attribute block number */
 };
 
 struct gfs2_inode {
@@ -244,6 +243,7 @@ struct gfs2_inode {
 	u64 i_no_addr;
 	u64 i_no_formal_ino;
 	u64 i_generation;
+	u64 i_eattr;
 	unsigned long i_flags;		/* GIF_... */
 
 	struct gfs2_dinode_host i_di; /* To be replaced by ref to block */

commit ad6203f2b46c2217f74b2e88299640eef5889e72
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Nov 3 13:59:19 2008 +0000

    GFS2: Move "entries" into "proper" inode
    
    This moves the directory entry count into the proper inode.
    Potentially we could get this to share the space used by
    something else in the future, but this is one more step
    on the way to removing the gfs2_dinode_host structure.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4ff1d7ecd98a..15ca3a75cf12 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -236,8 +236,6 @@ enum {
 struct gfs2_dinode_host {
 	u64 di_size;		/* number of bytes in file */
 	u32 di_flags;		/* GFS2_DIF_... */
-	/* These only apply to directories  */
-	u32 di_entries;		/* The number of entries in the directory */
 	u64 di_eattr;		/* extended attribute block number */
 };
 
@@ -256,6 +254,7 @@ struct gfs2_inode {
 	struct gfs2_alloc *i_alloc;
 	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
+	u32 i_entries;
 	u8 i_height;
 	u8 i_depth;
 };

commit bcf0b5b348a1f49c2c878ffdb78e68c930baabb8
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Nov 3 13:39:46 2008 +0000

    GFS2: Move generation number into "proper" part of inode
    
    This moves the generation number from the gfs2_dinode_host
    into the gfs2_inode structure. Eventually the plan is to get
    rid of the gfs2_dinode_host structure completely.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index f566ec1b4e8e..4ff1d7ecd98a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -235,7 +235,6 @@ enum {
 
 struct gfs2_dinode_host {
 	u64 di_size;		/* number of bytes in file */
-	u64 di_generation;	/* generation number for NFS */
 	u32 di_flags;		/* GFS2_DIF_... */
 	/* These only apply to directories  */
 	u32 di_entries;		/* The number of entries in the directory */
@@ -246,6 +245,7 @@ struct gfs2_inode {
 	struct inode i_inode;
 	u64 i_no_addr;
 	u64 i_no_formal_ino;
+	u64 i_generation;
 	unsigned long i_flags;		/* GIF_... */
 
 	struct gfs2_dinode_host i_di; /* To be replaced by ref to block */

commit 254db57f9b12daba841a4d91ddb9a8161e9c74ba
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 26 10:23:22 2008 +0100

    GFS2: Support for I/O barriers
    
    This patch adds barrier support to GFS2. There is not a lot of change
    really... we just add the barrier flag when we write journal header
    blocks. If the underlying device refuses to support them, we fall back
    to the previous way of doing things (wait for the I/O and hope) since
    there is nothing else we can do. There is no user configuration,
    barriers will always be on unless the device refuses to support them.
    This seems a reasonable solution to me since this is a correctness
    issue.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index f1ed3a1bf8aa..f566ec1b4e8e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -432,6 +432,7 @@ enum {
 	SDF_JOURNAL_CHECKED	= 0,
 	SDF_JOURNAL_LIVE	= 1,
 	SDF_SHUTDOWN		= 2,
+	SDF_NOBARRIERS		= 3,
 };
 
 #define GFS2_FSNAME_LEN		256

commit 719ee344675c2efed9115934f19aa66a526b6e5b
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Sep 18 13:53:59 2008 +0100

    GFS2: high time to take some time over atime
    
    Until now, we've used the same scheme as GFS1 for atime. This has failed
    since atime is a per vfsmnt flag, not a per fs flag and as such the
    "noatime" flag was not getting passed down to the filesystems. This
    patch removes all the "special casing" around atime updates and we
    simply use the VFS's atime code.
    
    The net result is that GFS2 will now support all the same atime related
    mount options of any other filesystem on a per-vfsmnt basis. We do lose
    the "lazy atime" updates, but we gain "relatime". We could add lazy
    atime to the VFS at a later date, if there is a requirement for that
    variant still - I suspect relatime will be enough.
    
    Also we lose about 100 lines of code after this patch has been applied,
    and I have a suspicion that it will speed things up a bit, even when
    atime is "on". So it seems like a nice clean up as well.
    
    From a user perspective, everything stays the same except the loss of
    the per-fs atime quantum tweekable (ought to be per-vfsmnt at the very
    least, and to be honest I don't think anybody ever used it) and that a
    number of options which were ignored before now work correctly.
    
    Please let me know if you've got any comments. I'm pushing this out
    early so that you can all see what my plans are.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b2c5784092cf..f1ed3a1bf8aa 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -420,7 +420,6 @@ struct gfs2_tune {
 	unsigned int gt_quota_scale_den; /* Denominator */
 	unsigned int gt_quota_cache_secs;
 	unsigned int gt_quota_quantum; /* Secs between syncs to quota file */
-	unsigned int gt_atime_quantum; /* Min secs between atime updates */
 	unsigned int gt_new_files_jdata;
 	unsigned int gt_max_readahead; /* Max bytes to read-ahead from disk */
 	unsigned int gt_stall_secs; /* Detects trouble! */
@@ -433,7 +432,6 @@ enum {
 	SDF_JOURNAL_CHECKED	= 0,
 	SDF_JOURNAL_LIVE	= 1,
 	SDF_SHUTDOWN		= 2,
-	SDF_NOATIME		= 3,
 };
 
 #define GFS2_FSNAME_LEN		256

commit 37ec89e83c4ca98323fe74f139301ff3949cfdb6
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Sep 18 13:49:32 2008 +0100

    GFS2: The war on bloat
    
    The following patch shrinks the gfs2_args structure which is embedded in
    every GFS2 superblock. It cuts down the size of the options to a single
    unsigned int (the 13 bits of bitfields will be rounded up to that size
    by the compiler) from the current 11 unsigned ints. So on x86 thats 44
    bytes shrinking to 4 bytes, in each and every GFS2 superblock.
    
    Signed-off-by: Steven Whitehouse <swhitho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a1777a1927b3..b2c5784092cf 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -386,21 +386,21 @@ struct gfs2_statfs_change_host {
 #define GFS2_DATA_ORDERED	2
 
 struct gfs2_args {
-	char ar_lockproto[GFS2_LOCKNAME_LEN]; /* Name of the Lock Protocol */
-	char ar_locktable[GFS2_LOCKNAME_LEN]; /* Name of the Lock Table */
-	char ar_hostdata[GFS2_LOCKNAME_LEN]; /* Host specific data */
-	int ar_spectator; /* Don't get a journal because we're always RO */
-	int ar_ignore_local_fs; /* Don't optimize even if local_fs is 1 */
-	int ar_localflocks; /* Let the VFS do flock|fcntl locks for us */
-	int ar_localcaching; /* Local-style caching (dangerous on multihost) */
-	int ar_debug; /* Oops on errors instead of trying to be graceful */
-	int ar_upgrade; /* Upgrade ondisk/multihost format */
-	unsigned int ar_num_glockd; /* Number of glockd threads */
-	int ar_posix_acl; /* Enable posix acls */
-	int ar_quota; /* off/account/on */
-	int ar_suiddir; /* suiddir support */
-	int ar_data; /* ordered/writeback */
-	int ar_meta; /* mount metafs */
+	char ar_lockproto[GFS2_LOCKNAME_LEN];	/* Name of the Lock Protocol */
+	char ar_locktable[GFS2_LOCKNAME_LEN];	/* Name of the Lock Table */
+	char ar_hostdata[GFS2_LOCKNAME_LEN];	/* Host specific data */
+	unsigned int ar_spectator:1;		/* Don't get a journal */
+	unsigned int ar_ignore_local_fs:1;	/* Ignore optimisations */
+	unsigned int ar_localflocks:1;		/* Let the VFS do flock|fcntl */
+	unsigned int ar_localcaching:1;		/* Local caching */
+	unsigned int ar_debug:1;		/* Oops on errors */
+	unsigned int ar_upgrade:1;		/* Upgrade ondisk format */
+	unsigned int ar_posix_acl:1;		/* Enable posix acls */
+	unsigned int ar_quota:2;		/* off/account/on */
+	unsigned int ar_suiddir:1;		/* suiddir support */
+	unsigned int ar_data:2;			/* ordered/writeback */
+	unsigned int ar_meta:1;			/* mount metafs */
+	unsigned int ar_num_glockd;		/* Number of glockd threads */
 };
 
 struct gfs2_tune {

commit 9b8df98fc8973ad1c5f0d7c4cf71c7fb84fe22c5
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Aug 8 13:45:13 2008 +0100

    GFS2: Fix metafs mounts
    
    This patch is intended to fix the issues reported in bz #457798. Instead
    of having the metafs as a separate filesystem, it becomes a second root
    of gfs2. As a result it will appear as type gfs2 in /proc/mounts, but it
    is still possible (for backwards compatibility purposes) to mount it as
    type gfs2meta. A new mount flag "meta" is introduced so that its possible
    to tell the two cases apart in /proc/mounts.
    
    As a result it becomes possible to mount type gfs2 with -o meta and
    get the same result as mounting type gfs2meta. So it is possible to
    mount just the metafs on its own. Currently if you do this, its then
    impossible to mount the "normal" root of the gfs2 filesystem without
    first unmounting the metafs root. I'm not sure if thats a feature or
    a bug :-)
    
    Either way, this is a great improvement on the previous scheme and I've
    verified that it works ok with bind mounts on both the "normal" root
    and the metafs root in various combinations.
    
    There were also a bunch of functions in super.c which didn't belong there,
    so this moves them into ops_fstype.c where they can be static. Hopefully
    the mount/umount sequence is now more obvious as a result.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Alexander Viro <aviro@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 448697a5c462..a1777a1927b3 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -400,6 +400,7 @@ struct gfs2_args {
 	int ar_quota; /* off/account/on */
 	int ar_suiddir; /* suiddir support */
 	int ar_data; /* ordered/writeback */
+	int ar_meta; /* mount metafs */
 };
 
 struct gfs2_tune {
@@ -461,7 +462,6 @@ struct gfs2_sb_host {
 
 struct gfs2_sbd {
 	struct super_block *sd_vfs;
-	struct super_block *sd_vfs_meta;
 	struct kobject sd_kobj;
 	unsigned long sd_flags;	/* SDF_... */
 	struct gfs2_sb_host sd_sb;
@@ -499,7 +499,9 @@ struct gfs2_sbd {
 
 	/* Inode Stuff */
 
-	struct inode *sd_master_dir;
+	struct dentry *sd_master_dir;
+	struct dentry *sd_root_dir;
+
 	struct inode *sd_jindex;
 	struct inode *sd_inum_inode;
 	struct inode *sd_statfs_inode;
@@ -634,7 +636,6 @@ struct gfs2_sbd {
 	/* Debugging crud */
 
 	unsigned long sd_last_warning;
-	struct vfsmount *sd_gfs2mnt;
 	struct dentry *debugfs_dir;    /* debugfs directory */
 	struct dentry *debugfs_dentry_glocks; /* for debugfs */
 };

commit c9f6a6bbc284ba87337876086f7e2e6e0b0d50dd
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jul 10 16:09:29 2008 +0100

    [GFS2] Remove support for unused and pointless flag
    
    The ability to mark files for direct i/o access when opened
    normally is both unused and pointless, so this patch removes
    support for that feature.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4ab3c3a4a96f..448697a5c462 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -421,7 +421,6 @@ struct gfs2_tune {
 	unsigned int gt_quota_quantum; /* Secs between syncs to quota file */
 	unsigned int gt_atime_quantum; /* Min secs between atime updates */
 	unsigned int gt_new_files_jdata;
-	unsigned int gt_new_files_directio;
 	unsigned int gt_max_readahead; /* Max bytes to read-ahead from disk */
 	unsigned int gt_stall_secs; /* Detects trouble! */
 	unsigned int gt_complain_secs;

commit 9cabcdbd4638cf884839ee4cd15780800c223b90
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jul 10 15:54:12 2008 +0100

    [GFS2] Replace rgrp "recent list" with mru list
    
    This patch removes the "recent list" which is used during allocation
    and replaces it with the (already existing) mru list used during
    deletion. The "recent list" was not a true mru list leading to a number
    of inefficiencies including a "next" function which made scanning the
    list an order N^2 operation wrt to the number of list elements.
    
    This should increase allocation performance with large numbers of rgrps.
    Its also a useful preparation and cleanup before some further changes
    which are planned in this area.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4b734c6e34f0..4ab3c3a4a96f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -77,7 +77,6 @@ struct gfs2_rgrp_host {
 struct gfs2_rgrpd {
 	struct list_head rd_list;	/* Link with superblock */
 	struct list_head rd_list_mru;
-	struct list_head rd_recent;	/* Recently used rgrps */
 	struct gfs2_glock *rd_gl;	/* Glock for this rgrp */
 	u64 rd_addr;			/* grp block disk address */
 	u64 rd_data0;			/* first data location */
@@ -529,7 +528,6 @@ struct gfs2_sbd {
 	struct mutex sd_rindex_mutex;
 	struct list_head sd_rindex_list;
 	struct list_head sd_rindex_mru_list;
-	struct list_head sd_rindex_recent_list;
 	struct gfs2_rgrpd *sd_rindex_forward;
 	unsigned int sd_rgrps;
 

commit 6802e3400ff4549525930ee744030c36fce9cc73
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed May 21 17:03:22 2008 +0100

    [GFS2] Clean up the glock core
    
    This patch implements a number of cleanups to the core of the
    GFS2 glock code. As a result a lot of code is removed. It looks
    like a really big change, but actually a large part of this patch
    is either removing or moving existing code.
    
    There are some new bits too though, such as the new run_queue()
    function which is considerably streamlined. Highlights of this
    patch include:
    
     o Fixes a cluster coherency bug during SH -> EX lock conversions
     o Removes the "glmutex" code in favour of a single bit lock
     o Removes the ->go_xmote_bh() for inodes since it was duplicating
       ->go_lock()
     o We now only use the ->lm_lock() function for both locks and
       unlocks (i.e. unlock is a lock with target mode LM_ST_UNLOCKED)
     o The fast path is considerably shortly, giving performance gains
       especially with lock_nolock
     o The glock_workqueue is now used for all the callbacks from the DLM
       which allows us to simplify the lock_dlm module (see following patch)
     o The way is now open to make further changes such as eliminating the two
       threads (gfs2_glockd and gfs2_scand) in favour of a more efficient
       scheme.
    
    This patch has undergone extensive testing with various test suites
    so it should be pretty stable by now.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Bob Peterson <rpeterso@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index eabe5eac41da..4b734c6e34f0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -128,20 +128,20 @@ struct gfs2_bufdata {
 
 struct gfs2_glock_operations {
 	void (*go_xmote_th) (struct gfs2_glock *gl);
-	void (*go_xmote_bh) (struct gfs2_glock *gl);
+	int (*go_xmote_bh) (struct gfs2_glock *gl, struct gfs2_holder *gh);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
+	int (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
 	const int go_type;
 	const unsigned long go_min_hold_time;
 };
 
 enum {
 	/* States */
-	HIF_HOLDER		= 6,
+	HIF_HOLDER		= 6,  /* Set for gh that "holds" the glock */
 	HIF_FIRST		= 7,
-	HIF_ABORTED		= 9,
 	HIF_WAIT		= 10,
 };
 
@@ -154,20 +154,20 @@ struct gfs2_holder {
 	unsigned gh_flags;
 
 	int gh_error;
-	unsigned long gh_iflags;
+	unsigned long gh_iflags; /* HIF_... */
 	unsigned long gh_ip;
 };
 
 enum {
-	GLF_LOCK		= 1,
-	GLF_STICKY		= 2,
-	GLF_DEMOTE		= 3,
-	GLF_PENDING_DEMOTE	= 4,
-	GLF_DIRTY		= 5,
-	GLF_DEMOTE_IN_PROGRESS	= 6,
-	GLF_LFLUSH		= 7,
-	GLF_WAITERS2		= 8,
-	GLF_CONV_DEADLK		= 9,
+	GLF_LOCK			= 1,
+	GLF_STICKY			= 2,
+	GLF_DEMOTE			= 3,
+	GLF_PENDING_DEMOTE		= 4,
+	GLF_DEMOTE_IN_PROGRESS		= 5,
+	GLF_DIRTY			= 6,
+	GLF_LFLUSH			= 7,
+	GLF_INVALIDATE_IN_PROGRESS	= 8,
+	GLF_REPLY_PENDING		= 9,
 };
 
 struct gfs2_glock {
@@ -179,19 +179,14 @@ struct gfs2_glock {
 	spinlock_t gl_spin;
 
 	unsigned int gl_state;
+	unsigned int gl_target;
+	unsigned int gl_reply;
 	unsigned int gl_hash;
 	unsigned int gl_demote_state; /* state requested by remote node */
 	unsigned long gl_demote_time; /* time of first demote request */
-	struct pid *gl_owner_pid;
-	unsigned long gl_ip;
 	struct list_head gl_holders;
-	struct list_head gl_waiters1;	/* HIF_MUTEX */
-	struct list_head gl_waiters3;	/* HIF_PROMOTE */
 
 	const struct gfs2_glock_operations *gl_ops;
-
-	struct gfs2_holder *gl_req_gh;
-
 	void *gl_lock;
 	char *gl_lvb;
 	atomic_t gl_lvb_count;

commit 091806edd458486af13ad83c9802f5b8b54d6d19
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Apr 29 12:35:48 2008 -0500

    [GFS2] filesystem consistency error from do_strip
    
    This patch fixes a GFS2 filesystem consistency error reported from
    function do_strip.  The problem was caused by a timing window
    that allowed two vfs inodes to be created in memory that point
    to the same file.  The problem is fixed by making the vfs's
    iget_test, iget_set mechanism check and set a new bit in the
    in-core gfs2_inode structure while the vfs inode spin_lock is held.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9c2c0b90b22a..eabe5eac41da 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -236,6 +236,7 @@ enum {
 	GIF_INVALID		= 0,
 	GIF_QD_LOCKED		= 1,
 	GIF_SW_PAGED		= 3,
+	GIF_USER                = 4, /* user inode, not metadata addr space */
 };
 
 struct gfs2_dinode_host {

commit 58e9fee13e579df44922172dbe3c9e3ba3edf7a3
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Fri Mar 14 13:52:52 2008 -0500

    [GFS2] Invalidate cache at correct point
    
    GFS2 wasn't invalidating its cache before it called into the lock manager
    with a request that could potentially drop a lock.  This was leaving a
    window where the lock could be actually be held by another node, but the
    file's page cache would still appear valid, causing coherency problems.
    This patch moves the cache invalidation to before the lock manager call
    when dropping a lock. It also adds the option to the lock_dlm lock
    manager to not use conversion mode deadlock avoidance, which, on a
    conversion from shared to exclusive, could internally drop the lock, and
    then reacquire in. GFS2 now asks lock_dlm to not do this.  Instead, GFS2
    manually drops the lock and reacquires it.
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4ba2ea63119d..9c2c0b90b22a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -167,6 +167,7 @@ enum {
 	GLF_DEMOTE_IN_PROGRESS	= 6,
 	GLF_LFLUSH		= 7,
 	GLF_WAITERS2		= 8,
+	GLF_CONV_DEADLK		= 9,
 };
 
 struct gfs2_glock {

commit 77658aad226866fb94097236d14d41a88aaab2ec
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Feb 12 14:17:27 2008 +0000

    [GFS2] Eliminate (almost) duplicate field from gfs2_inode
    
    The blocks counter is almost a duplicate of the i_blocks
    field in the VFS inode. The only difference is that i_blocks
    can be only 32bits long for 32bit arch without large single file
    support. Since GFS2 doesn't handle the non-large single file
    case (for 32 bit anyway) this adds a new config dependency on
    64BIT || LSF. This has always been the case, however we've never
    explicitly said so before.
    
    Even if we do add support for the non-LSF case, we will still
    not require this field to be duplicated since we will not be
    able to access oversized files anyway.
    
    So the net result of all this is that we shave 8 bytes from a gfs2_inode
    and get our config deps correct.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 898b456b386f..4ba2ea63119d 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -239,7 +239,6 @@ enum {
 
 struct gfs2_dinode_host {
 	u64 di_size;		/* number of bytes in file */
-	u64 di_blocks;		/* number of blocks in file */
 	u64 di_generation;	/* generation number for NFS */
 	u32 di_flags;		/* GFS2_DIF_... */
 	/* These only apply to directories  */

commit ac576cc5bed0dd7759e2b196468c7df93d6aeeee
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 1 10:34:15 2008 +0000

    [GFS2] Merge the rd_last_alloc_meta and rd_last_alloc_data fields
    
    We don't need to keep track of when we last allocated data
    and metadata separately since the only thing thats important
    when searching for a free block is whether its free or not,
    which is independent from what type of block it is.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c50dcdf79929..898b456b386f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -90,8 +90,7 @@ struct gfs2_rgrpd {
 	struct mutex rd_mutex;
 	u32 rd_free_clone;
 	struct gfs2_log_element rd_le;
-	u32 rd_last_alloc_data;
-	u32 rd_last_alloc_meta;
+	u32 rd_last_alloc;
 	struct gfs2_sbd *rd_sbd;
 	unsigned char rd_flags;
 #define GFS2_RDF_CHECK        0x01      /* Need to check for unlinked inodes */

commit ce276b06e8b81845926387e93f77bf81e14b5cc2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Feb 6 09:25:45 2008 +0000

    [GFS2] Reduce inode size by merging fields
    
    There were three fields being used to keep track of the location
    of the most recently allocated block for each inode. These have
    been merged into a single field in order to better keep the
    data and metadata for an inode close on disk, and also to reduce
    the space required for storage.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b67e44baa73c..c50dcdf79929 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -241,8 +241,6 @@ enum {
 struct gfs2_dinode_host {
 	u64 di_size;		/* number of bytes in file */
 	u64 di_blocks;		/* number of blocks in file */
-	u64 di_goal_meta;	/* rgrp to alloc from next */
-	u64 di_goal_data;	/* data block goal */
 	u64 di_generation;	/* generation number for NFS */
 	u32 di_flags;		/* GFS2_DIF_... */
 	/* These only apply to directories  */
@@ -262,8 +260,7 @@ struct gfs2_inode {
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
 	struct gfs2_alloc *i_alloc;
-	u64 i_last_rg_alloc;
-
+	u64 i_goal;	/* goal block for allocations */
 	struct rw_semaphore i_rw_mutex;
 	u8 i_height;
 	u8 i_depth;

commit 9feb7c889f2a3b088a7f6583e609bd39997c0f47
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Feb 5 17:11:40 2008 -0600

    [GFS2] Remove unused counters
    
    This is kind of trivial in the greater scheme of things, but
    this removes three counters that AFAICT are never used.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9dfdde3612a4..b67e44baa73c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -636,9 +636,6 @@ struct gfs2_sbd {
 
 	/* Counters */
 
-	atomic_t sd_glock_count;
-	atomic_t sd_glock_held_count;
-	atomic_t sd_inode_count;
 	atomic_t sd_reclaimed;
 
 	char sd_fsname[GFS2_FSNAME_LEN];

commit 9a0045088d888c9c539c8c626a366cb52c0fbdab
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Feb 1 09:23:44 2008 +0000

    [GFS2] Shrink & rename di_depth
    
    This patch forms a pair with the previous patch which shrunk
    di_height. Like that patch di_depth is renamed i_depth and moved
    into struct gfs2_inode directly. Also the field goes from 16 bits
    to 8 bits since it is also limited to a max value which is rather
    small (17 in this case). In addition we also now validate the field
    against this maximum value when its read in.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e9c58dc76869..9dfdde3612a4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -246,7 +246,6 @@ struct gfs2_dinode_host {
 	u64 di_generation;	/* generation number for NFS */
 	u32 di_flags;		/* GFS2_DIF_... */
 	/* These only apply to directories  */
-	u16 di_depth;		/* Number of bits in the table */
 	u32 di_entries;		/* The number of entries in the directory */
 	u64 di_eattr;		/* extended attribute block number */
 };
@@ -267,6 +266,7 @@ struct gfs2_inode {
 
 	struct rw_semaphore i_rw_mutex;
 	u8 i_height;
+	u8 i_depth;
 };
 
 /*

commit cf45b752c9f23939e40d823b0600bf876e97b0e0
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Thu Jan 31 10:31:39 2008 -0600

    [GFS2] Remove rgrp and glock version numbers
    
    This patch further reduces GFS2's memory requirements by
    eliminating the 64-bit version number fields in lieu of
    a couple bits.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8dee4672c3d8..e9c58dc76869 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -85,7 +85,6 @@ struct gfs2_rgrpd {
 	u32 rd_data;			/* num of data blocks in rgrp */
 	u32 rd_bitbytes;		/* number of bytes in data bitmaps */
 	struct gfs2_rgrp_host rd_rg;
-	u64 rd_rg_vn;
 	struct gfs2_bitmap *rd_bits;
 	unsigned int rd_bh_count;
 	struct mutex rd_mutex;
@@ -97,6 +96,7 @@ struct gfs2_rgrpd {
 	unsigned char rd_flags;
 #define GFS2_RDF_CHECK        0x01      /* Need to check for unlinked inodes */
 #define GFS2_RDF_NOALLOC      0x02      /* rg prohibits allocation */
+#define GFS2_RDF_UPTODATE     0x04      /* rg is up to date */
 };
 
 enum gfs2_state_bits {
@@ -196,7 +196,6 @@ struct gfs2_glock {
 	char *gl_lvb;
 	atomic_t gl_lvb_count;
 
-	u64 gl_vn;
 	unsigned long gl_stamp;
 	unsigned long gl_tchange;
 	void *gl_object;
@@ -533,7 +532,7 @@ struct gfs2_sbd {
 
 	/* Resource group stuff */
 
-	u64 sd_rindex_vn;
+	int sd_rindex_uptodate;
 	spinlock_t sd_rindex_spin;
 	struct mutex sd_rindex_mutex;
 	struct list_head sd_rindex_list;

commit da755fdb414470d6dce3df12ad188de9131cf96c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jan 30 15:34:04 2008 +0000

    [GFS2] Remove lm.[ch] and distribute content
    
    The functions in lm.c were just wrappers which were mostly
    only used in one other file. By moving the functions to
    the files where they are being used, they can be marked
    static and also this will usually result in them being inlined
    since they are often only used from one point in the code.
    
    A couple of really trivial functions have been inlined by hand
    into the function which called them as it makes the code clearer
    to do that.
    
    We also gain from one fewer function call in the glock lock and
    unlock paths.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 65aa46acb082..8dee4672c3d8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -211,6 +211,8 @@ struct gfs2_glock {
 	struct delayed_work gl_work;
 };
 
+#define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */
+
 struct gfs2_alloc {
 	/* Quota stuff */
 

commit ab0d756681c9502a2ab9e2e4ab3685bc0567f4ee
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Jan 29 13:56:15 2008 -0600

    [GFS2] Eliminate gl_req_bh
    
    This patch further reduces the memory needs of GFS2 by
    eliminating the gl_req_bh variable from struct gfs2_glock.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index fe14f6a417b5..65aa46acb082 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -191,7 +191,6 @@ struct gfs2_glock {
 	const struct gfs2_glock_operations *gl_ops;
 
 	struct gfs2_holder *gl_req_gh;
-	gfs2_glop_bh_t gl_req_bh;
 
 	void *gl_lock;
 	char *gl_lvb;

commit 29d38cd16358dcaef4a6c50866ecee28025b481a
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Jan 28 22:31:39 2008 -0600

    [GFS2] Get rid of gl_waiters2
    
    This patch reduces memory by replacing the int variable
    gl_waiters2 by a single bit in the gl_flags.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 39bab7b213e9..fe14f6a417b5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
- * Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
@@ -167,6 +167,7 @@ enum {
 	GLF_DIRTY		= 5,
 	GLF_DEMOTE_IN_PROGRESS	= 6,
 	GLF_LFLUSH		= 7,
+	GLF_WAITERS2		= 8,
 };
 
 struct gfs2_glock {
@@ -186,7 +187,6 @@ struct gfs2_glock {
 	struct list_head gl_holders;
 	struct list_head gl_waiters1;	/* HIF_MUTEX */
 	struct list_head gl_waiters3;	/* HIF_PROMOTE */
-	int gl_waiters2;		/* GIF_DEMOTE */
 
 	const struct gfs2_glock_operations *gl_ops;
 

commit 42d52e3818751633656fb90df1bd5cb5362fa8cc
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Jan 28 18:38:07 2008 -0600

    [GFS2] Combine rg_flags and rd_flags
    
    This patch reduces the memory required by GFS2 by combining
    the rd_flags and rg_flags (in core only).
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7ae12d2b6262..39bab7b213e9 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -69,7 +69,6 @@ struct gfs2_bitmap {
 };
 
 struct gfs2_rgrp_host {
-	u32 rg_flags;
 	u32 rg_free;
 	u32 rg_dinodes;
 	u64 rg_igeneration;
@@ -95,8 +94,9 @@ struct gfs2_rgrpd {
 	u32 rd_last_alloc_data;
 	u32 rd_last_alloc_meta;
 	struct gfs2_sbd *rd_sbd;
-	unsigned long rd_flags;
-#define GFS2_RDF_CHECK        0x0001          /* Need to check for unlinked inodes */
+	unsigned char rd_flags;
+#define GFS2_RDF_CHECK        0x01      /* Need to check for unlinked inodes */
+#define GFS2_RDF_NOALLOC      0x02      /* rg prohibits allocation */
 };
 
 enum gfs2_state_bits {

commit d0109bfa84d6603becac8c2e87b3716f557f2039
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Mon Jan 28 11:20:10 2008 -0600

    [GFS2] Only do lo_incore_commit once
    
    This patch is performance related.  When we're doing a log flush,
    I noticed we were calling buf_lo_incore_commit twice: once for
    data bufs and once for metadata bufs.  Since this is the same
    function and does the same thing in both cases, there should be
    no reason to call it twice.  Since we only need to call it once,
    we can also make it faster by removing it from the generic "lops"
    code and making it a stand-along static function.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 43472baa92e7..7ae12d2b6262 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -44,7 +44,6 @@ struct gfs2_log_header_host {
 
 struct gfs2_log_operations {
 	void (*lo_add) (struct gfs2_sbd *sdp, struct gfs2_log_element *le);
-	void (*lo_incore_commit) (struct gfs2_sbd *sdp, struct gfs2_trans *tr);
 	void (*lo_before_commit) (struct gfs2_sbd *sdp);
 	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_ail *ai);
 	void (*lo_before_scan) (struct gfs2_jdesc *jd,

commit ecc30c79157103e8bd7492043ee992b763443832
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 28 10:37:35 2008 +0000

    [GFS2] Streamline indirect pointer tree height calculation
    
    This patch improves the calculation of the tree height in order to reduce
    the number of operations which are carried out on each call to gfs2_block_map.
    In the common case, we now make a single comparison, rather than calculating
    the required tree height from scratch each time. Also in the case that the
    tree does need some extra height, we start from the current height rather from
    zero when we work out what the new height ought to be.
    
    In addition the di_height field is moved into the inode proper and reduced
    in size to a u8 since the value must be between 0 and GFS2_MAX_META_HEIGHT (10).
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 525dcae352d6..43472baa92e7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -246,7 +246,6 @@ struct gfs2_dinode_host {
 	u64 di_goal_data;	/* data block goal */
 	u64 di_generation;	/* generation number for NFS */
 	u32 di_flags;		/* GFS2_DIF_... */
-	u16 di_height;		/* height of metadata */
 	/* These only apply to directories  */
 	u16 di_depth;		/* Number of bits in the table */
 	u32 di_entries;		/* The number of entries in the directory */
@@ -268,6 +267,7 @@ struct gfs2_inode {
 	u64 i_last_rg_alloc;
 
 	struct rw_semaphore i_rw_mutex;
+	u8 i_height;
 };
 
 /*
@@ -490,9 +490,9 @@ struct gfs2_sbd {
 	u32 sd_qc_per_block;
 	u32 sd_max_dirres;	/* Max blocks needed to add a directory entry */
 	u32 sd_max_height;	/* Max height of a file's metadata tree */
-	u64 sd_heightsize[GFS2_MAX_META_HEIGHT];
+	u64 sd_heightsize[GFS2_MAX_META_HEIGHT + 1];
 	u32 sd_max_jheight; /* Max height of journaled file's meta tree */
-	u64 sd_jheightsize[GFS2_MAX_META_HEIGHT];
+	u64 sd_jheightsize[GFS2_MAX_META_HEIGHT + 1];
 
 	struct gfs2_args sd_args;	/* Mount arguments */
 	struct gfs2_tune sd_tune;	/* Filesystem tuning structure */

commit eccba068915feece2868c502787037e244db3376
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Feb 7 00:13:21 2008 -0800

    gfs2: make gfs2_glock.gl_owner_pid be a struct pid *
    
    The gl_owner_pid field is used to get the lock owning task by its pid, so make
    it in a proper manner, i.e.  by using the struct pid pointer and pid_task()
    function.
    
    The pid_task() becomes exported for the gfs2 module.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4b724e772602..525dcae352d6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -182,7 +182,7 @@ struct gfs2_glock {
 	unsigned int gl_hash;
 	unsigned int gl_demote_state; /* state requested by remote node */
 	unsigned long gl_demote_time; /* time of first demote request */
-	pid_t gl_owner_pid;
+	struct pid *gl_owner_pid;
 	unsigned long gl_ip;
 	struct list_head gl_holders;
 	struct list_head gl_waiters1;	/* HIF_MUTEX */

commit b1e058da50f7938e9c9e963e978b0730bba4ad32
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Feb 7 00:13:19 2008 -0800

    gfs2: make gfs2_holder.gh_owner_pid be a struct pid *
    
    The gl_owner_pid field is used to get the holder task by its pid and check
    whether the current is a holder, so make it in a proper manner, i.e.  via the
    struct pid * manipulations.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 513aaf0dc0ab..4b724e772602 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -151,7 +151,7 @@ struct gfs2_holder {
 	struct list_head gh_list;
 
 	struct gfs2_glock *gh_gl;
-	pid_t gh_owner_pid;
+	struct pid *gh_owner_pid;
 	unsigned int gh_state;
 	unsigned gh_flags;
 

commit 598278bd4808ed81b0e6fa445458a7d549f72a32
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Fri Jan 11 13:31:12 2008 -0600

    [GFS2] Remove unneeded i_spin
    
    This patch removes a vestigial variable "i_spin" from the gfs2_inode
    structure.  This not only saves us memory (>300000 of these in memory
    for the oom test) it also saves us time because we don't have to
    spend time initializing it (i.e. slightly better performance).
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 4cdda1a3e12c..513aaf0dc0ab 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -267,7 +267,6 @@ struct gfs2_inode {
 	struct gfs2_alloc *i_alloc;
 	u64 i_last_rg_alloc;
 
-	spinlock_t i_spin;
 	struct rw_semaphore i_rw_mutex;
 };
 

commit 6dbd822487d0a9f14432cb4680415b80656b63a2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jan 10 15:18:55 2008 +0000

    [GFS2] Reduce inode size by moving i_alloc out of line
    
    It is possible to reduce the size of GFS2 inodes by taking the i_alloc
    structure out of the gfs2_inode. This patch allocates the i_alloc
    structure whenever its needed, and frees it afterward. This decreases
    the amount of low memory we use at the expense of requiring a memory
    allocation for each page or partial page that we write. A quick test
    with postmark shows that the overhead is not measurable and I also note
    that OCFS2 use the same approach.
    
    In the future I'd like to solve the problem by shrinking down the size
    of the members of the i_alloc structure, but for now, this reduces the
    immediate problem of using too much low-memory on x86 and doesn't add
    too much overhead.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 745dada4085c..4cdda1a3e12c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -264,7 +264,7 @@ struct gfs2_inode {
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
-	struct gfs2_alloc i_alloc;
+	struct gfs2_alloc *i_alloc;
 	u64 i_last_rg_alloc;
 
 	spinlock_t i_spin;

commit 65a6290998f3d38b5c5e84423ae9e08bdd957095
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jan 2 10:16:56 2008 +0000

    [GFS2] Remove unused variable
    
    The go_drop_th function is never called or referenced.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 350b5169a9a0..745dada4085c 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -131,7 +131,6 @@ struct gfs2_bufdata {
 struct gfs2_glock_operations {
 	void (*go_xmote_th) (struct gfs2_glock *gl);
 	void (*go_xmote_bh) (struct gfs2_glock *gl);
-	void (*go_drop_th) (struct gfs2_glock *gl);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);

commit c3f60b6e3a7667f78a63b15cf09655ecfca757fc
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Wed Dec 12 11:44:41 2007 -0600

    [GFS2] Eliminate the no longer needed sd_statfs_mutex
    
    This patch eliminates the unneeded sd_statfs_mutex mutex but preserves
    the ordering as discussed.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 51166c12c5d7..350b5169a9a0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -529,7 +529,6 @@ struct gfs2_sbd {
 	/* StatFS stuff */
 
 	spinlock_t sd_statfs_spin;
-	struct mutex sd_statfs_mutex;
 	struct gfs2_statfs_change_host sd_statfs_master;
 	struct gfs2_statfs_change_host sd_statfs_local;
 	unsigned long sd_statfs_sync_time;

commit da6dd40d59fa9617ed697b90114e197036901632
Author: Bob Peterson <rpeterso@redhat.com>
Date:   Tue Dec 11 18:49:21 2007 -0600

    [GFS2] Journal extent mapping
    
    This patch saves a little time when gfs2 writes to the journals by
    keeping a mapping between logical and physical blocks on disk.
    That's better than constantly looking up indirect pointers in
    buffers, when the journals are several levels of indirection
    (which they typically are).
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 330f4c73d0e7..51166c12c5d7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
- * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
@@ -360,8 +360,17 @@ struct gfs2_ail {
 	u64 ai_sync_gen;
 };
 
+struct gfs2_journal_extent {
+	struct list_head extent_list;
+
+	unsigned int lblock; /* First logical block */
+	u64 dblock; /* First disk block */
+	u64 blocks;
+};
+
 struct gfs2_jdesc {
 	struct list_head jd_list;
+	struct list_head extent_list;
 
 	struct inode *jd_inode;
 	unsigned int jd_jid;

commit e35b921185728850c5db3b5d5b356178f931a157
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Nov 9 10:07:21 2007 +0000

    [GFS2] Don't periodically update the jindex
    
    We only care about the content of the jindex in two cases,
    one is when we mount the fs and the other is when we need
    to recover another journal. In both cases we have to update
    the jindex anyway, so there is no point in updating it
    periodically between times, so this removes it to simplify
    gfs2_logd.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7ae0206e9a61..330f4c73d0e7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -411,7 +411,6 @@ struct gfs2_tune {
 	unsigned int gt_demote_secs; /* Cache retention for unheld glock */
 	unsigned int gt_incore_log_blocks;
 	unsigned int gt_log_flush_secs;
-	unsigned int gt_jindex_refresh_secs; /* Check for new journal index */
 
 	unsigned int gt_recoverd_secs;
 	unsigned int gt_logd_secs;

commit fd041f0b4045db8646b36d393cbb274db60649f5
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Nov 8 14:55:03 2007 +0000

    [GFS2] Use atomic_t for journal free blocks counter
    
    This patch changes the counter which keeps track of the free
    blocks in the journal to an atomic_t in preparation for the
    following patch which will update the log reservation code.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 911822d1e4c0..7ae0206e9a61 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -595,7 +595,7 @@ struct gfs2_sbd {
 	struct list_head sd_log_le_databuf;
 	struct list_head sd_log_le_ordered;
 
-	unsigned int sd_log_blks_free;
+	atomic_t sd_log_blks_free;
 	struct mutex sd_log_reserve_mutex;
 
 	u64 sd_log_sequence;

commit 2bcd610d2fdea608a8fdac32788fc35a32a2327c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Nov 8 14:25:12 2007 +0000

    [GFS2] Don't add glocks to the journal
    
    The only reason for adding glocks to the journal was to keep track
    of which locks required a log flush prior to release. We add a
    flag to the glock to allow this check to be made in a simpler way.
    
    This reduces the size of a glock (by 12 bytes on i386, 24 on x86_64)
    and means that we can avoid extra work during the journal flush.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 478023e9fda6..911822d1e4c0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -168,6 +168,7 @@ enum {
 	GLF_PENDING_DEMOTE	= 4,
 	GLF_DIRTY		= 5,
 	GLF_DEMOTE_IN_PROGRESS	= 6,
+	GLF_LFLUSH		= 7,
 };
 
 struct gfs2_glock {
@@ -208,7 +209,6 @@ struct gfs2_glock {
 	struct gfs2_sbd *gl_sbd;
 
 	struct inode *gl_aspace;
-	struct gfs2_log_element gl_le;
 	struct list_head gl_ail_list;
 	atomic_t gl_ail_count;
 	struct delayed_work gl_work;
@@ -584,13 +584,11 @@ struct gfs2_sbd {
 	unsigned int sd_log_commited_databuf;
 	unsigned int sd_log_commited_revoke;
 
-	unsigned int sd_log_num_gl;
 	unsigned int sd_log_num_buf;
 	unsigned int sd_log_num_revoke;
 	unsigned int sd_log_num_rg;
 	unsigned int sd_log_num_databuf;
 
-	struct list_head sd_log_le_gl;
 	struct list_head sd_log_le_buf;
 	struct list_head sd_log_le_revoke;
 	struct list_head sd_log_le_rg;

commit e589665eb97b297412fb16b4c1737a01a91db903
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Nov 2 09:14:31 2007 +0000

    [GFS2] Remove flags no longer required
    
    The HIF_MUTEX and HIF_PROMOTE flags were set on the glock holders
    depending upon which of the two waiters lists they were going to
    be queued upon. They were then tested when the holders were taken
    off the lists to ensure that the right type of holder was being
    dequeued.
    
    Since we are already using separate lists, there doesn't seem a
    lot of point having these flags as well, and since setting them
    and testing them is in the fast path for locking and unlocking
    glock, this patch removes them.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 089dba412cc0..478023e9fda6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -141,10 +141,6 @@ struct gfs2_glock_operations {
 };
 
 enum {
-	/* Actions */
-	HIF_MUTEX		= 0,
-	HIF_PROMOTE		= 1,
-
 	/* States */
 	HIF_HOLDER		= 6,
 	HIF_FIRST		= 7,

commit c2932e03dbcfe7ea9052953dbd5f3157183c1e9b
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Nov 1 09:26:54 2007 +0000

    [GFS2] Remove "reclaim limit"
    
    This call to reclaim glocks is not needed, and in particular we don't want it
    in the fast path for locking glocks. The limit was entirely arbitrary anyway
    and we can't expect users to adjust things like this, the remaining code will
    do the right thing on its own.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index f7a50fed4b52..089dba412cc0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -433,7 +433,6 @@ struct gfs2_tune {
 	unsigned int gt_max_readahead; /* Max bytes to read-ahead from disk */
 	unsigned int gt_stall_secs; /* Detects trouble! */
 	unsigned int gt_complain_secs;
-	unsigned int gt_reclaim_limit; /* Max num of glocks in reclaim list */
 	unsigned int gt_statfs_quantum;
 	unsigned int gt_statfs_slow;
 };

commit 60b0d0877986b8fa70148f06055422d2ed858e88
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Oct 31 14:24:33 2007 +0000

    [GFS2] Remove unused variables
    
    These haven't been used for some time, remove them.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 82dfe9bd270b..f7a50fed4b52 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -412,9 +412,6 @@ struct gfs2_args {
 struct gfs2_tune {
 	spinlock_t gt_spin;
 
-	unsigned int gt_ilimit;
-	unsigned int gt_ilimit_tries;
-	unsigned int gt_ilimit_min;
 	unsigned int gt_demote_secs; /* Cache retention for unheld glock */
 	unsigned int gt_incore_log_blocks;
 	unsigned int gt_log_flush_secs;
@@ -434,7 +431,6 @@ struct gfs2_tune {
 	unsigned int gt_new_files_jdata;
 	unsigned int gt_new_files_directio;
 	unsigned int gt_max_readahead; /* Max bytes to read-ahead from disk */
-	unsigned int gt_lockdump_size;
 	unsigned int gt_stall_secs; /* Detects trouble! */
 	unsigned int gt_complain_secs;
 	unsigned int gt_reclaim_limit; /* Max num of glocks in reclaim list */

commit bf36a713169432643d4fc7eeb4e0ace96d791d26
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Oct 17 08:35:19 2007 +0100

    [GFS2] Add gfs2_is_writeback()
    
    This adds a function "gfs2_is_writeback()" along the lines of the
    existing "gfs2_is_jdata()" in order to clean up the code and make
    the various tests for the inode mode more obvious. It also fixes
    the PageChecked() logic where we were resetting the flag too early
    in the case of an error path.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e53da7d4cfff..82dfe9bd270b 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -285,7 +285,7 @@ static inline struct gfs2_inode *GFS2_I(struct inode *inode)
 	return container_of(inode, struct gfs2_inode, i_inode);
 }
 
-static inline struct gfs2_sbd *GFS2_SB(struct inode *inode)
+static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)
 {
 	return inode->i_sb->s_fs_info;
 }

commit e7e36f143565d14950055c893cfaf4400ad64d34
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Oct 16 11:47:04 2007 +0100

    [GFS2] Remove unused field in struct gfs2_inode
    
    Removes a field that is not used.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 5662ff9f86e1..e53da7d4cfff 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -274,7 +274,6 @@ struct gfs2_inode {
 
 	spinlock_t i_spin;
 	struct rw_semaphore i_rw_mutex;
-	unsigned long i_last_pfault;
 };
 
 /*

commit f91a0d3e24e4b0198be5fae20d45a35c40d1efce
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Oct 15 16:29:05 2007 +0100

    [GFS2] Remove useless i_cache from inodes
    
    The i_cache was designed to keep references to the indirect blocks
    used during block mapping so that they didn't have to be looked
    up continually. The idea failed because there are too many places
    where the i_cache needs to be freed, and this has in the past been
    the cause of many bugs.
    
    In addition there was no performance benefit being gained since the
    disk blocks in question were cached anyway. So this patch removes
    it in order to simplify the code to prepare for other changes which
    would otherwise have had to add further support for this feature.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 55c72f01cf31..5662ff9f86e1 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -275,8 +275,6 @@ struct gfs2_inode {
 	spinlock_t i_spin;
 	struct rw_semaphore i_rw_mutex;
 	unsigned long i_last_pfault;
-
-	struct buffer_head *i_cache[GFS2_MAX_META_HEIGHT];
 };
 
 /*

commit 3cc3f710ce0effe397b830826a1a081fa81f11c7
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Oct 15 15:40:33 2007 +0100

    [GFS2] Use ->page_mkwrite() for mmap()
    
    This cleans up the mmap() code path for GFS2 by implementing the
    page_mkwrite function for GFS2. We are thus able to use the
    generic filemap_fault function for our ->fault() implementation.
    
    This now means that shared writable mappings will be much more
    efficiently shared across the cluster if there is a reasonable
    proportion of read activity (the greater proportion, the better).
    
    As a side effect, it also reduces the size of the code, removes
    special cases from readpage and readpages, and makes the code
    path easier to follow.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 662182bfbff7..55c72f01cf31 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -241,7 +241,6 @@ struct gfs2_alloc {
 enum {
 	GIF_INVALID		= 0,
 	GIF_QD_LOCKED		= 1,
-	GIF_PAGED		= 2,
 	GIF_SW_PAGED		= 3,
 };
 
@@ -289,19 +288,12 @@ static inline struct gfs2_inode *GFS2_I(struct inode *inode)
 	return container_of(inode, struct gfs2_inode, i_inode);
 }
 
-/* To be removed? */
 static inline struct gfs2_sbd *GFS2_SB(struct inode *inode)
 {
 	return inode->i_sb->s_fs_info;
 }
 
-enum {
-	GFF_DID_DIRECT_ALLOC	= 0,
-	GFF_EXLOCK = 1,
-};
-
 struct gfs2_file {
-	unsigned long f_flags;		/* GFF_... */
 	struct mutex f_fl_mutex;
 	struct gfs2_holder f_fl_gh;
 };

commit cc7e79b168a552152299bd8a8254dc099aacc993
Author: Wendy Cheng <wcheng@redhat.com>
Date:   Fri Oct 5 00:27:58 2007 -0400

    [GFS2] Handle multiple glock demote requests
    
    Fix a race condition where multiple glock demote requests are sent to
    a node back-to-back. This patch does a check inside handle_callback()
    to see whether a demote request is in progress. If true, it sets a flag
    to make sure run_queue() will loop again to handle the new request,
    instead of erronously setting gl_demote_state to a different state.
    
    Signed-off-by: S. Wendy Cheng <wcheng@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index eaddfb5a8e6f..662182bfbff7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -171,6 +171,7 @@ enum {
 	GLF_DEMOTE		= 3,
 	GLF_PENDING_DEMOTE	= 4,
 	GLF_DIRTY		= 5,
+	GLF_DEMOTE_IN_PROGRESS	= 6,
 };
 
 struct gfs2_glock {
@@ -190,6 +191,7 @@ struct gfs2_glock {
 	struct list_head gl_holders;
 	struct list_head gl_waiters1;	/* HIF_MUTEX */
 	struct list_head gl_waiters3;	/* HIF_PROMOTE */
+	int gl_waiters2;		/* GIF_DEMOTE */
 
 	const struct gfs2_glock_operations *gl_ops;
 

commit 16615be18cadf53ee6f8a4f0bdd647f0753421b1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 17 10:59:52 2007 +0100

    [GFS2] Clean up journaled data writing
    
    This patch cleans up the code for writing journaled data into the log.
    It also removes the need to allocate a small "tag" structure for each
    block written into the log. Instead we just keep count of the outstanding
    I/O so that we can be sure that its all been written at the correct time.
    Another result of this patch is that a number of ll_rw_block() calls
    have become submit_bh() calls, closing some races at the same time.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8aa5780862be..eaddfb5a8e6f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -341,12 +341,6 @@ struct gfs2_quota_data {
 	unsigned long qd_last_touched;
 };
 
-struct gfs2_log_buf {
-	struct list_head lb_list;
-	struct buffer_head *lb_bh;
-	struct buffer_head *lb_real;
-};
-
 struct gfs2_trans {
 	unsigned long tr_ip;
 
@@ -631,7 +625,8 @@ struct gfs2_sbd {
 
 	unsigned long sd_log_flush_time;
 	struct rw_semaphore sd_log_flush_lock;
-	struct list_head sd_log_flush_list;
+	atomic_t sd_log_in_flight;
+	wait_queue_head_t sd_log_flush_wait;
 
 	unsigned int sd_log_flush_head;
 	u64 sd_log_flush_wrapped;

commit 82e86087bb774cd54d47db4a7c771b5b29bea9ed
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Sun Sep 2 15:39:43 2007 +0100

    [GFS2] Replace revoke structure with bufdata structure
    
    Both the revoke structure and the bufdata structure are quite similar.
    They are basically small tags which are put on lists. In addition to
    which the revoke structure is always allocated when there is a bufdata
    structure which is (or can be) freed. As such it should be possible to
    reduce the number of frees and allocations by using the same structure
    for both purposes.
    
    This patch is the first step along that path. It replaces existing uses
    of the revoke structure with the bufdata structure.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 388dc1bd736f..8aa5780862be 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -114,7 +114,13 @@ struct gfs2_bufdata {
 	struct buffer_head *bd_bh;
 	struct gfs2_glock *bd_gl;
 
-	struct list_head bd_list_tr;
+	union {
+		struct list_head list_tr;
+		u64 blkno;
+	} u;
+#define bd_list_tr u.list_tr
+#define bd_blkno u.blkno
+
 	struct gfs2_log_element bd_le;
 
 	struct gfs2_ail *bd_ail;
@@ -298,11 +304,6 @@ struct gfs2_file {
 	struct gfs2_holder f_fl_gh;
 };
 
-struct gfs2_revoke {
-	struct gfs2_log_element rv_le;
-	u64 rv_blkno;
-};
-
 struct gfs2_revoke_replay {
 	struct list_head rr_list;
 	u64 rr_blkno;

commit d7b616e252b125f12b007c392f7644053bb6f140
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Sun Sep 2 10:48:13 2007 +0100

    [GFS2] Clean up ordered write code
    
    The following patch removes the ordered write processing from
    databuf_lo_before_commit() and moves it to log.c. This has the effect of
    greatly simplyfying databuf_lo_before_commit() and well as potentially
    making the ordered write code more efficient.
    
    As a side effect of this, its now possible to remove ordered buffers
    from the ordered buffer list at any time, so we now make use of this in
    invalidatepage and releasepage to ensure timely release of these
    buffers.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 23b611aa70d2..388dc1bd736f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -612,13 +612,13 @@ struct gfs2_sbd {
 	unsigned int sd_log_num_revoke;
 	unsigned int sd_log_num_rg;
 	unsigned int sd_log_num_databuf;
-	unsigned int sd_log_num_jdata;
 
 	struct list_head sd_log_le_gl;
 	struct list_head sd_log_le_buf;
 	struct list_head sd_log_le_revoke;
 	struct list_head sd_log_le_rg;
 	struct list_head sd_log_le_databuf;
+	struct list_head sd_log_le_ordered;
 
 	unsigned int sd_log_blks_free;
 	struct mutex sd_log_reserve_mutex;

commit c4f68a130fc1795e4a75ec5bdaf9e85d86c22419
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Thu Aug 23 13:19:05 2007 -0500

    [GFS2] delay glock demote for a minimum hold time
    
    When a lot of IO, with some distributed mmap IO, is run on a GFS2 filesystem in
    a cluster, it will deadlock. The reason is that do_no_page() will repeatedly
    call gfs2_sharewrite_nopage(), because each node keeps giving up the glock
    too early, and is forced to call unmap_mapping_range(). This bumps the
    mapping->truncate_count sequence count, forcing do_no_page() to retry. This
    patch institutes a minimum glock hold time a tenth a second.  This insures
    that even in heavy contention cases, the node has enough time to get some
    useful work done before it gives up the glock.
    
    A second issue is that when gfs2_glock_dq() is called from within a page fault
    to demote a lock, and the associated page needs to be written out, it will
    try to acqire a lock on it, but it has already been locked at a higher level.
    This patch puts makes gfs2_glock_dq() use the work queue as well, to avoid this
    issue. This is the same patch as Steve Whitehouse originally proposed to fix
    this issue, execpt that gfs2_glock_dq() now grabs a reference to the glock
    before it queues up the work on it.
    
    Signed-off-by: Benjamin E. Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1390b30daf19..23b611aa70d2 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -11,6 +11,7 @@
 #define __INCORE_DOT_H__
 
 #include <linux/fs.h>
+#include <linux/workqueue.h>
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
@@ -130,6 +131,7 @@ struct gfs2_glock_operations {
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
 	const int go_type;
+	const unsigned long go_min_hold_time;
 };
 
 enum {
@@ -161,6 +163,7 @@ enum {
 	GLF_LOCK		= 1,
 	GLF_STICKY		= 2,
 	GLF_DEMOTE		= 3,
+	GLF_PENDING_DEMOTE	= 4,
 	GLF_DIRTY		= 5,
 };
 
@@ -193,6 +196,7 @@ struct gfs2_glock {
 
 	u64 gl_vn;
 	unsigned long gl_stamp;
+	unsigned long gl_tchange;
 	void *gl_object;
 
 	struct list_head gl_reclaim;
@@ -203,6 +207,7 @@ struct gfs2_glock {
 	struct gfs2_log_element gl_le;
 	struct list_head gl_ail_list;
 	atomic_t gl_ail_count;
+	struct delayed_work gl_work;
 };
 
 struct gfs2_alloc {

commit 8fbbfd214c853102b614f4705c1904ed14f5a808
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 1 13:57:10 2007 +0100

    [GFS2] Reduce number of gfs2_scand processes to one
    
    We only need a single gfs2_scand process rather than the one
    per filesystem which we had previously. As a result the parameter
    determining the frequency of gfs2_scand runs becomes a module
    parameter rather than a mount parameter as it was before.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 170ba93829c0..1390b30daf19 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -429,7 +429,6 @@ struct gfs2_tune {
 	unsigned int gt_log_flush_secs;
 	unsigned int gt_jindex_refresh_secs; /* Check for new journal index */
 
-	unsigned int gt_scand_secs;
 	unsigned int gt_recoverd_secs;
 	unsigned int gt_logd_secs;
 	unsigned int gt_quotad_secs;
@@ -574,7 +573,6 @@ struct gfs2_sbd {
 
 	/* Daemon stuff */
 
-	struct task_struct *sd_scand_process;
 	struct task_struct *sd_recoverd_process;
 	struct task_struct *sd_logd_process;
 	struct task_struct *sd_quotad_process;

commit 2332c4435bb733b5cd4f612ee57532bd8fde4c1c
Author: Robert Peterson <rpeterso@redhat.com>
Date:   Mon Jun 18 14:50:20 2007 -0500

    [GFS2] assertion failure after writing to journaled file, umount
    
    This patch passes all my nasty tests that were causing the code to
    fail under one circumstance or another.  Here is a complete summary
    of all changes from today's git tree, in order of appearance:
    
    1. There are now separate variables for metadata buffer accounting.
    2. Variable sd_log_num_hdrs is no longer needed, since the header
       accounting is taken care of by the reserve/refund sequence.
    3. Fixed a tiny grammatical problem in a comment.
    4. Added a new function "calc_reserved" to calculate the reserved
       log space.  This isn't entirely necessary, but it has two benefits:
       First, it simplifies the gfs2_log_refund function greatly.
       Second, it allows for easier debugging because I could sprinkle the
       code with calls to this function to make sure the accounting is
       proper (by adding asserts and printks) at strategic point of the code.
    5. In log_pull_tail there apparently was a kludge to fix up the
       accounting based on a "pull" parameter.  The buffer accounting is
       now done properly, so the kludge was removed.
    6. File sync operations were making a call to gfs2_log_flush that
       writes another journal header.  Since that header was unplanned
       for (reserved) by the reserve/refund sequence, the free space had
       to be decremented so that when log_pull_tail gets called, the free
       space is be adjusted properly.  (Did I hear you call that a kludge?
       well, maybe, but a lot more justifiable than the one I removed).
    7. In the gfs2_log_shutdown code, it optionally syncs the log by
       specifying the PULL parameter to log_write_header.  I'm not sure
       this is necessary anymore.  It just seems to me there could be
       cases where shutdown is called while there are outstanding log
       buffers.
    8. In the (data)buf_lo_before_commit functions, I changed some offset
       values from being calculated on the fly to being constants.  That
       simplified some code and we might as well let the compiler do the
       calculation once rather than redoing those cycles at run time.
    9. This version has my rewritten databuf_lo_add function.
       This version is much more like its predecessor, buf_lo_add, which
       makes it easier to understand.  Again, this might not be necessary,
       but it seems as if this one works as well as the previous one,
       maybe even better, so I decided to leave it in.
    10. In databuf_lo_before_commit, a previous data corruption problem
       was caused by going off the end of the buffer.  The proper solution
       is to have the proper limit in place, rather than stopping earlier.
       (Thus my previous attempt to fix it is wrong).
       If you don't wrap the buffer, you're stopping too early and that
       causes more log buffer accounting problems.
    11. In lops.h there are two new (previously mentioned) constants for
       figuring out the data offset for the journal buffers.
    12. There are also two new functions, buf_limit and databuf_limit to
       calculate how many entries will fit in the buffer.
    13. In function gfs2_meta_wipe, it needs to distinguish between pinned
       metadata buffers and journaled data buffers for proper journal buffer
       accounting.  It can't use the JDATA gfs2_inode flag because it's
       sometimes passed the "real" inode and sometimes the "metadata
       inode" and the inode flags will be random bits in a metadata
       gfs2_inode.  It needs to base its decision on which was passed in.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c7c6ec0f17c7..170ba93829c0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -354,7 +354,9 @@ struct gfs2_trans {
 
 	unsigned int tr_num_buf;
 	unsigned int tr_num_buf_new;
+	unsigned int tr_num_databuf_new;
 	unsigned int tr_num_buf_rm;
+	unsigned int tr_num_databuf_rm;
 	struct list_head tr_list_buf;
 
 	unsigned int tr_num_revoke;
@@ -599,6 +601,7 @@ struct gfs2_sbd {
 
 	unsigned int sd_log_blks_reserved;
 	unsigned int sd_log_commited_buf;
+	unsigned int sd_log_commited_databuf;
 	unsigned int sd_log_commited_revoke;
 
 	unsigned int sd_log_num_gl;
@@ -607,7 +610,6 @@ struct gfs2_sbd {
 	unsigned int sd_log_num_rg;
 	unsigned int sd_log_num_databuf;
 	unsigned int sd_log_num_jdata;
-	unsigned int sd_log_num_hdrs;
 
 	struct list_head sd_log_le_gl;
 	struct list_head sd_log_le_buf;

commit c8cdf479377462315d6b4f56379f8ac989b0ef29
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Jun 8 10:05:33 2007 +0100

    [GFS2] Recovery for lost unlinked inodes
    
    Under certain circumstances its possible (though rather unlikely) that
    inodes which were unlinked by one node while still open on another might
    get "lost" in the sense that they don't get deallocated if the node
    which held the inode open crashed before it was unlinked.
    
    This patch adds the recovery code which allows automatic deallocation of
    the inode if its found during block allocation (the sensible time to
    look for such inodes since we are scanning the rgrp's bitmaps anyway at
    this time, so it adds no overhead to do this).
    
    Since the inode will have had its i_nlink set to zero, all we need to
    trigger recovery is a lookup and an iput(), and the normal deallocation
    code takes care of the rest.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e5069b912d5e..c7c6ec0f17c7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -95,6 +95,8 @@ struct gfs2_rgrpd {
 	u32 rd_last_alloc_data;
 	u32 rd_last_alloc_meta;
 	struct gfs2_sbd *rd_sbd;
+	unsigned long rd_flags;
+#define GFS2_RDF_CHECK        0x0001          /* Need to check for unlinked inodes */
 };
 
 enum gfs2_state_bits {

commit bb8d8a6f54c1c84d7c74623491bab043b36a38c5
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Jun 1 14:11:58 2007 +0100

    [GFS2] Fix sign problem in quota/statfs and cleanup _host structures
    
    This patch fixes some sign issues which were accidentally introduced
    into the quota & statfs code during the endianess annotation process.
    Also included is a general clean up which moves all of the _host
    structures out of gfs2_ondisk.h (where they should not have been to
    start with) and into the places where they are actually used (often only
    one place). Also those _host structures which are not required any more
    are removed entirely (which is the eventual plan for all of them).
    
    The conversion routines from ondisk.c are also moved into the places
    where they are actually used, which for almost every one, was just one
    single place, so all those are now static functions. This also cleans up
    the end of gfs2_ondisk.h which no longer needs the #ifdef __KERNEL__.
    
    The net result is a reduction of about 100 lines of code, many functions
    now marked static plus the bug fixes as mentioned above. For good
    measure I ran the code through sparse after making these changes to
    check that there are no warnings generated.
    
    This fixes Red Hat bz #239686
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b2079fcd2513..e5069b912d5e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -28,6 +28,14 @@ struct gfs2_sbd;
 
 typedef void (*gfs2_glop_bh_t) (struct gfs2_glock *gl, unsigned int ret);
 
+struct gfs2_log_header_host {
+	u64 lh_sequence;	/* Sequence number of this transaction */
+	u32 lh_flags;		/* GFS2_LOG_HEAD_... */
+	u32 lh_tail;		/* Block number of log tail */
+	u32 lh_blkno;
+	u32 lh_hash;
+};
+
 /*
  * Structure of operations that are associated with each
  * type of element in the log.
@@ -60,12 +68,23 @@ struct gfs2_bitmap {
 	u32 bi_len;
 };
 
+struct gfs2_rgrp_host {
+	u32 rg_flags;
+	u32 rg_free;
+	u32 rg_dinodes;
+	u64 rg_igeneration;
+};
+
 struct gfs2_rgrpd {
 	struct list_head rd_list;	/* Link with superblock */
 	struct list_head rd_list_mru;
 	struct list_head rd_recent;	/* Recently used rgrps */
 	struct gfs2_glock *rd_gl;	/* Glock for this rgrp */
-	struct gfs2_rindex_host rd_ri;
+	u64 rd_addr;			/* grp block disk address */
+	u64 rd_data0;			/* first data location */
+	u32 rd_length;			/* length of rgrp header in fs blocks */
+	u32 rd_data;			/* num of data blocks in rgrp */
+	u32 rd_bitbytes;		/* number of bytes in data bitmaps */
 	struct gfs2_rgrp_host rd_rg;
 	u64 rd_rg_vn;
 	struct gfs2_bitmap *rd_bits;
@@ -211,6 +230,20 @@ enum {
 	GIF_SW_PAGED		= 3,
 };
 
+struct gfs2_dinode_host {
+	u64 di_size;		/* number of bytes in file */
+	u64 di_blocks;		/* number of blocks in file */
+	u64 di_goal_meta;	/* rgrp to alloc from next */
+	u64 di_goal_data;	/* data block goal */
+	u64 di_generation;	/* generation number for NFS */
+	u32 di_flags;		/* GFS2_DIF_... */
+	u16 di_height;		/* height of metadata */
+	/* These only apply to directories  */
+	u16 di_depth;		/* Number of bits in the table */
+	u32 di_entries;		/* The number of entries in the directory */
+	u64 di_eattr;		/* extended attribute block number */
+};
+
 struct gfs2_inode {
 	struct inode i_inode;
 	u64 i_no_addr;
@@ -346,6 +379,12 @@ struct gfs2_jdesc {
 	unsigned int jd_blocks;
 };
 
+struct gfs2_statfs_change_host {
+	s64 sc_total;
+	s64 sc_free;
+	s64 sc_dinodes;
+};
+
 #define GFS2_GLOCKD_DEFAULT	1
 #define GFS2_GLOCKD_MAX		16
 
@@ -418,6 +457,28 @@ enum {
 
 #define GFS2_FSNAME_LEN		256
 
+struct gfs2_inum_host {
+	u64 no_formal_ino;
+	u64 no_addr;
+};
+
+struct gfs2_sb_host {
+	u32 sb_magic;
+	u32 sb_type;
+	u32 sb_format;
+
+	u32 sb_fs_format;
+	u32 sb_multihost_format;
+	u32 sb_bsize;
+	u32 sb_bsize_shift;
+
+	struct gfs2_inum_host sb_master_dir;
+	struct gfs2_inum_host sb_root_dir;
+
+	char sb_lockproto[GFS2_LOCKNAME_LEN];
+	char sb_locktable[GFS2_LOCKNAME_LEN];
+};
+
 struct gfs2_sbd {
 	struct super_block *sd_vfs;
 	struct super_block *sd_vfs_meta;

commit 2a87ab080607d009b8b2a8706f4e27d70402ca9c
Author: Abhijith Das <adas@redhat.com>
Date:   Wed May 16 17:02:19 2007 -0500

    [GFS2] Quotas non-functional - fix bug
    
    This patch fixes an error in the quota code where a 'struct
    gfs2_quota_lvb*' was being passed to gfs2_adjust_quota() instead of a
    'struct gfs2_quota_data*'. Also moved 'struct gfs2_quota_lvb' from
    fs/gfs2/incore.h to include/linux/gfs2_ondisk.h as per Steve's suggestion.
    
    Signed-off-by: Abhijith Das <adas@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 00c3004a4c22..b2079fcd2513 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -275,14 +275,6 @@ enum {
 	QDF_LOCKED		= 2,
 };
 
-struct gfs2_quota_lvb {
-        __be32 qb_magic;
-        u32 __pad;
-        __be64 qb_limit;      /* Hard limit of # blocks to alloc */
-        __be64 qb_warn;       /* Warn user when alloc is above this # */
-        __be64 qb_value;       /* Current # blocks allocated */
-};
-
 struct gfs2_quota_data {
 	struct list_head qd_list;
 	unsigned int qd_count;

commit dbb7cae2a36170cd17ffbe286ec0c91a998740ff
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue May 15 15:37:50 2007 +0100

    [GFS2] Clean up inode number handling
    
    This patch cleans up the inode number handling code. The main difference
    is that instead of looking up the inodes using a struct gfs2_inum_host
    we now use just the no_addr member of this structure. The tests relating
    to no_formal_ino can then be done by the calling code. This has
    advantages in that we want to do different things in different code
    paths if the no_formal_ino doesn't match. In the NFS patch we want to
    return -ESTALE, but in the ->lookup() path, its a bug in the fs if the
    no_formal_ino doesn't match and thus we can withdraw in this case.
    
    In order to later fix bz #201012, we need to be able to look up an inode
    without knowing no_formal_ino, as the only information that is known to
    us is the on-disk location of the inode in question.
    
    This patch will also help us to fix bz #236099 at a later date by
    cleaning up a lot of the code in that area.
    
    There are no user visible changes as a result of this patch and there
    are no changes to the on-disk format either.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index d995441373ab..00c3004a4c22 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -213,8 +213,8 @@ enum {
 
 struct gfs2_inode {
 	struct inode i_inode;
-	struct gfs2_inum_host i_num;
-
+	u64 i_no_addr;
+	u64 i_no_formal_ino;
 	unsigned long i_flags;		/* GIF_... */
 
 	struct gfs2_dinode_host i_di; /* To be replaced by ref to block */

commit 5f8820960cf4fb621483d4a37c24939ad831bfe7
Author: Robert Peterson <rpeterso@redhat.com>
Date:   Wed Apr 18 11:41:11 2007 -0500

    [GFS2] lockdump improvements
    
    The patch below consists of the following changes (in code order):
    
    1. I fixed a minor compiler warning regarding the printing of
       a kernel symbol address.
    2. I implemented a suggestion from Dave Teigland that moves
       the debugfs information for gfs2 into a subdirectory so
       we can easily expand our use of debugfs in the future.
       The current code keeps the glock information in:
       /debug/gfs2/<fs>
       With the patch, the new code keeps the glock information in:
       /debug/gfs2/<fs>/glock
       That will allow us to create more debugfs files in the future.
    3. This fixes a bug whereby a failed mount attempt causes the
       debugfs file to not be deleted.  Failed mount attempts should
       always clean up after themselves, including deleting the
       debugfs file and/or directory.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index fdf04705906f..d995441373ab 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -609,7 +609,8 @@ struct gfs2_sbd {
 
 	unsigned long sd_last_warning;
 	struct vfsmount *sd_gfs2mnt;
-	struct dentry *debugfs_dentry; /* for debugfs */
+	struct dentry *debugfs_dir;    /* debugfs directory */
+	struct dentry *debugfs_dentry_glocks; /* for debugfs */
 };
 
 #endif /* __INCORE_DOT_H__ */

commit 04b933f27bc8e7f3f6423020cec58a4eab3bb7a7
Author: Robert Peterson <rpeterso@redhat.com>
Date:   Fri Mar 23 17:05:15 2007 -0500

    [GFS2] Red Hat bz 228540: owner references
    
    In Testing the previously posted and accepted patch for
    https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=228540
    I uncovered some gfs2 badness.  It turns out that the current
    gfs2 code saves off a process pointer when glocks is taken
    in both the glock and glock holder structures.  Those
    structures will persist in memory long after the process has
    ended; pointers to poisoned memory.
    
    This problem isn't caused by the 228540 fix; the new capability
    introduced by the fix just uncovered the problem.
    
    I wrote this patch that avoids saving process pointers
    and instead saves off the process pid.  Rather than
    referencing the bad pointers, it now does process lookups.
    There is special code that makes the output nicer for
    printing holder information for processes that have ended.
    
    This patch also adds a stub for the new "sprint_symbol"
    function that exists in Andrew Morton's -mm patch set, but
    won't go into the base kernel until 2.6.22, since it adds
    functionality but doesn't fix a bug.
    
    Signed-off-by: Bob Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9c125823d760..fdf04705906f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -127,7 +127,7 @@ struct gfs2_holder {
 	struct list_head gh_list;
 
 	struct gfs2_glock *gh_gl;
-	struct task_struct *gh_owner;
+	pid_t gh_owner_pid;
 	unsigned int gh_state;
 	unsigned gh_flags;
 
@@ -155,7 +155,7 @@ struct gfs2_glock {
 	unsigned int gl_hash;
 	unsigned int gl_demote_state; /* state requested by remote node */
 	unsigned long gl_demote_time; /* time of first demote request */
-	struct task_struct *gl_owner;
+	pid_t gl_owner_pid;
 	unsigned long gl_ip;
 	struct list_head gl_holders;
 	struct list_head gl_waiters1;	/* HIF_MUTEX */

commit 3b8249f6178cb2b68b9d683587797270125cc06a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Mar 16 09:40:31 2007 +0000

    [GFS2] Fix bz 224480 and cleanup glock demotion code
    
    This patch prevents the printing of a warning message in cases where
    the fs is functioning normally by handing off responsibility for
    unlinked, but still open inodes, to another node for eventual deallocation.
    Also, there is now an improved system for ensuring that such requests
    to other nodes do not get lost. The callback on the iopen lock is
    only ever called when i_nlink == 0 and when a node is unable to deallocate
    it due to it still being in use on another node. When a node receives
    the callback therefore, it knows that i_nlink must be zero, so we mark
    it as such (in gfs2_drop_inode) in order that it will then attempt
    deallocation of the inode itself.
    
    As an additional benefit, queuing a demote request no longer requires
    a memory allocation. This simplifies the code for dealing with gfs2_holders
    as it removes one special case.
    
    There are two new fields in struct gfs2_glock. gl_demote_state is the
    state which the remote node has requested and gl_demote_time is the
    time when the request came in. Both fields are only valid when the
    GLF_DEMOTE flag is set in gl_flags.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7555261d911f..9c125823d760 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -115,11 +115,8 @@ enum {
 	/* Actions */
 	HIF_MUTEX		= 0,
 	HIF_PROMOTE		= 1,
-	HIF_DEMOTE		= 2,
 
 	/* States */
-	HIF_ALLOCED		= 4,
-	HIF_DEALLOC		= 5,
 	HIF_HOLDER		= 6,
 	HIF_FIRST		= 7,
 	HIF_ABORTED		= 9,
@@ -142,8 +139,8 @@ struct gfs2_holder {
 enum {
 	GLF_LOCK		= 1,
 	GLF_STICKY		= 2,
+	GLF_DEMOTE		= 3,
 	GLF_DIRTY		= 5,
-	GLF_SKIP_WAITERS2	= 6,
 };
 
 struct gfs2_glock {
@@ -156,11 +153,12 @@ struct gfs2_glock {
 
 	unsigned int gl_state;
 	unsigned int gl_hash;
+	unsigned int gl_demote_state; /* state requested by remote node */
+	unsigned long gl_demote_time; /* time of first demote request */
 	struct task_struct *gl_owner;
 	unsigned long gl_ip;
 	struct list_head gl_holders;
 	struct list_head gl_waiters1;	/* HIF_MUTEX */
-	struct list_head gl_waiters2;	/* HIF_DEMOTE */
 	struct list_head gl_waiters3;	/* HIF_PROMOTE */
 
 	const struct gfs2_glock_operations *gl_ops;

commit 7c52b166c588c98cf3d2b2e7e6a0468a98e84d0d
Author: Robert Peterson <rpeterso@redhat.com>
Date:   Fri Mar 16 10:26:37 2007 +0000

    [GFS2] Add gfs2_tool lockdump support to gfs2 (bz 228540)
    
    The attached patch resolves bz 228540.  This adds the capability
    for gfs2 to dump gfs2 locks through the debugfs file system.
    This used to exist in gfs1 as "gfs_tool lockdump" but it's missing from
    gfs2 because all the ioctls were stripped out.  Please see the bugzilla
    for more history about the fix.  This patch is also attached to the bugzilla
    record.
    
    The patch is against Steve Whitehouse's latest nmw git tree kernel
    (2.6.21-rc1) and has been tested on system trin-10.
    
    Signed-off-by: Robert Peterson <rpeterso@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 49f0dbf40d86..7555261d911f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -611,6 +611,7 @@ struct gfs2_sbd {
 
 	unsigned long sd_last_warning;
 	struct vfsmount *sd_gfs2mnt;
+	struct dentry *debugfs_dentry; /* for debugfs */
 };
 
 #endif /* __INCORE_DOT_H__ */

commit 631c42e170564108423fa4073531db159f2523ea
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Mar 1 10:36:32 2007 +0000

    [GFS2] go_drop_bh is never used, so remove it
    
    The ->go_drop_bh function is never used, so this removes it and the single
    caller,
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 0b2b5454179b..49f0dbf40d86 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -104,7 +104,6 @@ struct gfs2_glock_operations {
 	void (*go_xmote_th) (struct gfs2_glock *gl);
 	void (*go_xmote_bh) (struct gfs2_glock *gl);
 	void (*go_drop_th) (struct gfs2_glock *gl);
-	void (*go_drop_bh) (struct gfs2_glock *gl);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);

commit 04b159b132c0d8e92dae8c72f134fd5b13b43deb
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Mar 1 11:14:44 2007 +0000

    [GFS2] Remove unused variable
    
    Remove an unused variable.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 12c80fd28db5..0b2b5454179b 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -416,7 +416,6 @@ struct gfs2_tune {
 	unsigned int gt_stall_secs; /* Detects trouble! */
 	unsigned int gt_complain_secs;
 	unsigned int gt_reclaim_limit; /* Max num of glocks in reclaim list */
-	unsigned int gt_entries_per_readdir;
 	unsigned int gt_statfs_quantum;
 	unsigned int gt_statfs_slow;
 };

commit b5d32bead1578afc5ca817d40c320764d50a8600
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 22 12:15:34 2007 -0500

    [GFS2] Tidy up glops calls
    
    This patch doesn't make any changes to the ordering of the various
    operations related to glocking, but it does tidy up the calls to the
    glops.c functions to make the structure more obvious.
    
    The two functions: gfs2_glock_xmote_th() and gfs2_glock_drop_th() can be
    made static within glock.c since they are called by every set of glock
    operations. The xmote_th and drop_th glock operations are then made
    conditional upon those two routines existing and called from the
    previously mentioned functions in glock.c respectively.
    
    Also it can be seen that the go_sync operation isn't needed since it can
    easily be replaced by calls to xmote_bh and drop_bh respectively. This
    results in no longer (confusingly) calling back into routines in glock.c
    from glops.c and also reducing the glock operations by one member.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1acbcc2415ee..12c80fd28db5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -101,11 +101,10 @@ struct gfs2_bufdata {
 };
 
 struct gfs2_glock_operations {
-	void (*go_xmote_th) (struct gfs2_glock *gl, unsigned int state, int flags);
+	void (*go_xmote_th) (struct gfs2_glock *gl);
 	void (*go_xmote_bh) (struct gfs2_glock *gl);
 	void (*go_drop_th) (struct gfs2_glock *gl);
 	void (*go_drop_bh) (struct gfs2_glock *gl);
-	void (*go_sync) (struct gfs2_glock *gl);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);

commit 6bd9c8c2fb99d1f5af6201db2f063c1d754c230a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Jan 19 13:57:36 2007 -0500

    [GFS2] Remove unused go_callback operation
    
    This is never used, so we might as well remove it.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index dc024b18ea96..1acbcc2415ee 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -110,7 +110,6 @@ struct gfs2_glock_operations {
 	int (*go_demote_ok) (struct gfs2_glock *gl);
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
-	void (*go_callback) (struct gfs2_glock *gl, unsigned int state);
 	const int go_type;
 };
 

commit e5dab552c82ce416d7be867b1e5a0fa585dcf590
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jan 18 17:44:20 2007 +0000

    [GFS2] Remove the "greedy" function from glock.[ch]
    
    The "greedy" code was an attempt to retain glocks for a minimum length
    of time when they relate to mmap()ed files. The current implementation
    of this feature is not, however, ideal in that it required allocating
    memory in order to do this and its overly complicated.
    
    It also misses the mark by ignoring the other I/O operations which are
    just as likely to suffer from the same problem. So the plan is to remove
    this now and then add the functionality back as part of the glock state
    machine at a later date (and thus take into account all the possible
    users of this feature)
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a24c4af09ce0..dc024b18ea96 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -111,7 +111,6 @@ struct gfs2_glock_operations {
 	int (*go_lock) (struct gfs2_holder *gh);
 	void (*go_unlock) (struct gfs2_holder *gh);
 	void (*go_callback) (struct gfs2_glock *gl, unsigned int state);
-	void (*go_greedy) (struct gfs2_glock *gl);
 	const int go_type;
 };
 
@@ -120,7 +119,6 @@ enum {
 	HIF_MUTEX		= 0,
 	HIF_PROMOTE		= 1,
 	HIF_DEMOTE		= 2,
-	HIF_GREEDY		= 3,
 
 	/* States */
 	HIF_ALLOCED		= 4,
@@ -149,7 +147,6 @@ enum {
 	GLF_STICKY		= 2,
 	GLF_DIRTY		= 5,
 	GLF_SKIP_WAITERS2	= 6,
-	GLF_GREEDY		= 7,
 };
 
 struct gfs2_glock {
@@ -166,7 +163,7 @@ struct gfs2_glock {
 	unsigned long gl_ip;
 	struct list_head gl_holders;
 	struct list_head gl_waiters1;	/* HIF_MUTEX */
-	struct list_head gl_waiters2;	/* HIF_DEMOTE, HIF_GREEDY */
+	struct list_head gl_waiters2;	/* HIF_DEMOTE */
 	struct list_head gl_waiters3;	/* HIF_PROMOTE */
 
 	const struct gfs2_glock_operations *gl_ops;
@@ -235,7 +232,6 @@ struct gfs2_inode {
 
 	spinlock_t i_spin;
 	struct rw_semaphore i_rw_mutex;
-	unsigned int i_greedy;
 	unsigned long i_last_pfault;
 
 	struct buffer_head *i_cache[GFS2_MAX_META_HEIGHT];
@@ -423,9 +419,6 @@ struct gfs2_tune {
 	unsigned int gt_complain_secs;
 	unsigned int gt_reclaim_limit; /* Max num of glocks in reclaim list */
 	unsigned int gt_entries_per_readdir;
-	unsigned int gt_greedy_default;
-	unsigned int gt_greedy_quantum;
-	unsigned int gt_greedy_max;
 	unsigned int gt_statfs_quantum;
 	unsigned int gt_statfs_slow;
 };

commit fee852e374fb367c5436b1226eb93b35f8355ed9
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jan 17 15:33:23 2007 +0000

    [GFS2] Shrink gfs2_inode memory by half
    
    Here is something I spotted (while looking for something entirely
    different) the other day.
    
    Rather than using a completion in each and every struct gfs2_holder,
    this removes it in favour of hashed wait queues, thus saving a
    considerable amount of memory both on the stack (where a number of
    gfs2_holder structures are allocated) and in particular in the
    gfs2_inode which has 8 gfs2_holder structures embedded within it.
    
    As a result on x86_64 the gfs2_inode shrinks from 2488 bytes to
    1912 bytes, a saving of 576 bytes per inode (no thats not a typo!).
    In actual practice we get a much better result than that since
    now that a gfs2_inode is under the 2048 byte barrier, we get two
    per 4k slab page effectively halving the amount of memory required
    to store gfs2_inodes.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9114851ac53e..a24c4af09ce0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -128,6 +128,7 @@ enum {
 	HIF_HOLDER		= 6,
 	HIF_FIRST		= 7,
 	HIF_ABORTED		= 9,
+	HIF_WAIT		= 10,
 };
 
 struct gfs2_holder {
@@ -140,7 +141,6 @@ struct gfs2_holder {
 
 	int gh_error;
 	unsigned long gh_iflags;
-	struct completion gh_wait;
 	unsigned long gh_ip;
 };
 

commit 330005c2b23e71e54931913e9b63d1712a19e444
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 15 16:36:26 2007 -0500

    [GFS2] Remove max_atomic_write tunable
    
    This removes an unused sysfs tunable parameter.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 807587050384..9114851ac53e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -417,7 +417,6 @@ struct gfs2_tune {
 	unsigned int gt_atime_quantum; /* Min secs between atime updates */
 	unsigned int gt_new_files_jdata;
 	unsigned int gt_new_files_directio;
-	unsigned int gt_max_atomic_write; /* Split big writes into this size */
 	unsigned int gt_max_readahead; /* Max bytes to read-ahead from disk */
 	unsigned int gt_lockdump_size;
 	unsigned int gt_stall_secs; /* Detects trouble! */

commit 3699e3a44bf56e0cd58c97e8655f375ad9b65d9d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jan 17 15:09:20 2007 +0000

    [GFS2] Clean up/speed up readdir
    
    This removes the extra filldir callback which gfs2 was using to
    enclose an attempt at readahead for inodes during readdir. The
    code was too complicated and also hurts performance badly in the
    case that the getdents64/readdir call isn't being followed by
    stat() and it wasn't even getting it right all the time when it
    was.
    
    As a result, on my test box an "ls" of a directory containing 250000
    files fell from about 7mins (freshly mounted, so nothing cached) to
    between about 15 to 25 seconds. When the directory content was cached,
    the time taken fell from about 3mins to about 4 or 5 seconds.
    
    Interestingly in the cached case, running "ls -l" once reduced the time
    taken for subsequent runs of "ls" to about 6 secs even without this
    patch. Now it turns out that there was a special case of glocks being
    used for prefetching the metadata, but because of the timeouts for these
    locks (set to 10 secs) the metadata was being timed out before it was
    being used and this the prefetch code was constantly trying to prefetch
    the same data over and over.
    
    Calling "ls -l" meant that the inodes were brought into memory and once
    the inodes are cached, the glocks are not disposed of until the inodes
    are pushed out of the cache, thus extending the lifetime of the glocks,
    and thus bringing down the time for subsequent runs of "ls"
    considerably.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 734421edae85..807587050384 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -147,7 +147,6 @@ struct gfs2_holder {
 enum {
 	GLF_LOCK		= 1,
 	GLF_STICKY		= 2,
-	GLF_PREFETCH		= 3,
 	GLF_DIRTY		= 5,
 	GLF_SKIP_WAITERS2	= 6,
 	GLF_GREEDY		= 7,
@@ -425,7 +424,6 @@ struct gfs2_tune {
 	unsigned int gt_complain_secs;
 	unsigned int gt_reclaim_limit; /* Max num of glocks in reclaim list */
 	unsigned int gt_entries_per_readdir;
-	unsigned int gt_prefetch_secs; /* Usage window for prefetched glocks */
 	unsigned int gt_greedy_default;
 	unsigned int gt_greedy_quantum;
 	unsigned int gt_greedy_max;

commit 1a14d3a68f04527546121eb7b45187ff6af63151
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Nov 20 10:37:45 2006 -0500

    [GFS2] Simplify glops functions
    
    The go_sync callback took two flags, but one of them was set on every
    call, so this patch removes once of the flags and makes the previously
    conditional operations (on this flag), unconditional.
    
    The go_inval callback took three flags, each of which was set on every
    call to it. This patch removes the flags and makes the operations
    unconditional, which makes the logic rather more obvious.
    
    Two now unused flags are also removed from incore.h.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 227a74dc5ec0..734421edae85 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -14,8 +14,6 @@
 
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
-#define DIO_DATA	0x00000040
-#define DIO_RELEASE	0x00000080
 #define DIO_ALL		0x00000100
 
 struct gfs2_log_operations;
@@ -103,18 +101,17 @@ struct gfs2_bufdata {
 };
 
 struct gfs2_glock_operations {
-	void (*go_xmote_th) (struct gfs2_glock * gl, unsigned int state,
-			     int flags);
-	void (*go_xmote_bh) (struct gfs2_glock * gl);
-	void (*go_drop_th) (struct gfs2_glock * gl);
-	void (*go_drop_bh) (struct gfs2_glock * gl);
-	void (*go_sync) (struct gfs2_glock * gl, int flags);
-	void (*go_inval) (struct gfs2_glock * gl, int flags);
-	int (*go_demote_ok) (struct gfs2_glock * gl);
-	int (*go_lock) (struct gfs2_holder * gh);
-	void (*go_unlock) (struct gfs2_holder * gh);
-	void (*go_callback) (struct gfs2_glock * gl, unsigned int state);
-	void (*go_greedy) (struct gfs2_glock * gl);
+	void (*go_xmote_th) (struct gfs2_glock *gl, unsigned int state, int flags);
+	void (*go_xmote_bh) (struct gfs2_glock *gl);
+	void (*go_drop_th) (struct gfs2_glock *gl);
+	void (*go_drop_bh) (struct gfs2_glock *gl);
+	void (*go_sync) (struct gfs2_glock *gl);
+	void (*go_inval) (struct gfs2_glock *gl, int flags);
+	int (*go_demote_ok) (struct gfs2_glock *gl);
+	int (*go_lock) (struct gfs2_holder *gh);
+	void (*go_unlock) (struct gfs2_holder *gh);
+	void (*go_callback) (struct gfs2_glock *gl, unsigned int state);
+	void (*go_greedy) (struct gfs2_glock *gl);
 	const int go_type;
 };
 

commit bfded27ba010d1c3b0aa3843f97dc9b80de751be
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Nov 1 16:05:38 2006 -0500

    [GFS2] Shrink gfs2_inode (8) - i_vn
    
    This shrinks the size of the gfs2_inode by 8 bytes by
    replacing the version counter with a one bit valid/invalid
    flag.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c0a8c3b6a852..227a74dc5ec0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -217,6 +217,7 @@ struct gfs2_alloc {
 };
 
 enum {
+	GIF_INVALID		= 0,
 	GIF_QD_LOCKED		= 1,
 	GIF_PAGED		= 2,
 	GIF_SW_PAGED		= 3,
@@ -228,7 +229,6 @@ struct gfs2_inode {
 
 	unsigned long i_flags;		/* GIF_... */
 
-	u64 i_vn;
 	struct gfs2_dinode_host i_di; /* To be replaced by ref to block */
 
 	struct gfs2_glock *i_gl; /* Move into i_gh? */

commit bd209cc017f231e8536550bdab1bf5da93c32798
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 13 23:43:19 2006 -0400

    [GFS2] split and annotate gfs2_statfs_change
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 20c9b4f0e52f..c0a8c3b6a852 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -503,8 +503,8 @@ struct gfs2_sbd {
 
 	spinlock_t sd_statfs_spin;
 	struct mutex sd_statfs_mutex;
-	struct gfs2_statfs_change sd_statfs_master;
-	struct gfs2_statfs_change sd_statfs_local;
+	struct gfs2_statfs_change_host sd_statfs_master;
+	struct gfs2_statfs_change_host sd_statfs_local;
 	unsigned long sd_statfs_sync_time;
 
 	/* Resource group stuff */

commit 629a21e7ecedf779c68dcaa9a186069f57a7c652
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 13 22:51:24 2006 -0400

    [GFS2] split and annotate gfs2_inum
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e4afc2c4d609..20c9b4f0e52f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -224,7 +224,7 @@ enum {
 
 struct gfs2_inode {
 	struct inode i_inode;
-	struct gfs2_inum i_num;
+	struct gfs2_inum_host i_num;
 
 	unsigned long i_flags;		/* GIF_... */
 

commit 1e81c4c3e0f55c95b6278a827262b80debd0dc7e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 13 22:51:24 2006 -0400

    [GFS2] split and annotate gfs_rindex
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e69f3394a2ce..e4afc2c4d609 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -67,7 +67,7 @@ struct gfs2_rgrpd {
 	struct list_head rd_list_mru;
 	struct list_head rd_recent;	/* Recently used rgrps */
 	struct gfs2_glock *rd_gl;	/* Glock for this rgrp */
-	struct gfs2_rindex rd_ri;
+	struct gfs2_rindex_host rd_ri;
 	struct gfs2_rgrp_host rd_rg;
 	u64 rd_rg_vn;
 	struct gfs2_bitmap *rd_bits;

commit 551676226163379c217e8ec54bd287eab9b8521e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 13 21:47:13 2006 -0400

    [GFS2] split and annotate gfs2_log_head
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8ca7a7f35062..e69f3394a2ce 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -41,7 +41,7 @@ struct gfs2_log_operations {
 	void (*lo_before_commit) (struct gfs2_sbd *sdp);
 	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_ail *ai);
 	void (*lo_before_scan) (struct gfs2_jdesc *jd,
-				struct gfs2_log_header *head, int pass);
+				struct gfs2_log_header_host *head, int pass);
 	int (*lo_scan_elements) (struct gfs2_jdesc *jd, unsigned int start,
 				 struct gfs2_log_descriptor *ld, __be64 *ptr,
 				 int pass);

commit 68826664d12827d7a732192e2f00ba46fb899414
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 13 21:07:22 2006 -0400

    [GFS2] split and annotate gfs2_rgrp
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index bd596ba74e56..8ca7a7f35062 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -68,7 +68,7 @@ struct gfs2_rgrpd {
 	struct list_head rd_recent;	/* Recently used rgrps */
 	struct gfs2_glock *rd_gl;	/* Glock for this rgrp */
 	struct gfs2_rindex rd_ri;
-	struct gfs2_rgrp rd_rg;
+	struct gfs2_rgrp_host rd_rg;
 	u64 rd_rg_vn;
 	struct gfs2_bitmap *rd_bits;
 	unsigned int rd_bh_count;

commit f50dfaf78c01df3cc2d8819f07d6661915567bae
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 13 20:45:02 2006 -0400

    [GFS2] split gfs2_sb
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1c876e0fb44a..bd596ba74e56 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -450,7 +450,7 @@ struct gfs2_sbd {
 	struct super_block *sd_vfs_meta;
 	struct kobject sd_kobj;
 	unsigned long sd_flags;	/* SDF_... */
-	struct gfs2_sb sd_sb;
+	struct gfs2_sb_host sd_sb;
 
 	/* Constants computed on mount */
 

commit 5c6edb576f3800723bb65dbfaff82517089e32d0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 13 20:33:01 2006 -0400

    [GFS2] gfs2_dinode_host fields are host-endian
    
    Annotated scalar fields, dropped unused ones.  Note that
    it's not at all obvious that we want to convert all of them
    to host-endian...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 118dc693d111..1c876e0fb44a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -229,7 +229,7 @@ struct gfs2_inode {
 	unsigned long i_flags;		/* GIF_... */
 
 	u64 i_vn;
-	struct gfs2_dinode i_di; /* To be replaced by ref to block */
+	struct gfs2_dinode_host i_di; /* To be replaced by ref to block */
 
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;

commit 7276b3b0c77101f8b3f4e45e89a29cf9045e831a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Sep 21 17:05:23 2006 -0400

    [GFS2] Tidy up meta_io code
    
    Fix a bug in the directory reading code, where we might have dereferenced
    a NULL pointer in case of OOM. Updated the directory code to use the new
    & improved version of gfs2_meta_ra() which now returns the first block
    that was being read. Previously it was releasing it requiring following
    code to grab the block again at each point it was called.
    
    Also turned off readahead on directory lookups since we are reading a
    hash table, and therefore reading the entries in order is very
    unlikely. Readahead is still used for all other calls to the
    directory reading function (e.g. when growing the hash table).
    
    Removed the DIO_START constant. Everywhere this was used, it was
    used to unconditionally start i/o aside from a couple of places, so
    I've removed it and made the couple of exceptions to this rule into
    separate functions.
    
    Also hunted through the other DIO flags and removed them as arguments
    from functions which were always called with the same combination of
    arguments.
    
    Updated gfs2_meta_indirect_buffer to be a bit more efficient and
    hopefully also be a bit easier to read.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7183dcf03563..118dc693d111 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -12,7 +12,6 @@
 
 #include <linux/fs.h>
 
-#define DIO_START	0x00000008
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020
 #define DIO_DATA	0x00000040

commit 56965536b8056f57830219efbba4b85218d96d6c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Sep 20 15:48:09 2006 -0400

    [GFS2] Remove unused constants
    
    Three of the DIO constants were not being used, so remove them.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 89df68b32fc6..7183dcf03563 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -12,9 +12,6 @@
 
 #include <linux/fs.h>
 
-#define DIO_FORCE	0x00000001
-#define DIO_CLEAN	0x00000002
-#define DIO_DIRTY	0x00000004
 #define DIO_START	0x00000008
 #define DIO_WAIT	0x00000010
 #define DIO_METADATA	0x00000020

commit 16feb9fec0e1f74339bd6992130ceedb3aa9567e
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Sep 13 10:43:37 2006 -0400

    [GFS2] Use atomic_t rather than kref in glock.c
    
    Use atomic_t as the ref count in glocks rather than a kref.
    This is another step towards using RCU for the glock hash.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c68d39271ede..89df68b32fc6 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -164,7 +164,7 @@ struct gfs2_glock {
 	struct hlist_node gl_list;
 	unsigned long gl_flags;		/* GLF_... */
 	struct lm_lockname gl_name;
-	struct kref gl_ref;
+	atomic_t gl_ref;
 
 	spinlock_t gl_spin;
 

commit b6397893a5ed81970e803d61ee2f1a0e79f87438
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Sep 12 10:10:01 2006 -0400

    [GFS2] Use hlist for glock hash chains
    
    This results in smaller list heads, so that we can have more chains
    in the same amount of memory (twice as many). I've multiplied the
    size of the table by four though - this is because we are saving
    memory by not having one lock per chain any more. So we land up
    using about the same amount of memory for the hash table as we
    did before I started these changes, the difference being that we
    now have four times as many hash chains.
    
    The reason that I say "about the same amount of memory" is that the
    actual amount now depends upon the NR_CPUS and some of the config
    variables, so that its not exact and in some cases we do use more
    memory. Eventually we might want to scale the hash table size
    according to the size of physical ram as measured on module load.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1fed8d1abae5..c68d39271ede 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -161,7 +161,7 @@ enum {
 };
 
 struct gfs2_glock {
-	struct list_head gl_list;
+	struct hlist_node gl_list;
 	unsigned long gl_flags;		/* GLF_... */
 	struct lm_lockname gl_name;
 	struct kref gl_ref;

commit 24264434603cc102d71fb2a1b3b7e282a781f449
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 11 21:40:30 2006 -0400

    [GFS2] Rewrite of examine_bucket()
    
    The existing implementation of this function in glock.c was not
    very efficient as it relied upon keeping a cursor element upon the
    hash chain in question and moving it along. This new version improves
    upon this by using the current element as a cursor. This is possible
    since we only look at the "next" element in the list after we've
    taken the read_lock() subsequent to calling the examiner function.
    Obviously we have to eventually drop the ref count that we are then
    left with and we cannot do that while holding the read_lock, so we
    do that next time we drop the lock. That means either just before
    we examine another glock, or when the loop has terminated.
    
    The new implementation has several advantages: it uses only a
    read_lock() rather than a write_lock(), so it can run simnultaneously
    with other code, it doesn't need a "plug" element, so that it removes
    a test not only from this list iterator, but from all the other glock
    list iterators too. So it makes things faster and smaller.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 64e13435ca3b..1fed8d1abae5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -152,7 +152,6 @@ struct gfs2_holder {
 };
 
 enum {
-	GLF_PLUG		= 0,
 	GLF_LOCK		= 1,
 	GLF_STICKY		= 2,
 	GLF_PREFETCH		= 3,

commit 087efdd391f47305dc251a7b00dcc5d69e8c636a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Sat Sep 9 16:59:11 2006 -0400

    [GFS2] Make glock hash locks proportional to NR_CPUS
    
    Make the number of locks used for hash chains in glock.c
    proportional to NR_CPUS. Also move constants for the number
    of hash chains into glock.c from incore.h since they are
    not used outside of glock.c.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index f50ea6282e77..64e13435ca3b 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -448,9 +448,6 @@ enum {
 	SDF_NOATIME		= 3,
 };
 
-#define GFS2_GL_HASH_SHIFT	13
-#define GFS2_GL_HASH_SIZE	(1 << GFS2_GL_HASH_SHIFT)
-#define GFS2_GL_HASH_MASK	(GFS2_GL_HASH_SIZE - 1)
 #define GFS2_FSNAME_LEN		256
 
 struct gfs2_sbd {

commit 37b2fa6a24f996d751dc80fbc8a77602cead269b
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 8 13:35:56 2006 -0400

    [GFS2] Move rwlocks in glock.c into their own array
    
    This splits the rwlocks guarding the hash chains of the glock hash
    table into their own array. This will reduce memory usage in some
    cases due to better alignment, although the real reason for doing it
    is to allow the two tables to be different sizes in future (i.e.
    the locks will be sized proportionally with the max number of CPUs
    and the hash chains sized proportinally with the size of physical memory)
    
    In order to allow this, the gl_bucket member of struct gfs2_glock has
    now become gl_hash, so we record the hash rather than a pointer to the
    bucket itself.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9f5d98ff823a..f50ea6282e77 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -106,11 +106,6 @@ struct gfs2_bufdata {
 	struct list_head bd_ail_gl_list;
 };
 
-struct gfs2_gl_hash_bucket {
-        rwlock_t hb_lock;
-        struct list_head hb_list;
-};
-
 struct gfs2_glock_operations {
 	void (*go_xmote_th) (struct gfs2_glock * gl, unsigned int state,
 			     int flags);
@@ -175,6 +170,7 @@ struct gfs2_glock {
 	spinlock_t gl_spin;
 
 	unsigned int gl_state;
+	unsigned int gl_hash;
 	struct task_struct *gl_owner;
 	unsigned long gl_ip;
 	struct list_head gl_holders;
@@ -195,7 +191,6 @@ struct gfs2_glock {
 	unsigned long gl_stamp;
 	void *gl_object;
 
-	struct gfs2_gl_hash_bucket *gl_bucket;
 	struct list_head gl_reclaim;
 
 	struct gfs2_sbd *gl_sbd;

commit 9b47c11d1cbedcba685c9bd90c73fd41acdfab0e
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 8 10:17:58 2006 -0400

    [GFS2] Use void * instead of typedef for locking module interface
    
    As requested by Jan Engelhardt, this removes the typedefs in the
    locking module interface and replaces them with void *. Also
    since we are changing the interface, I've added a few consts
    as well.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Cc: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 61849607211f..9f5d98ff823a 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -187,7 +187,7 @@ struct gfs2_glock {
 	struct gfs2_holder *gl_req_gh;
 	gfs2_glop_bh_t gl_req_bh;
 
-	lm_lock_t *gl_lock;
+	void *gl_lock;
 	char *gl_lvb;
 	atomic_t gl_lvb_count;
 

commit 85d1da67f7e1239afa3494d05be87da6fc3ecada
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Sep 7 14:40:21 2006 -0400

    [GFS2] Move glock hash table out of superblock
    
    There are several reasons why we want to do this:
     - Firstly its large and thus we'll scale better with multiple
       GFS2 fs mounted at the same time
     - Secondly its easier to scale its size as required (thats a plan
       for later patches)
     - Thirdly, we can use kzalloc rather than vmalloc when allocating
       the superblock (its now only 4888 bytes)
     - Fourth its all part of my plan to eventually be able to use RCU
       with the glock hash.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 225924ca6b3e..61849607211f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -30,7 +30,6 @@ struct gfs2_quota_data;
 struct gfs2_trans;
 struct gfs2_ail;
 struct gfs2_jdesc;
-struct gfs2_gl_hash_bucket;
 struct gfs2_sbd;
 
 typedef void (*gfs2_glop_bh_t) (struct gfs2_glock *gl, unsigned int ret);
@@ -107,6 +106,11 @@ struct gfs2_bufdata {
 	struct list_head bd_ail_gl_list;
 };
 
+struct gfs2_gl_hash_bucket {
+        rwlock_t hb_lock;
+        struct list_head hb_list;
+};
+
 struct gfs2_glock_operations {
 	void (*go_xmote_th) (struct gfs2_glock * gl, unsigned int state,
 			     int flags);
@@ -442,11 +446,6 @@ struct gfs2_tune {
 	unsigned int gt_statfs_slow;
 };
 
-struct gfs2_gl_hash_bucket {
-	rwlock_t hb_lock;
-	struct list_head hb_list;
-};
-
 enum {
 	SDF_JOURNAL_CHECKED	= 0,
 	SDF_JOURNAL_LIVE	= 1,
@@ -489,7 +488,6 @@ struct gfs2_sbd {
 	/* Lock Stuff */
 
 	struct lm_lockstruct sd_lockstruct;
-	struct gfs2_gl_hash_bucket sd_gl_hash[GFS2_GL_HASH_SIZE];
 	struct list_head sd_reclaim_list;
 	spinlock_t sd_reclaim_lock;
 	wait_queue_head_t sd_reclaim_wq;

commit f2f7ba5237e2fe10ba3e328a4f728b9e1ff141da
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Sep 5 10:39:21 2006 -0400

    [GFS2] Make headers compile on their own
    
    As per Jan Engelhardt's comments, this should make all the headers
    compile on their own by including and/or declaring structures
    early.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 407afd18fa2e..225924ca6b3e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -10,6 +10,8 @@
 #ifndef __INCORE_DOT_H__
 #define __INCORE_DOT_H__
 
+#include <linux/fs.h>
+
 #define DIO_FORCE	0x00000001
 #define DIO_CLEAN	0x00000002
 #define DIO_DIRTY	0x00000004

commit cd915493fce912f1bd838ee1250737ecf33b8fae
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Sep 4 12:49:07 2006 -0400

    [GFS2] Change all types to uX style
    
    This makes all fixed size types have consistent names.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 06f5ec6ebf7f..407afd18fa2e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -60,9 +60,9 @@ struct gfs2_log_element {
 struct gfs2_bitmap {
 	struct buffer_head *bi_bh;
 	char *bi_clone;
-	uint32_t bi_offset;
-	uint32_t bi_start;
-	uint32_t bi_len;
+	u32 bi_offset;
+	u32 bi_start;
+	u32 bi_len;
 };
 
 struct gfs2_rgrpd {
@@ -72,14 +72,14 @@ struct gfs2_rgrpd {
 	struct gfs2_glock *rd_gl;	/* Glock for this rgrp */
 	struct gfs2_rindex rd_ri;
 	struct gfs2_rgrp rd_rg;
-	uint64_t rd_rg_vn;
+	u64 rd_rg_vn;
 	struct gfs2_bitmap *rd_bits;
 	unsigned int rd_bh_count;
 	struct mutex rd_mutex;
-	uint32_t rd_free_clone;
+	u32 rd_free_clone;
 	struct gfs2_log_element rd_le;
-	uint32_t rd_last_alloc_data;
-	uint32_t rd_last_alloc_meta;
+	u32 rd_last_alloc_data;
+	u32 rd_last_alloc_meta;
 	struct gfs2_sbd *rd_sbd;
 };
 
@@ -185,7 +185,7 @@ struct gfs2_glock {
 	char *gl_lvb;
 	atomic_t gl_lvb_count;
 
-	uint64_t gl_vn;
+	u64 gl_vn;
 	unsigned long gl_stamp;
 	void *gl_object;
 
@@ -232,14 +232,14 @@ struct gfs2_inode {
 
 	unsigned long i_flags;		/* GIF_... */
 
-	uint64_t i_vn;
+	u64 i_vn;
 	struct gfs2_dinode i_di; /* To be replaced by ref to block */
 
 	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
 	struct gfs2_alloc i_alloc;
-	uint64_t i_last_rg_alloc;
+	u64 i_last_rg_alloc;
 
 	spinlock_t i_spin;
 	struct rw_semaphore i_rw_mutex;
@@ -277,12 +277,12 @@ struct gfs2_file {
 
 struct gfs2_revoke {
 	struct gfs2_log_element rv_le;
-	uint64_t rv_blkno;
+	u64 rv_blkno;
 };
 
 struct gfs2_revoke_replay {
 	struct list_head rr_list;
-	uint64_t rr_blkno;
+	u64 rr_blkno;
 	unsigned int rr_where;
 };
 
@@ -304,11 +304,11 @@ struct gfs2_quota_data {
 	struct list_head qd_list;
 	unsigned int qd_count;
 
-	uint32_t qd_id;
+	u32 qd_id;
 	unsigned long qd_flags;		/* QDF_... */
 
-	int64_t qd_change;
-	int64_t qd_change_sync;
+	s64 qd_change;
+	s64 qd_change_sync;
 
 	unsigned int qd_slot;
 	unsigned int qd_slot_count;
@@ -320,7 +320,7 @@ struct gfs2_quota_data {
 	struct gfs2_glock *qd_gl;
 	struct gfs2_quota_lvb qd_qb;
 
-	uint64_t qd_sync_gen;
+	u64 qd_sync_gen;
 	unsigned long qd_last_warn;
 	unsigned long qd_last_touched;
 };
@@ -358,7 +358,7 @@ struct gfs2_ail {
 	struct list_head ai_ail1_list;
 	struct list_head ai_ail2_list;
 
-	uint64_t ai_sync_gen;
+	u64 ai_sync_gen;
 };
 
 struct gfs2_jdesc {
@@ -466,20 +466,20 @@ struct gfs2_sbd {
 
 	/* Constants computed on mount */
 
-	uint32_t sd_fsb2bb;
-	uint32_t sd_fsb2bb_shift;
-	uint32_t sd_diptrs;	/* Number of pointers in a dinode */
-	uint32_t sd_inptrs;	/* Number of pointers in a indirect block */
-	uint32_t sd_jbsize;	/* Size of a journaled data block */
-	uint32_t sd_hash_bsize;	/* sizeof(exhash block) */
-	uint32_t sd_hash_bsize_shift;
-	uint32_t sd_hash_ptrs;	/* Number of pointers in a hash block */
-	uint32_t sd_qc_per_block;
-	uint32_t sd_max_dirres;	/* Max blocks needed to add a directory entry */
-	uint32_t sd_max_height;	/* Max height of a file's metadata tree */
-	uint64_t sd_heightsize[GFS2_MAX_META_HEIGHT];
-	uint32_t sd_max_jheight; /* Max height of journaled file's meta tree */
-	uint64_t sd_jheightsize[GFS2_MAX_META_HEIGHT];
+	u32 sd_fsb2bb;
+	u32 sd_fsb2bb_shift;
+	u32 sd_diptrs;	/* Number of pointers in a dinode */
+	u32 sd_inptrs;	/* Number of pointers in a indirect block */
+	u32 sd_jbsize;	/* Size of a journaled data block */
+	u32 sd_hash_bsize;	/* sizeof(exhash block) */
+	u32 sd_hash_bsize_shift;
+	u32 sd_hash_ptrs;	/* Number of pointers in a hash block */
+	u32 sd_qc_per_block;
+	u32 sd_max_dirres;	/* Max blocks needed to add a directory entry */
+	u32 sd_max_height;	/* Max height of a file's metadata tree */
+	u64 sd_heightsize[GFS2_MAX_META_HEIGHT];
+	u32 sd_max_jheight; /* Max height of journaled file's meta tree */
+	u64 sd_jheightsize[GFS2_MAX_META_HEIGHT];
 
 	struct gfs2_args sd_args;	/* Mount arguments */
 	struct gfs2_tune sd_tune;	/* Filesystem tuning structure */
@@ -522,7 +522,7 @@ struct gfs2_sbd {
 
 	/* Resource group stuff */
 
-	uint64_t sd_rindex_vn;
+	u64 sd_rindex_vn;
 	spinlock_t sd_rindex_spin;
 	struct mutex sd_rindex_mutex;
 	struct list_head sd_rindex_list;
@@ -567,7 +567,7 @@ struct gfs2_sbd {
 	unsigned int sd_quota_chunks;
 	unsigned char **sd_quota_bitmap;
 
-	uint64_t sd_quota_sync_gen;
+	u64 sd_quota_sync_gen;
 	unsigned long sd_quota_sync_time;
 
 	/* Log stuff */
@@ -595,7 +595,7 @@ struct gfs2_sbd {
 	unsigned int sd_log_blks_free;
 	struct mutex sd_log_reserve_mutex;
 
-	uint64_t sd_log_sequence;
+	u64 sd_log_sequence;
 	unsigned int sd_log_head;
 	unsigned int sd_log_tail;
 	int sd_log_idle;
@@ -605,11 +605,11 @@ struct gfs2_sbd {
 	struct list_head sd_log_flush_list;
 
 	unsigned int sd_log_flush_head;
-	uint64_t sd_log_flush_wrapped;
+	u64 sd_log_flush_wrapped;
 
 	struct list_head sd_ail1_list;
 	struct list_head sd_ail2_list;
-	uint64_t sd_ail_sync_gen;
+	u64 sd_ail_sync_gen;
 
 	/* Replay stuff */
 

commit e9fc2aa091ab8fa46e60d4c9d06a89305c441652
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Sep 1 11:05:15 2006 -0400

    [GFS2] Update copyright, tidy up incore.h
    
    As per comments from Jan Engelhardt <jengelh@linux01.gwdg.de> this
    updates the copyright message to say "version" in full rather than
    "v.2". Also incore.h has been updated to remove forward structure
    declarations which are not required.
    
    The gfs2_quota_lvb structure has now had endianess annotations added
    to it. Also quota.c has been updated so that we now store the
    lvb data locally in endian independant format to avoid needing
    a structure in host endianess too. As a result the endianess
    conversions are done as required at various points and thus the
    conversion routines in lvb.[ch] are no longer required. I've
    moved the one remaining constant in lvb.h thats used into lm.h
    and removed the unused lvb.[ch].
    
    I have not changed the HIF_ constants. That is left to a later patch
    which I hope will unify the gh_flags and gh_iflags fields of the
    struct gfs2_holder.
    
    Cc: Jan Engelhardt <jengelh@linux01.gwdg.de>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 362c2422d506..06f5ec6ebf7f 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -4,7 +4,7 @@
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
- * of the GNU General Public License v.2.
+ * of the GNU General Public License version 2.
  */
 
 #ifndef __INCORE_DOT_H__
@@ -22,24 +22,12 @@
 
 struct gfs2_log_operations;
 struct gfs2_log_element;
-struct gfs2_bitmap;
-struct gfs2_rgrpd;
-struct gfs2_bufdata;
-struct gfs2_glock_operations;
 struct gfs2_holder;
 struct gfs2_glock;
-struct gfs2_alloc;
-struct gfs2_inode;
-struct gfs2_file;
-struct gfs2_revoke;
-struct gfs2_revoke_replay;
 struct gfs2_quota_data;
-struct gfs2_log_buf;
 struct gfs2_trans;
 struct gfs2_ail;
 struct gfs2_jdesc;
-struct gfs2_args;
-struct gfs2_tune;
 struct gfs2_gl_hash_bucket;
 struct gfs2_sbd;
 
@@ -215,8 +203,8 @@ struct gfs2_glock {
 struct gfs2_alloc {
 	/* Quota stuff */
 
-	struct gfs2_quota_data *al_qd[4];
-	struct gfs2_holder al_qd_ghs[4];
+	struct gfs2_quota_data *al_qd[2*MAXQUOTAS];
+	struct gfs2_holder al_qd_ghs[2*MAXQUOTAS];
 	unsigned int al_qd_num;
 
 	u32 al_requested; /* Filled in by caller of gfs2_inplace_reserve() */
@@ -305,11 +293,11 @@ enum {
 };
 
 struct gfs2_quota_lvb {
-        uint32_t qb_magic;
-        uint32_t __pad;
-        uint64_t qb_limit;      /* Hard limit of # blocks to alloc */
-        uint64_t qb_warn;       /* Warn user when alloc is above this # */
-        int64_t qb_value;       /* Current # blocks allocated */
+        __be32 qb_magic;
+        u32 __pad;
+        __be64 qb_limit;      /* Hard limit of # blocks to alloc */
+        __be64 qb_warn;       /* Warn user when alloc is above this # */
+        __be64 qb_value;       /* Current # blocks allocated */
 };
 
 struct gfs2_quota_data {

commit 5e2b0613ed9f9641937dd5948051631249447c57
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 30 09:38:30 2006 -0400

    [GFS2] Remove unused code from glock layer
    
    Remove the unused sync feature from glocks. This is currently done by
    calling the required functions to sync pages/blocks directly so this
    code isn't needed.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 38098ac292af..362c2422d506 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -167,7 +167,6 @@ enum {
 	GLF_LOCK		= 1,
 	GLF_STICKY		= 2,
 	GLF_PREFETCH		= 3,
-	GLF_SYNC		= 4,
 	GLF_DIRTY		= 5,
 	GLF_SKIP_WAITERS2	= 6,
 	GLF_GREEDY		= 7,

commit 8fb4b536e7b9dbaf7a6b8204e887b92a14e4352c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Aug 30 09:30:00 2006 -0400

    [GFS2] Make glock operations const
    
    For all the usual reasons of enforcing correctness and potentially
    reducing code size, this patch makes the glock operations const.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 77f0903d2f3e..38098ac292af 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -130,7 +130,7 @@ struct gfs2_glock_operations {
 	void (*go_unlock) (struct gfs2_holder * gh);
 	void (*go_callback) (struct gfs2_glock * gl, unsigned int state);
 	void (*go_greedy) (struct gfs2_glock * gl);
-	int go_type;
+	const int go_type;
 };
 
 enum {
@@ -189,7 +189,7 @@ struct gfs2_glock {
 	struct list_head gl_waiters2;	/* HIF_DEMOTE, HIF_GREEDY */
 	struct list_head gl_waiters3;	/* HIF_PROMOTE */
 
-	struct gfs2_glock_operations *gl_ops;
+	const struct gfs2_glock_operations *gl_ops;
 
 	struct gfs2_holder *gl_req_gh;
 	gfs2_glop_bh_t gl_req_bh;

commit 8638460540749ddb1beca9e9a68d655a6fe6df65
Author: Abhijith Das <adas@redhat.com>
Date:   Fri Aug 25 11:13:37 2006 -0500

    [GFS2] Allow mounting of gfs2 and gfs2meta at the same time
    
    This patch allows the simultaneous mounting of gfs2meta and gfs2
    filesystems. A restriction however is that a gfs2meta fs may only be
    mounted if its corresponding gfs2 filesystem is also mounted. Also, a
    gfs2 filesystem cannot be unmounted before its gfs2meta filesystem.
    
    Signed-off-by: Abhijith Das <adas@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 78d3cb511eb8..77f0903d2f3e 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -472,6 +472,7 @@ enum {
 
 struct gfs2_sbd {
 	struct super_block *sd_vfs;
+	struct super_block *sd_vfs_meta;
 	struct kobject sd_kobj;
 	unsigned long sd_flags;	/* SDF_... */
 	struct gfs2_sb sd_sb;
@@ -652,6 +653,7 @@ struct gfs2_sbd {
 	/* Debugging crud */
 
 	unsigned long sd_last_warning;
+	struct vfsmount *sd_gfs2mnt;
 };
 
 #endif /* __INCORE_DOT_H__ */

commit a2242db0906445491d9ac50bfa756b0de0a25d45
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Aug 24 17:03:05 2006 -0400

    [GFS2] Speed up scanning of glocks
    
    I noticed the gfs2_scand seemed to be taking a lot of CPU,
    so in order to cut that down a bit, here is a patch. Firstly
    the type of a glock is a constant during its lifetime, so that
    its possible to check this without needing locking. I've moved
    the (common) case of testing for an inode glock outside of
    the glmutex lock.
    
    Also there was a mutex left over from when the glock cache was
    master of the inode cache. That isn't required any more so I've
    removed that too.
    
    There is probably scope for further speed ups in the future
    in this area.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e98c14f30daa..78d3cb511eb8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -507,7 +507,6 @@ struct gfs2_sbd {
 	struct gfs2_holder sd_live_gh;
 	struct gfs2_glock *sd_rename_gl;
 	struct gfs2_glock *sd_trans_gl;
-	struct mutex sd_invalidate_inodes_mutex;
 
 	/* Inode Stuff */
 

commit 59a1cc6bdabf5ed148b48808ad1a418d87f5e6bf
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Aug 4 15:41:22 2006 -0400

    [GFS2] Fix lock ordering bug in page fault path
    
    Mmapped files were able to trigger a lock ordering bug. Private
    maps do not need to take the glock so early on. Shared maps do
    unfortunately, however we can get around that by adding a flag
    into the flags for the struct gfs2_file. This only works because
    we are taking an exclusive lock at this point, so we know that
    nobody else can be racing with us.
    
    Fixes Red Hat bugzilla: #201196
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 90e0624d8065..e98c14f30daa 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -279,6 +279,7 @@ static inline struct gfs2_sbd *GFS2_SB(struct inode *inode)
 
 enum {
 	GFF_DID_DIRECT_ALLOC	= 0,
+	GFF_EXLOCK = 1,
 };
 
 struct gfs2_file {

commit bdd512aeeab860f7a9a537142dd0983f884d723a
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu Jun 22 15:26:33 2006 -0400

    [GFS2] Remove unused flag
    
    The flag GIF_MIN_INIT is no longer used or required.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 034a855a14bb..90e0624d8065 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -234,7 +234,6 @@ struct gfs2_alloc {
 };
 
 enum {
-	GIF_MIN_INIT		= 0,
 	GIF_QD_LOCKED		= 1,
 	GIF_PAGED		= 2,
 	GIF_SW_PAGED		= 3,

commit 695165dfba5204791bc4ae8911ed8b6326ce6d91
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Jun 20 13:44:27 2006 +0100

    [GFS2] Fix use of bitops on unsigned int (struct gfs2_holder->gh_iflags)
    
    fs/gfs2/glock.c: In function ‘gfs2_holder_get’:
    fs/gfs2/glock.c:439: warning: passing argument 2 of ‘set_bit’ from incompatible pointer type
    fs/gfs2/glock.c: In function ‘rq_promote’:
    fs/gfs2/glock.c:512: warning: passing argument 2 of ‘set_bit’ from incompatible pointer type
    fs/gfs2/glock.c:526: warning: passing argument 2 of ‘set_bit’ from incompatible pointer type
     ...
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 9a67a5954126..034a855a14bb 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -157,7 +157,7 @@ struct gfs2_holder {
 	unsigned gh_flags;
 
 	int gh_error;
-	unsigned gh_iflags;
+	unsigned long gh_iflags;
 	struct completion gh_wait;
 	unsigned long gh_ip;
 };

commit feaa7bba026c181ce071d5a4884f7f9dd26207a1
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Jun 14 15:32:57 2006 -0400

    [GFS2] Fix unlinked file handling
    
    This patch fixes the way we have been dealing with unlinked,
    but still open files. It removes all limits (other than memory
    for inodes, as per every other filesystem) on numbers of these
    which we can support on GFS2. It also means that (like other
    fs) its the responsibility of the last process to close the file
    to deallocate the storage, rather than the person who did the
    unlinking. Note that with GFS2, those two events might take place
    on different nodes.
    
    Also there are a number of other changes:
    
     o We use the Linux inode subsystem as it was intended to be
    used, wrt allocating GFS2 inodes
     o The Linux inode cache is now the point which we use for
    local enforcement of only holding one copy of the inode in
    core at once (previous to this we used the glock layer).
     o We no longer use the unlinked "special" file. We just ignore it
    completely. This makes unlinking more efficient.
     o We now use the 4th block allocation state. The previously unused
    state is used to track unlinked but still open inodes.
     o gfs2_inoded is no longer needed
     o Several fields are now no longer needed (and removed) from the in
    core struct gfs2_inode
     o Several fields are no longer needed (and removed) from the in core
    superblock
    
    There are a number of future possible optimisations and clean ups
    which have been made possible by this patch.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 8caefec88854..9a67a5954126 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -33,7 +33,6 @@ struct gfs2_inode;
 struct gfs2_file;
 struct gfs2_revoke;
 struct gfs2_revoke_replay;
-struct gfs2_unlinked;
 struct gfs2_quota_data;
 struct gfs2_log_buf;
 struct gfs2_trans;
@@ -245,16 +244,12 @@ struct gfs2_inode {
 	struct inode i_inode;
 	struct gfs2_inum i_num;
 
-	atomic_t i_count;
 	unsigned long i_flags;		/* GIF_... */
 
 	uint64_t i_vn;
-	struct gfs2_dinode i_di;
-
-	struct gfs2_glock *i_gl;
-	struct gfs2_sbd *i_sbd;
-	struct inode *i_vnode;
+	struct gfs2_dinode i_di; /* To be replaced by ref to block */
 
+	struct gfs2_glock *i_gl; /* Move into i_gh? */
 	struct gfs2_holder i_iopen_gh;
 	struct gfs2_holder i_gh; /* for prepare/commit_write only */
 	struct gfs2_alloc i_alloc;
@@ -262,18 +257,27 @@ struct gfs2_inode {
 
 	spinlock_t i_spin;
 	struct rw_semaphore i_rw_mutex;
-
 	unsigned int i_greedy;
 	unsigned long i_last_pfault;
 
 	struct buffer_head *i_cache[GFS2_MAX_META_HEIGHT];
 };
 
+/*
+ * Since i_inode is the first element of struct gfs2_inode,
+ * this is effectively a cast.
+ */
 static inline struct gfs2_inode *GFS2_I(struct inode *inode)
 {
 	return container_of(inode, struct gfs2_inode, i_inode);
 }
 
+/* To be removed? */
+static inline struct gfs2_sbd *GFS2_SB(struct inode *inode)
+{
+	return inode->i_sb->s_fs_info;
+}
+
 enum {
 	GFF_DID_DIRECT_ALLOC	= 0,
 };
@@ -295,18 +299,6 @@ struct gfs2_revoke_replay {
 	unsigned int rr_where;
 };
 
-enum {
-	ULF_LOCKED		= 0,
-};
-
-struct gfs2_unlinked {
-	struct list_head ul_list;
-	unsigned int ul_count;
-	struct gfs2_unlinked_tag ul_ut;
-	unsigned long ul_flags;		/* ULF_... */
-	unsigned int ul_slot;
-};
-
 enum {
 	QDF_USER		= 0,
 	QDF_CHANGE		= 1,
@@ -436,7 +428,6 @@ struct gfs2_tune {
 	unsigned int gt_recoverd_secs;
 	unsigned int gt_logd_secs;
 	unsigned int gt_quotad_secs;
-	unsigned int gt_inoded_secs;
 
 	unsigned int gt_quota_simul_sync; /* Max quotavals to sync at once */
 	unsigned int gt_quota_warn_period; /* Secs between quota warn msgs */
@@ -495,7 +486,6 @@ struct gfs2_sbd {
 	uint32_t sd_hash_bsize;	/* sizeof(exhash block) */
 	uint32_t sd_hash_bsize_shift;
 	uint32_t sd_hash_ptrs;	/* Number of pointers in a hash block */
-	uint32_t sd_ut_per_block;
 	uint32_t sd_qc_per_block;
 	uint32_t sd_max_dirres;	/* Max blocks needed to add a directory entry */
 	uint32_t sd_max_height;	/* Max height of a file's metadata tree */
@@ -527,7 +517,6 @@ struct gfs2_sbd {
 	struct inode *sd_statfs_inode;
 	struct inode *sd_ir_inode;
 	struct inode *sd_sc_inode;
-	struct inode *sd_ut_inode;
 	struct inode *sd_qc_inode;
 	struct inode *sd_rindex;
 	struct inode *sd_quota_inode;
@@ -569,7 +558,6 @@ struct gfs2_sbd {
 
 	struct gfs2_holder sd_ir_gh;
 	struct gfs2_holder sd_sc_gh;
-	struct gfs2_holder sd_ut_gh;
 	struct gfs2_holder sd_qc_gh;
 
 	/* Daemon stuff */
@@ -578,21 +566,9 @@ struct gfs2_sbd {
 	struct task_struct *sd_recoverd_process;
 	struct task_struct *sd_logd_process;
 	struct task_struct *sd_quotad_process;
-	struct task_struct *sd_inoded_process;
 	struct task_struct *sd_glockd_process[GFS2_GLOCKD_MAX];
 	unsigned int sd_glockd_num;
 
-	/* Unlinked inode stuff */
-
-	struct list_head sd_unlinked_list;
-	atomic_t sd_unlinked_count;
-	spinlock_t sd_unlinked_spin;
-	struct mutex sd_unlinked_mutex;
-
-	unsigned int sd_unlinked_slots;
-	unsigned int sd_unlinked_chunks;
-	unsigned char **sd_unlinked_bitmap;
-
 	/* Quota stuff */
 
 	struct list_head sd_quota_list;

commit 6b61b072a8b54212ab0808c443e5c16699390d25
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jun 6 14:49:39 2006 -0400

    [GFS2] Move some fields around to reduce wasted space
    
    We can reclaim some space by moving fields in some structures
    in order to allow them to pack better on 64 bit architectures.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 92091d006a02..8caefec88854 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -158,7 +158,7 @@ struct gfs2_holder {
 	unsigned gh_flags;
 
 	int gh_error;
-	unsigned long gh_iflags;
+	unsigned gh_iflags;
 	struct completion gh_wait;
 	unsigned long gh_ip;
 };
@@ -217,25 +217,21 @@ struct gfs2_glock {
 struct gfs2_alloc {
 	/* Quota stuff */
 
-	unsigned int al_qd_num;
 	struct gfs2_quota_data *al_qd[4];
 	struct gfs2_holder al_qd_ghs[4];
+	unsigned int al_qd_num;
 
-	/* Filled in by the caller to gfs2_inplace_reserve() */
-
-	uint32_t al_requested;
+	u32 al_requested; /* Filled in by caller of gfs2_inplace_reserve() */
+	u32 al_alloced; /* Filled in by gfs2_alloc_*() */
 
 	/* Filled in by gfs2_inplace_reserve() */
 
-	char *al_file;
 	unsigned int al_line;
+	char *al_file;
 	struct gfs2_holder al_ri_gh;
 	struct gfs2_holder al_rgd_gh;
 	struct gfs2_rgrpd *al_rgd;
 
-	/* Filled in by gfs2_alloc_*() */
-
-	uint32_t al_alloced;
 };
 
 enum {

commit 320dd101e2d595a03439adb92b319f3af53dd1d0
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu May 18 16:25:27 2006 -0400

    [GFS2] glock debugging and inode cache changes
    
    This adds some extra debugging to glock.c and changes
    inode.c's deallocation code to call the debugging code
    at a suitable moment. I'm chasing down a particular bug
    to do with deallocation at the moment and the code can
    go again once the bug is fixed.
    
    Also this includes the first part of some changes to unify
    the Linux struct inode and GFS2's struct gfs2_inode. This
    transformation will happen in small parts over the next short
    period.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index fc4a983e3c89..92091d006a02 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -183,6 +183,8 @@ struct gfs2_glock {
 	spinlock_t gl_spin;
 
 	unsigned int gl_state;
+	struct task_struct *gl_owner;
+	unsigned long gl_ip;
 	struct list_head gl_holders;
 	struct list_head gl_waiters1;	/* HIF_MUTEX */
 	struct list_head gl_waiters2;	/* HIF_DEMOTE, HIF_GREEDY */
@@ -244,6 +246,7 @@ enum {
 };
 
 struct gfs2_inode {
+	struct inode i_inode;
 	struct gfs2_inum i_num;
 
 	atomic_t i_count;
@@ -270,6 +273,11 @@ struct gfs2_inode {
 	struct buffer_head *i_cache[GFS2_MAX_META_HEIGHT];
 };
 
+static inline struct gfs2_inode *GFS2_I(struct inode *inode)
+{
+	return container_of(inode, struct gfs2_inode, i_inode);
+}
+
 enum {
 	GFF_DID_DIRECT_ALLOC	= 0,
 };

commit 3a8a9a1034813aa99f5ae3150f652d490c5ff10d
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Thu May 18 15:09:15 2006 -0400

    [GFS2] Update copyright date to 2006
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 84dd2f579e62..fc4a983e3c89 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
- * Copyright (C) 2004-2005 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions

commit 5965b1f4792a1a9364b4e1ed6be8778a50eb981b
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Apr 26 13:21:55 2006 -0400

    [GFS2] Don't do recursive locking in glock layer
    
    This patch changes the last user of recursive locking so that
    it no longer needs this feature and removes it from the glock
    layer. This makes the glock code a lot simpler and easier to
    understand. Its also a prerequsite to adding support for the
    AOP_TRUNCATED_PAGE return code (or at least it is if you don't
    want your brain to melt in the process)
    
    I've left in a couple of checks just in case there is some place
    else in the code which is still using this feature that I didn't
    spot yet, but they can probably be removed long term.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 761f00153d43..84dd2f579e62 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -146,7 +146,6 @@ enum {
 	HIF_DEALLOC		= 5,
 	HIF_HOLDER		= 6,
 	HIF_FIRST		= 7,
-	HIF_RECURSE		= 8,
 	HIF_ABORTED		= 9,
 };
 

commit fe1bdedc6c16adedc6fd3636185ea91596b1d6eb
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Apr 18 10:09:15 2006 -0400

    [GFS2] Use vmalloc() in dir code
    
    When allocating memory to sort directory entries, use vmalloc()
    rather than kmalloc() since for larger directories, the required
    size can easily be graeter than the 128k maximum of kmalloc().
    
    Also adding the first steps towards getting the AOP_TRUNCATED_PAGE
    return code get in the glock code by flagging all places where we
    request a glock and we are holding a page lock.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index dfed83b37ab7..761f00153d43 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -156,7 +156,7 @@ struct gfs2_holder {
 	struct gfs2_glock *gh_gl;
 	struct task_struct *gh_owner;
 	unsigned int gh_state;
-	int gh_flags;
+	unsigned gh_flags;
 
 	int gh_error;
 	unsigned long gh_iflags;

commit b09e593d799560f1a0782c20ac5900058390a26f
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Fri Apr 7 11:17:32 2006 -0400

    [GFS2] Fix a ref count bug and other clean ups
    
    This fixes a ref count bug that sometimes showed up a umount time
    (causing it to hang) but it otherwise mostly harmless. At the same
    time there are some clean ups including making the log operations
    structures const, moving a memory allocation so that its not done
    in the fast path of checking to see if there is an outstanding
    transaction related to a particular glock.
    
    Removes the sd_log_wrap varaible which was updated, but never actually
    used anywhere. Updates the gfs2 ioctl() to run without the kernel lock
    (which it never needed anyway). Removes the "invalidate inodes" loop
    from GFS2's put_super routine. This is done in kill super anyway so
    we don't need to do it here. The loop was also bogus in that if there
    are any inodes "stuck" at this point its a bug and we need to know
    about it rather than hide it by hanging forever.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 423cfa72b4c7..dfed83b37ab7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -62,12 +62,12 @@ struct gfs2_log_operations {
 				 struct gfs2_log_descriptor *ld, __be64 *ptr,
 				 int pass);
 	void (*lo_after_scan) (struct gfs2_jdesc *jd, int error, int pass);
-	char *lo_name;
+	const char *lo_name;
 };
 
 struct gfs2_log_element {
 	struct list_head le_list;
-	struct gfs2_log_operations *le_ops;
+	const struct gfs2_log_operations *le_ops;
 };
 
 struct gfs2_bitmap {
@@ -618,6 +618,7 @@ struct gfs2_sbd {
 	unsigned int sd_log_num_rg;
 	unsigned int sd_log_num_databuf;
 	unsigned int sd_log_num_jdata;
+	unsigned int sd_log_num_hdrs;
 
 	struct list_head sd_log_le_gl;
 	struct list_head sd_log_le_buf;
@@ -631,7 +632,6 @@ struct gfs2_sbd {
 	uint64_t sd_log_sequence;
 	unsigned int sd_log_head;
 	unsigned int sd_log_tail;
-	uint64_t sd_log_wraps;
 	int sd_log_idle;
 
 	unsigned long sd_log_flush_time;

commit 55eccc6d00cea224bf634d44e9871cfe83200ff2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Apr 4 14:29:30 2006 -0400

    [GFS2] Finish off ioctl support
    
    This puts the finishing touches to the ioctl support and also
    removes a couple of unused fields from GFS2's private per file
    structure.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index b5a994d1b5f7..423cfa72b4c7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -277,12 +277,8 @@ enum {
 
 struct gfs2_file {
 	unsigned long f_flags;		/* GFF_... */
-
 	struct mutex f_fl_mutex;
 	struct gfs2_holder f_fl_gh;
-
-	struct gfs2_inode *f_inode;
-	struct file *f_vfile;
 };
 
 struct gfs2_revoke {

commit d0dc80dbafb5c10ad2084831a61bbf945484a139
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Mar 29 14:36:49 2006 -0500

    [GFS2] Update debugging code
    
    Update the debugging code in trans.c and at the same time improve
    the debugging code for gfs2_holders. The new code should be pretty
    fast during the normal case and provide just as much information
    in case of errors (or more).
    
    One small function from glock.c has moved to glock.h as a static inline so
    that its return address won't get in the way of the debugging.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 35163b562460..b5a994d1b5f7 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -161,6 +161,7 @@ struct gfs2_holder {
 	int gh_error;
 	unsigned long gh_iflags;
 	struct completion gh_wait;
+	unsigned long gh_ip;
 };
 
 enum {
@@ -353,8 +354,7 @@ struct gfs2_log_buf {
 };
 
 struct gfs2_trans {
-	char *tr_file;
-	unsigned int tr_line;
+	unsigned long tr_ip;
 
 	unsigned int tr_blocks;
 	unsigned int tr_revokes;

commit 484adff8a06cb5d952832f5487ae863f54c0fb69
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Mar 29 09:12:12 2006 -0500

    [GFS2] Update locking in log.c
    
    Replace the lock_for_trans()/lock_for_flush() functions with an rwsem.
    In fact the sd_log_flush_lock becomes an rwsem (the write part of it)
    and is extended slightly to cover everything that the lock_for_flush()
    used to cover. The read part of the lock is instead of lock_for_trans().
    
    This corrects the races in the original code and reduces the code size.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index be307185f492..35163b562460 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -611,10 +611,6 @@ struct gfs2_sbd {
 	/* Log stuff */
 
 	spinlock_t sd_log_lock;
-	atomic_t sd_log_trans_count;
-	wait_queue_head_t sd_log_trans_wq;
-	atomic_t sd_log_flush_count;
-	wait_queue_head_t sd_log_flush_wq;
 
 	unsigned int sd_log_blks_reserved;
 	unsigned int sd_log_commited_buf;
@@ -643,7 +639,7 @@ struct gfs2_sbd {
 	int sd_log_idle;
 
 	unsigned long sd_log_flush_time;
-	struct mutex sd_log_flush_lock;
+	struct rw_semaphore sd_log_flush_lock;
 	struct list_head sd_log_flush_list;
 
 	unsigned int sd_log_flush_head;

commit 71b86f562b5eb6f94ea00bba060caa64d0137969
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Mar 28 14:14:04 2006 -0500

    [GFS2] Further updates to dir and logging code
    
    This reduces the size of the directory code by about 3k and gets
    readdir() to use the functions which were introduced in the previous
    directory code update.
    
    Two memory allocations are merged into one. Eliminates zeroing of some
    buffers which were never used before they were initialised by
    other data.
    
    There is still scope for further improvement in the directory code.
    
    On the logging side, a hand created mutex has been replaced by a
    standard Linux mutex in the log allocation code.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 62f109e553c4..be307185f492 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -634,8 +634,7 @@ struct gfs2_sbd {
 	struct list_head sd_log_le_databuf;
 
 	unsigned int sd_log_blks_free;
-	struct list_head sd_log_blks_list;
-	wait_queue_head_t sd_log_blks_wait;
+	struct mutex sd_log_reserve_mutex;
 
 	uint64_t sd_log_sequence;
 	unsigned int sd_log_head;

commit c9fd43078f5007c6ca6b3a9cd04c51a8f0e44a20
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Mar 1 15:31:02 2006 -0500

    [GFS2] Tidy up mount code.
    
    We no longer lookup ".gfs2_admin" in the root directory in order to
    find it, but instead use the inode number given in the superblock.
    Both the root directory and the admin directory are now looked up using
    the same routine, so the redundant code is removed.
    
    Also, there is no longer a reference to the root inode in the
    GFS2 super block. When required this can be retreived via
    sb->s_root->d_inode instead.
    
    Assuming that we introduce a metadata filesystem type for GFS, then
    this is a first step towards that goal.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index c741016d07dc..62f109e553c4 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -532,7 +532,6 @@ struct gfs2_sbd {
 	struct inode *sd_qc_inode;
 	struct inode *sd_rindex;
 	struct inode *sd_quota_inode;
-	struct inode *sd_root_dir;
 
 	/* Inum stuff */
 

commit e317ffcb7cc26c5e80cab97160a5e2761a4436ec
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Wed Mar 1 11:39:37 2006 -0500

    [GFS2] Remove uneeded memory allocation
    
    For every filesystem operation where we need a transaction, we
    now make one less memory allocation.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 2443e9aad598..c741016d07dc 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -360,7 +360,7 @@ struct gfs2_trans {
 	unsigned int tr_revokes;
 	unsigned int tr_reserved;
 
-	struct gfs2_holder *tr_t_gh;
+	struct gfs2_holder tr_t_gh;
 
 	int tr_touched;
 

commit 5c676f6d359b0404d53f542f02e1359583cb2895
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Feb 27 17:23:27 2006 -0500

    [GFS2] Macros removal in gfs2.h
    
    As suggested by Pekka Enberg <penberg@cs.helsinki.fi>.
    
    The DIV_RU macro is renamed DIV_ROUND_UP and and moved to kernel.h
    The other macros are gone from gfs2.h as (although not requested
    by Pekka Enberg) are a number of included header file which are now
    included individually. The inode number comparison function is
    now an inline function.
    
    The DT2IF and IF2DT may be addressed in a future patch.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 0e550e8e5be3..2443e9aad598 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -313,6 +313,14 @@ enum {
 	QDF_LOCKED		= 2,
 };
 
+struct gfs2_quota_lvb {
+        uint32_t qb_magic;
+        uint32_t __pad;
+        uint64_t qb_limit;      /* Hard limit of # blocks to alloc */
+        uint64_t qb_warn;       /* Warn user when alloc is above this # */
+        int64_t qb_value;       /* Current # blocks allocated */
+};
+
 struct gfs2_quota_data {
 	struct list_head qd_list;
 	unsigned int qd_count;

commit 6a6b3d018f4781f108d170f2181281a3c5589dc8
Author: David Teigland <teigland@redhat.com>
Date:   Thu Feb 23 10:11:47 2006 +0000

    [GFS2] Patch to remove stats gathering from GFS2
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 7fe422537ff0..0e550e8e5be3 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -667,27 +667,7 @@ struct gfs2_sbd {
 	atomic_t sd_glock_count;
 	atomic_t sd_glock_held_count;
 	atomic_t sd_inode_count;
-	atomic_t sd_bufdata_count;
-
-	atomic_t sd_fh2dentry_misses;
 	atomic_t sd_reclaimed;
-	atomic_t sd_log_flush_incore;
-	atomic_t sd_log_flush_ondisk;
-
-	atomic_t sd_glock_nq_calls;
-	atomic_t sd_glock_dq_calls;
-	atomic_t sd_glock_prefetch_calls;
-	atomic_t sd_lm_lock_calls;
-	atomic_t sd_lm_unlock_calls;
-	atomic_t sd_lm_callbacks;
-
-	atomic_t sd_ops_address;
-	atomic_t sd_ops_dentry;
-	atomic_t sd_ops_export;
-	atomic_t sd_ops_file;
-	atomic_t sd_ops_inode;
-	atomic_t sd_ops_super;
-	atomic_t sd_ops_vm;
 
 	char sd_fsname[GFS2_FSNAME_LEN];
 	char sd_table_name[GFS2_FSNAME_LEN];

commit f55ab26a8f92a23988c3e6da28dae4741933a4e2
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Feb 21 12:51:39 2006 +0000

    [GFS2] Use mutices rather than semaphores
    
    As well as a number of minor bug fixes, this patch changes GFS
    to use mutices rather than semaphores. This results in better
    information in case there are any locking problems.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index e43a0475d0d8..7fe422537ff0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -88,7 +88,7 @@ struct gfs2_rgrpd {
 	uint64_t rd_rg_vn;
 	struct gfs2_bitmap *rd_bits;
 	unsigned int rd_bh_count;
-	struct semaphore rd_mutex;
+	struct mutex rd_mutex;
 	uint32_t rd_free_clone;
 	struct gfs2_log_element rd_le;
 	uint32_t rd_last_alloc_data;
@@ -277,7 +277,7 @@ enum {
 struct gfs2_file {
 	unsigned long f_flags;		/* GFF_... */
 
-	struct semaphore f_fl_mutex;
+	struct mutex f_fl_mutex;
 	struct gfs2_holder f_fl_gh;
 
 	struct gfs2_inode *f_inode;
@@ -510,7 +510,7 @@ struct gfs2_sbd {
 	struct gfs2_holder sd_live_gh;
 	struct gfs2_glock *sd_rename_gl;
 	struct gfs2_glock *sd_trans_gl;
-	struct semaphore sd_invalidate_inodes_mutex;
+	struct mutex sd_invalidate_inodes_mutex;
 
 	/* Inode Stuff */
 
@@ -528,12 +528,12 @@ struct gfs2_sbd {
 
 	/* Inum stuff */
 
-	struct semaphore sd_inum_mutex;
+	struct mutex sd_inum_mutex;
 
 	/* StatFS stuff */
 
 	spinlock_t sd_statfs_spin;
-	struct semaphore sd_statfs_mutex;
+	struct mutex sd_statfs_mutex;
 	struct gfs2_statfs_change sd_statfs_master;
 	struct gfs2_statfs_change sd_statfs_local;
 	unsigned long sd_statfs_sync_time;
@@ -542,7 +542,7 @@ struct gfs2_sbd {
 
 	uint64_t sd_rindex_vn;
 	spinlock_t sd_rindex_spin;
-	struct semaphore sd_rindex_mutex;
+	struct mutex sd_rindex_mutex;
 	struct list_head sd_rindex_list;
 	struct list_head sd_rindex_mru_list;
 	struct list_head sd_rindex_recent_list;
@@ -553,7 +553,7 @@ struct gfs2_sbd {
 
 	struct list_head sd_jindex_list;
 	spinlock_t sd_jindex_spin;
-	struct semaphore sd_jindex_mutex;
+	struct mutex sd_jindex_mutex;
 	unsigned int sd_journals;
 	unsigned long sd_jindex_refresh_time;
 
@@ -581,7 +581,7 @@ struct gfs2_sbd {
 	struct list_head sd_unlinked_list;
 	atomic_t sd_unlinked_count;
 	spinlock_t sd_unlinked_spin;
-	struct semaphore sd_unlinked_mutex;
+	struct mutex sd_unlinked_mutex;
 
 	unsigned int sd_unlinked_slots;
 	unsigned int sd_unlinked_chunks;
@@ -592,7 +592,7 @@ struct gfs2_sbd {
 	struct list_head sd_quota_list;
 	atomic_t sd_quota_count;
 	spinlock_t sd_quota_spin;
-	struct semaphore sd_quota_mutex;
+	struct mutex sd_quota_mutex;
 
 	unsigned int sd_quota_slots;
 	unsigned int sd_quota_chunks;
@@ -637,7 +637,7 @@ struct gfs2_sbd {
 	int sd_log_idle;
 
 	unsigned long sd_log_flush_time;
-	struct semaphore sd_log_flush_lock;
+	struct mutex sd_log_flush_lock;
 	struct list_head sd_log_flush_list;
 
 	unsigned int sd_log_flush_head;
@@ -659,7 +659,7 @@ struct gfs2_sbd {
 	/* For quiescing the filesystem */
 
 	struct gfs2_holder sd_freeze_gh;
-	struct semaphore sd_freeze_lock;
+	struct mutex sd_freeze_lock;
 	unsigned int sd_freeze_count;
 
 	/* Counters */

commit 7359a19cc758946aba0e45233b8641256b194884
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Feb 13 12:27:43 2006 +0000

    [GFS2] Fix for root inode ref count bug
    
    Umount is now working correctly again. The bug was due to
    not getting an extra ref count when mounting the fs. We
    should have bumped it by two (once for the internal pointer
    to the root inode from the super block and once for the
    inode hanging off the dcache entry for root).
    
    Also this patch tidys up the code dealing with looking up
    and creating inodes. We now pass Linux inodes (with gfs2_inodes
    attached) rather than the other way around and this reduces code
    duplication in various places.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index d1954e2bb908..e43a0475d0d8 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -378,7 +378,7 @@ struct gfs2_ail {
 struct gfs2_jdesc {
 	struct list_head jd_list;
 
-	struct gfs2_inode *jd_inode;
+	struct inode *jd_inode;
 	unsigned int jd_jid;
 	int jd_dirty;
 

commit f42faf4fa4eaf7e108dd60f3f2ca5c6e9b45352c
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Jan 30 18:34:10 2006 +0000

    [GFS2] Add gfs2_internal_read()
    
    Add the new external read function. Its temporarily in jdata.c
    even though the protoype is in ops_file.h - this will change
    shortly. The current implementation will change to a page cache
    one when that happens.
    
    In order to effect the above changes, the various internal inodes
    now have Linux inodes attached to them. We keep the references to
    the Linux inodes, rather than the gfs2_inodes in the super block.
    
    In order to get everything to work correctly I've had to reorder
    the init sequence on mount (which I should probably have done
    earlier when .gfs2_admin was made visible).
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3bc40ff5fdf9..d1954e2bb908 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -98,10 +98,13 @@ struct gfs2_rgrpd {
 
 enum gfs2_state_bits {
 	BH_Pinned = BH_PrivateStart,
+	BH_Escaped = BH_PrivateStart + 1,
 };
 
 BUFFER_FNS(Pinned, pinned)
 TAS_BUFFER_FNS(Pinned, pinned)
+BUFFER_FNS(Escaped, escaped)
+TAS_BUFFER_FNS(Escaped, escaped)
 
 struct gfs2_bufdata {
 	struct buffer_head *bd_bh;
@@ -254,7 +257,7 @@ struct gfs2_inode {
 	struct inode *i_vnode;
 
 	struct gfs2_holder i_iopen_gh;
-
+	struct gfs2_holder i_gh; /* for prepare/commit_write only */
 	struct gfs2_alloc i_alloc;
 	uint64_t i_last_rg_alloc;
 
@@ -511,17 +514,17 @@ struct gfs2_sbd {
 
 	/* Inode Stuff */
 
-	struct gfs2_inode *sd_master_dir;
-	struct gfs2_inode *sd_jindex;
-	struct gfs2_inode *sd_inum_inode;
-	struct gfs2_inode *sd_statfs_inode;
-	struct gfs2_inode *sd_ir_inode;
-	struct gfs2_inode *sd_sc_inode;
-	struct gfs2_inode *sd_ut_inode;
-	struct gfs2_inode *sd_qc_inode;
-	struct gfs2_inode *sd_rindex;
-	struct gfs2_inode *sd_quota_inode;
-	struct gfs2_inode *sd_root_dir;
+	struct inode *sd_master_dir;
+	struct inode *sd_jindex;
+	struct inode *sd_inum_inode;
+	struct inode *sd_statfs_inode;
+	struct inode *sd_ir_inode;
+	struct inode *sd_sc_inode;
+	struct inode *sd_ut_inode;
+	struct inode *sd_qc_inode;
+	struct inode *sd_rindex;
+	struct inode *sd_quota_inode;
+	struct inode *sd_root_dir;
 
 	/* Inum stuff */
 
@@ -615,6 +618,8 @@ struct gfs2_sbd {
 	unsigned int sd_log_num_revoke;
 	unsigned int sd_log_num_rg;
 	unsigned int sd_log_num_databuf;
+	unsigned int sd_log_num_jdata;
+
 	struct list_head sd_log_le_gl;
 	struct list_head sd_log_le_buf;
 	struct list_head sd_log_le_revoke;

commit 64fb4eb7d4cc9de89f4d9b9061adde46ed3b5641
Author: Steven Whitehouse <steve@chygwyn.com>
Date:   Wed Jan 18 13:14:40 2006 +0000

    [GFS2] Remove gfs2_databuf in favour of gfs2_bufdata structure
    
    Removing the gfs2_databuf structure and using gfs2_bufdata instead
    is a step towards allowing journaling of data without requiring the
    metadata header on each journaled block. The idea is to merge the
    code paths for ordered data with that of journaled data, with the
    log operations in lops.c tacking account of the different types of
    buffers as they are presented to it. Largely the code path for
    metadata will be similar too, but obviously through a different set
    of log operations.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 3ed0a7f26e45..3bc40ff5fdf9 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -25,7 +25,6 @@ struct gfs2_log_element;
 struct gfs2_bitmap;
 struct gfs2_rgrpd;
 struct gfs2_bufdata;
-struct gfs2_databuf;
 struct gfs2_glock_operations;
 struct gfs2_holder;
 struct gfs2_glock;
@@ -116,11 +115,6 @@ struct gfs2_bufdata {
 	struct list_head bd_ail_gl_list;
 };
 
-struct gfs2_databuf {
-	struct gfs2_log_element db_le;
-	struct buffer_head *db_bh;
-};
-
 struct gfs2_glock_operations {
 	void (*go_xmote_th) (struct gfs2_glock * gl, unsigned int state,
 			     int flags);

commit b3b94faa5fe5968827ba0640ee9fba4b3e7f736e
Author: David Teigland <teigland@redhat.com>
Date:   Mon Jan 16 16:50:04 2006 +0000

    [GFS2] The core of GFS2
    
    This patch contains all the core files for GFS2.
    
    Signed-off-by: David Teigland <teigland@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
new file mode 100644
index 000000000000..3ed0a7f26e45
--- /dev/null
+++ b/fs/gfs2/incore.h
@@ -0,0 +1,703 @@
+/*
+ * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
+ * Copyright (C) 2004-2005 Red Hat, Inc.  All rights reserved.
+ *
+ * This copyrighted material is made available to anyone wishing to use,
+ * modify, copy, or redistribute it subject to the terms and conditions
+ * of the GNU General Public License v.2.
+ */
+
+#ifndef __INCORE_DOT_H__
+#define __INCORE_DOT_H__
+
+#define DIO_FORCE	0x00000001
+#define DIO_CLEAN	0x00000002
+#define DIO_DIRTY	0x00000004
+#define DIO_START	0x00000008
+#define DIO_WAIT	0x00000010
+#define DIO_METADATA	0x00000020
+#define DIO_DATA	0x00000040
+#define DIO_RELEASE	0x00000080
+#define DIO_ALL		0x00000100
+
+struct gfs2_log_operations;
+struct gfs2_log_element;
+struct gfs2_bitmap;
+struct gfs2_rgrpd;
+struct gfs2_bufdata;
+struct gfs2_databuf;
+struct gfs2_glock_operations;
+struct gfs2_holder;
+struct gfs2_glock;
+struct gfs2_alloc;
+struct gfs2_inode;
+struct gfs2_file;
+struct gfs2_revoke;
+struct gfs2_revoke_replay;
+struct gfs2_unlinked;
+struct gfs2_quota_data;
+struct gfs2_log_buf;
+struct gfs2_trans;
+struct gfs2_ail;
+struct gfs2_jdesc;
+struct gfs2_args;
+struct gfs2_tune;
+struct gfs2_gl_hash_bucket;
+struct gfs2_sbd;
+
+typedef void (*gfs2_glop_bh_t) (struct gfs2_glock *gl, unsigned int ret);
+
+/*
+ * Structure of operations that are associated with each
+ * type of element in the log.
+ */
+
+struct gfs2_log_operations {
+	void (*lo_add) (struct gfs2_sbd *sdp, struct gfs2_log_element *le);
+	void (*lo_incore_commit) (struct gfs2_sbd *sdp, struct gfs2_trans *tr);
+	void (*lo_before_commit) (struct gfs2_sbd *sdp);
+	void (*lo_after_commit) (struct gfs2_sbd *sdp, struct gfs2_ail *ai);
+	void (*lo_before_scan) (struct gfs2_jdesc *jd,
+				struct gfs2_log_header *head, int pass);
+	int (*lo_scan_elements) (struct gfs2_jdesc *jd, unsigned int start,
+				 struct gfs2_log_descriptor *ld, __be64 *ptr,
+				 int pass);
+	void (*lo_after_scan) (struct gfs2_jdesc *jd, int error, int pass);
+	char *lo_name;
+};
+
+struct gfs2_log_element {
+	struct list_head le_list;
+	struct gfs2_log_operations *le_ops;
+};
+
+struct gfs2_bitmap {
+	struct buffer_head *bi_bh;
+	char *bi_clone;
+	uint32_t bi_offset;
+	uint32_t bi_start;
+	uint32_t bi_len;
+};
+
+struct gfs2_rgrpd {
+	struct list_head rd_list;	/* Link with superblock */
+	struct list_head rd_list_mru;
+	struct list_head rd_recent;	/* Recently used rgrps */
+	struct gfs2_glock *rd_gl;	/* Glock for this rgrp */
+	struct gfs2_rindex rd_ri;
+	struct gfs2_rgrp rd_rg;
+	uint64_t rd_rg_vn;
+	struct gfs2_bitmap *rd_bits;
+	unsigned int rd_bh_count;
+	struct semaphore rd_mutex;
+	uint32_t rd_free_clone;
+	struct gfs2_log_element rd_le;
+	uint32_t rd_last_alloc_data;
+	uint32_t rd_last_alloc_meta;
+	struct gfs2_sbd *rd_sbd;
+};
+
+enum gfs2_state_bits {
+	BH_Pinned = BH_PrivateStart,
+};
+
+BUFFER_FNS(Pinned, pinned)
+TAS_BUFFER_FNS(Pinned, pinned)
+
+struct gfs2_bufdata {
+	struct buffer_head *bd_bh;
+	struct gfs2_glock *bd_gl;
+
+	struct list_head bd_list_tr;
+	struct gfs2_log_element bd_le;
+
+	struct gfs2_ail *bd_ail;
+	struct list_head bd_ail_st_list;
+	struct list_head bd_ail_gl_list;
+};
+
+struct gfs2_databuf {
+	struct gfs2_log_element db_le;
+	struct buffer_head *db_bh;
+};
+
+struct gfs2_glock_operations {
+	void (*go_xmote_th) (struct gfs2_glock * gl, unsigned int state,
+			     int flags);
+	void (*go_xmote_bh) (struct gfs2_glock * gl);
+	void (*go_drop_th) (struct gfs2_glock * gl);
+	void (*go_drop_bh) (struct gfs2_glock * gl);
+	void (*go_sync) (struct gfs2_glock * gl, int flags);
+	void (*go_inval) (struct gfs2_glock * gl, int flags);
+	int (*go_demote_ok) (struct gfs2_glock * gl);
+	int (*go_lock) (struct gfs2_holder * gh);
+	void (*go_unlock) (struct gfs2_holder * gh);
+	void (*go_callback) (struct gfs2_glock * gl, unsigned int state);
+	void (*go_greedy) (struct gfs2_glock * gl);
+	int go_type;
+};
+
+enum {
+	/* Actions */
+	HIF_MUTEX		= 0,
+	HIF_PROMOTE		= 1,
+	HIF_DEMOTE		= 2,
+	HIF_GREEDY		= 3,
+
+	/* States */
+	HIF_ALLOCED		= 4,
+	HIF_DEALLOC		= 5,
+	HIF_HOLDER		= 6,
+	HIF_FIRST		= 7,
+	HIF_RECURSE		= 8,
+	HIF_ABORTED		= 9,
+};
+
+struct gfs2_holder {
+	struct list_head gh_list;
+
+	struct gfs2_glock *gh_gl;
+	struct task_struct *gh_owner;
+	unsigned int gh_state;
+	int gh_flags;
+
+	int gh_error;
+	unsigned long gh_iflags;
+	struct completion gh_wait;
+};
+
+enum {
+	GLF_PLUG		= 0,
+	GLF_LOCK		= 1,
+	GLF_STICKY		= 2,
+	GLF_PREFETCH		= 3,
+	GLF_SYNC		= 4,
+	GLF_DIRTY		= 5,
+	GLF_SKIP_WAITERS2	= 6,
+	GLF_GREEDY		= 7,
+};
+
+struct gfs2_glock {
+	struct list_head gl_list;
+	unsigned long gl_flags;		/* GLF_... */
+	struct lm_lockname gl_name;
+	struct kref gl_ref;
+
+	spinlock_t gl_spin;
+
+	unsigned int gl_state;
+	struct list_head gl_holders;
+	struct list_head gl_waiters1;	/* HIF_MUTEX */
+	struct list_head gl_waiters2;	/* HIF_DEMOTE, HIF_GREEDY */
+	struct list_head gl_waiters3;	/* HIF_PROMOTE */
+
+	struct gfs2_glock_operations *gl_ops;
+
+	struct gfs2_holder *gl_req_gh;
+	gfs2_glop_bh_t gl_req_bh;
+
+	lm_lock_t *gl_lock;
+	char *gl_lvb;
+	atomic_t gl_lvb_count;
+
+	uint64_t gl_vn;
+	unsigned long gl_stamp;
+	void *gl_object;
+
+	struct gfs2_gl_hash_bucket *gl_bucket;
+	struct list_head gl_reclaim;
+
+	struct gfs2_sbd *gl_sbd;
+
+	struct inode *gl_aspace;
+	struct gfs2_log_element gl_le;
+	struct list_head gl_ail_list;
+	atomic_t gl_ail_count;
+};
+
+struct gfs2_alloc {
+	/* Quota stuff */
+
+	unsigned int al_qd_num;
+	struct gfs2_quota_data *al_qd[4];
+	struct gfs2_holder al_qd_ghs[4];
+
+	/* Filled in by the caller to gfs2_inplace_reserve() */
+
+	uint32_t al_requested;
+
+	/* Filled in by gfs2_inplace_reserve() */
+
+	char *al_file;
+	unsigned int al_line;
+	struct gfs2_holder al_ri_gh;
+	struct gfs2_holder al_rgd_gh;
+	struct gfs2_rgrpd *al_rgd;
+
+	/* Filled in by gfs2_alloc_*() */
+
+	uint32_t al_alloced;
+};
+
+enum {
+	GIF_MIN_INIT		= 0,
+	GIF_QD_LOCKED		= 1,
+	GIF_PAGED		= 2,
+	GIF_SW_PAGED		= 3,
+};
+
+struct gfs2_inode {
+	struct gfs2_inum i_num;
+
+	atomic_t i_count;
+	unsigned long i_flags;		/* GIF_... */
+
+	uint64_t i_vn;
+	struct gfs2_dinode i_di;
+
+	struct gfs2_glock *i_gl;
+	struct gfs2_sbd *i_sbd;
+	struct inode *i_vnode;
+
+	struct gfs2_holder i_iopen_gh;
+
+	struct gfs2_alloc i_alloc;
+	uint64_t i_last_rg_alloc;
+
+	spinlock_t i_spin;
+	struct rw_semaphore i_rw_mutex;
+
+	unsigned int i_greedy;
+	unsigned long i_last_pfault;
+
+	struct buffer_head *i_cache[GFS2_MAX_META_HEIGHT];
+};
+
+enum {
+	GFF_DID_DIRECT_ALLOC	= 0,
+};
+
+struct gfs2_file {
+	unsigned long f_flags;		/* GFF_... */
+
+	struct semaphore f_fl_mutex;
+	struct gfs2_holder f_fl_gh;
+
+	struct gfs2_inode *f_inode;
+	struct file *f_vfile;
+};
+
+struct gfs2_revoke {
+	struct gfs2_log_element rv_le;
+	uint64_t rv_blkno;
+};
+
+struct gfs2_revoke_replay {
+	struct list_head rr_list;
+	uint64_t rr_blkno;
+	unsigned int rr_where;
+};
+
+enum {
+	ULF_LOCKED		= 0,
+};
+
+struct gfs2_unlinked {
+	struct list_head ul_list;
+	unsigned int ul_count;
+	struct gfs2_unlinked_tag ul_ut;
+	unsigned long ul_flags;		/* ULF_... */
+	unsigned int ul_slot;
+};
+
+enum {
+	QDF_USER		= 0,
+	QDF_CHANGE		= 1,
+	QDF_LOCKED		= 2,
+};
+
+struct gfs2_quota_data {
+	struct list_head qd_list;
+	unsigned int qd_count;
+
+	uint32_t qd_id;
+	unsigned long qd_flags;		/* QDF_... */
+
+	int64_t qd_change;
+	int64_t qd_change_sync;
+
+	unsigned int qd_slot;
+	unsigned int qd_slot_count;
+
+	struct buffer_head *qd_bh;
+	struct gfs2_quota_change *qd_bh_qc;
+	unsigned int qd_bh_count;
+
+	struct gfs2_glock *qd_gl;
+	struct gfs2_quota_lvb qd_qb;
+
+	uint64_t qd_sync_gen;
+	unsigned long qd_last_warn;
+	unsigned long qd_last_touched;
+};
+
+struct gfs2_log_buf {
+	struct list_head lb_list;
+	struct buffer_head *lb_bh;
+	struct buffer_head *lb_real;
+};
+
+struct gfs2_trans {
+	char *tr_file;
+	unsigned int tr_line;
+
+	unsigned int tr_blocks;
+	unsigned int tr_revokes;
+	unsigned int tr_reserved;
+
+	struct gfs2_holder *tr_t_gh;
+
+	int tr_touched;
+
+	unsigned int tr_num_buf;
+	unsigned int tr_num_buf_new;
+	unsigned int tr_num_buf_rm;
+	struct list_head tr_list_buf;
+
+	unsigned int tr_num_revoke;
+	unsigned int tr_num_revoke_rm;
+};
+
+struct gfs2_ail {
+	struct list_head ai_list;
+
+	unsigned int ai_first;
+	struct list_head ai_ail1_list;
+	struct list_head ai_ail2_list;
+
+	uint64_t ai_sync_gen;
+};
+
+struct gfs2_jdesc {
+	struct list_head jd_list;
+
+	struct gfs2_inode *jd_inode;
+	unsigned int jd_jid;
+	int jd_dirty;
+
+	unsigned int jd_blocks;
+};
+
+#define GFS2_GLOCKD_DEFAULT	1
+#define GFS2_GLOCKD_MAX		16
+
+#define GFS2_QUOTA_DEFAULT	GFS2_QUOTA_OFF
+#define GFS2_QUOTA_OFF		0
+#define GFS2_QUOTA_ACCOUNT	1
+#define GFS2_QUOTA_ON		2
+
+#define GFS2_DATA_DEFAULT	GFS2_DATA_ORDERED
+#define GFS2_DATA_WRITEBACK	1
+#define GFS2_DATA_ORDERED	2
+
+struct gfs2_args {
+	char ar_lockproto[GFS2_LOCKNAME_LEN]; /* Name of the Lock Protocol */
+	char ar_locktable[GFS2_LOCKNAME_LEN]; /* Name of the Lock Table */
+	char ar_hostdata[GFS2_LOCKNAME_LEN]; /* Host specific data */
+	int ar_spectator; /* Don't get a journal because we're always RO */
+	int ar_ignore_local_fs; /* Don't optimize even if local_fs is 1 */
+	int ar_localflocks; /* Let the VFS do flock|fcntl locks for us */
+	int ar_localcaching; /* Local-style caching (dangerous on multihost) */
+	int ar_debug; /* Oops on errors instead of trying to be graceful */
+	int ar_upgrade; /* Upgrade ondisk/multihost format */
+	unsigned int ar_num_glockd; /* Number of glockd threads */
+	int ar_posix_acl; /* Enable posix acls */
+	int ar_quota; /* off/account/on */
+	int ar_suiddir; /* suiddir support */
+	int ar_data; /* ordered/writeback */
+};
+
+struct gfs2_tune {
+	spinlock_t gt_spin;
+
+	unsigned int gt_ilimit;
+	unsigned int gt_ilimit_tries;
+	unsigned int gt_ilimit_min;
+	unsigned int gt_demote_secs; /* Cache retention for unheld glock */
+	unsigned int gt_incore_log_blocks;
+	unsigned int gt_log_flush_secs;
+	unsigned int gt_jindex_refresh_secs; /* Check for new journal index */
+
+	unsigned int gt_scand_secs;
+	unsigned int gt_recoverd_secs;
+	unsigned int gt_logd_secs;
+	unsigned int gt_quotad_secs;
+	unsigned int gt_inoded_secs;
+
+	unsigned int gt_quota_simul_sync; /* Max quotavals to sync at once */
+	unsigned int gt_quota_warn_period; /* Secs between quota warn msgs */
+	unsigned int gt_quota_scale_num; /* Numerator */
+	unsigned int gt_quota_scale_den; /* Denominator */
+	unsigned int gt_quota_cache_secs;
+	unsigned int gt_quota_quantum; /* Secs between syncs to quota file */
+	unsigned int gt_atime_quantum; /* Min secs between atime updates */
+	unsigned int gt_new_files_jdata;
+	unsigned int gt_new_files_directio;
+	unsigned int gt_max_atomic_write; /* Split big writes into this size */
+	unsigned int gt_max_readahead; /* Max bytes to read-ahead from disk */
+	unsigned int gt_lockdump_size;
+	unsigned int gt_stall_secs; /* Detects trouble! */
+	unsigned int gt_complain_secs;
+	unsigned int gt_reclaim_limit; /* Max num of glocks in reclaim list */
+	unsigned int gt_entries_per_readdir;
+	unsigned int gt_prefetch_secs; /* Usage window for prefetched glocks */
+	unsigned int gt_greedy_default;
+	unsigned int gt_greedy_quantum;
+	unsigned int gt_greedy_max;
+	unsigned int gt_statfs_quantum;
+	unsigned int gt_statfs_slow;
+};
+
+struct gfs2_gl_hash_bucket {
+	rwlock_t hb_lock;
+	struct list_head hb_list;
+};
+
+enum {
+	SDF_JOURNAL_CHECKED	= 0,
+	SDF_JOURNAL_LIVE	= 1,
+	SDF_SHUTDOWN		= 2,
+	SDF_NOATIME		= 3,
+};
+
+#define GFS2_GL_HASH_SHIFT	13
+#define GFS2_GL_HASH_SIZE	(1 << GFS2_GL_HASH_SHIFT)
+#define GFS2_GL_HASH_MASK	(GFS2_GL_HASH_SIZE - 1)
+#define GFS2_FSNAME_LEN		256
+
+struct gfs2_sbd {
+	struct super_block *sd_vfs;
+	struct kobject sd_kobj;
+	unsigned long sd_flags;	/* SDF_... */
+	struct gfs2_sb sd_sb;
+
+	/* Constants computed on mount */
+
+	uint32_t sd_fsb2bb;
+	uint32_t sd_fsb2bb_shift;
+	uint32_t sd_diptrs;	/* Number of pointers in a dinode */
+	uint32_t sd_inptrs;	/* Number of pointers in a indirect block */
+	uint32_t sd_jbsize;	/* Size of a journaled data block */
+	uint32_t sd_hash_bsize;	/* sizeof(exhash block) */
+	uint32_t sd_hash_bsize_shift;
+	uint32_t sd_hash_ptrs;	/* Number of pointers in a hash block */
+	uint32_t sd_ut_per_block;
+	uint32_t sd_qc_per_block;
+	uint32_t sd_max_dirres;	/* Max blocks needed to add a directory entry */
+	uint32_t sd_max_height;	/* Max height of a file's metadata tree */
+	uint64_t sd_heightsize[GFS2_MAX_META_HEIGHT];
+	uint32_t sd_max_jheight; /* Max height of journaled file's meta tree */
+	uint64_t sd_jheightsize[GFS2_MAX_META_HEIGHT];
+
+	struct gfs2_args sd_args;	/* Mount arguments */
+	struct gfs2_tune sd_tune;	/* Filesystem tuning structure */
+
+	/* Lock Stuff */
+
+	struct lm_lockstruct sd_lockstruct;
+	struct gfs2_gl_hash_bucket sd_gl_hash[GFS2_GL_HASH_SIZE];
+	struct list_head sd_reclaim_list;
+	spinlock_t sd_reclaim_lock;
+	wait_queue_head_t sd_reclaim_wq;
+	atomic_t sd_reclaim_count;
+	struct gfs2_holder sd_live_gh;
+	struct gfs2_glock *sd_rename_gl;
+	struct gfs2_glock *sd_trans_gl;
+	struct semaphore sd_invalidate_inodes_mutex;
+
+	/* Inode Stuff */
+
+	struct gfs2_inode *sd_master_dir;
+	struct gfs2_inode *sd_jindex;
+	struct gfs2_inode *sd_inum_inode;
+	struct gfs2_inode *sd_statfs_inode;
+	struct gfs2_inode *sd_ir_inode;
+	struct gfs2_inode *sd_sc_inode;
+	struct gfs2_inode *sd_ut_inode;
+	struct gfs2_inode *sd_qc_inode;
+	struct gfs2_inode *sd_rindex;
+	struct gfs2_inode *sd_quota_inode;
+	struct gfs2_inode *sd_root_dir;
+
+	/* Inum stuff */
+
+	struct semaphore sd_inum_mutex;
+
+	/* StatFS stuff */
+
+	spinlock_t sd_statfs_spin;
+	struct semaphore sd_statfs_mutex;
+	struct gfs2_statfs_change sd_statfs_master;
+	struct gfs2_statfs_change sd_statfs_local;
+	unsigned long sd_statfs_sync_time;
+
+	/* Resource group stuff */
+
+	uint64_t sd_rindex_vn;
+	spinlock_t sd_rindex_spin;
+	struct semaphore sd_rindex_mutex;
+	struct list_head sd_rindex_list;
+	struct list_head sd_rindex_mru_list;
+	struct list_head sd_rindex_recent_list;
+	struct gfs2_rgrpd *sd_rindex_forward;
+	unsigned int sd_rgrps;
+
+	/* Journal index stuff */
+
+	struct list_head sd_jindex_list;
+	spinlock_t sd_jindex_spin;
+	struct semaphore sd_jindex_mutex;
+	unsigned int sd_journals;
+	unsigned long sd_jindex_refresh_time;
+
+	struct gfs2_jdesc *sd_jdesc;
+	struct gfs2_holder sd_journal_gh;
+	struct gfs2_holder sd_jinode_gh;
+
+	struct gfs2_holder sd_ir_gh;
+	struct gfs2_holder sd_sc_gh;
+	struct gfs2_holder sd_ut_gh;
+	struct gfs2_holder sd_qc_gh;
+
+	/* Daemon stuff */
+
+	struct task_struct *sd_scand_process;
+	struct task_struct *sd_recoverd_process;
+	struct task_struct *sd_logd_process;
+	struct task_struct *sd_quotad_process;
+	struct task_struct *sd_inoded_process;
+	struct task_struct *sd_glockd_process[GFS2_GLOCKD_MAX];
+	unsigned int sd_glockd_num;
+
+	/* Unlinked inode stuff */
+
+	struct list_head sd_unlinked_list;
+	atomic_t sd_unlinked_count;
+	spinlock_t sd_unlinked_spin;
+	struct semaphore sd_unlinked_mutex;
+
+	unsigned int sd_unlinked_slots;
+	unsigned int sd_unlinked_chunks;
+	unsigned char **sd_unlinked_bitmap;
+
+	/* Quota stuff */
+
+	struct list_head sd_quota_list;
+	atomic_t sd_quota_count;
+	spinlock_t sd_quota_spin;
+	struct semaphore sd_quota_mutex;
+
+	unsigned int sd_quota_slots;
+	unsigned int sd_quota_chunks;
+	unsigned char **sd_quota_bitmap;
+
+	uint64_t sd_quota_sync_gen;
+	unsigned long sd_quota_sync_time;
+
+	/* Log stuff */
+
+	spinlock_t sd_log_lock;
+	atomic_t sd_log_trans_count;
+	wait_queue_head_t sd_log_trans_wq;
+	atomic_t sd_log_flush_count;
+	wait_queue_head_t sd_log_flush_wq;
+
+	unsigned int sd_log_blks_reserved;
+	unsigned int sd_log_commited_buf;
+	unsigned int sd_log_commited_revoke;
+
+	unsigned int sd_log_num_gl;
+	unsigned int sd_log_num_buf;
+	unsigned int sd_log_num_revoke;
+	unsigned int sd_log_num_rg;
+	unsigned int sd_log_num_databuf;
+	struct list_head sd_log_le_gl;
+	struct list_head sd_log_le_buf;
+	struct list_head sd_log_le_revoke;
+	struct list_head sd_log_le_rg;
+	struct list_head sd_log_le_databuf;
+
+	unsigned int sd_log_blks_free;
+	struct list_head sd_log_blks_list;
+	wait_queue_head_t sd_log_blks_wait;
+
+	uint64_t sd_log_sequence;
+	unsigned int sd_log_head;
+	unsigned int sd_log_tail;
+	uint64_t sd_log_wraps;
+	int sd_log_idle;
+
+	unsigned long sd_log_flush_time;
+	struct semaphore sd_log_flush_lock;
+	struct list_head sd_log_flush_list;
+
+	unsigned int sd_log_flush_head;
+	uint64_t sd_log_flush_wrapped;
+
+	struct list_head sd_ail1_list;
+	struct list_head sd_ail2_list;
+	uint64_t sd_ail_sync_gen;
+
+	/* Replay stuff */
+
+	struct list_head sd_revoke_list;
+	unsigned int sd_replay_tail;
+
+	unsigned int sd_found_blocks;
+	unsigned int sd_found_revokes;
+	unsigned int sd_replayed_blocks;
+
+	/* For quiescing the filesystem */
+
+	struct gfs2_holder sd_freeze_gh;
+	struct semaphore sd_freeze_lock;
+	unsigned int sd_freeze_count;
+
+	/* Counters */
+
+	atomic_t sd_glock_count;
+	atomic_t sd_glock_held_count;
+	atomic_t sd_inode_count;
+	atomic_t sd_bufdata_count;
+
+	atomic_t sd_fh2dentry_misses;
+	atomic_t sd_reclaimed;
+	atomic_t sd_log_flush_incore;
+	atomic_t sd_log_flush_ondisk;
+
+	atomic_t sd_glock_nq_calls;
+	atomic_t sd_glock_dq_calls;
+	atomic_t sd_glock_prefetch_calls;
+	atomic_t sd_lm_lock_calls;
+	atomic_t sd_lm_unlock_calls;
+	atomic_t sd_lm_callbacks;
+
+	atomic_t sd_ops_address;
+	atomic_t sd_ops_dentry;
+	atomic_t sd_ops_export;
+	atomic_t sd_ops_file;
+	atomic_t sd_ops_inode;
+	atomic_t sd_ops_super;
+	atomic_t sd_ops_vm;
+
+	char sd_fsname[GFS2_FSNAME_LEN];
+	char sd_table_name[GFS2_FSNAME_LEN];
+	char sd_proto_name[GFS2_FSNAME_LEN];
+
+	/* Debugging crud */
+
+	unsigned long sd_last_warning;
+};
+
+#endif /* __INCORE_DOT_H__ */
+
