commit 027690c75e8fd91b60a634d31c4891a6e39d45bd
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Mon Jun 1 17:44:45 2020 -0400

    nfsd4: make drc_slab global, not per-net
    
    I made every global per-network-namespace instead.  But perhaps doing
    that to this slab was a step too far.
    
    The kmem_cache_create call in our net init method also seems to be
    responsible for this lockdep warning:
    
    [   45.163710] Unable to find swap-space signature
    [   45.375718] trinity-c1 (855): attempted to duplicate a private mapping with mremap.  This is not supported.
    [   46.055744] futex_wake_op: trinity-c1 tries to shift op by -209; fix this program
    [   51.011723]
    [   51.013378] ======================================================
    [   51.013875] WARNING: possible circular locking dependency detected
    [   51.014378] 5.2.0-rc2 #1 Not tainted
    [   51.014672] ------------------------------------------------------
    [   51.015182] trinity-c2/886 is trying to acquire lock:
    [   51.015593] 000000005405f099 (slab_mutex){+.+.}, at: slab_attr_store+0xa2/0x130
    [   51.016190]
    [   51.016190] but task is already holding lock:
    [   51.016652] 00000000ac662005 (kn->count#43){++++}, at: kernfs_fop_write+0x286/0x500
    [   51.017266]
    [   51.017266] which lock already depends on the new lock.
    [   51.017266]
    [   51.017909]
    [   51.017909] the existing dependency chain (in reverse order) is:
    [   51.018497]
    [   51.018497] -> #1 (kn->count#43){++++}:
    [   51.018956]        __lock_acquire+0x7cf/0x1a20
    [   51.019317]        lock_acquire+0x17d/0x390
    [   51.019658]        __kernfs_remove+0x892/0xae0
    [   51.020020]        kernfs_remove_by_name_ns+0x78/0x110
    [   51.020435]        sysfs_remove_link+0x55/0xb0
    [   51.020832]        sysfs_slab_add+0xc1/0x3e0
    [   51.021332]        __kmem_cache_create+0x155/0x200
    [   51.021720]        create_cache+0xf5/0x320
    [   51.022054]        kmem_cache_create_usercopy+0x179/0x320
    [   51.022486]        kmem_cache_create+0x1a/0x30
    [   51.022867]        nfsd_reply_cache_init+0x278/0x560
    [   51.023266]        nfsd_init_net+0x20f/0x5e0
    [   51.023623]        ops_init+0xcb/0x4b0
    [   51.023928]        setup_net+0x2fe/0x670
    [   51.024315]        copy_net_ns+0x30a/0x3f0
    [   51.024653]        create_new_namespaces+0x3c5/0x820
    [   51.025257]        unshare_nsproxy_namespaces+0xd1/0x240
    [   51.025881]        ksys_unshare+0x506/0x9c0
    [   51.026381]        __x64_sys_unshare+0x3a/0x50
    [   51.026937]        do_syscall_64+0x110/0x10b0
    [   51.027509]        entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [   51.028175]
    [   51.028175] -> #0 (slab_mutex){+.+.}:
    [   51.028817]        validate_chain+0x1c51/0x2cc0
    [   51.029422]        __lock_acquire+0x7cf/0x1a20
    [   51.029947]        lock_acquire+0x17d/0x390
    [   51.030438]        __mutex_lock+0x100/0xfa0
    [   51.030995]        mutex_lock_nested+0x27/0x30
    [   51.031516]        slab_attr_store+0xa2/0x130
    [   51.032020]        sysfs_kf_write+0x11d/0x180
    [   51.032529]        kernfs_fop_write+0x32a/0x500
    [   51.033056]        do_loop_readv_writev+0x21d/0x310
    [   51.033627]        do_iter_write+0x2e5/0x380
    [   51.034148]        vfs_writev+0x170/0x310
    [   51.034616]        do_pwritev+0x13e/0x160
    [   51.035100]        __x64_sys_pwritev+0xa3/0x110
    [   51.035633]        do_syscall_64+0x110/0x10b0
    [   51.036200]        entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [   51.036924]
    [   51.036924] other info that might help us debug this:
    [   51.036924]
    [   51.037876]  Possible unsafe locking scenario:
    [   51.037876]
    [   51.038556]        CPU0                    CPU1
    [   51.039130]        ----                    ----
    [   51.039676]   lock(kn->count#43);
    [   51.040084]                                lock(slab_mutex);
    [   51.040597]                                lock(kn->count#43);
    [   51.041062]   lock(slab_mutex);
    [   51.041320]
    [   51.041320]  *** DEADLOCK ***
    [   51.041320]
    [   51.041793] 3 locks held by trinity-c2/886:
    [   51.042128]  #0: 000000001f55e152 (sb_writers#5){.+.+}, at: vfs_writev+0x2b9/0x310
    [   51.042739]  #1: 00000000c7d6c034 (&of->mutex){+.+.}, at: kernfs_fop_write+0x25b/0x500
    [   51.043400]  #2: 00000000ac662005 (kn->count#43){++++}, at: kernfs_fop_write+0x286/0x500
    
    Reported-by: kernel test robot <lkp@intel.com>
    Fixes: 3ba75830ce17 "drc containerization"
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 09aa545825bd..9217cb64bf0e 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -139,7 +139,6 @@ struct nfsd_net {
 	 * Duplicate reply cache
 	 */
 	struct nfsd_drc_bucket   *drc_hashtbl;
-	struct kmem_cache        *drc_slab;
 
 	/* max number of entries allowed in the cache */
 	unsigned int             max_drc_entries;

commit 7627d7dc79a8edd4b8f946a66002ea4205203112
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Wed Feb 19 15:52:15 2020 -0500

    nfsd: set the server_scope during service startup
    
    Currently, nfsd4_encode_exchange_id() encodes the utsname nodename
    string in the server_scope field.  In a multi-host container
    environemnt, if an nfsd container is restarted on a different host than
    it was originally running on, clients will see a server_scope mismatch
    and will not attempt to reclaim opens.
    
    Instead, set the server_scope while we're in a process context during
    service startup, so we get the utsname nodename of the current process
    and store that in nfsd_net.
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    [bfields: fix up major_id too]
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 2baf32311e00..09aa545825bd 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -172,6 +172,8 @@ struct nfsd_net {
 	unsigned int             longest_chain_cachesize;
 
 	struct shrinker		nfsd_reply_cache_shrinker;
+	/* utsname taken from the the process that starts the server */
+	char			nfsd_name[UNX_MAXNODENAME+1];
 };
 
 /* Simple check to find out if a given net was properly initialized */

commit 20b7d86f29d39e8ae19bb29c24ffee70dc385ddf
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 4 16:31:52 2019 +0100

    nfsd: use boottime for lease expiry calculation
    
    A couple of time_t variables are only used to track the state of the
    lease time and its expiration. The code correctly uses the 'time_after()'
    macro to make this work on 32-bit architectures even beyond year 2038,
    but the get_seconds() function and the time_t type itself are deprecated
    as they behave inconsistently between 32-bit and 64-bit architectures
    and often lead to code that is not y2038 safe.
    
    As a minor issue, using get_seconds() leads to problems with concurrent
    settimeofday() or clock_settime() calls, in the worst case timeout never
    triggering after the time has been set backwards.
    
    Change nfsd to use time64_t and ktime_get_boottime_seconds() here. This
    is clearly excessive, as boottime by itself means we never go beyond 32
    bits, but it does mean we handle this correctly and consistently without
    having to worry about corner cases and should be no more expensive than
    the previous implementation on 64-bit architectures.
    
    The max_cb_time() function gets changed in order to avoid an expensive
    64-bit division operation, but as the lease time is at most one hour,
    there is no change in behavior.
    
    Also do the same for server-to-server copy expiration time.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [bfields@redhat.com: fix up copy expiration]
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 29bbe28eda53..2baf32311e00 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -92,8 +92,8 @@ struct nfsd_net {
 	bool in_grace;
 	const struct nfsd4_client_tracking_ops *client_tracking_ops;
 
-	time_t nfsd4_lease;
-	time_t nfsd4_grace;
+	time64_t nfsd4_lease;
+	time64_t nfsd4_grace;
 	bool somebody_reclaimed;
 
 	bool track_reclaim_completes;

commit 9cc7680149b238223bbb8bcf3272f6bd47f1fbfb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 31 15:53:13 2019 +0100

    nfsd: make 'boot_time' 64-bit wide
    
    The local boot time variable gets truncated to time_t at the moment,
    which can lead to slightly odd behavior on 32-bit architectures.
    
    Use ktime_get_real_seconds() instead of get_seconds() to always
    get a 64-bit result, and keep it that way wherever possible.
    
    It still gets truncated in a few places:
    
    - When assigning to cl_clientid.cl_boot, this is already documented
      and is only used as a unique identifier.
    
    - In clients_still_reclaiming(), the truncation is to 'unsigned long'
      in order to use the 'time_before() helper.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 9a4ef815fb8c..29bbe28eda53 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -40,7 +40,7 @@ struct nfsd_net {
 
 	struct lock_manager nfsd4_manager;
 	bool grace_ended;
-	time_t boot_time;
+	time64_t boot_time;
 
 	/* internal mount of the "nfsd" pseudofilesystem: */
 	struct vfsmount *nfsd_mnt;

commit 27c438f53e79b81dc8805a81f6cd74824ba57290
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Mon Sep 2 13:02:56 2019 -0400

    nfsd: Support the server resetting the boot verifier
    
    Add support to allow the server to reset the boot verifier in order to
    force clients to resend I/O after a timeout failure.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Lance Shelton <lance.shelton@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index bdfe5bcb3dcd..9a4ef815fb8c 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -104,6 +104,7 @@ struct nfsd_net {
 
 	/* Time of server startup */
 	struct timespec64 nfssvc_boot;
+	seqlock_t boot_lock;
 
 	/*
 	 * Max number of connections this nfsd container will allow. Defaults
@@ -179,4 +180,7 @@ struct nfsd_net {
 extern void nfsd_netns_free_versions(struct nfsd_net *nn);
 
 extern unsigned int nfsd_net_id;
+
+void nfsd_copy_boot_verifier(__be32 verf[2], struct nfsd_net *nn);
+void nfsd_reset_boot_verifier(struct nfsd_net *nn);
 #endif /* __NFSD_NETNS_H__ */

commit bf5ed3e3bb84c39d70ad10b2f8e47ec62f4c63b1
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Thu Mar 14 16:20:19 2019 -0400

    nfsd: make client/ directory names small ints
    
    We want clientid's on the wire to be randomized for reasons explained in
    ebd7c72c63ac "nfsd: randomize SETCLIENTID reply to help distinguish
    servers".  But I'd rather have mostly small integers for the clients/
    directory.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index ad1d74383d67..bdfe5bcb3dcd 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -111,6 +111,7 @@ struct nfsd_net {
 	 */
 	unsigned int max_connections;
 
+	u32 clientid_base;
 	u32 clientid_counter;
 	u32 clverifier_counter;
 

commit e8a79fb14f6b76b502218fce10696f4df9ff19b1
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Mar 22 11:11:06 2019 -0400

    nfsd: add nfsd/clients directory
    
    I plan to expose some information about nfsv4 clients here.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index df4ba4b8b540..ad1d74383d67 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -45,6 +45,8 @@ struct nfsd_net {
 	/* internal mount of the "nfsd" pseudofilesystem: */
 	struct vfsmount *nfsd_mnt;
 
+	struct dentry *nfsd_client_dir;
+
 	/*
 	 * reclaim_str_hashtbl[] holds known client info from previous reset/reboot
 	 * used in reboot/reset lease grace period processing

commit 2c830dd7209bf67863ae0b83c7dde847967ea43c
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Dec 14 09:40:56 2018 -0500

    nfsd: persist nfsd filesystem across mounts
    
    Keep around one internal mount of the nfsd filesystem so that we can add
    stuff to it when clients come and go, regardless of whether anyone has
    it mounted.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index ceb413f8fff3..df4ba4b8b540 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -42,6 +42,9 @@ struct nfsd_net {
 	bool grace_ended;
 	time_t boot_time;
 
+	/* internal mount of the "nfsd" pseudofilesystem: */
+	struct vfsmount *nfsd_mnt;
+
 	/*
 	 * reclaim_str_hashtbl[] holds known client info from previous reset/reboot
 	 * used in reboot/reset lease grace period processing

commit 22a46eb44016eec3384da3731a2d47a5d3c91955
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri May 17 16:22:18 2019 -0400

    nfsd: note inadequate stats locking
    
    After 89a26b3d295d "nfsd: split DRC global spinlock into per-bucket
    locks", there is no longer a single global spinlock to protect these
    stats.
    
    So, really we need to fix that.  For now, at least fix the comment.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 46240c4d9184..ceb413f8fff3 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -142,8 +142,11 @@ struct nfsd_net {
 	unsigned int             drc_hashsize;
 
 	/*
-	 * Stats and other tracking of on the duplicate reply cache. All of these and
-	 * the "rc" fields in nfsdstats are protected by the cache_lock
+	 * Stats and other tracking of on the duplicate reply cache.
+	 * These fields and the "rc" fields in nfsdstats are modified
+	 * with only the per-bucket cache lock, which isn't really safe
+	 * and should be fixed if we want the statistics to be
+	 * completely accurate.
 	 */
 
 	/* total number of entries */

commit 3ba75830ce175550ef45c6524ec62faab8f62c1b
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri May 17 09:03:38 2019 -0400

    nfsd4: drc containerization
    
    The nfsd duplicate reply cache should not be shared between network
    namespaces.
    
    The most straightforward way to fix this is just to move every global in
    the code to per-net-namespace memory, so that's what we do.
    
    Still todo: sort out which members of nfsd_stats should be global and
    which per-net-namespace.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 7c686a270d60..46240c4d9184 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -127,6 +127,41 @@ struct nfsd_net {
 	 */
 	bool *nfsd_versions;
 	bool *nfsd4_minorversions;
+
+	/*
+	 * Duplicate reply cache
+	 */
+	struct nfsd_drc_bucket   *drc_hashtbl;
+	struct kmem_cache        *drc_slab;
+
+	/* max number of entries allowed in the cache */
+	unsigned int             max_drc_entries;
+
+	/* number of significant bits in the hash value */
+	unsigned int             maskbits;
+	unsigned int             drc_hashsize;
+
+	/*
+	 * Stats and other tracking of on the duplicate reply cache. All of these and
+	 * the "rc" fields in nfsdstats are protected by the cache_lock
+	 */
+
+	/* total number of entries */
+	atomic_t                 num_drc_entries;
+
+	/* cache misses due only to checksum comparison failures */
+	unsigned int             payload_misses;
+
+	/* amount of memory (in bytes) currently consumed by the DRC */
+	unsigned int             drc_mem_usage;
+
+	/* longest hash chain seen */
+	unsigned int             longest_chain;
+
+	/* size of cache when we saw the longest hash chain */
+	unsigned int             longest_chain_cachesize;
+
+	struct shrinker		nfsd_reply_cache_shrinker;
 };
 
 /* Simple check to find out if a given net was properly initialized */

commit 16216333235adf51093d0330a934a7e4a03134fe
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:31 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 1
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin street fifth floor boston ma 02110 1301 usa
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option [no]_[pad]_[ctrl] any later version this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin street fifth floor boston ma
      02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 176 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154040.652910950@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 789abc4dd1d2..7c686a270d60 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -1,21 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * per net namespace data structures for nfsd
  *
  * Copyright (C) 2012, Jeff Layton <jlayton@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc., 51
- * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
 #ifndef __NFSD_NETNS_H__

commit e333f3bbefe3e25e2bcff58063f920a2eaba224b
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Apr 9 11:46:19 2019 -0400

    nfsd: Allow containers to set supported nfs versions
    
    Support use of the --nfs-version/--no-nfs-version arguments to rpc.nfsd
    in containers.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index b42aaa22fba2..789abc4dd1d2 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -134,10 +134,18 @@ struct nfsd_net {
 	u32		s2s_cp_cl_id;
 	struct idr	s2s_cp_stateids;
 	spinlock_t	s2s_cp_lock;
+
+	/*
+	 * Version information
+	 */
+	bool *nfsd_versions;
+	bool *nfsd4_minorversions;
 };
 
 /* Simple check to find out if a given net was properly initialized */
 #define nfsd_netns_ready(nn) ((nn)->sessionid_hashtbl)
 
+extern void nfsd_netns_free_versions(struct nfsd_net *nn);
+
 extern unsigned int nfsd_net_id;
 #endif /* __NFSD_NETNS_H__ */

commit 362063a595be959bc08f4163e6405a0266740091
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Tue Mar 26 18:06:28 2019 -0400

    nfsd: keep a tally of RECLAIM_COMPLETE operations when using nfsdcld
    
    When using nfsdcld for NFSv4 client tracking, track the number of
    RECLAIM_COMPLETE operations we receive from "known" clients to help in
    deciding if we can lift the grace period early (or whether we need to
    start a v4 grace period at all).
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 32cb8c027483..b42aaa22fba2 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -104,6 +104,9 @@ struct nfsd_net {
 	time_t nfsd4_grace;
 	bool somebody_reclaimed;
 
+	bool track_reclaim_completes;
+	atomic_t nr_reclaim_complete;
+
 	bool nfsd_net_up;
 	bool lockd_up;
 

commit e0639dc5805a9d4faaa2c07ad98fa853b9529dd3
Author: Olga Kornievskaia <kolga@netapp.com>
Date:   Fri Jul 20 18:19:20 2018 -0400

    NFSD introduce async copy feature
    
    Upon receiving a request for async copy, create a new kthread.  If we
    get asynchronous request, make sure to copy the needed arguments/state
    from the stack before starting the copy. Then start the thread and reply
    back to the client indicating copy is asynchronous.
    
    nfsd_copy_file_range() will copy in a loop over the total number of
    bytes is needed to copy. In case a failure happens in the middle, we
    ignore the error and return how much we copied so far. Once done
    creating a workitem for the callback workqueue and send CB_OFFLOAD with
    the results.
    
    The lifetime of the copy stateid is bound to the vfs copy. This way we
    don't need to keep the nfsd_net structure for the callback.  We could
    keep it around longer so that an OFFLOAD_STATUS that came late would
    still get results, but clients should be able to deal without that.
    
    We handle OFFLOAD_CANCEL by sending a signal to the copy thread and
    calling kthread_stop.
    
    A client should cancel any ongoing copies before calling DESTROY_CLIENT;
    if not, we return a CLIENT_BUSY error.
    
    If the client is destroyed for some other reason (lease expiration, or
    server shutdown), we must clean up any ongoing copies ourselves.
    
    Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
    [colin.king@canonical.com: fix leak in error case]
    [bfields@fieldses.org: remove signalling, merge patches]
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 426f55005697..32cb8c027483 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -123,6 +123,14 @@ struct nfsd_net {
 
 	wait_queue_head_t ntf_wq;
 	atomic_t ntf_refcnt;
+
+	/*
+	 * clientid and stateid data for construction of net unique COPY
+	 * stateids.
+	 */
+	u32		s2s_cp_cl_id;
+	struct idr	s2s_cp_stateids;
+	spinlock_t	s2s_cp_lock;
 };
 
 /* Simple check to find out if a given net was properly initialized */

commit 03f318ca652889a1aa407e7088b9a2f6a14ae374
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Jun 8 12:28:47 2018 -0400

    nfsd4: extend reclaim period for reclaiming clients
    
    If the client is only renewing state a little sooner than once a lease
    period, then it might not discover the server has restarted till close
    to the end of the grace period, and might run out of time to do the
    actual reclaim.
    
    Extend the grace period by a second each time we notice there are
    clients still trying to reclaim, up to a limit of another whole lease
    period.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 36358d435cb0..426f55005697 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -102,6 +102,7 @@ struct nfsd_net {
 
 	time_t nfsd4_lease;
 	time_t nfsd4_grace;
+	bool somebody_reclaimed;
 
 	bool nfsd_net_up;
 	bool lockd_up;

commit 2317dc557a3b6d5b73b697034611d658eb2cbde9
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Fri Nov 10 10:19:35 2017 +0300

    race of nfsd inetaddr notifiers vs nn->nfsd_serv change
    
    nfsd_inet[6]addr_event uses nn->nfsd_serv without taking nfsd_mutex,
    which can be changed during execution of notifiers and crash the host.
    
    Moreover if notifiers were enabled in one net namespace they are enabled
    in all other net namespaces, from creation until destruction.
    
    This patch allows notifiers to access nn->nfsd_serv only after the
    pointer is correctly initialized and delays cleanup until notifiers are
    no longer in use.
    
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Tested-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 1c91391f4805..36358d435cb0 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -119,6 +119,9 @@ struct nfsd_net {
 	u32 clverifier_counter;
 
 	struct svc_serv *nfsd_serv;
+
+	wait_queue_head_t ntf_wq;
+	atomic_t ntf_refcnt;
 };
 
 /* Simple check to find out if a given net was properly initialized */

commit 256a89fa3deb6bb699b794e5bf00a72e2fe558b0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 12:04:11 2017 +0200

    nfds: avoid gettimeofday for nfssvc_boot time
    
    do_gettimeofday() is deprecated and we should generally use time64_t
    based functions instead.
    
    In case of nfsd, all three users of nfssvc_boot only use the initial
    time as a unique token, and are not affected by it overflowing, so they
    are not affected by the y2038 overflow.
    
    This converts the structure to timespec64 anyway and adds comments
    to all uses, to document that we have thought about it and avoid
    having to look at it again.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 3714231a9d0f..1c91391f4805 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -107,7 +107,7 @@ struct nfsd_net {
 	bool lockd_up;
 
 	/* Time of server startup */
-	struct timeval nfssvc_boot;
+	struct timespec64 nfssvc_boot;
 
 	/*
 	 * Max number of connections this nfsd container will allow. Defaults

commit c7d03a00b56fc23c3a01a8353789ad257363e281
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Nov 17 04:58:21 2016 +0300

    netns: make struct pernet_operations::id unsigned int
    
    Make struct pernet_operations::id unsigned.
    
    There are 2 reasons to do so:
    
    1)
    This field is really an index into an zero based array and
    thus is unsigned entity. Using negative value is out-of-bound
    access by definition.
    
    2)
    On x86_64 unsigned 32-bit data which are mixed with pointers
    via array indexing or offsets added or subtracted to pointers
    are preffered to signed 32-bit data.
    
    "int" being used as an array index needs to be sign-extended
    to 64-bit before being used.
    
            void f(long *p, int i)
            {
                    g(p[i]);
            }
    
      roughly translates to
    
            movsx   rsi, esi
            mov     rdi, [rsi+...]
            call    g
    
    MOVSX is 3 byte instruction which isn't necessary if the variable is
    unsigned because x86_64 is zero extending by default.
    
    Now, there is net_generic() function which, you guessed it right, uses
    "int" as an array index:
    
            static inline void *net_generic(const struct net *net, int id)
            {
                    ...
                    ptr = ng->ptr[id - 1];
                    ...
            }
    
    And this function is used a lot, so those sign extensions add up.
    
    Patch snipes ~1730 bytes on allyesconfig kernel (without all junk
    messing with code generation):
    
            add/remove: 0/0 grow/shrink: 70/598 up/down: 396/-2126 (-1730)
    
    Unfortunately some functions actually grow bigger.
    This is a semmingly random artefact of code generation with register
    allocator being used differently. gcc decides that some variable
    needs to live in new r8+ registers and every access now requires REX
    prefix. Or it is shifted into r12, so [r12+0] addressing mode has to be
    used which is longer than [r8]
    
    However, overall balance is in negative direction:
    
            add/remove: 0/0 grow/shrink: 70/598 up/down: 396/-2126 (-1730)
            function                                     old     new   delta
            nfsd4_lock                                  3886    3959     +73
            tipc_link_build_proto_msg                   1096    1140     +44
            mac80211_hwsim_new_radio                    2776    2808     +32
            tipc_mon_rcv                                1032    1058     +26
            svcauth_gss_legacy_init                     1413    1429     +16
            tipc_bcbase_select_primary                   379     392     +13
            nfsd4_exchange_id                           1247    1260     +13
            nfsd4_setclientid_confirm                    782     793     +11
                    ...
            put_client_renew_locked                      494     480     -14
            ip_set_sockfn_get                            730     716     -14
            geneve_sock_add                              829     813     -16
            nfsd4_sequence_done                          721     703     -18
            nlmclnt_lookup_host                          708     686     -22
            nfsd4_lockt                                 1085    1063     -22
            nfs_get_client                              1077    1050     -27
            tcf_bpf_init                                1106    1076     -30
            nfsd4_encode_fattr                          5997    5930     -67
            Total: Before=154856051, After=154854321, chg -0.00%
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index ee36efd5aece..3714231a9d0f 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -124,5 +124,5 @@ struct nfsd_net {
 /* Simple check to find out if a given net was properly initialized */
 #define nfsd_netns_ready(nn) ((nn)->sessionid_hashtbl)
 
-extern int nfsd_net_id;
+extern unsigned int nfsd_net_id;
 #endif /* __NFSD_NETNS_H__ */

commit 0cc11a61b80a1ab1d12f1597b27b8b45ef8bac4a
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Oct 20 09:34:31 2016 -0400

    nfsd: move blocked lock handling under a dedicated spinlock
    
    Bruce was hitting some lockdep warnings in testing, showing that we
    could hit a deadlock with the new CB_NOTIFY_LOCK handling, involving a
    rather complex situation involving four different spinlocks.
    
    The crux of the matter is that we end up taking the nn->client_lock in
    the lm_notify handler. The simplest fix is to just declare a new
    per-nfsd_net spinlock to protect the new CB_NOTIFY_LOCK structures.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index b10d557f9c9e..ee36efd5aece 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -84,6 +84,8 @@ struct nfsd_net {
 	struct list_head client_lru;
 	struct list_head close_lru;
 	struct list_head del_recall_lru;
+
+	/* protected by blocked_locks_lock */
 	struct list_head blocked_locks_lru;
 
 	struct delayed_work laundromat_work;
@@ -91,6 +93,9 @@ struct nfsd_net {
 	/* client_lock protects the client lru list and session hash table */
 	spinlock_t client_lock;
 
+	/* protects blocked_locks_lru */
+	spinlock_t blocked_locks_lock;
+
 	struct file *rec_file;
 	bool in_grace;
 	const struct nfsd4_client_tracking_ops *client_tracking_ops;

commit 7919d0a27f1e7cb324e023776aa1cbff00f1ee7b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Sep 16 16:28:25 2016 -0400

    nfsd: add a LRU list for blocked locks
    
    It's possible for a client to call in on a lock that is blocked for a
    long time, but discontinue polling for it. A malicious client could
    even set a lock on a file, and then spam the server with failing lock
    requests from different lockowners that pile up in a DoS attack.
    
    Add the blocked lock structures to a per-net namespace LRU when hashing
    them, and timestamp them. If the lock request is not revisited after a
    lease period, we'll drop it under the assumption that the client is no
    longer interested.
    
    This also gives us a mechanism to clean up these objects at server
    shutdown time as well.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 5fbf3bbd00d0..b10d557f9c9e 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -84,6 +84,7 @@ struct nfsd_net {
 	struct list_head client_lru;
 	struct list_head close_lru;
 	struct list_head del_recall_lru;
+	struct list_head blocked_locks_lru;
 
 	struct delayed_work laundromat_work;
 

commit 7c582e4faaf2593116068fc9ec8f5d81f720c02b
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Nov 22 08:22:10 2015 +0100

    nfsd: recover: constify nfsd4_client_tracking_ops structures
    
    The nfsd4_client_tracking_ops structures are never modified, so declare
    them as const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Reviewed-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index d8b16c2568f3..5fbf3bbd00d0 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -92,7 +92,7 @@ struct nfsd_net {
 
 	struct file *rec_file;
 	bool in_grace;
-	struct nfsd4_client_tracking_ops *client_tracking_ops;
+	const struct nfsd4_client_tracking_ops *client_tracking_ops;
 
 	time_t nfsd4_lease;
 	time_t nfsd4_grace;

commit 19311aa8353644c18d609291e0078843d1c22ece
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Sat Jul 18 07:33:31 2015 +0800

    nfsd: New counter for generating client confirm verifier
    
    If using clientid_counter, it seems possible that gen_confirm could
    generate the same verifier for the same client in some situations.
    
    Add a new counter for client confirm verifier to make sure gen_confirm
    generates a different verifier on each call for the same clientid.
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@poochiereds.net>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index ea6749a32760..d8b16c2568f3 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -110,6 +110,7 @@ struct nfsd_net {
 	unsigned int max_connections;
 
 	u32 clientid_counter;
+	u32 clverifier_counter;
 
 	struct svc_serv *nfsd_serv;
 };

commit 14a571a8ecc69feadce8973bd67090a7d0430123
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Tue Aug 5 15:13:30 2014 -0400

    nfsd: add some comments to the nfsd4 object definitions
    
    Add some comments that describe what each of these objects is, and how
    they related to one another.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 3831ef6e5c75..ea6749a32760 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -34,6 +34,14 @@
 struct cld_net;
 struct nfsd4_client_tracking_ops;
 
+/*
+ * Represents a nfsd "container". With respect to nfsv4 state tracking, the
+ * fields of interest are the *_id_hashtbls and the *_name_tree. These track
+ * the nfs4_client objects by either short or long form clientid.
+ *
+ * Each nfsd_net runs a nfs4_laundromat workqueue job when necessary to clean
+ * up expired clients and delegations within the container.
+ */
 struct nfsd_net {
 	struct cld_net *cld_net;
 

commit 294ac32e99861f6efee548a6b7afb27c32cd502f
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Wed Jul 30 08:27:15 2014 -0400

    nfsd: protect clid and verifier generation with client_lock
    
    The clid counter is a global counter currently. Move it to be a per-net
    property so that it can be properly protected by the nn->client_lock
    instead of relying on the client_mutex.
    
    The verifier generator is also potentially racy if there are two
    simultaneous callers. Generate the verifier when we generate the clid
    value, so it's also created under the client_lock. With this, there's
    no need to keep two counters as they'd always be in sync anyway, so
    just use the clientid_counter for both.
    
    As Trond points out, what would be best is to eventually move this
    code to use IDR instead of the hash tables. That would also help ensure
    uniqueness, but that's probably best done as a separate project.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index e1f479c162b5..3831ef6e5c75 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -92,9 +92,7 @@ struct nfsd_net {
 	bool nfsd_net_up;
 	bool lockd_up;
 
-	/*
-	 * Time of server startup
-	 */
+	/* Time of server startup */
 	struct timeval nfssvc_boot;
 
 	/*
@@ -103,6 +101,8 @@ struct nfsd_net {
 	 */
 	unsigned int max_connections;
 
+	u32 clientid_counter;
+
 	struct svc_serv *nfsd_serv;
 };
 

commit d4f0489f38512027fdf5190d5d1d8007e155e88f
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Jul 29 21:34:36 2014 -0400

    nfsd: Move the open owner hash table into struct nfs4_client
    
    Preparation for removing the client_mutex.
    
    Convert the open owner hash table into a per-client table and protect it
    using the nfs4_client->cl_lock spin lock.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index a71d14413d39..e1f479c162b5 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -63,7 +63,6 @@ struct nfsd_net {
 	struct rb_root conf_name_tree;
 	struct list_head *unconf_id_hashtbl;
 	struct rb_root unconf_name_tree;
-	struct list_head *ownerstr_hashtbl;
 	struct list_head *sessionid_hashtbl;
 	/*
 	 * client_lru holds client queue ordered by nfs4_client.cl_time

commit b3c32bcd9c4b8320aea504477573f0c460d2d57d
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Mon Jun 30 11:48:40 2014 -0400

    nfsd: NFSv4 lock-owners are not associated to a specific file
    
    Just like open-owners, lock-owners are associated with a name, a clientid
    and, in the case of minor version 0, a sequence id. There is no association
    to a file.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 113e1aa9b0e8..a71d14413d39 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -29,9 +29,6 @@
 #define CLIENT_HASH_SIZE                (1 << CLIENT_HASH_BITS)
 #define CLIENT_HASH_MASK                (CLIENT_HASH_SIZE - 1)
 
-#define LOCKOWNER_INO_HASH_BITS		8
-#define LOCKOWNER_INO_HASH_SIZE		(1 << LOCKOWNER_INO_HASH_BITS)
-
 #define SESSION_HASH_SIZE	512
 
 struct cld_net;
@@ -67,7 +64,6 @@ struct nfsd_net {
 	struct list_head *unconf_id_hashtbl;
 	struct rb_root unconf_name_tree;
 	struct list_head *ownerstr_hashtbl;
-	struct list_head *lockowner_ino_hashtbl;
 	struct list_head *sessionid_hashtbl;
 	/*
 	 * client_lru holds client queue ordered by nfs4_client.cl_time

commit 5b8db00bae39e5ecd9bafb05478cca5b42564ab1
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Wed Jul 2 16:11:22 2014 -0400

    nfsd: add a new /proc/fs/nfsd/max_connections file
    
    Currently, the maximum number of connections that nfsd will allow
    is based on the number of threads spawned. While this is fine for a
    default, there really isn't a clear relationship between the two.
    
    The number of threads corresponds to the number of concurrent requests
    that we want to allow the server to process at any given time. The
    connection limit corresponds to the maximum number of clients that we
    want to allow the server to handle. These are two entirely different
    quantities.
    
    Break the dependency on increasing threads in order to allow for more
    connections, by adding a new per-net parameter that can be set to a
    non-zero value. The default is still to base it on the number of threads,
    so there should be no behavior change for anyone who doesn't use it.
    
    Cc: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index d32b3aa6600d..113e1aa9b0e8 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -102,6 +102,12 @@ struct nfsd_net {
 	 */
 	struct timeval nfssvc_boot;
 
+	/*
+	 * Max number of connections this nfsd container will allow. Defaults
+	 * to '0' which is means that it bases this on the number of threads.
+	 */
+	unsigned int max_connections;
+
 	struct svc_serv *nfsd_serv;
 };
 

commit 8ef667140c52e9b88934664954217f28559c75d6
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Tue Dec 31 13:17:30 2013 +0800

    NFSD: Don't start lockd when only NFSv4 is running
    
    When starting without nfsv2 and nfsv3, nfsd does not need to start
    lockd (and certainly doesn't need to fail because lockd failed to
    register with the portmapper).
    
    Reported-by: Gareth Williams <gareth@garethwilliams.me.uk>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 849a7c3ced22..d32b3aa6600d 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -95,6 +95,7 @@ struct nfsd_net {
 	time_t nfsd4_grace;
 
 	bool nfsd_net_up;
+	bool lockd_up;
 
 	/*
 	 * Time of server startup

commit e8c69d17d1ef8437aee729322db005573a467fd6
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Thu Mar 21 15:19:33 2013 -0400

    nfsd4: make del_recall_lru per-network-namespace
    
    If nothing else this simplifies the nfs4_state_shutdown_net logic a tad.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 1051bebff1b0..849a7c3ced22 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -80,6 +80,7 @@ struct nfsd_net {
 	 */
 	struct list_head client_lru;
 	struct list_head close_lru;
+	struct list_head del_recall_lru;
 
 	struct delayed_work laundromat_work;
 

commit 9dd9845f084cda07ce00cca32a5ba8fbcbbfbcaf
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Thu Dec 6 14:23:24 2012 +0300

    nfsd: make NFSd service structure allocated per net
    
    This patch makes main step in NFSd containerisation.
    
    There could be different approaches to how to make NFSd able to handle
    incoming RPC request from different network namespaces.  The two main
    options are:
    
    1) Share NFSd kthreads betwween all network namespaces.
    2) Create separated pool of threads for each namespace.
    
    While first approach looks more flexible, second one is simpler and
    non-racy.  This patch implements the second option.
    
    To make it possible to allocate separate pools of threads, we have to
    make it possible to allocate separate NFSd service structures per net.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 3b283eaab10d..1051bebff1b0 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -99,6 +99,8 @@ struct nfsd_net {
 	 * Time of server startup
 	 */
 	struct timeval nfssvc_boot;
+
+	struct svc_serv *nfsd_serv;
 };
 
 /* Simple check to find out if a given net was properly initialized */

commit b9c0ef8571c6ae33465dcf41d496ce2ad783c49d
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Thu Dec 6 14:23:19 2012 +0300

    nfsd: make NFSd service boot time per-net
    
    This is simple: an NFSd service can be started at different times in
    different network environments. So, its "boot time" has to be assigned
    per net.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 543ac486fd5d..3b283eaab10d 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -94,6 +94,11 @@ struct nfsd_net {
 	time_t nfsd4_grace;
 
 	bool nfsd_net_up;
+
+	/*
+	 * Time of server startup
+	 */
+	struct timeval nfssvc_boot;
 };
 
 /* Simple check to find out if a given net was properly initialized */

commit 2c2fe2909e124c32a34dbbb3ac129112524fc540
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Thu Dec 6 14:23:14 2012 +0300

    nfsd: per-net NFSd up flag introduced
    
    This patch introduces introduces per-net "nfsd_net_up" boolean flag, which has
    the same purpose as general "nfsd_up" flag - skip init or shutdown of per-net
    resources in case of they are inited on shutted down respectively.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index fac4123c918c..543ac486fd5d 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -92,6 +92,8 @@ struct nfsd_net {
 
 	time_t nfsd4_lease;
 	time_t nfsd4_grace;
+
+	bool nfsd_net_up;
 };
 
 /* Simple check to find out if a given net was properly initialized */

commit 9a9c6478a8b6ce8b6da6b6d1e15f365b505895cd
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Dec 4 14:29:27 2012 +0300

    nfsd: make NFSv4 recovery client tracking options per net
    
    Pointer to client tracking operations - client_tracking_ops - have to be
    containerized, because different environment can support different trackers
    (for example, legacy tracker currently is not suported in container).
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 964b5542f027..fac4123c918c 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -35,6 +35,7 @@
 #define SESSION_HASH_SIZE	512
 
 struct cld_net;
+struct nfsd4_client_tracking_ops;
 
 struct nfsd_net {
 	struct cld_net *cld_net;
@@ -87,6 +88,7 @@ struct nfsd_net {
 
 	struct file *rec_file;
 	bool in_grace;
+	struct nfsd4_client_tracking_ops *client_tracking_ops;
 
 	time_t nfsd4_lease;
 	time_t nfsd4_grace;

commit 44e34da60b24ca14666534b61cc9579aa4e1eac5
Author: Bryan Schumaker <bjschuma@netapp.com>
Date:   Thu Nov 29 11:40:39 2012 -0500

    NFSD: Clean up forgetting clients
    
    I added in a generic for-each loop that takes a pass over the client_lru
    list for the current net namespace and calls some function.  The next few
    patches will update other operations to use this function as well.  A value
    of 0 still means "forget everything that is found".
    
    Signed-off-by: Bryan Schumaker <bjschuma@netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 2c4b2e2896dd..964b5542f027 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -92,5 +92,8 @@ struct nfsd_net {
 	time_t nfsd4_grace;
 };
 
+/* Simple check to find out if a given net was properly initialized */
+#define nfsd_netns_ready(nn) ((nn)->sessionid_hashtbl)
+
 extern int nfsd_net_id;
 #endif /* __NFSD_NETNS_H__ */

commit 5284b44e438580a50e8cc5189297a73a48a45ecb
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Nov 27 14:11:49 2012 +0300

    nfsd: make NFSv4 grace time per net
    
    Grace time is a part of NFSv4 state engine, which is constructed per network
    namespace.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 0c20be82cb01..2c4b2e2896dd 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -89,6 +89,7 @@ struct nfsd_net {
 	bool in_grace;
 
 	time_t nfsd4_lease;
+	time_t nfsd4_grace;
 };
 
 extern int nfsd_net_id;

commit 3d7337115d06f21970e23684f4d2e62e3a44c572
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Nov 27 14:11:44 2012 +0300

    nfsd: make NFSv4 lease time per net
    
    Lease time is a part of NFSv4 state engine, which is constructed per network
    namespace.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 9047706b3e10..0c20be82cb01 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -87,6 +87,8 @@ struct nfsd_net {
 
 	struct file *rec_file;
 	bool in_grace;
+
+	time_t nfsd4_lease;
 };
 
 extern int nfsd_net_id;

commit f141f79d709de447c8c92ba54821740ae53a5d07
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Nov 26 16:16:30 2012 +0300

    nfsd: recovery - make in_grace per net
    
    Flag in_grace is a part of client tracking state, which is network namesapce
    aware. So let'a replace global static variable with per-net one.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 130563210c68..9047706b3e10 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -86,6 +86,7 @@ struct nfsd_net {
 	spinlock_t client_lock;
 
 	struct file *rec_file;
+	bool in_grace;
 };
 
 extern int nfsd_net_id;

commit 3a0733692f6665a28c50ebadb6d9db2b183bcb91
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Nov 26 16:16:25 2012 +0300

    nfsd: recovery - make rec_file per net
    
    Opening and closing of this file is done in client tracking init and exit
    operations.
    Client tracking is done in network namespace context already. So let's make
    this file opened and closed per network context - this will simlify it's
    management.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 08d5fa1ce82a..130563210c68 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -84,6 +84,8 @@ struct nfsd_net {
 
 	/* client_lock protects the client lru list and session hash table */
 	spinlock_t client_lock;
+
+	struct file *rec_file;
 };
 
 extern int nfsd_net_id;

commit c9a4962881929df7f1ef6e63e1b9da304faca4dd
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Nov 26 15:21:58 2012 +0300

    nfsd: make client_lock per net
    
    This lock protects the client lru list and session hash table, which are
    allocated per network namespace already.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 227b93ebb622..08d5fa1ce82a 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -81,6 +81,9 @@ struct nfsd_net {
 	struct list_head close_lru;
 
 	struct delayed_work laundromat_work;
+
+	/* client_lock protects the client lru list and session hash table */
+	spinlock_t client_lock;
 };
 
 extern int nfsd_net_id;

commit 0912128149e86b48ed946371298d7fe61120d627
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:22:17 2012 +0300

    nfsd: make laundromat network namespace aware
    
    This patch moves laundromat_work to nfsd per-net context, thus allowing to run
    multiple laundries.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index a356ea3dc686..227b93ebb622 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -79,6 +79,8 @@ struct nfsd_net {
 	 */
 	struct list_head client_lru;
 	struct list_head close_lru;
+
+	struct delayed_work laundromat_work;
 };
 
 extern int nfsd_net_id;

commit 73758fed711b847d833b9b0db59137eaeed06485
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:22:01 2012 +0300

    nfsd: make close_lru list per net
    
    This list holds nfs4 clients (open) stateowner queue for last close replay,
    which are network namespace aware. So let's make this list per network
    namespace too.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 9a98a0aeee68..a356ea3dc686 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -71,8 +71,14 @@ struct nfsd_net {
 	/*
 	 * client_lru holds client queue ordered by nfs4_client.cl_time
 	 * for lease renewal.
+	 *
+	 * close_lru holds (open) stateowner queue ordered by nfs4_stateowner.so_time
+	 * for last close replay.
+	 *
+	 * All of the above fields are protected by the client_mutex.
 	 */
 	struct list_head client_lru;
+	struct list_head close_lru;
 };
 
 extern int nfsd_net_id;

commit 5ed58bb243484e01e82ffca8451907403168e262
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:56 2012 +0300

    nfsd: make client_lru list per net
    
    This list holds nfs4 clients queue for lease renewal, which are network
    namespace aware. So let's make this list per network namespace too.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index da33d3f804b0..9a98a0aeee68 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -68,6 +68,11 @@ struct nfsd_net {
 	struct list_head *ownerstr_hashtbl;
 	struct list_head *lockowner_ino_hashtbl;
 	struct list_head *sessionid_hashtbl;
+	/*
+	 * client_lru holds client queue ordered by nfs4_client.cl_time
+	 * for lease renewal.
+	 */
+	struct list_head client_lru;
 };
 
 extern int nfsd_net_id;

commit 1872de0e8171904612ee85de218fa045bc473cad
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:51 2012 +0300

    nfsd: make sessionid_hashtbl allocated per net
    
    This hash holds established sessions state and closely associated with
    nfs4_clients info, which are network namespace aware. So let's make it
    allocated per network namespace too.
    
    Note: this hash can be allocated in per-net operations. But it looks
    better to allocate it on nfsd state start and thus don't waste resources
    if server is not running.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 2281f6df5573..da33d3f804b0 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -32,6 +32,8 @@
 #define LOCKOWNER_INO_HASH_BITS		8
 #define LOCKOWNER_INO_HASH_SIZE		(1 << LOCKOWNER_INO_HASH_BITS)
 
+#define SESSION_HASH_SIZE	512
+
 struct cld_net;
 
 struct nfsd_net {
@@ -65,6 +67,7 @@ struct nfsd_net {
 	struct rb_root unconf_name_tree;
 	struct list_head *ownerstr_hashtbl;
 	struct list_head *lockowner_ino_hashtbl;
+	struct list_head *sessionid_hashtbl;
 };
 
 extern int nfsd_net_id;

commit 20e9e2bc98b907efe82621797c561f6169d63d96
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:46 2012 +0300

    nfsd: make lockowner_ino_hashtbl allocated per net
    
    This hash holds file lock owners and closely associated with nfs4_clients info,
    which are network namespace aware. So let's make it allocated per network
    namespace too.
    
    Note: this hash can be allocated in per-net operations. But it looks
    better to allocate it on nfsd state start and thus don't waste resources
    if server is not running.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 46cca9494c7a..2281f6df5573 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -29,6 +29,9 @@
 #define CLIENT_HASH_SIZE                (1 << CLIENT_HASH_BITS)
 #define CLIENT_HASH_MASK                (CLIENT_HASH_SIZE - 1)
 
+#define LOCKOWNER_INO_HASH_BITS		8
+#define LOCKOWNER_INO_HASH_SIZE		(1 << LOCKOWNER_INO_HASH_BITS)
+
 struct cld_net;
 
 struct nfsd_net {
@@ -61,6 +64,7 @@ struct nfsd_net {
 	struct list_head *unconf_id_hashtbl;
 	struct rb_root unconf_name_tree;
 	struct list_head *ownerstr_hashtbl;
+	struct list_head *lockowner_ino_hashtbl;
 };
 
 extern int nfsd_net_id;

commit 9b5311374057e5c87017ea3756e566047c9b61e7
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:41 2012 +0300

    nfsd: make ownerstr_hashtbl allocated per net
    
    This hash holds open owner state and closely associated with nfs4_clients
    info, which are network namespace aware. So let's make it allocated per
    network namespace too.
    
    Note: this hash can be allocated in per-net operations. But it looks
    better to allocate it on nfsd state start and thus don't waste resources
    if server is not running.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 1e76030e1d16..46cca9494c7a 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -60,6 +60,7 @@ struct nfsd_net {
 	struct rb_root conf_name_tree;
 	struct list_head *unconf_id_hashtbl;
 	struct rb_root unconf_name_tree;
+	struct list_head *ownerstr_hashtbl;
 };
 
 extern int nfsd_net_id;

commit a99454aa4ff1241a19dcb486fa302d3e8cc09e5b
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:36 2012 +0300

    nfsd: make unconf_name_tree per net
    
    This hash holds nfs4_clients info, which are network namespace aware.
    So let's make it allocated per network namespace.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 1ff781f9c3d0..1e76030e1d16 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -50,12 +50,16 @@ struct nfsd_net {
 	 *
 	 * conf_id_hashtbl[], and conf_name_tree hold confirmed
 	 * setclientid_confirmed info.
+	 *
+	 * unconf_str_hastbl[] and unconf_name_tree hold unconfirmed
+	 * setclientid info.
 	 */
 	struct list_head *reclaim_str_hashtbl;
 	int reclaim_str_hashtbl_size;
 	struct list_head *conf_id_hashtbl;
 	struct rb_root conf_name_tree;
 	struct list_head *unconf_id_hashtbl;
+	struct rb_root unconf_name_tree;
 };
 
 extern int nfsd_net_id;

commit 0a7ec37727dcc3293cd4c9958b25c43f3a797d47
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:31 2012 +0300

    nfsd: make unconf_id_hashtbl allocated per net
    
    This hash holds nfs4_clients info, which are network namespace aware.
    So let's make it allocated per network namespace.
    
    Note: this hash can be allocated in per-net operations. But it looks
    better to allocate it on nfsd state start and thus don't waste resources
    if server is not running.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index afd911638464..1ff781f9c3d0 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -55,6 +55,7 @@ struct nfsd_net {
 	int reclaim_str_hashtbl_size;
 	struct list_head *conf_id_hashtbl;
 	struct rb_root conf_name_tree;
+	struct list_head *unconf_id_hashtbl;
 };
 
 extern int nfsd_net_id;

commit 382a62e76cbf91fb364a4cd8732761e4ecf62153
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:26 2012 +0300

    nfsd: make conf_name_tree per net
    
    This tree holds nfs4_clients info, which are network namespace aware.
    So let's make it per network namespace.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 0cc85e95e8a4..afd911638464 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -47,10 +47,14 @@ struct nfsd_net {
 	/*
 	 * reclaim_str_hashtbl[] holds known client info from previous reset/reboot
 	 * used in reboot/reset lease grace period processing
+	 *
+	 * conf_id_hashtbl[], and conf_name_tree hold confirmed
+	 * setclientid_confirmed info.
 	 */
 	struct list_head *reclaim_str_hashtbl;
 	int reclaim_str_hashtbl_size;
 	struct list_head *conf_id_hashtbl;
+	struct rb_root conf_name_tree;
 };
 
 extern int nfsd_net_id;

commit 8daae4dc0d09d44d38194f72bc91740b46a6ce53
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:21 2012 +0300

    nfsd: make conf_id_hashtbl allocated per net
    
    This hash holds nfs4_clients info, which are network namespace aware.
    So let's make it allocated per network namespace.
    
    Note: this hash can be allocated in per-net operations. But it looks
    better to allocate it on nfsd state start and thus don't waste resources
    if server is not running.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 49e54790d862..0cc85e95e8a4 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -50,6 +50,7 @@ struct nfsd_net {
 	 */
 	struct list_head *reclaim_str_hashtbl;
 	int reclaim_str_hashtbl_size;
+	struct list_head *conf_id_hashtbl;
 };
 
 extern int nfsd_net_id;

commit 52e19c09a183d82d99f10c284bc8b27933b1d1fc
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Nov 14 18:21:16 2012 +0300

    nfsd: make reclaim_str_hashtbl allocated per net
    
    This hash holds nfs4_clients info, which are network namespace aware.
    So let's make it allocated per network namespace.
    
    Note: this hash is used only by legacy tracker. So let's allocate hash in
    tracker init.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 65c2431ea32f..49e54790d862 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -24,6 +24,11 @@
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
 
+/* Hash tables for nfs4_clientid state */
+#define CLIENT_HASH_BITS                 4
+#define CLIENT_HASH_SIZE                (1 << CLIENT_HASH_BITS)
+#define CLIENT_HASH_MASK                (CLIENT_HASH_SIZE - 1)
+
 struct cld_net;
 
 struct nfsd_net {
@@ -38,6 +43,13 @@ struct nfsd_net {
 	struct lock_manager nfsd4_manager;
 	bool grace_ended;
 	time_t boot_time;
+
+	/*
+	 * reclaim_str_hashtbl[] holds known client info from previous reset/reboot
+	 * used in reboot/reset lease grace period processing
+	 */
+	struct list_head *reclaim_str_hashtbl;
+	int reclaim_str_hashtbl_size;
 };
 
 extern int nfsd_net_id;

commit 2c142baa7b237584bae7dc28630851701497e1ef
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:57:45 2012 +0400

    NFSd: make boot_time variable per network namespace
    
    NFSd's boot_time represents grace period start point in time.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index b6deebd08ef2..65c2431ea32f 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -37,6 +37,7 @@ struct nfsd_net {
 
 	struct lock_manager nfsd4_manager;
 	bool grace_ended;
+	time_t boot_time;
 };
 
 extern int nfsd_net_id;

commit a51c84ed502c25fed996afb7696fd7db2fa32fe2
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:57:37 2012 +0400

    NFSd: make grace end flag per network namespace
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index e99767d987c8..b6deebd08ef2 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -36,6 +36,7 @@ struct nfsd_net {
 	struct cache_detail *nametoid_cache;
 
 	struct lock_manager nfsd4_manager;
+	bool grace_ended;
 };
 
 extern int nfsd_net_id;

commit 5e1533c7880bb0df98f71fa683979ec296aa947d
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:56:58 2012 +0400

    NFSd: make nfsd4_manager allocated per network namespace context.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 39365636b244..e99767d987c8 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -34,6 +34,8 @@ struct nfsd_net {
 
 	struct cache_detail *idtoname_cache;
 	struct cache_detail *nametoid_cache;
+
+	struct lock_manager nfsd4_manager;
 };
 
 extern int nfsd_net_id;

commit 9e75a4dee08e8fe21f349e11c43955c34523bced
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 11 17:32:58 2012 +0400

    nfsd: make name-to-id cache allocated per network namespace context
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 948a718e24a4..39365636b244 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -33,7 +33,7 @@ struct nfsd_net {
 	struct cache_detail *svc_export_cache;
 
 	struct cache_detail *idtoname_cache;
-
+	struct cache_detail *nametoid_cache;
 };
 
 extern int nfsd_net_id;

commit c2e76ef5e0716bc82364e6049e8023ffd5bbe395
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 11 17:32:51 2012 +0400

    nfsd: make id-to-name cache allocated per network namespace context
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 9794c6c7d133..948a718e24a4 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -31,6 +31,9 @@ struct nfsd_net {
 
 	struct cache_detail *svc_expkey_cache;
 	struct cache_detail *svc_export_cache;
+
+	struct cache_detail *idtoname_cache;
+
 };
 
 extern int nfsd_net_id;

commit e5f06f720eff24e32f1cc08ec03bcc8c4b2d2934
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 11 15:13:28 2012 +0400

    nfsd: make expkey cache allocated per network namespace context
    
    This patch also changes svcauth_unix_purge() function: added network namespace
    as a parameter and thus loop over all networks was replaced by only one call
    for ip map cache purge.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index c1c6242942a9..9794c6c7d133 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -29,6 +29,7 @@ struct cld_net;
 struct nfsd_net {
 	struct cld_net *cld_net;
 
+	struct cache_detail *svc_expkey_cache;
 	struct cache_detail *svc_export_cache;
 };
 

commit b3853e0ea1f2ef58f7e7c03e47819e2ae3766dea
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Apr 11 15:13:21 2012 +0400

    nfsd: make export cache allocated per network namespace context
    
    This patch also changes prototypes of nfsd_export_flush() and exp_rootfh():
    network namespace parameter added.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 12e0cff435b4..c1c6242942a9 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -28,6 +28,8 @@ struct cld_net;
 
 struct nfsd_net {
 	struct cld_net *cld_net;
+
+	struct cache_detail *svc_export_cache;
 };
 
 extern int nfsd_net_id;

commit 797a9d797f8483bb67f265c761b76dcd5a077a23
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Mar 29 07:52:49 2012 -0400

    nfsd: only register cld pipe notifier when CONFIG_NFSD_V4 is enabled
    
    Otherwise, we get a warning or error similar to this when building with
    CONFIG_NFSD_V4 disabled:
    
        ERROR: "nfsd4_cld_block" [fs/nfsd/nfsd.ko] undefined!
    
    Fix this by wrapping the calls to rpc_pipefs_notifier_register and
    ..._unregister in another function and providing no-op replacements
    when CONFIG_NFSD_V4 is disabled.
    
    Reported-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 66eac332bf8d..12e0cff435b4 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -31,5 +31,4 @@ struct nfsd_net {
 };
 
 extern int nfsd_net_id;
-extern struct notifier_block nfsd4_cld_block;
 #endif /* __NFSD_NETNS_H__ */

commit 813fd320c16691eac508fe350b4ee7362c6c4a56
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Mar 21 09:52:08 2012 -0400

    nfsd: add notifier to handle mount/unmount of rpc_pipefs sb
    
    In the event that rpc_pipefs isn't mounted when nfsd starts, we
    must register a notifier to handle creating the dentry once it
    is mounted, and to remove the dentry on unmount.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index 12e0cff435b4..66eac332bf8d 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -31,4 +31,5 @@ struct nfsd_net {
 };
 
 extern int nfsd_net_id;
+extern struct notifier_block nfsd4_cld_block;
 #endif /* __NFSD_NETNS_H__ */

commit 7ea34ac15e45b790f2faa7d5f69c560a43f2de70
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Mar 21 09:52:05 2012 -0400

    nfsd: add a per-net-namespace struct for nfsd
    
    Eventually, we'll need this when nfsd gets containerized fully. For
    now, create a struct on a per-net-namespace basis that will just hold
    a pointer to the cld_net structure. That struct will hold all of the
    per-net data that we need for the cld tracker.
    
    Eventually we can add other pernet objects to struct nfsd_net.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
new file mode 100644
index 000000000000..12e0cff435b4
--- /dev/null
+++ b/fs/nfsd/netns.h
@@ -0,0 +1,34 @@
+/*
+ * per net namespace data structures for nfsd
+ *
+ * Copyright (C) 2012, Jeff Layton <jlayton@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 51
+ * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __NFSD_NETNS_H__
+#define __NFSD_NETNS_H__
+
+#include <net/net_namespace.h>
+#include <net/netns/generic.h>
+
+struct cld_net;
+
+struct nfsd_net {
+	struct cld_net *cld_net;
+};
+
+extern int nfsd_net_id;
+#endif /* __NFSD_NETNS_H__ */
