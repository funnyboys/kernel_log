commit ae98043f5f7fa45b65084f70e3ada3209873ebb4
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Tue Sep 4 15:46:30 2018 -0700

    nilfs2: convert to SPDX license tags
    
    Remove the verbose license text from NILFS2 files and replace them with
    SPDX tags.  This does not change the license of any of the code.
    
    Link: http://lkml.kernel.org/r/1535624528-5982-1-git-send-email-konishi.ryusuke@lab.ntt.co.jp
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 04634e3e3d58..f5cf5308f3fc 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -1,18 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * segment.h - NILFS Segment constructor prototypes and definitions
  *
  * Copyright (C) 2005-2008 Nippon Telegraph and Telephone Corporation.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Written by Ryusuke Konishi.
  *
  */

commit fb04b91bc2c3a83e9e2ba9c5ce0f0124dd3ffef0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Feb 6 15:39:21 2018 -0800

    nilfs2: use time64_t internally
    
    The superblock and segment timestamps are used only internally in nilfs2
    and can be read out using sysfs.
    
    Since we are using the old 'get_seconds()' interface and store the data
    as timestamps, the behavior differs slightly between 64-bit and 32-bit
    kernels, the latter will show incorrect timestamps after 2038 in sysfs,
    and presumably fail completely in 2106 as comparisons go wrong.
    
    This changes nilfs2 to use time64_t with ktime_get_real_seconds() to
    handle timestamps, making the behavior consistent and correct on both
    32-bit and 64-bit machines.
    
    The on-disk format already uses 64-bit timestamps, so nothing changes
    there.
    
    Link: http://lkml.kernel.org/r/20180122211050.1286441-1-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 84084a4d9b3e..04634e3e3d58 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -157,7 +157,7 @@ struct nilfs_sc_info {
 	unsigned long		sc_blk_cnt;
 	unsigned long		sc_datablk_cnt;
 	unsigned long		sc_nblk_this_inc;
-	time_t			sc_seg_ctime;
+	time64_t		sc_seg_ctime;
 	__u64			sc_cno;
 	unsigned long		sc_flags;
 

commit 7554e9c4cfa208acf3164a86c05aaa967b043425
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Nov 17 15:29:32 2017 -0800

    fs/nilfs2: convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer
    to all timer callbacks, switch to using the new timer_setup() and
    from_timer() to pass the timer pointer explicitly.  This requires adding
    a pointer to hold the timer's target task, as the lifetime of sc_task
    doesn't appear to match the timer's task.
    
    Link: http://lkml.kernel.org/r/20171016235900.GA102729@beast
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 1060949d7dd2..84084a4d9b3e 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -180,6 +180,7 @@ struct nilfs_sc_info {
 	unsigned long		sc_watermark;
 
 	struct timer_list	sc_timer;
+	struct task_struct     *sc_timer_task;
 	struct task_struct     *sc_task;
 };
 

commit e63e88bc53bac7e4c3f592f8126c51a7569be673
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Tue Aug 2 14:05:30 2016 -0700

    nilfs2: move ioctl interface and disk layout to uapi separately
    
    The header file "include/linux/nilfs2_fs.h" is composed of parts for
    ioctl and disk format, and both are intended to be shared with user
    space programs.
    
    This moves them to the uapi directory "include/uapi/linux" splitting the
    file to "nilfs2_api.h" and "nilfs2_ondisk.h".  The following minor
    changes are accompanied by this migration:
    
     - nilfs_direct_node struct in nilfs2/direct.h is converged to
       nilfs2_ondisk.h because it's an on-disk structure.
     - inline functions nilfs_rec_len_from_disk() and
       nilfs_rec_len_to_disk() are moved to nilfs2/dir.c.
    
    Link: http://lkml.kernel.org/r/1465825507-3407-4-git-send-email-konishi.ryusuke@lab.ntt.co.jp
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 6565c10b7b76..1060949d7dd2 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -23,7 +23,6 @@
 #include <linux/fs.h>
 #include <linux/buffer_head.h>
 #include <linux/workqueue.h>
-#include <linux/nilfs2_fs.h>
 #include "nilfs.h"
 
 struct nilfs_root;

commit 076a378ba6e6b6ddd5f2336aa0876349b7d36409
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon May 23 16:23:48 2016 -0700

    nilfs2: fix block comments
    
    This fixes block comments with proper formatting to eliminate the
    following checkpatch.pl warnings:
    
      "WARNING: Block comments use * on subsequent lines"
      "WARNING: Block comments use a trailing */ on a separate line"
    
    Link: http://lkml.kernel.org/r/1462886671-3521-8-git-send-email-konishi.ryusuke@lab.ntt.co.jp
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 27822e760d3f..6565c10b7b76 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -189,11 +189,15 @@ enum {
 	NILFS_SC_DIRTY,		/* One or more dirty meta-data blocks exist */
 	NILFS_SC_UNCLOSED,	/* Logical segment is not closed */
 	NILFS_SC_SUPER_ROOT,	/* The latest segment has a super root */
-	NILFS_SC_PRIOR_FLUSH,	/* Requesting immediate flush without making a
-				   checkpoint */
-	NILFS_SC_HAVE_DELTA,	/* Next checkpoint will have update of files
-				   other than DAT, cpfile, sufile, or files
-				   moved by GC */
+	NILFS_SC_PRIOR_FLUSH,	/*
+				 * Requesting immediate flush without making a
+				 * checkpoint
+				 */
+	NILFS_SC_HAVE_DELTA,	/*
+				 * Next checkpoint will have update of files
+				 * other than DAT, cpfile, sufile, or files
+				 * moved by GC.
+				 */
 };
 
 /* sc_state */
@@ -203,17 +207,23 @@ enum {
 /*
  * Constant parameters
  */
-#define NILFS_SC_CLEANUP_RETRY	    3  /* Retry count of construction when
-					  destroying segctord */
+#define NILFS_SC_CLEANUP_RETRY	    3  /*
+					* Retry count of construction when
+					* destroying segctord
+					*/
 
 /*
  * Default values of timeout, in seconds.
  */
-#define NILFS_SC_DEFAULT_TIMEOUT    5   /* Timeout value of dirty blocks.
-					   It triggers construction of a
-					   logical segment with a super root */
-#define NILFS_SC_DEFAULT_SR_FREQ    30  /* Maximum frequency of super root
-					   creation */
+#define NILFS_SC_DEFAULT_TIMEOUT    5   /*
+					 * Timeout value of dirty blocks.
+					 * It triggers construction of a
+					 * logical segment with a super root.
+					 */
+#define NILFS_SC_DEFAULT_SR_FREQ    30  /*
+					 * Maximum frequency of super root
+					 * creation
+					 */
 
 /*
  * The default threshold amount of data, in block counts.

commit 0c6c44cb9f93f7c0ad803b41ae7c0b08cf6942e2
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon May 23 16:23:39 2016 -0700

    nilfs2: avoid bare use of 'unsigned'
    
    This fixes checkpatch.pl warning "WARNING: Prefer 'unsigned int' to
    bare use of 'unsigned'".
    
    Link: http://lkml.kernel.org/r/1462886671-3521-5-git-send-email-konishi.ryusuke@lab.ntt.co.jp
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 6cb12dbee7c1..27822e760d3f 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -71,7 +71,7 @@ struct nilfs_recovery_info {
  */
 struct nilfs_cstage {
 	int			scnt;
-	unsigned		flags;
+	unsigned int		flags;
 	struct nilfs_inode_info *dirty_file_ptr;
 	struct nilfs_inode_info *gc_inode_ptr;
 };
@@ -80,7 +80,7 @@ struct nilfs_segment_buffer;
 
 struct nilfs_segsum_pointer {
 	struct buffer_head     *bh;
-	unsigned		offset; /* offset in bytes */
+	unsigned int		offset; /* offset in bytes */
 };
 
 /**

commit 4b420ab4eedc7a816ad0f2278871019de1a8ccef
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon May 23 16:23:09 2016 -0700

    nilfs2: clean up old e-mail addresses
    
    E-mail addresses of osrg.net domain are no longer available.  This
    removes them from authorship notices and prevents reporters from being
    confused.
    
    Link: http://lkml.kernel.org/r/1461935747-10380-5-git-send-email-konishi.ryusuke@lab.ntt.co.jp
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index a118eabd3ed6..6cb12dbee7c1 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -13,7 +13,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * Written by Ryusuke Konishi <ryusuke@osrg.net>
+ * Written by Ryusuke Konishi.
  *
  */
 #ifndef _NILFS_SEGMENT_H

commit 5726d0b454614a47e641a04c8106392d67a8e1ad
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon May 23 16:23:06 2016 -0700

    nilfs2: remove FSF mailing address from GPL notices
    
    This removes the extra paragraph which mentions FSF address in GPL
    notices from source code of nilfs2 and avoids the checkpatch.pl error
    related to it.
    
    Link: http://lkml.kernel.org/r/1461935747-10380-4-git-send-email-konishi.ryusuke@lab.ntt.co.jp
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 0408b9b2814b..a118eabd3ed6 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -13,10 +13,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
  * Written by Ryusuke Konishi <ryusuke@osrg.net>
  *
  */

commit 58497703837048ac501ce56056eb74b4361108fc
Author: Hitoshi Mitake <mitake.hitoshi@lab.ntt.co.jp>
Date:   Fri Nov 6 16:31:59 2015 -0800

    nilfs2: add a tracepoint for tracking stage transition of segment construction
    
    This patch adds a tracepoint for tracking stage transition of block
    collection in segment construction.  With the tracepoint, we can analysis
    the behavior of segment construction in depth.  It would be useful for
    bottleneck detection and debugging, etc.
    
    The tracepoint is created with the standard trace API of linux (like ext3,
    ext4, f2fs and btrfs).  So we can analysis with existing tools easily.  Of
    course, more detailed analysis will be possible if we can create nilfs
    specific analysis tools.
    
    Below is an example of event dump with Brendan Gregg's perf-tools
    (https://github.com/brendangregg/perf-tools).  Time consumption between
    each stage can be obtained.
    
    $ sudo bin/tpoint nilfs2:nilfs2_collection_stage_transition
    Tracing nilfs2:nilfs2_collection_stage_transition. Ctrl-C to end.
            segctord-14875 [003] ...1 28311.067794: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_INIT
            segctord-14875 [003] ...1 28311.068139: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_GC
            segctord-14875 [003] ...1 28311.068139: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_FILE
            segctord-14875 [003] ...1 28311.068486: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_IFILE
            segctord-14875 [003] ...1 28311.068540: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_CPFILE
            segctord-14875 [003] ...1 28311.068561: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_SUFILE
            segctord-14875 [003] ...1 28311.068565: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_DAT
            segctord-14875 [003] ...1 28311.068573: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_SR
            segctord-14875 [003] ...1 28311.068574: nilfs2_collection_stage_transition: sci = ffff8800ce6de000 stage = ST_DONE
    
    For capturing transition correctly, this patch adds wrappers for the
    member scnt of nilfs_cstage.  With this change, every transition of the
    stage can produce trace event in a correct manner.
    
    Signed-off-by: Hitoshi Mitake <mitake.hitoshi@lab.ntt.co.jp>
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index a48d6de1e02c..0408b9b2814b 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -67,7 +67,8 @@ struct nilfs_recovery_info {
 
 /**
  * struct nilfs_cstage - Context of collection stage
- * @scnt: Stage count
+ * @scnt: Stage count, must be accessed via wrappers:
+ *        nilfs_sc_cstage_inc(), nilfs_sc_cstage_set(), nilfs_sc_cstage_get()
  * @flags: State flags
  * @dirty_file_ptr: Pointer on dirty_files list, or inode of a target file
  * @gc_inode_ptr: Pointer on the list of gc-inodes

commit 7ef3ff2fea8bf5e4a21cef47ad87710a3d0fdb52
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Thu Feb 5 12:25:20 2015 -0800

    nilfs2: fix deadlock of segment constructor over I_SYNC flag
    
    Nilfs2 eventually hangs in a stress test with fsstress program.  This
    issue was caused by the following deadlock over I_SYNC flag between
    nilfs_segctor_thread() and writeback_sb_inodes():
    
      nilfs_segctor_thread()
        nilfs_segctor_thread_construct()
          nilfs_segctor_unlock()
            nilfs_dispose_list()
              iput()
                iput_final()
                  evict()
                    inode_wait_for_writeback()  * wait for I_SYNC flag
    
      writeback_sb_inodes()
         * set I_SYNC flag on inode->i_state
        __writeback_single_inode()
          do_writepages()
            nilfs_writepages()
              nilfs_construct_dsync_segment()
                nilfs_segctor_sync()
                   * wait for completion of segment constructor
        inode_sync_complete()
           * clear I_SYNC flag after __writeback_single_inode() completed
    
    writeback_sb_inodes() calls do_writepages() for dirty inodes after
    setting I_SYNC flag on inode->i_state.  do_writepages() in turn calls
    nilfs_writepages(), which can run segment constructor and wait for its
    completion.  On the other hand, segment constructor calls iput(), which
    can call evict() and wait for the I_SYNC flag on
    inode_wait_for_writeback().
    
    Since segment constructor doesn't know when I_SYNC will be set, it
    cannot know whether iput() will block or not unless inode->i_nlink has a
    non-zero count.  We can prevent evict() from being called in iput() by
    implementing sop->drop_inode(), but it's not preferable to leave inodes
    with i_nlink == 0 for long periods because it even defers file
    truncation and inode deallocation.  So, this instead resolves the
    deadlock by calling iput() asynchronously with a workqueue for inodes
    with i_nlink == 0.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Tested-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 38a1d0013314..a48d6de1e02c 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -26,6 +26,7 @@
 #include <linux/types.h>
 #include <linux/fs.h>
 #include <linux/buffer_head.h>
+#include <linux/workqueue.h>
 #include <linux/nilfs2_fs.h>
 #include "nilfs.h"
 
@@ -92,6 +93,8 @@ struct nilfs_segsum_pointer {
  * @sc_nblk_inc: Block count of current generation
  * @sc_dirty_files: List of files to be written
  * @sc_gc_inodes: List of GC inodes having blocks to be written
+ * @sc_iput_queue: list of inodes for which iput should be done
+ * @sc_iput_work: work struct to defer iput call
  * @sc_freesegs: array of segment numbers to be freed
  * @sc_nfreesegs: number of segments on @sc_freesegs
  * @sc_dsync_inode: inode whose data pages are written for a sync operation
@@ -135,6 +138,8 @@ struct nilfs_sc_info {
 
 	struct list_head	sc_dirty_files;
 	struct list_head	sc_gc_inodes;
+	struct list_head	sc_iput_queue;
+	struct work_struct	sc_iput_work;
 
 	__u64		       *sc_freesegs;
 	size_t			sc_nfreesegs;

commit 1cb2d38cb3e59d58e8321a0592e84b5761afb063
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon Apr 4 12:53:28 2011 +0900

    nilfs2: get rid of private page allocator
    
    Previously, nilfs was cloning pages for mmapped region to freeze their
    data and ensure consistency of checksum during writeback cycles.  A
    private page allocator was used for this page cloning.  But, we no
    longer need to do that since clear_page_dirty_for_io function sets up
    pte so that vm_ops->page_mkwrite function is called right before the
    mmapped pages are modified and nilfs_page_mkwrite function can safely
    wait for the pages to be written back to disk.
    
    So, this stops making a copy of mmapped pages during writeback, and
    eliminates the private page allocation and deallocation functions from
    nilfs.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 6c02a86745fb..38a1d0013314 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -92,7 +92,6 @@ struct nilfs_segsum_pointer {
  * @sc_nblk_inc: Block count of current generation
  * @sc_dirty_files: List of files to be written
  * @sc_gc_inodes: List of GC inodes having blocks to be written
- * @sc_copied_buffers: List of copied buffers (buffer heads) to freeze data
  * @sc_freesegs: array of segment numbers to be freed
  * @sc_nfreesegs: number of segments on @sc_freesegs
  * @sc_dsync_inode: inode whose data pages are written for a sync operation
@@ -136,7 +135,6 @@ struct nilfs_sc_info {
 
 	struct list_head	sc_dirty_files;
 	struct list_head	sc_gc_inodes;
-	struct list_head	sc_copied_buffers;
 
 	__u64		       *sc_freesegs;
 	size_t			sc_nfreesegs;

commit e3154e9748f0f337e9f6ff9dc7d7bf24d426bd1a
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Wed Mar 9 11:05:08 2011 +0900

    nilfs2: get rid of nilfs_sb_info structure
    
    This directly uses sb->s_fs_info to keep a nilfs filesystem object and
    fully removes the intermediate nilfs_sb_info structure.  With this
    change, the hierarchy of on-memory structures of nilfs will be
    simplified as follows:
    
    Before:
      super_block
           -> nilfs_sb_info
                 -> the_nilfs
                       -> cptree --+-> nilfs_root (current file system)
                                   +-> nilfs_root (snapshot A)
                                   +-> nilfs_root (snapshot B)
                                   :
                 -> nilfs_sc_info (log writer structure)
    After:
      super_block
           -> the_nilfs
                 -> cptree --+-> nilfs_root (current file system)
                             +-> nilfs_root (snapshot A)
                             +-> nilfs_root (snapshot B)
                             :
                 -> nilfs_sc_info (log writer structure)
    
    The reason why we didn't design so from the beginning is because the
    initial shape also differed from the above.  The early hierachy was
    composed of "per-mount-point" super_block -> nilfs_sb_info pairs and a
    shared nilfs object.  On the kernel 2.6.37, it was changed to the
    current shape in order to unify super block instances into one per
    device, and this cleanup became applicable as the result.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index e01998e33b31..6c02a86745fb 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -27,7 +27,7 @@
 #include <linux/fs.h>
 #include <linux/buffer_head.h>
 #include <linux/nilfs2_fs.h>
-#include "sb.h"
+#include "nilfs.h"
 
 struct nilfs_root;
 

commit f7545144c2e3d280139260df934043e0a6ccce6f
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Wed Mar 9 11:05:08 2011 +0900

    nilfs2: use sb instance instead of nilfs_sb_info struct
    
    This replaces sbi uses with direct reference to sb instance.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 9544aa97dd49..e01998e33b31 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -233,18 +233,16 @@ extern void nilfs_flush_segment(struct super_block *, ino_t);
 extern int nilfs_clean_segments(struct super_block *, struct nilfs_argv *,
 				void **);
 
-int nilfs_attach_segment_constructor(struct nilfs_sb_info *sbi,
-				     struct nilfs_root *root);
-extern void nilfs_detach_segment_constructor(struct nilfs_sb_info *);
+int nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root);
+void nilfs_detach_log_writer(struct super_block *sb);
 
 /* recovery.c */
 extern int nilfs_read_super_root_block(struct the_nilfs *, sector_t,
 				       struct buffer_head **, int);
 extern int nilfs_search_super_root(struct the_nilfs *,
 				   struct nilfs_recovery_info *);
-extern int nilfs_salvage_orphan_logs(struct the_nilfs *,
-				     struct nilfs_sb_info *,
-				     struct nilfs_recovery_info *);
+int nilfs_salvage_orphan_logs(struct the_nilfs *nilfs, struct super_block *sb,
+			      struct nilfs_recovery_info *ri);
 extern void nilfs_dispose_segment_list(struct list_head *);
 
 #endif /* _NILFS_SEGMENT_H */

commit d96bbfa28aa7a1d5a5bf549026a594d7a273c5d7
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Wed Mar 9 11:05:08 2011 +0900

    nilfs2: get rid of sc_sbi back pointer
    
    Removes sci->sc_sbi which is a back pointer to nilfs_sb_info struct
    from log writer object (nilfs_sc_info).
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index cd8056e7cbed..9544aa97dd49 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -88,7 +88,6 @@ struct nilfs_segsum_pointer {
 /**
  * struct nilfs_sc_info - Segment constructor information
  * @sc_super: Back pointer to super_block struct
- * @sc_sbi: Back pointer to nilfs_sb_info struct
  * @sc_root: root object of the current filesystem tree
  * @sc_nblk_inc: Block count of current generation
  * @sc_dirty_files: List of files to be written
@@ -131,7 +130,6 @@ struct nilfs_segsum_pointer {
  */
 struct nilfs_sc_info {
 	struct super_block     *sc_super;
-	struct nilfs_sb_info   *sc_sbi;
 	struct nilfs_root      *sc_root;
 
 	unsigned long		sc_nblk_inc;

commit e912a5b66837ee89fb025e67b5efeaa11930c2ce
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sat Aug 14 13:07:15 2010 +0900

    nilfs2: use root object to get ifile
    
    This rewrites functions using ifile so that they get ifile from
    nilfs_root object, and will remove sbi->s_ifile.  Some functions that
    don't know the root object are extended to receive it from caller.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 675d932148a4..cd8056e7cbed 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -29,6 +29,8 @@
 #include <linux/nilfs2_fs.h>
 #include "sb.h"
 
+struct nilfs_root;
+
 /**
  * struct nilfs_recovery_info - Recovery information
  * @ri_need_recovery: Recovery status
@@ -87,6 +89,7 @@ struct nilfs_segsum_pointer {
  * struct nilfs_sc_info - Segment constructor information
  * @sc_super: Back pointer to super_block struct
  * @sc_sbi: Back pointer to nilfs_sb_info struct
+ * @sc_root: root object of the current filesystem tree
  * @sc_nblk_inc: Block count of current generation
  * @sc_dirty_files: List of files to be written
  * @sc_gc_inodes: List of GC inodes having blocks to be written
@@ -129,6 +132,7 @@ struct nilfs_segsum_pointer {
 struct nilfs_sc_info {
 	struct super_block     *sc_super;
 	struct nilfs_sb_info   *sc_sbi;
+	struct nilfs_root      *sc_root;
 
 	unsigned long		sc_nblk_inc;
 
@@ -231,7 +235,8 @@ extern void nilfs_flush_segment(struct super_block *, ino_t);
 extern int nilfs_clean_segments(struct super_block *, struct nilfs_argv *,
 				void **);
 
-extern int nilfs_attach_segment_constructor(struct nilfs_sb_info *);
+int nilfs_attach_segment_constructor(struct nilfs_sb_info *sbi,
+				     struct nilfs_root *root);
 extern void nilfs_detach_segment_constructor(struct nilfs_sb_info *);
 
 /* recovery.c */

commit 6c43f41000312fefa482c3bfdd97e7f81d6be0ec
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Fri Aug 20 20:10:38 2010 +0900

    nilfs2: keep zero value in i_cno except for gc-inodes
    
    On-memory inode structures of nilfs have a member "i_cno" which stores
    a checkpoint number related to the inode.  For gc-inodes, this field
    indicates version of data each gc-inode caches for GC.  Log writer
    temporarily uses "i_cno" to transfer the latest checkpoint number.
    
    This stops the latter use and lets only gc-inodes use it.
    
    The purpose of this patch is to allow the successive change use
    "i_cno" for inode lookup.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 17c487bd8152..675d932148a4 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -107,6 +107,7 @@ struct nilfs_segsum_pointer {
  * @sc_datablk_cnt: Data block count of a file
  * @sc_nblk_this_inc: Number of blocks included in the current logical segment
  * @sc_seg_ctime: Creation time
+ * @sc_cno: checkpoint number of current log
  * @sc_flags: Internal flags
  * @sc_state_lock: spinlock for sc_state and so on
  * @sc_state: Segctord state flags
@@ -156,7 +157,7 @@ struct nilfs_sc_info {
 	unsigned long		sc_datablk_cnt;
 	unsigned long		sc_nblk_this_inc;
 	time_t			sc_seg_ctime;
-
+	__u64			sc_cno;
 	unsigned long		sc_flags;
 
 	spinlock_t		sc_state_lock;

commit aee5ce2f578b98eba16e59cb84d39a95682a836b
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sun May 23 12:21:57 2010 +0900

    nilfs2: rename nilfs_recover_logical_segments function
    
    The function name of nilfs_recover_logical_segments makes no sense.
    This changes the name into nilfs_salvage_orphan_logs to clarify the
    role of the function.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index d6bb67ee7bc8..17c487bd8152 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -238,9 +238,9 @@ extern int nilfs_read_super_root_block(struct the_nilfs *, sector_t,
 				       struct buffer_head **, int);
 extern int nilfs_search_super_root(struct the_nilfs *,
 				   struct nilfs_recovery_info *);
-extern int nilfs_recover_logical_segments(struct the_nilfs *,
-					  struct nilfs_sb_info *,
-					  struct nilfs_recovery_info *);
+extern int nilfs_salvage_orphan_logs(struct the_nilfs *,
+				     struct nilfs_sb_info *,
+				     struct nilfs_recovery_info *);
 extern void nilfs_dispose_segment_list(struct list_head *);
 
 #endif /* _NILFS_SEGMENT_H */

commit 8b94025c00f9171b41ba9c1696943f5c935b62ef
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sun May 23 01:39:02 2010 +0900

    nilfs2: refactor recovery logic routines
    
    Most functions in recovery code take an argument of a super block
    instance or a nilfs_sb_info struct for convenience sake.
    
    This replaces them aggressively with a nilfs object by applying
    __bread and __breadahead against routines using sb_bread and
    sb_breadahead.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 01e20dbb217d..d6bb67ee7bc8 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -234,9 +234,9 @@ extern int nilfs_attach_segment_constructor(struct nilfs_sb_info *);
 extern void nilfs_detach_segment_constructor(struct nilfs_sb_info *);
 
 /* recovery.c */
-extern int nilfs_read_super_root_block(struct super_block *, sector_t,
+extern int nilfs_read_super_root_block(struct the_nilfs *, sector_t,
 				       struct buffer_head **, int);
-extern int nilfs_search_super_root(struct the_nilfs *, struct nilfs_sb_info *,
+extern int nilfs_search_super_root(struct the_nilfs *,
 				   struct nilfs_recovery_info *);
 extern int nilfs_recover_logical_segments(struct the_nilfs *,
 					  struct nilfs_sb_info *,

commit c29684d6834af7b3792f2feb6bdcf8c906ad8db6
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sun May 23 20:40:32 2010 +0900

    nilfs2: remove obsolete declarations of cache constructor and destructor
    
    The commit 41c88bd7 ("nilfs2: cleanup multi
    kmem_cache_{create,destroy} code") consolidated slab constructors and
    destructors used in nilfs, but it left some declarations in header
    files.
    
    This gets rid of the obsolete declarations.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index dca142361ccf..01e20dbb217d 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -221,8 +221,6 @@ enum {
 extern struct kmem_cache *nilfs_transaction_cachep;
 
 /* segment.c */
-extern int nilfs_init_transaction_cache(void);
-extern void nilfs_destroy_transaction_cache(void);
 extern void nilfs_relax_pressure_in_lock(struct super_block *);
 
 extern int nilfs_construct_segment(struct super_block *);

commit fdce895ea5dd4e24edf1f4d693827349a4e5b3b4
Author: Li Hong <lihong.hi@gmail.com>
Date:   Sat Apr 10 23:25:39 2010 +0800

    nilfs2: change sc_timer from a pointer to an embedded one in struct nilfs_sc_info
    
    In nilfs_segctor_thread(), timer is a local variable allocated on stack. Its
    address can't be set to sci->sc_timer and passed in several procedures.
    
    It works now by chance, just because other procedures are called by
    nilfs_segctor_thread() directly or indirectly and the stack hasn't been
    deallocated yet.
    
    Signed-off-by: Li Hong <lihong.hi@gmail.com>
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 7aca76532683..dca142361ccf 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -177,7 +177,7 @@ struct nilfs_sc_info {
 	unsigned long		sc_lseg_stime;	/* in 1/HZ seconds */
 	unsigned long		sc_watermark;
 
-	struct timer_list      *sc_timer;
+	struct timer_list	sc_timer;
 	struct task_struct     *sc_task;
 };
 

commit 41c88bd74d372db5102996a4ea6167a725c24b5e
Author: Li Hong <lihong.hi@gmail.com>
Date:   Tue Apr 6 00:54:11 2010 +0800

    nilfs2: cleanup multi kmem_cache_{create,destroy} code
    
    This cleanup patch gives several improvements:
    
     - Moving all kmem_cache_{create_destroy} calls into one place, which removes
     some small function calls, cleans up error check code and clarify the logic.
    
     - Mark all initial code in __init section.
    
     - Remove some very obvious comments.
    
     - Adjust some declarations.
    
     - Fix some space-tab issues.
    
    Signed-off-by: Li Hong <lihong.hi@gmail.com>
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index e61fc797383e..7aca76532683 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -217,6 +217,8 @@ enum {
  */
 #define NILFS_SC_DEFAULT_WATERMARK  3600
 
+/* super.c */
+extern struct kmem_cache *nilfs_transaction_cachep;
 
 /* segment.c */
 extern int nilfs_init_transaction_cache(void);

commit 1e2b68bf285dce604388fcb6f85b7e612156db17
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Tue Mar 23 01:15:31 2010 +0900

    nilfs2: move pointer to super root block into logs
    
    This moves a pointer to buffer storing super root block to each log
    buffer from nilfs_sc_info struct for simplicity.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 82dfd6a686b9..e61fc797383e 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -100,7 +100,6 @@ struct nilfs_segsum_pointer {
  * @sc_write_logs: List of segment buffers to hold logs under writing
  * @sc_segbuf_nblocks: Number of available blocks in segment buffers.
  * @sc_curseg: Current segment buffer
- * @sc_super_root: Pointer to the super root buffer
  * @sc_stage: Collection stage
  * @sc_finfo_ptr: pointer to the current finfo struct in the segment summary
  * @sc_binfo_ptr: pointer to the current binfo struct in the segment summary
@@ -148,7 +147,6 @@ struct nilfs_sc_info {
 	struct list_head	sc_write_logs;
 	unsigned long		sc_segbuf_nblocks;
 	struct nilfs_segment_buffer *sc_curseg;
-	struct buffer_head     *sc_super_root;
 
 	struct nilfs_cstage	sc_stage;
 

commit 55480a06e9ee8d05d0e580bf46611df489653c76
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sun Mar 14 03:55:56 2010 +0900

    nilfs2: remove spaces before tabs
    
    This kills the following checkpatch warnings:
    
     WARNING: please, no space before tabs
     #74: FILE: segment.h:74:
     +^Iunsigned ^I^Iflags;$
    
     WARNING: please, no space before tabs
     #35: FILE: segbuf.c:35:
     +^Iint ^I^I^Istart, end; /* The region to be submitted */$
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 2a794569dd14..82dfd6a686b9 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -71,7 +71,7 @@ struct nilfs_recovery_info {
  */
 struct nilfs_cstage {
 	int			scnt;
-	unsigned 		flags;
+	unsigned		flags;
 	struct nilfs_inode_info *dirty_file_ptr;
 	struct nilfs_inode_info *gc_inode_ptr;
 };

commit 7a65004bbaa6a21a0438aac9c64814e46084dc3f
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sun Mar 14 03:32:40 2010 +0900

    nilfs2: fix various typos in comments
    
    This fixes various typos I found in comments of nilfs2.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 3155e0c7f415..2a794569dd14 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -30,7 +30,7 @@
 #include "sb.h"
 
 /**
- * struct nilfs_recovery_info - Recovery infomation
+ * struct nilfs_recovery_info - Recovery information
  * @ri_need_recovery: Recovery status
  * @ri_super_root: Block number of the last super root
  * @ri_ri_cno: Number of the last checkpoint

commit dcd76186955e2b595c378dbe5b9bb6c8c5374b10
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Tue Jan 26 15:20:15 2010 +0900

    nilfs2: get rid of nilfs_segctor_req struct
    
    This will clean up nilfs_segctor_req struct and the obscure request
    argument passed among private methods of segment constructor.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 3d3ab2f9864c..3155e0c7f415 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -116,6 +116,7 @@ struct nilfs_segsum_pointer {
  * @sc_wait_daemon: Daemon wait queue
  * @sc_wait_task: Start/end wait queue to control segctord task
  * @sc_seq_request: Request counter
+ * @sc_seq_accept: Accepted request count
  * @sc_seq_done: Completion counter
  * @sc_sync: Request of explicit sync operation
  * @sc_interval: Timeout value of background construction
@@ -169,6 +170,7 @@ struct nilfs_sc_info {
 	wait_queue_head_t	sc_wait_task;
 
 	__u32			sc_seq_request;
+	__u32			sc_seq_accepted;
 	__u32			sc_seq_done;
 
 	int			sc_sync;

commit a694291a6211537189c6080f77f63cdabfc9b63e
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sun Nov 29 23:03:04 2009 +0900

    nilfs2: separate wait function from nilfs_segctor_write
    
    This separates wait function for submitted logs from the write
    function nilfs_segctor_write().  A new list of segment buffers
    "sc_write_logs" is added to hold logs under writing, and double
    buffering is partially applied to hide io latency.
    
    At this point, the double buffering is disabled for blocksize <
    pagesize because page dirty flag is turned off during write and dirty
    buffers are not properly collected for pages crossing over segments.
    
    To receive full benefit of the double buffering, further refinement is
    needed to move the io wait outside the lock section of log writer.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 0d2a475a741b..3d3ab2f9864c 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -97,6 +97,7 @@ struct nilfs_segsum_pointer {
  * @sc_dsync_start: start byte offset of data pages
  * @sc_dsync_end: end byte offset of data pages (inclusive)
  * @sc_segbufs: List of segment buffers
+ * @sc_write_logs: List of segment buffers to hold logs under writing
  * @sc_segbuf_nblocks: Number of available blocks in segment buffers.
  * @sc_curseg: Current segment buffer
  * @sc_super_root: Pointer to the super root buffer
@@ -143,6 +144,7 @@ struct nilfs_sc_info {
 
 	/* Segment buffers */
 	struct list_head	sc_segbufs;
+	struct list_head	sc_write_logs;
 	unsigned long		sc_segbuf_nblocks;
 	struct nilfs_segment_buffer *sc_curseg;
 	struct buffer_head     *sc_super_root;

commit 654137dd46bc7e9f088a4a551a2b77a8541dfdb8
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sun May 17 19:07:21 2009 +0900

    nilfs2: remove header file for segment list operations
    
    This will eliminate obsolete list operations of nilfs_segment_entry
    structure which has been used to handle mutiple segment numbers.
    
    The patch ("nilfs2: remove list of freeing segments") removed use of
    the structure from the segment constructor code, and this patch
    simplifies the remaining code by integrating it into recovery.c.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index f36a851738e4..0d2a475a741b 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -239,5 +239,6 @@ extern int nilfs_search_super_root(struct the_nilfs *, struct nilfs_sb_info *,
 extern int nilfs_recover_logical_segments(struct the_nilfs *,
 					  struct nilfs_sb_info *,
 					  struct nilfs_recovery_info *);
+extern void nilfs_dispose_segment_list(struct list_head *);
 
 #endif /* _NILFS_SEGMENT_H */

commit 071cb4b81987a28c7ac2702003cff3e61684a630
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sat May 16 23:44:55 2009 +0900

    nilfs2: eliminate removal list of segments
    
    This will clean up the removal list of segments and the related
    functions from segment.c and ioctl.c, which have hurt code
    readability.
    
    This elimination is applied by using nilfs_sufile_updatev() previously
    introduced in the patch ("nilfs2: add sufile function that can modify
    multiple segment usages").
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 476bdd5df5be..f36a851738e4 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -90,8 +90,9 @@ struct nilfs_segsum_pointer {
  * @sc_nblk_inc: Block count of current generation
  * @sc_dirty_files: List of files to be written
  * @sc_gc_inodes: List of GC inodes having blocks to be written
- * @sc_cleaning_segments: List of segments to be freed through construction
  * @sc_copied_buffers: List of copied buffers (buffer heads) to freeze data
+ * @sc_freesegs: array of segment numbers to be freed
+ * @sc_nfreesegs: number of segments on @sc_freesegs
  * @sc_dsync_inode: inode whose data pages are written for a sync operation
  * @sc_dsync_start: start byte offset of data pages
  * @sc_dsync_end: end byte offset of data pages (inclusive)
@@ -131,9 +132,11 @@ struct nilfs_sc_info {
 
 	struct list_head	sc_dirty_files;
 	struct list_head	sc_gc_inodes;
-	struct list_head	sc_cleaning_segments;
 	struct list_head	sc_copied_buffers;
 
+	__u64		       *sc_freesegs;
+	size_t			sc_nfreesegs;
+
 	struct nilfs_inode_info *sc_dsync_inode;
 	loff_t			sc_dsync_start;
 	loff_t			sc_dsync_end;
@@ -225,10 +228,6 @@ extern void nilfs_flush_segment(struct super_block *, ino_t);
 extern int nilfs_clean_segments(struct super_block *, struct nilfs_argv *,
 				void **);
 
-extern int nilfs_segctor_add_segments_to_be_freed(struct nilfs_sc_info *,
-						  __u64 *, size_t);
-extern void nilfs_segctor_clear_segments_to_be_freed(struct nilfs_sc_info *);
-
 extern int nilfs_attach_segment_constructor(struct nilfs_sb_info *);
 extern void nilfs_detach_segment_constructor(struct nilfs_sb_info *);
 

commit 4f6b828837b4e3836f2c9ac2f0eab9773b6c1327
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Sun May 10 22:41:43 2009 +0900

    nilfs2: fix lock order reversal in nilfs_clean_segments ioctl
    
    This is a companion patch to ("nilfs2: fix possible circular locking
    for get information ioctls").
    
    This corrects lock order reversal between mm->mmap_sem and
    nilfs->ns_segctor_sem in nilfs_clean_segments() which was detected by
    lockdep check:
    
     =======================================================
     [ INFO: possible circular locking dependency detected ]
     2.6.30-rc3-nilfs-00003-g360bdc1 #7
     -------------------------------------------------------
     mmap/5294 is trying to acquire lock:
      (&nilfs->ns_segctor_sem){++++.+}, at: [<d0d0e846>] nilfs_transaction_begin+0xb6/0x10c [nilfs2]
    
     but task is already holding lock:
      (&mm->mmap_sem){++++++}, at: [<c043700a>] do_page_fault+0x1d8/0x30a
    
     which lock already depends on the new lock.
    
     the existing dependency chain (in reverse order) is:
    
     -> #1 (&mm->mmap_sem){++++++}:
            [<c01470a5>] __lock_acquire+0x1066/0x13b0
            [<c01474a9>] lock_acquire+0xba/0xdd
            [<c01836bc>] might_fault+0x68/0x88
            [<c023c61d>] copy_from_user+0x2a/0x111
            [<d0d120d0>] nilfs_ioctl_prepare_clean_segments+0x1d/0xf1 [nilfs2]
            [<d0d0e2aa>] nilfs_clean_segments+0x6d/0x1b9 [nilfs2]
            [<d0d11f68>] nilfs_ioctl+0x2ad/0x318 [nilfs2]
            [<c01a3be7>] vfs_ioctl+0x22/0x69
            [<c01a408e>] do_vfs_ioctl+0x460/0x499
            [<c01a4107>] sys_ioctl+0x40/0x5a
            [<c01031a4>] sysenter_do_call+0x12/0x38
            [<ffffffff>] 0xffffffff
    
     -> #0 (&nilfs->ns_segctor_sem){++++.+}:
            [<c0146e0b>] __lock_acquire+0xdcc/0x13b0
            [<c01474a9>] lock_acquire+0xba/0xdd
            [<c0433f1d>] down_read+0x2a/0x3e
            [<d0d0e846>] nilfs_transaction_begin+0xb6/0x10c [nilfs2]
            [<d0cfe0e5>] nilfs_page_mkwrite+0xe7/0x154 [nilfs2]
            [<c0183b0b>] __do_fault+0x165/0x376
            [<c01855cd>] handle_mm_fault+0x287/0x5d1
            [<c043712d>] do_page_fault+0x2fb/0x30a
            [<c0435462>] error_code+0x72/0x78
            [<ffffffff>] 0xffffffff
    
    where nilfs_clean_segments() holds:
    
      nilfs->ns_segctor_sem -> copy_from_user()
                                 --> page fault -> mm->mmap_sem
    
    And, page fault path may hold:
    
      page fault -> mm->mmap_sem
             --> nilfs_page_mkwrite() -> nilfs->ns_segctor_sem
    
    Even though nilfs_clean_segments() does not perform write access on
    given user pages, it may cause deadlock because nilfs->ns_segctor_sem
    is shared per device and mm->mmap_sem can be shared with other tasks.
    
    To avoid this problem, this patch moves all calls of copy_from_user()
    outside the nilfs->ns_segctor_sem lock in the ioctl.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index a98fc1ed0bbb..476bdd5df5be 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -222,7 +222,8 @@ extern int nilfs_construct_segment(struct super_block *);
 extern int nilfs_construct_dsync_segment(struct super_block *, struct inode *,
 					 loff_t, loff_t);
 extern void nilfs_flush_segment(struct super_block *, ino_t);
-extern int nilfs_clean_segments(struct super_block *, void __user *);
+extern int nilfs_clean_segments(struct super_block *, struct nilfs_argv *,
+				void **);
 
 extern int nilfs_segctor_add_segments_to_be_freed(struct nilfs_sc_info *,
 						  __u64 *, size_t);

commit e339ad31f59925b48a92ee3947692fdf9758b8c7
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon Apr 6 19:01:59 2009 -0700

    nilfs2: introduce secondary super block
    
    The former versions didn't have extra super blocks.  This improves the
    weak point by introducing another super block at unused region in tail of
    the partition.
    
    This doesn't break disk format compatibility; older versions just ingore
    the secondary super block, and new versions just recover it if it doesn't
    exist.  The partition created by an old mkfs may not have unused region,
    but in that case, the secondary super block will not be added.
    
    This doesn't make more redundant copies of the super block; it is a future
    work.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 4a64eb82f1f5..a98fc1ed0bbb 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -206,8 +206,6 @@ enum {
 					   logical segment with a super root */
 #define NILFS_SC_DEFAULT_SR_FREQ    30  /* Maximum frequency of super root
 					   creation */
-#define NILFS_SC_DEFAULT_SB_FREQ    30  /* Minimum interval of periodical
-					   update of superblock (reserved) */
 
 /*
  * The default threshold amount of data, in block counts.

commit cece552074c591970353ad48308d65f110aeaf28
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon Apr 6 19:01:58 2009 -0700

    nilfs2: simplify handling of active state of segments
    
    will reduce some lines of segment constructor.  Previously, the state was
    complexly controlled through a list of segments in order to keep
    consistency in meta data of usage state of segments.  Instead, this
    presents ``calculated'' active flags to userland cleaner program and stop
    maintaining its real flag on disk.
    
    Only by this fake flag, the cleaner cannot exactly know if each segment is
    reclaimable or not.  However, the recent extension of nilfs_sustat ioctl
    struct (nilfs2-extend-nilfs_sustat-ioctl-struct.patch) can prevent the
    cleaner from reclaiming in-use segment wrongly.
    
    So, now I can apply this for simplification.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index bb7d417fec62..4a64eb82f1f5 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -90,7 +90,6 @@ struct nilfs_segsum_pointer {
  * @sc_nblk_inc: Block count of current generation
  * @sc_dirty_files: List of files to be written
  * @sc_gc_inodes: List of GC inodes having blocks to be written
- * @sc_active_segments: List of active segments that were already written out
  * @sc_cleaning_segments: List of segments to be freed through construction
  * @sc_copied_buffers: List of copied buffers (buffer heads) to freeze data
  * @sc_dsync_inode: inode whose data pages are written for a sync operation
@@ -132,7 +131,6 @@ struct nilfs_sc_info {
 
 	struct list_head	sc_dirty_files;
 	struct list_head	sc_gc_inodes;
-	struct list_head	sc_active_segments;
 	struct list_head	sc_cleaning_segments;
 	struct list_head	sc_copied_buffers;
 
@@ -232,8 +230,7 @@ extern int nilfs_segctor_add_segments_to_be_freed(struct nilfs_sc_info *,
 						  __u64 *, size_t);
 extern void nilfs_segctor_clear_segments_to_be_freed(struct nilfs_sc_info *);
 
-extern int nilfs_attach_segment_constructor(struct nilfs_sb_info *,
-					    struct nilfs_recovery_info *);
+extern int nilfs_attach_segment_constructor(struct nilfs_sb_info *);
 extern void nilfs_detach_segment_constructor(struct nilfs_sb_info *);
 
 /* recovery.c */

commit c96fa464a567a2a8796009af0e79bc68af73f485
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon Apr 6 19:01:57 2009 -0700

    nilfs2: mark minor flag for checkpoint created by internal operation
    
    Nilfs creates checkpoints even for garbage collection or metadata updates
    such as checkpoint mode change.  So, user often sees checkpoints created
    only by such internal operations.
    
    This is inconvenient in some situations.  For example, application that
    monitors checkpoints and changes them to snapshots, will fall into an
    infinite loop because it cannot distinguish internally created
    checkpoints.
    
    This patch solves this sort of problem by adding a flag to checkpoint for
    identification.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index fbd162d71707..bb7d417fec62 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -185,6 +185,9 @@ enum {
 	NILFS_SC_SUPER_ROOT,	/* The latest segment has a super root */
 	NILFS_SC_PRIOR_FLUSH,	/* Requesting immediate flush without making a
 				   checkpoint */
+	NILFS_SC_HAVE_DELTA,	/* Next checkpoint will have update of files
+				   other than DAT, cpfile, sufile, or files
+				   moved by GC */
 };
 
 /* sc_state */

commit 458c5b0822a669d170fdb7bb16c9145f652ebe06
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon Apr 6 19:01:56 2009 -0700

    nilfs2: clean up sketch file
    
    The sketch file is a file to mark checkpoints with user data.  It was
    experimentally introduced in the original implementation, and now
    obsolete.  The file was handled differently with regular files; the file
    size got truncated when a checkpoint was created.
    
    This stops the special treatment and will treat it as a regular file.
    Most users are not affected because mkfs.nilfs2 no longer makes this file.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 2dd39da9f386..fbd162d71707 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -108,7 +108,6 @@ struct nilfs_segsum_pointer {
  * @sc_nblk_this_inc: Number of blocks included in the current logical segment
  * @sc_seg_ctime: Creation time
  * @sc_flags: Internal flags
- * @sc_sketch_inode: Inode of the sketch file
  * @sc_state_lock: spinlock for sc_state and so on
  * @sc_state: Segctord state flags
  * @sc_flush_request: inode bitmap of metadata files to be flushed
@@ -158,13 +157,6 @@ struct nilfs_sc_info {
 
 	unsigned long		sc_flags;
 
-	/*
-	 * Pointer to an inode of the sketch.
-	 * This pointer is kept only while it contains data.
-	 * We protect it with a semaphore of the segment constructor.
-	 */
-	struct inode	       *sc_sketch_inode;
-
 	spinlock_t		sc_state_lock;
 	unsigned long		sc_state;
 	unsigned long		sc_flush_request;

commit f30bf3e40f80ef50c17f55271deae3abc03e793e
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon Apr 6 19:01:38 2009 -0700

    nilfs2: fix missed-sync issue for do_sync_mapping_range()
    
    Chris Mason pointed out that there is a missed sync issue in
    nilfs_writepages():
    
    On Wed, 17 Dec 2008 21:52:55 -0500, Chris Mason wrote:
    > It looks like nilfs_writepage ignores WB_SYNC_NONE, which is used by
    > do_sync_mapping_range().
    
    where WB_SYNC_NONE in do_sync_mapping_range() was replaced with
    WB_SYNC_ALL by Nick's patch (commit:
    ee53a891f47444c53318b98dac947ede963db400).
    
    This fixes the problem by letting nilfs_writepages() write out the log of
    file data within the range if sync_mode is WB_SYNC_ALL.
    
    This involves removal of nilfs_file_aio_write() which was previously
    needed to ensure O_SYNC sync writes.
    
    Cc: Chris Mason <chris.mason@oracle.com>
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
index 615654b8c329..2dd39da9f386 100644
--- a/fs/nilfs2/segment.h
+++ b/fs/nilfs2/segment.h
@@ -93,6 +93,9 @@ struct nilfs_segsum_pointer {
  * @sc_active_segments: List of active segments that were already written out
  * @sc_cleaning_segments: List of segments to be freed through construction
  * @sc_copied_buffers: List of copied buffers (buffer heads) to freeze data
+ * @sc_dsync_inode: inode whose data pages are written for a sync operation
+ * @sc_dsync_start: start byte offset of data pages
+ * @sc_dsync_end: end byte offset of data pages (inclusive)
  * @sc_segbufs: List of segment buffers
  * @sc_segbuf_nblocks: Number of available blocks in segment buffers.
  * @sc_curseg: Current segment buffer
@@ -134,6 +137,10 @@ struct nilfs_sc_info {
 	struct list_head	sc_cleaning_segments;
 	struct list_head	sc_copied_buffers;
 
+	struct nilfs_inode_info *sc_dsync_inode;
+	loff_t			sc_dsync_start;
+	loff_t			sc_dsync_end;
+
 	/* Segment buffers */
 	struct list_head	sc_segbufs;
 	unsigned long		sc_segbuf_nblocks;
@@ -221,8 +228,8 @@ extern void nilfs_destroy_transaction_cache(void);
 extern void nilfs_relax_pressure_in_lock(struct super_block *);
 
 extern int nilfs_construct_segment(struct super_block *);
-extern int nilfs_construct_dsync_segment(struct super_block *,
-					 struct inode *);
+extern int nilfs_construct_dsync_segment(struct super_block *, struct inode *,
+					 loff_t, loff_t);
 extern void nilfs_flush_segment(struct super_block *, ino_t);
 extern int nilfs_clean_segments(struct super_block *, void __user *);
 

commit 9ff05123e3bfbb1d2b68ba1d9bf1f7d1dffc1453
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Mon Apr 6 19:01:37 2009 -0700

    nilfs2: segment constructor
    
    This adds the segment constructor (also called log writer).
    
    The segment constructor collects dirty buffers for every dirty inode,
    makes summaries of the buffers, assigns disk block addresses to the
    buffers, and then submits BIOs for the buffers.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/nilfs2/segment.h b/fs/nilfs2/segment.h
new file mode 100644
index 000000000000..615654b8c329
--- /dev/null
+++ b/fs/nilfs2/segment.h
@@ -0,0 +1,246 @@
+/*
+ * segment.h - NILFS Segment constructor prototypes and definitions
+ *
+ * Copyright (C) 2005-2008 Nippon Telegraph and Telephone Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Written by Ryusuke Konishi <ryusuke@osrg.net>
+ *
+ */
+#ifndef _NILFS_SEGMENT_H
+#define _NILFS_SEGMENT_H
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/buffer_head.h>
+#include <linux/nilfs2_fs.h>
+#include "sb.h"
+
+/**
+ * struct nilfs_recovery_info - Recovery infomation
+ * @ri_need_recovery: Recovery status
+ * @ri_super_root: Block number of the last super root
+ * @ri_ri_cno: Number of the last checkpoint
+ * @ri_lsegs_start: Region for roll-forwarding (start block number)
+ * @ri_lsegs_end: Region for roll-forwarding (end block number)
+ * @ri_lseg_start_seq: Sequence value of the segment at ri_lsegs_start
+ * @ri_used_segments: List of segments to be mark active
+ * @ri_pseg_start: Block number of the last partial segment
+ * @ri_seq: Sequence number on the last partial segment
+ * @ri_segnum: Segment number on the last partial segment
+ * @ri_nextnum: Next segment number on the last partial segment
+ */
+struct nilfs_recovery_info {
+	int			ri_need_recovery;
+	sector_t		ri_super_root;
+	__u64			ri_cno;
+
+	sector_t		ri_lsegs_start;
+	sector_t		ri_lsegs_end;
+	u64			ri_lsegs_start_seq;
+	struct list_head	ri_used_segments;
+	sector_t		ri_pseg_start;
+	u64			ri_seq;
+	__u64			ri_segnum;
+	__u64			ri_nextnum;
+};
+
+/* ri_need_recovery */
+#define NILFS_RECOVERY_SR_UPDATED	 1  /* The super root was updated */
+#define NILFS_RECOVERY_ROLLFORWARD_DONE	 2  /* Rollforward was carried out */
+
+/**
+ * struct nilfs_cstage - Context of collection stage
+ * @scnt: Stage count
+ * @flags: State flags
+ * @dirty_file_ptr: Pointer on dirty_files list, or inode of a target file
+ * @gc_inode_ptr: Pointer on the list of gc-inodes
+ */
+struct nilfs_cstage {
+	int			scnt;
+	unsigned 		flags;
+	struct nilfs_inode_info *dirty_file_ptr;
+	struct nilfs_inode_info *gc_inode_ptr;
+};
+
+struct nilfs_segment_buffer;
+
+struct nilfs_segsum_pointer {
+	struct buffer_head     *bh;
+	unsigned		offset; /* offset in bytes */
+};
+
+/**
+ * struct nilfs_sc_info - Segment constructor information
+ * @sc_super: Back pointer to super_block struct
+ * @sc_sbi: Back pointer to nilfs_sb_info struct
+ * @sc_nblk_inc: Block count of current generation
+ * @sc_dirty_files: List of files to be written
+ * @sc_gc_inodes: List of GC inodes having blocks to be written
+ * @sc_active_segments: List of active segments that were already written out
+ * @sc_cleaning_segments: List of segments to be freed through construction
+ * @sc_copied_buffers: List of copied buffers (buffer heads) to freeze data
+ * @sc_segbufs: List of segment buffers
+ * @sc_segbuf_nblocks: Number of available blocks in segment buffers.
+ * @sc_curseg: Current segment buffer
+ * @sc_super_root: Pointer to the super root buffer
+ * @sc_stage: Collection stage
+ * @sc_finfo_ptr: pointer to the current finfo struct in the segment summary
+ * @sc_binfo_ptr: pointer to the current binfo struct in the segment summary
+ * @sc_blk_cnt:	Block count of a file
+ * @sc_datablk_cnt: Data block count of a file
+ * @sc_nblk_this_inc: Number of blocks included in the current logical segment
+ * @sc_seg_ctime: Creation time
+ * @sc_flags: Internal flags
+ * @sc_sketch_inode: Inode of the sketch file
+ * @sc_state_lock: spinlock for sc_state and so on
+ * @sc_state: Segctord state flags
+ * @sc_flush_request: inode bitmap of metadata files to be flushed
+ * @sc_wait_request: Client request queue
+ * @sc_wait_daemon: Daemon wait queue
+ * @sc_wait_task: Start/end wait queue to control segctord task
+ * @sc_seq_request: Request counter
+ * @sc_seq_done: Completion counter
+ * @sc_sync: Request of explicit sync operation
+ * @sc_interval: Timeout value of background construction
+ * @sc_mjcp_freq: Frequency of creating checkpoints
+ * @sc_lseg_stime: Start time of the latest logical segment
+ * @sc_watermark: Watermark for the number of dirty buffers
+ * @sc_timer: Timer for segctord
+ * @sc_task: current thread of segctord
+ */
+struct nilfs_sc_info {
+	struct super_block     *sc_super;
+	struct nilfs_sb_info   *sc_sbi;
+
+	unsigned long		sc_nblk_inc;
+
+	struct list_head	sc_dirty_files;
+	struct list_head	sc_gc_inodes;
+	struct list_head	sc_active_segments;
+	struct list_head	sc_cleaning_segments;
+	struct list_head	sc_copied_buffers;
+
+	/* Segment buffers */
+	struct list_head	sc_segbufs;
+	unsigned long		sc_segbuf_nblocks;
+	struct nilfs_segment_buffer *sc_curseg;
+	struct buffer_head     *sc_super_root;
+
+	struct nilfs_cstage	sc_stage;
+
+	struct nilfs_segsum_pointer sc_finfo_ptr;
+	struct nilfs_segsum_pointer sc_binfo_ptr;
+	unsigned long		sc_blk_cnt;
+	unsigned long		sc_datablk_cnt;
+	unsigned long		sc_nblk_this_inc;
+	time_t			sc_seg_ctime;
+
+	unsigned long		sc_flags;
+
+	/*
+	 * Pointer to an inode of the sketch.
+	 * This pointer is kept only while it contains data.
+	 * We protect it with a semaphore of the segment constructor.
+	 */
+	struct inode	       *sc_sketch_inode;
+
+	spinlock_t		sc_state_lock;
+	unsigned long		sc_state;
+	unsigned long		sc_flush_request;
+
+	wait_queue_head_t	sc_wait_request;
+	wait_queue_head_t	sc_wait_daemon;
+	wait_queue_head_t	sc_wait_task;
+
+	__u32			sc_seq_request;
+	__u32			sc_seq_done;
+
+	int			sc_sync;
+	unsigned long		sc_interval;
+	unsigned long		sc_mjcp_freq;
+	unsigned long		sc_lseg_stime;	/* in 1/HZ seconds */
+	unsigned long		sc_watermark;
+
+	struct timer_list      *sc_timer;
+	struct task_struct     *sc_task;
+};
+
+/* sc_flags */
+enum {
+	NILFS_SC_DIRTY,		/* One or more dirty meta-data blocks exist */
+	NILFS_SC_UNCLOSED,	/* Logical segment is not closed */
+	NILFS_SC_SUPER_ROOT,	/* The latest segment has a super root */
+	NILFS_SC_PRIOR_FLUSH,	/* Requesting immediate flush without making a
+				   checkpoint */
+};
+
+/* sc_state */
+#define NILFS_SEGCTOR_QUIT	    0x0001  /* segctord is being destroyed */
+#define NILFS_SEGCTOR_COMMIT	    0x0004  /* committed transaction exists */
+
+/*
+ * Constant parameters
+ */
+#define NILFS_SC_CLEANUP_RETRY	    3  /* Retry count of construction when
+					  destroying segctord */
+
+/*
+ * Default values of timeout, in seconds.
+ */
+#define NILFS_SC_DEFAULT_TIMEOUT    5   /* Timeout value of dirty blocks.
+					   It triggers construction of a
+					   logical segment with a super root */
+#define NILFS_SC_DEFAULT_SR_FREQ    30  /* Maximum frequency of super root
+					   creation */
+#define NILFS_SC_DEFAULT_SB_FREQ    30  /* Minimum interval of periodical
+					   update of superblock (reserved) */
+
+/*
+ * The default threshold amount of data, in block counts.
+ */
+#define NILFS_SC_DEFAULT_WATERMARK  3600
+
+
+/* segment.c */
+extern int nilfs_init_transaction_cache(void);
+extern void nilfs_destroy_transaction_cache(void);
+extern void nilfs_relax_pressure_in_lock(struct super_block *);
+
+extern int nilfs_construct_segment(struct super_block *);
+extern int nilfs_construct_dsync_segment(struct super_block *,
+					 struct inode *);
+extern void nilfs_flush_segment(struct super_block *, ino_t);
+extern int nilfs_clean_segments(struct super_block *, void __user *);
+
+extern int nilfs_segctor_add_segments_to_be_freed(struct nilfs_sc_info *,
+						  __u64 *, size_t);
+extern void nilfs_segctor_clear_segments_to_be_freed(struct nilfs_sc_info *);
+
+extern int nilfs_attach_segment_constructor(struct nilfs_sb_info *,
+					    struct nilfs_recovery_info *);
+extern void nilfs_detach_segment_constructor(struct nilfs_sb_info *);
+
+/* recovery.c */
+extern int nilfs_read_super_root_block(struct super_block *, sector_t,
+				       struct buffer_head **, int);
+extern int nilfs_search_super_root(struct the_nilfs *, struct nilfs_sb_info *,
+				   struct nilfs_recovery_info *);
+extern int nilfs_recover_logical_segments(struct the_nilfs *,
+					  struct nilfs_sb_info *,
+					  struct nilfs_recovery_info *);
+
+#endif /* _NILFS_SEGMENT_H */
