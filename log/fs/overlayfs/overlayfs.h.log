commit 5ac8e8025aedd2ea832ae3fe3ca0f920697f45c7
Author: youngjun <her0gyugyu@gmail.com>
Date:   Sun Jun 21 07:30:59 2020 -0700

    ovl: change ovl_copy_up_flags static
    
    "ovl_copy_up_flags" is used in copy_up.c.
    so, change it static.
    
    Signed-off-by: youngjun <her0gyugyu@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index b725c7f15ff4..29bc1ec699e7 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -483,7 +483,6 @@ void ovl_aio_request_cache_destroy(void);
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_with_data(struct dentry *dentry);
-int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_maybe_copy_up(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);

commit 74c6e384e991c5305754e3c79edf768a62b00563
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jun 4 10:48:19 2020 +0200

    ovl: make oip->index bool
    
    ovl_get_inode() uses oip->index as a bool value, not as a pointer.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index ffbb57b2d7f6..b725c7f15ff4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -424,7 +424,7 @@ struct ovl_inode_params {
 	struct inode *newinode;
 	struct dentry *upperdentry;
 	struct ovl_path *lowerpath;
-	struct dentry *index;
+	bool index;
 	unsigned int numlower;
 	char *redirect;
 	struct dentry *lowerdata;

commit 522f6e6cba6880a038e2bd88e10390b84cd3febd
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat May 23 16:21:55 2020 +0300

    ovl: fix out of bounds access warning in ovl_check_fb_len()
    
    syzbot reported out of bounds memory access from open_by_handle_at()
    with a crafted file handle that looks like this:
    
      { .handle_bytes = 2, .handle_type = OVL_FILEID_V1 }
    
    handle_bytes gets rounded down to 0 and we end up calling:
      ovl_check_fh_len(fh, 0) => ovl_check_fb_len(fh + 3, -3)
    
    But fh buffer is only 2 bytes long, so accessing struct ovl_fb at
    fh + 3 is illegal.
    
    Fixes: cbe7fba8edfc ("ovl: make sure that real fid is 32bit aligned in memory")
    Reported-and-tested-by: syzbot+61958888b1c60361a791@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org> # v5.5
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 76747f5b0517..ffbb57b2d7f6 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -355,6 +355,9 @@ int ovl_check_fb_len(struct ovl_fb *fb, int fb_len);
 
 static inline int ovl_check_fh_len(struct ovl_fh *fh, int fh_len)
 {
+	if (fh_len < sizeof(struct ovl_fh))
+		return -EINVAL;
+
 	return ovl_check_fb_len(&fh->fb, fh_len - OVL_FH_WIRE_OFFSET);
 }
 

commit c21c839b8448dd4b1e37ffc1bde928f57d34c0db
Author: Chengguang Xu <cgxu519@mykernel.net>
Date:   Fri Apr 24 10:55:17 2020 +0800

    ovl: whiteout inode sharing
    
    Share inode with different whiteout files for saving inode and speeding up
    delete operation.
    
    If EMLINK is encountered when linking a shared whiteout, create a new one.
    In case of any other error, disable sharing for this super block.
    
    Note: ofs->whiteout is protected by inode lock on workdir.
    
    Signed-off-by: Chengguang Xu <cgxu519@mykernel.net>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e00b1ff6dea9..76747f5b0517 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -455,7 +455,7 @@ static inline void ovl_copyflags(struct inode *from, struct inode *to)
 
 /* dir.c */
 extern const struct inode_operations ovl_dir_inode_operations;
-int ovl_cleanup_and_whiteout(struct dentry *workdir, struct inode *dir,
+int ovl_cleanup_and_whiteout(struct ovl_fs *ofs, struct inode *dir,
 			     struct dentry *dentry);
 struct ovl_cattr {
 	dev_t rdev;

commit 3011645b5b061e99cf0f024b3260ec506f91b27c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Apr 3 07:58:49 2020 +0300

    ovl: cleanup non-empty directories in ovl_indexdir_cleanup()
    
    Teach ovl_indexdir_cleanup() to remove temp directories containing
    whiteouts to prepare for using index dir instead of work dir for removing
    merge directories.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e6f3670146ed..e00b1ff6dea9 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -394,8 +394,8 @@ void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list);
 void ovl_cache_free(struct list_head *list);
 void ovl_dir_cache_free(struct inode *inode);
 int ovl_check_d_type_supported(struct path *realpath);
-void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
-			 struct dentry *dentry, int level);
+int ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
+			struct dentry *dentry, int level);
 int ovl_indexdir_cleanup(struct ovl_fs *ofs);
 
 /* inode.c */

commit 926e94d79baf76ce7a4d26c3116b6d85a77a475b
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Feb 21 16:34:45 2020 +0200

    ovl: enable xino automatically in more cases
    
    So far, with xino=auto, we only enable xino if we know that all
    underlying filesystem use 32bit inode numbers.
    
    When users configure overlay with xino=auto, they already declare that
    they are ready to handle 64bit inode number from overlay.
    
    It is a very common case, that underlying filesystem uses 64bit ino,
    but rarely or never uses the high inode number bits (e.g. tmpfs, xfs).
    Leaving it for the users to declare high ino bits are unused with
    xino=on is not a recipe for many users to enjoy the benefits of xino.
    
    There appears to be very little reason not to enable xino when users
    declare xino=auto even if we do not know how many bits underlying
    filesystem uses for inode numbers.
    
    In the worst case of xino bits overflow by real inode number, we
    already fall back to the non-xino behavior - real inode number with
    unique pseudo dev or to non persistent inode number and overlay st_dev
    (for directories).
    
    The only annoyance from auto enabling xino is that xino bits overflow
    emits a warning to kmsg. Suppress those warnings unless users explicitly
    asked for xino=on, suggesting that they expected high ino bits to be
    unused by underlying filesystem.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e81fea86139e..e6f3670146ed 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -48,6 +48,12 @@ enum ovl_entry_flag {
 	OVL_E_CONNECTED,
 };
 
+enum {
+	OVL_XINO_OFF,
+	OVL_XINO_AUTO,
+	OVL_XINO_ON,
+};
+
 /*
  * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
  * where:
@@ -301,6 +307,16 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
 }
 
+/*
+ * With xino=auto, we do best effort to keep all inodes on same st_dev and
+ * d_ino consistent with st_ino.
+ * With xino=on, we do the same effort but we warn if we failed.
+ */
+static inline bool ovl_xino_warn(struct super_block *sb)
+{
+	return OVL_FS(sb)->config.xino == OVL_XINO_ON;
+}
+
 /* All layers on same fs? */
 static inline bool ovl_same_fs(struct super_block *sb)
 {

commit 0efbe7c4f948eb1233ef52c1cdba0b4ff973df36
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Mar 9 15:22:33 2020 -0500

    ovl: replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language extension
    to the C90 standard, but the preferred mechanism to declare variable-length
    types such as these ones is a flexible array member[1][2], introduced in
    C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning in
    case the flexible array does not occur last in the structure, which will
    help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by this
    change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Fixes: cbe7fba8edfc ("ovl: make sure that real fid is 32bit aligned in memory")
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index ea531b1075f2..e81fea86139e 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -87,7 +87,7 @@ struct ovl_fb {
 	u8 flags;	/* OVL_FH_FLAG_* */
 	u8 type;	/* fid_type of fid */
 	uuid_t uuid;	/* uuid of filesystem */
-	u32 fid[0];	/* file identifier should be 32bit aligned in-memory */
+	u32 fid[];	/* file identifier should be 32bit aligned in-memory */
 } __packed;
 
 /* In-memory and on-wire format for overlay file handle */

commit cad218ab3320789ea4621c15e56b8114a4160bab
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Feb 20 09:00:19 2020 +0200

    ovl: check if upper fs supports RENAME_WHITEOUT
    
    As with other required upper fs features, we only warn if support is
    missing to avoid breaking existing sub-optimal setups.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 70d17040ab4d..ea531b1075f2 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -453,6 +453,7 @@ struct ovl_cattr {
 struct dentry *ovl_create_real(struct inode *dir, struct dentry *newdentry,
 			       struct ovl_cattr *attr);
 int ovl_cleanup(struct inode *dir, struct dentry *dentry);
+struct dentry *ovl_lookup_temp(struct dentry *workdir);
 struct dentry *ovl_create_temp(struct dentry *workdir, struct ovl_cattr *attr);
 
 /* file.c */

commit f428884456192230ba1573e4028fb9282ffa2bb7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Mar 17 15:04:22 2020 +0100

    ovl: decide if revalidate needed on a per-dentry basis
    
    Allow completely skipping ->revalidate() on a per-dentry basis, in case the
    underlying layers used for a dentry do not themselves have ->revalidate().
    
    E.g. negative overlay dentry has no underlying layers, hence revalidate is
    unnecessary.  Or if lower layer is remote but overlay dentry is pure-upper,
    then can skip revalidate.
    
    The following places need to update whether the dentry needs revalidate or
    not:
    
     - fill-super (root dentry)
     - lookup
     - create
     - fh_to_dentry
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 442fbffe9d7e..70d17040ab4d 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -230,6 +230,8 @@ bool ovl_index_all(struct super_block *sb);
 bool ovl_verify_lower(struct super_block *sb);
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 bool ovl_dentry_remote(struct dentry *dentry);
+void ovl_dentry_update_reval(struct dentry *dentry, struct dentry *upperdentry,
+			     unsigned int mask);
 bool ovl_dentry_weird(struct dentry *dentry);
 enum ovl_path_type ovl_path_type(struct dentry *dentry);
 void ovl_path_upper(struct dentry *dentry, struct path *path);

commit 62c832ed4e1b67cc65d909005aae5ce7031a2b38
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Nov 19 15:31:46 2019 +0200

    ovl: simplify i_ino initialization
    
    Move i_ino initialization to ovl_inode_init() to avoid the dance of setting
    i_ino in ovl_fill_inode() sometimes on the first call and sometimes on the
    seconds call.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 3d3f2b8bdae5..442fbffe9d7e 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -264,8 +264,6 @@ void ovl_set_upperdata(struct inode *inode);
 bool ovl_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
-void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
-		    struct dentry *lowerdentry, struct dentry *lowerdata);
 void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
 void ovl_dir_modified(struct dentry *dentry, bool impurity);
 u64 ovl_dentry_version_get(struct dentry *dentry);
@@ -410,6 +408,8 @@ struct ovl_inode_params {
 	char *redirect;
 	struct dentry *lowerdata;
 };
+void ovl_inode_init(struct inode *inode, struct ovl_inode_params *oip,
+		    unsigned long ino, int fsid);
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
 			       bool is_upper);

commit 531d3040bc5cf37dea01b118608347cca9325f9d
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Mon Mar 2 15:03:35 2020 +0200

    ovl: fix lock in ovl_llseek()
    
    ovl_inode_lock() is interruptible. When inode_lock() in ovl_llseek()
    was replaced with ovl_inode_lock(), we did not add a check for error.
    
    Fix this by making ovl_inode_lock() uninterruptible and change the
    existing call sites to use an _interruptible variant.
    
    Reported-by: syzbot+66a9752fa927f745385e@syzkaller.appspotmail.com
    Fixes: b1f9d3858f72 ("ovl: use ovl_inode_lock in ovl_llseek()")
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 3623d28aa4fa..3d3f2b8bdae5 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -318,7 +318,12 @@ static inline unsigned int ovl_xino_bits(struct super_block *sb)
 	return ovl_same_dev(sb) ? OVL_FS(sb)->xino_mode : 0;
 }
 
-static inline int ovl_inode_lock(struct inode *inode)
+static inline void ovl_inode_lock(struct inode *inode)
+{
+	mutex_lock(&OVL_I(inode)->lock);
+}
+
+static inline int ovl_inode_lock_interruptible(struct inode *inode)
 {
 	return mutex_lock_interruptible(&OVL_I(inode)->lock);
 }

commit 2406a307ac7ddfd7effeeaff6947149ec6a95b4e
Author: Jiufei Xue <jiufei.xue@linux.alibaba.com>
Date:   Wed Nov 20 17:45:26 2019 +0800

    ovl: implement async IO routines
    
    A performance regression was observed since linux v4.19 with aio test using
    fio with iodepth 128 on overlayfs.  The queue depth of the device was
    always 1 which is unexpected.
    
    After investigation, it was found that commit 16914e6fc7e1 ("ovl: add
    ovl_read_iter()") and commit 2a92e07edc5e ("ovl: add ovl_write_iter()")
    resulted in vfs_iter_{read,write} being called on underlying filesystem,
    which always results in syncronous IO.
    
    Implement async IO for stacked reading and writing.  This resolves the
    performance regresion.
    
    This is implemented by allocating a new kiocb for submitting the AIO
    request on the underlying filesystem.  When the request is completed, the
    new kiocb is freed and the completion callback is called on the original
    iocb.
    
    Signed-off-by: Jiufei Xue <jiufei.xue@linux.alibaba.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index dabfa0d559fb..3623d28aa4fa 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -450,6 +450,8 @@ struct dentry *ovl_create_temp(struct dentry *workdir, struct ovl_cattr *attr);
 
 /* file.c */
 extern const struct file_operations ovl_file_operations;
+int __init ovl_aio_request_cache_init(void);
+void ovl_aio_request_cache_destroy(void);
 
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);

commit 1346416564f06444ca59778c05607bedb91a991a
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jan 24 09:46:45 2020 +0100

    ovl: layer is const
    
    The ovl_layer struct is never modified except at initialization.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e4ae3a459145..dabfa0d559fb 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -239,7 +239,7 @@ enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_lowerdata(struct dentry *dentry);
-struct ovl_layer *ovl_layer_lower(struct dentry *dentry);
+const struct ovl_layer *ovl_layer_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
 struct dentry *ovl_i_dentry_upper(struct inode *inode);
 struct inode *ovl_inode_upper(struct inode *inode);

commit 0f831ec85eda1ae27490baba106aba632c1d8e94
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Nov 16 18:14:41 2019 +0200

    ovl: simplify ovl_same_sb() helper
    
    No code uses the sb returned from this helper, so make it retrun a boolean
    and rename it to ovl_same_fs().
    
    The xino mode is irrelevant when all layers are on same fs, so instead of
    describing samefs with mode OVL_XINO_OFF, use a new xino_mode state, which
    is 0 in the case of samefs, -1 in the case of xino=off and > 0 with xino
    enabled.
    
    Create a new helper ovl_same_dev(), to use instead of the common check for
    (ovl_same_fs() || xinobits).
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index fea79f7680c8..e4ae3a459145 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -224,7 +224,6 @@ int ovl_want_write(struct dentry *dentry);
 void ovl_drop_write(struct dentry *dentry);
 struct dentry *ovl_workdir(struct dentry *dentry);
 const struct cred *ovl_override_creds(struct super_block *sb);
-struct super_block *ovl_same_sb(struct super_block *sb);
 int ovl_can_decode_fh(struct super_block *sb);
 struct dentry *ovl_indexdir(struct super_block *sb);
 bool ovl_index_all(struct super_block *sb);
@@ -302,11 +301,21 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
 }
 
-static inline unsigned int ovl_xino_bits(struct super_block *sb)
+/* All layers on same fs? */
+static inline bool ovl_same_fs(struct super_block *sb)
 {
-	struct ovl_fs *ofs = sb->s_fs_info;
+	return OVL_FS(sb)->xino_mode == 0;
+}
 
-	return ofs->xino_bits;
+/* All overlay inodes have same st_dev? */
+static inline bool ovl_same_dev(struct super_block *sb)
+{
+	return OVL_FS(sb)->xino_mode >= 0;
+}
+
+static inline unsigned int ovl_xino_bits(struct super_block *sb)
+{
+	return ovl_same_dev(sb) ? OVL_FS(sb)->xino_mode : 0;
 }
 
 static inline int ovl_inode_lock(struct inode *inode)

commit 1bd0a3aea4357e1dce8b3f0f889fd3fe756353e6
Author: lijiazi <jqqlijiazi@gmail.com>
Date:   Mon Dec 16 19:12:32 2019 +0800

    ovl: use pr_fmt auto generate prefix
    
    Use pr_fmt auto generate "overlayfs: " prefix.
    
    Signed-off-by: lijiazi <lijiazi@xiaomi.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f283b1d69a9e..fea79f7680c8 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -9,6 +9,9 @@
 #include <linux/fs.h>
 #include "ovl_entry.h"
 
+#undef pr_fmt
+#define pr_fmt(fmt) "overlayfs: " fmt
+
 enum ovl_path_type {
 	__OVL_PATH_UPPER	= (1 << 0),
 	__OVL_PATH_MERGE	= (1 << 1),

commit cbe7fba8edfc8cb8e621599e376f8ac5c224fa72
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Nov 15 13:33:03 2019 +0200

    ovl: make sure that real fid is 32bit aligned in memory
    
    Seprate on-disk encoding from in-memory and on-wire resresentation
    of overlay file handle.
    
    In-memory and on-wire we only ever pass around pointers to struct
    ovl_fh, which encapsulates at offset 3 the on-disk format struct
    ovl_fb. struct ovl_fb encapsulates at offset 21 the real file handle.
    That makes sure that the real file handle is always 32bit aligned
    in-memory when passed down to the underlying filesystem.
    
    On-disk format remains the same and store/load are done into
    correctly aligned buffer.
    
    New nfs exported file handles are exported with aligned real fid.
    Old nfs file handles are copied to an aligned buffer before being
    decoded.
    
    Reported-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 6934bcf030f0..f283b1d69a9e 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -71,20 +71,36 @@ enum ovl_entry_flag {
 #error Endianness not defined
 #endif
 
-/* The type returned by overlay exportfs ops when encoding an ovl_fh handle */
-#define OVL_FILEID	0xfb
+/* The type used to be returned by overlay exportfs for misaligned fid */
+#define OVL_FILEID_V0	0xfb
+/* The type returned by overlay exportfs for 32bit aligned fid */
+#define OVL_FILEID_V1	0xf8
 
-/* On-disk and in-memeory format for redirect by file handle */
-struct ovl_fh {
+/* On-disk format for "origin" file handle */
+struct ovl_fb {
 	u8 version;	/* 0 */
 	u8 magic;	/* 0xfb */
 	u8 len;		/* size of this header + size of fid */
 	u8 flags;	/* OVL_FH_FLAG_* */
 	u8 type;	/* fid_type of fid */
 	uuid_t uuid;	/* uuid of filesystem */
-	u8 fid[0];	/* file identifier */
+	u32 fid[0];	/* file identifier should be 32bit aligned in-memory */
 } __packed;
 
+/* In-memory and on-wire format for overlay file handle */
+struct ovl_fh {
+	u8 padding[3];	/* make sure fb.fid is 32bit aligned */
+	union {
+		struct ovl_fb fb;
+		u8 buf[0];
+	};
+} __packed;
+
+#define OVL_FH_WIRE_OFFSET	offsetof(struct ovl_fh, fb)
+#define OVL_FH_LEN(fh)		(OVL_FH_WIRE_OFFSET + (fh)->fb.len)
+#define OVL_FH_FID_OFFSET	(OVL_FH_WIRE_OFFSET + \
+				 offsetof(struct ovl_fb, fid))
+
 static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int err = vfs_rmdir(dir, dentry);
@@ -302,7 +318,13 @@ static inline void ovl_inode_unlock(struct inode *inode)
 
 
 /* namei.c */
-int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
+int ovl_check_fb_len(struct ovl_fb *fb, int fb_len);
+
+static inline int ovl_check_fh_len(struct ovl_fh *fh, int fh_len)
+{
+	return ovl_check_fb_len(&fh->fb, fh_len - OVL_FH_WIRE_OFFSET);
+}
+
 struct dentry *ovl_decode_real_fh(struct ovl_fh *fh, struct vfsmount *mnt,
 				  bool connected);
 int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index cec40077b522..6934bcf030f0 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *
  * Copyright (C) 2011 Novell Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
  */
 
 #include <linux/kernel.h>

commit 146d62e5a5867fbf84490d82455718bfb10fe824
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Apr 18 17:42:08 2019 +0300

    ovl: detect overlapping layers
    
    Overlapping overlay layers are not supported and can cause unexpected
    behavior, but overlayfs does not currently check or warn about these
    configurations.
    
    User is not supposed to specify the same directory for upper and
    lower dirs or for different lower layers and user is not supposed to
    specify directories that are descendants of each other for overlay
    layers, but that is exactly what this zysbot repro did:
    
        https://syzkaller.appspot.com/x/repro.syz?x=12c7a94f400000
    
    Moving layer root directories into other layers while overlayfs
    is mounted could also result in unexpected behavior.
    
    This commit places "traps" in the overlay inode hash table.
    Those traps are dummy overlay inodes that are hashed by the layers
    root inodes.
    
    On mount, the hash table trap entries are used to verify that overlay
    layers are not overlapping.  While at it, we also verify that overlay
    layers are not overlapping with directories "in-use" by other overlay
    instances as upperdir/workdir.
    
    On lookup, the trap entries are used to verify that overlay layers
    root inodes have not been moved into other layers after mount.
    
    Some examples:
    
    $ ./run --ov --samefs -s
    ...
    ( mkdir -p base/upper/0/u base/upper/0/w base/lower lower upper mnt
      mount -o bind base/lower lower
      mount -o bind base/upper upper
      mount -t overlay none mnt ...
            -o lowerdir=lower,upperdir=upper/0/u,workdir=upper/0/w)
    
    $ umount mnt
    $ mount -t overlay none mnt ...
            -o lowerdir=base,upperdir=upper/0/u,workdir=upper/0/w
    
      [   94.434900] overlayfs: overlapping upperdir path
      mount: mount overlay on mnt failed: Too many levels of symbolic links
    
    $ mount -t overlay none mnt ...
            -o lowerdir=upper/0/u,upperdir=upper/0/u,workdir=upper/0/w
    
      [  151.350132] overlayfs: conflicting lowerdir path
      mount: none is already mounted or mnt busy
    
    $ mount -t overlay none mnt ...
            -o lowerdir=lower:lower/a,upperdir=upper/0/u,workdir=upper/0/w
    
      [  201.205045] overlayfs: overlapping lowerdir path
      mount: mount overlay on mnt failed: Too many levels of symbolic links
    
    $ mount -t overlay none mnt ...
            -o lowerdir=lower,upperdir=upper/0/u,workdir=upper/0/w
    $ mv base/upper/0/ base/lower/
    $ find mnt/0
      mnt/0
      mnt/0/w
      find: 'mnt/0/w/work': Too many levels of symbolic links
      find: 'mnt/0/u': Too many levels of symbolic links
    
    Reported-by: syzbot+9c69c282adc4edd2b540@syzkaller.appspotmail.com
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d26efed9f80a..cec40077b522 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -270,6 +270,7 @@ void ovl_clear_flag(unsigned long flag, struct inode *inode);
 bool ovl_test_flag(unsigned long flag, struct inode *inode);
 bool ovl_inuse_trylock(struct dentry *dentry);
 void ovl_inuse_unlock(struct dentry *dentry);
+bool ovl_is_inuse(struct dentry *dentry);
 bool ovl_need_index(struct dentry *dentry);
 int ovl_nlink_start(struct dentry *dentry);
 void ovl_nlink_end(struct dentry *dentry);
@@ -376,6 +377,8 @@ struct ovl_inode_params {
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
 			       bool is_upper);
+bool ovl_lookup_trap_inode(struct super_block *sb, struct dentry *dir);
+struct inode *ovl_get_trap_inode(struct super_block *sb, struct dentry *dir);
 struct inode *ovl_get_inode(struct super_block *sb,
 			    struct ovl_inode_params *oip);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)

commit 3428030da004a1128cbdcf93dc03e16f184d845b
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 22 07:01:39 2019 +0200

    ovl: fix missing upper fs freeze protection on copy up for ioctl
    
    Generalize the helper ovl_open_maybe_copy_up() and use it to copy up file
    with data before FS_IOC_SETFLAGS ioctl.
    
    The FS_IOC_SETFLAGS ioctl is a bit of an odd ball in vfs, which probably
    caused the confusion.  File may be open O_RDONLY, but ioctl modifies the
    file.  VFS does not call mnt_want_write_file() nor lock inode mutex, but
    fs-specific code for FS_IOC_SETFLAGS does.  So ovl_ioctl() calls
    mnt_want_write_file() for the overlay file, and fs-specific code calls
    mnt_want_write_file() for upper fs file, but there was no call for
    ovl_want_write() for copy up duration which prevents overlayfs from copying
    up on a frozen upper fs.
    
    Fixes: dab5ca8fd9dd ("ovl: add lsattr/chattr support")
    Cc: <stable@vger.kernel.org> # v4.19
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 9c6018287d57..d26efed9f80a 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -421,7 +421,7 @@ extern const struct file_operations ovl_file_operations;
 int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_with_data(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
-int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
+int ovl_maybe_copy_up(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
 struct ovl_fh *ovl_encode_real_fh(struct dentry *real, bool is_upper);

commit 993a0b2aec52754f0897b1dab4c453be8217cae5
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Wed Jan 30 14:01:57 2019 -0500

    ovl: Do not lose security.capability xattr over metadata file copy-up
    
    If a file has been copied up metadata only, and later data is copied up,
    upper loses any security.capability xattr it has (underlying filesystem
    clears it as upon file write).
    
    From a user's point of view, this is just a file copy-up and that should
    not result in losing security.capability xattr.  Hence, before data copy
    up, save security.capability xattr (if any) and restore it on upper after
    data copy up is complete.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Fixes: 0c2888749363 ("ovl: A new xattr OVL_XATTR_METACOPY for file on upper")
    Cc: <stable@vger.kernel.org> # v4.19+
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 5e45cb3630a0..9c6018287d57 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -277,6 +277,8 @@ int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);
 int ovl_check_metacopy_xattr(struct dentry *dentry);
 bool ovl_is_metacopy_dentry(struct dentry *dentry);
 char *ovl_get_redirect_xattr(struct dentry *dentry, int padding);
+ssize_t ovl_getxattr(struct dentry *dentry, char *name, char **value,
+		     size_t padding);
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {

commit 1e92e3072c1456abedf51c9dedd245d2ba0daa4f
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Oct 18 18:37:14 2018 +0300

    ovl: abstract ovl_inode lock with a helper
    
    The abstraction improves code readabilty (to some).
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index b48ef22ef96b..5e45cb3630a0 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -290,6 +290,16 @@ static inline unsigned int ovl_xino_bits(struct super_block *sb)
 	return ofs->xino_bits;
 }
 
+static inline int ovl_inode_lock(struct inode *inode)
+{
+	return mutex_lock_interruptible(&OVL_I(inode)->lock);
+}
+
+static inline void ovl_inode_unlock(struct inode *inode)
+{
+	mutex_unlock(&OVL_I(inode)->lock);
+}
+
 
 /* namei.c */
 int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);

commit 0e32992f7faccd50d1b00032de83e87a35fed247
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Oct 18 18:37:13 2018 +0300

    ovl: remove the 'locked' argument of ovl_nlink_{start,end}
    
    It just makes the interface strange without adding any significant value.
    The only case where locked is false and return value is 0 is in
    ovl_rename() when new is negative, so handle that case explicitly in
    ovl_rename().
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index a3c0d9584312..b48ef22ef96b 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -271,8 +271,8 @@ bool ovl_test_flag(unsigned long flag, struct inode *inode);
 bool ovl_inuse_trylock(struct dentry *dentry);
 void ovl_inuse_unlock(struct dentry *dentry);
 bool ovl_need_index(struct dentry *dentry);
-int ovl_nlink_start(struct dentry *dentry, bool *locked);
-void ovl_nlink_end(struct dentry *dentry, bool locked);
+int ovl_nlink_start(struct dentry *dentry);
+void ovl_nlink_end(struct dentry *dentry);
 int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);
 int ovl_check_metacopy_xattr(struct dentry *dentry);
 bool ovl_is_metacopy_dentry(struct dentry *dentry);

commit 1a8f8d2a443ef9ad9a3065ba8c8119df714240fa
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Oct 4 14:49:10 2018 +0200

    ovl: fix format of setxattr debug
    
    Format has a typo: it was meant to be "%.*s", not "%*s".  But at some point
    callers grew nonprintable values as well, so use "%*pE" instead with a
    maximized length.
    
    Reported-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Fixes: 3a1e819b4e80 ("ovl: store file handle of lower inode on copy up")
    Cc: <stable@vger.kernel.org> # v4.12

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f61839e1054c..a3c0d9584312 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -152,8 +152,8 @@ static inline int ovl_do_setxattr(struct dentry *dentry, const char *name,
 				  const void *value, size_t size, int flags)
 {
 	int err = vfs_setxattr(dentry, name, value, size, flags);
-	pr_debug("setxattr(%pd2, \"%s\", \"%*s\", 0x%x) = %i\n",
-		 dentry, name, (int) size, (char *) value, flags, err);
+	pr_debug("setxattr(%pd2, \"%s\", \"%*pE\", %zu, 0x%x) = %i\n",
+		 dentry, name, min((int)size, 48), value, size, flags, err);
 	return err;
 }
 

commit d1e6f6a94d6cefed2b6f7a222853ebcd2805b43b
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:33 2018 -0400

    ovl: add helper to force data copy-up
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index c85aa438cc8f..f61839e1054c 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -407,6 +407,7 @@ extern const struct file_operations ovl_file_operations;
 
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);
+int ovl_copy_up_with_data(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);

commit 0a2d0d3f2f291e3080721888a986ea52e43e1086
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:32 2018 -0400

    ovl: Check redirect on index as well
    
    Right now we seem to check redirect only if upperdentry is found.  But it
    is possible that there is no upperdentry but later we found an index.
    
    We need to check redirect on index as well and set it in
    ovl_inode->redirect.  Otherwise link code can assume that dentry does not
    have redirect and place a new one which breaks things.  In my testing
    overlay/033 test started failing in xfstests.  Following are the details.
    
    For example do following.
    
    $ mkdir lower upper work merged
    
     - Make lower dir with 4 links.
      $ echo "foo" > lower/l0.txt
      $ ln  lower/l0.txt lower/l1.txt
      $ ln  lower/l0.txt lower/l2.txt
      $ ln  lower/l0.txt lower/l3.txt
    
     - Mount with index on and metacopy on.
    
      $ mount -t overlay -o lowerdir=lower,upperdir=upper,workdir=work,\
                            index=on,metacopy=on none merged
    
     - Link lower
    
      $ ln merged/l0.txt merged/l4.txt
        (This will metadata copy up of l0.txt and put an absolute redirect
         /l0.txt)
    
      $ echo 2 > /proc/sys/vm/drop/caches
    
      $ ls merged/l1.txt
      (Now l1.txt will be looked up.  There is no upper dentry but there is
       lower dentry and index will be found.  We don't check for redirect on
       index, hence ovl_inode->redirect will be NULL.)
    
     - Link Upper
    
      $ ln merged/l4.txt merged/l5.txt
      (Lookup of l4.txt will use inode from l1.txt lookup which is still in
       cache.  It has ovl_inode->redirect NULL, hence link will put a new
       redirect and replace /l0.txt with /l4.txt
    
     - Drop caches.
      echo 2 > /proc/sys/vm/drop_caches
    
     - List l1.txt and it returns -ESTALE
    
      $ ls merged/l0.txt
    
      (It returns stale because, we found a metacopy of l0.txt in upper and it
       has redirect l4.txt but there is no file named l4.txt in lower layer.
       So lower data copy is not found and -ESTALE is returned.)
    
    So problem here is that we did not process redirect on index.  Check
    redirect on index as well and then problem is fixed.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index a6b466b30f2b..c85aa438cc8f 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -276,6 +276,7 @@ void ovl_nlink_end(struct dentry *dentry, bool locked);
 int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);
 int ovl_check_metacopy_xattr(struct dentry *dentry);
 bool ovl_is_metacopy_dentry(struct dentry *dentry);
+char *ovl_get_redirect_xattr(struct dentry *dentry, int padding);
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {

commit a00c2d59e914b8ec46f1637e2e283aa35583c455
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:32 2018 -0400

    ovl: Add an inode flag OVL_CONST_INO
    
    Add an ovl_inode flag OVL_CONST_INO.  This flag signifies if inode number
    will remain constant over copy up or not.  This flag does not get updated
    over copy up and remains unmodifed after setting once.
    
    Next patch in the series will make use of this flag.  It will basically
    figure out if dentry is of type ORIGIN or not.  And this can be derived by
    this flag.
    
    ORIGIN = (upperdentry && ovl_test_flag(OVL_CONST_INO, inode)).
    
    Suggested-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 99f793904801..a6b466b30f2b 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -38,6 +38,8 @@ enum ovl_inode_flag {
 	OVL_WHITEOUTS,
 	OVL_INDEX,
 	OVL_UPPERDATA,
+	/* Inode number will remain constant over copy up. */
+	OVL_CONST_INO,
 };
 
 enum ovl_entry_flag {

commit 4823d49c26eaf269cd2c2723bed8249aaed80795
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:31 2018 -0400

    ovl: Add helper ovl_inode_realdata()
    
    Add an helper to retrieve real data inode associated with overlay inode.
    This helper will ignore all metacopy inodes and will return only the real
    inode which has data.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 0ad593a85121..99f793904801 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -229,6 +229,7 @@ struct inode *ovl_inode_upper(struct inode *inode);
 struct inode *ovl_inode_lower(struct inode *inode);
 struct inode *ovl_inode_lowerdata(struct inode *inode);
 struct inode *ovl_inode_real(struct inode *inode);
+struct inode *ovl_inode_realdata(struct inode *inode);
 struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);
 void ovl_set_dir_cache(struct inode *inode, struct ovl_dir_cache *cache);
 void ovl_dentry_set_flag(unsigned long flag, struct dentry *dentry);

commit 2664bd0897c2889258472a1ee922ef9d4c5fa58f
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:30 2018 -0400

    ovl: Store lower data inode in ovl_inode
    
    Right now ovl_inode stores inode pointer for lower inode.  This helps with
    quickly getting lower inode given overlay inode (ovl_inode_lower()).
    
    Now with metadata only copy-up, we can have metacopy inode in middle layer
    as well and inode containing data can be different from ->lower.  I need to
    be able to open the real file in ovl_open_realfile() and for that I need to
    quickly find the lower data inode.
    
    Hence store lower data inode also in ovl_inode.  Also provide an helper
    ovl_inode_lowerdata() to access this field.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index de80250b379f..0ad593a85121 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -227,6 +227,7 @@ struct dentry *ovl_dentry_real(struct dentry *dentry);
 struct dentry *ovl_i_dentry_upper(struct inode *inode);
 struct inode *ovl_inode_upper(struct inode *inode);
 struct inode *ovl_inode_lower(struct inode *inode);
+struct inode *ovl_inode_lowerdata(struct inode *inode);
 struct inode *ovl_inode_real(struct inode *inode);
 struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);
 void ovl_set_dir_cache(struct inode *inode, struct ovl_dir_cache *cache);
@@ -246,7 +247,7 @@ bool ovl_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
 void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
-		    struct dentry *lowerdentry);
+		    struct dentry *lowerdentry, struct dentry *lowerdata);
 void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
 void ovl_dir_modified(struct dentry *dentry, bool impurity);
 u64 ovl_dentry_version_get(struct dentry *dentry);
@@ -354,6 +355,7 @@ struct ovl_inode_params {
 	struct dentry *index;
 	unsigned int numlower;
 	char *redirect;
+	struct dentry *lowerdata;
 };
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,

commit 67d756c27ac4f4576dee313579724bd8711bc75e
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:30 2018 -0400

    ovl: Fix ovl_getattr() to get number of blocks from lower
    
    If an inode has been copied up metadata only, then we need to query the
    number of blocks from lower and fill up the stat->st_blocks.
    
    We need to be careful about races where we are doing stat on one cpu and
    data copy up is taking place on other cpu.  We want to return
    stat->st_blocks either from lower or stable upper and not something in
    between.  Hence, ovl_has_upperdata() is called first to figure out whether
    block reporting will take place from lower or upper.
    
    We now support metacopy dentries in middle layer.  That means number of
    blocks reporting needs to come from lowest data dentry and this could be
    different from lower dentry.  Hence we end up making a separate
    vfs_getxattr() call for metacopy dentries to get number of blocks.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index deda94381aac..de80250b379f 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -271,6 +271,7 @@ int ovl_nlink_start(struct dentry *dentry, bool *locked);
 void ovl_nlink_end(struct dentry *dentry, bool locked);
 int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);
 int ovl_check_metacopy_xattr(struct dentry *dentry);
+bool ovl_is_metacopy_dentry(struct dentry *dentry);
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {

commit 647d253fcd53fae185408b33ec5587a57cb3cc88
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:30 2018 -0400

    ovl: Add helper ovl_dentry_lowerdata() to get lower data dentry
    
    Now we have the notion of data dentry and metacopy dentry.
    ovl_dentry_lower() will return uppermost lower dentry, but it could be
    either data or metacopy dentry.  Now we support metacopy dentries in lower
    layers so it is possible that lowerstack[0] is metacopy dentry while
    lowerstack[1] is actual data dentry.
    
    So add an helper which returns lowest most dentry which is supposed to be
    data dentry.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index a59c546c10cf..deda94381aac 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -221,6 +221,7 @@ void ovl_path_lowerdata(struct dentry *dentry, struct path *path);
 enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
+struct dentry *ovl_dentry_lowerdata(struct dentry *dentry);
 struct ovl_layer *ovl_layer_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
 struct dentry *ovl_i_dentry_upper(struct inode *inode);

commit 4f93b426ab3930952eca6c5c456c2223a3adcbf5
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:30 2018 -0400

    ovl: Copy up meta inode data from lowest data inode
    
    So far lower could not be a meta inode.  So whenever it was time to copy up
    data of a meta inode, we could copy it up from top most lower dentry.
    
    But now lower itself can be a metacopy inode.  That means data copy up
    needs to take place from a data inode in metacopy inode chain.  Find lower
    data inode in the chain and use that for data copy up.
    
    Introduced a helper called ovl_path_lowerdata() to find the lower data
    inode chain.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 2de8e11db81a..a59c546c10cf 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -217,6 +217,7 @@ bool ovl_dentry_weird(struct dentry *dentry);
 enum ovl_path_type ovl_path_type(struct dentry *dentry);
 void ovl_path_upper(struct dentry *dentry, struct path *path);
 void ovl_path_lower(struct dentry *dentry, struct path *path);
+void ovl_path_lowerdata(struct dentry *dentry, struct path *path);
 enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);

commit 9d3dfea3d35a3235f0f1e2ce719bb4f0b696caa2
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:28 2018 -0400

    ovl: Modify ovl_lookup() and friends to lookup metacopy dentry
    
    This patch modifies ovl_lookup() and friends to lookup metacopy dentries.
    It also allows for presence of metacopy dentries in lower layer.
    
    During lookup, check for presence of OVL_XATTR_METACOPY and if not present,
    set OVL_UPPERDATA bit in flags.
    
    We don't support metacopy feature with nfs_export.  So in nfs_export code,
    we set OVL_UPPERDATA flag set unconditionally if upper inode exists.
    
    Do not follow metacopy origin if we find a metacopy only inode and metacopy
    feature is not enabled for that mount.  Like redirect, this can have
    security implications where an attacker could hand craft upper and try to
    gain access to file on lower which it should not have to begin with.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 16a000694c4e..2de8e11db81a 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -268,6 +268,7 @@ bool ovl_need_index(struct dentry *dentry);
 int ovl_nlink_start(struct dentry *dentry, bool *locked);
 void ovl_nlink_end(struct dentry *dentry, bool locked);
 int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);
+int ovl_check_metacopy_xattr(struct dentry *dentry);
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {

commit 0c2888749363645d62cc48852d0af98d5ceef332
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:28 2018 -0400

    ovl: A new xattr OVL_XATTR_METACOPY for file on upper
    
    Now we will have the capability to have upper inodes which might be only
    metadata copy up and data is still on lower inode.  So add a new xattr
    OVL_XATTR_METACOPY to distinguish between two cases.
    
    Presence of OVL_XATTR_METACOPY reflects that file has been copied up
    metadata only and and data will be copied up later from lower origin.  So
    this xattr is set when a metadata copy takes place and cleared when data
    copy takes place.
    
    We also use a bit in ovl_inode->flags to cache OVL_UPPERDATA which reflects
    whether ovl inode has data or not (as opposed to metadata only copy up).
    
    If a file is copied up metadata only and later when same file is opened for
    WRITE, then data copy up takes place.  We copy up data, remove METACOPY
    xattr and then set the UPPERDATA flag in ovl_inode->flags.  While all these
    operations happen with oi->lock held, read side of oi->flags can be
    lockless.  That is another thread on another cpu can check if UPPERDATA
    flag is set or not.
    
    So this gives us an ordering requirement w.r.t UPPERDATA flag.  That is, if
    another cpu sees UPPERDATA flag set, then it should be guaranteed that
    effects of data copy up and remove xattr operations are also visible.
    
    For example.
    
            CPU1                            CPU2
    ovl_open()                              acquire(oi->lock)
     ovl_open_maybe_copy_up()                ovl_copy_up_data()
      open_open_need_copy_up()               vfs_removexattr()
       ovl_already_copied_up()
        ovl_dentry_needs_data_copy_up()      ovl_set_flag(OVL_UPPERDATA)
         ovl_test_flag(OVL_UPPERDATA)       release(oi->lock)
    
    Say CPU2 is copying up data and in the end sets UPPERDATA flag.  But if
    CPU1 perceives the effects of setting UPPERDATA flag but not the effects of
    preceding operations (ex. upper that is not fully copied up), it will be a
    problem.
    
    Hence this patch introduces smp_wmb() on setting UPPERDATA flag operation
    and smp_rmb() on UPPERDATA flag test operation.
    
    May be some other lock or barrier is already covering it. But I am not sure
    what that is and is it obvious enough that we will not break it in future.
    
    So hence trying to be safe here and introducing barriers explicitly for
    UPPERDATA flag/bit.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 206e588df095..16a000694c4e 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -29,6 +29,7 @@ enum ovl_path_type {
 #define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
 #define OVL_XATTR_NLINK OVL_XATTR_PREFIX "nlink"
 #define OVL_XATTR_UPPER OVL_XATTR_PREFIX "upper"
+#define OVL_XATTR_METACOPY OVL_XATTR_PREFIX "metacopy"
 
 enum ovl_inode_flag {
 	/* Pure upper dir that may contain non pure upper entries */
@@ -36,6 +37,7 @@ enum ovl_inode_flag {
 	/* Non-merge dir that may contain whiteout entries */
 	OVL_WHITEOUTS,
 	OVL_INDEX,
+	OVL_UPPERDATA,
 };
 
 enum ovl_entry_flag {
@@ -191,6 +193,14 @@ static inline struct dentry *ovl_do_tmpfile(struct dentry *dentry, umode_t mode)
 	return ret;
 }
 
+static inline bool ovl_open_flags_need_copy_up(int flags)
+{
+	if (!flags)
+		return false;
+
+	return ((OPEN_FMODE(flags) & FMODE_WRITE) || (flags & O_TRUNC));
+}
+
 /* util.c */
 int ovl_want_write(struct dentry *dentry);
 void ovl_drop_write(struct dentry *dentry);
@@ -226,6 +236,10 @@ bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry);
 bool ovl_dentry_has_upper_alias(struct dentry *dentry);
 void ovl_dentry_set_upper_alias(struct dentry *dentry);
+bool ovl_dentry_needs_data_copy_up(struct dentry *dentry, int flags);
+bool ovl_dentry_needs_data_copy_up_locked(struct dentry *dentry, int flags);
+bool ovl_has_upperdata(struct inode *inode);
+void ovl_set_upperdata(struct inode *inode);
 bool ovl_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
@@ -236,9 +250,9 @@ void ovl_dir_modified(struct dentry *dentry, bool impurity);
 u64 ovl_dentry_version_get(struct dentry *dentry);
 bool ovl_is_whiteout(struct dentry *dentry);
 struct file *ovl_path_open(struct path *path, int flags);
-int ovl_copy_up_start(struct dentry *dentry);
+int ovl_copy_up_start(struct dentry *dentry, int flags);
 void ovl_copy_up_end(struct dentry *dentry);
-bool ovl_already_copied_up(struct dentry *dentry);
+bool ovl_already_copied_up(struct dentry *dentry, int flags);
 bool ovl_check_origin_xattr(struct dentry *dentry);
 bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
 int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,

commit 2002df85367ca69961d39020f56d3d727897be01
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:28 2018 -0400

    ovl: Add helper ovl_already_copied_up()
    
    There are couple of places where we need to know if file is already copied
    up (in lockless manner).  Right now its open coded and there are only two
    conditions to check.  Soon this patch series will introduce another
    condition to check and Amir wants to introduce one more.  So introduce a
    helper instead to check this so that code is easier to read.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index c0318b5a50f0..206e588df095 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -238,6 +238,7 @@ bool ovl_is_whiteout(struct dentry *dentry);
 struct file *ovl_path_open(struct path *path, int flags);
 int ovl_copy_up_start(struct dentry *dentry);
 void ovl_copy_up_end(struct dentry *dentry);
+bool ovl_already_copied_up(struct dentry *dentry);
 bool ovl_check_origin_xattr(struct dentry *dentry);
 bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
 int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,

commit d6eac039133b31f9db1c63d2e51b88df61d075cc
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:27 2018 -0400

    ovl: Move the copy up helpers to copy_up.c
    
    Right now two copy up helpers are in inode.c.  Amir suggested it might be
    better to move these to copy_up.c.
    
    There will one more related function which will come in later patch.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 69010e3dd846..c0318b5a50f0 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -325,7 +325,6 @@ int ovl_xattr_get(struct dentry *dentry, struct inode *inode, const char *name,
 		  void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 struct posix_acl *ovl_get_acl(struct inode *inode, int type);
-int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_update_time(struct inode *inode, struct timespec64 *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
@@ -384,6 +383,7 @@ extern const struct file_operations ovl_file_operations;
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
+int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
 struct ovl_fh *ovl_encode_real_fh(struct dentry *real, bool is_upper);

commit 9cec54c83a8baba3099bb8b445a735b93ab9511f
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:27 2018 -0400

    ovl: Initialize ovl_inode->redirect in ovl_get_inode()
    
    ovl_inode->redirect is an inode property and should be initialized in
    ovl_get_inode() only when we are adding a new inode to cache.  If inode is
    already in cache, it is already initialized and we should not be touching
    ovl_inode->redirect field.
    
    As of now this is not a problem as redirects are used only for directories
    which don't share inode.  But soon I want to use redirects for regular
    files also and there it can become an issue.
    
    Hence, move ->redirect initialization in ovl_get_inode().
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 16d439ebfe02..69010e3dd846 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -335,6 +335,7 @@ struct ovl_inode_params {
 	struct ovl_path *lowerpath;
 	struct dentry *index;
 	unsigned int numlower;
+	char *redirect;
 };
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,

commit d1d04ef8572bc8c22265057bd3d5a79f223f8f52
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:41 2018 +0200

    ovl: stack file ops
    
    Implement file operations on a regular overlay file.  The underlying file
    is opened separately and cached in ->private_data.
    
    It might be worth making an exception for such files when accounting in
    nr_file to confirm to userspace expectations.  We are only adding a small
    overhead (248bytes for the struct file) since the real inode and dentry are
    pinned by overlayfs anyway.
    
    This patch doesn't have any effect, since the vfs will use d_real() to find
    the real underlying file to open.  The patch at the end of the series will
    actually enable this functionality.
    
    AV: make it use open_with_fake_path(), don't mess with override_creds
    
    SzM: still need to mess with override_creds() until no fs uses
    current_cred() in their open method.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f28f1e37d457..16d439ebfe02 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -377,6 +377,9 @@ struct dentry *ovl_create_real(struct inode *dir, struct dentry *newdentry,
 int ovl_cleanup(struct inode *dir, struct dentry *dentry);
 struct dentry *ovl_create_temp(struct dentry *workdir, struct ovl_cattr *attr);
 
+/* file.c */
+extern const struct file_operations ovl_file_operations;
+
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);

commit 46e5d0a3907ba489fda4f7b043439a3599184f91
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:41 2018 +0200

    ovl: copy up file size as well
    
    Copy i_size of the underlying inode to the overlay inode in ovl_copyattr().
    
    This is in preparation for stacking I/O operations on overlay files.
    
    This patch shouldn't have any observable effect.
    
    Remove stale comment from ovl_setattr() [spotted by Vivek Goyal].
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 25cf26e57cdb..f28f1e37d457 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -9,6 +9,7 @@
 
 #include <linux/kernel.h>
 #include <linux/uuid.h>
+#include <linux/fs.h>
 #include "ovl_entry.h"
 
 enum ovl_path_type {
@@ -348,6 +349,7 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 	to->i_atime = from->i_atime;
 	to->i_mtime = from->i_mtime;
 	to->i_ctime = from->i_ctime;
+	i_size_write(to, i_size_read(from));
 }
 
 static inline void ovl_copyflags(struct inode *from, struct inode *to)

commit 4f3572954a9d4cbf992072713af284d990b65d87
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:41 2018 +0200

    ovl: copy up inode flags
    
    On inode creation copy certain inode flags from the underlying real inode
    to the overlay inode.
    
    This is in preparation for moving overlay functionality out of the VFS.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 008420e834d8..25cf26e57cdb 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -350,6 +350,13 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 	to->i_ctime = from->i_ctime;
 }
 
+static inline void ovl_copyflags(struct inode *from, struct inode *to)
+{
+	unsigned int mask = S_SYNC | S_IMMUTABLE | S_APPEND | S_NOATIME;
+
+	inode_set_flags(to, from->i_flags & mask, mask);
+}
+
 /* dir.c */
 extern const struct inode_operations ovl_dir_inode_operations;
 int ovl_cleanup_and_whiteout(struct dentry *workdir, struct inode *dir,

commit d9854c87f0ed1a5f32fec24bb5b5fb426ad79c26
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:40 2018 +0200

    ovl: copy up times
    
    Copy up mtime and ctime to overlay inode after times in real object are
    modified.  Be careful not to dirty cachelines when not necessary.
    
    This is in preparation for moving overlay functionality out of the VFS.
    
    This patch shouldn't have any observable effect.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 7538b9b56237..008420e834d8 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -231,7 +231,7 @@ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
 void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
 		    struct dentry *lowerdentry);
 void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
-void ovl_dentry_version_inc(struct dentry *dentry, bool impurity);
+void ovl_dir_modified(struct dentry *dentry, bool impurity);
 u64 ovl_dentry_version_get(struct dentry *dentry);
 bool ovl_is_whiteout(struct dentry *dentry);
 struct file *ovl_path_open(struct path *path, int flags);

commit 7a932516f55cdf430c7cce78df2010ff7db6b874
Merge: dc594c39f7a9 e264abeaf9da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 15 07:31:07 2018 +0900

    Merge tag 'vfs-timespec64' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground
    
    Pull inode timestamps conversion to timespec64 from Arnd Bergmann:
     "This is a late set of changes from Deepa Dinamani doing an automated
      treewide conversion of the inode and iattr structures from 'timespec'
      to 'timespec64', to push the conversion from the VFS layer into the
      individual file systems.
    
      As Deepa writes:
    
       'The series aims to switch vfs timestamps to use struct timespec64.
        Currently vfs uses struct timespec, which is not y2038 safe.
    
        The series involves the following:
        1. Add vfs helper functions for supporting struct timepec64
           timestamps.
        2. Cast prints of vfs timestamps to avoid warnings after the switch.
        3. Simplify code using vfs timestamps so that the actual replacement
           becomes easy.
        4. Convert vfs timestamps to use struct timespec64 using a script.
           This is a flag day patch.
    
        Next steps:
        1. Convert APIs that can handle timespec64, instead of converting
           timestamps at the boundaries.
        2. Update internal data structures to avoid timestamp conversions'
    
      Thomas Gleixner adds:
    
       'I think there is no point to drag that out for the next merge
        window. The whole thing needs to be done in one go for the core
        changes which means that you're going to play that catchup game
        forever. Let's get over with it towards the end of the merge window'"
    
    * tag 'vfs-timespec64' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground:
      pstore: Remove bogus format string definition
      vfs: change inode times to use struct timespec64
      pstore: Convert internal records to timespec64
      udf: Simplify calls to udf_disk_stamp_to_time
      fs: nfs: get rid of memcpys for inode times
      ceph: make inode time prints to be long long
      lustre: Use long long type to print inode time
      fs: add timespec64_truncate()

commit 95582b00838837fc07e042979320caf917ce3fe6
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Tue May 8 19:36:02 2018 -0700

    vfs: change inode times to use struct timespec64
    
    struct timespec is not y2038 safe. Transition vfs to use
    y2038 safe struct timespec64 instead.
    
    The change was made with the help of the following cocinelle
    script. This catches about 80% of the changes.
    All the header file and logic changes are included in the
    first 5 rules. The rest are trivial substitutions.
    I avoid changing any of the function signatures or any other
    filesystem specific data structures to keep the patch simple
    for review.
    
    The script can be a little shorter by combining different cases.
    But, this version was sufficient for my usecase.
    
    virtual patch
    
    @ depends on patch @
    identifier now;
    @@
    - struct timespec
    + struct timespec64
      current_time ( ... )
      {
    - struct timespec now = current_kernel_time();
    + struct timespec64 now = current_kernel_time64();
      ...
    - return timespec_trunc(
    + return timespec64_trunc(
      ... );
      }
    
    @ depends on patch @
    identifier xtime;
    @@
     struct \( iattr \| inode \| kstat \) {
     ...
    -       struct timespec xtime;
    +       struct timespec64 xtime;
     ...
     }
    
    @ depends on patch @
    identifier t;
    @@
     struct inode_operations {
     ...
    int (*update_time) (...,
    -       struct timespec t,
    +       struct timespec64 t,
    ...);
     ...
     }
    
    @ depends on patch @
    identifier t;
    identifier fn_update_time =~ "update_time$";
    @@
     fn_update_time (...,
    - struct timespec *t,
    + struct timespec64 *t,
     ...) { ... }
    
    @ depends on patch @
    identifier t;
    @@
    lease_get_mtime( ... ,
    - struct timespec *t
    + struct timespec64 *t
      ) { ... }
    
    @te depends on patch forall@
    identifier ts;
    local idexpression struct inode *inode_node;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn_update_time =~ "update_time$";
    identifier fn;
    expression e, E3;
    local idexpression struct inode *node1;
    local idexpression struct inode *node2;
    local idexpression struct iattr *attr1;
    local idexpression struct iattr *attr2;
    local idexpression struct iattr attr;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    @@
    (
    (
    - struct timespec ts;
    + struct timespec64 ts;
    |
    - struct timespec ts = current_time(inode_node);
    + struct timespec64 ts = current_time(inode_node);
    )
    
    <+... when != ts
    (
    - timespec_equal(&inode_node->i_xtime, &ts)
    + timespec64_equal(&inode_node->i_xtime, &ts)
    |
    - timespec_equal(&ts, &inode_node->i_xtime)
    + timespec64_equal(&ts, &inode_node->i_xtime)
    |
    - timespec_compare(&inode_node->i_xtime, &ts)
    + timespec64_compare(&inode_node->i_xtime, &ts)
    |
    - timespec_compare(&ts, &inode_node->i_xtime)
    + timespec64_compare(&ts, &inode_node->i_xtime)
    |
    ts = current_time(e)
    |
    fn_update_time(..., &ts,...)
    |
    inode_node->i_xtime = ts
    |
    node1->i_xtime = ts
    |
    ts = inode_node->i_xtime
    |
    <+... attr1->ia_xtime ...+> = ts
    |
    ts = attr1->ia_xtime
    |
    ts.tv_sec
    |
    ts.tv_nsec
    |
    btrfs_set_stack_timespec_sec(..., ts.tv_sec)
    |
    btrfs_set_stack_timespec_nsec(..., ts.tv_nsec)
    |
    - ts = timespec64_to_timespec(
    + ts =
    ...
    -)
    |
    - ts = ktime_to_timespec(
    + ts = ktime_to_timespec64(
    ...)
    |
    - ts = E3
    + ts = timespec_to_timespec64(E3)
    |
    - ktime_get_real_ts(&ts)
    + ktime_get_real_ts64(&ts)
    |
    fn(...,
    - ts
    + timespec64_to_timespec(ts)
    ,...)
    )
    ...+>
    (
    <... when != ts
    - return ts;
    + return timespec64_to_timespec(ts);
    ...>
    )
    |
    - timespec_equal(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_equal(&node1->i_xtime2, &node2->i_xtime2)
    |
    - timespec_equal(&node1->i_xtime1, &attr2->ia_xtime2)
    + timespec64_equal(&node1->i_xtime2, &attr2->ia_xtime2)
    |
    - timespec_compare(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_compare(&node1->i_xtime1, &node2->i_xtime2)
    |
    node1->i_xtime1 =
    - timespec_trunc(attr1->ia_xtime1,
    + timespec64_trunc(attr1->ia_xtime1,
    ...)
    |
    - attr1->ia_xtime1 = timespec_trunc(attr2->ia_xtime2,
    + attr1->ia_xtime1 =  timespec64_trunc(attr2->ia_xtime2,
    ...)
    |
    - ktime_get_real_ts(&attr1->ia_xtime1)
    + ktime_get_real_ts64(&attr1->ia_xtime1)
    |
    - ktime_get_real_ts(&attr.ia_xtime1)
    + ktime_get_real_ts64(&attr.ia_xtime1)
    )
    
    @ depends on patch @
    struct inode *node;
    struct iattr *attr;
    identifier fn;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    expression e;
    @@
    (
    - fn(node->i_xtime);
    + fn(timespec64_to_timespec(node->i_xtime));
    |
     fn(...,
    - node->i_xtime);
    + timespec64_to_timespec(node->i_xtime));
    |
    - e = fn(attr->ia_xtime);
    + e = fn(timespec64_to_timespec(attr->ia_xtime));
    )
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    )
    ...+>
    }
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    struct kstat *stat;
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier i_xtime =~ "^i_[acm]time$";
    identifier xtime =~ "^[acm]time$";
    identifier fn, ret;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(stat->xtime);
    ret = fn (...,
    - &stat->xtime);
    + &ts);
    )
    ...+>
    }
    
    @ depends on patch @
    struct inode *node;
    struct inode *node2;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier i_xtime3 =~ "^i_[acm]time$";
    struct iattr *attrp;
    struct iattr *attrp2;
    struct iattr attr ;
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    struct kstat *stat;
    struct kstat stat1;
    struct timespec64 ts;
    identifier xtime =~ "^[acmb]time$";
    expression e;
    @@
    (
    ( node->i_xtime2 \| attrp->ia_xtime2 \| attr.ia_xtime2 \) = node->i_xtime1  ;
    |
     node->i_xtime2 = \( node2->i_xtime1 \| timespec64_trunc(...) \);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     stat->xtime = node2->i_xtime1;
    |
     stat1.xtime = node2->i_xtime1;
    |
    ( node->i_xtime2 \| attrp->ia_xtime2 \) = attrp->ia_xtime1  ;
    |
    ( attrp->ia_xtime1 \| attr.ia_xtime1 \) = attrp2->ia_xtime2;
    |
    - e = node->i_xtime1;
    + e = timespec64_to_timespec( node->i_xtime1 );
    |
    - e = attrp->ia_xtime1;
    + e = timespec64_to_timespec( attrp->ia_xtime1 );
    |
    node->i_xtime1 = current_time(...);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
     node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
    - node->i_xtime1 = e;
    + node->i_xtime1 = timespec_to_timespec64(e);
    )
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: <anton@tuxera.com>
    Cc: <balbi@kernel.org>
    Cc: <bfields@fieldses.org>
    Cc: <darrick.wong@oracle.com>
    Cc: <dhowells@redhat.com>
    Cc: <dsterba@suse.com>
    Cc: <dwmw2@infradead.org>
    Cc: <hch@lst.de>
    Cc: <hirofumi@mail.parknet.co.jp>
    Cc: <hubcap@omnibond.com>
    Cc: <jack@suse.com>
    Cc: <jaegeuk@kernel.org>
    Cc: <jaharkes@cs.cmu.edu>
    Cc: <jslaby@suse.com>
    Cc: <keescook@chromium.org>
    Cc: <mark@fasheh.com>
    Cc: <miklos@szeredi.hu>
    Cc: <nico@linaro.org>
    Cc: <reiserfs-devel@vger.kernel.org>
    Cc: <richard@nod.at>
    Cc: <sage@redhat.com>
    Cc: <sfrench@samba.org>
    Cc: <swhiteho@redhat.com>
    Cc: <tj@kernel.org>
    Cc: <trond.myklebust@primarydata.com>
    Cc: <tytso@mit.edu>
    Cc: <viro@zeniv.linux.org.uk>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e0b7de799f6b..9fe10247f9d4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -331,7 +331,7 @@ int ovl_xattr_get(struct dentry *dentry, struct inode *inode, const char *name,
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 struct posix_acl *ovl_get_acl(struct inode *inode, int type);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
-int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
+int ovl_update_time(struct inode *inode, struct timespec64 *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);

commit 01b39dcc95680b04c7af5de7f39f577e9c4865e3
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri May 11 11:15:15 2018 +0300

    ovl: use inode_insert5() to hash a newly created inode
    
    Currently, there is a small window where ovl_obtain_alias() can
    race with ovl_instantiate() and create two different overlay inodes
    with the same underlying real non-dir non-hardlink inode.
    
    The race requires an adversary to guess the file handle of the
    yet to be created upper inode and decode the guessed file handle
    after ovl_creat_real(), but before ovl_instantiate().
    This race does not affect overlay directory inodes, because those
    are decoded via ovl_lookup_real() and not with ovl_obtain_alias().
    
    This patch fixes the race, by using inode_insert5() to add a newly
    created inode to cache.
    
    If the newly created inode apears to already exist in cache (hashed
    by the same real upper inode), we instantiate the dentry with the old
    inode and drop the new inode, instead of silently not hashing the new
    inode.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index b8a0160742b2..3c5e9f18b0d9 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -329,6 +329,7 @@ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
 struct ovl_inode_params {
+	struct inode *newinode;
 	struct dentry *upperdentry;
 	struct ovl_path *lowerpath;
 	struct dentry *index;

commit ac6a52eb65b5327859135269c9374bf2ff731c9f
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Tue May 8 09:27:21 2018 -0400

    ovl: Pass argument to ovl_get_inode() in a structure
    
    ovl_get_inode() right now has 5 parameters. Soon this patch series will
    add 2 more and suddenly argument list starts looking too long.
    
    Hence pass arguments to ovl_get_inode() in a structure and it looks
    little cleaner.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 3f13d0965e03..b8a0160742b2 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -328,12 +328,17 @@ int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
+struct ovl_inode_params {
+	struct dentry *upperdentry;
+	struct ovl_path *lowerpath;
+	struct dentry *index;
+	unsigned int numlower;
+};
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
 			       bool is_upper);
-struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
-			    struct ovl_path *lowerpath, struct dentry *index,
-			    unsigned int numlower);
+struct inode *ovl_get_inode(struct super_block *sb,
+			    struct ovl_inode_params *oip);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
 	to->i_uid = from->i_uid;

commit 137ec526a20c4e4d21d658a6581b471d39860911
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed May 16 17:51:25 2018 +0300

    ovl: create helper ovl_create_temp()
    
    Also used ovl_create_temp() in ovl_create_index() instead of calling
    ovl_do_mkdir() directly, so now all callers of ovl_do_mkdir() are routed
    through ovl_create_real(), which paves the way for Al's fix for non-hashed
    result from vfs_mkdir().
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 6bbde513e068..3f13d0965e03 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -346,7 +346,6 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 
 /* dir.c */
 extern const struct inode_operations ovl_dir_inode_operations;
-struct dentry *ovl_lookup_temp(struct dentry *workdir);
 int ovl_cleanup_and_whiteout(struct dentry *workdir, struct inode *dir,
 			     struct dentry *dentry);
 struct ovl_cattr {
@@ -361,6 +360,7 @@ struct ovl_cattr {
 struct dentry *ovl_create_real(struct inode *dir, struct dentry *newdentry,
 			       struct ovl_cattr *attr);
 int ovl_cleanup(struct inode *dir, struct dentry *dentry);
+struct dentry *ovl_create_temp(struct dentry *workdir, struct ovl_cattr *attr);
 
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);

commit 95a1c8153ad8bc99e7c4b90257f20b4f0474a9a0
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 16 17:51:25 2018 +0300

    ovl: return dentry from ovl_create_real()
    
    Al Viro suggested to simplify callers of ovl_create_real() by
    returning the created dentry (or ERR_PTR) from ovl_create_real().
    
    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index aa8286419133..6bbde513e068 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -358,8 +358,8 @@ struct ovl_cattr {
 
 #define OVL_CATTR(m) (&(struct ovl_cattr) { .mode = (m) })
 
-int ovl_create_real(struct inode *dir, struct dentry *newdentry,
-		    struct ovl_cattr *attr);
+struct dentry *ovl_create_real(struct inode *dir, struct dentry *newdentry,
+			       struct ovl_cattr *attr);
 int ovl_cleanup(struct inode *dir, struct dentry *dentry);
 
 /* copy_up.c */

commit 471ec5dcf4e712ea81bf431a57c98d4b67416d30
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed May 16 17:35:02 2018 +0300

    ovl: struct cattr cleanups
    
    * Rename to ovl_cattr
    
    * Fold ovl_create_real() hardlink argument into struct ovl_cattr
    
    * Create macro OVL_CATTR() to initialize struct ovl_cattr from mode
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 1c30d60cc290..aa8286419133 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -349,14 +349,17 @@ extern const struct inode_operations ovl_dir_inode_operations;
 struct dentry *ovl_lookup_temp(struct dentry *workdir);
 int ovl_cleanup_and_whiteout(struct dentry *workdir, struct inode *dir,
 			     struct dentry *dentry);
-struct cattr {
+struct ovl_cattr {
 	dev_t rdev;
 	umode_t mode;
 	const char *link;
+	struct dentry *hardlink;
 };
+
+#define OVL_CATTR(m) (&(struct ovl_cattr) { .mode = (m) })
+
 int ovl_create_real(struct inode *dir, struct dentry *newdentry,
-		    struct cattr *attr,
-		    struct dentry *hardlink);
+		    struct ovl_cattr *attr);
 int ovl_cleanup(struct inode *dir, struct dentry *dentry);
 
 /* copy_up.c */

commit 6cf00764b0082cefdaf5a36202aceb1ab2470051
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed May 16 17:04:00 2018 +0300

    ovl: strip debug argument from ovl_do_ helpers
    
    It did not prove to be useful.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e0b7de799f6b..1c30d60cc290 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -86,6 +86,7 @@ struct ovl_fh {
 static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int err = vfs_rmdir(dir, dentry);
+
 	pr_debug("rmdir(%pd2) = %i\n", dentry, err);
 	return err;
 }
@@ -93,56 +94,52 @@ static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
 static inline int ovl_do_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int err = vfs_unlink(dir, dentry, NULL);
+
 	pr_debug("unlink(%pd2) = %i\n", dentry, err);
 	return err;
 }
 
 static inline int ovl_do_link(struct dentry *old_dentry, struct inode *dir,
-			      struct dentry *new_dentry, bool debug)
+			      struct dentry *new_dentry)
 {
 	int err = vfs_link(old_dentry, dir, new_dentry, NULL);
-	if (debug) {
-		pr_debug("link(%pd2, %pd2) = %i\n",
-			 old_dentry, new_dentry, err);
-	}
+
+	pr_debug("link(%pd2, %pd2) = %i\n", old_dentry, new_dentry, err);
 	return err;
 }
 
 static inline int ovl_do_create(struct inode *dir, struct dentry *dentry,
-			     umode_t mode, bool debug)
+				umode_t mode)
 {
 	int err = vfs_create(dir, dentry, mode, true);
-	if (debug)
-		pr_debug("create(%pd2, 0%o) = %i\n", dentry, mode, err);
+
+	pr_debug("create(%pd2, 0%o) = %i\n", dentry, mode, err);
 	return err;
 }
 
 static inline int ovl_do_mkdir(struct inode *dir, struct dentry *dentry,
-			       umode_t mode, bool debug)
+			       umode_t mode)
 {
 	int err = vfs_mkdir(dir, dentry, mode);
-	if (debug)
-		pr_debug("mkdir(%pd2, 0%o) = %i\n", dentry, mode, err);
+	pr_debug("mkdir(%pd2, 0%o) = %i\n", dentry, mode, err);
 	return err;
 }
 
 static inline int ovl_do_mknod(struct inode *dir, struct dentry *dentry,
-			       umode_t mode, dev_t dev, bool debug)
+			       umode_t mode, dev_t dev)
 {
 	int err = vfs_mknod(dir, dentry, mode, dev);
-	if (debug) {
-		pr_debug("mknod(%pd2, 0%o, 0%o) = %i\n",
-			 dentry, mode, dev, err);
-	}
+
+	pr_debug("mknod(%pd2, 0%o, 0%o) = %i\n", dentry, mode, dev, err);
 	return err;
 }
 
 static inline int ovl_do_symlink(struct inode *dir, struct dentry *dentry,
-				 const char *oldname, bool debug)
+				 const char *oldname)
 {
 	int err = vfs_symlink(dir, dentry, oldname);
-	if (debug)
-		pr_debug("symlink(\"%s\", %pd2) = %i\n", oldname, dentry, err);
+
+	pr_debug("symlink(\"%s\", %pd2) = %i\n", oldname, dentry, err);
 	return err;
 }
 
@@ -168,11 +165,8 @@ static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,
 {
 	int err;
 
-	pr_debug("rename(%pd2, %pd2, 0x%x)\n",
-		 olddentry, newdentry, flags);
-
+	pr_debug("rename(%pd2, %pd2, 0x%x)\n", olddentry, newdentry, flags);
 	err = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);
-
 	if (err) {
 		pr_debug("...rename(%pd2, %pd2, ...) = %i\n",
 			 olddentry, newdentry, err);
@@ -362,7 +356,7 @@ struct cattr {
 };
 int ovl_create_real(struct inode *dir, struct dentry *newdentry,
 		    struct cattr *attr,
-		    struct dentry *hardlink, bool debug);
+		    struct dentry *hardlink);
 int ovl_cleanup(struct inode *dir, struct dentry *dentry);
 
 /* copy_up.c */

commit 12574a9f4c9cc9d8d6fd9078cbb8ec7d3e9ed46b
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Mar 16 10:39:37 2018 +0200

    ovl: consistent i_ino for non-samefs with xino
    
    When overlay layers are not all on the same fs, but all inode numbers
    of underlying fs do not use the high 'xino' bits, overlay st_ino values
    are constant and persistent.
    
    In that case, set i_ino value to the same value as st_ino for nfsd
    readdirplus validator.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 8eefc309aeb6..e0b7de799f6b 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -338,7 +338,7 @@ struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
 			       bool is_upper);
 struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
-			    struct dentry *lowerdentry, struct dentry *index,
+			    struct ovl_path *lowerpath, struct dentry *index,
 			    unsigned int numlower);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {

commit e487d889b7e3e8ec4091eb83bc4f7e67c7f05e27
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Nov 7 13:55:04 2017 +0200

    ovl: constant st_ino for non-samefs with xino
    
    On 64bit systems, when overlay layers are not all on the same fs, but
    all inode numbers of underlying fs are not using the high bits, use the
    high bits to partition the overlay st_ino address space.  The high bits
    hold the fsid (upper fsid is 0).  This way overlay inode numbers are unique
    and all inodes use overlay st_dev.  Inode numbers are also persistent
    for a given layer configuration.
    
    Currently, our only indication for available high ino bits is from a
    filesystem that supports file handles and uses the default encode_fh()
    operation, which encodes a 32bit inode number.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 09779f9111a8..8eefc309aeb6 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -202,7 +202,7 @@ void ovl_drop_write(struct dentry *dentry);
 struct dentry *ovl_workdir(struct dentry *dentry);
 const struct cred *ovl_override_creds(struct super_block *sb);
 struct super_block *ovl_same_sb(struct super_block *sb);
-bool ovl_can_decode_fh(struct super_block *sb);
+int ovl_can_decode_fh(struct super_block *sb);
 struct dentry *ovl_indexdir(struct super_block *sb);
 bool ovl_index_all(struct super_block *sb);
 bool ovl_verify_lower(struct super_block *sb);
@@ -264,6 +264,13 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
 }
 
+static inline unsigned int ovl_xino_bits(struct super_block *sb)
+{
+	struct ovl_fs *ofs = sb->s_fs_info;
+
+	return ofs->xino_bits;
+}
+
 
 /* namei.c */
 int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);

commit da309e8c055de8d6461ae01764a3352c77878735
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Nov 8 19:39:51 2017 +0200

    ovl: factor out ovl_map_dev_ino() helper
    
    A helper for ovl_getattr() to map the values of st_dev and st_ino
    according to constant st_ino rules.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index b51613b355c5..09779f9111a8 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -215,6 +215,7 @@ void ovl_path_lower(struct dentry *dentry, struct path *path);
 enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
+struct ovl_layer *ovl_layer_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
 struct dentry *ovl_i_dentry_upper(struct inode *inode);
 struct inode *ovl_inode_upper(struct inode *inode);

commit 8a22efa15b46d524577cac79da63cebca8e8307f
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Mar 9 15:51:02 2018 +0200

    ovl: do not try to reconnect a disconnected origin dentry
    
    On lookup of non directory, we try to decode the origin file handle
    stored in upper inode. The origin file handle is supposed to be decoded
    to a disconnected non-dir dentry, which is fine, because we only need
    the lower inode of a copy up origin.
    
    However, if the origin file handle somehow turns out to be a directory
    we pay the expensive cost of reconnecting the directory dentry, only to
    get a mismatch file type and drop the dentry.
    
    Optimize this case by explicitly opting out of reconnecting the dentry.
    Opting-out of reconnect is done by passing a NULL acceptable callback
    to exportfs_decode_fh().
    
    While the case described above is a strange corner case that does not
    really need to be optimized, the API added for this optimization will
    be used by a following patch to optimize a more common case of decoding
    an overlayfs file handle.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index dd6c10e5a7db..b51613b355c5 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -266,8 +266,9 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 
 /* namei.c */
 int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
-struct dentry *ovl_decode_real_fh(struct ovl_fh *fh, struct vfsmount *mnt);
-int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
+struct dentry *ovl_decode_real_fh(struct ovl_fh *fh, struct vfsmount *mnt,
+				  bool connected);
+int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh, bool connected,
 			struct dentry *upperdentry, struct ovl_path **stackp);
 int ovl_verify_set_fh(struct dentry *dentry, const char *name,
 		      struct dentry *real, bool is_upper, bool set);

commit 5b2cccd32c668de6bd1979545184cd7f0260f053
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Feb 2 10:42:03 2018 +0200

    ovl: disambiguate ovl_encode_fh()
    
    Rename ovl_encode_fh() to ovl_encode_real_fh() to differentiate from the
    exportfs function ovl_encode_inode_fh() and change the latter to
    ovl_encode_fh() to match the exportfs method name.
    
    Rename ovl_decode_fh() to ovl_decode_real_fh() for consistency.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 225ff1171147..dd6c10e5a7db 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -266,7 +266,7 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 
 /* namei.c */
 int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
-struct dentry *ovl_decode_fh(struct ovl_fh *fh, struct vfsmount *mnt);
+struct dentry *ovl_decode_real_fh(struct ovl_fh *fh, struct vfsmount *mnt);
 int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
 			struct dentry *upperdentry, struct ovl_path **stackp);
 int ovl_verify_set_fh(struct dentry *dentry, const char *name,
@@ -361,7 +361,7 @@ int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
-struct ovl_fh *ovl_encode_fh(struct dentry *real, bool is_upper);
+struct ovl_fh *ovl_encode_real_fh(struct dentry *real, bool is_upper);
 int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
 		   struct dentry *upper);
 

commit 2ca3c148a06244d46dcfc95c5965644c83a30b37
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 30 13:31:09 2018 +0200

    ovl: check lower ancestry on encode of lower dir file handle
    
    This change relaxes copy up on encode of merge dir with lower layer > 1
    and handles the case of encoding a merge dir with lower layer 1, where an
    ancestor is a non-indexed merge dir. In that case, decode of the lower
    file handle will not have been possible if the non-indexed ancestor is
    redirected before or after encode.
    
    Before encoding a non-upper directory file handle from real layer N, we
    need to check if it will be possible to reconnect an overlay dentry from
    the real lower decoded dentry. This is done by following the overlay
    ancestry up to a "layer N connected" ancestor and verifying that all
    parents along the way are "layer N connectable". If an ancestor that is
    NOT "layer N connectable" is found, we need to copy up an ancestor, which
    is "layer N connectable", thus making that ancestor "layer N connected".
    For example:
    
     layer 1: /a
     layer 2: /a/b/c
    
    The overlay dentry /a is NOT "layer 2 connectable", because if dir /a is
    copied up and renamed, upper dir /a will be indexed by lower dir /a from
    layer 1. The dir /a from layer 2 will never be indexed, so the algorithm
    in ovl_lookup_real_ancestor() (*) will not be able to lookup a connected
    overlay dentry from the connected lower dentry /a/b/c.
    
    To avoid this problem on decode time, we need to copy up an ancestor of
    /a/b/c, which is "layer 2 connectable", on encode time. That ancestor is
    /a/b. After copy up (and index) of /a/b, it will become "layer 2 connected"
    and when the time comes to decode the file handle from lower dentry /a/b/c,
    ovl_lookup_real_ancestor() will find the indexed ancestor /a/b and decoding
    a connected overlay dentry will be accomplished.
    
    (*) the algorithm in ovl_lookup_real_ancestor() can be improved to lookup
    an entry /a in the lower layers above layer N and find the indexed dir /a
    from layer 1. If that improvement is made, then the check for "layer N
    connected" will need to verify there are no redirects in lower layers above
    layer N. In the example above, /a will be "layer 2 connectable". However,
    if layer 2 dir /a is a target of a layer 1 redirect, then /a will NOT be
    "layer 2 connectable":
    
     layer 1: /A (redirect = /a)
     layer 2: /a/b/c
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 0df25a9c94bd..225ff1171147 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -40,6 +40,7 @@ enum ovl_inode_flag {
 enum ovl_entry_flag {
 	OVL_E_UPPER_ALIAS,
 	OVL_E_OPAQUE,
+	OVL_E_CONNECTED,
 };
 
 /*

commit 061701540349c30d72e48a201449a840c77ad509
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jan 17 14:40:27 2018 +0200

    ovl: lookup indexed ancestor of lower dir
    
    ovl_lookup_real() in lower layer walks back lower parents to find the
    topmost indexed parent. If an indexed ancestor is found before reaching
    lower layer root, ovl_lookup_real() is called recursively with upper
    layer to walk back from indexed upper to the topmost connected/hashed
    upper parent (or up to root).
    
    ovl_lookup_real() in upper layer then walks forward to connect the topmost
    upper overlay dir dentry and ovl_lookup_real() in lower layer continues to
    walk forward to connect the decoded lower overlay dir dentry.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index bf17bf97c50f..0df25a9c94bd 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -274,6 +274,8 @@ struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index);
 int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
 int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
+struct dentry *ovl_lookup_index(struct ovl_fs *ofs, struct dentry *upper,
+				struct dentry *origin, bool verify);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 			  unsigned int flags);

commit 4b91c30a5a19332e8dd10b601d05b72caf657730
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Jan 18 16:39:13 2018 +0200

    ovl: lookup connected ancestor of dir in inode cache
    
    Decoding a dir file handle requires walking backward up to layer root and
    for lower dir also checking the index to see if any of the parents have
    been copied up.
    
    Lookup overlay ancestor dentry in inode/dentry cache by decoded real
    parents to shortcut looking up all the way back to layer root.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index a5d415aec131..bf17bf97c50f 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -323,7 +323,8 @@ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
-struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *origin);
+struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
+			       bool is_upper);
 struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
 			    struct dentry *lowerdentry, struct dentry *index,
 			    unsigned int numlower);

commit 3b0bfc6ed3c434800e5eacfb6cdbe45c07c270e1
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sun Dec 24 18:42:16 2017 +0200

    ovl: decode indexed dir file handles
    
    Decoding an indexed dir file handle is done by looking up the file handle
    in index dir by name and then decoding the upper dir from the index origin
    file handle. The decoded upper path is used to lookup an overlay dentry of
    the same path.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index a47f9142b6be..a5d415aec131 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -270,6 +270,7 @@ int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
 			struct dentry *upperdentry, struct ovl_path **stackp);
 int ovl_verify_set_fh(struct dentry *dentry, const char *name,
 		      struct dentry *real, bool is_upper, bool set);
+struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index);
 int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
 int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);

commit 9436a1a339fae84698aaa0b66d7a822018388348
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sun Dec 24 18:28:04 2017 +0200

    ovl: decode lower file handles of unlinked but open files
    
    Lookup overlay inode in cache by origin inode, so we can decode a file
    handle of an open file even if the index has a whiteout index entry to
    mark this overlay inode was unlinked.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 40ba11e412b1..a47f9142b6be 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -322,6 +322,7 @@ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
+struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *origin);
 struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
 			    struct dentry *lowerdentry, struct dentry *index,
 			    unsigned int numlower);

commit f941866fc4a8ad0d0b861cc2dbffa06a9f5e8963
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Jan 19 21:33:44 2018 +0200

    ovl: decode lower non-dir file handles
    
    Decoding a lower non-dir file handle is done by decoding the lower dentry
    from underlying lower fs, finding or allocating an overlay inode that is
    hashed by the real lower inode and instantiating an overlay dentry with
    that inode.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 401113a2e9c7..40ba11e412b1 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -266,6 +266,8 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 /* namei.c */
 int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
 struct dentry *ovl_decode_fh(struct ovl_fh *fh, struct vfsmount *mnt);
+int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
+			struct dentry *upperdentry, struct ovl_path **stackp);
 int ovl_verify_set_fh(struct dentry *dentry, const char *name,
 		      struct dentry *real, bool is_upper, bool set);
 int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);

commit 8556a4205b111c4dac931ee5eba4fcce74c3cb21
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Jan 19 01:03:23 2018 +0200

    ovl: decode pure upper file handles
    
    Decoding an upper file handle is done by decoding the upper dentry from
    underlying upper fs, finding or allocating an overlay inode that is
    hashed by the real upper inode and instantiating an overlay dentry with
    that inode.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f2baa2ccaacd..401113a2e9c7 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -264,6 +264,8 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 
 
 /* namei.c */
+int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
+struct dentry *ovl_decode_fh(struct ovl_fh *fh, struct vfsmount *mnt);
 int ovl_verify_set_fh(struct dentry *dentry, const char *name,
 		      struct dentry *real, bool is_upper, bool set);
 int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);

commit 8ed5eec9d6c4c013aa657ebefbd10a1a0d15893d
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jul 12 14:17:16 2017 +0300

    ovl: encode pure upper file handles
    
    Encode overlay file handles as struct ovl_fh containing the file handle
    encoding of the real upper inode.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 2dddcd257eb3..f2baa2ccaacd 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -68,6 +68,9 @@ enum ovl_entry_flag {
 #error Endianness not defined
 #endif
 
+/* The type returned by overlay exportfs ops when encoding an ovl_fh handle */
+#define OVL_FILEID	0xfb
+
 /* On-disk and in-memeory format for redirect by file handle */
 struct ovl_fh {
 	u8 version;	/* 0 */
@@ -351,3 +354,6 @@ int ovl_set_attr(struct dentry *upper, struct kstat *stat);
 struct ovl_fh *ovl_encode_fh(struct dentry *real, bool is_upper);
 int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
 		   struct dentry *upper);
+
+/* export.c */
+extern const struct export_operations ovl_export_operations;

commit c62520a83bceae0bb0b7b3de10c3e81205cd3823
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sun Jan 14 19:25:31 2018 +0200

    ovl: store 'has_upper' and 'opaque' as bit flags
    
    We need to make some room in struct ovl_entry to store information
    about redirected ancestors for NFS export, so cram two booleans as
    bit flags.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f9fce7a680cd..2dddcd257eb3 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -29,7 +29,7 @@ enum ovl_path_type {
 #define OVL_XATTR_NLINK OVL_XATTR_PREFIX "nlink"
 #define OVL_XATTR_UPPER OVL_XATTR_PREFIX "upper"
 
-enum ovl_flag {
+enum ovl_inode_flag {
 	/* Pure upper dir that may contain non pure upper entries */
 	OVL_IMPURE,
 	/* Non-merge dir that may contain whiteout entries */
@@ -37,6 +37,11 @@ enum ovl_flag {
 	OVL_INDEX,
 };
 
+enum ovl_entry_flag {
+	OVL_E_UPPER_ALIAS,
+	OVL_E_OPAQUE,
+};
+
 /*
  * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
  * where:
@@ -213,6 +218,9 @@ struct inode *ovl_inode_lower(struct inode *inode);
 struct inode *ovl_inode_real(struct inode *inode);
 struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);
 void ovl_set_dir_cache(struct inode *inode, struct ovl_dir_cache *cache);
+void ovl_dentry_set_flag(unsigned long flag, struct dentry *dentry);
+void ovl_dentry_clear_flag(unsigned long flag, struct dentry *dentry);
+bool ovl_dentry_test_flag(unsigned long flag, struct dentry *dentry);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry);

commit 0aceb53e73befee4441c9e68d23cb4f682382171
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Dec 12 23:43:16 2017 +0200

    ovl: do not pass overlay dentry to ovl_get_inode()
    
    This is needed for using ovl_get_inode() for decoding file handles
    for NFS export.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 4e784f6ff484..f9fce7a680cd 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -307,8 +307,9 @@ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
-struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry,
-			    struct dentry *index);
+struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
+			    struct dentry *lowerdentry, struct dentry *index,
+			    unsigned int numlower);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
 	to->i_uid = from->i_uid;

commit 91ffe7beb31e7e1e689a59f5ef56acea0811d81c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Dec 28 20:23:05 2017 +0200

    ovl: factor out ovl_get_index_fh() helper
    
    The helper is needed to lookup an index by file handle for NFS export.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 8f4313c6693b..4e784f6ff484 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -257,6 +257,7 @@ int ovl_verify_set_fh(struct dentry *dentry, const char *name,
 		      struct dentry *real, bool is_upper, bool set);
 int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
 int ovl_get_index_name(struct dentry *origin, struct qstr *name);
+struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 			  unsigned int flags);

commit e7dd0e71348c1e3bc4b9d767c1ffbcbdee46a726
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Oct 24 17:38:33 2017 +0300

    ovl: whiteout index when union nlink drops to zero
    
    With NFS export feature enabled, when overlay inode nlink drops to
    zero, instead of removing the index entry, replace it with a whiteout
    index entry.
    
    This is needed for NFS export in order to prevent future open by handle
    from opening the lower file directly.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d7e65284c13b..8f4313c6693b 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -321,6 +321,8 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 /* dir.c */
 extern const struct inode_operations ovl_dir_inode_operations;
 struct dentry *ovl_lookup_temp(struct dentry *workdir);
+int ovl_cleanup_and_whiteout(struct dentry *workdir, struct inode *dir,
+			     struct dentry *dentry);
 struct cattr {
 	dev_t rdev;
 	umode_t mode;

commit 24b33ee104ecd5a4e1e71412f8966199d6a0bf02
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Sep 26 07:55:26 2017 +0300

    ovl: create ovl_need_index() helper
    
    The helper determines which lower file needs to be indexed
    on copy up and before nlink changes.
    
    For index=on, the helper evaluates to true for lower hardlinks.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 25794a3a3fe1..d7e65284c13b 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -241,6 +241,7 @@ void ovl_clear_flag(unsigned long flag, struct inode *inode);
 bool ovl_test_flag(unsigned long flag, struct inode *inode);
 bool ovl_inuse_trylock(struct dentry *dentry);
 void ovl_inuse_unlock(struct dentry *dentry);
+bool ovl_need_index(struct dentry *dentry);
 int ovl_nlink_start(struct dentry *dentry, bool *locked);
 void ovl_nlink_end(struct dentry *dentry, bool locked);
 int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);

commit ad1d615cec1c973aa222c065997a77e7cd5a0d17
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Jan 11 10:47:03 2018 +0200

    ovl: use directory index entries for consistency verification
    
    A directory index is a directory type entry in index dir with a
    "trusted.overlay.upper" xattr containing an encoded ovl_fh of the merge
    directory upper dir inode.
    
    On lookup of non-dir files, lower file is followed by origin file handle.
    On lookup of dir entries, lower dir is found by name and then compared
    to origin file handle. We only trust dir index if we verified that lower
    dir matches origin file handle, otherwise index may be inconsistent and
    we ignore it.
    
    If we find an indexed non-upper dir or an indexed merged dir, whose
    index 'upper' xattr points to a different upper dir, that means that the
    lower directory may be also referenced by another upper dir via redirect,
    so we fail the lookup on inconsistency error.
    
    To be consistent with directory index entries format, the association of
    index dir to upper root dir, that was stored by older kernels in
    "trusted.overlay.origin" xattr is now stored in "trusted.overlay.upper"
    xattr. This also serves as an indication that overlay was mounted with a
    kernel that support index directory entries. For backward compatibility,
    if an 'origin' xattr exists on the index dir we also verify it on mount.
    
    Directory index entries are going to be used for NFS export.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index db75955f9677..25794a3a3fe1 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -27,6 +27,7 @@ enum ovl_path_type {
 #define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
 #define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
 #define OVL_XATTR_NLINK OVL_XATTR_PREFIX "nlink"
+#define OVL_XATTR_UPPER OVL_XATTR_PREFIX "upper"
 
 enum ovl_flag {
 	/* Pure upper dir that may contain non pure upper entries */
@@ -266,6 +267,12 @@ static inline int ovl_verify_origin(struct dentry *upper,
 	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
 }
 
+static inline int ovl_verify_upper(struct dentry *index,
+				    struct dentry *upper, bool set)
+{
+	return ovl_verify_set_fh(index, OVL_XATTR_UPPER, upper, true, set);
+}
+
 /* readdir.c */
 extern const struct file_operations ovl_dir_operations;
 int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);

commit f168f1098dd9038daaf9f7be5f81cdea4985886a
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Jan 19 11:26:53 2018 +0200

    ovl: add support for "nfs_export" configuration
    
    Introduce the "nfs_export" config, module and mount options.
    
    The NFS export feature depends on the "index" feature and enables two
    implicit overlayfs features: "index_all" and "verify_lower".
    The "index_all" feature creates an index on copy up of every file and
    directory. The "verify_lower" feature uses the full index to detect
    overlay filesystems inconsistencies on lookup, like redirect from
    multiple upper dirs to the same lower dir.
    
    NFS export can be enabled for non-upper mount with no index. However,
    because lower layer redirects cannot be verified with the index, enabling
    NFS export support on an overlay with no upper layer requires turning off
    redirect follow (e.g. "redirect_dir=nofollow").
    
    The full index may incur some overhead on mount time, especially when
    verifying that lower directory file handles are not stale.
    
    NFS export support, full index and consistency verification will be
    implemented by following patches.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 1d62b1e6111a..db75955f9677 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -194,6 +194,8 @@ const struct cred *ovl_override_creds(struct super_block *sb);
 struct super_block *ovl_same_sb(struct super_block *sb);
 bool ovl_can_decode_fh(struct super_block *sb);
 struct dentry *ovl_indexdir(struct super_block *sb);
+bool ovl_index_all(struct super_block *sb);
+bool ovl_verify_lower(struct super_block *sb);
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 bool ovl_dentry_remote(struct dentry *dentry);
 bool ovl_dentry_weird(struct dentry *dentry);

commit 051224438af21047b34160b1e0ad1c5af45fdace
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Jan 11 08:25:32 2018 +0200

    ovl: generalize ovl_verify_origin() and helpers
    
    Remove the "origin" language from the functions that handle set, get
    and verify of "origin" xattr and pass the xattr name as an argument.
    
    The same helpers are going to be used for NFS export to get, get and
    verify the "upper" xattr for directory index entries.
    
    ovl_verify_origin() is now a helper used only to verify non upper
    file handle stored in "origin" xattr of upper inode.
    
    The upper root dir file handle is still stored in "origin" xattr on
    the index dir for backward compatibility. This is going to be changed
    by the patch that adds directory index entries support.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d55afb6646b0..1d62b1e6111a 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -249,8 +249,8 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 
 
 /* namei.c */
-int ovl_verify_origin(struct dentry *dentry, struct dentry *origin,
-		      bool is_upper, bool set);
+int ovl_verify_set_fh(struct dentry *dentry, const char *name,
+		      struct dentry *real, bool is_upper, bool set);
 int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
 int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
@@ -258,6 +258,12 @@ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 			  unsigned int flags);
 bool ovl_lower_positive(struct dentry *dentry);
 
+static inline int ovl_verify_origin(struct dentry *upper,
+				    struct dentry *origin, bool set)
+{
+	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
+}
+
 /* readdir.c */
 extern const struct file_operations ovl_dir_operations;
 int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
@@ -320,6 +326,6 @@ int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
-struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper);
+struct ovl_fh *ovl_encode_fh(struct dentry *real, bool is_upper);
 int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
 		   struct dentry *upper);

commit 1eff1a1deec727bacead79ec64554c1df190f43c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Dec 12 22:40:46 2017 +0200

    ovl: simplify arguments to ovl_check_origin_fh()
    
    Pass the fs instance with lower_layers array instead of the dentry
    lowerstack array to ovl_check_origin_fh(), because the dentry members
    of lowerstack play no role in this helper.
    
    This change simplifies the argument list of ovl_check_origin(),
    ovl_cleanup_index() and ovl_verify_index().
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d1cfa69c98b5..d55afb6646b0 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -251,11 +251,11 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 /* namei.c */
 int ovl_verify_origin(struct dentry *dentry, struct dentry *origin,
 		      bool is_upper, bool set);
-int ovl_verify_index(struct dentry *index, struct ovl_path *lower,
-		     unsigned int numlower);
+int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
 int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
-struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
+struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
+			  unsigned int flags);
 bool ovl_lower_positive(struct dentry *dentry);
 
 /* readdir.c */
@@ -267,8 +267,7 @@ void ovl_dir_cache_free(struct inode *inode);
 int ovl_check_d_type_supported(struct path *realpath);
 void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
 			 struct dentry *dentry, int level);
-int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
-			 struct ovl_path *lower, unsigned int numlower);
+int ovl_indexdir_cleanup(struct ovl_fs *ofs);
 
 /* inode.c */
 int ovl_set_nlink_upper(struct dentry *dentry);

commit 9678e630305724487f1fc101d6b83c383ff9cc90
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jan 3 19:34:45 2018 +0200

    ovl: fix inconsistent d_ino for legacy merge dir
    
    For a merge dir that was copied up before v4.12 or that was hand crafted
    offline (e.g. mkdir {upper/lower}/dir), upper dir does not contain the
    'trusted.overlay.origin' xattr.  In that case, stat(2) on the merge dir
    returns the lower dir st_ino, but getdents(2) returns the upper dir d_ino.
    
    After this change, on merge dir lookup, missing origin xattr on upper
    dir will be fixed and 'impure' xattr will be fixed on parent of the legacy
    merge dir.
    
    Suggested-by: zhangyi (F) <yi.zhang@huawei.com>
    Reviewed-by: zhangyi (F) <yi.zhang@huawei.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index b489099ccd49..d1cfa69c98b5 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -322,3 +322,5 @@ int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
 struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper);
+int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
+		   struct dentry *upper);

commit 7879cb43f9a75710af439c6bd81c94de1aa3d740
Author: Vasyl Gomonovych <gomonovych@gmail.com>
Date:   Tue Nov 28 00:09:23 2017 +0100

    ovl: Use PTR_ERR_OR_ZERO()
    
    Fix ptr_ret.cocci warnings:
    fs/overlayfs/overlayfs.h:179:11-17: WARNING: PTR_ERR_OR_ZERO can be used
    
    Use PTR_ERR_OR_ZERO rather than if(IS_ERR(...)) + PTR_ERR
    
    Generated by: scripts/coccinelle/api/ptr_ret.cocci
    
    Signed-off-by: Vasyl Gomonovych <gomonovych@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 13eab09a6b6f..b489099ccd49 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -180,7 +180,7 @@ static inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)
 static inline struct dentry *ovl_do_tmpfile(struct dentry *dentry, umode_t mode)
 {
 	struct dentry *ret = vfs_tmpfile(dentry, mode, 0);
-	int err = IS_ERR(ret) ? PTR_ERR(ret) : 0;
+	int err = PTR_ERR_OR_ZERO(ret);
 
 	pr_debug("tmpfile(%pd2, 0%o) = %i\n", dentry, mode, err);
 	return ret;

commit d9768076068f81687b3dbddbd76b5e108f5d53d0
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sun Sep 24 13:00:19 2017 +0300

    ovl: remove unneeded arg from ovl_verify_origin()
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index cefe5a97d048..13eab09a6b6f 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -249,8 +249,8 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 
 
 /* namei.c */
-int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
-		      struct dentry *origin, bool is_upper, bool set);
+int ovl_verify_origin(struct dentry *dentry, struct dentry *origin,
+		      bool is_upper, bool set);
 int ovl_verify_index(struct dentry *index, struct ovl_path *lower,
 		     unsigned int numlower);
 int ovl_get_index_name(struct dentry *origin, struct qstr *name);

commit b93436320c1e9089a055941523571cd7c037f7cb
Author: Chandan Rajendra <chandan@linux.vnet.ibm.com>
Date:   Mon Jul 24 01:57:54 2017 -0500

    ovl: re-structure overlay lower layers in-memory
    
    Define new structures to represent overlay instance lower layers and
    overlay merge dir lower layers to make room for storing more per layer
    information in-memory.
    
    Instead of keeping the fs instance lower layers in an array of struct
    vfsmount, keep them in an array of new struct ovl_layer, that has a
    pointer to struct vfsmount.
    
    Instead of keeping the dentry lower layers in an array of struct path,
    keep them in an array of new struct ovl_path, that has a pointer to
    struct dentry and to struct ovl_layer.
    
    Add a small helper to find the fs layer id that correspopnds to a lower
    struct ovl_path and use it in ovl_lookup().
    
    [amir: split re-structure from anonymous bdev patch]
    
    Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 1cf3bdd193a4..cefe5a97d048 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -251,7 +251,7 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 /* namei.c */
 int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 		      struct dentry *origin, bool is_upper, bool set);
-int ovl_verify_index(struct dentry *index, struct path *lowerstack,
+int ovl_verify_index(struct dentry *index, struct ovl_path *lower,
 		     unsigned int numlower);
 int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
@@ -268,7 +268,7 @@ int ovl_check_d_type_supported(struct path *realpath);
 void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
 			 struct dentry *dentry, int level);
 int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
-			 struct path *lowerstack, unsigned int numlower);
+			 struct ovl_path *lower, unsigned int numlower);
 
 /* inode.c */
 int ovl_set_nlink_upper(struct dentry *dentry);

commit ee023c30d7d6bc21d3a85f3625a30209bdcc41e6
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Mon Oct 30 13:33:11 2017 +0200

    ovl: move include of ovl_entry.h into overlayfs.h
    
    Most overlayfs c files already explicitly include ovl_entry.h
    to use overlay entry struct definitions and upcoming changes
    are going to require even more c files to include this header.
    
    All overlayfs c files include overlayfs.h and overlayfs.h itself
    refers to some structs defined in ovl_entry.h, so it seems more
    logic to include ovl_entry.h from overlayfs.h than from c files.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d53157ccf0d7..1cf3bdd193a4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -9,6 +9,7 @@
 
 #include <linux/kernel.h>
 #include <linux/uuid.h>
+#include "ovl_entry.h"
 
 enum ovl_path_type {
 	__OVL_PATH_UPPER	= (1 << 0),

commit b79e05aaa166755fafbf02db275175edb5175df8
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sun Jun 25 16:37:17 2017 +0300

    ovl: no direct iteration for dir with origin xattr
    
    If a non-merge dir in an overlay mount has an overlay.origin xattr, it
    means it was once an upper merge dir, which may contain whiteouts and
    then the lower dir was removed under it.
    
    Do not iterate real dir directly in this case to avoid exposing whiteouts.
    
    [SzM] Set OVL_WHITEOUT for all merge directories as well.
    
    [amir] A directory that was just copied up does not have the OVL_WHITEOUTS
    flag. We need to set it to fix merge dir iteration.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d9a0edd4e57e..d53157ccf0d7 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -28,7 +28,10 @@ enum ovl_path_type {
 #define OVL_XATTR_NLINK OVL_XATTR_PREFIX "nlink"
 
 enum ovl_flag {
+	/* Pure upper dir that may contain non pure upper entries */
 	OVL_IMPURE,
+	/* Non-merge dir that may contain whiteout entries */
+	OVL_WHITEOUTS,
 	OVL_INDEX,
 };
 
@@ -223,6 +226,7 @@ bool ovl_is_whiteout(struct dentry *dentry);
 struct file *ovl_path_open(struct path *path, int flags);
 int ovl_copy_up_start(struct dentry *dentry);
 void ovl_copy_up_end(struct dentry *dentry);
+bool ovl_check_origin_xattr(struct dentry *dentry);
 bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
 int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
 		       const char *name, const void *value, size_t size,

commit 6eaf011144af10cad34c0d46f82e50d382c8e926
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Oct 12 19:03:04 2017 +0300

    ovl: fix EIO from lookup of non-indexed upper
    
    Commit fbaf94ee3cd5 ("ovl: don't set origin on broken lower hardlink")
    attempt to avoid the condition of non-indexed upper inode with lower
    hardlink as origin. If this condition is found, lookup returns EIO.
    
    The protection of commit mentioned above does not cover the case of lower
    that is not a hardlink when it is copied up (with either index=off/on)
    and then lower is hardlinked while overlay is offline.
    
    Changes to lower layer while overlayfs is offline should not result in
    unexpected behavior, so a permanent EIO error after creating a link in
    lower layer should not be considered as correct behavior.
    
    This fix replaces EIO error with success in cases where upper has origin
    but no index is found, or index is found that does not match upper
    inode. In those cases, lookup will not fail and the returned overlay inode
    will be hashed by upper inode instead of by lower origin inode.
    
    Fixes: 359f392ca53e ("ovl: lookup index entry for copy up origin")
    Cc: <stable@vger.kernel.org> # v4.13
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index c706a6f99928..d9a0edd4e57e 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -286,7 +286,8 @@ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
-struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry);
+struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry,
+			    struct dentry *index);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
 	to->i_uid = from->i_uid;

commit 5820dc0888d302ac05f8b91ffdf7e4e53b4fbf53
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Mon Sep 25 16:39:55 2017 +0300

    ovl: fix missing unlock_rename() in ovl_do_copy_up()
    
    Use the ovl_lock_rename_workdir() helper which requires
    unlock_rename() only on lock success.
    
    Fixes: ("fd210b7d67ee ovl: move copy up lock out")
    Cc: <stable@vger.kernel.org> # v4.13
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d4e8c1a08fb0..c706a6f99928 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -235,6 +235,7 @@ bool ovl_inuse_trylock(struct dentry *dentry);
 void ovl_inuse_unlock(struct dentry *dentry);
 int ovl_nlink_start(struct dentry *dentry, bool *locked);
 void ovl_nlink_end(struct dentry *dentry, bool locked);
+int ovl_lock_rename_workdir(struct dentry *workdir, struct dentry *upperdir);
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {

commit 4edb83bb1041e2f946ce36ea93f6bcd06d984bf4
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jul 27 21:54:06 2017 +0200

    ovl: constant d_ino for non-merge dirs
    
    Impure directories are ones which contain objects with origins (i.e. those
    that have been copied up).  These are relevant to readdir operation only
    because of the d_ino field, no other transformation is necessary.  Also a
    directory can become impure between two getdents(2) calls.
    
    This patch creates a cache for impure directories.  Unlike the cache for
    merged directories, this one only contains entries with origin and is not
    refcounted but has a its lifetime tied to that of the dentry.
    
    Similarly to the merged cache, the impure cache is invalidated based on a
    version number.  This version number is incremented when an entry with
    origin is added or removed from the directory.
    
    If the cache is empty, then the impure xattr is removed from the directory.
    
    This patch also fixes up handling of d_ino for the ".." entry if the parent
    directory is merged.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e927a62c97ae..d4e8c1a08fb0 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -204,8 +204,8 @@ struct dentry *ovl_i_dentry_upper(struct inode *inode);
 struct inode *ovl_inode_upper(struct inode *inode);
 struct inode *ovl_inode_lower(struct inode *inode);
 struct inode *ovl_inode_real(struct inode *inode);
-struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
-void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
+struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);
+void ovl_set_dir_cache(struct inode *inode, struct ovl_dir_cache *cache);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry);
@@ -217,7 +217,7 @@ void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
 void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
 		    struct dentry *lowerdentry);
 void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
-void ovl_dentry_version_inc(struct dentry *dentry);
+void ovl_dentry_version_inc(struct dentry *dentry, bool impurity);
 u64 ovl_dentry_version_get(struct dentry *dentry);
 bool ovl_is_whiteout(struct dentry *dentry);
 struct file *ovl_path_open(struct path *path, int flags);
@@ -229,6 +229,7 @@ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
 		       int xerr);
 int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
 void ovl_set_flag(unsigned long flag, struct inode *inode);
+void ovl_clear_flag(unsigned long flag, struct inode *inode);
 bool ovl_test_flag(unsigned long flag, struct inode *inode);
 bool ovl_inuse_trylock(struct dentry *dentry);
 void ovl_inuse_unlock(struct dentry *dentry);
@@ -256,6 +257,7 @@ extern const struct file_operations ovl_dir_operations;
 int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
 void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list);
 void ovl_cache_free(struct list_head *list);
+void ovl_dir_cache_free(struct inode *inode);
 int ovl_check_d_type_supported(struct path *realpath);
 void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
 			 struct dentry *dentry, int level);

commit 1d88f183734c0d916428911df006e645a6162cab
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jul 20 11:08:21 2017 +0200

    ovl: fix xattr get and set with selinux
    
    inode_doinit_with_dentry() in SELinux wants to read the upper inode's xattr
    to get security label, and ovl_xattr_get() calls ovl_dentry_real(), which
    depends on dentry->d_inode, but d_inode is null and not initialized yet at
    this point resulting in an Oops.
    
    Fix by getting the upperdentry info from the inode directly in this case.
    
    Reported-by: Eryu Guan <eguan@redhat.com>
    Fixes: 09d8b586731b ("ovl: move __upperdentry to ovl_inode")
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 032120a761c4..e927a62c97ae 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -200,6 +200,7 @@ enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
+struct dentry *ovl_i_dentry_upper(struct inode *inode);
 struct inode *ovl_inode_upper(struct inode *inode);
 struct inode *ovl_inode_lower(struct inode *inode);
 struct inode *ovl_inode_real(struct inode *inode);
@@ -271,9 +272,9 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 int ovl_getattr(const struct path *path, struct kstat *stat,
 		u32 request_mask, unsigned int flags);
 int ovl_permission(struct inode *inode, int mask);
-int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
-		  size_t size, int flags);
-int ovl_xattr_get(struct dentry *dentry, const char *name,
+int ovl_xattr_set(struct dentry *dentry, struct inode *inode, const char *name,
+		  const void *value, size_t size, int flags);
+int ovl_xattr_get(struct dentry *dentry, struct inode *inode, const char *name,
 		  void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 struct posix_acl *ovl_get_acl(struct inode *inode, int type);

commit 961af647fc9ebcdb3e98c8f11b399ebe01169fb1
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jul 11 15:58:36 2017 +0300

    ovl: fix origin verification of index dir
    
    Commit 54fb347e836f ("ovl: verify index dir matches upper dir")
    introduced a new ovl_fh flag OVL_FH_FLAG_PATH_UPPER to indicate
    an upper file handle, but forgot to add the flag to the mask of
    valid flags, so index dir origin verification always discards
    existing origin and stores a new one.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 60d26605e039..032120a761c4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -47,7 +47,8 @@ enum ovl_flag {
 /* Is the real inode encoded in fid an upper inode? */
 #define OVL_FH_FLAG_PATH_UPPER	(1 << 2)
 
-#define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN)
+#define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN | \
+			 OVL_FH_FLAG_PATH_UPPER)
 
 #if defined(__LITTLE_ENDIAN)
 #define OVL_FH_FLAG_CPU_ENDIAN 0

commit caf70cb2ba5dff85ea90f494a30075af92df13b0
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 13:46:12 2017 +0300

    ovl: cleanup orphan index entries
    
    index entry should live only as long as there are upper or lower
    hardlinks.
    
    Cleanup orphan index entries on mount and when dropping the last
    overlay inode nlink.
    
    When about to cleanup or link up to orphan index and the index inode
    nlink > 1, admit that something went wrong and adjust overlay nlink
    to index inode nlink - 1 to prevent it from dropping below zero.
    This could happen when adding lower hardlinks underneath a mounted
    overlay and then trying to unlink them.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index c1321ab38224..60d26605e039 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -263,6 +263,9 @@ int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
 /* inode.c */
 int ovl_set_nlink_upper(struct dentry *dentry);
 int ovl_set_nlink_lower(struct dentry *dentry);
+unsigned int ovl_get_nlink(struct dentry *lowerdentry,
+			   struct dentry *upperdentry,
+			   unsigned int fallback);
 int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 int ovl_getattr(const struct path *path, struct kstat *stat,
 		u32 request_mask, unsigned int flags);

commit 5f8415d6b87ecb4ebf1bbd02c538694ebb7fb57c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jun 20 15:35:14 2017 +0300

    ovl: persistent overlay inode nlink for indexed inodes
    
    With inodes index enabled, an overlay inode nlink counts the union of upper
    and non-covered lower hardlinks. During the lifetime of a non-pure upper
    inode, the following nlink modifying operations can happen:
    
    1. Lower hardlink copy up
    2. Upper hardlink created, unlinked or renamed over
    3. Lower hardlink whiteout or renamed over
    
    For the first, copy up case, the union nlink does not change, whether the
    operation succeeds or fails, but the upper inode nlink may change.
    Therefore, before copy up, we store the union nlink value relative to the
    lower inode nlink in the index inode xattr trusted.overlay.nlink.
    
    For the second, upper hardlink case, the union nlink should be incremented
    or decremented IFF the operation succeeds, aligned with nlink change of the
    upper inode. Therefore, before link/unlink/rename, we store the union nlink
    value relative to the upper inode nlink in the index inode.
    
    For the last, lower cover up case, we simplify things by preceding the
    whiteout or cover up with copy up. This makes sure that there is an index
    upper inode where the nlink xattr can be stored before the copied up upper
    entry is unlink.
    
    Return the overlay inode nlinks for indexed upper inodes on stat(2).
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 751b36a5c22f..c1321ab38224 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -25,6 +25,7 @@ enum ovl_path_type {
 #define OVL_XATTR_REDIRECT OVL_XATTR_PREFIX "redirect"
 #define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
 #define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
+#define OVL_XATTR_NLINK OVL_XATTR_PREFIX "nlink"
 
 enum ovl_flag {
 	OVL_IMPURE,
@@ -229,6 +230,8 @@ void ovl_set_flag(unsigned long flag, struct inode *inode);
 bool ovl_test_flag(unsigned long flag, struct inode *inode);
 bool ovl_inuse_trylock(struct dentry *dentry);
 void ovl_inuse_unlock(struct dentry *dentry);
+int ovl_nlink_start(struct dentry *dentry, bool *locked);
+void ovl_nlink_end(struct dentry *dentry, bool locked);
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {
@@ -258,6 +261,8 @@ int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
 			 struct path *lowerstack, unsigned int numlower);
 
 /* inode.c */
+int ovl_set_nlink_upper(struct dentry *dentry);
+int ovl_set_nlink_lower(struct dentry *dentry);
 int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 int ovl_getattr(const struct path *path, struct kstat *stat,
 		u32 request_mask, unsigned int flags);

commit 55acc6618259c8ff0a400a131f0f4b613e96010a
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:18 2017 +0200

    ovl: add flag for upper in ovl_entry
    
    For rename, we need to ensure that an upper alias exists for hard links
    before attempting the operation.  Introduce a flag in ovl_entry to track
    the state of the upper alias.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f3e49cf34517..751b36a5c22f 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -206,6 +206,8 @@ void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry);
+bool ovl_dentry_has_upper_alias(struct dentry *dentry);
+void ovl_dentry_set_upper_alias(struct dentry *dentry);
 bool ovl_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);

commit 415543d5c64fe490b4b6a7e21c3ea2f1310c442f
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:42 2017 +0300

    ovl: cleanup bad and stale index entries on mount
    
    Bad index entries are entries whose name does not match the
    origin file handle stored in trusted.overlay.origin xattr.
    Bad index entries could be a result of a system power off in
    the middle of copy up.
    
    Stale index entries are entries whose origin file handle is
    stale. Stale index entries could be a result of copying layers
    or removing lower entries while the overlay is not mounted.
    The case of copying layers should be detected earlier by the
    verification of upper root dir origin and index dir origin.
    
    Both bad and stale index entries are detected and removed
    on mount.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 437a0301e1b6..f3e49cf34517 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -237,6 +237,8 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 /* namei.c */
 int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 		      struct dentry *origin, bool is_upper, bool set);
+int ovl_verify_index(struct dentry *index, struct path *lowerstack,
+		     unsigned int numlower);
 int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
@@ -250,6 +252,8 @@ void ovl_cache_free(struct list_head *list);
 int ovl_check_d_type_supported(struct path *realpath);
 void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
 			 struct dentry *dentry, int level);
+int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
+			 struct path *lowerstack, unsigned int numlower);
 
 /* inode.c */
 int ovl_setattr(struct dentry *dentry, struct iattr *attr);
@@ -289,7 +293,7 @@ struct cattr {
 int ovl_create_real(struct inode *dir, struct dentry *newdentry,
 		    struct cattr *attr,
 		    struct dentry *hardlink, bool debug);
-void ovl_cleanup(struct inode *dir, struct dentry *dentry);
+int ovl_cleanup(struct inode *dir, struct dentry *dentry);
 
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);

commit 359f392ca53e9122cafa5fc103545558b0b85d54
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:41 2017 +0300

    ovl: lookup index entry for copy up origin
    
    When inodes index feature is enabled, lookup in indexdir for the index
    entry of lower real inode or copy up origin inode. The index entry name
    is the hex representation of the lower inode file handle.
    
    If the index dentry in negative, then either no lower aliases have been
    copied up yet, or aliases have been copied up in older kernels and are
    not indexed.
    
    If the index dentry for a copy up origin inode is positive, but points
    to an inode different than the upper inode, then either the upper inode
    has been copied up and not indexed or it was indexed, but since then
    index dir was cleared. Either way, that index cannot be used to indentify
    the overlay inode.
    
    If a positive dentry that matches the upper inode was found, then it is
    safe to use the copy up origin st_ino for upper hardlinks, because all
    indexed upper hardlinks are represented by the same overlay inode as the
    copy up origin.
    
    Set the INDEX type flag on an indexed upper dentry. A non-upper dentry
    may also have a positive index from copy up of another lower hardlink.
    This situation will be handled by following patches.
    
    Index lookup is going to be used to prevent breaking hardlinks on copy up.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 58bbd135a7b3..437a0301e1b6 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -28,6 +28,7 @@ enum ovl_path_type {
 
 enum ovl_flag {
 	OVL_IMPURE,
+	OVL_INDEX,
 };
 
 /*
@@ -236,6 +237,7 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 /* namei.c */
 int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 		      struct dentry *origin, bool is_upper, bool set);
+int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
 bool ovl_lower_positive(struct dentry *dentry);

commit 54fb347e836faadaed2a5617fb4dd4a4597d0490
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:38 2017 +0300

    ovl: verify index dir matches upper dir
    
    An index dir contains persistent hardlinks to files in upper dir.
    Therefore, we must never mount an existing index dir with a differnt
    upper dir.
    
    Store the upper root dir file handle in index dir inode when index
    dir is created and verify the file handle before using an existing
    index dir on mount.
    
    Add an 'is_upper' flag to the overlay file handle encoding and set it
    when encoding the upper root file handle. This is not critical for index
    dir verification, but it is good practice towards a standard overlayfs
    file handle format for NFS export.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 38ac84cba6ea..58bbd135a7b3 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -42,6 +42,8 @@ enum ovl_flag {
 /* CPU byte order required for fid decoding:  */
 #define OVL_FH_FLAG_BIG_ENDIAN	(1 << 0)
 #define OVL_FH_FLAG_ANY_ENDIAN	(1 << 1)
+/* Is the real inode encoded in fid an upper inode? */
+#define OVL_FH_FLAG_PATH_UPPER	(1 << 2)
 
 #define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN)
 
@@ -233,7 +235,7 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 
 /* namei.c */
 int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
-		      struct dentry *origin, bool set);
+		      struct dentry *origin, bool is_upper, bool set);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
 bool ovl_lower_positive(struct dentry *dentry);
@@ -292,4 +294,4 @@ int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
-struct ovl_fh *ovl_encode_fh(struct dentry *lower);
+struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper);

commit 8b88a2e6403638b56556ed5b1c60d9318eefea9c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:37 2017 +0300

    ovl: verify upper root dir matches lower root dir
    
    When inodes index feature is enabled, verify that the file handle stored
    in upper root dir matches the lower root dir or fail to mount.
    
    If upper root dir has no stored file handle, encode and store the lower
    root dir file handle in overlay.origin xattr.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 4e7a74e99d3c..38ac84cba6ea 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -232,6 +232,8 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 
 
 /* namei.c */
+int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
+		      struct dentry *origin, bool set);
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
 bool ovl_lower_positive(struct dentry *dentry);
@@ -290,3 +292,4 @@ int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
+struct ovl_fh *ovl_encode_fh(struct dentry *lower);

commit 02bcd1577400b0b2eab806ccb9f72d6b5ec7bcca
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:36 2017 +0300

    ovl: introduce the inodes index dir feature
    
    Create the index dir on mount. The index dir will contain hardlinks to
    upper inodes, named after the hex representation of their origin lower
    inodes.
    
    The index dir is going to be used to prevent breaking lower hardlinks
    on copy up and to implement overlayfs NFS export.
    
    Because the feature is not fully backward compat, enabling the feature
    is opt-in by config/module/mount option.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 5e958427463d..4e7a74e99d3c 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -183,6 +183,8 @@ void ovl_drop_write(struct dentry *dentry);
 struct dentry *ovl_workdir(struct dentry *dentry);
 const struct cred *ovl_override_creds(struct super_block *sb);
 struct super_block *ovl_same_sb(struct super_block *sb);
+bool ovl_can_decode_fh(struct super_block *sb);
+struct dentry *ovl_indexdir(struct super_block *sb);
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 bool ovl_dentry_remote(struct dentry *dentry);
 bool ovl_dentry_weird(struct dentry *dentry);

commit ad0af7104dadccd55cd2b390271677fac142650f
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:32 2017 +0300

    vfs: introduce inode 'inuse' lock
    
    Added an i_state flag I_INUSE and helpers to set/clear/test the bit.
    
    The 'inuse' lock is an 'advisory' inode lock, that can be used to extend
    exclusive create protection beyond parent->i_mutex lock among cooperating
    users.
    
    This is going to be used by overlayfs to get exclusive ownership on upper
    and work dirs among overlayfs mounts.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index b1be3d39ac9d..5e958427463d 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -220,6 +220,8 @@ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
 int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
 void ovl_set_flag(unsigned long flag, struct inode *inode);
 bool ovl_test_flag(unsigned long flag, struct inode *inode);
+bool ovl_inuse_trylock(struct dentry *dentry);
+void ovl_inuse_unlock(struct dentry *dentry);
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {

commit 13c72075ac9f5a5cf3f61c85adaafffe48a6f797
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: move impure to ovl_inode
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 83607f883ace..b1be3d39ac9d 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -26,6 +26,10 @@ enum ovl_path_type {
 #define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
 #define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
 
+enum ovl_flag {
+	OVL_IMPURE,
+};
+
 /*
  * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
  * where:
@@ -195,7 +199,6 @@ struct inode *ovl_inode_real(struct inode *inode);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
-bool ovl_dentry_is_impure(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry);
 bool ovl_redirect_dir(struct super_block *sb);
@@ -215,6 +218,8 @@ int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
 		       const char *name, const void *value, size_t size,
 		       int xerr);
 int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
+void ovl_set_flag(unsigned long flag, struct inode *inode);
+bool ovl_test_flag(unsigned long flag, struct inode *inode);
 
 static inline bool ovl_is_impuredir(struct dentry *dentry)
 {

commit 09d8b586731bf589655c2ac971532c14cf272b63
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: move __upperdentry to ovl_inode
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 6e6600ae1d54..83607f883ace 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -189,7 +189,9 @@ enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
-struct inode *ovl_inode_real(struct inode *inode, bool *is_upper);
+struct inode *ovl_inode_upper(struct inode *inode);
+struct inode *ovl_inode_lower(struct inode *inode);
+struct inode *ovl_inode_real(struct inode *inode);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
@@ -199,9 +201,9 @@ void ovl_dentry_set_opaque(struct dentry *dentry);
 bool ovl_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
-void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
-void ovl_inode_init(struct inode *inode, struct dentry *dentry);
-void ovl_inode_update(struct inode *inode, struct inode *upperinode);
+void ovl_inode_init(struct inode *inode, struct dentry *upperdentry,
+		    struct dentry *lowerdentry);
+void ovl_inode_update(struct inode *inode, struct dentry *upperdentry);
 void ovl_dentry_version_inc(struct dentry *dentry);
 u64 ovl_dentry_version_get(struct dentry *dentry);
 bool ovl_is_whiteout(struct dentry *dentry);
@@ -250,7 +252,7 @@ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
-struct inode *ovl_get_inode(struct dentry *dentry);
+struct inode *ovl_get_inode(struct dentry *dentry, struct dentry *upperdentry);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
 	to->i_uid = from->i_uid;

commit 25b7713afe50963e70f98c1c964f60baf1e7e373
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: use i_private only as a key
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 3af33d3166e2..6e6600ae1d54 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -60,8 +60,6 @@ struct ovl_fh {
 	u8 fid[0];	/* file identifier */
 } __packed;
 
-#define OVL_ISUPPER_MASK 1UL
-
 static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int err = vfs_rmdir(dir, dentry);
@@ -175,16 +173,6 @@ static inline struct dentry *ovl_do_tmpfile(struct dentry *dentry, umode_t mode)
 	return ret;
 }
 
-static inline struct inode *ovl_inode_real(struct inode *inode, bool *is_upper)
-{
-	unsigned long x = (unsigned long) READ_ONCE(inode->i_private);
-
-	if (is_upper)
-		*is_upper = x & OVL_ISUPPER_MASK;
-
-	return (struct inode *) (x & ~OVL_ISUPPER_MASK);
-}
-
 /* util.c */
 int ovl_want_write(struct dentry *dentry);
 void ovl_drop_write(struct dentry *dentry);
@@ -201,6 +189,7 @@ enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
+struct inode *ovl_inode_real(struct inode *inode, bool *is_upper);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 bool ovl_dentry_is_opaque(struct dentry *dentry);

commit e6d2ebddbc5205635a021a910f2f0e93bc2aa534
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: simplify getting inode
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 10863b4105fa..3af33d3166e2 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -211,8 +211,7 @@ bool ovl_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
 void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
-void ovl_inode_init(struct inode *inode, struct inode *realinode,
-		    bool is_upper);
+void ovl_inode_init(struct inode *inode, struct dentry *dentry);
 void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 void ovl_dentry_version_inc(struct dentry *dentry);
 u64 ovl_dentry_version_get(struct dentry *dentry);
@@ -262,7 +261,7 @@ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
-struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode);
+struct inode *ovl_get_inode(struct dentry *dentry);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
 	to->i_uid = from->i_uid;

commit 01633fd254182eaa9372efa5c0688bf286e60d6b
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 17 09:32:50 2017 +0200

    overlayfs: use uuid_t instead of uuid_be
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 0623cebeefff..10863b4105fa 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -56,7 +56,7 @@ struct ovl_fh {
 	u8 len;		/* size of this header + size of fid */
 	u8 flags;	/* OVL_FH_FLAG_* */
 	u8 type;	/* fid_type of fid */
-	uuid_be uuid;	/* uuid of filesystem */
+	uuid_t uuid;	/* uuid of filesystem */
 	u8 fid[0];	/* file identifier */
 } __packed;
 

commit f3a1568582cc207663a4d5e37da790334372855b
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed May 24 15:29:33 2017 +0300

    ovl: mark upper merge dir with type origin entries "impure"
    
    An upper dir is marked "impure" to let ovl_iterate() know that this
    directory may contain non pure upper entries whose d_ino may need to be
    read from the origin inode.
    
    We already mark a non-merge dir "impure" when moving a non-pure child
    entry inside it, to let ovl_iterate() know not to iterate the non-merge
    dir directly.
    
    Mark also a merge dir "impure" when moving a non-pure child entry inside
    it and when copying up a child entry inside it.
    
    This can be used to optimize ovl_iterate() to perform a "pure merge" of
    upper and lower directories, merging the content of the directories,
    without having to read d_ino from origin inodes.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index a9fb958fd5d4..0623cebeefff 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -207,7 +207,6 @@ bool ovl_dentry_is_opaque(struct dentry *dentry);
 bool ovl_dentry_is_impure(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry);
-void ovl_dentry_set_impure(struct dentry *dentry);
 bool ovl_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
@@ -221,6 +220,17 @@ bool ovl_is_whiteout(struct dentry *dentry);
 struct file *ovl_path_open(struct path *path, int flags);
 int ovl_copy_up_start(struct dentry *dentry);
 void ovl_copy_up_end(struct dentry *dentry);
+bool ovl_check_dir_xattr(struct dentry *dentry, const char *name);
+int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
+		       const char *name, const void *value, size_t size,
+		       int xerr);
+int ovl_set_impure(struct dentry *dentry, struct dentry *upperdentry);
+
+static inline bool ovl_is_impuredir(struct dentry *dentry)
+{
+	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
+}
+
 
 /* namei.c */
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
@@ -281,6 +291,3 @@ int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
-int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
-		       const char *name, const void *value, size_t size,
-		       int xerr);

commit ee1d6d37b6b884383b501089be93ce94f2153028
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu May 11 16:42:26 2017 +0300

    ovl: mark upper dir with type origin entries "impure"
    
    When moving a merge dir or non-dir with copy up origin into a non-merge
    upper dir (a.k.a pure upper dir), we are marking the target parent dir
    "impure". ovl_iterate() iterates pure upper dirs directly, because there is
    no need to filter out whiteouts and merge dir content with lower dir. But
    for the case of an "impure" upper dir, ovl_iterate() will not be able to
    iterate the real upper dir directly, because it will need to lookup the
    origin inode and use it to fill d_ino.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 7c56932bfc2f..a9fb958fd5d4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -24,6 +24,7 @@ enum ovl_path_type {
 #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"
 #define OVL_XATTR_REDIRECT OVL_XATTR_PREFIX "redirect"
 #define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
+#define OVL_XATTR_IMPURE OVL_XATTR_PREFIX "impure"
 
 /*
  * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
@@ -203,8 +204,10 @@ struct dentry *ovl_dentry_real(struct dentry *dentry);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
+bool ovl_dentry_is_impure(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry);
+void ovl_dentry_set_impure(struct dentry *dentry);
 bool ovl_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);

commit 3d27573ce32b47ba54e6680c77c26a700d67cc16
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri May 19 09:33:49 2017 +0200

    ovl: remove unused arg from ovl_lookup_temp()
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 505b18b56330..7c56932bfc2f 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -262,7 +262,7 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 
 /* dir.c */
 extern const struct inode_operations ovl_dir_inode_operations;
-struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);
+struct dentry *ovl_lookup_temp(struct dentry *workdir);
 struct cattr {
 	dev_t rdev;
 	umode_t mode;

commit 21a228781104ae6fed7e720137ab024575071feb
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed May 17 00:12:41 2017 +0300

    ovl: handle rename when upper doesn't support xattr
    
    On failure to set opaque/redirect xattr on rename, skip setting xattr and
    return -EXDEV.
    
    On failure to set opaque xattr when creating a new directory, -EIO is
    returned instead of -EOPNOTSUPP.
    
    Any failure to set those xattr will be recorded in super block and
    then setting any xattr on upper won't be attempted again.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index ce7c3aba61e4..505b18b56330 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -206,7 +206,6 @@ bool ovl_dentry_is_opaque(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry);
 bool ovl_redirect_dir(struct super_block *sb);
-void ovl_clear_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);
 void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
 void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);

commit 82b749b2c65e9d108c1c5598dc0a5f436b525f42
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed May 17 00:12:40 2017 +0300

    ovl: check on mount time if upper fs supports setting xattr
    
    xattr are needed by overlayfs for setting opaque dir, redirect dir
    and copy up origin.
    
    Check at mount time by trying to set the overlay.opaque xattr on the
    workdir and if that fails issue a warning message.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index caa36cb9c46d..ce7c3aba61e4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -279,3 +279,6 @@ int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);
+int ovl_check_setxattr(struct dentry *dentry, struct dentry *upperdentry,
+		       const char *name, const void *value, size_t size,
+		       int xerr);

commit 5b712091a3a3904b0ae8311e18e6b540a070d464
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri May 5 11:38:58 2017 +0200

    ovl: merge getattr for dir and nondir
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 98af19828695..caa36cb9c46d 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -236,6 +236,8 @@ void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
 
 /* inode.c */
 int ovl_setattr(struct dentry *dentry, struct iattr *attr);
+int ovl_getattr(const struct path *path, struct kstat *stat,
+		u32 request_mask, unsigned int flags);
 int ovl_permission(struct inode *inode, int mask);
 int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
 		  size_t size, int flags);

commit 595485033db2c24178257698254fd4182fdb4123
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sun Apr 23 23:12:34 2017 +0300

    ovl: set the ORIGIN type flag
    
    For directory entries, non zero oe->numlower implies OVL_TYPE_MERGE.
    Define a new type flag OVL_TYPE_ORIGIN to indicate that an entry holds a
    reference to its lower copy up origin.
    
    For directory entries ORIGIN := MERGE && UPPER. For non-dir entries ORIGIN
    means that a lower type dentry has been recently copied up or that we were
    able to find the copy up origin from overlay.origin xattr.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 77405e27cd64..98af19828695 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -13,10 +13,12 @@
 enum ovl_path_type {
 	__OVL_PATH_UPPER	= (1 << 0),
 	__OVL_PATH_MERGE	= (1 << 1),
+	__OVL_PATH_ORIGIN	= (1 << 2),
 };
 
 #define OVL_TYPE_UPPER(type)	((type) & __OVL_PATH_UPPER)
 #define OVL_TYPE_MERGE(type)	((type) & __OVL_PATH_MERGE)
+#define OVL_TYPE_ORIGIN(type)	((type) & __OVL_PATH_ORIGIN)
 
 #define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
 #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"

commit 3a1e819b4e80216e00ef6a4dfe67fa142450c5e1
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Mar 30 15:22:16 2017 +0300

    ovl: store file handle of lower inode on copy up
    
    Sometimes it is interesting to know if an upper file is pure upper or a
    copy up target, and if it is a copy up target, it may be interesting to
    find the copy up origin.
    
    This will be used to preserve lower inode numbers across copy up.
    
    Store the lower inode file handle in upper inode extended attribute
    overlay.origin on copy up to use it later for these cases.  Store the lower
    filesystem uuid along side the file handle, so we can validate that we are
    looking for the origin file in the original fs.
    
    If lower fs does not support NFS export ops store a zero sized xattr so we
    can always use the overlay.origin xattr to distinguish between a copy up
    and a pure upper inode.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index c851158324e2..77405e27cd64 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -8,6 +8,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/uuid.h>
 
 enum ovl_path_type {
 	__OVL_PATH_UPPER	= (1 << 0),
@@ -20,6 +21,41 @@ enum ovl_path_type {
 #define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
 #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"
 #define OVL_XATTR_REDIRECT OVL_XATTR_PREFIX "redirect"
+#define OVL_XATTR_ORIGIN OVL_XATTR_PREFIX "origin"
+
+/*
+ * The tuple (fh,uuid) is a universal unique identifier for a copy up origin,
+ * where:
+ * origin.fh	- exported file handle of the lower file
+ * origin.uuid	- uuid of the lower filesystem
+ */
+#define OVL_FH_VERSION	0
+#define OVL_FH_MAGIC	0xfb
+
+/* CPU byte order required for fid decoding:  */
+#define OVL_FH_FLAG_BIG_ENDIAN	(1 << 0)
+#define OVL_FH_FLAG_ANY_ENDIAN	(1 << 1)
+
+#define OVL_FH_FLAG_ALL (OVL_FH_FLAG_BIG_ENDIAN | OVL_FH_FLAG_ANY_ENDIAN)
+
+#if defined(__LITTLE_ENDIAN)
+#define OVL_FH_FLAG_CPU_ENDIAN 0
+#elif defined(__BIG_ENDIAN)
+#define OVL_FH_FLAG_CPU_ENDIAN OVL_FH_FLAG_BIG_ENDIAN
+#else
+#error Endianness not defined
+#endif
+
+/* On-disk and in-memeory format for redirect by file handle */
+struct ovl_fh {
+	u8 version;	/* 0 */
+	u8 magic;	/* 0xfb */
+	u8 len;		/* size of this header + size of fid */
+	u8 flags;	/* OVL_FH_FLAG_* */
+	u8 type;	/* fid_type of fid */
+	uuid_be uuid;	/* uuid of filesystem */
+	u8 fid[0];	/* file identifier */
+} __packed;
 
 #define OVL_ISUPPER_MASK 1UL
 

commit 7bcd74b98d7bac3e5149894caaf72de6989af7f0
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Mar 22 08:42:21 2017 -0400

    ovl: check if all layers are on the same fs
    
    Some features can only work when all layers are on the same fs.  Test this
    condition during mount time, so features can check them later.
    
    Add helper ovl_same_sb() to return the common super block in case all
    layers are on the same fs.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 741dc0b6931f..c851158324e2 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -151,6 +151,7 @@ int ovl_want_write(struct dentry *dentry);
 void ovl_drop_write(struct dentry *dentry);
 struct dentry *ovl_workdir(struct dentry *dentry);
 const struct cred *ovl_override_creds(struct super_block *sb);
+struct super_block *ovl_same_sb(struct super_block *sb);
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 bool ovl_dentry_remote(struct dentry *dentry);
 bool ovl_dentry_weird(struct dentry *dentry);

commit 39d3d60a54df05a1a32fa71159d7a26a530dee6c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 17 06:34:56 2017 +0200

    ovl: introduce copy up waitqueue
    
    The overlay sb 'copyup_wq' and overlay inode 'copying' condition
    variable are about to replace the upper sb rename_lock, as finer
    grained synchronization objects for concurrent copy up.
    
    Suggested-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 3822a909ce1f..741dc0b6931f 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -178,6 +178,8 @@ void ovl_dentry_version_inc(struct dentry *dentry);
 u64 ovl_dentry_version_get(struct dentry *dentry);
 bool ovl_is_whiteout(struct dentry *dentry);
 struct file *ovl_path_open(struct path *path, int flags);
+int ovl_copy_up_start(struct dentry *dentry);
+void ovl_copy_up_end(struct dentry *dentry);
 
 /* namei.c */
 int ovl_path_next(int idx, struct dentry *dentry, struct path *path);

commit e7f52429b4a5b2e3224948d1737eb264c8f7e15f
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 17 06:34:53 2017 +0200

    ovl: check if upperdir fs supports O_TMPFILE
    
    This is needed for choosing between concurrent copyup
    using O_TMPFILE and legacy copyup using workdir+rename.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 8af450b0e57a..3822a909ce1f 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -127,6 +127,15 @@ static inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)
 	return err;
 }
 
+static inline struct dentry *ovl_do_tmpfile(struct dentry *dentry, umode_t mode)
+{
+	struct dentry *ret = vfs_tmpfile(dentry, mode, 0);
+	int err = IS_ERR(ret) ? PTR_ERR(ret) : 0;
+
+	pr_debug("tmpfile(%pd2, 0%o) = %i\n", dentry, mode, err);
+	return ret;
+}
+
 static inline struct inode *ovl_inode_real(struct inode *inode, bool *is_upper)
 {
 	unsigned long x = (unsigned long) READ_ONCE(inode->i_private);

commit 32a3d848eb91a298334991f1891e12e0362f91db
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Dec 4 17:33:17 2016 +0000

    ovl: clean up kstat usage
    
    FWIW, there's a bit of abuse of struct kstat in overlayfs object
    creation paths - for one thing, it ends up with a very small subset
    of struct kstat (mode + rdev), for another it also needs link in
    case of symlinks and ends up passing it separately.
    
    IMO it would be better to introduce a separate object for that.
    
    In principle, we might even lift that thing into general API and switch
     ->mkdir()/->mknod()/->symlink() to identical calling conventions.  Hell
    knows, perhaps ->create() as well...
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e07aa7b0ddb7..8af450b0e57a 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -212,8 +212,13 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 /* dir.c */
 extern const struct inode_operations ovl_dir_inode_operations;
 struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);
+struct cattr {
+	dev_t rdev;
+	umode_t mode;
+	const char *link;
+};
 int ovl_create_real(struct inode *dir, struct dentry *newdentry,
-		    struct kstat *stat, const char *link,
+		    struct cattr *attr,
 		    struct dentry *hardlink, bool debug);
 void ovl_cleanup(struct inode *dir, struct dentry *dentry);
 

commit 9aba652190f8cdced66967c97d6159de0cc8478e
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Nov 12 21:36:03 2016 +0200

    ovl: fold ovl_copy_up_truncate() into ovl_copy_up()
    
    This removes code duplication.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index a83de5d5b8a0..e07aa7b0ddb7 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -219,7 +219,6 @@ void ovl_cleanup(struct inode *dir, struct dentry *dentry);
 
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);
-int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
-		    struct path *lowerpath, struct kstat *stat);
+int ovl_copy_up_flags(struct dentry *dentry, int flags);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);

commit 5cf5b477f0ca33f56a30c7ec00e61a6204da2efb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:57 2016 +0100

    ovl: opaque cleanup
    
    oe->opaque is set for
    
     a) whiteouts
     b) directories having the "trusted.overlay.opaque" xattr
    
    Case b can be simplified, since setting the xattr always implies setting
    oe->opaque.  Also once set, the opaque flag is never cleared.
    
    Don't need to set opaque flag for non-directories.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index bdda37fa3f67..a83de5d5b8a0 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -156,7 +156,7 @@ struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
-void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
+void ovl_dentry_set_opaque(struct dentry *dentry);
 bool ovl_redirect_dir(struct super_block *sb);
 void ovl_clear_redirect_dir(struct super_block *sb);
 const char *ovl_dentry_get_redirect(struct dentry *dentry);

commit a6c6065511411c57167a6cdae0c33263fb662b51
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:56 2016 +0100

    ovl: redirect on rename-dir
    
    Current code returns EXDEV when a directory would need to be copied up to
    move.  We could copy up the directory tree in this case, but there's
    another, simpler solution: point to old lower directory from moved upper
    directory.
    
    This is achieved with a "trusted.overlay.redirect" xattr storing the path
    relative to the root of the overlay.  After such attribute has been set,
    the directory can be moved without further actions required.
    
    This is a backward incompatible feature, old kernels won't be able to
    correctly mount an overlay containing redirected directories.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e76d9d529e64..bdda37fa3f67 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -157,6 +157,10 @@ void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
+bool ovl_redirect_dir(struct super_block *sb);
+void ovl_clear_redirect_dir(struct super_block *sb);
+const char *ovl_dentry_get_redirect(struct dentry *dentry);
+void ovl_dentry_set_redirect(struct dentry *dentry, const char *redirect);
 void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 void ovl_inode_init(struct inode *inode, struct inode *realinode,
 		    bool is_upper);

commit 02b69b284cd7815239fabfe895bfef9a9eb5a3ce
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:56 2016 +0100

    ovl: lookup redirects
    
    If a directory has the "trusted.overlay.redirect" xattr, it means that the
    value of the xattr should be used to find the underlying directory on the
    next lower layer.
    
    The redirect may be relative or absolute.  Absolute redirects begin with a
    slash.
    
    A relative redirect means: instead of the current dentry's name use the
    value of the redirect to find the directory in the next lower
    layer. Relative redirects must not contain a slash.
    
    An absolute redirect means: look up the directory relative to the root of
    the overlay using the value of the redirect in the next lower layer.
    
    Redirects work on lower layers as well.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f6e4d3539a25..e76d9d529e64 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -19,6 +19,7 @@ enum ovl_path_type {
 
 #define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
 #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"
+#define OVL_XATTR_REDIRECT OVL_XATTR_PREFIX "redirect"
 
 #define OVL_ISUPPER_MASK 1UL
 

commit bbb1e54dd53cf83863e856dd5518ce5e58791115
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:56 2016 +0100

    ovl: split super.c
    
    fs/overlayfs/super.c is the biggest of the overlayfs source files and it
    contains various utility functions as well as the rather complicated lookup
    code.  Split these parts out to separate files.
    
    Before:
    
     1446 fs/overlayfs/super.c
    
    After:
    
      919 fs/overlayfs/super.c
      267 fs/overlayfs/namei.c
      235 fs/overlayfs/util.c
       51 fs/overlayfs/ovl_entry.h
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index db28512165c5..f6e4d3539a25 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -9,8 +9,6 @@
 
 #include <linux/kernel.h>
 
-struct ovl_entry;
-
 enum ovl_path_type {
 	__OVL_PATH_UPPER	= (1 << 0),
 	__OVL_PATH_MERGE	= (1 << 1),
@@ -138,37 +136,39 @@ static inline struct inode *ovl_inode_real(struct inode *inode, bool *is_upper)
 	return (struct inode *) (x & ~OVL_ISUPPER_MASK);
 }
 
+/* util.c */
+int ovl_want_write(struct dentry *dentry);
+void ovl_drop_write(struct dentry *dentry);
+struct dentry *ovl_workdir(struct dentry *dentry);
+const struct cred *ovl_override_creds(struct super_block *sb);
+struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
+bool ovl_dentry_remote(struct dentry *dentry);
+bool ovl_dentry_weird(struct dentry *dentry);
 enum ovl_path_type ovl_path_type(struct dentry *dentry);
-u64 ovl_dentry_version_get(struct dentry *dentry);
-void ovl_dentry_version_inc(struct dentry *dentry);
 void ovl_path_upper(struct dentry *dentry, struct path *path);
 void ovl_path_lower(struct dentry *dentry, struct path *path);
 enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
-int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
-struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
-				    bool is_upper);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
-struct dentry *ovl_workdir(struct dentry *dentry);
-int ovl_want_write(struct dentry *dentry);
-void ovl_drop_write(struct dentry *dentry);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
-bool ovl_lower_positive(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
-bool ovl_is_whiteout(struct dentry *dentry);
-const struct cred *ovl_override_creds(struct super_block *sb);
 void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
+void ovl_inode_init(struct inode *inode, struct inode *realinode,
+		    bool is_upper);
 void ovl_inode_update(struct inode *inode, struct inode *upperinode);
-struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
-			  unsigned int flags);
+void ovl_dentry_version_inc(struct dentry *dentry);
+u64 ovl_dentry_version_get(struct dentry *dentry);
+bool ovl_is_whiteout(struct dentry *dentry);
 struct file *ovl_path_open(struct path *path, int flags);
 
-struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
-				struct kstat *stat, const char *link);
+/* namei.c */
+int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
+struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
+bool ovl_lower_positive(struct dentry *dentry);
 
 /* readdir.c */
 extern const struct file_operations ovl_dir_operations;

commit 370e55ace59c2d3ed8f0ca933155030b9652e04f
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:55 2016 +0100

    ovl: rename: simplify handling of lower/merged directory
    
    d_is_dir() is safe to call on a negative dentry.  Use this fact to simplify
    handling of the lower or merged directories.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f183d1db78bd..db28512165c5 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -18,9 +18,6 @@ enum ovl_path_type {
 
 #define OVL_TYPE_UPPER(type)	((type) & __OVL_PATH_UPPER)
 #define OVL_TYPE_MERGE(type)	((type) & __OVL_PATH_MERGE)
-#define OVL_TYPE_MERGE_OR_LOWER(type) \
-	(OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type))
-
 
 #define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
 #define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"

commit 38e813db61c3951ef76d071ca7d2f46c2e939b80
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:55 2016 +0100

    ovl: get rid of PURE type
    
    The remainging uses of __OVL_PATH_PURE can be replaced by
    ovl_dentry_is_opaque().
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 2bd933aa622b..f183d1db78bd 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -12,14 +12,12 @@
 struct ovl_entry;
 
 enum ovl_path_type {
-	__OVL_PATH_PURE		= (1 << 0),
-	__OVL_PATH_UPPER	= (1 << 1),
-	__OVL_PATH_MERGE	= (1 << 2),
+	__OVL_PATH_UPPER	= (1 << 0),
+	__OVL_PATH_MERGE	= (1 << 1),
 };
 
 #define OVL_TYPE_UPPER(type)	((type) & __OVL_PATH_UPPER)
 #define OVL_TYPE_MERGE(type)	((type) & __OVL_PATH_MERGE)
-#define OVL_TYPE_PURE_UPPER(type) ((type) & __OVL_PATH_PURE)
 #define OVL_TYPE_MERGE_OR_LOWER(type) \
 	(OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type))
 

commit 2aff4534b6c48c465c2ba3bca310646652318e16
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:55 2016 +0100

    ovl: check lower existence when removing
    
    Currently ovl_lookup() checks existence of lower file even if there's a
    non-directory on upper (which is always opaque).  This is done so that
    remove can decide whether a whiteout is needed or not.
    
    It would be better to defer this check to unlink, since most of the time
    the gathered information about opaqueness will be unused.
    
    This adds a helper ovl_lower_positive() that checks if there's anything on
    the lower layer(s).
    
    The following patches also introduce changes to how the "opaque" attribute
    is updated on directories: this attribute is added when the directory is
    creted or moved over a whiteout or object covering something on the lower
    layer.  However following changes will allow the attribute to remain on the
    directory after being moved, even if the new location doesn't cover
    anything.  Because of this, we need to check lower layers even for opaque
    directories, so that whiteout is only created when necessary.
    
    This function will later be also used to decide about marking a directory
    opaque, so deal with negative dentries as well.  When dealing with
    negative, it's enough to check for being a whiteout
    
    If the dentry is positive but not upper then it also obviously needs
    whiteout/opaque.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 51e7d58276ce..2bd933aa622b 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -161,6 +161,7 @@ struct dentry *ovl_workdir(struct dentry *dentry);
 int ovl_want_write(struct dentry *dentry);
 void ovl_drop_write(struct dentry *dentry);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
+bool ovl_lower_positive(struct dentry *dentry);
 bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 bool ovl_is_whiteout(struct dentry *dentry);

commit c412ce498396097cb96b3e24e062752312a962c9
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:55 2016 +0100

    ovl: add ovl_dentry_is_whiteout()
    
    And use it instead of ovl_dentry_is_opaque() where appropriate.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 95d0d86c2d54..51e7d58276ce 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -161,6 +161,7 @@ struct dentry *ovl_workdir(struct dentry *dentry);
 int ovl_want_write(struct dentry *dentry);
 void ovl_drop_write(struct dentry *dentry);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
+bool ovl_dentry_is_whiteout(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 bool ovl_is_whiteout(struct dentry *dentry);
 const struct cred *ovl_override_creds(struct super_block *sb);

commit ca4c8a3a800039c2681d609c5b7491c1bd17c0a7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:55 2016 +0100

    ovl: treat special files like a regular fs
    
    No sense in opening special files on the underlying layers, they work just
    as well if opened on the overlay.
    
    Side effect is that it's no longer possible to connect one side of a pipe
    opened on overlayfs with the other side opened on the underlying layer.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e218e741cb99..95d0d86c2d54 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -195,7 +195,7 @@ int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 bool ovl_is_private_xattr(const char *name);
 
-struct inode *ovl_new_inode(struct super_block *sb, umode_t mode);
+struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {

commit 2773bf00aeb9bf39e022463272a61dd0ec9f55f4
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 27 11:03:58 2016 +0200

    fs: rename "rename2" i_op to "rename"
    
    Generated patch:
    
    sed -i "s/\.rename2\t/\.rename\t\t/" `git grep -wl rename2`
    sed -i "s/\brename2\b/rename/g" `git grep -wl rename2`
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 5813ccff8cd9..e218e741cb99 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -114,13 +114,13 @@ static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,
 {
 	int err;
 
-	pr_debug("rename2(%pd2, %pd2, 0x%x)\n",
+	pr_debug("rename(%pd2, %pd2, 0x%x)\n",
 		 olddentry, newdentry, flags);
 
 	err = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);
 
 	if (err) {
-		pr_debug("...rename2(%pd2, %pd2, ...) = %i\n",
+		pr_debug("...rename(%pd2, %pd2, ...) = %i\n",
 			 olddentry, newdentry, err);
 	}
 	return err;

commit 0eb45fc3bb7a2cf9c9c93d9e95986a841e5f4625
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon Aug 22 17:52:55 2016 +0200

    ovl: Switch to generic_getxattr
    
    Now that overlayfs has xattr handlers for iop->{set,remove}xattr, use
    those same handlers for iop->getxattr as well.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 5769aaf151a3..5813ccff8cd9 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -187,8 +187,8 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 int ovl_permission(struct inode *inode, int mask);
 int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
 		  size_t size, int flags);
-ssize_t ovl_getxattr(struct dentry *dentry, struct inode *inode,
-		     const char *name, void *value, size_t size);
+int ovl_xattr_get(struct dentry *dentry, const char *name,
+		  void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 struct posix_acl *ovl_get_acl(struct inode *inode, int type);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);

commit 0e585ccc13b3edbb187fb4f1b7cc9397f17d64a9
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon Aug 22 17:22:11 2016 +0200

    ovl: Switch to generic_removexattr
    
    Commit d837a49bd57f ("ovl: fix POSIX ACL setting") switches from
    iop->setxattr from ovl_setxattr to generic_setxattr, so switch from
    ovl_removexattr to generic_removexattr as well.  As far as permission
    checking goes, the same rules should apply in either case.
    
    While doing that, rename ovl_setxattr to ovl_xattr_set to indicate that
    this is not an iop->setxattr implementation and remove the unused inode
    argument.
    
    Move ovl_other_xattr_set above ovl_own_xattr_set so that they match the
    order of handlers in ovl_xattr_handlers.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Fixes: d837a49bd57f ("ovl: fix POSIX ACL setting")
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index f50c390683a3..5769aaf151a3 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -185,13 +185,11 @@ void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
 /* inode.c */
 int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 int ovl_permission(struct inode *inode, int mask);
-int ovl_setxattr(struct dentry *dentry, struct inode *inode,
-		 const char *name, const void *value,
-		 size_t size, int flags);
+int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
+		  size_t size, int flags);
 ssize_t ovl_getxattr(struct dentry *dentry, struct inode *inode,
 		     const char *name, void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
-int ovl_removexattr(struct dentry *dentry, const char *name);
 struct posix_acl *ovl_get_acl(struct inode *inode, int type);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);

commit fe2b75952347762a21f67d9df1199137ae5988b2
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Mon Aug 22 17:59:22 2016 +0200

    ovl: Fix OVL_XATTR_PREFIX
    
    Make sure ovl_own_xattr_handler only matches attribute names starting
    with "overlay.", not "overlayXXX".
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Fixes: d837a49bd57f ("ovl: fix POSIX ACL setting")
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 9a95e2c5653e..f50c390683a3 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -24,8 +24,8 @@ enum ovl_path_type {
 	(OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type))
 
 
-#define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay"
-#define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX ".opaque"
+#define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay."
+#define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX "opaque"
 
 #define OVL_ISUPPER_MASK 1UL
 

commit eea2fb4851e9dcbab6b991aaf47e2e024f1f55a0
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Sep 1 11:11:59 2016 +0200

    ovl: proper cleanup of workdir
    
    When mounting overlayfs it needs a clean "work" directory under the
    supplied workdir.
    
    Previously the mount code removed this directory if it already existed and
    created a new one.  If the removal failed (e.g. directory was not empty)
    then it fell back to a read-only mount not using the workdir.
    
    While this has never been reported, it is possible to get a non-empty
    "work" dir from a previous mount of overlayfs in case of crash in the
    middle of an operation using the work directory.
    
    In this case the left over state should be discarded and the overlay
    filesystem will be consistent, guaranteed by the atomicity of operations on
    moving to/from the workdir to the upper layer.
    
    This patch implements cleaning out any files left in workdir.  It is
    implemented using real recursion for simplicity, but the depth is limited
    to 2, because the worst case is that of a directory containing whiteouts
    under "work".
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 34839bd2b6b8..9a95e2c5653e 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -179,6 +179,8 @@ int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
 void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list);
 void ovl_cache_free(struct list_head *list);
 int ovl_check_d_type_supported(struct path *realpath);
+void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
+			 struct dentry *dentry, int level);
 
 /* inode.c */
 int ovl_setattr(struct dentry *dentry, struct iattr *attr);

commit 0956254a2d5b9e2141385514553aeef694dfe3b5
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Aug 8 15:08:49 2016 +0200

    ovl: don't copy up opaqueness
    
    When a copy up of a directory occurs which has the opaque xattr set, the
    xattr remains in the upper directory. The immediate behavior with overlayfs
    is that the upper directory is not treated as opaque, however after a
    remount the opaque flag is used and upper directory is treated as opaque.
    This causes files created in the lower layer to be hidden when using
    multiple lower directories.
    
    Fix by not copying up the opaque flag.
    
    To reproduce:
    
     ----8<---------8<---------8<---------8<---------8<---------8<----
    mkdir -p l/d/s u v w mnt
    mount -t overlay overlay -olowerdir=l,upperdir=u,workdir=w mnt
    rm -rf mnt/d/
    mkdir -p mnt/d/n
    umount mnt
    mount -t overlay overlay -olowerdir=u:l,upperdir=v,workdir=w mnt
    touch mnt/d/foo
    umount mnt
    mount -t overlay overlay -olowerdir=u:l,upperdir=v,workdir=w mnt
    ls mnt/d
     ----8<---------8<---------8<---------8<---------8<---------8<----
    
    output should be:  "foo  n"
    
    Reported-by: Derek McGowan <dmcg@drizz.net>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=151291
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e4f5c9536bfe..34839bd2b6b8 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -193,6 +193,7 @@ int ovl_removexattr(struct dentry *dentry, const char *name);
 struct posix_acl *ovl_get_acl(struct inode *inode, int type);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
+bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode);
 struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode);

commit d837a49bd57f1ec2f6411efa829fecc34002b110
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jul 29 12:05:24 2016 +0200

    ovl: fix POSIX ACL setting
    
    Setting POSIX ACL needs special handling:
    
    1) Some permission checks are done by ->setxattr() which now uses mounter's
    creds ("ovl: do operations on underlying file system in mounter's
    context").  These permission checks need to be done with current cred as
    well.
    
    2) Setting ACL can fail for various reasons.  We do not need to copy up in
    these cases.
    
    In the mean time switch to using generic_setxattr.
    
    [Arnd Bergmann] Fix link error without POSIX ACL. posix_acl_from_xattr()
    doesn't have a 'static inline' implementation when CONFIG_FS_POSIX_ACL is
    disabled, and I could not come up with an obvious way to do it.
    
    This instead avoids the link error by defining two sets of ACL operations
    and letting the compiler drop one of the two at compile time depending
    on CONFIG_FS_POSIX_ACL. This avoids all references to the ACL code,
    also leading to smaller code.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index abeef1e6db56..e4f5c9536bfe 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -23,9 +23,9 @@ enum ovl_path_type {
 #define OVL_TYPE_MERGE_OR_LOWER(type) \
 	(OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type))
 
-#define OVL_XATTR_PRE_NAME "trusted.overlay."
-#define OVL_XATTR_PRE_LEN  16
-#define OVL_XATTR_OPAQUE   OVL_XATTR_PRE_NAME"opaque"
+
+#define OVL_XATTR_PREFIX XATTR_TRUSTED_PREFIX "overlay"
+#define OVL_XATTR_OPAQUE OVL_XATTR_PREFIX ".opaque"
 
 #define OVL_ISUPPER_MASK 1UL
 

commit 51f7e52dc943468c6929fa0a82d4afac3c8e9636
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jul 29 12:05:24 2016 +0200

    ovl: share inode for hard link
    
    Inode attributes are copied up to overlay inode (uid, gid, mode, atime,
    mtime, ctime) so generic code using these fields works correcty.  If a hard
    link is created in overlayfs separate inodes are allocated for each link.
    If chmod/chown/etc. is performed on one of the links then the inode
    belonging to the other ones won't be updated.
    
    This patch attempts to fix this by sharing inodes for hard links.
    
    Use inode hash (with real inode pointer as a key) to make sure overlay
    inodes are shared for hard links on upper.  Hard links on lower are still
    split (which is not user observable until the copy-up happens, see
    Documentation/filesystems/overlayfs.txt under "Non-standard behavior").
    
    The inode is only inserted in the hash if it is non-directoy and upper.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 6410209ea616..abeef1e6db56 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -195,6 +195,7 @@ int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode);
+struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
 	to->i_uid = from->i_uid;

commit 39b681f8026c170a73972517269efc830db0d7ce
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jul 29 12:05:24 2016 +0200

    ovl: store real inode pointer in ->i_private
    
    To get from overlay inode to real inode we currently use 'struct
    ovl_entry', which has lifetime connected to overlay dentry.  This is okay,
    since each overlay dentry had a new overlay inode allocated.
    
    Following patch will break that assumption, so need to leave out ovl_entry.
    This patch stores the real inode directly in i_private, with the lowest bit
    used to indicate whether the inode is upper or lower.
    
    Lifetime rules remain, using ovl_inode_real() must only be done while
    caller holds ref on overlay dentry (and hence on real dentry), or within
    RCU protected regions.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index fb73c09a84e7..6410209ea616 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -27,6 +27,8 @@ enum ovl_path_type {
 #define OVL_XATTR_PRE_LEN  16
 #define OVL_XATTR_OPAQUE   OVL_XATTR_PRE_NAME"opaque"
 
+#define OVL_ISUPPER_MASK 1UL
+
 static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int err = vfs_rmdir(dir, dentry);
@@ -131,6 +133,16 @@ static inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)
 	return err;
 }
 
+static inline struct inode *ovl_inode_real(struct inode *inode, bool *is_upper)
+{
+	unsigned long x = (unsigned long) READ_ONCE(inode->i_private);
+
+	if (is_upper)
+		*is_upper = x & OVL_ISUPPER_MASK;
+
+	return (struct inode *) (x & ~OVL_ISUPPER_MASK);
+}
+
 enum ovl_path_type ovl_path_type(struct dentry *dentry);
 u64 ovl_dentry_version_get(struct dentry *dentry);
 void ovl_dentry_version_inc(struct dentry *dentry);
@@ -141,8 +153,6 @@ int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
-struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);
-struct inode *ovl_inode_real(struct inode *inode);
 struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 				    bool is_upper);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
@@ -155,6 +165,7 @@ void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 bool ovl_is_whiteout(struct dentry *dentry);
 const struct cred *ovl_override_creds(struct super_block *sb);
 void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
+void ovl_inode_update(struct inode *inode, struct inode *upperinode);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 			  unsigned int flags);
 struct file *ovl_path_open(struct path *path, int flags);
@@ -183,8 +194,7 @@ struct posix_acl *ovl_get_acl(struct inode *inode, int type);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 
-struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
-			    struct ovl_entry *oe);
+struct inode *ovl_new_inode(struct super_block *sb, umode_t mode);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
 	to->i_uid = from->i_uid;

commit d719e8f268fa4f9944b24b60814da9017dfb7787
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jul 29 12:05:23 2016 +0200

    ovl: update atime on upper
    
    Fix atime update logic in overlayfs.
    
    This patch adds an i_op->update_time() handler to overlayfs inodes.  This
    forwards atime updates to the upper layer only.  No atime updates are done
    on lower layers.
    
    Remove implicit atime updates to underlying files and directories with
    O_NOATIME.  Remove explicit atime update in ovl_readlink().
    
    Clear atime related mnt flags from cloned upper mount.  This means atime
    updates are controlled purely by overlayfs mount options.
    
    Reported-by: Konstantin Khlebnikov <koct9i@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index e8d50da384d5..fb73c09a84e7 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -181,6 +181,7 @@ ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 int ovl_removexattr(struct dentry *dentry, const char *name);
 struct posix_acl *ovl_get_acl(struct inode *inode, int type);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
+int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
 			    struct ovl_entry *oe);
@@ -189,6 +190,9 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 	to->i_uid = from->i_uid;
 	to->i_gid = from->i_gid;
 	to->i_mode = from->i_mode;
+	to->i_atime = from->i_atime;
+	to->i_mtime = from->i_mtime;
+	to->i_ctime = from->i_ctime;
 }
 
 /* dir.c */

commit 9c630ebefeeee4363ffd29f2f9b18eddafc6479c
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jul 29 12:05:23 2016 +0200

    ovl: simplify permission checking
    
    The fact that we always do permission checking on the overlay inode and
    clear MAY_WRITE for checking access to the lower inode allows cruft to be
    removed from ovl_permission().
    
    1) "default_permissions" option effectively did generic_permission() on the
    overlay inode with i_mode, i_uid and i_gid updated from underlying
    filesystem.  This is what we do by default now.  It did the update using
    vfs_getattr() but that's only needed if the underlying filesystem can
    change (which is not allowed).  We may later introduce a "paranoia_mode"
    that verifies that mode/uid/gid are not changed.
    
    2) splitting out the IS_RDONLY() check from inode_permission() also becomes
    unnecessary once we remove the MAY_WRITE from the lower inode check.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 75128c70aa6a..e8d50da384d5 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -146,7 +146,6 @@ struct inode *ovl_inode_real(struct inode *inode);
 struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 				    bool is_upper);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
-bool ovl_is_default_permissions(struct inode *inode);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 struct dentry *ovl_workdir(struct dentry *dentry);
 int ovl_want_write(struct dentry *dentry);

commit 39a25b2b37629f65e5a1eba1b353d0b47687c2ca
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri Jul 1 16:34:26 2016 -0400

    ovl: define ->get_acl() for overlay inodes
    
    Now we are planning to do DAC permission checks on overlay inode
    itself. And to make it work, we will need to make sure we can get acls from
    underlying inode. So define ->get_acl() for overlay inodes and this in turn
    calls into underlying filesystem to get acls, if any.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 0d3f2ad45708..75128c70aa6a 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -142,6 +142,7 @@ struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
 struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);
+struct inode *ovl_inode_real(struct inode *inode);
 struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
 				    bool is_upper);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
@@ -179,6 +180,7 @@ ssize_t ovl_getxattr(struct dentry *dentry, struct inode *inode,
 		     const char *name, void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 int ovl_removexattr(struct dentry *dentry, const char *name);
+struct posix_acl *ovl_get_acl(struct inode *inode, int type);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,

commit 1b91dbdd2938a0102fea2d8853073159f2b08deb
Merge: 523d939ef98f 0cac643c102c
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 27 11:36:03 2016 +0200

    Merge branch 'd_real' into overlayfs-next

commit 07a2daab49c549a37b5b744cbebb6e3f445f12bc
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri Jul 1 16:34:25 2016 -0400

    ovl: Copy up underlying inode's ->i_mode to overlay inode
    
    Right now when a new overlay inode is created, we initialize overlay
    inode's ->i_mode from underlying inode ->i_mode but we retain only
    file type bits (S_IFMT) and discard permission bits.
    
    This patch changes it and retains permission bits too. This should allow
    overlay to do permission checks on overlay inode itself in task context.
    
    [SzM] It also fixes clearing suid/sgid bits on write.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reported-by: Eryu Guan <eguan@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Fixes: 4bacc9c9234c ("overlayfs: Make f_path always point to the overlay and f_inode to the underlay")
    Cc: <stable@vger.kernel.org>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 4bd9b5ba8f42..cfbca53590d0 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -187,6 +187,7 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
 	to->i_uid = from->i_uid;
 	to->i_gid = from->i_gid;
+	to->i_mode = from->i_mode;
 }
 
 /* dir.c */

commit 2d902671ce1cd98cdc88d78c481889a1b2996101
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jun 30 08:53:27 2016 +0200

    vfs: merge .d_select_inode() into .d_real()
    
    The two methods essentially do the same: find the real dentry/inode
    belonging to an overlay dentry.  The difference is in the usage:
    
    vfs_open() uses ->d_select_inode() and expects the function to perform
    copy-up if necessary based on the open flags argument.
    
    file_dentry() uses ->d_real() passing in the overlay dentry as well as the
    underlying inode.
    
    vfs_rename() uses ->d_select_inode() but passes zero flags.  ->d_real()
    with a zero inode would have worked just as well here.
    
    This patch merges the functionality of ->d_select_inode() into ->d_real()
    by adding an 'open_flags' argument to the latter.
    
    [Al Viro] Make the signature of d_real() match that of ->d_real() again.
    And constify the inode argument, while we are at it.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 4bd9b5ba8f42..6b9fd25c5ad4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -179,7 +179,7 @@ ssize_t ovl_getxattr(struct dentry *dentry, struct inode *inode,
 		     const char *name, void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 int ovl_removexattr(struct dentry *dentry, const char *name);
-struct inode *ovl_d_select_inode(struct dentry *dentry, unsigned file_flags);
+int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
 			    struct ovl_entry *oe);

commit d102a56edba7a3f236454716fa09920e66772044
Merge: 0121a32201dc 3767e255b390
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 27 17:14:05 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs fixes from Al Viro:
     "Followups to the parallel lookup work:
    
       - update docs
    
       - restore killability of the places that used to take ->i_mutex
         killably now that we have down_write_killable() merged
    
       - Additionally, it turns out that I missed a prerequisite for
         security_d_instantiate() stuff - ->getxattr() wasn't the only thing
         that could be called before dentry is attached to inode; with smack
         we needed the same treatment applied to ->setxattr() as well"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      switch ->setxattr() to passing dentry and inode separately
      switch xattr_handler->set() to passing dentry and inode separately
      restore killability of old mutex_lock_killable(&inode->i_mutex) users
      add down_write_killable_nested()
      update D/f/directory-locking

commit 3767e255b390d72f9a33c08d9e86c5f21f25860f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 27 11:06:05 2016 -0400

    switch ->setxattr() to passing dentry and inode separately
    
    smack ->d_instantiate() uses ->setxattr(), so to be able to call it before
    we'd hashed the new dentry and attached it to inode, we need ->setxattr()
    instances getting the inode as an explicit argument rather than obtaining
    it from dentry.
    
    Similar change for ->getxattr() had been done in commit ce23e64.  Unlike
    ->getxattr() (which is used by both selinux and smack instances of
    ->d_instantiate()) ->setxattr() is used only by smack one and unfortunately
    it got missed back then.
    
    Reported-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Tested-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 99ec4b035237..d79577eb3937 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -171,8 +171,9 @@ int ovl_check_d_type_supported(struct path *realpath);
 /* inode.c */
 int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 int ovl_permission(struct inode *inode, int mask);
-int ovl_setxattr(struct dentry *dentry, const char *name,
-		 const void *value, size_t size, int flags);
+int ovl_setxattr(struct dentry *dentry, struct inode *inode,
+		 const char *name, const void *value,
+		 size_t size, int flags);
 ssize_t ovl_getxattr(struct dentry *dentry, struct inode *inode,
 		     const char *name, void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);

commit 0121a32201dcc72933fb6019c41661e2f8a02fc5
Merge: 559b6d90a0be 21765194cecf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 27 16:44:39 2016 -0700

    Merge branch 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs update from Miklos Szeredi:
     "The meat of this is a change to use the mounter's credentials for
      operations that require elevated privileges (such as whiteout
      creation).  This fixes behavior under user namespaces as well as being
      a nice cleanup"
    
    * 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      ovl: Do d_type check only if work dir creation was successful
      ovl: update documentation
      ovl: override creds with the ones from the superblock mounter

commit 3fe6e52f062643676eb4518d68cee3bc1272091b
Author: Antonio Murdaca <amurdaca@redhat.com>
Date:   Thu Apr 7 15:48:25 2016 +0200

    ovl: override creds with the ones from the superblock mounter
    
    In user namespace the whiteout creation fails with -EPERM because the
    current process isn't capable(CAP_SYS_ADMIN) when setting xattr.
    
    A simple reproducer:
    
    $ mkdir upper lower work merged lower/dir
    $ sudo mount -t overlay overlay -olowerdir=lower,upperdir=upper,workdir=work merged
    $ unshare -m -p -f -U -r bash
    
    Now as root in the user namespace:
    
    \# touch merged/dir/{1,2,3} # this will force a copy up of lower/dir
    \# rm -fR merged/*
    
    This ends up failing with -EPERM after the files in dir has been
    correctly deleted:
    
    unlinkat(4, "2", 0)                     = 0
    unlinkat(4, "1", 0)                     = 0
    unlinkat(4, "3", 0)                     = 0
    close(4)                                = 0
    unlinkat(AT_FDCWD, "merged/dir", AT_REMOVEDIR) = -1 EPERM (Operation not
    permitted)
    
    Interestingly, if you don't place files in merged/dir you can remove it,
    meaning if upper/dir does not exist, creating the char device file works
    properly in that same location.
    
    This patch uses ovl_sb_creator_cred() to get the cred struct from the
    superblock mounter and override the old cred with these new ones so that
    the whiteout creation is possible because overlay is wrong in assuming that
    the creds it will get with prepare_creds will be in the initial user
    namespace.  The old cap_raise game is removed in favor of just overriding
    the old cred struct.
    
    This patch also drops from ovl_copy_up_one() the following two lines:
    
    override_cred->fsuid = stat->uid;
    override_cred->fsgid = stat->gid;
    
    This is because the correct uid and gid are taken directly with the stat
    struct and correctly set with ovl_set_attr().
    
    Signed-off-by: Antonio Murdaca <runcom@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 6a7090f4a441..4cebeb24c08d 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -153,6 +153,7 @@ void ovl_drop_write(struct dentry *dentry);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 bool ovl_is_whiteout(struct dentry *dentry);
+const struct cred *ovl_override_creds(struct super_block *sb);
 void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 			  unsigned int flags);

commit ce23e640133484eebc20ca7b7668388213e11327
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 11 00:48:00 2016 -0400

    ->getxattr(): pass dentry and inode as separate arguments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 6a7090f4a441..99ec4b035237 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -173,8 +173,8 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr);
 int ovl_permission(struct inode *inode, int mask);
 int ovl_setxattr(struct dentry *dentry, const char *name,
 		 const void *value, size_t size, int flags);
-ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
-		     void *value, size_t size);
+ssize_t ovl_getxattr(struct dentry *dentry, struct inode *inode,
+		     const char *name, void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 int ovl_removexattr(struct dentry *dentry, const char *name);
 struct inode *ovl_d_select_inode(struct dentry *dentry, unsigned file_flags);

commit 45aebeaf4f67468f76bedf62923a576a519a9b68
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Mon Feb 22 09:28:34 2016 -0500

    ovl: Ensure upper filesystem supports d_type
    
    In some instances xfs has been created with ftype=0 and there if a file
    on lower fs is removed, overlay leaves a whiteout in upper fs but that
    whiteout does not get filtered out and is visible to overlayfs users.
    
    And reason it does not get filtered out because upper filesystem does
    not report file type of whiteout as DT_CHR during iterate_dir().
    
    So it seems to be a requirement that upper filesystem support d_type for
    overlayfs to work properly. Do this check during mount and fail if d_type
    is not supported.
    
    Suggested-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 99b4168c36ff..6a7090f4a441 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -166,6 +166,7 @@ extern const struct file_operations ovl_dir_operations;
 int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
 void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list);
 void ovl_cache_free(struct list_head *list);
+int ovl_check_d_type_supported(struct path *realpath);
 
 /* inode.c */
 int ovl_setattr(struct dentry *dentry, struct iattr *attr);

commit e9f57ebcba563e0cd532926cab83c92bb4d79360
Merge: 5c89e9ea7ef1 84889d493356
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 21 12:20:46 2016 -0800

    Merge branch 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "This contains several bug fixes and a new mount option
      'default_permissions' that allows read-only exported NFS
      filesystems to be used as lower layer"
    
    * 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      ovl: check dentry positiveness in ovl_cleanup_whiteouts()
      ovl: setattr: check permissions before copy-up
      ovl: root: copy attr
      ovl: move super block magic number to magic.h
      ovl: use a minimal buffer in ovl_copy_xattr
      ovl: allow zero size xattr
      ovl: default permissions

commit 0f7ff2dabbc95ed7a8019d142274f0c7e083577d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 6 12:31:07 2015 -0500

    ovl: get rid of the dead code left from broken (and disabled) optimizations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index ea5a40b06e3a..e17154aeaae4 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -194,7 +194,6 @@ void ovl_cleanup(struct inode *dir, struct dentry *dentry);
 /* copy_up.c */
 int ovl_copy_up(struct dentry *dentry);
 int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
-		    struct path *lowerpath, struct kstat *stat,
-		    struct iattr *attr);
+		    struct path *lowerpath, struct kstat *stat);
 int ovl_copy_xattr(struct dentry *old, struct dentry *new);
 int ovl_set_attr(struct dentry *upper, struct kstat *stat);

commit 8d3095f4ad47ac409440a0ba1c80e13519ff867d
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Oct 12 17:11:44 2015 +0200

    ovl: default permissions
    
    Add mount option "default_permissions" to alter the way permissions are
    calculated.
    
    Without this option and prior to this patch permissions were calculated by
    underlying lower or upper filesystem.
    
    With this option the permissions are calculated by overlayfs based on the
    file owner, group and mode bits.
    
    This has significance for example when a read-only exported NFS filesystem
    is used as a lower layer.  In this case the underlying NFS filesystem will
    reply with EROFS, in which case all we know is that the filesystem is
    read-only.  But that's not what we are interested in, we are interested in
    whether the access would be allowed if the filesystem wasn't read-only; the
    server doesn't tell us that, and would need updating at various levels,
    which doesn't seem practicable.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index ea5a40b06e3a..f3e6efefe40b 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -142,7 +142,10 @@ struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
 struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);
+struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
+				    bool is_upper);
 struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
+bool ovl_is_default_permissions(struct inode *inode);
 void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
 struct dentry *ovl_workdir(struct dentry *dentry);
 int ovl_want_write(struct dentry *dentry);

commit 4bacc9c9234c7c8eec44f5ed4e960d9f96fa0f01
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 18 14:32:31 2015 +0100

    overlayfs: Make f_path always point to the overlay and f_inode to the underlay
    
    Make file->f_path always point to the overlay dentry so that the path in
    /proc/pid/fd is correct and to ensure that label-based LSMs have access to the
    overlay as well as the underlay (path-based LSMs probably don't need it).
    
    Using my union testsuite to set things up, before the patch I see:
    
            [root@andromeda union-testsuite]# bash 5</mnt/a/foo107
            [root@andromeda union-testsuite]# ls -l /proc/$$/fd/
            ...
            lr-x------. 1 root root 64 Jun  5 14:38 5 -> /a/foo107
            [root@andromeda union-testsuite]# stat /mnt/a/foo107
            ...
            Device: 23h/35d Inode: 13381       Links: 1
            ...
            [root@andromeda union-testsuite]# stat -L /proc/$$/fd/5
            ...
            Device: 23h/35d Inode: 13381       Links: 1
            ...
    
    After the patch:
    
            [root@andromeda union-testsuite]# bash 5</mnt/a/foo107
            [root@andromeda union-testsuite]# ls -l /proc/$$/fd/
            ...
            lr-x------. 1 root root 64 Jun  5 14:22 5 -> /mnt/a/foo107
            [root@andromeda union-testsuite]# stat /mnt/a/foo107
            ...
            Device: 23h/35d Inode: 40346       Links: 1
            ...
            [root@andromeda union-testsuite]# stat -L /proc/$$/fd/5
            ...
            Device: 23h/35d Inode: 40346       Links: 1
            ...
    
    Note the change in where /proc/$$/fd/5 points to in the ls command.  It was
    pointing to /a/foo107 (which doesn't exist) and now points to /mnt/a/foo107
    (which is correct).
    
    The inode accessed, however, is the lower layer.  The union layer is on device
    25h/37d and the upper layer on 24h/36d.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 17ac5afc9ffb..ea5a40b06e3a 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -173,6 +173,7 @@ ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
 		     void *value, size_t size);
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 int ovl_removexattr(struct dentry *dentry, const char *name);
+struct inode *ovl_d_select_inode(struct dentry *dentry, unsigned file_flags);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
 			    struct ovl_entry *oe);

commit cead89bb08c0f64e23886f1c18df9bb98e97c55c
Author: hujianyang <hujianyang@huawei.com>
Date:   Mon Nov 24 18:25:21 2014 +0800

    ovl: Use macros to present ovl_xattr
    
    This patch adds two macros:
    
    OVL_XATTR_PRE_NAME and OVL_XATTR_PRE_LEN
    
    to present ovl_xattr name prefix and its length. Also, a
    new macro OVL_XATTR_OPAQUE is introduced to replace old
    *ovl_opaque_xattr*.
    
    Fix the length of "trusted.overlay." to *16*.
    
    Signed-off-by: hujianyang <hujianyang@huawei.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d176b679f526..17ac5afc9ffb 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -23,7 +23,9 @@ enum ovl_path_type {
 #define OVL_TYPE_MERGE_OR_LOWER(type) \
 	(OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type))
 
-extern const char *ovl_opaque_xattr;
+#define OVL_XATTR_PRE_NAME "trusted.overlay."
+#define OVL_XATTR_PRE_LEN  16
+#define OVL_XATTR_OPAQUE   OVL_XATTR_PRE_NAME"opaque"
 
 static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
 {

commit 5ef88da56a77bfb3b9631f5e5775f3bff86b6219
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Sat Dec 13 00:59:43 2014 +0100

    ovl: helper to iterate layers
    
    Add helper to iterate through all the layers, starting from the upper layer
    (if exists) and continuing down through the lower layers.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d39eaa8f5e47..d176b679f526 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -135,6 +135,7 @@ void ovl_dentry_version_inc(struct dentry *dentry);
 void ovl_path_upper(struct dentry *dentry, struct path *path);
 void ovl_path_lower(struct dentry *dentry, struct path *path);
 enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
+int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 struct dentry *ovl_dentry_upper(struct dentry *dentry);
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);

commit 1afaba1ecb5299cdd0f69b5bad98b0185fe71e79
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Sat Dec 13 00:59:42 2014 +0100

    ovl: make path-type a bitmap
    
    OVL_PATH_PURE_UPPER -> __OVL_PATH_UPPER | __OVL_PATH_PURE
    OVL_PATH_UPPER      -> __OVL_PATH_UPPER
    OVL_PATH_MERGE      -> __OVL_PATH_UPPER | __OVL_PATH_MERGE
    OVL_PATH_LOWER      -> 0
    
    Multiple R/O layers will allow __OVL_PATH_MERGE without __OVL_PATH_UPPER.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 814bed33dd07..d39eaa8f5e47 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -12,12 +12,17 @@
 struct ovl_entry;
 
 enum ovl_path_type {
-	OVL_PATH_PURE_UPPER,
-	OVL_PATH_UPPER,
-	OVL_PATH_MERGE,
-	OVL_PATH_LOWER,
+	__OVL_PATH_PURE		= (1 << 0),
+	__OVL_PATH_UPPER	= (1 << 1),
+	__OVL_PATH_MERGE	= (1 << 2),
 };
 
+#define OVL_TYPE_UPPER(type)	((type) & __OVL_PATH_UPPER)
+#define OVL_TYPE_MERGE(type)	((type) & __OVL_PATH_MERGE)
+#define OVL_TYPE_PURE_UPPER(type) ((type) & __OVL_PATH_PURE)
+#define OVL_TYPE_MERGE_OR_LOWER(type) \
+	(OVL_TYPE_MERGE(type) || !OVL_TYPE_UPPER(type))
+
 extern const char *ovl_opaque_xattr;
 
 static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)

commit e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:38 2014 +0200

    overlay filesystem
    
    Overlayfs allows one, usually read-write, directory tree to be
    overlaid onto another, read-only directory tree.  All modifications
    go to the upper, writable layer.
    
    This type of mechanism is most often used for live CDs but there's a
    wide variety of other uses.
    
    The implementation differs from other "union filesystem"
    implementations in that after a file is opened all operations go
    directly to the underlying, lower or upper, filesystems.  This
    simplifies the implementation and allows native performance in these
    cases.
    
    The dentry tree is duplicated from the underlying filesystems, this
    enables fast cached lookups without adding special support into the
    VFS.  This uses slightly more memory than union mounts, but dentries
    are relatively small.
    
    Currently inodes are duplicated as well, but it is a possible
    optimization to share inodes for non-directories.
    
    Opening non directories results in the open forwarded to the
    underlying filesystem.  This makes the behavior very similar to union
    mounts (with the same limitations vs. fchmod/fchown on O_RDONLY file
    descriptors).
    
    Usage:
    
      mount -t overlayfs overlayfs -olowerdir=/lower,upperdir=/upper/upper,workdir=/upper/work /overlay
    
    The following cotributions have been folded into this patch:
    
    Neil Brown <neilb@suse.de>:
     - minimal remount support
     - use correct seek function for directories
     - initialise is_real before use
     - rename ovl_fill_cache to ovl_dir_read
    
    Felix Fietkau <nbd@openwrt.org>:
     - fix a deadlock in ovl_dir_read_merged
     - fix a deadlock in ovl_remove_whiteouts
    
    Erez Zadok <ezk@fsl.cs.sunysb.edu>
     - fix cleanup after WARN_ON
    
    Sedat Dilek <sedat.dilek@googlemail.com>
     - fix up permission to confirm to new API
    
    Robin Dong <hao.bigrat@gmail.com>
     - fix possible leak in ovl_new_inode
     - create new inode in ovl_link
    
    Andy Whitcroft <apw@canonical.com>
     - switch to __inode_permission()
     - copy up i_uid/i_gid from the underlying inode
    
    AV:
     - ovl_copy_up_locked() - dput(ERR_PTR(...)) on two failure exits
     - ovl_clear_empty() - one failure exit forgetting to do unlock_rename(),
       lack of check for udir being the parent of upper, dropping and regaining
       the lock on udir (which would require _another_ check for parent being
       right).
     - bogus d_drop() in copyup and rename [fix from your mail]
     - copyup/remove and copyup/rename races [fix from your mail]
     - ovl_dir_fsync() leaving ERR_PTR() in ->realfile
     - ovl_entry_free() is pointless - it's just a kfree_rcu()
     - fold ovl_do_lookup() into ovl_lookup()
     - manually assigning ->d_op is wrong.  Just use ->s_d_op.
     [patches picked from Miklos]:
     * copyup/remove and copyup/rename races
     * bogus d_drop() in copyup and rename
    
    Also thanks to the following people for testing and reporting bugs:
    
      Jordi Pujol <jordipujolp@gmail.com>
      Andy Whitcroft <apw@canonical.com>
      Michal Suchanek <hramrach@centrum.cz>
      Felix Fietkau <nbd@openwrt.org>
      Erez Zadok <ezk@fsl.cs.sunysb.edu>
      Randy Dunlap <rdunlap@xenotime.net>
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
new file mode 100644
index 000000000000..814bed33dd07
--- /dev/null
+++ b/fs/overlayfs/overlayfs.h
@@ -0,0 +1,191 @@
+/*
+ *
+ * Copyright (C) 2011 Novell Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+
+struct ovl_entry;
+
+enum ovl_path_type {
+	OVL_PATH_PURE_UPPER,
+	OVL_PATH_UPPER,
+	OVL_PATH_MERGE,
+	OVL_PATH_LOWER,
+};
+
+extern const char *ovl_opaque_xattr;
+
+static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int err = vfs_rmdir(dir, dentry);
+	pr_debug("rmdir(%pd2) = %i\n", dentry, err);
+	return err;
+}
+
+static inline int ovl_do_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int err = vfs_unlink(dir, dentry, NULL);
+	pr_debug("unlink(%pd2) = %i\n", dentry, err);
+	return err;
+}
+
+static inline int ovl_do_link(struct dentry *old_dentry, struct inode *dir,
+			      struct dentry *new_dentry, bool debug)
+{
+	int err = vfs_link(old_dentry, dir, new_dentry, NULL);
+	if (debug) {
+		pr_debug("link(%pd2, %pd2) = %i\n",
+			 old_dentry, new_dentry, err);
+	}
+	return err;
+}
+
+static inline int ovl_do_create(struct inode *dir, struct dentry *dentry,
+			     umode_t mode, bool debug)
+{
+	int err = vfs_create(dir, dentry, mode, true);
+	if (debug)
+		pr_debug("create(%pd2, 0%o) = %i\n", dentry, mode, err);
+	return err;
+}
+
+static inline int ovl_do_mkdir(struct inode *dir, struct dentry *dentry,
+			       umode_t mode, bool debug)
+{
+	int err = vfs_mkdir(dir, dentry, mode);
+	if (debug)
+		pr_debug("mkdir(%pd2, 0%o) = %i\n", dentry, mode, err);
+	return err;
+}
+
+static inline int ovl_do_mknod(struct inode *dir, struct dentry *dentry,
+			       umode_t mode, dev_t dev, bool debug)
+{
+	int err = vfs_mknod(dir, dentry, mode, dev);
+	if (debug) {
+		pr_debug("mknod(%pd2, 0%o, 0%o) = %i\n",
+			 dentry, mode, dev, err);
+	}
+	return err;
+}
+
+static inline int ovl_do_symlink(struct inode *dir, struct dentry *dentry,
+				 const char *oldname, bool debug)
+{
+	int err = vfs_symlink(dir, dentry, oldname);
+	if (debug)
+		pr_debug("symlink(\"%s\", %pd2) = %i\n", oldname, dentry, err);
+	return err;
+}
+
+static inline int ovl_do_setxattr(struct dentry *dentry, const char *name,
+				  const void *value, size_t size, int flags)
+{
+	int err = vfs_setxattr(dentry, name, value, size, flags);
+	pr_debug("setxattr(%pd2, \"%s\", \"%*s\", 0x%x) = %i\n",
+		 dentry, name, (int) size, (char *) value, flags, err);
+	return err;
+}
+
+static inline int ovl_do_removexattr(struct dentry *dentry, const char *name)
+{
+	int err = vfs_removexattr(dentry, name);
+	pr_debug("removexattr(%pd2, \"%s\") = %i\n", dentry, name, err);
+	return err;
+}
+
+static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,
+				struct inode *newdir, struct dentry *newdentry,
+				unsigned int flags)
+{
+	int err;
+
+	pr_debug("rename2(%pd2, %pd2, 0x%x)\n",
+		 olddentry, newdentry, flags);
+
+	err = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);
+
+	if (err) {
+		pr_debug("...rename2(%pd2, %pd2, ...) = %i\n",
+			 olddentry, newdentry, err);
+	}
+	return err;
+}
+
+static inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)
+{
+	int err = vfs_whiteout(dir, dentry);
+	pr_debug("whiteout(%pd2) = %i\n", dentry, err);
+	return err;
+}
+
+enum ovl_path_type ovl_path_type(struct dentry *dentry);
+u64 ovl_dentry_version_get(struct dentry *dentry);
+void ovl_dentry_version_inc(struct dentry *dentry);
+void ovl_path_upper(struct dentry *dentry, struct path *path);
+void ovl_path_lower(struct dentry *dentry, struct path *path);
+enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
+struct dentry *ovl_dentry_upper(struct dentry *dentry);
+struct dentry *ovl_dentry_lower(struct dentry *dentry);
+struct dentry *ovl_dentry_real(struct dentry *dentry);
+struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);
+struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);
+void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);
+struct dentry *ovl_workdir(struct dentry *dentry);
+int ovl_want_write(struct dentry *dentry);
+void ovl_drop_write(struct dentry *dentry);
+bool ovl_dentry_is_opaque(struct dentry *dentry);
+void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
+bool ovl_is_whiteout(struct dentry *dentry);
+void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
+struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
+			  unsigned int flags);
+struct file *ovl_path_open(struct path *path, int flags);
+
+struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
+				struct kstat *stat, const char *link);
+
+/* readdir.c */
+extern const struct file_operations ovl_dir_operations;
+int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
+void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list);
+void ovl_cache_free(struct list_head *list);
+
+/* inode.c */
+int ovl_setattr(struct dentry *dentry, struct iattr *attr);
+int ovl_permission(struct inode *inode, int mask);
+int ovl_setxattr(struct dentry *dentry, const char *name,
+		 const void *value, size_t size, int flags);
+ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
+		     void *value, size_t size);
+ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
+int ovl_removexattr(struct dentry *dentry, const char *name);
+
+struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
+			    struct ovl_entry *oe);
+static inline void ovl_copyattr(struct inode *from, struct inode *to)
+{
+	to->i_uid = from->i_uid;
+	to->i_gid = from->i_gid;
+}
+
+/* dir.c */
+extern const struct inode_operations ovl_dir_inode_operations;
+struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);
+int ovl_create_real(struct inode *dir, struct dentry *newdentry,
+		    struct kstat *stat, const char *link,
+		    struct dentry *hardlink, bool debug);
+void ovl_cleanup(struct inode *dir, struct dentry *dentry);
+
+/* copy_up.c */
+int ovl_copy_up(struct dentry *dentry);
+int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
+		    struct path *lowerpath, struct kstat *stat,
+		    struct iattr *attr);
+int ovl_copy_xattr(struct dentry *old, struct dentry *new);
+int ovl_set_attr(struct dentry *upper, struct kstat *stat);
