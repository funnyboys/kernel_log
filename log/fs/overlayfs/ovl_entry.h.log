commit b8e42a651bdee06202ebdd96cff64fdeabd5b1d6
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jun 4 10:48:19 2020 +0200

    ovl: get rid of redundant members in struct ovl_fs
    
    ofs->upper_mnt is copied to ->layers[0].mnt and ->layers[0].trap could be
    used instead of a separate ->upperdir_trap.
    
    Split the lowerdir option early to get the number of layers, then allocate
    the ->layers array, and finally fill the upper and lower layers, as before.
    
    Get rid of path_put_init() in ovl_lower_dir(), since the only caller will
    take care of that.
    
    [Colin Ian King] Fix null pointer dereference on null stack pointer on
    error return found by Coverity.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 2da0ff355824..b429c80879ee 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -46,7 +46,6 @@ struct ovl_path {
 
 /* private information held for overlayfs's superblock */
 struct ovl_fs {
-	struct vfsmount *upper_mnt;
 	unsigned int numlayer;
 	/* Number of unique fs among layers including upper fs */
 	unsigned int numfs;
@@ -70,7 +69,6 @@ struct ovl_fs {
 	bool workdir_locked;
 	bool share_whiteout;
 	/* Traps in ovl inode cache */
-	struct inode *upperdir_trap;
 	struct inode *workbasedir_trap;
 	struct inode *workdir_trap;
 	struct inode *indexdir_trap;
@@ -84,7 +82,7 @@ struct ovl_fs {
 
 static inline struct vfsmount *ovl_upper_mnt(struct ovl_fs *ofs)
 {
-	return ofs->upper_mnt;
+	return ofs->layers[0].mnt;
 }
 
 static inline struct ovl_fs *OVL_FS(struct super_block *sb)

commit 08f4c7c86d4cf125389dce9d94423024549f9b02
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jun 4 10:48:19 2020 +0200

    ovl: add accessor for ofs->upper_mnt
    
    Next patch will remove ofs->upper_mnt, so add an accessor function for this
    field.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index a8f82fb7ffb4..2da0ff355824 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -82,6 +82,11 @@ struct ovl_fs {
 	struct dentry *whiteout;
 };
 
+static inline struct vfsmount *ovl_upper_mnt(struct ovl_fs *ofs)
+{
+	return ofs->upper_mnt;
+}
+
 static inline struct ovl_fs *OVL_FS(struct super_block *sb)
 {
 	return (struct ovl_fs *)sb->s_fs_info;

commit c21c839b8448dd4b1e37ffc1bde928f57d34c0db
Author: Chengguang Xu <cgxu519@mykernel.net>
Date:   Fri Apr 24 10:55:17 2020 +0800

    ovl: whiteout inode sharing
    
    Share inode with different whiteout files for saving inode and speeding up
    delete operation.
    
    If EMLINK is encountered when linking a shared whiteout, create a new one.
    In case of any other error, disable sharing for this super block.
    
    Note: ofs->whiteout is protected by inode lock on workdir.
    
    Signed-off-by: Chengguang Xu <cgxu519@mykernel.net>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 5762d802fe01..a8f82fb7ffb4 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -68,6 +68,7 @@ struct ovl_fs {
 	/* Did we take the inuse lock? */
 	bool upperdir_locked;
 	bool workdir_locked;
+	bool share_whiteout;
 	/* Traps in ovl inode cache */
 	struct inode *upperdir_trap;
 	struct inode *workbasedir_trap;
@@ -77,6 +78,8 @@ struct ovl_fs {
 	int xino_mode;
 	/* For allocation of non-persistent inode numbers */
 	atomic_long_t last_ino;
+	/* Whiteout dentry cache */
+	struct dentry *whiteout;
 };
 
 static inline struct ovl_fs *OVL_FS(struct super_block *sb)

commit 4d314f7859dc1925ee28b4d4e74f6f3a80e6f34b
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Feb 21 16:34:43 2020 +0200

    ovl: use a private non-persistent ino pool
    
    There is no reason to deplete the system's global get_next_ino() pool for
    overlay non-persistent inode numbers and there is no reason at all to
    allocate non-persistent inode numbers for non-directories.
    
    For non-directories, it is much better to leave i_ino the same as real
    i_ino, to be consistent with st_ino/d_ino.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 89015ea822e7..5762d802fe01 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -75,6 +75,8 @@ struct ovl_fs {
 	struct inode *indexdir_trap;
 	/* -1: disabled, 0: same fs, 1..32: number of unused ino bits */
 	int xino_mode;
+	/* For allocation of non-persistent inode numbers */
+	atomic_long_t last_ino;
 };
 
 static inline struct ovl_fs *OVL_FS(struct super_block *sb)

commit 1346416564f06444ca59778c05607bedb91a991a
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jan 24 09:46:45 2020 +0100

    ovl: layer is const
    
    The ovl_layer struct is never modified except at initialization.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index c9324ad47e15..89015ea822e7 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -40,7 +40,7 @@ struct ovl_layer {
 };
 
 struct ovl_path {
-	struct ovl_layer *layer;
+	const struct ovl_layer *layer;
 	struct dentry *dentry;
 };
 
@@ -50,7 +50,7 @@ struct ovl_fs {
 	unsigned int numlayer;
 	/* Number of unique fs among layers including upper fs */
 	unsigned int numfs;
-	struct ovl_layer *layers;
+	const struct ovl_layer *layers;
 	struct ovl_sb *fs;
 	/* workbasedir is the path at workdir= mount option */
 	struct dentry *workbasedir;

commit 1b81dddd354cf304574d79004400a6385613ae4e
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Nov 16 18:52:20 2019 +0200

    ovl: fix corner case of conflicting lower layer uuid
    
    This fixes ovl_lower_uuid_ok() to correctly detect the corner case:
     - two filesystems, A and B, both have null uuid
     - upper layer is on A
     - lower layer 1 is also on A
     - lower layer 2 is on B
    
    In this case, bad_uuid would not have been set for B, because the check
    only involved the list of lower fs.  Hence we'll try to decode a layer 2
    origin on layer 1 and fail.
    
    We check for conflicting (and null) uuid among all lower layers, including
    those layers that are on the same fs as the upper layer.
    
    Reported-by: Miklos Szeredi <mszeredi@redhat.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index d9fbebdb6076..c9324ad47e15 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -24,6 +24,8 @@ struct ovl_sb {
 	dev_t pseudo_dev;
 	/* Unusable (conflicting) uuid */
 	bool bad_uuid;
+	/* Used as a lower layer (but maybe also as upper) */
+	bool is_lower;
 };
 
 struct ovl_layer {

commit 07f1e59637a8e5a8bddba5da7567d46635da510f
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 14 21:59:22 2020 +0200

    ovl: generalize the lower_fs[] array
    
    Rename lower_fs[] array to fs[], extend its size by one and use index fsid
    (instead of fsid-1) to access the fs[] array.
    
    Initialize fs[0] with upper fs values. fsid 0 is reserved even with lower
    only overlay, so fs[0] remains null in this case.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 9a785702a2a4..d9fbebdb6076 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -46,10 +46,10 @@ struct ovl_path {
 struct ovl_fs {
 	struct vfsmount *upper_mnt;
 	unsigned int numlayer;
-	/* Number of unique lower sb that differ from upper sb */
-	unsigned int numlowerfs;
+	/* Number of unique fs among layers including upper fs */
+	unsigned int numfs;
 	struct ovl_layer *layers;
-	struct ovl_sb *lower_fs;
+	struct ovl_sb *fs;
 	/* workbasedir is the path at workdir= mount option */
 	struct dentry *workbasedir;
 	/* workdir is the 'work' directory under workbasedir */

commit 0f831ec85eda1ae27490baba106aba632c1d8e94
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Nov 16 18:14:41 2019 +0200

    ovl: simplify ovl_same_sb() helper
    
    No code uses the sb returned from this helper, so make it retrun a boolean
    and rename it to ovl_same_fs().
    
    The xino mode is irrelevant when all layers are on same fs, so instead of
    describing samefs with mode OVL_XINO_OFF, use a new xino_mode state, which
    is 0 in the case of samefs, -1 in the case of xino=off and > 0 with xino
    enabled.
    
    Create a new helper ovl_same_dev(), to use instead of the common check for
    (ovl_same_fs() || xinobits).
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 64baf04cdede..9a785702a2a4 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -71,10 +71,15 @@ struct ovl_fs {
 	struct inode *workbasedir_trap;
 	struct inode *workdir_trap;
 	struct inode *indexdir_trap;
-	/* Inode numbers in all layers do not use the high xino_bits */
-	unsigned int xino_bits;
+	/* -1: disabled, 0: same fs, 1..32: number of unused ino bits */
+	int xino_mode;
 };
 
+static inline struct ovl_fs *OVL_FS(struct super_block *sb)
+{
+	return (struct ovl_fs *)sb->s_fs_info;
+}
+
 /* private information held for every overlayfs dentry */
 struct ovl_entry {
 	union {

commit 94375f9d5103c2eb2f905381993a2fb70c297364
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Nov 15 14:12:40 2019 +0200

    ovl: generalize the lower_layers[] array
    
    Rename lower_layers[] array to layers[], extend its size by one and
    initialize layers[0] with upper layer values.  Lower layers are now
    addressed with index 1..numlower.  layers[0] is reserved even with lower
    only overlay.
    
    [SzM: replace ofs->numlower with ofs->numlayer, the latter's value is
    incremented by one]
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 28348c44ea5b..64baf04cdede 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -45,10 +45,10 @@ struct ovl_path {
 /* private information held for overlayfs's superblock */
 struct ovl_fs {
 	struct vfsmount *upper_mnt;
-	unsigned int numlower;
+	unsigned int numlayer;
 	/* Number of unique lower sb that differ from upper sb */
 	unsigned int numlowerfs;
-	struct ovl_layer *lower_layers;
+	struct ovl_layer *layers;
 	struct ovl_sb *lower_fs;
 	/* workbasedir is the path at workdir= mount option */
 	struct dentry *workbasedir;

commit 7e63c87fc2dcf3be9d3aab82d4a0ea085880bdca
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Nov 14 22:28:41 2019 +0200

    ovl: fix lookup failure on multi lower squashfs
    
    In the past, overlayfs required that lower fs have non null uuid in
    order to support nfs export and decode copy up origin file handles.
    
    Commit 9df085f3c9a2 ("ovl: relax requirement for non null uuid of
    lower fs") relaxed this requirement for nfs export support, as long
    as uuid (even if null) is unique among all lower fs.
    
    However, said commit unintentionally also relaxed the non null uuid
    requirement for decoding copy up origin file handles, regardless of
    the unique uuid requirement.
    
    Amend this mistake by disabling decoding of copy up origin file handle
    from lower fs with a conflicting uuid.
    
    We still encode copy up origin file handles from those fs, because
    file handles like those already exist in the wild and because they
    might provide useful information in the future.
    
    There is an unhandled corner case described by Miklos this way:
    - two filesystems, A and B, both have null uuid
    - upper layer is on A
    - lower layer 1 is also on A
    - lower layer 2 is on B
    
    In this case bad_uuid won't be set for B, because the check only
    involves the list of lower fs.  Hence we'll try to decode a layer 2
    origin on layer 1 and fail.
    
    We will deal with this corner case later.
    
    Reported-by: Colin Ian King <colin.king@canonical.com>
    Tested-by: Colin Ian King <colin.king@canonical.com>
    Link: https://lore.kernel.org/lkml/20191106234301.283006-1-colin.king@canonical.com/
    Fixes: 9df085f3c9a2 ("ovl: relax requirement for non null uuid ...")
    Cc: stable@vger.kernel.org # v4.20+
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index a8279280e88d..28348c44ea5b 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -22,6 +22,8 @@ struct ovl_config {
 struct ovl_sb {
 	struct super_block *sb;
 	dev_t pseudo_dev;
+	/* Unusable (conflicting) uuid */
+	bool bad_uuid;
 };
 
 struct ovl_layer {

commit 0be0bfd2de9dfdd2098a9c5b14bdd8f739c9165d
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Jul 12 15:24:34 2019 +0300

    ovl: fix regression caused by overlapping layers detection
    
    Once upon a time, commit 2cac0c00a6cd ("ovl: get exclusive ownership on
    upper/work dirs") in v4.13 added some sanity checks on overlayfs layers.
    This change caused a docker regression. The root cause was mount leaks
    by docker, which as far as I know, still exist.
    
    To mitigate the regression, commit 85fdee1eef1a ("ovl: fix regression
    caused by exclusive upper/work dir protection") in v4.14 turned the
    mount errors into warnings for the default index=off configuration.
    
    Recently, commit 146d62e5a586 ("ovl: detect overlapping layers") in
    v5.2, re-introduced exclusive upper/work dir checks regardless of
    index=off configuration.
    
    This changes the status quo and mount leak related bug reports have
    started to re-surface. Restore the status quo to fix the regressions.
    To clarify, index=off does NOT relax overlapping layers check for this
    ovelayfs mount. index=off only relaxes exclusive upper/work dir checks
    with another overlayfs mount.
    
    To cover the part of overlapping layers detection that used the
    exclusive upper/work dir checks to detect overlap with self upper/work
    dir, add a trap also on the work base dir.
    
    Link: https://github.com/moby/moby/issues/34672
    Link: https://lore.kernel.org/linux-fsdevel/20171006121405.GA32700@veci.piliscsaba.szeredi.hu/
    Link: https://github.com/containers/libpod/issues/3540
    Fixes: 146d62e5a586 ("ovl: detect overlapping layers")
    Cc: <stable@vger.kernel.org> # v4.19+
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Tested-by: Colin Walters <walters@verbum.org>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 28a2d12a1029..a8279280e88d 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -66,6 +66,7 @@ struct ovl_fs {
 	bool workdir_locked;
 	/* Traps in ovl inode cache */
 	struct inode *upperdir_trap;
+	struct inode *workbasedir_trap;
 	struct inode *workdir_trap;
 	struct inode *indexdir_trap;
 	/* Inode numbers in all layers do not use the high xino_bits */

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 6ed1ace8f8b3..28a2d12a1029 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -1,11 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *
  * Copyright (C) 2011 Novell Inc.
  * Copyright (C) 2016 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
  */
 
 struct ovl_config {

commit 146d62e5a5867fbf84490d82455718bfb10fe824
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Apr 18 17:42:08 2019 +0300

    ovl: detect overlapping layers
    
    Overlapping overlay layers are not supported and can cause unexpected
    behavior, but overlayfs does not currently check or warn about these
    configurations.
    
    User is not supposed to specify the same directory for upper and
    lower dirs or for different lower layers and user is not supposed to
    specify directories that are descendants of each other for overlay
    layers, but that is exactly what this zysbot repro did:
    
        https://syzkaller.appspot.com/x/repro.syz?x=12c7a94f400000
    
    Moving layer root directories into other layers while overlayfs
    is mounted could also result in unexpected behavior.
    
    This commit places "traps" in the overlay inode hash table.
    Those traps are dummy overlay inodes that are hashed by the layers
    root inodes.
    
    On mount, the hash table trap entries are used to verify that overlay
    layers are not overlapping.  While at it, we also verify that overlay
    layers are not overlapping with directories "in-use" by other overlay
    instances as upperdir/workdir.
    
    On lookup, the trap entries are used to verify that overlay layers
    root inodes have not been moved into other layers after mount.
    
    Some examples:
    
    $ ./run --ov --samefs -s
    ...
    ( mkdir -p base/upper/0/u base/upper/0/w base/lower lower upper mnt
      mount -o bind base/lower lower
      mount -o bind base/upper upper
      mount -t overlay none mnt ...
            -o lowerdir=lower,upperdir=upper/0/u,workdir=upper/0/w)
    
    $ umount mnt
    $ mount -t overlay none mnt ...
            -o lowerdir=base,upperdir=upper/0/u,workdir=upper/0/w
    
      [   94.434900] overlayfs: overlapping upperdir path
      mount: mount overlay on mnt failed: Too many levels of symbolic links
    
    $ mount -t overlay none mnt ...
            -o lowerdir=upper/0/u,upperdir=upper/0/u,workdir=upper/0/w
    
      [  151.350132] overlayfs: conflicting lowerdir path
      mount: none is already mounted or mnt busy
    
    $ mount -t overlay none mnt ...
            -o lowerdir=lower:lower/a,upperdir=upper/0/u,workdir=upper/0/w
    
      [  201.205045] overlayfs: overlapping lowerdir path
      mount: mount overlay on mnt failed: Too many levels of symbolic links
    
    $ mount -t overlay none mnt ...
            -o lowerdir=lower,upperdir=upper/0/u,workdir=upper/0/w
    $ mv base/upper/0/ base/lower/
    $ find mnt/0
      mnt/0
      mnt/0/w
      find: 'mnt/0/w/work': Too many levels of symbolic links
      find: 'mnt/0/u': Too many levels of symbolic links
    
    Reported-by: syzbot+9c69c282adc4edd2b540@syzkaller.appspotmail.com
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index ec237035333a..6ed1ace8f8b3 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -29,6 +29,8 @@ struct ovl_sb {
 
 struct ovl_layer {
 	struct vfsmount *mnt;
+	/* Trap in ovl inode cache */
+	struct inode *trap;
 	struct ovl_sb *fs;
 	/* Index of this layer in fs root (upper idx == 0) */
 	int idx;
@@ -65,6 +67,10 @@ struct ovl_fs {
 	/* Did we take the inuse lock? */
 	bool upperdir_locked;
 	bool workdir_locked;
+	/* Traps in ovl inode cache */
+	struct inode *upperdir_trap;
+	struct inode *workdir_trap;
+	struct inode *indexdir_trap;
 	/* Inode numbers in all layers do not use the high xino_bits */
 	unsigned int xino_bits;
 };

commit 2664bd0897c2889258472a1ee922ef9d4c5fa58f
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:30 2018 -0400

    ovl: Store lower data inode in ovl_inode
    
    Right now ovl_inode stores inode pointer for lower inode.  This helps with
    quickly getting lower inode given overlay inode (ovl_inode_lower()).
    
    Now with metadata only copy-up, we can have metacopy inode in middle layer
    as well and inode containing data can be different from ->lower.  I need to
    be able to open the real file in ovl_open_realfile() and for that I need to
    quickly find the lower data inode.
    
    Hence store lower data inode also in ovl_inode.  Also provide an helper
    ovl_inode_lowerdata() to access this field.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index ea4134e97d0d..ec237035333a 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -89,7 +89,10 @@ static inline struct ovl_entry *OVL_E(struct dentry *dentry)
 }
 
 struct ovl_inode {
-	struct ovl_dir_cache *cache;
+	union {
+		struct ovl_dir_cache *cache;	/* directory */
+		struct inode *lowerdata;	/* regular file */
+	};
 	const char *redirect;
 	u64 version;
 	unsigned long flags;

commit d5791044d2e5749ef4de84161cec5532e2111540
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri May 11 11:49:27 2018 -0400

    ovl: Provide a mount option metacopy=on/off for metadata copyup
    
    By default metadata only copy up is disabled.  Provide a mount option so
    that users can choose one way or other.
    
    Also provide a kernel config and module option to enable/disable metacopy
    feature.
    
    metacopy feature requires redirect_dir=on when upper is present.
    Otherwise, it requires redirect_dir=follow atleast.
    
    As of now, metacopy does not work with nfs_export=on.  So if both
    metacopy=on and nfs_export=on then nfs_export is disabled.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 41655a7d6894..ea4134e97d0d 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -19,6 +19,7 @@ struct ovl_config {
 	bool index;
 	bool nfs_export;
 	int xino;
+	bool metacopy;
 };
 
 struct ovl_sb {

commit 795939a93e600587e52c34fe02402b27ddda6017
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Mar 29 09:08:18 2018 +0300

    ovl: add support for "xino" mount and config options
    
    With mount option "xino=on", mounter declares that there are enough
    free high bits in underlying fs to hold the layer fsid.
    If overlayfs does encounter underlying inodes using the high xino
    bits reserved for layer fsid, a warning will be emitted and the original
    inode number will be used.
    
    The mount option name "xino" goes after a similar meaning mount option
    of aufs, but in overlayfs case, the mapping is stateless.
    
    An example for a use case of "xino=on" is when upper/lower is on an xfs
    filesystem. xfs uses 64bit inode numbers, but it currently never uses the
    upper 8bit for inode numbers exposed via stat(2) and that is not likely to
    change in the future without user opting-in for a new xfs feature. The
    actual number of unused upper bit is much larger and determined by the xfs
    filesystem geometry (64 - agno_log - agblklog - inopblog). That means
    that for all practical purpose, there are enough unused bits in xfs
    inode numbers for more than OVL_MAX_STACK unique fsid's.
    
    Another use case of "xino=on" is when upper/lower is on tmpfs. tmpfs inode
    numbers are allocated sequentially since boot, so they will practially
    never use the high inode number bits.
    
    For compatibility with applications that expect 32bit inodes, the feature
    can be disabled with "xino=off". The option "xino=auto" automatically
    detects underlying filesystem that use 32bit inodes and enables the
    feature. The Kconfig option OVERLAY_FS_XINO_AUTO and module parameter of
    the same name, determine if the default mode for overlayfs mount is
    "xino=auto" or "xino=off".
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 620bd20f9a22..41655a7d6894 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -18,6 +18,7 @@ struct ovl_config {
 	const char *redirect_mode;
 	bool index;
 	bool nfs_export;
+	int xino;
 };
 
 struct ovl_sb {

commit e487d889b7e3e8ec4091eb83bc4f7e67c7f05e27
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Nov 7 13:55:04 2017 +0200

    ovl: constant st_ino for non-samefs with xino
    
    On 64bit systems, when overlay layers are not all on the same fs, but
    all inode numbers of underlying fs are not using the high bits, use the
    high bits to partition the overlay st_ino address space.  The high bits
    hold the fsid (upper fsid is 0).  This way overlay inode numbers are unique
    and all inodes use overlay st_dev.  Inode numbers are also persistent
    for a given layer configuration.
    
    Currently, our only indication for available high ino bits is from a
    filesystem that supports file handles and uses the default encode_fh()
    operation, which encodes a 32bit inode number.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index e1c838c27a74..620bd20f9a22 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -63,6 +63,8 @@ struct ovl_fs {
 	/* Did we take the inuse lock? */
 	bool upperdir_locked;
 	bool workdir_locked;
+	/* Inode numbers in all layers do not use the high xino_bits */
+	unsigned int xino_bits;
 };
 
 /* private information held for every overlayfs dentry */

commit 5148626b806a74dd219f2bce5f204abf909f6930
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Mar 28 20:22:41 2018 +0300

    ovl: allocate anon bdev per unique lower fs
    
    Instead of allocating an anonymous bdev per lower layer, allocate
    one anonymous bdev per every unique lower fs that is different than
    upper fs.
    
    Every unique lower fs is assigned an fsid > 0 and the number of
    unique lower fs are stored in ofs->numlowerfs.
    
    The assigned fsid is stored in the lower layer struct and will be
    used also for inode number multiplexing.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index bfef6edcc111..e1c838c27a74 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -20,11 +20,18 @@ struct ovl_config {
 	bool nfs_export;
 };
 
+struct ovl_sb {
+	struct super_block *sb;
+	dev_t pseudo_dev;
+};
+
 struct ovl_layer {
 	struct vfsmount *mnt;
-	dev_t pseudo_dev;
-	/* Index of this layer in fs root (upper == 0) */
+	struct ovl_sb *fs;
+	/* Index of this layer in fs root (upper idx == 0) */
 	int idx;
+	/* One fsid per unique underlying sb (upper fsid == 0) */
+	int fsid;
 };
 
 struct ovl_path {
@@ -35,8 +42,11 @@ struct ovl_path {
 /* private information held for overlayfs's superblock */
 struct ovl_fs {
 	struct vfsmount *upper_mnt;
-	unsigned numlower;
+	unsigned int numlower;
+	/* Number of unique lower sb that differ from upper sb */
+	unsigned int numlowerfs;
 	struct ovl_layer *lower_layers;
+	struct ovl_sb *lower_fs;
 	/* workbasedir is the path at workdir= mount option */
 	struct dentry *workbasedir;
 	/* workdir is the 'work' directory under workbasedir */
@@ -50,8 +60,6 @@ struct ovl_fs {
 	const struct cred *creator_cred;
 	bool tmpfile;
 	bool noxattr;
-	/* sb common to all layers */
-	struct super_block *same_sb;
 	/* Did we take the inuse lock? */
 	bool upperdir_locked;
 	bool workdir_locked;

commit c62520a83bceae0bb0b7b3de10c3e81205cd3823
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sun Jan 14 19:25:31 2018 +0200

    ovl: store 'has_upper' and 'opaque' as bit flags
    
    We need to make some room in struct ovl_entry to store information
    about redirected ancestors for NFS export, so cram two booleans as
    bit flags.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 6dd60fcf8cb7..bfef6edcc111 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -61,8 +61,7 @@ struct ovl_fs {
 struct ovl_entry {
 	union {
 		struct {
-			unsigned long has_upper;
-			bool opaque;
+			unsigned long flags;
 		};
 		struct rcu_head rcu;
 	};
@@ -72,6 +71,11 @@ struct ovl_entry {
 
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 
+static inline struct ovl_entry *OVL_E(struct dentry *dentry)
+{
+	return (struct ovl_entry *) dentry->d_fsdata;
+}
+
 struct ovl_inode {
 	struct ovl_dir_cache *cache;
 	const char *redirect;

commit f168f1098dd9038daaf9f7be5f81cdea4985886a
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Jan 19 11:26:53 2018 +0200

    ovl: add support for "nfs_export" configuration
    
    Introduce the "nfs_export" config, module and mount options.
    
    The NFS export feature depends on the "index" feature and enables two
    implicit overlayfs features: "index_all" and "verify_lower".
    The "index_all" feature creates an index on copy up of every file and
    directory. The "verify_lower" feature uses the full index to detect
    overlay filesystems inconsistencies on lookup, like redirect from
    multiple upper dirs to the same lower dir.
    
    NFS export can be enabled for non-upper mount with no index. However,
    because lower layer redirects cannot be verified with the index, enabling
    NFS export support on an overlay with no upper layer requires turning off
    redirect follow (e.g. "redirect_dir=nofollow").
    
    The full index may incur some overhead on mount time, especially when
    verifying that lower directory file handles are not stale.
    
    NFS export support, full index and consistency verification will be
    implemented by following patches.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 608e48755070..6dd60fcf8cb7 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -17,6 +17,7 @@ struct ovl_config {
 	bool redirect_follow;
 	const char *redirect_mode;
 	bool index;
+	bool nfs_export;
 };
 
 struct ovl_layer {

commit d583ed7d138825fd9469d5419e23230ad39173e8
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Nov 8 19:23:36 2017 +0200

    ovl: store layer index in ovl_layer
    
    Store the fs root layer index inside ovl_layer struct, so we can
    get the root fs layer index from merge dir lower layer instead of
    find it with ovl_find_layer() helper.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 9d0bc03bf6e4..608e48755070 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -22,6 +22,8 @@ struct ovl_config {
 struct ovl_layer {
 	struct vfsmount *mnt;
 	dev_t pseudo_dev;
+	/* Index of this layer in fs root (upper == 0) */
+	int idx;
 };
 
 struct ovl_path {

commit 438c84c2f0c794f75ab55ce65c505b01bfce4480
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Dec 11 11:28:10 2017 +0100

    ovl: don't follow redirects if redirect_dir=off
    
    Overlayfs is following redirects even when redirects are disabled. If this
    is unintentional (probably the majority of cases) then this can be a
    problem.  E.g. upper layer comes from untrusted USB drive, and attacker
    crafts a redirect to enable read access to otherwise unreadable
    directories.
    
    If "redirect_dir=off", then turn off following as well as creation of
    redirects.  If "redirect_dir=follow", then turn on following, but turn off
    creation of redirects (which is what "redirect_dir=off" does now).
    
    This is a backward incompatible change, so make it dependent on a config
    option.
    
    Reported-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 752bab645879..9d0bc03bf6e4 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -14,6 +14,8 @@ struct ovl_config {
 	char *workdir;
 	bool default_permissions;
 	bool redirect_dir;
+	bool redirect_follow;
+	const char *redirect_mode;
 	bool index;
 };
 

commit b04a23421bf63d3fde3227041b31e39cb5b5349d
Merge: 5a3e0b196bbd d9768076068f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 17 13:36:59 2017 -0800

    Merge branch 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
    
     - Report constant st_ino values across copy-up even if underlying
       layers are on different filesystems, but using different st_dev
       values for each layer.
    
       Ideally we'd report the same st_dev across the overlay, and it's
       possible to do for filesystems that use only 32bits for st_ino by
       unifying the inum space. It would be nice if it wasn't a choice of 32
       or 64, rather filesystems could report their current maximum (that
       could change on resize, so it wouldn't be set in stone).
    
     - miscellaneus fixes and a cleanup of ovl_fill_super(), that was long
       overdue.
    
     - created a path_put_init() helper that clears out the pointers after
       putting the ref.
    
       I think this could be useful elsewhere, so added it to <linux/path.h>
    
    * 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs: (30 commits)
      ovl: remove unneeded arg from ovl_verify_origin()
      ovl: Put upperdentry if ovl_check_origin() fails
      ovl: rename ufs to ofs
      ovl: clean up getting lower layers
      ovl: clean up workdir creation
      ovl: clean up getting upper layer
      ovl: move ovl_get_workdir() and ovl_get_lower_layers()
      ovl: reduce the number of arguments for ovl_workdir_create()
      ovl: change order of setup in ovl_fill_super()
      ovl: factor out ovl_free_fs() helper
      ovl: grab reference to workbasedir early
      ovl: split out ovl_get_indexdir() from ovl_fill_super()
      ovl: split out ovl_get_lower_layers() from ovl_fill_super()
      ovl: split out ovl_get_workdir() from ovl_fill_super()
      ovl: split out ovl_get_upper() from ovl_fill_super()
      ovl: split out ovl_get_lowerstack() from ovl_fill_super()
      ovl: split out ovl_get_workpath() from ovl_fill_super()
      ovl: split out ovl_get_upperpath() from ovl_fill_super()
      ovl: use path_put_init() in error paths for ovl_fill_super()
      vfs: add path_put_init()
      ...

commit 2a9c6d066e98c1fe51a735b1439929f2f2afd891
Author: Chandan Rajendra <chandan@linux.vnet.ibm.com>
Date:   Wed Nov 1 20:12:49 2017 +0200

    ovl: allocate anonymous devs for lowerdirs
    
    Generate unique values of st_dev per lower layer for non-samefs
    overlay mount. The unique values are obtained by allocating anonymous
    bdevs for each of the lowerdirs in the overlayfs instance.
    
    The anonymous bdev is going to be returned by stat(2) for lowerdir
    non-dir entries in non-samefs case.
    
    [amir: split from ovl_getattr() and re-structure patches]
    
    Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 1e28329b5db8..93eb6a044dd2 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -19,6 +19,7 @@ struct ovl_config {
 
 struct ovl_layer {
 	struct vfsmount *mnt;
+	dev_t pseudo_dev;
 };
 
 struct ovl_path {

commit b93436320c1e9089a055941523571cd7c037f7cb
Author: Chandan Rajendra <chandan@linux.vnet.ibm.com>
Date:   Mon Jul 24 01:57:54 2017 -0500

    ovl: re-structure overlay lower layers in-memory
    
    Define new structures to represent overlay instance lower layers and
    overlay merge dir lower layers to make room for storing more per layer
    information in-memory.
    
    Instead of keeping the fs instance lower layers in an array of struct
    vfsmount, keep them in an array of new struct ovl_layer, that has a
    pointer to struct vfsmount.
    
    Instead of keeping the dentry lower layers in an array of struct path,
    keep them in an array of new struct ovl_path, that has a pointer to
    struct dentry and to struct ovl_layer.
    
    Add a small helper to find the fs layer id that correspopnds to a lower
    struct ovl_path and use it in ovl_lookup().
    
    [amir: split re-structure from anonymous bdev patch]
    
    Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 25d9b5adcd42..1e28329b5db8 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -17,11 +17,20 @@ struct ovl_config {
 	bool index;
 };
 
+struct ovl_layer {
+	struct vfsmount *mnt;
+};
+
+struct ovl_path {
+	struct ovl_layer *layer;
+	struct dentry *dentry;
+};
+
 /* private information held for overlayfs's superblock */
 struct ovl_fs {
 	struct vfsmount *upper_mnt;
 	unsigned numlower;
-	struct vfsmount **lower_mnt;
+	struct ovl_layer *lower_layers;
 	/* workbasedir is the path at workdir= mount option */
 	struct dentry *workbasedir;
 	/* workdir is the 'work' directory under workbasedir */
@@ -52,7 +61,7 @@ struct ovl_entry {
 		struct rcu_head rcu;
 	};
 	unsigned numlower;
-	struct path lowerstack[];
+	struct ovl_path lowerstack[];
 };
 
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);

commit 506458efaf153c1ea480591c5602a5a3ba5a3b76
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Oct 24 11:22:48 2017 +0100

    locking/barriers: Convert users of lockless_dereference() to READ_ONCE()
    
    READ_ONCE() now has an implicit smp_read_barrier_depends() call, so it
    can be used instead of lockless_dereference() without any change in
    semantics.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1508840570-22169-4-git-send-email-will.deacon@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 25d9b5adcd42..36b49bd09264 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -77,5 +77,5 @@ static inline struct ovl_inode *OVL_I(struct inode *inode)
 
 static inline struct dentry *ovl_upperdentry_dereference(struct ovl_inode *oi)
 {
-	return lockless_dereference(oi->__upperdentry);
+	return READ_ONCE(oi->__upperdentry);
 }

commit 85fdee1eef1a9e48ad5716916677e0c5fbc781e3
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Sep 29 10:21:21 2017 +0300

    ovl: fix regression caused by exclusive upper/work dir protection
    
    Enforcing exclusive ownership on upper/work dirs caused a docker
    regression: https://github.com/moby/moby/issues/34672.
    
    Euan spotted the regression and pointed to the offending commit.
    Vivek has brought the regression to my attention and provided this
    reproducer:
    
    Terminal 1:
    
      mount -t overlay -o workdir=work,lowerdir=lower,upperdir=upper none
            merged/
    
    Terminal 2:
    
      unshare -m
    
    Terminal 1:
    
      umount merged
      mount -t overlay -o workdir=work,lowerdir=lower,upperdir=upper none
            merged/
      mount: /root/overlay-testing/merged: none already mounted or mount point
             busy
    
    To fix the regression, I replaced the error with an alarming warning.
    With index feature enabled, mount does fail, but logs a suggestion to
    override exclusive dir protection by disabling index.
    Note that index=off mount does take the inuse locks, so a concurrent
    index=off will issue the warning and a concurrent index=on mount will fail.
    
    Documentation was updated to reflect this change.
    
    Fixes: 2cac0c00a6cd ("ovl: get exclusive ownership on upper/work dirs")
    Cc: <stable@vger.kernel.org> # v4.13
    Reported-by: Euan Kemp <euank@euank.com>
    Reported-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 878a750986dd..25d9b5adcd42 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -37,6 +37,9 @@ struct ovl_fs {
 	bool noxattr;
 	/* sb common to all layers */
 	struct super_block *same_sb;
+	/* Did we take the inuse lock? */
+	bool upperdir_locked;
+	bool workdir_locked;
 };
 
 /* private information held for every overlayfs dentry */

commit 55acc6618259c8ff0a400a131f0f4b613e96010a
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:18 2017 +0200

    ovl: add flag for upper in ovl_entry
    
    For rename, we need to ensure that an upper alias exists for hard links
    before attempting the operation.  Introduce a flag in ovl_entry to track
    the state of the upper alias.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 9642ec64467b..878a750986dd 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -42,7 +42,10 @@ struct ovl_fs {
 /* private information held for every overlayfs dentry */
 struct ovl_entry {
 	union {
-		bool opaque;
+		struct {
+			unsigned long has_upper;
+			bool opaque;
+		};
 		struct rcu_head rcu;
 	};
 	unsigned numlower;

commit 02bcd1577400b0b2eab806ccb9f72d6b5ec7bcca
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:36 2017 +0300

    ovl: introduce the inodes index dir feature
    
    Create the index dir on mount. The index dir will contain hardlinks to
    upper inodes, named after the hex representation of their origin lower
    inodes.
    
    The index dir is going to be used to prevent breaking lower hardlinks
    on copy up and to implement overlayfs NFS export.
    
    Because the feature is not fully backward compat, enabling the feature
    is opt-in by config/module/mount option.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 5b5a32116424..9642ec64467b 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -14,6 +14,7 @@ struct ovl_config {
 	char *workdir;
 	bool default_permissions;
 	bool redirect_dir;
+	bool index;
 };
 
 /* private information held for overlayfs's superblock */
@@ -25,6 +26,8 @@ struct ovl_fs {
 	struct dentry *workbasedir;
 	/* workdir is the 'work' directory under workbasedir */
 	struct dentry *workdir;
+	/* index directory listing overlay inodes by origin file handle */
+	struct dentry *indexdir;
 	long namelen;
 	/* pathnames of lower and upper dirs, for show_options */
 	struct ovl_config config;

commit 2cac0c00a6cdcc9121de150ed531f652396d1544
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:33 2017 +0300

    ovl: get exclusive ownership on upper/work dirs
    
    Bad things can happen if several concurrent overlay mounts try to
    use the same upperdir/workdir path.
    
    Try to get the 'inuse' advisory lock on upperdir and workdir.
    Fail mount if another overlay mount instance or another user
    holds the 'inuse' lock on these directories.
    
    Note that this provides no protection for concurrent overlay
    mount that use overlapping (i.e. descendant) upper/work dirs.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 6a90a48c3589..5b5a32116424 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -21,6 +21,9 @@ struct ovl_fs {
 	struct vfsmount *upper_mnt;
 	unsigned numlower;
 	struct vfsmount **lower_mnt;
+	/* workbasedir is the path at workdir= mount option */
+	struct dentry *workbasedir;
+	/* workdir is the 'work' directory under workbasedir */
 	struct dentry *workdir;
 	long namelen;
 	/* pathnames of lower and upper dirs, for show_options */

commit 04a01ac7ed3c5cd718713ef6341249a143c96b10
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: move cache and version to ovl_inode
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index d8f514a474ca..6a90a48c3589 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -35,12 +35,8 @@ struct ovl_fs {
 
 /* private information held for every overlayfs dentry */
 struct ovl_entry {
-	struct ovl_dir_cache *cache;
 	union {
-		struct {
-			u64 version;
-			bool opaque;
-		};
+		bool opaque;
 		struct rcu_head rcu;
 	};
 	unsigned numlower;
@@ -50,7 +46,9 @@ struct ovl_entry {
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 
 struct ovl_inode {
+	struct ovl_dir_cache *cache;
 	const char *redirect;
+	u64 version;
 	unsigned long flags;
 	struct inode vfs_inode;
 	struct dentry *__upperdentry;

commit a015dafcaf5b0316654a39bc598a76804595af90
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:51 2017 +0300

    ovl: use ovl_inode mutex to synchronize concurrent copy up
    
    Use the new ovl_inode mutex to synchonize concurrent copy up
    instead of the super block copy up workqueue.
    
    Moving the synchronization object from the overlay dentry to
    the overlay inode is needed for synchonizing concurrent copy up
    of lower hardlinks to the same upper inode.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 50dfa4826152..d8f514a474ca 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -29,7 +29,6 @@ struct ovl_fs {
 	const struct cred *creator_cred;
 	bool tmpfile;
 	bool noxattr;
-	wait_queue_head_t copyup_wq;
 	/* sb common to all layers */
 	struct super_block *same_sb;
 };
@@ -41,7 +40,6 @@ struct ovl_entry {
 		struct {
 			u64 version;
 			bool opaque;
-			bool copying;
 		};
 		struct rcu_head rcu;
 	};
@@ -57,6 +55,9 @@ struct ovl_inode {
 	struct inode vfs_inode;
 	struct dentry *__upperdentry;
 	struct inode *lower;
+
+	/* synchronize copy up and more */
+	struct mutex lock;
 };
 
 static inline struct ovl_inode *OVL_I(struct inode *inode)

commit 13c72075ac9f5a5cf3f61c85adaafffe48a6f797
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: move impure to ovl_inode
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 477d21738656..50dfa4826152 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -41,7 +41,6 @@ struct ovl_entry {
 		struct {
 			u64 version;
 			bool opaque;
-			bool impure;
 			bool copying;
 		};
 		struct rcu_head rcu;
@@ -54,6 +53,7 @@ struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 
 struct ovl_inode {
 	const char *redirect;
+	unsigned long flags;
 	struct inode vfs_inode;
 	struct dentry *__upperdentry;
 	struct inode *lower;

commit cf31c46347e8e54cb53d66255ae3eea045b0a60c
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: move redirect to ovl_inode
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index ddd937490f0d..477d21738656 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -40,7 +40,6 @@ struct ovl_entry {
 	union {
 		struct {
 			u64 version;
-			const char *redirect;
 			bool opaque;
 			bool impure;
 			bool copying;
@@ -54,6 +53,7 @@ struct ovl_entry {
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 
 struct ovl_inode {
+	const char *redirect;
 	struct inode vfs_inode;
 	struct dentry *__upperdentry;
 	struct inode *lower;

commit 09d8b586731bf589655c2ac971532c14cf272b63
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: move __upperdentry to ovl_inode
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index b8c213891e84..ddd937490f0d 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -36,7 +36,6 @@ struct ovl_fs {
 
 /* private information held for every overlayfs dentry */
 struct ovl_entry {
-	struct dentry *__upperdentry;
 	struct ovl_dir_cache *cache;
 	union {
 		struct {
@@ -54,14 +53,9 @@ struct ovl_entry {
 
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 
-static inline struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)
-{
-	return lockless_dereference(oe->__upperdentry);
-}
-
 struct ovl_inode {
 	struct inode vfs_inode;
-	struct inode *upper;
+	struct dentry *__upperdentry;
 	struct inode *lower;
 };
 
@@ -69,3 +63,8 @@ static inline struct ovl_inode *OVL_I(struct inode *inode)
 {
 	return container_of(inode, struct ovl_inode, vfs_inode);
 }
+
+static inline struct dentry *ovl_upperdentry_dereference(struct ovl_inode *oi)
+{
+	return lockless_dereference(oi->__upperdentry);
+}

commit 25b7713afe50963e70f98c1c964f60baf1e7e373
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jul 4 22:03:16 2017 +0200

    ovl: use i_private only as a key
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 553727df886c..b8c213891e84 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -61,6 +61,8 @@ static inline struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)
 
 struct ovl_inode {
 	struct inode vfs_inode;
+	struct inode *upper;
+	struct inode *lower;
 };
 
 static inline struct ovl_inode *OVL_I(struct inode *inode)

commit 13cf199d0088b77ab08a9594df2e73e775317ed2
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Mon Jun 12 09:54:40 2017 +0300

    ovl: allocate an ovl_inode struct
    
    We need some more space to store overlay inode data in memory,
    so allocate overlay inodes from a slab of struct ovl_inode.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 34bc4a9f5c61..553727df886c 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -58,3 +58,12 @@ static inline struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)
 {
 	return lockless_dereference(oe->__upperdentry);
 }
+
+struct ovl_inode {
+	struct inode vfs_inode;
+};
+
+static inline struct ovl_inode *OVL_I(struct inode *inode)
+{
+	return container_of(inode, struct ovl_inode, vfs_inode);
+}

commit ee1d6d37b6b884383b501089be93ce94f2153028
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu May 11 16:42:26 2017 +0300

    ovl: mark upper dir with type origin entries "impure"
    
    When moving a merge dir or non-dir with copy up origin into a non-merge
    upper dir (a.k.a pure upper dir), we are marking the target parent dir
    "impure". ovl_iterate() iterates pure upper dirs directly, because there is
    no need to filter out whiteouts and merge dir content with lower dir. But
    for the case of an "impure" upper dir, ovl_iterate() will not be able to
    iterate the real upper dir directly, because it will need to lookup the
    origin inode and use it to fill d_ino.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index ad86c0a302eb..34bc4a9f5c61 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -43,6 +43,7 @@ struct ovl_entry {
 			u64 version;
 			const char *redirect;
 			bool opaque;
+			bool impure;
 			bool copying;
 		};
 		struct rcu_head rcu;

commit 82b749b2c65e9d108c1c5598dc0a5f436b525f42
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed May 17 00:12:40 2017 +0300

    ovl: check on mount time if upper fs supports setting xattr
    
    xattr are needed by overlayfs for setting opaque dir, redirect dir
    and copy up origin.
    
    Check at mount time by trying to set the overlay.opaque xattr on the
    workdir and if that fails issue a warning message.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index b2023ddb8532..ad86c0a302eb 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -28,6 +28,7 @@ struct ovl_fs {
 	/* creds of process who forced instantiation of super block */
 	const struct cred *creator_cred;
 	bool tmpfile;
+	bool noxattr;
 	wait_queue_head_t copyup_wq;
 	/* sb common to all layers */
 	struct super_block *same_sb;

commit 7bcd74b98d7bac3e5149894caaf72de6989af7f0
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Mar 22 08:42:21 2017 -0400

    ovl: check if all layers are on the same fs
    
    Some features can only work when all layers are on the same fs.  Test this
    condition during mount time, so features can check them later.
    
    Add helper ovl_same_sb() to return the common super block in case all
    layers are on the same fs.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 59614faa14c3..b2023ddb8532 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -29,6 +29,8 @@ struct ovl_fs {
 	const struct cred *creator_cred;
 	bool tmpfile;
 	wait_queue_head_t copyup_wq;
+	/* sb common to all layers */
+	struct super_block *same_sb;
 };
 
 /* private information held for every overlayfs dentry */

commit 39d3d60a54df05a1a32fa71159d7a26a530dee6c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 17 06:34:56 2017 +0200

    ovl: introduce copy up waitqueue
    
    The overlay sb 'copyup_wq' and overlay inode 'copying' condition
    variable are about to replace the upper sb rename_lock, as finer
    grained synchronization objects for concurrent copy up.
    
    Suggested-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 65f240001aa6..59614faa14c3 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -28,6 +28,7 @@ struct ovl_fs {
 	/* creds of process who forced instantiation of super block */
 	const struct cred *creator_cred;
 	bool tmpfile;
+	wait_queue_head_t copyup_wq;
 };
 
 /* private information held for every overlayfs dentry */
@@ -39,6 +40,7 @@ struct ovl_entry {
 			u64 version;
 			const char *redirect;
 			bool opaque;
+			bool copying;
 		};
 		struct rcu_head rcu;
 	};

commit e7f52429b4a5b2e3224948d1737eb264c8f7e15f
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 17 06:34:53 2017 +0200

    ovl: check if upperdir fs supports O_TMPFILE
    
    This is needed for choosing between concurrent copyup
    using O_TMPFILE and legacy copyup using workdir+rename.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index d14bca1850d9..65f240001aa6 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -27,6 +27,7 @@ struct ovl_fs {
 	struct ovl_config config;
 	/* creds of process who forced instantiation of super block */
 	const struct cred *creator_cred;
+	bool tmpfile;
 };
 
 /* private information held for every overlayfs dentry */

commit a6c6065511411c57167a6cdae0c33263fb662b51
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:56 2016 +0100

    ovl: redirect on rename-dir
    
    Current code returns EXDEV when a directory would need to be copied up to
    move.  We could copy up the directory tree in this case, but there's
    another, simpler solution: point to old lower directory from moved upper
    directory.
    
    This is achieved with a "trusted.overlay.redirect" xattr storing the path
    relative to the root of the overlay.  After such attribute has been set,
    the directory can be moved without further actions required.
    
    This is a backward incompatible feature, old kernels won't be able to
    correctly mount an overlay containing redirected directories.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index eb29882b6a54..d14bca1850d9 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -13,6 +13,7 @@ struct ovl_config {
 	char *upperdir;
 	char *workdir;
 	bool default_permissions;
+	bool redirect_dir;
 };
 
 /* private information held for overlayfs's superblock */

commit 02b69b284cd7815239fabfe895bfef9a9eb5a3ce
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:56 2016 +0100

    ovl: lookup redirects
    
    If a directory has the "trusted.overlay.redirect" xattr, it means that the
    value of the xattr should be used to find the underlying directory on the
    next lower layer.
    
    The redirect may be relative or absolute.  Absolute redirects begin with a
    slash.
    
    A relative redirect means: instead of the current dentry's name use the
    value of the redirect to find the directory in the next lower
    layer. Relative redirects must not contain a slash.
    
    An absolute redirect means: look up the directory relative to the root of
    the overlay using the value of the redirect in the next lower layer.
    
    Redirects work on lower layers as well.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index b10745edfc93..eb29882b6a54 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -35,6 +35,7 @@ struct ovl_entry {
 	union {
 		struct {
 			u64 version;
+			const char *redirect;
 			bool opaque;
 		};
 		struct rcu_head rcu;

commit 6b2d5fe46fa8f4fc1c5262c73930b9a2a94db2e3
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:56 2016 +0100

    ovl: check namelen
    
    We already calculate f_namelen in statfs as the maximum of the name lengths
    provided by the filesystems taking part in the overlay.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index 3b7ba59ad27e..b10745edfc93 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -21,7 +21,7 @@ struct ovl_fs {
 	unsigned numlower;
 	struct vfsmount **lower_mnt;
 	struct dentry *workdir;
-	long lower_namelen;
+	long namelen;
 	/* pathnames of lower and upper dirs, for show_options */
 	struct ovl_config config;
 	/* creds of process who forced instantiation of super block */

commit bbb1e54dd53cf83863e856dd5518ce5e58791115
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 16 11:02:56 2016 +0100

    ovl: split super.c
    
    fs/overlayfs/super.c is the biggest of the overlayfs source files and it
    contains various utility functions as well as the rather complicated lookup
    code.  Split these parts out to separate files.
    
    Before:
    
     1446 fs/overlayfs/super.c
    
    After:
    
      919 fs/overlayfs/super.c
      267 fs/overlayfs/namei.c
      235 fs/overlayfs/util.c
       51 fs/overlayfs/ovl_entry.h
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
new file mode 100644
index 000000000000..3b7ba59ad27e
--- /dev/null
+++ b/fs/overlayfs/ovl_entry.h
@@ -0,0 +1,51 @@
+/*
+ *
+ * Copyright (C) 2011 Novell Inc.
+ * Copyright (C) 2016 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+struct ovl_config {
+	char *lowerdir;
+	char *upperdir;
+	char *workdir;
+	bool default_permissions;
+};
+
+/* private information held for overlayfs's superblock */
+struct ovl_fs {
+	struct vfsmount *upper_mnt;
+	unsigned numlower;
+	struct vfsmount **lower_mnt;
+	struct dentry *workdir;
+	long lower_namelen;
+	/* pathnames of lower and upper dirs, for show_options */
+	struct ovl_config config;
+	/* creds of process who forced instantiation of super block */
+	const struct cred *creator_cred;
+};
+
+/* private information held for every overlayfs dentry */
+struct ovl_entry {
+	struct dentry *__upperdentry;
+	struct ovl_dir_cache *cache;
+	union {
+		struct {
+			u64 version;
+			bool opaque;
+		};
+		struct rcu_head rcu;
+	};
+	unsigned numlower;
+	struct path lowerstack[];
+};
+
+struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
+
+static inline struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)
+{
+	return lockless_dereference(oe->__upperdentry);
+}
