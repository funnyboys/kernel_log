commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
index ac341e19e530..6565fdc2d4ca 100644
--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* PKCS#7 crypto data parser internal definitions
  *
  * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #include <linux/oid_registry.h>

commit 03bb79315ddc8972b1af71539799450acbc1be4f
Author: David Howells <dhowells@redhat.com>
Date:   Mon Apr 3 16:07:25 2017 +0100

    PKCS#7: Handle blacklisted certificates
    
    PKCS#7: Handle certificates that are blacklisted when verifying the chain
    of trust on the signatures on a PKCS#7 message.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
index f4e81074f5e0..ac341e19e530 100644
--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -23,6 +23,7 @@ struct pkcs7_signed_info {
 	struct x509_certificate *signer; /* Signing certificate (in msg->certs) */
 	unsigned	index;
 	bool		unsupported_crypto;	/* T if not usable due to missing crypto */
+	bool		blacklisted;
 
 	/* Message digest - the digest of the Content Data (or NULL) */
 	const void	*msgdigest;

commit bda850cd214e90b1be0cc25bc48c4f6ac53eb543
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:24 2016 +0100

    PKCS#7: Make trust determination dependent on contents of trust keyring
    
    Make the determination of the trustworthiness of a key dependent on whether
    a key that can verify it is present in the supplied ring of trusted keys
    rather than whether or not the verifying key has KEY_FLAG_TRUSTED set.
    
    verify_pkcs7_signature() will return -ENOKEY if the PKCS#7 message trust
    chain cannot be verified.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
index d5eec31e95b6..f4e81074f5e0 100644
--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -22,7 +22,6 @@ struct pkcs7_signed_info {
 	struct pkcs7_signed_info *next;
 	struct x509_certificate *signer; /* Signing certificate (in msg->certs) */
 	unsigned	index;
-	bool		trusted;
 	bool		unsupported_crypto;	/* T if not usable due to missing crypto */
 
 	/* Message digest - the digest of the Content Data (or NULL) */

commit 566a117a8b24e1ae2dfa817cf0c9eec092c783b5
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:13:33 2016 +0100

    PKCS#7: Make the signature a pointer rather than embedding it
    
    Point to the public_key_signature struct from the pkcs7_signed_info struct
    rather than embedding it.  This makes the code consistent with the X.509
    signature handling and makes it possible to have a common cleanup function.
    
    We also save a copy of the digest in the signature without sharing the
    memory with the crypto layer metadata.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
index a66b19ebcf47..d5eec31e95b6 100644
--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -41,19 +41,17 @@ struct pkcs7_signed_info {
 #define	sinfo_has_ms_statement_type	5
 	time64_t	signing_time;
 
-	/* Issuing cert serial number and issuer's name [PKCS#7 or CMS ver 1]
-	 * or issuing cert's SKID [CMS ver 3].
-	 */
-	struct asymmetric_key_id *signing_cert_id;
-
 	/* Message signature.
 	 *
 	 * This contains the generated digest of _either_ the Content Data or
 	 * the Authenticated Attributes [RFC2315 9.3].  If the latter, one of
 	 * the attributes contains the digest of the the Content Data within
 	 * it.
+	 *
+	 * THis also contains the issuing cert serial number and issuer's name
+	 * [PKCS#7 or CMS ver 1] or issuing cert's SKID [CMS ver 3].
 	 */
-	struct public_key_signature sig;
+	struct public_key_signature *sig;
 };
 
 struct pkcs7_message {

commit 99db44350672c8a5ee9a7b0a6f4cd6ff10136065
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 15:22:27 2015 +0100

    PKCS#7: Appropriately restrict authenticated attributes and content type
    
    A PKCS#7 or CMS message can have per-signature authenticated attributes
    that are digested as a lump and signed by the authorising key for that
    signature.  If such attributes exist, the content digest isn't itself
    signed, but rather it is included in a special authattr which then
    contributes to the signature.
    
    Further, we already require the master message content type to be
    pkcs7_signedData - but there's also a separate content type for the data
    itself within the SignedData object and this must be repeated inside the
    authattrs for each signer [RFC2315 9.2, RFC5652 11.1].
    
    We should really validate the authattrs if they exist or forbid them
    entirely as appropriate.  To this end:
    
     (1) Alter the PKCS#7 parser to reject any message that has more than one
         signature where at least one signature has authattrs and at least one
         that does not.
    
     (2) Validate authattrs if they are present and strongly restrict them.
         Only the following authattrs are permitted and all others are
         rejected:
    
         (a) contentType.  This is checked to be an OID that matches the
             content type in the SignedData object.
    
         (b) messageDigest.  This must match the crypto digest of the data.
    
         (c) signingTime.  If present, we check that this is a valid, parseable
             UTCTime or GeneralTime and that the date it encodes fits within
             the validity window of the matching X.509 cert.
    
         (d) S/MIME capabilities.  We don't check the contents.
    
         (e) Authenticode SP Opus Info.  We don't check the contents.
    
         (f) Authenticode Statement Type.  We don't check the contents.
    
         The message is rejected if (a) or (b) are missing.  If the message is
         an Authenticode type, the message is rejected if (e) is missing; if
         not Authenticode, the message is rejected if (d) - (f) are present.
    
         The S/MIME capabilities authattr (d) unfortunately has to be allowed
         to support kernels already signed by the pesign program.  This only
         affects kexec.  sign-file suppresses them (CMS_NOSMIMECAP).
    
         The message is also rejected if an authattr is given more than once or
         if it contains more than one element in its set of values.
    
     (3) Add a parameter to pkcs7_verify() to select one of the following
         restrictions and pass in the appropriate option from the callers:
    
         (*) VERIFYING_MODULE_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data and
             forbids authattrs.  sign-file sets CMS_NOATTR.  We could be more
             flexible and permit authattrs optionally, but only permit minimal
             content.
    
         (*) VERIFYING_FIRMWARE_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data and
             requires authattrs.  In future, this will require an attribute
             holding the target firmware name in addition to the minimal set.
    
         (*) VERIFYING_UNSPECIFIED_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data but
             allows either no authattrs or only permits the minimal set.
    
         (*) VERIFYING_KEXEC_PE_SIGNATURE
    
             This only supports the Authenticode SPC_INDIRECT_DATA content type
             and requires at least an SpcSpOpusInfo authattr in addition to the
             minimal set.  It also permits an SPC_STATEMENT_TYPE authattr (and
             an S/MIME capabilities authattr because the pesign program doesn't
             remove these).
    
         (*) VERIFYING_KEY_SIGNATURE
         (*) VERIFYING_KEY_SELF_SIGNATURE
    
             These are invalid in this context but are included for later use
             when limiting the use of X.509 certs.
    
     (4) The pkcs7_test key type is given a module parameter to select between
         the above options for testing purposes.  For example:
    
            echo 1 >/sys/module/pkcs7_test_key/parameters/usage
            keyctl padd pkcs7_test foo @s </tmp/stuff.pkcs7
    
         will attempt to check the signature on stuff.pkcs7 as if it contains a
         firmware blob (1 being VERIFYING_FIRMWARE_SIGNATURE).
    
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
index 790dd7cec82c..a66b19ebcf47 100644
--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -21,9 +21,9 @@
 struct pkcs7_signed_info {
 	struct pkcs7_signed_info *next;
 	struct x509_certificate *signer; /* Signing certificate (in msg->certs) */
-	unsigned index;
-	bool trusted;
-	bool unsupported_crypto;	/* T if not usable due to missing crypto */
+	unsigned	index;
+	bool		trusted;
+	bool		unsupported_crypto;	/* T if not usable due to missing crypto */
 
 	/* Message digest - the digest of the Content Data (or NULL) */
 	const void	*msgdigest;
@@ -32,6 +32,14 @@ struct pkcs7_signed_info {
 	/* Authenticated Attribute data (or NULL) */
 	unsigned	authattrs_len;
 	const void	*authattrs;
+	unsigned long	aa_set;
+#define	sinfo_has_content_type		0
+#define	sinfo_has_signing_time		1
+#define	sinfo_has_message_digest	2
+#define sinfo_has_smime_caps		3
+#define	sinfo_has_ms_opus_info		4
+#define	sinfo_has_ms_statement_type	5
+	time64_t	signing_time;
 
 	/* Issuing cert serial number and issuer's name [PKCS#7 or CMS ver 1]
 	 * or issuing cert's SKID [CMS ver 3].
@@ -53,6 +61,7 @@ struct pkcs7_message {
 	struct x509_certificate *crl;	/* Revocation list */
 	struct pkcs7_signed_info *signed_infos;
 	u8		version;	/* Version of cert (1 -> PKCS#7 or CMS; 3 -> CMS) */
+	bool		have_authattrs;	/* T if have authattrs */
 
 	/* Content Data (or NULL) */
 	enum OID	data_type;	/* Type of Data */

commit 60d65cacd7c2d84a6dcad69bcb57bbf0220c8643
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 20 21:16:33 2015 +0100

    PKCS#7: Support CMS messages also [RFC5652]
    
    Since CMS is an evolution of PKCS#7, with much of the ASN.1 being
    compatible, add support for CMS signed-data messages also [RFC5652 sec 5].
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-By: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
index efc7dc9b8f9c..790dd7cec82c 100644
--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -33,7 +33,9 @@ struct pkcs7_signed_info {
 	unsigned	authattrs_len;
 	const void	*authattrs;
 
-	/* Issuing cert serial number and issuer's name */
+	/* Issuing cert serial number and issuer's name [PKCS#7 or CMS ver 1]
+	 * or issuing cert's SKID [CMS ver 3].
+	 */
 	struct asymmetric_key_id *signing_cert_id;
 
 	/* Message signature.
@@ -50,6 +52,7 @@ struct pkcs7_message {
 	struct x509_certificate *certs;	/* Certificate list */
 	struct x509_certificate *crl;	/* Revocation list */
 	struct pkcs7_signed_info *signed_infos;
+	u8		version;	/* Version of cert (1 -> PKCS#7 or CMS; 3 -> CMS) */
 
 	/* Content Data (or NULL) */
 	enum OID	data_type;	/* Type of Data */

commit 41559420003cfe99522257dded7793192c77b4e9
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:15 2014 +0100

    PKCS#7: Better handling of unsupported crypto
    
    Provide better handling of unsupported crypto when verifying a PKCS#7 message.
    If we can't bridge the gap between a pair of X.509 certs or between a signed
    info block and an X.509 cert because it involves some crypto we don't support,
    that's not necessarily the end of the world as there may be other ways points
    at which we can intersect with a ring of trusted keys.
    
    Instead, only produce ENOPKG immediately if all the signed info blocks in a
    PKCS#7 message require unsupported crypto to bridge to the first X.509 cert.
    Otherwise, we defer the generation of ENOPKG until we get ENOKEY during trust
    validation.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
index 91949f92bc72..efc7dc9b8f9c 100644
--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -23,6 +23,7 @@ struct pkcs7_signed_info {
 	struct x509_certificate *signer; /* Signing certificate (in msg->certs) */
 	unsigned index;
 	bool trusted;
+	bool unsupported_crypto;	/* T if not usable due to missing crypto */
 
 	/* Message digest - the digest of the Content Data (or NULL) */
 	const void	*msgdigest;

commit 46963b774d441c833afc1535f6d84b3df2a94204
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:13 2014 +0100

    KEYS: Overhaul key identification when searching for asymmetric keys
    
    Make use of the new match string preparsing to overhaul key identification
    when searching for asymmetric keys.  The following changes are made:
    
     (1) Use the previously created asymmetric_key_id struct to hold the following
         key IDs derived from the X.509 certificate or PKCS#7 message:
    
            id: serial number + issuer
            skid: subjKeyId + subject
            authority: authKeyId + issuer
    
     (2) Replace the hex fingerprint attached to key->type_data[1] with an
         asymmetric_key_ids struct containing the id and the skid (if present).
    
     (3) Make the asymmetric_type match data preparse select one of two searches:
    
         (a) An iterative search for the key ID given if prefixed with "id:".  The
             prefix is expected to be followed by a hex string giving the ID to
             search for.  The criterion key ID is checked against all key IDs
             recorded on the key.
    
         (b) A direct search if the key ID is not prefixed with "id:".  This will
             look for an exact match on the key description.
    
     (4) Make x509_request_asymmetric_key() take a key ID.  This is then converted
         into "id:<hex>" and passed into keyring_search() where match preparsing
         will turn it back into a binary ID.
    
     (5) X.509 certificate verification then takes the authority key ID and looks
         up a key that matches it to find the public key for the certificate
         signature.
    
     (6) PKCS#7 certificate verification then takes the id key ID and looks up a
         key that matches it to find the public key for the signed information
         block signature.
    
    Additional changes:
    
     (1) Multiple subjKeyId and authKeyId values on an X.509 certificate cause the
         cert to be rejected with -EBADMSG.
    
     (2) The 'fingerprint' ID is gone.  This was primarily intended to convey PGP
         public key fingerprints.  If PGP is supported in future, this should
         generate a key ID that carries the fingerprint.
    
     (3) Th ca_keyid= kernel command line option is now converted to a key ID and
         used to match the authority key ID.  Possibly this should only match the
         actual authKeyId part and not the issuer as well.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
index d25f4d15370f..91949f92bc72 100644
--- a/crypto/asymmetric_keys/pkcs7_parser.h
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -33,10 +33,7 @@ struct pkcs7_signed_info {
 	const void	*authattrs;
 
 	/* Issuing cert serial number and issuer's name */
-	const void	*raw_serial;
-	unsigned	raw_serial_size;
-	unsigned	raw_issuer_size;
-	const void	*raw_issuer;
+	struct asymmetric_key_id *signing_cert_id;
 
 	/* Message signature.
 	 *

commit 2e3fadbf730fd0d13c891d5e555af3e7f39ca3f4
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 1 16:40:19 2014 +0100

    PKCS#7: Implement a parser [RFC 2315]
    
    Implement a parser for a PKCS#7 signed-data message as described in part of
    RFC 2315.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/crypto/asymmetric_keys/pkcs7_parser.h b/crypto/asymmetric_keys/pkcs7_parser.h
new file mode 100644
index 000000000000..d25f4d15370f
--- /dev/null
+++ b/crypto/asymmetric_keys/pkcs7_parser.h
@@ -0,0 +1,61 @@
+/* PKCS#7 crypto data parser internal definitions
+ *
+ * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#include <linux/oid_registry.h>
+#include <crypto/pkcs7.h>
+#include "x509_parser.h"
+
+#define kenter(FMT, ...) \
+	pr_devel("==> %s("FMT")\n", __func__, ##__VA_ARGS__)
+#define kleave(FMT, ...) \
+	pr_devel("<== %s()"FMT"\n", __func__, ##__VA_ARGS__)
+
+struct pkcs7_signed_info {
+	struct pkcs7_signed_info *next;
+	struct x509_certificate *signer; /* Signing certificate (in msg->certs) */
+	unsigned index;
+	bool trusted;
+
+	/* Message digest - the digest of the Content Data (or NULL) */
+	const void	*msgdigest;
+	unsigned	msgdigest_len;
+
+	/* Authenticated Attribute data (or NULL) */
+	unsigned	authattrs_len;
+	const void	*authattrs;
+
+	/* Issuing cert serial number and issuer's name */
+	const void	*raw_serial;
+	unsigned	raw_serial_size;
+	unsigned	raw_issuer_size;
+	const void	*raw_issuer;
+
+	/* Message signature.
+	 *
+	 * This contains the generated digest of _either_ the Content Data or
+	 * the Authenticated Attributes [RFC2315 9.3].  If the latter, one of
+	 * the attributes contains the digest of the the Content Data within
+	 * it.
+	 */
+	struct public_key_signature sig;
+};
+
+struct pkcs7_message {
+	struct x509_certificate *certs;	/* Certificate list */
+	struct x509_certificate *crl;	/* Revocation list */
+	struct pkcs7_signed_info *signed_infos;
+
+	/* Content Data (or NULL) */
+	enum OID	data_type;	/* Type of Data */
+	size_t		data_len;	/* Length of Data */
+	size_t		data_hdrlen;	/* Length of Data ASN.1 header */
+	const void	*data;		/* Content Data (or 0) */
+};
