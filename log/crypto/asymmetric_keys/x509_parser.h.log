commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index e373e7483812..c233f136fb35 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* X.509 certificate parser internal definitions
  *
  * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #include <linux/time.h>

commit 436529562df2748fd9918f578205b22cf8ced277
Author: David Howells <dhowells@redhat.com>
Date:   Mon Apr 3 16:07:25 2017 +0100

    X.509: Allow X.509 certs to be blacklisted
    
    Allow X.509 certs to be blacklisted based on their TBSCertificate hash.
    This is convenient since we have to determine this anyway to be able to
    check the signature on an X.509 certificate.  This is also what UEFI uses
    in its blacklist.
    
    If a certificate built into the kernel is blacklisted, something like the
    following might then be seen during boot:
    
            X.509: Cert 123412341234c55c1dcc601ab8e172917706aa32fb5eaf826813547fdf02dd46 is blacklisted
            Problem loading in-kernel X.509 certificate (-129)
    
    where the hex string shown is the blacklisted hash.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 05eef1c68881..e373e7483812 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -42,6 +42,7 @@ struct x509_certificate {
 	bool		self_signed;		/* T if self-signed (check unsupported_sig too) */
 	bool		unsupported_key;	/* T if key uses unsupported crypto */
 	bool		unsupported_sig;	/* T if signature uses unsupported crypto */
+	bool		blacklisted;
 };
 
 /*

commit a511e1af8b12f44c6e55786c463c9f093c214fb6
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:26 2016 +0100

    KEYS: Move the point of trust determination to __key_link()
    
    Move the point at which a key is determined to be trustworthy to
    __key_link() so that we use the contents of the keyring being linked in to
    to determine whether the key being linked in is trusted or not.
    
    What is 'trusted' then becomes a matter of what's in the keyring.
    
    Currently, the test is done when the key is parsed, but given that at that
    point we can only sensibly refer to the contents of the system trusted
    keyring, we can only use that as the basis for working out the
    trustworthiness of a new key.
    
    With this change, a trusted keyring is a set of keys that once the
    trusted-only flag is set cannot be added to except by verification through
    one of the contained keys.
    
    Further, adding a key into a trusted keyring, whilst it might grant
    trustworthiness in the context of that keyring, does not automatically
    grant trustworthiness in the context of a second keyring to which it could
    be secondarily linked.
    
    To accomplish this, the authentication data associated with the key source
    must now be retained.  For an X.509 cert, this means the contents of the
    AuthorityKeyIdentifier and the signature data.
    
    
    If system keyrings are disabled then restrict_link_by_builtin_trusted()
    resolves to restrict_link_reject().  The integrity digital signature code
    still works correctly with this as it was previously using
    KEY_FLAG_TRUSTED_ONLY, which doesn't permit anything to be added if there
    is no system keyring against which trust can be determined.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 7a802b09a509..05eef1c68881 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -58,9 +58,3 @@ extern int x509_decode_time(time64_t *_t,  size_t hdrlen,
  */
 extern int x509_get_sig_params(struct x509_certificate *cert);
 extern int x509_check_for_self_signed(struct x509_certificate *cert);
-
-/*
- * public_key_trust.c
- */
-extern int x509_validate_trust(struct x509_certificate *cert,
-			       struct key *trust_keyring);

commit cfb664ff2b71fbbdc438b8e6db2a1412440432a2
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:26 2016 +0100

    X.509: Move the trust validation code out to its own file
    
    Move the X.509 trust validation code out to its own file so that it can be
    generalised.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 05eef1c68881..7a802b09a509 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -58,3 +58,9 @@ extern int x509_decode_time(time64_t *_t,  size_t hdrlen,
  */
 extern int x509_get_sig_params(struct x509_certificate *cert);
 extern int x509_check_for_self_signed(struct x509_certificate *cert);
+
+/*
+ * public_key_trust.c
+ */
+extern int x509_validate_trust(struct x509_certificate *cert,
+			       struct key *trust_keyring);

commit bda850cd214e90b1be0cc25bc48c4f6ac53eb543
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:24 2016 +0100

    PKCS#7: Make trust determination dependent on contents of trust keyring
    
    Make the determination of the trustworthiness of a key dependent on whether
    a key that can verify it is present in the supplied ring of trusted keys
    rather than whether or not the verifying key has KEY_FLAG_TRUSTED set.
    
    verify_pkcs7_signature() will return -ENOKEY if the PKCS#7 message trust
    chain cannot be verified.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index f24f4d808e7f..05eef1c68881 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -39,7 +39,6 @@ struct x509_certificate {
 	unsigned	index;
 	bool		seen;			/* Infinite recursion prevention */
 	bool		verified;
-	bool		trusted;
 	bool		self_signed;		/* T if self-signed (check unsupported_sig too) */
 	bool		unsupported_key;	/* T if key uses unsupported crypto */
 	bool		unsupported_sig;	/* T if signature uses unsupported crypto */

commit 6c2dc5ae4ab719a61d19e8cef082226410b04ff8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:13:34 2016 +0100

    X.509: Extract signature digest and make self-signed cert checks earlier
    
    Extract the signature digest for an X.509 certificate earlier, at the end
    of x509_cert_parse() rather than leaving it to the callers thereof since it
    has to be called anyway.
    
    Further, immediately after that, check the signature on self-signed
    certificates, also rather in the callers of x509_cert_parse().
    
    We note in the x509_certificate struct the following bits of information:
    
     (1) Whether the signature is self-signed (even if we can't check the
         signature due to missing crypto).
    
     (2) Whether the key held in the certificate needs unsupported crypto to be
         used.  We may get a PKCS#7 message with X.509 certs that we can't make
         use of - we just ignore them and give ENOPKG at the end it we couldn't
         verify anything if at least one of these unusable certs are in the
         chain of trust.
    
     (3) Whether the signature held in the certificate needs unsupported crypto
         to be checked.  We can still use the key held in this certificate,
         even if we can't check the signature on it - if it is held in the
         system trusted keyring, for instance.  We just can't add it to a ring
         of trusted keys or follow it further up the chain of trust.
    
    Making these checks earlier allows x509_check_signature() to be removed and
    replaced with direct calls to public_key_verify_signature().
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 26a4d83e4e6d..f24f4d808e7f 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -40,7 +40,9 @@ struct x509_certificate {
 	bool		seen;			/* Infinite recursion prevention */
 	bool		verified;
 	bool		trusted;
-	bool		unsupported_crypto;	/* T if can't be verified due to missing crypto */
+	bool		self_signed;		/* T if self-signed (check unsupported_sig too) */
+	bool		unsupported_key;	/* T if key uses unsupported crypto */
+	bool		unsupported_sig;	/* T if signature uses unsupported crypto */
 };
 
 /*
@@ -56,5 +58,4 @@ extern int x509_decode_time(time64_t *_t,  size_t hdrlen,
  * x509_public_key.c
  */
 extern int x509_get_sig_params(struct x509_certificate *cert);
-extern int x509_check_signature(const struct public_key *pub,
-				struct x509_certificate *cert);
+extern int x509_check_for_self_signed(struct x509_certificate *cert);

commit 77d0910d153a7946df17cc15d3f423e534345f65
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:13:33 2016 +0100

    X.509: Retain the key verification data
    
    Retain the key verification data (ie. the struct public_key_signature)
    including the digest and the key identifiers.
    
    Note that this means that we need to take a separate copy of the digest in
    x509_get_sig_params() rather than lumping it in with the crypto layer data.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index dbeed6018e63..26a4d83e4e6d 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -17,13 +17,11 @@ struct x509_certificate {
 	struct x509_certificate *next;
 	struct x509_certificate *signer;	/* Certificate that signed this one */
 	struct public_key *pub;			/* Public key details */
-	struct public_key_signature sig;	/* Signature parameters */
+	struct public_key_signature *sig;	/* Signature parameters */
 	char		*issuer;		/* Name of certificate issuer */
 	char		*subject;		/* Name of certificate subject */
 	struct asymmetric_key_id *id;		/* Issuer + Serial number */
 	struct asymmetric_key_id *skid;		/* Subject + subjectKeyId (optional) */
-	struct asymmetric_key_id *akid_id;	/* CA AuthKeyId matching ->id (optional) */
-	struct asymmetric_key_id *akid_skid;	/* CA AuthKeyId matching ->skid (optional) */
 	time64_t	valid_from;
 	time64_t	valid_to;
 	const void	*tbs;			/* Signed data */

commit 146aa8b1453bd8f1ff2304ffb71b4ee0eb9acdcc
Author: David Howells <dhowells@redhat.com>
Date:   Wed Oct 21 14:04:48 2015 +0100

    KEYS: Merge the type-specific data with the payload data
    
    Merge the type-specific data with the payload data into one four-word chunk
    as it seems pointless to keep them separate.
    
    Use user_key_payload() for accessing the payloads of overloaded
    user-defined keys.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-cifs@vger.kernel.org
    cc: ecryptfs@vger.kernel.org
    cc: linux-ext4@vger.kernel.org
    cc: linux-f2fs-devel@lists.sourceforge.net
    cc: linux-nfs@vger.kernel.org
    cc: ceph-devel@vger.kernel.org
    cc: linux-ima-devel@lists.sourceforge.net

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 1de01eaec884..dbeed6018e63 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -11,6 +11,7 @@
 
 #include <linux/time.h>
 #include <crypto/public_key.h>
+#include <keys/asymmetric-type.h>
 
 struct x509_certificate {
 	struct x509_certificate *next;

commit fd19a3d195be23e8d9d0d66576b96ea25eea8323
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jul 29 16:58:32 2015 +0100

    PKCS#7: Improve and export the X.509 ASN.1 time object decoder
    
    Make the X.509 ASN.1 time object decoder fill in a time64_t rather than a
    struct tm to make comparison easier (unfortunately, this makes readable
    display less easy) and export it so that it can be used by the PKCS#7 code
    too.
    
    Further, tighten up its parsing to reject invalid dates (eg. weird
    characters, non-existent hour numbers) and unsupported dates (eg. timezones
    other than 'Z' or dates earlier than 1970).
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index dcdb5c94f514..1de01eaec884 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -23,8 +23,8 @@ struct x509_certificate {
 	struct asymmetric_key_id *skid;		/* Subject + subjectKeyId (optional) */
 	struct asymmetric_key_id *akid_id;	/* CA AuthKeyId matching ->id (optional) */
 	struct asymmetric_key_id *akid_skid;	/* CA AuthKeyId matching ->skid (optional) */
-	struct tm	valid_from;
-	struct tm	valid_to;
+	time64_t	valid_from;
+	time64_t	valid_to;
 	const void	*tbs;			/* Signed data */
 	unsigned	tbs_size;		/* Size of signed data */
 	unsigned	raw_sig_size;		/* Size of sigature */
@@ -49,6 +49,9 @@ struct x509_certificate {
  */
 extern void x509_free_certificate(struct x509_certificate *cert);
 extern struct x509_certificate *x509_cert_parse(const void *data, size_t datalen);
+extern int x509_decode_time(time64_t *_t,  size_t hdrlen,
+			    unsigned char tag,
+			    const unsigned char *value, size_t vlen);
 
 /*
  * x509_public_key.c

commit b92e6570a992c7d793a209db282f68159368201c
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 20 21:16:26 2015 +0100

    X.509: Extract both parts of the AuthorityKeyIdentifier
    
    Extract both parts of the AuthorityKeyIdentifier, not just the keyIdentifier,
    as the second part can be used to match X.509 certificates by issuer and
    serialNumber.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 3dfe6b5d6f0b..dcdb5c94f514 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -19,9 +19,10 @@ struct x509_certificate {
 	struct public_key_signature sig;	/* Signature parameters */
 	char		*issuer;		/* Name of certificate issuer */
 	char		*subject;		/* Name of certificate subject */
-	struct asymmetric_key_id *id;		/* Serial number + issuer */
+	struct asymmetric_key_id *id;		/* Issuer + Serial number */
 	struct asymmetric_key_id *skid;		/* Subject + subjectKeyId (optional) */
-	struct asymmetric_key_id *authority;	/* Authority key identifier (optional) */
+	struct asymmetric_key_id *akid_id;	/* CA AuthKeyId matching ->id (optional) */
+	struct asymmetric_key_id *akid_skid;	/* CA AuthKeyId matching ->skid (optional) */
 	struct tm	valid_from;
 	struct tm	valid_to;
 	const void	*tbs;			/* Signed data */

commit 8dd609805b87923a700a2fad646390a58013cdb9
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Mon Oct 6 16:52:12 2014 +0100

    KEYS: use swapped SKID for performing partial matching
    
    Earlier KEYS code used pure subject key identifiers (fingerprint)
    for searching keys. Latest merged code removed that and broke
    compatibility with integrity subsytem signatures and original
    format of module signatures.
    
    This patch returns back partial matching on SKID.
    
    Reported-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 3f0f0f081621..3dfe6b5d6f0b 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -19,9 +19,9 @@ struct x509_certificate {
 	struct public_key_signature sig;	/* Signature parameters */
 	char		*issuer;		/* Name of certificate issuer */
 	char		*subject;		/* Name of certificate subject */
-	struct asymmetric_key_id *id;		/* Issuer + serial number */
-	struct asymmetric_key_id *skid;		/* Subject key identifier */
-	struct asymmetric_key_id *authority;	/* Authority key identifier */
+	struct asymmetric_key_id *id;		/* Serial number + issuer */
+	struct asymmetric_key_id *skid;		/* Subject + subjectKeyId (optional) */
+	struct asymmetric_key_id *authority;	/* Authority key identifier (optional) */
 	struct tm	valid_from;
 	struct tm	valid_to;
 	const void	*tbs;			/* Signed data */

commit dd2f6c4481debfa389c1f2b2b1d5bd6449c42611
Author: David Howells <dhowells@redhat.com>
Date:   Fri Oct 3 16:17:02 2014 +0100

    X.509: If available, use the raw subjKeyId to form the key description
    
    Module signing matches keys by comparing against the key description exactly.
    However, the way the key description gets constructed got changed to be
    composed of the subject name plus the certificate serial number instead of the
    subject name and the subjectKeyId.  I changed this to avoid problems with
    certificates that don't *have* a subjectKeyId.
    
    Instead, if available, use the raw subjectKeyId to form the key description
    and only use the serial number if the subjectKeyId doesn't exist.
    
    Reported-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 4e1a384901ed..3f0f0f081621 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -34,6 +34,8 @@ struct x509_certificate {
 	const void	*raw_issuer;		/* Raw issuer name in ASN.1 */
 	const void	*raw_subject;		/* Raw subject name in ASN.1 */
 	unsigned	raw_subject_size;
+	unsigned	raw_skid_size;
+	const void	*raw_skid;		/* Raw subjectKeyId in ASN.1 */
 	unsigned	index;
 	bool		seen;			/* Infinite recursion prevention */
 	bool		verified;

commit 41559420003cfe99522257dded7793192c77b4e9
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:15 2014 +0100

    PKCS#7: Better handling of unsupported crypto
    
    Provide better handling of unsupported crypto when verifying a PKCS#7 message.
    If we can't bridge the gap between a pair of X.509 certs or between a signed
    info block and an X.509 cert because it involves some crypto we don't support,
    that's not necessarily the end of the world as there may be other ways points
    at which we can intersect with a ring of trusted keys.
    
    Instead, only produce ENOPKG immediately if all the signed info blocks in a
    PKCS#7 message require unsupported crypto to bridge to the first X.509 cert.
    Otherwise, we defer the generation of ENOPKG until we get ENOKEY during trust
    validation.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 0e8d59b010fb..4e1a384901ed 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -38,6 +38,7 @@ struct x509_certificate {
 	bool		seen;			/* Infinite recursion prevention */
 	bool		verified;
 	bool		trusted;
+	bool		unsupported_crypto;	/* T if can't be verified due to missing crypto */
 };
 
 /*

commit 46963b774d441c833afc1535f6d84b3df2a94204
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:13 2014 +0100

    KEYS: Overhaul key identification when searching for asymmetric keys
    
    Make use of the new match string preparsing to overhaul key identification
    when searching for asymmetric keys.  The following changes are made:
    
     (1) Use the previously created asymmetric_key_id struct to hold the following
         key IDs derived from the X.509 certificate or PKCS#7 message:
    
            id: serial number + issuer
            skid: subjKeyId + subject
            authority: authKeyId + issuer
    
     (2) Replace the hex fingerprint attached to key->type_data[1] with an
         asymmetric_key_ids struct containing the id and the skid (if present).
    
     (3) Make the asymmetric_type match data preparse select one of two searches:
    
         (a) An iterative search for the key ID given if prefixed with "id:".  The
             prefix is expected to be followed by a hex string giving the ID to
             search for.  The criterion key ID is checked against all key IDs
             recorded on the key.
    
         (b) A direct search if the key ID is not prefixed with "id:".  This will
             look for an exact match on the key description.
    
     (4) Make x509_request_asymmetric_key() take a key ID.  This is then converted
         into "id:<hex>" and passed into keyring_search() where match preparsing
         will turn it back into a binary ID.
    
     (5) X.509 certificate verification then takes the authority key ID and looks
         up a key that matches it to find the public key for the certificate
         signature.
    
     (6) PKCS#7 certificate verification then takes the id key ID and looks up a
         key that matches it to find the public key for the signed information
         block signature.
    
    Additional changes:
    
     (1) Multiple subjKeyId and authKeyId values on an X.509 certificate cause the
         cert to be rejected with -EBADMSG.
    
     (2) The 'fingerprint' ID is gone.  This was primarily intended to convey PGP
         public key fingerprints.  If PGP is supported in future, this should
         generate a key ID that carries the fingerprint.
    
     (3) Th ca_keyid= kernel command line option is now converted to a key ID and
         used to match the authority key ID.  Possibly this should only match the
         actual authKeyId part and not the issuer as well.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 1b76f207c1f3..0e8d59b010fb 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -19,8 +19,9 @@ struct x509_certificate {
 	struct public_key_signature sig;	/* Signature parameters */
 	char		*issuer;		/* Name of certificate issuer */
 	char		*subject;		/* Name of certificate subject */
-	char		*fingerprint;		/* Key fingerprint as hex */
-	char		*authority;		/* Authority key fingerprint as hex */
+	struct asymmetric_key_id *id;		/* Issuer + serial number */
+	struct asymmetric_key_id *skid;		/* Subject key identifier */
+	struct asymmetric_key_id *authority;	/* Authority key identifier */
 	struct tm	valid_from;
 	struct tm	valid_to;
 	const void	*tbs;			/* Signed data */

commit 84aabd46bf8791d0c6fc8db4dc65d45093f70aab
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 1 16:40:19 2014 +0100

    X.509: Add bits needed for PKCS#7
    
    PKCS#7 validation requires access to the serial number and the raw names in an
    X.509 certificate.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Josh Boyer <jwboyer@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 87d9cc26f630..1b76f207c1f3 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -14,7 +14,9 @@
 
 struct x509_certificate {
 	struct x509_certificate *next;
+	struct x509_certificate *signer;	/* Certificate that signed this one */
 	struct public_key *pub;			/* Public key details */
+	struct public_key_signature sig;	/* Signature parameters */
 	char		*issuer;		/* Name of certificate issuer */
 	char		*subject;		/* Name of certificate subject */
 	char		*fingerprint;		/* Key fingerprint as hex */
@@ -25,7 +27,16 @@ struct x509_certificate {
 	unsigned	tbs_size;		/* Size of signed data */
 	unsigned	raw_sig_size;		/* Size of sigature */
 	const void	*raw_sig;		/* Signature data */
-	struct public_key_signature sig;	/* Signature parameters */
+	const void	*raw_serial;		/* Raw serial number in ASN.1 */
+	unsigned	raw_serial_size;
+	unsigned	raw_issuer_size;
+	const void	*raw_issuer;		/* Raw issuer name in ASN.1 */
+	const void	*raw_subject;		/* Raw subject name in ASN.1 */
+	unsigned	raw_subject_size;
+	unsigned	index;
+	bool		seen;			/* Infinite recursion prevention */
+	bool		verified;
+	bool		trusted;
 };
 
 /*

commit c7c8bb237fdbff932b5e431aebee5ce862ea07d1
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Thu Apr 25 10:43:56 2013 +0300

    ima: provide support for arbitrary hash algorithms
    
    In preparation of supporting more hash algorithms with larger hash sizes
    needed for signature verification, this patch replaces the 20 byte sized
    digest, with a more flexible structure.  The new structure includes the
    hash algorithm, digest size, and digest.
    
    Changelog:
    - recalculate filedata hash for the measurement list, if the signature
      hash digest size is greater than 20 bytes.
    - use generic HASH_ALGO_
    - make ima_calc_file_hash static
    - scripts lindent and checkpatch fixes
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 04c81bd0f3f2..87d9cc26f630 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -21,8 +21,6 @@ struct x509_certificate {
 	char		*authority;		/* Authority key fingerprint as hex */
 	struct tm	valid_from;
 	struct tm	valid_to;
-	enum pkey_algo	pkey_algo : 8;		/* Public key algorithm */
-	enum hash_algo sig_hash_algo : 8;	/* Signature hash algorithm */
 	const void	*tbs;			/* Signed data */
 	unsigned	tbs_size;		/* Size of signed data */
 	unsigned	raw_sig_size;		/* Size of sigature */

commit 3fe78ca2fb1d61ea598e63fcbf38aec76b36b3a8
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Mon May 6 15:58:15 2013 +0300

    keys: change asymmetric keys to use common hash definitions
    
    This patch makes use of the newly defined common hash algorithm info,
    replacing, for example, PKEY_HASH with HASH_ALGO.
    
    Changelog:
    - Lindent fixes - Mimi
    
    CC: David Howells <dhowells@redhat.com>
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 87d9cc26f630..04c81bd0f3f2 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -21,6 +21,8 @@ struct x509_certificate {
 	char		*authority;		/* Authority key fingerprint as hex */
 	struct tm	valid_from;
 	struct tm	valid_to;
+	enum pkey_algo	pkey_algo : 8;		/* Public key algorithm */
+	enum hash_algo sig_hash_algo : 8;	/* Signature hash algorithm */
 	const void	*tbs;			/* Signed data */
 	unsigned	tbs_size;		/* Size of signed data */
 	unsigned	raw_sig_size;		/* Size of sigature */

commit b426beb6eeb0c81aeaa419f7444064abc9cb04ae
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:18:02 2013 +0100

    X.509: Embed public_key_signature struct and create filler function
    
    Embed a public_key_signature struct in struct x509_certificate, eliminating
    now unnecessary fields, and split x509_check_signature() to create a filler
    function for it that attaches a digest of the signed data and an MPI that
    represents the signature data.  x509_free_certificate() is then modified to
    deal with these.
    
    Whilst we're at it, export both x509_check_signature() and the new
    x509_get_sig_params().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Josh Boyer <jwboyer@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 2d0118214770..87d9cc26f630 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -21,12 +21,11 @@ struct x509_certificate {
 	char		*authority;		/* Authority key fingerprint as hex */
 	struct tm	valid_from;
 	struct tm	valid_to;
-	enum pkey_algo	sig_pkey_algo : 8;	/* Signature public key algorithm */
-	enum pkey_hash_algo sig_hash_algo : 8;	/* Signature hash algorithm */
 	const void	*tbs;			/* Signed data */
-	size_t		tbs_size;		/* Size of signed data */
-	const void	*sig;			/* Signature data */
-	size_t		sig_size;		/* Size of sigature */
+	unsigned	tbs_size;		/* Size of signed data */
+	unsigned	raw_sig_size;		/* Size of sigature */
+	const void	*raw_sig;		/* Signature data */
+	struct public_key_signature sig;	/* Signature parameters */
 };
 
 /*
@@ -34,3 +33,10 @@ struct x509_certificate {
  */
 extern void x509_free_certificate(struct x509_certificate *cert);
 extern struct x509_certificate *x509_cert_parse(const void *data, size_t datalen);
+
+/*
+ * x509_public_key.c
+ */
+extern int x509_get_sig_params(struct x509_certificate *cert);
+extern int x509_check_signature(const struct public_key *pub,
+				struct x509_certificate *cert);

commit 57be4a784bf58eb41784aa3431165b455cf7e9c6
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:16:34 2013 +0100

    X.509: struct x509_certificate needs struct tm declaring
    
    struct x509_certificate needs struct tm declaring by #inclusion of linux/time.h
    prior to its definition.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Josh Boyer <jwboyer@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index e583ad09e5a1..2d0118214770 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -9,6 +9,7 @@
  * 2 of the Licence, or (at your option) any later version.
  */
 
+#include <linux/time.h>
 #include <crypto/public_key.h>
 
 struct x509_certificate {

commit 67f7d60b3a08a3e3ec51c29c25767a9d9d0bd2b1
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:15:24 2013 +0100

    KEYS: Store public key algo ID in public_key struct
    
    Store public key algo ID in public_key struct for reference purposes.  This
    allows it to be removed from the x509_certificate struct and used to find a
    default in public_key_verify_signature().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Josh Boyer <jwboyer@redhat.com>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index f86dc5fcc4ad..e583ad09e5a1 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -20,7 +20,6 @@ struct x509_certificate {
 	char		*authority;		/* Authority key fingerprint as hex */
 	struct tm	valid_from;
 	struct tm	valid_to;
-	enum pkey_algo	pkey_algo : 8;		/* Public key algorithm */
 	enum pkey_algo	sig_pkey_algo : 8;	/* Signature public key algorithm */
 	enum pkey_hash_algo sig_hash_algo : 8;	/* Signature hash algorithm */
 	const void	*tbs;			/* Signed data */

commit a5752d11b3853fcdb48b303573dd39b09d05e500
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 14:36:16 2012 +0100

    MODSIGN: Fix 32-bit overflow in X.509 certificate validity date checking
    
    The current choice of lifetime for the autogenerated X.509 of 100 years,
    putting the validTo date in 2112, causes problems on 32-bit systems where a
    32-bit time_t wraps in 2106.  64-bit x86_64 systems seem to be unaffected.
    
    This can result in something like:
    
            Loading module verification certificates
            X.509: Cert 6e03943da0f3b015ba6ed7f5e0cac4fe48680994 has expired
            MODSIGN: Problem loading in-kernel X.509 certificate (-127)
    
    Or:
    
            X.509: Cert 6e03943da0f3b015ba6ed7f5e0cac4fe48680994 is not yet valid
            MODSIGN: Problem loading in-kernel X.509 certificate (-129)
    
    Instead of turning the dates into time_t values and comparing, turn the system
    clock and the ASN.1 dates into tm structs and compare those piecemeal instead.
    
    Reported-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Josh Boyer <jwboyer@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
index 635053f7e962..f86dc5fcc4ad 100644
--- a/crypto/asymmetric_keys/x509_parser.h
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -18,8 +18,8 @@ struct x509_certificate {
 	char		*subject;		/* Name of certificate subject */
 	char		*fingerprint;		/* Key fingerprint as hex */
 	char		*authority;		/* Authority key fingerprint as hex */
-	time_t		valid_from;
-	time_t		valid_to;
+	struct tm	valid_from;
+	struct tm	valid_to;
 	enum pkey_algo	pkey_algo : 8;		/* Public key algorithm */
 	enum pkey_algo	sig_pkey_algo : 8;	/* Signature public key algorithm */
 	enum pkey_hash_algo sig_hash_algo : 8;	/* Signature hash algorithm */

commit c26fd69fa00916a31a47f5f096fd7be924106df8
Author: David Howells <dhowells@redhat.com>
Date:   Mon Sep 24 17:11:48 2012 +0100

    X.509: Add a crypto key parser for binary (DER) X.509 certificates
    
    Add a crypto key parser for binary (DER) encoded X.509 certificates.  The
    certificate is parsed and, if possible, the signature is verified.
    
    An X.509 key can be added like this:
    
            # keyctl padd crypto bar @s </tmp/x509.cert
            15768135
    
    and displayed like this:
    
            # cat /proc/keys
            00f09a47 I--Q---     1 perm 39390000     0     0 asymmetri bar: X509.RSA e9fd6d08 []
    
    Note that this only works with binary certificates.  PEM encoded certificates
    are ignored by the parser.
    
    Note also that the X.509 key ID is not congruent with the PGP key ID, but for
    the moment, they will match.
    
    If a NULL or "" name is given to add_key(), then the parser will generate a key
    description from the CertificateSerialNumber and Name fields of the
    TBSCertificate:
    
            00aefc4e I--Q---     1 perm 39390000     0     0 asymmetri bfbc0cd76d050ea4:/C=GB/L=Cambridge/O=Red Hat/CN=kernel key: X509.RSA 0c688c7b []
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/crypto/asymmetric_keys/x509_parser.h b/crypto/asymmetric_keys/x509_parser.h
new file mode 100644
index 000000000000..635053f7e962
--- /dev/null
+++ b/crypto/asymmetric_keys/x509_parser.h
@@ -0,0 +1,36 @@
+/* X.509 certificate parser internal definitions
+ *
+ * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#include <crypto/public_key.h>
+
+struct x509_certificate {
+	struct x509_certificate *next;
+	struct public_key *pub;			/* Public key details */
+	char		*issuer;		/* Name of certificate issuer */
+	char		*subject;		/* Name of certificate subject */
+	char		*fingerprint;		/* Key fingerprint as hex */
+	char		*authority;		/* Authority key fingerprint as hex */
+	time_t		valid_from;
+	time_t		valid_to;
+	enum pkey_algo	pkey_algo : 8;		/* Public key algorithm */
+	enum pkey_algo	sig_pkey_algo : 8;	/* Signature public key algorithm */
+	enum pkey_hash_algo sig_hash_algo : 8;	/* Signature hash algorithm */
+	const void	*tbs;			/* Signed data */
+	size_t		tbs_size;		/* Size of signed data */
+	const void	*sig;			/* Signature data */
+	size_t		sig_size;		/* Size of sigature */
+};
+
+/*
+ * x509_cert_parser.c
+ */
+extern void x509_free_certificate(struct x509_certificate *cert);
+extern struct x509_certificate *x509_cert_parse(const void *data, size_t datalen);
