commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index 5b2f6a2b5585..b930d3bbf1af 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* Testing module to load key from trusted PKCS#7 message
  *
  * Copyright (C) 2014 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #define pr_fmt(fmt) "PKCS7key: "fmt

commit 817aef260037f33ee0f44c17fe341323d3aebd6d
Author: Yannik Sembritzki <yannik@sembritzki.me>
Date:   Thu Aug 16 14:05:10 2018 +0100

    Replace magic for trusting the secondary keyring with #define
    
    Replace the use of a magic number that indicates that verify_*_signature()
    should use the secondary keyring with a symbol.
    
    Signed-off-by: Yannik Sembritzki <yannik@sembritzki.me>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: keyrings@vger.kernel.org
    Cc: linux-security-module@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index e284d9cb9237..5b2f6a2b5585 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -63,7 +63,7 @@ static int pkcs7_preparse(struct key_preparsed_payload *prep)
 
 	return verify_pkcs7_signature(NULL, 0,
 				      prep->data, prep->datalen,
-				      (void *)1UL, usage,
+				      VERIFY_USE_SECONDARY_KEYRING, usage,
 				      pkcs7_view_content, prep);
 }
 

commit 1e684d3820d8f72d877c0adb521ae17c6fc9bc88
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 15 16:38:45 2017 +0000

    pkcs7: Set the module licence to prevent tainting
    
    Set the module licence to prevent the kernel from being tainted if loaded
    as a module.
    
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index 1063b644efcd..e284d9cb9237 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -19,6 +19,7 @@
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("PKCS#7 testing key type");
+MODULE_AUTHOR("Red Hat, Inc.");
 
 static unsigned pkcs7_usage;
 module_param_named(usage, pkcs7_usage, uint, S_IWUSR | S_IRUGO);

commit 3c8f2278716dc862c420d3d256a83ce30fd12e74
Author: David Howells <dhowells@redhat.com>
Date:   Wed May 11 14:31:55 2016 +0100

    KEYS: The PKCS#7 test key type should use the secondary keyring
    
    The PKCS#7 test key type should use the secondary keyring instead of the
    built-in keyring if available as the source of trustworthy keys.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index 3b92523882e5..1063b644efcd 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -62,7 +62,7 @@ static int pkcs7_preparse(struct key_preparsed_payload *prep)
 
 	return verify_pkcs7_signature(NULL, 0,
 				      prep->data, prep->datalen,
-				      NULL, usage,
+				      (void *)1UL, usage,
 				      pkcs7_view_content, prep);
 }
 

commit bda850cd214e90b1be0cc25bc48c4f6ac53eb543
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:24 2016 +0100

    PKCS#7: Make trust determination dependent on contents of trust keyring
    
    Make the determination of the trustworthiness of a key dependent on whether
    a key that can verify it is present in the supplied ring of trusted keys
    rather than whether or not the verifying key has KEY_FLAG_TRUSTED set.
    
    verify_pkcs7_signature() will return -ENOKEY if the PKCS#7 message trust
    chain cannot be verified.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index ab9bf5363ecd..3b92523882e5 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -62,7 +62,7 @@ static int pkcs7_preparse(struct key_preparsed_payload *prep)
 
 	return verify_pkcs7_signature(NULL, 0,
 				      prep->data, prep->datalen,
-				      NULL, -ENOKEY, usage,
+				      NULL, usage,
 				      pkcs7_view_content, prep);
 }
 

commit e68503bd6836ba765dc8e0ee77ea675fedc07e41
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:24 2016 +0100

    KEYS: Generalise system_verify_data() to provide access to internal content
    
    Generalise system_verify_data() to provide access to internal content
    through a callback.  This allows all the PKCS#7 stuff to be hidden inside
    this function and removed from the PE file parser and the PKCS#7 test key.
    
    If external content is not required, NULL should be passed as data to the
    function.  If the callback is not required, that can be set to NULL.
    
    The function is now called verify_pkcs7_signature() to contrast with
    verify_pefile_signature() and the definitions of both have been moved into
    linux/verification.h along with the key_being_used_for enum.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index e2d0edbbc71a..ab9bf5363ecd 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -13,12 +13,9 @@
 #include <linux/key.h>
 #include <linux/err.h>
 #include <linux/module.h>
+#include <linux/verification.h>
 #include <linux/key-type.h>
-#include <keys/asymmetric-type.h>
-#include <crypto/pkcs7.h>
 #include <keys/user-type.h>
-#include <keys/system_keyring.h>
-#include "pkcs7_parser.h"
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("PKCS#7 testing key type");
@@ -29,59 +26,46 @@ MODULE_PARM_DESC(pkcs7_usage,
 		 "Usage to specify when verifying the PKCS#7 message");
 
 /*
- * Preparse a PKCS#7 wrapped and validated data blob.
+ * Retrieve the PKCS#7 message content.
  */
-static int pkcs7_preparse(struct key_preparsed_payload *prep)
+static int pkcs7_view_content(void *ctx, const void *data, size_t len,
+			      size_t asn1hdrlen)
 {
-	enum key_being_used_for usage = pkcs7_usage;
-	struct pkcs7_message *pkcs7;
-	const void *data, *saved_prep_data;
-	size_t datalen, saved_prep_datalen;
-	bool trusted;
+	struct key_preparsed_payload *prep = ctx;
+	const void *saved_prep_data;
+	size_t saved_prep_datalen;
 	int ret;
 
-	kenter("");
-
-	if (usage >= NR__KEY_BEING_USED_FOR) {
-		pr_err("Invalid usage type %d\n", usage);
-		return -EINVAL;
-	}
-
 	saved_prep_data = prep->data;
 	saved_prep_datalen = prep->datalen;
-	pkcs7 = pkcs7_parse_message(saved_prep_data, saved_prep_datalen);
-	if (IS_ERR(pkcs7)) {
-		ret = PTR_ERR(pkcs7);
-		goto error;
-	}
-
-	ret = pkcs7_verify(pkcs7, usage);
-	if (ret < 0)
-		goto error_free;
-
-	ret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);
-	if (ret < 0)
-		goto error_free;
-	if (!trusted)
-		pr_warn("PKCS#7 message doesn't chain back to a trusted key\n");
-
-	ret = pkcs7_get_content_data(pkcs7, &data, &datalen, false);
-	if (ret < 0)
-		goto error_free;
-
 	prep->data = data;
-	prep->datalen = datalen;
+	prep->datalen = len;
+
 	ret = user_preparse(prep);
+
 	prep->data = saved_prep_data;
 	prep->datalen = saved_prep_datalen;
-
-error_free:
-	pkcs7_free_message(pkcs7);
-error:
-	kleave(" = %d", ret);
 	return ret;
 }
 
+/*
+ * Preparse a PKCS#7 wrapped and validated data blob.
+ */
+static int pkcs7_preparse(struct key_preparsed_payload *prep)
+{
+	enum key_being_used_for usage = pkcs7_usage;
+
+	if (usage >= NR__KEY_BEING_USED_FOR) {
+		pr_err("Invalid usage type %d\n", usage);
+		return -EINVAL;
+	}
+
+	return verify_pkcs7_signature(NULL, 0,
+				      prep->data, prep->datalen,
+				      NULL, -ENOKEY, usage,
+				      pkcs7_view_content, prep);
+}
+
 /*
  * user defined keys take an arbitrary string as the description and an
  * arbitrary blob of data as the payload

commit 772111ab01eace6a7e4cf821a4348cec64a97c92
Author: David Howells <dhowells@redhat.com>
Date:   Thu Aug 13 02:51:33 2015 +0100

    PKCS#7: Add MODULE_LICENSE() to test module
    
    Add a MODULE_LICENSE() line to the PKCS#7 test key module to fix this
    warning:
    
            WARNING: modpost: missing MODULE_LICENSE() in
            crypto/asymmetric_keys/pkcs7_test_key.o
    
    Whilst we're at it, also add a module description.
    
    Reported-by: James Morris <jmorris@namei.org>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index 10d34dbd00b9..e2d0edbbc71a 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -20,6 +20,9 @@
 #include <keys/system_keyring.h>
 #include "pkcs7_parser.h"
 
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PKCS#7 testing key type");
+
 static unsigned pkcs7_usage;
 module_param_named(usage, pkcs7_usage, uint, S_IWUSR | S_IRUGO);
 MODULE_PARM_DESC(pkcs7_usage,

commit 99db44350672c8a5ee9a7b0a6f4cd6ff10136065
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 15:22:27 2015 +0100

    PKCS#7: Appropriately restrict authenticated attributes and content type
    
    A PKCS#7 or CMS message can have per-signature authenticated attributes
    that are digested as a lump and signed by the authorising key for that
    signature.  If such attributes exist, the content digest isn't itself
    signed, but rather it is included in a special authattr which then
    contributes to the signature.
    
    Further, we already require the master message content type to be
    pkcs7_signedData - but there's also a separate content type for the data
    itself within the SignedData object and this must be repeated inside the
    authattrs for each signer [RFC2315 9.2, RFC5652 11.1].
    
    We should really validate the authattrs if they exist or forbid them
    entirely as appropriate.  To this end:
    
     (1) Alter the PKCS#7 parser to reject any message that has more than one
         signature where at least one signature has authattrs and at least one
         that does not.
    
     (2) Validate authattrs if they are present and strongly restrict them.
         Only the following authattrs are permitted and all others are
         rejected:
    
         (a) contentType.  This is checked to be an OID that matches the
             content type in the SignedData object.
    
         (b) messageDigest.  This must match the crypto digest of the data.
    
         (c) signingTime.  If present, we check that this is a valid, parseable
             UTCTime or GeneralTime and that the date it encodes fits within
             the validity window of the matching X.509 cert.
    
         (d) S/MIME capabilities.  We don't check the contents.
    
         (e) Authenticode SP Opus Info.  We don't check the contents.
    
         (f) Authenticode Statement Type.  We don't check the contents.
    
         The message is rejected if (a) or (b) are missing.  If the message is
         an Authenticode type, the message is rejected if (e) is missing; if
         not Authenticode, the message is rejected if (d) - (f) are present.
    
         The S/MIME capabilities authattr (d) unfortunately has to be allowed
         to support kernels already signed by the pesign program.  This only
         affects kexec.  sign-file suppresses them (CMS_NOSMIMECAP).
    
         The message is also rejected if an authattr is given more than once or
         if it contains more than one element in its set of values.
    
     (3) Add a parameter to pkcs7_verify() to select one of the following
         restrictions and pass in the appropriate option from the callers:
    
         (*) VERIFYING_MODULE_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data and
             forbids authattrs.  sign-file sets CMS_NOATTR.  We could be more
             flexible and permit authattrs optionally, but only permit minimal
             content.
    
         (*) VERIFYING_FIRMWARE_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data and
             requires authattrs.  In future, this will require an attribute
             holding the target firmware name in addition to the minimal set.
    
         (*) VERIFYING_UNSPECIFIED_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data but
             allows either no authattrs or only permits the minimal set.
    
         (*) VERIFYING_KEXEC_PE_SIGNATURE
    
             This only supports the Authenticode SPC_INDIRECT_DATA content type
             and requires at least an SpcSpOpusInfo authattr in addition to the
             minimal set.  It also permits an SPC_STATEMENT_TYPE authattr (and
             an S/MIME capabilities authattr because the pesign program doesn't
             remove these).
    
         (*) VERIFYING_KEY_SIGNATURE
         (*) VERIFYING_KEY_SELF_SIGNATURE
    
             These are invalid in this context but are included for later use
             when limiting the use of X.509 certs.
    
     (4) The pkcs7_test key type is given a module parameter to select between
         the above options for testing purposes.  For example:
    
            echo 1 >/sys/module/pkcs7_test_key/parameters/usage
            keyctl padd pkcs7_test foo @s </tmp/stuff.pkcs7
    
         will attempt to check the signature on stuff.pkcs7 as if it contains a
         firmware blob (1 being VERIFYING_FIRMWARE_SIGNATURE).
    
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index 3d13b042da73..10d34dbd00b9 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -14,16 +14,23 @@
 #include <linux/err.h>
 #include <linux/module.h>
 #include <linux/key-type.h>
+#include <keys/asymmetric-type.h>
 #include <crypto/pkcs7.h>
 #include <keys/user-type.h>
 #include <keys/system_keyring.h>
 #include "pkcs7_parser.h"
 
+static unsigned pkcs7_usage;
+module_param_named(usage, pkcs7_usage, uint, S_IWUSR | S_IRUGO);
+MODULE_PARM_DESC(pkcs7_usage,
+		 "Usage to specify when verifying the PKCS#7 message");
+
 /*
  * Preparse a PKCS#7 wrapped and validated data blob.
  */
 static int pkcs7_preparse(struct key_preparsed_payload *prep)
 {
+	enum key_being_used_for usage = pkcs7_usage;
 	struct pkcs7_message *pkcs7;
 	const void *data, *saved_prep_data;
 	size_t datalen, saved_prep_datalen;
@@ -32,6 +39,11 @@ static int pkcs7_preparse(struct key_preparsed_payload *prep)
 
 	kenter("");
 
+	if (usage >= NR__KEY_BEING_USED_FOR) {
+		pr_err("Invalid usage type %d\n", usage);
+		return -EINVAL;
+	}
+
 	saved_prep_data = prep->data;
 	saved_prep_datalen = prep->datalen;
 	pkcs7 = pkcs7_parse_message(saved_prep_data, saved_prep_datalen);
@@ -40,7 +52,7 @@ static int pkcs7_preparse(struct key_preparsed_payload *prep)
 		goto error;
 	}
 
-	ret = pkcs7_verify(pkcs7);
+	ret = pkcs7_verify(pkcs7, usage);
 	if (ret < 0)
 		goto error_free;
 

commit 88775588b71d28a9020a7faa4ad95bbf76d8bb45
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 1 21:29:53 2015 -0400

    crypto/asymmetric_keys: pkcs7_key_type needs module.h
    
    This driver builds off of the tristate CONFIG_PKCS7_TEST_KEY and calls
    module_init and module_exit. So it should explicitly include module.h
    to avoid compile breakage during header shuffles done in the future.
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: linux-crypto@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index 751f8fd7335d..3d13b042da73 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -12,6 +12,7 @@
 #define pr_fmt(fmt) "PKCS7key: "fmt
 #include <linux/key.h>
 #include <linux/err.h>
+#include <linux/module.h>
 #include <linux/key-type.h>
 #include <crypto/pkcs7.h>
 #include <keys/user-type.h>

commit c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:06 2014 +0100

    KEYS: Remove key_type::match in favour of overriding default by match_preparse
    
    A previous patch added a ->match_preparse() method to the key type.  This is
    allowed to override the function called by the iteration algorithm.
    Therefore, we can just set a default that simply checks for an exact match of
    the key description with the original criterion data and allow match_preparse
    to override it as needed.
    
    The key_type::match op is then redundant and can be removed, as can the
    user_match() function.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index d1faa1df1dec..751f8fd7335d 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {
 	.preparse		= pkcs7_preparse,
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
-	.match			= user_match,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,

commit 614d8c39014c185aa0f7254f0a470cc33fc1b284
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:04 2014 +0100

    KEYS: Remove key_type::def_lookup_type
    
    Remove key_type::def_lookup_type as it's no longer used.  The information now
    defaults to KEYRING_SEARCH_LOOKUP_DIRECT but may be overridden by
    type->match_preparse().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index 3de5fb011de0..d1faa1df1dec 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -72,7 +72,6 @@ static int pkcs7_preparse(struct key_preparsed_payload *prep)
  */
 static struct key_type key_type_pkcs7 = {
 	.name			= "pkcs7_test",
-	.def_lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	.preparse		= pkcs7_preparse,
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,

commit 63d2551ea7e2c34b533f2b6b0646cc825d9ee509
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Mon Jul 28 21:17:12 2014 +0800

    PKCS#7: fix sparse non static symbol warning
    
    Fixes the following sparse warnings:
    
    crypto/asymmetric_keys/pkcs7_key_type.c:73:17: warning:
     symbol 'key_type_pkcs7' was not declared. Should it be static?
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index 197ecdc0a5a1..3de5fb011de0 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -70,7 +70,7 @@ static int pkcs7_preparse(struct key_preparsed_payload *prep)
  * user defined keys take an arbitrary string as the description and an
  * arbitrary blob of data as the payload
  */
-struct key_type key_type_pkcs7 = {
+static struct key_type key_type_pkcs7 = {
 	.name			= "pkcs7_test",
 	.def_lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	.preparse		= pkcs7_preparse,

commit 8f3438ccea149647ad1849651d1e14c7b8b85e63
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jul 25 11:33:53 2014 +0100

    PKCS#7: Missing inclusion of linux/err.h
    
    crypto/asymmetric_keys/pkcs7_key_type.c needs to #include linux/err.h rather
    than relying on getting it through other headers.
    
    Without this, the powerpc allyesconfig build fails.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
index c2091f7bd15d..197ecdc0a5a1 100644
--- a/crypto/asymmetric_keys/pkcs7_key_type.c
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -11,6 +11,7 @@
 
 #define pr_fmt(fmt) "PKCS7key: "fmt
 #include <linux/key.h>
+#include <linux/err.h>
 #include <linux/key-type.h>
 #include <crypto/pkcs7.h>
 #include <keys/user-type.h>

commit 1ca72c96dbad332ebd89b5756640f881ff0e6e9e
Merge: a19e3c22b34a 22d01afb210f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 22 21:52:33 2014 +0100

    Merge tag 'keys-pkcs7-20140708' into keys-next
    
    Here's a set of changes that implement a PKCS#7 message parser in the kernel.
    
    The PKCS#7 message parsing will then be used to limit kexec to authenticated
    kernels only if so configured.
    
    The changes provide the following facilities:
    
     (1) Parse an ASN.1 PKCS#7 message and pick out useful bits such as the data
         content and the X.509 certificates used to sign it and all the data
         signatures.
    
     (2) Verify all the data signatures against the set of X.509 certificates
         available in the message.
    
     (3) Follow the certificate chains and verify that:
    
         (a) for every self-signed X.509 certificate, check that it validly signed
             itself, and:
    
         (b) for every non-self-signed certificate, if we have a 'parent'
             certificate, the former is validly signed by the latter.
    
     (4) Look for intersections between the certificate chains and the trusted
         keyring, if any intersections are found, verify that the trusted
         certificates signed the intersection point in the chain.
    
     (5) For testing purposes, a key type can be made available that will take a
         PKCS#7 message, check that the message is trustworthy, and if so, add its
         data content into the key.
    
    Note that (5) has to be altered to take account of the preparsing patches
    already committed to this branch.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

commit 22d01afb210ff77fc480a1fc531cd59a4f32157a
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 1 19:06:18 2014 +0100

    PKCS#7: Provide a key type for testing PKCS#7
    
    Provide a key type for testing the PKCS#7 parser.  It is given a non-detached
    PKCS#7 message as payload:
    
            keyctl padd pkcs7_test a @s <stuff.pkcs7
    
    The PKCS#7 wrapper is validated against the trusted certificates available and
    then stripped off.  If successful, the key can be read, which will give the
    data content of the PKCS#7 message.
    
    A suitable message can be created by running make on the attached Makefile.
    This will produce a file called stuff.pkcs7 for test loading.  The key3.x509
    file should be put into the kernel source tree before it is built and
    converted to DER form:
    
            openssl x509 -in .../pkcs7/key3.x509 -outform DER -out key3.x509
    
    ###############################################################################
    #
    # Create a pkcs7 message and sign it twice
    #
    #       openssl x509 -text -inform PEM -noout -in key2.x509
    #
    ###############################################################################
    stuff.pkcs7: stuff.txt key2.priv key2.x509 key4.priv key4.x509 certs
            $(RM) $@
            openssl smime -sign \
                    -signer key2.x509 \
                    -inkey key2.priv \
                    -signer key4.x509 \
                    -inkey key4.priv \
                    -in stuff.txt \
                    -certfile certs \
                    -out $@ -binary -outform DER -nodetach
            openssl pkcs7 -inform DER -in stuff.pkcs7  -print_certs -noout
            openssl asn1parse -inform DER -in stuff.pkcs7  -i >out
    
    stuff.txt:
            echo "The quick red fox jumped over the lazy brown dog" >stuff.txt
    
    certs: key1.x509 key2.x509 key3.x509 key4.x509
            cat key{1,3}.x509 >$@
    
    ###############################################################################
    #
    # Generate a signed key
    #
    #       openssl x509 -text -inform PEM -noout -in key2.x509
    #
    ###############################################################################
    key2.x509: key2.x509_unsigned key1.priv key1.x509
            openssl x509 \
                    -req -in key2.x509_unsigned \
                    -out key2.x509 \
                    -extfile key2.genkey -extensions myexts \
                    -CA key1.x509 \
                    -CAkey key1.priv \
                    -CAcreateserial
    
    key2.priv key2.x509_unsigned: key2.genkey
            openssl req -new -nodes -utf8 -sha1 -days 36500 \
                    -batch -outform PEM \
                    -config key2.genkey \
                    -keyout key2.priv \
                    -out key2.x509_unsigned
    
    key2.genkey:
            @echo Generating X.509 key generation config
            @echo  >$@ "[ req ]"
            @echo >>$@ "default_bits = 4096"
            @echo >>$@ "distinguished_name = req_distinguished_name"
            @echo >>$@ "prompt = no"
            @echo >>$@ "string_mask = utf8only"
            @echo >>$@ "x509_extensions = myexts"
            @echo >>$@
            @echo >>$@ "[ req_distinguished_name ]"
            @echo >>$@ "O = Magrathea"
            @echo >>$@ "CN = PKCS7 key 2"
            @echo >>$@ "emailAddress = slartibartfast@magrathea.h2g2"
            @echo >>$@
            @echo >>$@ "[ myexts ]"
            @echo >>$@ "basicConstraints=critical,CA:FALSE"
            @echo >>$@ "keyUsage=digitalSignature"
            @echo >>$@ "subjectKeyIdentifier=hash"
            @echo >>$@ "authorityKeyIdentifier=keyid"
    
    ###############################################################################
    #
    # Generate a couple of signing keys
    #
    #       openssl x509 -text -inform PEM -noout -in key1.x509
    #
    ###############################################################################
    key1.x509: key1.x509_unsigned key4.priv key4.x509
            openssl x509 \
                    -req -in key1.x509_unsigned \
                    -out key1.x509 \
                    -extfile key1.genkey -extensions myexts \
                    -CA key4.x509 \
                    -CAkey key4.priv \
                    -CAcreateserial
    
    key1.priv key1.x509_unsigned: key1.genkey
            openssl req -new -nodes -utf8 -sha1 -days 36500 \
                    -batch -outform PEM \
                    -config key1.genkey \
                    -keyout key1.priv \
                    -out key1.x509_unsigned
    
    key1.genkey:
            @echo Generating X.509 key generation config
            @echo  >$@ "[ req ]"
            @echo >>$@ "default_bits = 4096"
            @echo >>$@ "distinguished_name = req_distinguished_name"
            @echo >>$@ "prompt = no"
            @echo >>$@ "string_mask = utf8only"
            @echo >>$@ "x509_extensions = myexts"
            @echo >>$@
            @echo >>$@ "[ req_distinguished_name ]"
            @echo >>$@ "O = Magrathea"
            @echo >>$@ "CN = PKCS7 key 1"
            @echo >>$@ "emailAddress = slartibartfast@magrathea.h2g2"
            @echo >>$@
            @echo >>$@ "[ myexts ]"
            @echo >>$@ "basicConstraints=critical,CA:TRUE"
            @echo >>$@ "keyUsage=digitalSignature,keyCertSign"
            @echo >>$@ "subjectKeyIdentifier=hash"
            @echo >>$@ "authorityKeyIdentifier=keyid"
    
    ###############################################################################
    #
    # Generate a signed key
    #
    #       openssl x509 -text -inform PEM -noout -in key4.x509
    #
    ###############################################################################
    key4.x509: key4.x509_unsigned key3.priv key3.x509
            openssl x509 \
                    -req -in key4.x509_unsigned \
                    -out key4.x509 \
                    -extfile key4.genkey -extensions myexts \
                    -CA key3.x509 \
                    -CAkey key3.priv \
                    -CAcreateserial
    
    key4.priv key4.x509_unsigned: key4.genkey
            openssl req -new -nodes -utf8 -sha1 -days 36500 \
                    -batch -outform PEM \
                    -config key4.genkey \
                    -keyout key4.priv \
                    -out key4.x509_unsigned
    
    key4.genkey:
            @echo Generating X.509 key generation config
            @echo  >$@ "[ req ]"
            @echo >>$@ "default_bits = 4096"
            @echo >>$@ "distinguished_name = req_distinguished_name"
            @echo >>$@ "prompt = no"
            @echo >>$@ "string_mask = utf8only"
            @echo >>$@ "x509_extensions = myexts"
            @echo >>$@
            @echo >>$@ "[ req_distinguished_name ]"
            @echo >>$@ "O = Magrathea"
            @echo >>$@ "CN = PKCS7 key 4"
            @echo >>$@ "emailAddress = slartibartfast@magrathea.h2g2"
            @echo >>$@
            @echo >>$@ "[ myexts ]"
            @echo >>$@ "basicConstraints=critical,CA:TRUE"
            @echo >>$@ "keyUsage=digitalSignature,keyCertSign"
            @echo >>$@ "subjectKeyIdentifier=hash"
            @echo >>$@ "authorityKeyIdentifier=keyid"
    
    ###############################################################################
    #
    # Generate a couple of signing keys
    #
    #       openssl x509 -text -inform PEM -noout -in key3.x509
    #
    ###############################################################################
    key3.priv key3.x509: key3.genkey
            openssl req -new -nodes -utf8 -sha1 -days 36500 \
                    -batch -x509 -outform PEM \
                    -config key3.genkey \
                    -keyout key3.priv \
                    -out key3.x509
    
    key3.genkey:
            @echo Generating X.509 key generation config
            @echo  >$@ "[ req ]"
            @echo >>$@ "default_bits = 4096"
            @echo >>$@ "distinguished_name = req_distinguished_name"
            @echo >>$@ "prompt = no"
            @echo >>$@ "string_mask = utf8only"
            @echo >>$@ "x509_extensions = myexts"
            @echo >>$@
            @echo >>$@ "[ req_distinguished_name ]"
            @echo >>$@ "O = Magrathea"
            @echo >>$@ "CN = PKCS7 key 3"
            @echo >>$@ "emailAddress = slartibartfast@magrathea.h2g2"
            @echo >>$@
            @echo >>$@ "[ myexts ]"
            @echo >>$@ "basicConstraints=critical,CA:TRUE"
            @echo >>$@ "keyUsage=digitalSignature,keyCertSign"
            @echo >>$@ "subjectKeyIdentifier=hash"
            @echo >>$@ "authorityKeyIdentifier=keyid"
    
    clean:
            $(RM) *~
            $(RM) key1.* key2.* key3.* key4.* stuff.* out certs
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/crypto/asymmetric_keys/pkcs7_key_type.c b/crypto/asymmetric_keys/pkcs7_key_type.c
new file mode 100644
index 000000000000..b1797d2516e2
--- /dev/null
+++ b/crypto/asymmetric_keys/pkcs7_key_type.c
@@ -0,0 +1,97 @@
+/* Testing module to load key from trusted PKCS#7 message
+ *
+ * Copyright (C) 2014 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#define pr_fmt(fmt) "PKCS7key: "fmt
+#include <linux/key.h>
+#include <linux/key-type.h>
+#include <crypto/pkcs7.h>
+#include <keys/user-type.h>
+#include <keys/system_keyring.h>
+#include "pkcs7_parser.h"
+
+/*
+ * Instantiate a PKCS#7 wrapped and validated key.
+ */
+int pkcs7_instantiate(struct key *key, struct key_preparsed_payload *prep)
+{
+	struct pkcs7_message *pkcs7;
+	const void *data, *saved_prep_data;
+	size_t datalen, saved_prep_datalen;
+	bool trusted;
+	int ret;
+
+	kenter("");
+
+	saved_prep_data = prep->data;
+	saved_prep_datalen = prep->datalen;
+	pkcs7 = pkcs7_parse_message(saved_prep_data, saved_prep_datalen);
+	if (IS_ERR(pkcs7)) {
+		ret = PTR_ERR(pkcs7);
+		goto error;
+	}
+
+	ret = pkcs7_verify(pkcs7);
+	if (ret < 0)
+		goto error_free;
+
+	ret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);
+	if (ret < 0)
+		goto error_free;
+	if (!trusted)
+		pr_warn("PKCS#7 message doesn't chain back to a trusted key\n");
+
+	ret = pkcs7_get_content_data(pkcs7, &data, &datalen, false);
+	if (ret < 0)
+		goto error_free;
+
+	prep->data = data;
+	prep->datalen = datalen;
+	ret = user_instantiate(key, prep);
+	prep->data = saved_prep_data;
+	prep->datalen = saved_prep_datalen;
+
+error_free:
+	pkcs7_free_message(pkcs7);
+error:
+	kleave(" = %d", ret);
+	return ret;
+}
+
+/*
+ * user defined keys take an arbitrary string as the description and an
+ * arbitrary blob of data as the payload
+ */
+struct key_type key_type_pkcs7 = {
+	.name			= "pkcs7_test",
+	.def_lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
+	.instantiate		= pkcs7_instantiate,
+	.match			= user_match,
+	.revoke			= user_revoke,
+	.destroy		= user_destroy,
+	.describe		= user_describe,
+	.read			= user_read,
+};
+
+/*
+ * Module stuff
+ */
+static int __init pkcs7_key_init(void)
+{
+	return register_key_type(&key_type_pkcs7);
+}
+
+static void __exit pkcs7_key_cleanup(void)
+{
+	unregister_key_type(&key_type_pkcs7);
+}
+
+module_init(pkcs7_key_init);
+module_exit(pkcs7_key_cleanup);
