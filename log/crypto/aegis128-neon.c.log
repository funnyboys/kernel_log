commit 528282630ca961d6284f68f5f2f0057c86873bb6
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Oct 14 18:16:45 2019 +0200

    crypto: aegis128 - duplicate init() and final() hooks in SIMD code
    
    In order to speed up aegis128 processing even more, duplicate the init()
    and final() routines as SIMD versions in their entirety. This results
    in a 2x speedup on ARM Cortex-A57 for ~1500 byte packets (using AES
    instructions).
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/aegis128-neon.c b/crypto/aegis128-neon.c
index 751f9c195aa4..8271b1fa0fbc 100644
--- a/crypto/aegis128-neon.c
+++ b/crypto/aegis128-neon.c
@@ -8,11 +8,14 @@
 
 #include "aegis.h"
 
+void crypto_aegis128_init_neon(void *state, const void *key, const void *iv);
 void crypto_aegis128_update_neon(void *state, const void *msg);
 void crypto_aegis128_encrypt_chunk_neon(void *state, void *dst, const void *src,
 					unsigned int size);
 void crypto_aegis128_decrypt_chunk_neon(void *state, void *dst, const void *src,
 					unsigned int size);
+void crypto_aegis128_final_neon(void *state, void *tag_xor, uint64_t assoclen,
+				uint64_t cryptlen);
 
 int aegis128_have_aes_insn __ro_after_init;
 
@@ -25,6 +28,15 @@ bool crypto_aegis128_have_simd(void)
 	return IS_ENABLED(CONFIG_ARM64);
 }
 
+void crypto_aegis128_init_simd(union aegis_block *state,
+			       const union aegis_block *key,
+			       const u8 *iv)
+{
+	kernel_neon_begin();
+	crypto_aegis128_init_neon(state, key, iv);
+	kernel_neon_end();
+}
+
 void crypto_aegis128_update_simd(union aegis_block *state, const void *msg)
 {
 	kernel_neon_begin();
@@ -47,3 +59,12 @@ void crypto_aegis128_decrypt_chunk_simd(union aegis_block *state, u8 *dst,
 	crypto_aegis128_decrypt_chunk_neon(state, dst, src, size);
 	kernel_neon_end();
 }
+
+void crypto_aegis128_final_simd(union aegis_block *state,
+				union aegis_block *tag_xor,
+				u64 assoclen, u64 cryptlen)
+{
+	kernel_neon_begin();
+	crypto_aegis128_final_neon(state, tag_xor, assoclen, cryptlen);
+	kernel_neon_end();
+}

commit 198429631a85622da1d08d360ef02cfb84c95919
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Aug 12 01:59:12 2019 +0300

    crypto: arm64/aegis128 - implement plain NEON version
    
    Provide a version of the core AES transform to the aegis128 SIMD
    code that does not rely on the special AES instructions, but uses
    plain NEON instructions instead. This allows the SIMD version of
    the aegis128 driver to be used on arm64 systems that do not
    implement those instructions (which are not mandatory in the
    architecture), such as the Raspberry Pi 3.
    
    Since GCC makes a mess of this when using the tbl/tbx intrinsics
    to perform the sbox substitution, preload the Sbox into v16..v31
    in this case and use inline asm to emit the tbl/tbx instructions.
    Clang does not support this approach, nor does it require it, since
    it does a much better job at code generation, so there we use the
    intrinsics as usual.
    
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/aegis128-neon.c b/crypto/aegis128-neon.c
index c1c0a1686f67..751f9c195aa4 100644
--- a/crypto/aegis128-neon.c
+++ b/crypto/aegis128-neon.c
@@ -14,9 +14,15 @@ void crypto_aegis128_encrypt_chunk_neon(void *state, void *dst, const void *src,
 void crypto_aegis128_decrypt_chunk_neon(void *state, void *dst, const void *src,
 					unsigned int size);
 
+int aegis128_have_aes_insn __ro_after_init;
+
 bool crypto_aegis128_have_simd(void)
 {
-	return cpu_have_feature(cpu_feature(AES));
+	if (cpu_have_feature(cpu_feature(AES))) {
+		aegis128_have_aes_insn = 1;
+		return true;
+	}
+	return IS_ENABLED(CONFIG_ARM64);
 }
 
 void crypto_aegis128_update_simd(union aegis_block *state, const void *msg)

commit a4397635afea5d127548d64e0055ed471ef2d5be
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Aug 12 01:59:11 2019 +0300

    crypto: aegis128 - provide a SIMD implementation based on NEON intrinsics
    
    Provide an accelerated implementation of aegis128 by wiring up the
    SIMD hooks in the generic driver to an implementation based on NEON
    intrinsics, which can be compiled to both ARM and arm64 code.
    
    This results in a performance of 2.2 cycles per byte on Cortex-A53,
    which is a performance increase of ~11x compared to the generic
    code.
    
    Reviewed-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/aegis128-neon.c b/crypto/aegis128-neon.c
new file mode 100644
index 000000000000..c1c0a1686f67
--- /dev/null
+++ b/crypto/aegis128-neon.c
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2019 Linaro Ltd <ard.biesheuvel@linaro.org>
+ */
+
+#include <asm/cpufeature.h>
+#include <asm/neon.h>
+
+#include "aegis.h"
+
+void crypto_aegis128_update_neon(void *state, const void *msg);
+void crypto_aegis128_encrypt_chunk_neon(void *state, void *dst, const void *src,
+					unsigned int size);
+void crypto_aegis128_decrypt_chunk_neon(void *state, void *dst, const void *src,
+					unsigned int size);
+
+bool crypto_aegis128_have_simd(void)
+{
+	return cpu_have_feature(cpu_feature(AES));
+}
+
+void crypto_aegis128_update_simd(union aegis_block *state, const void *msg)
+{
+	kernel_neon_begin();
+	crypto_aegis128_update_neon(state, msg);
+	kernel_neon_end();
+}
+
+void crypto_aegis128_encrypt_chunk_simd(union aegis_block *state, u8 *dst,
+					const u8 *src, unsigned int size)
+{
+	kernel_neon_begin();
+	crypto_aegis128_encrypt_chunk_neon(state, dst, src, size);
+	kernel_neon_end();
+}
+
+void crypto_aegis128_decrypt_chunk_simd(union aegis_block *state, u8 *dst,
+					const u8 *src, unsigned int size)
+{
+	kernel_neon_begin();
+	crypto_aegis128_decrypt_chunk_neon(state, dst, src, size);
+	kernel_neon_end();
+}

commit c9f1fd4f2f74f322d5bdc4ec2c6a38ab7462967b
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Fri Aug 2 13:31:35 2019 +1000

    Revert "crypto: aegis128 - add support for SIMD acceleration"
    
    This reverts commit ecc8bc81f2fb3976737ef312f824ba6053aa3590
    ("crypto: aegis128 - provide a SIMD implementation based on NEON
    intrinsics") and commit 7cdc0ddbf74a19cecb2f0e9efa2cae9d3c665189
    ("crypto: aegis128 - add support for SIMD acceleration").
    
    They cause compile errors on platforms other than ARM because
    the mechanism to selectively compile the SIMD code is broken.
    
    Repoted-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/aegis128-neon.c b/crypto/aegis128-neon.c
deleted file mode 100644
index c1c0a1686f67..000000000000
--- a/crypto/aegis128-neon.c
+++ /dev/null
@@ -1,43 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (C) 2019 Linaro Ltd <ard.biesheuvel@linaro.org>
- */
-
-#include <asm/cpufeature.h>
-#include <asm/neon.h>
-
-#include "aegis.h"
-
-void crypto_aegis128_update_neon(void *state, const void *msg);
-void crypto_aegis128_encrypt_chunk_neon(void *state, void *dst, const void *src,
-					unsigned int size);
-void crypto_aegis128_decrypt_chunk_neon(void *state, void *dst, const void *src,
-					unsigned int size);
-
-bool crypto_aegis128_have_simd(void)
-{
-	return cpu_have_feature(cpu_feature(AES));
-}
-
-void crypto_aegis128_update_simd(union aegis_block *state, const void *msg)
-{
-	kernel_neon_begin();
-	crypto_aegis128_update_neon(state, msg);
-	kernel_neon_end();
-}
-
-void crypto_aegis128_encrypt_chunk_simd(union aegis_block *state, u8 *dst,
-					const u8 *src, unsigned int size)
-{
-	kernel_neon_begin();
-	crypto_aegis128_encrypt_chunk_neon(state, dst, src, size);
-	kernel_neon_end();
-}
-
-void crypto_aegis128_decrypt_chunk_simd(union aegis_block *state, u8 *dst,
-					const u8 *src, unsigned int size)
-{
-	kernel_neon_begin();
-	crypto_aegis128_decrypt_chunk_neon(state, dst, src, size);
-	kernel_neon_end();
-}

commit ecc8bc81f2fb3976737ef312f824ba6053aa3590
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jul 3 10:55:11 2019 +0200

    crypto: aegis128 - provide a SIMD implementation based on NEON intrinsics
    
    Provide an accelerated implementation of aegis128 by wiring up the
    SIMD hooks in the generic driver to an implementation based on NEON
    intrinsics, which can be compiled to both ARM and arm64 code.
    
    This results in a performance of 2.2 cycles per byte on Cortex-A53,
    which is a performance increase of ~11x compared to the generic
    code.
    
    Reviewed-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/aegis128-neon.c b/crypto/aegis128-neon.c
new file mode 100644
index 000000000000..c1c0a1686f67
--- /dev/null
+++ b/crypto/aegis128-neon.c
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2019 Linaro Ltd <ard.biesheuvel@linaro.org>
+ */
+
+#include <asm/cpufeature.h>
+#include <asm/neon.h>
+
+#include "aegis.h"
+
+void crypto_aegis128_update_neon(void *state, const void *msg);
+void crypto_aegis128_encrypt_chunk_neon(void *state, void *dst, const void *src,
+					unsigned int size);
+void crypto_aegis128_decrypt_chunk_neon(void *state, void *dst, const void *src,
+					unsigned int size);
+
+bool crypto_aegis128_have_simd(void)
+{
+	return cpu_have_feature(cpu_feature(AES));
+}
+
+void crypto_aegis128_update_simd(union aegis_block *state, const void *msg)
+{
+	kernel_neon_begin();
+	crypto_aegis128_update_neon(state, msg);
+	kernel_neon_end();
+}
+
+void crypto_aegis128_encrypt_chunk_simd(union aegis_block *state, u8 *dst,
+					const u8 *src, unsigned int size)
+{
+	kernel_neon_begin();
+	crypto_aegis128_encrypt_chunk_neon(state, dst, src, size);
+	kernel_neon_end();
+}
+
+void crypto_aegis128_decrypt_chunk_simd(union aegis_block *state, u8 *dst,
+					const u8 *src, unsigned int size)
+{
+	kernel_neon_begin();
+	crypto_aegis128_decrypt_chunk_neon(state, dst, src, size);
+	kernel_neon_end();
+}
