commit af1a8899d22c8acda5514999cd797d7139e47e56
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:12 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 47
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version you should have received a copy of the gnu general
      public license for example usr src linux copying if not write to the
      free software foundation inc 675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 20 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170858.552543146@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/crypto/xor.c b/crypto/xor.c
index bce9fe7af40a..ea7349e6ed23 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * xor.c : Multiple Devices driver for Linux
  *
@@ -5,15 +6,6 @@
  * Ingo Molnar, Matti Aarnio, Jakub Jelinek, Richard Henderson.
  *
  * Dispatch optimized RAID-5 checksumming functions.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * You should have received a copy of the GNU General Public License
- * (for example /usr/src/linux/COPYING); if not, write to the Free
- * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #define BH_TRACE 0

commit 75f296d93bcebcfe375884ddac79e30263a31766
Author: Levin, Alexander (Sasha Levin) <alexander.levin@verizon.com>
Date:   Wed Nov 15 17:35:54 2017 -0800

    kmemcheck: stop using GFP_NOTRACK and SLAB_NOTRACK
    
    Convert all allocations that used a NOTRACK flag to stop using it.
    
    Link: http://lkml.kernel.org/r/20171007030159.22241-3-alexander.levin@verizon.com
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Tim Hansen <devtimhansen@gmail.com>
    Cc: Vegard Nossum <vegardno@ifi.uio.no>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/crypto/xor.c b/crypto/xor.c
index 263af9fb45ea..bce9fe7af40a 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -122,12 +122,7 @@ calibrate_xor_blocks(void)
 		goto out;
 	}
 
-	/*
-	 * Note: Since the memory is not actually used for _anything_ but to
-	 * test the XOR speed, we don't really want kmemcheck to warn about
-	 * reading uninitialized bytes here.
-	 */
-	b1 = (void *) __get_free_pages(GFP_KERNEL | __GFP_NOTRACK, 2);
+	b1 = (void *) __get_free_pages(GFP_KERNEL, 2);
 	if (!b1) {
 		printk(KERN_WARNING "xor: Yikes!  No memory available.\n");
 		return -ENOMEM;

commit 27c4d548af958233e26ab5b00719ff3e49b3aebe
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Fri Aug 26 23:19:39 2016 +0800

    crypto: xor - Fix warning when XOR_SELECT_TEMPLATE is unset
    
    This patch fixes an unused label warning triggered when the macro
    XOR_SELECT_TEMPLATE is not set.
    
    Fixes: 39457acda913 ("crypto: xor - skip speed test if the xor...")
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Suggested-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/xor.c b/crypto/xor.c
index b8975d92cd94..263af9fb45ea 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -24,6 +24,10 @@
 #include <linux/preempt.h>
 #include <asm/xor.h>
 
+#ifndef XOR_SELECT_TEMPLATE
+#define XOR_SELECT_TEMPLATE(x) (x)
+#endif
+
 /* The xor routines to use.  */
 static struct xor_block_template *active_template;
 
@@ -109,17 +113,14 @@ calibrate_xor_blocks(void)
 	void *b1, *b2;
 	struct xor_block_template *f, *fastest;
 
-	fastest = NULL;
+	fastest = XOR_SELECT_TEMPLATE(NULL);
 
-#ifdef XOR_SELECT_TEMPLATE
-	fastest = XOR_SELECT_TEMPLATE(fastest);
 	if (fastest) {
 		printk(KERN_INFO "xor: automatically using best "
 				 "checksumming function   %-10s\n",
 		       fastest->name);
 		goto out;
 	}
-#endif
 
 	/*
 	 * Note: Since the memory is not actually used for _anything_ but to

commit 39457acda9139bb078d1b8f974651a194a397060
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 19 14:19:30 2016 +0200

    crypto: xor - skip speed test if the xor function is selected automatically
    
    If the architecture selected the xor function with XOR_SELECT_TEMPLATE
    the speed result of the do_xor_speed benchmark is of limited value.
    The speed measurement increases the bootup time a little, which can
    makes a difference for kernels used in container like virtual machines.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/xor.c b/crypto/xor.c
index 35d6b3adf230..b8975d92cd94 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -109,6 +109,18 @@ calibrate_xor_blocks(void)
 	void *b1, *b2;
 	struct xor_block_template *f, *fastest;
 
+	fastest = NULL;
+
+#ifdef XOR_SELECT_TEMPLATE
+	fastest = XOR_SELECT_TEMPLATE(fastest);
+	if (fastest) {
+		printk(KERN_INFO "xor: automatically using best "
+				 "checksumming function   %-10s\n",
+		       fastest->name);
+		goto out;
+	}
+#endif
+
 	/*
 	 * Note: Since the memory is not actually used for _anything_ but to
 	 * test the XOR speed, we don't really want kmemcheck to warn about
@@ -126,36 +138,22 @@ calibrate_xor_blocks(void)
 	 * all the possible functions, just test the best one
 	 */
 
-	fastest = NULL;
-
-#ifdef XOR_SELECT_TEMPLATE
-		fastest = XOR_SELECT_TEMPLATE(fastest);
-#endif
-
 #define xor_speed(templ)	do_xor_speed((templ), b1, b2)
 
-	if (fastest) {
-		printk(KERN_INFO "xor: automatically using best "
-				 "checksumming function:\n");
-		xor_speed(fastest);
-		goto out;
-	} else {
-		printk(KERN_INFO "xor: measuring software checksum speed\n");
-		XOR_TRY_TEMPLATES;
-		fastest = template_list;
-		for (f = fastest; f; f = f->next)
-			if (f->speed > fastest->speed)
-				fastest = f;
-	}
+	printk(KERN_INFO "xor: measuring software checksum speed\n");
+	XOR_TRY_TEMPLATES;
+	fastest = template_list;
+	for (f = fastest; f; f = f->next)
+		if (f->speed > fastest->speed)
+			fastest = f;
 
 	printk(KERN_INFO "xor: using function: %s (%d.%03d MB/sec)\n",
 	       fastest->name, fastest->speed / 1000, fastest->speed % 1000);
 
 #undef xor_speed
 
- out:
 	free_pages((unsigned long)b1, 2);
-
+out:
 	active_template = fastest;
 	return 0;
 }

commit af7cf25dd15b74a78bff8ed5dc969b20dae9554d
Author: Jan Beulich <JBeulich@suse.com>
Date:   Thu Oct 11 13:42:32 2012 +1100

    add further __init annotations to crypto/xor.c
    
    Allow particularly do_xor_speed() to be discarded post-init.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/crypto/xor.c b/crypto/xor.c
index 65c7b416b4a3..35d6b3adf230 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -56,11 +56,11 @@ xor_blocks(unsigned int src_count, unsigned int bytes, void *dest, void **srcs)
 EXPORT_SYMBOL(xor_blocks);
 
 /* Set of all registered templates.  */
-static struct xor_block_template *template_list;
+static struct xor_block_template *__initdata template_list;
 
 #define BENCH_SIZE (PAGE_SIZE)
 
-static void
+static void __init
 do_xor_speed(struct xor_block_template *tmpl, void *b1, void *b2)
 {
 	int speed;

commit c80ddb526331a72c9e9d1480f85f6fd7c74e3d2d
Merge: 2c13bc0f8f0d 1dff2b87a34a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 23 17:08:40 2012 -0700

    Merge tag 'md-3.5' of git://neil.brown.name/md
    
    Pull md updates from NeilBrown:
     "It's been a busy cycle for md - lots of fun stuff here..  if you like
      this kind of thing :-)
    
      Main features:
       - RAID10 arrays can be reshaped - adding and removing devices and
         changing chunks (not 'far' array though)
       - allow RAID5 arrays to be reshaped with a backup file (not tested
         yet, but the priciple works fine for RAID10).
       - arrays can be reshaped while a bitmap is present - you no longer
         need to remove it first
       - SSSE3 support for RAID6 syndrome calculations
    
      and of course a number of minor fixes etc."
    
    * tag 'md-3.5' of git://neil.brown.name/md: (56 commits)
      md/bitmap: record the space available for the bitmap in the superblock.
      md/raid10: Remove extras after reshape to smaller number of devices.
      md/raid5: improve removal of extra devices after reshape.
      md: check the return of mddev_find()
      MD RAID1: Further conditionalize 'fullsync'
      DM RAID: Use md_error() in place of simply setting Faulty bit
      DM RAID: Record and handle missing devices
      DM RAID: Set recovery flags on resume
      md/raid5: Allow reshape while a bitmap is present.
      md/raid10: resize bitmap when required during reshape.
      md: allow array to be resized while bitmap is present.
      md/bitmap: make sure reshape request are reflected in superblock.
      md/bitmap: add bitmap_resize function to allow bitmap resizing.
      md/bitmap: use DIV_ROUND_UP instead of open-code
      md/bitmap: create a 'struct bitmap_counts' substructure of 'struct bitmap'
      md/bitmap: make bitmap bitops atomic.
      md/bitmap: make _page_attr bitops atomic.
      md/bitmap: merge bitmap_file_unmap and bitmap_file_put.
      md/bitmap: remove async freeing of bitmap file.
      md/bitmap: convert some spin_lock_irqsave to spin_lock_irq
      ...

commit 56a519913eeba2bdae4d7ee39e80fab442c3836c
Author: Jim Kukunas <james.t.kukunas@linux.intel.com>
Date:   Tue May 22 13:54:04 2012 +1000

    crypto: disable preemption while benchmarking RAID5 xor checksumming
    
    With CONFIG_PREEMPT=y, we need to disable preemption while benchmarking
    RAID5 xor checksumming to ensure we're actually measuring what we think
    we're measuring.
    
    Signed-off-by: Jim Kukunas <james.t.kukunas@linux.intel.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/crypto/xor.c b/crypto/xor.c
index 87884435bddb..84daa1111dad 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -21,6 +21,7 @@
 #include <linux/gfp.h>
 #include <linux/raid/xor.h>
 #include <linux/jiffies.h>
+#include <linux/preempt.h>
 #include <asm/xor.h>
 
 /* The xor routines to use.  */
@@ -69,6 +70,8 @@ do_xor_speed(struct xor_block_template *tmpl, void *b1, void *b2)
 	tmpl->next = template_list;
 	template_list = tmpl;
 
+	preempt_disable();
+
 	/*
 	 * Count the number of XORs done during a whole jiffy, and use
 	 * this to calculate the speed of checksumming.  We use a 2-page
@@ -91,6 +94,8 @@ do_xor_speed(struct xor_block_template *tmpl, void *b1, void *b2)
 			max = count;
 	}
 
+	preempt_enable();
+
 	speed = max * (HZ * BENCH_SIZE / 1024);
 	tmpl->speed = speed;
 

commit 6a328475cccacb99a13b06978091da936dd51d89
Author: Jim Kukunas <james.t.kukunas@linux.intel.com>
Date:   Tue May 22 13:54:03 2012 +1000

    crypto: wait for a full jiffy in do_xor_speed
    
    In the existing do_xor_speed(), there is no guarantee that we actually
    run do_2() for a full jiffy. We get the current jiffy, then run do_2()
    until the next jiffy.
    
    Instead, let's get the current jiffy, then wait until the next jiffy
    to start our test.
    
    Signed-off-by: Jim Kukunas <james.t.kukunas@linux.intel.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/crypto/xor.c b/crypto/xor.c
index b75182d8ab14..87884435bddb 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -63,7 +63,7 @@ static void
 do_xor_speed(struct xor_block_template *tmpl, void *b1, void *b2)
 {
 	int speed;
-	unsigned long now;
+	unsigned long now, j;
 	int i, count, max;
 
 	tmpl->next = template_list;
@@ -76,9 +76,11 @@ do_xor_speed(struct xor_block_template *tmpl, void *b1, void *b2)
 	 */
 	max = 0;
 	for (i = 0; i < 5; i++) {
-		now = jiffies;
+		j = jiffies;
 		count = 0;
-		while (jiffies == now) {
+		while ((now = jiffies) == j)
+			cpu_relax();
+		while (time_before(jiffies, now + 1)) {
 			mb(); /* prevent loop optimzation */
 			tmpl->do_2(BENCH_SIZE, b1, b2);
 			mb();

commit d788fec855e832ee3381d9d3afc91c9c0292e428
Author: Borislav Petkov <borislav.petkov@amd.com>
Date:   Wed Apr 4 15:06:10 2012 +0200

    crypto, xor: Sanitize checksumming function selection output
    
    Currently, it says
    
    [    1.015541] xor: automatically using best checksumming function: generic_sse
    [    1.040769]    generic_sse:  6679.000 MB/sec
    [    1.045377] xor: using function: generic_sse (6679.000 MB/sec)
    
    and repeats the function name three times unnecessarily. Change it into
    
    [    1.015115] xor: automatically using best checksumming function:
    [    1.040794]    generic_sse:  6680.000 MB/sec
    
    and save us a line in dmesg.
    
    No functional change.
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/xor.c b/crypto/xor.c
index b75182d8ab14..664b6dfa9e2c 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -129,9 +129,9 @@ calibrate_xor_blocks(void)
 
 	if (fastest) {
 		printk(KERN_INFO "xor: automatically using best "
-			"checksumming function: %s\n",
-			fastest->name);
+				 "checksumming function:\n");
 		xor_speed(fastest);
+		goto out;
 	} else {
 		printk(KERN_INFO "xor: measuring software checksum speed\n");
 		XOR_TRY_TEMPLATES;
@@ -146,6 +146,7 @@ calibrate_xor_blocks(void)
 
 #undef xor_speed
 
+ out:
 	free_pages((unsigned long)b1, 2);
 
 	active_template = fastest;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/crypto/xor.c b/crypto/xor.c
index fc5b836f3430..b75182d8ab14 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -18,6 +18,7 @@
 
 #define BH_TRACE 0
 #include <linux/module.h>
+#include <linux/gfp.h>
 #include <linux/raid/xor.h>
 #include <linux/jiffies.h>
 #include <asm/xor.h>

commit 33f65df7ed1abcaac32ba620b9976a4d8cea3248
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Thu Feb 26 09:55:52 2009 +0100

    crypto: don't track xor test pages with kmemcheck
    
    The xor tests are run on uninitialized data, because it is doesn't
    really matter what the underlying data is. Annotate this false-
    positive warning.
    
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>

diff --git a/crypto/xor.c b/crypto/xor.c
index 996b6ee57d9e..fc5b836f3430 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -101,7 +101,12 @@ calibrate_xor_blocks(void)
 	void *b1, *b2;
 	struct xor_block_template *f, *fastest;
 
-	b1 = (void *) __get_free_pages(GFP_KERNEL, 2);
+	/*
+	 * Note: Since the memory is not actually used for _anything_ but to
+	 * test the XOR speed, we don't really want kmemcheck to warn about
+	 * reading uninitialized bytes here.
+	 */
+	b1 = (void *) __get_free_pages(GFP_KERNEL | __GFP_NOTRACK, 2);
 	if (!b1) {
 		printk(KERN_WARNING "xor: Yikes!  No memory available.\n");
 		return -ENOMEM;

commit bff61975b3d6c18ee31457cc5b4d73042f44915f
Author: NeilBrown <neilb@suse.de>
Date:   Tue Mar 31 14:33:13 2009 +1100

    md: move lots of #include lines out of .h files and into .c
    
    This makes the includes more explicit, and is preparation for moving
    md_k.h to drivers/md/md.h
    
    Remove include/raid/md.h as its only remaining use was to #include
    other files.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/crypto/xor.c b/crypto/xor.c
index b2e6db075e49..996b6ee57d9e 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -18,8 +18,8 @@
 
 #define BH_TRACE 0
 #include <linux/module.h>
-#include <linux/raid/md.h>
 #include <linux/raid/xor.h>
+#include <linux/jiffies.h>
 #include <asm/xor.h>
 
 /* The xor routines to use.  */

commit 9bc89cd82d6f88fb0ca39b30445c329a430fd66b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 2 11:10:44 2007 -0700

    async_tx: add the async_tx api
    
    The async_tx api provides methods for describing a chain of asynchronous
    bulk memory transfers/transforms with support for inter-transactional
    dependencies.  It is implemented as a dmaengine client that smooths over
    the details of different hardware offload engine implementations.  Code
    that is written to the api can optimize for asynchronous operation and the
    api will fit the chain of operations to the available offload resources.
    
            I imagine that any piece of ADMA hardware would register with the
            'async_*' subsystem, and a call to async_X would be routed as
            appropriate, or be run in-line. - Neil Brown
    
    async_tx exploits the capabilities of struct dma_async_tx_descriptor to
    provide an api of the following general format:
    
    struct dma_async_tx_descriptor *
    async_<operation>(..., struct dma_async_tx_descriptor *depend_tx,
                            dma_async_tx_callback cb_fn, void *cb_param)
    {
            struct dma_chan *chan = async_tx_find_channel(depend_tx, <operation>);
            struct dma_device *device = chan ? chan->device : NULL;
            int int_en = cb_fn ? 1 : 0;
            struct dma_async_tx_descriptor *tx = device ?
                    device->device_prep_dma_<operation>(chan, len, int_en) : NULL;
    
            if (tx) { /* run <operation> asynchronously */
                    ...
                    tx->tx_set_dest(addr, tx, index);
                    ...
                    tx->tx_set_src(addr, tx, index);
                    ...
                    async_tx_submit(chan, tx, flags, depend_tx, cb_fn, cb_param);
            } else { /* run <operation> synchronously */
                    ...
                    <operation>
                    ...
                    async_tx_sync_epilog(flags, depend_tx, cb_fn, cb_param);
            }
    
            return tx;
    }
    
    async_tx_find_channel() returns a capable channel from its pool.  The
    channel pool is organized as a per-cpu array of channel pointers.  The
    async_tx_rebalance() routine is tasked with managing these arrays.  In the
    uniprocessor case async_tx_rebalance() tries to spread responsibility
    evenly over channels of similar capabilities.  For example if there are two
    copy+xor channels, one will handle copy operations and the other will
    handle xor.  In the SMP case async_tx_rebalance() attempts to spread the
    operations evenly over the cpus, e.g. cpu0 gets copy channel0 and xor
    channel0 while cpu1 gets copy channel 1 and xor channel 1.  When a
    dependency is specified async_tx_find_channel defaults to keeping the
    operation on the same channel.  A xor->copy->xor chain will stay on one
    channel if it supports both operation types, otherwise the transaction will
    transition between a copy and a xor resource.
    
    Currently the raid5 implementation in the MD raid456 driver has been
    converted to the async_tx api.  A driver for the offload engines on the
    Intel Xscale series of I/O processors, iop-adma, is provided in a later
    commit.  With the iop-adma driver and async_tx, raid456 is able to offload
    copy, xor, and xor-zero-sum operations to hardware engines.
    
    On iop342 tiobench showed higher throughput for sequential writes (20 - 30%
    improvement) and sequential reads to a degraded array (40 - 55%
    improvement).  For the other cases performance was roughly equal, +/- a few
    percentage points.  On a x86-smp platform the performance of the async_tx
    implementation (in synchronous mode) was also +/- a few percentage points
    of the original implementation.  According to 'top' on iop342 CPU
    utilization drops from ~50% to ~15% during a 'resync' while the speed
    according to /proc/mdstat doubles from ~25 MB/s to ~50 MB/s.
    
    The tiobench command line used for testing was: tiobench --size 2048
    --block 4096 --block 131072 --dir /mnt/raid --numruns 5
    * iop342 had 1GB of memory available
    
    Details:
    * if CONFIG_DMA_ENGINE=n the asynchronous path is compiled away by making
      async_tx_find_channel a static inline routine that always returns NULL
    * when a callback is specified for a given transaction an interrupt will
      fire at operation completion time and the callback will occur in a
      tasklet.  if the the channel does not support interrupts then a live
      polling wait will be performed
    * the api is written as a dmaengine client that requests all available
      channels
    * In support of dependencies the api implicitly schedules channel-switch
      interrupts.  The interrupt triggers the cleanup tasklet which causes
      pending operations to be scheduled on the next channel
    * Xor engines treat an xor destination address differently than a software
      xor routine.  To the software routine the destination address is an implied
      source, whereas engines treat it as a write-only destination.  This patch
      modifies the xor_blocks routine to take a an explicit destination address
      to mirror the hardware.
    
    Changelog:
    * fixed a leftover debug print
    * don't allow callbacks in async_interrupt_cond
    * fixed xor_block changes
    * fixed usage of ASYNC_TX_XOR_DROP_DEST
    * drop dma mapping methods, suggested by Chris Leech
    * printk warning fixups from Andrew Morton
    * don't use inline in C files, Adrian Bunk
    * select the API when MD is enabled
    * BUG_ON xor source counts <= 1
    * implicitly handle hardware concerns like channel switching and
      interrupts, Neil Brown
    * remove the per operation type list, and distribute operation capabilities
      evenly amongst the available channels
    * simplify async_tx_find_channel to optimize the fast path
    * introduce the channel_table_initialized flag to prevent early calls to
      the api
    * reorganize the code to mimic crypto
    * include mm.h as not all archs include it in dma-mapping.h
    * make the Kconfig options non-user visible, Adrian Bunk
    * move async_tx under crypto since it is meant as 'core' functionality, and
      the two may share algorithms in the future
    * move large inline functions into c files
    * checkpatch.pl fixes
    * gpl v2 only correction
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-By: NeilBrown <neilb@suse.de>

diff --git a/crypto/xor.c b/crypto/xor.c
index 8281ac5e68a8..b2e6db075e49 100644
--- a/crypto/xor.c
+++ b/crypto/xor.c
@@ -26,31 +26,30 @@
 static struct xor_block_template *active_template;
 
 void
-xor_blocks(unsigned int count, unsigned int bytes, void **ptr)
+xor_blocks(unsigned int src_count, unsigned int bytes, void *dest, void **srcs)
 {
-	unsigned long *p0, *p1, *p2, *p3, *p4;
+	unsigned long *p1, *p2, *p3, *p4;
 
-	p0 = (unsigned long *) ptr[0];
-	p1 = (unsigned long *) ptr[1];
-	if (count == 2) {
-		active_template->do_2(bytes, p0, p1);
+	p1 = (unsigned long *) srcs[0];
+	if (src_count == 1) {
+		active_template->do_2(bytes, dest, p1);
 		return;
 	}
 
-	p2 = (unsigned long *) ptr[2];
-	if (count == 3) {
-		active_template->do_3(bytes, p0, p1, p2);
+	p2 = (unsigned long *) srcs[1];
+	if (src_count == 2) {
+		active_template->do_3(bytes, dest, p1, p2);
 		return;
 	}
 
-	p3 = (unsigned long *) ptr[3];
-	if (count == 4) {
-		active_template->do_4(bytes, p0, p1, p2, p3);
+	p3 = (unsigned long *) srcs[2];
+	if (src_count == 3) {
+		active_template->do_4(bytes, dest, p1, p2, p3);
 		return;
 	}
 
-	p4 = (unsigned long *) ptr[4];
-	active_template->do_5(bytes, p0, p1, p2, p3, p4);
+	p4 = (unsigned long *) srcs[3];
+	active_template->do_5(bytes, dest, p1, p2, p3, p4);
 }
 EXPORT_SYMBOL(xor_blocks);
 
@@ -128,7 +127,7 @@ calibrate_xor_blocks(void)
 			fastest->name);
 		xor_speed(fastest);
 	} else {
-		printk(KERN_INFO "xor: measuring checksumming speed\n");
+		printk(KERN_INFO "xor: measuring software checksum speed\n");
 		XOR_TRY_TEMPLATES;
 		fastest = template_list;
 		for (f = fastest; f; f = f->next)

commit 685784aaf3cd0e3ff5e36c7ecf6f441cdbf57f73
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jul 9 11:56:42 2007 -0700

    xor: make 'xor_blocks' a library routine for use with async_tx
    
    The async_tx api tries to use a dma engine for an operation, but will fall
    back to an optimized software routine otherwise.  Xor support is
    implemented using the raid5 xor routines.  For organizational purposes this
    routine is moved to a common area.
    
    The following fixes are also made:
    * rename xor_block => xor_blocks, suggested by Adrian Bunk
    * ensure that xor.o initializes before md.o in the built-in case
    * checkpatch.pl fixes
    * mark calibrate_xor_blocks __init, Adrian Bunk
    
    Cc: Adrian Bunk <bunk@stusta.de>
    Cc: NeilBrown <neilb@suse.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/crypto/xor.c b/crypto/xor.c
new file mode 100644
index 000000000000..8281ac5e68a8
--- /dev/null
+++ b/crypto/xor.c
@@ -0,0 +1,156 @@
+/*
+ * xor.c : Multiple Devices driver for Linux
+ *
+ * Copyright (C) 1996, 1997, 1998, 1999, 2000,
+ * Ingo Molnar, Matti Aarnio, Jakub Jelinek, Richard Henderson.
+ *
+ * Dispatch optimized RAID-5 checksumming functions.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * (for example /usr/src/linux/COPYING); if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define BH_TRACE 0
+#include <linux/module.h>
+#include <linux/raid/md.h>
+#include <linux/raid/xor.h>
+#include <asm/xor.h>
+
+/* The xor routines to use.  */
+static struct xor_block_template *active_template;
+
+void
+xor_blocks(unsigned int count, unsigned int bytes, void **ptr)
+{
+	unsigned long *p0, *p1, *p2, *p3, *p4;
+
+	p0 = (unsigned long *) ptr[0];
+	p1 = (unsigned long *) ptr[1];
+	if (count == 2) {
+		active_template->do_2(bytes, p0, p1);
+		return;
+	}
+
+	p2 = (unsigned long *) ptr[2];
+	if (count == 3) {
+		active_template->do_3(bytes, p0, p1, p2);
+		return;
+	}
+
+	p3 = (unsigned long *) ptr[3];
+	if (count == 4) {
+		active_template->do_4(bytes, p0, p1, p2, p3);
+		return;
+	}
+
+	p4 = (unsigned long *) ptr[4];
+	active_template->do_5(bytes, p0, p1, p2, p3, p4);
+}
+EXPORT_SYMBOL(xor_blocks);
+
+/* Set of all registered templates.  */
+static struct xor_block_template *template_list;
+
+#define BENCH_SIZE (PAGE_SIZE)
+
+static void
+do_xor_speed(struct xor_block_template *tmpl, void *b1, void *b2)
+{
+	int speed;
+	unsigned long now;
+	int i, count, max;
+
+	tmpl->next = template_list;
+	template_list = tmpl;
+
+	/*
+	 * Count the number of XORs done during a whole jiffy, and use
+	 * this to calculate the speed of checksumming.  We use a 2-page
+	 * allocation to have guaranteed color L1-cache layout.
+	 */
+	max = 0;
+	for (i = 0; i < 5; i++) {
+		now = jiffies;
+		count = 0;
+		while (jiffies == now) {
+			mb(); /* prevent loop optimzation */
+			tmpl->do_2(BENCH_SIZE, b1, b2);
+			mb();
+			count++;
+			mb();
+		}
+		if (count > max)
+			max = count;
+	}
+
+	speed = max * (HZ * BENCH_SIZE / 1024);
+	tmpl->speed = speed;
+
+	printk(KERN_INFO "   %-10s: %5d.%03d MB/sec\n", tmpl->name,
+	       speed / 1000, speed % 1000);
+}
+
+static int __init
+calibrate_xor_blocks(void)
+{
+	void *b1, *b2;
+	struct xor_block_template *f, *fastest;
+
+	b1 = (void *) __get_free_pages(GFP_KERNEL, 2);
+	if (!b1) {
+		printk(KERN_WARNING "xor: Yikes!  No memory available.\n");
+		return -ENOMEM;
+	}
+	b2 = b1 + 2*PAGE_SIZE + BENCH_SIZE;
+
+	/*
+	 * If this arch/cpu has a short-circuited selection, don't loop through
+	 * all the possible functions, just test the best one
+	 */
+
+	fastest = NULL;
+
+#ifdef XOR_SELECT_TEMPLATE
+		fastest = XOR_SELECT_TEMPLATE(fastest);
+#endif
+
+#define xor_speed(templ)	do_xor_speed((templ), b1, b2)
+
+	if (fastest) {
+		printk(KERN_INFO "xor: automatically using best "
+			"checksumming function: %s\n",
+			fastest->name);
+		xor_speed(fastest);
+	} else {
+		printk(KERN_INFO "xor: measuring checksumming speed\n");
+		XOR_TRY_TEMPLATES;
+		fastest = template_list;
+		for (f = fastest; f; f = f->next)
+			if (f->speed > fastest->speed)
+				fastest = f;
+	}
+
+	printk(KERN_INFO "xor: using function: %s (%d.%03d MB/sec)\n",
+	       fastest->name, fastest->speed / 1000, fastest->speed % 1000);
+
+#undef xor_speed
+
+	free_pages((unsigned long)b1, 2);
+
+	active_template = fastest;
+	return 0;
+}
+
+static __exit void xor_exit(void) { }
+
+MODULE_LICENSE("GPL");
+
+/* when built-in xor.o must initialize before drivers/md/md.o */
+core_initcall(calibrate_xor_blocks);
+module_exit(xor_exit);
