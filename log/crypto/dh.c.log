commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/crypto/dh.c b/crypto/dh.c
index ce77fb4ee8b3..566f624a2de2 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*  Diffie-Hellman Key Agreement Method [RFC2631]
  *
  * Copyright (c) 2016, Intel Corporation
  * Authors: Salvatore Benedetto <salvatore.benedetto@intel.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #include <linux/module.h>

commit c4741b23059794bd99beef0f700103b0d983b3fd
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Apr 11 21:57:42 2019 -0700

    crypto: run initcalls for generic implementations earlier
    
    Use subsys_initcall for registration of all templates and generic
    algorithm implementations, rather than module_init.  Then change
    cryptomgr to use arch_initcall, to place it before the subsys_initcalls.
    
    This is needed so that when both a generic and optimized implementation
    of an algorithm are built into the kernel (not loadable modules), the
    generic implementation is registered before the optimized one.
    Otherwise, the self-tests for the optimized implementation are unable to
    allocate the generic implementation for the new comparison fuzz tests.
    
    Note that on arm, a side effect of this change is that self-tests for
    generic implementations may run before the unaligned access handler has
    been installed.  So, unaligned accesses will crash the kernel.  This is
    arguably a good thing as it makes it easier to detect that type of bug.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index 09a44de4209d..ce77fb4ee8b3 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -236,7 +236,7 @@ static void dh_exit(void)
 	crypto_unregister_kpp(&dh);
 }
 
-module_init(dh_init);
+subsys_initcall(dh_init);
 module_exit(dh_exit);
 MODULE_ALIAS_CRYPTO("dh");
 MODULE_LICENSE("GPL");

commit 3fd8093b41e745448ffeb0a0d3becc2cd1f9d7ad
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Jul 10 09:22:52 2018 -0500

    crypto: dh - fix memory leak
    
    In case memory resources for *base* were allocated, release them
    before return.
    
    Addresses-Coverity-ID: 1471702 ("Resource leak")
    Fixes: e3fe0ae12962 ("crypto: dh - add public key verification test")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Reviewed-by: Stephan MÃ¼ller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index 8f79269db2b7..09a44de4209d 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -174,7 +174,7 @@ static int dh_compute_value(struct kpp_request *req)
 		}
 		ret = dh_is_pubkey_valid(ctx, base);
 		if (ret)
-			goto err_free_val;
+			goto err_free_base;
 	} else {
 		base = ctx->g;
 	}

commit e3fe0ae129622b78e710e75ecbf7aca7af5dda47
Author: Stephan Mueller <smueller@chronox.de>
Date:   Wed Jun 27 08:15:31 2018 +0200

    crypto: dh - add public key verification test
    
    According to SP800-56A section 5.6.2.1, the public key to be processed
    for the DH operation shall be checked for appropriateness. The check
    shall covers the full verification test in case the domain parameter Q
    is provided as defined in SP800-56A section 5.6.2.3.1. If Q is not
    provided, the partial check according to SP800-56A section 5.6.2.3.2 is
    performed.
    
    The full verification test requires the presence of the domain parameter
    Q. Thus, the patch adds the support to handle Q. It is permissible to
    not provide the Q value as part of the domain parameters. This implies
    that the interface is still backwards-compatible where so far only P and
    G are to be provided. However, if Q is provided, it is imported.
    
    Without the test, the NIST ACVP testing fails. After adding this check,
    the NIST ACVP testing passes. Testing without providing the Q domain
    parameter has been performed to verify the interface has not changed.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index 5659fe7f446d..8f79269db2b7 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -16,14 +16,16 @@
 #include <linux/mpi.h>
 
 struct dh_ctx {
-	MPI p;
-	MPI g;
-	MPI xa;
+	MPI p;	/* Value is guaranteed to be set. */
+	MPI q;	/* Value is optional. */
+	MPI g;	/* Value is guaranteed to be set. */
+	MPI xa;	/* Value is guaranteed to be set. */
 };
 
 static void dh_clear_ctx(struct dh_ctx *ctx)
 {
 	mpi_free(ctx->p);
+	mpi_free(ctx->q);
 	mpi_free(ctx->g);
 	mpi_free(ctx->xa);
 	memset(ctx, 0, sizeof(*ctx));
@@ -60,6 +62,12 @@ static int dh_set_params(struct dh_ctx *ctx, struct dh *params)
 	if (!ctx->p)
 		return -EINVAL;
 
+	if (params->q && params->q_size) {
+		ctx->q = mpi_read_raw_data(params->q, params->q_size);
+		if (!ctx->q)
+			return -EINVAL;
+	}
+
 	ctx->g = mpi_read_raw_data(params->g, params->g_size);
 	if (!ctx->g)
 		return -EINVAL;
@@ -93,6 +101,55 @@ static int dh_set_secret(struct crypto_kpp *tfm, const void *buf,
 	return -EINVAL;
 }
 
+/*
+ * SP800-56A public key verification:
+ *
+ * * If Q is provided as part of the domain paramenters, a full validation
+ *   according to SP800-56A section 5.6.2.3.1 is performed.
+ *
+ * * If Q is not provided, a partial validation according to SP800-56A section
+ *   5.6.2.3.2 is performed.
+ */
+static int dh_is_pubkey_valid(struct dh_ctx *ctx, MPI y)
+{
+	if (unlikely(!ctx->p))
+		return -EINVAL;
+
+	/*
+	 * Step 1: Verify that 2 <= y <= p - 2.
+	 *
+	 * The upper limit check is actually y < p instead of y < p - 1
+	 * as the mpi_sub_ui function is yet missing.
+	 */
+	if (mpi_cmp_ui(y, 1) < 1 || mpi_cmp(y, ctx->p) >= 0)
+		return -EINVAL;
+
+	/* Step 2: Verify that 1 = y^q mod p */
+	if (ctx->q) {
+		MPI val = mpi_alloc(0);
+		int ret;
+
+		if (!val)
+			return -ENOMEM;
+
+		ret = mpi_powm(val, y, ctx->q, ctx->p);
+
+		if (ret) {
+			mpi_free(val);
+			return ret;
+		}
+
+		ret = mpi_cmp_ui(val, 1);
+
+		mpi_free(val);
+
+		if (ret != 0)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int dh_compute_value(struct kpp_request *req)
 {
 	struct crypto_kpp *tfm = crypto_kpp_reqtfm(req);
@@ -115,6 +172,9 @@ static int dh_compute_value(struct kpp_request *req)
 			ret = -EINVAL;
 			goto err_free_val;
 		}
+		ret = dh_is_pubkey_valid(ctx, base);
+		if (ret)
+			goto err_free_val;
 	} else {
 		base = ctx->g;
 	}

commit ced6a58638432c9f731184f908208d539725ba82
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Nov 5 18:30:48 2017 -0800

    crypto: dh - Remove pointless checks for NULL 'p' and 'g'
    
    Neither 'p' nor 'g' can be NULL, as they were unpacked using
    crypto_dh_decode_key().  And it makes no sense for them to be optional.
    So remove the NULL checks that were copy-and-pasted into both modules.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Reviewed-by: Tudor Ambarus <tudor.ambarus@microchip.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index aadaf36fb56f..5659fe7f446d 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -53,9 +53,6 @@ static int dh_check_params_length(unsigned int p_len)
 
 static int dh_set_params(struct dh_ctx *ctx, struct dh *params)
 {
-	if (unlikely(!params->p || !params->g))
-		return -EINVAL;
-
 	if (dh_check_params_length(params->p_size << 3))
 		return -EINVAL;
 

commit 12d41a023efb01b846457ccdbbcbe2b65a87d530
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Nov 5 18:30:44 2017 -0800

    crypto: dh - Fix double free of ctx->p
    
    When setting the secret with the software Diffie-Hellman implementation,
    if allocating 'g' failed (e.g. if it was longer than
    MAX_EXTERN_MPI_BITS), then 'p' was freed twice: once immediately, and
    once later when the crypto_kpp tfm was destroyed.
    
    Fix it by using dh_free_ctx() (renamed to dh_clear_ctx()) in the error
    paths, as that correctly sets the pointers to NULL.
    
    KASAN report:
    
        MPI: mpi too large (32760 bits)
        ==================================================================
        BUG: KASAN: use-after-free in mpi_free+0x131/0x170
        Read of size 4 at addr ffff88006c7cdf90 by task reproduce_doubl/367
    
        CPU: 1 PID: 367 Comm: reproduce_doubl Not tainted 4.14.0-rc7-00040-g05298abde6fe #7
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
        Call Trace:
         dump_stack+0xb3/0x10b
         ? mpi_free+0x131/0x170
         print_address_description+0x79/0x2a0
         ? mpi_free+0x131/0x170
         kasan_report+0x236/0x340
         ? akcipher_register_instance+0x90/0x90
         __asan_report_load4_noabort+0x14/0x20
         mpi_free+0x131/0x170
         ? akcipher_register_instance+0x90/0x90
         dh_exit_tfm+0x3d/0x140
         crypto_kpp_exit_tfm+0x52/0x70
         crypto_destroy_tfm+0xb3/0x250
         __keyctl_dh_compute+0x640/0xe90
         ? kasan_slab_free+0x12f/0x180
         ? dh_data_from_key+0x240/0x240
         ? key_create_or_update+0x1ee/0xb20
         ? key_instantiate_and_link+0x440/0x440
         ? lock_contended+0xee0/0xee0
         ? kfree+0xcf/0x210
         ? SyS_add_key+0x268/0x340
         keyctl_dh_compute+0xb3/0xf1
         ? __keyctl_dh_compute+0xe90/0xe90
         ? SyS_add_key+0x26d/0x340
         ? entry_SYSCALL_64_fastpath+0x5/0xbe
         ? trace_hardirqs_on_caller+0x3f4/0x560
         SyS_keyctl+0x72/0x2c0
         entry_SYSCALL_64_fastpath+0x1f/0xbe
        RIP: 0033:0x43ccf9
        RSP: 002b:00007ffeeec96158 EFLAGS: 00000246 ORIG_RAX: 00000000000000fa
        RAX: ffffffffffffffda RBX: 000000000248b9b9 RCX: 000000000043ccf9
        RDX: 00007ffeeec96170 RSI: 00007ffeeec96160 RDI: 0000000000000017
        RBP: 0000000000000046 R08: 0000000000000000 R09: 0248b9b9143dc936
        R10: 0000000000001000 R11: 0000000000000246 R12: 0000000000000000
        R13: 0000000000409670 R14: 0000000000409700 R15: 0000000000000000
    
        Allocated by task 367:
         save_stack_trace+0x16/0x20
         kasan_kmalloc+0xeb/0x180
         kmem_cache_alloc_trace+0x114/0x300
         mpi_alloc+0x4b/0x230
         mpi_read_raw_data+0xbe/0x360
         dh_set_secret+0x1dc/0x460
         __keyctl_dh_compute+0x623/0xe90
         keyctl_dh_compute+0xb3/0xf1
         SyS_keyctl+0x72/0x2c0
         entry_SYSCALL_64_fastpath+0x1f/0xbe
    
        Freed by task 367:
         save_stack_trace+0x16/0x20
         kasan_slab_free+0xab/0x180
         kfree+0xb5/0x210
         mpi_free+0xcb/0x170
         dh_set_secret+0x2d7/0x460
         __keyctl_dh_compute+0x623/0xe90
         keyctl_dh_compute+0xb3/0xf1
         SyS_keyctl+0x72/0x2c0
         entry_SYSCALL_64_fastpath+0x1f/0xbe
    
    Fixes: 802c7f1c84e4 ("crypto: dh - Add DH software implementation")
    Cc: <stable@vger.kernel.org> # v4.8+
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Reviewed-by: Tudor Ambarus <tudor.ambarus@microchip.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index b1032a5c1bfa..aadaf36fb56f 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -21,19 +21,12 @@ struct dh_ctx {
 	MPI xa;
 };
 
-static inline void dh_clear_params(struct dh_ctx *ctx)
+static void dh_clear_ctx(struct dh_ctx *ctx)
 {
 	mpi_free(ctx->p);
 	mpi_free(ctx->g);
-	ctx->p = NULL;
-	ctx->g = NULL;
-}
-
-static void dh_free_ctx(struct dh_ctx *ctx)
-{
-	dh_clear_params(ctx);
 	mpi_free(ctx->xa);
-	ctx->xa = NULL;
+	memset(ctx, 0, sizeof(*ctx));
 }
 
 /*
@@ -71,10 +64,8 @@ static int dh_set_params(struct dh_ctx *ctx, struct dh *params)
 		return -EINVAL;
 
 	ctx->g = mpi_read_raw_data(params->g, params->g_size);
-	if (!ctx->g) {
-		mpi_free(ctx->p);
+	if (!ctx->g)
 		return -EINVAL;
-	}
 
 	return 0;
 }
@@ -86,21 +77,23 @@ static int dh_set_secret(struct crypto_kpp *tfm, const void *buf,
 	struct dh params;
 
 	/* Free the old MPI key if any */
-	dh_free_ctx(ctx);
+	dh_clear_ctx(ctx);
 
 	if (crypto_dh_decode_key(buf, len, &params) < 0)
-		return -EINVAL;
+		goto err_clear_ctx;
 
 	if (dh_set_params(ctx, &params) < 0)
-		return -EINVAL;
+		goto err_clear_ctx;
 
 	ctx->xa = mpi_read_raw_data(params.key, params.key_size);
-	if (!ctx->xa) {
-		dh_clear_params(ctx);
-		return -EINVAL;
-	}
+	if (!ctx->xa)
+		goto err_clear_ctx;
 
 	return 0;
+
+err_clear_ctx:
+	dh_clear_ctx(ctx);
+	return -EINVAL;
 }
 
 static int dh_compute_value(struct kpp_request *req)
@@ -158,7 +151,7 @@ static void dh_exit_tfm(struct crypto_kpp *tfm)
 {
 	struct dh_ctx *ctx = dh_get_ctx(tfm);
 
-	dh_free_ctx(ctx);
+	dh_clear_ctx(ctx);
 }
 
 static struct kpp_alg dh = {

commit 7f69105077bfb36a8ff9c2ee20af50d921445fc0
Author: Tudor-Dan Ambarus <tudor.ambarus@microchip.com>
Date:   Thu May 25 10:18:09 2017 +0300

    crypto: dh - comply with crypto_kpp_maxsize()
    
    crypto_kpp_maxsize() asks for the output buffer size without
    caring for errors. It allways assume that will be called after
    a valid setkey. Comply with it and return what he wants.
    
    Signed-off-by: Tudor Ambarus <tudor.ambarus@microchip.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index e151f12775ca..b1032a5c1bfa 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -147,7 +147,7 @@ static int dh_compute_value(struct kpp_request *req)
 	return ret;
 }
 
-static int dh_max_size(struct crypto_kpp *tfm)
+static unsigned int dh_max_size(struct crypto_kpp *tfm)
 {
 	struct dh_ctx *ctx = dh_get_ctx(tfm);
 

commit ee34e2644a78e2561742bea8c4bdcf83cabf90a7
Author: Tudor-Dan Ambarus <tudor.ambarus@microchip.com>
Date:   Thu May 25 10:18:07 2017 +0300

    crypto: dh - fix memleak in setkey
    
    setkey can be called multiple times during the existence
    of the transformation object. In case of multiple setkey calls,
    the old key was not freed and we leaked memory.
    Free the old MPI key if any.
    
    Signed-off-by: Tudor Ambarus <tudor.ambarus@microchip.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index 7cec04985b9d..e151f12775ca 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -85,6 +85,9 @@ static int dh_set_secret(struct crypto_kpp *tfm, const void *buf,
 	struct dh_ctx *ctx = dh_get_ctx(tfm);
 	struct dh params;
 
+	/* Free the old MPI key if any */
+	dh_free_ctx(ctx);
+
 	if (crypto_dh_decode_key(buf, len, &params) < 0)
 		return -EINVAL;
 

commit c0ca1215dc92ee6a0f975c95a92fb7f9fb31e9e1
Author: Tudor-Dan Ambarus <tudor.ambarus@microchip.com>
Date:   Thu May 25 10:18:03 2017 +0300

    crypto: kpp, (ec)dh - fix typos
    
    While here, add missing argument description (ndigits).
    
    Signed-off-by: Tudor Ambarus <tudor.ambarus@microchip.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index 87e3542cf1b8..7cec04985b9d 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -4,9 +4,9 @@
  * Authors: Salvatore Benedetto <salvatore.benedetto@intel.com>
  *
  * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
+ * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
+ * 2 of the License, or (at your option) any later version.
  */
 
 #include <linux/module.h>

commit 5527dfb6ddac2aac98c2939f27840cb47abd5693
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Feb 24 15:46:58 2017 -0800

    crypto: kpp - constify buffer passed to crypto_kpp_set_secret()
    
    Constify the buffer passed to crypto_kpp_set_secret() and
    kpp_alg.set_secret, since it is never modified.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index ddcb528ab2cc..87e3542cf1b8 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -79,7 +79,8 @@ static int dh_set_params(struct dh_ctx *ctx, struct dh *params)
 	return 0;
 }
 
-static int dh_set_secret(struct crypto_kpp *tfm, void *buf, unsigned int len)
+static int dh_set_secret(struct crypto_kpp *tfm, const void *buf,
+			 unsigned int len)
 {
 	struct dh_ctx *ctx = dh_get_ctx(tfm);
 	struct dh params;

commit 8edda7d22a95caddcc66431e4564c7d03568da4d
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Tue Nov 8 15:48:22 2016 -0800

    crypto: dh - Consistenly return negative error codes
    
    Fix the single instance where a positive EINVAL was returned.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index 9d19360e7189..ddcb528ab2cc 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -118,7 +118,7 @@ static int dh_compute_value(struct kpp_request *req)
 	if (req->src) {
 		base = mpi_read_raw_from_sgl(req->src, req->src_len);
 		if (!base) {
-			ret = EINVAL;
+			ret = -EINVAL;
 			goto err_free_val;
 		}
 	} else {

commit 9b45b7bba3d22de52e09df63c50f390a193a3f53
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Wed Jun 29 19:32:21 2016 +0800

    crypto: rsa - Generate fixed-length output
    
    Every implementation of RSA that we have naturally generates
    output with leading zeroes.  The one and only user of RSA,
    pkcs1pad wants to have those leading zeroes in place, in fact
    because they are currently absent it has to write those zeroes
    itself.
    
    So we shouldn't be stripping leading zeroes in the first place.
    In fact this patch makes rsa-generic produce output with fixed
    length so that pkcs1pad does not need to do any extra work.
    
    This patch also changes DH to use the new interface.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
index 5e960fe28681..9d19360e7189 100644
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -129,7 +129,7 @@ static int dh_compute_value(struct kpp_request *req)
 	if (ret)
 		goto err_free_base;
 
-	ret = mpi_write_to_sgl(val, req->dst, &req->dst_len, &sign);
+	ret = mpi_write_to_sgl(val, req->dst, req->dst_len, &sign);
 	if (ret)
 		goto err_free_base;
 

commit 802c7f1c84e4b5a6ac78635878041023fc5831b1
Author: Salvatore Benedetto <salvatore.benedetto@intel.com>
Date:   Wed Jun 22 17:49:14 2016 +0100

    crypto: dh - Add DH software implementation
    
    * Implement MPI based Diffie-Hellman under kpp API
     * Test provided uses data generad by OpenSSL
    
    Signed-off-by: Salvatore Benedetto <salvatore.benedetto@intel.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/dh.c b/crypto/dh.c
new file mode 100644
index 000000000000..5e960fe28681
--- /dev/null
+++ b/crypto/dh.c
@@ -0,0 +1,189 @@
+/*  Diffie-Hellman Key Agreement Method [RFC2631]
+ *
+ * Copyright (c) 2016, Intel Corporation
+ * Authors: Salvatore Benedetto <salvatore.benedetto@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <crypto/internal/kpp.h>
+#include <crypto/kpp.h>
+#include <crypto/dh.h>
+#include <linux/mpi.h>
+
+struct dh_ctx {
+	MPI p;
+	MPI g;
+	MPI xa;
+};
+
+static inline void dh_clear_params(struct dh_ctx *ctx)
+{
+	mpi_free(ctx->p);
+	mpi_free(ctx->g);
+	ctx->p = NULL;
+	ctx->g = NULL;
+}
+
+static void dh_free_ctx(struct dh_ctx *ctx)
+{
+	dh_clear_params(ctx);
+	mpi_free(ctx->xa);
+	ctx->xa = NULL;
+}
+
+/*
+ * If base is g we compute the public key
+ *	ya = g^xa mod p; [RFC2631 sec 2.1.1]
+ * else if base if the counterpart public key we compute the shared secret
+ *	ZZ = yb^xa mod p; [RFC2631 sec 2.1.1]
+ */
+static int _compute_val(const struct dh_ctx *ctx, MPI base, MPI val)
+{
+	/* val = base^xa mod p */
+	return mpi_powm(val, base, ctx->xa, ctx->p);
+}
+
+static inline struct dh_ctx *dh_get_ctx(struct crypto_kpp *tfm)
+{
+	return kpp_tfm_ctx(tfm);
+}
+
+static int dh_check_params_length(unsigned int p_len)
+{
+	return (p_len < 1536) ? -EINVAL : 0;
+}
+
+static int dh_set_params(struct dh_ctx *ctx, struct dh *params)
+{
+	if (unlikely(!params->p || !params->g))
+		return -EINVAL;
+
+	if (dh_check_params_length(params->p_size << 3))
+		return -EINVAL;
+
+	ctx->p = mpi_read_raw_data(params->p, params->p_size);
+	if (!ctx->p)
+		return -EINVAL;
+
+	ctx->g = mpi_read_raw_data(params->g, params->g_size);
+	if (!ctx->g) {
+		mpi_free(ctx->p);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dh_set_secret(struct crypto_kpp *tfm, void *buf, unsigned int len)
+{
+	struct dh_ctx *ctx = dh_get_ctx(tfm);
+	struct dh params;
+
+	if (crypto_dh_decode_key(buf, len, &params) < 0)
+		return -EINVAL;
+
+	if (dh_set_params(ctx, &params) < 0)
+		return -EINVAL;
+
+	ctx->xa = mpi_read_raw_data(params.key, params.key_size);
+	if (!ctx->xa) {
+		dh_clear_params(ctx);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dh_compute_value(struct kpp_request *req)
+{
+	struct crypto_kpp *tfm = crypto_kpp_reqtfm(req);
+	struct dh_ctx *ctx = dh_get_ctx(tfm);
+	MPI base, val = mpi_alloc(0);
+	int ret = 0;
+	int sign;
+
+	if (!val)
+		return -ENOMEM;
+
+	if (unlikely(!ctx->xa)) {
+		ret = -EINVAL;
+		goto err_free_val;
+	}
+
+	if (req->src) {
+		base = mpi_read_raw_from_sgl(req->src, req->src_len);
+		if (!base) {
+			ret = EINVAL;
+			goto err_free_val;
+		}
+	} else {
+		base = ctx->g;
+	}
+
+	ret = _compute_val(ctx, base, val);
+	if (ret)
+		goto err_free_base;
+
+	ret = mpi_write_to_sgl(val, req->dst, &req->dst_len, &sign);
+	if (ret)
+		goto err_free_base;
+
+	if (sign < 0)
+		ret = -EBADMSG;
+err_free_base:
+	if (req->src)
+		mpi_free(base);
+err_free_val:
+	mpi_free(val);
+	return ret;
+}
+
+static int dh_max_size(struct crypto_kpp *tfm)
+{
+	struct dh_ctx *ctx = dh_get_ctx(tfm);
+
+	return mpi_get_size(ctx->p);
+}
+
+static void dh_exit_tfm(struct crypto_kpp *tfm)
+{
+	struct dh_ctx *ctx = dh_get_ctx(tfm);
+
+	dh_free_ctx(ctx);
+}
+
+static struct kpp_alg dh = {
+	.set_secret = dh_set_secret,
+	.generate_public_key = dh_compute_value,
+	.compute_shared_secret = dh_compute_value,
+	.max_size = dh_max_size,
+	.exit = dh_exit_tfm,
+	.base = {
+		.cra_name = "dh",
+		.cra_driver_name = "dh-generic",
+		.cra_priority = 100,
+		.cra_module = THIS_MODULE,
+		.cra_ctxsize = sizeof(struct dh_ctx),
+	},
+};
+
+static int dh_init(void)
+{
+	return crypto_register_kpp(&dh);
+}
+
+static void dh_exit(void)
+{
+	crypto_unregister_kpp(&dh);
+}
+
+module_init(dh_init);
+module_exit(dh_exit);
+MODULE_ALIAS_CRYPTO("dh");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("DH generic algorithm");
