commit ef26650a201fbbb4ba90b63a82bf7950f2699a82
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sat May 9 19:20:19 2020 +0800

    Smack: Remove unused inline function smk_ad_setfield_u_fs_path_mnt
    
    commit a269434d2fb4 ("LSM: separate LSM_AUDIT_DATA_DENTRY from LSM_AUDIT_DATA_PATH")
    left behind this, remove it.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 803b024d3585..e9e817d09785 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -497,10 +497,6 @@ static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,
 						    struct dentry *d)
 {
 }
-static inline void smk_ad_setfield_u_fs_path_mnt(struct smk_audit_info *a,
-						 struct vfsmount *m)
-{
-}
 static inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,
 					      struct inode *i)
 {

commit 921bb1cbb31bb0424b47de52174da20367449c8e
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Apr 24 15:23:04 2020 -0700

    Smack:- Remove mutex lock "smk_lock" from inode_smack
    
    "smk_lock" mutex is used during inode instantiation in
    smack_d_instantiate()function. It has been used to avoid
    simultaneous access on same inode security structure.
    Since smack related initialization is done only once i.e during
    inode creation. If the inode has already been instantiated then
    smack_d_instantiate() function just returns without doing
    anything.
    
    So it means mutex lock is required only during inode creation.
    But since 2 processes can't create same inodes or files
    simultaneously. Also linking or some other file operation can't
    be done simultaneously when the file is getting created since
    file lookup will fail before dentry inode linkup which is done
    after smack initialization.
    So no mutex lock is required in inode_smack structure.
    
    It will save memory as well as improve some performance.
    If 40000 inodes are created in system, it will save 1.5 MB on
    32-bit systems & 2.8 MB on 64-bit systems.
    
    Signed-off-by: Vishal Goel <vishal.goel@samsung.com>
    Signed-off-by: Amit Sahrawat <a.sahrawat@samsung.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 09ed7f343be4..803b024d3585 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -109,7 +109,6 @@ struct inode_smack {
 	struct smack_known	*smk_inode;	/* label of the fso */
 	struct smack_known	*smk_task;	/* label of the task */
 	struct smack_known	*smk_mmap;	/* label of the mmap domain */
-	struct mutex		smk_lock;	/* initialization lock */
 	int			smk_flags;	/* smack inode flags */
 };
 

commit 092c94aed3e1bb0946fc7ba176cc3b4376d9910f
Author: Maninder Singh <maninder1.s@samsung.com>
Date:   Thu Apr 9 18:09:58 2020 +0530

    smack: remove redundant structure variable from header.
    
    commit afb1cbe37440 ("LSM: Infrastructure management
    of the inode security") removed usage of smk_rcu,
    thus removing it from structure.
    
    Signed-off-by: Maninder Singh <maninder1.s@samsung.com>
    Signed-off-by: Vaneet Narang <v.narang@samsung.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 335d2411abe4..09ed7f343be4 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -111,7 +111,6 @@ struct inode_smack {
 	struct smack_known	*smk_mmap;	/* label of the mmap domain */
 	struct mutex		smk_lock;	/* initialization lock */
 	int			smk_flags;	/* smack inode flags */
-	struct rcu_head         smk_rcu;	/* for freeing inode_smack */
 };
 
 struct task_smack {

commit 00720f0e7f288d29681d265c23b22bb0f0f4e5b4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 8 21:04:31 2020 +0200

    smack: avoid unused 'sip' variable warning
    
    The mix of IS_ENABLED() and #ifdef checks has left a combination
    that causes a warning about an unused variable:
    
    security/smack/smack_lsm.c: In function 'smack_socket_connect':
    security/smack/smack_lsm.c:2838:24: error: unused variable 'sip' [-Werror=unused-variable]
     2838 |   struct sockaddr_in6 *sip = (struct sockaddr_in6 *)sap;
    
    Change the code to use C-style checks consistently so the compiler
    can handle it correctly.
    
    Fixes: 87fbfffcc89b ("broken ping to ipv6 linklocal addresses on debian buster")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 62529f382942..335d2411abe4 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -148,7 +148,6 @@ struct smk_net4addr {
 	struct smack_known	*smk_label;	/* label */
 };
 
-#if IS_ENABLED(CONFIG_IPV6)
 /*
  * An entry in the table identifying IPv6 hosts.
  */
@@ -159,9 +158,7 @@ struct smk_net6addr {
 	int			smk_masks;	/* mask size */
 	struct smack_known	*smk_label;	/* label */
 };
-#endif /* CONFIG_IPV6 */
 
-#ifdef SMACK_IPV6_PORT_LABELING
 /*
  * An entry in the table identifying ports.
  */
@@ -174,7 +171,6 @@ struct smk_port_label {
 	short			smk_sock_type;	/* Socket type */
 	short			smk_can_reuse;
 };
-#endif /* SMACK_IPV6_PORT_LABELING */
 
 struct smack_known_list_elem {
 	struct list_head	list;
@@ -335,9 +331,7 @@ extern struct smack_known smack_known_web;
 extern struct mutex	smack_known_lock;
 extern struct list_head smack_known_list;
 extern struct list_head smk_net4addr_list;
-#if IS_ENABLED(CONFIG_IPV6)
 extern struct list_head smk_net6addr_list;
-#endif /* CONFIG_IPV6 */
 
 extern struct mutex     smack_onlycap_lock;
 extern struct list_head smack_onlycap_list;

commit a10e763b87134a9a4ca3a38b5c4b533e75ec63a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:32 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 372
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 135 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081036.435762997@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index e41ca1d58484..62529f382942 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -1,13 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2007 Casey Schaufler <casey@schaufler-ca.com>
  *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation, version 2.
- *
  * Author:
  *      Casey Schaufler <casey@schaufler-ca.com>
- *
  */
 
 #ifndef _SECURITY_SMACK_H

commit 4e328b08882a68649df2c2b76fd208b0d0b85503
Author: Casey Schaufler <cschaufler@localhost.localdomain>
Date:   Tue Apr 2 11:37:12 2019 -0700

    Smack: Create smack_rule cache to optimize memory usage
    
    This patch allows for small memory optimization by creating the
    kmem cache for "struct smack_rule" instead of using kzalloc.
    For adding new smack rule, kzalloc is used to allocate the memory
    for "struct smack_rule". kzalloc will always allocate 32 or 64 bytes
    for 1 structure depending upon the kzalloc cache sizes available in
    system. Although the size of structure is 20 bytes only, resulting
    in memory wastage per object in the default pool.
    
    For e.g., if there are 20000 rules, then it will save 240KB(20000*12)
    which is crucial for small memory targets.
    
    Signed-off-by: Vishal Goel <vishal.goel@samsung.com>
    Signed-off-by: Amit Sahrawat <a.sahrawat@samsung.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index cf52af77d15e..e41ca1d58484 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -348,6 +348,7 @@ extern struct list_head smack_onlycap_list;
 
 #define SMACK_HASH_SLOTS 16
 extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
+extern struct kmem_cache *smack_rule_cache;
 
 static inline struct task_smack *smack_cred(const struct cred *cred)
 {

commit 7b47a9e7c8f672b6fb0b77fca11a63a8a77f5a91
Merge: dbc2fba3fc46 c99c2171fc61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 12 14:08:19 2019 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount infrastructure updates from Al Viro:
     "The rest of core infrastructure; no new syscalls in that pile, but the
      old parts are switched to new infrastructure. At that point
      conversions of individual filesystems can happen independently; some
      are done here (afs, cgroup, procfs, etc.), there's also a large series
      outside of that pile dealing with NFS (quite a bit of option-parsing
      stuff is getting used there - it's one of the most convoluted
      filesystems in terms of mount-related logics), but NFS bits are the
      next cycle fodder.
    
      It got seriously simplified since the last cycle; documentation is
      probably the weakest bit at the moment - I considered dropping the
      commit introducing Documentation/filesystems/mount_api.txt (cutting
      the size increase by quarter ;-), but decided that it would be better
      to fix it up after -rc1 instead.
    
      That pile allows to do followup work in independent branches, which
      should make life much easier for the next cycle. fs/super.c size
      increase is unpleasant; there's a followup series that allows to
      shrink it considerably, but I decided to leave that until the next
      cycle"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (41 commits)
      afs: Use fs_context to pass parameters over automount
      afs: Add fs_context support
      vfs: Add some logging to the core users of the fs_context log
      vfs: Implement logging through fs_context
      vfs: Provide documentation for new mount API
      vfs: Remove kern_mount_data()
      hugetlbfs: Convert to fs_context
      cpuset: Use fs_context
      kernfs, sysfs, cgroup, intel_rdt: Support fs_context
      cgroup: store a reference to cgroup_ns into cgroup_fs_context
      cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper
      cgroup_do_mount(): massage calling conventions
      cgroup: stash cgroup_root reference into cgroup_fs_context
      cgroup2: switch to option-by-option parsing
      cgroup1: switch to option-by-option parsing
      cgroup: take options parsing into ->parse_monolithic()
      cgroup: fold cgroup1_mount() into cgroup1_get_tree()
      cgroup: start switching to fs_context
      ipc: Convert mqueue fs to fs_context
      proc: Add fs_context support to procfs
      ...

commit 2febd254adc4958b2388c7a49ddc85227f41a158
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:24 2018 +0000

    smack: Implement filesystem context security hooks
    
    Implement filesystem context security hooks for the smack LSM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Casey Schaufler <casey@schaufler-ca.com>
    cc: linux-security-module@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index f7db791fb566..0380a9c89d3b 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -195,22 +195,13 @@ struct smack_known_list_elem {
 
 enum {
 	Opt_error = -1,
-	Opt_fsdefault = 1,
-	Opt_fsfloor = 2,
-	Opt_fshat = 3,
-	Opt_fsroot = 4,
-	Opt_fstransmute = 5,
+	Opt_fsdefault = 0,
+	Opt_fsfloor = 1,
+	Opt_fshat = 2,
+	Opt_fsroot = 3,
+	Opt_fstransmute = 4,
 };
 
-/*
- * Mount options
- */
-#define SMK_FSDEFAULT	"smackfsdef="
-#define SMK_FSFLOOR	"smackfsfloor="
-#define SMK_FSHAT	"smackfshat="
-#define SMK_FSROOT	"smackfsroot="
-#define SMK_FSTRANS	"smackfstransmute="
-
 #define SMACK_DELETE_OPTION	"-DELETE"
 #define SMACK_CIPSO_OPTION 	"-CIPSO"
 

commit ecd5f82e05ddd9b06c258167ec7467ac79741d77
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Tue Nov 20 11:55:02 2018 -0800

    LSM: Infrastructure management of the ipc security blob
    
    Move management of the kern_ipc_perm->security and
    msg_msg->security blobs out of the individual security
    modules and into the security infrastructure. Instead
    of allocating the blobs from within the modules the modules
    tell the infrastructure how much space is required, and
    the space is allocated there.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 0adddbeecc62..9c7c95a5c497 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -376,12 +376,12 @@ static inline struct inode_smack *smack_inode(const struct inode *inode)
 
 static inline struct smack_known **smack_msg_msg(const struct msg_msg *msg)
 {
-	return (struct smack_known **)&msg->security;
+	return msg->security + smack_blob_sizes.lbs_msg_msg;
 }
 
 static inline struct smack_known **smack_ipc(const struct kern_ipc_perm *ipc)
 {
-	return (struct smack_known **)&ipc->security;
+	return ipc->security + smack_blob_sizes.lbs_ipc;
 }
 
 /*

commit 019bcca4626a9ed119e1d9ebfadb9fdbdcf9b35b
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Sep 21 17:19:54 2018 -0700

    Smack: Abstract use of ipc security blobs
    
    Don't use the ipc->security pointer directly.
    Don't use the msg_msg->security pointer directly.
    Provide helper functions that provides the security blob pointers.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index bf0abc35ca1c..0adddbeecc62 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -24,6 +24,7 @@
 #include <linux/list.h>
 #include <linux/rculist.h>
 #include <linux/lsm_audit.h>
+#include <linux/msg.h>
 
 /*
  * Use IPv6 port labeling if IPv6 is enabled and secmarks
@@ -373,6 +374,16 @@ static inline struct inode_smack *smack_inode(const struct inode *inode)
 	return inode->i_security + smack_blob_sizes.lbs_inode;
 }
 
+static inline struct smack_known **smack_msg_msg(const struct msg_msg *msg)
+{
+	return (struct smack_known **)&msg->security;
+}
+
+static inline struct smack_known **smack_ipc(const struct kern_ipc_perm *ipc)
+{
+	return (struct smack_known **)&ipc->security;
+}
+
 /*
  * Is the directory transmuting?
  */

commit afb1cbe37440c7f38b9cf46fc331cc9dfd5cce21
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Sep 21 17:19:29 2018 -0700

    LSM: Infrastructure management of the inode security
    
    Move management of the inode->i_security blob out
    of the individual security modules and into the security
    infrastructure. Instead of allocating the blobs from within
    the modules the modules tell the infrastructure how much
    space is required, and the space is allocated there.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 436231dfae33..bf0abc35ca1c 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -370,7 +370,7 @@ static inline struct smack_known **smack_file(const struct file *file)
 
 static inline struct inode_smack *smack_inode(const struct inode *inode)
 {
-	return inode->i_security;
+	return inode->i_security + smack_blob_sizes.lbs_inode;
 }
 
 /*

commit fb4021b6fb5818df1228a35b7e2645038d01bb9f
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Nov 12 12:43:01 2018 -0800

    Smack: Abstract use of inode security blob
    
    Don't use the inode->i_security pointer directly.
    Provide a helper function that provides the security blob pointer.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 2007d38d0e46..436231dfae33 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -368,12 +368,17 @@ static inline struct smack_known **smack_file(const struct file *file)
 				       smack_blob_sizes.lbs_file);
 }
 
+static inline struct inode_smack *smack_inode(const struct inode *inode)
+{
+	return inode->i_security;
+}
+
 /*
  * Is the directory transmuting?
  */
 static inline int smk_inode_transmutable(const struct inode *isp)
 {
-	struct inode_smack *sip = isp->i_security;
+	struct inode_smack *sip = smack_inode(isp);
 	return (sip->smk_flags & SMK_INODE_TRANSMUTE) != 0;
 }
 
@@ -382,7 +387,7 @@ static inline int smk_inode_transmutable(const struct inode *isp)
  */
 static inline struct smack_known *smk_of_inode(const struct inode *isp)
 {
-	struct inode_smack *sip = isp->i_security;
+	struct inode_smack *sip = smack_inode(isp);
 	return sip->smk_inode;
 }
 

commit 33bf60cabcc7687b194a689b068b65e9ecd556be
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Nov 12 12:02:49 2018 -0800

    LSM: Infrastructure management of the file security
    
    Move management of the file->f_security blob out of the
    individual security modules and into the infrastructure.
    The modules no longer allocate or free the data, instead
    they tell the infrastructure how much space they require.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 50854969a391..2007d38d0e46 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -364,7 +364,8 @@ static inline struct task_smack *smack_cred(const struct cred *cred)
 
 static inline struct smack_known **smack_file(const struct file *file)
 {
-	return (struct smack_known **)&file->f_security;
+	return (struct smack_known **)(file->f_security +
+				       smack_blob_sizes.lbs_file);
 }
 
 /*

commit f28952ac900822a189fc383a5b73631e72c69356
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Nov 12 09:38:53 2018 -0800

    Smack: Abstract use of file security blob
    
    Don't use the file->f_security pointer directly.
    Provide a helper function that provides the security blob pointer.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index b27eb252e953..50854969a391 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -362,6 +362,11 @@ static inline struct task_smack *smack_cred(const struct cred *cred)
 	return cred->security + smack_blob_sizes.lbs_cred;
 }
 
+static inline struct smack_known **smack_file(const struct file *file)
+{
+	return (struct smack_known **)&file->f_security;
+}
+
 /*
  * Is the directory transmuting?
  */

commit bbd3662a834813730912a58efb44dd6df6d952e6
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Nov 12 09:30:56 2018 -0800

    Infrastructure management of the cred security blob
    
    Move management of the cred security blob out of the
    security modules and into the security infrastructre.
    Instead of allocating and freeing space the security
    modules tell the infrastructure how much space they
    require.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 01a922856eba..b27eb252e953 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -336,6 +336,7 @@ extern struct smack_known *smack_syslog_label;
 extern struct smack_known *smack_unconfined;
 #endif
 extern int smack_ptrace_rule;
+extern struct lsm_blob_sizes smack_blob_sizes;
 
 extern struct smack_known smack_known_floor;
 extern struct smack_known smack_known_hat;
@@ -358,7 +359,7 @@ extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
 
 static inline struct task_smack *smack_cred(const struct cred *cred)
 {
-	return cred->security;
+	return cred->security + smack_blob_sizes.lbs_cred;
 }
 
 /*

commit b17103a8b8ae9c9ecc5e1e6501b1478ee2dc6fe4
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Nov 9 16:12:56 2018 -0800

    Smack: Abstract use of cred security blob
    
    Don't use the cred->security pointer directly.
    Provide a helper function that provides the security blob pointer.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index f7db791fb566..01a922856eba 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -356,6 +356,11 @@ extern struct list_head smack_onlycap_list;
 #define SMACK_HASH_SLOTS 16
 extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
 
+static inline struct task_smack *smack_cred(const struct cred *cred)
+{
+	return cred->security;
+}
+
 /*
  * Is the directory transmuting?
  */
@@ -382,13 +387,19 @@ static inline struct smack_known *smk_of_task(const struct task_smack *tsp)
 	return tsp->smk_task;
 }
 
-static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)
+static inline struct smack_known *smk_of_task_struct(
+						const struct task_struct *t)
 {
 	struct smack_known *skp;
+	const struct cred *cred;
 
 	rcu_read_lock();
-	skp = smk_of_task(__task_cred(t)->security);
+
+	cred = __task_cred(t);
+	skp = smk_of_task(smack_cred(cred));
+
 	rcu_read_unlock();
+
 	return skp;
 }
 
@@ -405,7 +416,7 @@ static inline struct smack_known *smk_of_forked(const struct task_smack *tsp)
  */
 static inline struct smack_known *smk_of_current(void)
 {
-	return smk_of_task(current_security());
+	return smk_of_task(smack_cred(current_cred()));
 }
 
 /*

commit d19dfe58b7ecbef3bd0c403c650200c57913ba1b
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Jan 8 10:25:32 2018 -0800

    Smack: Privilege check on key operations
    
    Smack: Privilege check on key operations
    
    Operations on key objects are subjected to Smack policy
    even if the process is privileged. This is inconsistent
    with the general behavior of Smack and may cause issues
    with authentication by privileged daemons. This patch
    allows processes with CAP_MAC_OVERRIDE to access keys
    even if the Smack rules indicate otherwise.
    
    Reported-by: Jose Bollo <jobol@nonadev.net>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 6a71fc7831ab..f7db791fb566 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -321,6 +321,7 @@ struct smack_known *smk_import_entry(const char *, int);
 void smk_insert_entry(struct smack_known *skp);
 struct smack_known *smk_find_entry(const char *);
 bool smack_privileged(int cap);
+bool smack_privileged_cred(int cap, const struct cred *cred);
 void smk_destroy_label_list(struct list_head *list);
 
 /*

commit f28e783ff668cf5757182f6b00d488be37226bff
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed May 31 13:23:41 2017 -0700

    Smack: Use cap_capable in privilege check
    
    Use cap_capable() rather than capable() in the Smack privilege
    check as the former does not invoke other security module
    privilege check, while the later does. This becomes important
    when stacking. It may be a problem even with minor modules.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 612b810fbbc6..6a71fc7831ab 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -320,7 +320,7 @@ int smk_netlbl_mls(int, char *, struct netlbl_lsm_secattr *, int);
 struct smack_known *smk_import_entry(const char *, int);
 void smk_insert_entry(struct smack_known *skp);
 struct smack_known *smk_find_entry(const char *);
-int smack_privileged(int cap);
+bool smack_privileged(int cap);
 void smk_destroy_label_list(struct list_head *list);
 
 /*

commit 3d4f673a6988f57e6f6ccd1a3b79eee171545e08
Author: Himanshu Shukla <himanshu.sh@samsung.com>
Date:   Wed Nov 23 11:59:19 2016 +0530

    SMACK: Free the i_security blob in inode using RCU
    
    There is race condition issue while freeing the i_security blob in SMACK
    module. There is existing condition where i_security can be freed while
    inode_permission is called from path lookup on second CPU. There has been
    observed the page fault with such condition. VFS code and Selinux module
    takes care of this condition by freeing the inode and i_security field
    using RCU via call_rcu(). But in SMACK directly the i_secuirty blob is
    being freed. Use call_rcu() to fix this race condition issue.
    
    Signed-off-by: Himanshu Shukla <himanshu.sh@samsung.com>
    Signed-off-by: Vishal Goel <vishal.goel@samsung.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 2fac3b5bf44a..612b810fbbc6 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -114,6 +114,7 @@ struct inode_smack {
 	struct smack_known	*smk_mmap;	/* label of the mmap domain */
 	struct mutex		smk_lock;	/* initialization lock */
 	int			smk_flags;	/* smack inode flags */
+	struct rcu_head         smk_rcu;	/* for freeing inode_smack */
 };
 
 struct task_smack {

commit 0c96d1f5328e834048480e4696e6867992115c33
Author: Vishal Goel <vishal.goel@samsung.com>
Date:   Wed Nov 23 10:32:54 2016 +0530

    Smack: Fix the issue of wrong SMACK label update in socket bind fail case
    
    Fix the issue of wrong SMACK label (SMACK64IPIN) update when a second bind
    call is made to same IP address & port, but with different SMACK label
    (SMACK64IPIN) by second instance of server. In this case server returns
    with "Bind:Address already in use" error but before returning, SMACK label
    is updated in SMACK port-label mapping list inside smack_socket_bind() hook
    
    To fix this issue a new check has been added in smk_ipv6_port_label()
    function before updating the existing port entry. It checks whether the
    socket for matching port entry is closed or not. If it is closed then it
    means port is not bound and it is safe to update the existing port entry
    else return if port is still getting used. For checking whether socket is
    closed or not, one more field "smk_can_reuse" has been added in the
    "smk_port_label" structure. This field will be set to '1' in
    "smack_sk_free_security()" function which is called to free the socket
    security blob when the socket is being closed. In this function, port entry
    is searched in the SMACK port-label mapping list for the closing socket.
    If entry is found then "smk_can_reuse" field is set to '1'.Initially
    "smk_can_reuse" field is set to '0' in smk_ipv6_port_label() function after
    creating a new entry in the list which indicates that socket is in use.
    
    Signed-off-by: Vishal Goel <vishal.goel@samsung.com>
    Signed-off-by: Himanshu Shukla <himanshu.sh@samsung.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 73480ee07478..2fac3b5bf44a 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -174,6 +174,7 @@ struct smk_port_label {
 	struct smack_known	*smk_in;	/* inbound label */
 	struct smack_known	*smk_out;	/* outgoing label */
 	short			smk_sock_type;	/* Socket type */
+	short			smk_can_reuse;
 };
 #endif /* SMACK_IPV6_PORT_LABELING */
 

commit 9d44c97384fdc04585c5d5c985fe88ba7285b5ac
Author: Vishal Goel <vishal.goel@samsung.com>
Date:   Wed Nov 23 10:31:59 2016 +0530

    Smack: Fix the issue of permission denied error in ipv6 hook
    
    Permission denied error comes when 2 IPv6 servers are running and client
    tries to connect one of them. Scenario is that both servers are using same
    IP and port but different protocols(Udp and tcp). They are using different
    SMACK64IPIN labels.Tcp server is using "test" and udp server is using
    "test-in". When we try to run tcp client with SMACK64IPOUT label as "test",
    then connection denied error comes. It should not happen since both tcp
    server and client labels are same.This happens because there is no check
    for protocol in smk_ipv6_port_label() function while searching for the
    earlier port entry. It checks whether there is an existing port entry on
    the basis of port only. So it updates the earlier port entry in the list.
    Due to which smack label gets changed for earlier entry in the
    "smk_ipv6_port_list" list and permission denied error comes.
    
    Now a check is added for socket type also.Now if 2 processes use same
    port  but different protocols (tcp or udp), then 2 different port entries
    will be  added in the list. Similarly while checking smack access in
    smk_ipv6_port_check() function,  port entry is searched on the basis of
    both port and protocol.
    
    Signed-off-by: Vishal Goel <vishal.goel@samsung.com>
    Signed-off-by: Himanshu Shukla <Himanshu.sh@samsung.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 77abe2efacae..73480ee07478 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -173,6 +173,7 @@ struct smk_port_label {
 	unsigned short		smk_port;	/* the port number */
 	struct smack_known	*smk_in;	/* inbound label */
 	struct smack_known	*smk_out;	/* outgoing label */
+	short			smk_sock_type;	/* Socket type */
 };
 #endif /* SMACK_IPV6_PORT_LABELING */
 

commit 152f91d4d11a30106b9cc0b27b47e0e80b633ee8
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Nov 14 09:38:15 2016 -0800

    Smack: Remove unnecessary smack_known_invalid
    
    The invalid Smack label ("") and the Huh ("?") Smack label
    serve the same purpose and having both is unnecessary.
    While pulling out the invalid label it became clear that
    the use of smack_from_secid() was inconsistent, so that
    is repaired. The setting of inode labels to the invalid
    label could never happen in a functional system, has
    never been observed in the wild and is not what you'd
    really want for a failure behavior in any case. That is
    removed.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 51fd30192c08..77abe2efacae 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -336,7 +336,6 @@ extern int smack_ptrace_rule;
 extern struct smack_known smack_known_floor;
 extern struct smack_known smack_known_hat;
 extern struct smack_known smack_known_huh;
-extern struct smack_known smack_known_invalid;
 extern struct smack_known smack_known_star;
 extern struct smack_known smack_known_web;
 

commit c60b906673eebb4f65840fa9dc204401caf276ea
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Tue Aug 30 10:31:39 2016 -0700

    Smack: Signal delivery as an append operation
    
    Under a strict subject/object security policy delivering a
    signal or delivering network IPC could be considered either
    a write or an append operation. The original choice to make
    both write operations leads to an issue where IPC delivery
    is desired under policy, but delivery of signals is not.
    This patch provides the option of making signal delivery
    an append operation, allowing Smack rules that deny signal
    delivery while allowing IPC. This was requested for Tizen.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 26e58f1804b1..51fd30192c08 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -256,6 +256,16 @@ enum {
 #define MAY_LOCK	0x00002000	/* Locks should be writes, but ... */
 #define MAY_BRINGUP	0x00004000	/* Report use of this rule */
 
+/*
+ * The policy for delivering signals is configurable.
+ * It is usually "write", but can be "append".
+ */
+#ifdef CONFIG_SECURITY_SMACK_APPEND_SIGNALS
+#define MAY_DELIVER	MAY_APPEND	/* Signal delivery requires append */
+#else
+#define MAY_DELIVER	MAY_WRITE	/* Signal delivery requires write */
+#endif
+
 #define SMACK_BRINGUP_ALLOW		1	/* Allow bringup mode */
 #define SMACK_UNCONFINED_SUBJECT	2	/* Allow unconfined label */
 #define SMACK_UNCONFINED_OBJECT		3	/* Allow unconfined label */

commit 9f50eda2a9277e0bc51d8ca5dd2ec1d0e73601bc
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Wed Sep 23 15:16:06 2015 -0500

    Smack: Add support for unprivileged mounts from user namespaces
    
    Security labels from unprivileged mounts cannot be trusted.
    Ideally for these mounts we would assign the objects in the
    filesystem the same label as the inode for the backing device
    passed to mount. Unfortunately it's currently impossible to
    determine which inode this is from the LSM mount hooks, so we
    settle for the label of the process doing the mount.
    
    This label is assigned to s_root, and also to smk_default to
    ensure that new inodes receive this label. The transmute property
    is also set on s_root to make this behavior more explicit, even
    though it is technically not necessary.
    
    If a filesystem has existing security labels, access to inodes is
    permitted if the label is the same as smk_root, otherwise access
    is denied. The SMACK64EXEC xattr is completely ignored.
    
    Explicit setting of security labels continues to require
    CAP_MAC_ADMIN in init_user_ns.
    
    Altogether, this ensures that filesystem objects are not
    accessible to subjects which cannot already access the backing
    store, that MAC is not violated for any objects in the fileystem
    which are already labeled, and that a user cannot use an
    unprivileged mount to gain elevated MAC privileges.
    
    sysfs, tmpfs, and ramfs are already mountable from user
    namespaces and support security labels. We can't rule out the
    possibility that these filesystems may already be used in mounts
    from user namespaces with security lables set from the init
    namespace, so failing to trust lables in these filesystems may
    introduce regressions. It is safe to trust labels from these
    filesystems, since the unprivileged user does not control the
    backing store and thus cannot supply security labels, so an
    explicit exception is made to trust labels from these
    filesystems.
    
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 6c91156ae225..26e58f1804b1 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -90,9 +90,15 @@ struct superblock_smack {
 	struct smack_known	*smk_floor;
 	struct smack_known	*smk_hat;
 	struct smack_known	*smk_default;
-	int			smk_initialized;
+	int			smk_flags;
 };
 
+/*
+ * Superblock flags
+ */
+#define SMK_SB_INITIALIZED	0x01
+#define SMK_SB_UNTRUSTED	0x02
+
 struct socket_smack {
 	struct smack_known	*smk_out;	/* outbound label */
 	struct smack_known	*smk_in;	/* inbound label */

commit 38416e53936ecf896948fdeffc36b76979117952
Author: Zbigniew Jasinski <z.jasinski@samsung.com>
Date:   Mon Oct 19 18:23:53 2015 +0200

    Smack: limited capability for changing process label
    
    This feature introduces new kernel interface:
    
    - <smack_fs>/relabel-self - for setting transition labels list
    
    This list is used to control smack label transition mechanism.
    List is set by, and per process. Process can transit to new label only if
    label is on the list. Only process with CAP_MAC_ADMIN capability can add
    labels to this list. With this list, process can change it's label without
    CAP_MAC_ADMIN but only once. After label changing, list is unset.
    
    Changes in v2:
    * use list_for_each_entry instead of _rcu during label write
    * added missing description in security/Smack.txt
    
    Changes in v3:
    * squashed into one commit
    
    Changes in v4:
    * switch from global list to per-task list
    * since the per-task list is accessed only by the task itself
      there is no need to use synchronization mechanisms on it
    
    Changes in v5:
    * change smackfs interface of relabel-self to the one used for onlycap
      multiple labels are accepted, separated by space, which
      replace the previous list upon write
    
    Signed-off-by: Zbigniew Jasinski <z.jasinski@samsung.com>
    Signed-off-by: Rafal Krypa <r.krypa@samsung.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index fff0c612bbb7..6c91156ae225 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -115,6 +115,7 @@ struct task_smack {
 	struct smack_known	*smk_forked;	/* label when forked */
 	struct list_head	smk_rules;	/* per task access rules */
 	struct mutex		smk_rules_lock;	/* lock for the rules */
+	struct list_head	smk_relabel;	/* transit allowed labels */
 };
 
 #define	SMK_INODE_INSTANT	0x01	/* inode is instantiated */
@@ -169,7 +170,7 @@ struct smk_port_label {
 };
 #endif /* SMACK_IPV6_PORT_LABELING */
 
-struct smack_onlycap {
+struct smack_known_list_elem {
 	struct list_head	list;
 	struct smack_known	*smk_label;
 };
@@ -301,6 +302,7 @@ struct smack_known *smk_import_entry(const char *, int);
 void smk_insert_entry(struct smack_known *skp);
 struct smack_known *smk_find_entry(const char *);
 int smack_privileged(int cap);
+void smk_destroy_label_list(struct list_head *list);
 
 /*
  * Shared data.

commit 21abb1ec414c75abe32c3854848ff30e2b4a6113
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed Jul 22 14:25:31 2015 -0700

    Smack: IPv6 host labeling
    
    IPv6 appears to be (finally) coming of age with the
    influx of autonomous devices. In support of this, add
    the ability to associate a Smack label with IPv6 addresses.
    
    This patch also cleans up some of the conditional
    compilation associated with the introduction of
    secmark processing. It's now more obvious which bit
    of code goes with which feature.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 69ab9eb7d6d9..fff0c612bbb7 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -17,11 +17,26 @@
 #include <linux/spinlock.h>
 #include <linux/lsm_hooks.h>
 #include <linux/in.h>
+#if IS_ENABLED(CONFIG_IPV6)
+#include <linux/in6.h>
+#endif /* CONFIG_IPV6 */
 #include <net/netlabel.h>
 #include <linux/list.h>
 #include <linux/rculist.h>
 #include <linux/lsm_audit.h>
 
+/*
+ * Use IPv6 port labeling if IPv6 is enabled and secmarks
+ * are not being used.
+ */
+#if IS_ENABLED(CONFIG_IPV6) && !defined(CONFIG_SECURITY_SMACK_NETFILTER)
+#define SMACK_IPV6_PORT_LABELING 1
+#endif
+
+#if IS_ENABLED(CONFIG_IPV6) && defined(CONFIG_SECURITY_SMACK_NETFILTER)
+#define SMACK_IPV6_SECMARK_LABELING 1
+#endif
+
 /*
  * Smack labels were limited to 23 characters for a long time.
  */
@@ -118,15 +133,30 @@ struct smack_rule {
 };
 
 /*
- * An entry in the table identifying hosts.
+ * An entry in the table identifying IPv4 hosts.
  */
-struct smk_netlbladdr {
+struct smk_net4addr {
 	struct list_head	list;
-	struct sockaddr_in	smk_host;	/* network address */
+	struct in_addr		smk_host;	/* network address */
 	struct in_addr		smk_mask;	/* network mask */
+	int			smk_masks;	/* mask size */
+	struct smack_known	*smk_label;	/* label */
+};
+
+#if IS_ENABLED(CONFIG_IPV6)
+/*
+ * An entry in the table identifying IPv6 hosts.
+ */
+struct smk_net6addr {
+	struct list_head	list;
+	struct in6_addr		smk_host;	/* network address */
+	struct in6_addr		smk_mask;	/* network mask */
+	int			smk_masks;	/* mask size */
 	struct smack_known	*smk_label;	/* label */
 };
+#endif /* CONFIG_IPV6 */
 
+#ifdef SMACK_IPV6_PORT_LABELING
 /*
  * An entry in the table identifying ports.
  */
@@ -137,6 +167,7 @@ struct smk_port_label {
 	struct smack_known	*smk_in;	/* inbound label */
 	struct smack_known	*smk_out;	/* outgoing label */
 };
+#endif /* SMACK_IPV6_PORT_LABELING */
 
 struct smack_onlycap {
 	struct list_head	list;
@@ -170,6 +201,7 @@ enum {
 #define SMK_FSROOT	"smackfsroot="
 #define SMK_FSTRANS	"smackfstransmute="
 
+#define SMACK_DELETE_OPTION	"-DELETE"
 #define SMACK_CIPSO_OPTION 	"-CIPSO"
 
 /*
@@ -252,10 +284,6 @@ struct smk_audit_info {
 	struct smack_audit_data sad;
 #endif
 };
-/*
- * These functions are in smack_lsm.c
- */
-struct inode_smack *new_inode_smack(struct smack_known *);
 
 /*
  * These functions are in smack_access.c
@@ -285,7 +313,6 @@ extern struct smack_known *smack_syslog_label;
 #ifdef CONFIG_SECURITY_SMACK_BRINGUP
 extern struct smack_known *smack_unconfined;
 #endif
-extern struct smack_known smack_cipso_option;
 extern int smack_ptrace_rule;
 
 extern struct smack_known smack_known_floor;
@@ -297,7 +324,10 @@ extern struct smack_known smack_known_web;
 
 extern struct mutex	smack_known_lock;
 extern struct list_head smack_known_list;
-extern struct list_head smk_netlbladdr_list;
+extern struct list_head smk_net4addr_list;
+#if IS_ENABLED(CONFIG_IPV6)
+extern struct list_head smk_net6addr_list;
+#endif /* CONFIG_IPV6 */
 
 extern struct mutex     smack_onlycap_lock;
 extern struct list_head smack_onlycap_list;

commit 3bf2789cad9e6573dc19a6c3d123c2c049f2d90f
Author: Vivek Trivedi <t.vivek@samsung.com>
Date:   Mon Jun 22 15:36:06 2015 +0530

    smack: allow mount opts setting over filesystems with binary mount data
    
    Add support for setting smack mount labels(using smackfsdef, smackfsroot,
    smackfshat, smackfsfloor, smackfstransmute) for filesystems with binary
    mount data like NFS.
    
    To achieve this, implement sb_parse_opts_str and sb_set_mnt_opts security
    operations in smack LSM similar to SELinux.
    
    Signed-off-by: Vivek Trivedi <t.vivek@samsung.com>
    Signed-off-by: Amit Sahrawat <a.sahrawat@samsung.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 244e035e5a99..69ab9eb7d6d9 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -143,6 +143,24 @@ struct smack_onlycap {
 	struct smack_known	*smk_label;
 };
 
+/* Super block security struct flags for mount options */
+#define FSDEFAULT_MNT	0x01
+#define FSFLOOR_MNT	0x02
+#define FSHAT_MNT	0x04
+#define FSROOT_MNT	0x08
+#define FSTRANS_MNT	0x10
+
+#define NUM_SMK_MNT_OPTS	5
+
+enum {
+	Opt_error = -1,
+	Opt_fsdefault = 1,
+	Opt_fsfloor = 2,
+	Opt_fshat = 3,
+	Opt_fsroot = 4,
+	Opt_fstransmute = 5,
+};
+
 /*
  * Mount options
  */

commit c0d77c884461fc0dec0411e49797dc3f3651c31b
Author: Rafal Krypa <r.krypa@samsung.com>
Date:   Tue Jun 2 11:23:48 2015 +0200

    Smack: allow multiple labels in onlycap
    
    Smack onlycap allows limiting of CAP_MAC_ADMIN and CAP_MAC_OVERRIDE to
    processes running with the configured label. But having single privileged
    label is not enough in some real use cases. On a complex system like Tizen,
    there maybe few programs that need to configure Smack policy in run-time
    and running them all with a single label is not always practical.
    This patch extends onlycap feature for multiple labels. They are configured
    in the same smackfs "onlycap" interface, separated by spaces.
    
    Signed-off-by: Rafal Krypa <r.krypa@samsung.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index b8c1a869d85e..244e035e5a99 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -138,6 +138,11 @@ struct smk_port_label {
 	struct smack_known	*smk_out;	/* outgoing label */
 };
 
+struct smack_onlycap {
+	struct list_head	list;
+	struct smack_known	*smk_label;
+};
+
 /*
  * Mount options
  */
@@ -249,6 +254,7 @@ int smk_netlbl_mls(int, char *, struct netlbl_lsm_secattr *, int);
 struct smack_known *smk_import_entry(const char *, int);
 void smk_insert_entry(struct smack_known *skp);
 struct smack_known *smk_find_entry(const char *);
+int smack_privileged(int cap);
 
 /*
  * Shared data.
@@ -257,7 +263,6 @@ extern int smack_enabled;
 extern int smack_cipso_direct;
 extern int smack_cipso_mapped;
 extern struct smack_known *smack_net_ambient;
-extern struct smack_known *smack_onlycap;
 extern struct smack_known *smack_syslog_label;
 #ifdef CONFIG_SECURITY_SMACK_BRINGUP
 extern struct smack_known *smack_unconfined;
@@ -276,6 +281,9 @@ extern struct mutex	smack_known_lock;
 extern struct list_head smack_known_list;
 extern struct list_head smk_netlbladdr_list;
 
+extern struct mutex     smack_onlycap_lock;
+extern struct list_head smack_onlycap_list;
+
 #define SMACK_HASH_SLOTS 16
 extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
 
@@ -331,21 +339,6 @@ static inline struct smack_known *smk_of_current(void)
 	return smk_of_task(current_security());
 }
 
-/*
- * Is the task privileged and allowed to be privileged
- * by the onlycap rule.
- */
-static inline int smack_privileged(int cap)
-{
-	struct smack_known *skp = smk_of_current();
-
-	if (!capable(cap))
-		return 0;
-	if (smack_onlycap == NULL || smack_onlycap == skp)
-		return 1;
-	return 0;
-}
-
 /*
  * logging functions
  */

commit b1d9e6b0646d0e5ee5d9050bd236b6c65d66faef
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Sat May 2 15:11:42 2015 -0700

    LSM: Switch to lists of hooks
    
    Instead of using a vector of security operations
    with explicit, special case stacking of the capability
    and yama hooks use lists of hooks with capability and
    yama hooks included as appropriate.
    
    The security_operations structure is no longer required.
    Instead, there is a union of the function pointers that
    allows all the hooks lists to use a common mechanism for
    list management while retaining typing. Each module
    supplies an array describing the hooks it provides instead
    of a sparsely populated security_operations structure.
    The description includes the element that gets put on
    the hook list, avoiding the issues surrounding individual
    element allocation.
    
    The method for registering security modules is changed to
    reflect the information available. The method for removing
    a module, currently only used by SELinux, has also changed.
    It should be generic now, however if there are potential
    race conditions based on ordering of hook removal that needs
    to be addressed by the calling module.
    
    The security hooks are called from the lists and the first
    failure is returned.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 262dad8dfbc6..b8c1a869d85e 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -276,8 +276,6 @@ extern struct mutex	smack_known_lock;
 extern struct list_head smack_known_list;
 extern struct list_head smk_netlbladdr_list;
 
-extern struct security_operations smack_ops;
-
 #define SMACK_HASH_SLOTS 16
 extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
 

commit 3c4ed7bdf5997d8020cbb8d4abbef2fcfb9f1284
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Sat May 2 15:10:46 2015 -0700

    LSM: Split security.h
    
    The security.h header file serves two purposes,
    interfaces for users of the security modules and
    interfaces for security modules. Users of the
    security modules don't need to know about what's
    in the security_operations structure, so pull it
    out into it's own header, lsm_hooks.h
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 49eada6266ec..262dad8dfbc6 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -15,7 +15,7 @@
 
 #include <linux/capability.h>
 #include <linux/spinlock.h>
-#include <linux/security.h>
+#include <linux/lsm_hooks.h>
 #include <linux/in.h>
 #include <net/netlabel.h>
 #include <linux/list.h>

commit bf4b2fee99799780ea3dbb6d79d1909b3e32be13
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Sat Mar 21 18:26:40 2015 -0700

    Smack: Allow an unconfined label in bringup mode
    
    I have vehemently opposed adding a "permissive" mode to Smack
    for the simple reasons that it would be subject to massive abuse
    and that developers refuse to turn it off come product release.
    I still believe that this is true, and still refuse to add a
    general "permissive mode". So don't ask again.
    
    Bumjin Im suggested an approach that addresses most of the concerns,
    and I have implemented it here. I still believe that we'd be better
    off without this sort of thing, but it looks like this minimizes the
    abuse potential.
    
    Firstly, you have to configure Smack Bringup Mode. That allows
    for "release" software to be ammune from abuse. Second, only one
    label gets to be "permissive" at a time. You can use it for
    debugging, but that's about it.
    
    A label written to smackfs/unconfined is treated specially.
    If either the subject or object label of an access check
    matches the "unconfined" label, and the access would not
    have been allowed otherwise an audit record and a console
    message are generated. The audit record "request" string is
    marked with either "(US)" or "(UO)", to indicate that the
    request was granted because of an unconfined label. The
    fact that an inode was accessed by an unconfined label is
    remembered, and subsequent accesses to that "impure"
    object are noted in the log. The impurity is not stored in
    the filesystem, so a file mislabled as a side effect of
    using an unconfined label may still cause concern after
    a reboot.
    
    So, it's there, it's dangerous, but so many application
    developers seem incapable of living without it I have
    given in. I've tried to make it as safe as I can, but
    in the end it's still a chain saw.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 67ccb7b2b89b..49eada6266ec 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -105,6 +105,7 @@ struct task_smack {
 #define	SMK_INODE_INSTANT	0x01	/* inode is instantiated */
 #define	SMK_INODE_TRANSMUTE	0x02	/* directory is transmuting */
 #define	SMK_INODE_CHANGED	0x04	/* smack was transmuted */
+#define	SMK_INODE_IMPURE	0x08	/* involved in an impure transaction */
 
 /*
  * A label access rule.
@@ -193,6 +194,10 @@ struct smk_port_label {
 #define MAY_LOCK	0x00002000	/* Locks should be writes, but ... */
 #define MAY_BRINGUP	0x00004000	/* Report use of this rule */
 
+#define SMACK_BRINGUP_ALLOW		1	/* Allow bringup mode */
+#define SMACK_UNCONFINED_SUBJECT	2	/* Allow unconfined label */
+#define SMACK_UNCONFINED_OBJECT		3	/* Allow unconfined label */
+
 /*
  * Just to make the common cases easier to deal with
  */
@@ -254,6 +259,9 @@ extern int smack_cipso_mapped;
 extern struct smack_known *smack_net_ambient;
 extern struct smack_known *smack_onlycap;
 extern struct smack_known *smack_syslog_label;
+#ifdef CONFIG_SECURITY_SMACK_BRINGUP
+extern struct smack_known *smack_unconfined;
+#endif
 extern struct smack_known smack_cipso_option;
 extern int smack_ptrace_rule;
 

commit 6d1cff2a885850b78b40c34777b46cf5da5d1050
Author: Andrey Ryabinin <a.ryabinin@samsung.com>
Date:   Tue Jan 13 18:52:40 2015 +0300

    smack: fix possible use after frees in task_security() callers
    
    We hit use after free on dereferncing pointer to task_smack struct in
    smk_of_task() called from smack_task_to_inode().
    
    task_security() macro uses task_cred_xxx() to get pointer to the task_smack.
    task_cred_xxx() could be used only for non-pointer members of task's
    credentials. It cannot be used for pointer members since what they point
    to may disapper after dropping RCU read lock.
    
    Mainly task_security() used this way:
            smk_of_task(task_security(p))
    
    Intead of this introduce function smk_of_task_struct() which
    takes task_struct as argument and returns pointer to smk_known struct
    and do this under RCU read lock.
    Bogus task_security() macro is not used anymore, so remove it.
    
    KASan's report for this:
    
            AddressSanitizer: use after free in smack_task_to_inode+0x50/0x70 at addr c4635600
            =============================================================================
            BUG kmalloc-64 (Tainted: PO): kasan error
            -----------------------------------------------------------------------------
    
            Disabling lock debugging due to kernel taint
            INFO: Allocated in new_task_smack+0x44/0xd8 age=39 cpu=0 pid=1866
                    kmem_cache_alloc_trace+0x88/0x1bc
                    new_task_smack+0x44/0xd8
                    smack_cred_prepare+0x48/0x21c
                    security_prepare_creds+0x44/0x4c
                    prepare_creds+0xdc/0x110
                    smack_setprocattr+0x104/0x150
                    security_setprocattr+0x4c/0x54
                    proc_pid_attr_write+0x12c/0x194
                    vfs_write+0x1b0/0x370
                    SyS_write+0x5c/0x94
                    ret_fast_syscall+0x0/0x48
            INFO: Freed in smack_cred_free+0xc4/0xd0 age=27 cpu=0 pid=1564
                    kfree+0x270/0x290
                    smack_cred_free+0xc4/0xd0
                    security_cred_free+0x34/0x3c
                    put_cred_rcu+0x58/0xcc
                    rcu_process_callbacks+0x738/0x998
                    __do_softirq+0x264/0x4cc
                    do_softirq+0x94/0xf4
                    irq_exit+0xbc/0x120
                    handle_IRQ+0x104/0x134
                    gic_handle_irq+0x70/0xac
                    __irq_svc+0x44/0x78
                    _raw_spin_unlock+0x18/0x48
                    sync_inodes_sb+0x17c/0x1d8
                    sync_filesystem+0xac/0xfc
                    vdfs_file_fsync+0x90/0xc0
                    vfs_fsync_range+0x74/0x7c
            INFO: Slab 0xd3b23f50 objects=32 used=31 fp=0xc4635600 flags=0x4080
            INFO: Object 0xc4635600 @offset=5632 fp=0x  (null)
    
            Bytes b4 c46355f0: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
            Object c4635600: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
            Object c4635610: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
            Object c4635620: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
            Object c4635630: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.
            Redzone c4635640: bb bb bb bb                                      ....
            Padding c46356e8: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
            Padding c46356f8: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ
            CPU: 5 PID: 834 Comm: launchpad_prelo Tainted: PBO 3.10.30 #1
            Backtrace:
            [<c00233a4>] (dump_backtrace+0x0/0x158) from [<c0023dec>] (show_stack+0x20/0x24)
             r7:c4634010 r6:d3b23f50 r5:c4635600 r4:d1002140
            [<c0023dcc>] (show_stack+0x0/0x24) from [<c06d6d7c>] (dump_stack+0x20/0x28)
            [<c06d6d5c>] (dump_stack+0x0/0x28) from [<c01c1d50>] (print_trailer+0x124/0x144)
            [<c01c1c2c>] (print_trailer+0x0/0x144) from [<c01c1e88>] (object_err+0x3c/0x44)
             r7:c4635600 r6:d1002140 r5:d3b23f50 r4:c4635600
            [<c01c1e4c>] (object_err+0x0/0x44) from [<c01cac18>] (kasan_report_error+0x2b8/0x538)
             r6:d1002140 r5:d3b23f50 r4:c6429cf8 r3:c09e1aa7
            [<c01ca960>] (kasan_report_error+0x0/0x538) from [<c01c9430>] (__asan_load4+0xd4/0xf8)
            [<c01c935c>] (__asan_load4+0x0/0xf8) from [<c031e168>] (smack_task_to_inode+0x50/0x70)
             r5:c4635600 r4:ca9da000
            [<c031e118>] (smack_task_to_inode+0x0/0x70) from [<c031af64>] (security_task_to_inode+0x3c/0x44)
             r5:cca25e80 r4:c0ba9780
            [<c031af28>] (security_task_to_inode+0x0/0x44) from [<c023d614>] (pid_revalidate+0x124/0x178)
             r6:00000000 r5:cca25e80 r4:cbabe3c0 r3:00008124
            [<c023d4f0>] (pid_revalidate+0x0/0x178) from [<c01db98c>] (lookup_fast+0x35c/0x43y4)
             r9:c6429efc r8:00000101 r7:c079d940 r6:c6429e90 r5:c6429ed8 r4:c83c4148
            [<c01db630>] (lookup_fast+0x0/0x434) from [<c01deec8>] (do_last.isra.24+0x1c0/0x1108)
            [<c01ded08>] (do_last.isra.24+0x0/0x1108) from [<c01dff04>] (path_openat.isra.25+0xf4/0x648)
            [<c01dfe10>] (path_openat.isra.25+0x0/0x648) from [<c01e1458>] (do_filp_open+0x3c/0x88)
            [<c01e141c>] (do_filp_open+0x0/0x88) from [<c01ccb28>] (do_sys_open+0xf0/0x198)
             r7:00000001 r6:c0ea2180 r5:0000000b r4:00000000
            [<c01cca38>] (do_sys_open+0x0/0x198) from [<c01ccc00>] (SyS_open+0x30/0x34)
            [<c01ccbd0>] (SyS_open+0x0/0x34) from [<c001db80>] (ret_fast_syscall+0x0/0x48)
            Read of size 4 by thread T834:
            Memory state around the buggy address:
             c4635380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
             c4635400: 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc fc
             c4635480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
             c4635500: 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc fc
             c4635580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
            >c4635600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                       ^
             c4635680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
             c4635700: 00 00 00 00 04 fc fc fc fc fc fc fc fc fc fc fc
             c4635780: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
             c4635800: 00 00 00 00 00 00 04 fc fc fc fc fc fc fc fc fc
             c4635880: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
            ==================================================================
    
    Signed-off-by: Andrey Ryabinin <a.ryabinin@samsung.com>
    Cc: <stable@vger.kernel.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 7629eaeb1fb2..67ccb7b2b89b 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -299,6 +299,16 @@ static inline struct smack_known *smk_of_task(const struct task_smack *tsp)
 	return tsp->smk_task;
 }
 
+static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)
+{
+	struct smack_known *skp;
+
+	rcu_read_lock();
+	skp = smk_of_task(__task_cred(t)->security);
+	rcu_read_unlock();
+	return skp;
+}
+
 /*
  * Present a pointer to the forked smack label entry in an task blob.
  */

commit 69f287ae6fc8357e0bc561353a2d585b89ee8cdc
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Dec 12 17:08:40 2014 -0800

    Smack: secmark support for netfilter
    
    Smack uses CIPSO to label internet packets and thus provide
    for access control on delivery of packets. The netfilter facility
    was not used to allow for Smack to work properly without netfilter
    configuration. Smack does not need netfilter, however there are
    cases where it would be handy.
    
    As a side effect, the labeling of local IPv4 packets can be optimized
    and the handling of local IPv6 packets is just all out better.
    
    The best part is that the netfilter tools use "contexts" that
    are just strings, and they work just as well for Smack as they
    do for SELinux.
    
    All of the conditional compilation for IPv6 was implemented
    by Rafal Krypa <r.krypa@samsung.com>
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index b828a379377c..7629eaeb1fb2 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -248,6 +248,7 @@ struct smack_known *smk_find_entry(const char *);
 /*
  * Shared data.
  */
+extern int smack_enabled;
 extern int smack_cipso_direct;
 extern int smack_cipso_mapped;
 extern struct smack_known *smack_net_ambient;

commit 21c7eae21a2100a89cfb8cebaf7b770271f32c6e
Author: Lukasz Pawelczyk <l.pawelczyk@samsung.com>
Date:   Fri Aug 29 17:02:55 2014 +0200

    Make Smack operate on smack_known struct where it still used char*
    
    Smack used to use a mix of smack_known struct and char* throughout its
    APIs and implementation. This patch unifies the behaviour and makes it
    store and operate exclusively on smack_known struct pointers when managing
    labels.
    
    Signed-off-by: Lukasz Pawelczyk <l.pawelczyk@samsung.com>
    
    Conflicts:
            security/smack/smack_access.c
            security/smack/smack_lsm.c

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 2d13d5fb17ed..b828a379377c 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -71,11 +71,11 @@ struct smack_known {
 #define SMK_CIPSOLEN	24
 
 struct superblock_smack {
-	char		*smk_root;
-	char		*smk_floor;
-	char		*smk_hat;
-	char		*smk_default;
-	int		smk_initialized;
+	struct smack_known	*smk_root;
+	struct smack_known	*smk_floor;
+	struct smack_known	*smk_hat;
+	struct smack_known	*smk_default;
+	int			smk_initialized;
 };
 
 struct socket_smack {
@@ -88,7 +88,7 @@ struct socket_smack {
  * Inode smack data
  */
 struct inode_smack {
-	char			*smk_inode;	/* label of the fso */
+	struct smack_known	*smk_inode;	/* label of the fso */
 	struct smack_known	*smk_task;	/* label of the task */
 	struct smack_known	*smk_mmap;	/* label of the mmap domain */
 	struct mutex		smk_lock;	/* initialization lock */
@@ -112,7 +112,7 @@ struct task_smack {
 struct smack_rule {
 	struct list_head	list;
 	struct smack_known	*smk_subject;
-	char			*smk_object;
+	struct smack_known	*smk_object;
 	int			smk_access;
 };
 
@@ -123,7 +123,7 @@ struct smk_netlbladdr {
 	struct list_head	list;
 	struct sockaddr_in	smk_host;	/* network address */
 	struct in_addr		smk_mask;	/* network mask */
-	char			*smk_label;	/* label */
+	struct smack_known	*smk_label;	/* label */
 };
 
 /*
@@ -227,23 +227,23 @@ struct smk_audit_info {
 /*
  * These functions are in smack_lsm.c
  */
-struct inode_smack *new_inode_smack(char *);
+struct inode_smack *new_inode_smack(struct smack_known *);
 
 /*
  * These functions are in smack_access.c
  */
 int smk_access_entry(char *, char *, struct list_head *);
-int smk_access(struct smack_known *, char *, int, struct smk_audit_info *);
-int smk_tskacc(struct task_smack *, char *, u32, struct smk_audit_info *);
-int smk_curacc(char *, u32, struct smk_audit_info *);
+int smk_access(struct smack_known *, struct smack_known *,
+	       int, struct smk_audit_info *);
+int smk_tskacc(struct task_smack *, struct smack_known *,
+	       u32, struct smk_audit_info *);
+int smk_curacc(struct smack_known *, u32, struct smk_audit_info *);
 struct smack_known *smack_from_secid(const u32);
 char *smk_parse_smack(const char *string, int len);
 int smk_netlbl_mls(int, char *, struct netlbl_lsm_secattr *, int);
-char *smk_import(const char *, int);
 struct smack_known *smk_import_entry(const char *, int);
 void smk_insert_entry(struct smack_known *skp);
 struct smack_known *smk_find_entry(const char *);
-u32 smack_to_secid(const char *);
 
 /*
  * Shared data.
@@ -253,7 +253,7 @@ extern int smack_cipso_mapped;
 extern struct smack_known *smack_net_ambient;
 extern struct smack_known *smack_onlycap;
 extern struct smack_known *smack_syslog_label;
-extern const char *smack_cipso_option;
+extern struct smack_known smack_cipso_option;
 extern int smack_ptrace_rule;
 
 extern struct smack_known smack_known_floor;
@@ -282,9 +282,9 @@ static inline int smk_inode_transmutable(const struct inode *isp)
 }
 
 /*
- * Present a pointer to the smack label in an inode blob.
+ * Present a pointer to the smack label entry in an inode blob.
  */
-static inline char *smk_of_inode(const struct inode *isp)
+static inline struct smack_known *smk_of_inode(const struct inode *isp)
 {
 	struct inode_smack *sip = isp->i_security;
 	return sip->smk_inode;

commit d166c8024d620d654b12834fac354fb4203c6c22
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed Aug 27 14:51:27 2014 -0700

    Smack: Bring-up access mode
    
    People keep asking me for permissive mode, and I keep saying "no".
    
    Permissive mode is wrong for more reasons than I can enumerate,
    but the compelling one is that it's once on, never off.
    
    Nonetheless, there is an argument to be made for running a
    process with lots of permissions, logging which are required,
    and then locking the process down. There wasn't a way to do
    that with Smack, but this provides it.
    
    The notion is that you start out by giving the process an
    appropriate Smack label, such as "ATBirds". You create rules
    with a wide range of access and the "b" mode. On Tizen it
    might be:
    
            ATBirds System  rwxalb
            ATBirds User    rwxalb
            ATBirds _       rwxalb
            User    ATBirds wb
            System  ATBirds wb
    
    Accesses that fail will generate audit records. Accesses
    that succeed because of rules marked with a "b" generate
    log messages identifying the rule, the program and as much
    object information as is convenient.
    
    When the system is properly configured and the programs
    brought in line with the labeling scheme the "b" mode can
    be removed from the rules. When the system is ready for
    production the facility can be configured out.
    
    This provides the developer the convenience of permissive
    mode without creating a system that looks like it is
    enforcing a policy while it is not.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 020307ef0972..2d13d5fb17ed 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -191,6 +191,7 @@ struct smk_port_label {
  */
 #define MAY_TRANSMUTE	0x00001000	/* Controls directory labeling */
 #define MAY_LOCK	0x00002000	/* Locks should be writes, but ... */
+#define MAY_BRINGUP	0x00004000	/* Report use of this rule */
 
 /*
  * Just to make the common cases easier to deal with
@@ -200,9 +201,9 @@ struct smk_port_label {
 #define MAY_NOT		0
 
 /*
- * Number of access types used by Smack (rwxatl)
+ * Number of access types used by Smack (rwxatlb)
  */
-#define SMK_NUM_ACCESS_TYPE 6
+#define SMK_NUM_ACCESS_TYPE 7
 
 /* SMACK data */
 struct smack_audit_data {

commit 54e70ec5eb090193b03e69d551fa6771a5a217c4
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Thu Apr 10 16:37:08 2014 -0700

    Smack: bidirectional UDS connect check
    
    Smack IPC policy requires that the sender have write access
    to the receiver. UDS streams don't do per-packet checks. The
    only check is done at connect time. The existing code checks
    if the connecting process can write to the other, but not the
    other way around. This change adds a check that the other end
    can write to the connecting process.
    
    Targeted for git://git.gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schuafler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index fade085b1128..020307ef0972 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -80,8 +80,8 @@ struct superblock_smack {
 
 struct socket_smack {
 	struct smack_known	*smk_out;	/* outbound label */
-	char			*smk_in;	/* inbound label */
-	char			*smk_packet;	/* TCP peer label */
+	struct smack_known	*smk_in;	/* inbound label */
+	struct smack_known	*smk_packet;	/* TCP peer label */
 };
 
 /*
@@ -133,7 +133,7 @@ struct smk_port_label {
 	struct list_head	list;
 	struct sock		*smk_sock;	/* socket initialized on */
 	unsigned short		smk_port;	/* the port number */
-	char			*smk_in;	/* incoming label */
+	struct smack_known	*smk_in;	/* inbound label */
 	struct smack_known	*smk_out;	/* outgoing label */
 };
 

commit 668678185247303450e60df14569f94cf5775fea
Author: Lukasz Pawelczyk <l.pawelczyk@partner.samsung.com>
Date:   Tue Mar 11 17:07:06 2014 +0100

    Smack: adds smackfs/ptrace interface
    
    This allows to limit ptrace beyond the regular smack access rules.
    It adds a smackfs/ptrace interface that allows smack to be configured
    to require equal smack labels for PTRACE_MODE_ATTACH access.
    See the changes in Documentation/security/Smack.txt below for details.
    
    Signed-off-by: Lukasz Pawelczyk <l.pawelczyk@partner.samsung.com>
    Signed-off-by: Rafal Krypa <r.krypa@samsung.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index b9dfc4e1d3e0..fade085b1128 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -176,6 +176,14 @@ struct smk_port_label {
  */
 #define SMACK_CIPSO_MAXCATNUM           184     /* 23 * 8 */
 
+/*
+ * Ptrace rules
+ */
+#define SMACK_PTRACE_DEFAULT	0
+#define SMACK_PTRACE_EXACT	1
+#define SMACK_PTRACE_DRACONIAN	2
+#define SMACK_PTRACE_MAX	SMACK_PTRACE_DRACONIAN
+
 /*
  * Flags for untraditional access modes.
  * It shouldn't be necessary to avoid conflicts with definitions
@@ -245,6 +253,7 @@ extern struct smack_known *smack_net_ambient;
 extern struct smack_known *smack_onlycap;
 extern struct smack_known *smack_syslog_label;
 extern const char *smack_cipso_option;
+extern int smack_ptrace_rule;
 
 extern struct smack_known smack_known_floor;
 extern struct smack_known smack_known_hat;

commit 959e6c7f1eee42f14d31755b1134f5615db1d9bc
Author: Lukasz Pawelczyk <l.pawelczyk@partner.samsung.com>
Date:   Tue Mar 11 17:07:04 2014 +0100

    Smack: fix the subject/object order in smack_ptrace_traceme()
    
    The order of subject/object is currently reversed in
    smack_ptrace_traceme(). It is currently checked if the tracee has a
    capability to trace tracer and according to this rule a decision is made
    whether the tracer will be allowed to trace tracee.
    
    Signed-off-by: Lukasz Pawelczyk <l.pawelczyk@partner.samsung.com>
    Signed-off-by: Rafal Krypa <r.krypa@samsung.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index d072fd32212d..b9dfc4e1d3e0 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -225,6 +225,7 @@ struct inode_smack *new_inode_smack(char *);
  */
 int smk_access_entry(char *, char *, struct list_head *);
 int smk_access(struct smack_known *, char *, int, struct smk_audit_info *);
+int smk_tskacc(struct task_smack *, char *, u32, struct smk_audit_info *);
 int smk_curacc(char *, u32, struct smk_audit_info *);
 struct smack_known *smack_from_secid(const u32);
 char *smk_parse_smack(const char *string, int len);

commit 00f84f3f2e9d088f06722f4351d67f5f577abe22
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Dec 23 11:07:10 2013 -0800

    Smack: Make the syslog control configurable
    
    The syslog control requires that the calling proccess
    have the floor ("_") Smack label. Tizen does not run any
    processes except for kernel helpers with the floor label.
    This changes allows the admin to configure a specific
    label for syslog. The default value is the star ("*")
    label, effectively removing the restriction. The value
    can be set using smackfs/syslog for anyone who wants
    a more restrictive behavior.
    
    Targeted for git://git.gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 364cc64fce71..d072fd32212d 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -241,7 +241,8 @@ u32 smack_to_secid(const char *);
 extern int smack_cipso_direct;
 extern int smack_cipso_mapped;
 extern struct smack_known *smack_net_ambient;
-extern char *smack_onlycap;
+extern struct smack_known *smack_onlycap;
+extern struct smack_known *smack_syslog_label;
 extern const char *smack_cipso_option;
 
 extern struct smack_known smack_known_floor;
@@ -312,7 +313,7 @@ static inline int smack_privileged(int cap)
 
 	if (!capable(cap))
 		return 0;
-	if (smack_onlycap == NULL || smack_onlycap == skp->smk_known)
+	if (smack_onlycap == NULL || smack_onlycap == skp)
 		return 1;
 	return 0;
 }

commit c0ab6e56dcb7ca9903d460247cb464e769ae6e77
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Oct 11 18:06:39 2013 -0700

    Smack: Implement lock security mode
    
    Linux file locking does not follow the same rules
    as other mechanisms. Even though it is a write operation
    a process can set a read lock on files which it has open
    only for read access. Two programs with read access to
    a file can use read locks to communicate.
    
    This is not acceptable in a Mandatory Access Control
    environment. Smack treats setting a read lock as the
    write operation that it is. Unfortunately, many programs
    assume that setting a read lock is a read operation.
    These programs are unhappy in the Smack environment.
    
    This patch introduces a new access mode (lock) to address
    this problem. A process with lock access to a file can
    set a read lock. A process with write access to a file can
    set a read lock or a write lock. This prevents a situation
    where processes are granted write access just so they can
    set read locks.
    
    Targeted for git://git.gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 076b8e8a51ab..364cc64fce71 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -177,9 +177,13 @@ struct smk_port_label {
 #define SMACK_CIPSO_MAXCATNUM           184     /* 23 * 8 */
 
 /*
- * Flag for transmute access
+ * Flags for untraditional access modes.
+ * It shouldn't be necessary to avoid conflicts with definitions
+ * in fs.h, but do so anyway.
  */
-#define MAY_TRANSMUTE	64
+#define MAY_TRANSMUTE	0x00001000	/* Controls directory labeling */
+#define MAY_LOCK	0x00002000	/* Locks should be writes, but ... */
+
 /*
  * Just to make the common cases easier to deal with
  */
@@ -188,9 +192,9 @@ struct smk_port_label {
 #define MAY_NOT		0
 
 /*
- * Number of access types used by Smack (rwxat)
+ * Number of access types used by Smack (rwxatl)
  */
-#define SMK_NUM_ACCESS_TYPE 5
+#define SMK_NUM_ACCESS_TYPE 6
 
 /* SMACK data */
 struct smack_audit_data {

commit 677264e8fb73ea35a508700e19ce76c527576d1c
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Jun 28 13:47:07 2013 -0700

    Smack: network label match fix
    
    The Smack code that matches incoming CIPSO tags with Smack labels
    reaches through the NetLabel interfaces and compares the network
    data with the CIPSO header associated with a Smack label. This was
    done in a ill advised attempt to optimize performance. It works
    so long as the categories fit in a single capset, but this isn't
    always the case.
    
    This patch changes the Smack code to use the appropriate NetLabel
    interfaces to compare the incoming CIPSO header with the CIPSO
    header associated with a label. It will always match the CIPSO
    headers correctly.
    
    Targeted for git://git.gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index e80597a3048a..076b8e8a51ab 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -168,9 +168,13 @@ struct smk_port_label {
 #define SMACK_CIPSO_DOI_INVALID		-1	/* Not a DOI */
 #define SMACK_CIPSO_DIRECT_DEFAULT	250	/* Arbitrary */
 #define SMACK_CIPSO_MAPPED_DEFAULT	251	/* Also arbitrary */
-#define SMACK_CIPSO_MAXCATVAL		63	/* Bigger gets harder */
 #define SMACK_CIPSO_MAXLEVEL            255     /* CIPSO 2.2 standard */
-#define SMACK_CIPSO_MAXCATNUM           239     /* CIPSO 2.2 standard */
+/*
+ * CIPSO 2.2 standard is 239, but Smack wants to use the
+ * categories in a structured way that limits the value to
+ * the bits in 23 bytes, hence the unusual number.
+ */
+#define SMACK_CIPSO_MAXCATNUM           184     /* 23 * 8 */
 
 /*
  * Flag for transmute access

commit 4d7cf4a1f49f76f4069114ee08be75cd68c37c5a
Author: Tomasz Stanislawski <t.stanislaws@samsung.com>
Date:   Tue Jun 11 14:55:13 2013 +0200

    security: smack: add a hash table to quicken smk_find_entry()
    
    Accepted for the smack-next tree after changing the number of
    slots from 128 to 16.
    
    This patch adds a hash table to quicken searching of a smack label by its name.
    
    Basically, the patch improves performance of SMACK initialization.  Parsing of
    rules involves translation from a string to a smack_known (aka label) entity
    which is done in smk_find_entry().
    
    The current implementation of the function iterates over a global list of
    smack_known resulting in O(N) complexity for smk_find_entry().  The total
    complexity of SMACK initialization becomes O(rules * labels).  Therefore it
    scales quadratically with a complexity of a system.
    
    Applying the patch reduced the complexity of smk_find_entry() to O(1) as long
    as number of label is in hundreds. If the number of labels is increased please
    update SMACK_HASH_SLOTS constant defined in security/smack/smack.h. Introducing
    the configuration of this constant with Kconfig or cmdline might be a good
    idea.
    
    The size of the hash table was adjusted experimentally.  The rule set used by
    TIZEN contains circa 17K rules for 500 labels.  The table above contains
    results of SMACK initialization using 'time smackctl apply' bash command.
    The 'Ref' is a kernel without this patch applied. The consecutive values
    refers to value of SMACK_HASH_SLOTS.  Every measurement was repeated three
    times to reduce noise.
    
         |  Ref  |   1   |   2   |   4   |   8   |   16  |   32  |   64  |  128  |  256  |  512
    --------------------------------------------------------------------------------------------
    Run1 | 1.156 | 1.096 | 0.883 | 0.764 | 0.692 | 0.667 | 0.649 | 0.633 | 0.634 | 0.629 | 0.620
    Run2 | 1.156 | 1.111 | 0.885 | 0.764 | 0.694 | 0.661 | 0.649 | 0.651 | 0.634 | 0.638 | 0.623
    Run3 | 1.160 | 1.107 | 0.886 | 0.764 | 0.694 | 0.671 | 0.661 | 0.638 | 0.631 | 0.624 | 0.638
    AVG  | 1.157 | 1.105 | 0.885 | 0.764 | 0.693 | 0.666 | 0.653 | 0.641 | 0.633 | 0.630 | 0.627
    
    Surprisingly, a single hlist is slightly faster than a double-linked list.
    The speed-up saturates near 64 slots.  Therefore I chose value 128 to provide
    some margin if more labels were used.
    It looks that IO becomes a new bottleneck.
    
    Signed-off-by: Tomasz Stanislawski <t.stanislaws@samsung.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 339614c76e63..e80597a3048a 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -53,6 +53,7 @@
  */
 struct smack_known {
 	struct list_head		list;
+	struct hlist_node		smk_hashed;
 	char				*smk_known;
 	u32				smk_secid;
 	struct netlbl_lsm_secattr	smk_netlabel;	/* on wire labels */
@@ -222,6 +223,7 @@ char *smk_parse_smack(const char *string, int len);
 int smk_netlbl_mls(int, char *, struct netlbl_lsm_secattr *, int);
 char *smk_import(const char *, int);
 struct smack_known *smk_import_entry(const char *, int);
+void smk_insert_entry(struct smack_known *skp);
 struct smack_known *smk_find_entry(const char *);
 u32 smack_to_secid(const char *);
 
@@ -247,6 +249,9 @@ extern struct list_head smk_netlbladdr_list;
 
 extern struct security_operations smack_ops;
 
+#define SMACK_HASH_SLOTS 16
+extern struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];
+
 /*
  * Is the directory transmuting?
  */

commit e830b39412ca2bbedd7508243f21c04d57ad543c
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed May 22 18:43:07 2013 -0700

    Smack: Add smkfstransmute mount option
    
    Suppliment the smkfsroot mount option with another, smkfstransmute,
    that does the same thing but also marks the root inode as
    transmutting. This allows a freshly created filesystem to
    be mounted with a transmutting heirarchy.
    
    Targeted for git://git.gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 159f25bfcf45..339614c76e63 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -143,6 +143,7 @@ struct smk_port_label {
 #define SMK_FSFLOOR	"smackfsfloor="
 #define SMK_FSHAT	"smackfshat="
 #define SMK_FSROOT	"smackfsroot="
+#define SMK_FSTRANS	"smackfstransmute="
 
 #define SMACK_CIPSO_OPTION 	"-CIPSO"
 

commit 2f823ff8bec03a1e6f9e11fd0c4d54e4c7d09532
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed May 22 18:43:03 2013 -0700

    Smack: Improve access check performance
    
    Each Smack label that the kernel has seen is added to a
    list of labels. The list of access rules for a given subject
    label hangs off of the label list entry for the label.
    This patch changes the structures that contain subject
    labels to point at the label list entry rather that the
    label itself. Doing so removes a label list lookup in
    smk_access() that was accounting for the largest single
    chunk of Smack overhead.
    
    Targeted for git://git.gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index bb28e099abfe..159f25bfcf45 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -28,6 +28,38 @@
 #define SMK_LABELLEN	24
 #define SMK_LONGLABEL	256
 
+/*
+ * This is the repository for labels seen so that it is
+ * not necessary to keep allocating tiny chuncks of memory
+ * and so that they can be shared.
+ *
+ * Labels are never modified in place. Anytime a label
+ * is imported (e.g. xattrset on a file) the list is checked
+ * for it and it is added if it doesn't exist. The address
+ * is passed out in either case. Entries are added, but
+ * never deleted.
+ *
+ * Since labels are hanging around anyway it doesn't
+ * hurt to maintain a secid for those awkward situations
+ * where kernel components that ought to use LSM independent
+ * interfaces don't. The secid should go away when all of
+ * these components have been repaired.
+ *
+ * The cipso value associated with the label gets stored here, too.
+ *
+ * Keep the access rules for this subject label here so that
+ * the entire set of rules does not need to be examined every
+ * time.
+ */
+struct smack_known {
+	struct list_head		list;
+	char				*smk_known;
+	u32				smk_secid;
+	struct netlbl_lsm_secattr	smk_netlabel;	/* on wire labels */
+	struct list_head		smk_rules;	/* access rules */
+	struct mutex			smk_rules_lock;	/* lock for rules */
+};
+
 /*
  * Maximum number of bytes for the levels in a CIPSO IP option.
  * Why 23? CIPSO is constrained to 30, so a 32 byte buffer is
@@ -46,25 +78,25 @@ struct superblock_smack {
 };
 
 struct socket_smack {
-	char		*smk_out;	/* outbound label */
-	char		*smk_in;	/* inbound label */
-	char		*smk_packet;	/* TCP peer label */
+	struct smack_known	*smk_out;	/* outbound label */
+	char			*smk_in;	/* inbound label */
+	char			*smk_packet;	/* TCP peer label */
 };
 
 /*
  * Inode smack data
  */
 struct inode_smack {
-	char		*smk_inode;	/* label of the fso */
-	char		*smk_task;	/* label of the task */
-	char		*smk_mmap;	/* label of the mmap domain */
-	struct mutex	smk_lock;	/* initialization lock */
-	int		smk_flags;	/* smack inode flags */
+	char			*smk_inode;	/* label of the fso */
+	struct smack_known	*smk_task;	/* label of the task */
+	struct smack_known	*smk_mmap;	/* label of the mmap domain */
+	struct mutex		smk_lock;	/* initialization lock */
+	int			smk_flags;	/* smack inode flags */
 };
 
 struct task_smack {
-	char			*smk_task;	/* label for access control */
-	char			*smk_forked;	/* label when forked */
+	struct smack_known	*smk_task;	/* label for access control */
+	struct smack_known	*smk_forked;	/* label when forked */
 	struct list_head	smk_rules;	/* per task access rules */
 	struct mutex		smk_rules_lock;	/* lock for the rules */
 };
@@ -78,7 +110,7 @@ struct task_smack {
  */
 struct smack_rule {
 	struct list_head	list;
-	char			*smk_subject;
+	struct smack_known	*smk_subject;
 	char			*smk_object;
 	int			smk_access;
 };
@@ -101,39 +133,7 @@ struct smk_port_label {
 	struct sock		*smk_sock;	/* socket initialized on */
 	unsigned short		smk_port;	/* the port number */
 	char			*smk_in;	/* incoming label */
-	char			*smk_out;	/* outgoing label */
-};
-
-/*
- * This is the repository for labels seen so that it is
- * not necessary to keep allocating tiny chuncks of memory
- * and so that they can be shared.
- *
- * Labels are never modified in place. Anytime a label
- * is imported (e.g. xattrset on a file) the list is checked
- * for it and it is added if it doesn't exist. The address
- * is passed out in either case. Entries are added, but
- * never deleted.
- *
- * Since labels are hanging around anyway it doesn't
- * hurt to maintain a secid for those awkward situations
- * where kernel components that ought to use LSM independent
- * interfaces don't. The secid should go away when all of
- * these components have been repaired.
- *
- * The cipso value associated with the label gets stored here, too.
- *
- * Keep the access rules for this subject label here so that
- * the entire set of rules does not need to be examined every
- * time.
- */
-struct smack_known {
-	struct list_head		list;
-	char				*smk_known;
-	u32				smk_secid;
-	struct netlbl_lsm_secattr	smk_netlabel;	/* on wire labels */
-	struct list_head		smk_rules;	/* access rules */
-	struct mutex			smk_rules_lock;	/* lock for rules */
+	struct smack_known	*smk_out;	/* outgoing label */
 };
 
 /*
@@ -214,9 +214,9 @@ struct inode_smack *new_inode_smack(char *);
  * These functions are in smack_access.c
  */
 int smk_access_entry(char *, char *, struct list_head *);
-int smk_access(char *, char *, int, struct smk_audit_info *);
+int smk_access(struct smack_known *, char *, int, struct smk_audit_info *);
 int smk_curacc(char *, u32, struct smk_audit_info *);
-char *smack_from_secid(const u32);
+struct smack_known *smack_from_secid(const u32);
 char *smk_parse_smack(const char *string, int len);
 int smk_netlbl_mls(int, char *, struct netlbl_lsm_secattr *, int);
 char *smk_import(const char *, int);
@@ -229,7 +229,7 @@ u32 smack_to_secid(const char *);
  */
 extern int smack_cipso_direct;
 extern int smack_cipso_mapped;
-extern char *smack_net_ambient;
+extern struct smack_known *smack_net_ambient;
 extern char *smack_onlycap;
 extern const char *smack_cipso_option;
 
@@ -265,17 +265,17 @@ static inline char *smk_of_inode(const struct inode *isp)
 }
 
 /*
- * Present a pointer to the smack label in an task blob.
+ * Present a pointer to the smack label entry in an task blob.
  */
-static inline char *smk_of_task(const struct task_smack *tsp)
+static inline struct smack_known *smk_of_task(const struct task_smack *tsp)
 {
 	return tsp->smk_task;
 }
 
 /*
- * Present a pointer to the forked smack label in an task blob.
+ * Present a pointer to the forked smack label entry in an task blob.
  */
-static inline char *smk_of_forked(const struct task_smack *tsp)
+static inline struct smack_known *smk_of_forked(const struct task_smack *tsp)
 {
 	return tsp->smk_forked;
 }
@@ -283,7 +283,7 @@ static inline char *smk_of_forked(const struct task_smack *tsp)
 /*
  * Present a pointer to the smack label in the current task blob.
  */
-static inline char *smk_of_current(void)
+static inline struct smack_known *smk_of_current(void)
 {
 	return smk_of_task(current_security());
 }
@@ -294,9 +294,11 @@ static inline char *smk_of_current(void)
  */
 static inline int smack_privileged(int cap)
 {
+	struct smack_known *skp = smk_of_current();
+
 	if (!capable(cap))
 		return 0;
-	if (smack_onlycap == NULL || smack_onlycap == smk_of_current())
+	if (smack_onlycap == NULL || smack_onlycap == skp->smk_known)
 		return 1;
 	return 0;
 }

commit c673944347edfd4362b10eea11ac384a582b1cf5
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed May 22 18:42:56 2013 -0700

    Smack: Local IPv6 port based controls
    
    Smack does not provide access controls on IPv6 communications.
    This patch introduces a mechanism for maintaining Smack lables
    for local IPv6 communications. It is based on labeling local ports.
    The behavior should be compatible with any future "real" IPv6
    support as it provides no interfaces for users to manipulate
    the labeling. Remote IPv6 connections use the ambient label
    the same way that unlabeled IPv4 packets are treated.
    
    Targeted for git://git.gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 8ad30955e15d..bb28e099abfe 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -93,6 +93,17 @@ struct smk_netlbladdr {
 	char			*smk_label;	/* label */
 };
 
+/*
+ * An entry in the table identifying ports.
+ */
+struct smk_port_label {
+	struct list_head	list;
+	struct sock		*smk_sock;	/* socket initialized on */
+	unsigned short		smk_port;	/* the port number */
+	char			*smk_in;	/* incoming label */
+	char			*smk_out;	/* outgoing label */
+};
+
 /*
  * This is the repository for labels seen so that it is
  * not necessary to keep allocating tiny chuncks of memory

commit cee7e443344a3845e5b9111614b41e0b1afb60ce
Author: Jarkko Sakkinen <jarkko.sakkinen@iki.fi>
Date:   Tue Nov 6 10:17:49 2012 +0200

    smack: SMACK_MAGIC to include/uapi/linux/magic.h
    
    SMACK_MAGIC moved to a proper place for easy user space access
    (i.e. libsmack).
    
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@iki.fi>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 99b36124f712..8ad30955e15d 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -148,11 +148,6 @@ struct smack_known {
 #define SMACK_UNLABELED_SOCKET	0
 #define SMACK_CIPSO_SOCKET	1
 
-/*
- * smackfs magic number
- */
-#define SMACK_MAGIC	0x43415d53 /* "SMAC" */
-
 /*
  * CIPSO defaults.
  */

commit 1880eff77e7a7cb46c68fae7cfa33f72f0a6e70e
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Tue Jun 5 15:28:30 2012 -0700

    Smack: onlycap limits on CAP_MAC_ADMIN
    
    Smack is integrated with the POSIX capabilities scheme,
    using the capabilities CAP_MAC_OVERRIDE and CAP_MAC_ADMIN to
    determine if a process is allowed to ignore Smack checks or
    change Smack related data respectively. Smack provides an
    additional restriction that if an onlycap value is set
    by writing to /smack/onlycap only tasks with that Smack
    label are allowed to use CAP_MAC_OVERRIDE.
    
    This change adds CAP_MAC_ADMIN as a capability that is affected
    by the onlycap mechanism.
    
    Targeted for git://git.gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 76feb31eb823..99b36124f712 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -282,6 +282,19 @@ static inline char *smk_of_current(void)
 	return smk_of_task(current_security());
 }
 
+/*
+ * Is the task privileged and allowed to be privileged
+ * by the onlycap rule.
+ */
+static inline int smack_privileged(int cap)
+{
+	if (!capable(cap))
+		return 0;
+	if (smack_onlycap == NULL || smack_onlycap == smk_of_current())
+		return 1;
+	return 0;
+}
+
 /*
  * logging functions
  */

commit eb982cb4cf6405b97ea1f9e1d10864981f269d46
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed May 23 17:46:58 2012 -0700

    Smack: fix smack_new_inode bogosities
    
    In January of 2012 Al Viro pointed out three bits of code that
    he titled "new_inode_smack bogosities". This patch repairs these
    errors.
    
    1. smack_sb_kern_mount() included a NULL check that is impossible.
       The check and NULL case are removed.
    2. smack_kb_kern_mount() included pointless locking. The locking is
       removed. Since this is the only place that lock was used the lock
       is removed from the superblock_smack structure.
    3. smk_fill_super() incorrectly and unnecessarily set the Smack label
       for the smackfs root inode. The assignment has been removed.
    
    Targeted for git://gitorious.org/smack-next/kernel.git
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index cc361b8f3d13..76feb31eb823 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -43,7 +43,6 @@ struct superblock_smack {
 	char		*smk_hat;
 	char		*smk_default;
 	int		smk_initialized;
-	spinlock_t	smk_sblock;	/* for initialization */
 };
 
 struct socket_smack {

commit ff2bb047c4bce9742e94911eeb44b4d6ff4734ab
Merge: cffee16e8b99 c737f8284cac
Author: James Morris <james.l.morris@oracle.com>
Date:   Tue May 22 11:21:06 2012 +1000

    Merge branch 'master' of git://git.infradead.org/users/eparis/selinux into next
    
    Per pull request, for 3.5.

commit f7112e6c9abf1c70f001dcf097c1d6e218a93f5c
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Sun May 6 15:22:02 2012 -0700

    Smack: allow for significantly longer Smack labels v4
    
    V4 updated to current linux-security#next
    Targeted for git://gitorious.org/smack-next/kernel.git
    
    Modern application runtime environments like to use
    naming schemes that are structured and generated without
    human intervention. Even though the Smack limit of 23
    characters for a label name is perfectly rational for
    human use there have been complaints that the limit is
    a problem in environments where names are composed from
    a set or sources, including vendor, author, distribution
    channel and application name. Names like
    
            softwarehouse-pgwodehouse-coolappstore-mellowmuskrats
    
    are becoming harder to avoid. This patch introduces long
    label support in Smack. Labels are now limited to 255
    characters instead of the old 23.
    
    The primary reason for limiting the labels to 23 characters
    was so they could be directly contained in CIPSO category sets.
    This is still done were possible, but for labels that are too
    large a mapping is required. This is perfectly safe for communication
    that stays "on the box" and doesn't require much coordination
    between boxes beyond what would have been required to keep label
    names consistent.
    
    The bulk of this patch is in smackfs, adding and updating
    administrative interfaces. Because existing APIs can't be
    changed new ones that do much the same things as old ones
    have been introduced.
    
    The Smack specific CIPSO data representation has been removed
    and replaced with the data format used by netlabel. The CIPSO
    header is now computed when a label is imported rather than
    on use. This results in improved IP performance. The smack
    label is now allocated separately from the containing structure,
    allowing for larger strings.
    
    Four new /smack interfaces have been introduced as four
    of the old interfaces strictly required labels be specified
    in fixed length arrays.
    
    The access interface is supplemented with the check interface:
            access  "Subject                 Object                  rwxat"
            access2 "Subject Object rwaxt"
    
    The load interface is supplemented with the rules interface:
            load   "Subject                 Object                  rwxat"
            load2  "Subject Object rwaxt"
    
    The load-self interface is supplemented with the self-rules interface:
            load-self   "Subject                 Object                  rwxat"
            load-self2  "Subject Object rwaxt"
    
    The cipso interface is supplemented with the wire interface:
            cipso  "Subject                  lvl cnt  c1  c2 ..."
            cipso2 "Subject lvl cnt  c1  c2 ..."
    
    The old interfaces are maintained for compatibility.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index cf2594dfa933..5e031a2e4c36 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -23,13 +23,19 @@
 #include <linux/lsm_audit.h>
 
 /*
+ * Smack labels were limited to 23 characters for a long time.
+ */
+#define SMK_LABELLEN	24
+#define SMK_LONGLABEL	256
+
+/*
+ * Maximum number of bytes for the levels in a CIPSO IP option.
  * Why 23? CIPSO is constrained to 30, so a 32 byte buffer is
  * bigger than can be used, and 24 is the next lower multiple
  * of 8, and there are too many issues if there isn't space set
  * aside for the terminating null byte.
  */
-#define SMK_MAXLEN	23
-#define SMK_LABELLEN	(SMK_MAXLEN+1)
+#define SMK_CIPSOLEN	24
 
 struct superblock_smack {
 	char		*smk_root;
@@ -78,15 +84,6 @@ struct smack_rule {
 	int			smk_access;
 };
 
-/*
- * An entry in the table mapping smack values to
- * CIPSO level/category-set values.
- */
-struct smack_cipso {
-	int	smk_level;
-	char	smk_catset[SMK_LABELLEN];
-};
-
 /*
  * An entry in the table identifying hosts.
  */
@@ -114,22 +111,19 @@ struct smk_netlbladdr {
  * interfaces don't. The secid should go away when all of
  * these components have been repaired.
  *
- * If there is a cipso value associated with the label it
- * gets stored here, too. This will most likely be rare as
- * the cipso direct mapping in used internally.
+ * The cipso value associated with the label gets stored here, too.
  *
  * Keep the access rules for this subject label here so that
  * the entire set of rules does not need to be examined every
  * time.
  */
 struct smack_known {
-	struct list_head	list;
-	char			smk_known[SMK_LABELLEN];
-	u32			smk_secid;
-	struct smack_cipso	*smk_cipso;
-	spinlock_t		smk_cipsolock;	/* for changing cipso map */
-	struct list_head	smk_rules;	/* access rules */
-	struct mutex		smk_rules_lock;	/* lock for the rules */
+	struct list_head		list;
+	char				*smk_known;
+	u32				smk_secid;
+	struct netlbl_lsm_secattr	smk_netlabel;	/* on wire labels */
+	struct list_head		smk_rules;	/* access rules */
+	struct mutex			smk_rules_lock;	/* lock for rules */
 };
 
 /*
@@ -166,6 +160,7 @@ struct smack_known {
 #define SMACK_CIPSO_DOI_DEFAULT		3	/* Historical */
 #define SMACK_CIPSO_DOI_INVALID		-1	/* Not a DOI */
 #define SMACK_CIPSO_DIRECT_DEFAULT	250	/* Arbitrary */
+#define SMACK_CIPSO_MAPPED_DEFAULT	251	/* Also arbitrary */
 #define SMACK_CIPSO_MAXCATVAL		63	/* Bigger gets harder */
 #define SMACK_CIPSO_MAXLEVEL            255     /* CIPSO 2.2 standard */
 #define SMACK_CIPSO_MAXCATNUM           239     /* CIPSO 2.2 standard */
@@ -216,10 +211,9 @@ struct inode_smack *new_inode_smack(char *);
 int smk_access_entry(char *, char *, struct list_head *);
 int smk_access(char *, char *, int, struct smk_audit_info *);
 int smk_curacc(char *, u32, struct smk_audit_info *);
-int smack_to_cipso(const char *, struct smack_cipso *);
-char *smack_from_cipso(u32, char *);
 char *smack_from_secid(const u32);
-void smk_parse_smack(const char *string, int len, char *smack);
+char *smk_parse_smack(const char *string, int len);
+int smk_netlbl_mls(int, char *, struct netlbl_lsm_secattr *, int);
 char *smk_import(const char *, int);
 struct smack_known *smk_import_entry(const char *, int);
 struct smack_known *smk_find_entry(const char *);
@@ -229,6 +223,7 @@ u32 smack_to_secid(const char *);
  * Shared data.
  */
 extern int smack_cipso_direct;
+extern int smack_cipso_mapped;
 extern char *smack_net_ambient;
 extern char *smack_onlycap;
 extern const char *smack_cipso_option;
@@ -240,23 +235,12 @@ extern struct smack_known smack_known_invalid;
 extern struct smack_known smack_known_star;
 extern struct smack_known smack_known_web;
 
+extern struct mutex	smack_known_lock;
 extern struct list_head smack_known_list;
 extern struct list_head smk_netlbladdr_list;
 
 extern struct security_operations smack_ops;
 
-/*
- * Stricly for CIPSO level manipulation.
- * Set the category bit number in a smack label sized buffer.
- */
-static inline void smack_catset_bit(int cat, char *catsetp)
-{
-	if (cat > SMK_LABELLEN * 8)
-		return;
-
-	catsetp[(cat - 1) / 8] |= 0x80 >> ((cat - 1) % 8);
-}
-
 /*
  * Is the directory transmuting?
  */

commit 2267b13a7cad1f9dfe0073c1f902d45953f9faff
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Tue Mar 13 19:14:19 2012 -0700

    Smack: recursive tramsmute
    
    The transmuting directory feature of Smack requires that
    the transmuting attribute be explicitly set in all cases.
    It seems the users of this facility would expect that the
    transmuting attribute be inherited by subdirectories that
    are created in a transmuting directory. This does not seem
    to add any additional complexity to the understanding of
    how the system works.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 4ede719922ed..cf2594dfa933 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -66,6 +66,7 @@ struct task_smack {
 
 #define	SMK_INODE_INSTANT	0x01	/* inode is instantiated */
 #define	SMK_INODE_TRANSMUTE	0x02	/* directory is transmuting */
+#define	SMK_INODE_CHANGED	0x04	/* smack was transmuted */
 
 /*
  * A label access rule.

commit 50c205f5e5c2e2af002fd4ef537ded79b90b1b56
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 4 15:01:43 2012 -0400

    LSM: do not initialize common_audit_data to 0
    
    It isn't needed.  If you don't set the type of the data associated with
    that type it is a pretty obvious programming bug.  So why waste the cycles?
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 4ede719922ed..b61e75f224d4 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -319,7 +319,7 @@ void smack_log(char *subject_label, char *object_label,
 static inline void smk_ad_init(struct smk_audit_info *a, const char *func,
 			       char type)
 {
-	memset(a, 0, sizeof(*a));
+	memset(&a->sad, 0, sizeof(a->sad));
 	a->a.type = type;
 	a->a.smack_audit_data = &a->sad;
 	a->a.smack_audit_data->function = func;

commit 48c62af68a403ef1655546bd3e021070c8508573
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Apr 2 13:15:44 2012 -0400

    LSM: shrink the common_audit_data data union
    
    After shrinking the common_audit_data stack usage for private LSM data I'm
    not going to shrink the data union.  To do this I'm going to move anything
    larger than 2 void * ptrs to it's own structure and require it to be declared
    separately on the calling stack.  Thus hot paths which don't need more than
    a couple pointer don't have to declare space to hold large unneeded
    structures.  I could get this down to one void * by dealing with the key
    struct and the struct path.  We'll see if that is helpful after taking care of
    networking.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index ccba3823d9ef..4ede719922ed 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -325,6 +325,14 @@ static inline void smk_ad_init(struct smk_audit_info *a, const char *func,
 	a->a.smack_audit_data->function = func;
 }
 
+static inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,
+				   char type, struct lsm_network_audit *net)
+{
+	smk_ad_init(a, func, type);
+	memset(net, 0, sizeof(*net));
+	a->a.u.net = net;
+}
+
 static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,
 					 struct task_struct *t)
 {
@@ -348,7 +356,7 @@ static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,
 static inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,
 					    struct sock *sk)
 {
-	a->a.u.net.sk = sk;
+	a->a.u.net->sk = sk;
 }
 
 #else /* no AUDIT */

commit 3b3b0e4fc15efa507b902d90cea39e496a523c3b
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Apr 3 09:37:02 2012 -0700

    LSM: shrink sizeof LSM specific portion of common_audit_data
    
    Linus found that the gigantic size of the common audit data caused a big
    perf hit on something as simple as running stat() in a loop.  This patch
    requires LSMs to declare the LSM specific portion separately rather than
    doing it in a union.  Thus each LSM can be responsible for shrinking their
    portion and don't have to pay a penalty just because other LSMs have a
    bigger space requirement.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 2ad00657b801..ccba3823d9ef 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -185,6 +185,15 @@ struct smack_known {
  */
 #define SMK_NUM_ACCESS_TYPE 5
 
+/* SMACK data */
+struct smack_audit_data {
+	const char *function;
+	char *subject;
+	char *object;
+	char *request;
+	int result;
+};
+
 /*
  * Smack audit data; is empty if CONFIG_AUDIT not set
  * to save some stack
@@ -192,6 +201,7 @@ struct smack_known {
 struct smk_audit_info {
 #ifdef CONFIG_AUDIT
 	struct common_audit_data a;
+	struct smack_audit_data sad;
 #endif
 };
 /*
@@ -311,7 +321,8 @@ static inline void smk_ad_init(struct smk_audit_info *a, const char *func,
 {
 	memset(a, 0, sizeof(*a));
 	a->a.type = type;
-	a->a.smack_audit_data.function = func;
+	a->a.smack_audit_data = &a->sad;
+	a->a.smack_audit_data->function = func;
 }
 
 static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,

commit 0e94ae17c857b3835a2b8ea46ce44b5da4e2cc5d
Author: Jarkko Sakkinen <jarkko.j.sakkinen@gmail.com>
Date:   Tue Oct 18 21:21:36 2011 +0300

    Smack: allow to access /smack/access as normal user
    
    Allow query access as a normal user removing the need
    for CAP_MAC_ADMIN. Give RW access to /smack/access
    for UGO. Do not import smack labels in access check.
    
    Signed-off-by: Jarkko Sakkinen <jarkko.j.sakkinen@gmail.com>
    Signed-off-by: Casey Schaufler <cschaufler@cschaufler-intel.(none)>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 9da2b2dfdefb..2ad00657b801 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -208,6 +208,7 @@ int smk_curacc(char *, u32, struct smk_audit_info *);
 int smack_to_cipso(const char *, struct smack_cipso *);
 char *smack_from_cipso(u32, char *);
 char *smack_from_secid(const u32);
+void smk_parse_smack(const char *string, int len, char *smack);
 char *smk_import(const char *, int);
 struct smack_known *smk_import_entry(const char *, int);
 struct smack_known *smk_find_entry(const char *);

commit ce8a432197d9892689eb4896f690b9fe6b3de598
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Thu Sep 29 18:21:01 2011 -0700

    Smack: Clean up comments
    
    There are a number of comments in the Smack code that
    are either malformed or include code. This patch cleans
    them up.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 174d3be9aaee..9da2b2dfdefb 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -156,7 +156,6 @@ struct smack_known {
 
 /*
  * smackfs magic number
- * smackfs macic number
  */
 #define SMACK_MAGIC	0x43415d53 /* "SMAC" */
 
@@ -182,9 +181,9 @@ struct smack_known {
 #define MAY_NOT		0
 
 /*
- * Number of access types used by Smack (rwxa)
+ * Number of access types used by Smack (rwxat)
  */
-#define SMK_NUM_ACCESS_TYPE 4
+#define SMK_NUM_ACCESS_TYPE 5
 
 /*
  * Smack audit data; is empty if CONFIG_AUDIT not set

commit 272cd7a8c67dd40a31ecff76a503bbb84707f757
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Tue Sep 20 12:24:36 2011 -0700

    Smack: Rule list lookup performance
    
    This patch is targeted for the smack-next tree.
    
    Smack access checks suffer from two significant performance
    issues. In cases where there are large numbers of rules the
    search of the single list of rules is wasteful. Comparing the
    string values of the smack labels is less efficient than a
    numeric comparison would.
    
    These changes take advantage of the Smack label list, which
    maintains the mapping of Smack labels to secids and optional
    CIPSO labels. Because the labels are kept perpetually, an
    access check can be done strictly based on the address of the
    label in the list without ever looking at the label itself.
    Rather than keeping one global list of rules the rules with
    a particular subject label can be based off of that label
    list entry. The access check need never look at entries that
    do not use the current subject label.
    
    This requires that packets coming off the network with
    CIPSO direct Smack labels that have never been seen before
    be treated carefully. The only case where they could be
    delivered is where the receiving socket has an IPIN star
    label, so that case is explicitly addressed.
    
    On a system with 39,800 rules (200 labels in all permutations)
    a system with this patch runs an access speed test in 5% of
    the time of the old version. That should be a best case
    improvement. If all of the rules are associated with the
    same subject label and all of the accesses are for processes
    with that label (unlikely) the improvement is about 30%.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 2b6c6a516123..174d3be9aaee 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -41,9 +41,9 @@ struct superblock_smack {
 };
 
 struct socket_smack {
-	char		*smk_out;			/* outbound label */
-	char		*smk_in;			/* inbound label */
-	char		smk_packet[SMK_LABELLEN];	/* TCP peer label */
+	char		*smk_out;	/* outbound label */
+	char		*smk_in;	/* inbound label */
+	char		*smk_packet;	/* TCP peer label */
 };
 
 /*
@@ -116,13 +116,19 @@ struct smk_netlbladdr {
  * If there is a cipso value associated with the label it
  * gets stored here, too. This will most likely be rare as
  * the cipso direct mapping in used internally.
+ *
+ * Keep the access rules for this subject label here so that
+ * the entire set of rules does not need to be examined every
+ * time.
  */
 struct smack_known {
 	struct list_head	list;
 	char			smk_known[SMK_LABELLEN];
 	u32			smk_secid;
 	struct smack_cipso	*smk_cipso;
-	spinlock_t		smk_cipsolock; /* for changing cipso map */
+	spinlock_t		smk_cipsolock;	/* for changing cipso map */
+	struct list_head	smk_rules;	/* access rules */
+	struct mutex		smk_rules_lock;	/* lock for the rules */
 };
 
 /*
@@ -201,10 +207,11 @@ int smk_access_entry(char *, char *, struct list_head *);
 int smk_access(char *, char *, int, struct smk_audit_info *);
 int smk_curacc(char *, u32, struct smk_audit_info *);
 int smack_to_cipso(const char *, struct smack_cipso *);
-void smack_from_cipso(u32, char *, char *);
+char *smack_from_cipso(u32, char *);
 char *smack_from_secid(const u32);
 char *smk_import(const char *, int);
 struct smack_known *smk_import_entry(const char *, int);
+struct smack_known *smk_find_entry(const char *);
 u32 smack_to_secid(const char *);
 
 /*
@@ -223,7 +230,6 @@ extern struct smack_known smack_known_star;
 extern struct smack_known smack_known_web;
 
 extern struct list_head smack_known_list;
-extern struct list_head smack_rule_list;
 extern struct list_head smk_netlbladdr_list;
 
 extern struct security_operations smack_ops;

commit a269434d2fb48a4d66c1d7bf821b7874b59c5b41
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Apr 25 13:10:27 2011 -0400

    LSM: separate LSM_AUDIT_DATA_DENTRY from LSM_AUDIT_DATA_PATH
    
    This patch separates and audit message that only contains a dentry from
    one that contains a full path.  This allows us to make it harder to
    misuse the interfaces or for the interfaces to be implemented wrong.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index a16925c0e91a..2b6c6a516123 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -316,12 +316,7 @@ static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,
 static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,
 						    struct dentry *d)
 {
-	a->a.u.path.dentry = d;
-}
-static inline void smk_ad_setfield_u_fs_path_mnt(struct smk_audit_info *a,
-						 struct vfsmount *m)
-{
-	a->a.u.path.mnt = m;
+	a->a.u.dentry = d;
 }
 static inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,
 					      struct inode *i)

commit f48b7399840b453e7282b523f535561fe9638a2d
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Apr 25 12:54:27 2011 -0400

    LSM: split LSM_AUDIT_DATA_FS into _PATH and _INODE
    
    The lsm common audit code has wacky contortions making sure which pieces
    of information are set based on if it was given a path, dentry, or
    inode.  Split this into path and inode to get rid of some of the code
    complexity.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index b449cfdad21c..a16925c0e91a 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -316,22 +316,22 @@ static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,
 static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,
 						    struct dentry *d)
 {
-	a->a.u.fs.path.dentry = d;
+	a->a.u.path.dentry = d;
 }
 static inline void smk_ad_setfield_u_fs_path_mnt(struct smk_audit_info *a,
 						 struct vfsmount *m)
 {
-	a->a.u.fs.path.mnt = m;
+	a->a.u.path.mnt = m;
 }
 static inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,
 					      struct inode *i)
 {
-	a->a.u.fs.inode = i;
+	a->a.u.inode = i;
 }
 static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,
 					     struct path p)
 {
-	a->a.u.fs.path = p;
+	a->a.u.path = p;
 }
 static inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,
 					    struct sock *sk)

commit db904aa8147440b750a35d58befed38155a1abb9
Author: Shan Wei <shanwei@cn.fujitsu.com>
Date:   Wed Feb 9 19:58:11 2011 -0800

    security:smack: kill unused SMACK_LIST_MAX, MAY_ANY and MAY_ANYWRITE
    
    Kill unused macros of SMACK_LIST_MAX, MAY_ANY and MAY_ANYWRITE.
    v2: As Casey Schaufler's advice, also remove MAY_ANY.
    
    Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index e365d455ceb6..b449cfdad21c 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -154,12 +154,6 @@ struct smack_known {
  */
 #define SMACK_MAGIC	0x43415d53 /* "SMAC" */
 
-/*
- * A limit on the number of entries in the lists
- * makes some of the list administration easier.
- */
-#define SMACK_LIST_MAX	10000
-
 /*
  * CIPSO defaults.
  */
@@ -177,9 +171,7 @@ struct smack_known {
 /*
  * Just to make the common cases easier to deal with
  */
-#define MAY_ANY		(MAY_READ | MAY_WRITE | MAY_APPEND | MAY_EXEC)
 #define MAY_ANYREAD	(MAY_READ | MAY_EXEC)
-#define MAY_ANYWRITE	(MAY_WRITE | MAY_APPEND)
 #define MAY_READWRITE	(MAY_READ | MAY_WRITE)
 #define MAY_NOT		0
 

commit 7898e1f8e9eb1bee88c92d636e0ab93f2cbe31c6
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Jan 17 08:05:27 2011 -0800

    Subject: [PATCH] Smack: mmap controls for library containment
    
      In the embedded world there are often situations
      where libraries are updated from a variety of sources,
      for a variety of reasons, and with any number of
      security characteristics. These differences
      might include privilege required for a given library
      provided interface to function properly, as occurs
      from time to time in graphics libraries. There are
      also cases where it is important to limit use of
      libraries based on the provider of the library and
      the security aware application may make choices
      based on that criteria.
    
      These issues are addressed by providing an additional
      Smack label that may optionally be assigned to an object,
      the SMACK64MMAP attribute. An mmap operation is allowed
      if there is no such attribute.
    
      If there is a SMACK64MMAP attribute the mmap is permitted
      only if a subject with that label has all of the access
      permitted a subject with the current task label.
    
      Security aware applications may from time to time
      wish to reduce their "privilege" to avoid accidental use
      of privilege. One case where this arises is the
      environment in which multiple sources provide libraries
      to perform the same functions. An application may know
      that it should eschew services made available from a
      particular vendor, or of a particular version.
    
      In support of this a secondary list of Smack rules has
      been added that is local to the task. This list is
      consulted only in the case where the global list has
      approved access. It can only further restrict access.
      Unlike the global last, if no entry is found on the
      local list access is granted. An application can add
      entries to its own list by writing to /smack/load-self.
    
      The changes appear large as they involve refactoring
      the list handling to accomodate there being more
      than one rule list.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 129c4eb8ffb1..e365d455ceb6 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -52,13 +52,16 @@ struct socket_smack {
 struct inode_smack {
 	char		*smk_inode;	/* label of the fso */
 	char		*smk_task;	/* label of the task */
+	char		*smk_mmap;	/* label of the mmap domain */
 	struct mutex	smk_lock;	/* initialization lock */
 	int		smk_flags;	/* smack inode flags */
 };
 
 struct task_smack {
-	char		*smk_task;	/* label used for access control */
-	char		*smk_forked;	/* label when forked */
+	char			*smk_task;	/* label for access control */
+	char			*smk_forked;	/* label when forked */
+	struct list_head	smk_rules;	/* per task access rules */
+	struct mutex		smk_rules_lock;	/* lock for the rules */
 };
 
 #define	SMK_INODE_INSTANT	0x01	/* inode is instantiated */
@@ -202,7 +205,7 @@ struct inode_smack *new_inode_smack(char *);
 /*
  * These functions are in smack_access.c
  */
-int smk_access_entry(char *, char *);
+int smk_access_entry(char *, char *, struct list_head *);
 int smk_access(char *, char *, int, struct smk_audit_info *);
 int smk_curacc(char *, u32, struct smk_audit_info *);
 int smack_to_cipso(const char *, struct smack_cipso *);

commit 5c6d1125f8dbd1bfef39e38fbc2837003be78a59
Author: Jarkko Sakkinen <ext-jarkko.2.sakkinen@nokia.com>
Date:   Tue Dec 7 13:34:01 2010 +0200

    Smack: Transmute labels on specified directories
    
    In a situation where Smack access rules allow processes
    with multiple labels to write to a directory it is easy
    to get into a situation where the directory gets cluttered
    with files that the owner can't deal with because while
    they could be written to the directory a process at the
    label of the directory can't write them. This is generally
    the desired behavior, but when it isn't it is a real
    issue.
    
    This patch introduces a new attribute SMACK64TRANSMUTE that
    instructs Smack to create the file with the label of the directory
    under certain circumstances.
    
    A new access mode, "t" for transmute, is made available to
    Smack access rules, which are expanded from "rwxa" to "rwxat".
    If a file is created in a directory marked as transmutable
    and if access was granted to perform the operation by a rule
    that included the transmute mode, then the file gets the
    Smack label of the directory instead of the Smack label of the
    creating process.
    
    Note that this is equivalent to creating an empty file at the
    label of the directory and then having the other process write
    to it. The transmute scheme requires that both the access rule
    allows transmutation and that the directory be explicitly marked.
    
    Signed-off-by: Jarkko Sakkinen <ext-jarkko.2.sakkinen@nokia.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index a2e2cdfab4ef..129c4eb8ffb1 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -62,6 +62,7 @@ struct task_smack {
 };
 
 #define	SMK_INODE_INSTANT	0x01	/* inode is instantiated */
+#define	SMK_INODE_TRANSMUTE	0x02	/* directory is transmuting */
 
 /*
  * A label access rule.
@@ -166,6 +167,10 @@ struct smack_known {
 #define SMACK_CIPSO_MAXLEVEL            255     /* CIPSO 2.2 standard */
 #define SMACK_CIPSO_MAXCATNUM           239     /* CIPSO 2.2 standard */
 
+/*
+ * Flag for transmute access
+ */
+#define MAY_TRANSMUTE	64
 /*
  * Just to make the common cases easier to deal with
  */
@@ -197,6 +202,7 @@ struct inode_smack *new_inode_smack(char *);
 /*
  * These functions are in smack_access.c
  */
+int smk_access_entry(char *, char *);
 int smk_access(char *, char *, int, struct smk_audit_info *);
 int smk_curacc(char *, u32, struct smk_audit_info *);
 int smack_to_cipso(const char *, struct smack_cipso *);
@@ -239,6 +245,15 @@ static inline void smack_catset_bit(int cat, char *catsetp)
 	catsetp[(cat - 1) / 8] |= 0x80 >> ((cat - 1) % 8);
 }
 
+/*
+ * Is the directory transmuting?
+ */
+static inline int smk_inode_transmutable(const struct inode *isp)
+{
+	struct inode_smack *sip = isp->i_security;
+	return (sip->smk_flags & SMK_INODE_TRANSMUTE) != 0;
+}
+
 /*
  * Present a pointer to the smack label in an inode blob.
  */
@@ -265,7 +280,7 @@ static inline char *smk_of_forked(const struct task_smack *tsp)
 }
 
 /*
- * Present a pointer to the smack label in the curren task blob.
+ * Present a pointer to the smack label in the current task blob.
  */
 static inline char *smk_of_current(void)
 {

commit 676dac4b1bee0469d6932f698aeb77e8489f5861
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Thu Dec 2 06:43:39 2010 -0800

    This patch adds a new security attribute to Smack called
    SMACK64EXEC. It defines label that is used while task is
    running.
    
    Exception: in smack_task_wait() child task is checked
    for write access to parent task using label inherited
    from the task that forked it.
    
    Fixed issues from previous submit:
    - SMACK64EXEC was not read when SMACK64 was not set.
    - inode security blob was not updated after setting
      SMACK64EXEC
    - inode security blob was not updated when removing
      SMACK64EXEC

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 43ae747a5aa4..a2e2cdfab4ef 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -51,10 +51,16 @@ struct socket_smack {
  */
 struct inode_smack {
 	char		*smk_inode;	/* label of the fso */
+	char		*smk_task;	/* label of the task */
 	struct mutex	smk_lock;	/* initialization lock */
 	int		smk_flags;	/* smack inode flags */
 };
 
+struct task_smack {
+	char		*smk_task;	/* label used for access control */
+	char		*smk_forked;	/* label when forked */
+};
+
 #define	SMK_INODE_INSTANT	0x01	/* inode is instantiated */
 
 /*
@@ -242,6 +248,30 @@ static inline char *smk_of_inode(const struct inode *isp)
 	return sip->smk_inode;
 }
 
+/*
+ * Present a pointer to the smack label in an task blob.
+ */
+static inline char *smk_of_task(const struct task_smack *tsp)
+{
+	return tsp->smk_task;
+}
+
+/*
+ * Present a pointer to the forked smack label in an task blob.
+ */
+static inline char *smk_of_forked(const struct task_smack *tsp)
+{
+	return tsp->smk_forked;
+}
+
+/*
+ * Present a pointer to the smack label in the curren task blob.
+ */
+static inline char *smk_of_current(void)
+{
+	return smk_of_task(current_security());
+}
+
 /*
  * logging functions
  */

commit af4f136056c984b0aa67feed7d3170b958370b2f
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Jul 1 15:07:43 2010 -0400

    security: move LSM xattrnames to xattr.h
    
    Make the security extended attributes names global. Updated to move
    the remaining Smack xattrs.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index c6e9acae72e4..43ae747a5aa4 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -123,16 +123,6 @@ struct smack_known {
 #define SMK_FSHAT	"smackfshat="
 #define SMK_FSROOT	"smackfsroot="
 
-/*
- * xattr names
- */
-#define XATTR_SMACK_SUFFIX	"SMACK64"
-#define XATTR_SMACK_IPIN	"SMACK64IPIN"
-#define XATTR_SMACK_IPOUT	"SMACK64IPOUT"
-#define XATTR_NAME_SMACK	XATTR_SECURITY_PREFIX XATTR_SMACK_SUFFIX
-#define XATTR_NAME_SMACKIPIN	XATTR_SECURITY_PREFIX XATTR_SMACK_IPIN
-#define XATTR_NAME_SMACKIPOUT	XATTR_SECURITY_PREFIX XATTR_SMACK_IPOUT
-
 #define SMACK_CIPSO_OPTION 	"-CIPSO"
 
 /*

commit d4131ded4d4c1a5c1363ddd93ca104ed97dd0458
Author: Thomas Liu <tliu@redhat.com>
Date:   Thu Jul 9 10:00:30 2009 -0400

    security: Make lsm_priv union in lsm_audit.h anonymous
    
    Made the lsm_priv union in include/linux/lsm_audit.h
    anonymous.
    
    Signed-off-by: Thomas Liu <tliu@redhat.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index ff180ede3e47..c6e9acae72e4 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -275,7 +275,7 @@ static inline void smk_ad_init(struct smk_audit_info *a, const char *func,
 {
 	memset(a, 0, sizeof(*a));
 	a->a.type = type;
-	a->a.lsm_priv.smack_audit_data.function = func;
+	a->a.smack_audit_data.function = func;
 }
 
 static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,

commit ed5215a21460f63d6bdc118cb55a9e6d1b433f35
Author: Thomas Liu <tliu@redhat.com>
Date:   Thu Jul 9 10:00:29 2009 -0400

    Move variable function in lsm_audit.h into SMACK private space
    
    Moved variable function in include/linux/lsm_audit.h into the
    smack_audit_data struct since it is never used outside of it.
    
    Also removed setting of function in the COMMON_AUDIT_DATA_INIT
    macro because that variable is now private to SMACK.
    
    Signed-off-by: Thomas Liu <tliu@redhat.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    I-dont-see-any-problems-with-it: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 243bec175be0..ff180ede3e47 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -275,7 +275,7 @@ static inline void smk_ad_init(struct smk_audit_info *a, const char *func,
 {
 	memset(a, 0, sizeof(*a));
 	a->a.type = type;
-	a->a.function = func;
+	a->a.lsm_priv.smack_audit_data.function = func;
 }
 
 static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,

commit ecfcc53fef3c357574bb6143dce6631e6d56295c
Author: Etienne Basset <etienne.basset@numericable.fr>
Date:   Wed Apr 8 20:40:06 2009 +0200

    smack: implement logging V3
    
    the following patch, add logging of Smack security decisions.
    This is of course very useful to understand what your current smack policy does.
    As suggested by Casey, it also now forbids labels with ', " or \
    
    It introduces a '/smack/logging' switch :
    0: no logging
    1: log denied (default)
    2: log accepted
    3: log denied&accepted
    
    Signed-off-by: Etienne Basset <etienne.basset@numericable.fr>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 42ef313f9856..243bec175be0 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -20,6 +20,7 @@
 #include <net/netlabel.h>
 #include <linux/list.h>
 #include <linux/rculist.h>
+#include <linux/lsm_audit.h>
 
 /*
  * Why 23? CIPSO is constrained to 30, so a 32 byte buffer is
@@ -178,6 +179,20 @@ struct smack_known {
 #define MAY_READWRITE	(MAY_READ | MAY_WRITE)
 #define MAY_NOT		0
 
+/*
+ * Number of access types used by Smack (rwxa)
+ */
+#define SMK_NUM_ACCESS_TYPE 4
+
+/*
+ * Smack audit data; is empty if CONFIG_AUDIT not set
+ * to save some stack
+ */
+struct smk_audit_info {
+#ifdef CONFIG_AUDIT
+	struct common_audit_data a;
+#endif
+};
 /*
  * These functions are in smack_lsm.c
  */
@@ -186,8 +201,8 @@ struct inode_smack *new_inode_smack(char *);
 /*
  * These functions are in smack_access.c
  */
-int smk_access(char *, char *, int);
-int smk_curacc(char *, u32);
+int smk_access(char *, char *, int, struct smk_audit_info *);
+int smk_curacc(char *, u32, struct smk_audit_info *);
 int smack_to_cipso(const char *, struct smack_cipso *);
 void smack_from_cipso(u32, char *, char *);
 char *smack_from_secid(const u32);
@@ -237,4 +252,93 @@ static inline char *smk_of_inode(const struct inode *isp)
 	return sip->smk_inode;
 }
 
+/*
+ * logging functions
+ */
+#define SMACK_AUDIT_DENIED 0x1
+#define SMACK_AUDIT_ACCEPT 0x2
+extern int log_policy;
+
+void smack_log(char *subject_label, char *object_label,
+		int request,
+		int result, struct smk_audit_info *auditdata);
+
+#ifdef CONFIG_AUDIT
+
+/*
+ * some inline functions to set up audit data
+ * they do nothing if CONFIG_AUDIT is not set
+ *
+ */
+static inline void smk_ad_init(struct smk_audit_info *a, const char *func,
+			       char type)
+{
+	memset(a, 0, sizeof(*a));
+	a->a.type = type;
+	a->a.function = func;
+}
+
+static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,
+					 struct task_struct *t)
+{
+	a->a.u.tsk = t;
+}
+static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,
+						    struct dentry *d)
+{
+	a->a.u.fs.path.dentry = d;
+}
+static inline void smk_ad_setfield_u_fs_path_mnt(struct smk_audit_info *a,
+						 struct vfsmount *m)
+{
+	a->a.u.fs.path.mnt = m;
+}
+static inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,
+					      struct inode *i)
+{
+	a->a.u.fs.inode = i;
+}
+static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,
+					     struct path p)
+{
+	a->a.u.fs.path = p;
+}
+static inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,
+					    struct sock *sk)
+{
+	a->a.u.net.sk = sk;
+}
+
+#else /* no AUDIT */
+
+static inline void smk_ad_init(struct smk_audit_info *a, const char *func,
+			       char type)
+{
+}
+static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,
+					 struct task_struct *t)
+{
+}
+static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,
+						    struct dentry *d)
+{
+}
+static inline void smk_ad_setfield_u_fs_path_mnt(struct smk_audit_info *a,
+						 struct vfsmount *m)
+{
+}
+static inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,
+					      struct inode *i)
+{
+}
+static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,
+					     struct path p)
+{
+}
+static inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,
+					    struct sock *sk)
+{
+}
+#endif
+
 #endif  /* _SECURITY_SMACK_H */

commit 4303154e86597885bc3cbc178a48ccbc8213875f
Author: Etienne Basset <etienne.basset@numericable.fr>
Date:   Fri Mar 27 17:11:01 2009 -0400

    smack: Add a new '-CIPSO' option to the network address label configuration
    
    This patch adds a new special option '-CIPSO' to the Smack subsystem. When used
    in the netlabel list, it means "use CIPSO networking". A use case is when your
    local network speaks CIPSO and you want also to connect to the unlabeled
    Internet. This patch also add some documentation describing that. The patch
    also corrects an oops when setting a '' SMACK64 xattr to a file.
    
    Signed-off-by: Etienne Basset <etienne.basset@numericable.fr>
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 5e5a3bcb599a..42ef313f9856 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -132,6 +132,8 @@ struct smack_known {
 #define XATTR_NAME_SMACKIPIN	XATTR_SECURITY_PREFIX XATTR_SMACK_IPIN
 #define XATTR_NAME_SMACKIPOUT	XATTR_SECURITY_PREFIX XATTR_SMACK_IPOUT
 
+#define SMACK_CIPSO_OPTION 	"-CIPSO"
+
 /*
  * How communications on this socket are treated.
  * Usually it's determined by the underlying netlabel code
@@ -199,6 +201,7 @@ u32 smack_to_secid(const char *);
 extern int smack_cipso_direct;
 extern char *smack_net_ambient;
 extern char *smack_onlycap;
+extern const char *smack_cipso_option;
 
 extern struct smack_known smack_known_floor;
 extern struct smack_known smack_known_hat;

commit 07feee8f812f7327a46186f7604df312c8c81962
Author: Paul Moore <paul.moore@hp.com>
Date:   Fri Mar 27 17:10:54 2009 -0400

    netlabel: Cleanup the Smack/NetLabel code to fix incoming TCP connections
    
    This patch cleans up a lot of the Smack network access control code.  The
    largest changes are to fix the labeling of incoming TCP connections in a
    manner similar to the recent SELinux changes which use the
    security_inet_conn_request() hook to label the request_sock and let the label
    move to the child socket via the normal network stack mechanisms.  In addition
    to the incoming TCP connection fixes this patch also removes the smk_labled
    field from the socket_smack struct as the minor optimization advantage was
    outweighed by the difficulty in maintaining it's proper state.
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 64164f8fde70..5e5a3bcb599a 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -42,7 +42,6 @@ struct superblock_smack {
 struct socket_smack {
 	char		*smk_out;			/* outbound label */
 	char		*smk_in;			/* inbound label */
-	int		smk_labeled;			/* label scheme */
 	char		smk_packet[SMK_LABELLEN];	/* TCP peer label */
 };
 

commit 7198e2eeb44b3fe7cc97f997824002da47a9c644
Author: Etienne Basset <etienne.basset@numericable.fr>
Date:   Tue Mar 24 20:53:24 2009 +0100

    smack: convert smack to standard linux lists
    
    the following patch (on top of 2.6.29) converts Smack lists to standard linux lists
    Please review and consider for inclusion in 2.6.30-rc
    
    regards,
    Etienne
    
    Signed-off-by: Etienne Basset <etienne.basset@numericable.fr>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index b79582e4fbfd..64164f8fde70 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -18,6 +18,8 @@
 #include <linux/security.h>
 #include <linux/in.h>
 #include <net/netlabel.h>
+#include <linux/list.h>
+#include <linux/rculist.h>
 
 /*
  * Why 23? CIPSO is constrained to 30, so a 32 byte buffer is
@@ -59,17 +61,10 @@ struct inode_smack {
  * A label access rule.
  */
 struct smack_rule {
-	char	*smk_subject;
-	char	*smk_object;
-	int	smk_access;
-};
-
-/*
- * An entry in the table of permitted label accesses.
- */
-struct smk_list_entry {
-	struct smk_list_entry	*smk_next;
-	struct smack_rule	smk_rule;
+	struct list_head	list;
+	char			*smk_subject;
+	char			*smk_object;
+	int			smk_access;
 };
 
 /*
@@ -85,7 +80,7 @@ struct smack_cipso {
  * An entry in the table identifying hosts.
  */
 struct smk_netlbladdr {
-	struct smk_netlbladdr	*smk_next;
+	struct list_head	list;
 	struct sockaddr_in	smk_host;	/* network address */
 	struct in_addr		smk_mask;	/* network mask */
 	char			*smk_label;	/* label */
@@ -113,7 +108,7 @@ struct smk_netlbladdr {
  * the cipso direct mapping in used internally.
  */
 struct smack_known {
-	struct smack_known	*smk_next;
+	struct list_head	list;
 	char			smk_known[SMK_LABELLEN];
 	u32			smk_secid;
 	struct smack_cipso	*smk_cipso;
@@ -206,7 +201,6 @@ extern int smack_cipso_direct;
 extern char *smack_net_ambient;
 extern char *smack_onlycap;
 
-extern struct smack_known *smack_known;
 extern struct smack_known smack_known_floor;
 extern struct smack_known smack_known_hat;
 extern struct smack_known smack_known_huh;
@@ -214,8 +208,10 @@ extern struct smack_known smack_known_invalid;
 extern struct smack_known smack_known_star;
 extern struct smack_known smack_known_web;
 
-extern struct smk_list_entry *smack_list;
-extern struct smk_netlbladdr *smack_netlbladdrs;
+extern struct list_head smack_known_list;
+extern struct list_head smack_rule_list;
+extern struct list_head smk_netlbladdr_list;
+
 extern struct security_operations smack_ops;
 
 /*

commit 6d3dc07cbb1e88deed2e8710e215f232a56b1dce
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed Dec 31 12:54:12 2008 -0500

    smack: Add support for unlabeled network hosts and networks
    
    Add support for unlabeled network hosts and networks.
    Relies heavily on Paul Moore's netlabel support.
    
    Creates a new entry in /smack called netlabel. Writes to /smack/netlabel
    take the form:
    
        A.B.C.D LABEL
    or
        A.B.C.D/N LABEL
    
    where A.B.C.D is a network address, N is an integer between 0-32,
    and LABEL is the Smack label to be used. If /N is omitted /32 is
    assumed. N designates the netmask for the address. Entries are
    matched by the most specific address/mask pair. 0.0.0.0/0 will
    match everything, while 192.168.1.117/32 will match exactly one
    host.
    
    A new system label "@", pronounced "web", is defined. Processes
    can not be assigned the web label. An address assigned the web
    label can be written to by any process, and packets coming from
    a web address can be written to any socket. Use of the web label
    is a violation of any strict MAC policy, but the web label has
    been requested many times.
    
    The nltype entry has been removed from /smack. It did not work right
    and the netlabel interface can be used to specify that all hosts
    be treated as unlabeled.
    
    CIPSO labels on incoming packets will be honored, even from designated
    single label hosts. Single label hosts can only be written to by
    processes with labels that can write to the label of the host.
    Packets sent to single label hosts will always be unlabeled.
    
    Once added a single label designation cannot be removed, however
    the label may be changed.
    
    The behavior of the ambient label remains unchanged.
    
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Paul Moore <paul.moore@hp.com>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 31dce559595a..b79582e4fbfd 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -16,6 +16,7 @@
 #include <linux/capability.h>
 #include <linux/spinlock.h>
 #include <linux/security.h>
+#include <linux/in.h>
 #include <net/netlabel.h>
 
 /*
@@ -39,6 +40,7 @@ struct superblock_smack {
 struct socket_smack {
 	char		*smk_out;			/* outbound label */
 	char		*smk_in;			/* inbound label */
+	int		smk_labeled;			/* label scheme */
 	char		smk_packet[SMK_LABELLEN];	/* TCP peer label */
 };
 
@@ -79,6 +81,16 @@ struct smack_cipso {
 	char	smk_catset[SMK_LABELLEN];
 };
 
+/*
+ * An entry in the table identifying hosts.
+ */
+struct smk_netlbladdr {
+	struct smk_netlbladdr	*smk_next;
+	struct sockaddr_in	smk_host;	/* network address */
+	struct in_addr		smk_mask;	/* network mask */
+	char			*smk_label;	/* label */
+};
+
 /*
  * This is the repository for labels seen so that it is
  * not necessary to keep allocating tiny chuncks of memory
@@ -127,6 +139,20 @@ struct smack_known {
 #define XATTR_NAME_SMACKIPOUT	XATTR_SECURITY_PREFIX XATTR_SMACK_IPOUT
 
 /*
+ * How communications on this socket are treated.
+ * Usually it's determined by the underlying netlabel code
+ * but there are certain cases, including single label hosts
+ * and potentially single label interfaces for which the
+ * treatment can not be known in advance.
+ *
+ * The possibility of additional labeling schemes being
+ * introduced in the future exists as well.
+ */
+#define SMACK_UNLABELED_SOCKET	0
+#define SMACK_CIPSO_SOCKET	1
+
+/*
+ * smackfs magic number
  * smackfs macic number
  */
 #define SMACK_MAGIC	0x43415d53 /* "SMAC" */
@@ -141,6 +167,7 @@ struct smack_known {
  * CIPSO defaults.
  */
 #define SMACK_CIPSO_DOI_DEFAULT		3	/* Historical */
+#define SMACK_CIPSO_DOI_INVALID		-1	/* Not a DOI */
 #define SMACK_CIPSO_DIRECT_DEFAULT	250	/* Arbitrary */
 #define SMACK_CIPSO_MAXCATVAL		63	/* Bigger gets harder */
 #define SMACK_CIPSO_MAXLEVEL            255     /* CIPSO 2.2 standard */
@@ -176,7 +203,6 @@ u32 smack_to_secid(const char *);
  * Shared data.
  */
 extern int smack_cipso_direct;
-extern int smack_net_nltype;
 extern char *smack_net_ambient;
 extern char *smack_onlycap;
 
@@ -186,9 +212,10 @@ extern struct smack_known smack_known_hat;
 extern struct smack_known smack_known_huh;
 extern struct smack_known smack_known_invalid;
 extern struct smack_known smack_known_star;
-extern struct smack_known smack_known_unset;
+extern struct smack_known smack_known_web;
 
 extern struct smk_list_entry *smack_list;
+extern struct smk_netlbladdr *smack_netlbladdrs;
 extern struct security_operations smack_ops;
 
 /*

commit 15446235367fa4a621ff5abfa4b6ebbe25b33763
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed Jul 30 15:37:11 2008 -0700

    smack: limit privilege by label
    
    There have been a number of requests to make the Smack LSM
    enforce MAC even in the face of privilege, either capability
    based or superuser based. This is not universally desired,
    however, so it seems desirable to make it optional. Further,
    at least one legacy OS implemented a scheme whereby only
    processes running with one particular label could be exempt
    from MAC. This patch supports these three cases.
    
    If /smack/onlycap is empty (unset or null-string) privilege
    is enforced in the normal way.
    
    If /smack/onlycap contains a label only processes running with
    that label may be MAC exempt.
    
    If the label in /smack/onlycap is the star label ("*") the
    semantics of the star label combine with the privilege
    restrictions to prevent any violations of MAC, even in the
    presence of privilege.
    
    Again, this will be independent of the privilege scheme.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: James Morris <jmorris@namei.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 4a4477f5afdc..31dce559595a 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -178,6 +178,7 @@ u32 smack_to_secid(const char *);
 extern int smack_cipso_direct;
 extern int smack_net_nltype;
 extern char *smack_net_ambient;
+extern char *smack_onlycap;
 
 extern struct smack_known *smack_known;
 extern struct smack_known smack_known_floor;

commit 076c54c5bcaed2081c0cba94a6f77c4d470236ad
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Thu Mar 6 18:09:10 2008 +0200

    Security: Introduce security= boot parameter
    
    Add the security= boot parameter. This is done to avoid LSM
    registration clashes in case of more than one bult-in module.
    
    User can choose a security module to enable at boot. If no
    security= boot parameter is specified, only the first LSM
    asking for registration will be loaded. An invalid security
    module name will be treated as if no module has been chosen.
    
    LSM modules must check now if they are allowed to register
    by calling security_module_enable(ops) first. Modify SELinux
    and SMACK to do so.
    
    Do not let SMACK register smackfs if it was not chosen on
    boot. Smackfs assumes that smack hooks are registered and
    the initial task security setup (swapper->security) is done.
    
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Acked-by: James Morris <jmorris@namei.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index 62c1e982849d..4a4477f5afdc 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -15,6 +15,7 @@
 
 #include <linux/capability.h>
 #include <linux/spinlock.h>
+#include <linux/security.h>
 #include <net/netlabel.h>
 
 /*
@@ -187,6 +188,7 @@ extern struct smack_known smack_known_star;
 extern struct smack_known smack_known_unset;
 
 extern struct smk_list_entry *smack_list;
+extern struct security_operations smack_ops;
 
 /*
  * Stricly for CIPSO level manipulation.

commit b500ce8d24d1f14426643da5f6fada28c1f60533
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Thu Mar 13 12:32:34 2008 -0700

    smackfs: do not trust `count' in inodes write()s
    
    Smackfs write() implementation does not put a higher bound on the number of
    bytes to copy from user-space.  This may lead to a DOS attack if a malicious
    `count' field is given.
    
    Assure that given `count' is exactly the length needed for a /smack/load rule.
     In case of /smack/cipso where the length is relative, assure that `count'
    does not exceed the size needed for a buffer representing maximum possible
    number of CIPSO 2.2 categories.
    
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
index a21a0e907ab3..62c1e982849d 100644
--- a/security/smack/smack.h
+++ b/security/smack/smack.h
@@ -26,14 +26,6 @@
 #define SMK_MAXLEN	23
 #define SMK_LABELLEN	(SMK_MAXLEN+1)
 
-/*
- * How many kinds of access are there?
- * Here's your answer.
- */
-#define SMK_ACCESSDASH	'-'
-#define SMK_ACCESSLOW	"rwxa"
-#define SMK_ACCESSKINDS	(sizeof(SMK_ACCESSLOW) - 1)
-
 struct superblock_smack {
 	char		*smk_root;
 	char		*smk_floor;

commit e114e473771c848c3cfec05f0123e70f1cdbdc99
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Feb 4 22:29:50 2008 -0800

    Smack: Simplified Mandatory Access Control Kernel
    
    Smack is the Simplified Mandatory Access Control Kernel.
    
    Smack implements mandatory access control (MAC) using labels
    attached to tasks and data containers, including files, SVIPC,
    and other tasks. Smack is a kernel based scheme that requires
    an absolute minimum of application support and a very small
    amount of configuration data.
    
    Smack uses extended attributes and
    provides a set of general mount options, borrowing technics used
    elsewhere. Smack uses netlabel for CIPSO labeling. Smack provides
    a pseudo-filesystem smackfs that is used for manipulation of
    system Smack attributes.
    
    The patch, patches for ls and sshd, a README, a startup script,
    and x86 binaries for ls and sshd are also available on
    
        http://www.schaufler-ca.com
    
    Development has been done using Fedora Core 7 in a virtual machine
    environment and on an old Sony laptop.
    
    Smack provides mandatory access controls based on the label attached
    to a task and the label attached to the object it is attempting to
    access. Smack labels are deliberately short (1-23 characters) text
    strings. Single character labels using special characters are reserved
    for system use. The only operation applied to Smack labels is equality
    comparison. No wildcards or expressions, regular or otherwise, are
    used. Smack labels are composed of printable characters and may not
    include "/".
    
    A file always gets the Smack label of the task that created it.
    
    Smack defines and uses these labels:
    
        "*" - pronounced "star"
        "_" - pronounced "floor"
        "^" - pronounced "hat"
        "?" - pronounced "huh"
    
    The access rules enforced by Smack are, in order:
    
    1. Any access requested by a task labeled "*" is denied.
    2. A read or execute access requested by a task labeled "^"
       is permitted.
    3. A read or execute access requested on an object labeled "_"
       is permitted.
    4. Any access requested on an object labeled "*" is permitted.
    5. Any access requested by a task on an object with the same
       label is permitted.
    6. Any access requested that is explicitly defined in the loaded
       rule set is permitted.
    7. Any other access is denied.
    
    Rules may be explicitly defined by writing subject,object,access
    triples to /smack/load.
    
    Smack rule sets can be easily defined that describe Bell&LaPadula
    sensitivity, Biba integrity, and a variety of interesting
    configurations. Smack rule sets can be modified on the fly to
    accommodate changes in the operating environment or even the time
    of day.
    
    Some practical use cases:
    
    Hierarchical levels. The less common of the two usual uses
    for MLS systems is to define hierarchical levels, often
    unclassified, confidential, secret, and so on. To set up smack
    to support this, these rules could be defined:
    
       C        Unclass rx
       S        C       rx
       S        Unclass rx
       TS       S       rx
       TS       C       rx
       TS       Unclass rx
    
    A TS process can read S, C, and Unclass data, but cannot write it.
    An S process can read C and Unclass. Note that specifying that
    TS can read S and S can read C does not imply TS can read C, it
    has to be explicitly stated.
    
    Non-hierarchical categories. This is the more common of the
    usual uses for an MLS system. Since the default rule is that a
    subject cannot access an object with a different label no
    access rules are required to implement compartmentalization.
    
    A case that the Bell & LaPadula policy does not allow is demonstrated
    with this Smack access rule:
    
    A case that Bell&LaPadula does not allow that Smack does:
    
        ESPN    ABC   r
        ABC     ESPN  r
    
    On my portable video device I have two applications, one that
    shows ABC programming and the other ESPN programming. ESPN wants
    to show me sport stories that show up as news, and ABC will
    only provide minimal information about a sports story if ESPN
    is covering it. Each side can look at the other's info, neither
    can change the other. Neither can see what FOX is up to, which
    is just as well all things considered.
    
    Another case that I especially like:
    
        SatData Guard   w
        Guard   Publish w
    
    A program running with the Guard label opens a UDP socket and
    accepts messages sent by a program running with a SatData label.
    The Guard program inspects the message to ensure it is wholesome
    and if it is sends it to a program running with the Publish label.
    This program then puts the information passed in an appropriate
    place. Note that the Guard program cannot write to a Publish
    file system object because file system semanitic require read as
    well as write.
    
    The four cases (categories, levels, mutual read, guardbox) here
    are all quite real, and problems I've been asked to solve over
    the years. The first two are easy to do with traditonal MLS systems
    while the last two you can't without invoking privilege, at least
    for a while.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Cc: Joshua Brindle <method@manicmethod.com>
    Cc: Paul Moore <paul.moore@hp.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: James Morris <jmorris@namei.org>
    Cc: "Ahmed S. Darwish" <darwish.07@gmail.com>
    Cc: Andrew G. Morgan <morgan@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/smack/smack.h b/security/smack/smack.h
new file mode 100644
index 000000000000..a21a0e907ab3
--- /dev/null
+++ b/security/smack/smack.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2007 Casey Schaufler <casey@schaufler-ca.com>
+ *
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation, version 2.
+ *
+ * Author:
+ *      Casey Schaufler <casey@schaufler-ca.com>
+ *
+ */
+
+#ifndef _SECURITY_SMACK_H
+#define _SECURITY_SMACK_H
+
+#include <linux/capability.h>
+#include <linux/spinlock.h>
+#include <net/netlabel.h>
+
+/*
+ * Why 23? CIPSO is constrained to 30, so a 32 byte buffer is
+ * bigger than can be used, and 24 is the next lower multiple
+ * of 8, and there are too many issues if there isn't space set
+ * aside for the terminating null byte.
+ */
+#define SMK_MAXLEN	23
+#define SMK_LABELLEN	(SMK_MAXLEN+1)
+
+/*
+ * How many kinds of access are there?
+ * Here's your answer.
+ */
+#define SMK_ACCESSDASH	'-'
+#define SMK_ACCESSLOW	"rwxa"
+#define SMK_ACCESSKINDS	(sizeof(SMK_ACCESSLOW) - 1)
+
+struct superblock_smack {
+	char		*smk_root;
+	char		*smk_floor;
+	char		*smk_hat;
+	char		*smk_default;
+	int		smk_initialized;
+	spinlock_t	smk_sblock;	/* for initialization */
+};
+
+struct socket_smack {
+	char		*smk_out;			/* outbound label */
+	char		*smk_in;			/* inbound label */
+	char		smk_packet[SMK_LABELLEN];	/* TCP peer label */
+};
+
+/*
+ * Inode smack data
+ */
+struct inode_smack {
+	char		*smk_inode;	/* label of the fso */
+	struct mutex	smk_lock;	/* initialization lock */
+	int		smk_flags;	/* smack inode flags */
+};
+
+#define	SMK_INODE_INSTANT	0x01	/* inode is instantiated */
+
+/*
+ * A label access rule.
+ */
+struct smack_rule {
+	char	*smk_subject;
+	char	*smk_object;
+	int	smk_access;
+};
+
+/*
+ * An entry in the table of permitted label accesses.
+ */
+struct smk_list_entry {
+	struct smk_list_entry	*smk_next;
+	struct smack_rule	smk_rule;
+};
+
+/*
+ * An entry in the table mapping smack values to
+ * CIPSO level/category-set values.
+ */
+struct smack_cipso {
+	int	smk_level;
+	char	smk_catset[SMK_LABELLEN];
+};
+
+/*
+ * This is the repository for labels seen so that it is
+ * not necessary to keep allocating tiny chuncks of memory
+ * and so that they can be shared.
+ *
+ * Labels are never modified in place. Anytime a label
+ * is imported (e.g. xattrset on a file) the list is checked
+ * for it and it is added if it doesn't exist. The address
+ * is passed out in either case. Entries are added, but
+ * never deleted.
+ *
+ * Since labels are hanging around anyway it doesn't
+ * hurt to maintain a secid for those awkward situations
+ * where kernel components that ought to use LSM independent
+ * interfaces don't. The secid should go away when all of
+ * these components have been repaired.
+ *
+ * If there is a cipso value associated with the label it
+ * gets stored here, too. This will most likely be rare as
+ * the cipso direct mapping in used internally.
+ */
+struct smack_known {
+	struct smack_known	*smk_next;
+	char			smk_known[SMK_LABELLEN];
+	u32			smk_secid;
+	struct smack_cipso	*smk_cipso;
+	spinlock_t		smk_cipsolock; /* for changing cipso map */
+};
+
+/*
+ * Mount options
+ */
+#define SMK_FSDEFAULT	"smackfsdef="
+#define SMK_FSFLOOR	"smackfsfloor="
+#define SMK_FSHAT	"smackfshat="
+#define SMK_FSROOT	"smackfsroot="
+
+/*
+ * xattr names
+ */
+#define XATTR_SMACK_SUFFIX	"SMACK64"
+#define XATTR_SMACK_IPIN	"SMACK64IPIN"
+#define XATTR_SMACK_IPOUT	"SMACK64IPOUT"
+#define XATTR_NAME_SMACK	XATTR_SECURITY_PREFIX XATTR_SMACK_SUFFIX
+#define XATTR_NAME_SMACKIPIN	XATTR_SECURITY_PREFIX XATTR_SMACK_IPIN
+#define XATTR_NAME_SMACKIPOUT	XATTR_SECURITY_PREFIX XATTR_SMACK_IPOUT
+
+/*
+ * smackfs macic number
+ */
+#define SMACK_MAGIC	0x43415d53 /* "SMAC" */
+
+/*
+ * A limit on the number of entries in the lists
+ * makes some of the list administration easier.
+ */
+#define SMACK_LIST_MAX	10000
+
+/*
+ * CIPSO defaults.
+ */
+#define SMACK_CIPSO_DOI_DEFAULT		3	/* Historical */
+#define SMACK_CIPSO_DIRECT_DEFAULT	250	/* Arbitrary */
+#define SMACK_CIPSO_MAXCATVAL		63	/* Bigger gets harder */
+#define SMACK_CIPSO_MAXLEVEL            255     /* CIPSO 2.2 standard */
+#define SMACK_CIPSO_MAXCATNUM           239     /* CIPSO 2.2 standard */
+
+/*
+ * Just to make the common cases easier to deal with
+ */
+#define MAY_ANY		(MAY_READ | MAY_WRITE | MAY_APPEND | MAY_EXEC)
+#define MAY_ANYREAD	(MAY_READ | MAY_EXEC)
+#define MAY_ANYWRITE	(MAY_WRITE | MAY_APPEND)
+#define MAY_READWRITE	(MAY_READ | MAY_WRITE)
+#define MAY_NOT		0
+
+/*
+ * These functions are in smack_lsm.c
+ */
+struct inode_smack *new_inode_smack(char *);
+
+/*
+ * These functions are in smack_access.c
+ */
+int smk_access(char *, char *, int);
+int smk_curacc(char *, u32);
+int smack_to_cipso(const char *, struct smack_cipso *);
+void smack_from_cipso(u32, char *, char *);
+char *smack_from_secid(const u32);
+char *smk_import(const char *, int);
+struct smack_known *smk_import_entry(const char *, int);
+u32 smack_to_secid(const char *);
+
+/*
+ * Shared data.
+ */
+extern int smack_cipso_direct;
+extern int smack_net_nltype;
+extern char *smack_net_ambient;
+
+extern struct smack_known *smack_known;
+extern struct smack_known smack_known_floor;
+extern struct smack_known smack_known_hat;
+extern struct smack_known smack_known_huh;
+extern struct smack_known smack_known_invalid;
+extern struct smack_known smack_known_star;
+extern struct smack_known smack_known_unset;
+
+extern struct smk_list_entry *smack_list;
+
+/*
+ * Stricly for CIPSO level manipulation.
+ * Set the category bit number in a smack label sized buffer.
+ */
+static inline void smack_catset_bit(int cat, char *catsetp)
+{
+	if (cat > SMK_LABELLEN * 8)
+		return;
+
+	catsetp[(cat - 1) / 8] |= 0x80 >> ((cat - 1) % 8);
+}
+
+/*
+ * Present a pointer to the smack label in an inode blob.
+ */
+static inline char *smk_of_inode(const struct inode *isp)
+{
+	struct inode_smack *sip = isp->i_security;
+	return sip->smk_inode;
+}
+
+#endif  /* _SECURITY_SMACK_H */
