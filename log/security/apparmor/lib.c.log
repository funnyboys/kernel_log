commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 76491e7f4177..30c246a9d440 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * AppArmor security module
  *
@@ -5,11 +6,6 @@
  *
  * Copyright (C) 1998-2008 Novell/SUSE
  * Copyright 2009-2010 Canonical Ltd.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation, version 2 of the
- * License.
  */
 
 #include <linux/ctype.h>

commit 250f2da49cb8e582215a65c03f50e8ddf5cd119c
Author: Zubin Mithra <zsm@chromium.org>
Date:   Thu Sep 27 14:49:17 2018 -0700

    apparmor: Fix uninitialized value in aa_split_fqname
    
    Syzkaller reported a OOB-read with the stacktrace below. This occurs
    inside __aa_lookupn_ns as `n` is not initialized. `n` is obtained from
    aa_splitn_fqname. In cases where `name` is invalid, aa_splitn_fqname
    returns without initializing `ns_name` and `ns_len`.
    
    Fix this by always initializing `ns_name` and `ns_len`.
    
            __dump_stack lib/dump_stack.c:77 [inline]
            dump_stack+0x1c4/0x2b4 lib/dump_stack.c:113
            print_address_description.cold.8+0x9/0x1ff mm/kasan/report.c:256
            kasan_report_error mm/kasan/report.c:354 [inline]
            kasan_report.cold.9+0x242/0x309 mm/kasan/report.c:412
            __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:430
            memcmp+0xe3/0x160 lib/string.c:861
            strnstr+0x4b/0x70 lib/string.c:934
            __aa_lookupn_ns+0xc1/0x570 security/apparmor/policy_ns.c:209
            aa_lookupn_ns+0x88/0x1e0 security/apparmor/policy_ns.c:240
            aa_fqlookupn_profile+0x1b9/0x1010 security/apparmor/policy.c:468
            fqlookupn_profile+0x80/0xc0 security/apparmor/label.c:1844
            aa_label_strn_parse+0xa3a/0x1230 security/apparmor/label.c:1908
            aa_label_parse+0x42/0x50 security/apparmor/label.c:1943
            aa_change_profile+0x513/0x3510 security/apparmor/domain.c:1362
            apparmor_setprocattr+0xaa4/0x1150 security/apparmor/lsm.c:658
            security_setprocattr+0x66/0xc0 security/security.c:1298
            proc_pid_attr_write+0x301/0x540 fs/proc/base.c:2555
            __vfs_write+0x119/0x9f0 fs/read_write.c:485
            vfs_write+0x1fc/0x560 fs/read_write.c:549
            ksys_write+0x101/0x260 fs/read_write.c:598
            __do_sys_write fs/read_write.c:610 [inline]
            __se_sys_write fs/read_write.c:607 [inline]
            __x64_sys_write+0x73/0xb0 fs/read_write.c:607
            do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290
            entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Fixes: 3b0aaf5866bf ("apparmor: add lib fn to find the "split" for fqnames")
    Reported-by: syzbot+61e4b490d9d2da591b50@syzkaller.appspotmail.com
    Signed-off-by: Zubin Mithra <zsm@chromium.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 974affe50531..76491e7f4177 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -90,10 +90,12 @@ const char *aa_splitn_fqname(const char *fqname, size_t n, const char **ns_name,
 	const char *end = fqname + n;
 	const char *name = skipn_spaces(fqname, n);
 
-	if (!name)
-		return NULL;
 	*ns_name = NULL;
 	*ns_len = 0;
+
+	if (!name)
+		return NULL;
+
 	if (name[0] == ':') {
 		char *split = strnchr(&name[1], end - &name[1], ':');
 		*ns_name = skipn_spaces(&name[1], end - &name[1]);

commit 7f3ebcf2b1395e0248e56146041e1e5625fd2f23
Author: Tyler Hicks <tyhicks@canonical.com>
Date:   Fri Jul 6 05:25:00 2018 +0000

    apparmor: Check buffer bounds when mapping permissions mask
    
    Don't read past the end of the buffer containing permissions
    characters or write past the end of the destination string.
    
    Detected by CoverityScan CID#1415361, 1415376 ("Out-of-bounds access")
    
    Fixes: e53cfe6c7caa ("apparmor: rework perm mapping to a slightly broader set")
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index a7b3f681b80e..974affe50531 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -198,15 +198,24 @@ const char *aa_file_perm_names[] = {
 /**
  * aa_perm_mask_to_str - convert a perm mask to its short string
  * @str: character buffer to store string in (at least 10 characters)
+ * @str_size: size of the @str buffer
+ * @chrs: NUL-terminated character buffer of permission characters
  * @mask: permission mask to convert
  */
-void aa_perm_mask_to_str(char *str, const char *chrs, u32 mask)
+void aa_perm_mask_to_str(char *str, size_t str_size, const char *chrs, u32 mask)
 {
 	unsigned int i, perm = 1;
+	size_t num_chrs = strlen(chrs);
+
+	for (i = 0; i < num_chrs; perm <<= 1, i++) {
+		if (mask & perm) {
+			/* Ensure that one byte is left for NUL-termination */
+			if (WARN_ON_ONCE(str_size <= 1))
+				break;
 
-	for (i = 0; i < 32; perm <<= 1, i++) {
-		if (mask & perm)
 			*str++ = chrs[i];
+			str_size--;
+		}
 	}
 	*str = '\0';
 }
@@ -236,7 +245,7 @@ void aa_audit_perm_mask(struct audit_buffer *ab, u32 mask, const char *chrs,
 
 	audit_log_format(ab, "\"");
 	if ((mask & chrsmask) && chrs) {
-		aa_perm_mask_to_str(str, chrs, mask & chrsmask);
+		aa_perm_mask_to_str(str, sizeof(str), chrs, mask & chrsmask);
 		mask &= ~chrsmask;
 		audit_log_format(ab, "%s", str);
 		if (mask & namesmask)

commit 69ad4a44a26ee8fefdb75848ccb6784f5254f14c
Author: Zygmunt Krynicki <zygmunt.krynicki@canonical.com>
Date:   Thu Apr 12 12:34:31 2018 +0200

    apparmor: fix typo "type"
    
    Signed-off-by: Zygmunt Krynicki <zygmunt.krynicki@canonical.com>
    Acked-by: Christian Boltz <apparmor@cboltz.de>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 068a9f471f77..a7b3f681b80e 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -408,7 +408,7 @@ int aa_profile_label_perm(struct aa_profile *profile, struct aa_profile *target,
  * @request: requested perms
  * @deny: Returns: explicit deny set
  * @sa: initialized audit structure (MAY BE NULL if not auditing)
- * @cb: callback fn for tpye specific fields (MAY BE NULL)
+ * @cb: callback fn for type specific fields (MAY BE NULL)
  *
  * Returns: 0 if permission else error code
  *

commit 56974a6fcfef69ee0825bd66ed13e92070ac5224
Author: John Johansen <john.johansen@canonical.com>
Date:   Tue Jul 18 23:18:33 2017 -0700

    apparmor: add base infastructure for socket mediation
    
    version 2 - Force an abi break. Network mediation will only be
                available in v8 abi complaint policy.
    
    Provide a basic mediation of sockets. This is not a full net mediation
    but just whether a spcific family of socket can be used by an
    application, along with setting up some basic infrastructure for
    network mediation to follow.
    
    the user space rule hav the basic form of
      NETWORK RULE = [ QUALIFIERS ] 'network' [ DOMAIN ]
                     [ TYPE | PROTOCOL ]
    
      DOMAIN = ( 'inet' | 'ax25' | 'ipx' | 'appletalk' | 'netrom' |
                 'bridge' | 'atmpvc' | 'x25' | 'inet6' | 'rose' |
                 'netbeui' | 'security' | 'key' | 'packet' | 'ash' |
                 'econet' | 'atmsvc' | 'sna' | 'irda' | 'pppox' |
                 'wanpipe' | 'bluetooth' | 'netlink' | 'unix' | 'rds' |
                 'llc' | 'can' | 'tipc' | 'iucv' | 'rxrpc' | 'isdn' |
                 'phonet' | 'ieee802154' | 'caif' | 'alg' | 'nfc' |
                 'vsock' | 'mpls' | 'ib' | 'kcm' ) ','
    
      TYPE = ( 'stream' | 'dgram' | 'seqpacket' |  'rdm' | 'raw' |
               'packet' )
    
      PROTOCOL = ( 'tcp' | 'udp' | 'icmp' )
    
    eg.
      network,
      network inet,
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Seth Arnold <seth.arnold@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 4d5e98e49d5e..068a9f471f77 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -211,7 +211,8 @@ void aa_perm_mask_to_str(char *str, const char *chrs, u32 mask)
 	*str = '\0';
 }
 
-void aa_audit_perm_names(struct audit_buffer *ab, const char **names, u32 mask)
+void aa_audit_perm_names(struct audit_buffer *ab, const char * const *names,
+			 u32 mask)
 {
 	const char *fmt = "%s";
 	unsigned int i, perm = 1;
@@ -229,7 +230,7 @@ void aa_audit_perm_names(struct audit_buffer *ab, const char **names, u32 mask)
 }
 
 void aa_audit_perm_mask(struct audit_buffer *ab, u32 mask, const char *chrs,
-			u32 chrsmask, const char **names, u32 namesmask)
+			u32 chrsmask, const char * const *names, u32 namesmask)
 {
 	char str[33];
 

commit e3bcfc148588e409685479f3d20ba3d66ae30035
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Oct 14 13:14:38 2017 +0100

    apparmor: remove unused redundant variable stop
    
    The boolean variable 'stop' is being set but never read. This
    is a redundant variable and can be removed.
    
    Cleans up clang warning: Value stored to 'stop' is never read
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 3d0a2bf87abd..4d5e98e49d5e 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -423,7 +423,6 @@ int aa_check_perms(struct aa_profile *profile, struct aa_perms *perms,
 		   void (*cb)(struct audit_buffer *, void *))
 {
 	int type, error;
-	bool stop = false;
 	u32 denied = request & (~perms->allow | perms->deny);
 
 	if (likely(!denied)) {
@@ -444,8 +443,6 @@ int aa_check_perms(struct aa_profile *profile, struct aa_perms *perms,
 		else
 			type = AUDIT_APPARMOR_DENIED;
 
-		if (denied & perms->stop)
-			stop = true;
 		if (denied == (denied & perms->hide))
 			error = -ENOENT;
 

commit 7bba39ae52c4d7b467d0a6f74cc067a561aac043
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Sep 15 21:55:46 2017 +0200

    apparmor: initialized returned struct aa_perms
    
    gcc-4.4 points out suspicious code in compute_mnt_perms, where
    the aa_perms structure is only partially initialized before getting
    returned:
    
    security/apparmor/mount.c: In function 'compute_mnt_perms':
    security/apparmor/mount.c:227: error: 'perms.prompt' is used uninitialized in this function
    security/apparmor/mount.c:227: error: 'perms.hide' is used uninitialized in this function
    security/apparmor/mount.c:227: error: 'perms.cond' is used uninitialized in this function
    security/apparmor/mount.c:227: error: 'perms.complain' is used uninitialized in this function
    security/apparmor/mount.c:227: error: 'perms.stop' is used uninitialized in this function
    security/apparmor/mount.c:227: error: 'perms.deny' is used uninitialized in this function
    
    Returning or assigning partially initialized structures is a bit tricky,
    in particular it is explicitly allowed in c99 to assign a partially
    initialized structure to another, as long as only members are read that
    have been initialized earlier. Looking at what various compilers do here,
    the version that produced the warning copied uninitialized stack data,
    while newer versions (and also clang) either set the other members to
    zero or don't update the parts of the return buffer that are not modified
    in the temporary structure, but they never warn about this.
    
    In case of apparmor, it seems better to be a little safer and always
    initialize the aa_perms structure. Most users already do that, this
    changes the remaining ones, including the one instance that I got the
    warning for.
    
    Fixes: fa488437d0f9 ("apparmor: add mount mediation")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Seth Arnold <seth.arnold@canonical.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 08ca26bcca77..3d0a2bf87abd 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -317,14 +317,11 @@ static u32 map_other(u32 x)
 void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,
 		      struct aa_perms *perms)
 {
-	perms->deny = 0;
-	perms->kill = perms->stop = 0;
-	perms->complain = perms->cond = 0;
-	perms->hide = 0;
-	perms->prompt = 0;
-	perms->allow = dfa_user_allow(dfa, state);
-	perms->audit = dfa_user_audit(dfa, state);
-	perms->quiet = dfa_user_quiet(dfa, state);
+	*perms = (struct aa_perms) {
+		.allow = dfa_user_allow(dfa, state),
+		.audit = dfa_user_audit(dfa, state),
+		.quiet = dfa_user_quiet(dfa, state),
+	};
 
 	/* for v5 perm mapping in the policydb, the other set is used
 	 * to extend the general perm set

commit 80c094a47dd4ea63375e3f60b5e076064f16e857
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 26 19:35:35 2017 +0200

    Revert "apparmor: add base infastructure for socket mediation"
    
    This reverts commit 651e28c5537abb39076d3949fb7618536f1d242e.
    
    This caused a regression:
     "The specific problem is that dnsmasq refuses to start on openSUSE Leap
      42.2.  The specific cause is that and attempt to open a PF_LOCAL socket
      gets EACCES.  This means that networking doesn't function on a system
      with a 4.14-rc2 system."
    
    Sadly, the developers involved seemed to be in denial for several weeks
    about this, delaying the revert.  This has not been a good release for
    the security subsystem, and this area needs to change development
    practices.
    
    Reported-and-bisected-by: James Bottomley <James.Bottomley@hansenpartnership.com>
    Tracked-by: Thorsten Leemhuis <regressions@leemhuis.info>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Seth Arnold <seth.arnold@canonical.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 8818621b5d95..08ca26bcca77 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -211,8 +211,7 @@ void aa_perm_mask_to_str(char *str, const char *chrs, u32 mask)
 	*str = '\0';
 }
 
-void aa_audit_perm_names(struct audit_buffer *ab, const char * const *names,
-			 u32 mask)
+void aa_audit_perm_names(struct audit_buffer *ab, const char **names, u32 mask)
 {
 	const char *fmt = "%s";
 	unsigned int i, perm = 1;
@@ -230,7 +229,7 @@ void aa_audit_perm_names(struct audit_buffer *ab, const char * const *names,
 }
 
 void aa_audit_perm_mask(struct audit_buffer *ab, u32 mask, const char *chrs,
-			u32 chrsmask, const char * const *names, u32 namesmask)
+			u32 chrsmask, const char **names, u32 namesmask)
 {
 	char str[33];
 

commit 651e28c5537abb39076d3949fb7618536f1d242e
Author: John Johansen <john.johansen@canonical.com>
Date:   Tue Jul 18 23:18:33 2017 -0700

    apparmor: add base infastructure for socket mediation
    
    Provide a basic mediation of sockets. This is not a full net mediation
    but just whether a spcific family of socket can be used by an
    application, along with setting up some basic infrastructure for
    network mediation to follow.
    
    the user space rule hav the basic form of
      NETWORK RULE = [ QUALIFIERS ] 'network' [ DOMAIN ]
                     [ TYPE | PROTOCOL ]
    
      DOMAIN = ( 'inet' | 'ax25' | 'ipx' | 'appletalk' | 'netrom' |
                 'bridge' | 'atmpvc' | 'x25' | 'inet6' | 'rose' |
                 'netbeui' | 'security' | 'key' | 'packet' | 'ash' |
                 'econet' | 'atmsvc' | 'sna' | 'irda' | 'pppox' |
                 'wanpipe' | 'bluetooth' | 'netlink' | 'unix' | 'rds' |
                 'llc' | 'can' | 'tipc' | 'iucv' | 'rxrpc' | 'isdn' |
                 'phonet' | 'ieee802154' | 'caif' | 'alg' | 'nfc' |
                 'vsock' | 'mpls' | 'ib' | 'kcm' ) ','
    
      TYPE = ( 'stream' | 'dgram' | 'seqpacket' |  'rdm' | 'raw' |
               'packet' )
    
      PROTOCOL = ( 'tcp' | 'udp' | 'icmp' )
    
    eg.
      network,
      network inet,
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Seth Arnold <seth.arnold@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 08ca26bcca77..8818621b5d95 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -211,7 +211,8 @@ void aa_perm_mask_to_str(char *str, const char *chrs, u32 mask)
 	*str = '\0';
 }
 
-void aa_audit_perm_names(struct audit_buffer *ab, const char **names, u32 mask)
+void aa_audit_perm_names(struct audit_buffer *ab, const char * const *names,
+			 u32 mask)
 {
 	const char *fmt = "%s";
 	unsigned int i, perm = 1;
@@ -229,7 +230,7 @@ void aa_audit_perm_names(struct audit_buffer *ab, const char **names, u32 mask)
 }
 
 void aa_audit_perm_mask(struct audit_buffer *ab, u32 mask, const char *chrs,
-			u32 chrsmask, const char **names, u32 namesmask)
+			u32 chrsmask, const char * const *names, u32 namesmask)
 {
 	char str[33];
 

commit 637f688dc3dc304a89f441d76f49a0e35bc49c08
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri Jun 9 08:14:28 2017 -0700

    apparmor: switch from profiles to using labels on contexts
    
    Begin the actual switch to using domain labels by storing them on
    the context and converting the label to a singular profile where
    possible.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 0ceecdbb4658..08ca26bcca77 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -246,6 +246,32 @@ void aa_audit_perm_mask(struct audit_buffer *ab, u32 mask, const char *chrs,
 	audit_log_format(ab, "\"");
 }
 
+/**
+ * aa_audit_perms_cb - generic callback fn for auditing perms
+ * @ab: audit buffer (NOT NULL)
+ * @va: audit struct to audit values of (NOT NULL)
+ */
+static void aa_audit_perms_cb(struct audit_buffer *ab, void *va)
+{
+	struct common_audit_data *sa = va;
+
+	if (aad(sa)->request) {
+		audit_log_format(ab, " requested_mask=");
+		aa_audit_perm_mask(ab, aad(sa)->request, aa_file_perm_chrs,
+				   PERMS_CHRS_MASK, aa_file_perm_names,
+				   PERMS_NAMES_MASK);
+	}
+	if (aad(sa)->denied) {
+		audit_log_format(ab, "denied_mask=");
+		aa_audit_perm_mask(ab, aad(sa)->denied, aa_file_perm_chrs,
+				   PERMS_CHRS_MASK, aa_file_perm_names,
+				   PERMS_NAMES_MASK);
+	}
+	audit_log_format(ab, " peer=");
+	aa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,
+				      FLAGS_NONE, GFP_ATOMIC);
+}
+
 /**
  * aa_apply_modes_to_perms - apply namespace and profile flags to perms
  * @profile: that perms where computed from
@@ -309,6 +335,143 @@ void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,
 //	perms->xindex = dfa_user_xindex(dfa, state);
 }
 
+/**
+ * aa_perms_accum_raw - accumulate perms with out masking off overlapping perms
+ * @accum - perms struct to accumulate into
+ * @addend - perms struct to add to @accum
+ */
+void aa_perms_accum_raw(struct aa_perms *accum, struct aa_perms *addend)
+{
+	accum->deny |= addend->deny;
+	accum->allow &= addend->allow & ~addend->deny;
+	accum->audit |= addend->audit & addend->allow;
+	accum->quiet &= addend->quiet & ~addend->allow;
+	accum->kill |= addend->kill & ~addend->allow;
+	accum->stop |= addend->stop & ~addend->allow;
+	accum->complain |= addend->complain & ~addend->allow & ~addend->deny;
+	accum->cond |= addend->cond & ~addend->allow & ~addend->deny;
+	accum->hide &= addend->hide & ~addend->allow;
+	accum->prompt |= addend->prompt & ~addend->allow & ~addend->deny;
+}
+
+/**
+ * aa_perms_accum - accumulate perms, masking off overlapping perms
+ * @accum - perms struct to accumulate into
+ * @addend - perms struct to add to @accum
+ */
+void aa_perms_accum(struct aa_perms *accum, struct aa_perms *addend)
+{
+	accum->deny |= addend->deny;
+	accum->allow &= addend->allow & ~accum->deny;
+	accum->audit |= addend->audit & accum->allow;
+	accum->quiet &= addend->quiet & ~accum->allow;
+	accum->kill |= addend->kill & ~accum->allow;
+	accum->stop |= addend->stop & ~accum->allow;
+	accum->complain |= addend->complain & ~accum->allow & ~accum->deny;
+	accum->cond |= addend->cond & ~accum->allow & ~accum->deny;
+	accum->hide &= addend->hide & ~accum->allow;
+	accum->prompt |= addend->prompt & ~accum->allow & ~accum->deny;
+}
+
+void aa_profile_match_label(struct aa_profile *profile, struct aa_label *label,
+			    int type, u32 request, struct aa_perms *perms)
+{
+	/* TODO: doesn't yet handle extended types */
+	unsigned int state;
+
+	state = aa_dfa_next(profile->policy.dfa,
+			    profile->policy.start[AA_CLASS_LABEL],
+			    type);
+	aa_label_match(profile, label, state, false, request, perms);
+}
+
+
+/* currently unused */
+int aa_profile_label_perm(struct aa_profile *profile, struct aa_profile *target,
+			  u32 request, int type, u32 *deny,
+			  struct common_audit_data *sa)
+{
+	struct aa_perms perms;
+
+	aad(sa)->label = &profile->label;
+	aad(sa)->peer = &target->label;
+	aad(sa)->request = request;
+
+	aa_profile_match_label(profile, &target->label, type, request, &perms);
+	aa_apply_modes_to_perms(profile, &perms);
+	*deny |= request & perms.deny;
+	return aa_check_perms(profile, &perms, request, sa, aa_audit_perms_cb);
+}
+
+/**
+ * aa_check_perms - do audit mode selection based on perms set
+ * @profile: profile being checked
+ * @perms: perms computed for the request
+ * @request: requested perms
+ * @deny: Returns: explicit deny set
+ * @sa: initialized audit structure (MAY BE NULL if not auditing)
+ * @cb: callback fn for tpye specific fields (MAY BE NULL)
+ *
+ * Returns: 0 if permission else error code
+ *
+ * Note: profile audit modes need to be set before calling by setting the
+ *       perm masks appropriately.
+ *
+ *       If not auditing then complain mode is not enabled and the
+ *       error code will indicate whether there was an explicit deny
+ *	 with a positive value.
+ */
+int aa_check_perms(struct aa_profile *profile, struct aa_perms *perms,
+		   u32 request, struct common_audit_data *sa,
+		   void (*cb)(struct audit_buffer *, void *))
+{
+	int type, error;
+	bool stop = false;
+	u32 denied = request & (~perms->allow | perms->deny);
+
+	if (likely(!denied)) {
+		/* mask off perms that are not being force audited */
+		request &= perms->audit;
+		if (!request || !sa)
+			return 0;
+
+		type = AUDIT_APPARMOR_AUDIT;
+		error = 0;
+	} else {
+		error = -EACCES;
+
+		if (denied & perms->kill)
+			type = AUDIT_APPARMOR_KILL;
+		else if (denied == (denied & perms->complain))
+			type = AUDIT_APPARMOR_ALLOWED;
+		else
+			type = AUDIT_APPARMOR_DENIED;
+
+		if (denied & perms->stop)
+			stop = true;
+		if (denied == (denied & perms->hide))
+			error = -ENOENT;
+
+		denied &= ~perms->quiet;
+		if (!sa || !denied)
+			return error;
+	}
+
+	if (sa) {
+		aad(sa)->label = &profile->label;
+		aad(sa)->request = request;
+		aad(sa)->denied = denied;
+		aad(sa)->error = error;
+		aa_audit_msg(type, sa, cb);
+	}
+
+	if (type == AUDIT_APPARMOR_ALLOWED)
+		error = 0;
+
+	return error;
+}
+
+
 /**
  * aa_policy_init - initialize a policy structure
  * @policy: policy to initialize  (NOT NULL)

commit a1bd627b46d169268a0ee5960899fb5be960a317
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri Jun 9 07:09:05 2017 -0700

    apparmor: share profile name on replacement
    
    The profile names are the same, leverage this.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 3e9146e68c4a..0ceecdbb4658 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -134,6 +134,24 @@ void aa_info_message(const char *str)
 	printk(KERN_INFO "AppArmor: %s\n", str);
 }
 
+__counted char *aa_str_alloc(int size, gfp_t gfp)
+{
+	struct counted_str *str;
+
+	str = kmalloc(sizeof(struct counted_str) + size, gfp);
+	if (!str)
+		return NULL;
+
+	kref_init(&str->count);
+	return str->name;
+}
+
+void aa_str_kref(struct kref *kref)
+{
+	kfree(container_of(kref, struct counted_str, count));
+}
+
+
 const char aa_file_perm_chrs[] = "xwracd         km l     ";
 const char *aa_file_perm_names[] = {
 	"exec",
@@ -296,6 +314,7 @@ void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,
  * @policy: policy to initialize  (NOT NULL)
  * @prefix: prefix name if any is required.  (MAYBE NULL)
  * @name: name of the policy, init will make a copy of it  (NOT NULL)
+ * @gfp: allocation mode
  *
  * Note: this fn creates a copy of strings passed in
  *
@@ -304,16 +323,21 @@ void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,
 bool aa_policy_init(struct aa_policy *policy, const char *prefix,
 		    const char *name, gfp_t gfp)
 {
+	char *hname;
+
 	/* freed by policy_free */
 	if (prefix) {
-		policy->hname = kmalloc(strlen(prefix) + strlen(name) + 3,
-					gfp);
-		if (policy->hname)
-			sprintf((char *)policy->hname, "%s//%s", prefix, name);
-	} else
-		policy->hname = kstrdup(name, gfp);
-	if (!policy->hname)
+		hname = aa_str_alloc(strlen(prefix) + strlen(name) + 3, gfp);
+		if (hname)
+			sprintf(hname, "%s//%s", prefix, name);
+	} else {
+		hname = aa_str_alloc(strlen(name) + 1, gfp);
+		if (hname)
+			strcpy(hname, name);
+	}
+	if (!hname)
 		return false;
+	policy->hname = hname;
 	/* base.name is a substring of fqname */
 	policy->name = basename(policy->hname);
 	INIT_LIST_HEAD(&policy->list);
@@ -332,5 +356,5 @@ void aa_policy_destroy(struct aa_policy *policy)
 	AA_BUG(on_list_rcu(&policy->list));
 
 	/* don't free name as its a subset of hname */
-	kzfree(policy->hname);
+	aa_put_str(policy->hname);
 }

commit 2d679f3cb0eaa6afa0dc97fe6ad3b797e1c1899a
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon May 29 12:19:39 2017 -0700

    apparmor: switch from file_perms to aa_perms
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index a50913744823..3e9146e68c4a 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -24,6 +24,7 @@
 #include "include/perms.h"
 #include "include/policy.h"
 
+struct aa_perms nullperms;
 struct aa_perms allperms = { .allow = ALL_PERMS_MASK,
 			     .quiet = ALL_PERMS_MASK,
 			     .hide = ALL_PERMS_MASK };

commit aa9aeea8d4c3dfb9297723c4340671ef88e372d3
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon May 29 12:16:04 2017 -0700

    apparmor: add gerneric permissions struct and support fns
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 90d4631ddafe..a50913744823 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -24,6 +24,10 @@
 #include "include/perms.h"
 #include "include/policy.h"
 
+struct aa_perms allperms = { .allow = ALL_PERMS_MASK,
+			     .quiet = ALL_PERMS_MASK,
+			     .hide = ALL_PERMS_MASK };
+
 /**
  * aa_split_fqname - split a fqname into a profile and namespace name
  * @fqname: a full qualified name in namespace profile format (NOT NULL)
@@ -188,6 +192,104 @@ void aa_perm_mask_to_str(char *str, const char *chrs, u32 mask)
 	*str = '\0';
 }
 
+void aa_audit_perm_names(struct audit_buffer *ab, const char **names, u32 mask)
+{
+	const char *fmt = "%s";
+	unsigned int i, perm = 1;
+	bool prev = false;
+
+	for (i = 0; i < 32; perm <<= 1, i++) {
+		if (mask & perm) {
+			audit_log_format(ab, fmt, names[i]);
+			if (!prev) {
+				prev = true;
+				fmt = " %s";
+			}
+		}
+	}
+}
+
+void aa_audit_perm_mask(struct audit_buffer *ab, u32 mask, const char *chrs,
+			u32 chrsmask, const char **names, u32 namesmask)
+{
+	char str[33];
+
+	audit_log_format(ab, "\"");
+	if ((mask & chrsmask) && chrs) {
+		aa_perm_mask_to_str(str, chrs, mask & chrsmask);
+		mask &= ~chrsmask;
+		audit_log_format(ab, "%s", str);
+		if (mask & namesmask)
+			audit_log_format(ab, " ");
+	}
+	if ((mask & namesmask) && names)
+		aa_audit_perm_names(ab, names, mask & namesmask);
+	audit_log_format(ab, "\"");
+}
+
+/**
+ * aa_apply_modes_to_perms - apply namespace and profile flags to perms
+ * @profile: that perms where computed from
+ * @perms: perms to apply mode modifiers to
+ *
+ * TODO: split into profile and ns based flags for when accumulating perms
+ */
+void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)
+{
+	switch (AUDIT_MODE(profile)) {
+	case AUDIT_ALL:
+		perms->audit = ALL_PERMS_MASK;
+		/* fall through */
+	case AUDIT_NOQUIET:
+		perms->quiet = 0;
+		break;
+	case AUDIT_QUIET:
+		perms->audit = 0;
+		/* fall through */
+	case AUDIT_QUIET_DENIED:
+		perms->quiet = ALL_PERMS_MASK;
+		break;
+	}
+
+	if (KILL_MODE(profile))
+		perms->kill = ALL_PERMS_MASK;
+	else if (COMPLAIN_MODE(profile))
+		perms->complain = ALL_PERMS_MASK;
+/*
+ *  TODO:
+ *	else if (PROMPT_MODE(profile))
+ *		perms->prompt = ALL_PERMS_MASK;
+ */
+}
+
+static u32 map_other(u32 x)
+{
+	return ((x & 0x3) << 8) |	/* SETATTR/GETATTR */
+		((x & 0x1c) << 18) |	/* ACCEPT/BIND/LISTEN */
+		((x & 0x60) << 19);	/* SETOPT/GETOPT */
+}
+
+void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,
+		      struct aa_perms *perms)
+{
+	perms->deny = 0;
+	perms->kill = perms->stop = 0;
+	perms->complain = perms->cond = 0;
+	perms->hide = 0;
+	perms->prompt = 0;
+	perms->allow = dfa_user_allow(dfa, state);
+	perms->audit = dfa_user_audit(dfa, state);
+	perms->quiet = dfa_user_quiet(dfa, state);
+
+	/* for v5 perm mapping in the policydb, the other set is used
+	 * to extend the general perm set
+	 */
+	perms->allow |= map_other(dfa_other_allow(dfa, state));
+	perms->audit |= map_other(dfa_other_audit(dfa, state));
+	perms->quiet |= map_other(dfa_other_quiet(dfa, state));
+//	perms->xindex = dfa_user_xindex(dfa, state);
+}
+
 /**
  * aa_policy_init - initialize a policy structure
  * @policy: policy to initialize  (NOT NULL)

commit e53cfe6c7caa79ccdccce53e600dae522acb1c84
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri May 26 15:07:22 2017 -0700

    apparmor: rework perm mapping to a slightly broader set
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 90eb14c9e0cf..90d4631ddafe 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -129,6 +129,65 @@ void aa_info_message(const char *str)
 	printk(KERN_INFO "AppArmor: %s\n", str);
 }
 
+const char aa_file_perm_chrs[] = "xwracd         km l     ";
+const char *aa_file_perm_names[] = {
+	"exec",
+	"write",
+	"read",
+	"append",
+
+	"create",
+	"delete",
+	"open",
+	"rename",
+
+	"setattr",
+	"getattr",
+	"setcred",
+	"getcred",
+
+	"chmod",
+	"chown",
+	"chgrp",
+	"lock",
+
+	"mmap",
+	"mprot",
+	"link",
+	"snapshot",
+
+	"unknown",
+	"unknown",
+	"unknown",
+	"unknown",
+
+	"unknown",
+	"unknown",
+	"unknown",
+	"unknown",
+
+	"stack",
+	"change_onexec",
+	"change_profile",
+	"change_hat",
+};
+
+/**
+ * aa_perm_mask_to_str - convert a perm mask to its short string
+ * @str: character buffer to store string in (at least 10 characters)
+ * @mask: permission mask to convert
+ */
+void aa_perm_mask_to_str(char *str, const char *chrs, u32 mask)
+{
+	unsigned int i, perm = 1;
+
+	for (i = 0; i < 32; perm <<= 1, i++) {
+		if (mask & perm)
+			*str++ = chrs[i];
+	}
+	*str = '\0';
+}
+
 /**
  * aa_policy_init - initialize a policy structure
  * @policy: policy to initialize  (NOT NULL)

commit fc7e0b26b8d26e680bb2f252e9521385e0092e4c
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri May 26 01:57:09 2017 -0700

    apparmor: move permissions into their own file to be more easily shared
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 864b2fa45852..90eb14c9e0cf 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -21,6 +21,7 @@
 #include "include/audit.h"
 #include "include/apparmor.h"
 #include "include/lib.h"
+#include "include/perms.h"
 #include "include/policy.h"
 
 /**

commit b91deb9db12851c18ccb55719f1cd55c2400aca1
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon May 22 02:47:22 2017 -0700

    apparmor: make internal lib fn skipn_spaces available to the rest of apparmor
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 7cd788a9445b..864b2fa45852 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -69,7 +69,7 @@ char *aa_split_fqname(char *fqname, char **ns_name)
  * if all whitespace will return NULL
  */
 
-static const char *skipn_spaces(const char *str, size_t n)
+const char *skipn_spaces(const char *str, size_t n)
 {
 	for (; n && isspace(*str); --n)
 		++str;

commit a7c3e901a46ff54c016d040847eda598a9e3e653
Author: Michal Hocko <mhocko@suse.com>
Date:   Mon May 8 15:57:09 2017 -0700

    mm: introduce kv[mz]alloc helpers
    
    Patch series "kvmalloc", v5.
    
    There are many open coded kmalloc with vmalloc fallback instances in the
    tree.  Most of them are not careful enough or simply do not care about
    the underlying semantic of the kmalloc/page allocator which means that
    a) some vmalloc fallbacks are basically unreachable because the kmalloc
    part will keep retrying until it succeeds b) the page allocator can
    invoke a really disruptive steps like the OOM killer to move forward
    which doesn't sound appropriate when we consider that the vmalloc
    fallback is available.
    
    As it can be seen implementing kvmalloc requires quite an intimate
    knowledge if the page allocator and the memory reclaim internals which
    strongly suggests that a helper should be implemented in the memory
    subsystem proper.
    
    Most callers, I could find, have been converted to use the helper
    instead.  This is patch 6.  There are some more relying on __GFP_REPEAT
    in the networking stack which I have converted as well and Eric Dumazet
    was not opposed [2] to convert them as well.
    
    [1] http://lkml.kernel.org/r/20170130094940.13546-1-mhocko@kernel.org
    [2] http://lkml.kernel.org/r/1485273626.16328.301.camel@edumazet-glaptop3.roam.corp.google.com
    
    This patch (of 9):
    
    Using kmalloc with the vmalloc fallback for larger allocations is a
    common pattern in the kernel code.  Yet we do not have any common helper
    for that and so users have invented their own helpers.  Some of them are
    really creative when doing so.  Let's just add kv[mz]alloc and make sure
    it is implemented properly.  This implementation makes sure to not make
    a large memory pressure for > PAGE_SZE requests (__GFP_NORETRY) and also
    to not warn about allocation failures.  This also rules out the OOM
    killer as the vmalloc is a more approapriate fallback than a disruptive
    user visible action.
    
    This patch also changes some existing users and removes helpers which
    are specific for them.  In some cases this is not possible (e.g.
    ext4_kvmalloc, libcfs_kvzalloc) because those seems to be broken and
    require GFP_NO{FS,IO} context which is not vmalloc compatible in general
    (note that the page table allocation is GFP_KERNEL).  Those need to be
    fixed separately.
    
    While we are at it, document that __vmalloc{_node} about unsupported gfp
    mask because there seems to be a lot of confusion out there.
    kvmalloc_node will warn about GFP_KERNEL incompatible (which are not
    superset) flags to catch new abusers.  Existing ones would have to die
    slowly.
    
    [sfr@canb.auug.org.au: f2fs fixup]
      Link: http://lkml.kernel.org/r/20170320163735.332e64b7@canb.auug.org.au
    Link: http://lkml.kernel.org/r/20170306103032.2540-2-mhocko@kernel.org
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reviewed-by: Andreas Dilger <adilger@dilger.ca> [ext4 part]
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: John Hubbard <jhubbard@nvidia.com>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 32cafc12593e..7cd788a9445b 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -128,36 +128,6 @@ void aa_info_message(const char *str)
 	printk(KERN_INFO "AppArmor: %s\n", str);
 }
 
-/**
- * __aa_kvmalloc - do allocation preferring kmalloc but falling back to vmalloc
- * @size: how many bytes of memory are required
- * @flags: the type of memory to allocate (see kmalloc).
- *
- * Return: allocated buffer or NULL if failed
- *
- * It is possible that policy being loaded from the user is larger than
- * what can be allocated by kmalloc, in those cases fall back to vmalloc.
- */
-void *__aa_kvmalloc(size_t size, gfp_t flags)
-{
-	void *buffer = NULL;
-
-	if (size == 0)
-		return NULL;
-
-	/* do not attempt kmalloc if we need more than 16 pages at once */
-	if (size <= (16*PAGE_SIZE))
-		buffer = kmalloc(size, flags | GFP_KERNEL | __GFP_NORETRY |
-				 __GFP_NOWARN);
-	if (!buffer) {
-		if (flags & __GFP_ZERO)
-			buffer = vzalloc(size);
-		else
-			buffer = vmalloc(size);
-	}
-	return buffer;
-}
-
 /**
  * aa_policy_init - initialize a policy structure
  * @policy: policy to initialize  (NOT NULL)

commit b9c42ac76ea13ab6d07681ff3079b3a242333764
Author: kbuild test robot <fengguang.wu@intel.com>
Date:   Thu Apr 6 06:55:19 2017 -0700

    apparmor: fix boolreturn.cocci warnings
    
    security/apparmor/lib.c:132:9-10: WARNING: return of 0/1 in function 'aa_policy_init' with return type bool
    
     Return statements in functions returning bool should use
     true/false instead of 1/0.
    Generated by: scripts/coccinelle/misc/boolreturn.cocci
    
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 66475bda6f72..32cafc12593e 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -180,13 +180,13 @@ bool aa_policy_init(struct aa_policy *policy, const char *prefix,
 	} else
 		policy->hname = kstrdup(name, gfp);
 	if (!policy->hname)
-		return 0;
+		return false;
 	/* base.name is a substring of fqname */
 	policy->name = basename(policy->hname);
 	INIT_LIST_HEAD(&policy->list);
 	INIT_LIST_HEAD(&policy->profiles);
 
-	return 1;
+	return true;
 }
 
 /**

commit ef88a7ac55fdd3bf6ac3942b83aa29311b45339b
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:43:02 2017 -0800

    apparmor: change aad apparmor_audit_data macro to a fn macro
    
    The aad macro can replace aad strings when it is not intended to. Switch
    to a fn macro so it is only applied when intended.
    
    Also at the same time cleanup audit_data initialization by putting
    common boiler plate behind a macro, and dropping the gfp_t parameter
    which will become useless.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 5d8ef31a60f1..66475bda6f72 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -120,11 +120,9 @@ const char *aa_splitn_fqname(const char *fqname, size_t n, const char **ns_name,
 void aa_info_message(const char *str)
 {
 	if (audit_enabled) {
-		struct common_audit_data sa;
-		struct apparmor_audit_data aad = {0,};
-		sa.type = LSM_AUDIT_DATA_NONE;
-		sa.aad = &aad;
-		aad.info = str;
+		DEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);
+
+		aad(&sa)->info = str;
 		aa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);
 	}
 	printk(KERN_INFO "AppArmor: %s\n", str);

commit 5fd1b95fc9b96629d185f5fe3d9342fcff78eb30
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:32 2017 -0800

    apparmor: update policy_destroy to use new debug asserts
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index bcd598c7ca9d..5d8ef31a60f1 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -197,15 +197,8 @@ bool aa_policy_init(struct aa_policy *policy, const char *prefix,
  */
 void aa_policy_destroy(struct aa_policy *policy)
 {
-	/* still contains profiles -- invalid */
-	if (on_list_rcu(&policy->profiles)) {
-		AA_ERROR("%s: internal error, policy '%s' contains profiles\n",
-			 __func__, policy->name);
-	}
-	if (on_list_rcu(&policy->list)) {
-		AA_ERROR("%s: internal error, policy '%s' still on list\n",
-			 __func__, policy->name);
-	}
+	AA_BUG(on_list_rcu(&policy->profiles));
+	AA_BUG(on_list_rcu(&policy->list));
 
 	/* don't free name as its a subset of hname */
 	kzfree(policy->hname);

commit d102d895713c736fd13e21feaab38b52d8ab32ad
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:31 2017 -0800

    apparmor: pass gfp param into aa_policy_init()
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 91d5766d1c28..bcd598c7ca9d 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -171,20 +171,20 @@ void *__aa_kvmalloc(size_t size, gfp_t flags)
  * Returns: true if policy init successful
  */
 bool aa_policy_init(struct aa_policy *policy, const char *prefix,
-		    const char *name)
+		    const char *name, gfp_t gfp)
 {
 	/* freed by policy_free */
 	if (prefix) {
 		policy->hname = kmalloc(strlen(prefix) + strlen(name) + 3,
-					GFP_KERNEL);
+					gfp);
 		if (policy->hname)
 			sprintf((char *)policy->hname, "%s//%s", prefix, name);
 	} else
-		policy->hname = kstrdup(name, GFP_KERNEL);
+		policy->hname = kstrdup(name, gfp);
 	if (!policy->hname)
 		return 0;
 	/* base.name is a substring of fqname */
-	policy->name = (char *)basename(policy->hname);
+	policy->name = basename(policy->hname);
 	INIT_LIST_HEAD(&policy->list);
 	INIT_LIST_HEAD(&policy->profiles);
 

commit bbe4a7c8733c925b061dcce2d1af8926cefbe539
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:30 2017 -0800

    apparmor: constify policy name and hname
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 02203889c3c8..91d5766d1c28 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -178,7 +178,7 @@ bool aa_policy_init(struct aa_policy *policy, const char *prefix,
 		policy->hname = kmalloc(strlen(prefix) + strlen(name) + 3,
 					GFP_KERNEL);
 		if (policy->hname)
-			sprintf(policy->hname, "%s//%s", prefix, name);
+			sprintf((char *)policy->hname, "%s//%s", prefix, name);
 	} else
 		policy->hname = kstrdup(name, GFP_KERNEL);
 	if (!policy->hname)

commit 6e474e3063eae9767f219d83cf91d8360f63be0c
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:29 2017 -0800

    apparmor: rename hname_tail to basename
    
    Rename to the shorter and more familiar shell cmd name
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index fec78eecce0d..02203889c3c8 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -184,7 +184,7 @@ bool aa_policy_init(struct aa_policy *policy, const char *prefix,
 	if (!policy->hname)
 		return 0;
 	/* base.name is a substring of fqname */
-	policy->name = (char *)hname_tail(policy->hname);
+	policy->name = (char *)basename(policy->hname);
 	INIT_LIST_HEAD(&policy->list);
 	INIT_LIST_HEAD(&policy->profiles);
 

commit 3b0aaf5866bf92a3e47627a02ed5e1be6d7cc110
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:23 2017 -0800

    apparmor: add lib fn to find the "split" for fqnames
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index e29ccdb0309a..fec78eecce0d 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -12,6 +12,7 @@
  * License.
  */
 
+#include <linux/ctype.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/string.h>
@@ -60,6 +61,58 @@ char *aa_split_fqname(char *fqname, char **ns_name)
 	return name;
 }
 
+/**
+ * skipn_spaces - Removes leading whitespace from @str.
+ * @str: The string to be stripped.
+ *
+ * Returns a pointer to the first non-whitespace character in @str.
+ * if all whitespace will return NULL
+ */
+
+static const char *skipn_spaces(const char *str, size_t n)
+{
+	for (; n && isspace(*str); --n)
+		++str;
+	if (n)
+		return (char *)str;
+	return NULL;
+}
+
+const char *aa_splitn_fqname(const char *fqname, size_t n, const char **ns_name,
+			     size_t *ns_len)
+{
+	const char *end = fqname + n;
+	const char *name = skipn_spaces(fqname, n);
+
+	if (!name)
+		return NULL;
+	*ns_name = NULL;
+	*ns_len = 0;
+	if (name[0] == ':') {
+		char *split = strnchr(&name[1], end - &name[1], ':');
+		*ns_name = skipn_spaces(&name[1], end - &name[1]);
+		if (!*ns_name)
+			return NULL;
+		if (split) {
+			*ns_len = split - *ns_name;
+			if (*ns_len == 0)
+				*ns_name = NULL;
+			split++;
+			if (end - split > 1 && strncmp(split, "//", 2) == 0)
+				split += 2;
+			name = skipn_spaces(split, end - split);
+		} else {
+			/* a ns name without a following profile is allowed */
+			name = NULL;
+			*ns_len = end - *ns_name;
+		}
+	}
+	if (name && *name == 0)
+		name = NULL;
+
+	return name;
+}
+
 /**
  * aa_info_message - log a none profile related status message
  * @str: message to log

commit fe6bb31f590c9cd9c8d3ddbdfd4301f72db91718
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:14 2017 -0800

    apparmor: split out shared policy_XXX fns to lib
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 6028ffc008ae..e29ccdb0309a 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -20,6 +20,7 @@
 #include "include/audit.h"
 #include "include/apparmor.h"
 #include "include/lib.h"
+#include "include/policy.h"
 
 /**
  * aa_split_fqname - split a fqname into a profile and namespace name
@@ -105,3 +106,54 @@ void *__aa_kvmalloc(size_t size, gfp_t flags)
 	}
 	return buffer;
 }
+
+/**
+ * aa_policy_init - initialize a policy structure
+ * @policy: policy to initialize  (NOT NULL)
+ * @prefix: prefix name if any is required.  (MAYBE NULL)
+ * @name: name of the policy, init will make a copy of it  (NOT NULL)
+ *
+ * Note: this fn creates a copy of strings passed in
+ *
+ * Returns: true if policy init successful
+ */
+bool aa_policy_init(struct aa_policy *policy, const char *prefix,
+		    const char *name)
+{
+	/* freed by policy_free */
+	if (prefix) {
+		policy->hname = kmalloc(strlen(prefix) + strlen(name) + 3,
+					GFP_KERNEL);
+		if (policy->hname)
+			sprintf(policy->hname, "%s//%s", prefix, name);
+	} else
+		policy->hname = kstrdup(name, GFP_KERNEL);
+	if (!policy->hname)
+		return 0;
+	/* base.name is a substring of fqname */
+	policy->name = (char *)hname_tail(policy->hname);
+	INIT_LIST_HEAD(&policy->list);
+	INIT_LIST_HEAD(&policy->profiles);
+
+	return 1;
+}
+
+/**
+ * aa_policy_destroy - free the elements referenced by @policy
+ * @policy: policy that is to have its elements freed  (NOT NULL)
+ */
+void aa_policy_destroy(struct aa_policy *policy)
+{
+	/* still contains profiles -- invalid */
+	if (on_list_rcu(&policy->profiles)) {
+		AA_ERROR("%s: internal error, policy '%s' contains profiles\n",
+			 __func__, policy->name);
+	}
+	if (on_list_rcu(&policy->list)) {
+		AA_ERROR("%s: internal error, policy '%s' still on list\n",
+			 __func__, policy->name);
+	}
+
+	/* don't free name as its a subset of hname */
+	kzfree(policy->hname);
+}

commit 12557dcba21b015f470076da6947e68bc70fff64
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:13 2017 -0800

    apparmor: move lib definitions into separate lib include
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 2ef422a25474..6028ffc008ae 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -19,7 +19,7 @@
 
 #include "include/audit.h"
 #include "include/apparmor.h"
-
+#include "include/lib.h"
 
 /**
  * aa_split_fqname - split a fqname into a profile and namespace name

commit a7f6c1b63b863d29f126d9b163ad5b40008544b2
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Mon Nov 14 20:11:52 2016 +0900

    AppArmor: Use GFP_KERNEL for __aa_kvmalloc().
    
    Calling kmalloc(GFP_NOIO) with order == PAGE_ALLOC_COSTLY_ORDER is not
    recommended because it might fall into infinite retry loop without
    invoking the OOM killer.
    
    Since aa_dfa_unpack() is the only caller of kvzalloc() and
    aa_dfa_unpack() which is calling kvzalloc() via unpack_table() is
    doing kzalloc(GFP_KERNEL), it is safe to use GFP_KERNEL from
    __aa_kvmalloc().
    
    Since aa_simple_write_to_buffer() is the only caller of kvmalloc()
    and aa_simple_write_to_buffer() is calling copy_from_user() which
    is GFP_KERNEL context (see memdup_user_nul()), it is safe to use
    GFP_KERNEL from __aa_kvmalloc().
    
    Therefore, replace GFP_NOIO with GFP_KERNEL. Also, since we have
    vmalloc() fallback, add __GFP_NORETRY so that we don't invoke the OOM
    killer by kmalloc(GFP_KERNEL) with order == PAGE_ALLOC_COSTLY_ORDER.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index c1827e068454..2ef422a25474 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -95,7 +95,8 @@ void *__aa_kvmalloc(size_t size, gfp_t flags)
 
 	/* do not attempt kmalloc if we need more than 16 pages at once */
 	if (size <= (16*PAGE_SIZE))
-		buffer = kmalloc(size, flags | GFP_NOIO | __GFP_NOWARN);
+		buffer = kmalloc(size, flags | GFP_KERNEL | __GFP_NORETRY |
+				 __GFP_NOWARN);
 	if (!buffer) {
 		if (flags & __GFP_ZERO)
 			buffer = vzalloc(size);

commit 39f1f78d53b9bcbca91967380c5f0f2305a5c55f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue May 6 14:02:53 2014 -0400

    nick kvfree() from apparmor
    
    too many places open-code it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 69689922c491..c1827e068454 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -104,17 +104,3 @@ void *__aa_kvmalloc(size_t size, gfp_t flags)
 	}
 	return buffer;
 }
-
-/**
- * kvfree - free an allocation do by kvmalloc
- * @buffer: buffer to free (MAYBE_NULL)
- *
- * Free a buffer allocated by kvmalloc
- */
-void kvfree(void *buffer)
-{
-	if (is_vmalloc_addr(buffer))
-		vfree(buffer);
-	else
-		kfree(buffer);
-}

commit dfe4ac28be73833556756dca6771d4274a7f1157
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Mon Jun 17 21:25:08 2013 +0900

    apparmor: remove minimum size check for vmalloc()
    
    This is a follow-up to commit b5b3ee6c "apparmor: no need to delay vfree()".
    
    Since vmalloc() will do "size = PAGE_ALIGN(size);",
    we don't need to check for "size >= sizeof(struct work_struct)".
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index fcfe0233574c..69689922c491 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -97,11 +97,6 @@ void *__aa_kvmalloc(size_t size, gfp_t flags)
 	if (size <= (16*PAGE_SIZE))
 		buffer = kmalloc(size, flags | GFP_NOIO | __GFP_NOWARN);
 	if (!buffer) {
-		/* see kvfree for why size must be at least work_struct size
-		 * when allocated via vmalloc
-		 */
-		if (size < sizeof(struct work_struct))
-			size = sizeof(struct work_struct);
 		if (flags & __GFP_ZERO)
 			buffer = vzalloc(size);
 		else

commit b5b3ee6c9cca8b6e1aa8c757e570f08f802c5573
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon May 6 03:10:35 2013 +0100

    apparmor: no need to delay vfree()
    
    vfree() can be called from interrupt contexts now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index d40bc592180d..fcfe0233574c 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -110,19 +110,6 @@ void *__aa_kvmalloc(size_t size, gfp_t flags)
 	return buffer;
 }
 
-/**
- * do_vfree - workqueue routine for freeing vmalloced memory
- * @work: data to be freed
- *
- * The work_struct is overlaid to the data being freed, as at the point
- * the work is scheduled the data is no longer valid, be its freeing
- * needs to be delayed until safe.
- */
-static void do_vfree(struct work_struct *work)
-{
-	vfree(work);
-}
-
 /**
  * kvfree - free an allocation do by kvmalloc
  * @buffer: buffer to free (MAYBE_NULL)
@@ -131,13 +118,8 @@ static void do_vfree(struct work_struct *work)
  */
 void kvfree(void *buffer)
 {
-	if (is_vmalloc_addr(buffer)) {
-		/* Data is no longer valid so just use the allocated space
-		 * as the work_struct
-		 */
-		struct work_struct *work = (struct work_struct *) buffer;
-		INIT_WORK(work, do_vfree);
-		schedule_work(work);
-	} else
+	if (is_vmalloc_addr(buffer))
+		vfree(buffer);
+	else
 		kfree(buffer);
 }

commit 2654bfbc2bd0e1e64f0b257c21da23f6cec32c6c
Author: John Johansen <john.johansen@canonical.com>
Date:   Wed Feb 27 03:45:05 2013 -0800

    apparmor: fix fully qualified name parsing
    
    currently apparmor name parsing is only correctly handling
    :<NS>:<profile>
    
    but
    :<NS>://<profile>
    
    is also a valid form and what is exported to userspace.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index d6e1f2148398..d40bc592180d 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -45,8 +45,10 @@ char *aa_split_fqname(char *fqname, char **ns_name)
 		*ns_name = skip_spaces(&name[1]);
 		if (split) {
 			/* overwrite ':' with \0 */
-			*split = 0;
-			name = skip_spaces(split + 1);
+			*split++ = 0;
+			if (strncmp(split, "//", 2) == 0)
+				split += 2;
+			name = skip_spaces(split);
 		} else
 			/* a ns name without a following profile is allowed */
 			name = NULL;

commit 0ca554b9fca425eb58325a36290deef698cef34b
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Feb 18 16:04:34 2013 -0800

    apparmor: add kvzalloc to handle zeroing for kvmalloc
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Steve Beattie <sbeattie@ubuntu.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 7430298116d6..d6e1f2148398 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -75,15 +75,16 @@ void aa_info_message(const char *str)
 }
 
 /**
- * kvmalloc - do allocation preferring kmalloc but falling back to vmalloc
- * @size: size of allocation
+ * __aa_kvmalloc - do allocation preferring kmalloc but falling back to vmalloc
+ * @size: how many bytes of memory are required
+ * @flags: the type of memory to allocate (see kmalloc).
  *
  * Return: allocated buffer or NULL if failed
  *
  * It is possible that policy being loaded from the user is larger than
  * what can be allocated by kmalloc, in those cases fall back to vmalloc.
  */
-void *kvmalloc(size_t size)
+void *__aa_kvmalloc(size_t size, gfp_t flags)
 {
 	void *buffer = NULL;
 
@@ -92,14 +93,17 @@ void *kvmalloc(size_t size)
 
 	/* do not attempt kmalloc if we need more than 16 pages at once */
 	if (size <= (16*PAGE_SIZE))
-		buffer = kmalloc(size, GFP_NOIO | __GFP_NOWARN);
+		buffer = kmalloc(size, flags | GFP_NOIO | __GFP_NOWARN);
 	if (!buffer) {
 		/* see kvfree for why size must be at least work_struct size
 		 * when allocated via vmalloc
 		 */
 		if (size < sizeof(struct work_struct))
 			size = sizeof(struct work_struct);
-		buffer = vmalloc(size);
+		if (flags & __GFP_ZERO)
+			buffer = vzalloc(size);
+		else
+			buffer = vmalloc(size);
 	}
 	return buffer;
 }

commit 50c205f5e5c2e2af002fd4ef537ded79b90b1b56
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 4 15:01:43 2012 -0400

    LSM: do not initialize common_audit_data to 0
    
    It isn't needed.  If you don't set the type of the data associated with
    that type it is a pretty obvious programming bug.  So why waste the cycles?
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index b11a2652f541..7430298116d6 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -66,7 +66,7 @@ void aa_info_message(const char *str)
 	if (audit_enabled) {
 		struct common_audit_data sa;
 		struct apparmor_audit_data aad = {0,};
-		COMMON_AUDIT_DATA_INIT(&sa, LSM_AUDIT_DATA_NONE);
+		sa.type = LSM_AUDIT_DATA_NONE;
 		sa.aad = &aad;
 		aad.info = str;
 		aa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);

commit bd5e50f9c1c71daac273fa586424f07205f6b13b
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 4 15:01:42 2012 -0400

    LSM: remove the COMMON_AUDIT_DATA_INIT type expansion
    
    Just open code it so grep on the source code works better.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index e75829ba0ff9..b11a2652f541 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -66,7 +66,7 @@ void aa_info_message(const char *str)
 	if (audit_enabled) {
 		struct common_audit_data sa;
 		struct apparmor_audit_data aad = {0,};
-		COMMON_AUDIT_DATA_INIT(&sa, NONE);
+		COMMON_AUDIT_DATA_INIT(&sa, LSM_AUDIT_DATA_NONE);
 		sa.aad = &aad;
 		aad.info = str;
 		aa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);

commit 3b3b0e4fc15efa507b902d90cea39e496a523c3b
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Apr 3 09:37:02 2012 -0700

    LSM: shrink sizeof LSM specific portion of common_audit_data
    
    Linus found that the gigantic size of the common audit data caused a big
    perf hit on something as simple as running stat() in a loop.  This patch
    requires LSMs to declare the LSM specific portion separately rather than
    doing it in a union.  Thus each LSM can be responsible for shrinking their
    portion and don't have to pay a penalty just because other LSMs have a
    bigger space requirement.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 9516948041ad..e75829ba0ff9 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -65,8 +65,10 @@ void aa_info_message(const char *str)
 {
 	if (audit_enabled) {
 		struct common_audit_data sa;
+		struct apparmor_audit_data aad = {0,};
 		COMMON_AUDIT_DATA_INIT(&sa, NONE);
-		sa.aad.info = str;
+		sa.aad = &aad;
+		aad.info = str;
 		aa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);
 	}
 	printk(KERN_INFO "AppArmor: %s\n", str);

commit 32c3df631bc018109136a8f4f941ad591e76a0aa
Author: James Morris <jmorris@namei.org>
Date:   Mon Aug 29 11:15:25 2011 +1000

    apparmor: sparse fix: add apparmor.h to lib.c
    
    Fix the following sparse warnings:
    security/apparmor/lib.c:37:6: warning: symbol 'aa_split_fqname' was not declared. Should it be static?
    security/apparmor/lib.c:63:6: warning: symbol 'aa_info_message' was not declared. Should it be static?
    security/apparmor/lib.c:83:6: warning: symbol 'kvmalloc' was not declared. Should it be static?
    security/apparmor/lib.c:123:6: warning: symbol 'kvfree' was not declared. Should it be static?
    
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index b82e383beb77..9516948041ad 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -18,6 +18,7 @@
 #include <linux/vmalloc.h>
 
 #include "include/audit.h"
+#include "include/apparmor.h"
 
 
 /**

commit b7f080cfe223b3b7424872639d153695615a9255
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Jun 16 11:01:34 2011 +0000

    net: remove mm.h inclusion from netdevice.h
    
    Remove linux/mm.h inclusion from netdevice.h -- it's unused (I've checked manually).
    
    To prevent mm.h inclusion via other channels also extract "enum dma_data_direction"
    definition into separate header. This tiny piece is what gluing netdevice.h with mm.h
    via "netdevice.h => dmaengine.h => dma-mapping.h => scatterlist.h => mm.h".
    Removal of mm.h from scatterlist.h was tried and was found not feasible
    on most archs, so the link was cutoff earlier.
    
    Hope people are OK with tiny include file.
    
    Note, that mm_types.h is still dragged in, but it is a separate story.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 506d2baf6147..b82e383beb77 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -12,6 +12,7 @@
  * License.
  */
 
+#include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/vmalloc.h>

commit 04ccd53f09741c4bc54ab36db000bc1383e4812e
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri Aug 27 18:33:28 2010 -0700

    AppArmor: Fix splitting an fqname into separate namespace and profile names
    
    As per Dan Carpenter <error27@gmail.com>
      If we have a ns name without a following profile then in the original
      code it did "*ns_name = &name[1];".  "name" is NULL so "*ns_name" is
      0x1.  That isn't useful and could cause an oops when this function is
      called from aa_remove_profiles().
    
    Beyond this the assignment of the namespace name was wrong in the case
    where the profile name was provided as it was being set to &name[1]
    after name  = skip_spaces(split + 1);
    
    Move the ns_name assignment before updating name for the split and
    also add skip_spaces, making the interface more robust.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index 6e85cdb4303f..506d2baf6147 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -40,6 +40,7 @@ char *aa_split_fqname(char *fqname, char **ns_name)
 	*ns_name = NULL;
 	if (name[0] == ':') {
 		char *split = strchr(&name[1], ':');
+		*ns_name = skip_spaces(&name[1]);
 		if (split) {
 			/* overwrite ':' with \0 */
 			*split = 0;
@@ -47,7 +48,6 @@ char *aa_split_fqname(char *fqname, char **ns_name)
 		} else
 			/* a ns name without a following profile is allowed */
 			name = NULL;
-		*ns_name = &name[1];
 	}
 	if (name && *name == 0)
 		name = NULL;

commit cdff264264254e0fabc8107a33f3bb75a95e981f
Author: John Johansen <john.johansen@canonical.com>
Date:   Thu Jul 29 14:47:57 2010 -0700

    AppArmor: misc. base functions and defines
    
    Miscellaneous functions and defines needed by AppArmor, including
    the base path resolution routines.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
new file mode 100644
index 000000000000..6e85cdb4303f
--- /dev/null
+++ b/security/apparmor/lib.c
@@ -0,0 +1,133 @@
+/*
+ * AppArmor security module
+ *
+ * This file contains basic common functions used in AppArmor
+ *
+ * Copyright (C) 1998-2008 Novell/SUSE
+ * Copyright 2009-2010 Canonical Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ */
+
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+
+#include "include/audit.h"
+
+
+/**
+ * aa_split_fqname - split a fqname into a profile and namespace name
+ * @fqname: a full qualified name in namespace profile format (NOT NULL)
+ * @ns_name: pointer to portion of the string containing the ns name (NOT NULL)
+ *
+ * Returns: profile name or NULL if one is not specified
+ *
+ * Split a namespace name from a profile name (see policy.c for naming
+ * description).  If a portion of the name is missing it returns NULL for
+ * that portion.
+ *
+ * NOTE: may modify the @fqname string.  The pointers returned point
+ *       into the @fqname string.
+ */
+char *aa_split_fqname(char *fqname, char **ns_name)
+{
+	char *name = strim(fqname);
+
+	*ns_name = NULL;
+	if (name[0] == ':') {
+		char *split = strchr(&name[1], ':');
+		if (split) {
+			/* overwrite ':' with \0 */
+			*split = 0;
+			name = skip_spaces(split + 1);
+		} else
+			/* a ns name without a following profile is allowed */
+			name = NULL;
+		*ns_name = &name[1];
+	}
+	if (name && *name == 0)
+		name = NULL;
+
+	return name;
+}
+
+/**
+ * aa_info_message - log a none profile related status message
+ * @str: message to log
+ */
+void aa_info_message(const char *str)
+{
+	if (audit_enabled) {
+		struct common_audit_data sa;
+		COMMON_AUDIT_DATA_INIT(&sa, NONE);
+		sa.aad.info = str;
+		aa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);
+	}
+	printk(KERN_INFO "AppArmor: %s\n", str);
+}
+
+/**
+ * kvmalloc - do allocation preferring kmalloc but falling back to vmalloc
+ * @size: size of allocation
+ *
+ * Return: allocated buffer or NULL if failed
+ *
+ * It is possible that policy being loaded from the user is larger than
+ * what can be allocated by kmalloc, in those cases fall back to vmalloc.
+ */
+void *kvmalloc(size_t size)
+{
+	void *buffer = NULL;
+
+	if (size == 0)
+		return NULL;
+
+	/* do not attempt kmalloc if we need more than 16 pages at once */
+	if (size <= (16*PAGE_SIZE))
+		buffer = kmalloc(size, GFP_NOIO | __GFP_NOWARN);
+	if (!buffer) {
+		/* see kvfree for why size must be at least work_struct size
+		 * when allocated via vmalloc
+		 */
+		if (size < sizeof(struct work_struct))
+			size = sizeof(struct work_struct);
+		buffer = vmalloc(size);
+	}
+	return buffer;
+}
+
+/**
+ * do_vfree - workqueue routine for freeing vmalloced memory
+ * @work: data to be freed
+ *
+ * The work_struct is overlaid to the data being freed, as at the point
+ * the work is scheduled the data is no longer valid, be its freeing
+ * needs to be delayed until safe.
+ */
+static void do_vfree(struct work_struct *work)
+{
+	vfree(work);
+}
+
+/**
+ * kvfree - free an allocation do by kvmalloc
+ * @buffer: buffer to free (MAYBE_NULL)
+ *
+ * Free a buffer allocated by kvmalloc
+ */
+void kvfree(void *buffer)
+{
+	if (is_vmalloc_addr(buffer)) {
+		/* Data is no longer valid so just use the allocated space
+		 * as the work_struct
+		 */
+		struct work_struct *work = (struct work_struct *) buffer;
+		INIT_WORK(work, do_vfree);
+		schedule_work(work);
+	} else
+		kfree(buffer);
+}
