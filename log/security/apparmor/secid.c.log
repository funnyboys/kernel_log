commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/apparmor/secid.c b/security/apparmor/secid.c
index 05373d9a3d6a..ce545f99259e 100644
--- a/security/apparmor/secid.c
+++ b/security/apparmor/secid.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * AppArmor security module
  *
@@ -5,12 +6,6 @@
  *
  * Copyright 2009-2017 Canonical Ltd.
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation, version 2 of the
- * License.
- *
- *
  * AppArmor allocates a unique secid for every label used. If a label
  * is replaced it receives the secid of the label it is replacing.
  */

commit d81f50bd34646d8373b989e55180c0fc9af94e0b
Merge: c2aa1a444cab 566f52ece7bd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 2 10:04:26 2018 -0700

    Merge tag 'apparmor-pr-2018-11-01' of git://git.kernel.org/pub/scm/linux/kernel/git/jj/linux-apparmor
    
    Pull apparmor updates from John Johansen:
     "Features/Improvements:
       - replace spin_is_locked() with lockdep
       - add base support for secmark labeling and matching
    
      Cleanups:
       - clean an indentation issue, remove extraneous space
       - remove no-op permission check in policy_unpack
       - fix checkpatch missing spaces error in Parse secmark policy
       - fix network performance issue in aa_label_sk_perm
    
      Bug fixes:
       - add #ifdef checks for secmark filtering
       - fix an error code in __aa_create_ns()
       - don't try to replace stale label in ptrace checks
       - fix failure to audit context info in build_change_hat
       - check buffer bounds when mapping permissions mask
       - fully initialize aa_perms struct when answering userspace query
       - fix uninitialized value in aa_split_fqname"
    
    * tag 'apparmor-pr-2018-11-01' of git://git.kernel.org/pub/scm/linux/kernel/git/jj/linux-apparmor:
      apparmor: clean an indentation issue, remove extraneous space
      apparmor: fix checkpatch error in Parse secmark policy
      apparmor: add #ifdef checks for secmark filtering
      apparmor: Fix uninitialized value in aa_split_fqname
      apparmor: don't try to replace stale label in ptraceme check
      apparmor: Replace spin_is_locked() with lockdep
      apparmor: Allow filtering based on secmark policy
      apparmor: Parse secmark policy
      apparmor: Add a wildcard secid
      apparmor: don't try to replace stale label in ptrace access check
      apparmor: Fix network performance issue in aa_label_sk_perm

commit 617a629c08bfffb05249131079d9a38322902e5b
Author: Matthew Garrett <mjg59@google.com>
Date:   Thu May 24 13:27:45 2018 -0700

    apparmor: Add a wildcard secid
    
    Reserve a secid value that we can use as a wildcard, allowing us to
    define policy that's expected to match against all secids.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/secid.c b/security/apparmor/secid.c
index f2f22d00db18..8c951c493beb 100644
--- a/security/apparmor/secid.c
+++ b/security/apparmor/secid.c
@@ -32,8 +32,7 @@
  * secids - do not pin labels with a refcount. They rely on the label
  * properly updating/freeing them
  */
-
-#define AA_FIRST_SECID 1
+#define AA_FIRST_SECID 2
 
 static DEFINE_IDR(aa_secids);
 static DEFINE_SPINLOCK(secid_lock);

commit edf4e7b7b9104b58fddfcd073bd7dcc1585d5326
Author: John Johansen <john.johansen@canonical.com>
Date:   Sat Sep 1 01:57:52 2018 -0700

    apparmor: fix bad debug check in apparmor_secid_to_secctx()
    
    apparmor_secid_to_secctx() has a bad debug statement tripping on a
    condition handle by the code.  When kconfig SECURITY_APPARMOR_DEBUG is
    enabled the debug WARN_ON will trip when **secdata is NULL resulting
    in the following trace.
    
    ------------[ cut here ]------------
    AppArmor WARN apparmor_secid_to_secctx: ((!secdata)):
    WARNING: CPU: 0 PID: 14826 at security/apparmor/secid.c:82 apparmor_secid_to_secctx+0x2b5/0x2f0 security/apparmor/secid.c:82
    Kernel panic - not syncing: panic_on_warn set ...
    
    CPU: 0 PID: 14826 Comm: syz-executor1 Not tainted 4.19.0-rc1+ #193
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x1c9/0x2b4 lib/dump_stack.c:113
     panic+0x238/0x4e7 kernel/panic.c:184
     __warn.cold.8+0x163/0x1ba kernel/panic.c:536
     report_bug+0x252/0x2d0 lib/bug.c:186
     fixup_bug arch/x86/kernel/traps.c:178 [inline]
     do_error_trap+0x1fc/0x4d0 arch/x86/kernel/traps.c:296
     do_invalid_op+0x1b/0x20 arch/x86/kernel/traps.c:316
     invalid_op+0x14/0x20 arch/x86/entry/entry_64.S:993
    RIP: 0010:apparmor_secid_to_secctx+0x2b5/0x2f0 security/apparmor/secid.c:82
    Code: c7 c7 40 66 58 87 e8 6a 6d 0f fe 0f 0b e9 6c fe ff ff e8 3e aa 44 fe 48 c7 c6 80 67 58 87 48 c7 c7 a0 65 58 87 e8 4b 6d 0f fe <0f> 0b e9 3f fe ff ff 48 89 df e8 fc a7 83 fe e9 ed fe ff ff bb f4
    RSP: 0018:ffff8801ba1bed10 EFLAGS: 00010286
    RAX: 0000000000000000 RBX: ffff8801ba1beed0 RCX: ffffc9000227e000
    RDX: 0000000000018482 RSI: ffffffff8163ac01 RDI: 0000000000000001
    RBP: ffff8801ba1bed30 R08: ffff8801b80ec080 R09: ffffed003b603eca
    R10: ffffed003b603eca R11: ffff8801db01f657 R12: 0000000000000001
    R13: 0000000000000000 R14: 0000000000000000 R15: ffff8801ba1beed0
     security_secid_to_secctx+0x63/0xc0 security/security.c:1314
     ctnetlink_secctx_size net/netfilter/nf_conntrack_netlink.c:621 [inline]
     ctnetlink_nlmsg_size net/netfilter/nf_conntrack_netlink.c:659 [inline]
     ctnetlink_conntrack_event+0x303/0x1470 net/netfilter/nf_conntrack_netlink.c:706
     nf_conntrack_eventmask_report+0x55f/0x930 net/netfilter/nf_conntrack_ecache.c:151
     nf_conntrack_event_report include/net/netfilter/nf_conntrack_ecache.h:112 [inline]
     nf_ct_delete+0x33c/0x5d0 net/netfilter/nf_conntrack_core.c:601
     nf_ct_iterate_cleanup+0x48c/0x5e0 net/netfilter/nf_conntrack_core.c:1892
     nf_ct_iterate_cleanup_net+0x23c/0x2d0 net/netfilter/nf_conntrack_core.c:1974
     ctnetlink_flush_conntrack net/netfilter/nf_conntrack_netlink.c:1226 [inline]
     ctnetlink_del_conntrack+0x66c/0x850 net/netfilter/nf_conntrack_netlink.c:1258
     nfnetlink_rcv_msg+0xd88/0x1070 net/netfilter/nfnetlink.c:228
     netlink_rcv_skb+0x172/0x440 net/netlink/af_netlink.c:2454
     nfnetlink_rcv+0x1c0/0x4d0 net/netfilter/nfnetlink.c:560
     netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]
     netlink_unicast+0x5a0/0x760 net/netlink/af_netlink.c:1343
     netlink_sendmsg+0xa18/0xfc0 net/netlink/af_netlink.c:1908
     sock_sendmsg_nosec net/socket.c:621 [inline]
     sock_sendmsg+0xd5/0x120 net/socket.c:631
     ___sys_sendmsg+0x7fd/0x930 net/socket.c:2114
     __sys_sendmsg+0x11d/0x290 net/socket.c:2152
     __do_sys_sendmsg net/socket.c:2161 [inline]
     __se_sys_sendmsg net/socket.c:2159 [inline]
     __x64_sys_sendmsg+0x78/0xb0 net/socket.c:2159
     do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x457089
    Code: fd b4 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 cb b4 fb ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007f7bc6e03c78 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
    RAX: ffffffffffffffda RBX: 00007f7bc6e046d4 RCX: 0000000000457089
    RDX: 0000000000000000 RSI: 0000000020d65000 RDI: 0000000000000003
    RBP: 00000000009300a0 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00000000ffffffff
    R13: 00000000004d4588 R14: 00000000004c8d5c R15: 0000000000000000
    Dumping ftrace buffer:
       (ftrace buffer empty)
    Kernel Offset: disabled
    Rebooting in 86400 seconds..
    
    CC: <stable@vger.kernel.org> #4.18
    Fixes: c092921219d2 ("apparmor: add support for mapping secids and using secctxes")
    Reported-by: syzbot+21016130b0580a9de3b5@syzkaller.appspotmail.com
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/secid.c b/security/apparmor/secid.c
index f2f22d00db18..4ccec1bcf6f5 100644
--- a/security/apparmor/secid.c
+++ b/security/apparmor/secid.c
@@ -79,7 +79,6 @@ int apparmor_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 	struct aa_label *label = aa_secid_to_label(secid);
 	int len;
 
-	AA_BUG(!secdata);
 	AA_BUG(!seclen);
 
 	if (!label)

commit a4c3f89c9b5a9fab5a8e4ea05399acd6e23072df
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jun 4 19:44:59 2018 -0700

    apparmor: fixup secid map conversion to using IDR
    
    The IDR conversion did not handle an error case for when allocating a
    mapping fails, and it did not ensure that mappings did not allocate or
    use a 0 value, which is used as an invalid secid. Which is used when a
    mapping fails.
    
    Fixes: 3ae7eb49a2be ("apparmor: Use an IDR to allocate apparmor secids")
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/secid.c b/security/apparmor/secid.c
index 3ad94b2ffbb2..f2f22d00db18 100644
--- a/security/apparmor/secid.c
+++ b/security/apparmor/secid.c
@@ -33,6 +33,8 @@
  * properly updating/freeing them
  */
 
+#define AA_FIRST_SECID 1
+
 static DEFINE_IDR(aa_secids);
 static DEFINE_SPINLOCK(secid_lock);
 
@@ -120,20 +122,31 @@ void apparmor_release_secctx(char *secdata, u32 seclen)
 
 /**
  * aa_alloc_secid - allocate a new secid for a profile
+ * @label: the label to allocate a secid for
+ * @gfp: memory allocation flags
+ *
+ * Returns: 0 with @label->secid initialized
+ *          <0 returns error with @label->secid set to AA_SECID_INVALID
  */
-u32 aa_alloc_secid(struct aa_label *label, gfp_t gfp)
+int aa_alloc_secid(struct aa_label *label, gfp_t gfp)
 {
 	unsigned long flags;
-	u32 secid;
+	int ret;
 
 	idr_preload(gfp);
 	spin_lock_irqsave(&secid_lock, flags);
-	secid = idr_alloc(&aa_secids, label, 0, 0, GFP_ATOMIC);
-	/* XXX: Can return -ENOMEM */
+	ret = idr_alloc(&aa_secids, label, AA_FIRST_SECID, 0, GFP_ATOMIC);
 	spin_unlock_irqrestore(&secid_lock, flags);
 	idr_preload_end();
 
-	return secid;
+	if (ret < 0) {
+		label->secid = AA_SECID_INVALID;
+		return ret;
+	}
+
+	AA_BUG(ret == AA_SECID_INVALID);
+	label->secid = ret;
+	return 0;
 }
 
 /**
@@ -148,3 +161,8 @@ void aa_free_secid(u32 secid)
 	idr_remove(&aa_secids, secid);
 	spin_unlock_irqrestore(&secid_lock, flags);
 }
+
+void aa_secids_init(void)
+{
+	idr_init_base(&aa_secids, AA_FIRST_SECID);
+}

commit 99cc45e486786c7215a7e39824c3bbaf7cf2fc08
Author: Matthew Wilcox <willy@infradead.org>
Date:   Tue May 22 02:32:59 2018 -0700

    apparmor: Use an IDR to allocate apparmor secids
    
    Replace the custom usage of the radix tree to store a list of free IDs
    with the IDR.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/secid.c b/security/apparmor/secid.c
index c2f0c1571156..3ad94b2ffbb2 100644
--- a/security/apparmor/secid.c
+++ b/security/apparmor/secid.c
@@ -18,6 +18,7 @@
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/gfp.h>
+#include <linux/idr.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 
@@ -30,18 +31,10 @@
 /*
  * secids - do not pin labels with a refcount. They rely on the label
  * properly updating/freeing them
- *
- * A singly linked free list is used to track secids that have been
- * freed and reuse them before allocating new ones
  */
 
-#define FREE_LIST_HEAD 1
-
-static RADIX_TREE(aa_secids_map, GFP_ATOMIC);
+static DEFINE_IDR(aa_secids);
 static DEFINE_SPINLOCK(secid_lock);
-static u32 alloced_secid = FREE_LIST_HEAD;
-static u32 free_list = FREE_LIST_HEAD;
-static unsigned long free_count;
 
 /*
  * TODO: allow policy to reserve a secid range?
@@ -49,65 +42,6 @@ static unsigned long free_count;
  * TODO: use secid_update in label replace
  */
 
-#define SECID_MAX U32_MAX
-
-/* TODO: mark free list as exceptional */
-static void *to_ptr(u32 secid)
-{
-	return (void *)
-		((((unsigned long) secid) << RADIX_TREE_EXCEPTIONAL_SHIFT));
-}
-
-static u32 to_secid(void *ptr)
-{
-	return (u32) (((unsigned long) ptr) >> RADIX_TREE_EXCEPTIONAL_SHIFT);
-}
-
-
-/* TODO: tag free_list entries to mark them as different */
-static u32 __pop(struct aa_label *label)
-{
-	u32 secid = free_list;
-	void __rcu **slot;
-	void *entry;
-
-	if (free_list == FREE_LIST_HEAD)
-		return AA_SECID_INVALID;
-
-	slot = radix_tree_lookup_slot(&aa_secids_map, secid);
-	AA_BUG(!slot);
-	entry = radix_tree_deref_slot_protected(slot, &secid_lock);
-	free_list = to_secid(entry);
-	radix_tree_replace_slot(&aa_secids_map, slot, label);
-	free_count--;
-
-	return secid;
-}
-
-static void __push(u32 secid)
-{
-	void __rcu **slot;
-
-	slot = radix_tree_lookup_slot(&aa_secids_map, secid);
-	AA_BUG(!slot);
-	radix_tree_replace_slot(&aa_secids_map, slot, to_ptr(free_list));
-	free_list = secid;
-	free_count++;
-}
-
-static struct aa_label * __secid_update(u32 secid, struct aa_label *label)
-{
-	struct aa_label *old;
-	void __rcu **slot;
-
-	slot = radix_tree_lookup_slot(&aa_secids_map, secid);
-	AA_BUG(!slot);
-	old = radix_tree_deref_slot_protected(slot, &secid_lock);
-	radix_tree_replace_slot(&aa_secids_map, slot, label);
-
-	return old;
-}
-
 /**
  * aa_secid_update - update a secid mapping to a new label
  * @secid: secid to update
@@ -115,11 +49,10 @@ static struct aa_label * __secid_update(u32 secid, struct aa_label *label)
  */
 void aa_secid_update(u32 secid, struct aa_label *label)
 {
-	struct aa_label *old;
 	unsigned long flags;
 
 	spin_lock_irqsave(&secid_lock, flags);
-	old = __secid_update(secid, label);
+	idr_replace(&aa_secids, label, secid);
 	spin_unlock_irqrestore(&secid_lock, flags);
 }
 
@@ -132,7 +65,7 @@ struct aa_label *aa_secid_to_label(u32 secid)
 	struct aa_label *label;
 
 	rcu_read_lock();
-	label = radix_tree_lookup(&aa_secids_map, secid);
+	label = idr_find(&aa_secids, secid);
 	rcu_read_unlock();
 
 	return label;
@@ -167,7 +100,6 @@ int apparmor_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 	return 0;
 }
 
-
 int apparmor_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
 {
 	struct aa_label *label;
@@ -186,7 +118,6 @@ void apparmor_release_secctx(char *secdata, u32 seclen)
 	kfree(secdata);
 }
 
-
 /**
  * aa_alloc_secid - allocate a new secid for a profile
  */
@@ -195,35 +126,12 @@ u32 aa_alloc_secid(struct aa_label *label, gfp_t gfp)
 	unsigned long flags;
 	u32 secid;
 
-	/* racey, but at worst causes new allocation instead of reuse */
-	if (free_list == FREE_LIST_HEAD) {
-		bool preload = 0;
-		int res;
-
-retry:
-		if (gfpflags_allow_blocking(gfp) && !radix_tree_preload(gfp))
-			preload = 1;
-		spin_lock_irqsave(&secid_lock, flags);
-		if (alloced_secid != SECID_MAX) {
-			secid = ++alloced_secid;
-			res = radix_tree_insert(&aa_secids_map, secid, label);
-			AA_BUG(res == -EEXIST);
-		} else {
-			secid = AA_SECID_INVALID;
-		}
-		spin_unlock_irqrestore(&secid_lock, flags);
-		if (preload)
-			radix_tree_preload_end();
-	} else {
-		spin_lock_irqsave(&secid_lock, flags);
-		/* remove entry from free list */
-		secid = __pop(label);
-		if (secid == AA_SECID_INVALID) {
-			spin_unlock_irqrestore(&secid_lock, flags);
-			goto retry;
-		}
-		spin_unlock_irqrestore(&secid_lock, flags);
-	}
+	idr_preload(gfp);
+	spin_lock_irqsave(&secid_lock, flags);
+	secid = idr_alloc(&aa_secids, label, 0, 0, GFP_ATOMIC);
+	/* XXX: Can return -ENOMEM */
+	spin_unlock_irqrestore(&secid_lock, flags);
+	idr_preload_end();
 
 	return secid;
 }
@@ -237,6 +145,6 @@ void aa_free_secid(u32 secid)
 	unsigned long flags;
 
 	spin_lock_irqsave(&secid_lock, flags);
-	__push(secid);
+	idr_remove(&aa_secids, secid);
 	spin_unlock_irqrestore(&secid_lock, flags);
 }

commit 52e7128ebbdd7b05ba8615efbe410e88a5925a1d
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri May 4 01:57:47 2018 -0700

    apparmor: fix '*seclen' is never less than zero
    
    smatch warnings:
    security/apparmor/secid.c:162 apparmor_secid_to_secctx() warn: unsigned '*seclen' is never less than zero.
    
    vim +162 security/apparmor/secid.c
    
       140
       141  int apparmor_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
       142  {
       143          /* TODO: cache secctx and ref count so we don't have to recreate */
       144          struct aa_label *label = aa_secid_to_label(secid);
       145
       146          AA_BUG(!secdata);
       147          AA_BUG(!seclen);
       148
       149          if (!label)
       150                  return -EINVAL;
       151
       152          if (secdata)
       153                  *seclen = aa_label_asxprint(secdata, root_ns, label,
       154                                              FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
       155                                              FLAG_HIDDEN_UNCONFINED |
       156                                              FLAG_ABS_ROOT, GFP_ATOMIC);
       157          else
       158                  *seclen = aa_label_snxprint(NULL, 0, root_ns, label,
       159                                              FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
       160                                              FLAG_HIDDEN_UNCONFINED |
       161                                              FLAG_ABS_ROOT);
     > 162          if (*seclen < 0)
       163                  return -ENOMEM;
       164
       165          return 0;
       166  }
       167
    
    Fixes: c092921219d2 ("apparmor: add support for mapping secids and using secctxes")
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/secid.c b/security/apparmor/secid.c
index 502924853986..c2f0c1571156 100644
--- a/security/apparmor/secid.c
+++ b/security/apparmor/secid.c
@@ -142,6 +142,7 @@ int apparmor_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 {
 	/* TODO: cache secctx and ref count so we don't have to recreate */
 	struct aa_label *label = aa_secid_to_label(secid);
+	int len;
 
 	AA_BUG(!secdata);
 	AA_BUG(!seclen);
@@ -150,18 +151,19 @@ int apparmor_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 		return -EINVAL;
 
 	if (secdata)
-		*seclen = aa_label_asxprint(secdata, root_ns, label,
-					    FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
-					    FLAG_HIDDEN_UNCONFINED |
-					    FLAG_ABS_ROOT, GFP_ATOMIC);
+		len = aa_label_asxprint(secdata, root_ns, label,
+					FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
+					FLAG_HIDDEN_UNCONFINED | FLAG_ABS_ROOT,
+					GFP_ATOMIC);
 	else
-		*seclen = aa_label_snxprint(NULL, 0, root_ns, label,
-					    FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
-					    FLAG_HIDDEN_UNCONFINED |
-					    FLAG_ABS_ROOT);
-	if (*seclen < 0)
+		len = aa_label_snxprint(NULL, 0, root_ns, label,
+					FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
+					FLAG_HIDDEN_UNCONFINED | FLAG_ABS_ROOT);
+	if (len < 0)
 		return -ENOMEM;
 
+	*seclen = len;
+
 	return 0;
 }
 

commit c092921219d227b13cb80dbecd3545ee66ab89b3
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jul 31 17:36:45 2017 -0700

    apparmor: add support for mapping secids and using secctxes
    
    Use a radix tree to provide a map between the secid and the label,
    and along with it a basic ability to provide secctx conversion.
    
    Shared/cached secctx will be added later.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/secid.c b/security/apparmor/secid.c
index 3a3edbad0b21..502924853986 100644
--- a/security/apparmor/secid.c
+++ b/security/apparmor/secid.c
@@ -3,7 +3,7 @@
  *
  * This file contains AppArmor security identifier (secid) manipulation fns
  *
- * Copyright 2009-2010 Canonical Ltd.
+ * Copyright 2009-2017 Canonical Ltd.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -11,37 +11,218 @@
  * License.
  *
  *
- * AppArmor allocates a unique secid for every profile loaded.  If a profile
- * is replaced it receives the secid of the profile it is replacing.
- *
- * The secid value of 0 is invalid.
+ * AppArmor allocates a unique secid for every label used. If a label
+ * is replaced it receives the secid of the label it is replacing.
  */
 
-#include <linux/spinlock.h>
 #include <linux/errno.h>
 #include <linux/err.h>
+#include <linux/gfp.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
 
+#include "include/cred.h"
+#include "include/lib.h"
 #include "include/secid.h"
+#include "include/label.h"
+#include "include/policy_ns.h"
 
-/* global counter from which secids are allocated */
-static u32 global_secid;
+/*
+ * secids - do not pin labels with a refcount. They rely on the label
+ * properly updating/freeing them
+ *
+ * A singly linked free list is used to track secids that have been
+ * freed and reuse them before allocating new ones
+ */
+
+#define FREE_LIST_HEAD 1
+
+static RADIX_TREE(aa_secids_map, GFP_ATOMIC);
 static DEFINE_SPINLOCK(secid_lock);
+static u32 alloced_secid = FREE_LIST_HEAD;
+static u32 free_list = FREE_LIST_HEAD;
+static unsigned long free_count;
+
+/*
+ * TODO: allow policy to reserve a secid range?
+ * TODO: add secid pinning
+ * TODO: use secid_update in label replace
+ */
+
+#define SECID_MAX U32_MAX
+
+/* TODO: mark free list as exceptional */
+static void *to_ptr(u32 secid)
+{
+	return (void *)
+		((((unsigned long) secid) << RADIX_TREE_EXCEPTIONAL_SHIFT));
+}
+
+static u32 to_secid(void *ptr)
+{
+	return (u32) (((unsigned long) ptr) >> RADIX_TREE_EXCEPTIONAL_SHIFT);
+}
+
+
+/* TODO: tag free_list entries to mark them as different */
+static u32 __pop(struct aa_label *label)
+{
+	u32 secid = free_list;
+	void __rcu **slot;
+	void *entry;
+
+	if (free_list == FREE_LIST_HEAD)
+		return AA_SECID_INVALID;
+
+	slot = radix_tree_lookup_slot(&aa_secids_map, secid);
+	AA_BUG(!slot);
+	entry = radix_tree_deref_slot_protected(slot, &secid_lock);
+	free_list = to_secid(entry);
+	radix_tree_replace_slot(&aa_secids_map, slot, label);
+	free_count--;
+
+	return secid;
+}
+
+static void __push(u32 secid)
+{
+	void __rcu **slot;
+
+	slot = radix_tree_lookup_slot(&aa_secids_map, secid);
+	AA_BUG(!slot);
+	radix_tree_replace_slot(&aa_secids_map, slot, to_ptr(free_list));
+	free_list = secid;
+	free_count++;
+}
+
+static struct aa_label * __secid_update(u32 secid, struct aa_label *label)
+{
+	struct aa_label *old;
+	void __rcu **slot;
+
+	slot = radix_tree_lookup_slot(&aa_secids_map, secid);
+	AA_BUG(!slot);
+	old = radix_tree_deref_slot_protected(slot, &secid_lock);
+	radix_tree_replace_slot(&aa_secids_map, slot, label);
+
+	return old;
+}
+
+/**
+ * aa_secid_update - update a secid mapping to a new label
+ * @secid: secid to update
+ * @label: label the secid will now map to
+ */
+void aa_secid_update(u32 secid, struct aa_label *label)
+{
+	struct aa_label *old;
+	unsigned long flags;
+
+	spin_lock_irqsave(&secid_lock, flags);
+	old = __secid_update(secid, label);
+	spin_unlock_irqrestore(&secid_lock, flags);
+}
+
+/**
+ *
+ * see label for inverse aa_label_to_secid
+ */
+struct aa_label *aa_secid_to_label(u32 secid)
+{
+	struct aa_label *label;
+
+	rcu_read_lock();
+	label = radix_tree_lookup(&aa_secids_map, secid);
+	rcu_read_unlock();
+
+	return label;
+}
+
+int apparmor_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
+{
+	/* TODO: cache secctx and ref count so we don't have to recreate */
+	struct aa_label *label = aa_secid_to_label(secid);
+
+	AA_BUG(!secdata);
+	AA_BUG(!seclen);
+
+	if (!label)
+		return -EINVAL;
+
+	if (secdata)
+		*seclen = aa_label_asxprint(secdata, root_ns, label,
+					    FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
+					    FLAG_HIDDEN_UNCONFINED |
+					    FLAG_ABS_ROOT, GFP_ATOMIC);
+	else
+		*seclen = aa_label_snxprint(NULL, 0, root_ns, label,
+					    FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |
+					    FLAG_HIDDEN_UNCONFINED |
+					    FLAG_ABS_ROOT);
+	if (*seclen < 0)
+		return -ENOMEM;
+
+	return 0;
+}
+
+
+int apparmor_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
+{
+	struct aa_label *label;
+
+	label = aa_label_strn_parse(&root_ns->unconfined->label, secdata,
+				    seclen, GFP_KERNEL, false, false);
+	if (IS_ERR(label))
+		return PTR_ERR(label);
+	*secid = label->secid;
+
+	return 0;
+}
+
+void apparmor_release_secctx(char *secdata, u32 seclen)
+{
+	kfree(secdata);
+}
 
-/* TODO FIXME: add secid to profile mapping, and secid recycling */
 
 /**
  * aa_alloc_secid - allocate a new secid for a profile
  */
-u32 aa_alloc_secid(void)
+u32 aa_alloc_secid(struct aa_label *label, gfp_t gfp)
 {
+	unsigned long flags;
 	u32 secid;
 
-	/*
-	 * TODO FIXME: secid recycling - part of profile mapping table
-	 */
-	spin_lock(&secid_lock);
-	secid = (++global_secid);
-	spin_unlock(&secid_lock);
+	/* racey, but at worst causes new allocation instead of reuse */
+	if (free_list == FREE_LIST_HEAD) {
+		bool preload = 0;
+		int res;
+
+retry:
+		if (gfpflags_allow_blocking(gfp) && !radix_tree_preload(gfp))
+			preload = 1;
+		spin_lock_irqsave(&secid_lock, flags);
+		if (alloced_secid != SECID_MAX) {
+			secid = ++alloced_secid;
+			res = radix_tree_insert(&aa_secids_map, secid, label);
+			AA_BUG(res == -EEXIST);
+		} else {
+			secid = AA_SECID_INVALID;
+		}
+		spin_unlock_irqrestore(&secid_lock, flags);
+		if (preload)
+			radix_tree_preload_end();
+	} else {
+		spin_lock_irqsave(&secid_lock, flags);
+		/* remove entry from free list */
+		secid = __pop(label);
+		if (secid == AA_SECID_INVALID) {
+			spin_unlock_irqrestore(&secid_lock, flags);
+			goto retry;
+		}
+		spin_unlock_irqrestore(&secid_lock, flags);
+	}
+
 	return secid;
 }
 
@@ -51,5 +232,9 @@ u32 aa_alloc_secid(void)
  */
 void aa_free_secid(u32 secid)
 {
-	;			/* NOP ATM */
+	unsigned long flags;
+
+	spin_lock_irqsave(&secid_lock, flags);
+	__push(secid);
+	spin_unlock_irqrestore(&secid_lock, flags);
 }

commit 121d4a91e3c12ddfb167edafb9aa64cc5cc3a406
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:17 2017 -0800

    apparmor: rename sid to secid
    
    Move to common terminology with other LSMs and kernel infrastucture
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/secid.c b/security/apparmor/secid.c
new file mode 100644
index 000000000000..3a3edbad0b21
--- /dev/null
+++ b/security/apparmor/secid.c
@@ -0,0 +1,55 @@
+/*
+ * AppArmor security module
+ *
+ * This file contains AppArmor security identifier (secid) manipulation fns
+ *
+ * Copyright 2009-2010 Canonical Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ *
+ * AppArmor allocates a unique secid for every profile loaded.  If a profile
+ * is replaced it receives the secid of the profile it is replacing.
+ *
+ * The secid value of 0 is invalid.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+
+#include "include/secid.h"
+
+/* global counter from which secids are allocated */
+static u32 global_secid;
+static DEFINE_SPINLOCK(secid_lock);
+
+/* TODO FIXME: add secid to profile mapping, and secid recycling */
+
+/**
+ * aa_alloc_secid - allocate a new secid for a profile
+ */
+u32 aa_alloc_secid(void)
+{
+	u32 secid;
+
+	/*
+	 * TODO FIXME: secid recycling - part of profile mapping table
+	 */
+	spin_lock(&secid_lock);
+	secid = (++global_secid);
+	spin_unlock(&secid_lock);
+	return secid;
+}
+
+/**
+ * aa_free_secid - free a secid
+ * @secid: secid to free
+ */
+void aa_free_secid(u32 secid)
+{
+	;			/* NOP ATM */
+}
