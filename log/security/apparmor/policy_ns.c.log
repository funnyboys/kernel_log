commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 1a7cec5d9cac..d7ef540027a5 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * AppArmor security module
  *
@@ -6,11 +7,6 @@
  * Copyright (C) 1998-2008 Novell/SUSE
  * Copyright 2009-2017 Canonical Ltd.
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation, version 2 of the
- * License.
- *
  * AppArmor policy namespaces, allow for different sets of policies
  * to be loaded for tasks within the namespace.
  */

commit 0a6b29230ec336189bab32498df3f06c8a6944d8
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Aug 2 11:38:23 2018 +0300

    apparmor: fix an error code in __aa_create_ns()
    
    We should return error pointers in this function.  Returning NULL
    results in a NULL dereference in the caller.
    
    Fixes: 73688d1ed0b8 ("apparmor: refactor prepare_ns() and make usable from different views")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index b0f9dc3f765a..1a7cec5d9cac 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -255,7 +255,7 @@ static struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,
 
 	ns = alloc_ns(parent->base.hname, name);
 	if (!ns)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 	ns->level = parent->level + 1;
 	mutex_lock_nested(&ns->lock, ns->level);
 	error = __aafs_ns_mkdir(ns, ns_subns_dir(parent), name, dir);

commit d8889d49e414b371eb235c08c3a759ab3e0cfa51
Author: John Johansen <john.johansen@canonical.com>
Date:   Wed Oct 11 01:04:48 2017 -0700

    apparmor: move context.h to cred.h
    
    Now that file contexts have been moved into file, and task context
    fns() and data have been split from the context, only the cred context
    remains in context.h so rename to cred.h to better reflect what it
    deals with.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index b1e629cba70b..b0f9dc3f765a 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -21,7 +21,7 @@
 #include <linux/string.h>
 
 #include "include/apparmor.h"
-#include "include/context.h"
+#include "include/cred.h"
 #include "include/policy_ns.h"
 #include "include/label.h"
 #include "include/policy.h"

commit feb3c766a3ab32d233aaff7db13afd9ba5bc142d
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Nov 20 23:24:09 2017 -0800

    apparmor: fix possible recursive lock warning in __aa_create_ns
    
    Use mutex_lock_nested to provide lockdep the parent child lock ordering of
    the tree.
    
    This fixes the lockdep Warning
    [  305.275177] ============================================
    [  305.275178] WARNING: possible recursive locking detected
    [  305.275179] 4.14.0-rc7+ #320 Not tainted
    [  305.275180] --------------------------------------------
    [  305.275181] apparmor_parser/1339 is trying to acquire lock:
    [  305.275182]  (&ns->lock){+.+.}, at: [<ffffffff970544dd>] __aa_create_ns+0x6d/0x1e0
    [  305.275187]
                   but task is already holding lock:
    [  305.275187]  (&ns->lock){+.+.}, at: [<ffffffff97054b5d>] aa_prepare_ns+0x3d/0xd0
    [  305.275190]
                   other info that might help us debug this:
    [  305.275191]  Possible unsafe locking scenario:
    
    [  305.275192]        CPU0
    [  305.275193]        ----
    [  305.275193]   lock(&ns->lock);
    [  305.275194]   lock(&ns->lock);
    [  305.275195]
                    *** DEADLOCK ***
    
    [  305.275196]  May be due to missing lock nesting notation
    
    [  305.275198] 2 locks held by apparmor_parser/1339:
    [  305.275198]  #0:  (sb_writers#10){.+.+}, at: [<ffffffff96e9c6b7>] vfs_write+0x1a7/0x1d0
    [  305.275202]  #1:  (&ns->lock){+.+.}, at: [<ffffffff97054b5d>] aa_prepare_ns+0x3d/0xd0
    [  305.275205]
                   stack backtrace:
    [  305.275207] CPU: 1 PID: 1339 Comm: apparmor_parser Not tainted 4.14.0-rc7+ #320
    [  305.275208] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.1-1ubuntu1 04/01/2014
    [  305.275209] Call Trace:
    [  305.275212]  dump_stack+0x85/0xcb
    [  305.275214]  __lock_acquire+0x141c/0x1460
    [  305.275216]  ? __aa_create_ns+0x6d/0x1e0
    [  305.275218]  ? ___slab_alloc+0x183/0x540
    [  305.275219]  ? ___slab_alloc+0x183/0x540
    [  305.275221]  lock_acquire+0xed/0x1e0
    [  305.275223]  ? lock_acquire+0xed/0x1e0
    [  305.275224]  ? __aa_create_ns+0x6d/0x1e0
    [  305.275227]  __mutex_lock+0x89/0x920
    [  305.275228]  ? __aa_create_ns+0x6d/0x1e0
    [  305.275230]  ? trace_hardirqs_on_caller+0x11f/0x190
    [  305.275231]  ? __aa_create_ns+0x6d/0x1e0
    [  305.275233]  ? __lockdep_init_map+0x57/0x1d0
    [  305.275234]  ? lockdep_init_map+0x9/0x10
    [  305.275236]  ? __rwlock_init+0x32/0x60
    [  305.275238]  mutex_lock_nested+0x1b/0x20
    [  305.275240]  ? mutex_lock_nested+0x1b/0x20
    [  305.275241]  __aa_create_ns+0x6d/0x1e0
    [  305.275243]  aa_prepare_ns+0xc2/0xd0
    [  305.275245]  aa_replace_profiles+0x168/0xf30
    [  305.275247]  ? __might_fault+0x85/0x90
    [  305.275250]  policy_update+0xb9/0x380
    [  305.275252]  profile_load+0x7e/0x90
    [  305.275254]  __vfs_write+0x28/0x150
    [  305.275256]  ? rcu_read_lock_sched_held+0x72/0x80
    [  305.275257]  ? rcu_sync_lockdep_assert+0x2f/0x60
    [  305.275259]  ? __sb_start_write+0xdc/0x1c0
    [  305.275261]  ? vfs_write+0x1a7/0x1d0
    [  305.275262]  vfs_write+0xca/0x1d0
    [  305.275264]  ? trace_hardirqs_on_caller+0x11f/0x190
    [  305.275266]  SyS_write+0x49/0xa0
    [  305.275268]  entry_SYSCALL_64_fastpath+0x23/0xc2
    [  305.275271] RIP: 0033:0x7fa6b22e8c74
    [  305.275272] RSP: 002b:00007ffeaaee6288 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [  305.275273] RAX: ffffffffffffffda RBX: 00007ffeaaee62a4 RCX: 00007fa6b22e8c74
    [  305.275274] RDX: 0000000000000a51 RSI: 00005566a8198c10 RDI: 0000000000000004
    [  305.275275] RBP: 0000000000000a39 R08: 0000000000000a51 R09: 0000000000000000
    [  305.275276] R10: 0000000000000000 R11: 0000000000000246 R12: 00005566a8198c10
    [  305.275277] R13: 0000000000000004 R14: 00005566a72ecb88 R15: 00005566a72ec3a8
    
    Fixes: 73688d1ed0b8 ("apparmor: refactor prepare_ns() and make usable from different views")
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 62a3589c62ab..b1e629cba70b 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -256,7 +256,8 @@ static struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,
 	ns = alloc_ns(parent->base.hname, name);
 	if (!ns)
 		return NULL;
-	mutex_lock(&ns->lock);
+	ns->level = parent->level + 1;
+	mutex_lock_nested(&ns->lock, ns->level);
 	error = __aafs_ns_mkdir(ns, ns_subns_dir(parent), name, dir);
 	if (error) {
 		AA_ERROR("Failed to create interface for ns %s\n",
@@ -266,7 +267,6 @@ static struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,
 		return ERR_PTR(error);
 	}
 	ns->parent = aa_get_ns(parent);
-	ns->level = parent->level + 1;
 	list_add_rcu(&ns->base.list, &parent->sub_ns);
 	/* add list ref */
 	aa_get_ns(ns);
@@ -313,7 +313,7 @@ struct aa_ns *aa_prepare_ns(struct aa_ns *parent, const char *name)
 {
 	struct aa_ns *ns;
 
-	mutex_lock(&parent->lock);
+	mutex_lock_nested(&parent->lock, parent->level);
 	/* try and find the specified ns and if it doesn't exist create it */
 	/* released by caller */
 	ns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));
@@ -336,7 +336,7 @@ static void destroy_ns(struct aa_ns *ns)
 	if (!ns)
 		return;
 
-	mutex_lock(&ns->lock);
+	mutex_lock_nested(&ns->lock, ns->level);
 	/* release all profiles in this namespace */
 	__aa_profile_list_release(&ns->base.profiles);
 

commit 15372b97aa7593c6f5bc1afe69f42fd403c40685
Author: John Johansen <john.johansen@canonical.com>
Date:   Wed Aug 16 05:48:06 2017 -0700

    apparmor: ensure unconfined profiles have dfas initialized
    
    Generally unconfined has early bailout tests and does not need the
    dfas initialized, however if an early bailout test is ever missed
    it will result in an oops.
    
    Be defensive and initialize the unconfined profile to have null dfas
    (no permission) so if an early bailout test is missed we fail
    closed (no perms granted) instead of oopsing.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 351d3bab3a3d..62a3589c62ab 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -112,6 +112,8 @@ static struct aa_ns *alloc_ns(const char *prefix, const char *name)
 	ns->unconfined->label.flags |= FLAG_IX_ON_NAME_ERROR |
 		FLAG_IMMUTIBLE | FLAG_NS_COUNT | FLAG_UNCONFINED;
 	ns->unconfined->mode = APPARMOR_UNCONFINED;
+	ns->unconfined->file.dfa = aa_get_dfa(nulldfa);
+	ns->unconfined->policy.dfa = aa_get_dfa(nulldfa);
 
 	/* ns and ns->unconfined share ns->unconfined refcount */
 	ns->unconfined->ns = ns;

commit 637f688dc3dc304a89f441d76f49a0e35bc49c08
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri Jun 9 08:14:28 2017 -0700

    apparmor: switch from profiles to using labels on contexts
    
    Begin the actual switch to using domain labels by storing them on
    the context and converting the label to a singular profile where
    possible.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index c05316809a5e..351d3bab3a3d 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -23,6 +23,7 @@
 #include "include/apparmor.h"
 #include "include/context.h"
 #include "include/policy_ns.h"
+#include "include/label.h"
 #include "include/policy.h"
 
 /* root profile namespace */
@@ -104,12 +105,12 @@ static struct aa_ns *alloc_ns(const char *prefix, const char *name)
 	init_waitqueue_head(&ns->wait);
 
 	/* released by aa_free_ns() */
-	ns->unconfined = aa_alloc_profile("unconfined", GFP_KERNEL);
+	ns->unconfined = aa_alloc_profile("unconfined", NULL, GFP_KERNEL);
 	if (!ns->unconfined)
 		goto fail_unconfined;
 
-	ns->unconfined->flags = PFLAG_IX_ON_NAME_ERROR |
-		PFLAG_IMMUTABLE | PFLAG_NS_COUNT;
+	ns->unconfined->label.flags |= FLAG_IX_ON_NAME_ERROR |
+		FLAG_IMMUTIBLE | FLAG_NS_COUNT | FLAG_UNCONFINED;
 	ns->unconfined->mode = APPARMOR_UNCONFINED;
 
 	/* ns and ns->unconfined share ns->unconfined refcount */
@@ -117,6 +118,8 @@ static struct aa_ns *alloc_ns(const char *prefix, const char *name)
 
 	atomic_set(&ns->uniq_null, 0);
 
+	aa_labelset_init(&ns->labels);
+
 	return ns;
 
 fail_unconfined:
@@ -139,6 +142,7 @@ void aa_free_ns(struct aa_ns *ns)
 		return;
 
 	aa_policy_destroy(&ns->base);
+	aa_labelset_destroy(&ns->labels);
 	aa_put_ns(ns->parent);
 
 	ns->unconfined->ns = NULL;
@@ -337,8 +341,14 @@ static void destroy_ns(struct aa_ns *ns)
 	/* release all sub namespaces */
 	__ns_list_release(&ns->sub_ns);
 
-	if (ns->parent)
-		__aa_update_proxy(ns->unconfined, ns->parent->unconfined);
+	if (ns->parent) {
+		unsigned long flags;
+
+		write_lock_irqsave(&ns->labels.lock, flags);
+		__aa_proxy_redirect(ns_unconfined(ns),
+				    ns_unconfined(ns->parent));
+		write_unlock_irqrestore(&ns->labels.lock, flags);
+	}
 	__aafs_ns_rmdir(ns);
 	mutex_unlock(&ns->lock);
 }

commit 3664268f19ea07bec55df92fe53ff9ed28968bcc
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri Jun 2 17:44:27 2017 -0700

    apparmor: add namespace lookup fns()
    
    Currently lookups are restricted to a single ns component in the
    path. However when namespaces are allowed to have separate views, and
    scopes this will not be sufficient, as it will be possible to have
    a multiple component ns path in scope.
    
    Add some ns lookup fns() to allow this and use them.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index f3418a9e59b1..c05316809a5e 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -183,6 +183,60 @@ struct aa_ns *aa_find_ns(struct aa_ns *root, const char *name)
 	return aa_findn_ns(root, name, strlen(name));
 }
 
+/**
+ * __aa_lookupn_ns - lookup the namespace matching @hname
+ * @base: base list to start looking up profile name from  (NOT NULL)
+ * @hname: hierarchical ns name  (NOT NULL)
+ * @n: length of @hname
+ *
+ * Requires: rcu_read_lock be held
+ *
+ * Returns: unrefcounted ns pointer or NULL if not found
+ *
+ * Do a relative name lookup, recursing through profile tree.
+ */
+struct aa_ns *__aa_lookupn_ns(struct aa_ns *view, const char *hname, size_t n)
+{
+	struct aa_ns *ns = view;
+	const char *split;
+
+	for (split = strnstr(hname, "//", n); split;
+	     split = strnstr(hname, "//", n)) {
+		ns = __aa_findn_ns(&ns->sub_ns, hname, split - hname);
+		if (!ns)
+			return NULL;
+
+		n -= split + 2 - hname;
+		hname = split + 2;
+	}
+
+	if (n)
+		return __aa_findn_ns(&ns->sub_ns, hname, n);
+	return NULL;
+}
+
+/**
+ * aa_lookupn_ns  -  look up a policy namespace relative to @view
+ * @view: namespace to search in  (NOT NULL)
+ * @name: name of namespace to find  (NOT NULL)
+ * @n: length of @name
+ *
+ * Returns: a refcounted namespace on the list, or NULL if no namespace
+ *          called @name exists.
+ *
+ * refcount released by caller
+ */
+struct aa_ns *aa_lookupn_ns(struct aa_ns *view, const char *name, size_t n)
+{
+	struct aa_ns *ns = NULL;
+
+	rcu_read_lock();
+	ns = aa_get_ns(__aa_lookupn_ns(view, name, n));
+	rcu_read_unlock();
+
+	return ns;
+}
+
 static struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,
 				    struct dentry *dir)
 {

commit d9bf2c268be6064ae0c9980e4c37fdd262c7effc
Author: John Johansen <john.johansen@canonical.com>
Date:   Fri May 26 16:27:58 2017 -0700

    apparmor: add policy revision file interface
    
    Add a policy revision file to find the current revision of a ns's policy.
    There is a revision file per ns, as well as a virtualized global revision
    file in the base apparmor fs directory. The global revision file when
    opened will provide the revision of the opening task namespace.
    
    The revision file can be waited on via select/poll to detect apparmor
    policy changes from the last read revision of the opened file. This
    means that the revision file must be read after the select/poll other
    wise update data will remain ready for reading.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 7d7c23705be2..f3418a9e59b1 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -101,6 +101,7 @@ static struct aa_ns *alloc_ns(const char *prefix, const char *name)
 	INIT_LIST_HEAD(&ns->sub_ns);
 	INIT_LIST_HEAD(&ns->rawdata_list);
 	mutex_init(&ns->lock);
+	init_waitqueue_head(&ns->wait);
 
 	/* released by aa_free_ns() */
 	ns->unconfined = aa_alloc_profile("unconfined", GFP_KERNEL);

commit 98407f0a0d378df27bfea79301a3aba42d7cea1c
Author: John Johansen <john.johansen@canonical.com>
Date:   Thu May 25 06:31:46 2017 -0700

    apparmor: allow specifying an already created dir to create ns entries in
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Seth Arnold <seth.arnold@canonical.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 0a8bc4e887ef..7d7c23705be2 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -196,7 +196,7 @@ static struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,
 	if (!ns)
 		return NULL;
 	mutex_lock(&ns->lock);
-	error = __aafs_ns_mkdir(ns, ns_subns_dir(parent), name);
+	error = __aafs_ns_mkdir(ns, ns_subns_dir(parent), name, dir);
 	if (error) {
 		AA_ERROR("Failed to create interface for ns %s\n",
 			 ns->base.name);

commit c97204baf840bf850e14ef4f5f43251239ca43b6
Author: John Johansen <john.johansen@canonical.com>
Date:   Thu May 25 06:23:42 2017 -0700

    apparmor: rename apparmor file fns and data to indicate use
    
    prefixes are used for fns/data that are not static to apparmorfs.c
    with the prefixes being
      aafs   - special magic apparmorfs for policy namespace data
      aa_sfs - for fns/data that go into securityfs
      aa_fs  - for fns/data that may be used in the either of aafs or
               securityfs
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Seth Arnold <seth.arnold@canonical.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index c94ec6ef9e35..0a8bc4e887ef 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -196,7 +196,7 @@ static struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,
 	if (!ns)
 		return NULL;
 	mutex_lock(&ns->lock);
-	error = __aa_fs_ns_mkdir(ns, ns_subns_dir(parent), name);
+	error = __aafs_ns_mkdir(ns, ns_subns_dir(parent), name);
 	if (error) {
 		AA_ERROR("Failed to create interface for ns %s\n",
 			 ns->base.name);
@@ -284,7 +284,7 @@ static void destroy_ns(struct aa_ns *ns)
 
 	if (ns->parent)
 		__aa_update_proxy(ns->unconfined, ns->parent->unconfined);
-	__aa_fs_ns_rmdir(ns);
+	__aafs_ns_rmdir(ns);
 	mutex_unlock(&ns->lock);
 }
 

commit 5d5182cae40115c03933989473288e54afb39c7c
Author: John Johansen <john.johansen@canonical.com>
Date:   Tue May 9 00:08:41 2017 -0700

    apparmor: move to per loaddata files, instead of replicating in profiles
    
    The loaddata sets cover more than just a single profile and should
    be tracked at the ns level. Move the load data files under the namespace
    and reference the files from the profiles via a symlink.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Seth Arnold <seth.arnold@canonical.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 93d1826c4b09..c94ec6ef9e35 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -99,6 +99,7 @@ static struct aa_ns *alloc_ns(const char *prefix, const char *name)
 		goto fail_ns;
 
 	INIT_LIST_HEAD(&ns->sub_ns);
+	INIT_LIST_HEAD(&ns->rawdata_list);
 	mutex_init(&ns->lock);
 
 	/* released by aa_free_ns() */

commit ee2351e4b07cb7e3609f8661effe0382fb23646b
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:46 2017 -0800

    apparmor: track ns level so it can be used to help in view checks
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 1e19bd3c7851..93d1826c4b09 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -204,6 +204,7 @@ static struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,
 		return ERR_PTR(error);
 	}
 	ns->parent = aa_get_ns(parent);
+	ns->level = parent->level + 1;
 	list_add_rcu(&ns->base.list, &parent->sub_ns);
 	/* add list ref */
 	aa_get_ns(ns);

commit 30b026a8d16bfa15bc24f4cca1604e47ac1a2f64
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:35 2017 -0800

    apparmor: pass gfp_t parameter into profile allocation
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index f6cdc738ffcd..1e19bd3c7851 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -102,7 +102,7 @@ static struct aa_ns *alloc_ns(const char *prefix, const char *name)
 	mutex_init(&ns->lock);
 
 	/* released by aa_free_ns() */
-	ns->unconfined = aa_alloc_profile("unconfined");
+	ns->unconfined = aa_alloc_profile("unconfined", GFP_KERNEL);
 	if (!ns->unconfined)
 		goto fail_unconfined;
 

commit 73688d1ed0b8f800f312f7bc9d583463858da861
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:34 2017 -0800

    apparmor: refactor prepare_ns() and make usable from different views
    
    prepare_ns() will need to be called from alternate views, and namespaces
    will need to be created via different interfaces. So refactor and
    allow specifying the view ns.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 8a5632f39751..f6cdc738ffcd 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -181,48 +181,82 @@ struct aa_ns *aa_find_ns(struct aa_ns *root, const char *name)
 	return aa_findn_ns(root, name, strlen(name));
 }
 
+static struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,
+				    struct dentry *dir)
+{
+	struct aa_ns *ns;
+	int error;
+
+	AA_BUG(!parent);
+	AA_BUG(!name);
+	AA_BUG(!mutex_is_locked(&parent->lock));
+
+	ns = alloc_ns(parent->base.hname, name);
+	if (!ns)
+		return NULL;
+	mutex_lock(&ns->lock);
+	error = __aa_fs_ns_mkdir(ns, ns_subns_dir(parent), name);
+	if (error) {
+		AA_ERROR("Failed to create interface for ns %s\n",
+			 ns->base.name);
+		mutex_unlock(&ns->lock);
+		aa_free_ns(ns);
+		return ERR_PTR(error);
+	}
+	ns->parent = aa_get_ns(parent);
+	list_add_rcu(&ns->base.list, &parent->sub_ns);
+	/* add list ref */
+	aa_get_ns(ns);
+	mutex_unlock(&ns->lock);
+
+	return ns;
+}
+
 /**
- * aa_prepare_ns - find an existing or create a new namespace of @name
- * @name: the namespace to find or add  (MAYBE NULL)
+ * aa_create_ns - create an ns, fail if it already exists
+ * @parent: the parent of the namespace being created
+ * @name: the name of the namespace
+ * @dir: if not null the dir to put the ns entries in
  *
- * Returns: refcounted ns or NULL if failed to create one
+ * Returns: the a refcounted ns that has been add or an ERR_PTR
  */
-struct aa_ns *aa_prepare_ns(const char *name)
+struct aa_ns *__aa_find_or_create_ns(struct aa_ns *parent, const char *name,
+				     struct dentry *dir)
 {
-	struct aa_ns *ns, *root;
+	struct aa_ns *ns;
 
-	root = aa_current_profile()->ns;
+	AA_BUG(!mutex_is_locked(&parent->lock));
 
-	mutex_lock(&root->lock);
+	/* try and find the specified ns */
+	/* released by caller */
+	ns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));
+	if (!ns)
+		ns = __aa_create_ns(parent, name, dir);
+	else
+		ns = ERR_PTR(-EEXIST);
 
-	/* if name isn't specified the profile is loaded to the current ns */
-	if (!name) {
-		/* released by caller */
-		ns = aa_get_ns(root);
-		goto out;
-	}
+	/* return ref */
+	return ns;
+}
 
+/**
+ * aa_prepare_ns - find an existing or create a new namespace of @name
+ * @parent: ns to treat as parent
+ * @name: the namespace to find or add  (NOT NULL)
+ *
+ * Returns: refcounted namespace or PTR_ERR if failed to create one
+ */
+struct aa_ns *aa_prepare_ns(struct aa_ns *parent, const char *name)
+{
+	struct aa_ns *ns;
+
+	mutex_lock(&parent->lock);
 	/* try and find the specified ns and if it doesn't exist create it */
 	/* released by caller */
-	ns = aa_get_ns(__aa_find_ns(&root->sub_ns, name));
-	if (!ns) {
-		ns = alloc_ns(root->base.hname, name);
-		if (!ns)
-			goto out;
-		if (__aa_fs_ns_mkdir(ns, ns_subns_dir(root), name)) {
-			AA_ERROR("Failed to create interface for ns %s\n",
-				 ns->base.name);
-			aa_free_ns(ns);
-			ns = NULL;
-			goto out;
-		}
-		ns->parent = aa_get_ns(root);
-		list_add_rcu(&ns->base.list, &root->sub_ns);
-		/* add list ref */
-		aa_get_ns(ns);
-	}
-out:
-	mutex_unlock(&root->lock);
+	ns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));
+	if (!ns)
+		ns = __aa_create_ns(parent, name, NULL);
+	mutex_unlock(&parent->lock);
 
 	/* return ref */
 	return ns;

commit d102d895713c736fd13e21feaab38b52d8ab32ad
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:31 2017 -0800

    apparmor: pass gfp param into aa_policy_init()
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index e7b7a829532e..8a5632f39751 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -95,7 +95,7 @@ static struct aa_ns *alloc_ns(const char *prefix, const char *name)
 	AA_DEBUG("%s(%p)\n", __func__, ns);
 	if (!ns)
 		return NULL;
-	if (!aa_policy_init(&ns->base, prefix, name))
+	if (!aa_policy_init(&ns->base, prefix, name, GFP_KERNEL))
 		goto fail_ns;
 
 	INIT_LIST_HEAD(&ns->sub_ns);

commit 92b6d8eff55f8dca57ade26e1dde2c3b6acdae02
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:25 2017 -0800

    apparmor: allow ns visibility question to consider subnses
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index bab23cce197c..e7b7a829532e 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -33,18 +33,23 @@ const char *aa_hidden_ns_name = "---";
  * aa_ns_visible - test if @view is visible from @curr
  * @curr: namespace to treat as the parent (NOT NULL)
  * @view: namespace to test if visible from @curr (NOT NULL)
+ * @subns: whether view of a subns is allowed
  *
  * Returns: true if @view is visible from @curr else false
  */
-bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view)
+bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)
 {
 	if (curr == view)
 		return true;
 
+	if (!subns)
+		return false;
+
 	for ( ; view; view = view->parent) {
 		if (view->parent == curr)
 			return true;
 	}
+
 	return false;
 }
 
@@ -52,16 +57,17 @@ bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view)
  * aa_na_name - Find the ns name to display for @view from @curr
  * @curr - current namespace (NOT NULL)
  * @view - namespace attempting to view (NOT NULL)
+ * @subns - are subns visible
  *
  * Returns: name of @view visible from @curr
  */
-const char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view)
+const char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)
 {
 	/* if view == curr then the namespace name isn't displayed */
 	if (curr == view)
 		return "";
 
-	if (aa_ns_visible(curr, view)) {
+	if (aa_ns_visible(curr, view, subns)) {
 		/* at this point if a ns is visible it is in a view ns
 		 * thus the curr ns.hname is a prefix of its name.
 		 * Only output the virtualized portion of the name

commit 31617ddfdd7764a5046f076247208aa324458069
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:24 2017 -0800

    apparmor: add fn to lookup profiles by fqname
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 9746643cbab2..bab23cce197c 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -226,7 +226,7 @@ static void __ns_list_release(struct list_head *head);
 
 /**
  * destroy_ns - remove everything contained by @ns
- * @ns: ns to have it contents removed  (NOT NULL)
+ * @ns: namespace to have it contents removed  (NOT NULL)
  */
 static void destroy_ns(struct aa_ns *ns)
 {
@@ -276,7 +276,7 @@ static void __ns_list_release(struct list_head *head)
 }
 
 /**
- * aa_alloc_root_ns - allocate the root profile namespcae
+ * aa_alloc_root_ns - allocate the root profile namespace
  *
  * Returns: %0 on success else error
  *

commit 9a2d40c12d00ead1b1a3ac8383d2d66e35674fdb
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:22 2017 -0800

    apparmor: add strn version of aa_find_ns
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 71fbd14e3b37..9746643cbab2 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -139,26 +139,42 @@ void aa_free_ns(struct aa_ns *ns)
 }
 
 /**
- * aa_find_ns  -  look up a profile namespace on the namespace list
+ * aa_findn_ns  -  look up a profile namespace on the namespace list
  * @root: namespace to search in  (NOT NULL)
  * @name: name of namespace to find  (NOT NULL)
+ * @n: length of @name
  *
  * Returns: a refcounted namespace on the list, or NULL if no namespace
  *          called @name exists.
  *
  * refcount released by caller
  */
-struct aa_ns *aa_find_ns(struct aa_ns *root, const char *name)
+struct aa_ns *aa_findn_ns(struct aa_ns *root, const char *name, size_t n)
 {
 	struct aa_ns *ns = NULL;
 
 	rcu_read_lock();
-	ns = aa_get_ns(__aa_find_ns(&root->sub_ns, name));
+	ns = aa_get_ns(__aa_findn_ns(&root->sub_ns, name, n));
 	rcu_read_unlock();
 
 	return ns;
 }
 
+/**
+ * aa_find_ns  -  look up a profile namespace on the namespace list
+ * @root: namespace to search in  (NOT NULL)
+ * @name: name of namespace to find  (NOT NULL)
+ *
+ * Returns: a refcounted namespace on the list, or NULL if no namespace
+ *          called @name exists.
+ *
+ * refcount released by caller
+ */
+struct aa_ns *aa_find_ns(struct aa_ns *root, const char *name)
+{
+	return aa_findn_ns(root, name, strlen(name));
+}
+
 /**
  * aa_prepare_ns - find an existing or create a new namespace of @name
  * @name: the namespace to find or add  (MAYBE NULL)

commit 8399588a7f9def9195e577f988ad06f2a0ffb1af
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:19 2017 -0800

    apparmor: rename replacedby to proxy
    
    Proxy is shorter and a better fit than replaceby, so rename it.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index 88b3b3c110e3..71fbd14e3b37 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -225,7 +225,7 @@ static void destroy_ns(struct aa_ns *ns)
 	__ns_list_release(&ns->sub_ns);
 
 	if (ns->parent)
-		__aa_update_replacedby(ns->unconfined, ns->parent->unconfined);
+		__aa_update_proxy(ns->unconfined, ns->parent->unconfined);
 	__aa_fs_ns_rmdir(ns);
 	mutex_unlock(&ns->lock);
 }

commit 98849dff90e270af3b34889b9e08252544f40b5b
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:16 2017 -0800

    apparmor: rename namespace to ns to improve code line lengths
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
index d4e9924a276e..88b3b3c110e3 100644
--- a/security/apparmor/policy_ns.c
+++ b/security/apparmor/policy_ns.c
@@ -26,7 +26,7 @@
 #include "include/policy.h"
 
 /* root profile namespace */
-struct aa_namespace *root_ns;
+struct aa_ns *root_ns;
 const char *aa_hidden_ns_name = "---";
 
 /**
@@ -36,7 +36,7 @@ const char *aa_hidden_ns_name = "---";
  *
  * Returns: true if @view is visible from @curr else false
  */
-bool aa_ns_visible(struct aa_namespace *curr, struct aa_namespace *view)
+bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view)
 {
 	if (curr == view)
 		return true;
@@ -55,7 +55,7 @@ bool aa_ns_visible(struct aa_namespace *curr, struct aa_namespace *view)
  *
  * Returns: name of @view visible from @curr
  */
-const char *aa_ns_name(struct aa_namespace *curr, struct aa_namespace *view)
+const char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view)
 {
 	/* if view == curr then the namespace name isn't displayed */
 	if (curr == view)
@@ -75,16 +75,15 @@ const char *aa_ns_name(struct aa_namespace *curr, struct aa_namespace *view)
 }
 
 /**
- * alloc_namespace - allocate, initialize and return a new namespace
+ * alloc_ns - allocate, initialize and return a new namespace
  * @prefix: parent namespace name (MAYBE NULL)
  * @name: a preallocated name  (NOT NULL)
  *
  * Returns: refcounted namespace or NULL on failure.
  */
-static struct aa_namespace *alloc_namespace(const char *prefix,
-					    const char *name)
+static struct aa_ns *alloc_ns(const char *prefix, const char *name)
 {
-	struct aa_namespace *ns;
+	struct aa_ns *ns;
 
 	ns = kzalloc(sizeof(*ns), GFP_KERNEL);
 	AA_DEBUG("%s(%p)\n", __func__, ns);
@@ -96,7 +95,7 @@ static struct aa_namespace *alloc_namespace(const char *prefix,
 	INIT_LIST_HEAD(&ns->sub_ns);
 	mutex_init(&ns->lock);
 
-	/* released by free_namespace */
+	/* released by aa_free_ns() */
 	ns->unconfined = aa_alloc_profile("unconfined");
 	if (!ns->unconfined)
 		goto fail_unconfined;
@@ -120,19 +119,19 @@ static struct aa_namespace *alloc_namespace(const char *prefix,
 }
 
 /**
- * aa_free_namespace - free a profile namespace
+ * aa_free_ns - free a profile namespace
  * @ns: the namespace to free  (MAYBE NULL)
  *
  * Requires: All references to the namespace must have been put, if the
  *           namespace was referenced by a profile confining a task,
  */
-void aa_free_namespace(struct aa_namespace *ns)
+void aa_free_ns(struct aa_ns *ns)
 {
 	if (!ns)
 		return;
 
 	aa_policy_destroy(&ns->base);
-	aa_put_namespace(ns->parent);
+	aa_put_ns(ns->parent);
 
 	ns->unconfined->ns = NULL;
 	aa_free_profile(ns->unconfined);
@@ -140,7 +139,7 @@ void aa_free_namespace(struct aa_namespace *ns)
 }
 
 /**
- * aa_find_namespace  -  look up a profile namespace on the namespace list
+ * aa_find_ns  -  look up a profile namespace on the namespace list
  * @root: namespace to search in  (NOT NULL)
  * @name: name of namespace to find  (NOT NULL)
  *
@@ -149,27 +148,26 @@ void aa_free_namespace(struct aa_namespace *ns)
  *
  * refcount released by caller
  */
-struct aa_namespace *aa_find_namespace(struct aa_namespace *root,
-				       const char *name)
+struct aa_ns *aa_find_ns(struct aa_ns *root, const char *name)
 {
-	struct aa_namespace *ns = NULL;
+	struct aa_ns *ns = NULL;
 
 	rcu_read_lock();
-	ns = aa_get_namespace(__aa_find_namespace(&root->sub_ns, name));
+	ns = aa_get_ns(__aa_find_ns(&root->sub_ns, name));
 	rcu_read_unlock();
 
 	return ns;
 }
 
 /**
- * aa_prepare_namespace - find an existing or create a new namespace of @name
+ * aa_prepare_ns - find an existing or create a new namespace of @name
  * @name: the namespace to find or add  (MAYBE NULL)
  *
- * Returns: refcounted namespace or NULL if failed to create one
+ * Returns: refcounted ns or NULL if failed to create one
  */
-struct aa_namespace *aa_prepare_namespace(const char *name)
+struct aa_ns *aa_prepare_ns(const char *name)
 {
-	struct aa_namespace *ns, *root;
+	struct aa_ns *ns, *root;
 
 	root = aa_current_profile()->ns;
 
@@ -178,28 +176,28 @@ struct aa_namespace *aa_prepare_namespace(const char *name)
 	/* if name isn't specified the profile is loaded to the current ns */
 	if (!name) {
 		/* released by caller */
-		ns = aa_get_namespace(root);
+		ns = aa_get_ns(root);
 		goto out;
 	}
 
 	/* try and find the specified ns and if it doesn't exist create it */
 	/* released by caller */
-	ns = aa_get_namespace(__aa_find_namespace(&root->sub_ns, name));
+	ns = aa_get_ns(__aa_find_ns(&root->sub_ns, name));
 	if (!ns) {
-		ns = alloc_namespace(root->base.hname, name);
+		ns = alloc_ns(root->base.hname, name);
 		if (!ns)
 			goto out;
-		if (__aa_fs_namespace_mkdir(ns, ns_subns_dir(root), name)) {
+		if (__aa_fs_ns_mkdir(ns, ns_subns_dir(root), name)) {
 			AA_ERROR("Failed to create interface for ns %s\n",
 				 ns->base.name);
-			aa_free_namespace(ns);
+			aa_free_ns(ns);
 			ns = NULL;
 			goto out;
 		}
-		ns->parent = aa_get_namespace(root);
+		ns->parent = aa_get_ns(root);
 		list_add_rcu(&ns->base.list, &root->sub_ns);
 		/* add list ref */
-		aa_get_namespace(ns);
+		aa_get_ns(ns);
 	}
 out:
 	mutex_unlock(&root->lock);
@@ -211,10 +209,10 @@ struct aa_namespace *aa_prepare_namespace(const char *name)
 static void __ns_list_release(struct list_head *head);
 
 /**
- * destroy_namespace - remove everything contained by @ns
- * @ns: namespace to have it contents removed  (NOT NULL)
+ * destroy_ns - remove everything contained by @ns
+ * @ns: ns to have it contents removed  (NOT NULL)
  */
-static void destroy_namespace(struct aa_namespace *ns)
+static void destroy_ns(struct aa_ns *ns)
 {
 	if (!ns)
 		return;
@@ -228,22 +226,22 @@ static void destroy_namespace(struct aa_namespace *ns)
 
 	if (ns->parent)
 		__aa_update_replacedby(ns->unconfined, ns->parent->unconfined);
-	__aa_fs_namespace_rmdir(ns);
+	__aa_fs_ns_rmdir(ns);
 	mutex_unlock(&ns->lock);
 }
 
 /**
- * __aa_remove_namespace - remove a namespace and all its children
+ * __aa_remove_ns - remove a namespace and all its children
  * @ns: namespace to be removed  (NOT NULL)
  *
  * Requires: ns->parent->lock be held and ns removed from parent.
  */
-void __aa_remove_namespace(struct aa_namespace *ns)
+void __aa_remove_ns(struct aa_ns *ns)
 {
 	/* remove ns from namespace list */
 	list_del_rcu(&ns->base.list);
-	destroy_namespace(ns);
-	aa_put_namespace(ns);
+	destroy_ns(ns);
+	aa_put_ns(ns);
 }
 
 /**
@@ -254,15 +252,15 @@ void __aa_remove_namespace(struct aa_namespace *ns)
  */
 static void __ns_list_release(struct list_head *head)
 {
-	struct aa_namespace *ns, *tmp;
+	struct aa_ns *ns, *tmp;
 
 	list_for_each_entry_safe(ns, tmp, head, base.list)
-		__aa_remove_namespace(ns);
+		__aa_remove_ns(ns);
 
 }
 
 /**
- * aa_alloc_root_ns - allocate the root profile namespace
+ * aa_alloc_root_ns - allocate the root profile namespcae
  *
  * Returns: %0 on success else error
  *
@@ -270,7 +268,7 @@ static void __ns_list_release(struct list_head *head)
 int __init aa_alloc_root_ns(void)
 {
 	/* released by aa_free_root_ns - used as list ref*/
-	root_ns = alloc_namespace(NULL, "root");
+	root_ns = alloc_ns(NULL, "root");
 	if (!root_ns)
 		return -ENOMEM;
 
@@ -282,10 +280,10 @@ int __init aa_alloc_root_ns(void)
   */
 void __init aa_free_root_ns(void)
 {
-	 struct aa_namespace *ns = root_ns;
+	 struct aa_ns *ns = root_ns;
 
 	 root_ns = NULL;
 
-	 destroy_namespace(ns);
-	 aa_put_namespace(ns);
+	 destroy_ns(ns);
+	 aa_put_ns(ns);
 }

commit cff281f6861e72f1416927aaa0c10a08bb7b2d3f
Author: John Johansen <john.johansen@canonical.com>
Date:   Mon Jan 16 00:42:15 2017 -0800

    apparmor: split apparmor policy namespaces code into its own file
    
    Policy namespaces will be diverging from profile management and
    expanding so put it in its own file.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/apparmor/policy_ns.c b/security/apparmor/policy_ns.c
new file mode 100644
index 000000000000..d4e9924a276e
--- /dev/null
+++ b/security/apparmor/policy_ns.c
@@ -0,0 +1,291 @@
+/*
+ * AppArmor security module
+ *
+ * This file contains AppArmor policy manipulation functions
+ *
+ * Copyright (C) 1998-2008 Novell/SUSE
+ * Copyright 2009-2017 Canonical Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * AppArmor policy namespaces, allow for different sets of policies
+ * to be loaded for tasks within the namespace.
+ */
+
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "include/apparmor.h"
+#include "include/context.h"
+#include "include/policy_ns.h"
+#include "include/policy.h"
+
+/* root profile namespace */
+struct aa_namespace *root_ns;
+const char *aa_hidden_ns_name = "---";
+
+/**
+ * aa_ns_visible - test if @view is visible from @curr
+ * @curr: namespace to treat as the parent (NOT NULL)
+ * @view: namespace to test if visible from @curr (NOT NULL)
+ *
+ * Returns: true if @view is visible from @curr else false
+ */
+bool aa_ns_visible(struct aa_namespace *curr, struct aa_namespace *view)
+{
+	if (curr == view)
+		return true;
+
+	for ( ; view; view = view->parent) {
+		if (view->parent == curr)
+			return true;
+	}
+	return false;
+}
+
+/**
+ * aa_na_name - Find the ns name to display for @view from @curr
+ * @curr - current namespace (NOT NULL)
+ * @view - namespace attempting to view (NOT NULL)
+ *
+ * Returns: name of @view visible from @curr
+ */
+const char *aa_ns_name(struct aa_namespace *curr, struct aa_namespace *view)
+{
+	/* if view == curr then the namespace name isn't displayed */
+	if (curr == view)
+		return "";
+
+	if (aa_ns_visible(curr, view)) {
+		/* at this point if a ns is visible it is in a view ns
+		 * thus the curr ns.hname is a prefix of its name.
+		 * Only output the virtualized portion of the name
+		 * Add + 2 to skip over // separating curr hname prefix
+		 * from the visible tail of the views hname
+		 */
+		return view->base.hname + strlen(curr->base.hname) + 2;
+	}
+
+	return aa_hidden_ns_name;
+}
+
+/**
+ * alloc_namespace - allocate, initialize and return a new namespace
+ * @prefix: parent namespace name (MAYBE NULL)
+ * @name: a preallocated name  (NOT NULL)
+ *
+ * Returns: refcounted namespace or NULL on failure.
+ */
+static struct aa_namespace *alloc_namespace(const char *prefix,
+					    const char *name)
+{
+	struct aa_namespace *ns;
+
+	ns = kzalloc(sizeof(*ns), GFP_KERNEL);
+	AA_DEBUG("%s(%p)\n", __func__, ns);
+	if (!ns)
+		return NULL;
+	if (!aa_policy_init(&ns->base, prefix, name))
+		goto fail_ns;
+
+	INIT_LIST_HEAD(&ns->sub_ns);
+	mutex_init(&ns->lock);
+
+	/* released by free_namespace */
+	ns->unconfined = aa_alloc_profile("unconfined");
+	if (!ns->unconfined)
+		goto fail_unconfined;
+
+	ns->unconfined->flags = PFLAG_IX_ON_NAME_ERROR |
+		PFLAG_IMMUTABLE | PFLAG_NS_COUNT;
+	ns->unconfined->mode = APPARMOR_UNCONFINED;
+
+	/* ns and ns->unconfined share ns->unconfined refcount */
+	ns->unconfined->ns = ns;
+
+	atomic_set(&ns->uniq_null, 0);
+
+	return ns;
+
+fail_unconfined:
+	kzfree(ns->base.hname);
+fail_ns:
+	kzfree(ns);
+	return NULL;
+}
+
+/**
+ * aa_free_namespace - free a profile namespace
+ * @ns: the namespace to free  (MAYBE NULL)
+ *
+ * Requires: All references to the namespace must have been put, if the
+ *           namespace was referenced by a profile confining a task,
+ */
+void aa_free_namespace(struct aa_namespace *ns)
+{
+	if (!ns)
+		return;
+
+	aa_policy_destroy(&ns->base);
+	aa_put_namespace(ns->parent);
+
+	ns->unconfined->ns = NULL;
+	aa_free_profile(ns->unconfined);
+	kzfree(ns);
+}
+
+/**
+ * aa_find_namespace  -  look up a profile namespace on the namespace list
+ * @root: namespace to search in  (NOT NULL)
+ * @name: name of namespace to find  (NOT NULL)
+ *
+ * Returns: a refcounted namespace on the list, or NULL if no namespace
+ *          called @name exists.
+ *
+ * refcount released by caller
+ */
+struct aa_namespace *aa_find_namespace(struct aa_namespace *root,
+				       const char *name)
+{
+	struct aa_namespace *ns = NULL;
+
+	rcu_read_lock();
+	ns = aa_get_namespace(__aa_find_namespace(&root->sub_ns, name));
+	rcu_read_unlock();
+
+	return ns;
+}
+
+/**
+ * aa_prepare_namespace - find an existing or create a new namespace of @name
+ * @name: the namespace to find or add  (MAYBE NULL)
+ *
+ * Returns: refcounted namespace or NULL if failed to create one
+ */
+struct aa_namespace *aa_prepare_namespace(const char *name)
+{
+	struct aa_namespace *ns, *root;
+
+	root = aa_current_profile()->ns;
+
+	mutex_lock(&root->lock);
+
+	/* if name isn't specified the profile is loaded to the current ns */
+	if (!name) {
+		/* released by caller */
+		ns = aa_get_namespace(root);
+		goto out;
+	}
+
+	/* try and find the specified ns and if it doesn't exist create it */
+	/* released by caller */
+	ns = aa_get_namespace(__aa_find_namespace(&root->sub_ns, name));
+	if (!ns) {
+		ns = alloc_namespace(root->base.hname, name);
+		if (!ns)
+			goto out;
+		if (__aa_fs_namespace_mkdir(ns, ns_subns_dir(root), name)) {
+			AA_ERROR("Failed to create interface for ns %s\n",
+				 ns->base.name);
+			aa_free_namespace(ns);
+			ns = NULL;
+			goto out;
+		}
+		ns->parent = aa_get_namespace(root);
+		list_add_rcu(&ns->base.list, &root->sub_ns);
+		/* add list ref */
+		aa_get_namespace(ns);
+	}
+out:
+	mutex_unlock(&root->lock);
+
+	/* return ref */
+	return ns;
+}
+
+static void __ns_list_release(struct list_head *head);
+
+/**
+ * destroy_namespace - remove everything contained by @ns
+ * @ns: namespace to have it contents removed  (NOT NULL)
+ */
+static void destroy_namespace(struct aa_namespace *ns)
+{
+	if (!ns)
+		return;
+
+	mutex_lock(&ns->lock);
+	/* release all profiles in this namespace */
+	__aa_profile_list_release(&ns->base.profiles);
+
+	/* release all sub namespaces */
+	__ns_list_release(&ns->sub_ns);
+
+	if (ns->parent)
+		__aa_update_replacedby(ns->unconfined, ns->parent->unconfined);
+	__aa_fs_namespace_rmdir(ns);
+	mutex_unlock(&ns->lock);
+}
+
+/**
+ * __aa_remove_namespace - remove a namespace and all its children
+ * @ns: namespace to be removed  (NOT NULL)
+ *
+ * Requires: ns->parent->lock be held and ns removed from parent.
+ */
+void __aa_remove_namespace(struct aa_namespace *ns)
+{
+	/* remove ns from namespace list */
+	list_del_rcu(&ns->base.list);
+	destroy_namespace(ns);
+	aa_put_namespace(ns);
+}
+
+/**
+ * __ns_list_release - remove all profile namespaces on the list put refs
+ * @head: list of profile namespaces  (NOT NULL)
+ *
+ * Requires: namespace lock be held
+ */
+static void __ns_list_release(struct list_head *head)
+{
+	struct aa_namespace *ns, *tmp;
+
+	list_for_each_entry_safe(ns, tmp, head, base.list)
+		__aa_remove_namespace(ns);
+
+}
+
+/**
+ * aa_alloc_root_ns - allocate the root profile namespace
+ *
+ * Returns: %0 on success else error
+ *
+ */
+int __init aa_alloc_root_ns(void)
+{
+	/* released by aa_free_root_ns - used as list ref*/
+	root_ns = alloc_namespace(NULL, "root");
+	if (!root_ns)
+		return -ENOMEM;
+
+	return 0;
+}
+
+ /**
+  * aa_free_root_ns - free the root profile namespace
+  */
+void __init aa_free_root_ns(void)
+{
+	 struct aa_namespace *ns = root_ns;
+
+	 root_ns = NULL;
+
+	 destroy_namespace(ns);
+	 aa_put_namespace(ns);
+}
