commit fbd9acb2dc2aa55902c48a83f157082849209fba
Author: Jann Horn <jannh@google.com>
Date:   Thu Apr 11 13:11:54 2019 -0700

    LSM: SafeSetID: add read handler
    
    For debugging a running system, it is very helpful to be able to see what
    policy the system is using. Add a read handler that can dump out a copy of
    the loaded policy.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Micah Morton <mortonm@chromium.org>

diff --git a/security/safesetid/lsm.h b/security/safesetid/lsm.h
index 4a34f558d964..db6d16e6bbc3 100644
--- a/security/safesetid/lsm.h
+++ b/security/safesetid/lsm.h
@@ -41,6 +41,7 @@ struct setuid_rule {
 
 struct setuid_ruleset {
 	DECLARE_HASHTABLE(rules, SETID_HASH_BITS);
+	char *policy_str;
 	struct rcu_head rcu;
 };
 

commit 03638e62f55f27e7a96d6b1175e75b7a81e562b3
Author: Jann Horn <jannh@google.com>
Date:   Wed Apr 10 09:56:05 2019 -0700

    LSM: SafeSetID: rewrite userspace API to atomic updates
    
    The current API of the SafeSetID LSM uses one write() per rule, and applies
    each written rule instantly. This has several downsides:
    
     - While a policy is being loaded, once a single parent-child pair has been
       loaded, the parent is restricted to that specific child, even if
       subsequent rules would allow transitions to other child UIDs. This means
       that during policy loading, set*uid() can randomly fail.
     - To replace the policy without rebooting, it is necessary to first flush
       all old rules. This creates a time window in which no constraints are
       placed on the use of CAP_SETUID.
     - If we want to perform sanity checks on the final policy, this requires
       that the policy isn't constructed in a piecemeal fashion without telling
       the kernel when it's done.
    
    Other kernel APIs - including things like the userns code and netfilter -
    avoid this problem by performing updates atomically. Luckily, SafeSetID
    hasn't landed in a stable (upstream) release yet, so maybe it's not too
    late to completely change the API.
    
    The new API for SafeSetID is: If you want to change the policy, open
    "safesetid/whitelist_policy" and write the entire policy,
    newline-delimited, in there.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Micah Morton <mortonm@chromium.org>

diff --git a/security/safesetid/lsm.h b/security/safesetid/lsm.h
index 6806f902794c..4a34f558d964 100644
--- a/security/safesetid/lsm.h
+++ b/security/safesetid/lsm.h
@@ -21,12 +21,6 @@
 /* Flag indicating whether initialization completed */
 extern int safesetid_initialized;
 
-/* Function type. */
-enum safesetid_whitelist_file_write_type {
-	SAFESETID_WHITELIST_ADD, /* Add whitelist policy. */
-	SAFESETID_WHITELIST_FLUSH, /* Flush whitelist policies. */
-};
-
 enum sid_policy_type {
 	SIDPOL_DEFAULT, /* source ID is unaffected by policy */
 	SIDPOL_CONSTRAINED, /* source ID is affected by policy */
@@ -35,18 +29,24 @@ enum sid_policy_type {
 
 /*
  * Hash table entry to store safesetid policy signifying that 'src_uid'
- * can setid to 'dst_uid'.
+ * can setuid to 'dst_uid'.
  */
-struct entry {
+struct setuid_rule {
 	struct hlist_node next;
-	struct hlist_node dlist; /* for deletion cleanup */
 	kuid_t src_uid;
 	kuid_t dst_uid;
 };
 
-/* Add entry to safesetid whitelist to allow 'parent' to setid to 'child'. */
-int add_safesetid_whitelist_entry(kuid_t parent, kuid_t child);
+#define SETID_HASH_BITS 8 /* 256 buckets in hash table */
+
+struct setuid_ruleset {
+	DECLARE_HASHTABLE(rules, SETID_HASH_BITS);
+	struct rcu_head rcu;
+};
+
+enum sid_policy_type _setuid_policy_lookup(struct setuid_ruleset *policy,
+		kuid_t src, kuid_t dst);
 
-void flush_safesetid_whitelist_entries(void);
+extern struct setuid_ruleset __rcu *safesetid_setuid_rules;
 
 #endif /* _SAFESETID_H */

commit 1cd02a27a9473fed0294561137cfb7dcc9b3aaa0
Author: Jann Horn <jannh@google.com>
Date:   Wed Apr 10 09:55:34 2019 -0700

    LSM: SafeSetID: refactor policy hash table
    
    parent_kuid and child_kuid are kuids, there is no reason to make them
    uint64_t. (And anyway, in the kernel, the normal name for that would be
    u64, not uint64_t.)
    
    check_setuid_policy_hashtable_key() and
    check_setuid_policy_hashtable_key_value() are basically the same thing,
    merge them.
    
    Also fix the comment that claimed that (1<<8)==128.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Micah Morton <mortonm@chromium.org>

diff --git a/security/safesetid/lsm.h b/security/safesetid/lsm.h
index c1ea3c265fcf..6806f902794c 100644
--- a/security/safesetid/lsm.h
+++ b/security/safesetid/lsm.h
@@ -15,6 +15,8 @@
 #define _SAFESETID_H
 
 #include <linux/types.h>
+#include <linux/uidgid.h>
+#include <linux/hashtable.h>
 
 /* Flag indicating whether initialization completed */
 extern int safesetid_initialized;
@@ -25,6 +27,23 @@ enum safesetid_whitelist_file_write_type {
 	SAFESETID_WHITELIST_FLUSH, /* Flush whitelist policies. */
 };
 
+enum sid_policy_type {
+	SIDPOL_DEFAULT, /* source ID is unaffected by policy */
+	SIDPOL_CONSTRAINED, /* source ID is affected by policy */
+	SIDPOL_ALLOWED /* target ID explicitly allowed */
+};
+
+/*
+ * Hash table entry to store safesetid policy signifying that 'src_uid'
+ * can setid to 'dst_uid'.
+ */
+struct entry {
+	struct hlist_node next;
+	struct hlist_node dlist; /* for deletion cleanup */
+	kuid_t src_uid;
+	kuid_t dst_uid;
+};
+
 /* Add entry to safesetid whitelist to allow 'parent' to setid to 'child'. */
 int add_safesetid_whitelist_entry(kuid_t parent, kuid_t child);
 

commit aeca4e2ca65c1aeacfbe520684e6421719d99417
Author: Micah Morton <mortonm@chromium.org>
Date:   Wed Jan 16 07:46:06 2019 -0800

    LSM: add SafeSetID module that gates setid calls
    
    SafeSetID gates the setid family of syscalls to restrict UID/GID
    transitions from a given UID/GID to only those approved by a
    system-wide whitelist. These restrictions also prohibit the given
    UIDs/GIDs from obtaining auxiliary privileges associated with
    CAP_SET{U/G}ID, such as allowing a user to set up user namespace UID
    mappings. For now, only gating the set*uid family of syscalls is
    supported, with support for set*gid coming in a future patch set.
    
    Signed-off-by: Micah Morton <mortonm@chromium.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/safesetid/lsm.h b/security/safesetid/lsm.h
new file mode 100644
index 000000000000..c1ea3c265fcf
--- /dev/null
+++ b/security/safesetid/lsm.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * SafeSetID Linux Security Module
+ *
+ * Author: Micah Morton <mortonm@chromium.org>
+ *
+ * Copyright (C) 2018 The Chromium OS Authors.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _SAFESETID_H
+#define _SAFESETID_H
+
+#include <linux/types.h>
+
+/* Flag indicating whether initialization completed */
+extern int safesetid_initialized;
+
+/* Function type. */
+enum safesetid_whitelist_file_write_type {
+	SAFESETID_WHITELIST_ADD, /* Add whitelist policy. */
+	SAFESETID_WHITELIST_FLUSH, /* Flush whitelist policies. */
+};
+
+/* Add entry to safesetid whitelist to allow 'parent' to setid to 'child'. */
+int add_safesetid_whitelist_entry(kuid_t parent, kuid_t child);
+
+void flush_safesetid_whitelist_entries(void);
+
+#endif /* _SAFESETID_H */
