commit 59438b46471ae6cdfb761afc8c9beaf1e428a331
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Wed Nov 27 12:04:36 2019 -0500

    security,lockdown,selinux: implement SELinux lockdown
    
    Implement a SELinux hook for lockdown.  If the lockdown module is also
    enabled, then a denial by the lockdown module will take precedence over
    SELinux, so SELinux can only further restrict lockdown decisions.
    The SELinux hook only distinguishes at the granularity of integrity
    versus confidentiality similar to the lockdown module, but includes the
    full lockdown reason as part of the audit record as a hint in diagnosing
    what triggered the denial.  To support this auditing, move the
    lockdown_reasons[] string array from being private to the lockdown
    module to the security framework so that it can be used by the lsm audit
    code and so that it is always available even when the lockdown module
    is disabled.
    
    Note that the SELinux implementation allows the integrity and
    confidentiality reasons to be controlled independently from one another.
    Thus, in an SELinux policy, one could allow operations that specify
    an integrity reason while blocking operations that specify a
    confidentiality reason. The SELinux hook implementation is
    stricter than the lockdown module in validating the provided reason value.
    
    Sample AVC audit output from denials:
    avc:  denied  { integrity } for pid=3402 comm="fwupd"
     lockdown_reason="/dev/mem,kmem,port" scontext=system_u:system_r:fwupd_t:s0
     tcontext=system_u:system_r:fwupd_t:s0 tclass=lockdown permissive=0
    
    avc:  denied  { confidentiality } for pid=4628 comm="cp"
     lockdown_reason="/proc/kcore access"
     scontext=unconfined_u:unconfined_r:test_lockdown_integrity_t:s0-s0:c0.c1023
     tcontext=unconfined_u:unconfined_r:test_lockdown_integrity_t:s0-s0:c0.c1023
     tclass=lockdown permissive=0
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Reviewed-by: James Morris <jamorris@linux.microsoft.com>
    [PM: some merge fuzz do the the perf hooks]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index e40874373f2b..2d2bf49016f4 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -27,6 +27,7 @@
 #include <linux/dccp.h>
 #include <linux/sctp.h>
 #include <linux/lsm_audit.h>
+#include <linux/security.h>
 
 /**
  * ipv4_skb_to_auditdata : fill auditdata from skb
@@ -425,6 +426,10 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 				 a->u.ibendport->dev_name,
 				 a->u.ibendport->port);
 		break;
+	case LSM_AUDIT_DATA_LOCKDOWN:
+		audit_log_format(ab, " lockdown_reason=");
+		audit_log_string(ab, lockdown_reasons[a->u.reason]);
+		break;
 	} /* switch (a->type) */
 }
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 33028c098ef3..e40874373f2b 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * common LSM auditing functions
  *
@@ -5,10 +6,6 @@
  *			Stephen Smalley, <sds@tycho.nsa.gov>
  * 			James Morris <jmorris@redhat.com>
  * Author : Etienne Basset, <etienne.basset@ensta.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2,
- * as published by the Free Software Foundation.
  */
 
 #include <linux/types.h>

commit ae3b564179bfd06f32d051b9e5d72ce4b2a07c37
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 15 20:09:35 2019 +0000

    missing barriers in some of unix_sock ->addr and ->path accesses
    
    Several u->addr and u->path users are not holding any locks in
    common with unix_bind().  unix_state_lock() is useless for those
    purposes.
    
    u->addr is assign-once and *(u->addr) is fully set up by the time
    we set u->addr (all under unix_table_lock).  u->path is also
    set in the same critical area, also before setting u->addr, and
    any unix_sock with ->path filled will have non-NULL ->addr.
    
    So setting ->addr with smp_store_release() is all we need for those
    "lockless" users - just have them fetch ->addr with smp_load_acquire()
    and don't even bother looking at ->path if they see NULL ->addr.
    
    Users of ->addr and ->path fall into several classes now:
        1) ones that do smp_load_acquire(u->addr) and access *(u->addr)
    and u->path only if smp_load_acquire() has returned non-NULL.
        2) places holding unix_table_lock.  These are guaranteed that
    *(u->addr) is seen fully initialized.  If unix_sock is in one of the
    "bound" chains, so's ->path.
        3) unix_sock_destructor() using ->addr is safe.  All places
    that set u->addr are guaranteed to have seen all stores *(u->addr)
    while holding a reference to u and unix_sock_destructor() is called
    when (atomic) refcount hits zero.
        4) unix_release_sock() using ->path is safe.  unix_bind()
    is serialized wrt unix_release() (normally - by struct file
    refcount), and for the instances that had ->path set by unix_bind()
    unix_release_sock() comes from unix_release(), so they are fine.
    Instances that had it set in unix_stream_connect() either end up
    attached to a socket (in unix_accept()), in which case the call
    chain to unix_release_sock() and serialization are the same as in
    the previous case, or they never get accept'ed and unix_release_sock()
    is called when the listener is shut down and its queue gets purged.
    In that case the listener's queue lock provides the barriers needed -
    unix_stream_connect() shoves our unix_sock into listener's queue
    under that lock right after having set ->path and eventual
    unix_release_sock() caller picks them from that queue under the
    same lock right before calling unix_release_sock().
        5) unix_find_other() use of ->path is pointless, but safe -
    it happens with successful lookup by (abstract) name, so ->path.dentry
    is guaranteed to be NULL there.
    
    earlier-variant-reviewed-by: "Paul E. McKenney" <paulmck@linux.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index f84001019356..33028c098ef3 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -321,6 +321,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		if (a->u.net->sk) {
 			struct sock *sk = a->u.net->sk;
 			struct unix_sock *u;
+			struct unix_address *addr;
 			int len = 0;
 			char *p = NULL;
 
@@ -351,14 +352,15 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 #endif
 			case AF_UNIX:
 				u = unix_sk(sk);
+				addr = smp_load_acquire(&u->addr);
+				if (!addr)
+					break;
 				if (u->path.dentry) {
 					audit_log_d_path(ab, " path=", &u->path);
 					break;
 				}
-				if (!u->addr)
-					break;
-				len = u->addr->len-sizeof(short);
-				p = &u->addr->name->sun_path[0];
+				len = addr->len-sizeof(short);
+				p = &addr->name->sun_path[0];
 				audit_log_format(ab, " path=");
 				if (*p)
 					audit_log_untrustedstring(ab, p);

commit cdfb6b341f0f2409aba24b84f3b4b2bba50be5c5
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Sat May 12 21:58:20 2018 -0400

    audit: use inline function to get audit context
    
    Recognizing that the audit context is an internal audit value, use an
    access function to retrieve the audit context pointer for the task
    rather than reaching directly into the task struct to get it.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: merge fuzz in auditsc.c and selinuxfs.c, checkpatch.pl fixes]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 67703dbe29ea..f84001019356 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -447,7 +447,7 @@ void common_lsm_audit(struct common_audit_data *a,
 	if (a == NULL)
 		return;
 	/* we use GFP_ATOMIC so we won't sleep */
-	ab = audit_log_start(current->audit_context, GFP_ATOMIC | __GFP_NOWARN,
+	ab = audit_log_start(audit_context(), GFP_ATOMIC | __GFP_NOWARN,
 			     AUDIT_AVC);
 
 	if (ab == NULL)

commit 5d72801538eb59cfd9ca25d00aa439cfbc02ac9a
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Thu Aug 17 13:32:37 2017 -0400

    lsm_audit: update my email address
    
    Update my email address since epoch.ncsc.mil no longer exists.
    MAINTAINERS and CREDITS are already correct.
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 28d4c3a528ab..67703dbe29ea 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -2,7 +2,7 @@
  * common LSM auditing functions
  *
  * Based on code written for SELinux by :
- *			Stephen Smalley, <sds@epoch.ncsc.mil>
+ *			Stephen Smalley, <sds@tycho.nsa.gov>
  * 			James Morris <jmorris@redhat.com>
  * Author : Etienne Basset, <etienne.basset@ensta.org>
  *

commit ab861dfca1652aa09b26b7aa2899feb29b33dfd9
Author: Daniel Jurgens <danielj@mellanox.com>
Date:   Fri May 19 15:48:58 2017 +0300

    selinux: Add IB Port SMP access vector
    
    Add a type for Infiniband ports and an access vector for subnet
    management packets. Implement the ib_port_smp hook to check that the
    caller has permission to send and receive SMPs on the end port specified
    by the device name and port. Add interface to query the SID for a IB
    port, which walks the IB_PORT ocontexts to find an entry for the
    given name and port.
    
    Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>
    Acked-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index c22c99fae06a..28d4c3a528ab 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -421,6 +421,11 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 				 a->u.ibpkey->pkey, &sbn_pfx);
 		break;
 	}
+	case LSM_AUDIT_DATA_IBENDPORT:
+		audit_log_format(ab, " device=%s port_num=%u",
+				 a->u.ibendport->dev_name,
+				 a->u.ibendport->port);
+		break;
 	} /* switch (a->type) */
 }
 

commit cfc4d882d41780d93471066d57d4630995427b29
Author: Daniel Jurgens <danielj@mellanox.com>
Date:   Fri May 19 15:48:57 2017 +0300

    selinux: Implement Infiniband PKey "Access" access vector
    
    Add a type and access vector for PKeys. Implement the ib_pkey_access
    hook to check that the caller has permission to access the PKey on the
    given subnet prefix. Add an interface to get the PKey SID. Walk the PKey
    ocontexts to find an entry for the given subnet prefix and pkey.
    
    Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>
    Acked-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 37f04dadc8d6..c22c99fae06a 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -410,6 +410,17 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		audit_log_format(ab, " kmod=");
 		audit_log_untrustedstring(ab, a->u.kmod_name);
 		break;
+	case LSM_AUDIT_DATA_IBPKEY: {
+		struct in6_addr sbn_pfx;
+
+		memset(&sbn_pfx.s6_addr, 0,
+		       sizeof(sbn_pfx.s6_addr));
+		memcpy(&sbn_pfx.s6_addr, &a->u.ibpkey->subnet_prefix,
+		       sizeof(a->u.ibpkey->subnet_prefix));
+		audit_log_format(ab, " pkey=0x%x subnet_prefix=%pI6c",
+				 a->u.ibpkey->pkey, &sbn_pfx);
+		break;
+	}
 	} /* switch (a->type) */
 }
 

commit a3443cda5588985a2724d6d0f4a5f04e625be6eb
Merge: 3cd013ab79e8 1306d8e1c09f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 4 14:48:27 2016 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
    
      SELinux/LSM:
       - overlayfs support, necessary for container filesystems
    
      LSM:
       - finally remove the kernel_module_from_file hook
    
      Smack:
       - treat signal delivery as an 'append' operation
    
      TPM:
       - lots of bugfixes & updates
    
      Audit:
       - new audit data type: LSM_AUDIT_DATA_FILE
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (47 commits)
      Revert "tpm/tpm_crb: implement tpm crb idle state"
      Revert "tmp/tpm_crb: fix Intel PTT hw bug during idle state"
      Revert "tpm/tpm_crb: open code the crb_init into acpi_add"
      Revert "tmp/tpm_crb: implement runtime pm for tpm_crb"
      lsm,audit,selinux: Introduce a new audit data type LSM_AUDIT_DATA_FILE
      tmp/tpm_crb: implement runtime pm for tpm_crb
      tpm/tpm_crb: open code the crb_init into acpi_add
      tmp/tpm_crb: fix Intel PTT hw bug during idle state
      tpm/tpm_crb: implement tpm crb idle state
      tpm: add check for minimum buffer size in tpm_transmit()
      tpm: constify TPM 1.x header structures
      tpm/tpm_crb: fix the over 80 characters checkpatch warring
      tpm/tpm_crb: drop useless cpu_to_le32 when writing to registers
      tpm/tpm_crb: cache cmd_size register value.
      tmp/tpm_crb: drop include to platform_device
      tpm/tpm_tis: remove unused itpm variable
      tpm_crb: fix incorrect values of cmdReady and goIdle bits
      tpm_crb: refine the naming of constants
      tpm_crb: remove wmb()'s
      tpm_crb: fix crb_req_canceled behavior
      ...

commit 43af5de74288a7cdc3684902c5259346ae67adf8
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Fri Sep 9 11:37:49 2016 -0400

    lsm,audit,selinux: Introduce a new audit data type LSM_AUDIT_DATA_FILE
    
    Right now LSM_AUDIT_DATA_PATH type contains "struct path" in union "u"
    of common_audit_data. This information is used to print path of file
    at the same time it is also used to get to dentry and inode. And this
    inode information is used to get to superblock and device and print
    device information.
    
    This does not work well for layered filesystems like overlay where dentry
    contained in path is overlay dentry and not the real dentry of underlying
    file system. That means inode retrieved from dentry is also overlay
    inode and not the real inode.
    
    SELinux helpers like file_path_has_perm() are doing checks on inode
    retrieved from file_inode(). This returns the real inode and not the
    overlay inode. That means we are doing check on real inode but for audit
    purposes we are printing details of overlay inode and that can be
    confusing while debugging.
    
    Hence, introduce a new type LSM_AUDIT_DATA_FILE which carries file
    information and inode retrieved is real inode using file_inode(). That
    way right avc denied information is given to user.
    
    For example, following is one example avc before the patch.
    
      type=AVC msg=audit(1473360868.399:214): avc:  denied  { read open } for
        pid=1765 comm="cat"
        path="/root/.../overlay/container1/merged/readfile"
        dev="overlay" ino=21443
        scontext=unconfined_u:unconfined_r:test_overlay_client_t:s0:c10,c20
        tcontext=unconfined_u:object_r:test_overlay_files_ro_t:s0
        tclass=file permissive=0
    
    It looks as follows after the patch.
    
      type=AVC msg=audit(1473360017.388:282): avc:  denied  { read open } for
        pid=2530 comm="cat"
        path="/root/.../overlay/container1/merged/readfile"
        dev="dm-0" ino=2377915
        scontext=unconfined_u:unconfined_r:test_overlay_client_t:s0:c10,c20
        tcontext=unconfined_u:object_r:test_overlay_files_ro_t:s0
        tclass=file permissive=0
    
    Notice that now dev information points to "dm-0" device instead of
    "overlay" device. This makes it clear that check failed on underlying
    inode and not on the overlay inode.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    [PM: slight tweaks to the description to make checkpatch.pl happy]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 9bf851884800..8bfa3147fd54 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -245,6 +245,19 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		}
 		break;
 	}
+	case LSM_AUDIT_DATA_FILE: {
+		struct inode *inode;
+
+		audit_log_d_path(ab, " path=", &a->u.file->f_path);
+
+		inode = file_inode(a->u.file);
+		if (inode) {
+			audit_log_format(ab, " dev=");
+			audit_log_untrustedstring(ab, inode->i_sb->s_id);
+			audit_log_format(ab, " ino=%lu", inode->i_ino);
+		}
+		break;
+	}
 	case LSM_AUDIT_DATA_IOCTL_OP: {
 		struct inode *inode;
 

commit fa2bea2f5cca5b8d4a3e5520d2e8c0ede67ac108
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Aug 30 17:19:13 2016 -0400

    audit: consistently record PIDs with task_tgid_nr()
    
    Unfortunately we record PIDs in audit records using a variety of
    methods despite the correct way being the use of task_tgid_nr().
    This patch converts all of these callers, except for the case of
    AUDIT_SET in audit_receive_msg() (see the comment in the code).
    
    Reported-by: Jeff Vander Stoep <jeffv@google.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index cccbf3068cdc..45d927ab807d 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -220,7 +220,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	 */
 	BUILD_BUG_ON(sizeof(a->u) > sizeof(void *)*2);
 
-	audit_log_format(ab, " pid=%d comm=", task_pid_nr(current));
+	audit_log_format(ab, " pid=%d comm=", task_tgid_nr(current));
 	audit_log_untrustedstring(ab, memcpy(comm, current->comm, sizeof(comm)));
 
 	switch (a->type) {
@@ -294,7 +294,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	case LSM_AUDIT_DATA_TASK: {
 		struct task_struct *tsk = a->u.tsk;
 		if (tsk) {
-			pid_t pid = task_pid_nr(tsk);
+			pid_t pid = task_tgid_nr(tsk);
 			if (pid) {
 				char comm[sizeof(tsk->comm)];
 				audit_log_format(ab, " opid=%d ocomm=", pid);

commit 8b31f456c72e53ee97474a538bcd91bfb1b93fb7
Author: William Roberts <william.c.roberts@intel.com>
Date:   Mon Aug 8 13:08:34 2016 -0400

    selinux: print leading 0x on ioctlcmd audits
    
    ioctlcmd is currently printing hex numbers, but their is no leading
    0x. Thus things like ioctlcmd=1234 are misleading, as the base is
    not evident.
    
    Correct this by adding 0x as a prefix, so ioctlcmd=1234 becomes
    ioctlcmd=0x1234.
    
    Signed-off-by: William Roberts <william.c.roberts@intel.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 5369036cf905..9bf851884800 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -257,7 +257,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 			audit_log_format(ab, " ino=%lu", inode->i_ino);
 		}
 
-		audit_log_format(ab, " ioctlcmd=%hx", a->u.op->cmd);
+		audit_log_format(ab, " ioctlcmd=0x%hx", a->u.op->cmd);
 		break;
 	}
 	case LSM_AUDIT_DATA_DENTRY: {

commit 1a93a6eac32a2853177f10e274b9b761b42356eb
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Mon Aug 8 13:08:25 2016 -0400

    security: Use IS_ENABLED() instead of checking for built-in or module
    
    The IS_ENABLED() macro checks if a Kconfig symbol has been enabled
    either built-in or as a module, use that macro instead of open coding
    the same.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index cccbf3068cdc..5369036cf905 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -99,7 +99,7 @@ int ipv4_skb_to_auditdata(struct sk_buff *skb,
 	}
 	return ret;
 }
-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#if IS_ENABLED(CONFIG_IPV6)
 /**
  * ipv6_skb_to_auditdata : fill auditdata from skb
  * @skb : the skb

commit 3e5f206c00f73f535c914eedc8b91f424c5a14ab
Merge: 0e38c35815f5 fda4d578ed0a
Author: James Morris <james.l.morris@oracle.com>
Date:   Sat Aug 15 13:29:57 2015 +1000

    Merge branch 'next' of git://git.infradead.org/users/pcmoore/selinux into next

commit 671a2781ff01abf4fdc8904881fc3abd3a8279af
Author: Jeff Vander Stoep <jeffv@google.com>
Date:   Fri Jul 10 17:19:55 2015 -0400

    security: add ioctl specific auditing to lsm_audit
    
    Add information about ioctl calls to the LSM audit data. Log the
    file path and command number.
    
    Signed-off-by: Jeff Vander Stoep <jeffv@google.com>
    Acked-by: Nick Kralevich <nnk@google.com>
    [PM: subject line tweak]
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 1d34277dc402..9f6c649c65e9 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -245,6 +245,21 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		}
 		break;
 	}
+	case LSM_AUDIT_DATA_IOCTL_OP: {
+		struct inode *inode;
+
+		audit_log_d_path(ab, " path=", &a->u.op->path);
+
+		inode = a->u.op->path.dentry->d_inode;
+		if (inode) {
+			audit_log_format(ab, " dev=");
+			audit_log_untrustedstring(ab, inode->i_sb->s_id);
+			audit_log_format(ab, " ino=%lu", inode->i_ino);
+		}
+
+		audit_log_format(ab, " ioctlcmd=%hx", a->u.op->cmd);
+		break;
+	}
 	case LSM_AUDIT_DATA_DENTRY: {
 		struct inode *inode;
 

commit 4a10a91756ef381bced7b88cfb9232f660b92d93
Merge: e22619a29fcd 0b08c5e59441
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 27 13:53:16 2015 -0700

    Merge branch 'upstream' of git://git.infradead.org/users/pcmoore/audit
    
    Pull audit updates from Paul Moore:
     "Four small audit patches for v4.2, all bug fixes.  Only 10 lines of
      change this time so very unremarkable, the patch subject lines pretty
      much tell the whole story"
    
    * 'upstream' of git://git.infradead.org/users/pcmoore/audit:
      audit: Fix check of return value of strnlen_user()
      audit: obsolete audit_context check is removed in audit_filter_rules()
      audit: fix for typo in comment to function audit_log_link_denied()
      lsm: rename duplicate labels in LSM_AUDIT_DATA_TASK audit message type

commit 5c5bc97e2fc819112ece40e7d433039d6df8f7ba
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Apr 15 14:08:25 2015 -0400

    lsm: rename duplicate labels in LSM_AUDIT_DATA_TASK audit message type
    
    The LSM_AUDIT_DATA_TASK pid= and comm= labels are duplicates of those at the
    start of this function with different values.  Rename them to their object
    counterparts opid= and ocomm= to disambiguate.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: minor merging needed due to differences in the tree]
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 69fdf3bc765b..07fc99724d41 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -281,7 +281,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		if (tsk) {
 			pid_t pid = task_pid_nr(tsk);
 			if (pid) {
-				audit_log_format(ab, " pid=%d comm=", pid);
+				audit_log_format(ab, " opid=%d ocomm=", pid);
 				audit_log_untrustedstring(ab, tsk->comm);
 			}
 		}

commit 9ec3a646fe09970f801ab15e0f1694060b9f19af
Merge: c8b3fd0ce313 3cab989afd8d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 26 15:48:49 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull fourth vfs update from Al Viro:
     "d_inode() annotations from David Howells (sat in for-next since before
      the beginning of merge window) + four assorted fixes"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      RCU pathwalk breakage when running into a symlink overmounting something
      fix I_DIO_WAKEUP definition
      direct-io: only inc/dec inode->i_dio_count for file systems
      fs/9p: fix readdir()
      VFS: assorted d_backing_inode() annotations
      VFS: fs/inode.c helpers: d_inode() annotations
      VFS: fs/cachefiles: d_backing_inode() annotations
      VFS: fs library helpers: d_inode() annotations
      VFS: assorted weird filesystems: d_inode() annotations
      VFS: normal filesystems (and lustre): d_inode() annotations
      VFS: security/: d_inode() annotations
      VFS: security/: d_backing_inode() annotations
      VFS: net/: d_inode() annotations
      VFS: net/unix: d_backing_inode() annotations
      VFS: kernel/: d_inode() annotations
      VFS: audit: d_backing_inode() annotations
      VFS: Fix up some ->d_inode accesses in the chelsio driver
      VFS: Cachefiles should perform fs modifications on the top layer only
      VFS: AF_UNIX sockets should call mknod on the top layer only

commit c6f493d631c4d40cea5c36055f9148f547b200af
Author: David Howells <dhowells@redhat.com>
Date:   Tue Mar 17 22:26:22 2015 +0000

    VFS: security/: d_backing_inode() annotations
    
    most of the ->d_inode uses there refer to the same inode IO would
    go to, i.e. d_backing_inode()
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 69fdf3bc765b..3b27e9928238 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -237,7 +237,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 
 		audit_log_d_path(ab, " path=", &a->u.path);
 
-		inode = a->u.path.dentry->d_inode;
+		inode = d_backing_inode(a->u.path.dentry);
 		if (inode) {
 			audit_log_format(ab, " dev=");
 			audit_log_untrustedstring(ab, inode->i_sb->s_id);
@@ -251,7 +251,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		audit_log_format(ab, " name=");
 		audit_log_untrustedstring(ab, a->u.dentry->d_name.name);
 
-		inode = a->u.dentry->d_inode;
+		inode = d_backing_inode(a->u.dentry);
 		if (inode) {
 			audit_log_format(ab, " dev=");
 			audit_log_untrustedstring(ab, inode->i_sb->s_id);

commit 5deeb5cece3f9b30c8129786726b9d02c412c8ca
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Apr 14 11:01:02 2015 -0400

    lsm: copy comm before calling audit_log to avoid race in string printing
    
    When task->comm is passed directly to audit_log_untrustedstring() without
    getting a copy or using the task_lock, there is a race that could happen that
    would output a NULL (\0) in the middle of the output string that would
    effectively truncate the rest of the report text after the comm= field in the
    audit log message, losing fields.
    
    Using get_task_comm() to get a copy while acquiring the task_lock to prevent
    this and to prevent the result from being a mixture of old and new values of
    comm would incur potentially unacceptable overhead, considering that the value
    can be influenced by userspace and therefore untrusted anyways.
    
    Copy the value before passing it to audit_log_untrustedstring() ensures that a
    local copy is used to calculate the length *and* subsequently printed.  Even if
    this value contains a mix of old and new values, it will only calculate and
    copy up to the first NULL, preventing the rest of the audit log message being
    truncated.
    
    Use a second local copy of comm to avoid a race between the first and second
    calls to audit_log_untrustedstring() with comm.
    
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 69fdf3bc765b..b526ddc3add5 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -211,7 +211,7 @@ static inline void print_ipv4_addr(struct audit_buffer *ab, __be32 addr,
 static void dump_common_audit_data(struct audit_buffer *ab,
 				   struct common_audit_data *a)
 {
-	struct task_struct *tsk = current;
+	char comm[sizeof(current->comm)];
 
 	/*
 	 * To keep stack sizes in check force programers to notice if they
@@ -220,8 +220,8 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	 */
 	BUILD_BUG_ON(sizeof(a->u) > sizeof(void *)*2);
 
-	audit_log_format(ab, " pid=%d comm=", task_pid_nr(tsk));
-	audit_log_untrustedstring(ab, tsk->comm);
+	audit_log_format(ab, " pid=%d comm=", task_pid_nr(current));
+	audit_log_untrustedstring(ab, memcpy(comm, current->comm, sizeof(comm)));
 
 	switch (a->type) {
 	case LSM_AUDIT_DATA_NONE:
@@ -276,16 +276,19 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		audit_log_format(ab, " ino=%lu", inode->i_ino);
 		break;
 	}
-	case LSM_AUDIT_DATA_TASK:
-		tsk = a->u.tsk;
+	case LSM_AUDIT_DATA_TASK: {
+		struct task_struct *tsk = a->u.tsk;
 		if (tsk) {
 			pid_t pid = task_pid_nr(tsk);
 			if (pid) {
+				char comm[sizeof(tsk->comm)];
 				audit_log_format(ab, " pid=%d comm=", pid);
-				audit_log_untrustedstring(ab, tsk->comm);
+				audit_log_untrustedstring(ab,
+				    memcpy(comm, tsk->comm, sizeof(comm)));
 			}
 		}
 		break;
+	}
 	case LSM_AUDIT_DATA_NET:
 		if (a->u.net->sk) {
 			struct sock *sk = a->u.net->sk;

commit f1dc4867ff41b7bcca57fa19449d1fe7ad517ac1
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Dec 11 13:52:26 2013 -0500

    audit: anchor all pid references in the initial pid namespace
    
    Store and log all PIDs with reference to the initial PID namespace and
    use the access functions task_pid_nr() and task_tgid_nr() for task->pid
    and task->tgid.
    
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    (informed by ebiederman's c776b5d2)
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 9a62045e6282..69fdf3bc765b 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -220,7 +220,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	 */
 	BUILD_BUG_ON(sizeof(a->u) > sizeof(void *)*2);
 
-	audit_log_format(ab, " pid=%d comm=", tsk->pid);
+	audit_log_format(ab, " pid=%d comm=", task_pid_nr(tsk));
 	audit_log_untrustedstring(ab, tsk->comm);
 
 	switch (a->type) {
@@ -278,9 +278,12 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	}
 	case LSM_AUDIT_DATA_TASK:
 		tsk = a->u.tsk;
-		if (tsk && tsk->pid) {
-			audit_log_format(ab, " pid=%d comm=", tsk->pid);
-			audit_log_untrustedstring(ab, tsk->comm);
+		if (tsk) {
+			pid_t pid = task_pid_nr(tsk);
+			if (pid) {
+				audit_log_format(ab, " pid=%d comm=", pid);
+				audit_log_untrustedstring(ab, tsk->comm);
+			}
 		}
 		break;
 	case LSM_AUDIT_DATA_NET:

commit 3eaded86ac3e7f00fb3eeb8162d89e9a34e42fb0
Merge: 527d1511310a 9175c9d2aed5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 21 19:18:14 2013 -0800

    Merge git://git.infradead.org/users/eparis/audit
    
    Pull audit updates from Eric Paris:
     "Nothing amazing.  Formatting, small bug fixes, couple of fixes where
      we didn't get records due to some old VFS changes, and a change to how
      we collect execve info..."
    
    Fixed conflict in fs/exec.c as per Eric and linux-next.
    
    * git://git.infradead.org/users/eparis/audit: (28 commits)
      audit: fix type of sessionid in audit_set_loginuid()
      audit: call audit_bprm() only once to add AUDIT_EXECVE information
      audit: move audit_aux_data_execve contents into audit_context union
      audit: remove unused envc member of audit_aux_data_execve
      audit: Kill the unused struct audit_aux_data_capset
      audit: do not reject all AUDIT_INODE filter types
      audit: suppress stock memalloc failure warnings since already managed
      audit: log the audit_names record type
      audit: add child record before the create to handle case where create fails
      audit: use given values in tty_audit enable api
      audit: use nlmsg_len() to get message payload length
      audit: use memset instead of trying to initialize field by field
      audit: fix info leak in AUDIT_GET requests
      audit: update AUDIT_INODE filter rule to comparator function
      audit: audit feature to set loginuid immutable
      audit: audit feature to only allow unsetting the loginuid
      audit: allow unsetting the loginuid (with priv)
      audit: remove CONFIG_AUDIT_LOGINUID_IMMUTABLE
      audit: loginuid functions coding style
      selinux: apply selinux checks on new audit message types
      ...

commit a20b62bdf7a1ed1a334eff3c4cafa97f5826006b
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Oct 1 21:14:54 2013 -0400

    audit: suppress stock memalloc failure warnings since already managed
    
    Supress the stock memory allocation failure warnings for audit buffers
    since audit alreay takes care of memory allocation failure warnings, including
    rate-limiting, in audit_log_start().
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 8d8d97dbb389..b0f249d1a1ef 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -396,7 +396,8 @@ void common_lsm_audit(struct common_audit_data *a,
 	if (a == NULL)
 		return;
 	/* we use GFP_ATOMIC so we won't sleep */
-	ab = audit_log_start(current->audit_context, GFP_ATOMIC, AUDIT_AVC);
+	ab = audit_log_start(current->audit_context, GFP_ATOMIC | __GFP_NOWARN,
+			     AUDIT_AVC);
 
 	if (ab == NULL)
 		return;

commit c2bb06db59eaf92eb5ca9c6faed590597c6ceccb
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Oct 9 03:05:48 2013 -0700

    net: fix build errors if ipv6 is disabled
    
    CONFIG_IPV6=n is still a valid choice ;)
    
    It appears we can remove dead code.
    
    Reported-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 80554fcf9fcc..234bc2ab450c 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -302,6 +302,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 						"faddr", "fport");
 				break;
 			}
+#if IS_ENABLED(CONFIG_IPV6)
 			case AF_INET6: {
 				struct inet_sock *inet = inet_sk(sk);
 
@@ -313,6 +314,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 						"faddr", "fport");
 				break;
 			}
+#endif
 			case AF_UNIX:
 				u = unix_sk(sk);
 				if (u->path.dentry) {

commit efe4208f47f907b86f528788da711e8ab9dea44d
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Oct 3 15:42:29 2013 -0700

    ipv6: make lookups simpler and faster
    
    TCP listener refactoring, part 4 :
    
    To speed up inet lookups, we moved IPv4 addresses from inet to struct
    sock_common
    
    Now is time to do the same for IPv6, because it permits us to have fast
    lookups for all kind of sockets, including upcoming SYN_RECV.
    
    Getting IPv6 addresses in TCP lookups currently requires two extra cache
    lines, plus a dereference (and memory stall).
    
    inet6_sk(sk) does the dereference of inet_sk(__sk)->pinet6
    
    This patch is way bigger than its IPv4 counter part, because for IPv4,
    we could add aliases (inet_daddr, inet_rcv_saddr), while on IPv6,
    it's not doable easily.
    
    inet6_sk(sk)->daddr becomes sk->sk_v6_daddr
    inet6_sk(sk)->rcv_saddr becomes sk->sk_v6_rcv_saddr
    
    And timewait socket also have tw->tw_v6_daddr & tw->tw_v6_rcv_saddr
    at the same offset.
    
    We get rid of INET6_TW_MATCH() as INET6_MATCH() is now the generic
    macro.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 8d8d97dbb389..80554fcf9fcc 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -304,12 +304,11 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 			}
 			case AF_INET6: {
 				struct inet_sock *inet = inet_sk(sk);
-				struct ipv6_pinfo *inet6 = inet6_sk(sk);
 
-				print_ipv6_addr(ab, &inet6->rcv_saddr,
+				print_ipv6_addr(ab, &sk->sk_v6_rcv_saddr,
 						inet->inet_sport,
 						"laddr", "lport");
-				print_ipv6_addr(ab, &inet6->daddr,
+				print_ipv6_addr(ab, &sk->sk_v6_daddr,
 						inet->inet_dport,
 						"faddr", "fport");
 				break;

commit 07f62eb66c6626aa5653a0fcb34c9c040d0bd032
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 4 15:01:43 2012 -0400

    LSM: BUILD_BUG_ON if the common_audit_data union ever grows
    
    We did a lot of work to shrink the common_audit_data.  Add a BUILD_BUG_ON
    so future programers (let's be honest, probably me) won't do something
    foolish like make it large again!
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index e796d2517653..8d8d97dbb389 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -213,6 +213,13 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 {
 	struct task_struct *tsk = current;
 
+	/*
+	 * To keep stack sizes in check force programers to notice if they
+	 * start making this union too large!  See struct lsm_network_audit
+	 * as an example of how to deal with large data.
+	 */
+	BUILD_BUG_ON(sizeof(a->u) > sizeof(void *)*2);
+
 	audit_log_format(ab, " pid=%d comm=", tsk->pid);
 	audit_log_untrustedstring(ab, tsk->comm);
 

commit b466066f9b648ccb6aa1e174f0389b7433e460fd
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 4 15:01:43 2012 -0400

    LSM: remove the task field from common_audit_data
    
    There are no legitimate users.  Always use current and get back some stack
    space for the common_audit_data.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 90c129b0102f..e796d2517653 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -213,12 +213,8 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 {
 	struct task_struct *tsk = current;
 
-	if (a->tsk)
-		tsk = a->tsk;
-	if (tsk && tsk->pid) {
-		audit_log_format(ab, " pid=%d comm=", tsk->pid);
-		audit_log_untrustedstring(ab, tsk->comm);
-	}
+	audit_log_format(ab, " pid=%d comm=", tsk->pid);
+	audit_log_untrustedstring(ab, tsk->comm);
 
 	switch (a->type) {
 	case LSM_AUDIT_DATA_NONE:

commit b61c37f57988567c84359645f8202a7c84bc798a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 2 15:48:12 2012 -0700

    lsm_audit: don't specify the audit pre/post callbacks in 'struct common_audit_data'
    
    It just bloats the audit data structure for no good reason, since the
    only time those fields are filled are just before calling the
    common_lsm_audit() function, which is also the only user of those
    fields.
    
    So just make them be the arguments to common_lsm_audit(), rather than
    bloating that structure that is passed around everywhere, and is
    initialized in hot paths.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index e96c6aa17bb0..90c129b0102f 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -378,11 +378,15 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 /**
  * common_lsm_audit - generic LSM auditing function
  * @a:  auxiliary audit data
+ * @pre_audit: lsm-specific pre-audit callback
+ * @post_audit: lsm-specific post-audit callback
  *
  * setup the audit buffer for common security information
  * uses callback to print LSM specific information
  */
-void common_lsm_audit(struct common_audit_data *a)
+void common_lsm_audit(struct common_audit_data *a,
+	void (*pre_audit)(struct audit_buffer *, void *),
+	void (*post_audit)(struct audit_buffer *, void *))
 {
 	struct audit_buffer *ab;
 
@@ -394,13 +398,13 @@ void common_lsm_audit(struct common_audit_data *a)
 	if (ab == NULL)
 		return;
 
-	if (a->lsm_pre_audit)
-		a->lsm_pre_audit(ab, a);
+	if (pre_audit)
+		pre_audit(ab, a);
 
 	dump_common_audit_data(ab, a);
 
-	if (a->lsm_post_audit)
-		a->lsm_post_audit(ab, a);
+	if (post_audit)
+		post_audit(ab, a);
 
 	audit_log_end(ab);
 }

commit 48c62af68a403ef1655546bd3e021070c8508573
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Apr 2 13:15:44 2012 -0400

    LSM: shrink the common_audit_data data union
    
    After shrinking the common_audit_data stack usage for private LSM data I'm
    not going to shrink the data union.  To do this I'm going to move anything
    larger than 2 void * ptrs to it's own structure and require it to be declared
    separately on the calling stack.  Thus hot paths which don't need more than
    a couple pointer don't have to declare space to hold large unneeded
    structures.  I could get this down to one void * by dealing with the key
    struct and the struct path.  We'll see if that is helpful after taking care of
    networking.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 8b8f0902f6e5..e96c6aa17bb0 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -49,8 +49,8 @@ int ipv4_skb_to_auditdata(struct sk_buff *skb,
 	if (ih == NULL)
 		return -EINVAL;
 
-	ad->u.net.v4info.saddr = ih->saddr;
-	ad->u.net.v4info.daddr = ih->daddr;
+	ad->u.net->v4info.saddr = ih->saddr;
+	ad->u.net->v4info.daddr = ih->daddr;
 
 	if (proto)
 		*proto = ih->protocol;
@@ -64,8 +64,8 @@ int ipv4_skb_to_auditdata(struct sk_buff *skb,
 		if (th == NULL)
 			break;
 
-		ad->u.net.sport = th->source;
-		ad->u.net.dport = th->dest;
+		ad->u.net->sport = th->source;
+		ad->u.net->dport = th->dest;
 		break;
 	}
 	case IPPROTO_UDP: {
@@ -73,8 +73,8 @@ int ipv4_skb_to_auditdata(struct sk_buff *skb,
 		if (uh == NULL)
 			break;
 
-		ad->u.net.sport = uh->source;
-		ad->u.net.dport = uh->dest;
+		ad->u.net->sport = uh->source;
+		ad->u.net->dport = uh->dest;
 		break;
 	}
 	case IPPROTO_DCCP: {
@@ -82,16 +82,16 @@ int ipv4_skb_to_auditdata(struct sk_buff *skb,
 		if (dh == NULL)
 			break;
 
-		ad->u.net.sport = dh->dccph_sport;
-		ad->u.net.dport = dh->dccph_dport;
+		ad->u.net->sport = dh->dccph_sport;
+		ad->u.net->dport = dh->dccph_dport;
 		break;
 	}
 	case IPPROTO_SCTP: {
 		struct sctphdr *sh = sctp_hdr(skb);
 		if (sh == NULL)
 			break;
-		ad->u.net.sport = sh->source;
-		ad->u.net.dport = sh->dest;
+		ad->u.net->sport = sh->source;
+		ad->u.net->dport = sh->dest;
 		break;
 	}
 	default:
@@ -119,8 +119,8 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 	ip6 = ipv6_hdr(skb);
 	if (ip6 == NULL)
 		return -EINVAL;
-	ad->u.net.v6info.saddr = ip6->saddr;
-	ad->u.net.v6info.daddr = ip6->daddr;
+	ad->u.net->v6info.saddr = ip6->saddr;
+	ad->u.net->v6info.daddr = ip6->daddr;
 	ret = 0;
 	/* IPv6 can have several extension header before the Transport header
 	 * skip them */
@@ -140,8 +140,8 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 		if (th == NULL)
 			break;
 
-		ad->u.net.sport = th->source;
-		ad->u.net.dport = th->dest;
+		ad->u.net->sport = th->source;
+		ad->u.net->dport = th->dest;
 		break;
 	}
 	case IPPROTO_UDP: {
@@ -151,8 +151,8 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 		if (uh == NULL)
 			break;
 
-		ad->u.net.sport = uh->source;
-		ad->u.net.dport = uh->dest;
+		ad->u.net->sport = uh->source;
+		ad->u.net->dport = uh->dest;
 		break;
 	}
 	case IPPROTO_DCCP: {
@@ -162,8 +162,8 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 		if (dh == NULL)
 			break;
 
-		ad->u.net.sport = dh->dccph_sport;
-		ad->u.net.dport = dh->dccph_dport;
+		ad->u.net->sport = dh->dccph_sport;
+		ad->u.net->dport = dh->dccph_dport;
 		break;
 	}
 	case IPPROTO_SCTP: {
@@ -172,8 +172,8 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 		sh = skb_header_pointer(skb, offset, sizeof(_sctph), &_sctph);
 		if (sh == NULL)
 			break;
-		ad->u.net.sport = sh->source;
-		ad->u.net.dport = sh->dest;
+		ad->u.net->sport = sh->source;
+		ad->u.net->dport = sh->dest;
 		break;
 	}
 	default:
@@ -281,8 +281,8 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		}
 		break;
 	case LSM_AUDIT_DATA_NET:
-		if (a->u.net.sk) {
-			struct sock *sk = a->u.net.sk;
+		if (a->u.net->sk) {
+			struct sock *sk = a->u.net->sk;
 			struct unix_sock *u;
 			int len = 0;
 			char *p = NULL;
@@ -330,29 +330,29 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 			}
 		}
 
-		switch (a->u.net.family) {
+		switch (a->u.net->family) {
 		case AF_INET:
-			print_ipv4_addr(ab, a->u.net.v4info.saddr,
-					a->u.net.sport,
+			print_ipv4_addr(ab, a->u.net->v4info.saddr,
+					a->u.net->sport,
 					"saddr", "src");
-			print_ipv4_addr(ab, a->u.net.v4info.daddr,
-					a->u.net.dport,
+			print_ipv4_addr(ab, a->u.net->v4info.daddr,
+					a->u.net->dport,
 					"daddr", "dest");
 			break;
 		case AF_INET6:
-			print_ipv6_addr(ab, &a->u.net.v6info.saddr,
-					a->u.net.sport,
+			print_ipv6_addr(ab, &a->u.net->v6info.saddr,
+					a->u.net->sport,
 					"saddr", "src");
-			print_ipv6_addr(ab, &a->u.net.v6info.daddr,
-					a->u.net.dport,
+			print_ipv6_addr(ab, &a->u.net->v6info.daddr,
+					a->u.net->dport,
 					"daddr", "dest");
 			break;
 		}
-		if (a->u.net.netif > 0) {
+		if (a->u.net->netif > 0) {
 			struct net_device *dev;
 
 			/* NOTE: we always use init's namespace */
-			dev = dev_get_by_index(&init_net, a->u.net.netif);
+			dev = dev_get_by_index(&init_net, a->u.net->netif);
 			if (dev) {
 				audit_log_format(ab, " netif=%s", dev->name);
 				dev_put(dev);

commit 40ffe67d2e89c7a475421d007becc11a2f88ea3d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 14 21:54:32 2012 -0400

    switch unix_sock to struct path
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 293b8c45b1d1..8b8f0902f6e5 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -313,12 +313,8 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 			}
 			case AF_UNIX:
 				u = unix_sk(sk);
-				if (u->dentry) {
-					struct path path = {
-						.dentry = u->dentry,
-						.mnt = u->mnt
-					};
-					audit_log_d_path(ab, " path=", &path);
+				if (u->path.dentry) {
+					audit_log_d_path(ab, " path=", &u->path);
 					break;
 				}
 				if (!u->addr)

commit c158a35c8a681cf68d36f22f058f9f5466386c71
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Jan 6 14:07:10 2012 -0800

    audit: no leading space in audit_log_d_path prefix
    
    audit_log_d_path() injects an additional space before the prefix,
    which serves no purpose and doesn't mix well with other audit_log*()
    functions that do not sneak extra characters into the log.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index fc41b7cccb53..293b8c45b1d1 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -232,7 +232,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	case LSM_AUDIT_DATA_PATH: {
 		struct inode *inode;
 
-		audit_log_d_path(ab, "path=", &a->u.path);
+		audit_log_d_path(ab, " path=", &a->u.path);
 
 		inode = a->u.path.dentry->d_inode;
 		if (inode) {
@@ -318,7 +318,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 						.dentry = u->dentry,
 						.mnt = u->mnt
 					};
-					audit_log_d_path(ab, "path=", &path);
+					audit_log_d_path(ab, " path=", &path);
 					break;
 				}
 				if (!u->addr)

commit 41fdc3054e23e3229edea27053522fe052d02ec2
Author: Kees Cook <keescook@chromium.org>
Date:   Sat Jan 7 10:41:04 2012 -0800

    audit: treat s_id as an untrusted string
    
    The use of s_id should go through the untrusted string path, just to be
    extra careful.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 7bd6f138236b..fc41b7cccb53 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -235,10 +235,11 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		audit_log_d_path(ab, "path=", &a->u.path);
 
 		inode = a->u.path.dentry->d_inode;
-		if (inode)
-			audit_log_format(ab, " dev=%s ino=%lu",
-					inode->i_sb->s_id,
-					inode->i_ino);
+		if (inode) {
+			audit_log_format(ab, " dev=");
+			audit_log_untrustedstring(ab, inode->i_sb->s_id);
+			audit_log_format(ab, " ino=%lu", inode->i_ino);
+		}
 		break;
 	}
 	case LSM_AUDIT_DATA_DENTRY: {
@@ -248,10 +249,11 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		audit_log_untrustedstring(ab, a->u.dentry->d_name.name);
 
 		inode = a->u.dentry->d_inode;
-		if (inode)
-			audit_log_format(ab, " dev=%s ino=%lu",
-					inode->i_sb->s_id,
-					inode->i_ino);
+		if (inode) {
+			audit_log_format(ab, " dev=");
+			audit_log_untrustedstring(ab, inode->i_sb->s_id);
+			audit_log_format(ab, " ino=%lu", inode->i_ino);
+		}
 		break;
 	}
 	case LSM_AUDIT_DATA_INODE: {
@@ -266,8 +268,9 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 					 dentry->d_name.name);
 			dput(dentry);
 		}
-		audit_log_format(ab, " dev=%s ino=%lu", inode->i_sb->s_id,
-				 inode->i_ino);
+		audit_log_format(ab, " dev=");
+		audit_log_untrustedstring(ab, inode->i_sb->s_id);
+		audit_log_format(ab, " ino=%lu", inode->i_ino);
 		break;
 	}
 	case LSM_AUDIT_DATA_TASK:

commit 75f2811c6460ccc59d83c66059943ce9c9f81a18
Author: Jesse Gross <jesse@nicira.com>
Date:   Wed Nov 30 17:05:51 2011 -0800

    ipv6: Add fragment reporting to ipv6_skip_exthdr().
    
    While parsing through IPv6 extension headers, fragment headers are
    skipped making them invisible to the caller.  This reports the
    fragment offset of the last header in order to make it possible to
    determine whether the packet is fragmented and, if so whether it is
    a first or last fragment.
    
    Signed-off-by: Jesse Gross <jesse@nicira.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 199616bb68d3..7bd6f138236b 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -114,6 +114,7 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 	int offset, ret = 0;
 	struct ipv6hdr *ip6;
 	u8 nexthdr;
+	__be16 frag_off;
 
 	ip6 = ipv6_hdr(skb);
 	if (ip6 == NULL)
@@ -126,7 +127,7 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 	offset = skb_network_offset(skb);
 	offset += sizeof(*ip6);
 	nexthdr = ip6->nexthdr;
-	offset = ipv6_skip_exthdr(skb, offset, &nexthdr);
+	offset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);
 	if (offset < 0)
 		return 0;
 	if (proto)

commit 4e3fd7a06dc20b2d8ec6892233ad2012968fe7b6
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Nov 21 03:39:03 2011 +0000

    net: remove ipv6_addr_copy()
    
    C assignment can handle struct in6_addr copying.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 893af8a2fa1e..199616bb68d3 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -118,8 +118,8 @@ int ipv6_skb_to_auditdata(struct sk_buff *skb,
 	ip6 = ipv6_hdr(skb);
 	if (ip6 == NULL)
 		return -EINVAL;
-	ipv6_addr_copy(&ad->u.net.v6info.saddr, &ip6->saddr);
-	ipv6_addr_copy(&ad->u.net.v6info.daddr, &ip6->daddr);
+	ad->u.net.v6info.saddr = ip6->saddr;
+	ad->u.net.v6info.daddr = ip6->daddr;
 	ret = 0;
 	/* IPv6 can have several extension header before the Transport header
 	 * skip them */

commit a269434d2fb48a4d66c1d7bf821b7874b59c5b41
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Apr 25 13:10:27 2011 -0400

    LSM: separate LSM_AUDIT_DATA_DENTRY from LSM_AUDIT_DATA_PATH
    
    This patch separates and audit message that only contains a dentry from
    one that contains a full path.  This allows us to make it harder to
    misuse the interfaces or for the interfaces to be implemented wrong.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 2e846052cbf4..893af8a2fa1e 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -229,17 +229,24 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		audit_log_format(ab, " capability=%d ", a->u.cap);
 		break;
 	case LSM_AUDIT_DATA_PATH: {
-		struct dentry *dentry = a->u.path.dentry;
 		struct inode *inode;
 
-		if (a->u.path.mnt) {
-			audit_log_d_path(ab, "path=", &a->u.path);
-		} else {
-			audit_log_format(ab, " name=");
-			audit_log_untrustedstring(ab,
-					 dentry->d_name.name);
-		}
-		inode = dentry->d_inode;
+		audit_log_d_path(ab, "path=", &a->u.path);
+
+		inode = a->u.path.dentry->d_inode;
+		if (inode)
+			audit_log_format(ab, " dev=%s ino=%lu",
+					inode->i_sb->s_id,
+					inode->i_ino);
+		break;
+	}
+	case LSM_AUDIT_DATA_DENTRY: {
+		struct inode *inode;
+
+		audit_log_format(ab, " name=");
+		audit_log_untrustedstring(ab, a->u.dentry->d_name.name);
+
+		inode = a->u.dentry->d_inode;
 		if (inode)
 			audit_log_format(ab, " dev=%s ino=%lu",
 					inode->i_sb->s_id,

commit f48b7399840b453e7282b523f535561fe9638a2d
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Apr 25 12:54:27 2011 -0400

    LSM: split LSM_AUDIT_DATA_FS into _PATH and _INODE
    
    The lsm common audit code has wacky contortions making sure which pieces
    of information are set based on if it was given a path, dentry, or
    inode.  Split this into path and inode to get rid of some of the code
    complexity.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 908aa712816a..2e846052cbf4 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -210,7 +210,6 @@ static inline void print_ipv4_addr(struct audit_buffer *ab, __be32 addr,
 static void dump_common_audit_data(struct audit_buffer *ab,
 				   struct common_audit_data *a)
 {
-	struct inode *inode = NULL;
 	struct task_struct *tsk = current;
 
 	if (a->tsk)
@@ -229,33 +228,40 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	case LSM_AUDIT_DATA_CAP:
 		audit_log_format(ab, " capability=%d ", a->u.cap);
 		break;
-	case LSM_AUDIT_DATA_FS:
-		if (a->u.fs.path.dentry) {
-			struct dentry *dentry = a->u.fs.path.dentry;
-			if (a->u.fs.path.mnt) {
-				audit_log_d_path(ab, "path=", &a->u.fs.path);
-			} else {
-				audit_log_format(ab, " name=");
-				audit_log_untrustedstring(ab,
-						 dentry->d_name.name);
-			}
-			inode = dentry->d_inode;
-		} else if (a->u.fs.inode) {
-			struct dentry *dentry;
-			inode = a->u.fs.inode;
-			dentry = d_find_alias(inode);
-			if (dentry) {
-				audit_log_format(ab, " name=");
-				audit_log_untrustedstring(ab,
-						 dentry->d_name.name);
-				dput(dentry);
-			}
+	case LSM_AUDIT_DATA_PATH: {
+		struct dentry *dentry = a->u.path.dentry;
+		struct inode *inode;
+
+		if (a->u.path.mnt) {
+			audit_log_d_path(ab, "path=", &a->u.path);
+		} else {
+			audit_log_format(ab, " name=");
+			audit_log_untrustedstring(ab,
+					 dentry->d_name.name);
 		}
+		inode = dentry->d_inode;
 		if (inode)
 			audit_log_format(ab, " dev=%s ino=%lu",
 					inode->i_sb->s_id,
 					inode->i_ino);
 		break;
+	}
+	case LSM_AUDIT_DATA_INODE: {
+		struct dentry *dentry;
+		struct inode *inode;
+
+		inode = a->u.inode;
+		dentry = d_find_alias(inode);
+		if (dentry) {
+			audit_log_format(ab, " name=");
+			audit_log_untrustedstring(ab,
+					 dentry->d_name.name);
+			dput(dentry);
+		}
+		audit_log_format(ab, " dev=%s ino=%lu", inode->i_sb->s_id,
+				 inode->i_ino);
+		break;
+	}
 	case LSM_AUDIT_DATA_TASK:
 		tsk = a->u.tsk;
 		if (tsk && tsk->pid) {

commit 0ffbe2699cda6afbe08501098dff8a8c2fe6ae09
Merge: 4e5d6f7ec383 7ebd467551ed
Author: James Morris <jmorris@namei.org>
Date:   Thu May 6 10:56:07 2010 +1000

    Merge branch 'master' into next

commit cb84aa9b42b506299e5aea1ba4da26c03ab12877
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Apr 27 17:20:38 2010 -0400

    LSM Audit: rename LSM_AUDIT_NO_AUDIT to LSM_AUDIT_DATA_NONE
    
    Most of the LSM common audit work uses LSM_AUDIT_DATA_* for the naming.
    This was not so for LSM_AUDIT_NO_AUDIT which means the generic initializer
    cannot be used.  This patch just renames the flag so the generic
    initializer can be used.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index acba3dfc8d29..8c3650672e23 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -220,7 +220,7 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	}
 
 	switch (a->type) {
-	case LSM_AUDIT_NO_AUDIT:
+	case LSM_AUDIT_DATA_NONE:
 		return;
 	case LSM_AUDIT_DATA_IPC:
 		audit_log_format(ab, " key=%d ", a->u.ipc_id);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index acba3dfc8d29..893365b79a29 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -14,6 +14,7 @@
 #include <linux/types.h>
 #include <linux/stddef.h>
 #include <linux/kernel.h>
+#include <linux/gfp.h>
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <net/sock.h>

commit 28b4d5cc17c20786848cdc07b7ea237a309776bb
Merge: d29cecda036f 96fa2b508d2d
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Dec 5 15:22:26 2009 -0800

    Merge branch 'master' of /home/davem/src/GIT/linux-2.6/
    
    Conflicts:
            drivers/net/pcmcia/fmvj18x_cs.c
            drivers/net/pcmcia/nmclan_cs.c
            drivers/net/pcmcia/xirc2ps_cs.c
            drivers/net/wireless/ray_cs.c

commit dd8dbf2e6880e30c00b18600c962d0cb5a03c555
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Nov 3 16:35:32 2009 +1100

    security: report the module name to security_module_request
    
    For SELinux to do better filtering in userspace we send the name of the
    module along with the AVC denial when a program is denied module_request.
    
    Example output:
    
    type=SYSCALL msg=audit(11/03/2009 10:59:43.510:9) : arch=x86_64 syscall=write success=yes exit=2 a0=3 a1=7fc28c0d56c0 a2=2 a3=7fffca0d7440 items=0 ppid=1727 pid=1729 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=rpc.nfsd exe=/usr/sbin/rpc.nfsd subj=system_u:system_r:nfsd_t:s0 key=(null)
    type=AVC msg=audit(11/03/2009 10:59:43.510:9) : avc:  denied  { module_request } for  pid=1729 comm=rpc.nfsd kmod="net-pf-10" scontext=system_u:system_r:nfsd_t:s0 tcontext=system_u:system_r:kernel_t:s0 tclass=system
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 3bb90b6f1dd3..51bd0fd9c9f0 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -354,6 +354,10 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 		}
 		break;
 #endif
+	case LSM_AUDIT_DATA_KMOD:
+		audit_log_format(ab, " kmod=");
+		audit_log_untrustedstring(ab, a->u.kmod_name);
+		break;
 	} /* switch (a->type) */
 }
 

commit c720c7e8383aff1cb219bddf474ed89d850336e3
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Oct 15 06:30:45 2009 +0000

    inet: rename some inet_sock fields
    
    In order to have better cache layouts of struct sock (separate zones
    for rx/tx paths), we need this preliminary patch.
    
    Goal is to transfert fields used at lookup time in the first
    read-mostly cache line (inside struct sock_common) and move sk_refcnt
    to a separate cache line (only written by rx path)
    
    This patch adds inet_ prefix to daddr, rcv_saddr, dport, num, saddr,
    sport and id fields. This allows a future patch to define these
    fields as macros, like sk_refcnt, without name clashes.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 3bb90b6f1dd3..e04566a2c4e5 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -273,11 +273,11 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 			case AF_INET: {
 				struct inet_sock *inet = inet_sk(sk);
 
-				print_ipv4_addr(ab, inet->rcv_saddr,
-						inet->sport,
+				print_ipv4_addr(ab, inet->inet_rcv_saddr,
+						inet->inet_sport,
 						"laddr", "lport");
-				print_ipv4_addr(ab, inet->daddr,
-						inet->dport,
+				print_ipv4_addr(ab, inet->inet_daddr,
+						inet->inet_dport,
 						"faddr", "fport");
 				break;
 			}
@@ -286,10 +286,10 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 				struct ipv6_pinfo *inet6 = inet6_sk(sk);
 
 				print_ipv6_addr(ab, &inet6->rcv_saddr,
-						inet->sport,
+						inet->inet_sport,
 						"laddr", "lport");
 				print_ipv6_addr(ab, &inet6->daddr,
-						inet->dport,
+						inet->inet_dport,
 						"faddr", "fport");
 				break;
 			}

commit d81165919ebf6e1cb9eeb612150f9287ad414659
Author: Paul Moore <paul.moore@hp.com>
Date:   Wed Sep 23 13:46:00 2009 -0400

    lsm: Use a compressed IPv6 string format in audit events
    
    Currently the audit subsystem prints uncompressed IPv6 addresses which not
    only differs from common usage but also results in ridiculously large audit
    strings which is not a good thing.  This patch fixes this by simply converting
    audit to always print compressed IPv6 addresses.
    
    Old message example:
    
     audit(1253576792.161:30): avc:  denied  { ingress } for
      saddr=0000:0000:0000:0000:0000:0000:0000:0001 src=5000
      daddr=0000:0000:0000:0000:0000:0000:0000:0001 dest=35502 netif=lo
      scontext=system_u:object_r:unlabeled_t:s15:c0.c1023
      tcontext=system_u:object_r:lo_netif_t:s0-s15:c0.c1023 tclass=netif
    
    New message example:
    
     audit(1253576792.161:30): avc:  denied  { ingress } for
      saddr=::1 src=5000 daddr=::1 dest=35502 netif=lo
      scontext=system_u:object_r:unlabeled_t:s15:c0.c1023
      tcontext=system_u:object_r:lo_netif_t:s0-s15:c0.c1023 tclass=netif
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 500aad0ebd6a..3bb90b6f1dd3 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -187,7 +187,7 @@ static inline void print_ipv6_addr(struct audit_buffer *ab,
 				   char *name1, char *name2)
 {
 	if (!ipv6_addr_any(addr))
-		audit_log_format(ab, " %s=%pI6", name1, addr);
+		audit_log_format(ab, " %s=%pI6c", name1, addr);
 	if (port)
 		audit_log_format(ab, " %s=%d", name2, ntohs(port));
 }

commit 2bf49690325b62480a42f7afed5e9f164173c570
Author: Thomas Liu <tliu@redhat.com>
Date:   Tue Jul 14 12:14:09 2009 -0400

    SELinux: Convert avc_audit to use lsm_audit.h
    
    Convert avc_audit in security/selinux/avc.c to use lsm_audit.h,
    for better maintainability.
    
     - changed selinux to use common_audit_data instead of
        avc_audit_data
     - eliminated code in avc.c and used code from lsm_audit.h instead.
    
    Had to add a LSM_AUDIT_NO_AUDIT to lsm_audit.h so that avc_audit
    can call common_lsm_audit and do the pre and post callbacks without
    doing the actual dump.  This makes it so that the patched version
    behaves the same way as the unpatched version.
    
    Also added a denied field to the selinux_audit_data private space,
    once again to make it so that the patched version behaves like the
    unpatched.
    
    I've tested and confirmed that AVCs look the same before and after
    this patch.
    
    Signed-off-by: Thomas Liu <tliu@redhat.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 94b868494b31..500aad0ebd6a 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -220,6 +220,8 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	}
 
 	switch (a->type) {
+	case LSM_AUDIT_NO_AUDIT:
+		return;
 	case LSM_AUDIT_DATA_IPC:
 		audit_log_format(ab, " key=%d ", a->u.ipc_id);
 		break;

commit 6e837fb152410e571a81aaadbd9884f0bc46a55e
Author: Etienne Basset <etienne.basset@numericable.fr>
Date:   Wed Apr 8 20:39:40 2009 +0200

    smack: implement logging V3
    
    This patch creates auditing functions usable by LSM to audit security
    events. It provides standard dumping of FS, NET, task etc ... events
    (code borrowed from SELinux)
    and provides 2 callbacks to define LSM specific auditing, which should be
    flexible enough to convert SELinux too.
    
    Signed-off-by: Etienne Basset <etienne.basset@numericable.fr>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    cked-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/lsm_audit.c b/security/lsm_audit.c
new file mode 100644
index 000000000000..94b868494b31
--- /dev/null
+++ b/security/lsm_audit.c
@@ -0,0 +1,386 @@
+/*
+ * common LSM auditing functions
+ *
+ * Based on code written for SELinux by :
+ *			Stephen Smalley, <sds@epoch.ncsc.mil>
+ * 			James Morris <jmorris@redhat.com>
+ * Author : Etienne Basset, <etienne.basset@ensta.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2,
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <net/sock.h>
+#include <linux/un.h>
+#include <net/af_unix.h>
+#include <linux/audit.h>
+#include <linux/ipv6.h>
+#include <linux/ip.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/dccp.h>
+#include <linux/sctp.h>
+#include <linux/lsm_audit.h>
+
+/**
+ * ipv4_skb_to_auditdata : fill auditdata from skb
+ * @skb : the skb
+ * @ad : the audit data to fill
+ * @proto : the layer 4 protocol
+ *
+ * return  0 on success
+ */
+int ipv4_skb_to_auditdata(struct sk_buff *skb,
+		struct common_audit_data *ad, u8 *proto)
+{
+	int ret = 0;
+	struct iphdr *ih;
+
+	ih = ip_hdr(skb);
+	if (ih == NULL)
+		return -EINVAL;
+
+	ad->u.net.v4info.saddr = ih->saddr;
+	ad->u.net.v4info.daddr = ih->daddr;
+
+	if (proto)
+		*proto = ih->protocol;
+	/* non initial fragment */
+	if (ntohs(ih->frag_off) & IP_OFFSET)
+		return 0;
+
+	switch (ih->protocol) {
+	case IPPROTO_TCP: {
+		struct tcphdr *th = tcp_hdr(skb);
+		if (th == NULL)
+			break;
+
+		ad->u.net.sport = th->source;
+		ad->u.net.dport = th->dest;
+		break;
+	}
+	case IPPROTO_UDP: {
+		struct udphdr *uh = udp_hdr(skb);
+		if (uh == NULL)
+			break;
+
+		ad->u.net.sport = uh->source;
+		ad->u.net.dport = uh->dest;
+		break;
+	}
+	case IPPROTO_DCCP: {
+		struct dccp_hdr *dh = dccp_hdr(skb);
+		if (dh == NULL)
+			break;
+
+		ad->u.net.sport = dh->dccph_sport;
+		ad->u.net.dport = dh->dccph_dport;
+		break;
+	}
+	case IPPROTO_SCTP: {
+		struct sctphdr *sh = sctp_hdr(skb);
+		if (sh == NULL)
+			break;
+		ad->u.net.sport = sh->source;
+		ad->u.net.dport = sh->dest;
+		break;
+	}
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+/**
+ * ipv6_skb_to_auditdata : fill auditdata from skb
+ * @skb : the skb
+ * @ad : the audit data to fill
+ * @proto : the layer 4 protocol
+ *
+ * return  0 on success
+ */
+int ipv6_skb_to_auditdata(struct sk_buff *skb,
+		struct common_audit_data *ad, u8 *proto)
+{
+	int offset, ret = 0;
+	struct ipv6hdr *ip6;
+	u8 nexthdr;
+
+	ip6 = ipv6_hdr(skb);
+	if (ip6 == NULL)
+		return -EINVAL;
+	ipv6_addr_copy(&ad->u.net.v6info.saddr, &ip6->saddr);
+	ipv6_addr_copy(&ad->u.net.v6info.daddr, &ip6->daddr);
+	ret = 0;
+	/* IPv6 can have several extension header before the Transport header
+	 * skip them */
+	offset = skb_network_offset(skb);
+	offset += sizeof(*ip6);
+	nexthdr = ip6->nexthdr;
+	offset = ipv6_skip_exthdr(skb, offset, &nexthdr);
+	if (offset < 0)
+		return 0;
+	if (proto)
+		*proto = nexthdr;
+	switch (nexthdr) {
+	case IPPROTO_TCP: {
+		struct tcphdr _tcph, *th;
+
+		th = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);
+		if (th == NULL)
+			break;
+
+		ad->u.net.sport = th->source;
+		ad->u.net.dport = th->dest;
+		break;
+	}
+	case IPPROTO_UDP: {
+		struct udphdr _udph, *uh;
+
+		uh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);
+		if (uh == NULL)
+			break;
+
+		ad->u.net.sport = uh->source;
+		ad->u.net.dport = uh->dest;
+		break;
+	}
+	case IPPROTO_DCCP: {
+		struct dccp_hdr _dccph, *dh;
+
+		dh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);
+		if (dh == NULL)
+			break;
+
+		ad->u.net.sport = dh->dccph_sport;
+		ad->u.net.dport = dh->dccph_dport;
+		break;
+	}
+	case IPPROTO_SCTP: {
+		struct sctphdr _sctph, *sh;
+
+		sh = skb_header_pointer(skb, offset, sizeof(_sctph), &_sctph);
+		if (sh == NULL)
+			break;
+		ad->u.net.sport = sh->source;
+		ad->u.net.dport = sh->dest;
+		break;
+	}
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+#endif
+
+
+static inline void print_ipv6_addr(struct audit_buffer *ab,
+				   struct in6_addr *addr, __be16 port,
+				   char *name1, char *name2)
+{
+	if (!ipv6_addr_any(addr))
+		audit_log_format(ab, " %s=%pI6", name1, addr);
+	if (port)
+		audit_log_format(ab, " %s=%d", name2, ntohs(port));
+}
+
+static inline void print_ipv4_addr(struct audit_buffer *ab, __be32 addr,
+				   __be16 port, char *name1, char *name2)
+{
+	if (addr)
+		audit_log_format(ab, " %s=%pI4", name1, &addr);
+	if (port)
+		audit_log_format(ab, " %s=%d", name2, ntohs(port));
+}
+
+/**
+ * dump_common_audit_data - helper to dump common audit data
+ * @a : common audit data
+ *
+ */
+static void dump_common_audit_data(struct audit_buffer *ab,
+				   struct common_audit_data *a)
+{
+	struct inode *inode = NULL;
+	struct task_struct *tsk = current;
+
+	if (a->tsk)
+		tsk = a->tsk;
+	if (tsk && tsk->pid) {
+		audit_log_format(ab, " pid=%d comm=", tsk->pid);
+		audit_log_untrustedstring(ab, tsk->comm);
+	}
+
+	switch (a->type) {
+	case LSM_AUDIT_DATA_IPC:
+		audit_log_format(ab, " key=%d ", a->u.ipc_id);
+		break;
+	case LSM_AUDIT_DATA_CAP:
+		audit_log_format(ab, " capability=%d ", a->u.cap);
+		break;
+	case LSM_AUDIT_DATA_FS:
+		if (a->u.fs.path.dentry) {
+			struct dentry *dentry = a->u.fs.path.dentry;
+			if (a->u.fs.path.mnt) {
+				audit_log_d_path(ab, "path=", &a->u.fs.path);
+			} else {
+				audit_log_format(ab, " name=");
+				audit_log_untrustedstring(ab,
+						 dentry->d_name.name);
+			}
+			inode = dentry->d_inode;
+		} else if (a->u.fs.inode) {
+			struct dentry *dentry;
+			inode = a->u.fs.inode;
+			dentry = d_find_alias(inode);
+			if (dentry) {
+				audit_log_format(ab, " name=");
+				audit_log_untrustedstring(ab,
+						 dentry->d_name.name);
+				dput(dentry);
+			}
+		}
+		if (inode)
+			audit_log_format(ab, " dev=%s ino=%lu",
+					inode->i_sb->s_id,
+					inode->i_ino);
+		break;
+	case LSM_AUDIT_DATA_TASK:
+		tsk = a->u.tsk;
+		if (tsk && tsk->pid) {
+			audit_log_format(ab, " pid=%d comm=", tsk->pid);
+			audit_log_untrustedstring(ab, tsk->comm);
+		}
+		break;
+	case LSM_AUDIT_DATA_NET:
+		if (a->u.net.sk) {
+			struct sock *sk = a->u.net.sk;
+			struct unix_sock *u;
+			int len = 0;
+			char *p = NULL;
+
+			switch (sk->sk_family) {
+			case AF_INET: {
+				struct inet_sock *inet = inet_sk(sk);
+
+				print_ipv4_addr(ab, inet->rcv_saddr,
+						inet->sport,
+						"laddr", "lport");
+				print_ipv4_addr(ab, inet->daddr,
+						inet->dport,
+						"faddr", "fport");
+				break;
+			}
+			case AF_INET6: {
+				struct inet_sock *inet = inet_sk(sk);
+				struct ipv6_pinfo *inet6 = inet6_sk(sk);
+
+				print_ipv6_addr(ab, &inet6->rcv_saddr,
+						inet->sport,
+						"laddr", "lport");
+				print_ipv6_addr(ab, &inet6->daddr,
+						inet->dport,
+						"faddr", "fport");
+				break;
+			}
+			case AF_UNIX:
+				u = unix_sk(sk);
+				if (u->dentry) {
+					struct path path = {
+						.dentry = u->dentry,
+						.mnt = u->mnt
+					};
+					audit_log_d_path(ab, "path=", &path);
+					break;
+				}
+				if (!u->addr)
+					break;
+				len = u->addr->len-sizeof(short);
+				p = &u->addr->name->sun_path[0];
+				audit_log_format(ab, " path=");
+				if (*p)
+					audit_log_untrustedstring(ab, p);
+				else
+					audit_log_n_hex(ab, p, len);
+				break;
+			}
+		}
+
+		switch (a->u.net.family) {
+		case AF_INET:
+			print_ipv4_addr(ab, a->u.net.v4info.saddr,
+					a->u.net.sport,
+					"saddr", "src");
+			print_ipv4_addr(ab, a->u.net.v4info.daddr,
+					a->u.net.dport,
+					"daddr", "dest");
+			break;
+		case AF_INET6:
+			print_ipv6_addr(ab, &a->u.net.v6info.saddr,
+					a->u.net.sport,
+					"saddr", "src");
+			print_ipv6_addr(ab, &a->u.net.v6info.daddr,
+					a->u.net.dport,
+					"daddr", "dest");
+			break;
+		}
+		if (a->u.net.netif > 0) {
+			struct net_device *dev;
+
+			/* NOTE: we always use init's namespace */
+			dev = dev_get_by_index(&init_net, a->u.net.netif);
+			if (dev) {
+				audit_log_format(ab, " netif=%s", dev->name);
+				dev_put(dev);
+			}
+		}
+		break;
+#ifdef CONFIG_KEYS
+	case LSM_AUDIT_DATA_KEY:
+		audit_log_format(ab, " key_serial=%u", a->u.key_struct.key);
+		if (a->u.key_struct.key_desc) {
+			audit_log_format(ab, " key_desc=");
+			audit_log_untrustedstring(ab, a->u.key_struct.key_desc);
+		}
+		break;
+#endif
+	} /* switch (a->type) */
+}
+
+/**
+ * common_lsm_audit - generic LSM auditing function
+ * @a:  auxiliary audit data
+ *
+ * setup the audit buffer for common security information
+ * uses callback to print LSM specific information
+ */
+void common_lsm_audit(struct common_audit_data *a)
+{
+	struct audit_buffer *ab;
+
+	if (a == NULL)
+		return;
+	/* we use GFP_ATOMIC so we won't sleep */
+	ab = audit_log_start(current->audit_context, GFP_ATOMIC, AUDIT_AVC);
+
+	if (ab == NULL)
+		return;
+
+	if (a->lsm_pre_audit)
+		a->lsm_pre_audit(ab, a);
+
+	dump_common_audit_data(ab, a);
+
+	if (a->lsm_post_audit)
+		a->lsm_post_audit(ab, a);
+
+	audit_log_end(ab);
+}
