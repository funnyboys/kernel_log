commit 770f60586d2af0590be263f55fd079226313922c
Author: Madhuparna Bhowmik <madhuparnabhowmik10@gmail.com>
Date:   Thu Apr 30 21:32:05 2020 +0530

    evm: Fix RCU list related warnings
    
    This patch fixes the following warning and few other instances of
    traversal of evm_config_xattrnames list:
    
    [   32.848432] =============================
    [   32.848707] WARNING: suspicious RCU usage
    [   32.848966] 5.7.0-rc1-00006-ga8d5875ce5f0b #1 Not tainted
    [   32.849308] -----------------------------
    [   32.849567] security/integrity/evm/evm_main.c:231 RCU-list traversed in non-reader section!!
    
    Since entries are only added to the list and never deleted, use
    list_for_each_entry_lockless() instead of list_for_each_entry_rcu for
    traversing the list.  Also, add a relevant comment in evm_secfs.c to
    indicate this fact.
    
    Reported-by: kernel test robot <lkp@intel.com>
    Suggested-by: Paul E. McKenney <paulmck@kernel.org>
    Signed-off-by: Madhuparna Bhowmik <madhuparnabhowmik10@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@kernel.org> (RCU viewpoint)
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 39ad1038d45d..cfc3075769bb 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -232,7 +232,14 @@ static ssize_t evm_write_xattrs(struct file *file, const char __user *buf,
 		goto out;
 	}
 
-	/* Guard against races in evm_read_xattrs */
+	/*
+	 * xattr_list_mutex guards against races in evm_read_xattrs().
+	 * Entries are only added to the evm_config_xattrnames list
+	 * and never deleted. Therefore, the list is traversed
+	 * using list_for_each_entry_lockless() without holding
+	 * the mutex in evm_calc_hmac_or_hash(), evm_find_protected_xattrs()
+	 * and evm_protected_xattr().
+	 */
 	mutex_lock(&xattr_list_mutex);
 	list_for_each_entry(tmp, &evm_config_xattrnames, list) {
 		if (strcmp(xattr->name, tmp->name) == 0) {

commit 555d6d71d57c4a2e4ff750f6a41d2b7d7c861863
Author: Tushar Sugandhi <tusharsu@linux.microsoft.com>
Date:   Tue Feb 18 16:06:11 2020 -0800

    integrity: Remove duplicate pr_fmt definitions
    
    The #define for formatting log messages, pr_fmt, is duplicated in the
    files under security/integrity.
    
    This change moves the definition to security/integrity/integrity.h and
    removes the duplicate definitions in the other files under
    security/integrity.
    
    With this change, the messages in the following files will be prefixed
    with 'integrity'.
    
         security/integrity/platform_certs/platform_keyring.c
         security/integrity/platform_certs/load_powerpc.c
         security/integrity/platform_certs/load_uefi.c
         security/integrity/iint.c
    
         e.g. "integrity: Error adding keys to platform keyring %s\n"
    
    And the messages in the following file will be prefixed with 'ima'.
    
         security/integrity/ima/ima_mok.c
    
         e.g. "ima: Allocating IMA blacklist keyring.\n"
    
    For the rest of the files under security/integrity, there will be no
    change in the message format.
    
    Suggested-by: Shuah Khan <skhan@linuxfoundation.org>
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Tushar Sugandhi <tusharsu@linux.microsoft.com>
    Reviewed-by: Lakshmi Ramasubramanian <nramas@linux.microsoft.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index c11c1f7b3ddd..39ad1038d45d 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -10,8 +10,6 @@
  *	- Get the key and enable EVM
  */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include <linux/audit.h>
 #include <linux/uaccess.h>
 #include <linux/init.h>

commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 3f7cbb238923..c11c1f7b3ddd 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2010 IBM Corporation
  *
  * Authors:
  * Mimi Zohar <zohar@us.ibm.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, version 2 of the License.
- *
  * File: evm_secfs.c
  *	- Used to signal when key is on keyring
  *	- Get the key and enable EVM

commit a1aa08a01f734d48a8f76b12aca9f4e4adae7649
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Mar 26 14:49:20 2019 -0400

    audit: link integrity evm_write_xattrs record to syscall event
    
    In commit fa516b66a1bf ("EVM: Allow runtime modification of the set of
    verified xattrs"), the call to audit_log_start() is missing a context to
    link it to an audit event. Since this event is in user context, add
    the process' syscall context to the record.
    
    In addition, the orphaned keyword "locked" appears in the record.
    Normalize this by changing it to logging the locking string "." as any
    other user input in the "xattr=" field.
    
    Please see the github issue
    https://github.com/linux-audit/audit-kernel/issues/109
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Acked-by: Mimi Zohar <zohar@linux.ibm.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 015aea8fdf1e..3f7cbb238923 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -192,7 +192,8 @@ static ssize_t evm_write_xattrs(struct file *file, const char __user *buf,
 	if (count > XATTR_NAME_MAX)
 		return -E2BIG;
 
-	ab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_EVM_XATTR);
+	ab = audit_log_start(audit_context(), GFP_KERNEL,
+			     AUDIT_INTEGRITY_EVM_XATTR);
 	if (!ab)
 		return -ENOMEM;
 
@@ -214,6 +215,9 @@ static ssize_t evm_write_xattrs(struct file *file, const char __user *buf,
 	if (len && xattr->name[len-1] == '\n')
 		xattr->name[len-1] = '\0';
 
+	audit_log_format(ab, "xattr=");
+	audit_log_untrustedstring(ab, xattr->name);
+
 	if (strcmp(xattr->name, ".") == 0) {
 		evm_xattrs_locked = 1;
 		newattrs.ia_mode = S_IFREG | 0440;
@@ -222,15 +226,11 @@ static ssize_t evm_write_xattrs(struct file *file, const char __user *buf,
 		inode_lock(inode);
 		err = simple_setattr(evm_xattrs, &newattrs);
 		inode_unlock(inode);
-		audit_log_format(ab, "locked");
 		if (!err)
 			err = count;
 		goto out;
 	}
 
-	audit_log_format(ab, "xattr=");
-	audit_log_untrustedstring(ab, xattr->name);
-
 	if (strncmp(xattr->name, XATTR_SECURITY_PREFIX,
 		    XATTR_SECURITY_PREFIX_LEN) != 0) {
 		err = -EINVAL;

commit 876979c9308b7228cdaf6785909c57eebc85d911
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Dec 9 15:36:29 2018 -0500

    security: audit and remove any unnecessary uses of module.h
    
    Historically a lot of these existed because we did not have
    a distinction between what was modular code and what was providing
    support to modules via EXPORT_SYMBOL and friends.  That changed
    when we forked out support for the latter into the export.h file.
    This means we should be able to reduce the usage of module.h
    in code that is obj-y Makefile or bool Kconfig.
    
    The advantage in removing such instances is that module.h itself
    sources about 15 other headers; adding significantly to what we feed
    cpp, and it can obscure what headers we are effectively using.
    
    Since module.h might have been the implicit source for init.h
    (for __init) and for export.h (for EXPORT_SYMBOL) we consider each
    instance for the presence of either and replace as needed.
    
    Cc: James Morris <jmorris@namei.org>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Mimi Zohar <zohar@linux.ibm.com>
    Cc: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: linux-security-module@vger.kernel.org
    Cc: linux-integrity@vger.kernel.org
    Cc: keyrings@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 77de71b7794c..015aea8fdf1e 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -17,7 +17,7 @@
 
 #include <linux/audit.h>
 #include <linux/uaccess.h>
-#include <linux/module.h>
+#include <linux/init.h>
 #include <linux/mutex.h>
 #include "evm.h"
 

commit 3dd0f18c70d94ca2432c78c5735744429f071b0b
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Wed Jul 11 13:28:40 2018 +0000

    EVM: fix return value check in evm_write_xattrs()
    
    In case of error, the function audit_log_start() returns NULL pointer
    not ERR_PTR(). The IS_ERR() test in the return value check should be
    replaced with NULL test.
    
    Fixes: fa516b66a1bf ("EVM: Allow runtime modification of the set of verified xattrs")
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 637eb999e340..77de71b7794c 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -193,8 +193,8 @@ static ssize_t evm_write_xattrs(struct file *file, const char __user *buf,
 		return -E2BIG;
 
 	ab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_EVM_XATTR);
-	if (IS_ERR(ab))
-		return PTR_ERR(ab);
+	if (!ab)
+		return -ENOMEM;
 
 	xattr = kmalloc(sizeof(struct xattr_list), GFP_KERNEL);
 	if (!xattr) {

commit b5c90a7526fe39164c2204f0404ce8f8ff21e522
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jun 1 11:00:05 2018 +0300

    EVM: unlock on error path in evm_read_xattrs()
    
    We need to unlock before returning on this error path.
    
    Fixes: fa516b66a1bf ("EVM: Allow runtime modification of the set of verified xattrs")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 3cefef3919e5..637eb999e340 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -147,8 +147,10 @@ static ssize_t evm_read_xattrs(struct file *filp, char __user *buf,
 		size += strlen(xattr->name) + 1;
 
 	temp = kmalloc(size + 1, GFP_KERNEL);
-	if (!temp)
+	if (!temp) {
+		mutex_unlock(&xattr_list_mutex);
 		return -ENOMEM;
+	}
 
 	list_for_each_entry(xattr, &evm_config_xattrnames, list) {
 		sprintf(temp + offset, "%s\n", xattr->name);

commit a41d80acfa2764e9b1ce49aa303a263e609d91f7
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue May 29 16:11:28 2018 +0300

    EVM: prevent array underflow in evm_write_xattrs()
    
    If the user sets xattr->name[0] to NUL then we would read one character
    before the start of the array.  This bug seems harmless as far as I can
    see but perhaps it would trigger a warning in KASAN.
    
    Fixes: fa516b66a1bf ("EVM: Allow runtime modification of the set of verified xattrs")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index cf5cd303d7c0..3cefef3919e5 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -209,7 +209,7 @@ static ssize_t evm_write_xattrs(struct file *file, const char __user *buf,
 
 	/* Remove any trailing newline */
 	len = strlen(xattr->name);
-	if (xattr->name[len-1] == '\n')
+	if (len && xattr->name[len-1] == '\n')
 		xattr->name[len-1] = '\0';
 
 	if (strcmp(xattr->name, ".") == 0) {

commit 72acd64df4561593d2ec3227b4aca9b0d7ded50e
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun May 27 23:55:10 2018 +0100

    EVM: Fix null dereference on xattr when xattr fails to allocate
    
    In the case where the allocation of xattr fails and xattr is NULL, the
    error exit return path via label 'out' will dereference xattr when
    kfree'ing xattr-name.  Fix this by only kfree'ing xattr->name and xattr
    when xattr is non-null.
    
    Detected by CoverityScan, CID#1469366 ("Dereference after null check")
    
    Fixes: fa516b66a1bf ("EVM: Allow runtime modification of the set of verified xattrs")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index fb8bc950aceb..cf5cd303d7c0 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -253,8 +253,10 @@ static ssize_t evm_write_xattrs(struct file *file, const char __user *buf,
 out:
 	audit_log_format(ab, " res=%d", err);
 	audit_log_end(ab);
-	kfree(xattr->name);
-	kfree(xattr);
+	if (xattr) {
+		kfree(xattr->name);
+		kfree(xattr);
+	}
 	return err;
 }
 

commit 825b8650dc3dd064969ce343e918d0eb6bf907fb
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun May 27 23:15:02 2018 +0100

    EVM: fix memory leak of temporary buffer 'temp'
    
    The allocation of 'temp' is not kfree'd and hence there is a memory
    leak on each call of evm_read_xattrs.  Fix this by kfree'ing it
    after copying data from it back to the user space buffer 'buf'.
    
    Detected by CoverityScan, CID#1469386 ("Resource Leak")
    
    Fixes: fa516b66a1bf ("EVM: Allow runtime modification of the set of verified xattrs")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index a7a0a1acae99..fb8bc950aceb 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -158,6 +158,8 @@ static ssize_t evm_read_xattrs(struct file *filp, char __user *buf,
 	mutex_unlock(&xattr_list_mutex);
 	rc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));
 
+	kfree(temp);
+
 	return rc;
 }
 

commit fa516b66a1bfce1d72f1620c54bdfebc493000d1
Author: Matthew Garrett <mjg59@google.com>
Date:   Tue May 15 10:38:26 2018 -0700

    EVM: Allow runtime modification of the set of verified xattrs
    
    Sites may wish to provide additional metadata alongside files in order
    to make more fine-grained security decisions[1]. The security of this is
    enhanced if this metadata is protected, something that EVM makes
    possible. However, the kernel cannot know about the set of extended
    attributes that local admins may wish to protect, and hardcoding this
    policy in the kernel makes it difficult to change over time and less
    convenient for distributions to enable.
    
    This patch adds a new /sys/kernel/security/integrity/evm/evm_xattrs node,
    which can be read to obtain the current set of EVM-protected extended
    attributes or written to in order to add new entries. Extending this list
    will not change the validity of any existing signatures provided that the
    file in question does not have any of the additional extended attributes -
    missing xattrs are skipped when calculating the EVM hash.
    
    [1] For instance, a package manager could install information about the
    package uploader in an additional extended attribute. Local LSM policy
    could then be associated with that extended attribute in order to
    restrict the privileges available to packages from less trusted
    uploaders.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index e44380f0cb45..a7a0a1acae99 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -15,14 +15,22 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/audit.h>
 #include <linux/uaccess.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include "evm.h"
 
 static struct dentry *evm_dir;
 static struct dentry *evm_init_tpm;
 static struct dentry *evm_symlink;
 
+#ifdef CONFIG_EVM_ADD_XATTRS
+static struct dentry *evm_xattrs;
+static DEFINE_MUTEX(xattr_list_mutex);
+static int evm_xattrs_locked;
+#endif
+
 /**
  * evm_read_key - read() for <securityfs>/evm
  *
@@ -109,6 +117,166 @@ static const struct file_operations evm_key_ops = {
 	.write		= evm_write_key,
 };
 
+#ifdef CONFIG_EVM_ADD_XATTRS
+/**
+ * evm_read_xattrs - read() for <securityfs>/evm_xattrs
+ *
+ * @filp: file pointer, not actually used
+ * @buf: where to put the result
+ * @count: maximum to send along
+ * @ppos: where to start
+ *
+ * Returns number of bytes read or error code, as appropriate
+ */
+static ssize_t evm_read_xattrs(struct file *filp, char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	char *temp;
+	int offset = 0;
+	ssize_t rc, size = 0;
+	struct xattr_list *xattr;
+
+	if (*ppos != 0)
+		return 0;
+
+	rc = mutex_lock_interruptible(&xattr_list_mutex);
+	if (rc)
+		return -ERESTARTSYS;
+
+	list_for_each_entry(xattr, &evm_config_xattrnames, list)
+		size += strlen(xattr->name) + 1;
+
+	temp = kmalloc(size + 1, GFP_KERNEL);
+	if (!temp)
+		return -ENOMEM;
+
+	list_for_each_entry(xattr, &evm_config_xattrnames, list) {
+		sprintf(temp + offset, "%s\n", xattr->name);
+		offset += strlen(xattr->name) + 1;
+	}
+
+	mutex_unlock(&xattr_list_mutex);
+	rc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));
+
+	return rc;
+}
+
+/**
+ * evm_write_xattrs - write() for <securityfs>/evm_xattrs
+ * @file: file pointer, not actually used
+ * @buf: where to get the data from
+ * @count: bytes sent
+ * @ppos: where to start
+ *
+ * Returns number of bytes written or error code, as appropriate
+ */
+static ssize_t evm_write_xattrs(struct file *file, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	int len, err;
+	struct xattr_list *xattr, *tmp;
+	struct audit_buffer *ab;
+	struct iattr newattrs;
+	struct inode *inode;
+
+	if (!capable(CAP_SYS_ADMIN) || evm_xattrs_locked)
+		return -EPERM;
+
+	if (*ppos != 0)
+		return -EINVAL;
+
+	if (count > XATTR_NAME_MAX)
+		return -E2BIG;
+
+	ab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_EVM_XATTR);
+	if (IS_ERR(ab))
+		return PTR_ERR(ab);
+
+	xattr = kmalloc(sizeof(struct xattr_list), GFP_KERNEL);
+	if (!xattr) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	xattr->name = memdup_user_nul(buf, count);
+	if (IS_ERR(xattr->name)) {
+		err = PTR_ERR(xattr->name);
+		xattr->name = NULL;
+		goto out;
+	}
+
+	/* Remove any trailing newline */
+	len = strlen(xattr->name);
+	if (xattr->name[len-1] == '\n')
+		xattr->name[len-1] = '\0';
+
+	if (strcmp(xattr->name, ".") == 0) {
+		evm_xattrs_locked = 1;
+		newattrs.ia_mode = S_IFREG | 0440;
+		newattrs.ia_valid = ATTR_MODE;
+		inode = evm_xattrs->d_inode;
+		inode_lock(inode);
+		err = simple_setattr(evm_xattrs, &newattrs);
+		inode_unlock(inode);
+		audit_log_format(ab, "locked");
+		if (!err)
+			err = count;
+		goto out;
+	}
+
+	audit_log_format(ab, "xattr=");
+	audit_log_untrustedstring(ab, xattr->name);
+
+	if (strncmp(xattr->name, XATTR_SECURITY_PREFIX,
+		    XATTR_SECURITY_PREFIX_LEN) != 0) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Guard against races in evm_read_xattrs */
+	mutex_lock(&xattr_list_mutex);
+	list_for_each_entry(tmp, &evm_config_xattrnames, list) {
+		if (strcmp(xattr->name, tmp->name) == 0) {
+			err = -EEXIST;
+			mutex_unlock(&xattr_list_mutex);
+			goto out;
+		}
+	}
+	list_add_tail_rcu(&xattr->list, &evm_config_xattrnames);
+	mutex_unlock(&xattr_list_mutex);
+
+	audit_log_format(ab, " res=0");
+	audit_log_end(ab);
+	return count;
+out:
+	audit_log_format(ab, " res=%d", err);
+	audit_log_end(ab);
+	kfree(xattr->name);
+	kfree(xattr);
+	return err;
+}
+
+static const struct file_operations evm_xattr_ops = {
+	.read		= evm_read_xattrs,
+	.write		= evm_write_xattrs,
+};
+
+static int evm_init_xattrs(void)
+{
+	evm_xattrs = securityfs_create_file("evm_xattrs", 0660, evm_dir, NULL,
+					    &evm_xattr_ops);
+	if (!evm_xattrs || IS_ERR(evm_xattrs))
+		return -EFAULT;
+
+	return 0;
+}
+#else
+static int evm_init_xattrs(void)
+{
+	return 0;
+}
+#endif
+
 int __init evm_init_secfs(void)
 {
 	int error = 0;
@@ -131,6 +299,11 @@ int __init evm_init_secfs(void)
 		goto out;
 	}
 
+	if (evm_init_xattrs() != 0) {
+		error = -EFAULT;
+		goto out;
+	}
+
 	return 0;
 out:
 	securityfs_remove(evm_symlink);

commit 0c343af8065be5ceb0c03a876af7c513e960e2ff
Author: Matthew Garrett <mjg59@google.com>
Date:   Fri May 11 16:12:34 2018 -0700

    integrity: Add an integrity directory in securityfs
    
    We want to add additional evm control nodes, and it'd be preferable not
    to clutter up the securityfs root directory any further. Create a new
    integrity directory, move the ima directory into it, create an evm
    directory for the evm attribute and add compatibility symlinks.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index feba03bbedae..e44380f0cb45 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -19,7 +19,9 @@
 #include <linux/module.h>
 #include "evm.h"
 
+static struct dentry *evm_dir;
 static struct dentry *evm_init_tpm;
+static struct dentry *evm_symlink;
 
 /**
  * evm_read_key - read() for <securityfs>/evm
@@ -111,9 +113,28 @@ int __init evm_init_secfs(void)
 {
 	int error = 0;
 
-	evm_init_tpm = securityfs_create_file("evm", S_IRUSR | S_IRGRP,
-					      NULL, NULL, &evm_key_ops);
-	if (!evm_init_tpm || IS_ERR(evm_init_tpm))
+	evm_dir = securityfs_create_dir("evm", integrity_dir);
+	if (!evm_dir || IS_ERR(evm_dir))
+		return -EFAULT;
+
+	evm_init_tpm = securityfs_create_file("evm", 0660,
+					      evm_dir, NULL, &evm_key_ops);
+	if (!evm_init_tpm || IS_ERR(evm_init_tpm)) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	evm_symlink = securityfs_create_symlink("evm", NULL,
+						"integrity/evm/evm", NULL);
+	if (!evm_symlink || IS_ERR(evm_symlink)) {
 		error = -EFAULT;
+		goto out;
+	}
+
+	return 0;
+out:
+	securityfs_remove(evm_symlink);
+	securityfs_remove(evm_init_tpm);
+	securityfs_remove(evm_dir);
 	return error;
 }

commit ae1ba1676b88e6c62368a433c7e2d0417e9879fd
Author: Matthew Garrett <mjg59@google.com>
Date:   Tue Nov 7 07:18:35 2017 -0800

    EVM: Allow userland to permit modification of EVM-protected metadata
    
    When EVM is enabled it forbids modification of metadata protected by
    EVM unless there is already a valid EVM signature. If any modification
    is made, the kernel will then generate a new EVM HMAC. However, this
    does not map well on use cases which use only asymmetric EVM signatures,
    as in this scenario the kernel is unable to generate new signatures.
    
    This patch extends the /sys/kernel/security/evm interface to allow
    userland to request that modification of these xattrs be permitted. This
    is only permitted if no keys have already been loaded. In this
    configuration, modifying the metadata will invalidate the EVM appraisal
    on the file in question. This allows packaging systems to write out new
    files, set the relevant extended attributes and then move them into
    place.
    
    There's also some refactoring of the use of evm_initialized in order to
    avoid heading down codepaths that assume there's a key available.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 319cf16d6603..feba03bbedae 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -40,7 +40,7 @@ static ssize_t evm_read_key(struct file *filp, char __user *buf,
 	if (*ppos != 0)
 		return 0;
 
-	sprintf(temp, "%d", (evm_initialized & ~EVM_SETUP));
+	sprintf(temp, "%d", (evm_initialized & ~EVM_SETUP_COMPLETE));
 	rc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));
 
 	return rc;
@@ -63,7 +63,7 @@ static ssize_t evm_write_key(struct file *file, const char __user *buf,
 {
 	int i, ret;
 
-	if (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_SETUP))
+	if (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_SETUP_COMPLETE))
 		return -EPERM;
 
 	ret = kstrtoint_from_user(buf, count, 0, &i);
@@ -75,16 +75,30 @@ static ssize_t evm_write_key(struct file *file, const char __user *buf,
 	if (!i || (i & ~EVM_INIT_MASK) != 0)
 		return -EINVAL;
 
+	/* Don't allow a request to freshly enable metadata writes if
+	 * keys are loaded.
+	 */
+	if ((i & EVM_ALLOW_METADATA_WRITES) &&
+	    ((evm_initialized & EVM_KEY_MASK) != 0) &&
+	    !(evm_initialized & EVM_ALLOW_METADATA_WRITES))
+		return -EPERM;
+
 	if (i & EVM_INIT_HMAC) {
 		ret = evm_init_key();
 		if (ret != 0)
 			return ret;
 		/* Forbid further writes after the symmetric key is loaded */
-		i |= EVM_SETUP;
+		i |= EVM_SETUP_COMPLETE;
 	}
 
 	evm_initialized |= i;
 
+	/* Don't allow protected metadata modification if a symmetric key
+	 * is loaded
+	 */
+	if (evm_initialized & EVM_INIT_HMAC)
+		evm_initialized &= ~(EVM_ALLOW_METADATA_WRITES);
+
 	return count;
 }
 

commit f00d79750712511d0a83c108eea0d44b680a915f
Author: Matthew Garrett <mjg59@google.com>
Date:   Wed Oct 11 12:10:14 2017 -0700

    EVM: Allow userspace to signal an RSA key has been loaded
    
    EVM will only perform validation once a key has been loaded. This key
    may either be a symmetric trusted key (for HMAC validation and creation)
    or the public half of an asymmetric key (for digital signature
    validation). The /sys/kernel/security/evm interface allows userland to
    signal that a symmetric key has been loaded, but does not allow userland
    to signal that an asymmetric public key has been loaded.
    
    This patch extends the interface to permit userspace to pass a bitmask
    of loaded key types. It also allows userspace to block loading of a
    symmetric key in order to avoid a compromised system from being able to
    load an additional key type later.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index c8dccd54d501..319cf16d6603 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -40,7 +40,7 @@ static ssize_t evm_read_key(struct file *filp, char __user *buf,
 	if (*ppos != 0)
 		return 0;
 
-	sprintf(temp, "%d", evm_initialized);
+	sprintf(temp, "%d", (evm_initialized & ~EVM_SETUP));
 	rc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));
 
 	return rc;
@@ -61,24 +61,29 @@ static ssize_t evm_read_key(struct file *filp, char __user *buf,
 static ssize_t evm_write_key(struct file *file, const char __user *buf,
 			     size_t count, loff_t *ppos)
 {
-	char temp[80];
-	int i;
+	int i, ret;
 
-	if (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_INIT_HMAC))
+	if (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_SETUP))
 		return -EPERM;
 
-	if (count >= sizeof(temp) || count == 0)
-		return -EINVAL;
-
-	if (copy_from_user(temp, buf, count) != 0)
-		return -EFAULT;
+	ret = kstrtoint_from_user(buf, count, 0, &i);
 
-	temp[count] = '\0';
+	if (ret)
+		return ret;
 
-	if ((sscanf(temp, "%d", &i) != 1) || (i != 1))
+	/* Reject invalid values */
+	if (!i || (i & ~EVM_INIT_MASK) != 0)
 		return -EINVAL;
 
-	evm_init_key();
+	if (i & EVM_INIT_HMAC) {
+		ret = evm_init_key();
+		if (ret != 0)
+			return ret;
+		/* Forbid further writes after the symmetric key is loaded */
+		i |= EVM_SETUP;
+	}
+
+	evm_initialized |= i;
 
 	return count;
 }

commit 7626676320f398980a6bb4490fd58e924c888f6a
Author: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>
Date:   Thu Oct 22 21:26:32 2015 +0300

    evm: provide a function to set the EVM key from the kernel
    
    A crypto HW kernel module can possibly initialize the EVM key from the
    kernel __init code to enable EVM before calling the 'init' process.
    This patch provides a function evm_set_key() to set the EVM key
    directly without using the KEY subsystem.
    
    Changes in v4:
    * kernel-doc style for evm_set_key
    
    Changes in v3:
    * error reporting moved to evm_set_key
    * EVM_INIT_HMAC moved to evm_set_key
    * added bitop to prevent key setting race
    
    Changes in v2:
    * use size_t for key size instead of signed int
    * provide EVM_MAX_KEY_SIZE macro in <linux/evm.h>
    * provide EVM_MIN_KEY_SIZE macro in <linux/evm.h>
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 3f775dfea868..c8dccd54d501 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -62,7 +62,7 @@ static ssize_t evm_write_key(struct file *file, const char __user *buf,
 			     size_t count, loff_t *ppos)
 {
 	char temp[80];
-	int i, error;
+	int i;
 
 	if (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_INIT_HMAC))
 		return -EPERM;
@@ -78,12 +78,8 @@ static ssize_t evm_write_key(struct file *file, const char __user *buf,
 	if ((sscanf(temp, "%d", &i) != 1) || (i != 1))
 		return -EINVAL;
 
-	error = evm_init_key();
-	if (!error) {
-		evm_initialized |= EVM_INIT_HMAC;
-		pr_info("initialized\n");
-	} else
-		pr_err("initialization failed\n");
+	evm_init_key();
+
 	return count;
 }
 

commit 26ddabfe96bb7468763c9c92791404d991b16250
Author: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>
Date:   Thu Oct 22 21:26:26 2015 +0300

    evm: enable EVM when X509 certificate is loaded
    
    In order to enable EVM before starting the 'init' process,
    evm_initialized needs to be non-zero.  Previously non-zero indicated
    that the HMAC key was loaded.  When EVM loads the X509 before calling
    'init', with this patch it is now possible to enable EVM to start
    signature based verification.
    
    This patch defines bits to enable EVM if a key of any type is loaded.
    
    Changes in v3:
    * print error message if key is not set
    
    Changes in v2:
    * EVM_STATE_KEY_SET replaced by EVM_INIT_HMAC
    * EVM_STATE_X509_SET replaced by EVM_INIT_X509
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index cf12a04717d3..3f775dfea868 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -64,7 +64,7 @@ static ssize_t evm_write_key(struct file *file, const char __user *buf,
 	char temp[80];
 	int i, error;
 
-	if (!capable(CAP_SYS_ADMIN) || evm_initialized)
+	if (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_INIT_HMAC))
 		return -EPERM;
 
 	if (count >= sizeof(temp) || count == 0)
@@ -80,7 +80,7 @@ static ssize_t evm_write_key(struct file *file, const char __user *buf,
 
 	error = evm_init_key();
 	if (!error) {
-		evm_initialized = 1;
+		evm_initialized |= EVM_INIT_HMAC;
 		pr_info("initialized\n");
 	} else
 		pr_err("initialization failed\n");

commit 20ee451f5a7cd43edda56ba36cbec4d881d3329f
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 24 13:59:56 2014 -0800

    security: integrity: Use a more current logging style
    
    Convert printks to pr_<level>.
    Add pr_fmt.
    Remove embedded prefixes.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 30f670ad6ac3..cf12a04717d3 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -13,6 +13,8 @@
  *	- Get the key and enable EVM
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/uaccess.h>
 #include <linux/module.h>
 #include "evm.h"
@@ -79,9 +81,9 @@ static ssize_t evm_write_key(struct file *file, const char __user *buf,
 	error = evm_init_key();
 	if (!error) {
 		evm_initialized = 1;
-		pr_info("EVM: initialized\n");
+		pr_info("initialized\n");
 	} else
-		pr_err("EVM: initialization failed\n");
+		pr_err("initialization failed\n");
 	return count;
 }
 

commit e90805656d4683f84d360276102ae63adc777a38
Author: Dmitry Kasatkin <dmitry.kasatkin@intel.com>
Date:   Mon Sep 3 17:11:56 2012 +0300

    evm: remove unused cleanup functions
    
    EVM cannot be built as a kernel module. Remove the unncessary __exit
    functions.
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@intel.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index ac7629950578..30f670ad6ac3 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -100,9 +100,3 @@ int __init evm_init_secfs(void)
 		error = -EFAULT;
 	return error;
 }
-
-void __exit evm_cleanup_secfs(void)
-{
-	if (evm_init_tpm)
-		securityfs_remove(evm_init_tpm);
-}

commit 66dbc325afcef909043c30e90930a36823fc734c
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Mar 15 16:12:09 2011 -0400

    evm: re-release
    
    EVM protects a file's security extended attributes(xattrs) against integrity
    attacks.  This patchset provides the framework and an initial method.  The
    initial method maintains an HMAC-sha1 value across the security extended
    attributes, storing the HMAC value as the extended attribute 'security.evm'.
    Other methods of validating the integrity of a file's metadata will be posted
    separately (eg. EVM-digital-signatures).
    
    While this patchset does authenticate the security xattrs, and
    cryptographically binds them to the inode, coming extensions will bind other
    directory and inode metadata for more complete protection.  To help simplify
    the review and upstreaming process, each extension will be posted separately
    (eg. IMA-appraisal, IMA-appraisal-directory).  For a general overview of the
    proposed Linux integrity subsystem, refer to Dave Safford's whitepaper:
    http://downloads.sf.net/project/linux-ima/linux-ima/Integrity_overview.pdf.
    
    EVM depends on the Kernel Key Retention System to provide it with a
    trusted/encrypted key for the HMAC-sha1 operation. The key is loaded onto the
    root's keyring using keyctl.  Until EVM receives notification that the key has
    been successfully loaded onto the keyring (echo 1 > <securityfs>/evm), EVM can
    not create or validate the 'security.evm' xattr, but returns INTEGRITY_UNKNOWN.
    Loading the key and signaling EVM should be done as early as possible. Normally
    this is done in the initramfs, which has already been measured as part of the
    trusted boot.  For more information on creating and loading existing
    trusted/encrypted keys, refer to Documentation/keys-trusted-encrypted.txt.  A
    sample dracut patch, which loads the trusted/encrypted key and enables EVM, is
    available from http://linux-ima.sourceforge.net/#EVM.
    
    Based on the LSMs enabled, the set of EVM protected security xattrs is defined
    at compile.  EVM adds the following three calls to the existing security hooks:
    evm_inode_setxattr(), evm_inode_post_setxattr(), and evm_inode_removexattr.  To
    initialize and update the 'security.evm' extended attribute, EVM defines three
    calls: evm_inode_post_init(), evm_inode_post_setattr() and
    evm_inode_post_removexattr() hooks.  To verify the integrity of a security
    xattr, EVM exports evm_verifyxattr().
    
    Changelog v7:
    - Fixed URL in EVM ABI documentation
    
    Changelog v6: (based on Serge Hallyn's review)
    - fix URL in patch description
    - remove evm_hmac_size definition
    - use SHA1_DIGEST_SIZE (removed both MAX_DIGEST_SIZE and evm_hmac_size)
    - moved linux include before other includes
    - test for crypto_hash_setkey failure
    - fail earlier for invalid key
    - clear entire encrypted key, even on failure
    - check xattr name length before comparing xattr names
    
    Changelog:
    - locking based on i_mutex, remove evm_mutex
    - using trusted/encrypted keys for storing the EVM key used in the HMAC-sha1
      operation.
    - replaced crypto hash with shash (Dmitry Kasatkin)
    - support for additional methods of verifying the security xattrs
      (Dmitry Kasatkin)
    - iint not allocated for all regular files, but only for those appraised
    - Use cap_sys_admin in lieu of cap_mac_admin
    - Use __vfs_setxattr_noperm(), without permission checks, from EVM
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>

diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
new file mode 100644
index 000000000000..ac7629950578
--- /dev/null
+++ b/security/integrity/evm/evm_secfs.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2010 IBM Corporation
+ *
+ * Authors:
+ * Mimi Zohar <zohar@us.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * File: evm_secfs.c
+ *	- Used to signal when key is on keyring
+ *	- Get the key and enable EVM
+ */
+
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include "evm.h"
+
+static struct dentry *evm_init_tpm;
+
+/**
+ * evm_read_key - read() for <securityfs>/evm
+ *
+ * @filp: file pointer, not actually used
+ * @buf: where to put the result
+ * @count: maximum to send along
+ * @ppos: where to start
+ *
+ * Returns number of bytes read or error code, as appropriate
+ */
+static ssize_t evm_read_key(struct file *filp, char __user *buf,
+			    size_t count, loff_t *ppos)
+{
+	char temp[80];
+	ssize_t rc;
+
+	if (*ppos != 0)
+		return 0;
+
+	sprintf(temp, "%d", evm_initialized);
+	rc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));
+
+	return rc;
+}
+
+/**
+ * evm_write_key - write() for <securityfs>/evm
+ * @file: file pointer, not actually used
+ * @buf: where to get the data from
+ * @count: bytes sent
+ * @ppos: where to start
+ *
+ * Used to signal that key is on the kernel key ring.
+ * - get the integrity hmac key from the kernel key ring
+ * - create list of hmac protected extended attributes
+ * Returns number of bytes written or error code, as appropriate
+ */
+static ssize_t evm_write_key(struct file *file, const char __user *buf,
+			     size_t count, loff_t *ppos)
+{
+	char temp[80];
+	int i, error;
+
+	if (!capable(CAP_SYS_ADMIN) || evm_initialized)
+		return -EPERM;
+
+	if (count >= sizeof(temp) || count == 0)
+		return -EINVAL;
+
+	if (copy_from_user(temp, buf, count) != 0)
+		return -EFAULT;
+
+	temp[count] = '\0';
+
+	if ((sscanf(temp, "%d", &i) != 1) || (i != 1))
+		return -EINVAL;
+
+	error = evm_init_key();
+	if (!error) {
+		evm_initialized = 1;
+		pr_info("EVM: initialized\n");
+	} else
+		pr_err("EVM: initialization failed\n");
+	return count;
+}
+
+static const struct file_operations evm_key_ops = {
+	.read		= evm_read_key,
+	.write		= evm_write_key,
+};
+
+int __init evm_init_secfs(void)
+{
+	int error = 0;
+
+	evm_init_tpm = securityfs_create_file("evm", S_IRUSR | S_IRGRP,
+					      NULL, NULL, &evm_key_ops);
+	if (!evm_init_tpm || IS_ERR(evm_init_tpm))
+		error = -EFAULT;
+	return error;
+}
+
+void __exit evm_cleanup_secfs(void)
+{
+	if (evm_init_tpm)
+		securityfs_remove(evm_init_tpm);
+}
