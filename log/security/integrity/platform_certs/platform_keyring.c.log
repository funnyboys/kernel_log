commit 028db3e290f15ac509084c0fc3b9d021f668f877
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 18:43:43 2019 -0700

    Revert "Merge tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs"
    
    This reverts merge 0f75ef6a9cff49ff612f7ce0578bced9d0b38325 (and thus
    effectively commits
    
       7a1ade847596 ("keys: Provide KEYCTL_GRANT_PERMISSION")
       2e12256b9a76 ("keys: Replace uid/gid/perm permissions checking with an ACL")
    
    that the merge brought in).
    
    It turns out that it breaks booting with an encrypted volume, and Eric
    biggers reports that it also breaks the fscrypt tests [1] and loading of
    in-kernel X.509 certificates [2].
    
    The root cause of all the breakage is likely the same, but David Howells
    is off email so rather than try to work it out it's getting reverted in
    order to not impact the rest of the merge window.
    
     [1] https://lore.kernel.org/lkml/20190710011559.GA7973@sol.localdomain/
     [2] https://lore.kernel.org/lkml/20190710013225.GB7973@sol.localdomain/
    
    Link: https://lore.kernel.org/lkml/CAHk-=wjxoeMJfeBahnWH=9zShKp2bsVy527vo3_y8HfOdhwAAw@mail.gmail.com/
    Reported-by: Eric Biggers <ebiggers@kernel.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/integrity/platform_certs/platform_keyring.c b/security/integrity/platform_certs/platform_keyring.c
index 7646e35f2d91..bcafd7387729 100644
--- a/security/integrity/platform_certs/platform_keyring.c
+++ b/security/integrity/platform_certs/platform_keyring.c
@@ -14,15 +14,6 @@
 #include <linux/slab.h>
 #include "../integrity.h"
 
-static struct key_acl platform_key_acl = {
-	.usage	= REFCOUNT_INIT(1),
-	.nr_ace	= 2,
-	.aces = {
-		KEY_POSSESSOR_ACE(KEY_ACE_SEARCH | KEY_ACE_READ),
-		KEY_OWNER_ACE(KEY_ACE_VIEW),
-	}
-};
-
 /**
  * add_to_platform_keyring - Add to platform keyring without validation.
  * @source: Source of key
@@ -35,10 +26,13 @@ static struct key_acl platform_key_acl = {
 void __init add_to_platform_keyring(const char *source, const void *data,
 				    size_t len)
 {
+	key_perm_t perm;
 	int rc;
 
+	perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW;
+
 	rc = integrity_load_cert(INTEGRITY_KEYRING_PLATFORM, source, data, len,
-				 &platform_key_acl);
+				 perm);
 	if (rc)
 		pr_info("Error adding keys to platform keyring %s\n", source);
 }

commit 2e12256b9a76584fa3a6da19210509d4775aee36
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 27 23:03:07 2019 +0100

    keys: Replace uid/gid/perm permissions checking with an ACL
    
    Replace the uid/gid/perm permissions checking on a key with an ACL to allow
    the SETATTR and SEARCH permissions to be split.  This will also allow a
    greater range of subjects to represented.
    
    ============
    WHY DO THIS?
    ============
    
    The problem is that SETATTR and SEARCH cover a slew of actions, not all of
    which should be grouped together.
    
    For SETATTR, this includes actions that are about controlling access to a
    key:
    
     (1) Changing a key's ownership.
    
     (2) Changing a key's security information.
    
     (3) Setting a keyring's restriction.
    
    And actions that are about managing a key's lifetime:
    
     (4) Setting an expiry time.
    
     (5) Revoking a key.
    
    and (proposed) managing a key as part of a cache:
    
     (6) Invalidating a key.
    
    Managing a key's lifetime doesn't really have anything to do with
    controlling access to that key.
    
    Expiry time is awkward since it's more about the lifetime of the content
    and so, in some ways goes better with WRITE permission.  It can, however,
    be set unconditionally by a process with an appropriate authorisation token
    for instantiating a key, and can also be set by the key type driver when a
    key is instantiated, so lumping it with the access-controlling actions is
    probably okay.
    
    As for SEARCH permission, that currently covers:
    
     (1) Finding keys in a keyring tree during a search.
    
     (2) Permitting keyrings to be joined.
    
     (3) Invalidation.
    
    But these don't really belong together either, since these actions really
    need to be controlled separately.
    
    Finally, there are number of special cases to do with granting the
    administrator special rights to invalidate or clear keys that I would like
    to handle with the ACL rather than key flags and special checks.
    
    
    ===============
    WHAT IS CHANGED
    ===============
    
    The SETATTR permission is split to create two new permissions:
    
     (1) SET_SECURITY - which allows the key's owner, group and ACL to be
         changed and a restriction to be placed on a keyring.
    
     (2) REVOKE - which allows a key to be revoked.
    
    The SEARCH permission is split to create:
    
     (1) SEARCH - which allows a keyring to be search and a key to be found.
    
     (2) JOIN - which allows a keyring to be joined as a session keyring.
    
     (3) INVAL - which allows a key to be invalidated.
    
    The WRITE permission is also split to create:
    
     (1) WRITE - which allows a key's content to be altered and links to be
         added, removed and replaced in a keyring.
    
     (2) CLEAR - which allows a keyring to be cleared completely.  This is
         split out to make it possible to give just this to an administrator.
    
     (3) REVOKE - see above.
    
    
    Keys acquire ACLs which consist of a series of ACEs, and all that apply are
    unioned together.  An ACE specifies a subject, such as:
    
     (*) Possessor - permitted to anyone who 'possesses' a key
     (*) Owner - permitted to the key owner
     (*) Group - permitted to the key group
     (*) Everyone - permitted to everyone
    
    Note that 'Other' has been replaced with 'Everyone' on the assumption that
    you wouldn't grant a permit to 'Other' that you wouldn't also grant to
    everyone else.
    
    Further subjects may be made available by later patches.
    
    The ACE also specifies a permissions mask.  The set of permissions is now:
    
            VIEW            Can view the key metadata
            READ            Can read the key content
            WRITE           Can update/modify the key content
            SEARCH          Can find the key by searching/requesting
            LINK            Can make a link to the key
            SET_SECURITY    Can change owner, ACL, expiry
            INVAL           Can invalidate
            REVOKE          Can revoke
            JOIN            Can join this keyring
            CLEAR           Can clear this keyring
    
    
    The KEYCTL_SETPERM function is then deprecated.
    
    The KEYCTL_SET_TIMEOUT function then is permitted if SET_SECURITY is set,
    or if the caller has a valid instantiation auth token.
    
    The KEYCTL_INVALIDATE function then requires INVAL.
    
    The KEYCTL_REVOKE function then requires REVOKE.
    
    The KEYCTL_JOIN_SESSION_KEYRING function then requires JOIN to join an
    existing keyring.
    
    The JOIN permission is enabled by default for session keyrings and manually
    created keyrings only.
    
    
    ======================
    BACKWARD COMPATIBILITY
    ======================
    
    To maintain backward compatibility, KEYCTL_SETPERM will translate the
    permissions mask it is given into a new ACL for a key - unless
    KEYCTL_SET_ACL has been called on that key, in which case an error will be
    returned.
    
    It will convert possessor, owner, group and other permissions into separate
    ACEs, if each portion of the mask is non-zero.
    
    SETATTR permission turns on all of INVAL, REVOKE and SET_SECURITY.  WRITE
    permission turns on WRITE, REVOKE and, if a keyring, CLEAR.  JOIN is turned
    on if a keyring is being altered.
    
    The KEYCTL_DESCRIBE function translates the ACL back into a permissions
    mask to return depending on possessor, owner, group and everyone ACEs.
    
    It will make the following mappings:
    
     (1) INVAL, JOIN -> SEARCH
    
     (2) SET_SECURITY -> SETATTR
    
     (3) REVOKE -> WRITE if SETATTR isn't already set
    
     (4) CLEAR -> WRITE
    
    Note that the value subsequently returned by KEYCTL_DESCRIBE may not match
    the value set with KEYCTL_SETATTR.
    
    
    =======
    TESTING
    =======
    
    This passes the keyutils testsuite for all but a couple of tests:
    
     (1) tests/keyctl/dh_compute/badargs: The first wrong-key-type test now
         returns EOPNOTSUPP rather than ENOKEY as READ permission isn't removed
         if the type doesn't have ->read().  You still can't actually read the
         key.
    
     (2) tests/keyctl/permitting/valid: The view-other-permissions test doesn't
         work as Other has been replaced with Everyone in the ACL.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/integrity/platform_certs/platform_keyring.c b/security/integrity/platform_certs/platform_keyring.c
index bcafd7387729..7646e35f2d91 100644
--- a/security/integrity/platform_certs/platform_keyring.c
+++ b/security/integrity/platform_certs/platform_keyring.c
@@ -14,6 +14,15 @@
 #include <linux/slab.h>
 #include "../integrity.h"
 
+static struct key_acl platform_key_acl = {
+	.usage	= REFCOUNT_INIT(1),
+	.nr_ace	= 2,
+	.aces = {
+		KEY_POSSESSOR_ACE(KEY_ACE_SEARCH | KEY_ACE_READ),
+		KEY_OWNER_ACE(KEY_ACE_VIEW),
+	}
+};
+
 /**
  * add_to_platform_keyring - Add to platform keyring without validation.
  * @source: Source of key
@@ -26,13 +35,10 @@
 void __init add_to_platform_keyring(const char *source, const void *data,
 				    size_t len)
 {
-	key_perm_t perm;
 	int rc;
 
-	perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW;
-
 	rc = integrity_load_cert(INTEGRITY_KEYRING_PLATFORM, source, data, len,
-				 perm);
+				 &platform_key_acl);
 	if (rc)
 		pr_info("Error adding keys to platform keyring %s\n", source);
 }

commit 60740accf78494e166ec76bdc39b7d75fc2fe1c7
Author: Nayna Jain <nayna@linux.ibm.com>
Date:   Sun Dec 9 01:57:00 2018 +0530

    integrity: Load certs to the platform keyring
    
    The patch refactors integrity_load_x509(), making it a wrapper for a new
    function named integrity_add_key(). This patch also defines a new
    function named integrity_load_cert() for loading the platform keys.
    
    Signed-off-by: Nayna Jain <nayna@linux.ibm.com>
    Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Reviewed-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/platform_certs/platform_keyring.c b/security/integrity/platform_certs/platform_keyring.c
index 79f80af5b470..bcafd7387729 100644
--- a/security/integrity/platform_certs/platform_keyring.c
+++ b/security/integrity/platform_certs/platform_keyring.c
@@ -14,6 +14,29 @@
 #include <linux/slab.h>
 #include "../integrity.h"
 
+/**
+ * add_to_platform_keyring - Add to platform keyring without validation.
+ * @source: Source of key
+ * @data: The blob holding the key
+ * @len: The length of the data blob
+ *
+ * Add a key to the platform keyring without checking its trust chain.  This
+ * is available only during kernel initialisation.
+ */
+void __init add_to_platform_keyring(const char *source, const void *data,
+				    size_t len)
+{
+	key_perm_t perm;
+	int rc;
+
+	perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW;
+
+	rc = integrity_load_cert(INTEGRITY_KEYRING_PLATFORM, source, data, len,
+				 perm);
+	if (rc)
+		pr_info("Error adding keys to platform keyring %s\n", source);
+}
+
 /*
  * Create the trusted keyrings.
  */

commit 9dc92c45177ab70e20ae94baa2f2e558da63a9c7
Author: Nayna Jain <nayna@linux.ibm.com>
Date:   Sun Dec 9 01:56:59 2018 +0530

    integrity: Define a trusted platform keyring
    
    On secure boot enabled systems, a verified kernel may need to kexec
    additional kernels. For example, it may be used as a bootloader needing
    to kexec a target kernel or it may need to kexec a crashdump kernel. In
    such cases, it may want to verify the signature of the next kernel
    image.
    
    It is further possible that the kernel image is signed with third party
    keys which are stored as platform or firmware keys in the 'db' variable.
    The kernel, however, can not directly verify these platform keys, and an
    administrator may therefore not want to trust them for arbitrary usage.
    In order to differentiate platform keys from other keys and provide the
    necessary separation of trust, the kernel needs an additional keyring to
    store platform keys.
    
    This patch creates the new keyring called ".platform" to isolate keys
    provided by platform from keys by kernel. These keys are used to
    facilitate signature verification during kexec. Since the scope of this
    keyring is only the platform/firmware keys, it cannot be updated from
    userspace.
    
    This keyring can be enabled by setting CONFIG_INTEGRITY_PLATFORM_KEYRING.
    
    Signed-off-by: Nayna Jain <nayna@linux.ibm.com>
    Reviewed-by: Mimi Zohar <zohar@linux.ibm.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Reviewed-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/platform_certs/platform_keyring.c b/security/integrity/platform_certs/platform_keyring.c
new file mode 100644
index 000000000000..79f80af5b470
--- /dev/null
+++ b/security/integrity/platform_certs/platform_keyring.c
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Platform keyring for firmware/platform keys
+ *
+ * Copyright IBM Corporation, 2018
+ * Author(s): Nayna Jain <nayna@linux.ibm.com>
+ */
+
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cred.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include "../integrity.h"
+
+/*
+ * Create the trusted keyrings.
+ */
+static __init int platform_keyring_init(void)
+{
+	int rc;
+
+	rc = integrity_init_keyring(INTEGRITY_KEYRING_PLATFORM);
+	if (rc)
+		return rc;
+
+	pr_notice("Platform Keyring initialized\n");
+	return 0;
+}
+
+/*
+ * Must be initialised before we try and load the keys into the keyring.
+ */
+device_initcall(platform_keyring_init);
