commit 42413b49804b250ced70dac8815388af2d4ad872
Author: Roberto Sassu <roberto.sassu@huawei.com>
Date:   Fri Jun 5 08:50:28 2020 +0200

    ima: Directly free *entry in ima_alloc_init_template() if digests is NULL
    
    To support multiple template digests, the static array entry->digest has
    been replaced with a dynamically allocated array in commit aa724fe18a8a
    ("ima: Switch to dynamically allocated buffer for template digests"). The
    array is allocated in ima_alloc_init_template() and if the returned pointer
    is NULL, ima_free_template_entry() is called.
    
    However, (*entry)->template_desc is not yet initialized while it is used by
    ima_free_template_entry(). This patch fixes the issue by directly freeing
    *entry without calling ima_free_template_entry().
    
    Fixes: aa724fe18a8a ("ima: Switch to dynamically allocated buffer for template digests")
    Reported-by: syzbot+223310b454ba6b75974e@syzkaller.appspotmail.com
    Signed-off-by: Roberto Sassu <roberto.sassu@huawei.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 78e0b0a7723e..bf22de8b7ce0 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -55,8 +55,9 @@ int ima_alloc_init_template(struct ima_event_data *event_data,
 	digests = kcalloc(NR_BANKS(ima_tpm_chip) + ima_extra_slots,
 			  sizeof(*digests), GFP_NOFS);
 	if (!digests) {
-		result = -ENOMEM;
-		goto out;
+		kfree(*entry);
+		*entry = NULL;
+		return -ENOMEM;
 	}
 
 	(*entry)->digests = digests;

commit aa724fe18a8a8285d0071c3bfc932efb090d142d
Author: Roberto Sassu <roberto.sassu@huawei.com>
Date:   Wed Mar 25 11:47:09 2020 +0100

    ima: Switch to dynamically allocated buffer for template digests
    
    This patch dynamically allocates the array of tpm_digest structures in
    ima_alloc_init_template() and ima_restore_template_data(). The size of the
    array is equal to the number of PCR banks plus ima_extra_slots, to make
    room for SHA1 and the IMA default hash algorithm, when PCR banks with those
    algorithms are not allocated.
    
    Calculating the SHA1 digest is mandatory, as SHA1 still remains the default
    hash algorithm for the measurement list. When IMA will support the Crypto
    Agile format, remaining digests will be also provided.
    
    The position in the measurement entry array of the SHA1 digest is stored in
    the ima_sha1_idx global variable and is determined at IMA initialization
    time.
    
    Signed-off-by: Roberto Sassu <roberto.sassu@huawei.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 2ef5a40c7ca5..78e0b0a7723e 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -27,6 +27,7 @@ void ima_free_template_entry(struct ima_template_entry *entry)
 	for (i = 0; i < entry->template_desc->num_fields; i++)
 		kfree(entry->template_data[i].data);
 
+	kfree(entry->digests);
 	kfree(entry);
 }
 
@@ -38,6 +39,7 @@ int ima_alloc_init_template(struct ima_event_data *event_data,
 			    struct ima_template_desc *desc)
 {
 	struct ima_template_desc *template_desc;
+	struct tpm_digest *digests;
 	int i, result = 0;
 
 	if (desc)
@@ -50,6 +52,14 @@ int ima_alloc_init_template(struct ima_event_data *event_data,
 	if (!*entry)
 		return -ENOMEM;
 
+	digests = kcalloc(NR_BANKS(ima_tpm_chip) + ima_extra_slots,
+			  sizeof(*digests), GFP_NOFS);
+	if (!digests) {
+		result = -ENOMEM;
+		goto out;
+	}
+
+	(*entry)->digests = digests;
 	(*entry)->template_desc = template_desc;
 	for (i = 0; i < template_desc->num_fields; i++) {
 		const struct ima_template_field *field =

commit 7ca79645a1f8837c3850b881a2c0b43cfba5dc36
Author: Roberto Sassu <roberto.sassu@huawei.com>
Date:   Wed Mar 25 11:47:08 2020 +0100

    ima: Store template digest directly in ima_template_entry
    
    In preparation for the patch that calculates a digest for each allocated
    PCR bank, this patch passes to ima_calc_field_array_hash() the
    ima_template_entry structure, so that digests can be directly stored in
    that structure instead of ima_digest_data.
    
    Signed-off-by: Roberto Sassu <roberto.sassu@huawei.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index f6bc00914aa5..2ef5a40c7ca5 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -96,26 +96,16 @@ int ima_store_template(struct ima_template_entry *entry,
 	static const char audit_cause[] = "hashing_error";
 	char *template_name = entry->template_desc->name;
 	int result;
-	struct {
-		struct ima_digest_data hdr;
-		char digest[TPM_DIGEST_SIZE];
-	} hash;
 
 	if (!violation) {
-		int num_fields = entry->template_desc->num_fields;
-
-		/* this function uses default algo */
-		hash.hdr.algo = HASH_ALGO_SHA1;
 		result = ima_calc_field_array_hash(&entry->template_data[0],
-						   entry->template_desc,
-						   num_fields, &hash.hdr);
+						   entry);
 		if (result < 0) {
 			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,
 					    template_name, op,
 					    audit_cause, result, 0);
 			return result;
 		}
-		memcpy(entry->digest, hash.hdr.digest, hash.hdr.length);
 	}
 	entry->pcr = pcr;
 	result = ima_add_template_entry(entry, violation, op, inode, filename);

commit e9085e0ad38a333012629d815c203155d61ebe7e
Author: Lakshmi Ramasubramanian <nramas@linux.microsoft.com>
Date:   Wed Dec 11 08:47:06 2019 -0800

    IMA: Add support to limit measuring keys
    
    Limit measuring keys to those keys being loaded onto a given set of
    keyrings only and when the user id (uid) matches if uid is specified
    in the policy.
    
    This patch defines a new IMA policy option namely "keyrings=" that
    can be used to specify a set of keyrings. If this option is specified
    in the policy for "measure func=KEY_CHECK" then only the keys
    loaded onto a keyring given in the "keyrings=" option are measured.
    
    If uid is specified in the policy then the key is measured only if
    the current user id matches the one specified in the policy.
    
    Added a new parameter namely "keyring" (name of the keyring) to
    process_buffer_measurement(). The keyring name is passed to
    ima_get_action() to determine the required action.
    ima_match_rules() is updated to check keyring in the policy, if
    specified, for KEY_CHECK function.
    
    Signed-off-by: Lakshmi Ramasubramanian <nramas@linux.microsoft.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 610759fe63b8..f6bc00914aa5 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -169,12 +169,13 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  * @func: caller identifier
  * @pcr: pointer filled in if matched measure policy sets pcr=
  * @template_desc: pointer filled in if matched measure policy sets template=
+ * @keyring: keyring name used to determine the action
  *
  * The policy is defined in terms of keypairs:
  *		subj=, obj=, type=, func=, mask=, fsmagic=
  *	subj,obj, and type: are LSM specific.
  *	func: FILE_CHECK | BPRM_CHECK | CREDS_CHECK | MMAP_CHECK | MODULE_CHECK
- *	| KEXEC_CMDLINE
+ *	| KEXEC_CMDLINE | KEY_CHECK
  *	mask: contains the permission mask
  *	fsmagic: hex value
  *
@@ -183,14 +184,15 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  */
 int ima_get_action(struct inode *inode, const struct cred *cred, u32 secid,
 		   int mask, enum ima_hooks func, int *pcr,
-		   struct ima_template_desc **template_desc)
+		   struct ima_template_desc **template_desc,
+		   const char *keyring)
 {
 	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE | IMA_HASH;
 
 	flags &= ima_policy_flag;
 
 	return ima_match_policy(inode, cred, secid, func, mask, flags, pcr,
-				template_desc);
+				template_desc, keyring);
 }
 
 /*

commit 2a7f0e53daf29ca6dc9fbe2a27158f13474ec1b5
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Aug 29 12:29:16 2019 -0500

    ima: ima_api: Use struct_size() in kzalloc()
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct ima_template_entry {
            ...
            struct ima_field_data template_data[0]; /* template related data */
    };
    
    instance = kzalloc(sizeof(struct ima_template_entry) + count * sizeof(struct ima_field_data), GFP_NOFS);
    
    Instead of leaving these open-coded and prone to type mistakes, we can
    now use the new struct_size() helper:
    
    instance = kzalloc(struct_size(instance, entry, count), GFP_NOFS);
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 65224474675b..610759fe63b8 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -45,8 +45,8 @@ int ima_alloc_init_template(struct ima_event_data *event_data,
 	else
 		template_desc = ima_template_desc_current();
 
-	*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *
-			 sizeof(struct ima_field_data), GFP_NOFS);
+	*entry = kzalloc(struct_size(*entry, template_data,
+				     template_desc->num_fields), GFP_NOFS);
 	if (!*entry)
 		return -ENOMEM;
 

commit e5092255bb3967bcc473dc86492dbbd5f7714023
Author: Thiago Jung Bauermann <bauerman@linux.ibm.com>
Date:   Thu Jun 27 23:19:33 2019 -0300

    ima: Store the measurement again when appraising a modsig
    
    If the IMA template contains the "modsig" or "d-modsig" field, then the
    modsig should be added to the measurement list when the file is appraised.
    
    And that is what normally happens, but if a measurement rule caused a file
    containing a modsig to be measured before a different rule causes it to be
    appraised, the resulting measurement entry will not contain the modsig
    because it is only fetched during appraisal. When the appraisal rule
    triggers, it won't store a new measurement containing the modsig because
    the file was already measured.
    
    We need to detect that situation and store an additional measurement with
    the modsig. This is done by adding an IMA_MEASURE action flag if we read a
    modsig and the IMA template contains a modsig field.
    
    Suggested-by: Mimi Zohar <zohar@linux.ibm.com>
    Signed-off-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index ca930e2ebc2c..65224474675b 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -219,6 +219,14 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 		char digest[IMA_MAX_DIGEST_SIZE];
 	} hash;
 
+	/*
+	 * Always collect the modsig, because IMA might have already collected
+	 * the file digest without collecting the modsig in a previous
+	 * measurement rule.
+	 */
+	if (modsig)
+		ima_collect_modsig(modsig, buf, size);
+
 	if (iint->flags & IMA_COLLECTED)
 		goto out;
 
@@ -252,9 +260,6 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	memcpy(iint->ima_hash, &hash, length);
 	iint->version = i_version;
 
-	if (modsig)
-		ima_collect_modsig(modsig, buf, size);
-
 	/* Possibly temporary failure due to type of read (eg. O_DIRECT) */
 	if (!result)
 		iint->flags |= IMA_COLLECTED;
@@ -304,7 +309,13 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 					     .modsig = modsig };
 	int violation = 0;
 
-	if (iint->measured_pcrs & (0x1 << pcr))
+	/*
+	 * We still need to store the measurement in the case of MODSIG because
+	 * we only have its contents to put in the list at the time of
+	 * appraisal, but a file measurement from earlier might already exist in
+	 * the measurement list.
+	 */
+	if (iint->measured_pcrs & (0x1 << pcr) && !modsig)
 		return;
 
 	result = ima_alloc_init_template(&event_data, &entry, template_desc);

commit 3878d505aa718bcc7b1eb4089ab9b9fb27dee957
Author: Thiago Jung Bauermann <bauerman@linux.ibm.com>
Date:   Thu Jun 27 23:19:32 2019 -0300

    ima: Define ima-modsig template
    
    Define new "d-modsig" template field which holds the digest that is
    expected to match the one contained in the modsig, and also new "modsig"
    template field which holds the appended file signature.
    
    Add a new "ima-modsig" defined template descriptor with the new fields as
    well as the ones from the "ima-sig" descriptor.
    
    Change ima_store_measurement() to accept a struct modsig * argument so that
    it can be passed along to the templates via struct ima_event_data.
    
    Suggested-by: Mimi Zohar <zohar@linux.ibm.com>
    Signed-off-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index ff8b7fb03ea0..ca930e2ebc2c 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -288,7 +288,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 void ima_store_measurement(struct integrity_iint_cache *iint,
 			   struct file *file, const unsigned char *filename,
 			   struct evm_ima_xattr_data *xattr_value,
-			   int xattr_len, int pcr,
+			   int xattr_len, const struct modsig *modsig, int pcr,
 			   struct ima_template_desc *template_desc)
 {
 	static const char op[] = "add_template_measure";
@@ -300,7 +300,8 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 					     .file = file,
 					     .filename = filename,
 					     .xattr_value = xattr_value,
-					     .xattr_len = xattr_len };
+					     .xattr_len = xattr_len,
+					     .modsig = modsig };
 	int violation = 0;
 
 	if (iint->measured_pcrs & (0x1 << pcr))

commit 15588227e086ec662d59df144e48af82e3e592f1
Author: Thiago Jung Bauermann <bauerman@linux.ibm.com>
Date:   Thu Jun 27 23:19:31 2019 -0300

    ima: Collect modsig
    
    Obtain the modsig and calculate its corresponding hash in
    ima_collect_measurement().
    
    Signed-off-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index f614e22bf39f..ff8b7fb03ea0 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -205,7 +205,7 @@ int ima_get_action(struct inode *inode, const struct cred *cred, u32 secid,
  */
 int ima_collect_measurement(struct integrity_iint_cache *iint,
 			    struct file *file, void *buf, loff_t size,
-			    enum hash_algo algo)
+			    enum hash_algo algo, struct modsig *modsig)
 {
 	const char *audit_cause = "failed";
 	struct inode *inode = file_inode(file);
@@ -252,6 +252,9 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	memcpy(iint->ima_hash, &hash, length);
 	iint->version = i_version;
 
+	if (modsig)
+		ima_collect_modsig(modsig, buf, size);
+
 	/* Possibly temporary failure due to type of read (eg. O_DIRECT) */
 	if (!result)
 		iint->flags |= IMA_COLLECTED;

commit 8b68150883ca466a23e90902dd4113b22e692f04
Merge: 0f75ef6a9cff 650b29dbdf2c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 20:28:59 2019 -0700

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity
    
    Pull integrity updates from Mimi Zohar:
     "Bug fixes, code clean up, and new features:
    
       - IMA policy rules can be defined in terms of LSM labels, making the
         IMA policy dependent on LSM policy label changes, in particular LSM
         label deletions. The new environment, in which IMA-appraisal is
         being used, frequently updates the LSM policy and permits LSM label
         deletions.
    
       - Prevent an mmap'ed shared file opened for write from also being
         mmap'ed execute. In the long term, making this and other similar
         changes at the VFS layer would be preferable.
    
       - The IMA per policy rule template format support is needed for a
         couple of new/proposed features (eg. kexec boot command line
         measurement, appended signatures, and VFS provided file hashes).
    
       - Other than the "boot-aggregate" record in the IMA measuremeent
         list, all other measurements are of file data. Measuring and
         storing the kexec boot command line in the IMA measurement list is
         the first buffer based measurement included in the measurement
         list"
    
    * 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity:
      integrity: Introduce struct evm_xattr
      ima: Update MAX_TEMPLATE_NAME_LEN to fit largest reasonable definition
      KEXEC: Call ima_kexec_cmdline to measure the boot command line args
      IMA: Define a new template field buf
      IMA: Define a new hook to measure the kexec boot command line arguments
      IMA: support for per policy rule template formats
      integrity: Fix __integrity_init_keyring() section mismatch
      ima: Use designated initializers for struct ima_event_data
      ima: use the lsm policy update notifier
      LSM: switch to blocking policy update notifiers
      x86/ima: fix the Kconfig dependency for IMA_ARCH_POLICY
      ima: Make arch_policy_entry static
      ima: prevent a file already mmap'ed write to be mmap'ed execute
      x86/ima: check EFI SetupMode too

commit b0935123a18360d19f1dcc779ea33841cdc304cc
Author: Prakhar Srivastava <prsriva02@gmail.com>
Date:   Sun Jun 23 23:23:29 2019 -0700

    IMA: Define a new hook to measure the kexec boot command line arguments
    
    Currently during soft reboot(kexec_file_load) boot command line
    arguments are not measured. Define hooks needed to measure kexec
    command line arguments during soft reboot(kexec_file_load).
    
    - A new ima hook ima_kexec_cmdline is defined to be called by the
    kexec code.
    - A new function process_buffer_measurement is defined to measure
    the buffer hash into the IMA measurement list.
    - A new func policy KEXEC_CMDLINE is defined to control the
     measurement.
    
    Signed-off-by: Prakhar Srivastava <prsriva02@gmail.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index c0cf4bcfc82f..d426d4d1fe04 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -178,6 +178,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  *		subj=, obj=, type=, func=, mask=, fsmagic=
  *	subj,obj, and type: are LSM specific.
  *	func: FILE_CHECK | BPRM_CHECK | CREDS_CHECK | MMAP_CHECK | MODULE_CHECK
+ *	| KEXEC_CMDLINE
  *	mask: contains the permission mask
  *	fsmagic: hex value
  *

commit 19453ce0bcfbdf7332a104eebf5d835977af7284
Author: Matthew Garrett <matthewgarrett@google.com>
Date:   Wed Jun 19 15:46:11 2019 -0700

    IMA: support for per policy rule template formats
    
    Admins may wish to log different measurements using different IMA
    templates. Add support for overriding the default template on a per-rule
    basis.
    
    Inspired-by: Roberto Sassu <roberto.sassu@huawei.com>
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 4aec6b035fe9..c0cf4bcfc82f 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -38,11 +38,17 @@ void ima_free_template_entry(struct ima_template_entry *entry)
  * ima_alloc_init_template - create and initialize a new template entry
  */
 int ima_alloc_init_template(struct ima_event_data *event_data,
-			    struct ima_template_entry **entry)
+			    struct ima_template_entry **entry,
+			    struct ima_template_desc *desc)
 {
-	struct ima_template_desc *template_desc = ima_template_desc_current();
+	struct ima_template_desc *template_desc;
 	int i, result = 0;
 
+	if (desc)
+		template_desc = desc;
+	else
+		template_desc = ima_template_desc_current();
+
 	*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *
 			 sizeof(struct ima_field_data), GFP_NOFS);
 	if (!*entry)
@@ -143,7 +149,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 	/* can overflow, only indicator */
 	atomic_long_inc(&ima_htable.violations);
 
-	result = ima_alloc_init_template(&event_data, &entry);
+	result = ima_alloc_init_template(&event_data, &entry, NULL);
 	if (result < 0) {
 		result = -ENOMEM;
 		goto err_out;
@@ -166,6 +172,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  *        MAY_APPEND)
  * @func: caller identifier
  * @pcr: pointer filled in if matched measure policy sets pcr=
+ * @template_desc: pointer filled in if matched measure policy sets template=
  *
  * The policy is defined in terms of keypairs:
  *		subj=, obj=, type=, func=, mask=, fsmagic=
@@ -178,13 +185,15 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  *
  */
 int ima_get_action(struct inode *inode, const struct cred *cred, u32 secid,
-		   int mask, enum ima_hooks func, int *pcr)
+		   int mask, enum ima_hooks func, int *pcr,
+		   struct ima_template_desc **template_desc)
 {
 	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE | IMA_HASH;
 
 	flags &= ima_policy_flag;
 
-	return ima_match_policy(inode, cred, secid, func, mask, flags, pcr);
+	return ima_match_policy(inode, cred, secid, func, mask, flags, pcr,
+				template_desc);
 }
 
 /*
@@ -279,7 +288,8 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 void ima_store_measurement(struct integrity_iint_cache *iint,
 			   struct file *file, const unsigned char *filename,
 			   struct evm_ima_xattr_data *xattr_value,
-			   int xattr_len, int pcr)
+			   int xattr_len, int pcr,
+			   struct ima_template_desc *template_desc)
 {
 	static const char op[] = "add_template_measure";
 	static const char audit_cause[] = "ENOMEM";
@@ -296,7 +306,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	if (iint->measured_pcrs & (0x1 << pcr))
 		return;
 
-	result = ima_alloc_init_template(&event_data, &entry);
+	result = ima_alloc_init_template(&event_data, &entry, template_desc);
 	if (result < 0) {
 		integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,
 				    op, audit_cause, result, 0);

commit e038f5f691e003af25cda0f1593d2cc0a4d1c866
Author: Thiago Jung Bauermann <bauerman@linux.ibm.com>
Date:   Tue Jun 11 03:28:10 2019 -0300

    ima: Use designated initializers for struct ima_event_data
    
    Designated initializers allow specifying only the members of the struct
    that need initialization. Non-mentioned members are initialized to zero.
    
    This makes the code a bit clearer (particularly in ima_add_boot_aggregate)
    and also allows adding a new member to the struct without having to update
    all struct initializations.
    
    Signed-off-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index c7505fb122d4..4aec6b035fe9 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -133,8 +133,10 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 {
 	struct ima_template_entry *entry;
 	struct inode *inode = file_inode(file);
-	struct ima_event_data event_data = {iint, file, filename, NULL, 0,
-					    cause};
+	struct ima_event_data event_data = { .iint = iint,
+					     .file = file,
+					     .filename = filename,
+					     .violation = cause };
 	int violation = 1;
 	int result;
 
@@ -284,8 +286,11 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	int result = -ENOMEM;
 	struct inode *inode = file_inode(file);
 	struct ima_template_entry *entry;
-	struct ima_event_data event_data = {iint, file, filename, xattr_value,
-					    xattr_len, NULL};
+	struct ima_event_data event_data = { .iint = iint,
+					     .file = file,
+					     .filename = filename,
+					     .xattr_value = xattr_value,
+					     .xattr_len = xattr_len };
 	int violation = 0;
 
 	if (iint->measured_pcrs & (0x1 << pcr))

commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index c7505fb122d4..35c129cbb7e9 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2008 IBM Corporation
  *
  * Author: Mimi Zohar <zohar@us.ibm.com>
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation, version 2 of the
- * License.
- *
  * File: ima_api.c
  *	Implements must_appraise_or_measure, collect_measurement,
  *	appraise_measurement, store_measurement and store_template.

commit 3f03bf93947fa2a2b84fac56e93c65d4fffed7f1
Merge: fb2a624d5fe8 b49d564344f7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 27 12:04:52 2018 -0800

    Merge branch 'next-general' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull general security subsystem updates from James Morris:
     "The main changes here are Paul Gortmaker's removal of unneccesary
      module.h infrastructure"
    
    * 'next-general' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      security: integrity: partial revert of make ima_main explicitly non-modular
      security: fs: make inode explicitly non-modular
      security: audit and remove any unnecessary uses of module.h
      security: integrity: make evm_main explicitly non-modular
      keys: remove needless modular infrastructure from ecryptfs_format
      security: integrity: make ima_main explicitly non-modular
      tomoyo: fix small typo

commit 876979c9308b7228cdaf6785909c57eebc85d911
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Dec 9 15:36:29 2018 -0500

    security: audit and remove any unnecessary uses of module.h
    
    Historically a lot of these existed because we did not have
    a distinction between what was modular code and what was providing
    support to modules via EXPORT_SYMBOL and friends.  That changed
    when we forked out support for the latter into the export.h file.
    This means we should be able to reduce the usage of module.h
    in code that is obj-y Makefile or bool Kconfig.
    
    The advantage in removing such instances is that module.h itself
    sources about 15 other headers; adding significantly to what we feed
    cpp, and it can obscure what headers we are effectively using.
    
    Since module.h might have been the implicit source for init.h
    (for __init) and for export.h (for EXPORT_SYMBOL) we consider each
    instance for the presence of either and replace as needed.
    
    Cc: James Morris <jmorris@namei.org>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Mimi Zohar <zohar@linux.ibm.com>
    Cc: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: linux-security-module@vger.kernel.org
    Cc: linux-integrity@vger.kernel.org
    Cc: keyrings@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 99dd1d53fc35..67dfbd1af3ca 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -12,7 +12,6 @@
  *	Implements must_appraise_or_measure, collect_measurement,
  *	appraise_measurement, store_measurement and store_template.
  */
-#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/file.h>
 #include <linux/fs.h>

commit 2a1fe215e7300c7ebd6a7a24afcab71db5107bb0
Author: Paul Moore <paul@paul-moore.com>
Date:   Mon Nov 26 18:40:07 2018 -0500

    audit: use current whenever possible
    
    There are many places, notably audit_log_task_info() and
    audit_log_exit(), that take task_struct pointers but in reality they
    are always working on the current task.  This patch eliminates the
    task_struct arguments and uses current directly which allows a number
    of cleanups as well.
    
    Acked-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 99dd1d53fc35..af134588ab4e 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -336,7 +336,7 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 	audit_log_untrustedstring(ab, filename);
 	audit_log_format(ab, " hash=\"%s:%s\"", algo_name, hash);
 
-	audit_log_task_info(ab, current);
+	audit_log_task_info(ab);
 	audit_log_end(ab);
 
 	iint->flags |= IMA_AUDITED;

commit b2724d5802a77b7fb47e84d9b88b80370eccbc64
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Sep 7 13:22:23 2018 -0700

    security/integrity: constify some read-only data
    
    Constify some static data that is never modified,
    so that it is placed in .rodata.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index a02c5acfd403..99dd1d53fc35 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -51,7 +51,8 @@ int ima_alloc_init_template(struct ima_event_data *event_data,
 
 	(*entry)->template_desc = template_desc;
 	for (i = 0; i < template_desc->num_fields; i++) {
-		struct ima_template_field *field = template_desc->fields[i];
+		const struct ima_template_field *field =
+			template_desc->fields[i];
 		u32 len;
 
 		result = field->field_init(event_data,

commit cdfb6b341f0f2409aba24b84f3b4b2bba50be5c5
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Sat May 12 21:58:20 2018 -0400

    audit: use inline function to get audit context
    
    Recognizing that the audit context is an internal audit value, use an
    access function to retrieve the audit context pointer for the task
    rather than reaching directly into the task struct to get it.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: merge fuzz in auditsc.c and selinuxfs.c, checkpatch.pl fixes]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index bf88236b7a0b..a02c5acfd403 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -326,7 +326,7 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 		hex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);
 	hash[i * 2] = '\0';
 
-	ab = audit_log_start(current->audit_context, GFP_KERNEL,
+	ab = audit_log_start(audit_context(), GFP_KERNEL,
 			     AUDIT_INTEGRITY_RULE);
 	if (!ab)
 		goto out;

commit e456ef88ae8c9ffd303e970c28dcce4474c3d356
Author: Tycho Andersen <tycho@tycho.ws>
Date:   Thu Mar 8 16:08:36 2018 -0700

    ima: drop vla in ima_audit_measurement()
    
    In keeping with the directive to get rid of VLAs [1], let's drop the VLA
    from ima_audit_measurement(). We need to adjust the return type of
    ima_audit_measurement, because now this function can fail if an allocation
    fails.
    
    [1]: https://lkml.org/lkml/2018/3/7/621
    
    v2: just use audit_log_format instead of doing a second allocation
    v3: ignore failures in ima_audit_measurement()
    
    Signed-off-by: Tycho Andersen <tycho@tycho.ws>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 33b4458cdbef..bf88236b7a0b 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -311,14 +311,17 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 			   const unsigned char *filename)
 {
 	struct audit_buffer *ab;
-	char hash[(iint->ima_hash->length * 2) + 1];
+	char *hash;
 	const char *algo_name = hash_algo_name[iint->ima_hash->algo];
-	char algo_hash[sizeof(hash) + strlen(algo_name) + 2];
 	int i;
 
 	if (iint->flags & IMA_AUDITED)
 		return;
 
+	hash = kzalloc((iint->ima_hash->length * 2) + 1, GFP_KERNEL);
+	if (!hash)
+		return;
+
 	for (i = 0; i < iint->ima_hash->length; i++)
 		hex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);
 	hash[i * 2] = '\0';
@@ -326,18 +329,19 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 	ab = audit_log_start(current->audit_context, GFP_KERNEL,
 			     AUDIT_INTEGRITY_RULE);
 	if (!ab)
-		return;
+		goto out;
 
 	audit_log_format(ab, "file=");
 	audit_log_untrustedstring(ab, filename);
-	audit_log_format(ab, " hash=");
-	snprintf(algo_hash, sizeof(algo_hash), "%s:%s", algo_name, hash);
-	audit_log_untrustedstring(ab, algo_hash);
+	audit_log_format(ab, " hash=\"%s:%s\"", algo_name, hash);
 
 	audit_log_task_info(ab, current);
 	audit_log_end(ab);
 
 	iint->flags |= IMA_AUDITED;
+out:
+	kfree(hash);
+	return;
 }
 
 /*

commit d906c10d8a31654cb9167c9a2ebc7d3e43820bad
Author: Matthew Garrett <mjg59@google.com>
Date:   Mon Jan 8 13:36:20 2018 -0800

    IMA: Support using new creds in appraisal policy
    
    The existing BPRM_CHECK functionality in IMA validates against the
    credentials of the existing process, not any new credentials that the
    child process may transition to. Add an additional CREDS_CHECK target
    and refactor IMA to pass the appropriate creds structure. In
    ima_bprm_check(), check with both the existing process credentials and
    the credentials that will be committed when the new process is started.
    This will not change behaviour unless the system policy is extended to
    include CREDS_CHECK targets - BPRM_CHECK will continue to check the same
    credentials that it did previously.
    
    After this patch, an IMA policy rule along the lines of:
    
    measure func=CREDS_CHECK subj_type=unconfined_t
    
    will trigger if a process is executed and runs as unconfined_t, ignoring
    the context of the parent process. This is in contrast to:
    
    measure func=BPRM_CHECK subj_type=unconfined_t
    
    which will trigger if the process that calls exec() is already executing
    in unconfined_t, ignoring the context that the child process executes
    into.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    
    Changelog:
    - initialize ima_creds_status

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 08fe405338e1..33b4458cdbef 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -158,6 +158,8 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 /**
  * ima_get_action - appraise & measure decision based on policy.
  * @inode: pointer to inode to measure
+ * @cred: pointer to credentials structure to validate
+ * @secid: secid of the task being validated
  * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXEC,
  *        MAY_APPEND)
  * @func: caller identifier
@@ -166,20 +168,21 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  * The policy is defined in terms of keypairs:
  *		subj=, obj=, type=, func=, mask=, fsmagic=
  *	subj,obj, and type: are LSM specific.
- *	func: FILE_CHECK | BPRM_CHECK | MMAP_CHECK | MODULE_CHECK
+ *	func: FILE_CHECK | BPRM_CHECK | CREDS_CHECK | MMAP_CHECK | MODULE_CHECK
  *	mask: contains the permission mask
  *	fsmagic: hex value
  *
  * Returns IMA_MEASURE, IMA_APPRAISE mask.
  *
  */
-int ima_get_action(struct inode *inode, int mask, enum ima_hooks func, int *pcr)
+int ima_get_action(struct inode *inode, const struct cred *cred, u32 secid,
+		   int mask, enum ima_hooks func, int *pcr)
 {
 	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE | IMA_HASH;
 
 	flags &= ima_policy_flag;
 
-	return ima_match_policy(inode, func, mask, flags, pcr);
+	return ima_match_policy(inode, cred, secid, func, mask, flags, pcr);
 }
 
 /*

commit 3c29548f87f9545f2f3c1cd1a784fae8ad2d53ba
Merge: e1c70f32386c 36447456e1cc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 13:07:35 2018 -0800

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull integrity updates from James Morris:
     "This contains a mixture of bug fixes, code cleanup, and new
      functionality. Of note is the integrity cache locking fix, file change
      detection, and support for a new EVM portable and immutable signature
      type.
    
      The re-introduction of the integrity cache lock (iint) fixes the
      problem of attempting to take the i_rwsem shared a second time, when
      it was previously taken exclusively. Defining atomic flags resolves
      the original iint/i_rwsem circular locking - accessing the file data
      vs. modifying the file metadata. Although it fixes the O_DIRECT
      problem as well, a subsequent patch is needed to remove the explicit
      O_DIRECT prevention.
    
      For performance reasons, detecting when a file has changed and needs
      to be re-measured, re-appraised, and/or re-audited, was limited to
      after the last writer has closed, and only if the file data has
      changed. Detecting file change is based on i_version. For filesystems
      that do not support i_version, remote filesystems, or userspace
      filesystems, the file was measured, appraised and/or audited once and
      never re-evaluated. Now local filesystems, which do not support
      i_version or are not mounted with the i_version option, assume the
      file has changed and are required to re-evaluate the file. This change
      does not address detecting file change on remote or userspace
      filesystems.
    
      Unlike file data signatures, which can be included and distributed in
      software packages (eg. rpm, deb), the existing EVM signature, which
      protects the file metadata, could not be included in software
      packages, as it includes file system specific information (eg. i_ino,
      possibly the UUID). This pull request defines a new EVM portable and
      immutable file metadata signature format, which can be included in
      software packages"
    
    * 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      ima/policy: fix parsing of fsuuid
      ima: Use i_version only when filesystem supports it
      integrity: remove unneeded initializations in integrity_iint_cache entries
      ima: log message to module appraisal error
      ima: pass filename to ima_rdwr_violation_check()
      ima: Fix line continuation format
      ima: support new "hash" and "dont_hash" policy actions
      ima: re-introduce own integrity cache lock
      EVM: Add support for portable signature format
      EVM: Allow userland to permit modification of EVM-protected metadata
      ima: relax requiring a file signature for new files with zero length

commit 3b370b215f4b45c0be87d7a15b0d0e2e8b238aee
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Dec 11 06:35:21 2017 -0500

    IMA: switch IMA over to new i_version API
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index c7e8db0ea4c0..c6ae42266270 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -18,6 +18,7 @@
 #include <linux/fs.h>
 #include <linux/xattr.h>
 #include <linux/evm.h>
+#include <linux/iversion.h>
 
 #include "ima.h"
 
@@ -215,7 +216,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	 * which do not support i_version, support is limited to an initial
 	 * measurement/appraisal/audit.
 	 */
-	i_version = file_inode(file)->i_version;
+	i_version = inode_query_iversion(inode);
 	hash.hdr.algo = algo;
 
 	/* Initialize hash digest to 0's in case of failure */

commit da1b0029f527a9b4204e90ba6f14ee139fd76f9e
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Sep 29 10:04:52 2016 -0400

    ima: support new "hash" and "dont_hash" policy actions
    
    The builtin ima_appraise_tcb policy, which is specified on the boot
    command line, can be replaced with a custom policy, normally early in
    the boot process.  Custom policies can be more restrictive in some ways,
    like requiring file signatures, but can be less restrictive in other
    ways, like not appraising mutable files.  With a less restrictive policy
    in place, files in the builtin policy might not be hashed and labeled
    with a security.ima hash.  On reboot, files which should be labeled in
    the ima_appraise_tcb are not labeled, possibly preventing the system
    from booting properly.
    
    To resolve this problem, this patch extends the existing IMA policy
    actions "measure", "dont_measure", "appraise", "dont_appraise", and
    "audit" with "hash" and "dont_hash".  The new "hash" action will write
    the file hash as security.ima, but without requiring the file to be
    appraised as well.
    
    For example, the builtin ima_appraise_tcb policy includes the rule,
    "appraise fowner=0".  Adding the "hash fowner=0" rule to a custom
    policy, will cause the needed file hashes to be calculated and written
    as security.ima xattrs.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Stefan Berger <stefanb@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index c7e8db0ea4c0..877f446fdca2 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -174,7 +174,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  */
 int ima_get_action(struct inode *inode, int mask, enum ima_hooks func, int *pcr)
 {
-	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;
+	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE | IMA_HASH;
 
 	flags &= ima_policy_flag;
 

commit f3cc6b25dcc5616f0d5c720009b2ac66f97df2ff
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Sat Jun 17 23:56:23 2017 -0400

    ima: always measure and audit files in policy
    
    All files matching a "measure" rule must be included in the IMA
    measurement list, even when the file hash cannot be calculated.
    Similarly, all files matching an "audit" rule must be audited, even when
    the file hash can not be calculated.
    
    The file data hash field contained in the IMA measurement list template
    data will contain 0's instead of the actual file hash digest.
    
    Note:
    In general, adding, deleting or in anyway changing which files are
    included in the IMA measurement list is not a good idea, as it might
    result in not being able to unseal trusted keys sealed to a specific
    TPM PCR value.  This patch not only adds file measurements that were
    not previously measured, but specifies that the file hash value for
    these files will be 0's.
    
    As the IMA measurement list ordering is not consistent from one boot
    to the next, it is unlikely that anyone is sealing keys based on the
    IMA measurement list.  Remote attestation servers should be able to
    process these new measurement records, but might complain about
    these unknown records.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Reviewed-by: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index c2edba8de35e..c7e8db0ea4c0 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -199,42 +199,59 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	struct inode *inode = file_inode(file);
 	const char *filename = file->f_path.dentry->d_name.name;
 	int result = 0;
+	int length;
+	void *tmpbuf;
+	u64 i_version;
 	struct {
 		struct ima_digest_data hdr;
 		char digest[IMA_MAX_DIGEST_SIZE];
 	} hash;
 
-	if (!(iint->flags & IMA_COLLECTED)) {
-		u64 i_version = file_inode(file)->i_version;
+	if (iint->flags & IMA_COLLECTED)
+		goto out;
 
-		if (file->f_flags & O_DIRECT) {
-			audit_cause = "failed(directio)";
-			result = -EACCES;
-			goto out;
-		}
+	/*
+	 * Dectecting file change is based on i_version. On filesystems
+	 * which do not support i_version, support is limited to an initial
+	 * measurement/appraisal/audit.
+	 */
+	i_version = file_inode(file)->i_version;
+	hash.hdr.algo = algo;
 
-		hash.hdr.algo = algo;
-
-		result = (!buf) ?  ima_calc_file_hash(file, &hash.hdr) :
-			ima_calc_buffer_hash(buf, size, &hash.hdr);
-		if (!result) {
-			int length = sizeof(hash.hdr) + hash.hdr.length;
-			void *tmpbuf = krealloc(iint->ima_hash, length,
-						GFP_NOFS);
-			if (tmpbuf) {
-				iint->ima_hash = tmpbuf;
-				memcpy(iint->ima_hash, &hash, length);
-				iint->version = i_version;
-				iint->flags |= IMA_COLLECTED;
-			} else
-				result = -ENOMEM;
-		}
+	/* Initialize hash digest to 0's in case of failure */
+	memset(&hash.digest, 0, sizeof(hash.digest));
+
+	if (buf)
+		result = ima_calc_buffer_hash(buf, size, &hash.hdr);
+	else
+		result = ima_calc_file_hash(file, &hash.hdr);
+
+	if (result && result != -EBADF && result != -EINVAL)
+		goto out;
+
+	length = sizeof(hash.hdr) + hash.hdr.length;
+	tmpbuf = krealloc(iint->ima_hash, length, GFP_NOFS);
+	if (!tmpbuf) {
+		result = -ENOMEM;
+		goto out;
 	}
+
+	iint->ima_hash = tmpbuf;
+	memcpy(iint->ima_hash, &hash, length);
+	iint->version = i_version;
+
+	/* Possibly temporary failure due to type of read (eg. O_DIRECT) */
+	if (!result)
+		iint->flags |= IMA_COLLECTED;
 out:
-	if (result)
+	if (result) {
+		if (file->f_flags & O_DIRECT)
+			audit_cause = "failed(directio)";
+
 		integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,
 				    filename, "collect_data", audit_cause,
 				    result, 0);
+	}
 	return result;
 }
 
@@ -278,7 +295,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	}
 
 	result = ima_store_template(entry, violation, inode, filename, pcr);
-	if (!result || result == -EEXIST) {
+	if ((!result || result == -EEXIST) && !(file->f_flags & O_DIRECT)) {
 		iint->flags |= IMA_MEASURED;
 		iint->measured_pcrs |= (0x1 << pcr);
 	}

commit 20f482ab9e0f800d1e01ce748ebd382d085abe56
Author: Lans Zhang <jia.zhang@windriver.com>
Date:   Fri Jan 6 12:38:11 2017 +0800

    ima: allow to check MAY_APPEND
    
    Otherwise some mask and inmask tokens with MAY_APPEND flag may not work
    as expected.
    
    Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index d01a52f8f708..c2edba8de35e 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -157,7 +157,8 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 /**
  * ima_get_action - appraise & measure decision based on policy.
  * @inode: pointer to inode to measure
- * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
+ * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXEC,
+ *        MAY_APPEND)
  * @func: caller identifier
  * @pcr: pointer filled in if matched measure policy sets pcr=
  *

commit bc15ed663e7e53ee4dc3e60f8d09c93a0528c694
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Jan 17 06:45:41 2017 -0500

    ima: fix ima_d_path() possible race with rename
    
    On failure to return a pathname from ima_d_path(), a pointer to
    dname is returned, which is subsequently used in the IMA measurement
    list, the IMA audit records, and other audit logging.  Saving the
    pointer to dname for later use has the potential to race with rename.
    
    Intead of returning a pointer to dname on failure, this patch returns
    a pointer to a copy of the filename.
    
    Reported-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: stable@vger.kernel.org

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 9df26a2b75ba..d01a52f8f708 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -318,7 +318,17 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 	iint->flags |= IMA_AUDITED;
 }
 
-const char *ima_d_path(const struct path *path, char **pathbuf)
+/*
+ * ima_d_path - return a pointer to the full pathname
+ *
+ * Attempt to return a pointer to the full pathname for use in the
+ * IMA measurement list, IMA audit records, and auditing logs.
+ *
+ * On failure, return a pointer to a copy of the filename, not dname.
+ * Returning a pointer to dname, could result in using the pointer
+ * after the memory has been freed.
+ */
+const char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)
 {
 	char *pathname = NULL;
 
@@ -331,5 +341,11 @@ const char *ima_d_path(const struct path *path, char **pathbuf)
 			pathname = NULL;
 		}
 	}
-	return pathname ?: (const char *)path->dentry->d_name.name;
+
+	if (!pathname) {
+		strlcpy(namebuf, path->dentry->d_name.name, NAME_MAX);
+		pathname = namebuf;
+	}
+
+	return pathname;
 }

commit a422638d492a35316e3fd9bb31bfc9769b249bca
Author: Eric Richter <erichte@linux.vnet.ibm.com>
Date:   Wed Jun 1 13:14:06 2016 -0500

    ima: change integrity cache to store measured pcr
    
    IMA avoids re-measuring files by storing the current state as a flag in
    the integrity cache. It will then skip adding a new measurement log entry
    if the cache reports the file as already measured.
    
    If a policy measures an already measured file to a new PCR, the measurement
    will not be added to the list. This patch implements a new bitfield for
    specifying which PCR the file was measured into, rather than if it was
    measured.
    
    Signed-off-by: Eric Richter <erichte@linux.vnet.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 8363ba384992..9df26a2b75ba 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -266,7 +266,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 					    xattr_len, NULL};
 	int violation = 0;
 
-	if (iint->flags & IMA_MEASURED)
+	if (iint->measured_pcrs & (0x1 << pcr))
 		return;
 
 	result = ima_alloc_init_template(&event_data, &entry);
@@ -277,8 +277,10 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	}
 
 	result = ima_store_template(entry, violation, inode, filename, pcr);
-	if (!result || result == -EEXIST)
+	if (!result || result == -EEXIST) {
 		iint->flags |= IMA_MEASURED;
+		iint->measured_pcrs |= (0x1 << pcr);
+	}
 	if (result < 0)
 		ima_free_template_entry(entry);
 }

commit 14b1da85bbe9a59c5e01123a06dea4c4758a6db9
Author: Eric Richter <erichte@linux.vnet.ibm.com>
Date:   Wed Jun 1 13:14:03 2016 -0500

    ima: include pcr for each measurement log entry
    
    The IMA measurement list entries include the Kconfig defined PCR value.
    This patch defines a new ima_template_entry field for including the PCR
    as specified in the policy rule.
    
    Signed-off-by: Eric Richter <erichte@linux.vnet.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 225b9cede300..8363ba384992 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -87,7 +87,7 @@ int ima_alloc_init_template(struct ima_event_data *event_data,
  */
 int ima_store_template(struct ima_template_entry *entry,
 		       int violation, struct inode *inode,
-		       const unsigned char *filename)
+		       const unsigned char *filename, int pcr)
 {
 	static const char op[] = "add_template_measure";
 	static const char audit_cause[] = "hashing_error";
@@ -114,6 +114,7 @@ int ima_store_template(struct ima_template_entry *entry,
 		}
 		memcpy(entry->digest, hash.hdr.digest, hash.hdr.length);
 	}
+	entry->pcr = pcr;
 	result = ima_add_template_entry(entry, violation, op, inode, filename);
 	return result;
 }
@@ -144,7 +145,8 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 		result = -ENOMEM;
 		goto err_out;
 	}
-	result = ima_store_template(entry, violation, inode, filename);
+	result = ima_store_template(entry, violation, inode,
+				    filename, CONFIG_IMA_MEASURE_PCR_IDX);
 	if (result < 0)
 		ima_free_template_entry(entry);
 err_out:
@@ -253,7 +255,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 void ima_store_measurement(struct integrity_iint_cache *iint,
 			   struct file *file, const unsigned char *filename,
 			   struct evm_ima_xattr_data *xattr_value,
-			   int xattr_len)
+			   int xattr_len, int pcr)
 {
 	static const char op[] = "add_template_measure";
 	static const char audit_cause[] = "ENOMEM";
@@ -274,7 +276,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 		return;
 	}
 
-	result = ima_store_template(entry, violation, inode, filename);
+	result = ima_store_template(entry, violation, inode, filename, pcr);
 	if (!result || result == -EEXIST)
 		iint->flags |= IMA_MEASURED;
 	if (result < 0)

commit 725de7fabb9fe4ca388c780ad4644352f2f06ccc
Author: Eric Richter <erichte@linux.vnet.ibm.com>
Date:   Wed Jun 1 13:14:02 2016 -0500

    ima: extend ima_get_action() to return the policy pcr
    
    Different policy rules may extend different PCRs. This patch retrieves
    the specific PCR for the matched rule.  Subsequent patches will include
    the rule specific PCR in the measurement list and extend the appropriate
    PCR.
    
    Signed-off-by: Eric Richter <erichte@linux.vnet.ibm.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 5a2218fe877a..225b9cede300 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -157,6 +157,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  * @inode: pointer to inode to measure
  * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
  * @func: caller identifier
+ * @pcr: pointer filled in if matched measure policy sets pcr=
  *
  * The policy is defined in terms of keypairs:
  *		subj=, obj=, type=, func=, mask=, fsmagic=
@@ -168,13 +169,13 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  * Returns IMA_MEASURE, IMA_APPRAISE mask.
  *
  */
-int ima_get_action(struct inode *inode, int mask, enum ima_hooks func)
+int ima_get_action(struct inode *inode, int mask, enum ima_hooks func, int *pcr)
 {
 	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;
 
 	flags &= ima_policy_flag;
 
-	return ima_match_policy(inode, func, mask, flags);
+	return ima_match_policy(inode, func, mask, flags, pcr);
 }
 
 /*

commit 81cd8896a64cc34bd59f097fa619b11ab40ca7a6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 15:33:04 2016 -0400

    constify ima_d_path()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 370e42dfc5c5..5a2218fe877a 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -313,7 +313,7 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 	iint->flags |= IMA_AUDITED;
 }
 
-const char *ima_d_path(struct path *path, char **pathbuf)
+const char *ima_d_path(const struct path *path, char **pathbuf)
 {
 	char *pathname = NULL;
 

commit cf2222178645e545e96717b2825601321ce4745c
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Jan 14 17:57:47 2016 -0500

    ima: define a new hook to measure and appraise a file already in memory
    
    This patch defines a new IMA hook ima_post_read_file() for measuring
    and appraising files read by the kernel. The caller loads the file into
    memory before calling this function, which calculates the hash followed by
    the normal IMA policy based processing.
    
    Changelog v5:
    - fail ima_post_read_file() if either file or buf is NULL
    v3:
    - rename ima_hash_and_process_file() to ima_post_read_file()
    
    v1:
    - split patch
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 8750254506a9..370e42dfc5c5 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -188,7 +188,8 @@ int ima_get_action(struct inode *inode, int mask, enum ima_hooks func)
  * Return 0 on success, error code otherwise
  */
 int ima_collect_measurement(struct integrity_iint_cache *iint,
-			    struct file *file, enum hash_algo algo)
+			    struct file *file, void *buf, loff_t size,
+			    enum hash_algo algo)
 {
 	const char *audit_cause = "failed";
 	struct inode *inode = file_inode(file);
@@ -210,7 +211,8 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 
 		hash.hdr.algo = algo;
 
-		result = ima_calc_file_hash(file, &hash.hdr);
+		result = (!buf) ?  ima_calc_file_hash(file, &hash.hdr) :
+			ima_calc_buffer_hash(buf, size, &hash.hdr);
 		if (!result) {
 			int length = sizeof(hash.hdr) + hash.hdr.length;
 			void *tmpbuf = krealloc(iint->ima_hash, length,

commit 4ad87a3d7444de08858e9dc8014e948670945b6c
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Jan 14 20:59:14 2016 -0500

    ima: use "ima_hooks" enum as function argument
    
    Cleanup the function arguments by using "ima_hooks" enumerator as needed.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Petko Manolov <petkan@mip-labs.com>
    Acked-by: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index e7c7a5d41413..8750254506a9 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -156,7 +156,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  * ima_get_action - appraise & measure decision based on policy.
  * @inode: pointer to inode to measure
  * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
- * @function: calling function (FILE_CHECK, BPRM_CHECK, MMAP_CHECK, MODULE_CHECK)
+ * @func: caller identifier
  *
  * The policy is defined in terms of keypairs:
  *		subj=, obj=, type=, func=, mask=, fsmagic=
@@ -168,13 +168,13 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  * Returns IMA_MEASURE, IMA_APPRAISE mask.
  *
  */
-int ima_get_action(struct inode *inode, int mask, int function)
+int ima_get_action(struct inode *inode, int mask, enum ima_hooks func)
 {
 	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;
 
 	flags &= ima_policy_flag;
 
-	return ima_match_policy(inode, function, mask, flags);
+	return ima_match_policy(inode, func, mask, flags);
 }
 
 /*

commit 1525b06d99b117198ea8d6c128ee5bf28ceb6723
Author: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>
Date:   Thu Oct 30 12:39:39 2014 +0200

    ima: separate 'security.ima' reading functionality from collect
    
    Instead of passing pointers to pointers to ima_collect_measurent() to
    read and return the 'security.ima' xattr value, this patch moves the
    functionality to the calling process_measurement() to directly read
    the xattr and pass only the hash algo to the ima_collect_measurement().
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 1d950fbb2aec..e7c7a5d41413 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -18,7 +18,7 @@
 #include <linux/fs.h>
 #include <linux/xattr.h>
 #include <linux/evm.h>
-#include <crypto/hash_info.h>
+
 #include "ima.h"
 
 /*
@@ -188,9 +188,7 @@ int ima_get_action(struct inode *inode, int mask, int function)
  * Return 0 on success, error code otherwise
  */
 int ima_collect_measurement(struct integrity_iint_cache *iint,
-			    struct file *file,
-			    struct evm_ima_xattr_data **xattr_value,
-			    int *xattr_len)
+			    struct file *file, enum hash_algo algo)
 {
 	const char *audit_cause = "failed";
 	struct inode *inode = file_inode(file);
@@ -201,9 +199,6 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 		char digest[IMA_MAX_DIGEST_SIZE];
 	} hash;
 
-	if (xattr_value)
-		*xattr_len = ima_read_xattr(file->f_path.dentry, xattr_value);
-
 	if (!(iint->flags & IMA_COLLECTED)) {
 		u64 i_version = file_inode(file)->i_version;
 
@@ -213,11 +208,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 			goto out;
 		}
 
-		/* use default hash algorithm */
-		hash.hdr.algo = ima_hash_algo;
-
-		if (xattr_value)
-			ima_get_hash_algo(*xattr_value, *xattr_len, &hash.hdr);
+		hash.hdr.algo = algo;
 
 		result = ima_calc_file_hash(file, &hash.hdr);
 		if (!result) {

commit 8d94eb9b5cff350ba170848c862ca0006d33d496
Author: Roberto Sassu <rsassu@suse.de>
Date:   Sat Apr 11 17:12:39 2015 +0200

    ima: pass iint to ima_add_violation()
    
    This patch adds the iint associated to the current inode as a new
    parameter of ima_add_violation(). The passed iint is always not NULL
    if a violation is detected. This modification will be used to determine
    the inode for which there is a violation.
    
    Since the 'd' and 'd-ng' template field init() functions were detecting
    a violation from the value of the iint pointer, they now check the new
    field 'violation', added to the 'ima_event_data' structure.
    
    Changelog:
     - v1:
       - modified an old comment (Roberto Sassu)
    
    Signed-off-by: Roberto Sassu <rsassu@suse.de>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 5865ea2a2777..1d950fbb2aec 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -126,11 +126,13 @@ int ima_store_template(struct ima_template_entry *entry,
  * value is invalidated.
  */
 void ima_add_violation(struct file *file, const unsigned char *filename,
+		       struct integrity_iint_cache *iint,
 		       const char *op, const char *cause)
 {
 	struct ima_template_entry *entry;
 	struct inode *inode = file_inode(file);
-	struct ima_event_data event_data = {NULL, file, filename, NULL, 0};
+	struct ima_event_data event_data = {iint, file, filename, NULL, 0,
+					    cause};
 	int violation = 1;
 	int result;
 
@@ -264,8 +266,8 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	int result = -ENOMEM;
 	struct inode *inode = file_inode(file);
 	struct ima_template_entry *entry;
-	struct ima_event_data event_data = {iint, file, filename,
-					    xattr_value, xattr_len};
+	struct ima_event_data event_data = {iint, file, filename, xattr_value,
+					    xattr_len, NULL};
 	int violation = 0;
 
 	if (iint->flags & IMA_MEASURED)

commit 23b5741932ca44856762fa24cc7e01307ab8af1f
Author: Roberto Sassu <rsassu@suse.de>
Date:   Sat Apr 11 17:09:50 2015 +0200

    ima: wrap event related data to the new ima_event_data structure
    
    All event related data has been wrapped into the new 'ima_event_data'
    structure. The main benefit of this patch is that a new information
    can be made available to template fields initialization functions
    by simply adding a new field to the new structure instead of modifying
    the definition of those functions.
    
    Changelog:
     - v2:
       - f_dentry replaced with f_path.dentry (Roberto Sassu)
       - removed declaration of temporary variables in template field functions
         when possible (suggested by Dmitry Kasatkin)
    
    Signed-off-by: Roberto Sassu <rsassu@suse.de>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index b8a27c5052d4..5865ea2a2777 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -37,10 +37,8 @@ void ima_free_template_entry(struct ima_template_entry *entry)
 /*
  * ima_alloc_init_template - create and initialize a new template entry
  */
-int ima_alloc_init_template(struct integrity_iint_cache *iint,
-			    struct file *file, const unsigned char *filename,
-			    struct evm_ima_xattr_data *xattr_value,
-			    int xattr_len, struct ima_template_entry **entry)
+int ima_alloc_init_template(struct ima_event_data *event_data,
+			    struct ima_template_entry **entry)
 {
 	struct ima_template_desc *template_desc = ima_template_desc_current();
 	int i, result = 0;
@@ -55,8 +53,7 @@ int ima_alloc_init_template(struct integrity_iint_cache *iint,
 		struct ima_template_field *field = template_desc->fields[i];
 		u32 len;
 
-		result = field->field_init(iint, file, filename,
-					   xattr_value, xattr_len,
+		result = field->field_init(event_data,
 					   &((*entry)->template_data[i]));
 		if (result != 0)
 			goto out;
@@ -133,14 +130,14 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 {
 	struct ima_template_entry *entry;
 	struct inode *inode = file_inode(file);
+	struct ima_event_data event_data = {NULL, file, filename, NULL, 0};
 	int violation = 1;
 	int result;
 
 	/* can overflow, only indicator */
 	atomic_long_inc(&ima_htable.violations);
 
-	result = ima_alloc_init_template(NULL, file, filename,
-					 NULL, 0, &entry);
+	result = ima_alloc_init_template(&event_data, &entry);
 	if (result < 0) {
 		result = -ENOMEM;
 		goto err_out;
@@ -267,13 +264,14 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	int result = -ENOMEM;
 	struct inode *inode = file_inode(file);
 	struct ima_template_entry *entry;
+	struct ima_event_data event_data = {iint, file, filename,
+					    xattr_value, xattr_len};
 	int violation = 0;
 
 	if (iint->flags & IMA_MEASURED)
 		return;
 
-	result = ima_alloc_init_template(iint, file, filename,
-					 xattr_value, xattr_len, &entry);
+	result = ima_alloc_init_template(&event_data, &entry);
 	if (result < 0) {
 		integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,
 				    op, audit_cause, result, 0);

commit 67e2c3883828b39548cee2091b36656787775d95
Merge: 6ae840e7cc4b b2d1965dcea1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 20:36:37 2014 -0800

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security layer updates from James Morris:
     "In terms of changes, there's general maintenance to the Smack,
      SELinux, and integrity code.
    
      The IMA code adds a new kconfig option, IMA_APPRAISE_SIGNED_INIT,
      which allows IMA appraisal to require signatures.  Support for reading
      keys from rootfs before init is call is also added"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (23 commits)
      selinux: Remove security_ops extern
      security: smack: fix out-of-bounds access in smk_parse_smack()
      VFS: refactor vfs_read()
      ima: require signature based appraisal
      integrity: provide a hook to load keys when rootfs is ready
      ima: load x509 certificate from the kernel
      integrity: provide a function to load x509 certificate from the kernel
      integrity: define a new function integrity_read_file()
      Security: smack: replace kzalloc with kmem_cache for inode_smack
      Smack: Lock mode for the floor and hat labels
      ima: added support for new kernel cmdline parameter ima_template_fmt
      ima: allocate field pointers array on demand in template_desc_init_fields()
      ima: don't allocate a copy of template_fmt in template_desc_init_fields()
      ima: display template format in meas. list if template name length is zero
      ima: added error messages to template-related functions
      ima: use atomic bit operations to protect policy update interface
      ima: ignore empty and with whitespaces policy lines
      ima: no need to allocate entry for comment
      ima: report policy load status
      ima: use path names cache
      ...

commit b583043e99bc6d91e98fae32bd9eff6a5958240a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 31 01:22:04 2014 -0400

    kill f_dentry uses
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 86885979918c..f92be1b14089 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -196,7 +196,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 {
 	const char *audit_cause = "failed";
 	struct inode *inode = file_inode(file);
-	const char *filename = file->f_dentry->d_name.name;
+	const char *filename = file->f_path.dentry->d_name.name;
 	int result = 0;
 	struct {
 		struct ima_digest_data hdr;
@@ -204,7 +204,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	} hash;
 
 	if (xattr_value)
-		*xattr_len = ima_read_xattr(file->f_dentry, xattr_value);
+		*xattr_len = ima_read_xattr(file->f_path.dentry, xattr_value);
 
 	if (!(iint->flags & IMA_COLLECTED)) {
 		u64 i_version = file_inode(file)->i_version;

commit fd5f4e9054acbf4f22fac81a358baf3c27aa42ac
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Wed Nov 5 17:01:14 2014 +0200

    ima: load x509 certificate from the kernel
    
    Define configuration option to load X509 certificate into the
    IMA trusted kernel keyring. It implements ima_load_x509() hook
    to load X509 certificate into the .ima trusted kernel keyring
    from the root filesystem.
    
    Changes in v3:
    * use ima_policy_flag in ima_get_action()
      ima_load_x509 temporarily clears ima_policy_flag to disable
      appraisal to load key. Use it to skip appraisal rules.
    * Key directory path changed to /etc/keys (Mimi)
    * Expand IMA_LOAD_X509 Kconfig help
    
    Changes in v2:
    * added '__init'
    * use ima_policy_flag to disable appraisal to load keys
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index a99eb6d4bc09..b0dc922d8be3 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -173,8 +173,7 @@ int ima_get_action(struct inode *inode, int mask, int function)
 {
 	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;
 
-	if (!ima_appraise)
-		flags &= ~IMA_APPRAISE;
+	flags &= ima_policy_flag;
 
 	return ima_match_policy(inode, function, mask, flags);
 }

commit 456f5fd3f6017f10d04d459159ac7bd9e3815c5e
Author: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>
Date:   Wed Oct 1 21:43:10 2014 +0300

    ima: use path names cache
    
    __getname() uses slab allocation which is faster than kmalloc.
    Make use of it.
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 86885979918c..a99eb6d4bc09 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -325,11 +325,11 @@ const char *ima_d_path(struct path *path, char **pathbuf)
 {
 	char *pathname = NULL;
 
-	*pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
+	*pathbuf = __getname();
 	if (*pathbuf) {
 		pathname = d_absolute_path(path, *pathbuf, PATH_MAX);
 		if (IS_ERR(pathname)) {
-			kfree(*pathbuf);
+			__putname(*pathbuf);
 			*pathbuf = NULL;
 			pathname = NULL;
 		}

commit 1b68bdf9cded82d37e443a20c5ed47bbb084d5dc
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Fri Sep 12 19:35:56 2014 +0200

    ima: detect violations for mmaped files
    
    This patch fixes the detection of the 'open_writers' violation for mmaped
    files.
    
    before) an 'open_writers' violation is detected if the policy contains
            a rule with the criteria: func=FILE_CHECK mask=MAY_READ
    
    after) an 'open_writers' violation is detected if the current event
           matches one of the policy rules.
    
    With the old behaviour, the 'open_writers' violation is not detected
    in the following case:
    
    policy:
    measure func=FILE_MMAP mask=MAY_EXEC
    
    steps:
    1) open a shared library for writing
    2) execute a binary that links that shared library
    3) during the binary execution, modify the shared library and save
       the change
    
    result:
    the 'open_writers' violation measurement is not present in the IMA list.
    
    Only binaries executed are protected from writes. For libraries mapped
    in memory there is the flag MAP_DENYWRITE for this purpose, but according
    to the output of 'man mmap', the mmap flag is ignored.
    
    Since ima_rdwr_violation_check() is now called by process_measurement()
    the information about if the inode must be measured is already provided
    by ima_get_action(). Thus the unnecessary function ima_must_measure()
    has been removed.
    
    Changes in v3 (Dmitry Kasatkin):
    - Violation for MMAP_CHECK function are verified since this patch
    - Changed patch description a bit
    
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 65c41a968cc1..86885979918c 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -179,11 +179,6 @@ int ima_get_action(struct inode *inode, int mask, int function)
 	return ima_match_policy(inode, function, mask, flags);
 }
 
-int ima_must_measure(struct inode *inode, int mask, int function)
-{
-	return ima_match_policy(inode, function, mask, IMA_MEASURE);
-}
-
 /*
  * ima_collect_measurement - collect file measurement
  *

commit 17f4bad3abc7c09f42987d89ccccab02c03455a9
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Tue Aug 19 16:48:39 2014 +0300

    ima: remove usage of filename parameter
    
    In all cases except ima_bprm_check() the filename was not defined
    and ima_d_path() was used to find the full path.  Unfortunately,
    the bprm filename is a relative pathname (eg. ./<dir>/filename).
    
    ima_bprm_check() selects between bprm->interp and bprm->filename.
    The following dump demonstrates the differences between using
    filename and interp.
    
    bprm->filename
     filename: ./foo.sh, pathname: /root/bin/foo.sh
     filename: ./foo.sh, pathname: /bin/dash
    
    bprm->interp
     filename: ./foo.sh, pathname: /root/bin/foo.sh
     filename: /bin/sh, pathname: /bin/dash
    
    In both cases the pathnames are currently the same.  This patch
    removes usage of filename and interp in favor of d_absolute_path.
    
    Changes v3:
    - 11 extra bytes for "deleted" not needed (Mimi)
    - purpose "replace relative bprm filename with full pathname" (Mimi)
    
    Changes v2:
    - use d_absolute_path() instead of d_path to work in chroot environments.
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index d9cd5ce14d2b..65c41a968cc1 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -330,10 +330,9 @@ const char *ima_d_path(struct path *path, char **pathbuf)
 {
 	char *pathname = NULL;
 
-	/* We will allow 11 spaces for ' (deleted)' to be appended */
-	*pathbuf = kmalloc(PATH_MAX + 11, GFP_KERNEL);
+	*pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
 	if (*pathbuf) {
-		pathname = d_path(path, *pathbuf, PATH_MAX + 11);
+		pathname = d_absolute_path(path, *pathbuf, PATH_MAX);
 		if (IS_ERR(pathname)) {
 			kfree(*pathbuf);
 			*pathbuf = NULL;

commit f9b2a735bdddf836214b5dca74f6ca7712e5a08c
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon May 12 09:28:11 2014 -0400

    ima: audit log files opened with O_DIRECT flag
    
    Files are measured or appraised based on the IMA policy.  When a
    file, in policy, is opened with the O_DIRECT flag, a deadlock
    occurs.
    
    The first attempt at resolving this lockdep temporarily removed the
    O_DIRECT flag and restored it, after calculating the hash.  The
    second attempt introduced the O_DIRECT_HAVELOCK flag. Based on this
    flag, do_blockdev_direct_IO() would skip taking the i_mutex a second
    time.  The third attempt, by Dmitry Kasatkin, resolves the i_mutex
    locking issue, by re-introducing the IMA mutex, but uncovered
    another problem.  Reading a file with O_DIRECT flag set, writes
    directly to userspace pages.  A second patch allocates a user-space
    like memory.  This works for all IMA hooks, except ima_file_free(),
    which is called on __fput() to recalculate the file hash.
    
    Until this last issue is addressed, do not 'collect' the
    measurement for measuring, appraising, or auditing files opened
    with the O_DIRECT flag set.  Based on policy, permit or deny file
    access.  This patch defines a new IMA policy rule option named
    'permit_directio'.  Policy rules could be defined, based on LSM
    or other criteria, to permit specific applications to open files
    with the O_DIRECT flag set.
    
    Changelog v1:
    - permit or deny file access based IMA policy rules
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Cc: <stable@vger.kernel.org>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index ba9e4d792dd5..d9cd5ce14d2b 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -199,6 +199,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 			    struct evm_ima_xattr_data **xattr_value,
 			    int *xattr_len)
 {
+	const char *audit_cause = "failed";
 	struct inode *inode = file_inode(file);
 	const char *filename = file->f_dentry->d_name.name;
 	int result = 0;
@@ -213,6 +214,12 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	if (!(iint->flags & IMA_COLLECTED)) {
 		u64 i_version = file_inode(file)->i_version;
 
+		if (file->f_flags & O_DIRECT) {
+			audit_cause = "failed(directio)";
+			result = -EACCES;
+			goto out;
+		}
+
 		/* use default hash algorithm */
 		hash.hdr.algo = ima_hash_algo;
 
@@ -233,9 +240,10 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 				result = -ENOMEM;
 		}
 	}
+out:
 	if (result)
 		integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,
-				    filename, "collect_data", "failed",
+				    filename, "collect_data", audit_cause,
 				    result, 0);
 	return result;
 }

commit 61997c4383c28fe93fb053295562ff6482ef5c07
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Wed Nov 13 22:23:20 2013 +0200

    ima: return d_name.name if d_path fails
    
    This is a small refactoring so ima_d_path() returns dentry name
    if path reconstruction fails. It simplifies callers actions
    and removes code duplication.
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index c6b4a732e89b..ba9e4d792dd5 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -332,5 +332,5 @@ const char *ima_d_path(struct path *path, char **pathbuf)
 			pathname = NULL;
 		}
 	}
-	return pathname;
+	return pathname ?: (const char *)path->dentry->d_name.name;
 }

commit 2bb930abcf39d8be243ddb4583cf013ea2a750d6
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Tue Mar 4 18:04:20 2014 +0200

    integrity: fix checkpatch errors
    
    Between checkpatch changes (eg. sizeof) and inconsistencies between
    Lindent and checkpatch, unfixed checkpatch errors make it difficult
    to see new errors. This patch fixes them. Some lines with over 80 chars
    remained unchanged to improve code readability.
    
    The "extern" keyword is removed from internal evm.h to make it consistent
    with internal ima.h.
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 393b9d46c472..c6b4a732e89b 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -160,10 +160,10 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
  * @function: calling function (FILE_CHECK, BPRM_CHECK, MMAP_CHECK, MODULE_CHECK)
  *
  * The policy is defined in terms of keypairs:
- * 		subj=, obj=, type=, func=, mask=, fsmagic=
+ *		subj=, obj=, type=, func=, mask=, fsmagic=
  *	subj,obj, and type: are LSM specific.
- * 	func: FILE_CHECK | BPRM_CHECK | MMAP_CHECK | MODULE_CHECK
- * 	mask: contains the permission mask
+ *	func: FILE_CHECK | BPRM_CHECK | MMAP_CHECK | MODULE_CHECK
+ *	mask: contains the permission mask
  *	fsmagic: hex value
  *
  * Returns IMA_MEASURE, IMA_APPRAISE mask.
@@ -248,7 +248,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
  *
  * We only get here if the inode has not already been measured,
  * but the measurement could already exist:
- * 	- multiple copies of the same file on either the same or
+ *	- multiple copies of the same file on either the same or
  *	  different filesystems.
  *	- the inode was previously flushed as well as the iint info,
  *	  containing the hashing info.

commit 52a13284844b354c7a37533f5366cb5b653a76b3
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Dec 11 14:44:04 2013 -0500

    ima: use static const char array definitions
    
    A const char pointer allocates memory for a pointer as well as for
    a string,  This patch replaces a number of the const char pointers
    throughout IMA, with a static const char array.
    
    Suggested-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: David Howells <dhowells@redhat.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 6d76d4a01503..393b9d46c472 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -92,8 +92,8 @@ int ima_store_template(struct ima_template_entry *entry,
 		       int violation, struct inode *inode,
 		       const unsigned char *filename)
 {
-	const char *op = "add_template_measure";
-	const char *audit_cause = "hashing_error";
+	static const char op[] = "add_template_measure";
+	static const char audit_cause[] = "hashing_error";
 	char *template_name = entry->template_desc->name;
 	int result;
 	struct {
@@ -260,8 +260,8 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 			   struct evm_ima_xattr_data *xattr_value,
 			   int xattr_len)
 {
-	const char *op = "add_template_measure";
-	const char *audit_cause = "ENOMEM";
+	static const char op[] = "add_template_measure";
+	static const char audit_cause[] = "ENOMEM";
 	int result = -ENOMEM;
 	struct inode *inode = file_inode(file);
 	struct ima_template_entry *entry;

commit 31d4b761896101660b3efe01816b63d9814755eb
Author: Libo Chen <clbchenlibo.chen@huawei.com>
Date:   Wed Dec 11 14:11:28 2013 +0800

    ima: new helper: file_inode(file)
    
    Replace "file->f_dentry->d_inode" with the new file_inode() helper
    function.
    
    Signed-off-by: Libo Chen <clbchenlibo.chen@huawei.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index c38bbce8c6a6..6d76d4a01503 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -132,7 +132,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 		       const char *op, const char *cause)
 {
 	struct ima_template_entry *entry;
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = file_inode(file);
 	int violation = 1;
 	int result;
 

commit a7ed7c60e14df5b986f93549717235b882643e7e
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Mon Dec 2 19:40:34 2013 +0100

    ima: properly free ima_template_entry structures
    
    The new templates management mechanism records information associated
    to an event into an array of 'ima_field_data' structures and makes it
    available through the 'template_data' field of the 'ima_template_entry'
    structure (the element of the measurements list created by IMA).
    
    Since 'ima_field_data' contains dynamically allocated data (which length
    varies depending on the data associated to a selected template field),
    it is not enough to just free the memory reserved for a
    'ima_template_entry' structure if something goes wrong.
    
    This patch creates the new function ima_free_template_entry() which
    walks the array of 'ima_field_data' structures, frees the memory
    referenced by the 'data' pointer and finally the space reserved for
    the 'ima_template_entry' structure. Further, it replaces existing kfree()
    that have a pointer to an 'ima_template_entry' structure as argument
    with calls to the new function.
    
    Fixes: a71dc65: ima: switch to new template management mechanism
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 80374842fe0b..c38bbce8c6a6 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -21,6 +21,19 @@
 #include <crypto/hash_info.h>
 #include "ima.h"
 
+/*
+ * ima_free_template_entry - free an existing template entry
+ */
+void ima_free_template_entry(struct ima_template_entry *entry)
+{
+	int i;
+
+	for (i = 0; i < entry->template_desc->num_fields; i++)
+		kfree(entry->template_data[i].data);
+
+	kfree(entry);
+}
+
 /*
  * ima_alloc_init_template - create and initialize a new template entry
  */
@@ -37,6 +50,7 @@ int ima_alloc_init_template(struct integrity_iint_cache *iint,
 	if (!*entry)
 		return -ENOMEM;
 
+	(*entry)->template_desc = template_desc;
 	for (i = 0; i < template_desc->num_fields; i++) {
 		struct ima_template_field *field = template_desc->fields[i];
 		u32 len;
@@ -51,10 +65,9 @@ int ima_alloc_init_template(struct integrity_iint_cache *iint,
 		(*entry)->template_data_len += sizeof(len);
 		(*entry)->template_data_len += len;
 	}
-	(*entry)->template_desc = template_desc;
 	return 0;
 out:
-	kfree(*entry);
+	ima_free_template_entry(*entry);
 	*entry = NULL;
 	return result;
 }
@@ -134,7 +147,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 	}
 	result = ima_store_template(entry, violation, inode, filename);
 	if (result < 0)
-		kfree(entry);
+		ima_free_template_entry(entry);
 err_out:
 	integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,
 			    op, cause, result, 0);
@@ -269,7 +282,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	if (!result || result == -EEXIST)
 		iint->flags |= IMA_MEASURED;
 	if (result < 0)
-		kfree(entry);
+		ima_free_template_entry(entry);
 }
 
 void ima_audit_measurement(struct integrity_iint_cache *iint,

commit b6f8f16f41d92861621b043389ef49de1c52d613
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Fri Nov 8 19:21:39 2013 +0100

    ima: do not include field length in template digest calc for ima template
    
    To maintain compatibility with userspace tools, the field length must not
    be included in the template digest calculation for the 'ima' template.
    
    Fixes commit: a71dc65 ima: switch to new template management mechanism
    
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 0e7540863fc2..80374842fe0b 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -94,6 +94,7 @@ int ima_store_template(struct ima_template_entry *entry,
 		/* this function uses default algo */
 		hash.hdr.algo = HASH_ALGO_SHA1;
 		result = ima_calc_field_array_hash(&entry->template_data[0],
+						   entry->template_desc,
 						   num_fields, &hash.hdr);
 		if (result < 0) {
 			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,

commit bcbc9b0cf6d8f340a1d166e414f4612b353f7a9b
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Jul 23 11:15:00 2013 -0400

    ima: extend the measurement list to include the file signature
    
    This patch defines a new template called 'ima-sig', which includes
    the file signature in the template data, in addition to the file's
    digest and pathname.
    
    A template is composed of a set of fields.  Associated with each
    field is an initialization and display function.  This patch defines
    a new template field called 'sig', the initialization function
    ima_eventsig_init(), and the display function ima_show_template_sig().
    
    This patch modifies the .field_init() function definition to include
    the 'security.ima' extended attribute and length.
    
    Changelog:
    - remove unused code (Dmitry Kasatkin)
    - avoid calling ima_write_template_field_data() unnecesarily (Roberto Sassu)
    - rename DATA_FMT_SIG to DATA_FMT_HEX
    - cleanup ima_eventsig_init() based on Roberto's comments
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 5fcc80695d87..0e7540863fc2 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -26,7 +26,8 @@
  */
 int ima_alloc_init_template(struct integrity_iint_cache *iint,
 			    struct file *file, const unsigned char *filename,
-			    struct ima_template_entry **entry)
+			    struct evm_ima_xattr_data *xattr_value,
+			    int xattr_len, struct ima_template_entry **entry)
 {
 	struct ima_template_desc *template_desc = ima_template_desc_current();
 	int i, result = 0;
@@ -41,6 +42,7 @@ int ima_alloc_init_template(struct integrity_iint_cache *iint,
 		u32 len;
 
 		result = field->field_init(iint, file, filename,
+					   xattr_value, xattr_len,
 					   &((*entry)->template_data[i]));
 		if (result != 0)
 			goto out;
@@ -123,7 +125,8 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 	/* can overflow, only indicator */
 	atomic_long_inc(&ima_htable.violations);
 
-	result = ima_alloc_init_template(NULL, file, filename, &entry);
+	result = ima_alloc_init_template(NULL, file, filename,
+					 NULL, 0, &entry);
 	if (result < 0) {
 		result = -ENOMEM;
 		goto err_out;
@@ -239,7 +242,9 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
  * Must be called with iint->mutex held.
  */
 void ima_store_measurement(struct integrity_iint_cache *iint,
-			   struct file *file, const unsigned char *filename)
+			   struct file *file, const unsigned char *filename,
+			   struct evm_ima_xattr_data *xattr_value,
+			   int xattr_len)
 {
 	const char *op = "add_template_measure";
 	const char *audit_cause = "ENOMEM";
@@ -251,7 +256,8 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	if (iint->flags & IMA_MEASURED)
 		return;
 
-	result = ima_alloc_init_template(iint, file, filename, &entry);
+	result = ima_alloc_init_template(iint, file, filename,
+					 xattr_value, xattr_len, &entry);
 	if (result < 0) {
 		integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,
 				    op, audit_cause, result, 0);

commit 5278aa52f35003ddafda80b0243b3693f935b134
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Fri Jun 7 12:16:38 2013 +0200

    ima: add audit log support for larger hashes
    
    Different files might be signed based on different hash algorithms.
    This patch prefixes the audit log measurement hash with the hash
    algorithm.
    
    Changelog:
    - use generic HASH_ALGO defintions
    - use ':' as delimiter between the hash algorithm and the digest
      (Roberto Sassu)
    - always include the hash algorithm used when audit-logging a measurement
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Peter Moody <pmoody@google.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index baa348179527..5fcc80695d87 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -270,6 +270,8 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 {
 	struct audit_buffer *ab;
 	char hash[(iint->ima_hash->length * 2) + 1];
+	const char *algo_name = hash_algo_name[iint->ima_hash->algo];
+	char algo_hash[sizeof(hash) + strlen(algo_name) + 2];
 	int i;
 
 	if (iint->flags & IMA_AUDITED)
@@ -287,7 +289,8 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 	audit_log_format(ab, "file=");
 	audit_log_untrustedstring(ab, filename);
 	audit_log_format(ab, " hash=");
-	audit_log_untrustedstring(ab, hash);
+	snprintf(algo_hash, sizeof(algo_hash), "%s:%s", algo_name, hash);
+	audit_log_untrustedstring(ab, algo_hash);
 
 	audit_log_task_info(ab, current);
 	audit_log_end(ab);

commit a71dc65d30a472409f05d247f4eab91b14acf2f5
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Fri Jun 7 12:16:33 2013 +0200

    ima: switch to new template management mechanism
    
    This patch performs the switch to the new template mechanism by modifying
    the functions ima_alloc_init_template(), ima_measurements_show() and
    ima_ascii_measurements_show(). The old function ima_template_show() was
    removed as it is no longer needed. Also, if the template descriptor used
    to generate a measurement entry is not 'ima', the whole length of field
    data stored for an entry is provided before the data itself through the
    binary_runtime_measurement interface.
    
    Changelog:
    - unnecessary to use strncmp() (Mimi Zohar)
    - create new variable 'field' in ima_alloc_init_template() (Roberto Sassu)
    - use GFP_NOFS flag in ima_alloc_init_template() (Roberto Sassu)
    - new variable 'num_fields' in ima_store_template() (Roberto Sassu,
      proposed by Mimi Zohar)
    - rename ima_calc_buffer_hash/template_hash() to ima_calc_field_array_hash(),
      something more generic (Mimi, requested by Dmitry)
    - sparse error fix - Fengguang Wu
    - fix lindent warnings
    - always include the field length in the template data length
    - include the template field length variable size in the template data length
    - include both the template field data and field length in the template digest
      calculation. Simplifies verifying the template digest. (Mimi)
    
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 29dd43de823a..baa348179527 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -21,8 +21,6 @@
 #include <crypto/hash_info.h>
 #include "ima.h"
 
-static const char *IMA_TEMPLATE_NAME = "ima";
-
 /*
  * ima_alloc_init_template - create and initialize a new template entry
  */
@@ -30,52 +28,32 @@ int ima_alloc_init_template(struct integrity_iint_cache *iint,
 			    struct file *file, const unsigned char *filename,
 			    struct ima_template_entry **entry)
 {
-	struct ima_template_entry *e;
-	int result = 0;
+	struct ima_template_desc *template_desc = ima_template_desc_current();
+	int i, result = 0;
 
-	e = kzalloc(sizeof(**entry), GFP_NOFS);
-	if (!e)
+	*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *
+			 sizeof(struct ima_field_data), GFP_NOFS);
+	if (!*entry)
 		return -ENOMEM;
 
-	memset(&(e)->template, 0, sizeof(e->template));
-	if (!iint)		/* IMA measurement violation entry */
-		goto out;
-
-	if (iint->ima_hash->algo != ima_hash_algo) {
-		struct inode *inode;
-		struct {
-			struct ima_digest_data hdr;
-			char digest[IMA_MAX_DIGEST_SIZE];
-		} hash;
+	for (i = 0; i < template_desc->num_fields; i++) {
+		struct ima_template_field *field = template_desc->fields[i];
+		u32 len;
 
-		if (!file) {
-			result = -EINVAL;
-			goto out_free;
-		}
+		result = field->field_init(iint, file, filename,
+					   &((*entry)->template_data[i]));
+		if (result != 0)
+			goto out;
 
-		inode = file_inode(file);
-		hash.hdr.algo = ima_hash_algo;
-		hash.hdr.length = SHA1_DIGEST_SIZE;
-		result = ima_calc_file_hash(file, &hash.hdr);
-		if (result) {
-			integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,
-					    filename, "collect_data",
-					    "failed", result, 0);
-			goto out_free;
-		} else
-			memcpy(e->template.digest, hash.hdr.digest,
-			       hash.hdr.length);
-	} else
-		memcpy(e->template.digest, iint->ima_hash->digest,
-		       iint->ima_hash->length);
-out:
-	strcpy(e->template.file_name,
-	       (strlen(filename) > IMA_EVENT_NAME_LEN_MAX && file != NULL) ?
-	       file->f_dentry->d_name.name : filename);
-	*entry = e;
+		len = (*entry)->template_data[i].len;
+		(*entry)->template_data_len += sizeof(len);
+		(*entry)->template_data_len += len;
+	}
+	(*entry)->template_desc = template_desc;
 	return 0;
-out_free:
-	kfree(e);
+out:
+	kfree(*entry);
+	*entry = NULL;
 	return result;
 }
 
@@ -101,24 +79,23 @@ int ima_store_template(struct ima_template_entry *entry,
 {
 	const char *op = "add_template_measure";
 	const char *audit_cause = "hashing_error";
+	char *template_name = entry->template_desc->name;
 	int result;
 	struct {
 		struct ima_digest_data hdr;
 		char digest[TPM_DIGEST_SIZE];
 	} hash;
 
-	memset(entry->digest, 0, sizeof(entry->digest));
-	entry->template_name = IMA_TEMPLATE_NAME;
-	entry->template_len = sizeof(entry->template);
-
 	if (!violation) {
+		int num_fields = entry->template_desc->num_fields;
+
 		/* this function uses default algo */
 		hash.hdr.algo = HASH_ALGO_SHA1;
-		result = ima_calc_buffer_hash(&entry->template,
-					      entry->template_len, &hash.hdr);
+		result = ima_calc_field_array_hash(&entry->template_data[0],
+						   num_fields, &hash.hdr);
 		if (result < 0) {
 			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,
-					    entry->template_name, op,
+					    template_name, op,
 					    audit_cause, result, 0);
 			return result;
 		}

commit 7bc5f447ce9d01e19394b5399bf1a4fcebf0f8dd
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Fri Jun 7 12:16:28 2013 +0200

    ima: define new function ima_alloc_init_template() to API
    
    Instead of allocating and initializing the template entry from multiple
    places (eg. boot aggregate, violation, and regular measurements), this
    patch defines a new function called ima_alloc_init_template().  The new
    function allocates and initializes the measurement entry with the inode
    digest and the filename.
    
    In respect to the current behavior, it truncates the file name passed
    in the 'filename' argument if the latter's size is greater than 255 bytes
    and the passed file descriptor is NULL.
    
    Changelog:
    - initialize 'hash' variable for non TPM case - Mimi
    - conform to expectation for 'iint' to be defined as a pointer. - Mimi
    - add missing 'file' dependency for recalculating file hash. - Mimi
    
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index a0fe5041310a..29dd43de823a 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -23,6 +23,62 @@
 
 static const char *IMA_TEMPLATE_NAME = "ima";
 
+/*
+ * ima_alloc_init_template - create and initialize a new template entry
+ */
+int ima_alloc_init_template(struct integrity_iint_cache *iint,
+			    struct file *file, const unsigned char *filename,
+			    struct ima_template_entry **entry)
+{
+	struct ima_template_entry *e;
+	int result = 0;
+
+	e = kzalloc(sizeof(**entry), GFP_NOFS);
+	if (!e)
+		return -ENOMEM;
+
+	memset(&(e)->template, 0, sizeof(e->template));
+	if (!iint)		/* IMA measurement violation entry */
+		goto out;
+
+	if (iint->ima_hash->algo != ima_hash_algo) {
+		struct inode *inode;
+		struct {
+			struct ima_digest_data hdr;
+			char digest[IMA_MAX_DIGEST_SIZE];
+		} hash;
+
+		if (!file) {
+			result = -EINVAL;
+			goto out_free;
+		}
+
+		inode = file_inode(file);
+		hash.hdr.algo = ima_hash_algo;
+		hash.hdr.length = SHA1_DIGEST_SIZE;
+		result = ima_calc_file_hash(file, &hash.hdr);
+		if (result) {
+			integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,
+					    filename, "collect_data",
+					    "failed", result, 0);
+			goto out_free;
+		} else
+			memcpy(e->template.digest, hash.hdr.digest,
+			       hash.hdr.length);
+	} else
+		memcpy(e->template.digest, iint->ima_hash->digest,
+		       iint->ima_hash->length);
+out:
+	strcpy(e->template.file_name,
+	       (strlen(filename) > IMA_EVENT_NAME_LEN_MAX && file != NULL) ?
+	       file->f_dentry->d_name.name : filename);
+	*entry = e;
+	return 0;
+out_free:
+	kfree(e);
+	return result;
+}
+
 /*
  * ima_store_template - store ima template measurements
  *
@@ -90,13 +146,11 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 	/* can overflow, only indicator */
 	atomic_long_inc(&ima_htable.violations);
 
-	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
-	if (!entry) {
+	result = ima_alloc_init_template(NULL, file, filename, &entry);
+	if (result < 0) {
 		result = -ENOMEM;
 		goto err_out;
 	}
-	memset(&entry->template, 0, sizeof(entry->template));
-	strncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);
 	result = ima_store_template(entry, violation, inode, filename);
 	if (result < 0)
 		kfree(entry);
@@ -220,34 +274,12 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	if (iint->flags & IMA_MEASURED)
 		return;
 
-	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
-	if (!entry) {
+	result = ima_alloc_init_template(iint, file, filename, &entry);
+	if (result < 0) {
 		integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,
 				    op, audit_cause, result, 0);
 		return;
 	}
-	memset(&entry->template, 0, sizeof(entry->template));
-	if (iint->ima_hash->algo != ima_hash_algo) {
-		struct {
-			struct ima_digest_data hdr;
-			char digest[IMA_MAX_DIGEST_SIZE];
-		} hash;
-
-		hash.hdr.algo = ima_hash_algo;
-		result = ima_calc_file_hash(file, &hash.hdr);
-		if (result)
-			integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,
-					    filename, "collect_data", "failed",
-					    result, 0);
-		else
-			memcpy(entry->template.digest, hash.hdr.digest,
-			       hash.hdr.length);
-	} else
-		memcpy(entry->template.digest, iint->ima_hash->digest,
-		       iint->ima_hash->length);
-	strcpy(entry->template.file_name,
-	       (strlen(filename) > IMA_EVENT_NAME_LEN_MAX) ?
-	       file->f_dentry->d_name.name : filename);
 
 	result = ima_store_template(entry, violation, inode, filename);
 	if (!result || result == -EEXIST)

commit 9803d413f41db86fdf0097f1af781fe2e68f474c
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Fri Jun 7 12:16:27 2013 +0200

    ima: pass the filename argument up to ima_add_template_entry()
    
    Pass the filename argument to ima_add_template_entry() in order to
    eliminate a dependency on template specific data (third argument of
    integrity_audit_msg).
    
    This change is required because, with the new template management
    mechanism, the generation of a new measurement entry will be performed
    by new specific functions (introduced in next patches) and the current IMA
    code will not be aware anymore of how data is stored in the entry payload.
    
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 98160a3259fe..a0fe5041310a 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -40,7 +40,8 @@ static const char *IMA_TEMPLATE_NAME = "ima";
  * Returns 0 on success, error code otherwise
  */
 int ima_store_template(struct ima_template_entry *entry,
-		       int violation, struct inode *inode)
+		       int violation, struct inode *inode,
+		       const unsigned char *filename)
 {
 	const char *op = "add_template_measure";
 	const char *audit_cause = "hashing_error";
@@ -67,7 +68,7 @@ int ima_store_template(struct ima_template_entry *entry,
 		}
 		memcpy(entry->digest, hash.hdr.digest, hash.hdr.length);
 	}
-	result = ima_add_template_entry(entry, violation, op, inode);
+	result = ima_add_template_entry(entry, violation, op, inode, filename);
 	return result;
 }
 
@@ -96,7 +97,7 @@ void ima_add_violation(struct file *file, const unsigned char *filename,
 	}
 	memset(&entry->template, 0, sizeof(entry->template));
 	strncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);
-	result = ima_store_template(entry, violation, inode);
+	result = ima_store_template(entry, violation, inode, filename);
 	if (result < 0)
 		kfree(entry);
 err_out:
@@ -248,7 +249,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	       (strlen(filename) > IMA_EVENT_NAME_LEN_MAX) ?
 	       file->f_dentry->d_name.name : filename);
 
-	result = ima_store_template(entry, violation, inode);
+	result = ima_store_template(entry, violation, inode, filename);
 	if (!result || result == -EEXIST)
 		iint->flags |= IMA_MEASURED;
 	if (result < 0)

commit 7d802a227b7f26c89f13dab09767e6b0aebd9c9f
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Fri Jun 7 12:16:26 2013 +0200

    ima: pass the file descriptor to ima_add_violation()
    
    Pass the file descriptor instead of the inode to ima_add_violation(),
    to make the latter consistent with ima_store_measurement() in
    preparation for the new template architecture.
    
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index bc1d1282a06f..98160a3259fe 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -78,10 +78,11 @@ int ima_store_template(struct ima_template_entry *entry,
  * By extending the PCR with 0xFF's instead of with zeroes, the PCR
  * value is invalidated.
  */
-void ima_add_violation(struct inode *inode, const unsigned char *filename,
+void ima_add_violation(struct file *file, const unsigned char *filename,
 		       const char *op, const char *cause)
 {
 	struct ima_template_entry *entry;
+	struct inode *inode = file->f_dentry->d_inode;
 	int violation = 1;
 	int result;
 

commit ea593993d361748e795f5eb783a5fb5144fb2df9
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Fri Jun 7 12:16:24 2013 +0200

    ima: support arbitrary hash algorithms in ima_calc_buffer_hash
    
    ima_calc_buffer_hash will be used with different hash algorithms.
    This patch provides support for arbitrary hash algorithms in
    ima_calc_buffer_hash.
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 2cc5dcc6bdeb..bc1d1282a06f 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -18,6 +18,7 @@
 #include <linux/fs.h>
 #include <linux/xattr.h>
 #include <linux/evm.h>
+#include <crypto/hash_info.h>
 #include "ima.h"
 
 static const char *IMA_TEMPLATE_NAME = "ima";
@@ -54,6 +55,8 @@ int ima_store_template(struct ima_template_entry *entry,
 	entry->template_len = sizeof(entry->template);
 
 	if (!violation) {
+		/* this function uses default algo */
+		hash.hdr.algo = HASH_ALGO_SHA1;
 		result = ima_calc_buffer_hash(&entry->template,
 					      entry->template_len, &hash.hdr);
 		if (result < 0) {

commit 140d802240a4ba3351494b4ab199964b96f87493
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Mar 11 20:29:47 2013 -0400

    ima: differentiate between template hash and file data hash sizes
    
    The TPM v1.2 limits the template hash size to 20 bytes.  This
    patch differentiates between the template hash size, as defined
    in the ima_template_entry, and the file data hash size, as
    defined in the ima_template_data.  Subsequent patches add support
    for different file data hash algorithms.
    
    Change log:
    - hash digest definition in ima_store_template() should be TPM_DIGEST_SIZE
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 5a7942e20814..2cc5dcc6bdeb 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -46,7 +46,7 @@ int ima_store_template(struct ima_template_entry *entry,
 	int result;
 	struct {
 		struct ima_digest_data hdr;
-		char digest[IMA_MAX_DIGEST_SIZE];
+		char digest[TPM_DIGEST_SIZE];
 	} hash;
 
 	memset(entry->digest, 0, sizeof(entry->digest));

commit a35c3fb6490cc1d3446e4781693408100113c4fb
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Thu Apr 25 10:44:04 2013 +0300

    ima: use dynamically allocated hash storage
    
    For each inode in the IMA policy, an iint is allocated.  To support
    larger hash digests, the iint digest size changed from 20 bytes to
    the maximum supported hash digest size.  Instead of allocating the
    maximum size, which most likely is not needed, this patch dynamically
    allocates the needed hash storage.
    
    Changelog:
    - fix krealloc bug
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 1dba98e2d7e9..5a7942e20814 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -44,7 +44,10 @@ int ima_store_template(struct ima_template_entry *entry,
 	const char *op = "add_template_measure";
 	const char *audit_cause = "hashing_error";
 	int result;
-	struct ima_digest_data hash;
+	struct {
+		struct ima_digest_data hdr;
+		char digest[IMA_MAX_DIGEST_SIZE];
+	} hash;
 
 	memset(entry->digest, 0, sizeof(entry->digest));
 	entry->template_name = IMA_TEMPLATE_NAME;
@@ -52,14 +55,14 @@ int ima_store_template(struct ima_template_entry *entry,
 
 	if (!violation) {
 		result = ima_calc_buffer_hash(&entry->template,
-					      entry->template_len, &hash);
+					      entry->template_len, &hash.hdr);
 		if (result < 0) {
 			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,
 					    entry->template_name, op,
 					    audit_cause, result, 0);
 			return result;
 		}
-		memcpy(entry->digest, hash.digest, hash.length);
+		memcpy(entry->digest, hash.hdr.digest, hash.hdr.length);
 	}
 	result = ima_add_template_entry(entry, violation, op, inode);
 	return result;
@@ -146,6 +149,10 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	struct inode *inode = file_inode(file);
 	const char *filename = file->f_dentry->d_name.name;
 	int result = 0;
+	struct {
+		struct ima_digest_data hdr;
+		char digest[IMA_MAX_DIGEST_SIZE];
+	} hash;
 
 	if (xattr_value)
 		*xattr_len = ima_read_xattr(file->f_dentry, xattr_value);
@@ -154,16 +161,23 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 		u64 i_version = file_inode(file)->i_version;
 
 		/* use default hash algorithm */
-		iint->ima_hash.algo = ima_hash_algo;
+		hash.hdr.algo = ima_hash_algo;
 
 		if (xattr_value)
-			ima_get_hash_algo(*xattr_value, *xattr_len,
-					  &iint->ima_hash);
+			ima_get_hash_algo(*xattr_value, *xattr_len, &hash.hdr);
 
-		result = ima_calc_file_hash(file, &iint->ima_hash);
+		result = ima_calc_file_hash(file, &hash.hdr);
 		if (!result) {
-			iint->version = i_version;
-			iint->flags |= IMA_COLLECTED;
+			int length = sizeof(hash.hdr) + hash.hdr.length;
+			void *tmpbuf = krealloc(iint->ima_hash, length,
+						GFP_NOFS);
+			if (tmpbuf) {
+				iint->ima_hash = tmpbuf;
+				memcpy(iint->ima_hash, &hash, length);
+				iint->version = i_version;
+				iint->flags |= IMA_COLLECTED;
+			} else
+				result = -ENOMEM;
 		}
 	}
 	if (result)
@@ -208,21 +222,24 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 		return;
 	}
 	memset(&entry->template, 0, sizeof(entry->template));
-	if (iint->ima_hash.algo != ima_hash_algo) {
-		struct ima_digest_data hash;
+	if (iint->ima_hash->algo != ima_hash_algo) {
+		struct {
+			struct ima_digest_data hdr;
+			char digest[IMA_MAX_DIGEST_SIZE];
+		} hash;
 
-		hash.algo = ima_hash_algo;
-		result = ima_calc_file_hash(file, &hash);
+		hash.hdr.algo = ima_hash_algo;
+		result = ima_calc_file_hash(file, &hash.hdr);
 		if (result)
 			integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,
 					    filename, "collect_data", "failed",
 					    result, 0);
 		else
-			memcpy(entry->template.digest, hash.digest,
-			       hash.length);
+			memcpy(entry->template.digest, hash.hdr.digest,
+			       hash.hdr.length);
 	} else
-		memcpy(entry->template.digest, iint->ima_hash.digest,
-		       iint->ima_hash.length);
+		memcpy(entry->template.digest, iint->ima_hash->digest,
+		       iint->ima_hash->length);
 	strcpy(entry->template.file_name,
 	       (strlen(filename) > IMA_EVENT_NAME_LEN_MAX) ?
 	       file->f_dentry->d_name.name : filename);
@@ -238,14 +255,14 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 			   const unsigned char *filename)
 {
 	struct audit_buffer *ab;
-	char hash[(iint->ima_hash.length * 2) + 1];
+	char hash[(iint->ima_hash->length * 2) + 1];
 	int i;
 
 	if (iint->flags & IMA_AUDITED)
 		return;
 
-	for (i = 0; i < iint->ima_hash.length; i++)
-		hex_byte_pack(hash + (i * 2), iint->ima_hash.digest[i]);
+	for (i = 0; i < iint->ima_hash->length; i++)
+		hex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);
 	hash[i * 2] = '\0';
 
 	ab = audit_log_start(current->audit_context, GFP_KERNEL,

commit d3634d0f426bdeb433cb288bdbb0a5e16cf3dbbf
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Thu Apr 25 10:44:04 2013 +0300

    ima: read and use signature hash algorithm
    
    All files on the filesystem, currently, are hashed using the same hash
    algorithm.  In preparation for files from different packages being
    signed using different hash algorithms, this patch adds support for
    reading the signature hash algorithm from the 'security.ima' extended
    attribute and calculates the appropriate file data hash based on it.
    
    Changelog:
    - fix scripts Lindent and checkpatch msgs - Mimi
    - fix md5 support for older version, which occupied 20 bytes in the
      xattr, not the expected 16 bytes.  Fix the comparison to compare
      only the first 16 bytes.
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index e531fe22e582..1dba98e2d7e9 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -139,17 +139,27 @@ int ima_must_measure(struct inode *inode, int mask, int function)
  * Return 0 on success, error code otherwise
  */
 int ima_collect_measurement(struct integrity_iint_cache *iint,
-			    struct file *file)
+			    struct file *file,
+			    struct evm_ima_xattr_data **xattr_value,
+			    int *xattr_len)
 {
 	struct inode *inode = file_inode(file);
 	const char *filename = file->f_dentry->d_name.name;
 	int result = 0;
 
+	if (xattr_value)
+		*xattr_len = ima_read_xattr(file->f_dentry, xattr_value);
+
 	if (!(iint->flags & IMA_COLLECTED)) {
 		u64 i_version = file_inode(file)->i_version;
 
 		/* use default hash algorithm */
 		iint->ima_hash.algo = ima_hash_algo;
+
+		if (xattr_value)
+			ima_get_hash_algo(*xattr_value, *xattr_len,
+					  &iint->ima_hash);
+
 		result = ima_calc_file_hash(file, &iint->ima_hash);
 		if (!result) {
 			iint->version = i_version;

commit c7c8bb237fdbff932b5e431aebee5ce862ea07d1
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Thu Apr 25 10:43:56 2013 +0300

    ima: provide support for arbitrary hash algorithms
    
    In preparation of supporting more hash algorithms with larger hash sizes
    needed for signature verification, this patch replaces the 20 byte sized
    digest, with a more flexible structure.  The new structure includes the
    hash algorithm, digest size, and digest.
    
    Changelog:
    - recalculate filedata hash for the measurement list, if the signature
      hash digest size is greater than 20 bytes.
    - use generic HASH_ALGO_
    - make ima_calc_file_hash static
    - scripts lindent and checkpatch fixes
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 1c03e8f1e0e1..e531fe22e582 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -44,6 +44,7 @@ int ima_store_template(struct ima_template_entry *entry,
 	const char *op = "add_template_measure";
 	const char *audit_cause = "hashing_error";
 	int result;
+	struct ima_digest_data hash;
 
 	memset(entry->digest, 0, sizeof(entry->digest));
 	entry->template_name = IMA_TEMPLATE_NAME;
@@ -51,14 +52,14 @@ int ima_store_template(struct ima_template_entry *entry,
 
 	if (!violation) {
 		result = ima_calc_buffer_hash(&entry->template,
-						entry->template_len,
-						entry->digest);
+					      entry->template_len, &hash);
 		if (result < 0) {
 			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,
 					    entry->template_name, op,
 					    audit_cause, result, 0);
 			return result;
 		}
+		memcpy(entry->digest, hash.digest, hash.length);
 	}
 	result = ima_add_template_entry(entry, violation, op, inode);
 	return result;
@@ -147,8 +148,9 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	if (!(iint->flags & IMA_COLLECTED)) {
 		u64 i_version = file_inode(file)->i_version;
 
-		iint->ima_xattr.type = IMA_XATTR_DIGEST;
-		result = ima_calc_file_hash(file, iint->ima_xattr.digest);
+		/* use default hash algorithm */
+		iint->ima_hash.algo = ima_hash_algo;
+		result = ima_calc_file_hash(file, &iint->ima_hash);
 		if (!result) {
 			iint->version = i_version;
 			iint->flags |= IMA_COLLECTED;
@@ -196,7 +198,21 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 		return;
 	}
 	memset(&entry->template, 0, sizeof(entry->template));
-	memcpy(entry->template.digest, iint->ima_xattr.digest, IMA_DIGEST_SIZE);
+	if (iint->ima_hash.algo != ima_hash_algo) {
+		struct ima_digest_data hash;
+
+		hash.algo = ima_hash_algo;
+		result = ima_calc_file_hash(file, &hash);
+		if (result)
+			integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,
+					    filename, "collect_data", "failed",
+					    result, 0);
+		else
+			memcpy(entry->template.digest, hash.digest,
+			       hash.length);
+	} else
+		memcpy(entry->template.digest, iint->ima_hash.digest,
+		       iint->ima_hash.length);
 	strcpy(entry->template.file_name,
 	       (strlen(filename) > IMA_EVENT_NAME_LEN_MAX) ?
 	       file->f_dentry->d_name.name : filename);
@@ -212,14 +228,14 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 			   const unsigned char *filename)
 {
 	struct audit_buffer *ab;
-	char hash[(IMA_DIGEST_SIZE * 2) + 1];
+	char hash[(iint->ima_hash.length * 2) + 1];
 	int i;
 
 	if (iint->flags & IMA_AUDITED)
 		return;
 
-	for (i = 0; i < IMA_DIGEST_SIZE; i++)
-		hex_byte_pack(hash + (i * 2), iint->ima_xattr.digest[i]);
+	for (i = 0; i < iint->ima_hash.length; i++)
+		hex_byte_pack(hash + (i * 2), iint->ima_hash.digest[i]);
 	hash[i * 2] = '\0';
 
 	ab = audit_log_start(current->audit_context, GFP_KERNEL,

commit d895cb1af15c04c522a25c79cc429076987c089b
Merge: 9626357371b5 d3d009cb965e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 26 20:16:07 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile (part one) from Al Viro:
     "Assorted stuff - cleaning namei.c up a bit, fixing ->d_name/->d_parent
      locking violations, etc.
    
      The most visible changes here are death of FS_REVAL_DOT (replaced with
      "has ->d_weak_revalidate()") and a new helper getting from struct file
      to inode.  Some bits of preparation to xattr method interface changes.
    
      Misc patches by various people sent this cycle *and* ocfs2 fixes from
      several cycles ago that should've been upstream right then.
    
      PS: the next vfs pile will be xattr stuff."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (46 commits)
      saner proc_get_inode() calling conventions
      proc: avoid extra pde_put() in proc_fill_super()
      fs: change return values from -EACCES to -EPERM
      fs/exec.c: make bprm_mm_init() static
      ocfs2/dlm: use GFP_ATOMIC inside a spin_lock
      ocfs2: fix possible use-after-free with AIO
      ocfs2: Fix oops in ocfs2_fast_symlink_readpage() code path
      get_empty_filp()/alloc_file() leave both ->f_pos and ->f_version zero
      target: writev() on single-element vector is pointless
      export kernel_write(), convert open-coded instances
      fs: encode_fh: return FILEID_INVALID if invalid fid_type
      kill f_vfsmnt
      vfs: kill FS_REVAL_DOT by adding a d_weak_revalidate dentry op
      nfsd: handle vfs_getattr errors in acl protocol
      switch vfs_getattr() to struct path
      default SET_PERSONALITY() in linux/elf.h
      ceph: prepopulate inodes only when request is aborted
      d_hash_and_lookup(): export, switch open-coded instances
      9p: switch v9fs_set_create_acl() to inode+fid, do it before d_instantiate()
      9p: split dropping the acls from v9fs_set_create_acl()
      ...

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 0cea3db21657..27cb9eb42cc8 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -140,12 +140,12 @@ int ima_must_measure(struct inode *inode, int mask, int function)
 int ima_collect_measurement(struct integrity_iint_cache *iint,
 			    struct file *file)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = file_inode(file);
 	const char *filename = file->f_dentry->d_name.name;
 	int result = 0;
 
 	if (!(iint->flags & IMA_COLLECTED)) {
-		u64 i_version = file->f_dentry->d_inode->i_version;
+		u64 i_version = file_inode(file)->i_version;
 
 		iint->ima_xattr.type = IMA_XATTR_DIGEST;
 		result = ima_calc_hash(file, iint->ima_xattr.digest);
@@ -182,7 +182,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	const char *op = "add_template_measure";
 	const char *audit_cause = "ENOMEM";
 	int result = -ENOMEM;
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = file_inode(file);
 	struct ima_template_entry *entry;
 	int violation = 0;
 

commit 50af554466804bf51a52fa3d1d0a76f96bd33929
Author: Dmitry Kasatkin <dmitry.kasatkin@intel.com>
Date:   Mon May 14 14:13:56 2012 +0300

    ima: rename hash calculation functions
    
    Rename hash calculation functions to reflect meaning
    and change argument order in conventional way.
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@intel.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 9382a4c568b2..d9030b29d84d 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -50,8 +50,8 @@ int ima_store_template(struct ima_template_entry *entry,
 	entry->template_len = sizeof(entry->template);
 
 	if (!violation) {
-		result = ima_calc_template_hash(entry->template_len,
-						&entry->template,
+		result = ima_calc_buffer_hash(&entry->template,
+						entry->template_len,
 						entry->digest);
 		if (result < 0) {
 			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,
@@ -148,7 +148,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 		u64 i_version = file->f_dentry->d_inode->i_version;
 
 		iint->ima_xattr.type = IMA_XATTR_DIGEST;
-		result = ima_calc_hash(file, iint->ima_xattr.digest);
+		result = ima_calc_file_hash(file, iint->ima_xattr.digest);
 		if (!result) {
 			iint->version = i_version;
 			iint->flags |= IMA_COLLECTED;

commit ea1046d4c57ee6e3d5f68f19dd9a45bbab0b71a0
Author: Dmitry Kasatkin <dmitry.kasatkin@intel.com>
Date:   Tue Sep 4 00:40:17 2012 +0300

    ima: move full pathname resolution to separate function
    
    Define a new function ima_d_path(), which returns the full pathname.
    This function will be used further, for example, by the directory
    verification code.
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@intel.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index fc722b44c416..9382a4c568b2 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -237,3 +237,20 @@ void ima_audit_measurement(struct integrity_iint_cache *iint,
 
 	iint->flags |= IMA_AUDITED;
 }
+
+const char *ima_d_path(struct path *path, char **pathbuf)
+{
+	char *pathname = NULL;
+
+	/* We will allow 11 spaces for ' (deleted)' to be appended */
+	*pathbuf = kmalloc(PATH_MAX + 11, GFP_KERNEL);
+	if (*pathbuf) {
+		pathname = d_path(path, *pathbuf, PATH_MAX + 11);
+		if (IS_ERR(pathname)) {
+			kfree(*pathbuf);
+			*pathbuf = NULL;
+			pathname = NULL;
+		}
+	}
+	return pathname;
+}

commit 16cac49f727621c6b0467ffe15ed72c2febb1296
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Dec 13 11:15:04 2012 -0500

    ima: rename FILE_MMAP to MMAP_CHECK
    
    Rename FILE_MMAP hook to MMAP_CHECK to be consistent with the other
    hook names.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 0cea3db21657..fc722b44c416 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -100,12 +100,12 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
  * ima_get_action - appraise & measure decision based on policy.
  * @inode: pointer to inode to measure
  * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
- * @function: calling function (FILE_CHECK, BPRM_CHECK, FILE_MMAP, MODULE_CHECK)
+ * @function: calling function (FILE_CHECK, BPRM_CHECK, MMAP_CHECK, MODULE_CHECK)
  *
  * The policy is defined in terms of keypairs:
  * 		subj=, obj=, type=, func=, mask=, fsmagic=
  *	subj,obj, and type: are LSM specific.
- * 	func: FILE_CHECK | BPRM_CHECK | FILE_MMAP | MODULE_CHECK
+ * 	func: FILE_CHECK | BPRM_CHECK | MMAP_CHECK | MODULE_CHECK
  * 	mask: contains the permission mask
  *	fsmagic: hex value
  *

commit fdf90729e57812cb12d7938e2dee7c71e875fb08
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Oct 16 12:40:08 2012 +1030

    ima: support new kernel module syscall
    
    With the addition of the new kernel module syscall, which defines two
    arguments - a file descriptor to the kernel module and a pointer to a NULL
    terminated string of module arguments - it is now possible to measure and
    appraise kernel modules like any other file on the file system.
    
    This patch adds support to measure and appraise kernel modules in an
    extensible and consistent manner.
    
    To support filesystems without extended attribute support, additional
    patches could pass the signature as the first parameter.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index b356884fb3ef..0cea3db21657 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -100,12 +100,12 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
  * ima_get_action - appraise & measure decision based on policy.
  * @inode: pointer to inode to measure
  * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
- * @function: calling function (FILE_CHECK, BPRM_CHECK, FILE_MMAP)
+ * @function: calling function (FILE_CHECK, BPRM_CHECK, FILE_MMAP, MODULE_CHECK)
  *
  * The policy is defined in terms of keypairs:
  * 		subj=, obj=, type=, func=, mask=, fsmagic=
  *	subj,obj, and type: are LSM specific.
- * 	func: FILE_CHECK | BPRM_CHECK | FILE_MMAP
+ * 	func: FILE_CHECK | BPRM_CHECK | FILE_MMAP | MODULE_CHECK
  * 	mask: contains the permission mask
  *	fsmagic: hex value
  *

commit e7c568e0fd0cf6d9c8ab8ea537ba8f3a3ae7c3d8
Author: Peter Moody <pmoody@google.com>
Date:   Thu Jun 14 10:04:36 2012 -0700

    ima: audit log hashes
    
    This adds an 'audit' policy action which audit logs file measurements.
    
    Changelog v6:
     - use new action flag handling (Dmitry Kasatkin).
     - removed whitespace (Mimi)
    
    Changelog v5:
     - use audit_log_untrustedstring.
    
    Changelog v4:
     - cleanup digest -> hash conversion.
     - use filename rather than d_path in ima_audit_measurement.
    
    Changelog v3:
     - Use newly exported audit_log_task_info for logging pid/ppid/uid/etc.
     - Update the ima_policy ABI documentation.
    
    Changelog v2:
     - Use 'audit' action rather than 'measure_and_audit' to permit
     auditing in the absence of measuring..
    
    Changelog v1:
     - Initial posting.
    
    Signed-off-by: Peter Moody <pmoody@google.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index f0d60e754b3e..b356884fb3ef 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -114,7 +114,7 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
  */
 int ima_get_action(struct inode *inode, int mask, int function)
 {
-	int flags = IMA_MEASURE | IMA_APPRAISE;
+	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;
 
 	if (!ima_appraise)
 		flags &= ~IMA_APPRAISE;
@@ -207,3 +207,33 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	if (result < 0)
 		kfree(entry);
 }
+
+void ima_audit_measurement(struct integrity_iint_cache *iint,
+			   const unsigned char *filename)
+{
+	struct audit_buffer *ab;
+	char hash[(IMA_DIGEST_SIZE * 2) + 1];
+	int i;
+
+	if (iint->flags & IMA_AUDITED)
+		return;
+
+	for (i = 0; i < IMA_DIGEST_SIZE; i++)
+		hex_byte_pack(hash + (i * 2), iint->ima_xattr.digest[i]);
+	hash[i * 2] = '\0';
+
+	ab = audit_log_start(current->audit_context, GFP_KERNEL,
+			     AUDIT_INTEGRITY_RULE);
+	if (!ab)
+		return;
+
+	audit_log_format(ab, "file=");
+	audit_log_untrustedstring(ab, filename);
+	audit_log_format(ab, " hash=");
+	audit_log_untrustedstring(ab, hash);
+
+	audit_log_task_info(ab, current);
+	audit_log_end(ab);
+
+	iint->flags |= IMA_AUDITED;
+}

commit d9d300cdb6f233c4c591348919c758062198a4f4
Author: Dmitry Kasatkin <dmitry.kasatkin@intel.com>
Date:   Wed Jun 27 11:26:14 2012 +0300

    ima: rename ima_must_appraise_or_measure
    
    When AUDIT action support is added to the IMA,
    ima_must_appraise_or_measure() does not reflect the real meaning anymore.
    Rename it to ima_get_action().
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@intel.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 33d46859753a..f0d60e754b3e 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -97,7 +97,7 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
 }
 
 /**
- * ima_must_appraise_or_measure - appraise & measure decision based on policy.
+ * ima_get_action - appraise & measure decision based on policy.
  * @inode: pointer to inode to measure
  * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
  * @function: calling function (FILE_CHECK, BPRM_CHECK, FILE_MMAP)
@@ -112,7 +112,7 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
  * Returns IMA_MEASURE, IMA_APPRAISE mask.
  *
  */
-int ima_must_appraise_or_measure(struct inode *inode, int mask, int function)
+int ima_get_action(struct inode *inode, int mask, int function)
 {
 	int flags = IMA_MEASURE | IMA_APPRAISE;
 

commit 5a44b41207174e1882ce0c24a752f4cfb65dab07
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Jan 9 22:59:36 2012 -0500

    ima: add support for different security.ima data types
    
    IMA-appraisal currently verifies the integrity of a file based on a
    known 'good' measurement value.  This patch reserves the first byte
    of 'security.ima' as a place holder for the type of method used for
    verifying file data integrity.
    
    Changelog v1:
    - Use the newly defined 'struct evm_ima_xattr_data'
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@nokia.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 41cce84416c5..33d46859753a 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -147,8 +147,8 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	if (!(iint->flags & IMA_COLLECTED)) {
 		u64 i_version = file->f_dentry->d_inode->i_version;
 
-		memset(iint->digest, 0, IMA_DIGEST_SIZE);
-		result = ima_calc_hash(file, iint->digest);
+		iint->ima_xattr.type = IMA_XATTR_DIGEST;
+		result = ima_calc_hash(file, iint->ima_xattr.digest);
 		if (!result) {
 			iint->version = i_version;
 			iint->flags |= IMA_COLLECTED;
@@ -196,7 +196,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 		return;
 	}
 	memset(&entry->template, 0, sizeof(entry->template));
-	memcpy(entry->template.digest, iint->digest, IMA_DIGEST_SIZE);
+	memcpy(entry->template.digest, iint->ima_xattr.digest, IMA_DIGEST_SIZE);
 	strcpy(entry->template.file_name,
 	       (strlen(filename) > IMA_EVENT_NAME_LEN_MAX) ?
 	       file->f_dentry->d_name.name : filename);

commit 2fe5d6def1672ae6635dd71867bf36dcfaa7434b
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Feb 13 10:15:05 2012 -0500

    ima: integrity appraisal extension
    
    IMA currently maintains an integrity measurement list used to assert the
    integrity of the running system to a third party.  The IMA-appraisal
    extension adds local integrity validation and enforcement of the
    measurement against a "good" value stored as an extended attribute
    'security.ima'.  The initial methods for validating 'security.ima' are
    hashed based, which provides file data integrity, and digital signature
    based, which in addition to providing file data integrity, provides
    authenticity.
    
    This patch creates and maintains the 'security.ima' xattr, containing
    the file data hash measurement.  Protection of the xattr is provided by
    EVM, if enabled and configured.
    
    Based on policy, IMA calls evm_verifyxattr() to verify a file's metadata
    integrity and, assuming success, compares the file's current hash value
    with the one stored as an extended attribute in 'security.ima'.
    
    Changelov v4:
    - changed iint cache flags to hex values
    
    Changelog v3:
    - change appraisal default for filesystems without xattr support to fail
    
    Changelog v2:
    - fix audit msg 'res' value
    - removed unused 'ima_appraise=' values
    
    Changelog v1:
    - removed unused iint mutex (Dmitry Kasatkin)
    - setattr hook must not reset appraised (Dmitry Kasatkin)
    - evm_verifyxattr() now differentiates between no 'security.evm' xattr
      (INTEGRITY_NOLABEL) and no EVM 'protected' xattrs included in the
      'security.evm' (INTEGRITY_NOXATTRS).
    - replace hash_status with ima_status (Dmitry Kasatkin)
    - re-initialize slab element ima_status on free (Dmitry Kasatkin)
    - include 'security.ima' in EVM if CONFIG_IMA_APPRAISE, not CONFIG_IMA
    - merged half "ima: ima_must_appraise_or_measure API change" (Dmitry Kasatkin)
    - removed unnecessary error variable in process_measurement() (Dmitry Kasatkin)
    - use ima_inode_post_setattr() stub function, if IMA_APPRAISE not configured
      (moved ima_inode_post_setattr() to ima_appraise.c)
    - make sure ima_collect_measurement() can read file
    
    Changelog:
    - add 'iint' to evm_verifyxattr() call (Dimitry Kasatkin)
    - fix the race condition between chmod, which takes the i_mutex and then
      iint->mutex, and ima_file_free() and process_measurement(), which take
      the locks in the reverse order, by eliminating iint->mutex. (Dmitry Kasatkin)
    - cleanup of ima_appraise_measurement() (Dmitry Kasatkin)
    - changes as a result of the iint not allocated for all regular files, but
      only for those measured/appraised.
    - don't try to appraise new/empty files
    - expanded ima_appraisal description in ima/Kconfig
    - IMA appraise definitions required even if IMA_APPRAISE not enabled
    - add return value to ima_must_appraise() stub
    - unconditionally set status = INTEGRITY_PASS *after* testing status,
      not before.  (Found by Joe Perches)
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@intel.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 032ff03ad907..41cce84416c5 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -9,13 +9,17 @@
  * License.
  *
  * File: ima_api.c
- *	Implements must_measure, collect_measurement, store_measurement,
- *	and store_template.
+ *	Implements must_appraise_or_measure, collect_measurement,
+ *	appraise_measurement, store_measurement and store_template.
  */
 #include <linux/module.h>
 #include <linux/slab.h>
-
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/xattr.h>
+#include <linux/evm.h>
 #include "ima.h"
+
 static const char *IMA_TEMPLATE_NAME = "ima";
 
 /*
@@ -93,7 +97,7 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
 }
 
 /**
- * ima_must_measure - measure decision based on policy.
+ * ima_must_appraise_or_measure - appraise & measure decision based on policy.
  * @inode: pointer to inode to measure
  * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
  * @function: calling function (FILE_CHECK, BPRM_CHECK, FILE_MMAP)
@@ -105,15 +109,22 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
  * 	mask: contains the permission mask
  *	fsmagic: hex value
  *
- * Return 0 to measure. For matching a DONT_MEASURE policy, no policy,
- * or other error, return an error code.
-*/
-int ima_must_measure(struct inode *inode, int mask, int function)
+ * Returns IMA_MEASURE, IMA_APPRAISE mask.
+ *
+ */
+int ima_must_appraise_or_measure(struct inode *inode, int mask, int function)
 {
-	int must_measure;
+	int flags = IMA_MEASURE | IMA_APPRAISE;
+
+	if (!ima_appraise)
+		flags &= ~IMA_APPRAISE;
+
+	return ima_match_policy(inode, function, mask, flags);
+}
 
-	must_measure = ima_match_policy(inode, function, mask);
-	return must_measure ? 0 : -EACCES;
+int ima_must_measure(struct inode *inode, int mask, int function)
+{
+	return ima_match_policy(inode, function, mask, IMA_MEASURE);
 }
 
 /*
@@ -129,16 +140,24 @@ int ima_must_measure(struct inode *inode, int mask, int function)
 int ima_collect_measurement(struct integrity_iint_cache *iint,
 			    struct file *file)
 {
-	int result = -EEXIST;
+	struct inode *inode = file->f_dentry->d_inode;
+	const char *filename = file->f_dentry->d_name.name;
+	int result = 0;
 
-	if (!(iint->flags & IMA_MEASURED)) {
+	if (!(iint->flags & IMA_COLLECTED)) {
 		u64 i_version = file->f_dentry->d_inode->i_version;
 
 		memset(iint->digest, 0, IMA_DIGEST_SIZE);
 		result = ima_calc_hash(file, iint->digest);
-		if (!result)
+		if (!result) {
 			iint->version = i_version;
+			iint->flags |= IMA_COLLECTED;
+		}
 	}
+	if (result)
+		integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,
+				    filename, "collect_data", "failed",
+				    result, 0);
 	return result;
 }
 
@@ -167,6 +186,9 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	struct ima_template_entry *entry;
 	int violation = 0;
 
+	if (iint->flags & IMA_MEASURED)
+		return;
+
 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry) {
 		integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,

commit 08e1b76ae399a010c0d0916b125d75aed6961d16
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Jun 20 09:32:55 2012 -0400

    ima: use full pathnames in measurement list
    
    The IMA measurement list contains filename hints, which can be
    ambigious without the full pathname.  This patch replaces the
    filename hint with the full pathname, simplifying for userspace
    the correlating of file hash measurements with files.
    
    Change log v1:
    - Revert to short filenames, when full pathname is longer than IMA
      measurement buffer size. (Based on Dmitry's review)
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 88a2788b981d..032ff03ad907 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -175,7 +175,9 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	}
 	memset(&entry->template, 0, sizeof(entry->template));
 	memcpy(entry->template.digest, iint->digest, IMA_DIGEST_SIZE);
-	strncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);
+	strcpy(entry->template.file_name,
+	       (strlen(filename) > IMA_EVENT_NAME_LEN_MAX) ?
+	       file->f_dentry->d_name.name : filename);
 
 	result = ima_store_template(entry, violation, inode);
 	if (!result || result == -EEXIST)

commit 45fae7493970d7c45626ccd96d4a74f5f1eea5a9
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Mon Dec 19 15:57:27 2011 +0100

    ima: free duplicate measurement memory
    
    Info about new measurements are cached in the iint for performance.  When
    the inode is flushed from cache, the associated iint is flushed as well.
    Subsequent access to the inode will cause the inode to be re-measured and
    will attempt to add a duplicate entry to the measurement list.
    
    This patch frees the duplicate measurement memory, fixing a memory leak.
    
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Cc: stable@vger.kernel.org

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 0d50df04ccc4..88a2788b981d 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -178,8 +178,8 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	strncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);
 
 	result = ima_store_template(entry, violation, inode);
-	if (!result)
+	if (!result || result == -EEXIST)
 		iint->flags |= IMA_MEASURED;
-	else
+	if (result < 0)
 		kfree(entry);
 }

commit f381c272224f5f158f5cff64f8f3481fa0eee8b3
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Mar 9 14:13:22 2011 -0500

    integrity: move ima inode integrity data management
    
    Move the inode integrity data(iint) management up to the integrity directory
    in order to share the iint among the different integrity models.
    
    Changelog:
    - don't define MAX_DIGEST_SIZE
    - rename several globally visible 'ima_' prefixed functions, structs,
      locks, etc to 'integrity_'
    - replace '20' with SHA1_DIGEST_SIZE
    - reflect location change in appropriate Kconfig and Makefiles
    - remove unnecessary initialization of iint_initialized to 0
    - rebased on current ima_iint.c
    - define integrity_iint_store/lock as static
    
    There should be no other functional changes.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index da36d2c085a4..0d50df04ccc4 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -126,7 +126,8 @@ int ima_must_measure(struct inode *inode, int mask, int function)
  *
  * Return 0 on success, error code otherwise
  */
-int ima_collect_measurement(struct ima_iint_cache *iint, struct file *file)
+int ima_collect_measurement(struct integrity_iint_cache *iint,
+			    struct file *file)
 {
 	int result = -EEXIST;
 
@@ -156,8 +157,8 @@ int ima_collect_measurement(struct ima_iint_cache *iint, struct file *file)
  *
  * Must be called with iint->mutex held.
  */
-void ima_store_measurement(struct ima_iint_cache *iint, struct file *file,
-			   const unsigned char *filename)
+void ima_store_measurement(struct integrity_iint_cache *iint,
+			   struct file *file, const unsigned char *filename)
 {
 	const char *op = "add_template_measure";
 	const char *audit_cause = "ENOMEM";

commit 1adace9bb04a5f4a4dea9e642089102661bb0ceb
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Feb 22 10:19:43 2011 -0500

    ima: remove unnecessary call to ima_must_measure
    
    The original ima_must_measure() function based its results on cached
    iint information, which required an iint be allocated for all files.
    Currently, an iint is allocated only for files in policy.  As a result,
    for those files in policy, ima_must_measure() is now called twice: once
    to determine if the inode is in the measurement policy and, the second
    time, to determine if it needs to be measured/re-measured.
    
    The second call to ima_must_measure() unnecessarily checks to see if
    the file is in policy. As we already know the file is in policy, this
    patch removes the second unnecessary call to ima_must_measure(), removes
    the vestige iint parameter, and just checks the iint directly to determine
    if the inode has been measured or needs to be measured/re-measured.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Eric Paris <eparis@redhat.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index d3963de6003d..da36d2c085a4 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -105,20 +105,13 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
  * 	mask: contains the permission mask
  *	fsmagic: hex value
  *
- * Must be called with iint->mutex held.
- *
- * Return 0 to measure. Return 1 if already measured.
- * For matching a DONT_MEASURE policy, no policy, or other
- * error, return an error code.
+ * Return 0 to measure. For matching a DONT_MEASURE policy, no policy,
+ * or other error, return an error code.
 */
-int ima_must_measure(struct ima_iint_cache *iint, struct inode *inode,
-		     int mask, int function)
+int ima_must_measure(struct inode *inode, int mask, int function)
 {
 	int must_measure;
 
-	if (iint && iint->flags & IMA_MEASURED)
-		return 1;
-
 	must_measure = ima_match_policy(inode, function, mask);
 	return must_measure ? 0 : -EACCES;
 }

commit a178d2027d3198b0a04517d764326ab71cd73da2
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Oct 25 14:41:59 2010 -0400

    IMA: move read counter into struct inode
    
    IMA currently allocated an inode integrity structure for every inode in
    core.  This stucture is about 120 bytes long.  Most files however
    (especially on a system which doesn't make use of IMA) will never need
    any of this space.  The problem is that if IMA is enabled we need to
    know information about the number of readers and the number of writers
    for every inode on the box.  At the moment we collect that information
    in the per inode iint structure and waste the rest of the space.  This
    patch moves those counters into the struct inode so we can eventually
    stop allocating an IMA integrity structure except when absolutely
    needed.
    
    This patch does the minimum needed to move the location of the data.
    Further cleanups, especially the location of counter updates, may still
    be possible.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 52015d098fdf..d3963de6003d 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -116,7 +116,7 @@ int ima_must_measure(struct ima_iint_cache *iint, struct inode *inode,
 {
 	int must_measure;
 
-	if (iint->flags & IMA_MEASURED)
+	if (iint && iint->flags & IMA_MEASURED)
 		return 1;
 
 	must_measure = ima_match_policy(inode, function, mask);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 2a5e0bcf3887..52015d098fdf 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -13,6 +13,7 @@
  *	and store_template.
  */
 #include <linux/module.h>
+#include <linux/slab.h>
 
 #include "ima.h"
 static const char *IMA_TEMPLATE_NAME = "ima";

commit 1e93d0052d9a6b3d0b382eedceb18b519d603baf
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Jan 26 17:02:41 2010 -0500

    ima: rename PATH_CHECK to FILE_CHECK
    
    With the movement of the ima hooks functions were renamed from *path* to
    *file* since they always deal with struct file.  This patch renames some of
    the ima internal flags to make them consistent with the rest of the code.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 3cd58b60afd2..2a5e0bcf3887 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -95,12 +95,12 @@ void ima_add_violation(struct inode *inode, const unsigned char *filename,
  * ima_must_measure - measure decision based on policy.
  * @inode: pointer to inode to measure
  * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
- * @function: calling function (PATH_CHECK, BPRM_CHECK, FILE_MMAP)
+ * @function: calling function (FILE_CHECK, BPRM_CHECK, FILE_MMAP)
  *
  * The policy is defined in terms of keypairs:
  * 		subj=, obj=, type=, func=, mask=, fsmagic=
  *	subj,obj, and type: are LSM specific.
- * 	func: PATH_CHECK | BPRM_CHECK | FILE_MMAP
+ * 	func: FILE_CHECK | BPRM_CHECK | FILE_MMAP
  * 	mask: contains the permission mask
  *	fsmagic: hex value
  *

commit 523979adfa0b79d4e3aa053220c37a9233294206
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Feb 11 11:12:28 2009 -0500

    integrity: audit update
    
    Based on discussions on linux-audit, as per Steve Grubb's request
    http://lkml.org/lkml/2009/2/6/269, the following changes were made:
    - forced audit result to be either 0 or 1.
    - made template names const
    - Added new stand-alone message type: AUDIT_INTEGRITY_RULE
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index a148a25804f6..3cd58b60afd2 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -15,7 +15,7 @@
 #include <linux/module.h>
 
 #include "ima.h"
-static char *IMA_TEMPLATE_NAME = "ima";
+static const char *IMA_TEMPLATE_NAME = "ima";
 
 /*
  * ima_store_template - store ima template measurements

commit 3323eec921efd815178a23107ab63588c605c0b2
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Feb 4 09:06:58 2009 -0500

    integrity: IMA as an integrity service provider
    
    IMA provides hardware (TPM) based measurement and attestation for
    file measurements. As the Trusted Computing (TPM) model requires,
    IMA measures all files before they are accessed in any way (on the
    integrity_bprm_check, integrity_path_check and integrity_file_mmap
    hooks), and commits the measurements to the TPM. Once added to the
    TPM, measurements can not be removed.
    
    In addition, IMA maintains a list of these file measurements, which
    can be used to validate the aggregate value stored in the TPM.  The
    TPM can sign these measurements, and thus the system can prove, to
    itself and to a third party, the system's integrity in a way that
    cannot be circumvented by malicious or compromised software.
    
    - alloc ima_template_entry before calling ima_store_template()
    - log ima_add_boot_aggregate() failure
    - removed unused IMA_TEMPLATE_NAME_LEN
    - replaced hard coded string length with #define name
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
new file mode 100644
index 000000000000..a148a25804f6
--- /dev/null
+++ b/security/integrity/ima/ima_api.c
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2008 IBM Corporation
+ *
+ * Author: Mimi Zohar <zohar@us.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * File: ima_api.c
+ *	Implements must_measure, collect_measurement, store_measurement,
+ *	and store_template.
+ */
+#include <linux/module.h>
+
+#include "ima.h"
+static char *IMA_TEMPLATE_NAME = "ima";
+
+/*
+ * ima_store_template - store ima template measurements
+ *
+ * Calculate the hash of a template entry, add the template entry
+ * to an ordered list of measurement entries maintained inside the kernel,
+ * and also update the aggregate integrity value (maintained inside the
+ * configured TPM PCR) over the hashes of the current list of measurement
+ * entries.
+ *
+ * Applications retrieve the current kernel-held measurement list through
+ * the securityfs entries in /sys/kernel/security/ima. The signed aggregate
+ * TPM PCR (called quote) can be retrieved using a TPM user space library
+ * and is used to validate the measurement list.
+ *
+ * Returns 0 on success, error code otherwise
+ */
+int ima_store_template(struct ima_template_entry *entry,
+		       int violation, struct inode *inode)
+{
+	const char *op = "add_template_measure";
+	const char *audit_cause = "hashing_error";
+	int result;
+
+	memset(entry->digest, 0, sizeof(entry->digest));
+	entry->template_name = IMA_TEMPLATE_NAME;
+	entry->template_len = sizeof(entry->template);
+
+	if (!violation) {
+		result = ima_calc_template_hash(entry->template_len,
+						&entry->template,
+						entry->digest);
+		if (result < 0) {
+			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,
+					    entry->template_name, op,
+					    audit_cause, result, 0);
+			return result;
+		}
+	}
+	result = ima_add_template_entry(entry, violation, op, inode);
+	return result;
+}
+
+/*
+ * ima_add_violation - add violation to measurement list.
+ *
+ * Violations are flagged in the measurement list with zero hash values.
+ * By extending the PCR with 0xFF's instead of with zeroes, the PCR
+ * value is invalidated.
+ */
+void ima_add_violation(struct inode *inode, const unsigned char *filename,
+		       const char *op, const char *cause)
+{
+	struct ima_template_entry *entry;
+	int violation = 1;
+	int result;
+
+	/* can overflow, only indicator */
+	atomic_long_inc(&ima_htable.violations);
+
+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry) {
+		result = -ENOMEM;
+		goto err_out;
+	}
+	memset(&entry->template, 0, sizeof(entry->template));
+	strncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);
+	result = ima_store_template(entry, violation, inode);
+	if (result < 0)
+		kfree(entry);
+err_out:
+	integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,
+			    op, cause, result, 0);
+}
+
+/**
+ * ima_must_measure - measure decision based on policy.
+ * @inode: pointer to inode to measure
+ * @mask: contains the permission mask (MAY_READ, MAY_WRITE, MAY_EXECUTE)
+ * @function: calling function (PATH_CHECK, BPRM_CHECK, FILE_MMAP)
+ *
+ * The policy is defined in terms of keypairs:
+ * 		subj=, obj=, type=, func=, mask=, fsmagic=
+ *	subj,obj, and type: are LSM specific.
+ * 	func: PATH_CHECK | BPRM_CHECK | FILE_MMAP
+ * 	mask: contains the permission mask
+ *	fsmagic: hex value
+ *
+ * Must be called with iint->mutex held.
+ *
+ * Return 0 to measure. Return 1 if already measured.
+ * For matching a DONT_MEASURE policy, no policy, or other
+ * error, return an error code.
+*/
+int ima_must_measure(struct ima_iint_cache *iint, struct inode *inode,
+		     int mask, int function)
+{
+	int must_measure;
+
+	if (iint->flags & IMA_MEASURED)
+		return 1;
+
+	must_measure = ima_match_policy(inode, function, mask);
+	return must_measure ? 0 : -EACCES;
+}
+
+/*
+ * ima_collect_measurement - collect file measurement
+ *
+ * Calculate the file hash, if it doesn't already exist,
+ * storing the measurement and i_version in the iint.
+ *
+ * Must be called with iint->mutex held.
+ *
+ * Return 0 on success, error code otherwise
+ */
+int ima_collect_measurement(struct ima_iint_cache *iint, struct file *file)
+{
+	int result = -EEXIST;
+
+	if (!(iint->flags & IMA_MEASURED)) {
+		u64 i_version = file->f_dentry->d_inode->i_version;
+
+		memset(iint->digest, 0, IMA_DIGEST_SIZE);
+		result = ima_calc_hash(file, iint->digest);
+		if (!result)
+			iint->version = i_version;
+	}
+	return result;
+}
+
+/*
+ * ima_store_measurement - store file measurement
+ *
+ * Create an "ima" template and then store the template by calling
+ * ima_store_template.
+ *
+ * We only get here if the inode has not already been measured,
+ * but the measurement could already exist:
+ * 	- multiple copies of the same file on either the same or
+ *	  different filesystems.
+ *	- the inode was previously flushed as well as the iint info,
+ *	  containing the hashing info.
+ *
+ * Must be called with iint->mutex held.
+ */
+void ima_store_measurement(struct ima_iint_cache *iint, struct file *file,
+			   const unsigned char *filename)
+{
+	const char *op = "add_template_measure";
+	const char *audit_cause = "ENOMEM";
+	int result = -ENOMEM;
+	struct inode *inode = file->f_dentry->d_inode;
+	struct ima_template_entry *entry;
+	int violation = 0;
+
+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry) {
+		integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,
+				    op, audit_cause, result, 0);
+		return;
+	}
+	memset(&entry->template, 0, sizeof(entry->template));
+	memcpy(entry->template.digest, iint->digest, IMA_DIGEST_SIZE);
+	strncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);
+
+	result = ima_store_template(entry, violation, inode);
+	if (!result)
+		iint->flags |= IMA_MEASURED;
+	else
+		kfree(entry);
+}
