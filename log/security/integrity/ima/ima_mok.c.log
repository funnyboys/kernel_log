commit 028db3e290f15ac509084c0fc3b9d021f668f877
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 18:43:43 2019 -0700

    Revert "Merge tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs"
    
    This reverts merge 0f75ef6a9cff49ff612f7ce0578bced9d0b38325 (and thus
    effectively commits
    
       7a1ade847596 ("keys: Provide KEYCTL_GRANT_PERMISSION")
       2e12256b9a76 ("keys: Replace uid/gid/perm permissions checking with an ACL")
    
    that the merge brought in).
    
    It turns out that it breaks booting with an encrypted volume, and Eric
    biggers reports that it also breaks the fscrypt tests [1] and loading of
    in-kernel X.509 certificates [2].
    
    The root cause of all the breakage is likely the same, but David Howells
    is off email so rather than try to work it out it's getting reverted in
    order to not impact the rest of the merge window.
    
     [1] https://lore.kernel.org/lkml/20190710011559.GA7973@sol.localdomain/
     [2] https://lore.kernel.org/lkml/20190710013225.GB7973@sol.localdomain/
    
    Link: https://lore.kernel.org/lkml/CAHk-=wjxoeMJfeBahnWH=9zShKp2bsVy527vo3_y8HfOdhwAAw@mail.gmail.com/
    Reported-by: Eric Biggers <ebiggers@kernel.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index b52ae1476ec3..36cadadbfba4 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -16,15 +16,6 @@
 #include <keys/system_keyring.h>
 
 
-static struct key_acl integrity_blacklist_keyring_acl = {
-	.usage	= REFCOUNT_INIT(1),
-	.nr_ace	= 2,
-	.aces = {
-		KEY_POSSESSOR_ACE(KEY_ACE_SEARCH | KEY_ACE_WRITE),
-		KEY_OWNER_ACE(KEY_ACE_VIEW | KEY_ACE_READ | KEY_ACE_WRITE | KEY_ACE_SEARCH),
-	}
-};
-
 struct key *ima_blacklist_keyring;
 
 /*
@@ -44,7 +35,9 @@ __init int ima_mok_init(void)
 
 	ima_blacklist_keyring = keyring_alloc(".ima_blacklist",
 				KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
-			        &integrity_blacklist_keyring_acl,
+				(KEY_POS_ALL & ~KEY_POS_SETATTR) |
+				KEY_USR_VIEW | KEY_USR_READ |
+				KEY_USR_WRITE | KEY_USR_SEARCH,
 				KEY_ALLOC_NOT_IN_QUOTA,
 				restriction, NULL);
 

commit 0f75ef6a9cff49ff612f7ce0578bced9d0b38325
Merge: c84ca912b079 7a1ade847596
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:56:57 2019 -0700

    Merge tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull keyring ACL support from David Howells:
     "This changes the permissions model used by keys and keyrings to be
      based on an internal ACL by the following means:
    
       - Replace the permissions mask internally with an ACL that contains a
         list of ACEs, each with a specific subject with a permissions mask.
         Potted default ACLs are available for new keys and keyrings.
    
         ACE subjects can be macroised to indicate the UID and GID specified
         on the key (which remain). Future commits will be able to add
         additional subject types, such as specific UIDs or domain
         tags/namespaces.
    
         Also split a number of permissions to give finer control. Examples
         include splitting the revocation permit from the change-attributes
         permit, thereby allowing someone to be granted permission to revoke
         a key without allowing them to change the owner; also the ability
         to join a keyring is split from the ability to link to it, thereby
         stopping a process accessing a keyring by joining it and thus
         acquiring use of possessor permits.
    
       - Provide a keyctl to allow the granting or denial of one or more
         permits to a specific subject. Direct access to the ACL is not
         granted, and the ACL cannot be viewed"
    
    * tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Provide KEYCTL_GRANT_PERMISSION
      keys: Replace uid/gid/perm permissions checking with an ACL

commit 2e12256b9a76584fa3a6da19210509d4775aee36
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 27 23:03:07 2019 +0100

    keys: Replace uid/gid/perm permissions checking with an ACL
    
    Replace the uid/gid/perm permissions checking on a key with an ACL to allow
    the SETATTR and SEARCH permissions to be split.  This will also allow a
    greater range of subjects to represented.
    
    ============
    WHY DO THIS?
    ============
    
    The problem is that SETATTR and SEARCH cover a slew of actions, not all of
    which should be grouped together.
    
    For SETATTR, this includes actions that are about controlling access to a
    key:
    
     (1) Changing a key's ownership.
    
     (2) Changing a key's security information.
    
     (3) Setting a keyring's restriction.
    
    And actions that are about managing a key's lifetime:
    
     (4) Setting an expiry time.
    
     (5) Revoking a key.
    
    and (proposed) managing a key as part of a cache:
    
     (6) Invalidating a key.
    
    Managing a key's lifetime doesn't really have anything to do with
    controlling access to that key.
    
    Expiry time is awkward since it's more about the lifetime of the content
    and so, in some ways goes better with WRITE permission.  It can, however,
    be set unconditionally by a process with an appropriate authorisation token
    for instantiating a key, and can also be set by the key type driver when a
    key is instantiated, so lumping it with the access-controlling actions is
    probably okay.
    
    As for SEARCH permission, that currently covers:
    
     (1) Finding keys in a keyring tree during a search.
    
     (2) Permitting keyrings to be joined.
    
     (3) Invalidation.
    
    But these don't really belong together either, since these actions really
    need to be controlled separately.
    
    Finally, there are number of special cases to do with granting the
    administrator special rights to invalidate or clear keys that I would like
    to handle with the ACL rather than key flags and special checks.
    
    
    ===============
    WHAT IS CHANGED
    ===============
    
    The SETATTR permission is split to create two new permissions:
    
     (1) SET_SECURITY - which allows the key's owner, group and ACL to be
         changed and a restriction to be placed on a keyring.
    
     (2) REVOKE - which allows a key to be revoked.
    
    The SEARCH permission is split to create:
    
     (1) SEARCH - which allows a keyring to be search and a key to be found.
    
     (2) JOIN - which allows a keyring to be joined as a session keyring.
    
     (3) INVAL - which allows a key to be invalidated.
    
    The WRITE permission is also split to create:
    
     (1) WRITE - which allows a key's content to be altered and links to be
         added, removed and replaced in a keyring.
    
     (2) CLEAR - which allows a keyring to be cleared completely.  This is
         split out to make it possible to give just this to an administrator.
    
     (3) REVOKE - see above.
    
    
    Keys acquire ACLs which consist of a series of ACEs, and all that apply are
    unioned together.  An ACE specifies a subject, such as:
    
     (*) Possessor - permitted to anyone who 'possesses' a key
     (*) Owner - permitted to the key owner
     (*) Group - permitted to the key group
     (*) Everyone - permitted to everyone
    
    Note that 'Other' has been replaced with 'Everyone' on the assumption that
    you wouldn't grant a permit to 'Other' that you wouldn't also grant to
    everyone else.
    
    Further subjects may be made available by later patches.
    
    The ACE also specifies a permissions mask.  The set of permissions is now:
    
            VIEW            Can view the key metadata
            READ            Can read the key content
            WRITE           Can update/modify the key content
            SEARCH          Can find the key by searching/requesting
            LINK            Can make a link to the key
            SET_SECURITY    Can change owner, ACL, expiry
            INVAL           Can invalidate
            REVOKE          Can revoke
            JOIN            Can join this keyring
            CLEAR           Can clear this keyring
    
    
    The KEYCTL_SETPERM function is then deprecated.
    
    The KEYCTL_SET_TIMEOUT function then is permitted if SET_SECURITY is set,
    or if the caller has a valid instantiation auth token.
    
    The KEYCTL_INVALIDATE function then requires INVAL.
    
    The KEYCTL_REVOKE function then requires REVOKE.
    
    The KEYCTL_JOIN_SESSION_KEYRING function then requires JOIN to join an
    existing keyring.
    
    The JOIN permission is enabled by default for session keyrings and manually
    created keyrings only.
    
    
    ======================
    BACKWARD COMPATIBILITY
    ======================
    
    To maintain backward compatibility, KEYCTL_SETPERM will translate the
    permissions mask it is given into a new ACL for a key - unless
    KEYCTL_SET_ACL has been called on that key, in which case an error will be
    returned.
    
    It will convert possessor, owner, group and other permissions into separate
    ACEs, if each portion of the mask is non-zero.
    
    SETATTR permission turns on all of INVAL, REVOKE and SET_SECURITY.  WRITE
    permission turns on WRITE, REVOKE and, if a keyring, CLEAR.  JOIN is turned
    on if a keyring is being altered.
    
    The KEYCTL_DESCRIBE function translates the ACL back into a permissions
    mask to return depending on possessor, owner, group and everyone ACEs.
    
    It will make the following mappings:
    
     (1) INVAL, JOIN -> SEARCH
    
     (2) SET_SECURITY -> SETATTR
    
     (3) REVOKE -> WRITE if SETATTR isn't already set
    
     (4) CLEAR -> WRITE
    
    Note that the value subsequently returned by KEYCTL_DESCRIBE may not match
    the value set with KEYCTL_SETATTR.
    
    
    =======
    TESTING
    =======
    
    This passes the keyutils testsuite for all but a couple of tests:
    
     (1) tests/keyctl/dh_compute/badargs: The first wrong-key-type test now
         returns EOPNOTSUPP rather than ENOKEY as READ permission isn't removed
         if the type doesn't have ->read().  You still can't actually read the
         key.
    
     (2) tests/keyctl/permitting/valid: The view-other-permissions test doesn't
         work as Other has been replaced with Everyone in the ACL.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index 073ddc9bce5b..ce48303cfacc 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -21,6 +21,15 @@
 #include <keys/system_keyring.h>
 
 
+static struct key_acl integrity_blacklist_keyring_acl = {
+	.usage	= REFCOUNT_INIT(1),
+	.nr_ace	= 2,
+	.aces = {
+		KEY_POSSESSOR_ACE(KEY_ACE_SEARCH | KEY_ACE_WRITE),
+		KEY_OWNER_ACE(KEY_ACE_VIEW | KEY_ACE_READ | KEY_ACE_WRITE | KEY_ACE_SEARCH),
+	}
+};
+
 struct key *ima_blacklist_keyring;
 
 /*
@@ -40,9 +49,7 @@ __init int ima_mok_init(void)
 
 	ima_blacklist_keyring = keyring_alloc(".ima_blacklist",
 				KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
-				(KEY_POS_ALL & ~KEY_POS_SETATTR) |
-				KEY_USR_VIEW | KEY_USR_READ |
-				KEY_USR_WRITE | KEY_USR_SEARCH,
+			        &integrity_blacklist_keyring_acl,
 				KEY_ALLOC_NOT_IN_QUOTA,
 				restriction, NULL);
 

commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index 073ddc9bce5b..36cadadbfba4 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -1,14 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2015 Juniper Networks, Inc.
  *
  * Author:
  * Petko Manolov <petko.manolov@konsulko.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation, version 2 of the
- * License.
- *
  */
 
 #include <linux/export.h>

commit 2b6aa412ff23a02ac777ad307249c60a839cfd25
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Wed Aug 31 16:05:43 2016 -0700

    KEYS: Use structure to capture key restriction function and data
    
    Replace struct key's restrict_link function pointer with a pointer to
    the new struct key_restriction. The structure contains pointers to the
    restriction function as well as relevant data for evaluating the
    restriction.
    
    The garbage collector checks restrict_link->keytype when key types are
    unregistered. Restrictions involving a removed key type are converted
    to use restrict_link_reject so that restrictions cannot be removed by
    unregistering key types.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index 74a279957464..073ddc9bce5b 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -17,6 +17,7 @@
 #include <linux/cred.h>
 #include <linux/err.h>
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <keys/system_keyring.h>
 
 
@@ -27,15 +28,23 @@ struct key *ima_blacklist_keyring;
  */
 __init int ima_mok_init(void)
 {
+	struct key_restriction *restriction;
+
 	pr_notice("Allocating IMA blacklist keyring.\n");
 
+	restriction = kzalloc(sizeof(struct key_restriction), GFP_KERNEL);
+	if (!restriction)
+		panic("Can't allocate IMA blacklist restriction.");
+
+	restriction->check = restrict_link_by_builtin_trusted;
+
 	ima_blacklist_keyring = keyring_alloc(".ima_blacklist",
 				KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
 				(KEY_POS_ALL & ~KEY_POS_SETATTR) |
 				KEY_USR_VIEW | KEY_USR_READ |
 				KEY_USR_WRITE | KEY_USR_SEARCH,
 				KEY_ALLOC_NOT_IN_QUOTA,
-				restrict_link_by_builtin_trusted, NULL);
+				restriction, NULL);
 
 	if (IS_ERR(ima_blacklist_keyring))
 		panic("Can't allocate IMA blacklist keyring.");

commit 56104cf2b8d20eed32c14eac8ac574c35377ab38
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 7 09:45:23 2016 +0100

    IMA: Use the the system trusted keyrings instead of .ima_mok
    
    Add a config option (IMA_KEYRINGS_PERMIT_SIGNED_BY_BUILTIN_OR_SECONDARY)
    that, when enabled, allows keys to be added to the IMA keyrings by
    userspace - with the restriction that each must be signed by a key in the
    system trusted keyrings.
    
    EPERM will be returned if this option is disabled, ENOKEY will be returned if
    no authoritative key can be found and EKEYREJECTED will be returned if the
    signature doesn't match.  Other errors such as ENOPKG may also be returned.
    
    If this new option is enabled, the builtin system keyring is searched, as is
    the secondary system keyring if that is also enabled.  Intermediate keys
    between the builtin system keyring and the key being added can be added to
    the secondary keyring (which replaces .ima_mok) to form a trust chain -
    provided they are also validly signed by a key in one of the trusted keyrings.
    
    The .ima_mok keyring is then removed and the IMA blacklist keyring gets its
    own config option (IMA_BLACKLIST_KEYRING).
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index 2988726d30d6..74a279957464 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -20,23 +20,14 @@
 #include <keys/system_keyring.h>
 
 
-struct key *ima_mok_keyring;
 struct key *ima_blacklist_keyring;
 
 /*
- * Allocate the IMA MOK and blacklist keyrings
+ * Allocate the IMA blacklist keyring
  */
 __init int ima_mok_init(void)
 {
-	pr_notice("Allocating IMA MOK and blacklist keyrings.\n");
-
-	ima_mok_keyring = keyring_alloc(".ima_mok",
-			      KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
-			      (KEY_POS_ALL & ~KEY_POS_SETATTR) |
-			      KEY_USR_VIEW | KEY_USR_READ |
-			      KEY_USR_WRITE | KEY_USR_SEARCH,
-			      KEY_ALLOC_NOT_IN_QUOTA,
-			      restrict_link_by_builtin_trusted, NULL);
+	pr_notice("Allocating IMA blacklist keyring.\n");
 
 	ima_blacklist_keyring = keyring_alloc(".ima_blacklist",
 				KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
@@ -46,8 +37,8 @@ __init int ima_mok_init(void)
 				KEY_ALLOC_NOT_IN_QUOTA,
 				restrict_link_by_builtin_trusted, NULL);
 
-	if (IS_ERR(ima_mok_keyring) || IS_ERR(ima_blacklist_keyring))
-		panic("Can't allocate IMA MOK or blacklist keyrings.");
+	if (IS_ERR(ima_blacklist_keyring))
+		panic("Can't allocate IMA blacklist keyring.");
 
 	set_bit(KEY_FLAG_KEEP, &ima_blacklist_keyring->flags);
 	return 0;

commit a511e1af8b12f44c6e55786c463c9f093c214fb6
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:26 2016 +0100

    KEYS: Move the point of trust determination to __key_link()
    
    Move the point at which a key is determined to be trustworthy to
    __key_link() so that we use the contents of the keyring being linked in to
    to determine whether the key being linked in is trusted or not.
    
    What is 'trusted' then becomes a matter of what's in the keyring.
    
    Currently, the test is done when the key is parsed, but given that at that
    point we can only sensibly refer to the contents of the system trusted
    keyring, we can only use that as the basis for working out the
    trustworthiness of a new key.
    
    With this change, a trusted keyring is a set of keys that once the
    trusted-only flag is set cannot be added to except by verification through
    one of the contained keys.
    
    Further, adding a key into a trusted keyring, whilst it might grant
    trustworthiness in the context of that keyring, does not automatically
    grant trustworthiness in the context of a second keyring to which it could
    be secondarily linked.
    
    To accomplish this, the authentication data associated with the key source
    must now be retained.  For an X.509 cert, this means the contents of the
    AuthorityKeyIdentifier and the signature data.
    
    
    If system keyrings are disabled then restrict_link_by_builtin_trusted()
    resolves to restrict_link_reject().  The integrity digital signature code
    still works correctly with this as it was previously using
    KEY_FLAG_TRUSTED_ONLY, which doesn't permit anything to be added if there
    is no system keyring against which trust can be determined.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index ef91248cb934..2988726d30d6 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -17,7 +17,7 @@
 #include <linux/cred.h>
 #include <linux/err.h>
 #include <linux/init.h>
-#include <keys/asymmetric-type.h>
+#include <keys/system_keyring.h>
 
 
 struct key *ima_mok_keyring;
@@ -36,7 +36,7 @@ __init int ima_mok_init(void)
 			      KEY_USR_VIEW | KEY_USR_READ |
 			      KEY_USR_WRITE | KEY_USR_SEARCH,
 			      KEY_ALLOC_NOT_IN_QUOTA,
-			      keyring_restrict_trusted_only, NULL);
+			      restrict_link_by_builtin_trusted, NULL);
 
 	ima_blacklist_keyring = keyring_alloc(".ima_blacklist",
 				KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
@@ -44,7 +44,7 @@ __init int ima_mok_init(void)
 				KEY_USR_VIEW | KEY_USR_READ |
 				KEY_USR_WRITE | KEY_USR_SEARCH,
 				KEY_ALLOC_NOT_IN_QUOTA,
-				keyring_restrict_trusted_only, NULL);
+				restrict_link_by_builtin_trusted, NULL);
 
 	if (IS_ERR(ima_mok_keyring) || IS_ERR(ima_blacklist_keyring))
 		panic("Can't allocate IMA MOK or blacklist keyrings.");

commit 5ac7eace2d00eab5ae0e9fdee63e38aee6001f7c
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:24 2016 +0100

    KEYS: Add a facility to restrict new links into a keyring
    
    Add a facility whereby proposed new links to be added to a keyring can be
    vetted, permitting them to be rejected if necessary.  This can be used to
    block public keys from which the signature cannot be verified or for which
    the signature verification fails.  It could also be used to provide
    blacklisting.
    
    This affects operations like add_key(), KEYCTL_LINK and KEYCTL_INSTANTIATE.
    
    To this end:
    
     (1) A function pointer is added to the key struct that, if set, points to
         the vetting function.  This is called as:
    
            int (*restrict_link)(struct key *keyring,
                                 const struct key_type *key_type,
                                 unsigned long key_flags,
                                 const union key_payload *key_payload),
    
         where 'keyring' will be the keyring being added to, key_type and
         key_payload will describe the key being added and key_flags[*] can be
         AND'ed with KEY_FLAG_TRUSTED.
    
         [*] This parameter will be removed in a later patch when
             KEY_FLAG_TRUSTED is removed.
    
         The function should return 0 to allow the link to take place or an
         error (typically -ENOKEY, -ENOPKG or -EKEYREJECTED) to reject the
         link.
    
         The pointer should not be set directly, but rather should be set
         through keyring_alloc().
    
         Note that if called during add_key(), preparse is called before this
         method, but a key isn't actually allocated until after this function
         is called.
    
     (2) KEY_ALLOC_BYPASS_RESTRICTION is added.  This can be passed to
         key_create_or_update() or key_instantiate_and_link() to bypass the
         restriction check.
    
     (3) KEY_FLAG_TRUSTED_ONLY is removed.  The entire contents of a keyring
         with this restriction emplaced can be considered 'trustworthy' by
         virtue of being in the keyring when that keyring is consulted.
    
     (4) key_alloc() and keyring_alloc() take an extra argument that will be
         used to set restrict_link in the new key.  This ensures that the
         pointer is set before the key is published, thus preventing a window
         of unrestrictedness.  Normally this argument will be NULL.
    
     (5) As a temporary affair, keyring_restrict_trusted_only() is added.  It
         should be passed to keyring_alloc() as the extra argument instead of
         setting KEY_FLAG_TRUSTED_ONLY on a keyring.  This will be replaced in
         a later patch with functions that look in the appropriate places for
         authoritative keys.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index 676885e4320e..ef91248cb934 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -35,20 +35,20 @@ __init int ima_mok_init(void)
 			      (KEY_POS_ALL & ~KEY_POS_SETATTR) |
 			      KEY_USR_VIEW | KEY_USR_READ |
 			      KEY_USR_WRITE | KEY_USR_SEARCH,
-			      KEY_ALLOC_NOT_IN_QUOTA, NULL);
+			      KEY_ALLOC_NOT_IN_QUOTA,
+			      keyring_restrict_trusted_only, NULL);
 
 	ima_blacklist_keyring = keyring_alloc(".ima_blacklist",
 				KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
 				(KEY_POS_ALL & ~KEY_POS_SETATTR) |
 				KEY_USR_VIEW | KEY_USR_READ |
 				KEY_USR_WRITE | KEY_USR_SEARCH,
-				KEY_ALLOC_NOT_IN_QUOTA, NULL);
+				KEY_ALLOC_NOT_IN_QUOTA,
+				keyring_restrict_trusted_only, NULL);
 
 	if (IS_ERR(ima_mok_keyring) || IS_ERR(ima_blacklist_keyring))
 		panic("Can't allocate IMA MOK or blacklist keyrings.");
-	set_bit(KEY_FLAG_TRUSTED_ONLY, &ima_mok_keyring->flags);
 
-	set_bit(KEY_FLAG_TRUSTED_ONLY, &ima_blacklist_keyring->flags);
 	set_bit(KEY_FLAG_KEEP, &ima_blacklist_keyring->flags);
 	return 0;
 }

commit 92cc916638a48f285736cd5541536e2e1b73ecf8
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Dec 9 17:37:16 2015 -0500

    security/integrity: make ima/ima_mok.c explicitly non-modular
    
    The Kconfig currently controlling compilation of this code is:
    
    ima/Kconfig:config IMA_MOK_KEYRING
    ima/Kconfig: bool "Create IMA machine owner keys (MOK) and blacklist keyrings"
    
    ...meaning that it currently is not being built as a module by anyone.
    
    Lets remove the couple of traces of modularity so that when reading the
    driver there is no doubt it really is builtin-only.
    
    Since module_init translates to device_initcall in the non-modular
    case, the init ordering remains unchanged with this commit.
    
    Cc: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>
    Cc: James Morris <james.l.morris@oracle.com>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: linux-ima-devel@lists.sourceforge.net
    Cc: linux-ima-user@lists.sourceforge.net
    Cc: linux-security-module@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index 8dad9a2b8e47..676885e4320e 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -16,7 +16,7 @@
 #include <linux/sched.h>
 #include <linux/cred.h>
 #include <linux/err.h>
-#include <linux/module.h>
+#include <linux/init.h>
 #include <keys/asymmetric-type.h>
 
 
@@ -52,5 +52,4 @@ __init int ima_mok_init(void)
 	set_bit(KEY_FLAG_KEEP, &ima_blacklist_keyring->flags);
 	return 0;
 }
-
-module_init(ima_mok_init);
+device_initcall(ima_mok_init);

commit 501f1bde66525f94403a5b78832a9218ef9b1c14
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Nov 10 09:00:38 2015 -0500

    IMA: prevent keys on the .ima_blacklist from being removed
    
    Set the KEY_FLAGS_KEEP on the .ima_blacklist to prevent userspace
    from removing keys from the keyring.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
index 18e37f57f512..8dad9a2b8e47 100644
--- a/security/integrity/ima/ima_mok.c
+++ b/security/integrity/ima/ima_mok.c
@@ -47,7 +47,9 @@ __init int ima_mok_init(void)
 	if (IS_ERR(ima_mok_keyring) || IS_ERR(ima_blacklist_keyring))
 		panic("Can't allocate IMA MOK or blacklist keyrings.");
 	set_bit(KEY_FLAG_TRUSTED_ONLY, &ima_mok_keyring->flags);
+
 	set_bit(KEY_FLAG_TRUSTED_ONLY, &ima_blacklist_keyring->flags);
+	set_bit(KEY_FLAG_KEEP, &ima_blacklist_keyring->flags);
 	return 0;
 }
 

commit 41c89b64d7184a780f12f2cccdabe65cb2408893
Author: Petko Manolov <petkan@mip-labs.com>
Date:   Wed Dec 2 17:47:55 2015 +0200

    IMA: create machine owner and blacklist keyrings
    
    This option creates IMA MOK and blacklist keyrings.  IMA MOK is an
    intermediate keyring that sits between .system and .ima keyrings,
    effectively forming a simple CA hierarchy.  To successfully import a key
    into .ima_mok it must be signed by a key which CA is in .system keyring.
    On turn any key that needs to go in .ima keyring must be signed by CA in
    either .system or .ima_mok keyrings. IMA MOK is empty at kernel boot.
    
    IMA blacklist keyring contains all revoked IMA keys.  It is consulted
    before any other keyring.  If the search is successful the requested
    operation is rejected and error is returned to the caller.
    
    Signed-off-by: Petko Manolov <petkan@mip-labs.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/integrity/ima/ima_mok.c b/security/integrity/ima/ima_mok.c
new file mode 100644
index 000000000000..18e37f57f512
--- /dev/null
+++ b/security/integrity/ima/ima_mok.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Juniper Networks, Inc.
+ *
+ * Author:
+ * Petko Manolov <petko.manolov@konsulko.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ */
+
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cred.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <keys/asymmetric-type.h>
+
+
+struct key *ima_mok_keyring;
+struct key *ima_blacklist_keyring;
+
+/*
+ * Allocate the IMA MOK and blacklist keyrings
+ */
+__init int ima_mok_init(void)
+{
+	pr_notice("Allocating IMA MOK and blacklist keyrings.\n");
+
+	ima_mok_keyring = keyring_alloc(".ima_mok",
+			      KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
+			      (KEY_POS_ALL & ~KEY_POS_SETATTR) |
+			      KEY_USR_VIEW | KEY_USR_READ |
+			      KEY_USR_WRITE | KEY_USR_SEARCH,
+			      KEY_ALLOC_NOT_IN_QUOTA, NULL);
+
+	ima_blacklist_keyring = keyring_alloc(".ima_blacklist",
+				KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),
+				(KEY_POS_ALL & ~KEY_POS_SETATTR) |
+				KEY_USR_VIEW | KEY_USR_READ |
+				KEY_USR_WRITE | KEY_USR_SEARCH,
+				KEY_ALLOC_NOT_IN_QUOTA, NULL);
+
+	if (IS_ERR(ima_mok_keyring) || IS_ERR(ima_blacklist_keyring))
+		panic("Can't allocate IMA MOK or blacklist keyrings.");
+	set_bit(KEY_FLAG_TRUSTED_ONLY, &ima_mok_keyring->flags);
+	set_bit(KEY_FLAG_TRUSTED_ONLY, &ima_blacklist_keyring->flags);
+	return 0;
+}
+
+module_init(ima_mok_init);
