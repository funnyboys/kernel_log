commit 23e390cdbe6f85827a43d38f9288dcd3066fa376
Author: KP Singh <kpsingh@google.com>
Date:   Mon Jun 22 00:21:35 2020 +0200

    security: Fix hook iteration and default value for inode_copy_up_xattr
    
    inode_copy_up_xattr returns 0 to indicate the acceptance of the xattr
    and 1 to reject it. If the LSM does not know about the xattr, it's
    expected to return -EOPNOTSUPP, which is the correct default value for
    this hook. BPF LSM, currently, uses 0 as the default value and thereby
    falsely allows all overlay fs xattributes to be copied up.
    
    The iteration logic is also updated from the "bail-on-fail"
    call_int_hook to continue on the non-decisive -EOPNOTSUPP and bail out
    on other values.
    
    Fixes: 98e828a0650f ("security: Refactor declaration of LSM hooks")
    Signed-off-by: KP Singh <kpsingh@google.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 0ce3e73edd42..70a7ad357bc6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1414,7 +1414,22 @@ EXPORT_SYMBOL(security_inode_copy_up);
 
 int security_inode_copy_up_xattr(const char *name)
 {
-	return call_int_hook(inode_copy_up_xattr, -EOPNOTSUPP, name);
+	struct security_hook_list *hp;
+	int rc;
+
+	/*
+	 * The implementation can return 0 (accept the xattr), 1 (discard the
+	 * xattr), -EOPNOTSUPP if it does not know anything about the xattr or
+	 * any other error code incase of an error.
+	 */
+	hlist_for_each_entry(hp,
+		&security_hook_heads.inode_copy_up_xattr, list) {
+		rc = hp->hook.inode_copy_up_xattr(name);
+		if (rc != LSM_RET_DEFAULT(inode_copy_up_xattr))
+			return rc;
+	}
+
+	return LSM_RET_DEFAULT(inode_copy_up_xattr);
 }
 EXPORT_SYMBOL(security_inode_copy_up_xattr);
 

commit 4a87b197c1da6b16608d5110709e0b3308e25dcd
Merge: 9d645db853a4 39030e1351aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 14 11:39:31 2020 -0700

    Merge tag 'LSM-add-setgid-hook-5.8-author-fix' of git://github.com/micah-morton/linux
    
    Pull SafeSetID update from Micah Morton:
     "Add additional LSM hooks for SafeSetID
    
      SafeSetID is capable of making allow/deny decisions for set*uid calls
      on a system, and we want to add similar functionality for set*gid
      calls.
    
      The work to do that is not yet complete, so probably won't make it in
      for v5.8, but we are looking to get this simple patch in for v5.8
      since we have it ready.
    
      We are planning on the rest of the work for extending the SafeSetID
      LSM being merged during the v5.9 merge window"
    
    * tag 'LSM-add-setgid-hook-5.8-author-fix' of git://github.com/micah-morton/linux:
      security: Add LSM hooks to set*gid syscalls

commit 39030e1351aa1aa7443bb2da24426573077c83da
Author: Thomas Cedeno <thomascedeno@google.com>
Date:   Tue Jun 9 10:22:13 2020 -0700

    security: Add LSM hooks to set*gid syscalls
    
    The SafeSetID LSM uses the security_task_fix_setuid hook to filter
    set*uid() syscalls according to its configured security policy. In
    preparation for adding analagous support in the LSM for set*gid()
    syscalls, we add the requisite hook here. Tested by putting print
    statements in the security_task_fix_setgid hook and seeing them get hit
    during kernel boot.
    
    Signed-off-by: Thomas Cedeno <thomascedeno@google.com>
    Signed-off-by: Micah Morton <mortonm@chromium.org>

diff --git a/security/security.c b/security/security.c
index 51de970fbb1e..5d4ad6f3fc55 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1685,6 +1685,12 @@ int security_task_fix_setuid(struct cred *new, const struct cred *old,
 	return call_int_hook(task_fix_setuid, 0, new, old, flags);
 }
 
+int security_task_fix_setgid(struct cred *new, const struct cred *old,
+				 int flags)
+{
+	return call_int_hook(task_fix_setgid, 0, new, old, flags);
+}
+
 int security_task_setpgid(struct task_struct *p, pid_t pgid)
 {
 	return call_int_hook(task_setpgid, 0, p, pgid);

commit 6c3297841472b4e53e22e53826eea9e483d993e5
Merge: df2fbf5bfa0e a8478a602913
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 13 09:56:21 2020 -0700

    Merge tag 'notifications-20200601' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull notification queue from David Howells:
     "This adds a general notification queue concept and adds an event
      source for keys/keyrings, such as linking and unlinking keys and
      changing their attributes.
    
      Thanks to Debarshi Ray, we do have a pull request to use this to fix a
      problem with gnome-online-accounts - as mentioned last time:
    
         https://gitlab.gnome.org/GNOME/gnome-online-accounts/merge_requests/47
    
      Without this, g-o-a has to constantly poll a keyring-based kerberos
      cache to find out if kinit has changed anything.
    
      [ There are other notification pending: mount/sb fsinfo notifications
        for libmount that Karel Zak and Ian Kent have been working on, and
        Christian Brauner would like to use them in lxc, but let's see how
        this one works first ]
    
      LSM hooks are included:
    
       - A set of hooks are provided that allow an LSM to rule on whether or
         not a watch may be set. Each of these hooks takes a different
         "watched object" parameter, so they're not really shareable. The
         LSM should use current's credentials. [Wanted by SELinux & Smack]
    
       - A hook is provided to allow an LSM to rule on whether or not a
         particular message may be posted to a particular queue. This is
         given the credentials from the event generator (which may be the
         system) and the watch setter. [Wanted by Smack]
    
      I've provided SELinux and Smack with implementations of some of these
      hooks.
    
      WHY
      ===
    
      Key/keyring notifications are desirable because if you have your
      kerberos tickets in a file/directory, your Gnome desktop will monitor
      that using something like fanotify and tell you if your credentials
      cache changes.
    
      However, we also have the ability to cache your kerberos tickets in
      the session, user or persistent keyring so that it isn't left around
      on disk across a reboot or logout. Keyrings, however, cannot currently
      be monitored asynchronously, so the desktop has to poll for it - not
      so good on a laptop. This facility will allow the desktop to avoid the
      need to poll.
    
      DESIGN DECISIONS
      ================
    
       - The notification queue is built on top of a standard pipe. Messages
         are effectively spliced in. The pipe is opened with a special flag:
    
            pipe2(fds, O_NOTIFICATION_PIPE);
    
         The special flag has the same value as O_EXCL (which doesn't seem
         like it will ever be applicable in this context)[?]. It is given up
         front to make it a lot easier to prohibit splice&co from accessing
         the pipe.
    
         [?] Should this be done some other way?  I'd rather not use up a new
             O_* flag if I can avoid it - should I add a pipe3() system call
             instead?
    
         The pipe is then configured::
    
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_SIZE, queue_depth);
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_FILTER, &filter);
    
         Messages are then read out of the pipe using read().
    
       - It should be possible to allow write() to insert data into the
         notification pipes too, but this is currently disabled as the
         kernel has to be able to insert messages into the pipe *without*
         holding pipe->mutex and the code to make this work needs careful
         auditing.
    
       - sendfile(), splice() and vmsplice() are disabled on notification
         pipes because of the pipe->mutex issue and also because they
         sometimes want to revert what they just did - but one or more
         notification messages might've been interleaved in the ring.
    
       - The kernel inserts messages with the wait queue spinlock held. This
         means that pipe_read() and pipe_write() have to take the spinlock
         to update the queue pointers.
    
       - Records in the buffer are binary, typed and have a length so that
         they can be of varying size.
    
         This allows multiple heterogeneous sources to share a common
         buffer; there are 16 million types available, of which I've used
         just a few, so there is scope for others to be used. Tags may be
         specified when a watchpoint is created to help distinguish the
         sources.
    
       - Records are filterable as types have up to 256 subtypes that can be
         individually filtered. Other filtration is also available.
    
       - Notification pipes don't interfere with each other; each may be
         bound to a different set of watches. Any particular notification
         will be copied to all the queues that are currently watching for it
         - and only those that are watching for it.
    
       - When recording a notification, the kernel will not sleep, but will
         rather mark a queue as having lost a message if there's
         insufficient space. read() will fabricate a loss notification
         message at an appropriate point later.
    
       - The notification pipe is created and then watchpoints are attached
         to it, using one of:
    
            keyctl_watch_key(KEY_SPEC_SESSION_KEYRING, fds[1], 0x01);
            watch_mount(AT_FDCWD, "/", 0, fd, 0x02);
            watch_sb(AT_FDCWD, "/mnt", 0, fd, 0x03);
    
         where in both cases, fd indicates the queue and the number after is
         a tag between 0 and 255.
    
       - Watches are removed if either the notification pipe is destroyed or
         the watched object is destroyed. In the latter case, a message will
         be generated indicating the enforced watch removal.
    
      Things I want to avoid:
    
       - Introducing features that make the core VFS dependent on the
         network stack or networking namespaces (ie. usage of netlink).
    
       - Dumping all this stuff into dmesg and having a daemon that sits
         there parsing the output and distributing it as this then puts the
         responsibility for security into userspace and makes handling
         namespaces tricky. Further, dmesg might not exist or might be
         inaccessible inside a container.
    
       - Letting users see events they shouldn't be able to see.
    
      TESTING AND MANPAGES
      ====================
    
       - The keyutils tree has a pipe-watch branch that has keyctl commands
         for making use of notifications. Proposed manual pages can also be
         found on this branch, though a couple of them really need to go to
         the main manpages repository instead.
    
         If the kernel supports the watching of keys, then running "make
         test" on that branch will cause the testing infrastructure to spawn
         a monitoring process on the side that monitors a notifications pipe
         for all the key/keyring changes induced by the tests and they'll
         all be checked off to make sure they happened.
    
            https://git.kernel.org/pub/scm/linux/kernel/git/dhowells/keyutils.git/log/?h=pipe-watch
    
       - A test program is provided (samples/watch_queue/watch_test) that
         can be used to monitor for keyrings, mount and superblock events.
         Information on the notifications is simply logged to stdout"
    
    * tag 'notifications-20200601' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      smack: Implement the watch_key and post_notification hooks
      selinux: Implement the watch_key security hook
      keys: Make the KEY_NEED_* perms an enum rather than a mask
      pipe: Add notification lossage handling
      pipe: Allow buffers to be marked read-whole-or-error for notifications
      Add sample notification program
      watch_queue: Add a key/keyring notification facility
      security: Add hooks to rule on setting a watch
      pipe: Add general notification queue support
      pipe: Add O_NOTIFICATION_PIPE
      security: Add a hook for the point of notification insertion
      uapi: General notification queue definitions

commit 52435c86bf0f5c892804912481af7f1a5b95ff2d
Merge: 4964dd29140a 2068cf7dfbc6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 9 15:40:50 2020 -0700

    Merge tag 'ovl-update-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "Fixes:
    
       - Resolve mount option conflicts consistently
    
       - Sync before remount R/O
    
       - Fix file handle encoding corner cases
    
       - Fix metacopy related issues
    
       - Fix an unintialized return value
    
       - Add missing permission checks for underlying layers
    
      Optimizations:
    
       - Allow multipe whiteouts to share an inode
    
       - Optimize small writes by inheriting SB_NOSEC from upper layer
    
       - Do not call ->syncfs() multiple times for sync(2)
    
       - Do not cache negative lookups on upper layer
    
       - Make private internal mounts longterm"
    
    * tag 'ovl-update-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs: (27 commits)
      ovl: remove unnecessary lock check
      ovl: make oip->index bool
      ovl: only pass ->ki_flags to ovl_iocb_to_rwf()
      ovl: make private mounts longterm
      ovl: get rid of redundant members in struct ovl_fs
      ovl: add accessor for ofs->upper_mnt
      ovl: initialize error in ovl_copy_xattr
      ovl: drop negative dentry in upper layer
      ovl: check permission to open real file
      ovl: call secutiry hook in ovl_real_ioctl()
      ovl: verify permissions in ovl_path_open()
      ovl: switch to mounter creds in readdir
      ovl: pass correct flags for opening real directory
      ovl: fix redirect traversal on metacopy dentries
      ovl: initialize OVL_UPPERDATA in ovl_lookup()
      ovl: use only uppermetacopy state in ovl_lookup()
      ovl: simplify setting of origin for index lookup
      ovl: fix out of bounds access warning in ovl_check_fb_len()
      ovl: return required buffer size for file handles
      ovl: sync dirty data when remounting to ro mode
      ...

commit 3c0ad98c2eda5ff30d23777e30744be6f7b8f097
Merge: aaa2faab4ed8 42413b49804b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 6 09:39:05 2020 -0700

    Merge tag 'integrity-v5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity
    
    Pull integrity updates from Mimi Zohar:
     "The main changes are extending the TPM 2.0 PCR banks with bank
      specific file hashes, calculating the "boot_aggregate" based on other
      TPM PCR banks, using the default IMA hash algorithm, instead of SHA1,
      as the basis for the cache hash table key, and preventing the mprotect
      syscall to circumvent an IMA mmap appraise policy rule.
    
       - In preparation for extending TPM 2.0 PCR banks with bank specific
         digests, commit 0b6cf6b97b7e ("tpm: pass an array of
         tpm_extend_digest structures to tpm_pcr_extend()") modified
         tpm_pcr_extend(). The original SHA1 file digests were
         padded/truncated, before being extended into the other TPM PCR
         banks. This pull request calculates and extends the TPM PCR banks
         with bank specific file hashes completing the above change.
    
       - The "boot_aggregate", the first IMA measurement list record, is the
         "trusted boot" link between the pre-boot environment and the
         running OS. With TPM 2.0, the "boot_aggregate" record is not
         limited to being based on the SHA1 TPM PCR bank, but can be
         calculated based on any enabled bank, assuming the hash algorithm
         is also enabled in the kernel.
    
      Other changes include the following and five other bug fixes/code
      clean up:
    
       - supporting both a SHA1 and a larger "boot_aggregate" digest in a
         custom template format containing both the the SHA1 ('d') and
         larger digests ('d-ng') fields.
    
       - Initial hash table key fix, but additional changes would be good"
    
    * tag 'integrity-v5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity:
      ima: Directly free *entry in ima_alloc_init_template() if digests is NULL
      ima: Call ima_calc_boot_aggregate() in ima_eventdigest_init()
      ima: Directly assign the ima_default_policy pointer to ima_rules
      ima: verify mprotect change is consistent with mmap policy
      evm: Fix possible memory leak in evm_calc_hmac_or_hash()
      ima: Set again build_ima_appraise variable
      ima: Remove redundant policy rule set in add_rules()
      ima: Fix ima digest hash table key calculation
      ima: Use ima_hash_algo for collision detection in the measurement list
      ima: Calculate and extend PCR with digests in ima_template_entry
      ima: Allocate and initialize tfm for each PCR bank
      ima: Switch to dynamically allocated buffer for template digests
      ima: Store template digest directly in ima_template_entry
      ima: Evaluate error in init_ima()
      ima: Switch to ima_hash_algo for boot aggregate

commit 15a2bc4dbb9cfed1c661a657fcb10798150b7598
Merge: 9ff7258575d5 3977e285ee89
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 4 14:07:08 2020 -0700

    Merge branch 'exec-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull execve updates from Eric Biederman:
     "Last cycle for the Nth time I ran into bugs and quality of
      implementation issues related to exec that could not be easily be
      fixed because of the way exec is implemented. So I have been digging
      into exec and cleanup up what I can.
    
      I don't think I have exec sorted out enough to fix the issues I
      started with but I have made some headway this cycle with 4 sets of
      changes.
    
       - promised cleanups after introducing exec_update_mutex
    
       - trivial cleanups for exec
    
       - control flow simplifications
    
       - remove the recomputation of bprm->cred
    
      The net result is code that is a bit easier to understand and work
      with and a decrease in the number of lines of code (if you don't count
      the added tests)"
    
    * 'exec-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (24 commits)
      exec: Compute file based creds only once
      exec: Add a per bprm->file version of per_clear
      binfmt_elf_fdpic: fix execfd build regression
      selftests/exec: Add binfmt_script regression test
      exec: Remove recursion from search_binary_handler
      exec: Generic execfd support
      exec/binfmt_script: Don't modify bprm->buf and then return -ENOEXEC
      exec: Move the call of prepare_binprm into search_binary_handler
      exec: Allow load_misc_binary to call prepare_binprm unconditionally
      exec: Convert security_bprm_set_creds into security_bprm_repopulate_creds
      exec: Factor security_bprm_creds_for_exec out of security_bprm_set_creds
      exec: Teach prepare_exec_creds how exec treats uids & gids
      exec: Set the point of no return sooner
      exec: Move handling of the point of no return to the top level
      exec: Run sync_mm_rss before taking exec_update_mutex
      exec: Fix spelling of search_binary_handler in a comment
      exec: Move the comment from above de_thread to above unshare_sighand
      exec: Rename flush_old_exec begin_new_exec
      exec: Move most of setup_new_exec into flush_old_exec
      exec: In setup_new_exec cache current in the local variable me
      ...

commit 292f902a40c11f043a5ca1305a114da0e523eaa3
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Jun 2 22:20:26 2020 +0200

    ovl: call secutiry hook in ovl_real_ioctl()
    
    Verify LSM permissions for underlying file, since vfs_ioctl() doesn't do
    it.
    
    [Stephen Rothwell] export security_file_ioctl
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/security/security.c b/security/security.c
index 7fed24b9d57e..a67414105130 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1459,6 +1459,7 @@ int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	return call_int_hook(file_ioctl, 0, file, cmd, arg);
 }
+EXPORT_SYMBOL_GPL(security_file_ioctl);
 
 static inline unsigned long mmap_prot(struct file *file, unsigned long prot)
 {

commit 56305aa9b6fab91a5555a45796b79c1b0a6353d1
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri May 29 22:00:54 2020 -0500

    exec: Compute file based creds only once
    
    Move the computation of creds from prepare_binfmt into begin_new_exec
    so that the creds need only be computed once.  This is just code
    reorganization no semantic changes of any kind are made.
    
    Moving the computation is safe.  I have looked through the kernel and
    verified none of the binfmts look at bprm->cred directly, and that
    there are no helpers that look at bprm->cred indirectly.  Which means
    that it is not a problem to compute the bprm->cred later in the
    execution flow as it is not used until it becomes current->cred.
    
    A new function bprm_creds_from_file is added to contain the work that
    needs to be done.  bprm_creds_from_file first computes which file
    bprm->executable or most likely bprm->file that the bprm->creds
    will be computed from.
    
    The funciton bprm_fill_uid is updated to receive the file instead of
    accessing bprm->file.  The now unnecessary work needed to reset the
    bprm->cred->euid, and bprm->cred->egid is removed from brpm_fill_uid.
    A small comment to document that bprm_fill_uid now only deals with the
    work to handle suid and sgid files.  The default case is already
    heandled by prepare_exec_creds.
    
    The function security_bprm_repopulate_creds is renamed
    security_bprm_creds_from_file and now is explicitly passed the file
    from which to compute the creds.  The documentation of the
    bprm_creds_from_file security hook is updated to explain when the hook
    is called and what it needs to do.  The file is passed from
    cap_bprm_creds_from_file into get_file_caps so that the caps are
    computed for the appropriate file.  The now unnecessary work in
    cap_bprm_creds_from_file to reset the ambient capabilites has been
    removed.  A small comment to document that the work of
    cap_bprm_creds_from_file is to read capabilities from the files
    secureity attribute and derive capabilities from the fact the
    user had uid 0 has been added.
    
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index b890b7e2a765..259b8e750aa2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -828,9 +828,9 @@ int security_bprm_creds_for_exec(struct linux_binprm *bprm)
 	return call_int_hook(bprm_creds_for_exec, 0, bprm);
 }
 
-int security_bprm_repopulate_creds(struct linux_binprm *bprm)
+int security_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file)
 {
-	return call_int_hook(bprm_repopulate_creds, 0, bprm);
+	return call_int_hook(bprm_creds_from_file, 0, bprm, file);
 }
 
 int security_bprm_check(struct linux_binprm *bprm)

commit 8eb613c0b8f19627ba1846dcf78bb2c85edbe8dd
Author: Mimi Zohar <zohar@linux.ibm.com>
Date:   Sun May 3 01:00:02 2020 -0400

    ima: verify mprotect change is consistent with mmap policy
    
    Files can be mmap'ed read/write and later changed to execute to circumvent
    IMA's mmap appraise policy rules.  Due to locking issues (mmap semaphore
    would be taken prior to i_mutex), files can not be measured or appraised at
    this point.  Eliminate this integrity gap, by denying the mprotect
    PROT_EXECUTE change, if an mmap appraise policy rule exists.
    
    On mprotect change success, return 0.  On failure, return -EACESS.
    
    Reviewed-by: Lakshmi Ramasubramanian <nramas@linux.microsoft.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/security.c b/security/security.c
index 7fed24b9d57e..dd0917c5bfe9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1512,7 +1512,12 @@ int security_mmap_addr(unsigned long addr)
 int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,
 			    unsigned long prot)
 {
-	return call_int_hook(file_mprotect, 0, vma, reqprot, prot);
+	int ret;
+
+	ret = call_int_hook(file_mprotect, 0, vma, reqprot, prot);
+	if (ret)
+		return ret;
+	return ima_file_mprotect(vma, prot);
 }
 
 int security_file_lock(struct file *file, unsigned int cmd)

commit 112b7147592e8f46bd1da4f961773e6d974f38a8
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu May 14 12:53:44 2020 -0500

    exec: Convert security_bprm_set_creds into security_bprm_repopulate_creds
    
    Rename bprm->cap_elevated to bprm->active_secureexec and initialize it
    in prepare_binprm instead of in cap_bprm_set_creds.  Initializing
    bprm->active_secureexec in prepare_binprm allows multiple
    implementations of security_bprm_repopulate_creds to play nicely with
    each other.
    
    Rename security_bprm_set_creds to security_bprm_reopulate_creds to
    emphasize that this path recomputes part of bprm->cred.  This
    recomputation avoids the time of check vs time of use problems that
    are inherent in unix #! interpreters.
    
    In short two renames and a move in the location of initializing
    bprm->active_secureexec.
    
    Link: https://lkml.kernel.org/r/87o8qkzrxp.fsf_-_@x220.int.ebiederm.org
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index 4ee76a729f73..b890b7e2a765 100644
--- a/security/security.c
+++ b/security/security.c
@@ -828,9 +828,9 @@ int security_bprm_creds_for_exec(struct linux_binprm *bprm)
 	return call_int_hook(bprm_creds_for_exec, 0, bprm);
 }
 
-int security_bprm_set_creds(struct linux_binprm *bprm)
+int security_bprm_repopulate_creds(struct linux_binprm *bprm)
 {
-	return call_int_hook(bprm_set_creds, 0, bprm);
+	return call_int_hook(bprm_repopulate_creds, 0, bprm);
 }
 
 int security_bprm_check(struct linux_binprm *bprm)

commit 0550cfe8c2c6f8e7a4c348b6603a794576db12dd
Author: KP Singh <kpsingh@google.com>
Date:   Wed May 20 14:56:16 2020 +0200

    security: Fix hook iteration for secid_to_secctx
    
    secid_to_secctx is not stackable, and since the BPF LSM registers this
    hook by default, the call_int_hook logic is not suitable which
    "bails-on-fail" and casues issues when other LSMs register this hook and
    eventually breaks Audit.
    
    In order to fix this, directly iterate over the security hooks instead
    of using call_int_hook as suggested in:
    
    https: //lore.kernel.org/bpf/9d0eb6c6-803a-ff3a-5603-9ad6d9edfc00@schaufler-ca.com/#t
    
    Fixes: 98e828a0650f ("security: Refactor declaration of LSM hooks")
    Fixes: 625236ba3832 ("security: Fix the default value of secid_to_secctx hook")
    Reported-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: KP Singh <kpsingh@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: James Morris <jamorris@linux.microsoft.com>
    Link: https://lore.kernel.org/bpf/20200520125616.193765-1-kpsingh@chromium.org

diff --git a/security/security.c b/security/security.c
index 7fed24b9d57e..51de970fbb1e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1965,8 +1965,20 @@ EXPORT_SYMBOL(security_ismaclabel);
 
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 {
-	return call_int_hook(secid_to_secctx, -EOPNOTSUPP, secid, secdata,
-				seclen);
+	struct security_hook_list *hp;
+	int rc;
+
+	/*
+	 * Currently, only one LSM can implement secid_to_secctx (i.e this
+	 * LSM hook is not "stackable").
+	 */
+	hlist_for_each_entry(hp, &security_hook_heads.secid_to_secctx, list) {
+		rc = hp->hook.secid_to_secctx(secid, secdata, seclen);
+		if (rc != LSM_RET_DEFAULT(secid_to_secctx))
+			return rc;
+	}
+
+	return LSM_RET_DEFAULT(secid_to_secctx);
 }
 EXPORT_SYMBOL(security_secid_to_secctx);
 

commit b8bff599261c930630385ee21d3f98e7ce7d4843
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Mar 22 15:46:24 2020 -0500

    exec: Factor security_bprm_creds_for_exec out of security_bprm_set_creds
    
    Today security_bprm_set_creds has several implementations:
    apparmor_bprm_set_creds, cap_bprm_set_creds, selinux_bprm_set_creds,
    smack_bprm_set_creds, and tomoyo_bprm_set_creds.
    
    Except for cap_bprm_set_creds they all test bprm->called_set_creds and
    return immediately if it is true.  The function cap_bprm_set_creds
    ignores bprm->calld_sed_creds entirely.
    
    Create a new LSM hook security_bprm_creds_for_exec that is called just
    before prepare_binprm in __do_execve_file, resulting in a LSM hook
    that is called exactly once for the entire of exec.  Modify the bits
    of security_bprm_set_creds that only want to be called once per exec
    into security_bprm_creds_for_exec, leaving only cap_bprm_set_creds
    behind.
    
    Remove bprm->called_set_creds all of it's former users have been moved
    to security_bprm_creds_for_exec.
    
    Add or upate comments a appropriate to bring them up to date and
    to reflect this change.
    
    Link: https://lkml.kernel.org/r/87v9kszrzh.fsf_-_@x220.int.ebiederm.org
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com> # For the LSM and Smack bits
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index 7fed24b9d57e..4ee76a729f73 100644
--- a/security/security.c
+++ b/security/security.c
@@ -823,6 +823,11 @@ int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 	return __vm_enough_memory(mm, pages, cap_sys_admin);
 }
 
+int security_bprm_creds_for_exec(struct linux_binprm *bprm)
+{
+	return call_int_hook(bprm_creds_for_exec, 0, bprm);
+}
+
 int security_bprm_set_creds(struct linux_binprm *bprm)
 {
 	return call_int_hook(bprm_set_creds, 0, bprm);

commit 8c0637e950d68933a67f7438f779d79b049b5e5c
Author: David Howells <dhowells@redhat.com>
Date:   Tue May 12 15:16:29 2020 +0100

    keys: Make the KEY_NEED_* perms an enum rather than a mask
    
    Since the meaning of combining the KEY_NEED_* constants is undefined, make
    it so that you can't do that by turning them into an enum.
    
    The enum is also given some extra values to represent special
    circumstances, such as:
    
     (1) The '0' value is reserved and causes a warning to trap the parameter
         being unset.
    
     (2) The key is to be unlinked and we require no permissions on it, only
         the keyring, (this replaces the KEY_LOOKUP_FOR_UNLINK flag).
    
     (3) An override due to CAP_SYS_ADMIN.
    
     (4) An override due to an instantiation token being present.
    
     (5) The permissions check is being deferred to later key_permission()
         calls.
    
    The extra values give the opportunity for LSMs to audit these situations.
    
    [Note: This really needs overhauling so that lookup_user_key() tells
     key_task_permission() and the LSM what operation is being done and leaves
     it to those functions to decide how to map that onto the available
     permits.  However, I don't really want to make these change in the middle
     of the notifications patchset.]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    cc: Paul Moore <paul@paul-moore.com>
    cc: Stephen Smalley <stephen.smalley.work@gmail.com>
    cc: Casey Schaufler <casey@schaufler-ca.com>
    cc: keyrings@vger.kernel.org
    cc: selinux@vger.kernel.org

diff --git a/security/security.c b/security/security.c
index c73334ab2882..af32d4cd0462 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2398,10 +2398,10 @@ void security_key_free(struct key *key)
 	call_void_hook(key_free, key);
 }
 
-int security_key_permission(key_ref_t key_ref,
-			    const struct cred *cred, unsigned perm)
+int security_key_permission(key_ref_t key_ref, const struct cred *cred,
+			    enum key_need_perm need_perm)
 {
-	return call_int_hook(key_permission, 0, key_ref, cred, perm);
+	return call_int_hook(key_permission, 0, key_ref, cred, need_perm);
 }
 
 int security_key_getsecurity(struct key *key, char **_buffer)

commit 998f50407ffc9370565c7ed3fcd1366adccdfbbf
Author: David Howells <dhowells@redhat.com>
Date:   Wed Feb 12 13:58:35 2020 +0000

    security: Add hooks to rule on setting a watch
    
    Add security hooks that will allow an LSM to rule on whether or not a watch
    may be set.  More than one hook is required as the watches watch different
    types of object.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jamorris@linux.microsoft.com>
    cc: Casey Schaufler <casey@schaufler-ca.com>
    cc: Stephen Smalley <sds@tycho.nsa.gov>
    cc: linux-security-module@vger.kernel.org

diff --git a/security/security.c b/security/security.c
index 7d55607120b4..c73334ab2882 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2016,6 +2016,13 @@ int security_post_notification(const struct cred *w_cred,
 }
 #endif /* CONFIG_WATCH_QUEUE */
 
+#ifdef CONFIG_KEY_NOTIFICATIONS
+int security_watch_key(struct key *key)
+{
+	return call_int_hook(watch_key, 0, key);
+}
+#endif
+
 #ifdef CONFIG_SECURITY_NETWORK
 
 int security_unix_stream_connect(struct sock *sock, struct sock *other, struct sock *newsk)

commit 344fa64ef8f6740e99b32ab788b6e3742d7284b3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Feb 12 13:58:35 2020 +0000

    security: Add a hook for the point of notification insertion
    
    Add a security hook that allows an LSM to rule on whether a notification
    message is allowed to be inserted into a particular watch queue.
    
    The hook is given the following information:
    
     (1) The credentials of the triggerer (which may be init_cred for a system
         notification, eg. a hardware error).
    
     (2) The credentials of the whoever set the watch.
    
     (3) The notification message.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jamorris@linux.microsoft.com>
    cc: Casey Schaufler <casey@schaufler-ca.com>
    cc: Stephen Smalley <sds@tycho.nsa.gov>
    cc: linux-security-module@vger.kernel.org

diff --git a/security/security.c b/security/security.c
index 7fed24b9d57e..7d55607120b4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2007,6 +2007,15 @@ int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)
 }
 EXPORT_SYMBOL(security_inode_getsecctx);
 
+#ifdef CONFIG_WATCH_QUEUE
+int security_post_notification(const struct cred *w_cred,
+			       const struct cred *cred,
+			       struct watch_notification *n)
+{
+	return call_int_hook(post_notification, 0, w_cred, cred, n);
+}
+#endif /* CONFIG_WATCH_QUEUE */
+
 #ifdef CONFIG_SECURITY_NETWORK
 
 int security_unix_stream_connect(struct sock *sock, struct sock *other, struct sock *newsk)

commit 98e828a0650f348be85728c69875260cf78069e6
Author: KP Singh <kpsingh@google.com>
Date:   Sun Mar 29 01:43:50 2020 +0100

    security: Refactor declaration of LSM hooks
    
    The information about the different types of LSM hooks is scattered
    in two locations i.e. union security_list_options and
    struct security_hook_heads. Rather than duplicating this information
    even further for BPF_PROG_TYPE_LSM, define all the hooks with the
    LSM_HOOK macro in lsm_hook_defs.h which is then used to generate all
    the data structures required by the LSM framework.
    
    The LSM hooks are defined as:
    
      LSM_HOOK(<return_type>, <default_value>, <hook_name>, args...)
    
    with <default_value> acccessible in security.c as:
    
      LSM_RET_DEFAULT(<hook_name>)
    
    Signed-off-by: KP Singh <kpsingh@google.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: Brendan Jackman <jackmanb@google.com>
    Reviewed-by: Florent Revest <revest@google.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: James Morris <jamorris@linux.microsoft.com>
    Link: https://lore.kernel.org/bpf/20200329004356.27286-3-kpsingh@chromium.org

diff --git a/security/security.c b/security/security.c
index 565bc9b67276..7fed24b9d57e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -668,6 +668,25 @@ static void __init lsm_early_task(struct task_struct *task)
 		panic("%s: Early task alloc failed.\n", __func__);
 }
 
+/*
+ * The default value of the LSM hook is defined in linux/lsm_hook_defs.h and
+ * can be accessed with:
+ *
+ *	LSM_RET_DEFAULT(<hook_name>)
+ *
+ * The macros below define static constants for the default value of each
+ * LSM hook.
+ */
+#define LSM_RET_DEFAULT(NAME) (NAME##_default)
+#define DECLARE_LSM_RET_DEFAULT_void(DEFAULT, NAME)
+#define DECLARE_LSM_RET_DEFAULT_int(DEFAULT, NAME) \
+	static const int LSM_RET_DEFAULT(NAME) = (DEFAULT);
+#define LSM_HOOK(RET, DEFAULT, NAME, ...) \
+	DECLARE_LSM_RET_DEFAULT_##RET(DEFAULT, NAME)
+
+#include <linux/lsm_hook_defs.h>
+#undef LSM_HOOK
+
 /*
  * Hook list operation macros.
  *
@@ -1338,16 +1357,16 @@ int security_inode_getsecurity(struct inode *inode, const char *name, void **buf
 	int rc;
 
 	if (unlikely(IS_PRIVATE(inode)))
-		return -EOPNOTSUPP;
+		return LSM_RET_DEFAULT(inode_getsecurity);
 	/*
 	 * Only one module will provide an attribute with a given name.
 	 */
 	hlist_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {
 		rc = hp->hook.inode_getsecurity(inode, name, buffer, alloc);
-		if (rc != -EOPNOTSUPP)
+		if (rc != LSM_RET_DEFAULT(inode_getsecurity))
 			return rc;
 	}
-	return -EOPNOTSUPP;
+	return LSM_RET_DEFAULT(inode_getsecurity);
 }
 
 int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)
@@ -1356,17 +1375,17 @@ int security_inode_setsecurity(struct inode *inode, const char *name, const void
 	int rc;
 
 	if (unlikely(IS_PRIVATE(inode)))
-		return -EOPNOTSUPP;
+		return LSM_RET_DEFAULT(inode_setsecurity);
 	/*
 	 * Only one module will provide an attribute with a given name.
 	 */
 	hlist_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {
 		rc = hp->hook.inode_setsecurity(inode, name, value, size,
 								flags);
-		if (rc != -EOPNOTSUPP)
+		if (rc != LSM_RET_DEFAULT(inode_setsecurity))
 			return rc;
 	}
-	return -EOPNOTSUPP;
+	return LSM_RET_DEFAULT(inode_setsecurity);
 }
 
 int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)
@@ -1740,12 +1759,12 @@ int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 			 unsigned long arg4, unsigned long arg5)
 {
 	int thisrc;
-	int rc = -ENOSYS;
+	int rc = LSM_RET_DEFAULT(task_prctl);
 	struct security_hook_list *hp;
 
 	hlist_for_each_entry(hp, &security_hook_heads.task_prctl, list) {
 		thisrc = hp->hook.task_prctl(option, arg2, arg3, arg4, arg5);
-		if (thisrc != -ENOSYS) {
+		if (thisrc != LSM_RET_DEFAULT(task_prctl)) {
 			rc = thisrc;
 			if (thisrc != 0)
 				break;
@@ -1917,7 +1936,7 @@ int security_getprocattr(struct task_struct *p, const char *lsm, char *name,
 			continue;
 		return hp->hook.getprocattr(p, name, value);
 	}
-	return -EINVAL;
+	return LSM_RET_DEFAULT(getprocattr);
 }
 
 int security_setprocattr(const char *lsm, const char *name, void *value,
@@ -1930,7 +1949,7 @@ int security_setprocattr(const char *lsm, const char *name, void *value,
 			continue;
 		return hp->hook.setprocattr(name, value, size);
 	}
-	return -EINVAL;
+	return LSM_RET_DEFAULT(setprocattr);
 }
 
 int security_netlink_send(struct sock *sk, struct sk_buff *skb)
@@ -2315,7 +2334,7 @@ int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
 				       const struct flowi *fl)
 {
 	struct security_hook_list *hp;
-	int rc = 1;
+	int rc = LSM_RET_DEFAULT(xfrm_state_pol_flow_match);
 
 	/*
 	 * Since this function is expected to return 0 or 1, the judgment

commit b3a6082223369203d7e7db7e81253ac761377644
Merge: 73a0bff2058f 10c2d111c906
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 18:55:17 2020 -0800

    Merge branch 'for-v5.6' of git://git.kernel.org:/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem update from James Morris:
     "Just one minor fix this time"
    
    * 'for-v5.6' of git://git.kernel.org:/pub/scm/linux/kernel/git/jmorris/linux-security:
      security: remove EARLY_LSM_COUNT which never used

commit 10c2d111c906599942efd13109061885631c4a0c
Author: Alex Shi <alex.shi@linux.alibaba.com>
Date:   Tue Jan 21 16:50:03 2020 +0800

    security: remove EARLY_LSM_COUNT which never used
    
    This macro is never used from it was introduced in commit e6b1db98cf4d5
    ("security: Support early LSMs"), better to remove it.
    
    Signed-off-by: Alex Shi <alex.shi@linux.alibaba.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 1bc000f834e2..344bf1327d7e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -33,7 +33,6 @@
 
 /* How many LSMs were built into the kernel? */
 #define LSM_COUNT (__end_lsm_info - __start_lsm_info)
-#define EARLY_LSM_COUNT (__end_early_lsm_info - __start_early_lsm_info)
 
 struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);

commit 59438b46471ae6cdfb761afc8c9beaf1e428a331
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Wed Nov 27 12:04:36 2019 -0500

    security,lockdown,selinux: implement SELinux lockdown
    
    Implement a SELinux hook for lockdown.  If the lockdown module is also
    enabled, then a denial by the lockdown module will take precedence over
    SELinux, so SELinux can only further restrict lockdown decisions.
    The SELinux hook only distinguishes at the granularity of integrity
    versus confidentiality similar to the lockdown module, but includes the
    full lockdown reason as part of the audit record as a hint in diagnosing
    what triggered the denial.  To support this auditing, move the
    lockdown_reasons[] string array from being private to the lockdown
    module to the security framework so that it can be used by the lsm audit
    code and so that it is always available even when the lockdown module
    is disabled.
    
    Note that the SELinux implementation allows the integrity and
    confidentiality reasons to be controlled independently from one another.
    Thus, in an SELinux policy, one could allow operations that specify
    an integrity reason while blocking operations that specify a
    confidentiality reason. The SELinux hook implementation is
    stricter than the lockdown module in validating the provided reason value.
    
    Sample AVC audit output from denials:
    avc:  denied  { integrity } for pid=3402 comm="fwupd"
     lockdown_reason="/dev/mem,kmem,port" scontext=system_u:system_r:fwupd_t:s0
     tcontext=system_u:system_r:fwupd_t:s0 tclass=lockdown permissive=0
    
    avc:  denied  { confidentiality } for pid=4628 comm="cp"
     lockdown_reason="/proc/kcore access"
     scontext=unconfined_u:unconfined_r:test_lockdown_integrity_t:s0-s0:c0.c1023
     tcontext=unconfined_u:unconfined_r:test_lockdown_integrity_t:s0-s0:c0.c1023
     tclass=lockdown permissive=0
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Reviewed-by: James Morris <jamorris@linux.microsoft.com>
    [PM: some merge fuzz do the the perf hooks]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index cd2d18d2d279..2b5473d92416 100644
--- a/security/security.c
+++ b/security/security.c
@@ -35,6 +35,39 @@
 #define LSM_COUNT (__end_lsm_info - __start_lsm_info)
 #define EARLY_LSM_COUNT (__end_early_lsm_info - __start_early_lsm_info)
 
+/*
+ * These are descriptions of the reasons that can be passed to the
+ * security_locked_down() LSM hook. Placing this array here allows
+ * all security modules to use the same descriptions for auditing
+ * purposes.
+ */
+const char *const lockdown_reasons[LOCKDOWN_CONFIDENTIALITY_MAX+1] = {
+	[LOCKDOWN_NONE] = "none",
+	[LOCKDOWN_MODULE_SIGNATURE] = "unsigned module loading",
+	[LOCKDOWN_DEV_MEM] = "/dev/mem,kmem,port",
+	[LOCKDOWN_EFI_TEST] = "/dev/efi_test access",
+	[LOCKDOWN_KEXEC] = "kexec of unsigned images",
+	[LOCKDOWN_HIBERNATION] = "hibernation",
+	[LOCKDOWN_PCI_ACCESS] = "direct PCI access",
+	[LOCKDOWN_IOPORT] = "raw io port access",
+	[LOCKDOWN_MSR] = "raw MSR access",
+	[LOCKDOWN_ACPI_TABLES] = "modifying ACPI tables",
+	[LOCKDOWN_PCMCIA_CIS] = "direct PCMCIA CIS storage",
+	[LOCKDOWN_TIOCSSERIAL] = "reconfiguration of serial port IO",
+	[LOCKDOWN_MODULE_PARAMETERS] = "unsafe module parameters",
+	[LOCKDOWN_MMIOTRACE] = "unsafe mmio",
+	[LOCKDOWN_DEBUGFS] = "debugfs access",
+	[LOCKDOWN_XMON_WR] = "xmon write access",
+	[LOCKDOWN_INTEGRITY_MAX] = "integrity",
+	[LOCKDOWN_KCORE] = "/proc/kcore access",
+	[LOCKDOWN_KPROBES] = "use of kprobes",
+	[LOCKDOWN_BPF_READ] = "use of bpf to read kernel RAM",
+	[LOCKDOWN_PERF] = "unsafe use of perf",
+	[LOCKDOWN_TRACEFS] = "use of tracefs",
+	[LOCKDOWN_XMON_RW] = "xmon read and write access",
+	[LOCKDOWN_CONFIDENTIALITY_MAX] = "confidentiality",
+};
+
 struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);
 

commit da97e18458fb42d7c00fac5fd1c56a3896ec666e
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Mon Oct 14 13:03:08 2019 -0400

    perf_event: Add support for LSM and SELinux checks
    
    In current mainline, the degree of access to perf_event_open(2) system
    call depends on the perf_event_paranoid sysctl.  This has a number of
    limitations:
    
    1. The sysctl is only a single value. Many types of accesses are controlled
       based on the single value thus making the control very limited and
       coarse grained.
    2. The sysctl is global, so if the sysctl is changed, then that means
       all processes get access to perf_event_open(2) opening the door to
       security issues.
    
    This patch adds LSM and SELinux access checking which will be used in
    Android to access perf_event_open(2) for the purposes of attaching BPF
    programs to tracepoints, perf profiling and other operations from
    userspace. These operations are intended for production systems.
    
    5 new LSM hooks are added:
    1. perf_event_open: This controls access during the perf_event_open(2)
       syscall itself. The hook is called from all the places that the
       perf_event_paranoid sysctl is checked to keep it consistent with the
       systctl. The hook gets passed a 'type' argument which controls CPU,
       kernel and tracepoint accesses (in this context, CPU, kernel and
       tracepoint have the same semantics as the perf_event_paranoid sysctl).
       Additionally, I added an 'open' type which is similar to
       perf_event_paranoid sysctl == 3 patch carried in Android and several other
       distros but was rejected in mainline [1] in 2016.
    
    2. perf_event_alloc: This allocates a new security object for the event
       which stores the current SID within the event. It will be useful when
       the perf event's FD is passed through IPC to another process which may
       try to read the FD. Appropriate security checks will limit access.
    
    3. perf_event_free: Called when the event is closed.
    
    4. perf_event_read: Called from the read(2) and mmap(2) syscalls for the event.
    
    5. perf_event_write: Called from the ioctl(2) syscalls for the event.
    
    [1] https://lwn.net/Articles/696240/
    
    Since Peter had suggest LSM hooks in 2016 [1], I am adding his
    Suggested-by tag below.
    
    To use this patch, we set the perf_event_paranoid sysctl to -1 and then
    apply selinux checking as appropriate (default deny everything, and then
    add policy rules to give access to domains that need it). In the future
    we can remove the perf_event_paranoid sysctl altogether.
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Co-developed-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: James Morris <jmorris@namei.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: rostedt@goodmis.org
    Cc: Yonghong Song <yhs@fb.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: jeffv@google.com
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: primiano@google.com
    Cc: Song Liu <songliubraving@fb.com>
    Cc: rsavitski@google.com
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Matthew Garrett <matthewgarrett@google.com>
    Link: https://lkml.kernel.org/r/20191014170308.70668-1-joel@joelfernandes.org

diff --git a/security/security.c b/security/security.c
index 1bc000f834e2..cd2d18d2d279 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2404,3 +2404,30 @@ int security_locked_down(enum lockdown_reason what)
 	return call_int_hook(locked_down, 0, what);
 }
 EXPORT_SYMBOL(security_locked_down);
+
+#ifdef CONFIG_PERF_EVENTS
+int security_perf_event_open(struct perf_event_attr *attr, int type)
+{
+	return call_int_hook(perf_event_open, 0, attr, type);
+}
+
+int security_perf_event_alloc(struct perf_event *event)
+{
+	return call_int_hook(perf_event_alloc, 0, event);
+}
+
+void security_perf_event_free(struct perf_event *event)
+{
+	call_void_hook(perf_event_free, event);
+}
+
+int security_perf_event_read(struct perf_event *event)
+{
+	return call_int_hook(perf_event_read, 0, event);
+}
+
+int security_perf_event_write(struct perf_event *event)
+{
+	return call_int_hook(perf_event_write, 0, event);
+}
+#endif /* CONFIG_PERF_EVENTS */

commit aefcf2f4b58155d27340ba5f9ddbe9513da8286d
Merge: f1f2f614d535 45893a0abee6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 28 08:14:15 2019 -0700

    Merge branch 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull kernel lockdown mode from James Morris:
     "This is the latest iteration of the kernel lockdown patchset, from
      Matthew Garrett, David Howells and others.
    
      From the original description:
    
        This patchset introduces an optional kernel lockdown feature,
        intended to strengthen the boundary between UID 0 and the kernel.
        When enabled, various pieces of kernel functionality are restricted.
        Applications that rely on low-level access to either hardware or the
        kernel may cease working as a result - therefore this should not be
        enabled without appropriate evaluation beforehand.
    
        The majority of mainstream distributions have been carrying variants
        of this patchset for many years now, so there's value in providing a
        doesn't meet every distribution requirement, but gets us much closer
        to not requiring external patches.
    
      There are two major changes since this was last proposed for mainline:
    
       - Separating lockdown from EFI secure boot. Background discussion is
         covered here: https://lwn.net/Articles/751061/
    
       -  Implementation as an LSM, with a default stackable lockdown LSM
          module. This allows the lockdown feature to be policy-driven,
          rather than encoding an implicit policy within the mechanism.
    
      The new locked_down LSM hook is provided to allow LSMs to make a
      policy decision around whether kernel functionality that would allow
      tampering with or examining the runtime state of the kernel should be
      permitted.
    
      The included lockdown LSM provides an implementation with a simple
      policy intended for general purpose use. This policy provides a coarse
      level of granularity, controllable via the kernel command line:
    
        lockdown={integrity|confidentiality}
    
      Enable the kernel lockdown feature. If set to integrity, kernel features
      that allow userland to modify the running kernel are disabled. If set to
      confidentiality, kernel features that allow userland to extract
      confidential information from the kernel are also disabled.
    
      This may also be controlled via /sys/kernel/security/lockdown and
      overriden by kernel configuration.
    
      New or existing LSMs may implement finer-grained controls of the
      lockdown features. Refer to the lockdown_reason documentation in
      include/linux/security.h for details.
    
      The lockdown feature has had signficant design feedback and review
      across many subsystems. This code has been in linux-next for some
      weeks, with a few fixes applied along the way.
    
      Stephen Rothwell noted that commit 9d1f8be5cf42 ("bpf: Restrict bpf
      when kernel lockdown is in confidentiality mode") is missing a
      Signed-off-by from its author. Matthew responded that he is providing
      this under category (c) of the DCO"
    
    * 'next-lockdown' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (31 commits)
      kexec: Fix file verification on S390
      security: constify some arrays in lockdown LSM
      lockdown: Print current->comm in restriction messages
      efi: Restrict efivar_ssdt_load when the kernel is locked down
      tracefs: Restrict tracefs when the kernel is locked down
      debugfs: Restrict debugfs when the kernel is locked down
      kexec: Allow kexec_file() with appropriate IMA policy when locked down
      lockdown: Lock down perf when in confidentiality mode
      bpf: Restrict bpf when kernel lockdown is in confidentiality mode
      lockdown: Lock down tracing and perf kprobes when in confidentiality mode
      lockdown: Lock down /proc/kcore
      x86/mmiotrace: Lock down the testmmiotrace module
      lockdown: Lock down module params that specify hardware parameters (eg. ioport)
      lockdown: Lock down TIOCSSERIAL
      lockdown: Prohibit PCMCIA CIS storage when the kernel is locked down
      acpi: Disable ACPI table override if the kernel is locked down
      acpi: Ignore acpi_rsdp kernel param when the kernel has been locked down
      ACPI: Limit access to custom_method when the kernel is locked down
      x86/msr: Restrict MSR access when the kernel is locked down
      x86: Lock down IO port access when the kernel is locked down
      ...

commit 5825a95fe92566ada2292a65de030850b5cff1da
Merge: 3c6a6910a81e 15322a0d90b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 23 11:21:04 2019 -0700

    Merge tag 'selinux-pr-20190917' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux
    
    Pull selinux updates from Paul Moore:
    
     - Add LSM hooks, and SELinux access control hooks, for dnotify,
       fanotify, and inotify watches. This has been discussed with both the
       LSM and fs/notify folks and everybody is good with these new hooks.
    
     - The LSM stacking changes missed a few calls to current_security() in
       the SELinux code; we fix those and remove current_security() for
       good.
    
     - Improve our network object labeling cache so that we always return
       the object's label, even when under memory pressure. Previously we
       would return an error if we couldn't allocate a new cache entry, now
       we always return the label even if we can't create a new cache entry
       for it.
    
     - Convert the sidtab atomic_t counter to a normal u32 with
       READ/WRITE_ONCE() and memory barrier protection.
    
     - A few patches to policydb.c to clean things up (remove forward
       declarations, long lines, bad variable names, etc)
    
    * tag 'selinux-pr-20190917' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux:
      lsm: remove current_security()
      selinux: fix residual uses of current_security() for the SELinux blob
      selinux: avoid atomic_t usage in sidtab
      fanotify, inotify, dnotify, security: add security hook for fs notifications
      selinux: always return a secid from the network caches if we find one
      selinux: policydb - rename type_val_to_struct_array
      selinux: policydb - fix some checkpatch.pl warnings
      selinux: shuffle around policydb.c to get rid of forward declarations

commit 9e47d31d6a57b5babaca36d42b0d11b6db6019b7
Author: Matthew Garrett <matthewgarrett@google.com>
Date:   Mon Aug 19 17:17:38 2019 -0700

    security: Add a "locked down" LSM hook
    
    Add a mechanism to allow LSMs to make a policy decision around whether
    kernel functionality that would allow tampering with or examining the
    runtime state of the kernel should be permitted.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index ef4a0111c8b4..7fc373486d7a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -2389,3 +2389,9 @@ void security_bpf_prog_free(struct bpf_prog_aux *aux)
 	call_void_hook(bpf_prog_free_security, aux);
 }
 #endif /* CONFIG_BPF_SYSCALL */
+
+int security_locked_down(enum lockdown_reason what)
+{
+	return call_int_hook(locked_down, 0, what);
+}
+EXPORT_SYMBOL(security_locked_down);

commit e6b1db98cf4d54d9ea59cfcc195f70dc946fdd38
Author: Matthew Garrett <matthewgarrett@google.com>
Date:   Mon Aug 19 17:17:37 2019 -0700

    security: Support early LSMs
    
    The lockdown module is intended to allow for kernels to be locked down
    early in boot - sufficiently early that we don't have the ability to
    kmalloc() yet. Add support for early initialisation of some LSMs, and
    then add them to the list of names when we do full initialisation later.
    Early LSMs are initialised in link order and cannot be overridden via
    boot parameters, and cannot make use of kmalloc() (since the allocator
    isn't initialised yet).
    
    (Fixed by Stephen Rothwell to include a stub to fix builds when
    !CONFIG_SECURITY)
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index f493db0bf62a..ef4a0111c8b4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -33,6 +33,7 @@
 
 /* How many LSMs were built into the kernel? */
 #define LSM_COUNT (__end_lsm_info - __start_lsm_info)
+#define EARLY_LSM_COUNT (__end_early_lsm_info - __start_early_lsm_info)
 
 struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
@@ -277,6 +278,8 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 static void __init lsm_early_cred(struct cred *cred);
 static void __init lsm_early_task(struct task_struct *task);
 
+static int lsm_append(const char *new, char **result);
+
 static void __init ordered_lsm_init(void)
 {
 	struct lsm_info **lsm;
@@ -323,6 +326,26 @@ static void __init ordered_lsm_init(void)
 	kfree(ordered_lsms);
 }
 
+int __init early_security_init(void)
+{
+	int i;
+	struct hlist_head *list = (struct hlist_head *) &security_hook_heads;
+	struct lsm_info *lsm;
+
+	for (i = 0; i < sizeof(security_hook_heads) / sizeof(struct hlist_head);
+	     i++)
+		INIT_HLIST_HEAD(&list[i]);
+
+	for (lsm = __start_early_lsm_info; lsm < __end_early_lsm_info; lsm++) {
+		if (!lsm->enabled)
+			lsm->enabled = &lsm_enabled_true;
+		prepare_lsm(lsm);
+		initialize_lsm(lsm);
+	}
+
+	return 0;
+}
+
 /**
  * security_init - initializes the security framework
  *
@@ -330,14 +353,18 @@ static void __init ordered_lsm_init(void)
  */
 int __init security_init(void)
 {
-	int i;
-	struct hlist_head *list = (struct hlist_head *) &security_hook_heads;
+	struct lsm_info *lsm;
 
 	pr_info("Security Framework initializing\n");
 
-	for (i = 0; i < sizeof(security_hook_heads) / sizeof(struct hlist_head);
-	     i++)
-		INIT_HLIST_HEAD(&list[i]);
+	/*
+	 * Append the names of the early LSM modules now that kmalloc() is
+	 * available
+	 */
+	for (lsm = __start_early_lsm_info; lsm < __end_early_lsm_info; lsm++) {
+		if (lsm->enabled)
+			lsm_append(lsm->name, &lsm_names);
+	}
 
 	/* Load LSMs in specified order. */
 	ordered_lsm_init();
@@ -384,7 +411,7 @@ static bool match_last_lsm(const char *list, const char *lsm)
 	return !strcmp(last, lsm);
 }
 
-static int lsm_append(char *new, char **result)
+static int lsm_append(const char *new, char **result)
 {
 	char *cp;
 
@@ -422,8 +449,15 @@ void __init security_add_hooks(struct security_hook_list *hooks, int count,
 		hooks[i].lsm = lsm;
 		hlist_add_tail_rcu(&hooks[i].list, hooks[i].head);
 	}
-	if (lsm_append(lsm, &lsm_names) < 0)
-		panic("%s - Cannot get early memory.\n", __func__);
+
+	/*
+	 * Don't try to append during early_security_init(), we'll come back
+	 * and fix this up afterwards.
+	 */
+	if (slab_is_available()) {
+		if (lsm_append(lsm, &lsm_names) < 0)
+			panic("%s - Cannot get early memory.\n", __func__);
+	}
 }
 
 int call_lsm_notifier(enum lsm_event event, void *data)

commit ac5656d8a4cdd93cd2c74355ed12e5617817e0e7
Author: Aaron Goidel <acgoide@tycho.nsa.gov>
Date:   Mon Aug 12 11:20:00 2019 -0400

    fanotify, inotify, dnotify, security: add security hook for fs notifications
    
    As of now, setting watches on filesystem objects has, at most, applied a
    check for read access to the inode, and in the case of fanotify, requires
    CAP_SYS_ADMIN. No specific security hook or permission check has been
    provided to control the setting of watches. Using any of inotify, dnotify,
    or fanotify, it is possible to observe, not only write-like operations, but
    even read access to a file. Modeling the watch as being merely a read from
    the file is insufficient for the needs of SELinux. This is due to the fact
    that read access should not necessarily imply access to information about
    when another process reads from a file. Furthermore, fanotify watches grant
    more power to an application in the form of permission events. While
    notification events are solely, unidirectional (i.e. they only pass
    information to the receiving application), permission events are blocking.
    Permission events make a request to the receiving application which will
    then reply with a decision as to whether or not that action may be
    completed. This causes the issue of the watching application having the
    ability to exercise control over the triggering process. Without drawing a
    distinction within the permission check, the ability to read would imply
    the greater ability to control an application. Additionally, mount and
    superblock watches apply to all files within the same mount or superblock.
    Read access to one file should not necessarily imply the ability to watch
    all files accessed within a given mount or superblock.
    
    In order to solve these issues, a new LSM hook is implemented and has been
    placed within the system calls for marking filesystem objects with inotify,
    fanotify, and dnotify watches. These calls to the hook are placed at the
    point at which the target path has been resolved and are provided with the
    path struct, the mask of requested notification events, and the type of
    object on which the mark is being set (inode, superblock, or mount). The
    mask and obj_type have already been translated into common FS_* values
    shared by the entirety of the fs notification infrastructure. The path
    struct is passed rather than just the inode so that the mount is available,
    particularly for mount watches. This also allows for use of the hook by
    pathname-based security modules. However, since the hook is intended for
    use even by inode based security modules, it is not placed under the
    CONFIG_SECURITY_PATH conditional. Otherwise, the inode-based security
    modules would need to enable all of the path hooks, even though they do not
    use any of them.
    
    This only provides a hook at the point of setting a watch, and presumes
    that permission to set a particular watch implies the ability to receive
    all notification about that object which match the mask. This is all that
    is required for SELinux. If other security modules require additional hooks
    or infrastructure to control delivery of notification, these can be added
    by them. It does not make sense for us to propose hooks for which we have
    no implementation. The understanding that all notifications received by the
    requesting application are all strictly of a type for which the application
    has been granted permission shows that this implementation is sufficient in
    its coverage.
    
    Security modules wishing to provide complete control over fanotify must
    also implement a security_file_open hook that validates that the access
    requested by the watching application is authorized. Fanotify has the issue
    that it returns a file descriptor with the file mode specified during
    fanotify_init() to the watching process on event. This is already covered
    by the LSM security_file_open hook if the security module implements
    checking of the requested file mode there. Otherwise, a watching process
    can obtain escalated access to a file for which it has not been authorized.
    
    The selinux_path_notify hook implementation works by adding five new file
    permissions: watch, watch_mount, watch_sb, watch_reads, and watch_with_perm
    (descriptions about which will follow), and one new filesystem permission:
    watch (which is applied to superblock checks). The hook then decides which
    subset of these permissions must be held by the requesting application
    based on the contents of the provided mask and the obj_type. The
    selinux_file_open hook already checks the requested file mode and therefore
    ensures that a watching process cannot escalate its access through
    fanotify.
    
    The watch, watch_mount, and watch_sb permissions are the baseline
    permissions for setting a watch on an object and each are a requirement for
    any watch to be set on a file, mount, or superblock respectively. It should
    be noted that having either of the other two permissions (watch_reads and
    watch_with_perm) does not imply the watch, watch_mount, or watch_sb
    permission. Superblock watches further require the filesystem watch
    permission to the superblock. As there is no labeled object in view for
    mounts, there is no specific check for mount watches beyond watch_mount to
    the inode. Such a check could be added in the future, if a suitable labeled
    object existed representing the mount.
    
    The watch_reads permission is required to receive notifications from
    read-exclusive events on filesystem objects. These events include accessing
    a file for the purpose of reading and closing a file which has been opened
    read-only. This distinction has been drawn in order to provide a direct
    indication in the policy for this otherwise not obvious capability. Read
    access to a file should not necessarily imply the ability to observe read
    events on a file.
    
    Finally, watch_with_perm only applies to fanotify masks since it is the
    only way to set a mask which allows for the blocking, permission event.
    This permission is needed for any watch which is of this type. Though
    fanotify requires CAP_SYS_ADMIN, this is insufficient as it gives implicit
    trust to root, which we do not do, and does not support least privilege.
    
    Signed-off-by: Aaron Goidel <acgoide@tycho.nsa.gov>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index 613a5c00e602..30687e1366b7 100644
--- a/security/security.c
+++ b/security/security.c
@@ -871,6 +871,12 @@ int security_move_mount(const struct path *from_path, const struct path *to_path
 	return call_int_hook(move_mount, 0, from_path, to_path);
 }
 
+int security_path_notify(const struct path *path, u64 mask,
+				unsigned int obj_type)
+{
+	return call_int_hook(path_notify, 0, path, mask, obj_type);
+}
+
 int security_inode_alloc(struct inode *inode)
 {
 	int rc = lsm_inode_alloc(inode);

commit 8b68150883ca466a23e90902dd4113b22e692f04
Merge: 0f75ef6a9cff 650b29dbdf2c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 20:28:59 2019 -0700

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity
    
    Pull integrity updates from Mimi Zohar:
     "Bug fixes, code clean up, and new features:
    
       - IMA policy rules can be defined in terms of LSM labels, making the
         IMA policy dependent on LSM policy label changes, in particular LSM
         label deletions. The new environment, in which IMA-appraisal is
         being used, frequently updates the LSM policy and permits LSM label
         deletions.
    
       - Prevent an mmap'ed shared file opened for write from also being
         mmap'ed execute. In the long term, making this and other similar
         changes at the VFS layer would be preferable.
    
       - The IMA per policy rule template format support is needed for a
         couple of new/proposed features (eg. kexec boot command line
         measurement, appended signatures, and VFS provided file hashes).
    
       - Other than the "boot-aggregate" record in the IMA measuremeent
         list, all other measurements are of file data. Measuring and
         storing the kexec boot command line in the IMA measurement list is
         the first buffer based measurement included in the measurement
         list"
    
    * 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity:
      integrity: Introduce struct evm_xattr
      ima: Update MAX_TEMPLATE_NAME_LEN to fit largest reasonable definition
      KEXEC: Call ima_kexec_cmdline to measure the boot command line args
      IMA: Define a new template field buf
      IMA: Define a new hook to measure the kexec boot command line arguments
      IMA: support for per policy rule template formats
      integrity: Fix __integrity_init_keyring() section mismatch
      ima: Use designated initializers for struct ima_event_data
      ima: use the lsm policy update notifier
      LSM: switch to blocking policy update notifiers
      x86/ima: fix the Kconfig dependency for IMA_ARCH_POLICY
      ima: Make arch_policy_entry static
      ima: prevent a file already mmap'ed write to be mmap'ed execute
      x86/ima: check EFI SetupMode too

commit 42df744c4166af6959eda2df1ee5cde744d4a1c3
Author: Janne Karhunen <janne.karhunen@gmail.com>
Date:   Fri Jun 14 15:20:14 2019 +0300

    LSM: switch to blocking policy update notifiers
    
    Atomic policy updaters are not very useful as they cannot
    usually perform the policy updates on their own. Since it
    seems that there is no strict need for the atomicity,
    switch to the blocking variant. While doing so, rename
    the functions accordingly.
    
    Signed-off-by: Janne Karhunen <janne.karhunen@gmail.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by: James Morris <jamorris@linux.microsoft.com>
    Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>

diff --git a/security/security.c b/security/security.c
index 613a5c00e602..47e5849d7557 100644
--- a/security/security.c
+++ b/security/security.c
@@ -39,7 +39,7 @@
 #define LSM_COUNT (__end_lsm_info - __start_lsm_info)
 
 struct security_hook_heads security_hook_heads __lsm_ro_after_init;
-static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
+static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);
 
 static struct kmem_cache *lsm_file_cache;
 static struct kmem_cache *lsm_inode_cache;
@@ -430,23 +430,26 @@ void __init security_add_hooks(struct security_hook_list *hooks, int count,
 		panic("%s - Cannot get early memory.\n", __func__);
 }
 
-int call_lsm_notifier(enum lsm_event event, void *data)
+int call_blocking_lsm_notifier(enum lsm_event event, void *data)
 {
-	return atomic_notifier_call_chain(&lsm_notifier_chain, event, data);
+	return blocking_notifier_call_chain(&blocking_lsm_notifier_chain,
+					    event, data);
 }
-EXPORT_SYMBOL(call_lsm_notifier);
+EXPORT_SYMBOL(call_blocking_lsm_notifier);
 
-int register_lsm_notifier(struct notifier_block *nb)
+int register_blocking_lsm_notifier(struct notifier_block *nb)
 {
-	return atomic_notifier_chain_register(&lsm_notifier_chain, nb);
+	return blocking_notifier_chain_register(&blocking_lsm_notifier_chain,
+						nb);
 }
-EXPORT_SYMBOL(register_lsm_notifier);
+EXPORT_SYMBOL(register_blocking_lsm_notifier);
 
-int unregister_lsm_notifier(struct notifier_block *nb)
+int unregister_blocking_lsm_notifier(struct notifier_block *nb)
 {
-	return atomic_notifier_chain_unregister(&lsm_notifier_chain, nb);
+	return blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,
+						  nb);
 }
-EXPORT_SYMBOL(unregister_lsm_notifier);
+EXPORT_SYMBOL(unregister_blocking_lsm_notifier);
 
 /**
  * lsm_cred_alloc - allocate a composite cred blob

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/security.c b/security/security.c
index 613a5c00e602..f493db0bf62a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Security plug functions
  *
@@ -5,11 +6,6 @@
  * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
  * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>
  * Copyright (C) 2016 Mellanox Technologies
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
  */
 
 #define pr_fmt(fmt) "LSM: " fmt

commit 400913252d09f9cfb8cce33daee43167921fc343
Merge: d27fb65bc238 f1b5618e013a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 20:17:51 2019 -0700

    Merge branch 'work.mount-syscalls' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull mount ABI updates from Al Viro:
     "The syscalls themselves, finally.
    
      That's not all there is to that stuff, but switching individual
      filesystems to new methods is fortunately independent from everything
      else, so e.g. NFS series can go through NFS tree, etc.
    
      As those conversions get done, we'll be finally able to get rid of a
      bunch of duplication in fs/super.c introduced in the beginning of the
      entire thing. I expect that to be finished in the next window..."
    
    * 'work.mount-syscalls' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: Add a sample program for the new mount API
      vfs: syscall: Add fspick() to select a superblock for reconfiguration
      vfs: syscall: Add fsmount() to create a mount for a superblock
      vfs: syscall: Add fsconfig() for configuring and managing a context
      vfs: Implement logging through fs_context
      vfs: syscall: Add fsopen() to prepare for superblock creation
      Make anon_inodes unconditional
      teach move_mount(2) to work with OPEN_TREE_CLONE
      vfs: syscall: Add move_mount(2) to move mounts around
      vfs: syscall: Add open_tree(2) to reference or clone a mount

commit b230d5aba2d1a7b0636408889a75bf9eae6b8bc7
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Feb 22 15:57:16 2019 +0100

    LSM: add new hook for kernfs node initialization
    
    This patch introduces a new security hook that is intended for
    initializing the security data for newly created kernfs nodes, which
    provide a way of storing a non-default security context, but need to
    operate independently from mounts (and therefore may not have an
    associated inode at the moment of creation).
    
    The main motivation is to allow kernfs nodes to inherit the context of
    the parent under SELinux, similar to the behavior of
    security_inode_init_security(). Other LSMs may implement their own logic
    for handling the creation of new nodes.
    
    This patch also adds helper functions to <linux/kernfs.h> for
    getting/setting security xattrs of a kernfs node so that LSMs hooks are
    able to do their job. Other important attributes should be accessible
    direcly in the kernfs_node fields (in case there is need for more, then
    new helpers should be added to kernfs.h along with the patch that needs
    them).
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    [PM: more manual merge fixes]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index 23cbb1a295a3..8d6ef9da94eb 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1318,6 +1318,12 @@ int security_inode_copy_up_xattr(const char *name)
 }
 EXPORT_SYMBOL(security_inode_copy_up_xattr);
 
+int security_kernfs_init_security(struct kernfs_node *kn_dir,
+				  struct kernfs_node *kn)
+{
+	return call_int_hook(kernfs_init_security, 0, kn_dir, kn);
+}
+
 int security_file_permission(struct file *file, int mask)
 {
 	int ret;

commit 2db154b3ea8e14b04fee23e3fdfd5e9d17fbc6ae
Author: David Howells <dhowells@redhat.com>
Date:   Mon Nov 5 17:40:30 2018 +0000

    vfs: syscall: Add move_mount(2) to move mounts around
    
    Add a move_mount() system call that will move a mount from one place to
    another and, in the next commit, allow to attach an unattached mount tree.
    
    The new system call looks like the following:
    
            int move_mount(int from_dfd, const char *from_path,
                           int to_dfd, const char *to_path,
                           unsigned int flags);
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 23cbb1a295a3..5b3d23e427b3 100644
--- a/security/security.c
+++ b/security/security.c
@@ -866,6 +866,11 @@ int security_add_mnt_opt(const char *option, const char *val, int len,
 }
 EXPORT_SYMBOL(security_add_mnt_opt);
 
+int security_move_mount(const struct path *from_path, const struct path *to_path)
+{
+	return call_int_hook(move_mount, 0, from_path, to_path);
+}
+
 int security_inode_alloc(struct inode *inode)
 {
 	int rc = lsm_inode_alloc(inode);

commit 7b47a9e7c8f672b6fb0b77fca11a63a8a77f5a91
Merge: dbc2fba3fc46 c99c2171fc61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 12 14:08:19 2019 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount infrastructure updates from Al Viro:
     "The rest of core infrastructure; no new syscalls in that pile, but the
      old parts are switched to new infrastructure. At that point
      conversions of individual filesystems can happen independently; some
      are done here (afs, cgroup, procfs, etc.), there's also a large series
      outside of that pile dealing with NFS (quite a bit of option-parsing
      stuff is getting used there - it's one of the most convoluted
      filesystems in terms of mount-related logics), but NFS bits are the
      next cycle fodder.
    
      It got seriously simplified since the last cycle; documentation is
      probably the weakest bit at the moment - I considered dropping the
      commit introducing Documentation/filesystems/mount_api.txt (cutting
      the size increase by quarter ;-), but decided that it would be better
      to fix it up after -rc1 instead.
    
      That pile allows to do followup work in independent branches, which
      should make life much easier for the next cycle. fs/super.c size
      increase is unpleasant; there's a followup series that allows to
      shrink it considerably, but I decided to leave that until the next
      cycle"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (41 commits)
      afs: Use fs_context to pass parameters over automount
      afs: Add fs_context support
      vfs: Add some logging to the core users of the fs_context log
      vfs: Implement logging through fs_context
      vfs: Provide documentation for new mount API
      vfs: Remove kern_mount_data()
      hugetlbfs: Convert to fs_context
      cpuset: Use fs_context
      kernfs, sysfs, cgroup, intel_rdt: Support fs_context
      cgroup: store a reference to cgroup_ns into cgroup_fs_context
      cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper
      cgroup_do_mount(): massage calling conventions
      cgroup: stash cgroup_root reference into cgroup_fs_context
      cgroup2: switch to option-by-option parsing
      cgroup1: switch to option-by-option parsing
      cgroup: take options parsing into ->parse_monolithic()
      cgroup: fold cgroup1_mount() into cgroup1_get_tree()
      cgroup: start switching to fs_context
      ipc: Convert mqueue fs to fs_context
      proc: Add fs_context support to procfs
      ...

commit be37f21a08ce65c7632c7f45e1755a4b07f278a0
Merge: 3ac96c30ccfa 131d34cb0795
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 7 12:20:11 2019 -0800

    Merge tag 'audit-pr-20190305' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit
    
    Pull audit updates from Paul Moore:
     "A lucky 13 audit patches for v5.1.
    
      Despite the rather large diffstat, most of the changes are from two
      bug fix patches that move code from one Kconfig option to another.
    
      Beyond that bit of churn, the remaining changes are largely cleanups
      and bug-fixes as we slowly march towards container auditing. It isn't
      all boring though, we do have a couple of new things: file
      capabilities v3 support, and expanded support for filtering on
      filesystems to solve problems with remote filesystems.
    
      All changes pass the audit-testsuite.  Please merge for v5.1"
    
    * tag 'audit-pr-20190305' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit:
      audit: mark expected switch fall-through
      audit: hide auditsc_get_stamp and audit_serial prototypes
      audit: join tty records to their syscall
      audit: remove audit_context when CONFIG_ AUDIT and not AUDITSYSCALL
      audit: remove unused actx param from audit_rule_match
      audit: ignore fcaps on umount
      audit: clean up AUDITSYSCALL prototypes and stubs
      audit: more filter PATH records keyed on filesystem magic
      audit: add support for fcaps v3
      audit: move loginuid and sessionid from CONFIG_AUDITSYSCALL to CONFIG_AUDIT
      audit: add syscall information to CONFIG_CHANGE records
      audit: hand taken context to audit_kill_trees for syscall logging
      audit: give a clue what CONFIG_CHANGE op was involved

commit 0b52075ee62301dd150c9f2c3ddd0035ed894cde
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 23 16:02:47 2018 -0500

    introduce cloning of fs_context
    
    new primitive: vfs_dup_fs_context().  Comes with fs_context
    method (->dup()) for copying the filesystem-specific parts
    of fs_context, along with LSM one (->fs_context_dup()) for
    doing the same to LSM parts.
    
    [needs better commit message, and change of Author:, anyway]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index e5519488327d..5759339319dc 100644
--- a/security/security.c
+++ b/security/security.c
@@ -374,6 +374,11 @@ void security_bprm_committed_creds(struct linux_binprm *bprm)
 	call_void_hook(bprm_committed_creds, bprm);
 }
 
+int security_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)
+{
+	return call_int_hook(fs_context_dup, 0, fc, src_fc);
+}
+
 int security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param)
 {
 	return call_int_hook(fs_context_parse_param, -ENOPARAM, fc, param);

commit da2441fdffbf7602da702aea5bd95ca4dc3d63fc
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:24 2018 +0000

    vfs: Add LSM hooks for the new mount API
    
    Add LSM hooks for use by the new mount API and filesystem context code.
    This includes:
    
     (1) Hooks to handle allocation, duplication and freeing of the security
         record attached to a filesystem context.
    
     (2) A hook to snoop source specifications.  There may be multiple of these
         if the filesystem supports it.  They will to be local files/devices if
         fs_context::source_is_dev is true and will be something else, possibly
         remote server specifications, if false.
    
     (3) A hook to snoop superblock configuration options in key[=val] form.
         If the LSM decides it wants to handle it, it can suppress the option
         being passed to the filesystem.  Note that 'val' may include commas
         and binary data with the fsopen patch.
    
     (4) A hook to perform validation and allocation after the configuration
         has been done but before the superblock is allocated and set up.
    
     (5) A hook to transfer the security from the context to a newly created
         superblock.
    
     (6) A hook to rule on whether a path point can be used as a mountpoint.
    
    These are intended to replace:
    
            security_sb_copy_data
            security_sb_kern_mount
            security_sb_mount
            security_sb_set_mnt_opts
            security_sb_clone_mnt_opts
            security_sb_parse_opts_str
    
    [AV -- some of the methods being replaced are already gone, some of the
    methods are not added for the lack of need]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-security-module@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index f1b8d2587639..e5519488327d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -374,6 +374,11 @@ void security_bprm_committed_creds(struct linux_binprm *bprm)
 	call_void_hook(bprm_committed_creds, bprm);
 }
 
+int security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param)
+{
+	return call_int_hook(fs_context_parse_param, -ENOPARAM, fc, param);
+}
+
 int security_sb_alloc(struct super_block *sb)
 {
 	return call_int_hook(sb_alloc_security, 0, sb);

commit 89a9684ea158dd7eef1728be9f0aed9a7d41cf19
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Feb 12 10:23:18 2019 -0800

    LSM: Ignore "security=" when "lsm=" is specified
    
    To avoid potential confusion, explicitly ignore "security=" when "lsm=" is
    used on the command line, and report that it is happening.
    
    Suggested-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index b6bff646d373..ed9b8cbf21cf 100644
--- a/security/security.c
+++ b/security/security.c
@@ -288,9 +288,13 @@ static void __init ordered_lsm_init(void)
 	ordered_lsms = kcalloc(LSM_COUNT + 1, sizeof(*ordered_lsms),
 				GFP_KERNEL);
 
-	if (chosen_lsm_order)
+	if (chosen_lsm_order) {
+		if (chosen_major_lsm) {
+			pr_info("security= is ignored because it is superseded by lsm=\n");
+			chosen_major_lsm = NULL;
+		}
 		ordered_lsm_parse(chosen_lsm_order, "cmdline");
-	else
+	} else
 		ordered_lsm_parse(builtin_lsm_order, "builtin");
 
 	for (lsm = ordered_lsms; *lsm; lsm++)

commit 90462a5bd30c6ed91c6758e59537d047d7878ff9
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Thu Jan 31 11:52:11 2019 -0500

    audit: remove unused actx param from audit_rule_match
    
    The audit_rule_match() struct audit_context *actx parameter is not used
    by any in-tree consumers (selinux, apparmour, integrity, smack).
    
    The audit context is an internal audit structure that should only be
    accessed by audit accessor functions.
    
    It was part of commit 03d37d25e0f9 ("LSM/Audit: Introduce generic
    Audit LSM hooks") but appears to have never been used.
    
    Remove it.
    
    Please see the github issue
    https://github.com/linux-audit/audit-kernel/issues/107
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: fixed the referenced commit title]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index f1b8d2587639..5f954b179a8e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1783,11 +1783,9 @@ void security_audit_rule_free(void *lsmrule)
 	call_void_hook(audit_rule_free, lsmrule);
 }
 
-int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
-			      struct audit_context *actx)
+int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule)
 {
-	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule,
-				actx);
+	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule);
 }
 #endif /* CONFIG_AUDIT */
 

commit 9624d5c9c7ff6836bbf9f9b230fd1fcf3d56f91a
Merge: 3e8c73671244 49a57857aeea
Author: James Morris <james.morris@microsoft.com>
Date:   Tue Jan 22 14:33:10 2019 -0800

    Merge tag 'v5.0-rc3' into next-general
    
    Sync to Linux 5.0-rc3 to pull in the VFS changes which impacted a lot
    of the LSM code.

commit 3e8c73671244af16f1a6042f1c10d13b75cd1156
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Wed Jan 16 05:44:32 2019 +0000

    LSM: Make some functions static
    
    Fixes the following sparse warnings:
    
    security/security.c:533:5: warning:
     symbol 'lsm_task_alloc' was not declared. Should it be static?
    security/security.c:554:5: warning:
     symbol 'lsm_ipc_alloc' was not declared. Should it be static?
    security/security.c:575:5: warning:
     symbol 'lsm_msg_msg_alloc' was not declared. Should it be static?
    
    Fixes: f4ad8f2c4076 ("LSM: Infrastructure management of the task security")
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 992b612c819a..3664fb9d5cf7 100644
--- a/security/security.c
+++ b/security/security.c
@@ -530,7 +530,7 @@ int lsm_inode_alloc(struct inode *inode)
  *
  * Returns 0, or -ENOMEM if memory can't be allocated.
  */
-int lsm_task_alloc(struct task_struct *task)
+static int lsm_task_alloc(struct task_struct *task)
 {
 	if (blob_sizes.lbs_task == 0) {
 		task->security = NULL;
@@ -551,7 +551,7 @@ int lsm_task_alloc(struct task_struct *task)
  *
  * Returns 0, or -ENOMEM if memory can't be allocated.
  */
-int lsm_ipc_alloc(struct kern_ipc_perm *kip)
+static int lsm_ipc_alloc(struct kern_ipc_perm *kip)
 {
 	if (blob_sizes.lbs_ipc == 0) {
 		kip->security = NULL;
@@ -572,7 +572,7 @@ int lsm_ipc_alloc(struct kern_ipc_perm *kip)
  *
  * Returns 0, or -ENOMEM if memory can't be allocated.
  */
-int lsm_msg_msg_alloc(struct msg_msg *mp)
+static int lsm_msg_msg_alloc(struct msg_msg *mp)
 {
 	if (blob_sizes.lbs_msg_msg == 0) {
 		mp->security = NULL;

commit 1cfb2a512e74e577bb0ed7c8d76df90a41a83f6a
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Fri Jan 18 19:15:59 2019 +0900

    LSM: Make lsm_early_cred() and lsm_early_task() local functions.
    
    Since current->cred == current->real_cred when ordered_lsm_init()
    is called, and lsm_early_cred()/lsm_early_task() need to be called
    between the amount of required bytes is determined and module specific
    initialization function is called, we can move these calls from
    individual modules to ordered_lsm_init().
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index a618e22df5c6..992b612c819a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -278,6 +278,9 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 	kfree(sep);
 }
 
+static void __init lsm_early_cred(struct cred *cred);
+static void __init lsm_early_task(struct task_struct *task);
+
 static void __init ordered_lsm_init(void)
 {
 	struct lsm_info **lsm;
@@ -312,6 +315,8 @@ static void __init ordered_lsm_init(void)
 						    blob_sizes.lbs_inode, 0,
 						    SLAB_PANIC, NULL);
 
+	lsm_early_cred((struct cred *) current->cred);
+	lsm_early_task(current);
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		initialize_lsm(*lsm);
 
@@ -465,17 +470,12 @@ static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)
  * lsm_early_cred - during initialization allocate a composite cred blob
  * @cred: the cred that needs a blob
  *
- * Allocate the cred blob for all the modules if it's not already there
+ * Allocate the cred blob for all the modules
  */
-void __init lsm_early_cred(struct cred *cred)
+static void __init lsm_early_cred(struct cred *cred)
 {
-	int rc;
+	int rc = lsm_cred_alloc(cred, GFP_KERNEL);
 
-	if (cred == NULL)
-		panic("%s: NULL cred.\n", __func__);
-	if (cred->security != NULL)
-		return;
-	rc = lsm_cred_alloc(cred, GFP_KERNEL);
 	if (rc)
 		panic("%s: Early cred alloc failed.\n", __func__);
 }
@@ -589,17 +589,12 @@ int lsm_msg_msg_alloc(struct msg_msg *mp)
  * lsm_early_task - during initialization allocate a composite task blob
  * @task: the task that needs a blob
  *
- * Allocate the task blob for all the modules if it's not already there
+ * Allocate the task blob for all the modules
  */
-void __init lsm_early_task(struct task_struct *task)
+static void __init lsm_early_task(struct task_struct *task)
 {
-	int rc;
+	int rc = lsm_task_alloc(task);
 
-	if (task == NULL)
-		panic("%s: task cred.\n", __func__);
-	if (task->security != NULL)
-		return;
-	rc = lsm_task_alloc(task);
 	if (rc)
 		panic("%s: Early task alloc failed.\n", __func__);
 }

commit a5795fd38ee8194451ba3f281f075301a3696ce2
Author: James Morris <james.morris@microsoft.com>
Date:   Wed Jan 16 15:41:11 2019 -0800

    LSM: Check for NULL cred-security on free
    
    From: Casey Schaufler <casey@schaufler-ca.com>
    
    Check that the cred security blob has been set before trying
    to clean it up. There is a case during credential initialization
    that could result in this.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>
    Reported-by: syzbot+69ca07954461f189e808@syzkaller.appspotmail.com

diff --git a/security/security.c b/security/security.c
index f1b8d2587639..55bc49027ba9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1027,6 +1027,13 @@ int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 
 void security_cred_free(struct cred *cred)
 {
+	/*
+	 * There is a failure case in prepare_creds() that
+	 * may result in a call here with ->security being NULL.
+	 */
+	if (unlikely(cred->security == NULL))
+		return;
+
 	call_void_hook(cred_free, cred);
 }
 

commit c1a85a00ea66cb6f0bd0f14e47c28c2b0999799f
Author: Micah Morton <mortonm@chromium.org>
Date:   Mon Jan 7 16:10:53 2019 -0800

    LSM: generalize flag passing to security_capable
    
    This patch provides a general mechanism for passing flags to the
    security_capable LSM hook. It replaces the specific 'audit' flag that is
    used to tell security_capable whether it should log an audit message for
    the given capability check. The reason for generalizing this flag
    passing is so we can add an additional flag that signifies whether
    security_capable is being called by a setid syscall (which is needed by
    the proposed SafeSetID LSM).
    
    Signed-off-by: Micah Morton <mortonm@chromium.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 953fc3ea18a9..a618e22df5c6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -689,16 +689,12 @@ int security_capset(struct cred *new, const struct cred *old,
 				effective, inheritable, permitted);
 }
 
-int security_capable(const struct cred *cred, struct user_namespace *ns,
-		     int cap)
+int security_capable(const struct cred *cred,
+		     struct user_namespace *ns,
+		     int cap,
+		     unsigned int opts)
 {
-	return call_int_hook(capable, 0, cred, ns, cap, SECURITY_CAP_AUDIT);
-}
-
-int security_capable_noaudit(const struct cred *cred, struct user_namespace *ns,
-			     int cap)
-{
-	return call_int_hook(capable, 0, cred, ns, cap, SECURITY_CAP_NOAUDIT);
+	return call_int_hook(capable, 0, cred, ns, cap, opts);
 }
 
 int security_quotactl(int cmds, int type, int id, struct super_block *sb)

commit ecd5f82e05ddd9b06c258167ec7467ac79741d77
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Tue Nov 20 11:55:02 2018 -0800

    LSM: Infrastructure management of the ipc security blob
    
    Move management of the kern_ipc_perm->security and
    msg_msg->security blobs out of the individual security
    modules and into the security infrastructure. Instead
    of allocating the blobs from within the modules the modules
    tell the infrastructure how much space is required, and
    the space is allocated there.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index e59a1e1514ee..953fc3ea18a9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -30,6 +30,7 @@
 #include <linux/personality.h>
 #include <linux/backing-dev.h>
 #include <linux/string.h>
+#include <linux/msg.h>
 #include <net/flow.h>
 
 #define MAX_LSM_EVM_XATTR	2
@@ -169,6 +170,8 @@ static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
 	if (needed->lbs_inode && blob_sizes.lbs_inode == 0)
 		blob_sizes.lbs_inode = sizeof(struct rcu_head);
 	lsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);
+	lsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);
+	lsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);
 	lsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);
 }
 
@@ -293,6 +296,8 @@ static void __init ordered_lsm_init(void)
 	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
 	init_debug("file blob size     = %d\n", blob_sizes.lbs_file);
 	init_debug("inode blob size    = %d\n", blob_sizes.lbs_inode);
+	init_debug("ipc blob size      = %d\n", blob_sizes.lbs_ipc);
+	init_debug("msg_msg blob size  = %d\n", blob_sizes.lbs_msg_msg);
 	init_debug("task blob size     = %d\n", blob_sizes.lbs_task);
 
 	/*
@@ -538,6 +543,48 @@ int lsm_task_alloc(struct task_struct *task)
 	return 0;
 }
 
+/**
+ * lsm_ipc_alloc - allocate a composite ipc blob
+ * @kip: the ipc that needs a blob
+ *
+ * Allocate the ipc blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+int lsm_ipc_alloc(struct kern_ipc_perm *kip)
+{
+	if (blob_sizes.lbs_ipc == 0) {
+		kip->security = NULL;
+		return 0;
+	}
+
+	kip->security = kzalloc(blob_sizes.lbs_ipc, GFP_KERNEL);
+	if (kip->security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+/**
+ * lsm_msg_msg_alloc - allocate a composite msg_msg blob
+ * @mp: the msg_msg that needs a blob
+ *
+ * Allocate the ipc blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+int lsm_msg_msg_alloc(struct msg_msg *mp)
+{
+	if (blob_sizes.lbs_msg_msg == 0) {
+		mp->security = NULL;
+		return 0;
+	}
+
+	mp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);
+	if (mp->security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
 /**
  * lsm_early_task - during initialization allocate a composite task blob
  * @task: the task that needs a blob
@@ -1631,22 +1678,40 @@ void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
 
 int security_msg_msg_alloc(struct msg_msg *msg)
 {
-	return call_int_hook(msg_msg_alloc_security, 0, msg);
+	int rc = lsm_msg_msg_alloc(msg);
+
+	if (unlikely(rc))
+		return rc;
+	rc = call_int_hook(msg_msg_alloc_security, 0, msg);
+	if (unlikely(rc))
+		security_msg_msg_free(msg);
+	return rc;
 }
 
 void security_msg_msg_free(struct msg_msg *msg)
 {
 	call_void_hook(msg_msg_free_security, msg);
+	kfree(msg->security);
+	msg->security = NULL;
 }
 
 int security_msg_queue_alloc(struct kern_ipc_perm *msq)
 {
-	return call_int_hook(msg_queue_alloc_security, 0, msq);
+	int rc = lsm_ipc_alloc(msq);
+
+	if (unlikely(rc))
+		return rc;
+	rc = call_int_hook(msg_queue_alloc_security, 0, msq);
+	if (unlikely(rc))
+		security_msg_queue_free(msq);
+	return rc;
 }
 
 void security_msg_queue_free(struct kern_ipc_perm *msq)
 {
 	call_void_hook(msg_queue_free_security, msq);
+	kfree(msq->security);
+	msq->security = NULL;
 }
 
 int security_msg_queue_associate(struct kern_ipc_perm *msq, int msqflg)
@@ -1673,12 +1738,21 @@ int security_msg_queue_msgrcv(struct kern_ipc_perm *msq, struct msg_msg *msg,
 
 int security_shm_alloc(struct kern_ipc_perm *shp)
 {
-	return call_int_hook(shm_alloc_security, 0, shp);
+	int rc = lsm_ipc_alloc(shp);
+
+	if (unlikely(rc))
+		return rc;
+	rc = call_int_hook(shm_alloc_security, 0, shp);
+	if (unlikely(rc))
+		security_shm_free(shp);
+	return rc;
 }
 
 void security_shm_free(struct kern_ipc_perm *shp)
 {
 	call_void_hook(shm_free_security, shp);
+	kfree(shp->security);
+	shp->security = NULL;
 }
 
 int security_shm_associate(struct kern_ipc_perm *shp, int shmflg)
@@ -1698,12 +1772,21 @@ int security_shm_shmat(struct kern_ipc_perm *shp, char __user *shmaddr, int shmf
 
 int security_sem_alloc(struct kern_ipc_perm *sma)
 {
-	return call_int_hook(sem_alloc_security, 0, sma);
+	int rc = lsm_ipc_alloc(sma);
+
+	if (unlikely(rc))
+		return rc;
+	rc = call_int_hook(sem_alloc_security, 0, sma);
+	if (unlikely(rc))
+		security_sem_free(sma);
+	return rc;
 }
 
 void security_sem_free(struct kern_ipc_perm *sma)
 {
 	call_void_hook(sem_free_security, sma);
+	kfree(sma->security);
+	sma->security = NULL;
 }
 
 int security_sem_associate(struct kern_ipc_perm *sma, int semflg)

commit f4ad8f2c40769b3cc9497ba0883bbaf823f7752f
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Sep 21 17:19:37 2018 -0700

    LSM: Infrastructure management of the task security
    
    Move management of the task_struct->security blob out
    of the individual security modules and into the security
    infrastructure. Instead of allocating the blobs from within
    the modules the modules tell the infrastructure how much
    space is required, and the space is allocated there.
    The only user of this blob is AppArmor. The AppArmor use
    is abstracted to avoid future conflict.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 4989fb65e662..e59a1e1514ee 100644
--- a/security/security.c
+++ b/security/security.c
@@ -169,6 +169,7 @@ static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
 	if (needed->lbs_inode && blob_sizes.lbs_inode == 0)
 		blob_sizes.lbs_inode = sizeof(struct rcu_head);
 	lsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);
+	lsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);
 }
 
 /* Prepare LSM for initialization. */
@@ -292,6 +293,7 @@ static void __init ordered_lsm_init(void)
 	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
 	init_debug("file blob size     = %d\n", blob_sizes.lbs_file);
 	init_debug("inode blob size    = %d\n", blob_sizes.lbs_inode);
+	init_debug("task blob size     = %d\n", blob_sizes.lbs_task);
 
 	/*
 	 * Create any kmem_caches needed for blobs
@@ -515,6 +517,46 @@ int lsm_inode_alloc(struct inode *inode)
 	return 0;
 }
 
+/**
+ * lsm_task_alloc - allocate a composite task blob
+ * @task: the task that needs a blob
+ *
+ * Allocate the task blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+int lsm_task_alloc(struct task_struct *task)
+{
+	if (blob_sizes.lbs_task == 0) {
+		task->security = NULL;
+		return 0;
+	}
+
+	task->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);
+	if (task->security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+/**
+ * lsm_early_task - during initialization allocate a composite task blob
+ * @task: the task that needs a blob
+ *
+ * Allocate the task blob for all the modules if it's not already there
+ */
+void __init lsm_early_task(struct task_struct *task)
+{
+	int rc;
+
+	if (task == NULL)
+		panic("%s: task cred.\n", __func__);
+	if (task->security != NULL)
+		return;
+	rc = lsm_task_alloc(task);
+	if (rc)
+		panic("%s: Early task alloc failed.\n", __func__);
+}
+
 /*
  * Hook list operation macros.
  *
@@ -1359,12 +1401,22 @@ int security_file_open(struct file *file)
 
 int security_task_alloc(struct task_struct *task, unsigned long clone_flags)
 {
-	return call_int_hook(task_alloc, 0, task, clone_flags);
+	int rc = lsm_task_alloc(task);
+
+	if (rc)
+		return rc;
+	rc = call_int_hook(task_alloc, 0, task, clone_flags);
+	if (unlikely(rc))
+		security_task_free(task);
+	return rc;
 }
 
 void security_task_free(struct task_struct *task)
 {
 	call_void_hook(task_free, task);
+
+	kfree(task->security);
+	task->security = NULL;
 }
 
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)

commit afb1cbe37440c7f38b9cf46fc331cc9dfd5cce21
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Sep 21 17:19:29 2018 -0700

    LSM: Infrastructure management of the inode security
    
    Move management of the inode->i_security blob out
    of the individual security modules and into the security
    infrastructure. Instead of allocating the blobs from within
    the modules the modules tell the infrastructure how much
    space is required, and the space is allocated there.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index f32d7d2075c6..4989fb65e662 100644
--- a/security/security.c
+++ b/security/security.c
@@ -41,6 +41,7 @@ struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
 
 static struct kmem_cache *lsm_file_cache;
+static struct kmem_cache *lsm_inode_cache;
 
 char *lsm_names;
 static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;
@@ -161,6 +162,13 @@ static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
 
 	lsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);
 	lsm_set_blob_size(&needed->lbs_file, &blob_sizes.lbs_file);
+	/*
+	 * The inode blob gets an rcu_head in addition to
+	 * what the modules might need.
+	 */
+	if (needed->lbs_inode && blob_sizes.lbs_inode == 0)
+		blob_sizes.lbs_inode = sizeof(struct rcu_head);
+	lsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);
 }
 
 /* Prepare LSM for initialization. */
@@ -283,6 +291,7 @@ static void __init ordered_lsm_init(void)
 
 	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
 	init_debug("file blob size     = %d\n", blob_sizes.lbs_file);
+	init_debug("inode blob size    = %d\n", blob_sizes.lbs_inode);
 
 	/*
 	 * Create any kmem_caches needed for blobs
@@ -291,6 +300,10 @@ static void __init ordered_lsm_init(void)
 		lsm_file_cache = kmem_cache_create("lsm_file_cache",
 						   blob_sizes.lbs_file, 0,
 						   SLAB_PANIC, NULL);
+	if (blob_sizes.lbs_inode)
+		lsm_inode_cache = kmem_cache_create("lsm_inode_cache",
+						    blob_sizes.lbs_inode, 0,
+						    SLAB_PANIC, NULL);
 
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		initialize_lsm(*lsm);
@@ -481,6 +494,27 @@ static int lsm_file_alloc(struct file *file)
 	return 0;
 }
 
+/**
+ * lsm_inode_alloc - allocate a composite inode blob
+ * @inode: the inode that needs a blob
+ *
+ * Allocate the inode blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+int lsm_inode_alloc(struct inode *inode)
+{
+	if (!lsm_inode_cache) {
+		inode->i_security = NULL;
+		return 0;
+	}
+
+	inode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);
+	if (inode->i_security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
 /*
  * Hook list operation macros.
  *
@@ -740,14 +774,40 @@ EXPORT_SYMBOL(security_add_mnt_opt);
 
 int security_inode_alloc(struct inode *inode)
 {
-	inode->i_security = NULL;
-	return call_int_hook(inode_alloc_security, 0, inode);
+	int rc = lsm_inode_alloc(inode);
+
+	if (unlikely(rc))
+		return rc;
+	rc = call_int_hook(inode_alloc_security, 0, inode);
+	if (unlikely(rc))
+		security_inode_free(inode);
+	return rc;
+}
+
+static void inode_free_by_rcu(struct rcu_head *head)
+{
+	/*
+	 * The rcu head is at the start of the inode blob
+	 */
+	kmem_cache_free(lsm_inode_cache, head);
 }
 
 void security_inode_free(struct inode *inode)
 {
 	integrity_inode_free(inode);
 	call_void_hook(inode_free_security, inode);
+	/*
+	 * The inode may still be referenced in a path walk and
+	 * a call to security_inode_permission() can be made
+	 * after inode_free_security() is called. Ideally, the VFS
+	 * wouldn't do this, but fixing that is a much harder
+	 * job. For now, simply free the i_security via RCU, and
+	 * leave the current inode->i_security pointer intact.
+	 * The inode will be freed after the RCU grace period too.
+	 */
+	if (inode->i_security)
+		call_rcu((struct rcu_head *)inode->i_security,
+				inode_free_by_rcu);
 }
 
 int security_dentry_init_security(struct dentry *dentry, int mode,

commit 33bf60cabcc7687b194a689b068b65e9ecd556be
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Nov 12 12:02:49 2018 -0800

    LSM: Infrastructure management of the file security
    
    Move management of the file->f_security blob out of the
    individual security modules and into the infrastructure.
    The modules no longer allocate or free the data, instead
    they tell the infrastructure how much space they require.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 09be8ce007a2..f32d7d2075c6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -40,6 +40,8 @@
 struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
 
+static struct kmem_cache *lsm_file_cache;
+
 char *lsm_names;
 static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;
 
@@ -158,6 +160,7 @@ static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
 		return;
 
 	lsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);
+	lsm_set_blob_size(&needed->lbs_file, &blob_sizes.lbs_file);
 }
 
 /* Prepare LSM for initialization. */
@@ -279,6 +282,15 @@ static void __init ordered_lsm_init(void)
 		prepare_lsm(*lsm);
 
 	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
+	init_debug("file blob size     = %d\n", blob_sizes.lbs_file);
+
+	/*
+	 * Create any kmem_caches needed for blobs
+	 */
+	if (blob_sizes.lbs_file)
+		lsm_file_cache = kmem_cache_create("lsm_file_cache",
+						   blob_sizes.lbs_file, 0,
+						   SLAB_PANIC, NULL);
 
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		initialize_lsm(*lsm);
@@ -448,6 +460,27 @@ void __init lsm_early_cred(struct cred *cred)
 		panic("%s: Early cred alloc failed.\n", __func__);
 }
 
+/**
+ * lsm_file_alloc - allocate a composite file blob
+ * @file: the file that needs a blob
+ *
+ * Allocate the file blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+static int lsm_file_alloc(struct file *file)
+{
+	if (!lsm_file_cache) {
+		file->f_security = NULL;
+		return 0;
+	}
+
+	file->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);
+	if (file->f_security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
 /*
  * Hook list operation macros.
  *
@@ -1144,12 +1177,27 @@ int security_file_permission(struct file *file, int mask)
 
 int security_file_alloc(struct file *file)
 {
-	return call_int_hook(file_alloc_security, 0, file);
+	int rc = lsm_file_alloc(file);
+
+	if (rc)
+		return rc;
+	rc = call_int_hook(file_alloc_security, 0, file);
+	if (unlikely(rc))
+		security_file_free(file);
+	return rc;
 }
 
 void security_file_free(struct file *file)
 {
+	void *blob;
+
 	call_void_hook(file_free_security, file);
+
+	blob = file->f_security;
+	if (blob) {
+		file->f_security = NULL;
+		kmem_cache_free(lsm_file_cache, blob);
+	}
 }
 
 int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
@@ -1267,7 +1315,7 @@ int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 		return rc;
 
 	rc = call_int_hook(cred_alloc_blank, 0, cred, gfp);
-	if (rc)
+	if (unlikely(rc))
 		security_cred_free(cred);
 	return rc;
 }
@@ -1288,7 +1336,7 @@ int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
 		return rc;
 
 	rc = call_int_hook(cred_prepare, 0, new, old, gfp);
-	if (rc)
+	if (unlikely(rc))
 		security_cred_free(new);
 	return rc;
 }

commit bbd3662a834813730912a58efb44dd6df6d952e6
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Nov 12 09:30:56 2018 -0800

    Infrastructure management of the cred security blob
    
    Move management of the cred security blob out of the
    security modules and into the security infrastructre.
    Instead of allocating and freeing space the security
    modules tell the infrastructure how much space they
    require.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    [kees: adjusted for ordered init series]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 60b39db95c2f..09be8ce007a2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -41,6 +41,8 @@ struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
 
 char *lsm_names;
+static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;
+
 /* Boot-time LSM user choice */
 static __initdata const char *chosen_lsm_order;
 static __initdata const char *chosen_major_lsm;
@@ -139,6 +141,25 @@ static bool __init lsm_allowed(struct lsm_info *lsm)
 	return true;
 }
 
+static void __init lsm_set_blob_size(int *need, int *lbs)
+{
+	int offset;
+
+	if (*need > 0) {
+		offset = *lbs;
+		*lbs += *need;
+		*need = offset;
+	}
+}
+
+static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)
+{
+	if (!needed)
+		return;
+
+	lsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);
+}
+
 /* Prepare LSM for initialization. */
 static void __init prepare_lsm(struct lsm_info *lsm)
 {
@@ -153,6 +174,8 @@ static void __init prepare_lsm(struct lsm_info *lsm)
 			exclusive = lsm;
 			init_debug("exclusive chosen: %s\n", lsm->name);
 		}
+
+		lsm_set_blob_sizes(lsm->blobs);
 	}
 }
 
@@ -255,6 +278,8 @@ static void __init ordered_lsm_init(void)
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		prepare_lsm(*lsm);
 
+	init_debug("cred blob size     = %d\n", blob_sizes.lbs_cred);
+
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		initialize_lsm(*lsm);
 
@@ -382,6 +407,47 @@ int unregister_lsm_notifier(struct notifier_block *nb)
 }
 EXPORT_SYMBOL(unregister_lsm_notifier);
 
+/**
+ * lsm_cred_alloc - allocate a composite cred blob
+ * @cred: the cred that needs a blob
+ * @gfp: allocation type
+ *
+ * Allocate the cred blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)
+{
+	if (blob_sizes.lbs_cred == 0) {
+		cred->security = NULL;
+		return 0;
+	}
+
+	cred->security = kzalloc(blob_sizes.lbs_cred, gfp);
+	if (cred->security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+/**
+ * lsm_early_cred - during initialization allocate a composite cred blob
+ * @cred: the cred that needs a blob
+ *
+ * Allocate the cred blob for all the modules if it's not already there
+ */
+void __init lsm_early_cred(struct cred *cred)
+{
+	int rc;
+
+	if (cred == NULL)
+		panic("%s: NULL cred.\n", __func__);
+	if (cred->security != NULL)
+		return;
+	rc = lsm_cred_alloc(cred, GFP_KERNEL);
+	if (rc)
+		panic("%s: Early cred alloc failed.\n", __func__);
+}
+
 /*
  * Hook list operation macros.
  *
@@ -1195,17 +1261,36 @@ void security_task_free(struct task_struct *task)
 
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
-	return call_int_hook(cred_alloc_blank, 0, cred, gfp);
+	int rc = lsm_cred_alloc(cred, gfp);
+
+	if (rc)
+		return rc;
+
+	rc = call_int_hook(cred_alloc_blank, 0, cred, gfp);
+	if (rc)
+		security_cred_free(cred);
+	return rc;
 }
 
 void security_cred_free(struct cred *cred)
 {
 	call_void_hook(cred_free, cred);
+
+	kfree(cred->security);
+	cred->security = NULL;
 }
 
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
 {
-	return call_int_hook(cred_prepare, 0, new, old, gfp);
+	int rc = lsm_cred_alloc(new, gfp);
+
+	if (rc)
+		return rc;
+
+	rc = call_int_hook(cred_prepare, 0, new, old, gfp);
+	if (rc)
+		security_cred_free(new);
+	return rc;
 }
 
 void security_transfer_creds(struct cred *new, const struct cred *old)

commit 6d9c939dbe4d0bcea09cd4b410f624cde1acb678
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Fri Sep 21 17:16:59 2018 -0700

    procfs: add smack subdir to attrs
    
    Back in 2007 I made what turned out to be a rather serious
    mistake in the implementation of the Smack security module.
    The SELinux module used an interface in /proc to manipulate
    the security context on processes. Rather than use a similar
    interface, I used the same interface. The AppArmor team did
    likewise. Now /proc/.../attr/current will tell you the
    security "context" of the process, but it will be different
    depending on the security module you're using.
    
    This patch provides a subdirectory in /proc/.../attr for
    Smack. Smack user space can use the "current" file in
    this subdirectory and never have to worry about getting
    SELinux attributes by mistake. Programs that use the
    old interface will continue to work (or fail, as the case
    may be) as before.
    
    The proposed S.A.R.A security module is dependent on
    the mechanism to create its own attr subdirectory.
    
    The original implementation is by Kees Cook.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 9411f659454b..60b39db95c2f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1485,14 +1485,30 @@ void security_d_instantiate(struct dentry *dentry, struct inode *inode)
 }
 EXPORT_SYMBOL(security_d_instantiate);
 
-int security_getprocattr(struct task_struct *p, char *name, char **value)
+int security_getprocattr(struct task_struct *p, const char *lsm, char *name,
+				char **value)
 {
-	return call_int_hook(getprocattr, -EINVAL, p, name, value);
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.getprocattr, list) {
+		if (lsm != NULL && strcmp(lsm, hp->lsm))
+			continue;
+		return hp->hook.getprocattr(p, name, value);
+	}
+	return -EINVAL;
 }
 
-int security_setprocattr(const char *name, void *value, size_t size)
+int security_setprocattr(const char *lsm, const char *name, void *value,
+			 size_t size)
 {
-	return call_int_hook(setprocattr, -EINVAL, name, value, size);
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.setprocattr, list) {
+		if (lsm != NULL && strcmp(lsm, hp->lsm))
+			continue;
+		return hp->hook.setprocattr(name, value, size);
+	}
+	return -EINVAL;
 }
 
 int security_netlink_send(struct sock *sk, struct sk_buff *skb)

commit d117a154e6128abac5409d3f173584e7b25981a2
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Sep 14 15:40:45 2018 -0700

    capability: Initialize as LSM_ORDER_FIRST
    
    This converts capabilities to use the new LSM_ORDER_FIRST position.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/security.c b/security/security.c
index 8b673bb2a0dd..9411f659454b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -277,11 +277,6 @@ int __init security_init(void)
 	     i++)
 		INIT_HLIST_HEAD(&list[i]);
 
-	/*
-	 * Load minor LSMs, with the capability module always first.
-	 */
-	capability_add_hooks();
-
 	/* Load LSMs in specified order. */
 	ordered_lsm_init();
 

commit e2bc445b66cad25b0627391df8138a83d0e48f97
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Sep 19 17:48:21 2018 -0700

    LSM: Introduce enum lsm_order
    
    In preparation for distinguishing the "capability" LSM from other LSMs, it
    must be ordered first. This introduces LSM_ORDER_MUTABLE for the general
    LSMs and LSM_ORDER_FIRST for capability. In the future LSM_ORDER_LAST
    for could be added for anything that must run last (e.g. Landlock may
    use this).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 35f93b7c585b..8b673bb2a0dd 100644
--- a/security/security.c
+++ b/security/security.c
@@ -174,6 +174,12 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 	struct lsm_info *lsm;
 	char *sep, *name, *next;
 
+	/* LSM_ORDER_FIRST is always first. */
+	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
+		if (lsm->order == LSM_ORDER_FIRST)
+			append_ordered_lsm(lsm, "first");
+	}
+
 	/* Process "security=", if given. */
 	if (chosen_major_lsm) {
 		struct lsm_info *major;
@@ -202,7 +208,8 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 		bool found = false;
 
 		for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
-			if (strcmp(lsm->name, name) == 0) {
+			if (lsm->order == LSM_ORDER_MUTABLE &&
+			    strcmp(lsm->name, name) == 0) {
 				append_ordered_lsm(lsm, origin);
 				found = true;
 			}

commit d6aed64b74b73b64278c059eacd59d87167aa968
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Sep 14 15:37:20 2018 -0700

    Yama: Initialize as ordered LSM
    
    This converts Yama from being a direct "minor" LSM into an ordered LSM.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/security.c b/security/security.c
index b8d75f5a948d..35f93b7c585b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -274,7 +274,6 @@ int __init security_init(void)
 	 * Load minor LSMs, with the capability module always first.
 	 */
 	capability_add_hooks();
-	yama_add_hooks();
 
 	/* Load LSMs in specified order. */
 	ordered_lsm_init();

commit 70b62c25665f636c9f6c700b26af7df296b0887e
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Sep 14 15:26:37 2018 -0700

    LoadPin: Initialize as ordered LSM
    
    This converts LoadPin from being a direct "minor" LSM into an ordered LSM.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/security.c b/security/security.c
index 46c5b0fa515e..b8d75f5a948d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -275,7 +275,6 @@ int __init security_init(void)
 	 */
 	capability_add_hooks();
 	yama_add_hooks();
-	loadpin_add_hooks();
 
 	/* Load LSMs in specified order. */
 	ordered_lsm_init();

commit d8e9bbd4fa7f654bd877a312fc4104c6e5e5c6ca
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 10 15:45:22 2018 -0700

    LSM: Split LSM preparation from initialization
    
    Since we already have to do a pass through the LSMs to figure out if
    exclusive LSMs should be disabled after the first one is seen as enabled,
    this splits the logic up a bit more cleanly. Now we do a full "prepare"
    pass through the LSMs (which also allows for later use by the blob-sharing
    code), before starting the LSM initialization pass.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 2d08a5357bf4..46c5b0fa515e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -139,22 +139,28 @@ static bool __init lsm_allowed(struct lsm_info *lsm)
 	return true;
 }
 
-/* Check if LSM should be initialized. */
-static void __init maybe_initialize_lsm(struct lsm_info *lsm)
+/* Prepare LSM for initialization. */
+static void __init prepare_lsm(struct lsm_info *lsm)
 {
 	int enabled = lsm_allowed(lsm);
 
 	/* Record enablement (to handle any following exclusive LSMs). */
 	set_enabled(lsm, enabled);
 
-	/* If selected, initialize the LSM. */
+	/* If enabled, do pre-initialization work. */
 	if (enabled) {
-		int ret;
-
 		if ((lsm->flags & LSM_FLAG_EXCLUSIVE) && !exclusive) {
 			exclusive = lsm;
 			init_debug("exclusive chosen: %s\n", lsm->name);
 		}
+	}
+}
+
+/* Initialize a given LSM, if it is enabled. */
+static void __init initialize_lsm(struct lsm_info *lsm)
+{
+	if (is_enabled(lsm)) {
+		int ret;
 
 		init_debug("initializing %s\n", lsm->name);
 		ret = lsm->init();
@@ -240,7 +246,10 @@ static void __init ordered_lsm_init(void)
 		ordered_lsm_parse(builtin_lsm_order, "builtin");
 
 	for (lsm = ordered_lsms; *lsm; lsm++)
-		maybe_initialize_lsm(*lsm);
+		prepare_lsm(*lsm);
+
+	for (lsm = ordered_lsms; *lsm; lsm++)
+		initialize_lsm(*lsm);
 
 	kfree(ordered_lsms);
 }

commit c91d8106b370593b4d3dcc0b06282bf39478ae13
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Mon Nov 19 18:04:32 2018 -0800

    LSM: Add all exclusive LSMs to ordered initialization
    
    This removes CONFIG_DEFAULT_SECURITY in favor of the explicit ordering
    offered by CONFIG_LSM and adds all the exclusive LSMs to the ordered
    LSM initialization. The old meaning of CONFIG_DEFAULT_SECURITY is now
    captured by which exclusive LSM is listed first in the LSM order. All
    LSMs not added to the ordered list are explicitly disabled.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/security.c b/security/security.c
index a8dd7defe30a..2d08a5357bf4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -169,8 +169,6 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 	char *sep, *name, *next;
 
 	/* Process "security=", if given. */
-	if (!chosen_major_lsm)
-		chosen_major_lsm = CONFIG_DEFAULT_SECURITY;
 	if (chosen_major_lsm) {
 		struct lsm_info *major;
 
@@ -198,8 +196,7 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 		bool found = false;
 
 		for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
-			if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) == 0 &&
-			    strcmp(lsm->name, name) == 0) {
+			if (strcmp(lsm->name, name) == 0) {
 				append_ordered_lsm(lsm, origin);
 				found = true;
 			}
@@ -208,6 +205,25 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 		if (!found)
 			init_debug("%s ignored: %s\n", origin, name);
 	}
+
+	/* Process "security=", if given. */
+	if (chosen_major_lsm) {
+		for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
+			if (exists_ordered_lsm(lsm))
+				continue;
+			if (strcmp(lsm->name, chosen_major_lsm) == 0)
+				append_ordered_lsm(lsm, "security=");
+		}
+	}
+
+	/* Disable all LSMs not in the ordered list. */
+	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
+		if (exists_ordered_lsm(lsm))
+			continue;
+		set_enabled(lsm, false);
+		init_debug("%s disabled: %s\n", origin, lsm->name);
+	}
+
 	kfree(sep);
 }
 
@@ -229,22 +245,6 @@ static void __init ordered_lsm_init(void)
 	kfree(ordered_lsms);
 }
 
-static void __init major_lsm_init(void)
-{
-	struct lsm_info *lsm;
-
-	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
-		if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) == 0)
-			continue;
-
-		/* Enable this LSM, if it is not already set. */
-		if (!lsm->enabled)
-			lsm->enabled = &lsm_enabled_true;
-
-		maybe_initialize_lsm(lsm);
-	}
-}
-
 /**
  * security_init - initializes the security framework
  *
@@ -271,11 +271,6 @@ int __init security_init(void)
 	/* Load LSMs in specified order. */
 	ordered_lsm_init();
 
-	/*
-	 * Load all the remaining security modules.
-	 */
-	major_lsm_init();
-
 	return 0;
 }
 

commit 14bd99c821f7ace0e8110a1bfdfaa27e1788e20f
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Sep 19 19:57:06 2018 -0700

    LSM: Separate idea of "major" LSM from "exclusive" LSM
    
    In order to both support old "security=" Legacy Major LSM selection, and
    handling real exclusivity, this creates LSM_FLAG_EXCLUSIVE and updates
    the selection logic to handle them.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/security.c b/security/security.c
index 88de6b073246..a8dd7defe30a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -49,6 +49,7 @@ static __initconst const char * const builtin_lsm_order = CONFIG_LSM;
 
 /* Ordered list of LSMs to initialize. */
 static __initdata struct lsm_info **ordered_lsms;
+static __initdata struct lsm_info *exclusive;
 
 static __initdata bool debug;
 #define init_debug(...)						\
@@ -129,6 +130,12 @@ static bool __init lsm_allowed(struct lsm_info *lsm)
 	if (!is_enabled(lsm))
 		return false;
 
+	/* Not allowed if another exclusive LSM already initialized. */
+	if ((lsm->flags & LSM_FLAG_EXCLUSIVE) && exclusive) {
+		init_debug("exclusive disabled: %s\n", lsm->name);
+		return false;
+	}
+
 	return true;
 }
 
@@ -144,6 +151,11 @@ static void __init maybe_initialize_lsm(struct lsm_info *lsm)
 	if (enabled) {
 		int ret;
 
+		if ((lsm->flags & LSM_FLAG_EXCLUSIVE) && !exclusive) {
+			exclusive = lsm;
+			init_debug("exclusive chosen: %s\n", lsm->name);
+		}
+
 		init_debug("initializing %s\n", lsm->name);
 		ret = lsm->init();
 		WARN(ret, "%s failed to initialize: %d\n", lsm->name, ret);

commit 7e611486d905f435faf80969deed68a615019e6b
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Sep 19 13:32:15 2018 -0700

    LSM: Refactor "security=" in terms of enable/disable
    
    For what are marked as the Legacy Major LSMs, make them effectively
    exclusive when selected on the "security=" boot parameter, to handle
    the future case of when a previously major LSMs become non-exclusive
    (e.g. when TOMOYO starts blob-sharing).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/security.c b/security/security.c
index 1e1f34285e96..88de6b073246 100644
--- a/security/security.c
+++ b/security/security.c
@@ -129,14 +129,6 @@ static bool __init lsm_allowed(struct lsm_info *lsm)
 	if (!is_enabled(lsm))
 		return false;
 
-	/* Skip major-specific checks if not a major LSM. */
-	if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) == 0)
-		return true;
-
-	/* Disabled if this LSM isn't the chosen one. */
-	if (strcmp(lsm->name, chosen_major_lsm) != 0)
-		return false;
-
 	return true;
 }
 
@@ -164,8 +156,28 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 	struct lsm_info *lsm;
 	char *sep, *name, *next;
 
+	/* Process "security=", if given. */
 	if (!chosen_major_lsm)
 		chosen_major_lsm = CONFIG_DEFAULT_SECURITY;
+	if (chosen_major_lsm) {
+		struct lsm_info *major;
+
+		/*
+		 * To match the original "security=" behavior, this
+		 * explicitly does NOT fallback to another Legacy Major
+		 * if the selected one was separately disabled: disable
+		 * all non-matching Legacy Major LSMs.
+		 */
+		for (major = __start_lsm_info; major < __end_lsm_info;
+		     major++) {
+			if ((major->flags & LSM_FLAG_LEGACY_MAJOR) &&
+			    strcmp(major->name, chosen_major_lsm) != 0) {
+				set_enabled(major, false);
+				init_debug("security=%s disabled: %s\n",
+					   chosen_major_lsm, major->name);
+			}
+		}
+	}
 
 	sep = kstrdup(order, GFP_KERNEL);
 	next = sep;

commit 5ef4e41918b2dffffa445d8d3a45f3dc257920dc
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Sep 19 13:11:41 2018 -0700

    LSM: Prepare for reorganizing "security=" logic
    
    This moves the string handling for "security=" boot parameter into
    a stored pointer instead of a string duplicate. This will allow
    easier handling of the string when switching logic to use the coming
    enable/disable infrastructure.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/security.c b/security/security.c
index b6d3456978a4..1e1f34285e96 100644
--- a/security/security.c
+++ b/security/security.c
@@ -34,9 +34,6 @@
 
 #define MAX_LSM_EVM_XATTR	2
 
-/* Maximum number of letters for an LSM name string */
-#define SECURITY_NAME_MAX	10
-
 /* How many LSMs were built into the kernel? */
 #define LSM_COUNT (__end_lsm_info - __start_lsm_info)
 
@@ -45,9 +42,8 @@ static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
 
 char *lsm_names;
 /* Boot-time LSM user choice */
-static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
-	CONFIG_DEFAULT_SECURITY;
 static __initdata const char *chosen_lsm_order;
+static __initdata const char *chosen_major_lsm;
 
 static __initconst const char * const builtin_lsm_order = CONFIG_LSM;
 
@@ -138,7 +134,7 @@ static bool __init lsm_allowed(struct lsm_info *lsm)
 		return true;
 
 	/* Disabled if this LSM isn't the chosen one. */
-	if (strcmp(lsm->name, chosen_lsm) != 0)
+	if (strcmp(lsm->name, chosen_major_lsm) != 0)
 		return false;
 
 	return true;
@@ -168,6 +164,9 @@ static void __init ordered_lsm_parse(const char *order, const char *origin)
 	struct lsm_info *lsm;
 	char *sep, *name, *next;
 
+	if (!chosen_major_lsm)
+		chosen_major_lsm = CONFIG_DEFAULT_SECURITY;
+
 	sep = kstrdup(order, GFP_KERNEL);
 	next = sep;
 	/* Walk the list, looking for matching LSMs. */
@@ -257,12 +256,12 @@ int __init security_init(void)
 }
 
 /* Save user chosen LSM */
-static int __init choose_lsm(char *str)
+static int __init choose_major_lsm(char *str)
 {
-	strncpy(chosen_lsm, str, SECURITY_NAME_MAX);
+	chosen_major_lsm = str;
 	return 1;
 }
-__setup("security=", choose_lsm);
+__setup("security=", choose_major_lsm);
 
 /* Explicitly choose LSM initialization order. */
 static int __init choose_lsm_order(char *str)

commit a8027fb0d188599ccdb2096f49f708bae04d86c4
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 9 14:42:57 2018 -0700

    LSM: Tie enabling logic to presence in ordered list
    
    Until now, any LSM without an enable storage variable was considered
    enabled. This inverts the logic and sets defaults to true only if the
    LSM gets added to the ordered initialization list. (And an exception
    continues for the major LSMs until they are integrated into the ordered
    initialization in a later patch.)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 2e1f48e8a6f2..b6d3456978a4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -63,10 +63,10 @@ static __initdata bool debug;
 
 static bool __init is_enabled(struct lsm_info *lsm)
 {
-	if (!lsm->enabled || *lsm->enabled)
-		return true;
+	if (!lsm->enabled)
+		return false;
 
-	return false;
+	return *lsm->enabled;
 }
 
 /* Mark an LSM's enabled flag. */
@@ -117,7 +117,11 @@ static void __init append_ordered_lsm(struct lsm_info *lsm, const char *from)
 	if (WARN(last_lsm == LSM_COUNT, "%s: out of LSM slots!?\n", from))
 		return;
 
+	/* Enable this LSM, if it is not already set. */
+	if (!lsm->enabled)
+		lsm->enabled = &lsm_enabled_true;
 	ordered_lsms[last_lsm++] = lsm;
+
 	init_debug("%s ordering: %s (%sabled)\n", from, lsm->name,
 		   is_enabled(lsm) ? "en" : "dis");
 }
@@ -210,6 +214,10 @@ static void __init major_lsm_init(void)
 		if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) == 0)
 			continue;
 
+		/* Enable this LSM, if it is not already set. */
+		if (!lsm->enabled)
+			lsm->enabled = &lsm_enabled_true;
+
 		maybe_initialize_lsm(lsm);
 	}
 }

commit 79f7865d844c7703e3dc0e2f5b9ed2f3a4f412e5
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Sep 19 17:30:09 2018 -0700

    LSM: Introduce "lsm=" for boottime LSM selection
    
    Provide a way to explicitly choose LSM initialization order via the new
    "lsm=" comma-separated list of LSMs.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 11a42cd313c5..2e1f48e8a6f2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -47,6 +47,7 @@ char *lsm_names;
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
+static __initdata const char *chosen_lsm_order;
 
 static __initconst const char * const builtin_lsm_order = CONFIG_LSM;
 
@@ -190,7 +191,10 @@ static void __init ordered_lsm_init(void)
 	ordered_lsms = kcalloc(LSM_COUNT + 1, sizeof(*ordered_lsms),
 				GFP_KERNEL);
 
-	ordered_lsm_parse(builtin_lsm_order, "builtin");
+	if (chosen_lsm_order)
+		ordered_lsm_parse(chosen_lsm_order, "cmdline");
+	else
+		ordered_lsm_parse(builtin_lsm_order, "builtin");
 
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		maybe_initialize_lsm(*lsm);
@@ -252,6 +256,14 @@ static int __init choose_lsm(char *str)
 }
 __setup("security=", choose_lsm);
 
+/* Explicitly choose LSM initialization order. */
+static int __init choose_lsm_order(char *str)
+{
+	chosen_lsm_order = str;
+	return 1;
+}
+__setup("lsm=", choose_lsm_order);
+
 /* Enable LSM order debugging. */
 static int __init enable_debug(char *str)
 {

commit 13e735c0e953246bd531d342bb86acb5b1bf664a
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 9 14:27:46 2018 -0700

    LSM: Introduce CONFIG_LSM
    
    This provides a way to declare LSM initialization order via the new
    CONFIG_LSM. Currently only non-major LSMs are recognized. This will
    be expanded in future patches.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 3a277fbf6023..11a42cd313c5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -48,6 +48,8 @@ char *lsm_names;
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
+static __initconst const char * const builtin_lsm_order = CONFIG_LSM;
+
 /* Ordered list of LSMs to initialize. */
 static __initdata struct lsm_info **ordered_lsms;
 
@@ -155,15 +157,30 @@ static void __init maybe_initialize_lsm(struct lsm_info *lsm)
 	}
 }
 
-/* Populate ordered LSMs list from single LSM name. */
+/* Populate ordered LSMs list from comma-separated LSM name list. */
 static void __init ordered_lsm_parse(const char *order, const char *origin)
 {
 	struct lsm_info *lsm;
+	char *sep, *name, *next;
+
+	sep = kstrdup(order, GFP_KERNEL);
+	next = sep;
+	/* Walk the list, looking for matching LSMs. */
+	while ((name = strsep(&next, ",")) != NULL) {
+		bool found = false;
+
+		for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
+			if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) == 0 &&
+			    strcmp(lsm->name, name) == 0) {
+				append_ordered_lsm(lsm, origin);
+				found = true;
+			}
+		}
 
-	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
-		if (strcmp(lsm->name, order) == 0)
-			append_ordered_lsm(lsm, origin);
+		if (!found)
+			init_debug("%s ignored: %s\n", origin, name);
 	}
+	kfree(sep);
 }
 
 static void __init ordered_lsm_init(void)
@@ -173,7 +190,7 @@ static void __init ordered_lsm_init(void)
 	ordered_lsms = kcalloc(LSM_COUNT + 1, sizeof(*ordered_lsms),
 				GFP_KERNEL);
 
-	ordered_lsm_parse("integrity", "builtin");
+	ordered_lsm_parse(builtin_lsm_order, "builtin");
 
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		maybe_initialize_lsm(*lsm);

commit 2d4d51198c730adbbc5e071b18c84e5d0d2d65df
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Sep 19 16:58:31 2018 -0700

    LSM: Build ordered list of LSMs to initialize
    
    This constructs an ordered list of LSMs to initialize, using a hard-coded
    list of only "integrity": minor LSMs continue to have direct hook calls,
    and major LSMs continue to initialize separately.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/security.c b/security/security.c
index c900d7a1441a..3a277fbf6023 100644
--- a/security/security.c
+++ b/security/security.c
@@ -37,6 +37,9 @@
 /* Maximum number of letters for an LSM name string */
 #define SECURITY_NAME_MAX	10
 
+/* How many LSMs were built into the kernel? */
+#define LSM_COUNT (__end_lsm_info - __start_lsm_info)
+
 struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
 
@@ -45,6 +48,9 @@ char *lsm_names;
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
+/* Ordered list of LSMs to initialize. */
+static __initdata struct lsm_info **ordered_lsms;
+
 static __initdata bool debug;
 #define init_debug(...)						\
 	do {							\
@@ -85,6 +91,34 @@ static void __init set_enabled(struct lsm_info *lsm, bool enabled)
 	}
 }
 
+/* Is an LSM already listed in the ordered LSMs list? */
+static bool __init exists_ordered_lsm(struct lsm_info *lsm)
+{
+	struct lsm_info **check;
+
+	for (check = ordered_lsms; *check; check++)
+		if (*check == lsm)
+			return true;
+
+	return false;
+}
+
+/* Append an LSM to the list of ordered LSMs to initialize. */
+static int last_lsm __initdata;
+static void __init append_ordered_lsm(struct lsm_info *lsm, const char *from)
+{
+	/* Ignore duplicate selections. */
+	if (exists_ordered_lsm(lsm))
+		return;
+
+	if (WARN(last_lsm == LSM_COUNT, "%s: out of LSM slots!?\n", from))
+		return;
+
+	ordered_lsms[last_lsm++] = lsm;
+	init_debug("%s ordering: %s (%sabled)\n", from, lsm->name,
+		   is_enabled(lsm) ? "en" : "dis");
+}
+
 /* Is an LSM allowed to be initialized? */
 static bool __init lsm_allowed(struct lsm_info *lsm)
 {
@@ -121,18 +155,32 @@ static void __init maybe_initialize_lsm(struct lsm_info *lsm)
 	}
 }
 
-static void __init ordered_lsm_init(void)
+/* Populate ordered LSMs list from single LSM name. */
+static void __init ordered_lsm_parse(const char *order, const char *origin)
 {
 	struct lsm_info *lsm;
 
 	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
-		if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) != 0)
-			continue;
-
-		maybe_initialize_lsm(lsm);
+		if (strcmp(lsm->name, order) == 0)
+			append_ordered_lsm(lsm, origin);
 	}
 }
 
+static void __init ordered_lsm_init(void)
+{
+	struct lsm_info **lsm;
+
+	ordered_lsms = kcalloc(LSM_COUNT + 1, sizeof(*ordered_lsms),
+				GFP_KERNEL);
+
+	ordered_lsm_parse("integrity", "builtin");
+
+	for (lsm = ordered_lsms; *lsm; lsm++)
+		maybe_initialize_lsm(*lsm);
+
+	kfree(ordered_lsms);
+}
+
 static void __init major_lsm_init(void)
 {
 	struct lsm_info *lsm;

commit f4941d75b9cba5e1fae1aebe0139dcca0703a294
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Sep 13 23:17:50 2018 -0700

    LSM: Lift LSM selection out of individual LSMs
    
    As a prerequisite to adjusting LSM selection logic in the future, this
    moves the selection logic up out of the individual major LSMs, making
    their init functions only run when actually enabled. This considers all
    LSMs enabled by default unless they specified an external "enable"
    variable.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/security.c b/security/security.c
index 6bc591f77b1a..c900d7a1441a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -52,33 +52,96 @@ static __initdata bool debug;
 			pr_info(__VA_ARGS__);			\
 	} while (0)
 
+static bool __init is_enabled(struct lsm_info *lsm)
+{
+	if (!lsm->enabled || *lsm->enabled)
+		return true;
+
+	return false;
+}
+
+/* Mark an LSM's enabled flag. */
+static int lsm_enabled_true __initdata = 1;
+static int lsm_enabled_false __initdata = 0;
+static void __init set_enabled(struct lsm_info *lsm, bool enabled)
+{
+	/*
+	 * When an LSM hasn't configured an enable variable, we can use
+	 * a hard-coded location for storing the default enabled state.
+	 */
+	if (!lsm->enabled) {
+		if (enabled)
+			lsm->enabled = &lsm_enabled_true;
+		else
+			lsm->enabled = &lsm_enabled_false;
+	} else if (lsm->enabled == &lsm_enabled_true) {
+		if (!enabled)
+			lsm->enabled = &lsm_enabled_false;
+	} else if (lsm->enabled == &lsm_enabled_false) {
+		if (enabled)
+			lsm->enabled = &lsm_enabled_true;
+	} else {
+		*lsm->enabled = enabled;
+	}
+}
+
+/* Is an LSM allowed to be initialized? */
+static bool __init lsm_allowed(struct lsm_info *lsm)
+{
+	/* Skip if the LSM is disabled. */
+	if (!is_enabled(lsm))
+		return false;
+
+	/* Skip major-specific checks if not a major LSM. */
+	if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) == 0)
+		return true;
+
+	/* Disabled if this LSM isn't the chosen one. */
+	if (strcmp(lsm->name, chosen_lsm) != 0)
+		return false;
+
+	return true;
+}
+
+/* Check if LSM should be initialized. */
+static void __init maybe_initialize_lsm(struct lsm_info *lsm)
+{
+	int enabled = lsm_allowed(lsm);
+
+	/* Record enablement (to handle any following exclusive LSMs). */
+	set_enabled(lsm, enabled);
+
+	/* If selected, initialize the LSM. */
+	if (enabled) {
+		int ret;
+
+		init_debug("initializing %s\n", lsm->name);
+		ret = lsm->init();
+		WARN(ret, "%s failed to initialize: %d\n", lsm->name, ret);
+	}
+}
+
 static void __init ordered_lsm_init(void)
 {
 	struct lsm_info *lsm;
-	int ret;
 
 	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
 		if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) != 0)
 			continue;
 
-		init_debug("initializing %s\n", lsm->name);
-		ret = lsm->init();
-		WARN(ret, "%s failed to initialize: %d\n", lsm->name, ret);
+		maybe_initialize_lsm(lsm);
 	}
 }
 
 static void __init major_lsm_init(void)
 {
 	struct lsm_info *lsm;
-	int ret;
 
 	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
 		if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) == 0)
 			continue;
 
-		init_debug("initializing %s\n", lsm->name);
-		ret = lsm->init();
-		WARN(ret, "%s failed to initialize: %d\n", lsm->name, ret);
+		maybe_initialize_lsm(lsm);
 	}
 }
 
@@ -168,29 +231,6 @@ static int lsm_append(char *new, char **result)
 	return 0;
 }
 
-/**
- * security_module_enable - Load given security module on boot ?
- * @module: the name of the module
- *
- * Each LSM must pass this method before registering its own operations
- * to avoid security registration races. This method may also be used
- * to check if your LSM is currently loaded during kernel initialization.
- *
- * Returns:
- *
- * true if:
- *
- * - The passed LSM is the one chosen by user at boot time,
- * - or the passed LSM is configured as the default and the user did not
- *   choose an alternate LSM at boot time.
- *
- * Otherwise, return false.
- */
-int __init security_module_enable(const char *module)
-{
-	return !strcmp(module, chosen_lsm);
-}
-
 /**
  * security_add_hooks - Add a modules hooks to the hook lists.
  * @hooks: the hooks to add

commit 657d910b52a38c5e0d753c2a5448c6ae26ec85d0
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Sep 19 16:16:55 2018 -0700

    LSM: Provide separate ordered initialization
    
    This provides a place for ordered LSMs to be initialized, separate from
    the "major" LSMs. This is mainly a copy/paste from major_lsm_init() to
    ordered_lsm_init(), but it will change drastically in later patches.
    
    What is not obvious in the patch is that this change moves the integrity
    LSM from major_lsm_init() into ordered_lsm_init(), since it is not marked
    with the LSM_FLAG_LEGACY_MAJOR. As it is the only LSM in the "ordered"
    list, there is no reordering yet created.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: John Johansen <john.johansen@canonical.com>

diff --git a/security/security.c b/security/security.c
index f1b8d2587639..6bc591f77b1a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -52,12 +52,30 @@ static __initdata bool debug;
 			pr_info(__VA_ARGS__);			\
 	} while (0)
 
+static void __init ordered_lsm_init(void)
+{
+	struct lsm_info *lsm;
+	int ret;
+
+	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
+		if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) != 0)
+			continue;
+
+		init_debug("initializing %s\n", lsm->name);
+		ret = lsm->init();
+		WARN(ret, "%s failed to initialize: %d\n", lsm->name, ret);
+	}
+}
+
 static void __init major_lsm_init(void)
 {
 	struct lsm_info *lsm;
 	int ret;
 
 	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
+		if ((lsm->flags & LSM_FLAG_LEGACY_MAJOR) == 0)
+			continue;
+
 		init_debug("initializing %s\n", lsm->name);
 		ret = lsm->init();
 		WARN(ret, "%s failed to initialize: %d\n", lsm->name, ret);
@@ -87,6 +105,9 @@ int __init security_init(void)
 	yama_add_hooks();
 	loadpin_add_hooks();
 
+	/* Load LSMs in specified order. */
+	ordered_lsm_init();
+
 	/*
 	 * Load all the remaining security modules.
 	 */

commit 505b050fdf42097883b2d37b8e796e1f11dbef50
Merge: 9b286efeb5eb 718c43038f28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 5 13:25:58 2019 -0800

    Merge branch 'mount.part1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount API prep from Al Viro:
     "Mount API prereqs.
    
      Mostly that's LSM mount options cleanups. There are several minor
      fixes in there, but nothing earth-shattering (leaks on failure exits,
      mostly)"
    
    * 'mount.part1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (27 commits)
      mount_fs: suppress MAC on MS_SUBMOUNT as well as MS_KERNMOUNT
      smack: rewrite smack_sb_eat_lsm_opts()
      smack: get rid of match_token()
      smack: take the guts of smack_parse_opts_str() into a new helper
      LSM: new method: ->sb_add_mnt_opt()
      selinux: rewrite selinux_sb_eat_lsm_opts()
      selinux: regularize Opt_... names a bit
      selinux: switch away from match_token()
      selinux: new helper - selinux_add_opt()
      LSM: bury struct security_mnt_opts
      smack: switch to private smack_mnt_opts
      selinux: switch to private struct selinux_mnt_opts
      LSM: hide struct security_mnt_opts from any generic code
      selinux: kill selinux_sb_get_mnt_opts()
      LSM: turn sb_eat_lsm_opts() into a method
      nfs_remount(): don't leak, don't ignore LSM options quietly
      btrfs: sanitize security_mnt_opts use
      selinux; don't open-code a loop in sb_finish_set_opts()
      LSM: split ->sb_set_mnt_opts() out of ->sb_kern_mount()
      new helper: security_sb_eat_lsm_opts()
      ...

commit 757cbe597fe8490c7c0a9650ebe5d60195f151d4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Dec 14 23:42:21 2018 -0500

    LSM: new method: ->sb_add_mnt_opt()
    
    Adding options to growing mnt_opts.  NFS kludge with passing
    context= down into non-text-options mount switched to it, and
    with that the last use of ->sb_parse_opts_str() is gone.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index b7a5a0051807..c251278b0297 100644
--- a/security/security.c
+++ b/security/security.c
@@ -458,11 +458,13 @@ int security_sb_clone_mnt_opts(const struct super_block *oldsb,
 }
 EXPORT_SYMBOL(security_sb_clone_mnt_opts);
 
-int security_sb_parse_opts_str(char *options, void **mnt_opts)
+int security_add_mnt_opt(const char *option, const char *val, int len,
+			 void **mnt_opts)
 {
-	return call_int_hook(sb_parse_opts_str, 0, options, mnt_opts);
+	return call_int_hook(sb_add_mnt_opt, -EINVAL,
+					option, val, len, mnt_opts);
 }
-EXPORT_SYMBOL(security_sb_parse_opts_str);
+EXPORT_SYMBOL(security_add_mnt_opt);
 
 int security_inode_alloc(struct inode *inode)
 {

commit 204cc0ccf1d49c6292aeef4c8edd1b3d10ff933c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 13 13:41:47 2018 -0500

    LSM: hide struct security_mnt_opts from any generic code
    
    Keep void * instead, allocate on demand (in parse_str_opts, at the
    moment).  Eventually both selinux and smack will be better off
    with private structures with several strings in those, rather than
    this "counter and two pointers to dynamically allocated arrays"
    ugliness.  This commit allows to do that at leisure, without
    disrupting anything outside of given module.
    
    Changes:
            * instead of struct security_mnt_opt use an opaque pointer
    initialized to NULL.
            * security_sb_eat_lsm_opts(), security_sb_parse_opts_str() and
    security_free_mnt_opts() take it as var argument (i.e. as void **);
    call sites are unchanged.
            * security_sb_set_mnt_opts() and security_sb_remount() take
    it by value (i.e. as void *).
            * new method: ->sb_free_mnt_opts().  Takes void *, does
    whatever freeing that needs to be done.
            * ->sb_set_mnt_opts() and ->sb_remount() might get NULL as
    mnt_opts argument, meaning "empty".
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index feb18c925349..b7a5a0051807 100644
--- a/security/security.c
+++ b/security/security.c
@@ -384,16 +384,25 @@ void security_sb_free(struct super_block *sb)
 	call_void_hook(sb_free_security, sb);
 }
 
-int security_sb_eat_lsm_opts(char *options, struct security_mnt_opts *opts)
+void security_free_mnt_opts(void **mnt_opts)
 {
-	return call_int_hook(sb_eat_lsm_opts, 0, options, opts);
+	if (!*mnt_opts)
+		return;
+	call_void_hook(sb_free_mnt_opts, *mnt_opts);
+	*mnt_opts = NULL;
+}
+EXPORT_SYMBOL(security_free_mnt_opts);
+
+int security_sb_eat_lsm_opts(char *options, void **mnt_opts)
+{
+	return call_int_hook(sb_eat_lsm_opts, 0, options, mnt_opts);
 }
 EXPORT_SYMBOL(security_sb_eat_lsm_opts);
 
 int security_sb_remount(struct super_block *sb,
-			struct security_mnt_opts *opts)
+			void *mnt_opts)
 {
-	return call_int_hook(sb_remount, 0, sb, opts);
+	return call_int_hook(sb_remount, 0, sb, mnt_opts);
 }
 EXPORT_SYMBOL(security_sb_remount);
 
@@ -429,13 +438,13 @@ int security_sb_pivotroot(const struct path *old_path, const struct path *new_pa
 }
 
 int security_sb_set_mnt_opts(struct super_block *sb,
-				struct security_mnt_opts *opts,
+				void *mnt_opts,
 				unsigned long kern_flags,
 				unsigned long *set_kern_flags)
 {
 	return call_int_hook(sb_set_mnt_opts,
-				opts->num_mnt_opts ? -EOPNOTSUPP : 0, sb,
-				opts, kern_flags, set_kern_flags);
+				mnt_opts ? -EOPNOTSUPP : 0, sb,
+				mnt_opts, kern_flags, set_kern_flags);
 }
 EXPORT_SYMBOL(security_sb_set_mnt_opts);
 
@@ -449,9 +458,9 @@ int security_sb_clone_mnt_opts(const struct super_block *oldsb,
 }
 EXPORT_SYMBOL(security_sb_clone_mnt_opts);
 
-int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)
+int security_sb_parse_opts_str(char *options, void **mnt_opts)
 {
-	return call_int_hook(sb_parse_opts_str, 0, options, opts);
+	return call_int_hook(sb_parse_opts_str, 0, options, mnt_opts);
 }
 EXPORT_SYMBOL(security_sb_parse_opts_str);
 

commit 5b4002391153acebce2557af318bbdc17e235134
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 12 20:13:29 2018 -0500

    LSM: turn sb_eat_lsm_opts() into a method
    
    Kill ->sb_copy_data() - it's used only in combination with immediately
    following ->sb_parse_opts_str().  Turn that combination into a new
    method.
    
    This is just a mechanical move - cleanups will be the next step.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 3d8b72904e00..feb18c925349 100644
--- a/security/security.c
+++ b/security/security.c
@@ -386,16 +386,7 @@ void security_sb_free(struct super_block *sb)
 
 int security_sb_eat_lsm_opts(char *options, struct security_mnt_opts *opts)
 {
-	char *s = (char *)get_zeroed_page(GFP_KERNEL);
-	int err;
-
-	if (!s)
-		return -ENOMEM;
-	err = call_int_hook(sb_copy_data, 0, options, s);
-	if (!err)
-		err = call_int_hook(sb_parse_opts_str, 0, s, opts);
-	free_page((unsigned long)s);
-	return err;
+	return call_int_hook(sb_eat_lsm_opts, 0, options, opts);
 }
 EXPORT_SYMBOL(security_sb_eat_lsm_opts);
 

commit a65001e8a4d465693d0191297a6fd864c96b3147
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 10 17:19:21 2018 -0500

    btrfs: sanitize security_mnt_opts use
    
    1) keeping a copy in btrfs_fs_info is completely pointless - we never
    use it for anything.  Getting rid of that allows for simpler calling
    conventions for setup_security_options() (caller is responsible for
    freeing mnt_opts in all cases).
    
    2) on remount we want to use ->sb_remount(), not ->sb_set_mnt_opts(),
    same as we would if not for FS_BINARY_MOUNTDATA.  Behaviours *are*
    close (in fact, selinux sb_set_mnt_opts() ought to punt to
    sb_remount() in "already initialized" case), but let's handle
    that uniformly.  And the only reason why the original btrfs changes
    didn't go for security_sb_remount() in btrfs_remount() case is that
    it hadn't been exported.  Let's export it for a while - it'll be
    going away soon anyway.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index afb05646d41b..3d8b72904e00 100644
--- a/security/security.c
+++ b/security/security.c
@@ -404,6 +404,7 @@ int security_sb_remount(struct super_block *sb,
 {
 	return call_int_hook(sb_remount, 0, sb, opts);
 }
+EXPORT_SYMBOL(security_sb_remount);
 
 int security_sb_kern_mount(struct super_block *sb)
 {

commit a10d7c22b34bcf744679019269bfb33ebf0b75ee
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 5 11:58:35 2018 -0500

    LSM: split ->sb_set_mnt_opts() out of ->sb_kern_mount()
    
    ... leaving the "is it kernel-internal" logics in the caller.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 02c656dd5c0c..afb05646d41b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -405,10 +405,9 @@ int security_sb_remount(struct super_block *sb,
 	return call_int_hook(sb_remount, 0, sb, opts);
 }
 
-int security_sb_kern_mount(struct super_block *sb, int flags,
-			   struct security_mnt_opts *opts)
+int security_sb_kern_mount(struct super_block *sb)
 {
-	return call_int_hook(sb_kern_mount, 0, sb, flags, opts);
+	return call_int_hook(sb_kern_mount, 0, sb);
 }
 
 int security_sb_show_options(struct seq_file *m, struct super_block *sb)

commit f5c0c26d9008b355babb6d16f3d7c4de3bada0e7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Nov 17 12:09:18 2018 -0500

    new helper: security_sb_eat_lsm_opts()
    
    combination of alloc_secdata(), security_sb_copy_data(),
    security_sb_parse_opt_str() and free_secdata().
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 3f50beb30fb1..02c656dd5c0c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -384,11 +384,20 @@ void security_sb_free(struct super_block *sb)
 	call_void_hook(sb_free_security, sb);
 }
 
-int security_sb_copy_data(char *orig, char *copy)
+int security_sb_eat_lsm_opts(char *options, struct security_mnt_opts *opts)
 {
-	return call_int_hook(sb_copy_data, 0, orig, copy);
+	char *s = (char *)get_zeroed_page(GFP_KERNEL);
+	int err;
+
+	if (!s)
+		return -ENOMEM;
+	err = call_int_hook(sb_copy_data, 0, options, s);
+	if (!err)
+		err = call_int_hook(sb_parse_opts_str, 0, s, opts);
+	free_page((unsigned long)s);
+	return err;
 }
-EXPORT_SYMBOL(security_sb_copy_data);
+EXPORT_SYMBOL(security_sb_eat_lsm_opts);
 
 int security_sb_remount(struct super_block *sb,
 			struct security_mnt_opts *opts)

commit c039bc3c2498724946304a8f964244a9b6af1043
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 1 23:06:57 2018 -0500

    LSM: lift extracting and parsing LSM options into the caller of ->sb_remount()
    
    This paves the way for retaining the LSM options from a common filesystem
    mount context during a mount parameter parsing phase to be instituted prior
    to actual mount/reconfiguration actions.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index b5fc8e1e849c..3f50beb30fb1 100644
--- a/security/security.c
+++ b/security/security.c
@@ -390,9 +390,10 @@ int security_sb_copy_data(char *orig, char *copy)
 }
 EXPORT_SYMBOL(security_sb_copy_data);
 
-int security_sb_remount(struct super_block *sb, void *data)
+int security_sb_remount(struct super_block *sb,
+			struct security_mnt_opts *opts)
 {
-	return call_int_hook(sb_remount, 0, sb, data);
+	return call_int_hook(sb_remount, 0, sb, opts);
 }
 
 int security_sb_kern_mount(struct super_block *sb, int flags,

commit 6be8750b4cba8c37170f46b29841d112f1be749b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 1 22:42:44 2018 -0500

    LSM: lift parsing LSM options into the caller of ->sb_kern_mount()
    
    This paves the way for retaining the LSM options from a common filesystem
    mount context during a mount parameter parsing phase to be instituted prior
    to actual mount/reconfiguration actions.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 04d173eb93f6..b5fc8e1e849c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -395,9 +395,10 @@ int security_sb_remount(struct super_block *sb, void *data)
 	return call_int_hook(sb_remount, 0, sb, data);
 }
 
-int security_sb_kern_mount(struct super_block *sb, int flags, void *data)
+int security_sb_kern_mount(struct super_block *sb, int flags,
+			   struct security_mnt_opts *opts)
 {
-	return call_int_hook(sb_kern_mount, 0, sb, flags, data);
+	return call_int_hook(sb_kern_mount, 0, sb, flags, opts);
 }
 
 int security_sb_show_options(struct seq_file *m, struct super_block *sb)

commit 876979c9308b7228cdaf6785909c57eebc85d911
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Dec 9 15:36:29 2018 -0500

    security: audit and remove any unnecessary uses of module.h
    
    Historically a lot of these existed because we did not have
    a distinction between what was modular code and what was providing
    support to modules via EXPORT_SYMBOL and friends.  That changed
    when we forked out support for the latter into the export.h file.
    This means we should be able to reduce the usage of module.h
    in code that is obj-y Makefile or bool Kconfig.
    
    The advantage in removing such instances is that module.h itself
    sources about 15 other headers; adding significantly to what we feed
    cpp, and it can obscure what headers we are effectively using.
    
    Since module.h might have been the implicit source for init.h
    (for __init) and for export.h (for EXPORT_SYMBOL) we consider each
    instance for the presence of either and replace as needed.
    
    Cc: James Morris <jmorris@namei.org>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Mimi Zohar <zohar@linux.ibm.com>
    Cc: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: linux-security-module@vger.kernel.org
    Cc: linux-integrity@vger.kernel.org
    Cc: keyrings@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 04d173eb93f6..d670136dda2c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -17,7 +17,7 @@
 #include <linux/bpf.h>
 #include <linux/capability.h>
 #include <linux/dcache.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/lsm_hooks.h>

commit 638820d8da8ededd6dc609beaef02d5396599c03
Merge: d5e4d81da4d4 3f6caaf5ff33
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 24 11:49:35 2018 +0100

    Merge branch 'next-general' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "In this patchset, there are a couple of minor updates, as well as some
      reworking of the LSM initialization code from Kees Cook (these prepare
      the way for ordered stackable LSMs, but are a valuable cleanup on
      their own)"
    
    * 'next-general' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      LSM: Don't ignore initialization failures
      LSM: Provide init debugging infrastructure
      LSM: Record LSM name in struct lsm_info
      LSM: Convert security_initcall() into DEFINE_LSM()
      vmlinux.lds.h: Move LSM_TABLE into INIT_DATA
      LSM: Convert from initcall to struct lsm_info
      LSM: Remove initcall tracing
      LSM: Rename .security_initcall section to .lsm_info
      vmlinux.lds.h: Avoid copy/paste of security_init section
      LSM: Correctly announce start of LSM initialization
      security: fix LSM description location
      keys: Fix the use of the C++ keyword "private" in uapi/linux/keyctl.h
      seccomp: remove unnecessary unlikely()
      security: tomoyo: Fix obsolete function
      security/capabilities: remove check for -EINVAL

commit 3f6caaf5ff33073ca1a3a0b82edacab3c57c38f9
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 10 17:18:26 2018 -0700

    LSM: Don't ignore initialization failures
    
    LSM initialization failures have traditionally been ignored. We should
    at least WARN when something goes wrong.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 395f804f6a91..2055af907eba 100644
--- a/security/security.c
+++ b/security/security.c
@@ -55,10 +55,12 @@ static __initdata bool debug;
 static void __init major_lsm_init(void)
 {
 	struct lsm_info *lsm;
+	int ret;
 
 	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
 		init_debug("initializing %s\n", lsm->name);
-		lsm->init();
+		ret = lsm->init();
+		WARN(ret, "%s failed to initialize: %d\n", lsm->name, ret);
 	}
 }
 

commit 9b8c7c14059af801637a818882159145c370d6f1
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 10 17:18:25 2018 -0700

    LSM: Provide init debugging infrastructure
    
    Booting with "lsm.debug" will report future details on how LSM ordering
    decisions are being made.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index e74f46fba591..395f804f6a91 100644
--- a/security/security.c
+++ b/security/security.c
@@ -12,6 +12,8 @@
  *	(at your option) any later version.
  */
 
+#define pr_fmt(fmt) "LSM: " fmt
+
 #include <linux/bpf.h>
 #include <linux/capability.h>
 #include <linux/dcache.h>
@@ -43,11 +45,19 @@ char *lsm_names;
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
+static __initdata bool debug;
+#define init_debug(...)						\
+	do {							\
+		if (debug)					\
+			pr_info(__VA_ARGS__);			\
+	} while (0)
+
 static void __init major_lsm_init(void)
 {
 	struct lsm_info *lsm;
 
 	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
+		init_debug("initializing %s\n", lsm->name);
 		lsm->init();
 	}
 }
@@ -91,6 +101,14 @@ static int __init choose_lsm(char *str)
 }
 __setup("security=", choose_lsm);
 
+/* Enable LSM order debugging. */
+static int __init enable_debug(char *str)
+{
+	debug = true;
+	return 1;
+}
+__setup("lsm.debug", enable_debug);
+
 static bool match_last_lsm(const char *list, const char *lsm)
 {
 	const char *last;

commit 5b89c1bd4c7e5c5ca8c5374fde35ecee6e16496c
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 10 17:18:21 2018 -0700

    LSM: Convert from initcall to struct lsm_info
    
    In preparation for doing more interesting LSM init probing, this converts
    the existing initcall system into an explicit call into a function pointer
    from a section-collected struct lsm_info array.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Reviewed-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 41a5da2c7faf..e74f46fba591 100644
--- a/security/security.c
+++ b/security/security.c
@@ -43,16 +43,12 @@ char *lsm_names;
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
-static void __init do_security_initcalls(void)
+static void __init major_lsm_init(void)
 {
-	initcall_t call;
-	initcall_entry_t *ce;
+	struct lsm_info *lsm;
 
-	ce = __start_lsm_info;
-	while (ce < __end_lsm_info) {
-		call = initcall_from_entry(ce);
-		call();
-		ce++;
+	for (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {
+		lsm->init();
 	}
 }
 
@@ -82,7 +78,7 @@ int __init security_init(void)
 	/*
 	 * Load all the remaining security modules.
 	 */
-	do_security_initcalls();
+	major_lsm_init();
 
 	return 0;
 }

commit 6907e3746fa1b9b685230098266bbeba99b93c7d
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 10 17:18:20 2018 -0700

    LSM: Remove initcall tracing
    
    This partially reverts commit 58eacfffc417 ("init, tracing: instrument
    security and console initcall trace events") since security init calls
    are about to no longer resemble regular init calls.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 892fe6b691cf..41a5da2c7faf 100644
--- a/security/security.c
+++ b/security/security.c
@@ -30,8 +30,6 @@
 #include <linux/string.h>
 #include <net/flow.h>
 
-#include <trace/events/initcall.h>
-
 #define MAX_LSM_EVM_XATTR	2
 
 /* Maximum number of letters for an LSM name string */
@@ -47,17 +45,13 @@ static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 
 static void __init do_security_initcalls(void)
 {
-	int ret;
 	initcall_t call;
 	initcall_entry_t *ce;
 
 	ce = __start_lsm_info;
-	trace_initcall_level("security");
 	while (ce < __end_lsm_info) {
 		call = initcall_from_entry(ce);
-		trace_initcall_start(call);
-		ret = call();
-		trace_initcall_finish(call, ret);
+		call();
 		ce++;
 	}
 }

commit b048ae6e6c7062809e4398f4d0bfe80870715d3c
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 10 17:18:19 2018 -0700

    LSM: Rename .security_initcall section to .lsm_info
    
    In preparation for switching from initcall to just a regular set of
    pointers in a section, rename the internal section name.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Reviewed-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 4cbcf244a965..892fe6b691cf 100644
--- a/security/security.c
+++ b/security/security.c
@@ -51,9 +51,9 @@ static void __init do_security_initcalls(void)
 	initcall_t call;
 	initcall_entry_t *ce;
 
-	ce = __security_initcall_start;
+	ce = __start_lsm_info;
 	trace_initcall_level("security");
-	while (ce < __security_initcall_end) {
+	while (ce < __end_lsm_info) {
 		call = initcall_from_entry(ce);
 		trace_initcall_start(call);
 		ret = call();

commit 98d291708cbaab06efec195d0810a7ef60f7603a
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 10 17:18:17 2018 -0700

    LSM: Correctly announce start of LSM initialization
    
    For a while now, the LSM core has said it was "initializED", rather than
    "initializING". This adjust the report to be more accurate (i.e. before
    this was reported before any LSMs had been initialized.)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: James Morris <james.morris@microsoft.com>
    Reviewed-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 736e78da1ab9..4cbcf244a965 100644
--- a/security/security.c
+++ b/security/security.c
@@ -72,10 +72,11 @@ int __init security_init(void)
 	int i;
 	struct hlist_head *list = (struct hlist_head *) &security_hook_heads;
 
+	pr_info("Security Framework initializing\n");
+
 	for (i = 0; i < sizeof(security_hook_heads) / sizeof(struct hlist_head);
 	     i++)
 		INIT_HLIST_HEAD(&list[i]);
-	pr_info("Security Framework initialized\n");
 
 	/*
 	 * Load minor LSMs, with the capability module always first.

commit ae7795bc6187a15ec51cf258abae656a625f9980
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Sep 25 11:27:20 2018 +0200

    signal: Distinguish between kernel_siginfo and siginfo
    
    Linus recently observed that if we did not worry about the padding
    member in struct siginfo it is only about 48 bytes, and 48 bytes is
    much nicer than 128 bytes for allocating on the stack and copying
    around in the kernel.
    
    The obvious thing of only adding the padding when userspace is
    including siginfo.h won't work as there are sigframe definitions in
    the kernel that embed struct siginfo.
    
    So split siginfo in two; kernel_siginfo and siginfo.  Keeping the
    traditional name for the userspace definition.  While the version that
    is used internally to the kernel and ultimately will not be padded to
    128 bytes is called kernel_siginfo.
    
    The definition of struct kernel_siginfo I have put in include/signal_types.h
    
    A set of buildtime checks has been added to verify the two structures have
    the same field offsets.
    
    To make it easy to verify the change kernel_siginfo retains the same
    size as siginfo.  The reduction in size comes in a following change.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index 736e78da1ab9..0d504fceda8b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1147,7 +1147,7 @@ int security_task_movememory(struct task_struct *p)
 	return call_int_hook(task_movememory, 0, p);
 }
 
-int security_task_kill(struct task_struct *p, struct siginfo *info,
+int security_task_kill(struct task_struct *p, struct kernel_siginfo *info,
 			int sig, const struct cred *cred)
 {
 	return call_int_hook(task_kill, 0, p, info, sig, cred);

commit 1b1eeca7e4c19fa76d409d4c7b338dba21f2df45
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Aug 21 21:56:13 2018 -0700

    init: allow initcall tables to be emitted using relative references
    
    Allow the initcall tables to be emitted using relative references that
    are only half the size on 64-bit architectures and don't require fixups
    at runtime on relocatable kernels.
    
    Link: http://lkml.kernel.org/r/20180704083651.24360-5-ard.biesheuvel@linaro.org
    Acked-by: James Morris <james.morris@microsoft.com>
    Acked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Acked-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Garnier <thgarnie@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 47cfff01d7ec..736e78da1ab9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -48,14 +48,17 @@ static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 static void __init do_security_initcalls(void)
 {
 	int ret;
-	initcall_t *call;
-	call = __security_initcall_start;
+	initcall_t call;
+	initcall_entry_t *ce;
+
+	ce = __security_initcall_start;
 	trace_initcall_level("security");
-	while (call < __security_initcall_end) {
-		trace_initcall_start((*call));
-		ret = (*call) ();
-		trace_initcall_finish((*call), ret);
-		call++;
+	while (ce < __security_initcall_end) {
+		call = initcall_from_entry(ce);
+		trace_initcall_start(call);
+		ret = call();
+		trace_initcall_finish(call, ret);
+		ce++;
 	}
 }
 

commit f91e654474d413201ae578820fb63f8a811f6c4e
Merge: c715ebeb0303 3dd0f18c70d9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 15 22:54:12 2018 -0700

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull integrity updates from James Morris:
     "This adds support for EVM signatures based on larger digests, contains
      a new audit record AUDIT_INTEGRITY_POLICY_RULE to differentiate the
      IMA policy rules from the IMA-audit messages, addresses two deadlocks
      due to either loading or searching for crypto algorithms, and cleans
      up the audit messages"
    
    * 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      EVM: fix return value check in evm_write_xattrs()
      integrity: prevent deadlock during digsig verification.
      evm: Allow non-SHA1 digital signatures
      evm: Don't deadlock if a crypto algorithm is unavailable
      integrity: silence warning when CONFIG_SECURITYFS is not enabled
      ima: Differentiate auditing policy rules from "audit" actions
      ima: Do not audit if CONFIG_INTEGRITY_AUDIT is not set
      ima: Use audit_log_format() rather than audit_log_string()
      ima: Call audit_log_string() rather than logging it untrusted

commit 92d4a03674b8c399c2f547580fa509db78226170
Merge: 1eb46908b35d 87ea58433208
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 15 10:25:26 2018 -0700

    Merge branch 'next-general' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
    
     - kstrdup() return value fix from Eric Biggers
    
     - Add new security_load_data hook to differentiate security checking of
       kernel-loaded binaries in the case of there being no associated file
       descriptor, from Mimi Zohar.
    
     - Add ability to IMA to specify a policy at build-time, rather than
       just via command line params or by loading a custom policy, from
       Mimi.
    
     - Allow IMA and LSMs to prevent sysfs firmware load fallback (e.g. if
       using signed firmware), from Mimi.
    
     - Allow IMA to deny loading of kexec kernel images, as they cannot be
       measured by IMA, from Mimi.
    
    * 'next-general' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      security: check for kstrdup() failure in lsm_append()
      security: export security_kernel_load_data function
      ima: based on policy warn about loading firmware (pre-allocated buffer)
      module: replace the existing LSM hook in init_module
      ima: add build time policy
      ima: based on policy require signed firmware (sysfs fallback)
      firmware: add call to LSM hook before firmware sysfs fallback
      ima: based on policy require signed kexec kernel images
      kexec: add call to LSM hook in original kexec_load syscall
      security: define new LSM hook named security_kernel_load_data
      MAINTAINERS: remove the outdated "LINUX SECURITY MODULE (LSM) FRAMEWORK" entry

commit 6eb864c1d9dd1ef32b88e03c3f49d8be0dab7dcf
Author: Mikhail Kurinnoi <viewizard@viewizard.com>
Date:   Wed Jun 27 16:33:42 2018 +0300

    integrity: prevent deadlock during digsig verification.
    
    This patch aimed to prevent deadlock during digsig verification.The point
    of issue - user space utility modprobe and/or it's dependencies (ld-*.so,
    libz.so.*, libc-*.so and /lib/modules/ files) that could be used for
    kernel modules load during digsig verification and could be signed by
    digsig in the same time.
    
    First at all, look at crypto_alloc_tfm() work algorithm:
    crypto_alloc_tfm() will first attempt to locate an already loaded
    algorithm. If that fails and the kernel supports dynamically loadable
    modules, it will then attempt to load a module of the same name or alias.
    If that fails it will send a query to any loaded crypto manager to
    construct an algorithm on the fly.
    
    We have situation, when public_key_verify_signature() in case of RSA
    algorithm use alg_name to store internal information in order to construct
    an algorithm on the fly, but crypto_larval_lookup() will try to use
    alg_name in order to load kernel module with same name.
    
    1) we can't do anything with crypto module work, since it designed to work
    exactly in this way;
    2) we can't globally filter module requests for modprobe, since it
    designed to work with any requests.
    
    In this patch, I propose add an exception for "crypto-pkcs1pad(rsa,*)"
    module requests only in case of enabled integrity asymmetric keys support.
    Since we don't have any real "crypto-pkcs1pad(rsa,*)" kernel modules for
    sure, we are safe to fail such module request from crypto_larval_lookup().
    In this way we prevent modprobe execution during digsig verification and
    avoid possible deadlock if modprobe and/or it's dependencies also signed
    with digsig.
    
    Requested "crypto-pkcs1pad(rsa,*)" kernel module name formed by:
    1) "pkcs1pad(rsa,%s)" in public_key_verify_signature();
    2) "crypto-%s" / "crypto-%s-all" in crypto_larval_lookup().
    "crypto-pkcs1pad(rsa," part of request is a constant and unique and could
    be used as filter.
    
    Signed-off-by: Mikhail Kurinnoi <viewizard@viewizard.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    
     include/linux/integrity.h              | 13 +++++++++++++
     security/integrity/digsig_asymmetric.c | 23 +++++++++++++++++++++++
     security/security.c                    |  7 ++++++-
     3 files changed, 42 insertions(+), 1 deletion(-)

diff --git a/security/security.c b/security/security.c
index b49ee810371b..dbca03d3629b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1032,7 +1032,12 @@ int security_kernel_create_files_as(struct cred *new, struct inode *inode)
 
 int security_kernel_module_request(char *kmod_name)
 {
-	return call_int_hook(kernel_module_request, 0, kmod_name);
+	int ret;
+
+	ret = call_int_hook(kernel_module_request, 0, kmod_name);
+	if (ret)
+		return ret;
+	return integrity_kernel_module_request(kmod_name);
 }
 
 int security_kernel_read_file(struct file *file, enum kernel_read_file_id id)

commit 87ea58433208d17295e200d56be5e2a4fe4ce7d6
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Jul 17 10:36:04 2018 -0700

    security: check for kstrdup() failure in lsm_append()
    
    lsm_append() should return -ENOMEM if memory allocation failed.
    
    Fixes: d69dece5f5b6 ("LSM: Add /sys/kernel/security/lsm")
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 6e149d0ffe33..b49ee810371b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -118,6 +118,8 @@ static int lsm_append(char *new, char **result)
 
 	if (*result == NULL) {
 		*result = kstrdup(new, GFP_KERNEL);
+		if (*result == NULL)
+			return -ENOMEM;
 	} else {
 		/* Check if it is the last registered name */
 		if (match_last_lsm(*result, new))

commit 83a68a06795fa47e77ea758f293a5946e9e02e84
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 17 22:23:37 2018 +0200

    security: export security_kernel_load_data function
    
    The firmware_loader can be built as a loadable module, which now
    fails when CONFIG_SECURITY is enabled, because a call to the
    security_kernel_load_data() function got added, and this is
    not exported to modules:
    
    ERROR: "security_kernel_load_data" [drivers/base/firmware_loader/firmware_class.ko] undefined!
    
    Add an EXPORT_SYMBOL_GPL() to make it available here.
    
    Fixes: 6e852651f28e ("firmware: add call to LSM hook before firmware sysfs fallback")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 4927e7cc7d96..6e149d0ffe33 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1065,6 +1065,7 @@ int security_kernel_load_data(enum kernel_load_data_id id)
 		return ret;
 	return ima_load_data(id);
 }
+EXPORT_SYMBOL_GPL(security_kernel_load_data);
 
 int security_task_fix_setuid(struct cred *new, const struct cred *old,
 			     int flags)

commit 16c267aac86b463b1fcccd43c89f4c8e5c5c86fa
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Fri Jul 13 14:05:58 2018 -0400

    ima: based on policy require signed kexec kernel images
    
    The original kexec_load syscall can not verify file signatures, nor can
    the kexec image be measured.  Based on policy, deny the kexec_load
    syscall.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Kees Cook <keescook@chromium.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index c2de2f134854..4927e7cc7d96 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1058,7 +1058,12 @@ EXPORT_SYMBOL_GPL(security_kernel_post_read_file);
 
 int security_kernel_load_data(enum kernel_load_data_id id)
 {
-	return call_int_hook(kernel_load_data, 0, id);
+	int ret;
+
+	ret = call_int_hook(kernel_load_data, 0, id);
+	if (ret)
+		return ret;
+	return ima_load_data(id);
 }
 
 int security_task_fix_setuid(struct cred *new, const struct cred *old,

commit 377179cd28cd417dcfb4396edb824533431e607e
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Fri Jul 13 14:05:56 2018 -0400

    security: define new LSM hook named security_kernel_load_data
    
    Differentiate between the kernel reading a file specified by userspace
    from the kernel loading a buffer containing data provided by userspace.
    This patch defines a new LSM hook named security_kernel_load_data().
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 68f46d849abe..c2de2f134854 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1056,6 +1056,11 @@ int security_kernel_post_read_file(struct file *file, char *buf, loff_t size,
 }
 EXPORT_SYMBOL_GPL(security_kernel_post_read_file);
 
+int security_kernel_load_data(enum kernel_load_data_id id)
+{
+	return call_int_hook(kernel_load_data, 0, id);
+}
+
 int security_task_fix_setuid(struct cred *new, const struct cred *old,
 			     int flags)
 {

commit 9481769208b5e39b871ae4e89f5328c776ec38dc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 10 14:13:18 2018 -0400

    ->file_open(): lose cred argument
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 235b35f58a65..5dce67070cdf 100644
--- a/security/security.c
+++ b/security/security.c
@@ -974,7 +974,7 @@ int security_file_open(struct file *file)
 {
 	int ret;
 
-	ret = call_int_hook(file_open, 0, file, file->f_cred);
+	ret = call_int_hook(file_open, 0, file);
 	if (ret)
 		return ret;
 

commit e3f20ae21079ecac282df65d83865c5771f4bca0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 10 13:25:29 2018 -0400

    security_file_open(): lose cred argument
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 68f46d849abe..235b35f58a65 100644
--- a/security/security.c
+++ b/security/security.c
@@ -970,11 +970,11 @@ int security_file_receive(struct file *file)
 	return call_int_hook(file_receive, 0, file);
 }
 
-int security_file_open(struct file *file, const struct cred *cred)
+int security_file_open(struct file *file)
 {
 	int ret;
 
-	ret = call_int_hook(file_open, 0, file, cred);
+	ret = call_int_hook(file_open, 0, file, file->f_cred);
 	if (ret)
 		return ret;
 

commit aae7cfcbb733cf16f3bc9cbb650673b94d5df75f
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Fri May 4 16:28:19 2018 +0200

    security: add hook for socketpair()
    
    Right now the LSM labels for socketpairs are always uninitialized,
    since there is no security hook for the socketpair() syscall. This
    patch adds the required hooks so LSMs can properly label socketpairs.
    This allows SO_PEERSEC to return useful information on those sockets.
    
    Note that the behavior of socketpair() can be emulated by creating a
    listener socket, connecting to it, and then discarding the initial
    listener socket. With this workaround, SO_PEERSEC would return the
    caller's security context. However, with socketpair(), the uninitialized
    context is returned unconditionally. This is unexpected and makes
    socketpair() less useful in situations where the security context is
    crucial to the application.
    
    With the new socketpair-hook this disparity can be solved by making
    socketpair() return the expected security context.
    
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 7bc2fde023a7..68f46d849abe 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1358,6 +1358,12 @@ int security_socket_post_create(struct socket *sock, int family,
 						protocol, kern);
 }
 
+int security_socket_socketpair(struct socket *socka, struct socket *sockb)
+{
+	return call_int_hook(socket_socketpair, 0, socka, sockb);
+}
+EXPORT_SYMBOL(security_socket_socketpair);
+
 int security_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
 {
 	return call_int_hook(socket_bind, 0, sock, address, addrlen);

commit 2a56bb596b2c1fb612f9988afda9655c8c872a6e
Merge: 9f3a0941fb5e b0dc52f15e7f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 10 11:27:30 2018 -0700

    Merge tag 'trace-v4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace
    
    Pull tracing updates from Steven Rostedt:
     "New features:
    
       - Tom Zanussi's extended histogram work.
    
         This adds the synthetic events to have histograms from multiple
         event data Adds triggers "onmatch" and "onmax" to call the
         synthetic events Several updates to the histogram code from this
    
       - Allow way to nest ring buffer calls in the same context
    
       - Allow absolute time stamps in ring buffer
    
       - Rewrite of filter code parsing based on Al Viro's suggestions
    
       - Setting of trace_clock to global if TSC is unstable (on boot)
    
       - Better OOM handling when allocating large ring buffers
    
       - Added initcall tracepoints (consolidated initcall_debug code with
         them)
    
      And other various fixes and clean ups"
    
    * tag 'trace-v4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace: (68 commits)
      init: Have initcall_debug still work without CONFIG_TRACEPOINTS
      init, tracing: Have printk come through the trace events for initcall_debug
      init, tracing: instrument security and console initcall trace events
      init, tracing: Add initcall trace events
      tracing: Add rcu dereference annotation for test func that touches filter->prog
      tracing: Add rcu dereference annotation for filter->prog
      tracing: Fixup logic inversion on setting trace_global_clock defaults
      tracing: Hide global trace clock from lockdep
      ring-buffer: Add set/clear_current_oom_origin() during allocations
      ring-buffer: Check if memory is available before allocation
      lockdep: Add print_irqtrace_events() to __warn
      vsprintf: Do not preprocess non-dereferenced pointers for bprintf (%px and %pK)
      tracing: Uninitialized variable in create_tracing_map_fields()
      tracing: Make sure variable string fields are NULL-terminated
      tracing: Add action comparisons when testing matching hist triggers
      tracing: Don't add flag strings when displaying variable references
      tracing: Fix display of hist trigger expressions containing timestamps
      ftrace: Drop a VLA in module_exists()
      tracing: Mention trace_clock=global when warning about unstable clocks
      tracing: Default to using trace_global_clock if sched_clock is unstable
      ...

commit f8cf2f16a7c95acce497bfafa90e7c6d8397d653
Merge: 4b3f1a151571 ab60368ab6a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 7 16:53:59 2018 -0700

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull integrity updates from James Morris:
     "A mixture of bug fixes, code cleanup, and continues to close
      IMA-measurement, IMA-appraisal, and IMA-audit gaps.
    
      Also note the addition of a new cred_getsecid LSM hook by Matthew
      Garrett:
    
         For IMA purposes, we want to be able to obtain the prepared secid
         in the bprm structure before the credentials are committed. Add a
         cred_getsecid hook that makes this possible.
    
      which is used by a new CREDS_CHECK target in IMA:
    
         In ima_bprm_check(), check with both the existing process
         credentials and the credentials that will be committed when the new
         process is started. This will not change behaviour unless the
         system policy is extended to include CREDS_CHECK targets -
         BPRM_CHECK will continue to check the same credentials that it did
         previously"
    
    * 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      ima: Fallback to the builtin hash algorithm
      ima: Add smackfs to the default appraise/measure list
      evm: check for remount ro in progress before writing
      ima: Improvements in ima_appraise_measurement()
      ima: Simplify ima_eventsig_init()
      integrity: Remove unused macro IMA_ACTION_RULE_FLAGS
      ima: drop vla in ima_audit_measurement()
      ima: Fix Kconfig to select TPM 2.0 CRB interface
      evm: Constify *integrity_status_msg[]
      evm: Move evm_hmac and evm_hash from evm_main.c to evm_crypto.c
      fuse: define the filesystem as untrusted
      ima: fail signature verification based on policy
      ima: clear IMA_HASH
      ima: re-evaluate files on privileged mounted filesystems
      ima: fail file signature verification on non-init mounted filesystems
      IMA: Support using new creds in appraisal policy
      security: Add a cred_getsecid hook

commit 3612605a5a5bc3d3ae0ec861328be8a2990f2c7a
Merge: 62f8e6c5dcb6 df0ce17331e2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 7 11:11:41 2018 -0700

    Merge branch 'next-general' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull general security layer updates from James Morris:
    
     - Convert security hooks from list to hlist, a nice cleanup, saving
       about 50% of space, from Sargun Dhillon.
    
     - Only pass the cred, not the secid, to kill_pid_info_as_cred and
       security_task_kill (as the secid can be determined from the cred),
       from Stephen Smalley.
    
     - Close a potential race in kernel_read_file(), by making the file
       unwritable before calling the LSM check (vs after), from Kees Cook.
    
    * 'next-general' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      security: convert security hooks to use hlist
      exec: Set file unwritable before LSM check
      usb, signal, security: only pass the cred, not the secid, to kill_pid_info_as_cred and security_task_kill

commit 9eda2d2dca830f0f8923b1f377d0fb70f576af1d
Merge: 6ad11bdd57ad 6b6bc6205d98
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 15:39:26 2018 -0700

    Merge tag 'selinux-pr-20180403' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux
    
    Pull SELinux updates from Paul Moore:
     "A bigger than usual pull request for SELinux, 13 patches (lucky!)
      along with a scary looking diffstat.
    
      Although if you look a bit closer, excluding the usual minor
      tweaks/fixes, there are really only two significant changes in this
      pull request: the addition of proper SELinux access controls for SCTP
      and the encapsulation of a lot of internal SELinux state.
    
      The SCTP changes are the result of a multi-month effort (maybe even a
      year or longer?) between the SELinux folks and the SCTP folks to add
      proper SELinux controls. A special thanks go to Richard for seeing
      this through and keeping the effort moving forward.
    
      The state encapsulation work is a bit of janitorial work that came out
      of some early work on SELinux namespacing. The question of namespacing
      is still an open one, but I believe there is some real value in the
      encapsulation work so we've split that out and are now sending that up
      to you"
    
    * tag 'selinux-pr-20180403' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux:
      selinux: wrap AVC state
      selinux: wrap selinuxfs state
      selinux: fix handling of uninitialized selinux state in get_bools/classes
      selinux: Update SELinux SCTP documentation
      selinux: Fix ltp test connect-syscall failure
      selinux: rename the {is,set}_enforcing() functions
      selinux: wrap global selinux state
      selinux: fix typo in selinux_netlbl_sctp_sk_clone declaration
      selinux: Add SCTP support
      sctp: Add LSM hooks
      sctp: Add ip option support
      security: Add support for SCTP security hooks
      netlabel: If PF_INET6, check sk_buff ip header version

commit 58eacfffc41735c9155becc73cb7f4dcc60a46a9
Author: Abderrahmane Benbachir <abderrahmane.benbachir@polymtl.ca>
Date:   Thu Mar 22 20:33:28 2018 -0400

    init, tracing: instrument security and console initcall trace events
    
    Trace events have been added around the initcall functions defined in
    init/main.c. But console and security have their own initcalls. This adds
    the trace events associated for those initcall functions.
    
    Link: http://lkml.kernel.org/r/1521765208.19745.2.camel@polymtl.ca
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Abderrahmane Benbachir <abderrahmane.benbachir@polymtl.ca>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/security/security.c b/security/security.c
index 1cd8526cb0b7..987afe3d464c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -30,6 +30,8 @@
 #include <linux/string.h>
 #include <net/flow.h>
 
+#include <trace/events/initcall.h>
+
 #define MAX_LSM_EVM_XATTR	2
 
 /* Maximum number of letters for an LSM name string */
@@ -45,10 +47,14 @@ static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 
 static void __init do_security_initcalls(void)
 {
+	int ret;
 	initcall_t *call;
 	call = __security_initcall_start;
+	trace_initcall_level("security");
 	while (call < __security_initcall_end) {
-		(*call) ();
+		trace_initcall_start((*call));
+		ret = (*call) ();
+		trace_initcall_finish((*call), ret);
 		call++;
 	}
 }

commit df0ce17331e2501dbffc060041dfc6c5f85227b5
Author: Sargun Dhillon <sargun@sargun.me>
Date:   Thu Mar 29 01:28:23 2018 +0000

    security: convert security hooks to use hlist
    
    This changes security_hook_heads to use hlist_heads instead of
    the circular doubly-linked list heads. This should cut down
    the size of the struct by about half.
    
    In addition, it allows mutation of the hooks at the tail of the
    callback list without having to modify the head. The longer-term
    purpose of this is to enable making the heads read only.
    
    Signed-off-by: Sargun Dhillon <sargun@sargun.me>
    Reviewed-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 14c291910d25..dd246a38b3f0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -61,11 +61,11 @@ static void __init do_security_initcalls(void)
 int __init security_init(void)
 {
 	int i;
-	struct list_head *list = (struct list_head *) &security_hook_heads;
+	struct hlist_head *list = (struct hlist_head *) &security_hook_heads;
 
-	for (i = 0; i < sizeof(security_hook_heads) / sizeof(struct list_head);
+	for (i = 0; i < sizeof(security_hook_heads) / sizeof(struct hlist_head);
 	     i++)
-		INIT_LIST_HEAD(&list[i]);
+		INIT_HLIST_HEAD(&list[i]);
 	pr_info("Security Framework initialized\n");
 
 	/*
@@ -163,7 +163,7 @@ void __init security_add_hooks(struct security_hook_list *hooks, int count,
 
 	for (i = 0; i < count; i++) {
 		hooks[i].lsm = lsm;
-		list_add_tail_rcu(&hooks[i].list, hooks[i].head);
+		hlist_add_tail_rcu(&hooks[i].list, hooks[i].head);
 	}
 	if (lsm_append(lsm, &lsm_names) < 0)
 		panic("%s - Cannot get early memory.\n", __func__);
@@ -201,7 +201,7 @@ EXPORT_SYMBOL(unregister_lsm_notifier);
 	do {							\
 		struct security_hook_list *P;			\
 								\
-		list_for_each_entry(P, &security_hook_heads.FUNC, list)	\
+		hlist_for_each_entry(P, &security_hook_heads.FUNC, list) \
 			P->hook.FUNC(__VA_ARGS__);		\
 	} while (0)
 
@@ -210,7 +210,7 @@ EXPORT_SYMBOL(unregister_lsm_notifier);
 	do {							\
 		struct security_hook_list *P;			\
 								\
-		list_for_each_entry(P, &security_hook_heads.FUNC, list) { \
+		hlist_for_each_entry(P, &security_hook_heads.FUNC, list) { \
 			RC = P->hook.FUNC(__VA_ARGS__);		\
 			if (RC != 0)				\
 				break;				\
@@ -317,7 +317,7 @@ int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 	 * agree that it should be set it will. If any module
 	 * thinks it should not be set it won't.
 	 */
-	list_for_each_entry(hp, &security_hook_heads.vm_enough_memory, list) {
+	hlist_for_each_entry(hp, &security_hook_heads.vm_enough_memory, list) {
 		rc = hp->hook.vm_enough_memory(mm, pages);
 		if (rc <= 0) {
 			cap_sys_admin = 0;
@@ -805,7 +805,7 @@ int security_inode_getsecurity(struct inode *inode, const char *name, void **buf
 	/*
 	 * Only one module will provide an attribute with a given name.
 	 */
-	list_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {
+	hlist_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {
 		rc = hp->hook.inode_getsecurity(inode, name, buffer, alloc);
 		if (rc != -EOPNOTSUPP)
 			return rc;
@@ -823,7 +823,7 @@ int security_inode_setsecurity(struct inode *inode, const char *name, const void
 	/*
 	 * Only one module will provide an attribute with a given name.
 	 */
-	list_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {
+	hlist_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {
 		rc = hp->hook.inode_setsecurity(inode, name, value, size,
 								flags);
 		if (rc != -EOPNOTSUPP)
@@ -1126,7 +1126,7 @@ int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 	int rc = -ENOSYS;
 	struct security_hook_list *hp;
 
-	list_for_each_entry(hp, &security_hook_heads.task_prctl, list) {
+	hlist_for_each_entry(hp, &security_hook_heads.task_prctl, list) {
 		thisrc = hp->hook.task_prctl(option, arg2, arg3, arg4, arg5);
 		if (thisrc != -ENOSYS) {
 			rc = thisrc;
@@ -1629,7 +1629,7 @@ int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
 	 * For speed optimization, we explicitly break the loop rather than
 	 * using the macro
 	 */
-	list_for_each_entry(hp, &security_hook_heads.xfrm_state_pol_flow_match,
+	hlist_for_each_entry(hp, &security_hook_heads.xfrm_state_pol_flow_match,
 				list) {
 		rc = hp->hook.xfrm_state_pol_flow_match(x, xp, fl);
 		break;

commit 3ec30113264a7bcd389f51d1738e42da0f41bb5a
Author: Matthew Garrett <mjg59@google.com>
Date:   Mon Jan 8 13:36:19 2018 -0800

    security: Add a cred_getsecid hook
    
    For IMA purposes, we want to be able to obtain the prepared secid in the
    bprm structure before the credentials are committed. Add a cred_getsecid
    hook that makes this possible.
    
    Signed-off-by: Matthew Garrett <mjg59@google.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/security/security.c b/security/security.c
index 14c291910d25..957e8bee3554 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1005,6 +1005,13 @@ void security_transfer_creds(struct cred *new, const struct cred *old)
 	call_void_hook(cred_transfer, new, old);
 }
 
+void security_cred_getsecid(const struct cred *c, u32 *secid)
+{
+	*secid = 0;
+	call_void_hook(cred_getsecid, c, secid);
+}
+EXPORT_SYMBOL(security_cred_getsecid);
+
 int security_kernel_act_as(struct cred *new, u32 secid)
 {
 	return call_int_hook(kernel_act_as, 0, new, secid);

commit d8c6e8543294428426578d74dc7aaf121e762d58
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 22 21:22:26 2018 -0500

    msg/security: Pass kern_ipc_perm not msg_queue into the msg_queue security hooks
    
    All of the implementations of security hooks that take msg_queue only
    access q_perm the struct kern_ipc_perm member.  This means the
    dependencies of the msg_queue security hooks can be simplified by
    passing the kern_ipc_perm member of msg_queue.
    
    Making this change will allow struct msg_queue to become private to
    ipc/msg.c.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index 77b69bd6f234..02d734e69955 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1163,33 +1163,33 @@ void security_msg_msg_free(struct msg_msg *msg)
 	call_void_hook(msg_msg_free_security, msg);
 }
 
-int security_msg_queue_alloc(struct msg_queue *msq)
+int security_msg_queue_alloc(struct kern_ipc_perm *msq)
 {
 	return call_int_hook(msg_queue_alloc_security, 0, msq);
 }
 
-void security_msg_queue_free(struct msg_queue *msq)
+void security_msg_queue_free(struct kern_ipc_perm *msq)
 {
 	call_void_hook(msg_queue_free_security, msq);
 }
 
-int security_msg_queue_associate(struct msg_queue *msq, int msqflg)
+int security_msg_queue_associate(struct kern_ipc_perm *msq, int msqflg)
 {
 	return call_int_hook(msg_queue_associate, 0, msq, msqflg);
 }
 
-int security_msg_queue_msgctl(struct msg_queue *msq, int cmd)
+int security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd)
 {
 	return call_int_hook(msg_queue_msgctl, 0, msq, cmd);
 }
 
-int security_msg_queue_msgsnd(struct msg_queue *msq,
+int security_msg_queue_msgsnd(struct kern_ipc_perm *msq,
 			       struct msg_msg *msg, int msqflg)
 {
 	return call_int_hook(msg_queue_msgsnd, 0, msq, msg, msqflg);
 }
 
-int security_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+int security_msg_queue_msgrcv(struct kern_ipc_perm *msq, struct msg_msg *msg,
 			       struct task_struct *target, long type, int mode)
 {
 	return call_int_hook(msg_queue_msgrcv, 0, msq, msg, target, type, mode);

commit 7191adff2a5566efb139c79ea03eda3d0520d44a
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 22 21:08:27 2018 -0500

    shm/security: Pass kern_ipc_perm not shmid_kernel into the shm security hooks
    
    All of the implementations of security hooks that take shmid_kernel only
    access shm_perm the struct kern_ipc_perm member.  This means the
    dependencies of the shm security hooks can be simplified by passing
    the kern_ipc_perm member of shmid_kernel..
    
    Making this change will allow struct shmid_kernel to become private to ipc/shm.c.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index d3b9aeb6b73b..77b69bd6f234 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1195,27 +1195,27 @@ int security_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
 	return call_int_hook(msg_queue_msgrcv, 0, msq, msg, target, type, mode);
 }
 
-int security_shm_alloc(struct shmid_kernel *shp)
+int security_shm_alloc(struct kern_ipc_perm *shp)
 {
 	return call_int_hook(shm_alloc_security, 0, shp);
 }
 
-void security_shm_free(struct shmid_kernel *shp)
+void security_shm_free(struct kern_ipc_perm *shp)
 {
 	call_void_hook(shm_free_security, shp);
 }
 
-int security_shm_associate(struct shmid_kernel *shp, int shmflg)
+int security_shm_associate(struct kern_ipc_perm *shp, int shmflg)
 {
 	return call_int_hook(shm_associate, 0, shp, shmflg);
 }
 
-int security_shm_shmctl(struct shmid_kernel *shp, int cmd)
+int security_shm_shmctl(struct kern_ipc_perm *shp, int cmd)
 {
 	return call_int_hook(shm_shmctl, 0, shp, cmd);
 }
 
-int security_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmflg)
+int security_shm_shmat(struct kern_ipc_perm *shp, char __user *shmaddr, int shmflg)
 {
 	return call_int_hook(shm_shmat, 0, shp, shmaddr, shmflg);
 }

commit aefad9593ec5ad4aae5346253a8b646364cd7317
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 22 20:52:43 2018 -0500

    sem/security: Pass kern_ipc_perm not sem_array into the sem security hooks
    
    All of the implementations of security hooks that take sem_array only
    access sem_perm the struct kern_ipc_perm member.  This means the
    dependencies of the sem security hooks can be simplified by passing
    the kern_ipc_perm member of sem_array.
    
    Making this change will allow struct sem and struct sem_array
    to become private to ipc/sem.c.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index 1cd8526cb0b7..d3b9aeb6b73b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1220,27 +1220,27 @@ int security_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmfl
 	return call_int_hook(shm_shmat, 0, shp, shmaddr, shmflg);
 }
 
-int security_sem_alloc(struct sem_array *sma)
+int security_sem_alloc(struct kern_ipc_perm *sma)
 {
 	return call_int_hook(sem_alloc_security, 0, sma);
 }
 
-void security_sem_free(struct sem_array *sma)
+void security_sem_free(struct kern_ipc_perm *sma)
 {
 	call_void_hook(sem_free_security, sma);
 }
 
-int security_sem_associate(struct sem_array *sma, int semflg)
+int security_sem_associate(struct kern_ipc_perm *sma, int semflg)
 {
 	return call_int_hook(sem_associate, 0, sma, semflg);
 }
 
-int security_sem_semctl(struct sem_array *sma, int cmd)
+int security_sem_semctl(struct kern_ipc_perm *sma, int cmd)
 {
 	return call_int_hook(sem_semctl, 0, sma, cmd);
 }
 
-int security_sem_semop(struct sem_array *sma, struct sembuf *sops,
+int security_sem_semop(struct kern_ipc_perm *sma, struct sembuf *sops,
 			unsigned nsops, int alter)
 {
 	return call_int_hook(sem_semop, 0, sma, sops, nsops, alter);

commit 6b4f3d01052a479c7ebbe99d52a663558dc1be2a
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Fri Sep 8 12:40:01 2017 -0400

    usb, signal, security: only pass the cred, not the secid, to kill_pid_info_as_cred and security_task_kill
    
    commit d178bc3a708f39cbfefc3fab37032d3f2511b4ec ("user namespace: usb:
     make usb urbs user namespace aware (v2)") changed kill_pid_info_as_uid
    to kill_pid_info_as_cred, saving and passing a cred structure instead of
    uids.  Since the secid can be obtained from the cred, drop the secid fields
    from the usb_dev_state and async structures, and drop the secid argument to
    kill_pid_info_as_cred.  Replace the secid argument to security_task_kill
    with the cred.  Update SELinux, Smack, and AppArmor to use the cred, which
    avoids the need for Smack and AppArmor to use a secid at all in this hook.
    Further changes to Smack might still be required to take full advantage of
    this change, since it should now be possible to perform capability
    checking based on the supplied cred.  The changes to Smack and AppArmor
    have only been compile-tested.
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/security.c b/security/security.c
index 1cd8526cb0b7..14c291910d25 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1114,9 +1114,9 @@ int security_task_movememory(struct task_struct *p)
 }
 
 int security_task_kill(struct task_struct *p, struct siginfo *info,
-			int sig, u32 secid)
+			int sig, const struct cred *cred)
 {
-	return call_int_hook(task_kill, 0, p, info, sig, secid);
+	return call_int_hook(task_kill, 0, p, info, sig, cred);
 }
 
 int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,

commit 72e89f50084c6dbc58a00aeedf92c450dc1a8b1c
Author: Richard Haines <richard_c_haines@btinternet.com>
Date:   Tue Feb 13 20:53:21 2018 +0000

    security: Add support for SCTP security hooks
    
    The SCTP security hooks are explained in:
    Documentation/security/LSM-sctp.rst
    
    Signed-off-by: Richard Haines <richard_c_haines@btinternet.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index 1cd8526cb0b7..133bc9915f18 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1473,6 +1473,7 @@ void security_inet_conn_established(struct sock *sk,
 {
 	call_void_hook(inet_conn_established, sk, skb);
 }
+EXPORT_SYMBOL(security_inet_conn_established);
 
 int security_secmark_relabel_packet(u32 secid)
 {
@@ -1528,6 +1529,27 @@ int security_tun_dev_open(void *security)
 }
 EXPORT_SYMBOL(security_tun_dev_open);
 
+int security_sctp_assoc_request(struct sctp_endpoint *ep, struct sk_buff *skb)
+{
+	return call_int_hook(sctp_assoc_request, 0, ep, skb);
+}
+EXPORT_SYMBOL(security_sctp_assoc_request);
+
+int security_sctp_bind_connect(struct sock *sk, int optname,
+			       struct sockaddr *address, int addrlen)
+{
+	return call_int_hook(sctp_bind_connect, 0, sk, optname,
+			     address, addrlen);
+}
+EXPORT_SYMBOL(security_sctp_bind_connect);
+
+void security_sctp_sk_clone(struct sctp_endpoint *ep, struct sock *sk,
+			    struct sock *newsk)
+{
+	call_void_hook(sctp_sk_clone, ep, sk, newsk);
+}
+EXPORT_SYMBOL(security_sctp_sk_clone);
+
 #endif	/* CONFIG_SECURITY_NETWORK */
 
 #ifdef CONFIG_SECURITY_INFINIBAND

commit afdb09c720b62b8090584c11151d856df330e57d
Author: Chenbo Feng <fengc@google.com>
Date:   Wed Oct 18 13:00:24 2017 -0700

    security: bpf: Add LSM hooks for bpf object related syscall
    
    Introduce several LSM hooks for the syscalls that will allow the
    userspace to access to eBPF object such as eBPF programs and eBPF maps.
    The security check is aimed to enforce a per object security protection
    for eBPF object so only processes with the right priviliges can
    read/write to a specific map or use a specific eBPF program. Besides
    that, a general security hook is added before the multiplexer of bpf
    syscall to check the cmd and the attribute used for the command. The
    actual security module can decide which command need to be checked and
    how the cmd should be checked.
    
    Signed-off-by: Chenbo Feng <fengc@google.com>
    Acked-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index 4bf0f571b4ef..1cd8526cb0b7 100644
--- a/security/security.c
+++ b/security/security.c
@@ -12,6 +12,7 @@
  *	(at your option) any later version.
  */
 
+#include <linux/bpf.h>
 #include <linux/capability.h>
 #include <linux/dcache.h>
 #include <linux/module.h>
@@ -1703,3 +1704,34 @@ int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
 				actx);
 }
 #endif /* CONFIG_AUDIT */
+
+#ifdef CONFIG_BPF_SYSCALL
+int security_bpf(int cmd, union bpf_attr *attr, unsigned int size)
+{
+	return call_int_hook(bpf, 0, cmd, attr, size);
+}
+int security_bpf_map(struct bpf_map *map, fmode_t fmode)
+{
+	return call_int_hook(bpf_map, 0, map, fmode);
+}
+int security_bpf_prog(struct bpf_prog *prog)
+{
+	return call_int_hook(bpf_prog, 0, prog);
+}
+int security_bpf_map_alloc(struct bpf_map *map)
+{
+	return call_int_hook(bpf_map_alloc_security, 0, map);
+}
+int security_bpf_prog_alloc(struct bpf_prog_aux *aux)
+{
+	return call_int_hook(bpf_prog_alloc_security, 0, aux);
+}
+void security_bpf_map_free(struct bpf_map *map)
+{
+	call_void_hook(bpf_map_free_security, map);
+}
+void security_bpf_prog_free(struct bpf_prog_aux *aux)
+{
+	call_void_hook(bpf_prog_free_security, aux);
+}
+#endif /* CONFIG_BPF_SYSCALL */

commit 7f85565a3f7194b966de71926471d69788b6b9c3
Merge: 680352bda57e 0c3014f22dec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 12 13:21:00 2017 -0700

    Merge tag 'selinux-pr-20170831' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux
    
    Pull selinux updates from Paul Moore:
     "A relatively quiet period for SELinux, 11 patches with only two/three
      having any substantive changes.
    
      These noteworthy changes include another tweak to the NNP/nosuid
      handling, per-file labeling for cgroups, and an object class fix for
      AF_UNIX/SOCK_RAW sockets; the rest of the changes are minor tweaks or
      administrative updates (Stephen's email update explains the file
      explosion in the diffstat).
    
      Everything passes the selinux-testsuite"
    
    [ Also a couple of small patches from the security tree from Tetsuo
      Handa for Tomoyo and LSM cleanup. The separation of security policy
      updates wasn't all that clean - Linus ]
    
    * tag 'selinux-pr-20170831' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux:
      selinux: constify nf_hook_ops
      selinux: allow per-file labeling for cgroupfs
      lsm_audit: update my email address
      selinux: update my email address
      MAINTAINERS: update the NetLabel and Labeled Networking information
      selinux: use GFP_NOWAIT in the AVC kmem_caches
      selinux: Generalize support for NNP/nosuid SELinux domain transitions
      selinux: genheaders should fail if too many permissions are defined
      selinux: update the selinux info in MAINTAINERS
      credits: update Paul Moore's info
      selinux: Assign proper class to PF_UNIX/SOCK_RAW sockets
      tomoyo: Update URLs in Documentation/admin-guide/LSM/tomoyo.rst
      LSM: Remove security_task_create() hook.

commit 2af622802696e1dbe28d81c8ea6355dc30800396
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jul 18 15:25:29 2017 -0700

    LSM: drop bprm_secureexec hook
    
    This removes the bprm_secureexec hook since the logic has been folded into
    the bprm_set_creds hook for all LSMs now.
    
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: John Johansen <john.johansen@canonical.com>
    Acked-by: James Morris <james.l.morris@oracle.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>

diff --git a/security/security.c b/security/security.c
index 30132378d103..afc34f46c6c5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -351,11 +351,6 @@ void security_bprm_committed_creds(struct linux_binprm *bprm)
 	call_void_hook(bprm_committed_creds, bprm);
 }
 
-int security_bprm_secureexec(struct linux_binprm *bprm)
-{
-	return call_int_hook(bprm_secureexec, 0, bprm);
-}
-
 int security_sb_alloc(struct super_block *sb)
 {
 	return call_int_hook(sb_alloc_security, 0, sb);

commit 3cf29931453215536916d0c4da953fce1911ced3
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Fri Jul 14 19:38:36 2017 +0900

    LSM: Remove security_task_create() hook.
    
    Since commit a79be238600d1a03 ("selinux: Use task_alloc hook rather than
    task_create hook") changed to use task_alloc hook, task_create hook is
    no longer used.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 30132378d103..55b5997e4b72 100644
--- a/security/security.c
+++ b/security/security.c
@@ -979,11 +979,6 @@ int security_file_open(struct file *file, const struct cred *cred)
 	return fsnotify_perm(file, MAY_OPEN);
 }
 
-int security_task_create(unsigned long clone_flags)
-{
-	return call_int_hook(task_create, 0, clone_flags);
-}
-
 int security_task_alloc(struct task_struct *task, unsigned long clone_flags)
 {
 	return call_int_hook(task_alloc, 0, task, clone_flags);

commit 0b4d3452b8b4a5309b4445b900e3cec022cca95a
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Mon Jun 5 11:45:04 2017 -0400

    security/selinux: allow security_sb_clone_mnt_opts to enable/disable native labeling behavior
    
    When an NFSv4 client performs a mount operation, it first mounts the
    NFSv4 root and then does path walk to the exported path and performs a
    submount on that, cloning the security mount options from the root's
    superblock to the submount's superblock in the process.
    
    Unless the NFS server has an explicit fsid=0 export with the
    "security_label" option, the NFSv4 root superblock will not have
    SBLABEL_MNT set, and neither will the submount superblock after cloning
    the security mount options.  As a result, setxattr's of security labels
    over NFSv4.2 will fail.  In a similar fashion, NFSv4.2 mounts mounted
    with the context= mount option will not show the correct labels because
    the nfs_server->caps flags of the cloned superblock will still have
    NFS_CAP_SECURITY_LABEL set.
    
    Allowing the NFSv4 client to enable or disable SECURITY_LSM_NATIVE_LABELS
    behavior will ensure that the SBLABEL_MNT flag has the correct value
    when the client traverses from an exported path without the
    "security_label" option to one with the "security_label" option and
    vice versa.  Similarly, checking to see if SECURITY_LSM_NATIVE_LABELS is
    set upon return from security_sb_clone_mnt_opts() and clearing
    NFS_CAP_SECURITY_LABEL if necessary will allow the correct labels to
    be displayed for NFSv4.2 mounts mounted with the context= mount option.
    
    Resolves: https://github.com/SELinuxProject/selinux-kernel/issues/35
    
    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Reviewed-by: Stephen Smalley <sds@tycho.nsa.gov>
    Tested-by: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index 714433e3e9a2..30132378d103 100644
--- a/security/security.c
+++ b/security/security.c
@@ -420,9 +420,12 @@ int security_sb_set_mnt_opts(struct super_block *sb,
 EXPORT_SYMBOL(security_sb_set_mnt_opts);
 
 int security_sb_clone_mnt_opts(const struct super_block *oldsb,
-				struct super_block *newsb)
+				struct super_block *newsb,
+				unsigned long kern_flags,
+				unsigned long *set_kern_flags)
 {
-	return call_int_hook(sb_clone_mnt_opts, 0, oldsb, newsb);
+	return call_int_hook(sb_clone_mnt_opts, 0, oldsb, newsb,
+				kern_flags, set_kern_flags);
 }
 EXPORT_SYMBOL(security_sb_clone_mnt_opts);
 

commit 47a2b338fe63200d716d2e24131cdb49f17c77da
Author: Daniel Jurgens <danielj@mellanox.com>
Date:   Fri May 19 15:48:54 2017 +0300

    IB/core: Enforce security on management datagrams
    
    Allocate and free a security context when creating and destroying a MAD
    agent.  This context is used for controlling access to PKeys and sending
    and receiving SMPs.
    
    When sending or receiving a MAD check that the agent has permission to
    access the PKey for the Subnet Prefix of the port.
    
    During MAD and snoop agent registration for SMI QPs check that the
    calling process has permission to access the manage the subnet  and
    register a callback with the LSM to be notified of policy changes. When
    notificaiton of a policy change occurs recheck permission and set a flag
    indicating sending and receiving SMPs is allowed.
    
    When sending and receiving MADs check that the agent has access to the
    SMI if it's on an SMI QP.  Because security policy can change it's
    possible permission was allowed when creating the agent, but no longer
    is.
    
    Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
    Acked-by: Doug Ledford <dledford@redhat.com>
    [PM: remove the LSM hook init code]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index b59be0d6535f..714433e3e9a2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1544,6 +1544,12 @@ int security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey)
 }
 EXPORT_SYMBOL(security_ib_pkey_access);
 
+int security_ib_endport_manage_subnet(void *sec, const char *dev_name, u8 port_num)
+{
+	return call_int_hook(ib_endport_manage_subnet, 0, sec, dev_name, port_num);
+}
+EXPORT_SYMBOL(security_ib_endport_manage_subnet);
+
 int security_ib_alloc_security(void **sec)
 {
 	return call_int_hook(ib_alloc_security, 0, sec);

commit 8f408ab64be6319cb7736cbc6982838dcc362306
Author: Daniel Jurgens <danielj@mellanox.com>
Date:   Fri May 19 15:48:53 2017 +0300

    selinux lsm IB/core: Implement LSM notification system
    
    Add a generic notificaiton mechanism in the LSM. Interested consumers
    can register a callback with the LSM and security modules can produce
    events.
    
    Because access to Infiniband QPs are enforced in the setup phase of a
    connection security should be enforced again if the policy changes.
    Register infiniband devices for policy change notification and check all
    QPs on that device when the notification is received.
    
    Add a call to the notification mechanism from SELinux when the AVC
    cache changes or setenforce is cleared.
    
    Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
    Acked-by: James Morris <james.l.morris@oracle.com>
    Acked-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index 2a9d1a7fa1f8..b59be0d6535f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -35,6 +35,8 @@
 #define SECURITY_NAME_MAX	10
 
 struct security_hook_heads security_hook_heads __lsm_ro_after_init;
+static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);
+
 char *lsm_names;
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
@@ -166,6 +168,24 @@ void __init security_add_hooks(struct security_hook_list *hooks, int count,
 		panic("%s - Cannot get early memory.\n", __func__);
 }
 
+int call_lsm_notifier(enum lsm_event event, void *data)
+{
+	return atomic_notifier_call_chain(&lsm_notifier_chain, event, data);
+}
+EXPORT_SYMBOL(call_lsm_notifier);
+
+int register_lsm_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&lsm_notifier_chain, nb);
+}
+EXPORT_SYMBOL(register_lsm_notifier);
+
+int unregister_lsm_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&lsm_notifier_chain, nb);
+}
+EXPORT_SYMBOL(unregister_lsm_notifier);
+
 /*
  * Hook list operation macros.
  *

commit d291f1a6523292d916fe1659c67f6db061fbd1b5
Author: Daniel Jurgens <danielj@mellanox.com>
Date:   Fri May 19 15:48:52 2017 +0300

    IB/core: Enforce PKey security on QPs
    
    Add new LSM hooks to allocate and free security contexts and check for
    permission to access a PKey.
    
    Allocate and free a security context when creating and destroying a QP.
    This context is used for controlling access to PKeys.
    
    When a request is made to modify a QP that changes the port, PKey index,
    or alternate path, check that the QP has permission for the PKey in the
    PKey table index on the subnet prefix of the port. If the QP is shared
    make sure all handles to the QP also have access.
    
    Store which port and PKey index a QP is using. After the reset to init
    transition the user can modify the port, PKey index and alternate path
    independently. So port and PKey settings changes can be a merge of the
    previous settings and the new ones.
    
    In order to maintain access control if there are PKey table or subnet
    prefix change keep a list of all QPs are using each PKey index on
    each port. If a change occurs all QPs using that device and port must
    have access enforced for the new cache settings.
    
    These changes add a transaction to the QP modify process. Association
    with the old port and PKey index must be maintained if the modify fails,
    and must be removed if it succeeds. Association with the new port and
    PKey index must be established prior to the modify and removed if the
    modify fails.
    
    1. When a QP is modified to a particular Port, PKey index or alternate
       path insert that QP into the appropriate lists.
    
    2. Check permission to access the new settings.
    
    3. If step 2 grants access attempt to modify the QP.
    
    4a. If steps 2 and 3 succeed remove any prior associations.
    
    4b. If ether fails remove the new setting associations.
    
    If a PKey table or subnet prefix changes walk the list of QPs and
    check that they have permission. If not send the QP to the error state
    and raise a fatal error event. If it's a shared QP make sure all the
    QPs that share the real_qp have permission as well. If the QP that
    owns a security structure is denied access the security structure is
    marked as such and the QP is added to an error_list. Once the moving
    the QP to error is complete the security structure mark is cleared.
    
    Maintaining the lists correctly turns QP destroy into a transaction.
    The hardware driver for the device frees the ib_qp structure, so while
    the destroy is in progress the ib_qp pointer in the ib_qp_security
    struct is undefined. When the destroy process begins the ib_qp_security
    structure is marked as destroying. This prevents any action from being
    taken on the QP pointer. After the QP is destroyed successfully it
    could still listed on an error_list wait for it to be processed by that
    flow before cleaning up the structure.
    
    If the destroy fails the QPs port and PKey settings are reinserted into
    the appropriate lists, the destroying flag is cleared, and access control
    is enforced, in case there were any cache changes during the destroy
    flow.
    
    To keep the security changes isolated a new file is used to hold security
    related functionality.
    
    Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
    Acked-by: Doug Ledford <dledford@redhat.com>
    [PM: merge fixup in ib_verbs.h and uverbs_cmd.c]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index 38316bb28b16..2a9d1a7fa1f8 100644
--- a/security/security.c
+++ b/security/security.c
@@ -4,6 +4,7 @@
  * Copyright (C) 2001 WireX Communications, Inc <chris@wirex.com>
  * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
  * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>
+ * Copyright (C) 2016 Mellanox Technologies
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -1515,6 +1516,27 @@ EXPORT_SYMBOL(security_tun_dev_open);
 
 #endif	/* CONFIG_SECURITY_NETWORK */
 
+#ifdef CONFIG_SECURITY_INFINIBAND
+
+int security_ib_pkey_access(void *sec, u64 subnet_prefix, u16 pkey)
+{
+	return call_int_hook(ib_pkey_access, 0, sec, subnet_prefix, pkey);
+}
+EXPORT_SYMBOL(security_ib_pkey_access);
+
+int security_ib_alloc_security(void **sec)
+{
+	return call_int_hook(ib_alloc_security, 0, sec);
+}
+EXPORT_SYMBOL(security_ib_alloc_security);
+
+void security_ib_free_security(void *sec)
+{
+	call_void_hook(ib_free_security, sec);
+}
+EXPORT_SYMBOL(security_ib_free_security);
+#endif	/* CONFIG_SECURITY_INFINIBAND */
+
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 
 int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,

commit d68c51e0b377838dd31b37707813bb62089f399c
Merge: 99c55fb18fc4 08332893e37a
Author: James Morris <james.l.morris@oracle.com>
Date:   Mon May 22 16:32:40 2017 +1000

    Sync to mainline for security submaintainers to work against

commit 3bb857e47e49f72352249c938aa8b9159d636530
Author: Mickal Salan <mic@digikod.net>
Date:   Wed May 10 22:48:48 2017 +0200

    LSM: Enable multiple calls to security_add_hooks() for the same LSM
    
    The commit d69dece5f5b6 ("LSM: Add /sys/kernel/security/lsm") extend
    security_add_hooks() with a new parameter to register the LSM name,
    which may be useful to make the list of currently loaded LSM available
    to userspace. However, there is no clean way for an LSM to split its
    hook declarations into multiple files, which may reduce the mess with
    all the included files (needed for LSM hook argument types) and make the
    source code easier to review and maintain.
    
    This change allows an LSM to register multiple times its hook while
    keeping a consistent list of LSM names as described in
    Documentation/security/LSM.txt . The list reflects the order in which
    checks are made. This patch only check for the last registered LSM. If
    an LSM register multiple times its hooks, interleaved with other LSM
    registrations (which should not happen), its name will still appear in
    the same order that the hooks are called, hence multiple times.
    
    To sum up, "capability,selinux,foo,foo" will be replaced with
    "capability,selinux,foo", however "capability,foo,selinux,foo" will
    remain as is.
    
    Signed-off-by: Mickal Salan <mic@digikod.net>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 549bddcc2116..54b1e395978a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -25,6 +25,7 @@
 #include <linux/mount.h>
 #include <linux/personality.h>
 #include <linux/backing-dev.h>
+#include <linux/string.h>
 #include <net/flow.h>
 
 #define MAX_LSM_EVM_XATTR	2
@@ -86,6 +87,21 @@ static int __init choose_lsm(char *str)
 }
 __setup("security=", choose_lsm);
 
+static bool match_last_lsm(const char *list, const char *lsm)
+{
+	const char *last;
+
+	if (WARN_ON(!list || !lsm))
+		return false;
+	last = strrchr(list, ',');
+	if (last)
+		/* Pass the comma, strcmp() will check for '\0' */
+		last++;
+	else
+		last = list;
+	return !strcmp(last, lsm);
+}
+
 static int lsm_append(char *new, char **result)
 {
 	char *cp;
@@ -93,6 +109,9 @@ static int lsm_append(char *new, char **result)
 	if (*result == NULL) {
 		*result = kstrdup(new, GFP_KERNEL);
 	} else {
+		/* Check if it is the last registered name */
+		if (match_last_lsm(*result, new))
+			return 0;
 		cp = kasprintf(GFP_KERNEL, "%s,%s", *result, new);
 		if (cp == NULL)
 			return -ENOMEM;

commit 0302e28dee643932ee7b3c112ebccdbb9f8ec32c
Merge: 89c9fea3c803 8979b02aaf1d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 3 08:50:52 2017 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Highlights:
    
      IMA:
       - provide ">" and "<" operators for fowner/uid/euid rules
    
      KEYS:
       - add a system blacklist keyring
    
       - add KEYCTL_RESTRICT_KEYRING, exposes keyring link restriction
         functionality to userland via keyctl()
    
      LSM:
       - harden LSM API with __ro_after_init
    
       - add prlmit security hook, implement for SELinux
    
       - revive security_task_alloc hook
    
      TPM:
       - implement contextual TPM command 'spaces'"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (98 commits)
      tpm: Fix reference count to main device
      tpm_tis: convert to using locality callbacks
      tpm: fix handling of the TPM 2.0 event logs
      tpm_crb: remove a cruft constant
      keys: select CONFIG_CRYPTO when selecting DH / KDF
      apparmor: Make path_max parameter readonly
      apparmor: fix parameters so that the permission test is bypassed at boot
      apparmor: fix invalid reference to index variable of iterator line 836
      apparmor: use SHASH_DESC_ON_STACK
      security/apparmor/lsm.c: set debug messages
      apparmor: fix boolreturn.cocci warnings
      Smack: Use GFP_KERNEL for smk_netlbl_mls().
      smack: fix double free in smack_parse_opts_str()
      KEYS: add SP800-56A KDF support for DH
      KEYS: Keyring asymmetric key restrict method with chaining
      KEYS: Restrict asymmetric key linkage using a specific keychain
      KEYS: Add a lookup_restriction function for the asymmetric key type
      KEYS: Add KEYCTL_RESTRICT_KEYRING
      KEYS: Consistent ordering for __key_link_begin and restrict check
      KEYS: Add an optional lookup_restriction hook to key_type
      ...

commit 0e056eb5530da802c07f080d6bbd43c50e799efd
Author: mchehab@s-opensource.com <mchehab@s-opensource.com>
Date:   Thu Mar 30 17:11:36 2017 -0300

    kernel-api.rst: fix a series of errors when parsing C files
    
    ./lib/string.c:134: WARNING: Inline emphasis start-string without end-string.
    ./mm/filemap.c:522: WARNING: Inline interpreted text or phrase reference start-string without end-string.
    ./mm/filemap.c:1283: ERROR: Unexpected indentation.
    ./mm/filemap.c:3003: WARNING: Inline interpreted text or phrase reference start-string without end-string.
    ./mm/vmalloc.c:1544: WARNING: Inline emphasis start-string without end-string.
    ./mm/page_alloc.c:4245: ERROR: Unexpected indentation.
    ./ipc/util.c:676: ERROR: Unexpected indentation.
    ./drivers/pci/irq.c:35: WARNING: Block quote ends without a blank line; unexpected unindent.
    ./security/security.c:109: ERROR: Unexpected indentation.
    ./security/security.c:110: WARNING: Definition list ends without a blank line; unexpected unindent.
    ./block/genhd.c:275: WARNING: Inline strong start-string without end-string.
    ./block/genhd.c:283: WARNING: Inline strong start-string without end-string.
    ./include/linux/clk.h:134: WARNING: Inline emphasis start-string without end-string.
    ./include/linux/clk.h:134: WARNING: Inline emphasis start-string without end-string.
    ./ipc/util.c:477: ERROR: Unknown target name: "s".
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/security/security.c b/security/security.c
index d0e07f269b2d..23555c5504f6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -103,10 +103,14 @@ static int lsm_append(char *new, char **result)
  * to avoid security registration races. This method may also be used
  * to check if your LSM is currently loaded during kernel initialization.
  *
- * Return true if:
- *	-The passed LSM is the one chosen by user at boot time,
- *	-or the passed LSM is configured as the default and the user did not
- *	 choose an alternate LSM at boot time.
+ * Returns:
+ *
+ * true if:
+ *
+ * - The passed LSM is the one chosen by user at boot time,
+ * - or the passed LSM is configured as the default and the user did not
+ *   choose an alternate LSM at boot time.
+ *
  * Otherwise, return false.
  */
 int __init security_module_enable(const char *module)

commit e4e55b47ed9ae2c05ff062601ff6dacbe9dc4775
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Fri Mar 24 20:46:33 2017 +0900

    LSM: Revive security_task_alloc() hook and per "struct task_struct" security blob.
    
    We switched from "struct task_struct"->security to "struct cred"->security
    in Linux 2.6.29. But not all LSM modules were happy with that change.
    TOMOYO LSM module is an example which want to use per "struct task_struct"
    security blob, for TOMOYO's security context is defined based on "struct
    task_struct" rather than "struct cred". AppArmor LSM module is another
    example which want to use it, for AppArmor is currently abusing the cred
    a little bit to store the change_hat and setexeccon info. Although
    security_task_free() hook was revived in Linux 3.4 because Yama LSM module
    wanted to release per "struct task_struct" security blob,
    security_task_alloc() hook and "struct task_struct"->security field were
    not revived. Nowadays, we are getting proposals of lightweight LSM modules
    which want to use per "struct task_struct" security blob.
    
    We are already allowing multiple concurrent LSM modules (up to one fully
    armored module which uses "struct cred"->security field or exclusive hooks
    like security_xfrm_state_pol_flow_match(), plus unlimited number of
    lightweight modules which do not use "struct cred"->security nor exclusive
    hooks) as long as they are built into the kernel. But this patch does not
    implement variable length "struct task_struct"->security field which will
    become needed when multiple LSM modules want to use "struct task_struct"->
    security field. Although it won't be difficult to implement variable length
    "struct task_struct"->security field, let's think about it after we merged
    this patch.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Tested-by: Djalal Harouni <tixxdz@gmail.com>
    Acked-by: Jos Bollo <jobol@nonadev.net>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: James Morris <james.l.morris@oracle.com>
    Cc: Jos Bollo <jobol@nonadev.net>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 2f15488dc6bc..549bddcc2116 100644
--- a/security/security.c
+++ b/security/security.c
@@ -937,6 +937,11 @@ int security_task_create(unsigned long clone_flags)
 	return call_int_hook(task_create, 0, clone_flags);
 }
 
+int security_task_alloc(struct task_struct *task, unsigned long clone_flags)
+{
+	return call_int_hook(task_alloc, 0, task, clone_flags);
+}
+
 void security_task_free(struct task_struct *task)
 {
 	call_void_hook(task_free, task);

commit 3dfc9b02864b19f4dab376f14479ee4ad1de6c9e
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Wed Mar 22 19:46:19 2017 +0900

    LSM: Initialize security_hook_heads upon registration.
    
    "struct security_hook_heads" is an array of "struct list_head"
    where elements can be initialized just before registration.
    
    There is no need to waste 350+ lines for initialization. Let's
    initialize "struct security_hook_heads" just before registration.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: James Morris <james.l.morris@oracle.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index d6d18a3721aa..2f15488dc6bc 100644
--- a/security/security.c
+++ b/security/security.c
@@ -32,6 +32,7 @@
 /* Maximum number of letters for an LSM name string */
 #define SECURITY_NAME_MAX	10
 
+struct security_hook_heads security_hook_heads __lsm_ro_after_init;
 char *lsm_names;
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
@@ -54,6 +55,12 @@ static void __init do_security_initcalls(void)
  */
 int __init security_init(void)
 {
+	int i;
+	struct list_head *list = (struct list_head *) &security_hook_heads;
+
+	for (i = 0; i < sizeof(security_hook_heads) / sizeof(struct list_head);
+	     i++)
+		INIT_LIST_HEAD(&list[i]);
 	pr_info("Security Framework initialized\n");
 
 	/*
@@ -1627,357 +1634,3 @@ int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
 				actx);
 }
 #endif /* CONFIG_AUDIT */
-
-struct security_hook_heads security_hook_heads __lsm_ro_after_init = {
-	.binder_set_context_mgr =
-		LIST_HEAD_INIT(security_hook_heads.binder_set_context_mgr),
-	.binder_transaction =
-		LIST_HEAD_INIT(security_hook_heads.binder_transaction),
-	.binder_transfer_binder =
-		LIST_HEAD_INIT(security_hook_heads.binder_transfer_binder),
-	.binder_transfer_file =
-		LIST_HEAD_INIT(security_hook_heads.binder_transfer_file),
-
-	.ptrace_access_check =
-		LIST_HEAD_INIT(security_hook_heads.ptrace_access_check),
-	.ptrace_traceme =
-		LIST_HEAD_INIT(security_hook_heads.ptrace_traceme),
-	.capget =	LIST_HEAD_INIT(security_hook_heads.capget),
-	.capset =	LIST_HEAD_INIT(security_hook_heads.capset),
-	.capable =	LIST_HEAD_INIT(security_hook_heads.capable),
-	.quotactl =	LIST_HEAD_INIT(security_hook_heads.quotactl),
-	.quota_on =	LIST_HEAD_INIT(security_hook_heads.quota_on),
-	.syslog =	LIST_HEAD_INIT(security_hook_heads.syslog),
-	.settime =	LIST_HEAD_INIT(security_hook_heads.settime),
-	.vm_enough_memory =
-		LIST_HEAD_INIT(security_hook_heads.vm_enough_memory),
-	.bprm_set_creds =
-		LIST_HEAD_INIT(security_hook_heads.bprm_set_creds),
-	.bprm_check_security =
-		LIST_HEAD_INIT(security_hook_heads.bprm_check_security),
-	.bprm_secureexec =
-		LIST_HEAD_INIT(security_hook_heads.bprm_secureexec),
-	.bprm_committing_creds =
-		LIST_HEAD_INIT(security_hook_heads.bprm_committing_creds),
-	.bprm_committed_creds =
-		LIST_HEAD_INIT(security_hook_heads.bprm_committed_creds),
-	.sb_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.sb_alloc_security),
-	.sb_free_security =
-		LIST_HEAD_INIT(security_hook_heads.sb_free_security),
-	.sb_copy_data =	LIST_HEAD_INIT(security_hook_heads.sb_copy_data),
-	.sb_remount =	LIST_HEAD_INIT(security_hook_heads.sb_remount),
-	.sb_kern_mount =
-		LIST_HEAD_INIT(security_hook_heads.sb_kern_mount),
-	.sb_show_options =
-		LIST_HEAD_INIT(security_hook_heads.sb_show_options),
-	.sb_statfs =	LIST_HEAD_INIT(security_hook_heads.sb_statfs),
-	.sb_mount =	LIST_HEAD_INIT(security_hook_heads.sb_mount),
-	.sb_umount =	LIST_HEAD_INIT(security_hook_heads.sb_umount),
-	.sb_pivotroot =	LIST_HEAD_INIT(security_hook_heads.sb_pivotroot),
-	.sb_set_mnt_opts =
-		LIST_HEAD_INIT(security_hook_heads.sb_set_mnt_opts),
-	.sb_clone_mnt_opts =
-		LIST_HEAD_INIT(security_hook_heads.sb_clone_mnt_opts),
-	.sb_parse_opts_str =
-		LIST_HEAD_INIT(security_hook_heads.sb_parse_opts_str),
-	.dentry_init_security =
-		LIST_HEAD_INIT(security_hook_heads.dentry_init_security),
-	.dentry_create_files_as =
-		LIST_HEAD_INIT(security_hook_heads.dentry_create_files_as),
-#ifdef CONFIG_SECURITY_PATH
-	.path_unlink =	LIST_HEAD_INIT(security_hook_heads.path_unlink),
-	.path_mkdir =	LIST_HEAD_INIT(security_hook_heads.path_mkdir),
-	.path_rmdir =	LIST_HEAD_INIT(security_hook_heads.path_rmdir),
-	.path_mknod =	LIST_HEAD_INIT(security_hook_heads.path_mknod),
-	.path_truncate =
-		LIST_HEAD_INIT(security_hook_heads.path_truncate),
-	.path_symlink =	LIST_HEAD_INIT(security_hook_heads.path_symlink),
-	.path_link =	LIST_HEAD_INIT(security_hook_heads.path_link),
-	.path_rename =	LIST_HEAD_INIT(security_hook_heads.path_rename),
-	.path_chmod =	LIST_HEAD_INIT(security_hook_heads.path_chmod),
-	.path_chown =	LIST_HEAD_INIT(security_hook_heads.path_chown),
-	.path_chroot =	LIST_HEAD_INIT(security_hook_heads.path_chroot),
-#endif
-	.inode_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.inode_alloc_security),
-	.inode_free_security =
-		LIST_HEAD_INIT(security_hook_heads.inode_free_security),
-	.inode_init_security =
-		LIST_HEAD_INIT(security_hook_heads.inode_init_security),
-	.inode_create =	LIST_HEAD_INIT(security_hook_heads.inode_create),
-	.inode_link =	LIST_HEAD_INIT(security_hook_heads.inode_link),
-	.inode_unlink =	LIST_HEAD_INIT(security_hook_heads.inode_unlink),
-	.inode_symlink =
-		LIST_HEAD_INIT(security_hook_heads.inode_symlink),
-	.inode_mkdir =	LIST_HEAD_INIT(security_hook_heads.inode_mkdir),
-	.inode_rmdir =	LIST_HEAD_INIT(security_hook_heads.inode_rmdir),
-	.inode_mknod =	LIST_HEAD_INIT(security_hook_heads.inode_mknod),
-	.inode_rename =	LIST_HEAD_INIT(security_hook_heads.inode_rename),
-	.inode_readlink =
-		LIST_HEAD_INIT(security_hook_heads.inode_readlink),
-	.inode_follow_link =
-		LIST_HEAD_INIT(security_hook_heads.inode_follow_link),
-	.inode_permission =
-		LIST_HEAD_INIT(security_hook_heads.inode_permission),
-	.inode_setattr =
-		LIST_HEAD_INIT(security_hook_heads.inode_setattr),
-	.inode_getattr =
-		LIST_HEAD_INIT(security_hook_heads.inode_getattr),
-	.inode_setxattr =
-		LIST_HEAD_INIT(security_hook_heads.inode_setxattr),
-	.inode_post_setxattr =
-		LIST_HEAD_INIT(security_hook_heads.inode_post_setxattr),
-	.inode_getxattr =
-		LIST_HEAD_INIT(security_hook_heads.inode_getxattr),
-	.inode_listxattr =
-		LIST_HEAD_INIT(security_hook_heads.inode_listxattr),
-	.inode_removexattr =
-		LIST_HEAD_INIT(security_hook_heads.inode_removexattr),
-	.inode_need_killpriv =
-		LIST_HEAD_INIT(security_hook_heads.inode_need_killpriv),
-	.inode_killpriv =
-		LIST_HEAD_INIT(security_hook_heads.inode_killpriv),
-	.inode_getsecurity =
-		LIST_HEAD_INIT(security_hook_heads.inode_getsecurity),
-	.inode_setsecurity =
-		LIST_HEAD_INIT(security_hook_heads.inode_setsecurity),
-	.inode_listsecurity =
-		LIST_HEAD_INIT(security_hook_heads.inode_listsecurity),
-	.inode_getsecid =
-		LIST_HEAD_INIT(security_hook_heads.inode_getsecid),
-	.inode_copy_up =
-		LIST_HEAD_INIT(security_hook_heads.inode_copy_up),
-	.inode_copy_up_xattr =
-		LIST_HEAD_INIT(security_hook_heads.inode_copy_up_xattr),
-	.file_permission =
-		LIST_HEAD_INIT(security_hook_heads.file_permission),
-	.file_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.file_alloc_security),
-	.file_free_security =
-		LIST_HEAD_INIT(security_hook_heads.file_free_security),
-	.file_ioctl =	LIST_HEAD_INIT(security_hook_heads.file_ioctl),
-	.mmap_addr =	LIST_HEAD_INIT(security_hook_heads.mmap_addr),
-	.mmap_file =	LIST_HEAD_INIT(security_hook_heads.mmap_file),
-	.file_mprotect =
-		LIST_HEAD_INIT(security_hook_heads.file_mprotect),
-	.file_lock =	LIST_HEAD_INIT(security_hook_heads.file_lock),
-	.file_fcntl =	LIST_HEAD_INIT(security_hook_heads.file_fcntl),
-	.file_set_fowner =
-		LIST_HEAD_INIT(security_hook_heads.file_set_fowner),
-	.file_send_sigiotask =
-		LIST_HEAD_INIT(security_hook_heads.file_send_sigiotask),
-	.file_receive =	LIST_HEAD_INIT(security_hook_heads.file_receive),
-	.file_open =	LIST_HEAD_INIT(security_hook_heads.file_open),
-	.task_create =	LIST_HEAD_INIT(security_hook_heads.task_create),
-	.task_free =	LIST_HEAD_INIT(security_hook_heads.task_free),
-	.cred_alloc_blank =
-		LIST_HEAD_INIT(security_hook_heads.cred_alloc_blank),
-	.cred_free =	LIST_HEAD_INIT(security_hook_heads.cred_free),
-	.cred_prepare =	LIST_HEAD_INIT(security_hook_heads.cred_prepare),
-	.cred_transfer =
-		LIST_HEAD_INIT(security_hook_heads.cred_transfer),
-	.kernel_act_as =
-		LIST_HEAD_INIT(security_hook_heads.kernel_act_as),
-	.kernel_create_files_as =
-		LIST_HEAD_INIT(security_hook_heads.kernel_create_files_as),
-	.kernel_module_request =
-		LIST_HEAD_INIT(security_hook_heads.kernel_module_request),
-	.kernel_read_file =
-		LIST_HEAD_INIT(security_hook_heads.kernel_read_file),
-	.kernel_post_read_file =
-		LIST_HEAD_INIT(security_hook_heads.kernel_post_read_file),
-	.task_fix_setuid =
-		LIST_HEAD_INIT(security_hook_heads.task_fix_setuid),
-	.task_setpgid =	LIST_HEAD_INIT(security_hook_heads.task_setpgid),
-	.task_getpgid =	LIST_HEAD_INIT(security_hook_heads.task_getpgid),
-	.task_getsid =	LIST_HEAD_INIT(security_hook_heads.task_getsid),
-	.task_getsecid =
-		LIST_HEAD_INIT(security_hook_heads.task_getsecid),
-	.task_setnice =	LIST_HEAD_INIT(security_hook_heads.task_setnice),
-	.task_setioprio =
-		LIST_HEAD_INIT(security_hook_heads.task_setioprio),
-	.task_getioprio =
-		LIST_HEAD_INIT(security_hook_heads.task_getioprio),
-	.task_prlimit =
-		LIST_HEAD_INIT(security_hook_heads.task_prlimit),
-	.task_setrlimit =
-		LIST_HEAD_INIT(security_hook_heads.task_setrlimit),
-	.task_setscheduler =
-		LIST_HEAD_INIT(security_hook_heads.task_setscheduler),
-	.task_getscheduler =
-		LIST_HEAD_INIT(security_hook_heads.task_getscheduler),
-	.task_movememory =
-		LIST_HEAD_INIT(security_hook_heads.task_movememory),
-	.task_kill =	LIST_HEAD_INIT(security_hook_heads.task_kill),
-	.task_prctl =	LIST_HEAD_INIT(security_hook_heads.task_prctl),
-	.task_to_inode =
-		LIST_HEAD_INIT(security_hook_heads.task_to_inode),
-	.ipc_permission =
-		LIST_HEAD_INIT(security_hook_heads.ipc_permission),
-	.ipc_getsecid =	LIST_HEAD_INIT(security_hook_heads.ipc_getsecid),
-	.msg_msg_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.msg_msg_alloc_security),
-	.msg_msg_free_security =
-		LIST_HEAD_INIT(security_hook_heads.msg_msg_free_security),
-	.msg_queue_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.msg_queue_alloc_security),
-	.msg_queue_free_security =
-		LIST_HEAD_INIT(security_hook_heads.msg_queue_free_security),
-	.msg_queue_associate =
-		LIST_HEAD_INIT(security_hook_heads.msg_queue_associate),
-	.msg_queue_msgctl =
-		LIST_HEAD_INIT(security_hook_heads.msg_queue_msgctl),
-	.msg_queue_msgsnd =
-		LIST_HEAD_INIT(security_hook_heads.msg_queue_msgsnd),
-	.msg_queue_msgrcv =
-		LIST_HEAD_INIT(security_hook_heads.msg_queue_msgrcv),
-	.shm_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.shm_alloc_security),
-	.shm_free_security =
-		LIST_HEAD_INIT(security_hook_heads.shm_free_security),
-	.shm_associate =
-		LIST_HEAD_INIT(security_hook_heads.shm_associate),
-	.shm_shmctl =	LIST_HEAD_INIT(security_hook_heads.shm_shmctl),
-	.shm_shmat =	LIST_HEAD_INIT(security_hook_heads.shm_shmat),
-	.sem_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.sem_alloc_security),
-	.sem_free_security =
-		LIST_HEAD_INIT(security_hook_heads.sem_free_security),
-	.sem_associate =
-		LIST_HEAD_INIT(security_hook_heads.sem_associate),
-	.sem_semctl =	LIST_HEAD_INIT(security_hook_heads.sem_semctl),
-	.sem_semop =	LIST_HEAD_INIT(security_hook_heads.sem_semop),
-	.netlink_send =	LIST_HEAD_INIT(security_hook_heads.netlink_send),
-	.d_instantiate =
-		LIST_HEAD_INIT(security_hook_heads.d_instantiate),
-	.getprocattr =	LIST_HEAD_INIT(security_hook_heads.getprocattr),
-	.setprocattr =	LIST_HEAD_INIT(security_hook_heads.setprocattr),
-	.ismaclabel =	LIST_HEAD_INIT(security_hook_heads.ismaclabel),
-	.secid_to_secctx =
-		LIST_HEAD_INIT(security_hook_heads.secid_to_secctx),
-	.secctx_to_secid =
-		LIST_HEAD_INIT(security_hook_heads.secctx_to_secid),
-	.release_secctx =
-		LIST_HEAD_INIT(security_hook_heads.release_secctx),
-	.inode_invalidate_secctx =
-		LIST_HEAD_INIT(security_hook_heads.inode_invalidate_secctx),
-	.inode_notifysecctx =
-		LIST_HEAD_INIT(security_hook_heads.inode_notifysecctx),
-	.inode_setsecctx =
-		LIST_HEAD_INIT(security_hook_heads.inode_setsecctx),
-	.inode_getsecctx =
-		LIST_HEAD_INIT(security_hook_heads.inode_getsecctx),
-#ifdef CONFIG_SECURITY_NETWORK
-	.unix_stream_connect =
-		LIST_HEAD_INIT(security_hook_heads.unix_stream_connect),
-	.unix_may_send =
-		LIST_HEAD_INIT(security_hook_heads.unix_may_send),
-	.socket_create =
-		LIST_HEAD_INIT(security_hook_heads.socket_create),
-	.socket_post_create =
-		LIST_HEAD_INIT(security_hook_heads.socket_post_create),
-	.socket_bind =	LIST_HEAD_INIT(security_hook_heads.socket_bind),
-	.socket_connect =
-		LIST_HEAD_INIT(security_hook_heads.socket_connect),
-	.socket_listen =
-		LIST_HEAD_INIT(security_hook_heads.socket_listen),
-	.socket_accept =
-		LIST_HEAD_INIT(security_hook_heads.socket_accept),
-	.socket_sendmsg =
-		LIST_HEAD_INIT(security_hook_heads.socket_sendmsg),
-	.socket_recvmsg =
-		LIST_HEAD_INIT(security_hook_heads.socket_recvmsg),
-	.socket_getsockname =
-		LIST_HEAD_INIT(security_hook_heads.socket_getsockname),
-	.socket_getpeername =
-		LIST_HEAD_INIT(security_hook_heads.socket_getpeername),
-	.socket_getsockopt =
-		LIST_HEAD_INIT(security_hook_heads.socket_getsockopt),
-	.socket_setsockopt =
-		LIST_HEAD_INIT(security_hook_heads.socket_setsockopt),
-	.socket_shutdown =
-		LIST_HEAD_INIT(security_hook_heads.socket_shutdown),
-	.socket_sock_rcv_skb =
-		LIST_HEAD_INIT(security_hook_heads.socket_sock_rcv_skb),
-	.socket_getpeersec_stream =
-		LIST_HEAD_INIT(security_hook_heads.socket_getpeersec_stream),
-	.socket_getpeersec_dgram =
-		LIST_HEAD_INIT(security_hook_heads.socket_getpeersec_dgram),
-	.sk_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.sk_alloc_security),
-	.sk_free_security =
-		LIST_HEAD_INIT(security_hook_heads.sk_free_security),
-	.sk_clone_security =
-		LIST_HEAD_INIT(security_hook_heads.sk_clone_security),
-	.sk_getsecid =	LIST_HEAD_INIT(security_hook_heads.sk_getsecid),
-	.sock_graft =	LIST_HEAD_INIT(security_hook_heads.sock_graft),
-	.inet_conn_request =
-		LIST_HEAD_INIT(security_hook_heads.inet_conn_request),
-	.inet_csk_clone =
-		LIST_HEAD_INIT(security_hook_heads.inet_csk_clone),
-	.inet_conn_established =
-		LIST_HEAD_INIT(security_hook_heads.inet_conn_established),
-	.secmark_relabel_packet =
-		LIST_HEAD_INIT(security_hook_heads.secmark_relabel_packet),
-	.secmark_refcount_inc =
-		LIST_HEAD_INIT(security_hook_heads.secmark_refcount_inc),
-	.secmark_refcount_dec =
-		LIST_HEAD_INIT(security_hook_heads.secmark_refcount_dec),
-	.req_classify_flow =
-		LIST_HEAD_INIT(security_hook_heads.req_classify_flow),
-	.tun_dev_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.tun_dev_alloc_security),
-	.tun_dev_free_security =
-		LIST_HEAD_INIT(security_hook_heads.tun_dev_free_security),
-	.tun_dev_create =
-		LIST_HEAD_INIT(security_hook_heads.tun_dev_create),
-	.tun_dev_attach_queue =
-		LIST_HEAD_INIT(security_hook_heads.tun_dev_attach_queue),
-	.tun_dev_attach =
-		LIST_HEAD_INIT(security_hook_heads.tun_dev_attach),
-	.tun_dev_open =	LIST_HEAD_INIT(security_hook_heads.tun_dev_open),
-#endif	/* CONFIG_SECURITY_NETWORK */
-#ifdef CONFIG_SECURITY_NETWORK_XFRM
-	.xfrm_policy_alloc_security =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_alloc_security),
-	.xfrm_policy_clone_security =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_clone_security),
-	.xfrm_policy_free_security =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_free_security),
-	.xfrm_policy_delete_security =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_delete_security),
-	.xfrm_state_alloc =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_state_alloc),
-	.xfrm_state_alloc_acquire =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_state_alloc_acquire),
-	.xfrm_state_free_security =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_state_free_security),
-	.xfrm_state_delete_security =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_state_delete_security),
-	.xfrm_policy_lookup =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_lookup),
-	.xfrm_state_pol_flow_match =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_state_pol_flow_match),
-	.xfrm_decode_session =
-		LIST_HEAD_INIT(security_hook_heads.xfrm_decode_session),
-#endif	/* CONFIG_SECURITY_NETWORK_XFRM */
-#ifdef CONFIG_KEYS
-	.key_alloc =	LIST_HEAD_INIT(security_hook_heads.key_alloc),
-	.key_free =	LIST_HEAD_INIT(security_hook_heads.key_free),
-	.key_permission =
-		LIST_HEAD_INIT(security_hook_heads.key_permission),
-	.key_getsecurity =
-		LIST_HEAD_INIT(security_hook_heads.key_getsecurity),
-#endif	/* CONFIG_KEYS */
-#ifdef CONFIG_AUDIT
-	.audit_rule_init =
-		LIST_HEAD_INIT(security_hook_heads.audit_rule_init),
-	.audit_rule_known =
-		LIST_HEAD_INIT(security_hook_heads.audit_rule_known),
-	.audit_rule_match =
-		LIST_HEAD_INIT(security_hook_heads.audit_rule_match),
-	.audit_rule_free =
-		LIST_HEAD_INIT(security_hook_heads.audit_rule_free),
-#endif /* CONFIG_AUDIT */
-};

commit ca97d939db114c8d1619e10a3b82af8615372dae
Author: James Morris <jmorris@namei.org>
Date:   Wed Feb 15 00:18:51 2017 +1100

    security: mark LSM hooks as __ro_after_init
    
    Mark all of the registration hooks as __ro_after_init (via the
    __lsm_ro_after_init macro).
    
    Signed-off-by: James Morris <james.l.morris@oracle.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 905dad2811d3..d6d18a3721aa 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1628,7 +1628,7 @@ int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
 }
 #endif /* CONFIG_AUDIT */
 
-struct security_hook_heads security_hook_heads = {
+struct security_hook_heads security_hook_heads __lsm_ro_after_init = {
 	.binder_set_context_mgr =
 		LIST_HEAD_INIT(security_hook_heads.binder_set_context_mgr),
 	.binder_transaction =

commit 791ec491c372f49cea3ea7a7143454a9023ac9d4
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Fri Feb 17 07:57:00 2017 -0500

    prlimit,security,selinux: add a security hook for prlimit
    
    When SELinux was first added to the kernel, a process could only get
    and set its own resource limits via getrlimit(2) and setrlimit(2), so no
    MAC checks were required for those operations, and thus no security hooks
    were defined for them. Later, SELinux introduced a hook for setlimit(2)
    with a check if the hard limit was being changed in order to be able to
    rely on the hard limit value as a safe reset point upon context
    transitions.
    
    Later on, when prlimit(2) was added to the kernel with the ability to get
    or set resource limits (hard or soft) of another process, LSM/SELinux was
    not updated other than to pass the target process to the setrlimit hook.
    This resulted in incomplete control over both getting and setting the
    resource limits of another process.
    
    Add a new security_task_prlimit() hook to the check_prlimit_permission()
    function to provide complete mediation.  The hook is only called when
    acting on another task, and only if the existing DAC/capability checks
    would allow access.  Pass flags down to the hook to indicate whether the
    prlimit(2) call will read, write, or both read and write the resource
    limits of the target process.
    
    The existing security_task_setrlimit() hook is left alone; it continues
    to serve a purpose in supporting the ability to make decisions based on
    the old and/or new resource limit values when setting limits.  This
    is consistent with the DAC/capability logic, where
    check_prlimit_permission() performs generic DAC/capability checks for
    acting on another task, while do_prlimit() performs a capability check
    based on a comparison of the old and new resource limits.  Fix the
    inline documentation for the hook to match the code.
    
    Implement the new hook for SELinux.  For setting resource limits, we
    reuse the existing setrlimit permission.  Note that this does overload
    the setrlimit permission to mean the ability to set the resource limit
    (soft or hard) of another process or the ability to change one's own
    hard limit.  For getting resource limits, a new getrlimit permission
    is defined.  This was not originally defined since getrlimit(2) could
    only be used to obtain a process' own limits.
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index d0e07f269b2d..905dad2811d3 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1036,6 +1036,12 @@ int security_task_getioprio(struct task_struct *p)
 	return call_int_hook(task_getioprio, 0, p);
 }
 
+int security_task_prlimit(const struct cred *cred, const struct cred *tcred,
+			  unsigned int flags)
+{
+	return call_int_hook(task_prlimit, 0, cred, tcred, flags);
+}
+
 int security_task_setrlimit(struct task_struct *p, unsigned int resource,
 		struct rlimit *new_rlim)
 {
@@ -1793,6 +1799,8 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.task_setioprio),
 	.task_getioprio =
 		LIST_HEAD_INIT(security_hook_heads.task_getioprio),
+	.task_prlimit =
+		LIST_HEAD_INIT(security_hook_heads.task_prlimit),
 	.task_setrlimit =
 		LIST_HEAD_INIT(security_hook_heads.task_setrlimit),
 	.task_setscheduler =

commit a2a15479d617ebbab67c60b4eed02524536af780
Merge: e2241be62dea 1ea0ce40690d
Author: James Morris <james.l.morris@oracle.com>
Date:   Fri Feb 10 10:28:49 2017 +1100

    Merge branch 'stable-4.11' of git://git.infradead.org/users/pcmoore/selinux into next

commit d69dece5f5b6bc7a5e39d2b6136ddc69469331fe
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Wed Jan 18 17:09:05 2017 -0800

    LSM: Add /sys/kernel/security/lsm
    
    I am still tired of having to find indirect ways to determine
    what security modules are active on a system. I have added
    /sys/kernel/security/lsm, which contains a comma separated
    list of the active security modules. No more groping around
    in /proc/filesystems or other clever hacks.
    
    Unchanged from previous versions except for being updated
    to the latest security next branch.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index f825304f04a7..f0a802ee29b6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -32,6 +32,7 @@
 /* Maximum number of letters for an LSM name string */
 #define SECURITY_NAME_MAX	10
 
+char *lsm_names;
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
@@ -78,6 +79,22 @@ static int __init choose_lsm(char *str)
 }
 __setup("security=", choose_lsm);
 
+static int lsm_append(char *new, char **result)
+{
+	char *cp;
+
+	if (*result == NULL) {
+		*result = kstrdup(new, GFP_KERNEL);
+	} else {
+		cp = kasprintf(GFP_KERNEL, "%s,%s", *result, new);
+		if (cp == NULL)
+			return -ENOMEM;
+		kfree(*result);
+		*result = cp;
+	}
+	return 0;
+}
+
 /**
  * security_module_enable - Load given security module on boot ?
  * @module: the name of the module
@@ -97,6 +114,27 @@ int __init security_module_enable(const char *module)
 	return !strcmp(module, chosen_lsm);
 }
 
+/**
+ * security_add_hooks - Add a modules hooks to the hook lists.
+ * @hooks: the hooks to add
+ * @count: the number of hooks to add
+ * @lsm: the name of the security module
+ *
+ * Each LSM has to register its hooks with the infrastructure.
+ */
+void __init security_add_hooks(struct security_hook_list *hooks, int count,
+				char *lsm)
+{
+	int i;
+
+	for (i = 0; i < count; i++) {
+		hooks[i].lsm = lsm;
+		list_add_tail_rcu(&hooks[i].list, hooks[i].head);
+	}
+	if (lsm_append(lsm, &lsm_names) < 0)
+		panic("%s - Cannot get early memory.\n", __func__);
+}
+
 /*
  * Hook list operation macros.
  *

commit 3a2f5a59a695a73e0cde9a61e0feae5fa730e936
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Tue Jan 10 12:28:32 2017 -0500

    security,selinux,smack: kill security_task_wait hook
    
    As reported by yangshukui, a permission denial from security_task_wait()
    can lead to a soft lockup in zap_pid_ns_processes() since it only expects
    sys_wait4() to return 0 or -ECHILD. Further, security_task_wait() can
    in general lead to zombies; in the absence of some way to automatically
    reparent a child process upon a denial, the hook is not useful.  Remove
    the security hook and its implementations in SELinux and Smack.  Smack
    already removed its check from its hook.
    
    Reported-by: yangshukui <yangshukui@huawei.com>
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index 32052f5c76b2..8c9fee59e60a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1025,11 +1025,6 @@ int security_task_kill(struct task_struct *p, struct siginfo *info,
 	return call_int_hook(task_kill, 0, p, info, sig, secid);
 }
 
-int security_task_wait(struct task_struct *p)
-{
-	return call_int_hook(task_wait, 0, p);
-}
-
 int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 			 unsigned long arg4, unsigned long arg5)
 {
@@ -1769,7 +1764,6 @@ struct security_hook_heads security_hook_heads = {
 	.task_movememory =
 		LIST_HEAD_INIT(security_hook_heads.task_movememory),
 	.task_kill =	LIST_HEAD_INIT(security_hook_heads.task_kill),
-	.task_wait =	LIST_HEAD_INIT(security_hook_heads.task_wait),
 	.task_prctl =	LIST_HEAD_INIT(security_hook_heads.task_prctl),
 	.task_to_inode =
 		LIST_HEAD_INIT(security_hook_heads.task_to_inode),

commit b21507e272627c434e8dd74e8d51fd8245281b59
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Mon Jan 9 10:07:31 2017 -0500

    proc,security: move restriction on writing /proc/pid/attr nodes to proc
    
    Processes can only alter their own security attributes via
    /proc/pid/attr nodes.  This is presently enforced by each individual
    security module and is also imposed by the Linux credentials
    implementation, which only allows a task to alter its own credentials.
    Move the check enforcing this restriction from the individual
    security modules to proc_pid_attr_write() before calling the security hook,
    and drop the unnecessary task argument to the security hook since it can
    only ever be the current task.
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index f825304f04a7..32052f5c76b2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1170,9 +1170,9 @@ int security_getprocattr(struct task_struct *p, char *name, char **value)
 	return call_int_hook(getprocattr, -EINVAL, p, name, value);
 }
 
-int security_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
+int security_setprocattr(const char *name, void *value, size_t size)
 {
-	return call_int_hook(setprocattr, -EINVAL, p, name, value, size);
+	return call_int_hook(setprocattr, -EINVAL, name, value, size);
 }
 
 int security_netlink_send(struct sock *sk, struct sk_buff *skb)

commit 2602625b7e46576b00db619ac788c508ba3bcb2c
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Wed Jul 13 10:44:52 2016 -0400

    security, overlayfs: Provide hook to correctly label newly created files
    
    During a new file creation we need to make sure new file is created with the
    right label. New file is created in upper/ so effectively file should get
    label as if task had created file in upper/.
    
    We switched to mounter's creds for actual file creation. Also if there is a
    whiteout present, then file will be created in work/ dir first and then
    renamed in upper. In none of the cases file will be labeled as we want it to
    be.
    
    This patch introduces a new hook dentry_create_files_as(), which determines
    the label/context dentry will get if it had been created by task in upper
    and modify passed set of creds appropriately. Caller makes use of these new
    creds for file creation.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    [PM: fix whitespace issues found with checkpatch.pl]
    [PM: changes to use stat->mode in ovl_create_or_link()]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index a9e2bb9fb9d3..f825304f04a7 100644
--- a/security/security.c
+++ b/security/security.c
@@ -364,6 +364,15 @@ int security_dentry_init_security(struct dentry *dentry, int mode,
 }
 EXPORT_SYMBOL(security_dentry_init_security);
 
+int security_dentry_create_files_as(struct dentry *dentry, int mode,
+				    struct qstr *name,
+				    const struct cred *old, struct cred *new)
+{
+	return call_int_hook(dentry_create_files_as, 0, dentry, mode,
+				name, old, new);
+}
+EXPORT_SYMBOL(security_dentry_create_files_as);
+
 int security_inode_init_security(struct inode *inode, struct inode *dir,
 				 const struct qstr *qstr,
 				 const initxattrs initxattrs, void *fs_data)
@@ -1635,6 +1644,8 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.sb_parse_opts_str),
 	.dentry_init_security =
 		LIST_HEAD_INIT(security_hook_heads.dentry_init_security),
+	.dentry_create_files_as =
+		LIST_HEAD_INIT(security_hook_heads.dentry_create_files_as),
 #ifdef CONFIG_SECURITY_PATH
 	.path_unlink =	LIST_HEAD_INIT(security_hook_heads.path_unlink),
 	.path_mkdir =	LIST_HEAD_INIT(security_hook_heads.path_mkdir),

commit 121ab822ef21914adac2fa3730efeeb8fd762473
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Wed Jul 13 10:44:49 2016 -0400

    security,overlayfs: Provide security hook for copy up of xattrs for overlay file
    
    Provide a security hook which is called when xattrs of a file are being
    copied up. This hook is called once for each xattr and LSM can return
    0 if the security module wants the xattr to be copied up, 1 if the
    security module wants the xattr to be discarded on the copy, -EOPNOTSUPP
    if the security module does not handle/manage the xattr, or a -errno
    upon an error.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    [PM: whitespace cleanup for checkpatch.pl]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index f2a7f27bd3e9..a9e2bb9fb9d3 100644
--- a/security/security.c
+++ b/security/security.c
@@ -754,6 +754,12 @@ int security_inode_copy_up(struct dentry *src, struct cred **new)
 }
 EXPORT_SYMBOL(security_inode_copy_up);
 
+int security_inode_copy_up_xattr(const char *name)
+{
+	return call_int_hook(inode_copy_up_xattr, -EOPNOTSUPP, name);
+}
+EXPORT_SYMBOL(security_inode_copy_up_xattr);
+
 int security_file_permission(struct file *file, int mask)
 {
 	int ret;
@@ -1692,6 +1698,8 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.inode_getsecid),
 	.inode_copy_up =
 		LIST_HEAD_INIT(security_hook_heads.inode_copy_up),
+	.inode_copy_up_xattr =
+		LIST_HEAD_INIT(security_hook_heads.inode_copy_up_xattr),
 	.file_permission =
 		LIST_HEAD_INIT(security_hook_heads.file_permission),
 	.file_alloc_security =

commit d8ad8b49618410ddeafd78465b63a6cedd6c9484
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Wed Jul 13 11:13:56 2016 -0400

    security, overlayfs: provide copy up security hook for unioned files
    
    Provide a security hook to label new file correctly when a file is copied
    up from lower layer to upper layer of a overlay/union mount.
    
    This hook can prepare a new set of creds which are suitable for new file
    creation during copy up. Caller will use new creds to create file and then
    revert back to old creds and release new creds.
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    [PM: whitespace cleanup to appease checkpatch.pl]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/security/security.c b/security/security.c
index 4838e7fefa1f..f2a7f27bd3e9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -748,6 +748,12 @@ void security_inode_getsecid(struct inode *inode, u32 *secid)
 	call_void_hook(inode_getsecid, inode, secid);
 }
 
+int security_inode_copy_up(struct dentry *src, struct cred **new)
+{
+	return call_int_hook(inode_copy_up, 0, src, new);
+}
+EXPORT_SYMBOL(security_inode_copy_up);
+
 int security_file_permission(struct file *file, int mask)
 {
 	int ret;
@@ -1684,6 +1690,8 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.inode_listsecurity),
 	.inode_getsecid =
 		LIST_HEAD_INIT(security_hook_heads.inode_getsecid),
+	.inode_copy_up =
+		LIST_HEAD_INIT(security_hook_heads.inode_copy_up),
 	.file_permission =
 		LIST_HEAD_INIT(security_hook_heads.file_permission),
 	.file_alloc_security =

commit 835c92d43b29eb354abdbd5475308a474d7efdfa
Merge: ce804bf598b5 19a6d89de2f1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 6 09:49:02 2016 -0400

    Merge branch 'work.const-qstr' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull qstr constification updates from Al Viro:
     "Fairly self-contained bunch - surprising lot of places passes struct
      qstr * as an argument when const struct qstr * would suffice; it
      complicates analysis for no good reason.
    
      I'd prefer to feed that separately from the assorted fixes (those are
      in #for-linus and with somewhat trickier topology)"
    
    * 'work.const-qstr' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      qstr: constify instances in adfs
      qstr: constify instances in lustre
      qstr: constify instances in f2fs
      qstr: constify instances in ext2
      qstr: constify instances in vfat
      qstr: constify instances in procfs
      qstr: constify instances in fuse
      qstr constify instances in fs/dcache.c
      qstr: constify instances in nfs
      qstr: constify instances in ocfs2
      qstr: constify instances in autofs4
      qstr: constify instances in hfs
      qstr: constify instances in hfsplus
      qstr: constify instances in logfs
      qstr: constify dentry_init_security

commit 4f3ccd76572a83278166c12f3e351e74cc03578c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jul 20 16:06:15 2016 -0400

    qstr: constify dentry_init_security
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 709569305d32..d441f45943e1 100644
--- a/security/security.c
+++ b/security/security.c
@@ -356,7 +356,7 @@ void security_inode_free(struct inode *inode)
 }
 
 int security_dentry_init_security(struct dentry *dentry, int mode,
-					struct qstr *name, void **ctx,
+					const struct qstr *name, void **ctx,
 					u32 *ctxlen)
 {
 	return call_int_hook(dentry_init_security, -EOPNOTSUPP, dentry, mode,

commit 2885c1e3e0c29e4a1915214ddc9673925f538299
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Tue May 31 17:24:15 2016 -0700

    LSM: Fix for security_inode_getsecurity and -EOPNOTSUPP
    
    Serge Hallyn pointed out that the current implementation of
    security_inode_getsecurity() works if there is only one hook
    provided for it, but will fail if there is more than one and
    the attribute requested isn't supplied by the first module.
    This isn't a problem today, since only SELinux and Smack
    provide this hook and there is (currently) no way to enable
    both of those modules at the same time. Serge, however, wants
    to introduce a capability attribute and an inode_getsecurity
    hook in the capability security module to handle it. This
    addresses that upcoming problem, will be required for "extreme
    stacking" and is just a better implementation.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 709569305d32..c4bb47db30ee 100644
--- a/security/security.c
+++ b/security/security.c
@@ -700,18 +700,39 @@ int security_inode_killpriv(struct dentry *dentry)
 
 int security_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)
 {
+	struct security_hook_list *hp;
+	int rc;
+
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return call_int_hook(inode_getsecurity, -EOPNOTSUPP, inode, name,
-				buffer, alloc);
+	/*
+	 * Only one module will provide an attribute with a given name.
+	 */
+	list_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {
+		rc = hp->hook.inode_getsecurity(inode, name, buffer, alloc);
+		if (rc != -EOPNOTSUPP)
+			return rc;
+	}
+	return -EOPNOTSUPP;
 }
 
 int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)
 {
+	struct security_hook_list *hp;
+	int rc;
+
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return call_int_hook(inode_setsecurity, -EOPNOTSUPP, inode, name,
-				value, size, flags);
+	/*
+	 * Only one module will provide an attribute with a given name.
+	 */
+	list_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {
+		rc = hp->hook.inode_setsecurity(inode, name, value, size,
+								flags);
+		if (rc != -EOPNOTSUPP)
+			return rc;
+	}
+	return -EOPNOTSUPP;
 }
 
 int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)

commit f4f27d0028aabce57e44c16c2fdefccd6310d2f3
Merge: 2600a46ee0ed b937190c40de
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 09:21:36 2016 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Highlights:
    
       - A new LSM, "LoadPin", from Kees Cook is added, which allows forcing
         of modules and firmware to be loaded from a specific device (this
         is from ChromeOS, where the device as a whole is verified
         cryptographically via dm-verity).
    
         This is disabled by default but can be configured to be enabled by
         default (don't do this if you don't know what you're doing).
    
       - Keys: allow authentication data to be stored in an asymmetric key.
         Lots of general fixes and updates.
    
       - SELinux: add restrictions for loading of kernel modules via
         finit_module().  Distinguish non-init user namespace capability
         checks.  Apply execstack check on thread stacks"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (48 commits)
      LSM: LoadPin: provide enablement CONFIG
      Yama: use atomic allocations when reporting
      seccomp: Fix comment typo
      ima: add support for creating files using the mknodat syscall
      ima: fix ima_inode_post_setattr
      vfs: forbid write access when reading a file into memory
      fs: fix over-zealous use of "const"
      selinux: apply execstack check on thread stacks
      selinux: distinguish non-init user namespace capability checks
      LSM: LoadPin for kernel file loading restrictions
      fs: define a string representation of the kernel_read_file_id enumeration
      Yama: consolidate error reporting
      string_helpers: add kstrdup_quotable_file
      string_helpers: add kstrdup_quotable_cmdline
      string_helpers: add kstrdup_quotable
      selinux: check ss_initialized before revalidating an inode label
      selinux: delay inode label lookup as long as possible
      selinux: don't revalidate an inode's label when explicitly setting it
      selinux: Change bool variable name to index.
      KEYS: Add KEYCTL_DH_COMPUTE command
      ...

commit c52b76185b7a1b300e5f15ff871c8f45ced3dee9
Merge: 681750c04681 81cd8896a64c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 17 14:41:03 2016 -0700

    Merge branch 'work.const-path' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull 'struct path' constification update from Al Viro:
     "'struct path' is passed by reference to a bunch of Linux security
      methods; in theory, there's nothing to stop them from modifying the
      damn thing and LSM community being what it is, sooner or later some
      enterprising soul is going to decide that it's a good idea.
    
      Let's remove the temptation and constify all of those..."
    
    * 'work.const-path' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      constify ima_d_path()
      constify security_sb_pivotroot()
      constify security_path_chroot()
      constify security_path_{link,rename}
      apparmor: remove useless checks for NULL ->mnt
      constify security_path_{mkdir,mknod,symlink}
      constify security_path_{unlink,rmdir}
      apparmor: constify common_perm_...()
      apparmor: constify aa_path_link()
      apparmor: new helper - common_path_perm()
      constify chmod_common/security_path_chmod
      constify security_sb_mount()
      constify chown_common/security_path_chown
      tomoyo: constify assorted struct path *
      apparmor_path_truncate(): path->mnt is never NULL
      constify vfs_truncate()
      constify security_path_truncate()
      [apparmor] constify struct path * in a bunch of helpers

commit 457db29bfcfd1d9cc717587c446a89d60499d4a9
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Fri Apr 8 14:02:11 2016 +0800

    security: Introduce security_settime64()
    
    security_settime() uses a timespec, which is not year 2038 safe
    on 32bit systems. Thus this patch introduces the security_settime64()
    function with timespec64 type. We also convert the cap_settime() helper
    function to use the 64bit types.
    
    This patch then moves security_settime() to the header file as an
    inline helper function so that existing users can be iteratively
    converted.
    
    None of the existing hooks is using the timespec argument and therefor
    the patch is not making any functional changes.
    
    Cc: Serge Hallyn <serge.hallyn@canonical.com>,
    Cc: James Morris <james.l.morris@oracle.com>,
    Cc: "Serge E. Hallyn" <serge@hallyn.com>,
    Cc: Paul Moore <pmoore@redhat.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    [jstultz: Reworded commit message]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/security/security.c b/security/security.c
index 3644b0344d29..8c44a64f191d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -208,7 +208,7 @@ int security_syslog(int type)
 	return call_int_hook(syslog, 0, type);
 }
 
-int security_settime(const struct timespec *ts, const struct timezone *tz)
+int security_settime64(const struct timespec64 *ts, const struct timezone *tz)
 {
 	return call_int_hook(settime, 0, ts, tz);
 }

commit 9b091556a073a9f5f93e2ad23d118f45c4796a84
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Apr 20 15:46:28 2016 -0700

    LSM: LoadPin for kernel file loading restrictions
    
    This LSM enforces that kernel-loaded files (modules, firmware, etc)
    must all come from the same filesystem, with the expectation that
    such a filesystem is backed by a read-only device such as dm-verity
    or CDROM. This allows systems that have a verified and/or unchangeable
    filesystem to enforce module and firmware loading restrictions without
    needing to sign the files individually.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 554c3fb7d4a5..e42860899f23 100644
--- a/security/security.c
+++ b/security/security.c
@@ -60,6 +60,7 @@ int __init security_init(void)
 	 */
 	capability_add_hooks();
 	yama_add_hooks();
+	loadpin_add_hooks();
 
 	/*
 	 * Load all the remaining security modules.

commit 3c9d6296b7aee536a96ea2b53a15d23511738c1c
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Fri Apr 8 12:20:30 2016 +0200

    security: drop the unused hook skb_owned_by
    
    The skb_owned_by hook was added with the commit ca10b9e9a8ca
    ("selinux: add a skb_owned_by() hook") and later removed
    when said commit was reverted.
    
    Later on, when switching to list of hooks, a field named
    'skb_owned_by' was included into the security_hook_head struct,
    but without any users nor caller.
    
    This commit removes the said left-over field.
    
    Fixes: b1d9e6b0646d ("LSM: Switch to lists of hooks")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Paul Moore <pmoore@paul-moore.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 3644b0344d29..554c3fb7d4a5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1848,7 +1848,6 @@ struct security_hook_heads security_hook_heads = {
 	.tun_dev_attach =
 		LIST_HEAD_INIT(security_hook_heads.tun_dev_attach),
 	.tun_dev_open =	LIST_HEAD_INIT(security_hook_heads.tun_dev_open),
-	.skb_owned_by =	LIST_HEAD_INIT(security_hook_heads.skb_owned_by),
 #endif	/* CONFIG_SECURITY_NETWORK */
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 	.xfrm_policy_alloc_security =

commit 3b73b68c05db0b3c9b282c6e8e6eb71acc589a02
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 15:31:19 2016 -0400

    constify security_sb_pivotroot()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index cf6f31df524a..f7af0aaa173e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -313,7 +313,7 @@ int security_sb_umount(struct vfsmount *mnt, int flags)
 	return call_int_hook(sb_umount, 0, mnt, flags);
 }
 
-int security_sb_pivotroot(struct path *old_path, struct path *new_path)
+int security_sb_pivotroot(const struct path *old_path, const struct path *new_path)
 {
 	return call_int_hook(sb_pivotroot, 0, old_path, new_path);
 }

commit 77b286c0d26a5399912f5affd90ed73e2d8b42a5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 15:28:43 2016 -0400

    constify security_path_chroot()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 33b85a960128..cf6f31df524a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -499,7 +499,7 @@ int security_path_chown(const struct path *path, kuid_t uid, kgid_t gid)
 	return call_int_hook(path_chown, 0, path, uid, gid);
 }
 
-int security_path_chroot(struct path *path)
+int security_path_chroot(const struct path *path)
 {
 	return call_int_hook(path_chroot, 0, path);
 }

commit 3ccee46ab487d5b87d0621824efe2500b2857c58
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 15:27:45 2016 -0400

    constify security_path_{link,rename}
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 7f62e2ed6a28..33b85a960128 100644
--- a/security/security.c
+++ b/security/security.c
@@ -450,7 +450,7 @@ int security_path_symlink(const struct path *dir, struct dentry *dentry,
 	return call_int_hook(path_symlink, 0, dir, dentry, old_name);
 }
 
-int security_path_link(struct dentry *old_dentry, struct path *new_dir,
+int security_path_link(struct dentry *old_dentry, const struct path *new_dir,
 		       struct dentry *new_dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))
@@ -458,8 +458,8 @@ int security_path_link(struct dentry *old_dentry, struct path *new_dir,
 	return call_int_hook(path_link, 0, old_dentry, new_dir, new_dentry);
 }
 
-int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
-			 struct path *new_dir, struct dentry *new_dentry,
+int security_path_rename(const struct path *old_dir, struct dentry *old_dentry,
+			 const struct path *new_dir, struct dentry *new_dentry,
 			 unsigned int flags)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||

commit d360775217070ff0f4291e47d3f568f0fe0b7374
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 15:21:09 2016 -0400

    constify security_path_{mkdir,mknod,symlink}
    
    ... as well as unix_mknod() and may_o_create()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 20f2070b3ace..7f62e2ed6a28 100644
--- a/security/security.c
+++ b/security/security.c
@@ -410,7 +410,7 @@ int security_old_inode_init_security(struct inode *inode, struct inode *dir,
 EXPORT_SYMBOL(security_old_inode_init_security);
 
 #ifdef CONFIG_SECURITY_PATH
-int security_path_mknod(struct path *dir, struct dentry *dentry, umode_t mode,
+int security_path_mknod(const struct path *dir, struct dentry *dentry, umode_t mode,
 			unsigned int dev)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
@@ -419,7 +419,7 @@ int security_path_mknod(struct path *dir, struct dentry *dentry, umode_t mode,
 }
 EXPORT_SYMBOL(security_path_mknod);
 
-int security_path_mkdir(struct path *dir, struct dentry *dentry, umode_t mode)
+int security_path_mkdir(const struct path *dir, struct dentry *dentry, umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
@@ -442,7 +442,7 @@ int security_path_unlink(const struct path *dir, struct dentry *dentry)
 }
 EXPORT_SYMBOL(security_path_unlink);
 
-int security_path_symlink(struct path *dir, struct dentry *dentry,
+int security_path_symlink(const struct path *dir, struct dentry *dentry,
 			  const char *old_name)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))

commit 989f74e0500a1e136d369bb619adc22786ea5e68
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 15:13:39 2016 -0400

    constify security_path_{unlink,rmdir}
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index b333429fe718..20f2070b3ace 100644
--- a/security/security.c
+++ b/security/security.c
@@ -427,14 +427,14 @@ int security_path_mkdir(struct path *dir, struct dentry *dentry, umode_t mode)
 }
 EXPORT_SYMBOL(security_path_mkdir);
 
-int security_path_rmdir(struct path *dir, struct dentry *dentry)
+int security_path_rmdir(const struct path *dir, struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
 	return call_int_hook(path_rmdir, 0, dir, dentry);
 }
 
-int security_path_unlink(struct path *dir, struct dentry *dentry)
+int security_path_unlink(const struct path *dir, struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;

commit be01f9f28e66fa846f02196eb047c6bc445642db
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 14:56:23 2016 -0400

    constify chmod_common/security_path_chmod
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index fc567656b16f..b333429fe718 100644
--- a/security/security.c
+++ b/security/security.c
@@ -485,7 +485,7 @@ int security_path_truncate(const struct path *path)
 	return call_int_hook(path_truncate, 0, path);
 }
 
-int security_path_chmod(struct path *path, umode_t mode)
+int security_path_chmod(const struct path *path, umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;

commit 8a04c43b8741ebb40508d160cf87ca74b70941af
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 14:52:53 2016 -0400

    constify security_sb_mount()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 4a3e7e99abbb..fc567656b16f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -302,7 +302,7 @@ int security_sb_statfs(struct dentry *dentry)
 	return call_int_hook(sb_statfs, 0, dentry);
 }
 
-int security_sb_mount(const char *dev_name, struct path *path,
+int security_sb_mount(const char *dev_name, const struct path *path,
                        const char *type, unsigned long flags, void *data)
 {
 	return call_int_hook(sb_mount, 0, dev_name, path, type, flags, data);

commit 7fd25dac9ad3970bede16f2834daf9f9d779d1b0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 14:44:41 2016 -0400

    constify chown_common/security_path_chown
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 23ffb6cc3974..4a3e7e99abbb 100644
--- a/security/security.c
+++ b/security/security.c
@@ -492,7 +492,7 @@ int security_path_chmod(struct path *path, umode_t mode)
 	return call_int_hook(path_chmod, 0, path, mode);
 }
 
-int security_path_chown(struct path *path, kuid_t uid, kgid_t gid)
+int security_path_chown(const struct path *path, kuid_t uid, kgid_t gid)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;

commit 81f4c50607b423a59f8a1b03e1e8fc409a1dcd22
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 14:22:01 2016 -0400

    constify security_path_truncate()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 3644b0344d29..23ffb6cc3974 100644
--- a/security/security.c
+++ b/security/security.c
@@ -478,7 +478,7 @@ int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
 }
 EXPORT_SYMBOL(security_path_rename);
 
-int security_path_truncate(struct path *path)
+int security_path_truncate(const struct path *path)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;

commit a1db74209483a24c861c848b4bb79a4d945ef6fa
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Dec 30 07:35:30 2015 -0500

    module: replace copy_module_from_fd with kernel version
    
    Replace copy_module_from_fd() with kernel_read_file_from_fd().
    
    Although none of the upstreamed LSMs define a kernel_module_from_file
    hook, IMA is called, based on policy, to prevent unsigned kernel modules
    from being loaded by the original kernel module syscall and to
    measure/appraise signed kernel modules.
    
    The security function security_kernel_module_from_file() was called prior
    to reading a kernel module.  Preventing unsigned kernel modules from being
    loaded by the original kernel module syscall remains on the pre-read
    kernel_read_file() security hook.  Instead of reading the kernel module
    twice, once for measuring/appraising and again for loading the kernel
    module, the signature validation is moved to the kernel_post_read_file()
    security hook.
    
    This patch removes the security_kernel_module_from_file() hook and security
    call.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/security/security.c b/security/security.c
index 8e699f98a600..3644b0344d29 100644
--- a/security/security.c
+++ b/security/security.c
@@ -889,16 +889,6 @@ int security_kernel_module_request(char *kmod_name)
 	return call_int_hook(kernel_module_request, 0, kmod_name);
 }
 
-int security_kernel_module_from_file(struct file *file)
-{
-	int ret;
-
-	ret = call_int_hook(kernel_module_from_file, 0, file);
-	if (ret)
-		return ret;
-	return ima_module_check(file);
-}
-
 int security_kernel_read_file(struct file *file, enum kernel_read_file_id id)
 {
 	int ret;
@@ -1705,8 +1695,6 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.kernel_create_files_as),
 	.kernel_module_request =
 		LIST_HEAD_INIT(security_hook_heads.kernel_module_request),
-	.kernel_module_from_file =
-		LIST_HEAD_INIT(security_hook_heads.kernel_module_from_file),
 	.kernel_read_file =
 		LIST_HEAD_INIT(security_hook_heads.kernel_read_file),
 	.kernel_post_read_file =

commit 39eeb4fb97f60dbdfc823c1a673a8844b9226b60
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Sat Jan 30 22:23:26 2016 -0500

    security: define kernel_read_file hook
    
    The kernel_read_file security hook is called prior to reading the file
    into memory.
    
    Changelog v4+:
    - export security_kernel_read_file()
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>

diff --git a/security/security.c b/security/security.c
index cd85be61c416..8e699f98a600 100644
--- a/security/security.c
+++ b/security/security.c
@@ -899,6 +899,17 @@ int security_kernel_module_from_file(struct file *file)
 	return ima_module_check(file);
 }
 
+int security_kernel_read_file(struct file *file, enum kernel_read_file_id id)
+{
+	int ret;
+
+	ret = call_int_hook(kernel_read_file, 0, file, id);
+	if (ret)
+		return ret;
+	return ima_read_file(file, id);
+}
+EXPORT_SYMBOL_GPL(security_kernel_read_file);
+
 int security_kernel_post_read_file(struct file *file, char *buf, loff_t size,
 				   enum kernel_read_file_id id)
 {
@@ -1696,6 +1707,8 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.kernel_module_request),
 	.kernel_module_from_file =
 		LIST_HEAD_INIT(security_hook_heads.kernel_module_from_file),
+	.kernel_read_file =
+		LIST_HEAD_INIT(security_hook_heads.kernel_read_file),
 	.kernel_post_read_file =
 		LIST_HEAD_INIT(security_hook_heads.kernel_post_read_file),
 	.task_fix_setuid =

commit e40ba6d56b41754b37b995dbc8035b2b3a6afd8a
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Nov 19 12:39:22 2015 -0500

    firmware: replace call to fw_read_file_contents() with kernel version
    
    Replace the fw_read_file_contents with kernel_file_read_from_path().
    
    Although none of the upstreamed LSMs define a kernel_fw_from_file hook,
    IMA is called by the security function to prevent unsigned firmware from
    being loaded and to measure/appraise signed firmware, based on policy.
    
    Instead of reading the firmware twice, once for measuring/appraising the
    firmware and again for reading the firmware contents into memory, the
    kernel_post_read_file() security hook calculates the file hash based on
    the in memory file buffer.  The firmware is read once.
    
    This patch removes the LSM kernel_fw_from_file() hook and security call.
    
    Changelog v4+:
    - revert dropped buf->size assignment - reported by Sergey Senozhatsky
    v3:
    - remove kernel_fw_from_file hook
    - use kernel_file_read_from_path() - requested by Luis
    v2:
    - reordered and squashed firmware patches
    - fix MAX firmware size (Kees Cook)
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>

diff --git a/security/security.c b/security/security.c
index ef4c65a9fd17..cd85be61c416 100644
--- a/security/security.c
+++ b/security/security.c
@@ -884,17 +884,6 @@ int security_kernel_create_files_as(struct cred *new, struct inode *inode)
 	return call_int_hook(kernel_create_files_as, 0, new, inode);
 }
 
-int security_kernel_fw_from_file(struct file *file, char *buf, size_t size)
-{
-	int ret;
-
-	ret = call_int_hook(kernel_fw_from_file, 0, file, buf, size);
-	if (ret)
-		return ret;
-	return ima_fw_from_file(file, buf, size);
-}
-EXPORT_SYMBOL_GPL(security_kernel_fw_from_file);
-
 int security_kernel_module_request(char *kmod_name)
 {
 	return call_int_hook(kernel_module_request, 0, kmod_name);
@@ -1703,8 +1692,6 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.kernel_act_as),
 	.kernel_create_files_as =
 		LIST_HEAD_INIT(security_hook_heads.kernel_create_files_as),
-	.kernel_fw_from_file =
-		LIST_HEAD_INIT(security_hook_heads.kernel_fw_from_file),
 	.kernel_module_request =
 		LIST_HEAD_INIT(security_hook_heads.kernel_module_request),
 	.kernel_module_from_file =

commit cf2222178645e545e96717b2825601321ce4745c
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Jan 14 17:57:47 2016 -0500

    ima: define a new hook to measure and appraise a file already in memory
    
    This patch defines a new IMA hook ima_post_read_file() for measuring
    and appraising files read by the kernel. The caller loads the file into
    memory before calling this function, which calculates the hash followed by
    the normal IMA policy based processing.
    
    Changelog v5:
    - fail ima_post_read_file() if either file or buf is NULL
    v3:
    - rename ima_hash_and_process_file() to ima_post_read_file()
    
    v1:
    - split patch
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>

diff --git a/security/security.c b/security/security.c
index 5b96eabaafd4..ef4c65a9fd17 100644
--- a/security/security.c
+++ b/security/security.c
@@ -913,7 +913,12 @@ int security_kernel_module_from_file(struct file *file)
 int security_kernel_post_read_file(struct file *file, char *buf, loff_t size,
 				   enum kernel_read_file_id id)
 {
-	return call_int_hook(kernel_post_read_file, 0, file, buf, size, id);
+	int ret;
+
+	ret = call_int_hook(kernel_post_read_file, 0, file, buf, size, id);
+	if (ret)
+		return ret;
+	return ima_post_read_file(file, buf, size, id);
 }
 EXPORT_SYMBOL_GPL(security_kernel_post_read_file);
 

commit bc8ca5b92d54f6f005fa73ad546f02fca26ddd85
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Sun Jan 24 10:07:32 2016 -0500

    vfs: define kernel_read_file_id enumeration
    
    To differentiate between the kernel_read_file() callers, this patch
    defines a new enumeration named kernel_read_file_id and includes the
    caller identifier as an argument.
    
    Subsequent patches define READING_KEXEC_IMAGE, READING_KEXEC_INITRAMFS,
    READING_FIRMWARE, READING_MODULE, and READING_POLICY.
    
    Changelog v3:
    - Replace the IMA specific enumeration with a generic one.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index c98dd6bf4ebd..5b96eabaafd4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -910,9 +910,10 @@ int security_kernel_module_from_file(struct file *file)
 	return ima_module_check(file);
 }
 
-int security_kernel_post_read_file(struct file *file, char *buf, loff_t size)
+int security_kernel_post_read_file(struct file *file, char *buf, loff_t size,
+				   enum kernel_read_file_id id)
 {
-	return call_int_hook(kernel_post_read_file, 0, file, buf, size);
+	return call_int_hook(kernel_post_read_file, 0, file, buf, size, id);
 }
 EXPORT_SYMBOL_GPL(security_kernel_post_read_file);
 

commit b44a7dfc6fa16e01f2497c9fa62c3926f94be174
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Dec 28 16:02:29 2015 -0500

    vfs: define a generic function to read a file from the kernel
    
    For a while it was looked down upon to directly read files from Linux.
    These days there exists a few mechanisms in the kernel that do just
    this though to load a file into a local buffer.  There are minor but
    important checks differences on each.  This patch set is the first
    attempt at resolving some of these differences.
    
    This patch introduces a common function for reading files from the kernel
    with the corresponding security post-read hook and function.
    
    Changelog v4+:
    - export security_kernel_post_read_file() - Fengguang Wu
    v3:
    - additional bounds checking - Luis
    v2:
    - To simplify patch review, re-ordered patches
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Reviewed-by: Luis R. Rodriguez <mcgrof@suse.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index e8ffd92ae2eb..c98dd6bf4ebd 100644
--- a/security/security.c
+++ b/security/security.c
@@ -910,6 +910,12 @@ int security_kernel_module_from_file(struct file *file)
 	return ima_module_check(file);
 }
 
+int security_kernel_post_read_file(struct file *file, char *buf, loff_t size)
+{
+	return call_int_hook(kernel_post_read_file, 0, file, buf, size);
+}
+EXPORT_SYMBOL_GPL(security_kernel_post_read_file);
+
 int security_task_fix_setuid(struct cred *new, const struct cred *old,
 			     int flags)
 {
@@ -1697,6 +1703,8 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.kernel_module_request),
 	.kernel_module_from_file =
 		LIST_HEAD_INIT(security_hook_heads.kernel_module_from_file),
+	.kernel_post_read_file =
+		LIST_HEAD_INIT(security_hook_heads.kernel_post_read_file),
 	.task_fix_setuid =
 		LIST_HEAD_INIT(security_hook_heads.task_fix_setuid),
 	.task_setpgid =	LIST_HEAD_INIT(security_hook_heads.task_setpgid),

commit 6f3be9f562e3027c77bc4482ccf2cea8600a7f74
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Dec 24 11:09:40 2015 -0500

    security: Add hook to invalidate inode security labels
    
    Add a hook to invalidate an inode's security label when the cached
    information becomes invalid.
    
    Add the new hook in selinux: set a flag when a security label becomes
    invalid.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/security/security.c b/security/security.c
index c5beb7e90721..e8ffd92ae2eb 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1161,6 +1161,12 @@ void security_release_secctx(char *secdata, u32 seclen)
 }
 EXPORT_SYMBOL(security_release_secctx);
 
+void security_inode_invalidate_secctx(struct inode *inode)
+{
+	call_void_hook(inode_invalidate_secctx, inode);
+}
+EXPORT_SYMBOL(security_inode_invalidate_secctx);
+
 int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)
 {
 	return call_int_hook(inode_notifysecctx, 0, inode, ctx, ctxlen);
@@ -1763,6 +1769,8 @@ struct security_hook_heads security_hook_heads = {
 		LIST_HEAD_INIT(security_hook_heads.secctx_to_secid),
 	.release_secctx =
 		LIST_HEAD_INIT(security_hook_heads.release_secctx),
+	.inode_invalidate_secctx =
+		LIST_HEAD_INIT(security_hook_heads.inode_invalidate_secctx),
 	.inode_notifysecctx =
 		LIST_HEAD_INIT(security_hook_heads.inode_notifysecctx),
 	.inode_setsecctx =

commit d6335d77a7622a88380f3f207cc1f727f878dd21
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Dec 24 11:09:39 2015 -0500

    security: Make inode argument of inode_getsecid non-const
    
    Make the inode argument of the inode_getsecid hook non-const so that we
    can use it to revalidate invalid security labels.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/security/security.c b/security/security.c
index 73514c91d87f..c5beb7e90721 100644
--- a/security/security.c
+++ b/security/security.c
@@ -721,7 +721,7 @@ int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer
 }
 EXPORT_SYMBOL(security_inode_listsecurity);
 
-void security_inode_getsecid(const struct inode *inode, u32 *secid)
+void security_inode_getsecid(struct inode *inode, u32 *secid)
 {
 	call_void_hook(inode_getsecid, inode, secid);
 }

commit ea861dfd9e0e7e044a6e65fa02a14b9159b568da
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Dec 24 11:09:39 2015 -0500

    security: Make inode argument of inode_getsecurity non-const
    
    Make the inode argument of the inode_getsecurity hook non-const so that
    we can use it to revalidate invalid security labels.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/security/security.c b/security/security.c
index 46f405ce6b0f..73514c91d87f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -697,7 +697,7 @@ int security_inode_killpriv(struct dentry *dentry)
 	return call_int_hook(inode_killpriv, 0, dentry);
 }
 
-int security_inode_getsecurity(const struct inode *inode, const char *name, void **buffer, bool alloc)
+int security_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;

commit b793c005ceabf6db0b17494b0ec67ade6796bb34
Merge: 6f0a2fc1feb1 07f081fb5057
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 8 12:41:25 2015 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Highlights:
    
       - PKCS#7 support added to support signed kexec, also utilized for
         module signing.  See comments in 3f1e1bea.
    
         ** NOTE: this requires linking against the OpenSSL library, which
            must be installed, e.g.  the openssl-devel on Fedora **
    
       - Smack
          - add IPv6 host labeling; ignore labels on kernel threads
          - support smack labeling mounts which use binary mount data
    
       - SELinux:
          - add ioctl whitelisting (see
            http://kernsec.org/files/lss2015/vanderstoep.pdf)
          - fix mprotect PROT_EXEC regression caused by mm change
    
       - Seccomp:
          - add ptrace options for suspend/resume"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (57 commits)
      PKCS#7: Add OIDs for sha224, sha284 and sha512 hash algos and use them
      Documentation/Changes: Now need OpenSSL devel packages for module signing
      scripts: add extract-cert and sign-file to .gitignore
      modsign: Handle signing key in source tree
      modsign: Use if_changed rule for extracting cert from module signing key
      Move certificate handling to its own directory
      sign-file: Fix warning about BIO_reset() return value
      PKCS#7: Add MODULE_LICENSE() to test module
      Smack - Fix build error with bringup unconfigured
      sign-file: Document dependency on OpenSSL devel libraries
      PKCS#7: Appropriately restrict authenticated attributes and content type
      KEYS: Add a name for PKEY_ID_PKCS7
      PKCS#7: Improve and export the X.509 ASN.1 time object decoder
      modsign: Use extract-cert to process CONFIG_SYSTEM_TRUSTED_KEYS
      extract-cert: Cope with multiple X.509 certificates in a single file
      sign-file: Generate CMS message as signature instead of PKCS#7
      PKCS#7: Support CMS messages also [RFC5652]
      X.509: Change recorded SKID & AKID to not include Subject or Issuer
      PKCS#7: Check content type and versions
      MAINTAINERS: The keyrings mailing list has moved
      ...

commit 73b6fa8e49c2d13e04d20186261e5f7855c6d0bf
Merge: e713c80a4e49 4b75de861505
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 16:13:25 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace updates from Eric Biederman:
     "This finishes up the changes to ensure proc and sysfs do not start
      implementing executable files, as the there are application today that
      are only secure because such files do not exist.
    
      It akso fixes a long standing misfeature of /proc/<pid>/mountinfo that
      did not show the proper source for files bind mounted from
      /proc/<pid>/ns/*.
    
      It also straightens out the handling of clone flags related to user
      namespaces, fixing an unnecessary failure of unshare(CLONE_NEWUSER)
      when files such as /proc/<pid>/environ are read while <pid> is calling
      unshare.  This winds up fixing a minor bug in unshare flag handling
      that dates back to the first version of unshare in the kernel.
    
      Finally, this fixes a minor regression caused by the introduction of
      sysfs_create_mount_point, which broke someone's in house application,
      by restoring the size of /sys/fs/cgroup to 0 bytes.  Apparently that
      application uses the directory size to determine if a tmpfs is mounted
      on /sys/fs/cgroup.
    
      The bind mount escape fixes are present in Al Viros for-next branch.
      and I expect them to come from there.  The bind mount escape is the
      last of the user namespace related security bugs that I am aware of"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      fs: Set the size of empty dirs to 0.
      userns,pidns: Force thread group sharing, not signal handler sharing.
      unshare: Unsharing a thread does not require unsharing a vm
      nsfs: Add a show_path method to fix mountinfo
      mnt: fs_fully_visible enforce noexec and nosuid  if !SB_I_NOEXEC
      vfs: Commit to never having exectuables on proc and sysfs.

commit e308fd3bb2e469c4939d3f4bd22b468de3ed04ae
Author: Jan Beulich <JBeulich@suse.com>
Date:   Mon Aug 24 06:22:25 2015 -0600

    LSM: restore certain default error codes
    
    While in most cases commit b1d9e6b064 ("LSM: Switch to lists of hooks")
    retained previous error returns, in three cases it altered them without
    any explanation in the commit message. Restore all of them - in the
    security_old_inode_init_security() case this led to reiserfs using
    uninitialized data, sooner or later crashing the system (the only other
    user of this function - ocfs2 - was unaffected afaict, since it passes
    pre-initialized structures).
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 595fffab48b0..994283624bdb 100644
--- a/security/security.c
+++ b/security/security.c
@@ -380,8 +380,8 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 		return 0;
 
 	if (!initxattrs)
-		return call_int_hook(inode_init_security, 0, inode, dir, qstr,
-							 NULL, NULL, NULL);
+		return call_int_hook(inode_init_security, -EOPNOTSUPP, inode,
+				     dir, qstr, NULL, NULL, NULL);
 	memset(new_xattrs, 0, sizeof(new_xattrs));
 	lsm_xattr = new_xattrs;
 	ret = call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir, qstr,
@@ -409,8 +409,8 @@ int security_old_inode_init_security(struct inode *inode, struct inode *dir,
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return call_int_hook(inode_init_security, 0, inode, dir, qstr,
-				name, value, len);
+	return call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir,
+			     qstr, name, value, len);
 }
 EXPORT_SYMBOL(security_old_inode_init_security);
 
@@ -1281,7 +1281,8 @@ int security_socket_getpeersec_stream(struct socket *sock, char __user *optval,
 
 int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)
 {
-	return call_int_hook(socket_getpeersec_dgram, 0, sock, skb, secid);
+	return call_int_hook(socket_getpeersec_dgram, -ENOPROTOOPT, sock,
+			     skb, secid);
 }
 EXPORT_SYMBOL(security_socket_getpeersec_dgram);
 

commit 730daa164e7c7e31c08fab940549f4acc3329432
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Jul 23 18:02:48 2015 -0700

    Yama: remove needless CONFIG_SECURITY_YAMA_STACKED
    
    Now that minor LSMs can cleanly stack with major LSMs, remove the unneeded
    config for Yama to be made to explicitly stack. Just selecting the main
    Yama CONFIG will allow it to work, regardless of the major LSM. Since
    distros using Yama are already forcing it to stack, this is effectively
    a no-op change.
    
    Additionally add MAINTAINERS entry.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 595fffab48b0..e693ffcf9266 100644
--- a/security/security.c
+++ b/security/security.c
@@ -56,18 +56,13 @@ int __init security_init(void)
 	pr_info("Security Framework initialized\n");
 
 	/*
-	 * Always load the capability module.
+	 * Load minor LSMs, with the capability module always first.
 	 */
 	capability_add_hooks();
-#ifdef CONFIG_SECURITY_YAMA_STACKED
-	/*
-	 * If Yama is configured for stacking load it next.
-	 */
 	yama_add_hooks();
-#endif
+
 	/*
-	 * Load the chosen module if there is one.
-	 * This will also find yama if it is stacking
+	 * Load all the remaining security modules.
 	 */
 	do_security_initcalls();
 

commit 90f8572b0f021fdd1baa68e00a8c30482ee9e5f4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Jun 29 14:42:03 2015 -0500

    vfs: Commit to never having exectuables on proc and sysfs.
    
    Today proc and sysfs do not contain any executable files.  Several
    applications today mount proc or sysfs without noexec and nosuid and
    then depend on there being no exectuables files on proc or sysfs.
    Having any executable files show on proc or sysfs would cause
    a user space visible regression, and most likely security problems.
    
    Therefore commit to never allowing executables on proc and sysfs by
    adding a new flag to mark them as filesystems without executables and
    enforce that flag.
    
    Test the flag where MNT_NOEXEC is tested today, so that the only user
    visible effect will be that exectuables will be treated as if the
    execute bit is cleared.
    
    The filesystems proc and sysfs do not currently incoporate any
    executable files so this does not result in any user visible effects.
    
    This makes it unnecessary to vet changes to proc and sysfs tightly for
    adding exectuable files or changes to chattr that would modify
    existing files, as no matter what the individual file say they will
    not be treated as exectuable files by the vfs.
    
    Not having to vet changes to closely is important as without this we
    are only one proc_create call (or another goof up in the
    implementation of notify_change) from having problematic executables
    on proc.  Those mistakes are all too easy to make and would create
    a situation where there are security issues or the assumptions of
    some program having to be broken (and cause userspace regressions).
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index 595fffab48b0..062f3c997fdc 100644
--- a/security/security.c
+++ b/security/security.c
@@ -776,7 +776,7 @@ static inline unsigned long mmap_prot(struct file *file, unsigned long prot)
 	 * ditto if it's not on noexec mount, except that on !MMU we need
 	 * NOMMU_MAP_EXEC (== VM_MAYEXEC) in this case
 	 */
-	if (!(file->f_path.mnt->mnt_flags & MNT_NOEXEC)) {
+	if (!path_noexec(&file->f_path)) {
 #ifndef CONFIG_MMU
 		if (file->f_op->mmap_capabilities) {
 			unsigned caps = file->f_op->mmap_capabilities(file);

commit e22619a29fcdb513b7bc020e84225bb3b5914259
Merge: 78c10e556ed9 b3bddffd35a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 27 13:26:03 2015 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "The main change in this kernel is Casey's generalized LSM stacking
      work, which removes the hard-coding of Capabilities and Yama stacking,
      allowing multiple arbitrary "small" LSMs to be stacked with a default
      monolithic module (e.g.  SELinux, Smack, AppArmor).
    
      See
            https://lwn.net/Articles/636056/
    
      This will allow smaller, simpler LSMs to be incorporated into the
      mainline kernel and arbitrarily stacked by users.  Also, this is a
      useful cleanup of the LSM code in its own right"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (38 commits)
      tpm, tpm_crb: fix le64_to_cpu conversions in crb_acpi_add()
      vTPM: set virtual device before passing to ibmvtpm_reset_crq
      tpm_ibmvtpm: remove unneccessary message level.
      ima: update builtin policies
      ima: extend "mask" policy matching support
      ima: add support for new "euid" policy condition
      ima: fix ima_show_template_data_ascii()
      Smack: freeing an error pointer in smk_write_revoke_subj()
      selinux: fix setting of security labels on NFS
      selinux: Remove unused permission definitions
      selinux: enable genfscon labeling for sysfs and pstore files
      selinux: enable per-file labeling for debugfs files.
      selinux: update netlink socket classes
      signals: don't abuse __flush_signals() in selinux_bprm_committed_creds()
      selinux: Print 'sclass' as string when unrecognized netlink message occurs
      Smack: allow multiple labels in onlycap
      Smack: fix seq operations in smackfs
      ima: pass iint to ima_add_violation()
      ima: wrap event related data to the new ima_event_data structure
      integrity: add validity checks for 'path' parameter
      ...

commit b1d9e6b0646d0e5ee5d9050bd236b6c65d66faef
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Sat May 2 15:11:42 2015 -0700

    LSM: Switch to lists of hooks
    
    Instead of using a vector of security operations
    with explicit, special case stacking of the capability
    and yama hooks use lists of hooks with capability and
    yama hooks included as appropriate.
    
    The security_operations structure is no longer required.
    Instead, there is a union of the function pointers that
    allows all the hooks lists to use a common mechanism for
    list management while retaining typing. Each module
    supplies an array describing the hooks it provides instead
    of a sparsely populated security_operations structure.
    The description includes the element that gets put on
    the hook list, avoiding the issues surrounding individual
    element allocation.
    
    The method for registering security modules is changed to
    reflect the information available. The method for removing
    a module, currently only used by SELinux, has also changed.
    It should be generic now, however if there are potential
    race conditions based on ordering of hook removal that needs
    to be addressed by the calling module.
    
    The security hooks are called from the lists and the first
    failure is returned.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 02dc72006afa..bd4c5f6a5b78 100644
--- a/security/security.c
+++ b/security/security.c
@@ -29,24 +29,13 @@
 
 #define MAX_LSM_EVM_XATTR	2
 
+/* Maximum number of letters for an LSM name string */
+#define SECURITY_NAME_MAX	10
+
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
-static struct security_operations *security_ops;
-static struct security_operations default_security_ops = {
-	.name	= "default",
-};
-
-static inline int __init verify(struct security_operations *ops)
-{
-	/* verify the security_operations structure exists */
-	if (!ops)
-		return -EINVAL;
-	security_fixup_ops(ops);
-	return 0;
-}
-
 static void __init do_security_initcalls(void)
 {
 	initcall_t *call;
@@ -64,20 +53,27 @@ static void __init do_security_initcalls(void)
  */
 int __init security_init(void)
 {
-	printk(KERN_INFO "Security Framework initialized\n");
+	pr_info("Security Framework initialized\n");
 
-	security_fixup_ops(&default_security_ops);
-	security_ops = &default_security_ops;
+	/*
+	 * Always load the capability module.
+	 */
+	capability_add_hooks();
+#ifdef CONFIG_SECURITY_YAMA_STACKED
+	/*
+	 * If Yama is configured for stacking load it next.
+	 */
+	yama_add_hooks();
+#endif
+	/*
+	 * Load the chosen module if there is one.
+	 * This will also find yama if it is stacking
+	 */
 	do_security_initcalls();
 
 	return 0;
 }
 
-void reset_security_ops(void)
-{
-	security_ops = &default_security_ops;
-}
-
 /* Save user chosen LSM */
 static int __init choose_lsm(char *str)
 {
@@ -88,7 +84,7 @@ __setup("security=", choose_lsm);
 
 /**
  * security_module_enable - Load given security module on boot ?
- * @ops: a pointer to the struct security_operations that is to be checked.
+ * @module: the name of the module
  *
  * Each LSM must pass this method before registering its own operations
  * to avoid security registration races. This method may also be used
@@ -100,41 +96,13 @@ __setup("security=", choose_lsm);
  *	 choose an alternate LSM at boot time.
  * Otherwise, return false.
  */
-int __init security_module_enable(struct security_operations *ops)
+int __init security_module_enable(const char *module)
 {
-	return !strcmp(ops->name, chosen_lsm);
-}
-
-/**
- * register_security - registers a security framework with the kernel
- * @ops: a pointer to the struct security_options that is to be registered
- *
- * This function allows a security module to register itself with the
- * kernel security subsystem.  Some rudimentary checking is done on the @ops
- * value passed to this function. You'll need to check first if your LSM
- * is allowed to register its @ops by calling security_module_enable(@ops).
- *
- * If there is already a security module registered with the kernel,
- * an error will be returned.  Otherwise %0 is returned on success.
- */
-int __init register_security(struct security_operations *ops)
-{
-	if (verify(ops)) {
-		printk(KERN_DEBUG "%s could not verify "
-		       "security_operations structure.\n", __func__);
-		return -EINVAL;
-	}
-
-	if (security_ops != &default_security_ops)
-		return -EAGAIN;
-
-	security_ops = ops;
-
-	return 0;
+	return !strcmp(module, chosen_lsm);
 }
 
 /*
- * Hook operation macros.
+ * Hook list operation macros.
  *
  * call_void_hook:
  *	This is a hook that does not return a value.
@@ -143,8 +111,27 @@ int __init register_security(struct security_operations *ops)
  *	This is a hook that returns a value.
  */
 
-#define call_void_hook(FUNC, ...)	security_ops->FUNC(__VA_ARGS__)
-#define call_int_hook(FUNC, IRC, ...)	security_ops->FUNC(__VA_ARGS__)
+#define call_void_hook(FUNC, ...)				\
+	do {							\
+		struct security_hook_list *P;			\
+								\
+		list_for_each_entry(P, &security_hook_heads.FUNC, list)	\
+			P->hook.FUNC(__VA_ARGS__);		\
+	} while (0)
+
+#define call_int_hook(FUNC, IRC, ...) ({			\
+	int RC = IRC;						\
+	do {							\
+		struct security_hook_list *P;			\
+								\
+		list_for_each_entry(P, &security_hook_heads.FUNC, list) { \
+			RC = P->hook.FUNC(__VA_ARGS__);		\
+			if (RC != 0)				\
+				break;				\
+		}						\
+	} while (0);						\
+	RC;							\
+})
 
 /* Security operations */
 
@@ -173,23 +160,11 @@ int security_binder_transfer_file(struct task_struct *from,
 
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
-#ifdef CONFIG_SECURITY_YAMA_STACKED
-	int rc;
-	rc = yama_ptrace_access_check(child, mode);
-	if (rc)
-		return rc;
-#endif
 	return call_int_hook(ptrace_access_check, 0, child, mode);
 }
 
 int security_ptrace_traceme(struct task_struct *parent)
 {
-#ifdef CONFIG_SECURITY_YAMA_STACKED
-	int rc;
-	rc = yama_ptrace_traceme(parent);
-	if (rc)
-		return rc;
-#endif
 	return call_int_hook(ptrace_traceme, 0, parent);
 }
 
@@ -245,7 +220,25 @@ int security_settime(const struct timespec *ts, const struct timezone *tz)
 
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
-	return call_int_hook(vm_enough_memory, 0, mm, pages);
+	struct security_hook_list *hp;
+	int cap_sys_admin = 1;
+	int rc;
+
+	/*
+	 * The module will respond with a positive value if
+	 * it thinks the __vm_enough_memory() call should be
+	 * made with the cap_sys_admin set. If all of the modules
+	 * agree that it should be set it will. If any module
+	 * thinks it should not be set it won't.
+	 */
+	list_for_each_entry(hp, &security_hook_heads.vm_enough_memory, list) {
+		rc = hp->hook.vm_enough_memory(mm, pages);
+		if (rc <= 0) {
+			cap_sys_admin = 0;
+			break;
+		}
+	}
+	return __vm_enough_memory(mm, pages, cap_sys_admin);
 }
 
 int security_bprm_set_creds(struct linux_binprm *bprm)
@@ -335,8 +328,9 @@ int security_sb_set_mnt_opts(struct super_block *sb,
 				unsigned long kern_flags,
 				unsigned long *set_kern_flags)
 {
-	return call_int_hook(sb_set_mnt_opts, 0, sb, opts, kern_flags,
-						set_kern_flags);
+	return call_int_hook(sb_set_mnt_opts,
+				opts->num_mnt_opts ? -EOPNOTSUPP : 0, sb,
+				opts, kern_flags, set_kern_flags);
 }
 EXPORT_SYMBOL(security_sb_set_mnt_opts);
 
@@ -369,8 +363,8 @@ int security_dentry_init_security(struct dentry *dentry, int mode,
 					struct qstr *name, void **ctx,
 					u32 *ctxlen)
 {
-	return call_int_hook(dentry_init_security, 0, dentry, mode, name,
-							ctx, ctxlen);
+	return call_int_hook(dentry_init_security, -EOPNOTSUPP, dentry, mode,
+				name, ctx, ctxlen);
 }
 EXPORT_SYMBOL(security_dentry_init_security);
 
@@ -390,7 +384,7 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 							 NULL, NULL, NULL);
 	memset(new_xattrs, 0, sizeof(new_xattrs));
 	lsm_xattr = new_xattrs;
-	ret = call_int_hook(inode_init_security, 0, inode, dir, qstr,
+	ret = call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir, qstr,
 						&lsm_xattr->name,
 						&lsm_xattr->value,
 						&lsm_xattr->value_len);
@@ -636,8 +630,15 @@ int security_inode_setxattr(struct dentry *dentry, const char *name,
 
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	ret = call_int_hook(inode_setxattr, 0, dentry, name, value, size,
+	/*
+	 * SELinux and Smack integrate the cap call,
+	 * so assume that all LSMs supplying this call do so.
+	 */
+	ret = call_int_hook(inode_setxattr, 1, dentry, name, value, size,
 				flags);
+
+	if (ret == 1)
+		ret = cap_inode_setxattr(dentry, name, value, size, flags);
 	if (ret)
 		return ret;
 	ret = ima_inode_setxattr(dentry, name, value, size);
@@ -675,7 +676,13 @@ int security_inode_removexattr(struct dentry *dentry, const char *name)
 
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	ret = call_int_hook(inode_removexattr, 0, dentry, name);
+	/*
+	 * SELinux and Smack integrate the cap call,
+	 * so assume that all LSMs supplying this call do so.
+	 */
+	ret = call_int_hook(inode_removexattr, 1, dentry, name);
+	if (ret == 1)
+		ret = cap_inode_removexattr(dentry, name);
 	if (ret)
 		return ret;
 	ret = ima_inode_removexattr(dentry, name);
@@ -698,15 +705,16 @@ int security_inode_getsecurity(const struct inode *inode, const char *name, void
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return call_int_hook(inode_getsecurity, 0, inode, name, buffer, alloc);
+	return call_int_hook(inode_getsecurity, -EOPNOTSUPP, inode, name,
+				buffer, alloc);
 }
 
 int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return call_int_hook(inode_setsecurity, 0, inode, name, value, size,
-				flags);
+	return call_int_hook(inode_setsecurity, -EOPNOTSUPP, inode, name,
+				value, size, flags);
 }
 
 int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)
@@ -847,9 +855,6 @@ int security_task_create(unsigned long clone_flags)
 
 void security_task_free(struct task_struct *task)
 {
-#ifdef CONFIG_SECURITY_YAMA_STACKED
-	yama_task_free(task);
-#endif
 	call_void_hook(task_free, task);
 }
 
@@ -932,6 +937,7 @@ int security_task_getsid(struct task_struct *p)
 
 void security_task_getsecid(struct task_struct *p, u32 *secid)
 {
+	*secid = 0;
 	call_void_hook(task_getsecid, p, secid);
 }
 EXPORT_SYMBOL(security_task_getsecid);
@@ -986,13 +992,19 @@ int security_task_wait(struct task_struct *p)
 int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 			 unsigned long arg4, unsigned long arg5)
 {
-#ifdef CONFIG_SECURITY_YAMA_STACKED
-	int rc;
-	rc = yama_task_prctl(option, arg2, arg3, arg4, arg5);
-	if (rc != -ENOSYS)
-		return rc;
-#endif
-	return call_int_hook(task_prctl, 0, option, arg2, arg3, arg4, arg5);
+	int thisrc;
+	int rc = -ENOSYS;
+	struct security_hook_list *hp;
+
+	list_for_each_entry(hp, &security_hook_heads.task_prctl, list) {
+		thisrc = hp->hook.task_prctl(option, arg2, arg3, arg4, arg5);
+		if (thisrc != -ENOSYS) {
+			rc = thisrc;
+			if (thisrc != 0)
+				break;
+		}
+	}
+	return rc;
 }
 
 void security_task_to_inode(struct task_struct *p, struct inode *inode)
@@ -1007,6 +1019,7 @@ int security_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
 
 void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
 {
+	*secid = 0;
 	call_void_hook(ipc_getsecid, ipcp, secid);
 }
 
@@ -1113,12 +1126,12 @@ EXPORT_SYMBOL(security_d_instantiate);
 
 int security_getprocattr(struct task_struct *p, char *name, char **value)
 {
-	return call_int_hook(getprocattr, 0, p, name, value);
+	return call_int_hook(getprocattr, -EINVAL, p, name, value);
 }
 
 int security_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
 {
-	return call_int_hook(setprocattr, 0, p, name, value, size);
+	return call_int_hook(setprocattr, -EINVAL, p, name, value, size);
 }
 
 int security_netlink_send(struct sock *sk, struct sk_buff *skb)
@@ -1134,12 +1147,14 @@ EXPORT_SYMBOL(security_ismaclabel);
 
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 {
-	return call_int_hook(secid_to_secctx, 0, secid, secdata, seclen);
+	return call_int_hook(secid_to_secctx, -EOPNOTSUPP, secid, secdata,
+				seclen);
 }
 EXPORT_SYMBOL(security_secid_to_secctx);
 
 int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
 {
+	*secid = 0;
 	return call_int_hook(secctx_to_secid, 0, secdata, seclen, secid);
 }
 EXPORT_SYMBOL(security_secctx_to_secid);
@@ -1164,7 +1179,7 @@ EXPORT_SYMBOL(security_inode_setsecctx);
 
 int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)
 {
-	return call_int_hook(inode_getsecctx, 0, inode, ctx, ctxlen);
+	return call_int_hook(inode_getsecctx, -EOPNOTSUPP, inode, ctx, ctxlen);
 }
 EXPORT_SYMBOL(security_inode_getsecctx);
 
@@ -1259,8 +1274,8 @@ EXPORT_SYMBOL(security_sock_rcv_skb);
 int security_socket_getpeersec_stream(struct socket *sock, char __user *optval,
 				      int __user *optlen, unsigned len)
 {
-	return call_int_hook(socket_getpeersec_stream, 0, sock, optval,
-				optlen, len);
+	return call_int_hook(socket_getpeersec_stream, -ENOPROTOOPT, sock,
+				optval, optlen, len);
 }
 
 int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)
@@ -1438,7 +1453,24 @@ int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
 				       struct xfrm_policy *xp,
 				       const struct flowi *fl)
 {
-	return call_int_hook(xfrm_state_pol_flow_match, 0, x, xp, fl);
+	struct security_hook_list *hp;
+	int rc = 1;
+
+	/*
+	 * Since this function is expected to return 0 or 1, the judgment
+	 * becomes difficult if multiple LSMs supply this call. Fortunately,
+	 * we can use the first LSM's judgment because currently only SELinux
+	 * supplies this call.
+	 *
+	 * For speed optimization, we explicitly break the loop rather than
+	 * using the macro
+	 */
+	list_for_each_entry(hp, &security_hook_heads.xfrm_state_pol_flow_match,
+				list) {
+		rc = hp->hook.xfrm_state_pol_flow_match(x, xp, fl);
+		break;
+	}
+	return rc;
 }
 
 int security_xfrm_decode_session(struct sk_buff *skb, u32 *secid)
@@ -1478,6 +1510,7 @@ int security_key_permission(key_ref_t key_ref,
 
 int security_key_getsecurity(struct key *key, char **_buffer)
 {
+	*_buffer = NULL;
 	return call_int_hook(key_getsecurity, 0, key, _buffer);
 }
 
@@ -1506,5 +1539,350 @@ int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
 	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule,
 				actx);
 }
+#endif /* CONFIG_AUDIT */
 
+struct security_hook_heads security_hook_heads = {
+	.binder_set_context_mgr =
+		LIST_HEAD_INIT(security_hook_heads.binder_set_context_mgr),
+	.binder_transaction =
+		LIST_HEAD_INIT(security_hook_heads.binder_transaction),
+	.binder_transfer_binder =
+		LIST_HEAD_INIT(security_hook_heads.binder_transfer_binder),
+	.binder_transfer_file =
+		LIST_HEAD_INIT(security_hook_heads.binder_transfer_file),
+
+	.ptrace_access_check =
+		LIST_HEAD_INIT(security_hook_heads.ptrace_access_check),
+	.ptrace_traceme =
+		LIST_HEAD_INIT(security_hook_heads.ptrace_traceme),
+	.capget =	LIST_HEAD_INIT(security_hook_heads.capget),
+	.capset =	LIST_HEAD_INIT(security_hook_heads.capset),
+	.capable =	LIST_HEAD_INIT(security_hook_heads.capable),
+	.quotactl =	LIST_HEAD_INIT(security_hook_heads.quotactl),
+	.quota_on =	LIST_HEAD_INIT(security_hook_heads.quota_on),
+	.syslog =	LIST_HEAD_INIT(security_hook_heads.syslog),
+	.settime =	LIST_HEAD_INIT(security_hook_heads.settime),
+	.vm_enough_memory =
+		LIST_HEAD_INIT(security_hook_heads.vm_enough_memory),
+	.bprm_set_creds =
+		LIST_HEAD_INIT(security_hook_heads.bprm_set_creds),
+	.bprm_check_security =
+		LIST_HEAD_INIT(security_hook_heads.bprm_check_security),
+	.bprm_secureexec =
+		LIST_HEAD_INIT(security_hook_heads.bprm_secureexec),
+	.bprm_committing_creds =
+		LIST_HEAD_INIT(security_hook_heads.bprm_committing_creds),
+	.bprm_committed_creds =
+		LIST_HEAD_INIT(security_hook_heads.bprm_committed_creds),
+	.sb_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.sb_alloc_security),
+	.sb_free_security =
+		LIST_HEAD_INIT(security_hook_heads.sb_free_security),
+	.sb_copy_data =	LIST_HEAD_INIT(security_hook_heads.sb_copy_data),
+	.sb_remount =	LIST_HEAD_INIT(security_hook_heads.sb_remount),
+	.sb_kern_mount =
+		LIST_HEAD_INIT(security_hook_heads.sb_kern_mount),
+	.sb_show_options =
+		LIST_HEAD_INIT(security_hook_heads.sb_show_options),
+	.sb_statfs =	LIST_HEAD_INIT(security_hook_heads.sb_statfs),
+	.sb_mount =	LIST_HEAD_INIT(security_hook_heads.sb_mount),
+	.sb_umount =	LIST_HEAD_INIT(security_hook_heads.sb_umount),
+	.sb_pivotroot =	LIST_HEAD_INIT(security_hook_heads.sb_pivotroot),
+	.sb_set_mnt_opts =
+		LIST_HEAD_INIT(security_hook_heads.sb_set_mnt_opts),
+	.sb_clone_mnt_opts =
+		LIST_HEAD_INIT(security_hook_heads.sb_clone_mnt_opts),
+	.sb_parse_opts_str =
+		LIST_HEAD_INIT(security_hook_heads.sb_parse_opts_str),
+	.dentry_init_security =
+		LIST_HEAD_INIT(security_hook_heads.dentry_init_security),
+#ifdef CONFIG_SECURITY_PATH
+	.path_unlink =	LIST_HEAD_INIT(security_hook_heads.path_unlink),
+	.path_mkdir =	LIST_HEAD_INIT(security_hook_heads.path_mkdir),
+	.path_rmdir =	LIST_HEAD_INIT(security_hook_heads.path_rmdir),
+	.path_mknod =	LIST_HEAD_INIT(security_hook_heads.path_mknod),
+	.path_truncate =
+		LIST_HEAD_INIT(security_hook_heads.path_truncate),
+	.path_symlink =	LIST_HEAD_INIT(security_hook_heads.path_symlink),
+	.path_link =	LIST_HEAD_INIT(security_hook_heads.path_link),
+	.path_rename =	LIST_HEAD_INIT(security_hook_heads.path_rename),
+	.path_chmod =	LIST_HEAD_INIT(security_hook_heads.path_chmod),
+	.path_chown =	LIST_HEAD_INIT(security_hook_heads.path_chown),
+	.path_chroot =	LIST_HEAD_INIT(security_hook_heads.path_chroot),
+#endif
+	.inode_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.inode_alloc_security),
+	.inode_free_security =
+		LIST_HEAD_INIT(security_hook_heads.inode_free_security),
+	.inode_init_security =
+		LIST_HEAD_INIT(security_hook_heads.inode_init_security),
+	.inode_create =	LIST_HEAD_INIT(security_hook_heads.inode_create),
+	.inode_link =	LIST_HEAD_INIT(security_hook_heads.inode_link),
+	.inode_unlink =	LIST_HEAD_INIT(security_hook_heads.inode_unlink),
+	.inode_symlink =
+		LIST_HEAD_INIT(security_hook_heads.inode_symlink),
+	.inode_mkdir =	LIST_HEAD_INIT(security_hook_heads.inode_mkdir),
+	.inode_rmdir =	LIST_HEAD_INIT(security_hook_heads.inode_rmdir),
+	.inode_mknod =	LIST_HEAD_INIT(security_hook_heads.inode_mknod),
+	.inode_rename =	LIST_HEAD_INIT(security_hook_heads.inode_rename),
+	.inode_readlink =
+		LIST_HEAD_INIT(security_hook_heads.inode_readlink),
+	.inode_follow_link =
+		LIST_HEAD_INIT(security_hook_heads.inode_follow_link),
+	.inode_permission =
+		LIST_HEAD_INIT(security_hook_heads.inode_permission),
+	.inode_setattr =
+		LIST_HEAD_INIT(security_hook_heads.inode_setattr),
+	.inode_getattr =
+		LIST_HEAD_INIT(security_hook_heads.inode_getattr),
+	.inode_setxattr =
+		LIST_HEAD_INIT(security_hook_heads.inode_setxattr),
+	.inode_post_setxattr =
+		LIST_HEAD_INIT(security_hook_heads.inode_post_setxattr),
+	.inode_getxattr =
+		LIST_HEAD_INIT(security_hook_heads.inode_getxattr),
+	.inode_listxattr =
+		LIST_HEAD_INIT(security_hook_heads.inode_listxattr),
+	.inode_removexattr =
+		LIST_HEAD_INIT(security_hook_heads.inode_removexattr),
+	.inode_need_killpriv =
+		LIST_HEAD_INIT(security_hook_heads.inode_need_killpriv),
+	.inode_killpriv =
+		LIST_HEAD_INIT(security_hook_heads.inode_killpriv),
+	.inode_getsecurity =
+		LIST_HEAD_INIT(security_hook_heads.inode_getsecurity),
+	.inode_setsecurity =
+		LIST_HEAD_INIT(security_hook_heads.inode_setsecurity),
+	.inode_listsecurity =
+		LIST_HEAD_INIT(security_hook_heads.inode_listsecurity),
+	.inode_getsecid =
+		LIST_HEAD_INIT(security_hook_heads.inode_getsecid),
+	.file_permission =
+		LIST_HEAD_INIT(security_hook_heads.file_permission),
+	.file_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.file_alloc_security),
+	.file_free_security =
+		LIST_HEAD_INIT(security_hook_heads.file_free_security),
+	.file_ioctl =	LIST_HEAD_INIT(security_hook_heads.file_ioctl),
+	.mmap_addr =	LIST_HEAD_INIT(security_hook_heads.mmap_addr),
+	.mmap_file =	LIST_HEAD_INIT(security_hook_heads.mmap_file),
+	.file_mprotect =
+		LIST_HEAD_INIT(security_hook_heads.file_mprotect),
+	.file_lock =	LIST_HEAD_INIT(security_hook_heads.file_lock),
+	.file_fcntl =	LIST_HEAD_INIT(security_hook_heads.file_fcntl),
+	.file_set_fowner =
+		LIST_HEAD_INIT(security_hook_heads.file_set_fowner),
+	.file_send_sigiotask =
+		LIST_HEAD_INIT(security_hook_heads.file_send_sigiotask),
+	.file_receive =	LIST_HEAD_INIT(security_hook_heads.file_receive),
+	.file_open =	LIST_HEAD_INIT(security_hook_heads.file_open),
+	.task_create =	LIST_HEAD_INIT(security_hook_heads.task_create),
+	.task_free =	LIST_HEAD_INIT(security_hook_heads.task_free),
+	.cred_alloc_blank =
+		LIST_HEAD_INIT(security_hook_heads.cred_alloc_blank),
+	.cred_free =	LIST_HEAD_INIT(security_hook_heads.cred_free),
+	.cred_prepare =	LIST_HEAD_INIT(security_hook_heads.cred_prepare),
+	.cred_transfer =
+		LIST_HEAD_INIT(security_hook_heads.cred_transfer),
+	.kernel_act_as =
+		LIST_HEAD_INIT(security_hook_heads.kernel_act_as),
+	.kernel_create_files_as =
+		LIST_HEAD_INIT(security_hook_heads.kernel_create_files_as),
+	.kernel_fw_from_file =
+		LIST_HEAD_INIT(security_hook_heads.kernel_fw_from_file),
+	.kernel_module_request =
+		LIST_HEAD_INIT(security_hook_heads.kernel_module_request),
+	.kernel_module_from_file =
+		LIST_HEAD_INIT(security_hook_heads.kernel_module_from_file),
+	.task_fix_setuid =
+		LIST_HEAD_INIT(security_hook_heads.task_fix_setuid),
+	.task_setpgid =	LIST_HEAD_INIT(security_hook_heads.task_setpgid),
+	.task_getpgid =	LIST_HEAD_INIT(security_hook_heads.task_getpgid),
+	.task_getsid =	LIST_HEAD_INIT(security_hook_heads.task_getsid),
+	.task_getsecid =
+		LIST_HEAD_INIT(security_hook_heads.task_getsecid),
+	.task_setnice =	LIST_HEAD_INIT(security_hook_heads.task_setnice),
+	.task_setioprio =
+		LIST_HEAD_INIT(security_hook_heads.task_setioprio),
+	.task_getioprio =
+		LIST_HEAD_INIT(security_hook_heads.task_getioprio),
+	.task_setrlimit =
+		LIST_HEAD_INIT(security_hook_heads.task_setrlimit),
+	.task_setscheduler =
+		LIST_HEAD_INIT(security_hook_heads.task_setscheduler),
+	.task_getscheduler =
+		LIST_HEAD_INIT(security_hook_heads.task_getscheduler),
+	.task_movememory =
+		LIST_HEAD_INIT(security_hook_heads.task_movememory),
+	.task_kill =	LIST_HEAD_INIT(security_hook_heads.task_kill),
+	.task_wait =	LIST_HEAD_INIT(security_hook_heads.task_wait),
+	.task_prctl =	LIST_HEAD_INIT(security_hook_heads.task_prctl),
+	.task_to_inode =
+		LIST_HEAD_INIT(security_hook_heads.task_to_inode),
+	.ipc_permission =
+		LIST_HEAD_INIT(security_hook_heads.ipc_permission),
+	.ipc_getsecid =	LIST_HEAD_INIT(security_hook_heads.ipc_getsecid),
+	.msg_msg_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.msg_msg_alloc_security),
+	.msg_msg_free_security =
+		LIST_HEAD_INIT(security_hook_heads.msg_msg_free_security),
+	.msg_queue_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.msg_queue_alloc_security),
+	.msg_queue_free_security =
+		LIST_HEAD_INIT(security_hook_heads.msg_queue_free_security),
+	.msg_queue_associate =
+		LIST_HEAD_INIT(security_hook_heads.msg_queue_associate),
+	.msg_queue_msgctl =
+		LIST_HEAD_INIT(security_hook_heads.msg_queue_msgctl),
+	.msg_queue_msgsnd =
+		LIST_HEAD_INIT(security_hook_heads.msg_queue_msgsnd),
+	.msg_queue_msgrcv =
+		LIST_HEAD_INIT(security_hook_heads.msg_queue_msgrcv),
+	.shm_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.shm_alloc_security),
+	.shm_free_security =
+		LIST_HEAD_INIT(security_hook_heads.shm_free_security),
+	.shm_associate =
+		LIST_HEAD_INIT(security_hook_heads.shm_associate),
+	.shm_shmctl =	LIST_HEAD_INIT(security_hook_heads.shm_shmctl),
+	.shm_shmat =	LIST_HEAD_INIT(security_hook_heads.shm_shmat),
+	.sem_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.sem_alloc_security),
+	.sem_free_security =
+		LIST_HEAD_INIT(security_hook_heads.sem_free_security),
+	.sem_associate =
+		LIST_HEAD_INIT(security_hook_heads.sem_associate),
+	.sem_semctl =	LIST_HEAD_INIT(security_hook_heads.sem_semctl),
+	.sem_semop =	LIST_HEAD_INIT(security_hook_heads.sem_semop),
+	.netlink_send =	LIST_HEAD_INIT(security_hook_heads.netlink_send),
+	.d_instantiate =
+		LIST_HEAD_INIT(security_hook_heads.d_instantiate),
+	.getprocattr =	LIST_HEAD_INIT(security_hook_heads.getprocattr),
+	.setprocattr =	LIST_HEAD_INIT(security_hook_heads.setprocattr),
+	.ismaclabel =	LIST_HEAD_INIT(security_hook_heads.ismaclabel),
+	.secid_to_secctx =
+		LIST_HEAD_INIT(security_hook_heads.secid_to_secctx),
+	.secctx_to_secid =
+		LIST_HEAD_INIT(security_hook_heads.secctx_to_secid),
+	.release_secctx =
+		LIST_HEAD_INIT(security_hook_heads.release_secctx),
+	.inode_notifysecctx =
+		LIST_HEAD_INIT(security_hook_heads.inode_notifysecctx),
+	.inode_setsecctx =
+		LIST_HEAD_INIT(security_hook_heads.inode_setsecctx),
+	.inode_getsecctx =
+		LIST_HEAD_INIT(security_hook_heads.inode_getsecctx),
+#ifdef CONFIG_SECURITY_NETWORK
+	.unix_stream_connect =
+		LIST_HEAD_INIT(security_hook_heads.unix_stream_connect),
+	.unix_may_send =
+		LIST_HEAD_INIT(security_hook_heads.unix_may_send),
+	.socket_create =
+		LIST_HEAD_INIT(security_hook_heads.socket_create),
+	.socket_post_create =
+		LIST_HEAD_INIT(security_hook_heads.socket_post_create),
+	.socket_bind =	LIST_HEAD_INIT(security_hook_heads.socket_bind),
+	.socket_connect =
+		LIST_HEAD_INIT(security_hook_heads.socket_connect),
+	.socket_listen =
+		LIST_HEAD_INIT(security_hook_heads.socket_listen),
+	.socket_accept =
+		LIST_HEAD_INIT(security_hook_heads.socket_accept),
+	.socket_sendmsg =
+		LIST_HEAD_INIT(security_hook_heads.socket_sendmsg),
+	.socket_recvmsg =
+		LIST_HEAD_INIT(security_hook_heads.socket_recvmsg),
+	.socket_getsockname =
+		LIST_HEAD_INIT(security_hook_heads.socket_getsockname),
+	.socket_getpeername =
+		LIST_HEAD_INIT(security_hook_heads.socket_getpeername),
+	.socket_getsockopt =
+		LIST_HEAD_INIT(security_hook_heads.socket_getsockopt),
+	.socket_setsockopt =
+		LIST_HEAD_INIT(security_hook_heads.socket_setsockopt),
+	.socket_shutdown =
+		LIST_HEAD_INIT(security_hook_heads.socket_shutdown),
+	.socket_sock_rcv_skb =
+		LIST_HEAD_INIT(security_hook_heads.socket_sock_rcv_skb),
+	.socket_getpeersec_stream =
+		LIST_HEAD_INIT(security_hook_heads.socket_getpeersec_stream),
+	.socket_getpeersec_dgram =
+		LIST_HEAD_INIT(security_hook_heads.socket_getpeersec_dgram),
+	.sk_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.sk_alloc_security),
+	.sk_free_security =
+		LIST_HEAD_INIT(security_hook_heads.sk_free_security),
+	.sk_clone_security =
+		LIST_HEAD_INIT(security_hook_heads.sk_clone_security),
+	.sk_getsecid =	LIST_HEAD_INIT(security_hook_heads.sk_getsecid),
+	.sock_graft =	LIST_HEAD_INIT(security_hook_heads.sock_graft),
+	.inet_conn_request =
+		LIST_HEAD_INIT(security_hook_heads.inet_conn_request),
+	.inet_csk_clone =
+		LIST_HEAD_INIT(security_hook_heads.inet_csk_clone),
+	.inet_conn_established =
+		LIST_HEAD_INIT(security_hook_heads.inet_conn_established),
+	.secmark_relabel_packet =
+		LIST_HEAD_INIT(security_hook_heads.secmark_relabel_packet),
+	.secmark_refcount_inc =
+		LIST_HEAD_INIT(security_hook_heads.secmark_refcount_inc),
+	.secmark_refcount_dec =
+		LIST_HEAD_INIT(security_hook_heads.secmark_refcount_dec),
+	.req_classify_flow =
+		LIST_HEAD_INIT(security_hook_heads.req_classify_flow),
+	.tun_dev_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.tun_dev_alloc_security),
+	.tun_dev_free_security =
+		LIST_HEAD_INIT(security_hook_heads.tun_dev_free_security),
+	.tun_dev_create =
+		LIST_HEAD_INIT(security_hook_heads.tun_dev_create),
+	.tun_dev_attach_queue =
+		LIST_HEAD_INIT(security_hook_heads.tun_dev_attach_queue),
+	.tun_dev_attach =
+		LIST_HEAD_INIT(security_hook_heads.tun_dev_attach),
+	.tun_dev_open =	LIST_HEAD_INIT(security_hook_heads.tun_dev_open),
+	.skb_owned_by =	LIST_HEAD_INIT(security_hook_heads.skb_owned_by),
+#endif	/* CONFIG_SECURITY_NETWORK */
+#ifdef CONFIG_SECURITY_NETWORK_XFRM
+	.xfrm_policy_alloc_security =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_alloc_security),
+	.xfrm_policy_clone_security =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_clone_security),
+	.xfrm_policy_free_security =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_free_security),
+	.xfrm_policy_delete_security =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_delete_security),
+	.xfrm_state_alloc =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_state_alloc),
+	.xfrm_state_alloc_acquire =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_state_alloc_acquire),
+	.xfrm_state_free_security =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_state_free_security),
+	.xfrm_state_delete_security =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_state_delete_security),
+	.xfrm_policy_lookup =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_policy_lookup),
+	.xfrm_state_pol_flow_match =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_state_pol_flow_match),
+	.xfrm_decode_session =
+		LIST_HEAD_INIT(security_hook_heads.xfrm_decode_session),
+#endif	/* CONFIG_SECURITY_NETWORK_XFRM */
+#ifdef CONFIG_KEYS
+	.key_alloc =	LIST_HEAD_INIT(security_hook_heads.key_alloc),
+	.key_free =	LIST_HEAD_INIT(security_hook_heads.key_free),
+	.key_permission =
+		LIST_HEAD_INIT(security_hook_heads.key_permission),
+	.key_getsecurity =
+		LIST_HEAD_INIT(security_hook_heads.key_getsecurity),
+#endif	/* CONFIG_KEYS */
+#ifdef CONFIG_AUDIT
+	.audit_rule_init =
+		LIST_HEAD_INIT(security_hook_heads.audit_rule_init),
+	.audit_rule_known =
+		LIST_HEAD_INIT(security_hook_heads.audit_rule_known),
+	.audit_rule_match =
+		LIST_HEAD_INIT(security_hook_heads.audit_rule_match),
+	.audit_rule_free =
+		LIST_HEAD_INIT(security_hook_heads.audit_rule_free),
 #endif /* CONFIG_AUDIT */
+};

commit f25fce3e8f1f15d6d2a22620ebf98a68a4641f06
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Sat May 2 15:11:29 2015 -0700

    LSM: Introduce security hook calling Macros
    
    Introduce two macros around calling the functions in the
    security operations vector. The marco versions here do not
    change any behavior.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 9c95fe0c8d75..02dc72006afa 100644
--- a/security/security.c
+++ b/security/security.c
@@ -133,29 +133,42 @@ int __init register_security(struct security_operations *ops)
 	return 0;
 }
 
+/*
+ * Hook operation macros.
+ *
+ * call_void_hook:
+ *	This is a hook that does not return a value.
+ *
+ * call_int_hook:
+ *	This is a hook that returns a value.
+ */
+
+#define call_void_hook(FUNC, ...)	security_ops->FUNC(__VA_ARGS__)
+#define call_int_hook(FUNC, IRC, ...)	security_ops->FUNC(__VA_ARGS__)
+
 /* Security operations */
 
 int security_binder_set_context_mgr(struct task_struct *mgr)
 {
-	return security_ops->binder_set_context_mgr(mgr);
+	return call_int_hook(binder_set_context_mgr, 0, mgr);
 }
 
 int security_binder_transaction(struct task_struct *from,
 				struct task_struct *to)
 {
-	return security_ops->binder_transaction(from, to);
+	return call_int_hook(binder_transaction, 0, from, to);
 }
 
 int security_binder_transfer_binder(struct task_struct *from,
 				    struct task_struct *to)
 {
-	return security_ops->binder_transfer_binder(from, to);
+	return call_int_hook(binder_transfer_binder, 0, from, to);
 }
 
 int security_binder_transfer_file(struct task_struct *from,
 				  struct task_struct *to, struct file *file)
 {
-	return security_ops->binder_transfer_file(from, to, file);
+	return call_int_hook(binder_transfer_file, 0, from, to, file);
 }
 
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
@@ -166,7 +179,7 @@ int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 	if (rc)
 		return rc;
 #endif
-	return security_ops->ptrace_access_check(child, mode);
+	return call_int_hook(ptrace_access_check, 0, child, mode);
 }
 
 int security_ptrace_traceme(struct task_struct *parent)
@@ -177,7 +190,7 @@ int security_ptrace_traceme(struct task_struct *parent)
 	if (rc)
 		return rc;
 #endif
-	return security_ops->ptrace_traceme(parent);
+	return call_int_hook(ptrace_traceme, 0, parent);
 }
 
 int security_capget(struct task_struct *target,
@@ -185,7 +198,8 @@ int security_capget(struct task_struct *target,
 		     kernel_cap_t *inheritable,
 		     kernel_cap_t *permitted)
 {
-	return security_ops->capget(target, effective, inheritable, permitted);
+	return call_int_hook(capget, 0, target,
+				effective, inheritable, permitted);
 }
 
 int security_capset(struct cred *new, const struct cred *old,
@@ -193,57 +207,57 @@ int security_capset(struct cred *new, const struct cred *old,
 		    const kernel_cap_t *inheritable,
 		    const kernel_cap_t *permitted)
 {
-	return security_ops->capset(new, old,
-				    effective, inheritable, permitted);
+	return call_int_hook(capset, 0, new, old,
+				effective, inheritable, permitted);
 }
 
 int security_capable(const struct cred *cred, struct user_namespace *ns,
 		     int cap)
 {
-	return security_ops->capable(cred, ns, cap, SECURITY_CAP_AUDIT);
+	return call_int_hook(capable, 0, cred, ns, cap, SECURITY_CAP_AUDIT);
 }
 
 int security_capable_noaudit(const struct cred *cred, struct user_namespace *ns,
 			     int cap)
 {
-	return security_ops->capable(cred, ns, cap, SECURITY_CAP_NOAUDIT);
+	return call_int_hook(capable, 0, cred, ns, cap, SECURITY_CAP_NOAUDIT);
 }
 
 int security_quotactl(int cmds, int type, int id, struct super_block *sb)
 {
-	return security_ops->quotactl(cmds, type, id, sb);
+	return call_int_hook(quotactl, 0, cmds, type, id, sb);
 }
 
 int security_quota_on(struct dentry *dentry)
 {
-	return security_ops->quota_on(dentry);
+	return call_int_hook(quota_on, 0, dentry);
 }
 
 int security_syslog(int type)
 {
-	return security_ops->syslog(type);
+	return call_int_hook(syslog, 0, type);
 }
 
 int security_settime(const struct timespec *ts, const struct timezone *tz)
 {
-	return security_ops->settime(ts, tz);
+	return call_int_hook(settime, 0, ts, tz);
 }
 
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
-	return security_ops->vm_enough_memory(mm, pages);
+	return call_int_hook(vm_enough_memory, 0, mm, pages);
 }
 
 int security_bprm_set_creds(struct linux_binprm *bprm)
 {
-	return security_ops->bprm_set_creds(bprm);
+	return call_int_hook(bprm_set_creds, 0, bprm);
 }
 
 int security_bprm_check(struct linux_binprm *bprm)
 {
 	int ret;
 
-	ret = security_ops->bprm_check_security(bprm);
+	ret = call_int_hook(bprm_check_security, 0, bprm);
 	if (ret)
 		return ret;
 	return ima_bprm_check(bprm);
@@ -251,69 +265,69 @@ int security_bprm_check(struct linux_binprm *bprm)
 
 void security_bprm_committing_creds(struct linux_binprm *bprm)
 {
-	security_ops->bprm_committing_creds(bprm);
+	call_void_hook(bprm_committing_creds, bprm);
 }
 
 void security_bprm_committed_creds(struct linux_binprm *bprm)
 {
-	security_ops->bprm_committed_creds(bprm);
+	call_void_hook(bprm_committed_creds, bprm);
 }
 
 int security_bprm_secureexec(struct linux_binprm *bprm)
 {
-	return security_ops->bprm_secureexec(bprm);
+	return call_int_hook(bprm_secureexec, 0, bprm);
 }
 
 int security_sb_alloc(struct super_block *sb)
 {
-	return security_ops->sb_alloc_security(sb);
+	return call_int_hook(sb_alloc_security, 0, sb);
 }
 
 void security_sb_free(struct super_block *sb)
 {
-	security_ops->sb_free_security(sb);
+	call_void_hook(sb_free_security, sb);
 }
 
 int security_sb_copy_data(char *orig, char *copy)
 {
-	return security_ops->sb_copy_data(orig, copy);
+	return call_int_hook(sb_copy_data, 0, orig, copy);
 }
 EXPORT_SYMBOL(security_sb_copy_data);
 
 int security_sb_remount(struct super_block *sb, void *data)
 {
-	return security_ops->sb_remount(sb, data);
+	return call_int_hook(sb_remount, 0, sb, data);
 }
 
 int security_sb_kern_mount(struct super_block *sb, int flags, void *data)
 {
-	return security_ops->sb_kern_mount(sb, flags, data);
+	return call_int_hook(sb_kern_mount, 0, sb, flags, data);
 }
 
 int security_sb_show_options(struct seq_file *m, struct super_block *sb)
 {
-	return security_ops->sb_show_options(m, sb);
+	return call_int_hook(sb_show_options, 0, m, sb);
 }
 
 int security_sb_statfs(struct dentry *dentry)
 {
-	return security_ops->sb_statfs(dentry);
+	return call_int_hook(sb_statfs, 0, dentry);
 }
 
 int security_sb_mount(const char *dev_name, struct path *path,
                        const char *type, unsigned long flags, void *data)
 {
-	return security_ops->sb_mount(dev_name, path, type, flags, data);
+	return call_int_hook(sb_mount, 0, dev_name, path, type, flags, data);
 }
 
 int security_sb_umount(struct vfsmount *mnt, int flags)
 {
-	return security_ops->sb_umount(mnt, flags);
+	return call_int_hook(sb_umount, 0, mnt, flags);
 }
 
 int security_sb_pivotroot(struct path *old_path, struct path *new_path)
 {
-	return security_ops->sb_pivotroot(old_path, new_path);
+	return call_int_hook(sb_pivotroot, 0, old_path, new_path);
 }
 
 int security_sb_set_mnt_opts(struct super_block *sb,
@@ -321,7 +335,7 @@ int security_sb_set_mnt_opts(struct super_block *sb,
 				unsigned long kern_flags,
 				unsigned long *set_kern_flags)
 {
-	return security_ops->sb_set_mnt_opts(sb, opts, kern_flags,
+	return call_int_hook(sb_set_mnt_opts, 0, sb, opts, kern_flags,
 						set_kern_flags);
 }
 EXPORT_SYMBOL(security_sb_set_mnt_opts);
@@ -329,33 +343,33 @@ EXPORT_SYMBOL(security_sb_set_mnt_opts);
 int security_sb_clone_mnt_opts(const struct super_block *oldsb,
 				struct super_block *newsb)
 {
-	return security_ops->sb_clone_mnt_opts(oldsb, newsb);
+	return call_int_hook(sb_clone_mnt_opts, 0, oldsb, newsb);
 }
 EXPORT_SYMBOL(security_sb_clone_mnt_opts);
 
 int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)
 {
-	return security_ops->sb_parse_opts_str(options, opts);
+	return call_int_hook(sb_parse_opts_str, 0, options, opts);
 }
 EXPORT_SYMBOL(security_sb_parse_opts_str);
 
 int security_inode_alloc(struct inode *inode)
 {
 	inode->i_security = NULL;
-	return security_ops->inode_alloc_security(inode);
+	return call_int_hook(inode_alloc_security, 0, inode);
 }
 
 void security_inode_free(struct inode *inode)
 {
 	integrity_inode_free(inode);
-	security_ops->inode_free_security(inode);
+	call_void_hook(inode_free_security, inode);
 }
 
 int security_dentry_init_security(struct dentry *dentry, int mode,
 					struct qstr *name, void **ctx,
 					u32 *ctxlen)
 {
-	return security_ops->dentry_init_security(dentry, mode, name,
+	return call_int_hook(dentry_init_security, 0, dentry, mode, name,
 							ctx, ctxlen);
 }
 EXPORT_SYMBOL(security_dentry_init_security);
@@ -372,11 +386,11 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 		return 0;
 
 	if (!initxattrs)
-		return security_ops->inode_init_security(inode, dir, qstr,
+		return call_int_hook(inode_init_security, 0, inode, dir, qstr,
 							 NULL, NULL, NULL);
 	memset(new_xattrs, 0, sizeof(new_xattrs));
 	lsm_xattr = new_xattrs;
-	ret = security_ops->inode_init_security(inode, dir, qstr,
+	ret = call_int_hook(inode_init_security, 0, inode, dir, qstr,
 						&lsm_xattr->name,
 						&lsm_xattr->value,
 						&lsm_xattr->value_len);
@@ -401,8 +415,8 @@ int security_old_inode_init_security(struct inode *inode, struct inode *dir,
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return security_ops->inode_init_security(inode, dir, qstr, name, value,
-						 len);
+	return call_int_hook(inode_init_security, 0, inode, dir, qstr,
+				name, value, len);
 }
 EXPORT_SYMBOL(security_old_inode_init_security);
 
@@ -412,7 +426,7 @@ int security_path_mknod(struct path *dir, struct dentry *dentry, umode_t mode,
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
-	return security_ops->path_mknod(dir, dentry, mode, dev);
+	return call_int_hook(path_mknod, 0, dir, dentry, mode, dev);
 }
 EXPORT_SYMBOL(security_path_mknod);
 
@@ -420,7 +434,7 @@ int security_path_mkdir(struct path *dir, struct dentry *dentry, umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
-	return security_ops->path_mkdir(dir, dentry, mode);
+	return call_int_hook(path_mkdir, 0, dir, dentry, mode);
 }
 EXPORT_SYMBOL(security_path_mkdir);
 
@@ -428,14 +442,14 @@ int security_path_rmdir(struct path *dir, struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
-	return security_ops->path_rmdir(dir, dentry);
+	return call_int_hook(path_rmdir, 0, dir, dentry);
 }
 
 int security_path_unlink(struct path *dir, struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
-	return security_ops->path_unlink(dir, dentry);
+	return call_int_hook(path_unlink, 0, dir, dentry);
 }
 EXPORT_SYMBOL(security_path_unlink);
 
@@ -444,7 +458,7 @@ int security_path_symlink(struct path *dir, struct dentry *dentry,
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
-	return security_ops->path_symlink(dir, dentry, old_name);
+	return call_int_hook(path_symlink, 0, dir, dentry, old_name);
 }
 
 int security_path_link(struct dentry *old_dentry, struct path *new_dir,
@@ -452,7 +466,7 @@ int security_path_link(struct dentry *old_dentry, struct path *new_dir,
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))
 		return 0;
-	return security_ops->path_link(old_dentry, new_dir, new_dentry);
+	return call_int_hook(path_link, 0, old_dentry, new_dir, new_dentry);
 }
 
 int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
@@ -464,14 +478,14 @@ int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
 		return 0;
 
 	if (flags & RENAME_EXCHANGE) {
-		int err = security_ops->path_rename(new_dir, new_dentry,
-						    old_dir, old_dentry);
+		int err = call_int_hook(path_rename, 0, new_dir, new_dentry,
+					old_dir, old_dentry);
 		if (err)
 			return err;
 	}
 
-	return security_ops->path_rename(old_dir, old_dentry, new_dir,
-					 new_dentry);
+	return call_int_hook(path_rename, 0, old_dir, old_dentry, new_dir,
+				new_dentry);
 }
 EXPORT_SYMBOL(security_path_rename);
 
@@ -479,26 +493,26 @@ int security_path_truncate(struct path *path)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;
-	return security_ops->path_truncate(path);
+	return call_int_hook(path_truncate, 0, path);
 }
 
 int security_path_chmod(struct path *path, umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;
-	return security_ops->path_chmod(path, mode);
+	return call_int_hook(path_chmod, 0, path, mode);
 }
 
 int security_path_chown(struct path *path, kuid_t uid, kgid_t gid)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;
-	return security_ops->path_chown(path, uid, gid);
+	return call_int_hook(path_chown, 0, path, uid, gid);
 }
 
 int security_path_chroot(struct path *path)
 {
-	return security_ops->path_chroot(path);
+	return call_int_hook(path_chroot, 0, path);
 }
 #endif
 
@@ -506,7 +520,7 @@ int security_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode
 {
 	if (unlikely(IS_PRIVATE(dir)))
 		return 0;
-	return security_ops->inode_create(dir, dentry, mode);
+	return call_int_hook(inode_create, 0, dir, dentry, mode);
 }
 EXPORT_SYMBOL_GPL(security_inode_create);
 
@@ -515,14 +529,14 @@ int security_inode_link(struct dentry *old_dentry, struct inode *dir,
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))
 		return 0;
-	return security_ops->inode_link(old_dentry, dir, new_dentry);
+	return call_int_hook(inode_link, 0, old_dentry, dir, new_dentry);
 }
 
 int security_inode_unlink(struct inode *dir, struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	return security_ops->inode_unlink(dir, dentry);
+	return call_int_hook(inode_unlink, 0, dir, dentry);
 }
 
 int security_inode_symlink(struct inode *dir, struct dentry *dentry,
@@ -530,14 +544,14 @@ int security_inode_symlink(struct inode *dir, struct dentry *dentry,
 {
 	if (unlikely(IS_PRIVATE(dir)))
 		return 0;
-	return security_ops->inode_symlink(dir, dentry, old_name);
+	return call_int_hook(inode_symlink, 0, dir, dentry, old_name);
 }
 
 int security_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(dir)))
 		return 0;
-	return security_ops->inode_mkdir(dir, dentry, mode);
+	return call_int_hook(inode_mkdir, 0, dir, dentry, mode);
 }
 EXPORT_SYMBOL_GPL(security_inode_mkdir);
 
@@ -545,14 +559,14 @@ int security_inode_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	return security_ops->inode_rmdir(dir, dentry);
+	return call_int_hook(inode_rmdir, 0, dir, dentry);
 }
 
 int security_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
 {
 	if (unlikely(IS_PRIVATE(dir)))
 		return 0;
-	return security_ops->inode_mknod(dir, dentry, mode, dev);
+	return call_int_hook(inode_mknod, 0, dir, dentry, mode, dev);
 }
 
 int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
@@ -564,13 +578,13 @@ int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
 		return 0;
 
 	if (flags & RENAME_EXCHANGE) {
-		int err = security_ops->inode_rename(new_dir, new_dentry,
+		int err = call_int_hook(inode_rename, 0, new_dir, new_dentry,
 						     old_dir, old_dentry);
 		if (err)
 			return err;
 	}
 
-	return security_ops->inode_rename(old_dir, old_dentry,
+	return call_int_hook(inode_rename, 0, old_dir, old_dentry,
 					   new_dir, new_dentry);
 }
 
@@ -578,21 +592,21 @@ int security_inode_readlink(struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	return security_ops->inode_readlink(dentry);
+	return call_int_hook(inode_readlink, 0, dentry);
 }
 
 int security_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	return security_ops->inode_follow_link(dentry, nd);
+	return call_int_hook(inode_follow_link, 0, dentry, nd);
 }
 
 int security_inode_permission(struct inode *inode, int mask)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	return security_ops->inode_permission(inode, mask);
+	return call_int_hook(inode_permission, 0, inode, mask);
 }
 
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
@@ -601,7 +615,7 @@ int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	ret = security_ops->inode_setattr(dentry, attr);
+	ret = call_int_hook(inode_setattr, 0, dentry, attr);
 	if (ret)
 		return ret;
 	return evm_inode_setattr(dentry, attr);
@@ -612,7 +626,7 @@ int security_inode_getattr(const struct path *path)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;
-	return security_ops->inode_getattr(path);
+	return call_int_hook(inode_getattr, 0, path);
 }
 
 int security_inode_setxattr(struct dentry *dentry, const char *name,
@@ -622,7 +636,8 @@ int security_inode_setxattr(struct dentry *dentry, const char *name,
 
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	ret = security_ops->inode_setxattr(dentry, name, value, size, flags);
+	ret = call_int_hook(inode_setxattr, 0, dentry, name, value, size,
+				flags);
 	if (ret)
 		return ret;
 	ret = ima_inode_setxattr(dentry, name, value, size);
@@ -636,7 +651,7 @@ void security_inode_post_setxattr(struct dentry *dentry, const char *name,
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return;
-	security_ops->inode_post_setxattr(dentry, name, value, size, flags);
+	call_void_hook(inode_post_setxattr, dentry, name, value, size, flags);
 	evm_inode_post_setxattr(dentry, name, value, size);
 }
 
@@ -644,14 +659,14 @@ int security_inode_getxattr(struct dentry *dentry, const char *name)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	return security_ops->inode_getxattr(dentry, name);
+	return call_int_hook(inode_getxattr, 0, dentry, name);
 }
 
 int security_inode_listxattr(struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	return security_ops->inode_listxattr(dentry);
+	return call_int_hook(inode_listxattr, 0, dentry);
 }
 
 int security_inode_removexattr(struct dentry *dentry, const char *name)
@@ -660,7 +675,7 @@ int security_inode_removexattr(struct dentry *dentry, const char *name)
 
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	ret = security_ops->inode_removexattr(dentry, name);
+	ret = call_int_hook(inode_removexattr, 0, dentry, name);
 	if (ret)
 		return ret;
 	ret = ima_inode_removexattr(dentry, name);
@@ -671,46 +686,47 @@ int security_inode_removexattr(struct dentry *dentry, const char *name)
 
 int security_inode_need_killpriv(struct dentry *dentry)
 {
-	return security_ops->inode_need_killpriv(dentry);
+	return call_int_hook(inode_need_killpriv, 0, dentry);
 }
 
 int security_inode_killpriv(struct dentry *dentry)
 {
-	return security_ops->inode_killpriv(dentry);
+	return call_int_hook(inode_killpriv, 0, dentry);
 }
 
 int security_inode_getsecurity(const struct inode *inode, const char *name, void **buffer, bool alloc)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return security_ops->inode_getsecurity(inode, name, buffer, alloc);
+	return call_int_hook(inode_getsecurity, 0, inode, name, buffer, alloc);
 }
 
 int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return security_ops->inode_setsecurity(inode, name, value, size, flags);
+	return call_int_hook(inode_setsecurity, 0, inode, name, value, size,
+				flags);
 }
 
 int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	return security_ops->inode_listsecurity(inode, buffer, buffer_size);
+	return call_int_hook(inode_listsecurity, 0, inode, buffer, buffer_size);
 }
 EXPORT_SYMBOL(security_inode_listsecurity);
 
 void security_inode_getsecid(const struct inode *inode, u32 *secid)
 {
-	security_ops->inode_getsecid(inode, secid);
+	call_void_hook(inode_getsecid, inode, secid);
 }
 
 int security_file_permission(struct file *file, int mask)
 {
 	int ret;
 
-	ret = security_ops->file_permission(file, mask);
+	ret = call_int_hook(file_permission, 0, file, mask);
 	if (ret)
 		return ret;
 
@@ -719,17 +735,17 @@ int security_file_permission(struct file *file, int mask)
 
 int security_file_alloc(struct file *file)
 {
-	return security_ops->file_alloc_security(file);
+	return call_int_hook(file_alloc_security, 0, file);
 }
 
 void security_file_free(struct file *file)
 {
-	security_ops->file_free_security(file);
+	call_void_hook(file_free_security, file);
 }
 
 int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	return security_ops->file_ioctl(file, cmd, arg);
+	return call_int_hook(file_ioctl, 0, file, cmd, arg);
 }
 
 static inline unsigned long mmap_prot(struct file *file, unsigned long prot)
@@ -769,7 +785,7 @@ int security_mmap_file(struct file *file, unsigned long prot,
 			unsigned long flags)
 {
 	int ret;
-	ret = security_ops->mmap_file(file, prot,
+	ret = call_int_hook(mmap_file, 0, file, prot,
 					mmap_prot(file, prot), flags);
 	if (ret)
 		return ret;
@@ -778,46 +794,46 @@ int security_mmap_file(struct file *file, unsigned long prot,
 
 int security_mmap_addr(unsigned long addr)
 {
-	return security_ops->mmap_addr(addr);
+	return call_int_hook(mmap_addr, 0, addr);
 }
 
 int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,
 			    unsigned long prot)
 {
-	return security_ops->file_mprotect(vma, reqprot, prot);
+	return call_int_hook(file_mprotect, 0, vma, reqprot, prot);
 }
 
 int security_file_lock(struct file *file, unsigned int cmd)
 {
-	return security_ops->file_lock(file, cmd);
+	return call_int_hook(file_lock, 0, file, cmd);
 }
 
 int security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	return security_ops->file_fcntl(file, cmd, arg);
+	return call_int_hook(file_fcntl, 0, file, cmd, arg);
 }
 
 void security_file_set_fowner(struct file *file)
 {
-	security_ops->file_set_fowner(file);
+	call_void_hook(file_set_fowner, file);
 }
 
 int security_file_send_sigiotask(struct task_struct *tsk,
 				  struct fown_struct *fown, int sig)
 {
-	return security_ops->file_send_sigiotask(tsk, fown, sig);
+	return call_int_hook(file_send_sigiotask, 0, tsk, fown, sig);
 }
 
 int security_file_receive(struct file *file)
 {
-	return security_ops->file_receive(file);
+	return call_int_hook(file_receive, 0, file);
 }
 
 int security_file_open(struct file *file, const struct cred *cred)
 {
 	int ret;
 
-	ret = security_ops->file_open(file, cred);
+	ret = call_int_hook(file_open, 0, file, cred);
 	if (ret)
 		return ret;
 
@@ -826,7 +842,7 @@ int security_file_open(struct file *file, const struct cred *cred)
 
 int security_task_create(unsigned long clone_flags)
 {
-	return security_ops->task_create(clone_flags);
+	return call_int_hook(task_create, 0, clone_flags);
 }
 
 void security_task_free(struct task_struct *task)
@@ -834,44 +850,44 @@ void security_task_free(struct task_struct *task)
 #ifdef CONFIG_SECURITY_YAMA_STACKED
 	yama_task_free(task);
 #endif
-	security_ops->task_free(task);
+	call_void_hook(task_free, task);
 }
 
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
-	return security_ops->cred_alloc_blank(cred, gfp);
+	return call_int_hook(cred_alloc_blank, 0, cred, gfp);
 }
 
 void security_cred_free(struct cred *cred)
 {
-	security_ops->cred_free(cred);
+	call_void_hook(cred_free, cred);
 }
 
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
 {
-	return security_ops->cred_prepare(new, old, gfp);
+	return call_int_hook(cred_prepare, 0, new, old, gfp);
 }
 
 void security_transfer_creds(struct cred *new, const struct cred *old)
 {
-	security_ops->cred_transfer(new, old);
+	call_void_hook(cred_transfer, new, old);
 }
 
 int security_kernel_act_as(struct cred *new, u32 secid)
 {
-	return security_ops->kernel_act_as(new, secid);
+	return call_int_hook(kernel_act_as, 0, new, secid);
 }
 
 int security_kernel_create_files_as(struct cred *new, struct inode *inode)
 {
-	return security_ops->kernel_create_files_as(new, inode);
+	return call_int_hook(kernel_create_files_as, 0, new, inode);
 }
 
 int security_kernel_fw_from_file(struct file *file, char *buf, size_t size)
 {
 	int ret;
 
-	ret = security_ops->kernel_fw_from_file(file, buf, size);
+	ret = call_int_hook(kernel_fw_from_file, 0, file, buf, size);
 	if (ret)
 		return ret;
 	return ima_fw_from_file(file, buf, size);
@@ -880,14 +896,14 @@ EXPORT_SYMBOL_GPL(security_kernel_fw_from_file);
 
 int security_kernel_module_request(char *kmod_name)
 {
-	return security_ops->kernel_module_request(kmod_name);
+	return call_int_hook(kernel_module_request, 0, kmod_name);
 }
 
 int security_kernel_module_from_file(struct file *file)
 {
 	int ret;
 
-	ret = security_ops->kernel_module_from_file(file);
+	ret = call_int_hook(kernel_module_from_file, 0, file);
 	if (ret)
 		return ret;
 	return ima_module_check(file);
@@ -896,75 +912,75 @@ int security_kernel_module_from_file(struct file *file)
 int security_task_fix_setuid(struct cred *new, const struct cred *old,
 			     int flags)
 {
-	return security_ops->task_fix_setuid(new, old, flags);
+	return call_int_hook(task_fix_setuid, 0, new, old, flags);
 }
 
 int security_task_setpgid(struct task_struct *p, pid_t pgid)
 {
-	return security_ops->task_setpgid(p, pgid);
+	return call_int_hook(task_setpgid, 0, p, pgid);
 }
 
 int security_task_getpgid(struct task_struct *p)
 {
-	return security_ops->task_getpgid(p);
+	return call_int_hook(task_getpgid, 0, p);
 }
 
 int security_task_getsid(struct task_struct *p)
 {
-	return security_ops->task_getsid(p);
+	return call_int_hook(task_getsid, 0, p);
 }
 
 void security_task_getsecid(struct task_struct *p, u32 *secid)
 {
-	security_ops->task_getsecid(p, secid);
+	call_void_hook(task_getsecid, p, secid);
 }
 EXPORT_SYMBOL(security_task_getsecid);
 
 int security_task_setnice(struct task_struct *p, int nice)
 {
-	return security_ops->task_setnice(p, nice);
+	return call_int_hook(task_setnice, 0, p, nice);
 }
 
 int security_task_setioprio(struct task_struct *p, int ioprio)
 {
-	return security_ops->task_setioprio(p, ioprio);
+	return call_int_hook(task_setioprio, 0, p, ioprio);
 }
 
 int security_task_getioprio(struct task_struct *p)
 {
-	return security_ops->task_getioprio(p);
+	return call_int_hook(task_getioprio, 0, p);
 }
 
 int security_task_setrlimit(struct task_struct *p, unsigned int resource,
 		struct rlimit *new_rlim)
 {
-	return security_ops->task_setrlimit(p, resource, new_rlim);
+	return call_int_hook(task_setrlimit, 0, p, resource, new_rlim);
 }
 
 int security_task_setscheduler(struct task_struct *p)
 {
-	return security_ops->task_setscheduler(p);
+	return call_int_hook(task_setscheduler, 0, p);
 }
 
 int security_task_getscheduler(struct task_struct *p)
 {
-	return security_ops->task_getscheduler(p);
+	return call_int_hook(task_getscheduler, 0, p);
 }
 
 int security_task_movememory(struct task_struct *p)
 {
-	return security_ops->task_movememory(p);
+	return call_int_hook(task_movememory, 0, p);
 }
 
 int security_task_kill(struct task_struct *p, struct siginfo *info,
 			int sig, u32 secid)
 {
-	return security_ops->task_kill(p, info, sig, secid);
+	return call_int_hook(task_kill, 0, p, info, sig, secid);
 }
 
 int security_task_wait(struct task_struct *p)
 {
-	return security_ops->task_wait(p);
+	return call_int_hook(task_wait, 0, p);
 }
 
 int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
@@ -976,179 +992,179 @@ int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 	if (rc != -ENOSYS)
 		return rc;
 #endif
-	return security_ops->task_prctl(option, arg2, arg3, arg4, arg5);
+	return call_int_hook(task_prctl, 0, option, arg2, arg3, arg4, arg5);
 }
 
 void security_task_to_inode(struct task_struct *p, struct inode *inode)
 {
-	security_ops->task_to_inode(p, inode);
+	call_void_hook(task_to_inode, p, inode);
 }
 
 int security_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
 {
-	return security_ops->ipc_permission(ipcp, flag);
+	return call_int_hook(ipc_permission, 0, ipcp, flag);
 }
 
 void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
 {
-	security_ops->ipc_getsecid(ipcp, secid);
+	call_void_hook(ipc_getsecid, ipcp, secid);
 }
 
 int security_msg_msg_alloc(struct msg_msg *msg)
 {
-	return security_ops->msg_msg_alloc_security(msg);
+	return call_int_hook(msg_msg_alloc_security, 0, msg);
 }
 
 void security_msg_msg_free(struct msg_msg *msg)
 {
-	security_ops->msg_msg_free_security(msg);
+	call_void_hook(msg_msg_free_security, msg);
 }
 
 int security_msg_queue_alloc(struct msg_queue *msq)
 {
-	return security_ops->msg_queue_alloc_security(msq);
+	return call_int_hook(msg_queue_alloc_security, 0, msq);
 }
 
 void security_msg_queue_free(struct msg_queue *msq)
 {
-	security_ops->msg_queue_free_security(msq);
+	call_void_hook(msg_queue_free_security, msq);
 }
 
 int security_msg_queue_associate(struct msg_queue *msq, int msqflg)
 {
-	return security_ops->msg_queue_associate(msq, msqflg);
+	return call_int_hook(msg_queue_associate, 0, msq, msqflg);
 }
 
 int security_msg_queue_msgctl(struct msg_queue *msq, int cmd)
 {
-	return security_ops->msg_queue_msgctl(msq, cmd);
+	return call_int_hook(msg_queue_msgctl, 0, msq, cmd);
 }
 
 int security_msg_queue_msgsnd(struct msg_queue *msq,
 			       struct msg_msg *msg, int msqflg)
 {
-	return security_ops->msg_queue_msgsnd(msq, msg, msqflg);
+	return call_int_hook(msg_queue_msgsnd, 0, msq, msg, msqflg);
 }
 
 int security_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
 			       struct task_struct *target, long type, int mode)
 {
-	return security_ops->msg_queue_msgrcv(msq, msg, target, type, mode);
+	return call_int_hook(msg_queue_msgrcv, 0, msq, msg, target, type, mode);
 }
 
 int security_shm_alloc(struct shmid_kernel *shp)
 {
-	return security_ops->shm_alloc_security(shp);
+	return call_int_hook(shm_alloc_security, 0, shp);
 }
 
 void security_shm_free(struct shmid_kernel *shp)
 {
-	security_ops->shm_free_security(shp);
+	call_void_hook(shm_free_security, shp);
 }
 
 int security_shm_associate(struct shmid_kernel *shp, int shmflg)
 {
-	return security_ops->shm_associate(shp, shmflg);
+	return call_int_hook(shm_associate, 0, shp, shmflg);
 }
 
 int security_shm_shmctl(struct shmid_kernel *shp, int cmd)
 {
-	return security_ops->shm_shmctl(shp, cmd);
+	return call_int_hook(shm_shmctl, 0, shp, cmd);
 }
 
 int security_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmflg)
 {
-	return security_ops->shm_shmat(shp, shmaddr, shmflg);
+	return call_int_hook(shm_shmat, 0, shp, shmaddr, shmflg);
 }
 
 int security_sem_alloc(struct sem_array *sma)
 {
-	return security_ops->sem_alloc_security(sma);
+	return call_int_hook(sem_alloc_security, 0, sma);
 }
 
 void security_sem_free(struct sem_array *sma)
 {
-	security_ops->sem_free_security(sma);
+	call_void_hook(sem_free_security, sma);
 }
 
 int security_sem_associate(struct sem_array *sma, int semflg)
 {
-	return security_ops->sem_associate(sma, semflg);
+	return call_int_hook(sem_associate, 0, sma, semflg);
 }
 
 int security_sem_semctl(struct sem_array *sma, int cmd)
 {
-	return security_ops->sem_semctl(sma, cmd);
+	return call_int_hook(sem_semctl, 0, sma, cmd);
 }
 
 int security_sem_semop(struct sem_array *sma, struct sembuf *sops,
 			unsigned nsops, int alter)
 {
-	return security_ops->sem_semop(sma, sops, nsops, alter);
+	return call_int_hook(sem_semop, 0, sma, sops, nsops, alter);
 }
 
 void security_d_instantiate(struct dentry *dentry, struct inode *inode)
 {
 	if (unlikely(inode && IS_PRIVATE(inode)))
 		return;
-	security_ops->d_instantiate(dentry, inode);
+	call_void_hook(d_instantiate, dentry, inode);
 }
 EXPORT_SYMBOL(security_d_instantiate);
 
 int security_getprocattr(struct task_struct *p, char *name, char **value)
 {
-	return security_ops->getprocattr(p, name, value);
+	return call_int_hook(getprocattr, 0, p, name, value);
 }
 
 int security_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
 {
-	return security_ops->setprocattr(p, name, value, size);
+	return call_int_hook(setprocattr, 0, p, name, value, size);
 }
 
 int security_netlink_send(struct sock *sk, struct sk_buff *skb)
 {
-	return security_ops->netlink_send(sk, skb);
+	return call_int_hook(netlink_send, 0, sk, skb);
 }
 
 int security_ismaclabel(const char *name)
 {
-	return security_ops->ismaclabel(name);
+	return call_int_hook(ismaclabel, 0, name);
 }
 EXPORT_SYMBOL(security_ismaclabel);
 
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 {
-	return security_ops->secid_to_secctx(secid, secdata, seclen);
+	return call_int_hook(secid_to_secctx, 0, secid, secdata, seclen);
 }
 EXPORT_SYMBOL(security_secid_to_secctx);
 
 int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
 {
-	return security_ops->secctx_to_secid(secdata, seclen, secid);
+	return call_int_hook(secctx_to_secid, 0, secdata, seclen, secid);
 }
 EXPORT_SYMBOL(security_secctx_to_secid);
 
 void security_release_secctx(char *secdata, u32 seclen)
 {
-	security_ops->release_secctx(secdata, seclen);
+	call_void_hook(release_secctx, secdata, seclen);
 }
 EXPORT_SYMBOL(security_release_secctx);
 
 int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)
 {
-	return security_ops->inode_notifysecctx(inode, ctx, ctxlen);
+	return call_int_hook(inode_notifysecctx, 0, inode, ctx, ctxlen);
 }
 EXPORT_SYMBOL(security_inode_notifysecctx);
 
 int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)
 {
-	return security_ops->inode_setsecctx(dentry, ctx, ctxlen);
+	return call_int_hook(inode_setsecctx, 0, dentry, ctx, ctxlen);
 }
 EXPORT_SYMBOL(security_inode_setsecctx);
 
 int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)
 {
-	return security_ops->inode_getsecctx(inode, ctx, ctxlen);
+	return call_int_hook(inode_getsecctx, 0, inode, ctx, ctxlen);
 }
 EXPORT_SYMBOL(security_inode_getsecctx);
 
@@ -1156,206 +1172,207 @@ EXPORT_SYMBOL(security_inode_getsecctx);
 
 int security_unix_stream_connect(struct sock *sock, struct sock *other, struct sock *newsk)
 {
-	return security_ops->unix_stream_connect(sock, other, newsk);
+	return call_int_hook(unix_stream_connect, 0, sock, other, newsk);
 }
 EXPORT_SYMBOL(security_unix_stream_connect);
 
 int security_unix_may_send(struct socket *sock,  struct socket *other)
 {
-	return security_ops->unix_may_send(sock, other);
+	return call_int_hook(unix_may_send, 0, sock, other);
 }
 EXPORT_SYMBOL(security_unix_may_send);
 
 int security_socket_create(int family, int type, int protocol, int kern)
 {
-	return security_ops->socket_create(family, type, protocol, kern);
+	return call_int_hook(socket_create, 0, family, type, protocol, kern);
 }
 
 int security_socket_post_create(struct socket *sock, int family,
 				int type, int protocol, int kern)
 {
-	return security_ops->socket_post_create(sock, family, type,
+	return call_int_hook(socket_post_create, 0, sock, family, type,
 						protocol, kern);
 }
 
 int security_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
 {
-	return security_ops->socket_bind(sock, address, addrlen);
+	return call_int_hook(socket_bind, 0, sock, address, addrlen);
 }
 
 int security_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
 {
-	return security_ops->socket_connect(sock, address, addrlen);
+	return call_int_hook(socket_connect, 0, sock, address, addrlen);
 }
 
 int security_socket_listen(struct socket *sock, int backlog)
 {
-	return security_ops->socket_listen(sock, backlog);
+	return call_int_hook(socket_listen, 0, sock, backlog);
 }
 
 int security_socket_accept(struct socket *sock, struct socket *newsock)
 {
-	return security_ops->socket_accept(sock, newsock);
+	return call_int_hook(socket_accept, 0, sock, newsock);
 }
 
 int security_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size)
 {
-	return security_ops->socket_sendmsg(sock, msg, size);
+	return call_int_hook(socket_sendmsg, 0, sock, msg, size);
 }
 
 int security_socket_recvmsg(struct socket *sock, struct msghdr *msg,
 			    int size, int flags)
 {
-	return security_ops->socket_recvmsg(sock, msg, size, flags);
+	return call_int_hook(socket_recvmsg, 0, sock, msg, size, flags);
 }
 
 int security_socket_getsockname(struct socket *sock)
 {
-	return security_ops->socket_getsockname(sock);
+	return call_int_hook(socket_getsockname, 0, sock);
 }
 
 int security_socket_getpeername(struct socket *sock)
 {
-	return security_ops->socket_getpeername(sock);
+	return call_int_hook(socket_getpeername, 0, sock);
 }
 
 int security_socket_getsockopt(struct socket *sock, int level, int optname)
 {
-	return security_ops->socket_getsockopt(sock, level, optname);
+	return call_int_hook(socket_getsockopt, 0, sock, level, optname);
 }
 
 int security_socket_setsockopt(struct socket *sock, int level, int optname)
 {
-	return security_ops->socket_setsockopt(sock, level, optname);
+	return call_int_hook(socket_setsockopt, 0, sock, level, optname);
 }
 
 int security_socket_shutdown(struct socket *sock, int how)
 {
-	return security_ops->socket_shutdown(sock, how);
+	return call_int_hook(socket_shutdown, 0, sock, how);
 }
 
 int security_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
-	return security_ops->socket_sock_rcv_skb(sk, skb);
+	return call_int_hook(socket_sock_rcv_skb, 0, sk, skb);
 }
 EXPORT_SYMBOL(security_sock_rcv_skb);
 
 int security_socket_getpeersec_stream(struct socket *sock, char __user *optval,
 				      int __user *optlen, unsigned len)
 {
-	return security_ops->socket_getpeersec_stream(sock, optval, optlen, len);
+	return call_int_hook(socket_getpeersec_stream, 0, sock, optval,
+				optlen, len);
 }
 
 int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)
 {
-	return security_ops->socket_getpeersec_dgram(sock, skb, secid);
+	return call_int_hook(socket_getpeersec_dgram, 0, sock, skb, secid);
 }
 EXPORT_SYMBOL(security_socket_getpeersec_dgram);
 
 int security_sk_alloc(struct sock *sk, int family, gfp_t priority)
 {
-	return security_ops->sk_alloc_security(sk, family, priority);
+	return call_int_hook(sk_alloc_security, 0, sk, family, priority);
 }
 
 void security_sk_free(struct sock *sk)
 {
-	security_ops->sk_free_security(sk);
+	call_void_hook(sk_free_security, sk);
 }
 
 void security_sk_clone(const struct sock *sk, struct sock *newsk)
 {
-	security_ops->sk_clone_security(sk, newsk);
+	call_void_hook(sk_clone_security, sk, newsk);
 }
 EXPORT_SYMBOL(security_sk_clone);
 
 void security_sk_classify_flow(struct sock *sk, struct flowi *fl)
 {
-	security_ops->sk_getsecid(sk, &fl->flowi_secid);
+	call_void_hook(sk_getsecid, sk, &fl->flowi_secid);
 }
 EXPORT_SYMBOL(security_sk_classify_flow);
 
 void security_req_classify_flow(const struct request_sock *req, struct flowi *fl)
 {
-	security_ops->req_classify_flow(req, fl);
+	call_void_hook(req_classify_flow, req, fl);
 }
 EXPORT_SYMBOL(security_req_classify_flow);
 
 void security_sock_graft(struct sock *sk, struct socket *parent)
 {
-	security_ops->sock_graft(sk, parent);
+	call_void_hook(sock_graft, sk, parent);
 }
 EXPORT_SYMBOL(security_sock_graft);
 
 int security_inet_conn_request(struct sock *sk,
 			struct sk_buff *skb, struct request_sock *req)
 {
-	return security_ops->inet_conn_request(sk, skb, req);
+	return call_int_hook(inet_conn_request, 0, sk, skb, req);
 }
 EXPORT_SYMBOL(security_inet_conn_request);
 
 void security_inet_csk_clone(struct sock *newsk,
 			const struct request_sock *req)
 {
-	security_ops->inet_csk_clone(newsk, req);
+	call_void_hook(inet_csk_clone, newsk, req);
 }
 
 void security_inet_conn_established(struct sock *sk,
 			struct sk_buff *skb)
 {
-	security_ops->inet_conn_established(sk, skb);
+	call_void_hook(inet_conn_established, sk, skb);
 }
 
 int security_secmark_relabel_packet(u32 secid)
 {
-	return security_ops->secmark_relabel_packet(secid);
+	return call_int_hook(secmark_relabel_packet, 0, secid);
 }
 EXPORT_SYMBOL(security_secmark_relabel_packet);
 
 void security_secmark_refcount_inc(void)
 {
-	security_ops->secmark_refcount_inc();
+	call_void_hook(secmark_refcount_inc);
 }
 EXPORT_SYMBOL(security_secmark_refcount_inc);
 
 void security_secmark_refcount_dec(void)
 {
-	security_ops->secmark_refcount_dec();
+	call_void_hook(secmark_refcount_dec);
 }
 EXPORT_SYMBOL(security_secmark_refcount_dec);
 
 int security_tun_dev_alloc_security(void **security)
 {
-	return security_ops->tun_dev_alloc_security(security);
+	return call_int_hook(tun_dev_alloc_security, 0, security);
 }
 EXPORT_SYMBOL(security_tun_dev_alloc_security);
 
 void security_tun_dev_free_security(void *security)
 {
-	security_ops->tun_dev_free_security(security);
+	call_void_hook(tun_dev_free_security, security);
 }
 EXPORT_SYMBOL(security_tun_dev_free_security);
 
 int security_tun_dev_create(void)
 {
-	return security_ops->tun_dev_create();
+	return call_int_hook(tun_dev_create, 0);
 }
 EXPORT_SYMBOL(security_tun_dev_create);
 
 int security_tun_dev_attach_queue(void *security)
 {
-	return security_ops->tun_dev_attach_queue(security);
+	return call_int_hook(tun_dev_attach_queue, 0, security);
 }
 EXPORT_SYMBOL(security_tun_dev_attach_queue);
 
 int security_tun_dev_attach(struct sock *sk, void *security)
 {
-	return security_ops->tun_dev_attach(sk, security);
+	return call_int_hook(tun_dev_attach, 0, sk, security);
 }
 EXPORT_SYMBOL(security_tun_dev_attach);
 
 int security_tun_dev_open(void *security)
 {
-	return security_ops->tun_dev_open(security);
+	return call_int_hook(tun_dev_open, 0, security);
 }
 EXPORT_SYMBOL(security_tun_dev_open);
 
@@ -1367,71 +1384,72 @@ int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,
 			       struct xfrm_user_sec_ctx *sec_ctx,
 			       gfp_t gfp)
 {
-	return security_ops->xfrm_policy_alloc_security(ctxp, sec_ctx, gfp);
+	return call_int_hook(xfrm_policy_alloc_security, 0, ctxp, sec_ctx, gfp);
 }
 EXPORT_SYMBOL(security_xfrm_policy_alloc);
 
 int security_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,
 			      struct xfrm_sec_ctx **new_ctxp)
 {
-	return security_ops->xfrm_policy_clone_security(old_ctx, new_ctxp);
+	return call_int_hook(xfrm_policy_clone_security, 0, old_ctx, new_ctxp);
 }
 
 void security_xfrm_policy_free(struct xfrm_sec_ctx *ctx)
 {
-	security_ops->xfrm_policy_free_security(ctx);
+	call_void_hook(xfrm_policy_free_security, ctx);
 }
 EXPORT_SYMBOL(security_xfrm_policy_free);
 
 int security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)
 {
-	return security_ops->xfrm_policy_delete_security(ctx);
+	return call_int_hook(xfrm_policy_delete_security, 0, ctx);
 }
 
 int security_xfrm_state_alloc(struct xfrm_state *x,
 			      struct xfrm_user_sec_ctx *sec_ctx)
 {
-	return security_ops->xfrm_state_alloc(x, sec_ctx);
+	return call_int_hook(xfrm_state_alloc, 0, x, sec_ctx);
 }
 EXPORT_SYMBOL(security_xfrm_state_alloc);
 
 int security_xfrm_state_alloc_acquire(struct xfrm_state *x,
 				      struct xfrm_sec_ctx *polsec, u32 secid)
 {
-	return security_ops->xfrm_state_alloc_acquire(x, polsec, secid);
+	return call_int_hook(xfrm_state_alloc_acquire, 0, x, polsec, secid);
 }
 
 int security_xfrm_state_delete(struct xfrm_state *x)
 {
-	return security_ops->xfrm_state_delete_security(x);
+	return call_int_hook(xfrm_state_delete_security, 0, x);
 }
 EXPORT_SYMBOL(security_xfrm_state_delete);
 
 void security_xfrm_state_free(struct xfrm_state *x)
 {
-	security_ops->xfrm_state_free_security(x);
+	call_void_hook(xfrm_state_free_security, x);
 }
 
 int security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)
 {
-	return security_ops->xfrm_policy_lookup(ctx, fl_secid, dir);
+	return call_int_hook(xfrm_policy_lookup, 0, ctx, fl_secid, dir);
 }
 
 int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
 				       struct xfrm_policy *xp,
 				       const struct flowi *fl)
 {
-	return security_ops->xfrm_state_pol_flow_match(x, xp, fl);
+	return call_int_hook(xfrm_state_pol_flow_match, 0, x, xp, fl);
 }
 
 int security_xfrm_decode_session(struct sk_buff *skb, u32 *secid)
 {
-	return security_ops->xfrm_decode_session(skb, secid, 1);
+	return call_int_hook(xfrm_decode_session, 0, skb, secid, 1);
 }
 
 void security_skb_classify_flow(struct sk_buff *skb, struct flowi *fl)
 {
-	int rc = security_ops->xfrm_decode_session(skb, &fl->flowi_secid, 0);
+	int rc = call_int_hook(xfrm_decode_session, 0, skb, &fl->flowi_secid,
+				0);
 
 	BUG_ON(rc);
 }
@@ -1444,23 +1462,23 @@ EXPORT_SYMBOL(security_skb_classify_flow);
 int security_key_alloc(struct key *key, const struct cred *cred,
 		       unsigned long flags)
 {
-	return security_ops->key_alloc(key, cred, flags);
+	return call_int_hook(key_alloc, 0, key, cred, flags);
 }
 
 void security_key_free(struct key *key)
 {
-	security_ops->key_free(key);
+	call_void_hook(key_free, key);
 }
 
 int security_key_permission(key_ref_t key_ref,
 			    const struct cred *cred, unsigned perm)
 {
-	return security_ops->key_permission(key_ref, cred, perm);
+	return call_int_hook(key_permission, 0, key_ref, cred, perm);
 }
 
 int security_key_getsecurity(struct key *key, char **_buffer)
 {
-	return security_ops->key_getsecurity(key, _buffer);
+	return call_int_hook(key_getsecurity, 0, key, _buffer);
 }
 
 #endif	/* CONFIG_KEYS */
@@ -1469,23 +1487,24 @@ int security_key_getsecurity(struct key *key, char **_buffer)
 
 int security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
 {
-	return security_ops->audit_rule_init(field, op, rulestr, lsmrule);
+	return call_int_hook(audit_rule_init, 0, field, op, rulestr, lsmrule);
 }
 
 int security_audit_rule_known(struct audit_krule *krule)
 {
-	return security_ops->audit_rule_known(krule);
+	return call_int_hook(audit_rule_known, 0, krule);
 }
 
 void security_audit_rule_free(void *lsmrule)
 {
-	security_ops->audit_rule_free(lsmrule);
+	call_void_hook(audit_rule_free, lsmrule);
 }
 
 int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
 			      struct audit_context *actx)
 {
-	return security_ops->audit_rule_match(secid, field, op, lsmrule, actx);
+	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule,
+				actx);
 }
 
 #endif /* CONFIG_AUDIT */

commit 3c4ed7bdf5997d8020cbb8d4abbef2fcfb9f1284
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Sat May 2 15:10:46 2015 -0700

    LSM: Split security.h
    
    The security.h header file serves two purposes,
    interfaces for users of the security modules and
    interfaces for security modules. Users of the
    security modules don't need to know about what's
    in the security_operations structure, so pull it
    out into it's own header, lsm_hooks.h
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 8e9b1f4b9b45..9c95fe0c8d75 100644
--- a/security/security.c
+++ b/security/security.c
@@ -16,7 +16,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/security.h>
+#include <linux/lsm_hooks.h>
 #include <linux/integrity.h>
 #include <linux/ima.h>
 #include <linux/evm.h>

commit bda0be7ad994812960e9f8f2d2757f72cb4a96cb
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 23 13:37:39 2015 +1100

    security: make inode_follow_link RCU-walk aware
    
    inode_follow_link now takes an inode and rcu flag as well as the
    dentry.
    
    inode is used in preference to d_backing_inode(dentry), particularly
    in RCU-walk mode.
    
    selinux_inode_follow_link() gets dentry_has_perm() and
    inode_has_perm() open-coded into it so that it can call
    avc_has_perm_flags() in way that is safe if LOOKUP_RCU is set.
    
    Calling avc_has_perm_flags() with rcu_read_lock() held means
    that when avc_has_perm_noaudit calls avc_compute_av(), the attempt
    to rcu_read_unlock() before calling security_compute_av() will not
    actually drop the RCU read-lock.
    
    However as security_compute_av() is completely in a read_lock()ed
    region, it should be safe with the RCU read-lock held.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index d7c30b03e144..04c8feca081a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -581,11 +581,12 @@ int security_inode_readlink(struct dentry *dentry)
 	return security_ops->inode_readlink(dentry);
 }
 
-int security_inode_follow_link(struct dentry *dentry)
+int security_inode_follow_link(struct dentry *dentry, struct inode *inode,
+			       bool rcu)
 {
-	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
+	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	return security_ops->inode_follow_link(dentry);
+	return security_ops->inode_follow_link(dentry, inode, rcu);
 }
 
 int security_inode_permission(struct inode *inode, int mask)

commit 37882db0546c759ff75b561c188539ac96fd0bfe
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 23 13:37:39 2015 +1100

    SECURITY: remove nameidata arg from inode_follow_link.
    
    No ->inode_follow_link() methods use the nameidata arg, and
    it is about to become private to namei.c.
    So remove from all inode_follow_link() functions.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 8e9b1f4b9b45..d7c30b03e144 100644
--- a/security/security.c
+++ b/security/security.c
@@ -581,11 +581,11 @@ int security_inode_readlink(struct dentry *dentry)
 	return security_ops->inode_readlink(dentry);
 }
 
-int security_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
+int security_inode_follow_link(struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
-	return security_ops->inode_follow_link(dentry, nd);
+	return security_ops->inode_follow_link(dentry);
 }
 
 int security_inode_permission(struct inode *inode, int mask)

commit c6f493d631c4d40cea5c36055f9148f547b200af
Author: David Howells <dhowells@redhat.com>
Date:   Tue Mar 17 22:26:22 2015 +0000

    VFS: security/: d_backing_inode() annotations
    
    most of the ->d_inode uses there refer to the same inode IO would
    go to, i.e. d_backing_inode()
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 730ac65a5737..8e9b1f4b9b45 100644
--- a/security/security.c
+++ b/security/security.c
@@ -410,7 +410,7 @@ EXPORT_SYMBOL(security_old_inode_init_security);
 int security_path_mknod(struct path *dir, struct dentry *dentry, umode_t mode,
 			unsigned int dev)
 {
-	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
 	return security_ops->path_mknod(dir, dentry, mode, dev);
 }
@@ -418,7 +418,7 @@ EXPORT_SYMBOL(security_path_mknod);
 
 int security_path_mkdir(struct path *dir, struct dentry *dentry, umode_t mode)
 {
-	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
 	return security_ops->path_mkdir(dir, dentry, mode);
 }
@@ -426,14 +426,14 @@ EXPORT_SYMBOL(security_path_mkdir);
 
 int security_path_rmdir(struct path *dir, struct dentry *dentry)
 {
-	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
 	return security_ops->path_rmdir(dir, dentry);
 }
 
 int security_path_unlink(struct path *dir, struct dentry *dentry)
 {
-	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
 	return security_ops->path_unlink(dir, dentry);
 }
@@ -442,7 +442,7 @@ EXPORT_SYMBOL(security_path_unlink);
 int security_path_symlink(struct path *dir, struct dentry *dentry,
 			  const char *old_name)
 {
-	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))
 		return 0;
 	return security_ops->path_symlink(dir, dentry, old_name);
 }
@@ -450,7 +450,7 @@ int security_path_symlink(struct path *dir, struct dentry *dentry,
 int security_path_link(struct dentry *old_dentry, struct path *new_dir,
 		       struct dentry *new_dentry)
 {
-	if (unlikely(IS_PRIVATE(old_dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))
 		return 0;
 	return security_ops->path_link(old_dentry, new_dir, new_dentry);
 }
@@ -459,8 +459,8 @@ int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
 			 struct path *new_dir, struct dentry *new_dentry,
 			 unsigned int flags)
 {
-	if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
-		     (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))
+	if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||
+		     (d_is_positive(new_dentry) && IS_PRIVATE(d_backing_inode(new_dentry)))))
 		return 0;
 
 	if (flags & RENAME_EXCHANGE) {
@@ -477,21 +477,21 @@ EXPORT_SYMBOL(security_path_rename);
 
 int security_path_truncate(struct path *path)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;
 	return security_ops->path_truncate(path);
 }
 
 int security_path_chmod(struct path *path, umode_t mode)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;
 	return security_ops->path_chmod(path, mode);
 }
 
 int security_path_chown(struct path *path, kuid_t uid, kgid_t gid)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;
 	return security_ops->path_chown(path, uid, gid);
 }
@@ -513,14 +513,14 @@ EXPORT_SYMBOL_GPL(security_inode_create);
 int security_inode_link(struct dentry *old_dentry, struct inode *dir,
 			 struct dentry *new_dentry)
 {
-	if (unlikely(IS_PRIVATE(old_dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))
 		return 0;
 	return security_ops->inode_link(old_dentry, dir, new_dentry);
 }
 
 int security_inode_unlink(struct inode *dir, struct dentry *dentry)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	return security_ops->inode_unlink(dir, dentry);
 }
@@ -543,7 +543,7 @@ EXPORT_SYMBOL_GPL(security_inode_mkdir);
 
 int security_inode_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	return security_ops->inode_rmdir(dir, dentry);
 }
@@ -559,8 +559,8 @@ int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
 			   struct inode *new_dir, struct dentry *new_dentry,
 			   unsigned int flags)
 {
-        if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
-            (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))
+        if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||
+            (d_is_positive(new_dentry) && IS_PRIVATE(d_backing_inode(new_dentry)))))
 		return 0;
 
 	if (flags & RENAME_EXCHANGE) {
@@ -576,14 +576,14 @@ int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
 
 int security_inode_readlink(struct dentry *dentry)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	return security_ops->inode_readlink(dentry);
 }
 
 int security_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	return security_ops->inode_follow_link(dentry, nd);
 }
@@ -599,7 +599,7 @@ int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int ret;
 
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	ret = security_ops->inode_setattr(dentry, attr);
 	if (ret)
@@ -610,7 +610,7 @@ EXPORT_SYMBOL_GPL(security_inode_setattr);
 
 int security_inode_getattr(const struct path *path)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))
 		return 0;
 	return security_ops->inode_getattr(path);
 }
@@ -620,7 +620,7 @@ int security_inode_setxattr(struct dentry *dentry, const char *name,
 {
 	int ret;
 
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	ret = security_ops->inode_setxattr(dentry, name, value, size, flags);
 	if (ret)
@@ -634,7 +634,7 @@ int security_inode_setxattr(struct dentry *dentry, const char *name,
 void security_inode_post_setxattr(struct dentry *dentry, const char *name,
 				  const void *value, size_t size, int flags)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return;
 	security_ops->inode_post_setxattr(dentry, name, value, size, flags);
 	evm_inode_post_setxattr(dentry, name, value, size);
@@ -642,14 +642,14 @@ void security_inode_post_setxattr(struct dentry *dentry, const char *name,
 
 int security_inode_getxattr(struct dentry *dentry, const char *name)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	return security_ops->inode_getxattr(dentry, name);
 }
 
 int security_inode_listxattr(struct dentry *dentry)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	return security_ops->inode_listxattr(dentry);
 }
@@ -658,7 +658,7 @@ int security_inode_removexattr(struct dentry *dentry, const char *name)
 {
 	int ret;
 
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
 	ret = security_ops->inode_removexattr(dentry, name);
 	if (ret)

commit 39c853ebfe169f187a760b34f9cbf54751bfce00
Merge: fdc81f45e9f5 01e97e651705
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 11 22:27:19 2015 -0400

    Merge branch 'for-davem' into for-next

commit 3f7036a071b879da017eddaedb10fba173fdf1ff
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 8 19:28:30 2015 -0400

    switch security_inode_getattr() to struct path *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index e81d5bbe7363..ed890c6d31c5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -608,11 +608,11 @@ int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 }
 EXPORT_SYMBOL_GPL(security_inode_setattr);
 
-int security_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
+int security_inode_getattr(const struct path *path)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
 		return 0;
-	return security_ops->inode_getattr(mnt, dentry);
+	return security_ops->inode_getattr(path);
 }
 
 int security_inode_setxattr(struct dentry *dentry, const char *name,

commit d3593b5cef76db45c864de23c599b58198879e8c
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Mar 20 17:15:19 2015 -0700

    Revert "selinux: add a skb_owned_by() hook"
    
    This reverts commit ca10b9e9a8ca7342ee07065289cbe74ac128c169.
    
    No longer needed after commit eb8895debe1baba41fcb62c78a16f0c63c21662a
    ("tcp: tcp_make_synack() should use sock_wmalloc")
    
    When under SYNFLOOD, we build lot of SYNACK and hit false sharing
    because of multiple modifications done on sk_listener->sk_wmem_alloc
    
    Since tcp_make_synack() uses sock_wmalloc(), there is no need
    to call skb_set_owner_w() again, as this adds two atomic operations.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index e81d5bbe7363..1f475aa53288 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1359,11 +1359,6 @@ int security_tun_dev_open(void *security)
 }
 EXPORT_SYMBOL(security_tun_dev_open);
 
-void security_skb_owned_by(struct sk_buff *skb, struct sock *sk)
-{
-	security_ops->skb_owned_by(skb, sk);
-}
-
 #endif	/* CONFIG_SECURITY_NETWORK */
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM

commit 4ba63072b998cc31515cc6305c25f3b808b50c01
Merge: e29876723f7c 5fb31cd839c2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 15 10:48:44 2015 -0800

    Merge tag 'char-misc-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char / misc patches from Greg KH:
     "Here's the big char/misc driver update for 3.20-rc1.
    
      Lots of little things in here, all described in the changelog.
      Nothing major or unusual, except maybe the binder selinux stuff, which
      was all acked by the proper selinux people and they thought it best to
      come through this tree.
    
      All of this has been in linux-next with no reported issues for a while"
    
    * tag 'char-misc-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (90 commits)
      coresight: fix function etm_writel_cp14() parameter order
      coresight-etm: remove check for unknown Kconfig macro
      coresight: fixing CPU hwid lookup in device tree
      coresight: remove the unnecessary function coresight_is_bit_set()
      coresight: fix the debug AMBA bus name
      coresight: remove the extra spaces
      coresight: fix the link between orphan connection and newly added device
      coresight: remove the unnecessary replicator property
      coresight: fix the replicator subtype value
      pdfdocs: Fix 'make pdfdocs' failure for 'uio-howto.tmpl'
      mcb: Fix error path of mcb_pci_probe
      virtio/console: verify device has config space
      ti-st: clean up data types (fix harmless memory corruption)
      mei: me: release hw from reset only during the reset flow
      mei: mask interrupt set bit on clean reset bit
      extcon: max77693: Constify struct regmap_config
      extcon: adc-jack: Release IIO channel on driver remove
      extcon: Remove duplicated include from extcon-class.c
      Drivers: hv: vmbus: hv_process_timer_expiration() can be static
      Drivers: hv: vmbus: serialize Offer and Rescind offer
      ...

commit 79af73079d753b2d04e46f7445716d3b5f914dbd
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Wed Jan 21 10:54:10 2015 -0500

    Add security hooks to binder and implement the hooks for SELinux.
    
    Add security hooks to the binder and implement the hooks for SELinux.
    The security hooks enable security modules such as SELinux to implement
    controls over binder IPC.  The security hooks include support for
    controlling what process can become the binder context manager
    (binder_set_context_mgr), controlling the ability of a process
    to invoke a binder transaction/IPC to another process (binder_transaction),
    controlling the ability of a process to transfer a binder reference to
    another process (binder_transfer_binder), and controlling the ability
    of a process to transfer an open file to another process (binder_transfer_file).
    
    These hooks have been included in the Android kernel trees since Android 4.3.
    
    (Updated to reflect upstream relocation and changes to the binder driver,
    changes to the LSM audit data structures, coding style cleanups, and
    to add inline documentation for the hooks).
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Nick Kralevich <nnk@google.com>
    Acked-by: Jeffrey Vander Stoep <jeffv@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/security.c b/security/security.c
index 18b35c63fc0c..b196de34b19f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -135,6 +135,29 @@ int __init register_security(struct security_operations *ops)
 
 /* Security operations */
 
+int security_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return security_ops->binder_set_context_mgr(mgr);
+}
+
+int security_binder_transaction(struct task_struct *from,
+				struct task_struct *to)
+{
+	return security_ops->binder_transaction(from, to);
+}
+
+int security_binder_transfer_binder(struct task_struct *from,
+				    struct task_struct *to)
+{
+	return security_ops->binder_transfer_binder(from, to);
+}
+
+int security_binder_transfer_file(struct task_struct *from,
+				  struct task_struct *to, struct file *file)
+{
+	return security_ops->binder_transfer_file(from, to, file);
+}
+
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
 #ifdef CONFIG_SECURITY_YAMA_STACKED

commit b4caecd48005fbed3949dde6c1cb233142fd69e9
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 14 10:42:32 2015 +0100

    fs: introduce f_op->mmap_capabilities for nommu mmap support
    
    Since "BDI: Provide backing device capability information [try #3]" the
    backing_dev_info structure also provides flags for the kind of mmap
    operation available in a nommu environment, which is entirely unrelated
    to it's original purpose.
    
    Introduce a new nommu-only file operation to provide this information to
    the nommu mmap code instead.  Splitting this from the backing_dev_info
    structure allows to remove lots of backing_dev_info instance that aren't
    otherwise needed, and entirely gets rid of the concept of providing a
    backing_dev_info for a character device.  It also removes the need for
    the mtd_inodefs filesystem.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/security/security.c b/security/security.c
index 18b35c63fc0c..a0442b20f001 100644
--- a/security/security.c
+++ b/security/security.c
@@ -726,16 +726,15 @@ static inline unsigned long mmap_prot(struct file *file, unsigned long prot)
 		return prot | PROT_EXEC;
 	/*
 	 * ditto if it's not on noexec mount, except that on !MMU we need
-	 * BDI_CAP_EXEC_MMAP (== VM_MAYEXEC) in this case
+	 * NOMMU_MAP_EXEC (== VM_MAYEXEC) in this case
 	 */
 	if (!(file->f_path.mnt->mnt_flags & MNT_NOEXEC)) {
 #ifndef CONFIG_MMU
-		unsigned long caps = 0;
-		struct address_space *mapping = file->f_mapping;
-		if (mapping && mapping->backing_dev_info)
-			caps = mapping->backing_dev_info->capabilities;
-		if (!(caps & BDI_CAP_EXEC_MAP))
-			return prot;
+		if (file->f_op->mmap_capabilities) {
+			unsigned caps = file->f_op->mmap_capabilities(file);
+			if (!(caps & NOMMU_MAP_EXEC))
+				return prot;
+		}
 #endif
 		return prot | PROT_EXEC;
 	}

commit e0b93eddfe17dcb7d644eb5d6ad02a86fc41a977
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Aug 22 11:27:32 2014 -0400

    security: make security_file_set_fowner, f_setown and __f_setown void return
    
    security_file_set_fowner always returns 0, so make it f_setown and
    __f_setown void return functions and fix up the error handling in the
    callers.
    
    Cc: linux-security-module@vger.kernel.org
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/security/security.c b/security/security.c
index e41b1a8d7644..18b35c63fc0c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -775,9 +775,9 @@ int security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
 	return security_ops->file_fcntl(file, cmd, arg);
 }
 
-int security_file_set_fowner(struct file *file)
+void security_file_set_fowner(struct file *file)
 {
-	return security_ops->file_set_fowner(file);
+	security_ops->file_set_fowner(file);
 }
 
 int security_file_send_sigiotask(struct task_struct *tsk,

commit 5a9196d715607f76d6b7d96a0970d6065335e62b
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Jul 22 10:39:48 2014 -0400

    ima: add support for measuring and appraising firmware
    
    The "security: introduce kernel_fw_from_file hook" patch defined a
    new security hook to evaluate any loaded firmware that wasn't built
    into the kernel.
    
    This patch defines ima_fw_from_file(), which is called from the new
    security hook, to measure and/or appraise the loaded firmware's
    integrity.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/security.c b/security/security.c
index 35d37d0f0d49..e41b1a8d7644 100644
--- a/security/security.c
+++ b/security/security.c
@@ -847,7 +847,12 @@ int security_kernel_create_files_as(struct cred *new, struct inode *inode)
 
 int security_kernel_fw_from_file(struct file *file, char *buf, size_t size)
 {
-	return security_ops->kernel_fw_from_file(file, buf, size);
+	int ret;
+
+	ret = security_ops->kernel_fw_from_file(file, buf, size);
+	if (ret)
+		return ret;
+	return ima_fw_from_file(file, buf, size);
 }
 EXPORT_SYMBOL_GPL(security_kernel_fw_from_file);
 

commit 13752fe2d7f2d41c2fd92a5d1b1c6e38c4de0c05
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Feb 25 10:28:04 2014 -0800

    security: introduce kernel_fw_from_file hook
    
    In order to validate the contents of firmware being loaded, there must be
    a hook to evaluate any loaded firmware that wasn't built into the kernel
    itself. Without this, there is a risk that a root user could load malicious
    firmware designed to mount an attack against kernel memory (e.g. via DMA).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>

diff --git a/security/security.c b/security/security.c
index 31614e9e96e5..35d37d0f0d49 100644
--- a/security/security.c
+++ b/security/security.c
@@ -845,6 +845,12 @@ int security_kernel_create_files_as(struct cred *new, struct inode *inode)
 	return security_ops->kernel_create_files_as(new, inode);
 }
 
+int security_kernel_fw_from_file(struct file *file, char *buf, size_t size)
+{
+	return security_ops->kernel_fw_from_file(file, buf, size);
+}
+EXPORT_SYMBOL_GPL(security_kernel_fw_from_file);
+
 int security_kernel_module_request(char *kmod_name)
 {
 	return security_ops->kernel_module_request(kmod_name);

commit f01387d2693813eb5271a3448e6a082322c7d75d
Merge: 92953ff38ba5 1860e379875d
Author: James Morris <james.l.morris@oracle.com>
Date:   Tue Jun 24 18:46:07 2014 +1000

    Merge commit 'v3.15' into next

commit b13cebe70775e67323e1c2eff20e1cd174e430a4
Merge: ecd740c6f2f0 fffea214abf6
Author: James Morris <james.l.morris@oracle.com>
Date:   Mon Apr 14 11:42:49 2014 +1000

    Merge tag 'keys-20140314' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs into next

commit da1ce0670c14d8380e423a3239e562a1dc15fa9e
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 1 17:08:43 2014 +0200

    vfs: add cross-rename
    
    If flags contain RENAME_EXCHANGE then exchange source and destination files.
    There's no restriction on the type of the files; e.g. a directory can be
    exchanged with a symlink.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/security/security.c b/security/security.c
index 284fbc99aa9d..8b774f362a3d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -439,6 +439,14 @@ int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
 	if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
 		     (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))
 		return 0;
+
+	if (flags & RENAME_EXCHANGE) {
+		int err = security_ops->path_rename(new_dir, new_dentry,
+						    old_dir, old_dentry);
+		if (err)
+			return err;
+	}
+
 	return security_ops->path_rename(old_dir, old_dentry, new_dir,
 					 new_dentry);
 }
@@ -531,6 +539,14 @@ int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
         if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
             (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))
 		return 0;
+
+	if (flags & RENAME_EXCHANGE) {
+		int err = security_ops->inode_rename(new_dir, new_dentry,
+						     old_dir, old_dentry);
+		if (err)
+			return err;
+	}
+
 	return security_ops->inode_rename(old_dir, old_dentry,
 					   new_dir, new_dentry);
 }

commit 0b3974eb04c4874e85fa1d4fc70450d12f28611d
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 1 17:08:43 2014 +0200

    security: add flags to rename hooks
    
    Add flags to security_path_rename() and security_inode_rename() hooks.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/security/security.c b/security/security.c
index 919cad93ac82..284fbc99aa9d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -433,7 +433,8 @@ int security_path_link(struct dentry *old_dentry, struct path *new_dir,
 }
 
 int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
-			 struct path *new_dir, struct dentry *new_dentry)
+			 struct path *new_dir, struct dentry *new_dentry,
+			 unsigned int flags)
 {
 	if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
 		     (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))
@@ -524,7 +525,8 @@ int security_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
 }
 
 int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
-			   struct inode *new_dir, struct dentry *new_dentry)
+			   struct inode *new_dir, struct dentry *new_dentry,
+			   unsigned int flags)
 {
         if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
             (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))

commit f5895943d91b41b0368830cdb6eaffb8eda0f4c8
Author: David Howells <dhowells@redhat.com>
Date:   Fri Mar 14 17:44:49 2014 +0000

    KEYS: Move the flags representing required permission to linux/key.h
    
    Move the flags representing required permission to linux/key.h as the perm
    parameter of security_key_permission() is in terms of them - and not the
    permissions mask flags used in key->perm.
    
    Whilst we're at it:
    
     (1) Rename them to be KEY_NEED_xxx rather than KEY_xxx to avoid collisions
         with symbols in uapi/linux/input.h.
    
     (2) Don't use key_perm_t for a mask of required permissions, but rather limit
         it to the permissions mask attached to the key and arguments related
         directly to that.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Dmitry Kasatkin <d.kasatkin@samsung.com>

diff --git a/security/security.c b/security/security.c
index 15b6928592ef..8e428ac90233 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1405,7 +1405,7 @@ void security_key_free(struct key *key)
 }
 
 int security_key_permission(key_ref_t key_ref,
-			    const struct cred *cred, key_perm_t perm)
+			    const struct cred *cred, unsigned perm)
 {
 	return security_ops->key_permission(key_ref, cred, perm);
 }

commit 52a4c6404f91f2d2c5592ee6365a8418c4565f53
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Fri Mar 7 12:44:19 2014 +0100

    selinux: add gfp argument to security_xfrm_policy_alloc and fix callers
    
    security_xfrm_policy_alloc can be called in atomic context so the
    allocation should be done with GFP_ATOMIC. Add an argument to let the
    callers choose the appropriate way. In order to do so a gfp argument
    needs to be added to the method xfrm_policy_alloc_security in struct
    security_operations and to the internal function
    selinux_xfrm_alloc_user. After that switch to GFP_ATOMIC in the atomic
    callers and leave GFP_KERNEL as before for the rest.
    The path that needed the gfp argument addition is:
    security_xfrm_policy_alloc -> security_ops.xfrm_policy_alloc_security ->
    all users of xfrm_policy_alloc_security (e.g. selinux_xfrm_policy_alloc) ->
    selinux_xfrm_alloc_user (here the allocation used to be GFP_KERNEL only)
    
    Now adding a gfp argument to selinux_xfrm_alloc_user requires us to also
    add it to security_context_to_sid which is used inside and prior to this
    patch did only GFP_KERNEL allocation. So add gfp argument to
    security_context_to_sid and adjust all of its callers as well.
    
    CC: Paul Moore <paul@paul-moore.com>
    CC: Dave Jones <davej@redhat.com>
    CC: Steffen Klassert <steffen.klassert@secunet.com>
    CC: Fan Du <fan.du@windriver.com>
    CC: David S. Miller <davem@davemloft.net>
    CC: LSM list <linux-security-module@vger.kernel.org>
    CC: SELinux list <selinux@tycho.nsa.gov>
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/security/security.c b/security/security.c
index 15b6928592ef..919cad93ac82 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1317,9 +1317,11 @@ void security_skb_owned_by(struct sk_buff *skb, struct sock *sk)
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 
-int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx)
+int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,
+			       struct xfrm_user_sec_ctx *sec_ctx,
+			       gfp_t gfp)
 {
-	return security_ops->xfrm_policy_alloc_security(ctxp, sec_ctx);
+	return security_ops->xfrm_policy_alloc_security(ctxp, sec_ctx, gfp);
 }
 EXPORT_SYMBOL(security_xfrm_policy_alloc);
 

commit 6f799c97f37fc0ee2c9c427fa0dada637394886c
Merge: eb8948a03704 42d64e1add3a
Author: James Morris <james.l.morris@oracle.com>
Date:   Tue Oct 22 22:26:41 2013 +1100

    Merge branch 'master' of git://git.infradead.org/users/pcmoore/selinux into ra-next

commit 98f700f317967d45cf60c9843b3c42ce3c286f7c
Merge: 6e4664525b1d 0b4bdb3573a8
Author: Paul Moore <pmoore@redhat.com>
Date:   Wed Sep 18 13:52:20 2013 -0400

    Merge git://git.infradead.org/users/eparis/selinux
    
    Conflicts:
            security/selinux/hooks.c
    
    Pull Eric's existing SELinux tree as there are a number of patches in
    there that are not yet upstream.  There was some minor fixup needed to
    resolve a conflict in security/selinux/hooks.c:selinux_set_mnt_opts()
    between the labeled NFS patches and Eric's security_fs_use()
    simplification patch.

commit 2e5aa86609ec1cf37bcc204fd7ba6c24c2f49fec
Author: Paul Moore <pmoore@redhat.com>
Date:   Tue Jul 23 17:38:38 2013 -0400

    lsm: split the xfrm_state_alloc_security() hook implementation
    
    The xfrm_state_alloc_security() LSM hook implementation is really a
    multiplexed hook with two different behaviors depending on the
    arguments passed to it by the caller.  This patch splits the LSM hook
    implementation into two new hook implementations, which match the
    LSM hooks in the rest of the kernel:
    
     * xfrm_state_alloc
     * xfrm_state_alloc_acquire
    
    Also included in this patch are the necessary changes to the SELinux
    code; no other LSMs are affected.
    
    Signed-off-by: Paul Moore <pmoore@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/security.c b/security/security.c
index a3dce87d1aef..57e25c962968 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1322,22 +1322,17 @@ int security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)
 	return security_ops->xfrm_policy_delete_security(ctx);
 }
 
-int security_xfrm_state_alloc(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx)
+int security_xfrm_state_alloc(struct xfrm_state *x,
+			      struct xfrm_user_sec_ctx *sec_ctx)
 {
-	return security_ops->xfrm_state_alloc_security(x, sec_ctx, 0);
+	return security_ops->xfrm_state_alloc(x, sec_ctx);
 }
 EXPORT_SYMBOL(security_xfrm_state_alloc);
 
 int security_xfrm_state_alloc_acquire(struct xfrm_state *x,
 				      struct xfrm_sec_ctx *polsec, u32 secid)
 {
-	if (!polsec)
-		return 0;
-	/*
-	 * We want the context to be taken from secid which is usually
-	 * from the sock.
-	 */
-	return security_ops->xfrm_state_alloc_security(x, NULL, secid);
+	return security_ops->xfrm_state_alloc_acquire(x, polsec, secid);
 }
 
 int security_xfrm_state_delete(struct xfrm_state *x)

commit 9548906b2bb7ff09e12c013a55d669bef2c8e121
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Thu Jul 25 05:44:02 2013 +0900

    xattr: Constify ->name member of "struct xattr".
    
    Since everybody sets kstrdup()ed constant string to "struct xattr"->name but
    nobody modifies "struct xattr"->name , we can omit kstrdup() and its failure
    checking by constifying ->name member of "struct xattr".
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Joel Becker <jlbec@evilplan.org> [ocfs2]
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Reviewed-by: Paul Moore <paul@paul-moore.com>
    Tested-by: Paul Moore <paul@paul-moore.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 94b35aef6871..4dc31f4f2700 100644
--- a/security/security.c
+++ b/security/security.c
@@ -348,10 +348,10 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
 
-	memset(new_xattrs, 0, sizeof new_xattrs);
 	if (!initxattrs)
 		return security_ops->inode_init_security(inode, dir, qstr,
 							 NULL, NULL, NULL);
+	memset(new_xattrs, 0, sizeof(new_xattrs));
 	lsm_xattr = new_xattrs;
 	ret = security_ops->inode_init_security(inode, dir, qstr,
 						&lsm_xattr->name,
@@ -366,16 +366,14 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 		goto out;
 	ret = initxattrs(inode, new_xattrs, fs_data);
 out:
-	for (xattr = new_xattrs; xattr->name != NULL; xattr++) {
-		kfree(xattr->name);
+	for (xattr = new_xattrs; xattr->value != NULL; xattr++)
 		kfree(xattr->value);
-	}
 	return (ret == -EOPNOTSUPP) ? 0 : ret;
 }
 EXPORT_SYMBOL(security_inode_init_security);
 
 int security_old_inode_init_security(struct inode *inode, struct inode *dir,
-				     const struct qstr *qstr, char **name,
+				     const struct qstr *qstr, const char **name,
 				     void **value, size_t *len)
 {
 	if (unlikely(IS_PRIVATE(inode)))

commit c9bccef6b98ae563f725f6e315d8adc685239781
Author: David Quigley <dpquigl@davequigley.com>
Date:   Wed May 22 12:50:45 2013 -0400

    NFS: Extend NFS xattr handlers to accept the security namespace
    
    The existing NFSv4 xattr handlers do not accept xattr calls to the security
    namespace. This patch extends these handlers to accept xattrs from the security
    namespace in addition to the default NFSv4 ACL namespace.
    
    Acked-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Matthew N. Dodd <Matthew.Dodd@sparta.com>
    Signed-off-by: Miguel Rodel Felipe <Rodel_FM@dsi.a-star.edu.sg>
    Signed-off-by: Phua Eu Gene <PHUA_Eu_Gene@dsi.a-star.edu.sg>
    Signed-off-by: Khin Mi Mi Aung <Mi_Mi_AUNG@dsi.a-star.edu.sg>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/security/security.c b/security/security.c
index 8d0b9a79611a..94b35aef6871 100644
--- a/security/security.c
+++ b/security/security.c
@@ -660,6 +660,7 @@ int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer
 		return 0;
 	return security_ops->inode_listsecurity(inode, buffer, buffer_size);
 }
+EXPORT_SYMBOL(security_inode_listsecurity);
 
 void security_inode_getsecid(const struct inode *inode, u32 *secid)
 {

commit 649f6e7718891fe7691e5084ce3fa623acba3129
Author: David Quigley <dpquigl@davequigley.com>
Date:   Wed May 22 12:50:36 2013 -0400

    LSM: Add flags field to security_sb_set_mnt_opts for in kernel mount data.
    
    There is no way to differentiate if a text mount option is passed from user
    space or the kernel. A flags field is being added to the
    security_sb_set_mnt_opts hook to allow for in kernel security flags to be sent
    to the LSM for processing in addition to the text options received from mount.
    This patch also updated existing code to fix compilation errors.
    
    Acked-by: Eric Paris <eparis@redhat.com>
    Acked-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: David P. Quigley <dpquigl@tycho.nsa.gov>
    Signed-off-by: Miguel Rodel Felipe <Rodel_FM@dsi.a-star.edu.sg>
    Signed-off-by: Phua Eu Gene <PHUA_Eu_Gene@dsi.a-star.edu.sg>
    Signed-off-by: Khin Mi Mi Aung <Mi_Mi_AUNG@dsi.a-star.edu.sg>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/security/security.c b/security/security.c
index c3ceb754e705..8d0b9a79611a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -294,9 +294,12 @@ int security_sb_pivotroot(struct path *old_path, struct path *new_path)
 }
 
 int security_sb_set_mnt_opts(struct super_block *sb,
-				struct security_mnt_opts *opts)
+				struct security_mnt_opts *opts,
+				unsigned long kern_flags,
+				unsigned long *set_kern_flags)
 {
-	return security_ops->sb_set_mnt_opts(sb, opts);
+	return security_ops->sb_set_mnt_opts(sb, opts, kern_flags,
+						set_kern_flags);
 }
 EXPORT_SYMBOL(security_sb_set_mnt_opts);
 

commit 746df9b59c8a5f162c907796c7295d3c4c0d8995
Author: David Quigley <dpquigl@davequigley.com>
Date:   Wed May 22 12:50:35 2013 -0400

    Security: Add Hook to test if the particular xattr is part of a MAC model.
    
    The interface to request security labels from user space is the xattr
    interface. When requesting the security label from an NFS server it is
    important to make sure the requested xattr actually is a MAC label. This allows
    us to make sure that we get the desired semantics from the attribute instead of
    something else such as capabilities or a time based LSM.
    
    Acked-by: Eric Paris <eparis@redhat.com>
    Acked-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Matthew N. Dodd <Matthew.Dodd@sparta.com>
    Signed-off-by: Miguel Rodel Felipe <Rodel_FM@dsi.a-star.edu.sg>
    Signed-off-by: Phua Eu Gene <PHUA_Eu_Gene@dsi.a-star.edu.sg>
    Signed-off-by: Khin Mi Mi Aung <Mi_Mi_AUNG@dsi.a-star.edu.sg>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/security/security.c b/security/security.c
index 0fe2b2ee9545..c3ceb754e705 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1057,6 +1057,12 @@ int security_netlink_send(struct sock *sk, struct sk_buff *skb)
 	return security_ops->netlink_send(sk, skb);
 }
 
+int security_ismaclabel(const char *name)
+{
+	return security_ops->ismaclabel(name);
+}
+EXPORT_SYMBOL(security_ismaclabel);
+
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 {
 	return security_ops->secid_to_secctx(secid, secdata, seclen);

commit d47be3dfecaf20255af89a57460285c82d5271ad
Author: David Quigley <dpquigl@davequigley.com>
Date:   Wed May 22 12:50:34 2013 -0400

    Security: Add hook to calculate context based on a negative dentry.
    
    There is a time where we need to calculate a context without the
    inode having been created yet. To do this we take the negative dentry and
    calculate a context based on the process and the parent directory contexts.
    
    Acked-by: Eric Paris <eparis@redhat.com>
    Acked-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Matthew N. Dodd <Matthew.Dodd@sparta.com>
    Signed-off-by: Miguel Rodel Felipe <Rodel_FM@dsi.a-star.edu.sg>
    Signed-off-by: Phua Eu Gene <PHUA_Eu_Gene@dsi.a-star.edu.sg>
    Signed-off-by: Khin Mi Mi Aung <Mi_Mi_AUNG@dsi.a-star.edu.sg>
    Signed-off-by: Steve Dickson <steved@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/security/security.c b/security/security.c
index a3dce87d1aef..0fe2b2ee9545 100644
--- a/security/security.c
+++ b/security/security.c
@@ -12,6 +12,7 @@
  */
 
 #include <linux/capability.h>
+#include <linux/dcache.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -324,6 +325,15 @@ void security_inode_free(struct inode *inode)
 	security_ops->inode_free_security(inode);
 }
 
+int security_dentry_init_security(struct dentry *dentry, int mode,
+					struct qstr *name, void **ctx,
+					u32 *ctxlen)
+{
+	return security_ops->dentry_init_security(dentry, mode, name,
+							ctx, ctxlen);
+}
+EXPORT_SYMBOL(security_dentry_init_security);
+
 int security_inode_init_security(struct inode *inode, struct inode *dir,
 				 const struct qstr *qstr,
 				 const initxattrs initxattrs, void *fs_data)

commit 2e1deaad1e48453cea782854ab87df3f78c121c2
Merge: 50528fabeb25 b7ae9f064bec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 30 16:27:51 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem update from James Morris:
     "Just some minor updates across the subsystem"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      ima: eliminate passing d_name.name to process_measurement()
      TPM: Retry SaveState command in suspend path
      tpm/tpm_i2c_infineon: Add small comment about return value of __i2c_transfer
      tpm/tpm_i2c_infineon.c: Add OF attributes type and name to the of_device_id table entries
      tpm_i2c_stm_st33: Remove duplicate inclusion of header files
      tpm: Add support for new Infineon I2C TPM (SLB 9645 TT 1.2 I2C)
      char/tpm: Convert struct i2c_msg initialization to C99 format
      drivers/char/tpm/tpm_ppi: use strlcpy instead of strncpy
      tpm/tpm_i2c_stm_st33: formatting and white space changes
      Smack: include magic.h in smackfs.c
      selinux: make security_sb_clone_mnt_opts return an error on context mismatch
      seccomp: allow BPF_XOR based ALU instructions.
      Fix NULL pointer dereference in smack_inode_unlink() and smack_inode_rmdir()
      Smack: add support for modification of existing rules
      smack: SMACK_MAGIC to include/uapi/linux/magic.h
      Smack: add missing support for transmute bit in smack_str_from_perm()
      Smack: prevent revoke-subject from failing when unseen label is written to it
      tomoyo: use DEFINE_SRCU() to define tomoyo_ss
      tomoyo: use DEFINE_SRCU() to define tomoyo_ss

commit ca10b9e9a8ca7342ee07065289cbe74ac128c169
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Apr 8 17:58:11 2013 +0000

    selinux: add a skb_owned_by() hook
    
    Commit 90ba9b1986b5ac (tcp: tcp_make_synack() can use alloc_skb())
    broke certain SELinux/NetLabel configurations by no longer correctly
    assigning the sock to the outgoing SYNACK packet.
    
    Cost of atomic operations on the LISTEN socket is quite big,
    and we would like it to happen only if really needed.
    
    This patch introduces a new security_ops->skb_owned_by() method,
    that is a void operation unless selinux is active.
    
    Reported-by: Miroslav Vadkerti <mvadkert@redhat.com>
    Diagnosed-by: Paul Moore <pmoore@redhat.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: linux-security-module@vger.kernel.org
    Acked-by: James Morris <james.l.morris@oracle.com>
    Tested-by: Paul Moore <pmoore@redhat.com>
    Acked-by: Paul Moore <pmoore@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index 7b88c6aeaed4..03f248b84e9f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1290,6 +1290,11 @@ int security_tun_dev_open(void *security)
 }
 EXPORT_SYMBOL(security_tun_dev_open);
 
+void security_skb_owned_by(struct sk_buff *skb, struct sock *sk)
+{
+	security_ops->skb_owned_by(skb, sk);
+}
+
 #endif	/* CONFIG_SECURITY_NETWORK */
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM

commit 094f7b69ea738d7d619cba449d2af97159949459
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Apr 1 08:14:24 2013 -0400

    selinux: make security_sb_clone_mnt_opts return an error on context mismatch
    
    I had the following problem reported a while back. If you mount the
    same filesystem twice using NFSv4 with different contexts, then the
    second context= option is ignored. For instance:
    
        # mount server:/export /mnt/test1
        # mount server:/export /mnt/test2 -o context=system_u:object_r:tmp_t:s0
        # ls -dZ /mnt/test1
        drwxrwxrwt. root root system_u:object_r:nfs_t:s0       /mnt/test1
        # ls -dZ /mnt/test2
        drwxrwxrwt. root root system_u:object_r:nfs_t:s0       /mnt/test2
    
    When we call into SELinux to set the context of a "cloned" superblock,
    it will currently just bail out when it notices that we're reusing an
    existing superblock. Since the existing superblock is already set up and
    presumably in use, we can't go overwriting its context with the one from
    the "original" sb. Because of this, the second context= option in this
    case cannot take effect.
    
    This patch fixes this by turning security_sb_clone_mnt_opts into an int
    return operation. When it finds that the "new" superblock that it has
    been handed is already set up, it checks to see whether the contexts on
    the old superblock match it. If it does, then it will just return
    success, otherwise it'll return -EBUSY and emit a printk to tell the
    admin why the second mount failed.
    
    Note that this patch may cause casualties. The NFSv4 code relies on
    being able to walk down to an export from the pseudoroot. If you mount
    filesystems that are nested within one another with different contexts,
    then this patch will make those mounts fail in new and "exciting" ways.
    
    For instance, suppose that /export is a separate filesystem on the
    server:
    
        # mount server:/ /mnt/test1
        # mount salusa:/export /mnt/test2 -o context=system_u:object_r:tmp_t:s0
        mount.nfs: an incorrect mount option was specified
    
    ...with the printk in the ring buffer. Because we *might* eventually
    walk down to /mnt/test1/export, the mount is denied due to this patch.
    The second mount needs the pseudoroot superblock, but that's already
    present with the wrong context.
    
    OTOH, if we mount these in the reverse order, then both mounts work,
    because the pseudoroot superblock created when mounting /export is
    discarded once that mount is done. If we then however try to walk into
    that directory, the automount fails for the similar reasons:
    
        # cd /mnt/test1/scratch/
        -bash: cd: /mnt/test1/scratch: Device or resource busy
    
    The story I've gotten from the SELinux folks that I've talked to is that
    this is desirable behavior. In SELinux-land, mounting the same data
    under different contexts is wrong -- there can be only one.
    
    Cc: Steve Dickson <steved@redhat.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 7b88c6aeaed4..108281d2307a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -299,10 +299,10 @@ int security_sb_set_mnt_opts(struct super_block *sb,
 }
 EXPORT_SYMBOL(security_sb_set_mnt_opts);
 
-void security_sb_clone_mnt_opts(const struct super_block *oldsb,
+int security_sb_clone_mnt_opts(const struct super_block *oldsb,
 				struct super_block *newsb)
 {
-	security_ops->sb_clone_mnt_opts(oldsb, newsb);
+	return security_ops->sb_clone_mnt_opts(oldsb, newsb);
 }
 EXPORT_SYMBOL(security_sb_clone_mnt_opts);
 

commit 5dbbaf2de89613d19a9286d4db0a535ca2735d26
Author: Paul Moore <pmoore@redhat.com>
Date:   Mon Jan 14 07:12:19 2013 +0000

    tun: fix LSM/SELinux labeling of tun/tap devices
    
    This patch corrects some problems with LSM/SELinux that were introduced
    with the multiqueue patchset.  The problem stems from the fact that the
    multiqueue work changed the relationship between the tun device and its
    associated socket; before the socket persisted for the life of the
    device, however after the multiqueue changes the socket only persisted
    for the life of the userspace connection (fd open).  For non-persistent
    devices this is not an issue, but for persistent devices this can cause
    the tun device to lose its SELinux label.
    
    We correct this problem by adding an opaque LSM security blob to the
    tun device struct which allows us to have the LSM security state, e.g.
    SELinux labeling information, persist for the lifetime of the tun
    device.  In the process we tweak the LSM hooks to work with this new
    approach to TUN device/socket labeling and introduce a new LSM hook,
    security_tun_dev_attach_queue(), to approve requests to attach to a
    TUN queue via TUNSETQUEUE.
    
    The SELinux code has been adjusted to match the new LSM hooks, the
    other LSMs do not make use of the LSM TUN controls.  This patch makes
    use of the recently added "tun_socket:attach_queue" permission to
    restrict access to the TUNSETQUEUE operation.  On older SELinux
    policies which do not define the "tun_socket:attach_queue" permission
    the access control decision for TUNSETQUEUE will be handled according
    to the SELinux policy's unknown permission setting.
    
    Signed-off-by: Paul Moore <pmoore@redhat.com>
    Acked-by: Eric Paris <eparis@parisplace.org>
    Tested-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index daa97f4ac9d1..7b88c6aeaed4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1254,24 +1254,42 @@ void security_secmark_refcount_dec(void)
 }
 EXPORT_SYMBOL(security_secmark_refcount_dec);
 
+int security_tun_dev_alloc_security(void **security)
+{
+	return security_ops->tun_dev_alloc_security(security);
+}
+EXPORT_SYMBOL(security_tun_dev_alloc_security);
+
+void security_tun_dev_free_security(void *security)
+{
+	security_ops->tun_dev_free_security(security);
+}
+EXPORT_SYMBOL(security_tun_dev_free_security);
+
 int security_tun_dev_create(void)
 {
 	return security_ops->tun_dev_create();
 }
 EXPORT_SYMBOL(security_tun_dev_create);
 
-void security_tun_dev_post_create(struct sock *sk)
+int security_tun_dev_attach_queue(void *security)
 {
-	return security_ops->tun_dev_post_create(sk);
+	return security_ops->tun_dev_attach_queue(security);
 }
-EXPORT_SYMBOL(security_tun_dev_post_create);
+EXPORT_SYMBOL(security_tun_dev_attach_queue);
 
-int security_tun_dev_attach(struct sock *sk)
+int security_tun_dev_attach(struct sock *sk, void *security)
 {
-	return security_ops->tun_dev_attach(sk);
+	return security_ops->tun_dev_attach(sk, security);
 }
 EXPORT_SYMBOL(security_tun_dev_attach);
 
+int security_tun_dev_open(void *security)
+{
+	return security_ops->tun_dev_open(security);
+}
+EXPORT_SYMBOL(security_tun_dev_open);
+
 #endif	/* CONFIG_SECURITY_NETWORK */
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM

commit fdf90729e57812cb12d7938e2dee7c71e875fb08
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Oct 16 12:40:08 2012 +1030

    ima: support new kernel module syscall
    
    With the addition of the new kernel module syscall, which defines two
    arguments - a file descriptor to the kernel module and a pointer to a NULL
    terminated string of module arguments - it is now possible to measure and
    appraise kernel modules like any other file on the file system.
    
    This patch adds support to measure and appraise kernel modules in an
    extensible and consistent manner.
    
    To support filesystems without extended attribute support, additional
    patches could pass the signature as the first parameter.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/security/security.c b/security/security.c
index ce88630de15d..daa97f4ac9d1 100644
--- a/security/security.c
+++ b/security/security.c
@@ -822,7 +822,12 @@ int security_kernel_module_request(char *kmod_name)
 
 int security_kernel_module_from_file(struct file *file)
 {
-	return security_ops->kernel_module_from_file(file);
+	int ret;
+
+	ret = security_ops->kernel_module_from_file(file);
+	if (ret)
+		return ret;
+	return ima_module_check(file);
 }
 
 int security_task_fix_setuid(struct cred *new, const struct cred *old,

commit 2e72d51b4ac32989496870cd8171b3682fea1839
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 16 07:32:07 2012 +1030

    security: introduce kernel_module_from_file hook
    
    Now that kernel module origins can be reasoned about, provide a hook to
    the LSMs to make policy decisions about the module file. This will let
    Chrome OS enforce that loadable kernel modules can only come from its
    read-only hash-verified root filesystem. Other LSMs can, for example,
    read extended attributes for signatures, etc.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    Acked-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/security/security.c b/security/security.c
index 8dcd4ae10a5f..ce88630de15d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -820,6 +820,11 @@ int security_kernel_module_request(char *kmod_name)
 	return security_ops->kernel_module_request(kmod_name);
 }
 
+int security_kernel_module_from_file(struct file *file)
+{
+	return security_ops->kernel_module_from_file(file);
+}
+
 int security_task_fix_setuid(struct cred *new, const struct cred *old,
 			     int flags)
 {

commit 808d4e3cfdcc52b19276175464f6dbca4df13b09
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 11 11:42:01 2012 -0400

    consitify do_mount() arguments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 3724029d0f6d..8dcd4ae10a5f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -276,8 +276,8 @@ int security_sb_statfs(struct dentry *dentry)
 	return security_ops->sb_statfs(dentry);
 }
 
-int security_sb_mount(char *dev_name, struct path *path,
-                       char *type, unsigned long flags, void *data)
+int security_sb_mount(const char *dev_name, struct path *path,
+                       const char *type, unsigned long flags, void *data)
 {
 	return security_ops->sb_mount(dev_name, path, type, flags, data);
 }

commit 88265322c14cce39f7afbc416726ef4fac413298
Merge: 65b99c74fdd3 bf5308344527
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 21:38:48 2012 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Highlights:
    
       - Integrity: add local fs integrity verification to detect offline
         attacks
       - Integrity: add digital signature verification
       - Simple stacking of Yama with other LSMs (per LSS discussions)
       - IBM vTPM support on ppc64
       - Add new driver for Infineon I2C TIS TPM
       - Smack: add rule revocation for subject labels"
    
    Fixed conflicts with the user namespace support in kernel/auditsc.c and
    security/integrity/ima/ima_policy.c.
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (39 commits)
      Documentation: Update git repository URL for Smack userland tools
      ima: change flags container data type
      Smack: setprocattr memory leak fix
      Smack: implement revoking all rules for a subject label
      Smack: remove task_wait() hook.
      ima: audit log hashes
      ima: generic IMA action flag handling
      ima: rename ima_must_appraise_or_measure
      audit: export audit_log_task_info
      tpm: fix tpm_acpi sparse warning on different address spaces
      samples/seccomp: fix 31 bit build on s390
      ima: digital signature verification support
      ima: add support for different security.ima data types
      ima: add ima_inode_setxattr/removexattr function and calls
      ima: add inode_post_setattr call
      ima: replace iint spinblock with rwlock/read_lock
      ima: allocating iint improvements
      ima: add appraise action keywords and default rules
      ima: integrity appraisal extension
      vfs: move ima_file_free before releasing the file
      ...

commit d2b31ca644fdc8704de3367a6a56a5c958c77f53
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Jun 1 16:14:19 2012 -0600

    userns: Teach security_path_chown to take kuids and kgids
    
    Don't make the security modules deal with raw user space uid and
    gids instead pass in a kuid_t and a kgid_t so that security modules
    only have to deal with internal kernel uids and gids.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: James Morris <james.l.morris@oracle.com>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Kentaro Takeda <takedakn@nttdata.co.jp>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/security/security.c b/security/security.c
index 860aeb349cb3..f9a2f2ef2454 100644
--- a/security/security.c
+++ b/security/security.c
@@ -434,7 +434,7 @@ int security_path_chmod(struct path *path, umode_t mode)
 	return security_ops->path_chmod(path, mode);
 }
 
-int security_path_chown(struct path *path, uid_t uid, gid_t gid)
+int security_path_chown(struct path *path, kuid_t uid, kgid_t gid)
 {
 	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
 		return 0;

commit 42c63330f2b05aa6077c1bfc2798c04afe54f6b2
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Mar 10 18:54:15 2011 -0500

    ima: add ima_inode_setxattr/removexattr function and calls
    
    Based on xattr_permission comments, the restriction to modify 'security'
    xattr is left up to the underlying fs or lsm. Ensure that not just anyone
    can modify or remove 'security.ima'.
    
    Changelog v1:
    - Unless IMA-APPRAISE is configured, use stub ima_inode_removexattr()/setxattr()
      functions.  (Moved ima_inode_removexattr()/setxattr() to ima_appraise.c)
    
    Changelog:
      - take i_mutex to fix locking (Dmitry Kasatkin)
      - ima_reset_appraise_flags should only be called when modifying or
        removing the 'security.ima' xattr. Requires CAP_SYS_ADMIN privilege.
        (Incorporated fix from Roberto Sassu)
      - Even if allowed to update security.ima, reset the appraisal flags,
        forcing re-appraisal.
      - Replace CAP_MAC_ADMIN with CAP_SYS_ADMIN
      - static inline ima_inode_setxattr()/ima_inode_removexattr() stubs
      - ima_protect_xattr should be static
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@intel.com>

diff --git a/security/security.c b/security/security.c
index 68c1b9b45d93..d23b43522a5a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -571,6 +571,9 @@ int security_inode_setxattr(struct dentry *dentry, const char *name,
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;
 	ret = security_ops->inode_setxattr(dentry, name, value, size, flags);
+	if (ret)
+		return ret;
+	ret = ima_inode_setxattr(dentry, name, value, size);
 	if (ret)
 		return ret;
 	return evm_inode_setxattr(dentry, name, value, size);
@@ -606,6 +609,9 @@ int security_inode_removexattr(struct dentry *dentry, const char *name)
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;
 	ret = security_ops->inode_removexattr(dentry, name);
+	if (ret)
+		return ret;
+	ret = ima_inode_removexattr(dentry, name);
 	if (ret)
 		return ret;
 	return evm_inode_removexattr(dentry, name);

commit c6993e4ac002c92bc75379212e9179c36d4bf7ee
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Sep 4 13:32:13 2012 -0700

    security: allow Yama to be unconditionally stacked
    
    Unconditionally call Yama when CONFIG_SECURITY_YAMA_STACKED is selected,
    no matter what LSM module is primary.
    
    Ubuntu and Chrome OS already carry patches to do this, and Fedora
    has voiced interest in doing this as well. Instead of having multiple
    distributions (or LSM authors) carrying these patches, just allow Yama
    to be called unconditionally when selected by the new CONFIG.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 860aeb349cb3..68c1b9b45d93 100644
--- a/security/security.c
+++ b/security/security.c
@@ -136,11 +136,23 @@ int __init register_security(struct security_operations *ops)
 
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
+#ifdef CONFIG_SECURITY_YAMA_STACKED
+	int rc;
+	rc = yama_ptrace_access_check(child, mode);
+	if (rc)
+		return rc;
+#endif
 	return security_ops->ptrace_access_check(child, mode);
 }
 
 int security_ptrace_traceme(struct task_struct *parent)
 {
+#ifdef CONFIG_SECURITY_YAMA_STACKED
+	int rc;
+	rc = yama_ptrace_traceme(parent);
+	if (rc)
+		return rc;
+#endif
 	return security_ops->ptrace_traceme(parent);
 }
 
@@ -761,6 +773,9 @@ int security_task_create(unsigned long clone_flags)
 
 void security_task_free(struct task_struct *task)
 {
+#ifdef CONFIG_SECURITY_YAMA_STACKED
+	yama_task_free(task);
+#endif
 	security_ops->task_free(task);
 }
 
@@ -876,6 +891,12 @@ int security_task_wait(struct task_struct *p)
 int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
 			 unsigned long arg4, unsigned long arg5)
 {
+#ifdef CONFIG_SECURITY_YAMA_STACKED
+	int rc;
+	rc = yama_task_prctl(option, arg2, arg3, arg4, arg5);
+	if (rc != -ENOSYS)
+		return rc;
+#endif
 	return security_ops->task_prctl(option, arg2, arg3, arg4, arg5);
 }
 

commit 75331a597cf4cde51d9b0bb22cbd03b9837ef9e4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jul 2 14:34:11 2012 +0900

    security: Fix nommu build.
    
    The security + nommu configuration presently blows up with an undefined
    reference to BDI_CAP_EXEC_MAP:
    
    security/security.c: In function 'mmap_prot':
    security/security.c:687:36: error: dereferencing pointer to incomplete type
    security/security.c:688:16: error: 'BDI_CAP_EXEC_MAP' undeclared (first use in this function)
    security/security.c:688:16: note: each undeclared identifier is reported only once for each function it appears in
    
    include backing-dev.h directly to fix it up.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 3efc9b12aef4..860aeb349cb3 100644
--- a/security/security.c
+++ b/security/security.c
@@ -23,6 +23,7 @@
 #include <linux/mman.h>
 #include <linux/mount.h>
 #include <linux/personality.h>
+#include <linux/backing-dev.h>
 #include <net/flow.h>
 
 #define MAX_LSM_EVM_XATTR	2

commit 659b5e76521c10331495cbd9acb7217e38ff9750
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jul 2 14:34:11 2012 +0900

    security: Fix nommu build.
    
    The security + nommu configuration presently blows up with an undefined
    reference to BDI_CAP_EXEC_MAP:
    
    security/security.c: In function 'mmap_prot':
    security/security.c:687:36: error: dereferencing pointer to incomplete type
    security/security.c:688:16: error: 'BDI_CAP_EXEC_MAP' undeclared (first use in this function)
    security/security.c:688:16: note: each undeclared identifier is reported only once for each function it appears in
    
    include backing-dev.h directly to fix it up.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/security.c b/security/security.c
index 3efc9b12aef4..860aeb349cb3 100644
--- a/security/security.c
+++ b/security/security.c
@@ -23,6 +23,7 @@
 #include <linux/mman.h>
 #include <linux/mount.h>
 #include <linux/personality.h>
+#include <linux/backing-dev.h>
 #include <net/flow.h>
 
 #define MAX_LSM_EVM_XATTR	2

commit 98de59bfe4b2ff6344d9ad8e5296f80de5dcc5b6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 30 19:58:30 2012 -0400

    take calculation of final prot in security_mmap_file() into a helper
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 3b11b3b72fe2..3efc9b12aef4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -660,36 +660,46 @@ int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	return security_ops->file_ioctl(file, cmd, arg);
 }
 
-int security_mmap_file(struct file *file, unsigned long prot,
-			unsigned long flags)
+static inline unsigned long mmap_prot(struct file *file, unsigned long prot)
 {
-	unsigned long reqprot = prot;
-	int ret;
 	/*
-	 * Does the application expect PROT_READ to imply PROT_EXEC?
-	 *
-	 * (the exception is when the underlying filesystem is noexec
-	 *  mounted, in which case we dont add PROT_EXEC.)
+	 * Does we have PROT_READ and does the application expect
+	 * it to imply PROT_EXEC?  If not, nothing to talk about...
 	 */
-	if (!(reqprot & PROT_READ))
-		goto out;
+	if ((prot & (PROT_READ | PROT_EXEC)) != PROT_READ)
+		return prot;
 	if (!(current->personality & READ_IMPLIES_EXEC))
-		goto out;
-	if (!file) {
-		prot |= PROT_EXEC;
-	} else if (!(file->f_path.mnt->mnt_flags & MNT_NOEXEC)) {
+		return prot;
+	/*
+	 * if that's an anonymous mapping, let it.
+	 */
+	if (!file)
+		return prot | PROT_EXEC;
+	/*
+	 * ditto if it's not on noexec mount, except that on !MMU we need
+	 * BDI_CAP_EXEC_MMAP (== VM_MAYEXEC) in this case
+	 */
+	if (!(file->f_path.mnt->mnt_flags & MNT_NOEXEC)) {
 #ifndef CONFIG_MMU
 		unsigned long caps = 0;
 		struct address_space *mapping = file->f_mapping;
 		if (mapping && mapping->backing_dev_info)
 			caps = mapping->backing_dev_info->capabilities;
 		if (!(caps & BDI_CAP_EXEC_MAP))
-			goto out;
+			return prot;
 #endif
-		prot |= PROT_EXEC;
+		return prot | PROT_EXEC;
 	}
-out:
-	ret = security_ops->mmap_file(file, reqprot, prot, flags);
+	/* anything on noexec mount won't get PROT_EXEC */
+	return prot;
+}
+
+int security_mmap_file(struct file *file, unsigned long prot,
+			unsigned long flags)
+{
+	int ret;
+	ret = security_ops->mmap_file(file, prot,
+					mmap_prot(file, prot), flags);
 	if (ret)
 		return ret;
 	return ima_file_mmap(file, prot);

commit 8b3ec6814c83d76b85bd13badc48552836c24839
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 30 17:11:23 2012 -0400

    take security_mmap_file() outside of ->mmap_sem
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index d91c66d3956b..3b11b3b72fe2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -20,6 +20,9 @@
 #include <linux/ima.h>
 #include <linux/evm.h>
 #include <linux/fsnotify.h>
+#include <linux/mman.h>
+#include <linux/mount.h>
+#include <linux/personality.h>
 #include <net/flow.h>
 
 #define MAX_LSM_EVM_XATTR	2
@@ -657,11 +660,35 @@ int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	return security_ops->file_ioctl(file, cmd, arg);
 }
 
-int security_mmap_file(struct file *file, unsigned long reqprot,
-			unsigned long prot, unsigned long flags)
+int security_mmap_file(struct file *file, unsigned long prot,
+			unsigned long flags)
 {
+	unsigned long reqprot = prot;
 	int ret;
-
+	/*
+	 * Does the application expect PROT_READ to imply PROT_EXEC?
+	 *
+	 * (the exception is when the underlying filesystem is noexec
+	 *  mounted, in which case we dont add PROT_EXEC.)
+	 */
+	if (!(reqprot & PROT_READ))
+		goto out;
+	if (!(current->personality & READ_IMPLIES_EXEC))
+		goto out;
+	if (!file) {
+		prot |= PROT_EXEC;
+	} else if (!(file->f_path.mnt->mnt_flags & MNT_NOEXEC)) {
+#ifndef CONFIG_MMU
+		unsigned long caps = 0;
+		struct address_space *mapping = file->f_mapping;
+		if (mapping && mapping->backing_dev_info)
+			caps = mapping->backing_dev_info->capabilities;
+		if (!(caps & BDI_CAP_EXEC_MAP))
+			goto out;
+#endif
+		prot |= PROT_EXEC;
+	}
+out:
 	ret = security_ops->mmap_file(file, reqprot, prot, flags);
 	if (ret)
 		return ret;

commit e5467859f7f79b69fc49004403009dfdba3bec53
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 30 13:30:51 2012 -0400

    split ->file_mmap() into ->mmap_addr()/->mmap_file()
    
    ... i.e. file-dependent and address-dependent checks.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 5497a57fba01..d91c66d3956b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -657,18 +657,22 @@ int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	return security_ops->file_ioctl(file, cmd, arg);
 }
 
-int security_file_mmap(struct file *file, unsigned long reqprot,
-			unsigned long prot, unsigned long flags,
-			unsigned long addr, unsigned long addr_only)
+int security_mmap_file(struct file *file, unsigned long reqprot,
+			unsigned long prot, unsigned long flags)
 {
 	int ret;
 
-	ret = security_ops->file_mmap(file, reqprot, prot, flags, addr, addr_only);
+	ret = security_ops->mmap_file(file, reqprot, prot, flags);
 	if (ret)
 		return ret;
 	return ima_file_mmap(file, prot);
 }
 
+int security_mmap_addr(unsigned long addr)
+{
+	return security_ops->mmap_addr(addr);
+}
+
 int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,
 			    unsigned long prot)
 {

commit 83d498569e9a7a4b92c4c5d3566f2d6a604f28c9
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 4 13:45:40 2012 -0400

    SELinux: rename dentry_open to file_open
    
    dentry_open takes a file, rename it to file_open
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/security.c b/security/security.c
index bf619ffc9a4d..5497a57fba01 100644
--- a/security/security.c
+++ b/security/security.c
@@ -701,11 +701,11 @@ int security_file_receive(struct file *file)
 	return security_ops->file_receive(file);
 }
 
-int security_dentry_open(struct file *file, const struct cred *cred)
+int security_file_open(struct file *file, const struct cred *cred)
 {
 	int ret;
 
-	ret = security_ops->dentry_open(file, cred);
+	ret = security_ops->file_open(file, cred);
 	if (ret)
 		return ret;
 

commit 4040153087478993cbf0809f444400a3c808074c
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Mon Feb 13 03:58:52 2012 +0000

    security: trim security.h
    
    Trim security.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 44177add4713..bf619ffc9a4d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -19,6 +19,8 @@
 #include <linux/integrity.h>
 #include <linux/ima.h>
 #include <linux/evm.h>
+#include <linux/fsnotify.h>
+#include <net/flow.h>
 
 #define MAX_LSM_EVM_XATTR	2
 

commit 191c542442fdf53cc3c496c00be13367fd9cd42d
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Mon Feb 13 03:58:52 2012 +0000

    mm: collapse security_vm_enough_memory() variants into a single function
    
    Collapse security_vm_enough_memory() variants into a single function.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 7d9426bb7442..44177add4713 100644
--- a/security/security.c
+++ b/security/security.c
@@ -187,25 +187,11 @@ int security_settime(const struct timespec *ts, const struct timezone *tz)
 	return security_ops->settime(ts, tz);
 }
 
-int security_vm_enough_memory(long pages)
-{
-	WARN_ON(current->mm == NULL);
-	return security_ops->vm_enough_memory(current->mm, pages);
-}
-
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
-	WARN_ON(mm == NULL);
 	return security_ops->vm_enough_memory(mm, pages);
 }
 
-int security_vm_enough_memory_kern(long pages)
-{
-	/* If current->mm is a kernel thread then we will pass NULL,
-	   for this specific case that is fine */
-	return security_ops->vm_enough_memory(current->mm, pages);
-}
-
 int security_bprm_set_creds(struct linux_binprm *bprm)
 {
 	return security_ops->bprm_set_creds(bprm);

commit 1a2a4d06e1e95260c470ebe3a945f61bbe8c1fd8
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Dec 21 12:17:03 2011 -0800

    security: create task_free security callback
    
    The current LSM interface to cred_free is not sufficient for allowing
    an LSM to track the life and death of a task. This patch adds the
    task_free hook so that an LSM can clean up resources on task death.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index d7542493454d..7d9426bb7442 100644
--- a/security/security.c
+++ b/security/security.c
@@ -729,6 +729,11 @@ int security_task_create(unsigned long clone_flags)
 	return security_ops->task_create(clone_flags);
 }
 
+void security_task_free(struct task_struct *task)
+{
+	security_ops->task_free(task);
+}
+
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
 	return security_ops->cred_alloc_blank(cred, gfp);

commit c49c41a4134679cecb77362e7f6b59acb6320aa7
Merge: 892d208bcf79 f423e5ba76e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 14 18:36:33 2012 -0800

    Merge branch 'for-linus' of git://selinuxproject.org/~jmorris/linux-security
    
    * 'for-linus' of git://selinuxproject.org/~jmorris/linux-security:
      capabilities: remove __cap_full_set definition
      security: remove the security_netlink_recv hook as it is equivalent to capable()
      ptrace: do not audit capability check when outputing /proc/pid/stat
      capabilities: remove task_ns_* functions
      capabitlies: ns_capable can use the cap helpers rather than lsm call
      capabilities: style only - move capable below ns_capable
      capabilites: introduce new has_ns_capabilities_noaudit
      capabilities: call has_ns_capability from has_capability
      capabilities: remove all _real_ interfaces
      capabilities: introduce security_capable_noaudit
      capabilities: reverse arguments to security_capable
      capabilities: remove the task from capable LSM hook entirely
      selinux: sparse fix: fix several warnings in the security server cod
      selinux: sparse fix: fix warnings in netlink code
      selinux: sparse fix: eliminate warnings for selinuxfs
      selinux: sparse fix: declare selinux_disable() in security.h
      selinux: sparse fix: move selinux_complete_init
      selinux: sparse fix: make selinux_secmark_refcount static
      SELinux: Fix RCU deref check warning in sel_netport_insert()
    
    Manually fix up a semantic mis-merge wrt security_netlink_recv():
    
     - the interface was removed in commit fd7784615248 ("security: remove
       the security_netlink_recv hook as it is equivalent to capable()")
    
     - a new user of it appeared in commit a38f7907b926 ("crypto: Add
       userspace configuration API")
    
    causing no automatic merge conflict, but Eric Paris pointed out the
    issue.

commit cdcf116d44e78c7216ba9f8be9af1cdfca7af728
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 10:51:53 2011 -0500

    switch security_path_chmod() to struct path *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 151152de1a0a..214502c772ab 100644
--- a/security/security.c
+++ b/security/security.c
@@ -454,12 +454,11 @@ int security_path_truncate(struct path *path)
 	return security_ops->path_truncate(path);
 }
 
-int security_path_chmod(struct dentry *dentry, struct vfsmount *mnt,
-			umode_t mode)
+int security_path_chmod(struct path *path, umode_t mode)
 {
-	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
 		return 0;
-	return security_ops->path_chmod(dentry, mnt, mode);
+	return security_ops->path_chmod(path, mode);
 }
 
 int security_path_chown(struct path *path, uid_t uid, gid_t gid)

commit fd778461524849afd035679030ae8e8873c72b81
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 12:25:16 2012 -0500

    security: remove the security_netlink_recv hook as it is equivalent to capable()
    
    Once upon a time netlink was not sync and we had to get the effective
    capabilities from the skb that was being received.  Today we instead get
    the capabilities from the current task.  This has rendered the entire
    purpose of the hook moot as it is now functionally equivalent to the
    capable() call.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/security.c b/security/security.c
index 8900c5c4db5c..85481a9c5632 100644
--- a/security/security.c
+++ b/security/security.c
@@ -922,12 +922,6 @@ int security_netlink_send(struct sock *sk, struct sk_buff *skb)
 	return security_ops->netlink_send(sk, skb);
 }
 
-int security_netlink_recv(struct sk_buff *skb, int cap)
-{
-	return security_ops->netlink_recv(skb, cap);
-}
-EXPORT_SYMBOL(security_netlink_recv);
-
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 {
 	return security_ops->secid_to_secctx(secid, secdata, seclen);

commit 2920a8409de5a51575d03deca07e5bb2be6fc98d
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 12:25:15 2012 -0500

    capabilities: remove all _real_ interfaces
    
    The name security_real_capable and security_real_capable_noaudit just don't
    make much sense to me.  Convert them to use security_capable and
    security_capable_noaudit.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@canonical.com>

diff --git a/security/security.c b/security/security.c
index b7edaae77d1d..8900c5c4db5c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -166,30 +166,6 @@ int security_capable_noaudit(const struct cred *cred, struct user_namespace *ns,
 	return security_ops->capable(cred, ns, cap, SECURITY_CAP_NOAUDIT);
 }
 
-int security_real_capable(struct task_struct *tsk, struct user_namespace *ns,
-			  int cap)
-{
-	const struct cred *cred;
-	int ret;
-
-	cred = get_task_cred(tsk);
-	ret = security_ops->capable(cred, ns, cap, SECURITY_CAP_AUDIT);
-	put_cred(cred);
-	return ret;
-}
-
-int security_real_capable_noaudit(struct task_struct *tsk,
-				  struct user_namespace *ns, int cap)
-{
-	const struct cred *cred;
-	int ret;
-
-	cred = get_task_cred(tsk);
-	ret = security_ops->capable(cred, ns, cap, SECURITY_CAP_NOAUDIT);
-	put_cred(cred);
-	return ret;
-}
-
 int security_quotactl(int cmds, int type, int id, struct super_block *sb)
 {
 	return security_ops->quotactl(cmds, type, id, sb);

commit c7eba4a97563fd8b431787f7ad623444f2da80c6
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 12:25:15 2012 -0500

    capabilities: introduce security_capable_noaudit
    
    Exactly like security_capable except don't audit any denials.  This is for
    places where the kernel may make decisions about what to do if a task has a
    given capability, but which failing that capability is not a sign of a
    security policy violation.  An example is checking if a task has
    CAP_SYS_ADMIN to lower it's likelyhood of being killed by the oom killer.
    This check is not a security violation if it is denied.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@canonical.com>

diff --git a/security/security.c b/security/security.c
index b9e57f4fc44a..b7edaae77d1d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -160,6 +160,12 @@ int security_capable(const struct cred *cred, struct user_namespace *ns,
 	return security_ops->capable(cred, ns, cap, SECURITY_CAP_AUDIT);
 }
 
+int security_capable_noaudit(const struct cred *cred, struct user_namespace *ns,
+			     int cap)
+{
+	return security_ops->capable(cred, ns, cap, SECURITY_CAP_NOAUDIT);
+}
+
 int security_real_capable(struct task_struct *tsk, struct user_namespace *ns,
 			  int cap)
 {

commit b7e724d303b684655e4ca3dabd5a6840ad19012d
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 12:25:15 2012 -0500

    capabilities: reverse arguments to security_capable
    
    security_capable takes ns, cred, cap.  But the LSM capable() hook takes
    cred, ns, cap.  The capability helper functions also take cred, ns, cap.
    Rather than flip argument order just to flip it back, leave them alone.
    Heck, this should be a little faster since argument will be in the right
    place!
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/security.c b/security/security.c
index 9ae68c64455e..b9e57f4fc44a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -154,7 +154,7 @@ int security_capset(struct cred *new, const struct cred *old,
 				    effective, inheritable, permitted);
 }
 
-int security_capable(struct user_namespace *ns, const struct cred *cred,
+int security_capable(const struct cred *cred, struct user_namespace *ns,
 		     int cap)
 {
 	return security_ops->capable(cred, ns, cap, SECURITY_CAP_AUDIT);

commit 6a9de49115d5ff9871d953af1a5c8249e1585731
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 12:25:14 2012 -0500

    capabilities: remove the task from capable LSM hook entirely
    
    The capabilities framework is based around credentials, not necessarily the
    current task.  Yet we still passed the current task down into LSMs from the
    security_capable() LSM hook as if it was a meaningful portion of the security
    decision.  This patch removes the 'generic' passing of current and instead
    forces individual LSMs to use current explicitly if they think it is
    appropriate.  In our case those LSMs are SELinux and AppArmor.
    
    I believe the AppArmor use of current is incorrect, but that is wholely
    unrelated to this patch.  This patch does not change what AppArmor does, it
    just makes it clear in the AppArmor code that it is doing it.
    
    The SELinux code still uses current in it's audit message, which may also be
    wrong and needs further investigation.  Again this is NOT a change, it may
    have always been wrong, this patch just makes it clear what is happening.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/security.c b/security/security.c
index d9e153390926..9ae68c64455e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -157,8 +157,7 @@ int security_capset(struct cred *new, const struct cred *old,
 int security_capable(struct user_namespace *ns, const struct cred *cred,
 		     int cap)
 {
-	return security_ops->capable(current, cred, ns, cap,
-				     SECURITY_CAP_AUDIT);
+	return security_ops->capable(cred, ns, cap, SECURITY_CAP_AUDIT);
 }
 
 int security_real_capable(struct task_struct *tsk, struct user_namespace *ns,
@@ -168,7 +167,7 @@ int security_real_capable(struct task_struct *tsk, struct user_namespace *ns,
 	int ret;
 
 	cred = get_task_cred(tsk);
-	ret = security_ops->capable(tsk, cred, ns, cap, SECURITY_CAP_AUDIT);
+	ret = security_ops->capable(cred, ns, cap, SECURITY_CAP_AUDIT);
 	put_cred(cred);
 	return ret;
 }
@@ -180,7 +179,7 @@ int security_real_capable_noaudit(struct task_struct *tsk,
 	int ret;
 
 	cred = get_task_cred(tsk);
-	ret = security_ops->capable(tsk, cred, ns, cap, SECURITY_CAP_NOAUDIT);
+	ret = security_ops->capable(cred, ns, cap, SECURITY_CAP_NOAUDIT);
 	put_cred(cred);
 	return ret;
 }

commit 04fc66e789a896e684bfdca30208e57eb832dd96
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 21 14:58:38 2011 -0500

    switch ->path_mknod() to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index e9724e058b43..151152de1a0a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -388,7 +388,7 @@ int security_old_inode_init_security(struct inode *inode, struct inode *dir,
 EXPORT_SYMBOL(security_old_inode_init_security);
 
 #ifdef CONFIG_SECURITY_PATH
-int security_path_mknod(struct path *dir, struct dentry *dentry, int mode,
+int security_path_mknod(struct path *dir, struct dentry *dentry, umode_t mode,
 			unsigned int dev)
 {
 	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))

commit 4572befe248fd0d94aedc98775e3f0ddc8a26651
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 21 14:56:21 2011 -0500

    switch ->path_mkdir() to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 3635a13cd4ab..e9724e058b43 100644
--- a/security/security.c
+++ b/security/security.c
@@ -397,7 +397,7 @@ int security_path_mknod(struct path *dir, struct dentry *dentry, int mode,
 }
 EXPORT_SYMBOL(security_path_mknod);
 
-int security_path_mkdir(struct path *dir, struct dentry *dentry, int mode)
+int security_path_mkdir(struct path *dir, struct dentry *dentry, umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
 		return 0;

commit 910f4ecef3f67714ebff69d0bc34313e48afaed2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 04:25:58 2011 -0400

    switch security_path_chmod() to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 8cc0f0caa640..3635a13cd4ab 100644
--- a/security/security.c
+++ b/security/security.c
@@ -455,7 +455,7 @@ int security_path_truncate(struct path *path)
 }
 
 int security_path_chmod(struct dentry *dentry, struct vfsmount *mnt,
-			mode_t mode)
+			umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;

commit 1a67aafb5f72a436ca044293309fa7e6351d6a35
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 01:52:52 2011 -0400

    switch ->mknod() to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 2420eed87639..8cc0f0caa640 100644
--- a/security/security.c
+++ b/security/security.c
@@ -521,7 +521,7 @@ int security_inode_rmdir(struct inode *dir, struct dentry *dentry)
 	return security_ops->inode_rmdir(dir, dentry);
 }
 
-int security_inode_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+int security_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
 {
 	if (unlikely(IS_PRIVATE(dir)))
 		return 0;

commit 4acdaf27ebe2034c342f3be57ef49aed1ad885ef
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 01:42:34 2011 -0400

    switch ->create() to umode_t
    
    vfs_create() ignores everything outside of 16bit subset of its
    mode argument; switching it to umode_t is obviously equivalent
    and it's the only caller of the method
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index be49eb5768bc..2420eed87639 100644
--- a/security/security.c
+++ b/security/security.c
@@ -475,7 +475,7 @@ int security_path_chroot(struct path *path)
 }
 #endif
 
-int security_inode_create(struct inode *dir, struct dentry *dentry, int mode)
+int security_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(dir)))
 		return 0;

commit 18bb1db3e7607e4a997d50991a6f9fa5b0f8722c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 01:41:39 2011 -0400

    switch vfs_mkdir() and ->mkdir() to umode_t
    
    vfs_mkdir() gets int, but immediately drops everything that might not
    fit into umode_t and that's the only caller of ->mkdir()...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index e2f684aeb70c..be49eb5768bc 100644
--- a/security/security.c
+++ b/security/security.c
@@ -506,7 +506,7 @@ int security_inode_symlink(struct inode *dir, struct dentry *dentry,
 	return security_ops->inode_symlink(dir, dentry, old_name);
 }
 
-int security_inode_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+int security_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
 	if (unlikely(IS_PRIVATE(dir)))
 		return 0;

commit 30e053248da178cf6154bb7e950dc8713567e3fa
Author: Jan Kara <jack@suse.cz>
Date:   Tue Jan 3 13:14:29 2012 +0100

    security: Fix security_old_inode_init_security() when CONFIG_SECURITY is not set
    
    Commit 1e39f384bb01 ("evm: fix build problems") makes the stub version
    of security_old_inode_init_security() return 0 when CONFIG_SECURITY is
    not set.
    
    But that makes callers such as reiserfs_security_init() assume that
    security_old_inode_init_security() has set name, value, and len
    arguments properly - but security_old_inode_init_security() left them
    uninitialized which then results in interesting failures.
    
    Revert security_old_inode_init_security() to the old behavior of
    returning EOPNOTSUPP since both callers (reiserfs and ocfs2) handle this
    just fine.
    
    [ Also fixed the S_PRIVATE(inode) case of the actual non-stub
      security_old_inode_init_security() function to return EOPNOTSUPP
      for the same reason, as pointed out by Mimi Zohar.
    
      It got incorrectly changed to match the new function in commit
      fb88c2b6cbb1: "evm: fix security/security_old_init_security return
      code".   - Linus ]
    
    Reported-by: Jorge Bastos <mysql.jorge@decimal.pt>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 0c6cc69c8f86..e2f684aeb70c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -381,7 +381,7 @@ int security_old_inode_init_security(struct inode *inode, struct inode *dir,
 				     void **value, size_t *len)
 {
 	if (unlikely(IS_PRIVATE(inode)))
-		return 0;
+		return -EOPNOTSUPP;
 	return security_ops->inode_init_security(inode, dir, qstr, name, value,
 						 len);
 }

commit 36b8d186e6cc8e32cb5227f5645a58e1bc0af190
Merge: cd85b557414f c45ed235abf1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 25 09:45:31 2011 +0200

    Merge branch 'next' of git://selinuxproject.org/~jmorris/linux-security
    
    * 'next' of git://selinuxproject.org/~jmorris/linux-security: (95 commits)
      TOMOYO: Fix incomplete read after seek.
      Smack: allow to access /smack/access as normal user
      TOMOYO: Fix unused kernel config option.
      Smack: fix: invalid length set for the result of /smack/access
      Smack: compilation fix
      Smack: fix for /smack/access output, use string instead of byte
      Smack: domain transition protections (v3)
      Smack: Provide information for UDS getsockopt(SO_PEERCRED)
      Smack: Clean up comments
      Smack: Repair processing of fcntl
      Smack: Rule list lookup performance
      Smack: check permissions from user space (v2)
      TOMOYO: Fix quota and garbage collector.
      TOMOYO: Remove redundant tasklist_lock.
      TOMOYO: Fix domain transition failure warning.
      TOMOYO: Remove tomoyo_policy_memory_lock spinlock.
      TOMOYO: Simplify garbage collector.
      TOMOYO: Fix make namespacecheck warnings.
      target: check hex2bin result
      encrypted-keys: check hex2bin result
      ...

commit 6230c9b4f8957c8938ee4cf2d03166d3c2dc89de
Author: Paul Moore <pmoore@redhat.com>
Date:   Fri Oct 7 09:40:59 2011 +0000

    bluetooth: Properly clone LSM attributes to newly created child connections
    
    The Bluetooth stack has internal connection handlers for all of the various
    Bluetooth protocols, and unfortunately, they are currently lacking the LSM
    hooks found in the core network stack's connection handlers.  I say
    unfortunately, because this can cause problems for users who have have an
    LSM enabled and are using certain Bluetooth devices.  See one problem
    report below:
    
     * http://bugzilla.redhat.com/show_bug.cgi?id=741703
    
    In order to keep things simple at this point in time, this patch fixes the
    problem by cloning the parent socket's LSM attributes to the newly created
    child socket.  If we decide we need a more elaborate LSM marking mechanism
    for Bluetooth (I somewhat doubt this) we can always revisit this decision
    in the future.
    
    Reported-by: James M. Cape <jcape@ignore-your.tv>
    Signed-off-by: Paul Moore <pmoore@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index 0e4fccfef12c..d9e153390926 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1097,6 +1097,7 @@ void security_sk_clone(const struct sock *sk, struct sock *newsk)
 {
 	security_ops->sk_clone_security(sk, newsk);
 }
+EXPORT_SYMBOL(security_sk_clone);
 
 void security_sk_classify_flow(struct sock *sk, struct flowi *fl)
 {

commit fb88c2b6cbb1265a8bef60694699b37f5cd4ba76
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Aug 15 10:13:18 2011 -0400

    evm: fix security/security_old_init_security return code
    
    security_inode_init_security previously returned -EOPNOTSUPP, for S_PRIVATE
    inodes, and relied on the callers to change it to 0.  As the callers do not
    change the return code anymore, return 0, intead of -EOPNOTSUPP.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>

diff --git a/security/security.c b/security/security.c
index 9ebda054a333..c1d69875db6c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -348,7 +348,7 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 	int ret;
 
 	if (unlikely(IS_PRIVATE(inode)))
-		return -EOPNOTSUPP;
+		return 0;
 
 	memset(new_xattrs, 0, sizeof new_xattrs);
 	if (!initxattrs)
@@ -381,7 +381,7 @@ int security_old_inode_init_security(struct inode *inode, struct inode *dir,
 				     void **value, size_t *len)
 {
 	if (unlikely(IS_PRIVATE(inode)))
-		return -EOPNOTSUPP;
+		return 0;
 	return security_ops->inode_init_security(inode, dir, qstr, name, value,
 						 len);
 }

commit 5dbe3040c74eef18e66951347eda05b153e69328
Author: James Morris <jmorris@namei.org>
Date:   Tue Aug 30 13:48:53 2011 +1000

    security: sparse fix: Move security_fixup_op to security.h
    
    Fix sparse warning by moving declaraion to global header.
    
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index a6328421a055..9ebda054a333 100644
--- a/security/security.c
+++ b/security/security.c
@@ -26,9 +26,6 @@
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
-/* things that live in capability.c */
-extern void __init security_fixup_ops(struct security_operations *ops);
-
 static struct security_operations *security_ops;
 static struct security_operations default_security_ops = {
 	.name	= "default",

commit 5a2f3a02aea164f4f59c0c3497772090a411b462
Merge: 1d568ab068c0 817b54aa45db
Author: James Morris <jmorris@namei.org>
Date:   Tue Aug 9 10:31:03 2011 +1000

    Merge branch 'next-evm' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/ima-2.6 into next
    
    Conflicts:
            fs/attr.c
    
    Resolve conflict manually.
    
    Signed-off-by: James Morris <jmorris@namei.org>

commit eecdd358b467405a084d400d5ec571bbdbfe97a3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:48:41 2011 -0400

    ->permission() sanitizing: don't pass flags to exec_permission()
    
    pass mask instead; kill security_inode_exec_permission() since we can use
    security_inode_permission() instead.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index db3b750da353..0e4fccfef12c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -521,16 +521,6 @@ int security_inode_permission(struct inode *inode, int mask)
 	return security_ops->inode_permission(inode, mask);
 }
 
-int security_inode_exec_permission(struct inode *inode, unsigned int flags)
-{
-	int mask = MAY_EXEC;
-	if (unlikely(IS_PRIVATE(inode)))
-		return 0;
-	if (flags)
-		mask |= MAY_NOT_BLOCK;
-	return security_ops->inode_permission(inode, mask);
-}
-
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))

commit e74f71eb78a4a8b9eaf1bc65f20f761648e85f76
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:38:15 2011 -0400

    ->permission() sanitizing: don't pass flags to ->inode_permission()
    
    pass that via mask instead.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 4ba6d4cc061f..db3b750da353 100644
--- a/security/security.c
+++ b/security/security.c
@@ -518,14 +518,17 @@ int security_inode_permission(struct inode *inode, int mask)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	return security_ops->inode_permission(inode, mask, 0);
+	return security_ops->inode_permission(inode, mask);
 }
 
 int security_inode_exec_permission(struct inode *inode, unsigned int flags)
 {
+	int mask = MAY_EXEC;
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	return security_ops->inode_permission(inode, MAY_EXEC, flags);
+	if (flags)
+		mask |= MAY_NOT_BLOCK;
+	return security_ops->inode_permission(inode, mask);
 }
 
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)

commit 817b54aa45db03437c6d09a7693fc6926eb8e822
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Fri May 13 12:53:38 2011 -0400

    evm: add evm_inode_setattr to prevent updating an invalid security.evm
    
    Permit changing of security.evm only when valid, unless in fixmode.
    
    Reported-by: Roberto Sassu <roberto.sassu@polito.it>
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>

diff --git a/security/security.c b/security/security.c
index 181990ae90c1..19251ccb2de0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -571,9 +571,14 @@ int security_inode_exec_permission(struct inode *inode, unsigned int flags)
 
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 {
+	int ret;
+
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;
-	return security_ops->inode_setattr(dentry, attr);
+	ret = security_ops->inode_setattr(dentry, attr);
+	if (ret)
+		return ret;
+	return evm_inode_setattr(dentry, attr);
 }
 EXPORT_SYMBOL_GPL(security_inode_setattr);
 

commit 823eb1ccd0b310449e99c822412ea8208334d14c
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Jun 15 21:19:10 2011 -0400

    evm: call evm_inode_init_security from security_inode_init_security
    
    Changelog v7:
    - moved the initialization call to security_inode_init_security,
      renaming evm_inode_post_init_security to evm_inode_init_security
    - increase size of xattr array for EVM xattr
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>

diff --git a/security/security.c b/security/security.c
index 21a79b3d1e8e..181990ae90c1 100644
--- a/security/security.c
+++ b/security/security.c
@@ -20,7 +20,7 @@
 #include <linux/ima.h>
 #include <linux/evm.h>
 
-#define MAX_LSM_XATTR	1
+#define MAX_LSM_EVM_XATTR	2
 
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
@@ -346,8 +346,8 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 				 const struct qstr *qstr,
 				 const initxattrs initxattrs, void *fs_data)
 {
-	struct xattr new_xattrs[MAX_LSM_XATTR + 1];
-	struct xattr *lsm_xattr;
+	struct xattr new_xattrs[MAX_LSM_EVM_XATTR + 1];
+	struct xattr *lsm_xattr, *evm_xattr, *xattr;
 	int ret;
 
 	if (unlikely(IS_PRIVATE(inode)))
@@ -364,11 +364,17 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 						&lsm_xattr->value_len);
 	if (ret)
 		goto out;
+
+	evm_xattr = lsm_xattr + 1;
+	ret = evm_inode_init_security(inode, lsm_xattr, evm_xattr);
+	if (ret)
+		goto out;
 	ret = initxattrs(inode, new_xattrs, fs_data);
 out:
-	kfree(lsm_xattr->name);
-	kfree(lsm_xattr->value);
-
+	for (xattr = new_xattrs; xattr->name != NULL; xattr++) {
+		kfree(xattr->name);
+		kfree(xattr->value);
+	}
 	return (ret == -EOPNOTSUPP) ? 0 : ret;
 }
 EXPORT_SYMBOL(security_inode_init_security);

commit 3e1be52d6c6b21d9080dd886c0e609e009831562
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Mar 9 14:38:26 2011 -0500

    security: imbed evm calls in security hooks
    
    Imbed the evm calls evm_inode_setxattr(), evm_inode_post_setxattr(),
    evm_inode_removexattr() in the security hooks.  evm_inode_setxattr()
    protects security.evm xattr.  evm_inode_post_setxattr() and
    evm_inode_removexattr() updates the hmac associated with an inode.
    
    (Assumes an LSM module protects the setting/removing of xattr.)
    
    Changelog:
      - Don't define evm_verifyxattr(), unless CONFIG_INTEGRITY is enabled.
      - xattr_name is a 'const', value is 'void *'
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/security/security.c b/security/security.c
index 947fdcfbc83e..21a79b3d1e8e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -18,6 +18,7 @@
 #include <linux/security.h>
 #include <linux/integrity.h>
 #include <linux/ima.h>
+#include <linux/evm.h>
 
 #define MAX_LSM_XATTR	1
 
@@ -580,9 +581,14 @@ int security_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
 int security_inode_setxattr(struct dentry *dentry, const char *name,
 			    const void *value, size_t size, int flags)
 {
+	int ret;
+
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;
-	return security_ops->inode_setxattr(dentry, name, value, size, flags);
+	ret = security_ops->inode_setxattr(dentry, name, value, size, flags);
+	if (ret)
+		return ret;
+	return evm_inode_setxattr(dentry, name, value, size);
 }
 
 void security_inode_post_setxattr(struct dentry *dentry, const char *name,
@@ -591,6 +597,7 @@ void security_inode_post_setxattr(struct dentry *dentry, const char *name,
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return;
 	security_ops->inode_post_setxattr(dentry, name, value, size, flags);
+	evm_inode_post_setxattr(dentry, name, value, size);
 }
 
 int security_inode_getxattr(struct dentry *dentry, const char *name)
@@ -609,9 +616,14 @@ int security_inode_listxattr(struct dentry *dentry)
 
 int security_inode_removexattr(struct dentry *dentry, const char *name)
 {
+	int ret;
+
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;
-	return security_ops->inode_removexattr(dentry, name);
+	ret = security_ops->inode_removexattr(dentry, name);
+	if (ret)
+		return ret;
+	return evm_inode_removexattr(dentry, name);
 }
 
 int security_inode_need_killpriv(struct dentry *dentry)

commit f381c272224f5f158f5cff64f8f3481fa0eee8b3
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Mar 9 14:13:22 2011 -0500

    integrity: move ima inode integrity data management
    
    Move the inode integrity data(iint) management up to the integrity directory
    in order to share the iint among the different integrity models.
    
    Changelog:
    - don't define MAX_DIGEST_SIZE
    - rename several globally visible 'ima_' prefixed functions, structs,
      locks, etc to 'integrity_'
    - replace '20' with SHA1_DIGEST_SIZE
    - reflect location change in appropriate Kconfig and Makefiles
    - remove unnecessary initialization of iint_initialized to 0
    - rebased on current ima_iint.c
    - define integrity_iint_store/lock as static
    
    There should be no other functional changes.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/security/security.c b/security/security.c
index 3464d58a5766..947fdcfbc83e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/security.h>
+#include <linux/integrity.h>
 #include <linux/ima.h>
 
 #define MAX_LSM_XATTR	1
@@ -336,7 +337,7 @@ int security_inode_alloc(struct inode *inode)
 
 void security_inode_free(struct inode *inode)
 {
-	ima_inode_free(inode);
+	integrity_inode_free(inode);
 	security_ops->inode_free_security(inode);
 }
 

commit 9d8f13ba3f4833219e50767b022b82cd0da930eb
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Jun 6 15:29:25 2011 -0400

    security: new security_inode_init_security API adds function callback
    
    This patch changes the security_inode_init_security API by adding a
    filesystem specific callback to write security extended attributes.
    This change is in preparation for supporting the initialization of
    multiple LSM xattrs and the EVM xattr.  Initially the callback function
    walks an array of xattrs, writing each xattr separately, but could be
    optimized to write multiple xattrs at once.
    
    For existing security_inode_init_security() calls, which have not yet
    been converted to use the new callback function, such as those in
    reiserfs and ocfs2, this patch defines security_old_inode_init_security().
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>

diff --git a/security/security.c b/security/security.c
index 4ba6d4cc061f..3464d58a5766 100644
--- a/security/security.c
+++ b/security/security.c
@@ -18,6 +18,8 @@
 #include <linux/security.h>
 #include <linux/ima.h>
 
+#define MAX_LSM_XATTR	1
+
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
@@ -339,15 +341,46 @@ void security_inode_free(struct inode *inode)
 }
 
 int security_inode_init_security(struct inode *inode, struct inode *dir,
-				 const struct qstr *qstr, char **name,
-				 void **value, size_t *len)
+				 const struct qstr *qstr,
+				 const initxattrs initxattrs, void *fs_data)
+{
+	struct xattr new_xattrs[MAX_LSM_XATTR + 1];
+	struct xattr *lsm_xattr;
+	int ret;
+
+	if (unlikely(IS_PRIVATE(inode)))
+		return -EOPNOTSUPP;
+
+	memset(new_xattrs, 0, sizeof new_xattrs);
+	if (!initxattrs)
+		return security_ops->inode_init_security(inode, dir, qstr,
+							 NULL, NULL, NULL);
+	lsm_xattr = new_xattrs;
+	ret = security_ops->inode_init_security(inode, dir, qstr,
+						&lsm_xattr->name,
+						&lsm_xattr->value,
+						&lsm_xattr->value_len);
+	if (ret)
+		goto out;
+	ret = initxattrs(inode, new_xattrs, fs_data);
+out:
+	kfree(lsm_xattr->name);
+	kfree(lsm_xattr->value);
+
+	return (ret == -EOPNOTSUPP) ? 0 : ret;
+}
+EXPORT_SYMBOL(security_inode_init_security);
+
+int security_old_inode_init_security(struct inode *inode, struct inode *dir,
+				     const struct qstr *qstr, char **name,
+				     void **value, size_t *len)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
 	return security_ops->inode_init_security(inode, dir, qstr, name, value,
 						 len);
 }
-EXPORT_SYMBOL(security_inode_init_security);
+EXPORT_SYMBOL(security_old_inode_init_security);
 
 #ifdef CONFIG_SECURITY_PATH
 int security_path_mknod(struct path *dir, struct dentry *dentry, int mode,

commit 8c9e80ed276fc4b9c9fadf29d8bf6b3576112f1a
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Apr 21 17:23:19 2011 -0700

    SECURITY: Move exec_permission RCU checks into security modules
    
    Right now all RCU walks fall back to reference walk when CONFIG_SECURITY
    is enabled, even though just the standard capability module is active.
    This is because security_inode_exec_permission unconditionally fails
    RCU walks.
    
    Move this decision to the low level security module. This requires
    passing the RCU flags down the security hook. This way at least
    the capability module and a few easy cases in selinux/smack work
    with RCU walks with CONFIG_SECURITY=y
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 101142369db4..4ba6d4cc061f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -518,16 +518,14 @@ int security_inode_permission(struct inode *inode, int mask)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	return security_ops->inode_permission(inode, mask);
+	return security_ops->inode_permission(inode, mask, 0);
 }
 
 int security_inode_exec_permission(struct inode *inode, unsigned int flags)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	if (flags)
-		return -ECHILD;
-	return security_ops->inode_permission(inode, MAY_EXEC);
+	return security_ops->inode_permission(inode, MAY_EXEC, flags);
 }
 
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)

commit 3486740a4f32a6a466f5ac931654d154790ba648
Author: Serge E. Hallyn <serge@hallyn.com>
Date:   Wed Mar 23 16:43:17 2011 -0700

    userns: security: make capabilities relative to the user namespace
    
    - Introduce ns_capable to test for a capability in a non-default
      user namespace.
    - Teach cap_capable to handle capabilities in a non-default
      user namespace.
    
    The motivation is to get to the unprivileged creation of new
    namespaces.  It looks like this gets us 90% of the way there, with
    only potential uid confusion issues left.
    
    I still need to handle getting all caps after creation but otherwise I
    think I have a good starter patch that achieves all of your goals.
    
    Changelog:
            11/05/2010: [serge] add apparmor
            12/14/2010: [serge] fix capabilities to created user namespaces
            Without this, if user serge creates a user_ns, he won't have
            capabilities to the user_ns he created.  THis is because we
            were first checking whether his effective caps had the caps
            he needed and returning -EPERM if not, and THEN checking whether
            he was the creator.  Reverse those checks.
            12/16/2010: [serge] security_real_capable needs ns argument in !security case
            01/11/2011: [serge] add task_ns_capable helper
            01/11/2011: [serge] add nsown_capable() helper per Bastian Blank suggestion
            02/16/2011: [serge] fix a logic bug: the root user is always creator of
                        init_user_ns, but should not always have capabilities to
                        it!  Fix the check in cap_capable().
            02/21/2011: Add the required user_ns parameter to security_capable,
                        fixing a compile failure.
            02/23/2011: Convert some macros to functions as per akpm comments.  Some
                        couldn't be converted because we can't easily forward-declare
                        them (they are inline if !SECURITY, extern if SECURITY).  Add
                        a current_user_ns function so we can use it in capability.h
                        without #including cred.h.  Move all forward declarations
                        together to the top of the #ifdef __KERNEL__ section, and use
                        kernel-doc format.
            02/23/2011: Per dhowells, clean up comment in cap_capable().
            02/23/2011: Per akpm, remove unreachable 'return -EPERM' in cap_capable.
    
    (Original written and signed off by Eric;  latest, modified version
    acked by him)
    
    [akpm@linux-foundation.org: fix build]
    [akpm@linux-foundation.org: export current_user_ns() for ecryptfs]
    [serge.hallyn@canonical.com: remove unneeded extra argument in selinux's task_has_capability]
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@free.fr>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 9187665a3fdd..101142369db4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -154,29 +154,33 @@ int security_capset(struct cred *new, const struct cred *old,
 				    effective, inheritable, permitted);
 }
 
-int security_capable(const struct cred *cred, int cap)
+int security_capable(struct user_namespace *ns, const struct cred *cred,
+		     int cap)
 {
-	return security_ops->capable(current, cred, cap, SECURITY_CAP_AUDIT);
+	return security_ops->capable(current, cred, ns, cap,
+				     SECURITY_CAP_AUDIT);
 }
 
-int security_real_capable(struct task_struct *tsk, int cap)
+int security_real_capable(struct task_struct *tsk, struct user_namespace *ns,
+			  int cap)
 {
 	const struct cred *cred;
 	int ret;
 
 	cred = get_task_cred(tsk);
-	ret = security_ops->capable(tsk, cred, cap, SECURITY_CAP_AUDIT);
+	ret = security_ops->capable(tsk, cred, ns, cap, SECURITY_CAP_AUDIT);
 	put_cred(cred);
 	return ret;
 }
 
-int security_real_capable_noaudit(struct task_struct *tsk, int cap)
+int security_real_capable_noaudit(struct task_struct *tsk,
+				  struct user_namespace *ns, int cap)
 {
 	const struct cred *cred;
 	int ret;
 
 	cred = get_task_cred(tsk);
-	ret = security_ops->capable(tsk, cred, cap, SECURITY_CAP_NOAUDIT);
+	ret = security_ops->capable(tsk, cred, ns, cap, SECURITY_CAP_NOAUDIT);
 	put_cred(cred);
 	return ret;
 }

commit 7a6362800cb7d1d618a697a650c7aaed3eb39320
Merge: 6445ced8670f ceda86a10867
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 16:29:25 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1480 commits)
      bonding: enable netpoll without checking link status
      xfrm: Refcount destination entry on xfrm_lookup
      net: introduce rx_handler results and logic around that
      bonding: get rid of IFF_SLAVE_INACTIVE netdev->priv_flag
      bonding: wrap slave state work
      net: get rid of multiple bond-related netdevice->priv_flags
      bonding: register slave pointer for rx_handler
      be2net: Bump up the version number
      be2net: Copyright notice change. Update to Emulex instead of ServerEngines
      e1000e: fix kconfig for crc32 dependency
      netfilter ebtables: fix xt_AUDIT to work with ebtables
      xen network backend driver
      bonding: Improve syslog message at device creation time
      bonding: Call netif_carrier_off after register_netdevice
      bonding: Incorrect TX queue offset
      net_sched: fix ip_tos2prio
      xfrm: fix __xfrm_route_forward()
      be2net: Fix UDP packet detected status in RX compl
      Phonet: fix aligned-mode pipe socket buffer header reserve
      netxen: support for GbE port settings
      ...
    
    Fix up conflicts in drivers/staging/brcm80211/brcmsmac/wl_mac80211.c
    with the staging updates.

commit 0f6e0e8448a16d8d22119ce91d8dd24b44865b51
Merge: 0d2ecee2bdb2 a002951c97ff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 09:15:43 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6: (33 commits)
      AppArmor: kill unused macros in lsm.c
      AppArmor: cleanup generated files correctly
      KEYS: Add an iovec version of KEYCTL_INSTANTIATE
      KEYS: Add a new keyctl op to reject a key with a specified error code
      KEYS: Add a key type op to permit the key description to be vetted
      KEYS: Add an RCU payload dereference macro
      AppArmor: Cleanup make file to remove cruft and make it easier to read
      SELinux: implement the new sb_remount LSM hook
      LSM: Pass -o remount options to the LSM
      SELinux: Compute SID for the newly created socket
      SELinux: Socket retains creator role and MLS attribute
      SELinux: Auto-generate security_is_socket_class
      TOMOYO: Fix memory leak upon file open.
      Revert "selinux: simplify ioctl checking"
      selinux: drop unused packet flow permissions
      selinux: Fix packet forwarding checks on postrouting
      selinux: Fix wrong checks for selinux_policycap_netpeer
      selinux: Fix check for xfrm selinux context algorithm
      ima: remove unnecessary call to ima_must_measure
      IMA: remove IMA imbalance checking
      ...

commit 420c1c572d4ceaa2f37b6311b7017ac6cf049fe2
Merge: 9620639b7ea3 6e6823d17b15
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 18:53:35 2011 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (62 commits)
      posix-clocks: Check write permissions in posix syscalls
      hrtimer: Remove empty hrtimer_init_hres_timer()
      hrtimer: Update hrtimer->state documentation
      hrtimer: Update base[CLOCK_BOOTTIME].offset correctly
      timers: Export CLOCK_BOOTTIME via the posix timers interface
      timers: Add CLOCK_BOOTTIME hrtimer base
      time: Extend get_xtime_and_monotonic_offset() to also return sleep
      time: Introduce get_monotonic_boottime and ktime_get_boottime
      hrtimers: extend hrtimer base code to handle more then 2 clockids
      ntp: Remove redundant and incorrect parameter check
      mn10300: Switch do_timer() to xtimer_update()
      posix clocks: Introduce dynamic clocks
      posix-timers: Cleanup namespace
      posix-timers: Add support for fd based clocks
      x86: Add clock_adjtime for x86
      posix-timers: Introduce a syscall for clock tuning.
      time: Splitout compat timex accessors
      ntp: Add ADJ_SETOFFSET mode bit
      time: Introduce timekeeping_inject_offset
      posix-timer: Update comment
      ...
    
    Fix up new system-call-related conflicts in
            arch/x86/ia32/ia32entry.S
            arch/x86/include/asm/unistd_32.h
            arch/x86/include/asm/unistd_64.h
            arch/x86/kernel/syscall_table_32.S
    (name_to_handle_at()/open_by_handle_at() vs clock_adjtime()), and some
    due to movement of get_jiffies_64() in:
            kernel/time.c

commit 1d28f42c1bd4bb2363d88df74d0128b4da135b4a
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 12 00:29:39 2011 -0500

    net: Put flowi_* prefix on AF independent members of struct flowi
    
    I intend to turn struct flowi into a union of AF specific flowi
    structs.  There will be a common structure that each variant includes
    first, much like struct sock_common.
    
    This is the first step to move in that direction.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index 8ef1f7dff277..bae843c8a13e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1100,7 +1100,7 @@ void security_sk_clone(const struct sock *sk, struct sock *newsk)
 
 void security_sk_classify_flow(struct sock *sk, struct flowi *fl)
 {
-	security_ops->sk_getsecid(sk, &fl->secid);
+	security_ops->sk_getsecid(sk, &fl->flowi_secid);
 }
 EXPORT_SYMBOL(security_sk_classify_flow);
 
@@ -1246,7 +1246,7 @@ int security_xfrm_decode_session(struct sk_buff *skb, u32 *secid)
 
 void security_skb_classify_flow(struct sk_buff *skb, struct flowi *fl)
 {
-	int rc = security_ops->xfrm_decode_session(skb, &fl->secid, 0);
+	int rc = security_ops->xfrm_decode_session(skb, &fl->flowi_secid, 0);
 
 	BUG_ON(rc);
 }

commit fe3fa43039d47ee4e22caf460b79b62a14937f79
Merge: ee009e4a0d45 026eb167ae77
Author: James Morris <jmorris@namei.org>
Date:   Tue Mar 8 11:38:10 2011 +1100

    Merge branch 'master' of git://git.infradead.org/users/eparis/selinux into next

commit 1cc26bada9f6807814806db2f0d78792eecdac71
Merge: eae61f3c8294 214d93b02c4f
Author: James Morris <jmorris@namei.org>
Date:   Tue Mar 8 10:55:06 2011 +1100

    Merge branch 'master'; commit 'v2.6.38-rc7' into next

commit ff36fe2c845cab2102e4826c1ffa0a6ebf487c65
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Mar 3 16:09:14 2011 -0500

    LSM: Pass -o remount options to the LSM
    
    The VFS mount code passes the mount options to the LSM.  The LSM will remove
    options it understands from the data and the VFS will then pass the remaining
    options onto the underlying filesystem.  This is how options like the
    SELinux context= work.  The problem comes in that -o remount never calls
    into LSM code.  So if you include an LSM specific option it will get passed
    to the filesystem and will cause the remount to fail.  An example of where
    this is a problem is the 'seclabel' option.  The SELinux LSM hook will
    print this word in /proc/mounts if the filesystem is being labeled using
    xattrs.  If you pass this word on mount it will be silently stripped and
    ignored.  But if you pass this word on remount the LSM never gets called
    and it will be passed to the FS.  The FS doesn't know what seclabel means
    and thus should fail the mount.  For example an ext3 fs mounted over loop
    
    # mount -o loop /tmp/fs /mnt/tmp
    # cat /proc/mounts | grep /mnt/tmp
    /dev/loop0 /mnt/tmp ext3 rw,seclabel,relatime,errors=continue,barrier=0,data=ordered 0 0
    # mount -o remount /mnt/tmp
    mount: /mnt/tmp not mounted already, or bad option
    # dmesg
    EXT3-fs (loop0): error: unrecognized mount option "seclabel" or missing value
    
    This patch passes the remount mount options to an new LSM hook.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 8f28685ee0d9..b1d6134548bc 100644
--- a/security/security.c
+++ b/security/security.c
@@ -267,6 +267,11 @@ int security_sb_copy_data(char *orig, char *copy)
 }
 EXPORT_SYMBOL(security_sb_copy_data);
 
+int security_sb_remount(struct super_block *sb, void *data)
+{
+	return security_ops->sb_remount(sb, data);
+}
+
 int security_sb_kern_mount(struct super_block *sb, int flags, void *data)
 {
 	return security_ops->sb_kern_mount(sb, flags, data);

commit e33f770426674a565a188042caf3f974f8b3722d
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Feb 22 18:13:15 2011 -0800

    xfrm: Mark flowi arg to security_xfrm_state_pol_flow_match() const.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index 7b7308ace8c5..8ef1f7dff277 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1233,7 +1233,8 @@ int security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)
 }
 
 int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
-				       struct xfrm_policy *xp, struct flowi *fl)
+				       struct xfrm_policy *xp,
+				       const struct flowi *fl)
 {
 	return security_ops->xfrm_state_pol_flow_match(x, xp, fl);
 }

commit 6037b715d6fab139742c3df8851db4c823081561
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Wed Feb 9 22:11:51 2011 -0800

    security: add cred argument to security_capable()
    
    Expand security_capable() to include cred, so that it can be usable in a
    wider range of call sites.
    
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 739e40362f44..7b7308ace8c5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -154,10 +154,9 @@ int security_capset(struct cred *new, const struct cred *old,
 				    effective, inheritable, permitted);
 }
 
-int security_capable(int cap)
+int security_capable(const struct cred *cred, int cap)
 {
-	return security_ops->capable(current, current_cred(), cap,
-				     SECURITY_CAP_AUDIT);
+	return security_ops->capable(current, cred, cap, SECURITY_CAP_AUDIT);
 }
 
 int security_real_capable(struct task_struct *tsk, int cap)

commit 1e6d767924c74929c0cfe839ae8f37bcee9e544e
Author: Richard Cochran <richard.cochran@omicron.at>
Date:   Tue Feb 1 13:50:58 2011 +0000

    time: Correct the *settime* parameters
    
    Both settimeofday() and clock_settime() promise with a 'const'
    attribute not to alter the arguments passed in. This patch adds the
    missing 'const' attribute into the various kernel functions
    implementing these calls.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20110201134417.545698637@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/security/security.c b/security/security.c
index 739e40362f44..b995428f1c96 100644
--- a/security/security.c
+++ b/security/security.c
@@ -202,7 +202,7 @@ int security_syslog(int type)
 	return security_ops->syslog(type);
 }
 
-int security_settime(struct timespec *ts, struct timezone *tz)
+int security_settime(const struct timespec *ts, const struct timezone *tz)
 {
 	return security_ops->settime(ts, tz);
 }

commit 4916ca401e3051dad326ddd69765bd0e3f32fb9b
Author: Lucian Adrian Grijincu <lucian.grijincu@gmail.com>
Date:   Tue Feb 1 18:44:56 2011 +0200

    security: remove unused security_sysctl hook
    
    The only user for this hook was selinux. sysctl routes every call
    through /proc/sys/. Selinux and other security modules use the file
    system checks for sysctl too, so no need for this hook any more.
    
    Signed-off-by: Lucian Adrian Grijincu <lucian.grijincu@gmail.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/security.c b/security/security.c
index 4830f36e1ab5..8f28685ee0d9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -182,11 +182,6 @@ int security_real_capable_noaudit(struct task_struct *tsk, int cap)
 	return ret;
 }
 
-int security_sysctl(struct ctl_table *table, int op)
-{
-	return security_ops->sysctl(table, op);
-}
-
 int security_quotactl(int cmds, int type, int id, struct super_block *sb)
 {
 	return security_ops->quotactl(cmds, type, id, sb);

commit 2a7dba391e5628ad665ce84ef9a6648da541ebab
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Feb 1 11:05:39 2011 -0500

    fs/vfs/security: pass last path component to LSM on inode creation
    
    SELinux would like to implement a new labeling behavior of newly created
    inodes.  We currently label new inodes based on the parent and the creating
    process.  This new behavior would also take into account the name of the
    new object when deciding the new label.  This is not the (supposed) full path,
    just the last component of the path.
    
    This is very useful because creating /etc/shadow is different than creating
    /etc/passwd but the kernel hooks are unable to differentiate these
    operations.  We currently require that userspace realize it is doing some
    difficult operation like that and than userspace jumps through SELinux hoops
    to get things set up correctly.  This patch does not implement new
    behavior, that is obviously contained in a seperate SELinux patch, but it
    does pass the needed name down to the correct LSM hook.  If no such name
    exists it is fine to pass NULL.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/security.c b/security/security.c
index b84a89dd59c6..4830f36e1ab5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -336,11 +336,13 @@ void security_inode_free(struct inode *inode)
 }
 
 int security_inode_init_security(struct inode *inode, struct inode *dir,
-				  char **name, void **value, size_t *len)
+				 const struct qstr *qstr, char **name,
+				 void **value, size_t *len)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return -EOPNOTSUPP;
-	return security_ops->inode_init_security(inode, dir, name, value, len);
+	return security_ops->inode_init_security(inode, dir, qstr, name, value,
+						 len);
 }
 EXPORT_SYMBOL(security_inode_init_security);
 

commit 821404434f3324bf23f545050ff64055a149766e
Author: David Howells <dhowells@redhat.com>
Date:   Fri Dec 24 14:48:35 2010 +0000

    CacheFiles: Add calls to path-based security hooks
    
    Add calls to path-based security hooks into CacheFiles as, unlike inode-based
    security, these aren't implicit in the vfs_mkdir() and similar calls.
    
    Reported-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 739e40362f44..b84a89dd59c6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -360,6 +360,7 @@ int security_path_mkdir(struct path *dir, struct dentry *dentry, int mode)
 		return 0;
 	return security_ops->path_mkdir(dir, dentry, mode);
 }
+EXPORT_SYMBOL(security_path_mkdir);
 
 int security_path_rmdir(struct path *dir, struct dentry *dentry)
 {
@@ -374,6 +375,7 @@ int security_path_unlink(struct path *dir, struct dentry *dentry)
 		return 0;
 	return security_ops->path_unlink(dir, dentry);
 }
+EXPORT_SYMBOL(security_path_unlink);
 
 int security_path_symlink(struct path *dir, struct dentry *dentry,
 			  const char *old_name)
@@ -400,6 +402,7 @@ int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
 	return security_ops->path_rename(old_dir, old_dentry, new_dir,
 					 new_dentry);
 }
+EXPORT_SYMBOL(security_path_rename);
 
 int security_path_truncate(struct path *path)
 {

commit b4a45f5fe8078bfc10837dbd5b98735058bc4698
Merge: 01539ba2a706 b3e19d924b6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 7 08:56:33 2011 -0800

    Merge branch 'vfs-scale-working' of git://git.kernel.org/pub/scm/linux/kernel/git/npiggin/linux-npiggin
    
    * 'vfs-scale-working' of git://git.kernel.org/pub/scm/linux/kernel/git/npiggin/linux-npiggin: (57 commits)
      fs: scale mntget/mntput
      fs: rename vfsmount counter helpers
      fs: implement faster dentry memcmp
      fs: prefetch inode data in dcache lookup
      fs: improve scalability of pseudo filesystems
      fs: dcache per-inode inode alias locking
      fs: dcache per-bucket dcache hash locking
      bit_spinlock: add required includes
      kernel: add bl_list
      xfs: provide simple rcu-walk ACL implementation
      btrfs: provide simple rcu-walk ACL implementation
      ext2,3,4: provide simple rcu-walk ACL implementation
      fs: provide simple rcu-walk generic_check_acl implementation
      fs: provide rcu-walk aware permission i_ops
      fs: rcu-walk aware d_revalidate method
      fs: cache optimise dentry and inode for rcu-walk
      fs: dcache reduce branches in lookup path
      fs: dcache remove d_mounted
      fs: fs_struct use seqlock
      fs: rcu-walk for path lookup
      ...

commit 31e6b01f4183ff419a6d1f86177cbf4662347cec
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:52 2011 +1100

    fs: rcu-walk for path lookup
    
    Perform common cases of path lookups without any stores or locking in the
    ancestor dentry elements. This is called rcu-walk, as opposed to the current
    algorithm which is a refcount based walk, or ref-walk.
    
    This results in far fewer atomic operations on every path element,
    significantly improving path lookup performance. It also avoids cacheline
    bouncing on common dentries, significantly improving scalability.
    
    The overall design is like this:
    * LOOKUP_RCU is set in nd->flags, which distinguishes rcu-walk from ref-walk.
    * Take the RCU lock for the entire path walk, starting with the acquiring
      of the starting path (eg. root/cwd/fd-path). So now dentry refcounts are
      not required for dentry persistence.
    * synchronize_rcu is called when unregistering a filesystem, so we can
      access d_ops and i_ops during rcu-walk.
    * Similarly take the vfsmount lock for the entire path walk. So now mnt
      refcounts are not required for persistence. Also we are free to perform mount
      lookups, and to assume dentry mount points and mount roots are stable up and
      down the path.
    * Have a per-dentry seqlock to protect the dentry name, parent, and inode,
      so we can load this tuple atomically, and also check whether any of its
      members have changed.
    * Dentry lookups (based on parent, candidate string tuple) recheck the parent
      sequence after the child is found in case anything changed in the parent
      during the path walk.
    * inode is also RCU protected so we can load d_inode and use the inode for
      limited things.
    * i_mode, i_uid, i_gid can be tested for exec permissions during path walk.
    * i_op can be loaded.
    
    When we reach the destination dentry, we lock it, recheck lookup sequence,
    and increment its refcount and mountpoint refcount. RCU and vfsmount locks
    are dropped. This is termed "dropping rcu-walk". If the dentry refcount does
    not match, we can not drop rcu-walk gracefully at the current point in the
    lokup, so instead return -ECHILD (for want of a better errno). This signals the
    path walking code to re-do the entire lookup with a ref-walk.
    
    Aside from the final dentry, there are other situations that may be encounted
    where we cannot continue rcu-walk. In that case, we drop rcu-walk (ie. take
    a reference on the last good dentry) and continue with a ref-walk. Again, if
    we can drop rcu-walk gracefully, we return -ECHILD and do the whole lookup
    using ref-walk. But it is very important that we can continue with ref-walk
    for most cases, particularly to avoid the overhead of double lookups, and to
    gain the scalability advantages on common path elements (like cwd and root).
    
    The cases where rcu-walk cannot continue are:
    * NULL dentry (ie. any uncached path element)
    * parent with d_inode->i_op->permission or ACLs
    * dentries with d_revalidate
    * Following links
    
    In future patches, permission checks and d_revalidate become rcu-walk aware. It
    may be possible eventually to make following links rcu-walk aware.
    
    Uncached path elements will always require dropping to ref-walk mode, at the
    very least because i_mutex needs to be grabbed, and objects allocated.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/security/security.c b/security/security.c
index 1b798d3df710..c645e263ca8d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -513,6 +513,15 @@ int security_inode_permission(struct inode *inode, int mask)
 	return security_ops->inode_permission(inode, mask);
 }
 
+int security_inode_exec_permission(struct inode *inode, unsigned int flags)
+{
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+	if (flags)
+		return -ECHILD;
+	return security_ops->inode_permission(inode, MAY_EXEC);
+}
+
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))

commit 3610cda53f247e176bcbb7a7cca64bc53b12acdb
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jan 5 15:38:53 2011 -0800

    af_unix: Avoid socket->sk NULL OOPS in stream connect security hooks.
    
    unix_release() can asynchornously set socket->sk to NULL, and
    it does so without holding the unix_state_lock() on "other"
    during stream connects.
    
    However, the reverse mapping, sk->sk_socket, is only transitioned
    to NULL under the unix_state_lock().
    
    Therefore make the security hooks follow the reverse mapping instead
    of the forward mapping.
    
    Reported-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index 1b798d3df710..e5fb07a3052d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -977,8 +977,7 @@ EXPORT_SYMBOL(security_inode_getsecctx);
 
 #ifdef CONFIG_SECURITY_NETWORK
 
-int security_unix_stream_connect(struct socket *sock, struct socket *other,
-				 struct sock *newsk)
+int security_unix_stream_connect(struct sock *sock, struct sock *other, struct sock *newsk)
 {
 	return security_ops->unix_stream_connect(sock, other, newsk);
 }

commit 12b3052c3ee8f508b2c7ee4ddd63ed03423409d8
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Nov 15 18:36:29 2010 -0500

    capabilities/syslog: open code cap_syslog logic to fix build failure
    
    The addition of CONFIG_SECURITY_DMESG_RESTRICT resulted in a build
    failure when CONFIG_PRINTK=n.  This is because the capabilities code
    which used the new option was built even though the variable in question
    didn't exist.
    
    The patch here fixes this by moving the capabilities checks out of the
    LSM and into the caller.  All (known) LSMs should have been calling the
    capabilities hook already so it actually makes the code organization
    better to eliminate the hook altogether.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 3ef5e2a7a741..1b798d3df710 100644
--- a/security/security.c
+++ b/security/security.c
@@ -197,9 +197,9 @@ int security_quota_on(struct dentry *dentry)
 	return security_ops->quota_on(dentry);
 }
 
-int security_syslog(int type, bool from_file)
+int security_syslog(int type)
 {
-	return security_ops->syslog(type, from_file);
+	return security_ops->syslog(type);
 }
 
 int security_settime(struct timespec *ts, struct timezone *tz)

commit f9ba5375a8aae4aeea6be15df77e24707a429812
Merge: 45352bbf48e9 bade72d607c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 26 11:37:48 2010 -0700

    Merge branch 'ima-memory-use-fixes'
    
    * ima-memory-use-fixes:
      IMA: fix the ToMToU logic
      IMA: explicit IMA i_flag to remove global lock on inode_delete
      IMA: drop refcnt from ima_iint_cache since it isn't needed
      IMA: only allocate iint when needed
      IMA: move read counter into struct inode
      IMA: use i_writecount rather than a private counter
      IMA: use inode->i_lock to protect read and write counters
      IMA: convert internal flags from long to char
      IMA: use unsigned int instead of long for counters
      IMA: drop the inode opencount since it isn't needed for operation
      IMA: use rbtree instead of radix tree for inode information cache

commit bc7d2a3e66b40477270c3cbe3b89b47093276e7a
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Oct 25 14:42:05 2010 -0400

    IMA: only allocate iint when needed
    
    IMA always allocates an integrity structure to hold information about
    every inode, but only needed this structure to track the number of
    readers and writers currently accessing a given inode.  Since that
    information was moved into struct inode instead of the integrity struct
    this patch stops allocating the integrity stucture until it is needed.
    Thus greatly reducing memory usage.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index c53949f17d9e..a3b47feccae9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -333,16 +333,8 @@ EXPORT_SYMBOL(security_sb_parse_opts_str);
 
 int security_inode_alloc(struct inode *inode)
 {
-	int ret;
-
 	inode->i_security = NULL;
-	ret =  security_ops->inode_alloc_security(inode);
-	if (ret)
-		return ret;
-	ret = ima_inode_alloc(inode);
-	if (ret)
-		security_inode_free(inode);
-	return ret;
+	return security_ops->inode_alloc_security(inode);
 }
 
 void security_inode_free(struct inode *inode)

commit 2606fd1fa5710205b23ee859563502aa18362447
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Oct 13 16:24:41 2010 -0400

    secmark: make secmark object handling generic
    
    Right now secmark has lots of direct selinux calls.  Use all LSM calls and
    remove all SELinux specific knowledge.  The only SELinux specific knowledge
    we leave is the mode.  The only point is to make sure that other LSMs at
    least test this generic code before they assume it works.  (They may also
    have to make changes if they do not represent labels as strings)
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Paul Moore <paul.moore@hp.com>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 1cbcdfa4b015..b50f472061a4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1136,6 +1136,24 @@ void security_inet_conn_established(struct sock *sk,
 	security_ops->inet_conn_established(sk, skb);
 }
 
+int security_secmark_relabel_packet(u32 secid)
+{
+	return security_ops->secmark_relabel_packet(secid);
+}
+EXPORT_SYMBOL(security_secmark_relabel_packet);
+
+void security_secmark_refcount_inc(void)
+{
+	security_ops->secmark_refcount_inc();
+}
+EXPORT_SYMBOL(security_secmark_refcount_inc);
+
+void security_secmark_refcount_dec(void)
+{
+	security_ops->secmark_refcount_dec();
+}
+EXPORT_SYMBOL(security_secmark_refcount_dec);
+
 int security_tun_dev_create(void)
 {
 	return security_ops->tun_dev_create();

commit b0ae19811375031ae3b3fecc65b702a9c6e5cc28
Author: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Date:   Fri Oct 15 04:21:18 2010 +0900

    security: remove unused parameter from security_task_setscheduler()
    
    All security modules shouldn't change sched_param parameter of
    security_task_setscheduler().  This is not only meaningless, but also
    make a harmful result if caller pass a static variable.
    
    This patch remove policy and sched_param parameter from
    security_task_setscheduler() becuase none of security module is
    using it.
    
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 43b6463ebbfb..1cbcdfa4b015 100644
--- a/security/security.c
+++ b/security/security.c
@@ -778,10 +778,9 @@ int security_task_setrlimit(struct task_struct *p, unsigned int resource,
 	return security_ops->task_setrlimit(p, resource, new_rlim);
 }
 
-int security_task_setscheduler(struct task_struct *p,
-				int policy, struct sched_param *lp)
+int security_task_setscheduler(struct task_struct *p)
 {
-	return security_ops->task_setscheduler(p, policy, lp);
+	return security_ops->task_setscheduler(p);
 }
 
 int security_task_getscheduler(struct task_struct *p)

commit 065d78a0603cc6f8d288e96dbf761b96984b634f
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Sat Aug 28 14:58:44 2010 +0900

    LSM: Fix security_module_enable() error.
    
    We can set default LSM module to DAC (which means "enable no LSM module").
    If default LSM module was set to DAC, security_module_enable() must return 0
    unless overridden via boot time parameter.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Acked-by: Serge E. Hallyn <serge@hallyn.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index c53949f17d9e..43b6463ebbfb 100644
--- a/security/security.c
+++ b/security/security.c
@@ -89,20 +89,12 @@ __setup("security=", choose_lsm);
  * Return true if:
  *	-The passed LSM is the one chosen by user at boot time,
  *	-or the passed LSM is configured as the default and the user did not
- *	 choose an alternate LSM at boot time,
- *	-or there is no default LSM set and the user didn't specify a
- *	 specific LSM and we're the first to ask for registration permission,
- *	-or the passed LSM is currently loaded.
+ *	 choose an alternate LSM at boot time.
  * Otherwise, return false.
  */
 int __init security_module_enable(struct security_operations *ops)
 {
-	if (!*chosen_lsm)
-		strncpy(chosen_lsm, ops->name, SECURITY_NAME_MAX);
-	else if (strncmp(ops->name, chosen_lsm, SECURITY_NAME_MAX))
-		return 0;
-
-	return 1;
+	return !strcmp(ops->name, chosen_lsm);
 }
 
 /**

commit b34d8915c413acb51d837a45fb8747b61f65c020
Merge: e8a89cebdbaa f33ebbe9da2c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 10 12:07:51 2010 -0700

    Merge branch 'writable_limits' of git://decibel.fi.muni.cz/~xslaby/linux
    
    * 'writable_limits' of git://decibel.fi.muni.cz/~xslaby/linux:
      unistd: add __NR_prlimit64 syscall numbers
      rlimits: implement prlimit64 syscall
      rlimits: switch more rlimit syscalls to do_prlimit
      rlimits: redo do_setrlimit to more generic do_prlimit
      rlimits: add rlimit64 structure
      rlimits: do security check under task_lock
      rlimits: allow setrlimit to non-current tasks
      rlimits: split sys_setrlimit
      rlimits: selinux, do rlimits changes under task_lock
      rlimits: make sure ->rlim_max never grows in sys_setrlimit
      rlimits: add task_struct to update_rlimit_cpu
      rlimits: security, add task_struct to setrlimit
    
    Fix up various system call number conflicts.  We not only added fanotify
    system calls in the meantime, but asm-generic/unistd.h added a wait4
    along with a range of reserved per-architecture system calls.

commit 8c8946f509a494769a8c602b5ed189df01917d39
Merge: 5f248c9c251c 1968f5eed54c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 10 11:39:13 2010 -0700

    Merge branch 'for-linus' of git://git.infradead.org/users/eparis/notify
    
    * 'for-linus' of git://git.infradead.org/users/eparis/notify: (132 commits)
      fanotify: use both marks when possible
      fsnotify: pass both the vfsmount mark and inode mark
      fsnotify: walk the inode and vfsmount lists simultaneously
      fsnotify: rework ignored mark flushing
      fsnotify: remove global fsnotify groups lists
      fsnotify: remove group->mask
      fsnotify: remove the global masks
      fsnotify: cleanup should_send_event
      fanotify: use the mark in handler functions
      audit: use the mark in handler functions
      dnotify: use the mark in handler functions
      inotify: use the mark in handler functions
      fsnotify: send fsnotify_mark to groups in event handling functions
      fsnotify: Exchange list heads instead of moving elements
      fsnotify: srcu to protect read side of inode and vfsmount locks
      fsnotify: use an explicit flag to indicate fsnotify_destroy_mark has been called
      fsnotify: use _rcu functions for mark list traversal
      fsnotify: place marks on object in order of group memory address
      vfs/fsnotify: fsnotify_close can delay the final work in fput
      fsnotify: store struct file not struct path
      ...
    
    Fix up trivial delete/modify conflict in fs/notify/inotify/inotify.c.

commit ea0d3ab239fba48d6e998b19c28d78f765963007
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Wed Jun 2 13:24:43 2010 +0900

    LSM: Remove unused arguments from security_path_truncate().
    
    When commit be6d3e56a6b9b3a4ee44a0685e39e595073c6f0d "introduce new LSM hooks
    where vfsmount is available." was proposed, regarding security_path_truncate(),
    only "struct file *" argument (which AppArmor wanted to use) was removed.
    But length and time_attrs arguments are not used by TOMOYO nor AppArmor.
    Thus, let's remove these arguments.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Acked-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 351942a4ca0e..e8c87b8601b4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -417,12 +417,11 @@ int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
 					 new_dentry);
 }
 
-int security_path_truncate(struct path *path, loff_t length,
-			   unsigned int time_attrs)
+int security_path_truncate(struct path *path)
 {
 	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
 		return 0;
-	return security_ops->path_truncate(path, length, time_attrs);
+	return security_ops->path_truncate(path);
 }
 
 int security_path_chmod(struct dentry *dentry, struct vfsmount *mnt,

commit c4ec54b40d33f8016fea970a383cc584dd0e6019
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:34 2009 -0500

    fsnotify: new fsnotify hooks and events types for access decisions
    
    introduce a new fsnotify hook, fsnotify_perm(), which is called from the
    security code.  This hook is used to allow fsnotify groups to make access
    control decisions about events on the system.  We also must change the
    generic fsnotify function to return an error code if we intend these hooks
    to be in any way useful.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/security/security.c b/security/security.c
index 351942a4ca0e..f6ac27cd3452 100644
--- a/security/security.c
+++ b/security/security.c
@@ -620,7 +620,13 @@ void security_inode_getsecid(const struct inode *inode, u32 *secid)
 
 int security_file_permission(struct file *file, int mask)
 {
-	return security_ops->file_permission(file, mask);
+	int ret;
+
+	ret = security_ops->file_permission(file, mask);
+	if (ret)
+		return ret;
+
+	return fsnotify_perm(file, mask);
 }
 
 int security_file_alloc(struct file *file)
@@ -684,7 +690,13 @@ int security_file_receive(struct file *file)
 
 int security_dentry_open(struct file *file, const struct cred *cred)
 {
-	return security_ops->dentry_open(file, cred);
+	int ret;
+
+	ret = security_ops->dentry_open(file, cred);
+	if (ret)
+		return ret;
+
+	return fsnotify_perm(file, MAY_OPEN);
 }
 
 int security_task_create(unsigned long clone_flags)

commit 8fd00b4d7014b00448eb33cf0590815304769798
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Wed Aug 26 18:41:16 2009 +0200

    rlimits: security, add task_struct to setrlimit
    
    Add task_struct to task_setrlimit of security_operations to be able to set
    rlimit of task other than current.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Acked-by: Eric Paris <eparis@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 351942a4ca0e..aa510609a955 100644
--- a/security/security.c
+++ b/security/security.c
@@ -769,9 +769,10 @@ int security_task_getioprio(struct task_struct *p)
 	return security_ops->task_getioprio(p);
 }
 
-int security_task_setrlimit(unsigned int resource, struct rlimit *new_rlim)
+int security_task_setrlimit(struct task_struct *p, unsigned int resource,
+		struct rlimit *new_rlim)
 {
-	return security_ops->task_setrlimit(resource, new_rlim);
+	return security_ops->task_setrlimit(p, resource, new_rlim);
 }
 
 int security_task_setscheduler(struct task_struct *p,

commit c80901f2755c582e3096e6708028a8daca59e6e2
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Fri May 14 12:01:26 2010 +0900

    LSM: Add __init to fixup function.
    
    register_security() became __init function.
    So do verify() and security_fixup_ops().
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 8585019a1a59..351942a4ca0e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -23,14 +23,14 @@ static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
 /* things that live in capability.c */
-extern void security_fixup_ops(struct security_operations *ops);
+extern void __init security_fixup_ops(struct security_operations *ops);
 
 static struct security_operations *security_ops;
 static struct security_operations default_security_ops = {
 	.name	= "default",
 };
 
-static inline int verify(struct security_operations *ops)
+static inline int __init verify(struct security_operations *ops)
 {
 	/* verify the security_operations structure exists */
 	if (!ops)

commit 05b90496f2f366b9d3eea468351888ddf010782a
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:15:25 2010 -0400

    security: remove dead hook acct
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 490f77753b2d..8585019a1a59 100644
--- a/security/security.c
+++ b/security/security.c
@@ -190,11 +190,6 @@ int security_real_capable_noaudit(struct task_struct *tsk, int cap)
 	return ret;
 }
 
-int security_acct(struct file *file)
-{
-	return security_ops->acct(file);
-}
-
 int security_sysctl(struct ctl_table *table, int op)
 {
 	return security_ops->sysctl(table, op);

commit 3011a344cdcda34cdbcb40c3fb3d1a6e89954abb
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:15:19 2010 -0400

    security: remove dead hook key_session_to_parent
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 5cf9ca6890f6..490f77753b2d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1262,13 +1262,6 @@ int security_key_getsecurity(struct key *key, char **_buffer)
 	return security_ops->key_getsecurity(key, _buffer);
 }
 
-int security_key_session_to_parent(const struct cred *cred,
-				   const struct cred *parent_cred,
-				   struct key *key)
-{
-	return security_ops->key_session_to_parent(cred, parent_cred, key);
-}
-
 #endif	/* CONFIG_KEYS */
 
 #ifdef CONFIG_AUDIT

commit 6307f8fee295b364716d28686df6e69c2fee751a
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:15:13 2010 -0400

    security: remove dead hook task_setgroups
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 1e35dd669209..5cf9ca6890f6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -759,11 +759,6 @@ void security_task_getsecid(struct task_struct *p, u32 *secid)
 }
 EXPORT_SYMBOL(security_task_getsecid);
 
-int security_task_setgroups(struct group_info *group_info)
-{
-	return security_ops->task_setgroups(group_info);
-}
-
 int security_task_setnice(struct task_struct *p, int nice)
 {
 	return security_ops->task_setnice(p, nice);

commit 06ad187e280e725e356c62c3a30ddcd01564f8be
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:15:08 2010 -0400

    security: remove dead hook task_setgid
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 3900da3da87b..1e35dd669209 100644
--- a/security/security.c
+++ b/security/security.c
@@ -738,11 +738,6 @@ int security_task_fix_setuid(struct cred *new, const struct cred *old,
 	return security_ops->task_fix_setuid(new, old, flags);
 }
 
-int security_task_setgid(gid_t id0, gid_t id1, gid_t id2, int flags)
-{
-	return security_ops->task_setgid(id0, id1, id2, flags);
-}
-
 int security_task_setpgid(struct task_struct *p, pid_t pgid)
 {
 	return security_ops->task_setpgid(p, pgid);

commit 43ed8c3b4573d5f5cd314937fee63b4ab046ac5f
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:15:02 2010 -0400

    security: remove dead hook task_setuid
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 6e5942653d4f..3900da3da87b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -732,11 +732,6 @@ int security_kernel_module_request(char *kmod_name)
 	return security_ops->kernel_module_request(kmod_name);
 }
 
-int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
-{
-	return security_ops->task_setuid(id0, id1, id2, flags);
-}
-
 int security_task_fix_setuid(struct cred *new, const struct cred *old,
 			     int flags)
 {

commit 0968d0060a3c885e53d453380266c7792a55d302
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:14:56 2010 -0400

    security: remove dead hook cred_commit
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index c65b0bca05bb..6e5942653d4f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -712,11 +712,6 @@ int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
 	return security_ops->cred_prepare(new, old, gfp);
 }
 
-void security_commit_creds(struct cred *new, const struct cred *old)
-{
-	security_ops->cred_commit(new, old);
-}
-
 void security_transfer_creds(struct cred *new, const struct cred *old)
 {
 	security_ops->cred_transfer(new, old);

commit 9d5ed77dadc66a72b40419c91df942adfa55a102
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:14:50 2010 -0400

    security: remove dead hook inode_delete
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 5223fa408271..c65b0bca05bb 100644
--- a/security/security.c
+++ b/security/security.c
@@ -550,13 +550,6 @@ int security_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
 	return security_ops->inode_getattr(mnt, dentry);
 }
 
-void security_inode_delete(struct inode *inode)
-{
-	if (unlikely(IS_PRIVATE(inode)))
-		return;
-	security_ops->inode_delete(inode);
-}
-
 int security_inode_setxattr(struct dentry *dentry, const char *name,
 			    const void *value, size_t size, int flags)
 {

commit 91a9420f5826db482030c21eca8c507271bbc441
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:14:45 2010 -0400

    security: remove dead hook sb_post_pivotroot
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 6a8e5411d7a0..5223fa408271 100644
--- a/security/security.c
+++ b/security/security.c
@@ -316,11 +316,6 @@ int security_sb_pivotroot(struct path *old_path, struct path *new_path)
 	return security_ops->sb_pivotroot(old_path, new_path);
 }
 
-void security_sb_post_pivotroot(struct path *old_path, struct path *new_path)
-{
-	security_ops->sb_post_pivotroot(old_path, new_path);
-}
-
 int security_sb_set_mnt_opts(struct super_block *sb,
 				struct security_mnt_opts *opts)
 {

commit 3db291017753e539af64c8bab373785f34e43ed2
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:14:39 2010 -0400

    security: remove dead hook sb_post_addmount
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index d9538d98736b..6a8e5411d7a0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -311,11 +311,6 @@ int security_sb_umount(struct vfsmount *mnt, int flags)
 	return security_ops->sb_umount(mnt, flags);
 }
 
-void security_sb_post_addmount(struct vfsmount *mnt, struct path *mountpoint)
-{
-	security_ops->sb_post_addmount(mnt, mountpoint);
-}
-
 int security_sb_pivotroot(struct path *old_path, struct path *new_path)
 {
 	return security_ops->sb_pivotroot(old_path, new_path);

commit 82dab10453d65ad9ca551de5b8925673ca05c7e9
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:14:33 2010 -0400

    security: remove dead hook sb_post_remount
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index c1341fbe98ca..d9538d98736b 100644
--- a/security/security.c
+++ b/security/security.c
@@ -311,11 +311,6 @@ int security_sb_umount(struct vfsmount *mnt, int flags)
 	return security_ops->sb_umount(mnt, flags);
 }
 
-void security_sb_post_remount(struct vfsmount *mnt, unsigned long flags, void *data)
-{
-	security_ops->sb_post_remount(mnt, flags, data);
-}
-
 void security_sb_post_addmount(struct vfsmount *mnt, struct path *mountpoint)
 {
 	security_ops->sb_post_addmount(mnt, mountpoint);

commit 4b61d12c84293ac061909f27f567c1905e4d90e3
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:14:27 2010 -0400

    security: remove dead hook sb_umount_busy
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 591c25fd430f..c1341fbe98ca 100644
--- a/security/security.c
+++ b/security/security.c
@@ -311,11 +311,6 @@ int security_sb_umount(struct vfsmount *mnt, int flags)
 	return security_ops->sb_umount(mnt, flags);
 }
 
-void security_sb_umount_busy(struct vfsmount *mnt)
-{
-	security_ops->sb_umount_busy(mnt);
-}
-
 void security_sb_post_remount(struct vfsmount *mnt, unsigned long flags, void *data)
 {
 	security_ops->sb_post_remount(mnt, flags, data);

commit 231923bd0e06cba69f7c2028f4a68602b8d22160
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:14:21 2010 -0400

    security: remove dead hook sb_umount_close
    
    Unused hook.  Remove.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index a0bee70ed4b6..591c25fd430f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -311,11 +311,6 @@ int security_sb_umount(struct vfsmount *mnt, int flags)
 	return security_ops->sb_umount(mnt, flags);
 }
 
-void security_sb_umount_close(struct vfsmount *mnt)
-{
-	security_ops->sb_umount_close(mnt);
-}
-
 void security_sb_umount_busy(struct vfsmount *mnt)
 {
 	security_ops->sb_umount_busy(mnt);

commit 353633100d8d684ac0acae4ce93fb833f92881f4
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Apr 7 15:14:15 2010 -0400

    security: remove sb_check_sb hooks
    
    Unused hook.  Remove it.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index b98334b0a576..a0bee70ed4b6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -306,11 +306,6 @@ int security_sb_mount(char *dev_name, struct path *path,
 	return security_ops->sb_mount(dev_name, path, type, flags, data);
 }
 
-int security_sb_check_sb(struct vfsmount *mnt, struct path *path)
-{
-	return security_ops->sb_check_sb(mnt, path);
-}
-
 int security_sb_umount(struct vfsmount *mnt, int flags)
 {
 	return security_ops->sb_umount(mnt, flags);

commit c43a7523470dc2d9947fa114a0b54317975d4c04
Merge: eaa5eec73963 634a539e16bd
Author: James Morris <jmorris@namei.org>
Date:   Tue Mar 9 12:46:47 2010 +1100

    Merge branch 'next-queue' into next

commit c1e992b99603a84d7debb188542b64f2d9232c07
Author: wzt.wzt@gmail.com <wzt.wzt@gmail.com>
Date:   Fri Feb 26 22:49:55 2010 +0800

    Security: Add __init to register_security to disable load a security module on runtime
    
    LSM framework doesn't allow to load a security module on runtime, it must be loaded on boot time.
    but in security/security.c:
    int register_security(struct security_operations *ops)
    {
            ...
            if (security_ops != &default_security_ops)
                    return -EAGAIN;
            ...
    }
    if security_ops == &default_security_ops, it can access to register a security module. If selinux is enabled,
    other security modules can't register, but if selinux is disabled on boot time, the security_ops was set to
    default_security_ops, LSM allows other kernel modules to use register_security() to register a not trust
    security module. For example:
    
    disable selinux on boot time(selinux=0).
    
    #include <linux/kernel.h>
    #include <linux/module.h>
    #include <linux/init.h>
    #include <linux/version.h>
    #include <linux/string.h>
    #include <linux/list.h>
    #include <linux/security.h>
    
    MODULE_LICENSE("GPL");
    MODULE_AUTHOR("wzt");
    
    extern int register_security(struct security_operations *ops);
    int (*new_register_security)(struct security_operations *ops);
    
    int rootkit_bprm_check_security(struct linux_binprm *bprm)
    {
            return 0;
    }
    
    struct security_operations rootkit_ops = {
                    .bprm_check_security = rootkit_bprm_check_security,
    };
    
    static int rootkit_init(void)
    {
            printk("Load LSM rootkit module.\n");
    
            /* cat /proc/kallsyms | grep register_security */
            new_register_security = 0xc0756689;
            if (new_register_security(&rootkit_ops)) {
                    printk("Can't register rootkit module.\n");
                    return 0;
            }
            printk("Register rootkit module ok.\n");
    
            return 0;
    }
    
    static void rootkit_exit(void)
    {
            printk("Unload LSM rootkit module.\n");
    }
    
    module_init(rootkit_init);
    module_exit(rootkit_exit);
    
    Signed-off-by: Zhitong Wang <zhitong.wangzt@alibaba-inc.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 122b748d0f4c..7da630a8c065 100644
--- a/security/security.c
+++ b/security/security.c
@@ -110,7 +110,7 @@ int __init security_module_enable(struct security_operations *ops)
  * If there is already a security module registered with the kernel,
  * an error will be returned.  Otherwise %0 is returned on success.
  */
-int register_security(struct security_operations *ops)
+int __init register_security(struct security_operations *ops)
 {
 	if (verify(ops)) {
 		printk(KERN_DEBUG "%s could not verify "

commit b4ccebdd37ff70d349321a198f416ba737a5e833
Merge: 30ff056c42c6 ef57471a73b6
Author: James Morris <jmorris@namei.org>
Date:   Mon Mar 1 09:36:31 2010 +1100

    Merge branch 'next' into for-linus

commit 189b3b1c89761054fee3438f063d7f257306e2d8
Author: wzt.wzt@gmail.com <wzt.wzt@gmail.com>
Date:   Tue Feb 23 23:15:28 2010 +0800

    Security: add static to security_ops and default_security_ops variable
    
    Enhance the security framework to support resetting the active security
    module. This eliminates the need for direct use of the security_ops and
    default_security_ops variables outside of security.c, so make security_ops
    and default_security_ops static. Also remove the secondary_ops variable as
    a cleanup since there is no use for that. secondary_ops was originally used by
    SELinux to call the "secondary" security module (capability or dummy),
    but that was replaced by direct calls to capability and the only
    remaining use is to save and restore the original security ops pointer
    value if SELinux is disabled by early userspace based on /etc/selinux/config.
    Further, if we support this directly in the security framework, then we can
    just use &default_security_ops for this purpose since that is now available.
    
    Signed-off-by: Zhitong Wang <zhitong.wangzt@alibaba-inc.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 971092c06f31..edae56b78771 100644
--- a/security/security.c
+++ b/security/security.c
@@ -23,10 +23,12 @@ static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
 	CONFIG_DEFAULT_SECURITY;
 
 /* things that live in capability.c */
-extern struct security_operations default_security_ops;
 extern void security_fixup_ops(struct security_operations *ops);
 
-struct security_operations *security_ops;	/* Initialized to NULL */
+static struct security_operations *security_ops;
+static struct security_operations default_security_ops = {
+	.name	= "default",
+};
 
 static inline int verify(struct security_operations *ops)
 {
@@ -63,6 +65,11 @@ int __init security_init(void)
 	return 0;
 }
 
+void reset_security_ops(void)
+{
+	security_ops = &default_security_ops;
+}
+
 /* Save user chosen LSM */
 static int __init choose_lsm(char *str)
 {

commit 89068c576bf324ef6fbd50dfc745148f7def202c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 7 03:07:29 2010 -0500

    Take ima_file_free() to proper place.
    
    Hooks: Just Say No.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 24e060be9fa5..122b748d0f4c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -666,8 +666,6 @@ int security_file_alloc(struct file *file)
 void security_file_free(struct file *file)
 {
 	security_ops->file_free_security(file);
-	if (file->f_dentry)
-		ima_file_free(file);
 }
 
 int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)

commit 002345925e6c45861f60db6f4fc6236713fd8847
Author: Kees Cook <kees.cook@canonical.com>
Date:   Wed Feb 3 15:36:43 2010 -0800

    syslog: distinguish between /proc/kmsg and syscalls
    
    This allows the LSM to distinguish between syslog functions originating
    from /proc/kmsg access and direct syscalls.  By default, the commoncaps
    will now no longer require CAP_SYS_ADMIN to read an opened /proc/kmsg
    file descriptor.  For example the kernel syslog reader can now drop
    privileges after opening /proc/kmsg, instead of staying privileged with
    CAP_SYS_ADMIN.  MAC systems that implement security_syslog have unchanged
    behavior.
    
    Signed-off-by: Kees Cook <kees.cook@canonical.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Acked-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 440afe5eb54c..971092c06f31 100644
--- a/security/security.c
+++ b/security/security.c
@@ -203,9 +203,9 @@ int security_quota_on(struct dentry *dentry)
 	return security_ops->quota_on(dentry);
 }
 
-int security_syslog(int type)
+int security_syslog(int type, bool from_file)
 {
-	return security_ops->syslog(type);
+	return security_ops->syslog(type, from_file);
 }
 
 int security_settime(struct timespec *ts, struct timezone *tz)

commit 8d9525048c74786205b99f3fcd05a839721edfb7
Author: James Morris <jmorris@namei.org>
Date:   Thu Jan 14 09:33:28 2010 +1100

    security: correct error returns for get/set security with private inodes
    
    Currently, the getsecurity and setsecurity operations return zero for
    kernel private inodes, where xattrs are not available directly to
    userspace.
    
    This confuses some applications, and does not conform to the
    man page for getxattr(2) etc., which state that these syscalls
    should return ENOTSUP if xattrs are not supported or disabled.
    
    Note that in the listsecurity case, we still need to return zero
    as we don't know which other xattr handlers may be active.
    
    For discussion of userland confusion, see:
    http://www.mail-archive.com/bug-coreutils@gnu.org/msg17988.html
    
    This patch corrects the error returns so that ENOTSUP is reported
    to userspace as required.
    
    Signed-off-by: James Morris <jmorris@namei.org>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Serge Hallyn <serue@us.ibm.com>

diff --git a/security/security.c b/security/security.c
index f2d8aa949323..440afe5eb54c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -630,14 +630,14 @@ int security_inode_killpriv(struct dentry *dentry)
 int security_inode_getsecurity(const struct inode *inode, const char *name, void **buffer, bool alloc)
 {
 	if (unlikely(IS_PRIVATE(inode)))
-		return 0;
+		return -EOPNOTSUPP;
 	return security_ops->inode_getsecurity(inode, name, buffer, alloc);
 }
 
 int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)
 {
 	if (unlikely(IS_PRIVATE(inode)))
-		return 0;
+		return -EOPNOTSUPP;
 	return security_ops->inode_setsecurity(inode, name, value, size, flags);
 }
 

commit 5d0901a3a0c39c97ca504f73d24030f63cfc9fa2
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Thu Nov 26 15:24:49 2009 +0900

    LSM: Rename security_path_ functions argument names.
    
    include/linux/security.h and security/capability.c are using "struct path *dir"
    but security/security.c was using "struct path *path" by error.
    This patch renames "struct path *path" to "struct path *dir".
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 24e060be9fa5..f2d8aa949323 100644
--- a/security/security.c
+++ b/security/security.c
@@ -389,42 +389,42 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 EXPORT_SYMBOL(security_inode_init_security);
 
 #ifdef CONFIG_SECURITY_PATH
-int security_path_mknod(struct path *path, struct dentry *dentry, int mode,
+int security_path_mknod(struct path *dir, struct dentry *dentry, int mode,
 			unsigned int dev)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
 		return 0;
-	return security_ops->path_mknod(path, dentry, mode, dev);
+	return security_ops->path_mknod(dir, dentry, mode, dev);
 }
 EXPORT_SYMBOL(security_path_mknod);
 
-int security_path_mkdir(struct path *path, struct dentry *dentry, int mode)
+int security_path_mkdir(struct path *dir, struct dentry *dentry, int mode)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
 		return 0;
-	return security_ops->path_mkdir(path, dentry, mode);
+	return security_ops->path_mkdir(dir, dentry, mode);
 }
 
-int security_path_rmdir(struct path *path, struct dentry *dentry)
+int security_path_rmdir(struct path *dir, struct dentry *dentry)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
 		return 0;
-	return security_ops->path_rmdir(path, dentry);
+	return security_ops->path_rmdir(dir, dentry);
 }
 
-int security_path_unlink(struct path *path, struct dentry *dentry)
+int security_path_unlink(struct path *dir, struct dentry *dentry)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
 		return 0;
-	return security_ops->path_unlink(path, dentry);
+	return security_ops->path_unlink(dir, dentry);
 }
 
-int security_path_symlink(struct path *path, struct dentry *dentry,
+int security_path_symlink(struct path *dir, struct dentry *dentry,
 			  const char *old_name)
 {
-	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
 		return 0;
-	return security_ops->path_symlink(path, dentry, old_name);
+	return security_ops->path_symlink(dir, dentry, old_name);
 }
 
 int security_path_link(struct dentry *old_dentry, struct path *new_dir,

commit dd8dbf2e6880e30c00b18600c962d0cb5a03c555
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Nov 3 16:35:32 2009 +1100

    security: report the module name to security_module_request
    
    For SELinux to do better filtering in userspace we send the name of the
    module along with the AVC denial when a program is denied module_request.
    
    Example output:
    
    type=SYSCALL msg=audit(11/03/2009 10:59:43.510:9) : arch=x86_64 syscall=write success=yes exit=2 a0=3 a1=7fc28c0d56c0 a2=2 a3=7fffca0d7440 items=0 ppid=1727 pid=1729 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=rpc.nfsd exe=/usr/sbin/rpc.nfsd subj=system_u:system_r:nfsd_t:s0 key=(null)
    type=AVC msg=audit(11/03/2009 10:59:43.510:9) : avc:  denied  { module_request } for  pid=1729 comm=rpc.nfsd kmod="net-pf-10" scontext=system_u:system_r:nfsd_t:s0 tcontext=system_u:system_r:kernel_t:s0 tclass=system
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index aad71b2ca195..24e060be9fa5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -764,9 +764,9 @@ int security_kernel_create_files_as(struct cred *new, struct inode *inode)
 	return security_ops->kernel_create_files_as(new, inode);
 }
 
-int security_kernel_module_request(void)
+int security_kernel_module_request(char *kmod_name)
 {
-	return security_ops->kernel_module_request();
+	return security_ops->kernel_module_request(kmod_name);
 }
 
 int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)

commit 6e65f92ff0d6f18580737321718d09035085a3fb
Author: John Johansen <john.johansen@canonical.com>
Date:   Thu Nov 5 17:03:20 2009 -0800

    Config option to set a default LSM
    
    The LSM currently requires setting a kernel parameter at boot to select
    a specific LSM.  This adds a config option that allows specifying a default
    LSM that is used unless overridden with the security= kernel parameter.
    If the the config option is not set the current behavior of first LSM
    to register is used.
    
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 684d5ee655da..aad71b2ca195 100644
--- a/security/security.c
+++ b/security/security.c
@@ -19,7 +19,8 @@
 #include <linux/ima.h>
 
 /* Boot-time LSM user choice */
-static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1];
+static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
+	CONFIG_DEFAULT_SECURITY;
 
 /* things that live in capability.c */
 extern struct security_operations default_security_ops;
@@ -80,8 +81,10 @@ __setup("security=", choose_lsm);
  *
  * Return true if:
  *	-The passed LSM is the one chosen by user at boot time,
- *	-or user didn't specify a specific LSM and we're the first to ask
- *	 for registration permission,
+ *	-or the passed LSM is configured as the default and the user did not
+ *	 choose an alternate LSM at boot time,
+ *	-or there is no default LSM set and the user didn't specify a
+ *	 specific LSM and we're the first to ask for registration permission,
  *	-or the passed LSM is currently loaded.
  * Otherwise, return false.
  */

commit 6c21a7fb492bf7e2c4985937082ce58ddeca84bd
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Oct 22 17:30:13 2009 -0400

    LSM: imbed ima calls in the security hooks
    
    Based on discussions on LKML and LSM, where there are consecutive
    security_ and ima_ calls in the vfs layer, move the ima_ calls to
    the existing security_ hooks.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 279757314a05..684d5ee655da 100644
--- a/security/security.c
+++ b/security/security.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/security.h>
+#include <linux/ima.h>
 
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1];
@@ -235,7 +236,12 @@ int security_bprm_set_creds(struct linux_binprm *bprm)
 
 int security_bprm_check(struct linux_binprm *bprm)
 {
-	return security_ops->bprm_check_security(bprm);
+	int ret;
+
+	ret = security_ops->bprm_check_security(bprm);
+	if (ret)
+		return ret;
+	return ima_bprm_check(bprm);
 }
 
 void security_bprm_committing_creds(struct linux_binprm *bprm)
@@ -352,12 +358,21 @@ EXPORT_SYMBOL(security_sb_parse_opts_str);
 
 int security_inode_alloc(struct inode *inode)
 {
+	int ret;
+
 	inode->i_security = NULL;
-	return security_ops->inode_alloc_security(inode);
+	ret =  security_ops->inode_alloc_security(inode);
+	if (ret)
+		return ret;
+	ret = ima_inode_alloc(inode);
+	if (ret)
+		security_inode_free(inode);
+	return ret;
 }
 
 void security_inode_free(struct inode *inode)
 {
+	ima_inode_free(inode);
 	security_ops->inode_free_security(inode);
 }
 
@@ -648,6 +663,8 @@ int security_file_alloc(struct file *file)
 void security_file_free(struct file *file)
 {
 	security_ops->file_free_security(file);
+	if (file->f_dentry)
+		ima_file_free(file);
 }
 
 int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
@@ -659,7 +676,12 @@ int security_file_mmap(struct file *file, unsigned long reqprot,
 			unsigned long prot, unsigned long flags,
 			unsigned long addr, unsigned long addr_only)
 {
-	return security_ops->file_mmap(file, reqprot, prot, flags, addr, addr_only);
+	int ret;
+
+	ret = security_ops->file_mmap(file, reqprot, prot, flags, addr, addr_only);
+	if (ret)
+		return ret;
+	return ima_file_mmap(file, prot);
 }
 
 int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,

commit 8b8efb44033c7e86b3dc76f825c693ec92ae30e9
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Sun Oct 4 21:49:48 2009 +0900

    LSM: Add security_path_chroot().
    
    This patch allows pathname based LSM modules to check chroot() operations.
    
    This hook is used by TOMOYO.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 5259270e558f..279757314a05 100644
--- a/security/security.c
+++ b/security/security.c
@@ -449,6 +449,11 @@ int security_path_chown(struct path *path, uid_t uid, gid_t gid)
 		return 0;
 	return security_ops->path_chown(path, uid, gid);
 }
+
+int security_path_chroot(struct path *path)
+{
+	return security_ops->path_chroot(path);
+}
 #endif
 
 int security_inode_create(struct inode *dir, struct dentry *dentry, int mode)

commit 89eda06837094ce9f34fae269b8773fcfd70f046
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Sun Oct 4 21:49:47 2009 +0900

    LSM: Add security_path_chmod() and security_path_chown().
    
    This patch allows pathname based LSM modules to check chmod()/chown()
    operations. Since notify_change() does not receive "struct vfsmount *",
    we add security_path_chmod() and security_path_chown() to the caller of
    notify_change().
    
    These hooks are used by TOMOYO.
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index c4c673240c1c..5259270e558f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -434,6 +434,21 @@ int security_path_truncate(struct path *path, loff_t length,
 		return 0;
 	return security_ops->path_truncate(path, length, time_attrs);
 }
+
+int security_path_chmod(struct dentry *dentry, struct vfsmount *mnt,
+			mode_t mode)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->path_chmod(dentry, mnt, mode);
+}
+
+int security_path_chown(struct path *path, uid_t uid, gid_t gid)
+{
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+		return 0;
+	return security_ops->path_chown(path, uid, gid);
+}
 #endif
 
 int security_inode_create(struct inode *dir, struct dentry *dentry, int mode)

commit 1ee65e37e904b959c24404139f5752edc66319d5
Author: David P. Quigley <dpquigl@tycho.nsa.gov>
Date:   Thu Sep 3 14:25:57 2009 -0400

    LSM/SELinux: inode_{get,set,notify}secctx hooks to access LSM security context information.
    
    This patch introduces three new hooks. The inode_getsecctx hook is used to get
    all relevant information from an LSM about an inode. The inode_setsecctx is
    used to set both the in-core and on-disk state for the inode based on a context
    derived from inode_getsecctx.The final hook inode_notifysecctx will notify the
    LSM of a change for the in-core state of the inode in question. These hooks are
    for use in the labeled NFS code and addresses concerns of how to set security
    on an inode in a multi-xattr LSM. For historical reasons Stephen Smalley's
    explanation of the reason for these hooks is pasted below.
    
    Quote Stephen Smalley
    
    inode_setsecctx:  Change the security context of an inode.  Updates the
    in core security context managed by the security module and invokes the
    fs code as needed (via __vfs_setxattr_noperm) to update any backing
    xattrs that represent the context.  Example usage:  NFS server invokes
    this hook to change the security context in its incore inode and on the
    backing file system to a value provided by the client on a SETATTR
    operation.
    
    inode_notifysecctx:  Notify the security module of what the security
    context of an inode should be.  Initializes the incore security context
    managed by the security module for this inode.  Example usage:  NFS
    client invokes this hook to initialize the security context in its
    incore inode to the value provided by the server for the file when the
    server returned the file's attributes to the client.
    
    Signed-off-by: David P. Quigley <dpquigl@tycho.nsa.gov>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index d8b727637f02..c4c673240c1c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -974,6 +974,24 @@ void security_release_secctx(char *secdata, u32 seclen)
 }
 EXPORT_SYMBOL(security_release_secctx);
 
+int security_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)
+{
+	return security_ops->inode_notifysecctx(inode, ctx, ctxlen);
+}
+EXPORT_SYMBOL(security_inode_notifysecctx);
+
+int security_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)
+{
+	return security_ops->inode_setsecctx(dentry, ctx, ctxlen);
+}
+EXPORT_SYMBOL(security_inode_setsecctx);
+
+int security_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)
+{
+	return security_ops->inode_getsecctx(inode, ctx, ctxlen);
+}
+EXPORT_SYMBOL(security_inode_getsecctx);
+
 #ifdef CONFIG_SECURITY_NETWORK
 
 int security_unix_stream_connect(struct socket *sock, struct socket *other,

commit ee18d64c1f632043a02e6f5ba5e045bb26a5465f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:14:21 2009 +0100

    KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]
    
    Add a keyctl to install a process's session keyring onto its parent.  This
    replaces the parent's session keyring.  Because the COW credential code does
    not permit one process to change another process's credentials directly, the
    change is deferred until userspace next starts executing again.  Normally this
    will be after a wait*() syscall.
    
    To support this, three new security hooks have been provided:
    cred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in
    the blank security creds and key_session_to_parent() - which asks the LSM if
    the process may replace its parent's session keyring.
    
    The replacement may only happen if the process has the same ownership details
    as its parent, and the process has LINK permission on the session keyring, and
    the session keyring is owned by the process, and the LSM permits it.
    
    Note that this requires alteration to each architecture's notify_resume path.
    This has been done for all arches barring blackfin, m68k* and xtensa, all of
    which need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the
    replacement to be performed at the point the parent process resumes userspace
    execution.
    
    This allows the userspace AFS pioctl emulation to fully emulate newpag() and
    the VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to
    alter the parent process's PAG membership.  However, since kAFS doesn't use
    PAGs per se, but rather dumps the keys into the session keyring, the session
    keyring of the parent must be replaced if, for example, VIOCSETTOK is passed
    the newpag flag.
    
    This can be tested with the following program:
    
            #include <stdio.h>
            #include <stdlib.h>
            #include <keyutils.h>
    
            #define KEYCTL_SESSION_TO_PARENT        18
    
            #define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)
    
            int main(int argc, char **argv)
            {
                    key_serial_t keyring, key;
                    long ret;
    
                    keyring = keyctl_join_session_keyring(argv[1]);
                    OSERROR(keyring, "keyctl_join_session_keyring");
    
                    key = add_key("user", "a", "b", 1, keyring);
                    OSERROR(key, "add_key");
    
                    ret = keyctl(KEYCTL_SESSION_TO_PARENT);
                    OSERROR(ret, "KEYCTL_SESSION_TO_PARENT");
    
                    return 0;
            }
    
    Compiled and linked with -lkeyutils, you should see something like:
    
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            355907932 --alswrv   4043    -1   \_ keyring: _uid.4043
            [dhowells@andromeda ~]$ /tmp/newpag
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            1055658746 --alswrv   4043  4043   \_ user: a
            [dhowells@andromeda ~]$ /tmp/newpag hello
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: hello
            340417692 --alswrv   4043  4043   \_ user: a
    
    Where the test program creates a new session keyring, sticks a user key named
    'a' into it and then installs it on its parent.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index f88eaf6b14cc..d8b727637f02 100644
--- a/security/security.c
+++ b/security/security.c
@@ -684,6 +684,11 @@ int security_task_create(unsigned long clone_flags)
 	return security_ops->task_create(clone_flags);
 }
 
+int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+{
+	return security_ops->cred_alloc_blank(cred, gfp);
+}
+
 void security_cred_free(struct cred *cred)
 {
 	security_ops->cred_free(cred);
@@ -699,6 +704,11 @@ void security_commit_creds(struct cred *new, const struct cred *old)
 	security_ops->cred_commit(new, old);
 }
 
+void security_transfer_creds(struct cred *new, const struct cred *old)
+{
+	security_ops->cred_transfer(new, old);
+}
+
 int security_kernel_act_as(struct cred *new, u32 secid)
 {
 	return security_ops->kernel_act_as(new, secid);
@@ -1241,6 +1251,13 @@ int security_key_getsecurity(struct key *key, char **_buffer)
 	return security_ops->key_getsecurity(key, _buffer);
 }
 
+int security_key_session_to_parent(const struct cred *cred,
+				   const struct cred *parent_cred,
+				   struct key *key)
+{
+	return security_ops->key_session_to_parent(cred, parent_cred, key);
+}
+
 #endif	/* CONFIG_KEYS */
 
 #ifdef CONFIG_AUDIT

commit 2b980dbd77d229eb60588802162c9659726b11f4
Author: Paul Moore <paul.moore@hp.com>
Date:   Fri Aug 28 18:12:43 2009 -0400

    lsm: Add hooks to the TUN driver
    
    The TUN driver lacks any LSM hooks which makes it difficult for LSM modules,
    such as SELinux, to enforce access controls on network traffic generated by
    TUN users; this is particularly problematic for virtualization apps such as
    QEMU and KVM.  This patch adds three new LSM hooks designed to control the
    creation and attachment of TUN devices, the hooks are:
    
     * security_tun_dev_create()
       Provides access control for the creation of new TUN devices
    
     * security_tun_dev_post_create()
       Provides the ability to create the necessary socket LSM state for newly
       created TUN devices
    
     * security_tun_dev_attach()
       Provides access control for attaching to existing, persistent TUN devices
       and the ability to update the TUN device's socket LSM state as necessary
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Acked-by: Eric Paris <eparis@parisplace.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 0e993f42ce3d..f88eaf6b14cc 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1117,6 +1117,24 @@ void security_inet_conn_established(struct sock *sk,
 	security_ops->inet_conn_established(sk, skb);
 }
 
+int security_tun_dev_create(void)
+{
+	return security_ops->tun_dev_create();
+}
+EXPORT_SYMBOL(security_tun_dev_create);
+
+void security_tun_dev_post_create(struct sock *sk)
+{
+	return security_ops->tun_dev_post_create(sk);
+}
+EXPORT_SYMBOL(security_tun_dev_post_create);
+
+int security_tun_dev_attach(struct sock *sk)
+{
+	return security_ops->tun_dev_attach(sk);
+}
+EXPORT_SYMBOL(security_tun_dev_attach);
+
 #endif	/* CONFIG_SECURITY_NETWORK */
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM

commit 9188499cdb117d86a1ea6b04374095b098d56936
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Aug 13 09:44:57 2009 -0400

    security: introducing security_request_module
    
    Calling request_module() will trigger a userspace upcall which will load a
    new module into the kernel.  This can be a dangerous event if the process
    able to trigger request_module() is able to control either the modprobe
    binary or the module binary.  This patch adds a new security hook to
    request_module() which can be used by an LSM to control a processes ability
    to call request_module().
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 4501c5e1f988..0e993f42ce3d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -709,6 +709,11 @@ int security_kernel_create_files_as(struct cred *new, struct inode *inode)
 	return security_ops->kernel_create_files_as(new, inode);
 }
 
+int security_kernel_module_request(void)
+{
+	return security_ops->kernel_module_request();
+}
+
 int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
 {
 	return security_ops->task_setuid(id0, id1, id2, flags);

commit 9e48858f7d36a6a3849f1d1b40c3bf5624b4ee7c
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu May 7 19:26:19 2009 +1000

    security: rename ptrace_may_access => ptrace_access_check
    
    The ->ptrace_may_access() methods are named confusingly - the real
    ptrace_may_access() returns a bool, while these security checks have
    a retval convention.
    
    Rename it to ptrace_access_check, to reduce the confusion factor.
    
    [ Impact: cleanup, no code changed ]
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index dc7674fbfc7a..4501c5e1f988 100644
--- a/security/security.c
+++ b/security/security.c
@@ -124,9 +124,9 @@ int register_security(struct security_operations *ops)
 
 /* Security operations */
 
-int security_ptrace_may_access(struct task_struct *child, unsigned int mode)
+int security_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
-	return security_ops->ptrace_may_access(child, mode);
+	return security_ops->ptrace_access_check(child, mode);
 }
 
 int security_ptrace_traceme(struct task_struct *parent)

commit e0a94c2a63f2644826069044649669b5e7ca75d3
Author: Christoph Lameter <cl@linux-foundation.org>
Date:   Wed Jun 3 16:04:31 2009 -0400

    security: use mmap_min_addr indepedently of security models
    
    This patch removes the dependency of mmap_min_addr on CONFIG_SECURITY.
    It also sets a default mmap_min_addr of 4096.
    
    mmapping of addresses below 4096 will only be possible for processes
    with CAP_SYS_RAWIO.
    
    Signed-off-by: Christoph Lameter <cl@linux-foundation.org>
    Acked-by: Eric Paris <eparis@redhat.com>
    Looks-ok-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 5284255c5cdf..dc7674fbfc7a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -26,9 +26,6 @@ extern void security_fixup_ops(struct security_operations *ops);
 
 struct security_operations *security_ops;	/* Initialized to NULL */
 
-/* amount of vm to protect from userspace access */
-unsigned long mmap_min_addr = CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR;
-
 static inline int verify(struct security_operations *ops)
 {
 	/* verify the security_operations structure exists */

commit 800a964787faef3509d194fa33268628c3d1daa9
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 3 16:42:40 2009 +0100

    CacheFiles: Export things for CacheFiles
    
    Export a number of functions for CacheFiles's use.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Steve Dickson <steved@redhat.com>
    Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Tested-by: Daire Byrne <Daire.Byrne@framestore.com>

diff --git a/security/security.c b/security/security.c
index 206e53844d2f..5284255c5cdf 100644
--- a/security/security.c
+++ b/security/security.c
@@ -445,6 +445,7 @@ int security_inode_create(struct inode *dir, struct dentry *dentry, int mode)
 		return 0;
 	return security_ops->inode_create(dir, dentry, mode);
 }
+EXPORT_SYMBOL_GPL(security_inode_create);
 
 int security_inode_link(struct dentry *old_dentry, struct inode *dir,
 			 struct dentry *new_dentry)
@@ -475,6 +476,7 @@ int security_inode_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 		return 0;
 	return security_ops->inode_mkdir(dir, dentry, mode);
 }
+EXPORT_SYMBOL_GPL(security_inode_mkdir);
 
 int security_inode_rmdir(struct inode *dir, struct dentry *dentry)
 {

commit 8651d5c0b1f874c5b8307ae2b858bc40f9f02482
Author: Paul Moore <paul.moore@hp.com>
Date:   Fri Mar 27 17:10:48 2009 -0400

    lsm: Remove the socket_post_accept() hook
    
    The socket_post_accept() hook is not currently used by any in-tree modules
    and its existence continues to cause problems by confusing people about
    what can be safely accomplished using this hook.  If a legitimate need for
    this hook arises in the future it can always be reintroduced.
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index c3586c0d97e2..206e53844d2f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1007,11 +1007,6 @@ int security_socket_accept(struct socket *sock, struct socket *newsock)
 	return security_ops->socket_accept(sock, newsock);
 }
 
-void security_socket_post_accept(struct socket *sock, struct socket *newsock)
-{
-	security_ops->socket_post_accept(sock, newsock);
-}
-
 int security_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size)
 {
 	return security_ops->socket_sendmsg(sock, msg, size);

commit ac8cc0fa5395fe2278e305a4cbed48e90d88d878
Merge: 238c6d54830c 3699c53c485b
Author: James Morris <jmorris@namei.org>
Date:   Wed Jan 7 09:58:22 2009 +1100

    Merge branch 'next' into for-linus

commit 3699c53c485bf0168e6500d0ed18bf931584dd7c
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 6 22:27:01 2009 +0000

    CRED: Fix regression in cap_capable() as shown up by sys_faccessat() [ver #3]
    
    Fix a regression in cap_capable() due to:
    
            commit 3b11a1decef07c19443d24ae926982bc8ec9f4c0
            Author: David Howells <dhowells@redhat.com>
            Date:   Fri Nov 14 10:39:26 2008 +1100
    
                CRED: Differentiate objective and effective subjective credentials on a task
    
    The problem is that the above patch allows a process to have two sets of
    credentials, and for the most part uses the subjective credentials when
    accessing current's creds.
    
    There is, however, one exception: cap_capable(), and thus capable(), uses the
    real/objective credentials of the target task, whether or not it is the current
    task.
    
    Ordinarily this doesn't matter, since usually the two cred pointers in current
    point to the same set of creds.  However, sys_faccessat() makes use of this
    facility to override the credentials of the calling process to make its test,
    without affecting the creds as seen from other processes.
    
    One of the things sys_faccessat() does is to make an adjustment to the
    effective capabilities mask, which cap_capable(), as it stands, then ignores.
    
    The affected capability check is in generic_permission():
    
            if (!(mask & MAY_EXEC) || execute_ok(inode))
                    if (capable(CAP_DAC_OVERRIDE))
                            return 0;
    
    This change passes the set of credentials to be tested down into the commoncap
    and SELinux code.  The security functions called by capable() and
    has_capability() select the appropriate set of credentials from the process
    being checked.
    
    This can be tested by compiling the following program from the XFS testsuite:
    
    /*
     *  t_access_root.c - trivial test program to show permission bug.
     *
     *  Written by Michael Kerrisk - copyright ownership not pursued.
     *  Sourced from: http://linux.derkeiler.com/Mailing-Lists/Kernel/2003-10/6030.html
     */
    #include <limits.h>
    #include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    
    #define UID 500
    #define GID 100
    #define PERM 0
    #define TESTPATH "/tmp/t_access"
    
    static void
    errExit(char *msg)
    {
        perror(msg);
        exit(EXIT_FAILURE);
    } /* errExit */
    
    static void
    accessTest(char *file, int mask, char *mstr)
    {
        printf("access(%s, %s) returns %d\n", file, mstr, access(file, mask));
    } /* accessTest */
    
    int
    main(int argc, char *argv[])
    {
        int fd, perm, uid, gid;
        char *testpath;
        char cmd[PATH_MAX + 20];
    
        testpath = (argc > 1) ? argv[1] : TESTPATH;
        perm = (argc > 2) ? strtoul(argv[2], NULL, 8) : PERM;
        uid = (argc > 3) ? atoi(argv[3]) : UID;
        gid = (argc > 4) ? atoi(argv[4]) : GID;
    
        unlink(testpath);
    
        fd = open(testpath, O_RDWR | O_CREAT, 0);
        if (fd == -1) errExit("open");
    
        if (fchown(fd, uid, gid) == -1) errExit("fchown");
        if (fchmod(fd, perm) == -1) errExit("fchmod");
        close(fd);
    
        snprintf(cmd, sizeof(cmd), "ls -l %s", testpath);
        system(cmd);
    
        if (seteuid(uid) == -1) errExit("seteuid");
    
        accessTest(testpath, 0, "0");
        accessTest(testpath, R_OK, "R_OK");
        accessTest(testpath, W_OK, "W_OK");
        accessTest(testpath, X_OK, "X_OK");
        accessTest(testpath, R_OK | W_OK, "R_OK | W_OK");
        accessTest(testpath, R_OK | X_OK, "R_OK | X_OK");
        accessTest(testpath, W_OK | X_OK, "W_OK | X_OK");
        accessTest(testpath, R_OK | W_OK | X_OK, "R_OK | W_OK | X_OK");
    
        exit(EXIT_SUCCESS);
    } /* main */
    
    This can be run against an Ext3 filesystem as well as against an XFS
    filesystem.  If successful, it will show:
    
            [root@andromeda src]# ./t_access_root /tmp/xxx 0 4043 4043
            ---------- 1 dhowells dhowells 0 2008-12-31 03:00 /tmp/xxx
            access(/tmp/xxx, 0) returns 0
            access(/tmp/xxx, R_OK) returns 0
            access(/tmp/xxx, W_OK) returns 0
            access(/tmp/xxx, X_OK) returns -1
            access(/tmp/xxx, R_OK | W_OK) returns 0
            access(/tmp/xxx, R_OK | X_OK) returns -1
            access(/tmp/xxx, W_OK | X_OK) returns -1
            access(/tmp/xxx, R_OK | W_OK | X_OK) returns -1
    
    If unsuccessful, it will show:
    
            [root@andromeda src]# ./t_access_root /tmp/xxx 0 4043 4043
            ---------- 1 dhowells dhowells 0 2008-12-31 02:56 /tmp/xxx
            access(/tmp/xxx, 0) returns 0
            access(/tmp/xxx, R_OK) returns -1
            access(/tmp/xxx, W_OK) returns -1
            access(/tmp/xxx, X_OK) returns -1
            access(/tmp/xxx, R_OK | W_OK) returns -1
            access(/tmp/xxx, R_OK | X_OK) returns -1
            access(/tmp/xxx, W_OK | X_OK) returns -1
            access(/tmp/xxx, R_OK | W_OK | X_OK) returns -1
    
    I've also tested the fix with the SELinux and syscalls LTP testsuites.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: J. Bruce Fields <bfields@citi.umich.edu>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index d85dbb37c972..a02f243f09c0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -154,14 +154,32 @@ int security_capset(struct cred *new, const struct cred *old,
 				    effective, inheritable, permitted);
 }
 
-int security_capable(struct task_struct *tsk, int cap)
+int security_capable(int cap)
 {
-	return security_ops->capable(tsk, cap, SECURITY_CAP_AUDIT);
+	return security_ops->capable(current, current_cred(), cap,
+				     SECURITY_CAP_AUDIT);
 }
 
-int security_capable_noaudit(struct task_struct *tsk, int cap)
+int security_real_capable(struct task_struct *tsk, int cap)
 {
-	return security_ops->capable(tsk, cap, SECURITY_CAP_NOAUDIT);
+	const struct cred *cred;
+	int ret;
+
+	cred = get_task_cred(tsk);
+	ret = security_ops->capable(tsk, cred, cap, SECURITY_CAP_AUDIT);
+	put_cred(cred);
+	return ret;
+}
+
+int security_real_capable_noaudit(struct task_struct *tsk, int cap)
+{
+	const struct cred *cred;
+	int ret;
+
+	cred = get_task_cred(tsk);
+	ret = security_ops->capable(tsk, cred, cap, SECURITY_CAP_NOAUDIT);
+	put_cred(cred);
+	return ret;
 }
 
 int security_acct(struct file *file)

commit 29881c4502ba05f46bc12ae8053d4e08d7e2615c
Author: James Morris <jmorris@namei.org>
Date:   Wed Jan 7 09:21:54 2009 +1100

    Revert "CRED: Fix regression in cap_capable() as shown up by sys_faccessat() [ver #2]"
    
    This reverts commit 14eaddc967b16017d4a1a24d2be6c28ecbe06ed8.
    
    David has a better version to come.

diff --git a/security/security.c b/security/security.c
index 9bbc8e57b8c6..d85dbb37c972 100644
--- a/security/security.c
+++ b/security/security.c
@@ -154,31 +154,14 @@ int security_capset(struct cred *new, const struct cred *old,
 				    effective, inheritable, permitted);
 }
 
-int security_capable(int cap)
+int security_capable(struct task_struct *tsk, int cap)
 {
-	return security_ops->capable(cap, SECURITY_CAP_AUDIT);
+	return security_ops->capable(tsk, cap, SECURITY_CAP_AUDIT);
 }
 
-int security_task_capable(struct task_struct *tsk, int cap)
+int security_capable_noaudit(struct task_struct *tsk, int cap)
 {
-	const struct cred *cred;
-	int ret;
-
-	cred = get_task_cred(tsk);
-	ret = security_ops->task_capable(tsk, cred, cap, SECURITY_CAP_AUDIT);
-	put_cred(cred);
-	return ret;
-}
-
-int security_task_capable_noaudit(struct task_struct *tsk, int cap)
-{
-	const struct cred *cred;
-	int ret;
-
-	cred = get_task_cred(tsk);
-	ret = security_ops->task_capable(tsk, cred, cap, SECURITY_CAP_NOAUDIT);
-	put_cred(cred);
-	return ret;
+	return security_ops->capable(tsk, cap, SECURITY_CAP_NOAUDIT);
 }
 
 int security_acct(struct file *file)

commit 14eaddc967b16017d4a1a24d2be6c28ecbe06ed8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Dec 31 15:15:42 2008 +0000

    CRED: Fix regression in cap_capable() as shown up by sys_faccessat() [ver #2]
    
    Fix a regression in cap_capable() due to:
    
            commit 5ff7711e635b32f0a1e558227d030c7e45b4a465
            Author: David Howells <dhowells@redhat.com>
            Date:   Wed Dec 31 02:52:28 2008 +0000
    
                CRED: Differentiate objective and effective subjective credentials on a task
    
    The problem is that the above patch allows a process to have two sets of
    credentials, and for the most part uses the subjective credentials when
    accessing current's creds.
    
    There is, however, one exception: cap_capable(), and thus capable(), uses the
    real/objective credentials of the target task, whether or not it is the current
    task.
    
    Ordinarily this doesn't matter, since usually the two cred pointers in current
    point to the same set of creds.  However, sys_faccessat() makes use of this
    facility to override the credentials of the calling process to make its test,
    without affecting the creds as seen from other processes.
    
    One of the things sys_faccessat() does is to make an adjustment to the
    effective capabilities mask, which cap_capable(), as it stands, then ignores.
    
    The affected capability check is in generic_permission():
    
            if (!(mask & MAY_EXEC) || execute_ok(inode))
                    if (capable(CAP_DAC_OVERRIDE))
                            return 0;
    
    This change splits capable() from has_capability() down into the commoncap and
    SELinux code.  The capable() security op now only deals with the current
    process, and uses the current process's subjective creds.  A new security op -
    task_capable() - is introduced that can check any task's objective creds.
    
    strictly the capable() security op is superfluous with the presence of the
    task_capable() op, however it should be faster to call the capable() op since
    two fewer arguments need be passed down through the various layers.
    
    This can be tested by compiling the following program from the XFS testsuite:
    
    /*
     *  t_access_root.c - trivial test program to show permission bug.
     *
     *  Written by Michael Kerrisk - copyright ownership not pursued.
     *  Sourced from: http://linux.derkeiler.com/Mailing-Lists/Kernel/2003-10/6030.html
     */
    #include <limits.h>
    #include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    
    #define UID 500
    #define GID 100
    #define PERM 0
    #define TESTPATH "/tmp/t_access"
    
    static void
    errExit(char *msg)
    {
        perror(msg);
        exit(EXIT_FAILURE);
    } /* errExit */
    
    static void
    accessTest(char *file, int mask, char *mstr)
    {
        printf("access(%s, %s) returns %d\n", file, mstr, access(file, mask));
    } /* accessTest */
    
    int
    main(int argc, char *argv[])
    {
        int fd, perm, uid, gid;
        char *testpath;
        char cmd[PATH_MAX + 20];
    
        testpath = (argc > 1) ? argv[1] : TESTPATH;
        perm = (argc > 2) ? strtoul(argv[2], NULL, 8) : PERM;
        uid = (argc > 3) ? atoi(argv[3]) : UID;
        gid = (argc > 4) ? atoi(argv[4]) : GID;
    
        unlink(testpath);
    
        fd = open(testpath, O_RDWR | O_CREAT, 0);
        if (fd == -1) errExit("open");
    
        if (fchown(fd, uid, gid) == -1) errExit("fchown");
        if (fchmod(fd, perm) == -1) errExit("fchmod");
        close(fd);
    
        snprintf(cmd, sizeof(cmd), "ls -l %s", testpath);
        system(cmd);
    
        if (seteuid(uid) == -1) errExit("seteuid");
    
        accessTest(testpath, 0, "0");
        accessTest(testpath, R_OK, "R_OK");
        accessTest(testpath, W_OK, "W_OK");
        accessTest(testpath, X_OK, "X_OK");
        accessTest(testpath, R_OK | W_OK, "R_OK | W_OK");
        accessTest(testpath, R_OK | X_OK, "R_OK | X_OK");
        accessTest(testpath, W_OK | X_OK, "W_OK | X_OK");
        accessTest(testpath, R_OK | W_OK | X_OK, "R_OK | W_OK | X_OK");
    
        exit(EXIT_SUCCESS);
    } /* main */
    
    This can be run against an Ext3 filesystem as well as against an XFS
    filesystem.  If successful, it will show:
    
            [root@andromeda src]# ./t_access_root /tmp/xxx 0 4043 4043
            ---------- 1 dhowells dhowells 0 2008-12-31 03:00 /tmp/xxx
            access(/tmp/xxx, 0) returns 0
            access(/tmp/xxx, R_OK) returns 0
            access(/tmp/xxx, W_OK) returns 0
            access(/tmp/xxx, X_OK) returns -1
            access(/tmp/xxx, R_OK | W_OK) returns 0
            access(/tmp/xxx, R_OK | X_OK) returns -1
            access(/tmp/xxx, W_OK | X_OK) returns -1
            access(/tmp/xxx, R_OK | W_OK | X_OK) returns -1
    
    If unsuccessful, it will show:
    
            [root@andromeda src]# ./t_access_root /tmp/xxx 0 4043 4043
            ---------- 1 dhowells dhowells 0 2008-12-31 02:56 /tmp/xxx
            access(/tmp/xxx, 0) returns 0
            access(/tmp/xxx, R_OK) returns -1
            access(/tmp/xxx, W_OK) returns -1
            access(/tmp/xxx, X_OK) returns -1
            access(/tmp/xxx, R_OK | W_OK) returns -1
            access(/tmp/xxx, R_OK | X_OK) returns -1
            access(/tmp/xxx, W_OK | X_OK) returns -1
            access(/tmp/xxx, R_OK | W_OK | X_OK) returns -1
    
    I've also tested the fix with the SELinux and syscalls LTP testsuites.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index d85dbb37c972..9bbc8e57b8c6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -154,14 +154,31 @@ int security_capset(struct cred *new, const struct cred *old,
 				    effective, inheritable, permitted);
 }
 
-int security_capable(struct task_struct *tsk, int cap)
+int security_capable(int cap)
 {
-	return security_ops->capable(tsk, cap, SECURITY_CAP_AUDIT);
+	return security_ops->capable(cap, SECURITY_CAP_AUDIT);
 }
 
-int security_capable_noaudit(struct task_struct *tsk, int cap)
+int security_task_capable(struct task_struct *tsk, int cap)
 {
-	return security_ops->capable(tsk, cap, SECURITY_CAP_NOAUDIT);
+	const struct cred *cred;
+	int ret;
+
+	cred = get_task_cred(tsk);
+	ret = security_ops->task_capable(tsk, cred, cap, SECURITY_CAP_AUDIT);
+	put_cred(cred);
+	return ret;
+}
+
+int security_task_capable_noaudit(struct task_struct *tsk, int cap)
+{
+	const struct cred *cred;
+	int ret;
+
+	cred = get_task_cred(tsk);
+	ret = security_ops->task_capable(tsk, cred, cap, SECURITY_CAP_NOAUDIT);
+	put_cred(cred);
+	return ret;
 }
 
 int security_acct(struct file *file)

commit be6d3e56a6b9b3a4ee44a0685e39e595073c6f0d
Author: Kentaro Takeda <takedakn@nttdata.co.jp>
Date:   Wed Dec 17 13:24:15 2008 +0900

    introduce new LSM hooks where vfsmount is available.
    
    Add new LSM hooks for path-based checks.  Call them on directory-modifying
    operations at the points where we still know the vfsmount involved.
    
    Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Toshiharu Harada <haradats@nttdata.co.jp>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index d85dbb37c972..678d4d07b852 100644
--- a/security/security.c
+++ b/security/security.c
@@ -355,6 +355,72 @@ int security_inode_init_security(struct inode *inode, struct inode *dir,
 }
 EXPORT_SYMBOL(security_inode_init_security);
 
+#ifdef CONFIG_SECURITY_PATH
+int security_path_mknod(struct path *path, struct dentry *dentry, int mode,
+			unsigned int dev)
+{
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+		return 0;
+	return security_ops->path_mknod(path, dentry, mode, dev);
+}
+EXPORT_SYMBOL(security_path_mknod);
+
+int security_path_mkdir(struct path *path, struct dentry *dentry, int mode)
+{
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+		return 0;
+	return security_ops->path_mkdir(path, dentry, mode);
+}
+
+int security_path_rmdir(struct path *path, struct dentry *dentry)
+{
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+		return 0;
+	return security_ops->path_rmdir(path, dentry);
+}
+
+int security_path_unlink(struct path *path, struct dentry *dentry)
+{
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+		return 0;
+	return security_ops->path_unlink(path, dentry);
+}
+
+int security_path_symlink(struct path *path, struct dentry *dentry,
+			  const char *old_name)
+{
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+		return 0;
+	return security_ops->path_symlink(path, dentry, old_name);
+}
+
+int security_path_link(struct dentry *old_dentry, struct path *new_dir,
+		       struct dentry *new_dentry)
+{
+	if (unlikely(IS_PRIVATE(old_dentry->d_inode)))
+		return 0;
+	return security_ops->path_link(old_dentry, new_dir, new_dentry);
+}
+
+int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
+			 struct path *new_dir, struct dentry *new_dentry)
+{
+	if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
+		     (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))
+		return 0;
+	return security_ops->path_rename(old_dir, old_dentry, new_dir,
+					 new_dentry);
+}
+
+int security_path_truncate(struct path *path, loff_t length,
+			   unsigned int time_attrs)
+{
+	if (unlikely(IS_PRIVATE(path->dentry->d_inode)))
+		return 0;
+	return security_ops->path_truncate(path, length, time_attrs);
+}
+#endif
+
 int security_inode_create(struct inode *dir, struct dentry *dentry, int mode)
 {
 	if (unlikely(IS_PRIVATE(dir)))

commit 12204e24b1330428c3062faee10a0d80b8a5cb61
Author: James Morris <jmorris@namei.org>
Date:   Fri Dec 19 10:44:42 2008 +1100

    security: pass mount flags to security_sb_kern_mount()
    
    Pass mount flags to security_sb_kern_mount(), so security modules
    can determine if a mount operation is being performed by the kernel.
    
    Signed-off-by: James Morris <jmorris@namei.org>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>

diff --git a/security/security.c b/security/security.c
index f0d96a6cc4e9..d85dbb37c972 100644
--- a/security/security.c
+++ b/security/security.c
@@ -254,9 +254,9 @@ int security_sb_copy_data(char *orig, char *copy)
 }
 EXPORT_SYMBOL(security_sb_copy_data);
 
-int security_sb_kern_mount(struct super_block *sb, void *data)
+int security_sb_kern_mount(struct super_block *sb, int flags, void *data)
 {
-	return security_ops->sb_kern_mount(sb, data);
+	return security_ops->sb_kern_mount(sb, flags, data);
 }
 
 int security_sb_show_options(struct seq_file *m, struct super_block *sb)

commit 200036ca9b3f0b2250912142552ce56682190f95
Author: Hannes Eder <hannes@hanneseder.net>
Date:   Mon Nov 24 22:14:43 2008 +0100

    CRED: fix sparse warnings
    
    Impact: fix sparse warnings
    
    Fix the following sparse warnings:
    
      security/security.c:228:2: warning: returning void-valued expression
      security/security.c:233:2: warning: returning void-valued expression
      security/security.c:616:2: warning: returning void-valued expression
    
    Signed-off-by: Hannes Eder <hannes@hanneseder.net>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 038ef04b2c7f..f0d96a6cc4e9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -225,12 +225,12 @@ int security_bprm_check(struct linux_binprm *bprm)
 
 void security_bprm_committing_creds(struct linux_binprm *bprm)
 {
-	return security_ops->bprm_committing_creds(bprm);
+	security_ops->bprm_committing_creds(bprm);
 }
 
 void security_bprm_committed_creds(struct linux_binprm *bprm)
 {
-	return security_ops->bprm_committed_creds(bprm);
+	security_ops->bprm_committed_creds(bprm);
 }
 
 int security_bprm_secureexec(struct linux_binprm *bprm)
@@ -613,7 +613,7 @@ int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
 
 void security_commit_creds(struct cred *new, const struct cred *old)
 {
-	return security_ops->cred_commit(new, old);
+	security_ops->cred_commit(new, old);
 }
 
 int security_kernel_act_as(struct cred *new, u32 secid)

commit 3a3b7ce9336952ea7b9564d976d068a238976c9d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:28 2008 +1100

    CRED: Allow kernel services to override LSM settings for task actions
    
    Allow kernel services to override LSM settings appropriate to the actions
    performed by a task by duplicating a set of credentials, modifying it and then
    using task_struct::cred to point to it when performing operations on behalf of
    a task.
    
    This is used, for example, by CacheFiles which has to transparently access the
    cache on behalf of a process that thinks it is doing, say, NFS accesses with a
    potentially inappropriate (with respect to accessing the cache) set of
    credentials.
    
    This patch provides two LSM hooks for modifying a task security record:
    
     (*) security_kernel_act_as() which allows modification of the security datum
         with which a task acts on other objects (most notably files).
    
     (*) security_kernel_create_files_as() which allows modification of the
         security datum that is used to initialise the security data on a file that
         a task creates.
    
    The patch also provides four new credentials handling functions, which wrap the
    LSM functions:
    
     (1) prepare_kernel_cred()
    
         Prepare a set of credentials for a kernel service to use, based either on
         a daemon's credentials or on init_cred.  All the keyrings are cleared.
    
     (2) set_security_override()
    
         Set the LSM security ID in a set of credentials to a specific security
         context, assuming permission from the LSM policy.
    
     (3) set_security_override_from_ctx()
    
         As (2), but takes the security context as a string.
    
     (4) set_create_files_as()
    
         Set the file creation LSM security ID in a set of credentials to be the
         same as that on a particular inode.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com> [Smack changes]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index dc5babb2d6d8..038ef04b2c7f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -616,6 +616,16 @@ void security_commit_creds(struct cred *new, const struct cred *old)
 	return security_ops->cred_commit(new, old);
 }
 
+int security_kernel_act_as(struct cred *new, u32 secid)
+{
+	return security_ops->kernel_act_as(new, secid);
+}
+
+int security_kernel_create_files_as(struct cred *new, struct inode *inode)
+{
+	return security_ops->kernel_create_files_as(new, inode);
+}
+
 int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
 {
 	return security_ops->task_setuid(id0, id1, id2, flags);

commit a6f76f23d297f70e2a6b3ec607f7aeeea9e37e8d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:24 2008 +1100

    CRED: Make execve() take advantage of copy-on-write credentials
    
    Make execve() take advantage of copy-on-write credentials, allowing it to set
    up the credentials in advance, and then commit the whole lot after the point
    of no return.
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         The credential bits from struct linux_binprm are, for the most part,
         replaced with a single credentials pointer (bprm->cred).  This means that
         all the creds can be calculated in advance and then applied at the point
         of no return with no possibility of failure.
    
         I would like to replace bprm->cap_effective with:
    
            cap_isclear(bprm->cap_effective)
    
         but this seems impossible due to special behaviour for processes of pid 1
         (they always retain their parent's capability masks where normally they'd
         be changed - see cap_bprm_set_creds()).
    
         The following sequence of events now happens:
    
         (a) At the start of do_execve, the current task's cred_exec_mutex is
             locked to prevent PTRACE_ATTACH from obsoleting the calculation of
             creds that we make.
    
         (a) prepare_exec_creds() is then called to make a copy of the current
             task's credentials and prepare it.  This copy is then assigned to
             bprm->cred.
    
             This renders security_bprm_alloc() and security_bprm_free()
             unnecessary, and so they've been removed.
    
         (b) The determination of unsafe execution is now performed immediately
             after (a) rather than later on in the code.  The result is stored in
             bprm->unsafe for future reference.
    
         (c) prepare_binprm() is called, possibly multiple times.
    
             (i) This applies the result of set[ug]id binaries to the new creds
                 attached to bprm->cred.  Personality bit clearance is recorded,
                 but now deferred on the basis that the exec procedure may yet
                 fail.
    
             (ii) This then calls the new security_bprm_set_creds().  This should
                 calculate the new LSM and capability credentials into *bprm->cred.
    
                 This folds together security_bprm_set() and parts of
                 security_bprm_apply_creds() (these two have been removed).
                 Anything that might fail must be done at this point.
    
             (iii) bprm->cred_prepared is set to 1.
    
                 bprm->cred_prepared is 0 on the first pass of the security
                 calculations, and 1 on all subsequent passes.  This allows SELinux
                 in (ii) to base its calculations only on the initial script and
                 not on the interpreter.
    
         (d) flush_old_exec() is called to commit the task to execution.  This
             performs the following steps with regard to credentials:
    
             (i) Clear pdeath_signal and set dumpable on certain circumstances that
                 may not be covered by commit_creds().
    
             (ii) Clear any bits in current->personality that were deferred from
                 (c.i).
    
         (e) install_exec_creds() [compute_creds() as was] is called to install the
             new credentials.  This performs the following steps with regard to
             credentials:
    
             (i) Calls security_bprm_committing_creds() to apply any security
                 requirements, such as flushing unauthorised files in SELinux, that
                 must be done before the credentials are changed.
    
                 This is made up of bits of security_bprm_apply_creds() and
                 security_bprm_post_apply_creds(), both of which have been removed.
                 This function is not allowed to fail; anything that might fail
                 must have been done in (c.ii).
    
             (ii) Calls commit_creds() to apply the new credentials in a single
                 assignment (more or less).  Possibly pdeath_signal and dumpable
                 should be part of struct creds.
    
             (iii) Unlocks the task's cred_replace_mutex, thus allowing
                 PTRACE_ATTACH to take place.
    
             (iv) Clears The bprm->cred pointer as the credentials it was holding
                 are now immutable.
    
             (v) Calls security_bprm_committed_creds() to apply any security
                 alterations that must be done after the creds have been changed.
                 SELinux uses this to flush signals and signal handlers.
    
         (f) If an error occurs before (d.i), bprm_free() will call abort_creds()
             to destroy the proposed new credentials and will then unlock
             cred_replace_mutex.  No changes to the credentials will have been
             made.
    
     (2) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_bprm_alloc(), ->bprm_alloc_security()
         (*) security_bprm_free(), ->bprm_free_security()
    
             Removed in favour of preparing new credentials and modifying those.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
         (*) security_bprm_post_apply_creds(), ->bprm_post_apply_creds()
    
             Removed; split between security_bprm_set_creds(),
             security_bprm_committing_creds() and security_bprm_committed_creds().
    
         (*) security_bprm_set(), ->bprm_set_security()
    
             Removed; folded into security_bprm_set_creds().
    
         (*) security_bprm_set_creds(), ->bprm_set_creds()
    
             New.  The new credentials in bprm->creds should be checked and set up
             as appropriate.  bprm->cred_prepared is 0 on the first call, 1 on the
             second and subsequent calls.
    
         (*) security_bprm_committing_creds(), ->bprm_committing_creds()
         (*) security_bprm_committed_creds(), ->bprm_committed_creds()
    
             New.  Apply the security effects of the new credentials.  This
             includes closing unauthorised files in SELinux.  This function may not
             fail.  When the former is called, the creds haven't yet been applied
             to the process; when the latter is called, they have.
    
             The former may access bprm->cred, the latter may not.
    
     (3) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) The bprm_security_struct struct has been removed in favour of using
             the credentials-under-construction approach.
    
         (c) flush_unauthorized_files() now takes a cred pointer and passes it on
             to inode_has_perm(), file_has_perm() and dentry_open().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index a55d739c6864..dc5babb2d6d8 100644
--- a/security/security.c
+++ b/security/security.c
@@ -213,34 +213,24 @@ int security_vm_enough_memory_kern(long pages)
 	return security_ops->vm_enough_memory(current->mm, pages);
 }
 
-int security_bprm_alloc(struct linux_binprm *bprm)
+int security_bprm_set_creds(struct linux_binprm *bprm)
 {
-	return security_ops->bprm_alloc_security(bprm);
+	return security_ops->bprm_set_creds(bprm);
 }
 
-void security_bprm_free(struct linux_binprm *bprm)
-{
-	security_ops->bprm_free_security(bprm);
-}
-
-int security_bprm_apply_creds(struct linux_binprm *bprm, int unsafe)
-{
-	return security_ops->bprm_apply_creds(bprm, unsafe);
-}
-
-void security_bprm_post_apply_creds(struct linux_binprm *bprm)
+int security_bprm_check(struct linux_binprm *bprm)
 {
-	security_ops->bprm_post_apply_creds(bprm);
+	return security_ops->bprm_check_security(bprm);
 }
 
-int security_bprm_set(struct linux_binprm *bprm)
+void security_bprm_committing_creds(struct linux_binprm *bprm)
 {
-	return security_ops->bprm_set_security(bprm);
+	return security_ops->bprm_committing_creds(bprm);
 }
 
-int security_bprm_check(struct linux_binprm *bprm)
+void security_bprm_committed_creds(struct linux_binprm *bprm)
 {
-	return security_ops->bprm_check_security(bprm);
+	return security_ops->bprm_committed_creds(bprm);
 }
 
 int security_bprm_secureexec(struct linux_binprm *bprm)

commit d84f4f992cbd76e8f39c488cf0c5d123843923b1
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:23 2008 +1100

    CRED: Inaugurate COW credentials
    
    Inaugurate copy-on-write credentials management.  This uses RCU to manage the
    credentials pointer in the task_struct with respect to accesses by other tasks.
    A process may only modify its own credentials, and so does not need locking to
    access or modify its own credentials.
    
    A mutex (cred_replace_mutex) is added to the task_struct to control the effect
    of PTRACE_ATTACHED on credential calculations, particularly with respect to
    execve().
    
    With this patch, the contents of an active credentials struct may not be
    changed directly; rather a new set of credentials must be prepared, modified
    and committed using something like the following sequence of events:
    
            struct cred *new = prepare_creds();
            int ret = blah(new);
            if (ret < 0) {
                    abort_creds(new);
                    return ret;
            }
            return commit_creds(new);
    
    There are some exceptions to this rule: the keyrings pointed to by the active
    credentials may be instantiated - keyrings violate the COW rule as managing
    COW keyrings is tricky, given that it is possible for a task to directly alter
    the keys in a keyring in use by another task.
    
    To help enforce this, various pointers to sets of credentials, such as those in
    the task_struct, are declared const.  The purpose of this is compile-time
    discouragement of altering credentials through those pointers.  Once a set of
    credentials has been made public through one of these pointers, it may not be
    modified, except under special circumstances:
    
      (1) Its reference count may incremented and decremented.
    
      (2) The keyrings to which it points may be modified, but not replaced.
    
    The only safe way to modify anything else is to create a replacement and commit
    using the functions described in Documentation/credentials.txt (which will be
    added by a later patch).
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         This now prepares and commits credentials in various places in the
         security code rather than altering the current creds directly.
    
     (2) Temporary credential overrides.
    
         do_coredump() and sys_faccessat() now prepare their own credentials and
         temporarily override the ones currently on the acting thread, whilst
         preventing interference from other threads by holding cred_replace_mutex
         on the thread being dumped.
    
         This will be replaced in a future patch by something that hands down the
         credentials directly to the functions being called, rather than altering
         the task's objective credentials.
    
     (3) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_capset_check(), ->capset_check()
         (*) security_capset_set(), ->capset_set()
    
             Removed in favour of security_capset().
    
         (*) security_capset(), ->capset()
    
             New.  This is passed a pointer to the new creds, a pointer to the old
             creds and the proposed capability sets.  It should fill in the new
             creds or return an error.  All pointers, barring the pointer to the
             new creds, are now const.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
    
             Changed; now returns a value, which will cause the process to be
             killed if it's an error.
    
         (*) security_task_alloc(), ->task_alloc_security()
    
             Removed in favour of security_prepare_creds().
    
         (*) security_cred_free(), ->cred_free()
    
             New.  Free security data attached to cred->security.
    
         (*) security_prepare_creds(), ->cred_prepare()
    
             New. Duplicate any security data attached to cred->security.
    
         (*) security_commit_creds(), ->cred_commit()
    
             New. Apply any security effects for the upcoming installation of new
             security by commit_creds().
    
         (*) security_task_post_setuid(), ->task_post_setuid()
    
             Removed in favour of security_task_fix_setuid().
    
         (*) security_task_fix_setuid(), ->task_fix_setuid()
    
             Fix up the proposed new credentials for setuid().  This is used by
             cap_set_fix_setuid() to implicitly adjust capabilities in line with
             setuid() changes.  Changes are made to the new credentials, rather
             than the task itself as in security_task_post_setuid().
    
         (*) security_task_reparent_to_init(), ->task_reparent_to_init()
    
             Removed.  Instead the task being reparented to init is referred
             directly to init's credentials.
    
             NOTE!  This results in the loss of some state: SELinux's osid no
             longer records the sid of the thread that forked it.
    
         (*) security_key_alloc(), ->key_alloc()
         (*) security_key_permission(), ->key_permission()
    
             Changed.  These now take cred pointers rather than task pointers to
             refer to the security context.
    
     (4) sys_capset().
    
         This has been simplified and uses less locking.  The LSM functions it
         calls have been merged.
    
     (5) reparent_to_kthreadd().
    
         This gives the current thread the same credentials as init by simply using
         commit_thread() to point that way.
    
     (6) __sigqueue_alloc() and switch_uid()
    
         __sigqueue_alloc() can't stop the target task from changing its creds
         beneath it, so this function gets a reference to the currently applicable
         user_struct which it then passes into the sigqueue struct it returns if
         successful.
    
         switch_uid() is now called from commit_creds(), and possibly should be
         folded into that.  commit_creds() should take care of protecting
         __sigqueue_alloc().
    
     (7) [sg]et[ug]id() and co and [sg]et_current_groups.
    
         The set functions now all use prepare_creds(), commit_creds() and
         abort_creds() to build and check a new set of credentials before applying
         it.
    
         security_task_set[ug]id() is called inside the prepared section.  This
         guarantees that nothing else will affect the creds until we've finished.
    
         The calling of set_dumpable() has been moved into commit_creds().
    
         Much of the functionality of set_user() has been moved into
         commit_creds().
    
         The get functions all simply access the data directly.
    
     (8) security_task_prctl() and cap_task_prctl().
    
         security_task_prctl() has been modified to return -ENOSYS if it doesn't
         want to handle a function, or otherwise return the return value directly
         rather than through an argument.
    
         Additionally, cap_task_prctl() now prepares a new set of credentials, even
         if it doesn't end up using it.
    
     (9) Keyrings.
    
         A number of changes have been made to the keyrings code:
    
         (a) switch_uid_keyring(), copy_keys(), exit_keys() and suid_keys() have
             all been dropped and built in to the credentials functions directly.
             They may want separating out again later.
    
         (b) key_alloc() and search_process_keyrings() now take a cred pointer
             rather than a task pointer to specify the security context.
    
         (c) copy_creds() gives a new thread within the same thread group a new
             thread keyring if its parent had one, otherwise it discards the thread
             keyring.
    
         (d) The authorisation key now points directly to the credentials to extend
             the search into rather pointing to the task that carries them.
    
         (e) Installing thread, process or session keyrings causes a new set of
             credentials to be created, even though it's not strictly necessary for
             process or session keyrings (they're shared).
    
    (10) Usermode helper.
    
         The usermode helper code now carries a cred struct pointer in its
         subprocess_info struct instead of a new session keyring pointer.  This set
         of credentials is derived from init_cred and installed on the new process
         after it has been cloned.
    
         call_usermodehelper_setup() allocates the new credentials and
         call_usermodehelper_freeinfo() discards them if they haven't been used.  A
         special cred function (prepare_usermodeinfo_creds()) is provided
         specifically for call_usermodehelper_setup() to call.
    
         call_usermodehelper_setkeys() adjusts the credentials to sport the
         supplied keyring as the new session keyring.
    
    (11) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) selinux_setprocattr() no longer does its check for whether the
             current ptracer can access processes with the new SID inside the lock
             that covers getting the ptracer's SID.  Whilst this lock ensures that
             the check is done with the ptracer pinned, the result is only valid
             until the lock is released, so there's no point doing it inside the
             lock.
    
    (12) is_single_threaded().
    
         This function has been extracted from selinux_setprocattr() and put into
         a file of its own in the lib/ directory as join_session_keyring() now
         wants to use it too.
    
         The code in SELinux just checked to see whether a task shared mm_structs
         with other tasks (CLONE_VM), but that isn't good enough.  We really want
         to know if they're part of the same thread group (CLONE_THREAD).
    
    (13) nfsd.
    
         The NFS server daemon now has to use the COW credentials to set the
         credentials it is going to use.  It really needs to pass the credentials
         down to the functions it calls, but it can't do that until other patches
         in this series have been applied.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index f40a0a04c3c2..a55d739c6864 100644
--- a/security/security.c
+++ b/security/security.c
@@ -145,18 +145,13 @@ int security_capget(struct task_struct *target,
 	return security_ops->capget(target, effective, inheritable, permitted);
 }
 
-int security_capset_check(const kernel_cap_t *effective,
-			  const kernel_cap_t *inheritable,
-			  const kernel_cap_t *permitted)
+int security_capset(struct cred *new, const struct cred *old,
+		    const kernel_cap_t *effective,
+		    const kernel_cap_t *inheritable,
+		    const kernel_cap_t *permitted)
 {
-	return security_ops->capset_check(effective, inheritable, permitted);
-}
-
-void security_capset_set(const kernel_cap_t *effective,
-			 const kernel_cap_t *inheritable,
-			 const kernel_cap_t *permitted)
-{
-	security_ops->capset_set(effective, inheritable, permitted);
+	return security_ops->capset(new, old,
+				    effective, inheritable, permitted);
 }
 
 int security_capable(struct task_struct *tsk, int cap)
@@ -228,9 +223,9 @@ void security_bprm_free(struct linux_binprm *bprm)
 	security_ops->bprm_free_security(bprm);
 }
 
-void security_bprm_apply_creds(struct linux_binprm *bprm, int unsafe)
+int security_bprm_apply_creds(struct linux_binprm *bprm, int unsafe)
 {
-	security_ops->bprm_apply_creds(bprm, unsafe);
+	return security_ops->bprm_apply_creds(bprm, unsafe);
 }
 
 void security_bprm_post_apply_creds(struct linux_binprm *bprm)
@@ -616,14 +611,19 @@ int security_task_create(unsigned long clone_flags)
 	return security_ops->task_create(clone_flags);
 }
 
-int security_cred_alloc(struct cred *cred)
+void security_cred_free(struct cred *cred)
 {
-	return security_ops->cred_alloc_security(cred);
+	security_ops->cred_free(cred);
 }
 
-void security_cred_free(struct cred *cred)
+int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
 {
-	security_ops->cred_free(cred);
+	return security_ops->cred_prepare(new, old, gfp);
+}
+
+void security_commit_creds(struct cred *new, const struct cred *old)
+{
+	return security_ops->cred_commit(new, old);
 }
 
 int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
@@ -631,10 +631,10 @@ int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
 	return security_ops->task_setuid(id0, id1, id2, flags);
 }
 
-int security_task_post_setuid(uid_t old_ruid, uid_t old_euid,
-			       uid_t old_suid, int flags)
+int security_task_fix_setuid(struct cred *new, const struct cred *old,
+			     int flags)
 {
-	return security_ops->task_post_setuid(old_ruid, old_euid, old_suid, flags);
+	return security_ops->task_fix_setuid(new, old, flags);
 }
 
 int security_task_setgid(gid_t id0, gid_t id1, gid_t id2, int flags)
@@ -716,14 +716,9 @@ int security_task_wait(struct task_struct *p)
 }
 
 int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
-			 unsigned long arg4, unsigned long arg5, long *rc_p)
-{
-	return security_ops->task_prctl(option, arg2, arg3, arg4, arg5, rc_p);
-}
-
-void security_task_reparent_to_init(struct task_struct *p)
+			 unsigned long arg4, unsigned long arg5)
 {
-	security_ops->task_reparent_to_init(p);
+	return security_ops->task_prctl(option, arg2, arg3, arg4, arg5);
 }
 
 void security_task_to_inode(struct task_struct *p, struct inode *inode)
@@ -1123,9 +1118,10 @@ EXPORT_SYMBOL(security_skb_classify_flow);
 
 #ifdef CONFIG_KEYS
 
-int security_key_alloc(struct key *key, struct task_struct *tsk, unsigned long flags)
+int security_key_alloc(struct key *key, const struct cred *cred,
+		       unsigned long flags)
 {
-	return security_ops->key_alloc(key, tsk, flags);
+	return security_ops->key_alloc(key, cred, flags);
 }
 
 void security_key_free(struct key *key)
@@ -1134,9 +1130,9 @@ void security_key_free(struct key *key)
 }
 
 int security_key_permission(key_ref_t key_ref,
-			    struct task_struct *context, key_perm_t perm)
+			    const struct cred *cred, key_perm_t perm)
 {
-	return security_ops->key_permission(key_ref, context, perm);
+	return security_ops->key_permission(key_ref, cred, perm);
 }
 
 int security_key_getsecurity(struct key *key, char **_buffer)

commit 745ca2475a6ac596e3d8d37c2759c0fbe2586227
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:22 2008 +1100

    CRED: Pass credentials through dentry_open()
    
    Pass credentials through dentry_open() so that the COW creds patch can have
    SELinux's flush_unauthorized_files() pass the appropriate creds back to itself
    when it opens its null chardev.
    
    The security_dentry_open() call also now takes a creds pointer, as does the
    dentry_open hook in struct security_operations.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index d058f7d5b10a..f40a0a04c3c2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -606,9 +606,9 @@ int security_file_receive(struct file *file)
 	return security_ops->file_receive(file);
 }
 
-int security_dentry_open(struct file *file)
+int security_dentry_open(struct file *file, const struct cred *cred)
 {
-	return security_ops->dentry_open(file);
+	return security_ops->dentry_open(file, cred);
 }
 
 int security_task_create(unsigned long clone_flags)

commit f1752eec6145c97163dbce62d17cf5d928e28a27
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:17 2008 +1100

    CRED: Detach the credentials from task_struct
    
    Detach the credentials from task_struct, duplicating them in copy_process()
    and releasing them in __put_task_struct().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 81c956a12300..d058f7d5b10a 100644
--- a/security/security.c
+++ b/security/security.c
@@ -616,14 +616,14 @@ int security_task_create(unsigned long clone_flags)
 	return security_ops->task_create(clone_flags);
 }
 
-int security_task_alloc(struct task_struct *p)
+int security_cred_alloc(struct cred *cred)
 {
-	return security_ops->task_alloc_security(p);
+	return security_ops->cred_alloc_security(cred);
 }
 
-void security_task_free(struct task_struct *p)
+void security_cred_free(struct cred *cred)
 {
-	security_ops->task_free_security(p);
+	security_ops->cred_free(cred);
 }
 
 int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)

commit 15a2460ed0af7538ca8e6c610fe607a2cd9da142
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:15 2008 +1100

    CRED: Constify the kernel_cap_t arguments to the capset LSM hooks
    
    Constify the kernel_cap_t arguments to the capset LSM hooks.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index dca37381e2a7..81c956a12300 100644
--- a/security/security.c
+++ b/security/security.c
@@ -145,16 +145,16 @@ int security_capget(struct task_struct *target,
 	return security_ops->capget(target, effective, inheritable, permitted);
 }
 
-int security_capset_check(kernel_cap_t *effective,
-			  kernel_cap_t *inheritable,
-			  kernel_cap_t *permitted)
+int security_capset_check(const kernel_cap_t *effective,
+			  const kernel_cap_t *inheritable,
+			  const kernel_cap_t *permitted)
 {
 	return security_ops->capset_check(effective, inheritable, permitted);
 }
 
-void security_capset_set(kernel_cap_t *effective,
-			 kernel_cap_t *inheritable,
-			 kernel_cap_t *permitted)
+void security_capset_set(const kernel_cap_t *effective,
+			 const kernel_cap_t *inheritable,
+			 const kernel_cap_t *permitted)
 {
 	security_ops->capset_set(effective, inheritable, permitted);
 }

commit 1cdcbec1a3372c0c49c59d292e708fd07b509f18
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:14 2008 +1100

    CRED: Neuter sys_capset()
    
    Take away the ability for sys_capset() to affect processes other than current.
    
    This means that current will not need to lock its own credentials when reading
    them against interference by other processes.
    
    This has effectively been the case for a while anyway, since:
    
     (1) Without LSM enabled, sys_capset() is disallowed.
    
     (2) With file-based capabilities, sys_capset() is neutered.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Acked-by: Andrew G. Morgan <morgan@kernel.org>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 346f21e0ec2c..dca37381e2a7 100644
--- a/security/security.c
+++ b/security/security.c
@@ -145,20 +145,18 @@ int security_capget(struct task_struct *target,
 	return security_ops->capget(target, effective, inheritable, permitted);
 }
 
-int security_capset_check(struct task_struct *target,
-			   kernel_cap_t *effective,
-			   kernel_cap_t *inheritable,
-			   kernel_cap_t *permitted)
+int security_capset_check(kernel_cap_t *effective,
+			  kernel_cap_t *inheritable,
+			  kernel_cap_t *permitted)
 {
-	return security_ops->capset_check(target, effective, inheritable, permitted);
+	return security_ops->capset_check(effective, inheritable, permitted);
 }
 
-void security_capset_set(struct task_struct *target,
-			  kernel_cap_t *effective,
-			  kernel_cap_t *inheritable,
-			  kernel_cap_t *permitted)
+void security_capset_set(kernel_cap_t *effective,
+			 kernel_cap_t *inheritable,
+			 kernel_cap_t *permitted)
 {
-	security_ops->capset_set(target, effective, inheritable, permitted);
+	security_ops->capset_set(effective, inheritable, permitted);
 }
 
 int security_capable(struct task_struct *tsk, int cap)

commit 06112163f5fd9e491a7f810443d81efa9d88e247
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Nov 11 22:02:50 2008 +1100

    Add a new capable interface that will be used by systems that use audit to
    make an A or B type decision instead of a security decision.  Currently
    this is the case at least for filesystems when deciding if a process can use
    the reserved 'root' blocks and for the case of things like the oom
    algorithm determining if processes are root processes and should be less
    likely to be killed.  These types of security system requests should not be
    audited or logged since they are not really security decisions.  It would be
    possible to solve this problem like the vm_enough_memory security check did
    by creating a new LSM interface and moving all of the policy into that
    interface but proves the needlessly bloat the LSM and provide complex
    indirection.
    
    This merely allows those decisions to be made where they belong and to not
    flood logs or printk with denials for thing that are not security decisions.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index c0acfa7177e5..346f21e0ec2c 100644
--- a/security/security.c
+++ b/security/security.c
@@ -163,7 +163,12 @@ void security_capset_set(struct task_struct *target,
 
 int security_capable(struct task_struct *tsk, int cap)
 {
-	return security_ops->capable(tsk, cap);
+	return security_ops->capable(tsk, cap, SECURITY_CAP_AUDIT);
+}
+
+int security_capable_noaudit(struct task_struct *tsk, int cap)
+{
+	return security_ops->capable(tsk, cap, SECURITY_CAP_NOAUDIT);
 }
 
 int security_acct(struct file *file)

commit 731572d39fcd3498702eda4600db4c43d51e0b26
Author: Alan Cox <alan@redhat.com>
Date:   Wed Oct 29 14:01:20 2008 -0700

    nfsd: fix vm overcommit crash
    
    Junjiro R.  Okajima reported a problem where knfsd crashes if you are
    using it to export shmemfs objects and run strict overcommit.  In this
    situation the current->mm based modifier to the overcommit goes through a
    NULL pointer.
    
    We could simply check for NULL and skip the modifier but we've caught
    other real bugs in the past from mm being NULL here - cases where we did
    need a valid mm set up (eg the exec bug about a year ago).
    
    To preserve the checks and get the logic we want shuffle the checking
    around and add a new helper to the vm_ security wrappers
    
    Also fix a current->mm reference in nommu that should use the passed mm
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: fix build]
    Reported-by: Junjiro R. Okajima <hooanon05@yahoo.co.jp>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 255b08559b2b..c0acfa7177e5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -198,14 +198,23 @@ int security_settime(struct timespec *ts, struct timezone *tz)
 
 int security_vm_enough_memory(long pages)
 {
+	WARN_ON(current->mm == NULL);
 	return security_ops->vm_enough_memory(current->mm, pages);
 }
 
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
+	WARN_ON(mm == NULL);
 	return security_ops->vm_enough_memory(mm, pages);
 }
 
+int security_vm_enough_memory_kern(long pages)
+{
+	/* If current->mm is a kernel thread then we will pass NULL,
+	   for this specific case that is fine */
+	return security_ops->vm_enough_memory(current->mm, pages);
+}
+
 int security_bprm_alloc(struct linux_binprm *bprm)
 {
 	return security_ops->bprm_alloc_security(bprm);

commit 86d688984deefa3ae5a802880c11f2b408b5d6cf
Merge: 93c06cbbf9fe 4c246edd2550
Author: James Morris <jmorris@namei.org>
Date:   Thu Aug 28 10:47:34 2008 +1000

    Merge branch 'master' into next

commit 3f23d815c5049c9d7022226cec2242e384dd0b43
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sun Aug 17 21:44:22 2008 -0700

    security: add/fix security kernel-doc
    
    Add security/inode.c functions to the kernel-api docbook.
    Use '%' on constants in kernel-doc notation.
    Fix several typos/spellos in security function descriptions.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index ff7068727757..d953d251fdca 100644
--- a/security/security.c
+++ b/security/security.c
@@ -82,8 +82,8 @@ __setup("security=", choose_lsm);
  *
  * Return true if:
  *	-The passed LSM is the one chosen by user at boot time,
- *	-or user didsn't specify a specific LSM and we're the first to ask
- *	 for registeration permissoin,
+ *	-or user didn't specify a specific LSM and we're the first to ask
+ *	 for registration permission,
  *	-or the passed LSM is currently loaded.
  * Otherwise, return false.
  */
@@ -101,13 +101,13 @@ int __init security_module_enable(struct security_operations *ops)
  * register_security - registers a security framework with the kernel
  * @ops: a pointer to the struct security_options that is to be registered
  *
- * This function is to allow a security module to register itself with the
+ * This function allows a security module to register itself with the
  * kernel security subsystem.  Some rudimentary checking is done on the @ops
  * value passed to this function. You'll need to check first if your LSM
  * is allowed to register its @ops by calling security_module_enable(@ops).
  *
  * If there is already a security module registered with the kernel,
- * an error will be returned.  Otherwise 0 is returned on success.
+ * an error will be returned.  Otherwise %0 is returned on success.
  */
 int register_security(struct security_operations *ops)
 {

commit 5cd9c58fbe9ec92b45b27e131719af4f2bd9eb40
Author: David Howells <dhowells@redhat.com>
Date:   Thu Aug 14 11:37:28 2008 +0100

    security: Fix setting of PF_SUPERPRIV by __capable()
    
    Fix the setting of PF_SUPERPRIV by __capable() as it could corrupt the flags
    the target process if that is not the current process and it is trying to
    change its own flags in a different way at the same time.
    
    __capable() is using neither atomic ops nor locking to protect t->flags.  This
    patch removes __capable() and introduces has_capability() that doesn't set
    PF_SUPERPRIV on the process being queried.
    
    This patch further splits security_ptrace() in two:
    
     (1) security_ptrace_may_access().  This passes judgement on whether one
         process may access another only (PTRACE_MODE_ATTACH for ptrace() and
         PTRACE_MODE_READ for /proc), and takes a pointer to the child process.
         current is the parent.
    
     (2) security_ptrace_traceme().  This passes judgement on PTRACE_TRACEME only,
         and takes only a pointer to the parent process.  current is the child.
    
         In Smack and commoncap, this uses has_capability() to determine whether
         the parent will be permitted to use PTRACE_ATTACH if normal checks fail.
         This does not set PF_SUPERPRIV.
    
    Two of the instances of __capable() actually only act on current, and so have
    been changed to calls to capable().
    
    Of the places that were using __capable():
    
     (1) The OOM killer calls __capable() thrice when weighing the killability of a
         process.  All of these now use has_capability().
    
     (2) cap_ptrace() and smack_ptrace() were using __capable() to check to see
         whether the parent was allowed to trace any process.  As mentioned above,
         these have been split.  For PTRACE_ATTACH and /proc, capable() is now
         used, and for PTRACE_TRACEME, has_capability() is used.
    
     (3) cap_safe_nice() only ever saw current, so now uses capable().
    
     (4) smack_setprocattr() rejected accesses to tasks other than current just
         after calling __capable(), so the order of these two tests have been
         switched and capable() is used instead.
    
     (5) In smack_file_send_sigiotask(), we need to allow privileged processes to
         receive SIGIO on files they're manipulating.
    
     (6) In smack_task_wait(), we let a process wait for a privileged process,
         whether or not the process doing the waiting is privileged.
    
    I've tested this with the LTP SELinux and syscalls testscripts.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Andrew G. Morgan <morgan@kernel.org>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index ff7068727757..3a4b4f55b33f 100644
--- a/security/security.c
+++ b/security/security.c
@@ -127,10 +127,14 @@ int register_security(struct security_operations *ops)
 
 /* Security operations */
 
-int security_ptrace(struct task_struct *parent, struct task_struct *child,
-		    unsigned int mode)
+int security_ptrace_may_access(struct task_struct *child, unsigned int mode)
 {
-	return security_ops->ptrace(parent, child, mode);
+	return security_ops->ptrace_may_access(child, mode);
+}
+
+int security_ptrace_traceme(struct task_struct *parent)
+{
+	return security_ops->ptrace_traceme(parent);
 }
 
 int security_capget(struct task_struct *target,

commit b1da47e29e467f1ec36dc78d009bfb109fd533c7
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jul 1 15:01:28 2008 +0200

    [patch 3/4] fat: dont call notify_change
    
    The FAT_IOCTL_SET_ATTRIBUTES ioctl() calls notify_change() to change
    the file mode before changing the inode attributes.  Replace with
    explicit calls to security_inode_setattr(), fat_setattr() and
    fsnotify_change().
    
    This is equivalent to the original.  The reason it is needed, is that
    later in the series we move the immutable check into notify_change().
    That would break the FAT_IOCTL_SET_ATTRIBUTES ioctl, as it needs to
    perform the mode change regardless of the immutability of the file.
    
    [Fix error if fat is built as a module.  Thanks to OGAWA Hirofumi for
    noticing.]
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Acked-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 78ed3ffde242..ff7068727757 100644
--- a/security/security.c
+++ b/security/security.c
@@ -442,6 +442,7 @@ int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 		return 0;
 	return security_ops->inode_setattr(dentry, attr);
 }
+EXPORT_SYMBOL_GPL(security_inode_setattr);
 
 int security_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
 {

commit b77b0646ef4efe31a7449bb3d9360fd00f95433d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jul 17 09:37:02 2008 -0400

    [PATCH] pass MAY_OPEN to vfs_permission() explicitly
    
    ... and get rid of the last "let's deduce mask from nameidata->flags"
    bit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 59f23b5918b3..78ed3ffde242 100644
--- a/security/security.c
+++ b/security/security.c
@@ -429,11 +429,11 @@ int security_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
 	return security_ops->inode_follow_link(dentry, nd);
 }
 
-int security_inode_permission(struct inode *inode, int mask, struct nameidata *nd)
+int security_inode_permission(struct inode *inode, int mask)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	return security_ops->inode_permission(inode, mask, nd);
+	return security_ops->inode_permission(inode, mask);
 }
 
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)

commit 6f0f0fd496333777d53daff21a4e3b28c4d03a6d
Author: James Morris <jmorris@namei.org>
Date:   Thu Jul 10 17:02:07 2008 +0900

    security: remove register_security hook
    
    The register security hook is no longer required, as the capability
    module is always registered.  LSMs wishing to stack capability as
    a secondary module should do so explicitly.
    
    Signed-off-by: James Morris <jmorris@namei.org>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/security/security.c b/security/security.c
index 30b0278de394..59f23b5918b3 100644
--- a/security/security.c
+++ b/security/security.c
@@ -125,35 +125,6 @@ int register_security(struct security_operations *ops)
 	return 0;
 }
 
-/**
- * mod_reg_security - allows security modules to be "stacked"
- * @name: a pointer to a string with the name of the security_options to be registered
- * @ops: a pointer to the struct security_options that is to be registered
- *
- * This function allows security modules to be stacked if the currently loaded
- * security module allows this to happen.  It passes the @name and @ops to the
- * register_security function of the currently loaded security module.
- *
- * The return value depends on the currently loaded security module, with 0 as
- * success.
- */
-int mod_reg_security(const char *name, struct security_operations *ops)
-{
-	if (verify(ops)) {
-		printk(KERN_INFO "%s could not verify "
-		       "security operations.\n", __func__);
-		return -EINVAL;
-	}
-
-	if (ops == security_ops) {
-		printk(KERN_INFO "%s security operations "
-		       "already registered.\n", __func__);
-		return -EINVAL;
-	}
-
-	return security_ops->register_security(name, ops);
-}
-
 /* Security operations */
 
 int security_ptrace(struct task_struct *parent, struct task_struct *child,

commit 5915eb53861c5776cfec33ca4fcc1fd20d66dd27
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Jul 3 20:56:05 2008 +0200

    security: remove dummy module
    
    Remove the dummy module and make the "capability" module the default.
    
    Compile and boot tested.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 28b2860c1129..30b0278de394 100644
--- a/security/security.c
+++ b/security/security.c
@@ -20,8 +20,8 @@
 /* Boot-time LSM user choice */
 static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1];
 
-/* things that live in dummy.c */
-extern struct security_operations dummy_security_ops;
+/* things that live in capability.c */
+extern struct security_operations default_security_ops;
 extern void security_fixup_ops(struct security_operations *ops);
 
 struct security_operations *security_ops;	/* Initialized to NULL */
@@ -57,13 +57,8 @@ int __init security_init(void)
 {
 	printk(KERN_INFO "Security Framework initialized\n");
 
-	if (verify(&dummy_security_ops)) {
-		printk(KERN_ERR "%s could not verify "
-		       "dummy_security_ops structure.\n", __func__);
-		return -EIO;
-	}
-
-	security_ops = &dummy_security_ops;
+	security_fixup_ops(&default_security_ops);
+	security_ops = &default_security_ops;
 	do_security_initcalls();
 
 	return 0;
@@ -122,7 +117,7 @@ int register_security(struct security_operations *ops)
 		return -EINVAL;
 	}
 
-	if (security_ops != &dummy_security_ops)
+	if (security_ops != &default_security_ops)
 		return -EAGAIN;
 
 	security_ops = ops;

commit b478a9f9889c81e88077d1495daadee64c0af541
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Jul 3 20:56:04 2008 +0200

    security: remove unused sb_get_mnt_opts hook
    
    The sb_get_mnt_opts() hook is unused, and is superseded by the
    sb_show_options() hook.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Acked-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index de74fdccde26..28b2860c1129 100644
--- a/security/security.c
+++ b/security/security.c
@@ -348,12 +348,6 @@ void security_sb_post_pivotroot(struct path *old_path, struct path *new_path)
 	security_ops->sb_post_pivotroot(old_path, new_path);
 }
 
-int security_sb_get_mnt_opts(const struct super_block *sb,
-				struct security_mnt_opts *opts)
-{
-	return security_ops->sb_get_mnt_opts(sb, opts);
-}
-
 int security_sb_set_mnt_opts(struct super_block *sb,
 				struct security_mnt_opts *opts)
 {

commit 2069f457848f846cb31149c9aa29b330a6b66d1b
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Jul 4 09:47:13 2008 +1000

    LSM/SELinux: show LSM mount options in /proc/mounts
    
    This patch causes SELinux mount options to show up in /proc/mounts.  As
    with other code in the area seq_put errors are ignored.  Other LSM's
    will not have their mount options displayed until they fill in their own
    security_sb_show_options() function.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 2c0a5876b939..de74fdccde26 100644
--- a/security/security.c
+++ b/security/security.c
@@ -292,6 +292,11 @@ int security_sb_kern_mount(struct super_block *sb, void *data)
 	return security_ops->sb_kern_mount(sb, data);
 }
 
+int security_sb_show_options(struct seq_file *m, struct super_block *sb)
+{
+	return security_ops->sb_show_options(m, sb);
+}
+
 int security_sb_statfs(struct dentry *dentry)
 {
 	return security_ops->sb_statfs(dentry);

commit 65fc7668006b537f7ae8451990c0ed9ec882544e
Author: James Morris <jmorris@namei.org>
Date:   Thu Jun 12 01:00:10 2008 +1000

    security: fix return of void-valued expressions
    
    Fix several warnings generated by sparse of the form
    "returning void-valued expression".
    
    Signed-off-by: James Morris <jmorris@namei.org>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>

diff --git a/security/security.c b/security/security.c
index c4507ce2a5a0..2c0a5876b939 100644
--- a/security/security.c
+++ b/security/security.c
@@ -895,7 +895,7 @@ EXPORT_SYMBOL(security_secctx_to_secid);
 
 void security_release_secctx(char *secdata, u32 seclen)
 {
-	return security_ops->release_secctx(secdata, seclen);
+	security_ops->release_secctx(secdata, seclen);
 }
 EXPORT_SYMBOL(security_release_secctx);
 
@@ -1012,12 +1012,12 @@ int security_sk_alloc(struct sock *sk, int family, gfp_t priority)
 
 void security_sk_free(struct sock *sk)
 {
-	return security_ops->sk_free_security(sk);
+	security_ops->sk_free_security(sk);
 }
 
 void security_sk_clone(const struct sock *sk, struct sock *newsk)
 {
-	return security_ops->sk_clone_security(sk, newsk);
+	security_ops->sk_clone_security(sk, newsk);
 }
 
 void security_sk_classify_flow(struct sock *sk, struct flowi *fl)

commit 006ebb40d3d65338bd74abb03b945f8d60e362bd
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Mon May 19 08:32:49 2008 -0400

    Security: split proc ptrace checking into read vs. attach
    
    Enable security modules to distinguish reading of process state via
    proc from full ptrace access by renaming ptrace_may_attach to
    ptrace_may_access and adding a mode argument indicating whether only
    read access or full attach access is requested.  This allows security
    modules to permit access to reading process state without granting
    full ptrace access.  The base DAC/capability checking remains unchanged.
    
    Read access to /proc/pid/mem continues to apply a full ptrace attach
    check since check_mem_permission() already requires the current task
    to already be ptracing the target.  The other ptrace checks within
    proc for elements like environ, maps, and fds are changed to pass the
    read mode instead of attach.
    
    In the SELinux case, we model such reading of process state as a
    reading of a proc file labeled with the target process' label.  This
    enables SELinux policy to permit such reading of process state without
    permitting control or manipulation of the target process, as there are
    a number of cases where programs probe for such information via proc
    but do not need to be able to control the target (e.g. procps,
    lsof, PolicyKit, ConsoleKit).  At present we have to choose between
    allowing full ptrace in policy (more permissive than required/desired)
    or breaking functionality (or in some cases just silencing the denials
    via dontaudit rules but this can hide genuine attacks).
    
    This version of the patch incorporates comments from Casey Schaufler
    (change/replace existing ptrace_may_attach interface, pass access
    mode), and Chris Wright (provide greater consistency in the checking).
    
    Note that like their predecessors __ptrace_may_attach and
    ptrace_may_attach, the __ptrace_may_access and ptrace_may_access
    interfaces use different return value conventions from each other (0
    or -errno vs. 1 or 0).  I retained this difference to avoid any
    changes to the caller logic but made the difference clearer by
    changing the latter interface to return a bool rather than an int and
    by adding a comment about it to ptrace.h for any future callers.
    
    Signed-off-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 59838a99b80e..c4507ce2a5a0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -161,9 +161,10 @@ int mod_reg_security(const char *name, struct security_operations *ops)
 
 /* Security operations */
 
-int security_ptrace(struct task_struct *parent, struct task_struct *child)
+int security_ptrace(struct task_struct *parent, struct task_struct *child,
+		    unsigned int mode)
 {
-	return security_ops->ptrace(parent, child);
+	return security_ops->ptrace(parent, child, mode);
 }
 
 int security_capget(struct task_struct *target,

commit 7bf570dc8dcf76df2a9f583bef2da96d4289ed0d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 20:52:51 2008 +0100

    Security: Make secctx_to_secid() take const secdata
    
    Make secctx_to_secid() take constant secdata.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 8e64a29dc55d..59838a99b80e 100644
--- a/security/security.c
+++ b/security/security.c
@@ -886,7 +886,7 @@ int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 }
 EXPORT_SYMBOL(security_secid_to_secctx);
 
-int security_secctx_to_secid(char *secdata, u32 seclen, u32 *secid)
+int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
 {
 	return security_ops->secctx_to_secid(secdata, seclen, secid);
 }

commit 70a5bb72b55e82fbfbf1e22cae6975fac58a1e2d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:26 2008 -0700

    keys: add keyctl function to get a security label
    
    Add a keyctl() function to get the security label of a key.
    
    The following is added to Documentation/keys.txt:
    
     (*) Get the LSM security context attached to a key.
    
            long keyctl(KEYCTL_GET_SECURITY, key_serial_t key, char *buffer,
                        size_t buflen)
    
         This function returns a string that represents the LSM security context
         attached to a key in the buffer provided.
    
         Unless there's an error, it always returns the amount of data it could
         produce, even if that's too big for the buffer, but it won't copy more
         than requested to userspace. If the buffer pointer is NULL then no copy
         will take place.
    
         A NUL character is included at the end of the string if the buffer is
         sufficiently big.  This is included in the returned count.  If no LSM is
         in force then an empty string will be returned.
    
         A process must have view permission on the key for this function to be
         successful.
    
    [akpm@linux-foundation.org: declare keyctl_get_security()]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Paul Moore <paul.moore@hp.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: James Morris <jmorris@namei.org>
    Cc: Kevin Coffman <kwc@citi.umich.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index a809035441ab..8e64a29dc55d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1156,6 +1156,11 @@ int security_key_permission(key_ref_t key_ref,
 	return security_ops->key_permission(key_ref, context, perm);
 }
 
+int security_key_getsecurity(struct key *key, char **_buffer)
+{
+	return security_ops->key_getsecurity(key, _buffer);
+}
+
 #endif	/* CONFIG_KEYS */
 
 #ifdef CONFIG_AUDIT

commit 8f0cfa52a1d4ffacd8e7de906d19662f5da58d58
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 00:59:41 2008 -0700

    xattr: add missing consts to function arguments
    
    Add missing consts to xattr function arguments.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Andreas Gruenbacher <agruen@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index d5cb5898d967..a809035441ab 100644
--- a/security/security.c
+++ b/security/security.c
@@ -491,23 +491,23 @@ void security_inode_delete(struct inode *inode)
 	security_ops->inode_delete(inode);
 }
 
-int security_inode_setxattr(struct dentry *dentry, char *name,
-			     void *value, size_t size, int flags)
+int security_inode_setxattr(struct dentry *dentry, const char *name,
+			    const void *value, size_t size, int flags)
 {
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;
 	return security_ops->inode_setxattr(dentry, name, value, size, flags);
 }
 
-void security_inode_post_setxattr(struct dentry *dentry, char *name,
-				   void *value, size_t size, int flags)
+void security_inode_post_setxattr(struct dentry *dentry, const char *name,
+				  const void *value, size_t size, int flags)
 {
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return;
 	security_ops->inode_post_setxattr(dentry, name, value, size, flags);
 }
 
-int security_inode_getxattr(struct dentry *dentry, char *name)
+int security_inode_getxattr(struct dentry *dentry, const char *name)
 {
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;
@@ -521,7 +521,7 @@ int security_inode_listxattr(struct dentry *dentry)
 	return security_ops->inode_listxattr(dentry);
 }
 
-int security_inode_removexattr(struct dentry *dentry, char *name)
+int security_inode_removexattr(struct dentry *dentry, const char *name)
 {
 	if (unlikely(IS_PRIVATE(dentry->d_inode)))
 		return 0;

commit 3898b1b4ebff8dcfbcf1807e0661585e06c9a91c
Author: Andrew G. Morgan <morgan@kernel.org>
Date:   Mon Apr 28 02:13:40 2008 -0700

    capabilities: implement per-process securebits
    
    Filesystem capability support makes it possible to do away with (set)uid-0
    based privilege and use capabilities instead.  That is, with filesystem
    support for capabilities but without this present patch, it is (conceptually)
    possible to manage a system with capabilities alone and never need to obtain
    privilege via (set)uid-0.
    
    Of course, conceptually isn't quite the same as currently possible since few
    user applications, certainly not enough to run a viable system, are currently
    prepared to leverage capabilities to exercise privilege.  Further, many
    applications exist that may never get upgraded in this way, and the kernel
    will continue to want to support their setuid-0 base privilege needs.
    
    Where pure-capability applications evolve and replace setuid-0 binaries, it is
    desirable that there be a mechanisms by which they can contain their
    privilege.  In addition to leveraging the per-process bounding and inheritable
    sets, this should include suppressing the privilege of the uid-0 superuser
    from the process' tree of children.
    
    The feature added by this patch can be leveraged to suppress the privilege
    associated with (set)uid-0.  This suppression requires CAP_SETPCAP to
    initiate, and only immediately affects the 'current' process (it is inherited
    through fork()/exec()).  This reimplementation differs significantly from the
    historical support for securebits which was system-wide, unwieldy and which
    has ultimately withered to a dead relic in the source of the modern kernel.
    
    With this patch applied a process, that is capable(CAP_SETPCAP), can now drop
    all legacy privilege (through uid=0) for itself and all subsequently
    fork()'d/exec()'d children with:
    
      prctl(PR_SET_SECUREBITS, 0x2f);
    
    This patch represents a no-op unless CONFIG_SECURITY_FILE_CAPABILITIES is
    enabled at configure time.
    
    [akpm@linux-foundation.org: fix uninitialised var warning]
    [serue@us.ibm.com: capabilities: use cap_task_prctl when !CONFIG_SECURITY]
    Signed-off-by: Andrew G. Morgan <morgan@kernel.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Paul Moore <paul.moore@hp.com>
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 8a285c7b9962..d5cb5898d967 100644
--- a/security/security.c
+++ b/security/security.c
@@ -733,9 +733,9 @@ int security_task_wait(struct task_struct *p)
 }
 
 int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
-			 unsigned long arg4, unsigned long arg5)
+			 unsigned long arg4, unsigned long arg5, long *rc_p)
 {
-	return security_ops->task_prctl(option, arg2, arg3, arg4, arg5);
+	return security_ops->task_prctl(option, arg2, arg3, arg4, arg5, rc_p);
 }
 
 void security_task_reparent_to_init(struct task_struct *p)

commit b5266eb4c8d1a2887a19aaec8144ee4ad1b054c3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 22 17:48:24 2008 -0400

    [PATCH] switch a bunch of LSM hooks from nameidata to path
    
    Namely, ones from namespace.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/security.c b/security/security.c
index 2e250c7028eb..8a285c7b9962 100644
--- a/security/security.c
+++ b/security/security.c
@@ -296,15 +296,15 @@ int security_sb_statfs(struct dentry *dentry)
 	return security_ops->sb_statfs(dentry);
 }
 
-int security_sb_mount(char *dev_name, struct nameidata *nd,
+int security_sb_mount(char *dev_name, struct path *path,
                        char *type, unsigned long flags, void *data)
 {
-	return security_ops->sb_mount(dev_name, nd, type, flags, data);
+	return security_ops->sb_mount(dev_name, path, type, flags, data);
 }
 
-int security_sb_check_sb(struct vfsmount *mnt, struct nameidata *nd)
+int security_sb_check_sb(struct vfsmount *mnt, struct path *path)
 {
-	return security_ops->sb_check_sb(mnt, nd);
+	return security_ops->sb_check_sb(mnt, path);
 }
 
 int security_sb_umount(struct vfsmount *mnt, int flags)
@@ -327,19 +327,19 @@ void security_sb_post_remount(struct vfsmount *mnt, unsigned long flags, void *d
 	security_ops->sb_post_remount(mnt, flags, data);
 }
 
-void security_sb_post_addmount(struct vfsmount *mnt, struct nameidata *mountpoint_nd)
+void security_sb_post_addmount(struct vfsmount *mnt, struct path *mountpoint)
 {
-	security_ops->sb_post_addmount(mnt, mountpoint_nd);
+	security_ops->sb_post_addmount(mnt, mountpoint);
 }
 
-int security_sb_pivotroot(struct nameidata *old_nd, struct nameidata *new_nd)
+int security_sb_pivotroot(struct path *old_path, struct path *new_path)
 {
-	return security_ops->sb_pivotroot(old_nd, new_nd);
+	return security_ops->sb_pivotroot(old_path, new_path);
 }
 
-void security_sb_post_pivotroot(struct nameidata *old_nd, struct nameidata *new_nd)
+void security_sb_post_pivotroot(struct path *old_path, struct path *new_path)
 {
-	security_ops->sb_post_pivotroot(old_nd, new_nd);
+	security_ops->sb_post_pivotroot(old_path, new_path);
 }
 
 int security_sb_get_mnt_opts(const struct super_block *sb,

commit 3925e6fc1f774048404fdd910b0345b06c699eb4
Merge: 334d094504c2 7cea51be4e91
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 18 18:18:30 2008 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6:
      security: fix up documentation for security_module_enable
      Security: Introduce security= boot parameter
      Audit: Final renamings and cleanup
      SELinux: use new audit hooks, remove redundant exports
      Audit: internally use the new LSM audit hooks
      LSM/Audit: Introduce generic Audit LSM hooks
      SELinux: remove redundant exports
      Netlink: Use generic LSM hook
      Audit: use new LSM hooks instead of SELinux exports
      SELinux: setup new inode/ipc getsecid hooks
      LSM: Introduce inode_getsecid and ipc_getsecid hooks

commit 334d094504c2fe1c44211ecb49146ae6bca8c321
Merge: d1a4be630fb0 d1643d24c61b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 18 18:02:35 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-2.6.26
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-2.6.26: (1090 commits)
      [NET]: Fix and allocate less memory for ->priv'less netdevices
      [IPV6]: Fix dangling references on error in fib6_add().
      [NETLABEL]: Fix NULL deref in netlbl_unlabel_staticlist_gen() if ifindex not found
      [PKT_SCHED]: Fix datalen check in tcf_simp_init().
      [INET]: Uninline the __inet_inherit_port call.
      [INET]: Drop the inet_inherit_port() call.
      SCTP: Initialize partial_bytes_acked to 0, when all of the data is acked.
      [netdrvr] forcedeth: internal simplifications; changelog removal
      phylib: factor out get_phy_id from within get_phy_device
      PHY: add BCM5464 support to broadcom PHY driver
      cxgb3: Fix __must_check warning with dev_dbg.
      tc35815: Statistics cleanup
      natsemi: fix MMIO for PPC 44x platforms
      [TIPC]: Cleanup of TIPC reference table code
      [TIPC]: Optimized initialization of TIPC reference table
      [TIPC]: Remove inlining of reference table locking routines
      e1000: convert uint16_t style integers to u16
      ixgb: convert uint16_t style integers to u16
      sb1000.c: make const arrays static
      sb1000.c: stop inlining largish static functions
      ...

commit 7cea51be4e91edad05bd834f3235b45c57783f0d
Author: James Morris <jmorris@namei.org>
Date:   Fri Mar 7 12:23:49 2008 +1100

    security: fix up documentation for security_module_enable
    
    security_module_enable() can only be called during kernel init.
    
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index dd0c6baed494..4a6265ab3cc2 100644
--- a/security/security.c
+++ b/security/security.c
@@ -83,7 +83,7 @@ __setup("security=", choose_lsm);
  *
  * Each LSM must pass this method before registering its own operations
  * to avoid security registration races. This method may also be used
- * to check if your LSM is currently loaded.
+ * to check if your LSM is currently loaded during kernel initialization.
  *
  * Return true if:
  *	-The passed LSM is the one chosen by user at boot time,

commit 076c54c5bcaed2081c0cba94a6f77c4d470236ad
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Thu Mar 6 18:09:10 2008 +0200

    Security: Introduce security= boot parameter
    
    Add the security= boot parameter. This is done to avoid LSM
    registration clashes in case of more than one bult-in module.
    
    User can choose a security module to enable at boot. If no
    security= boot parameter is specified, only the first LSM
    asking for registration will be loaded. An invalid security
    module name will be treated as if no module has been chosen.
    
    LSM modules must check now if they are allowed to register
    by calling security_module_enable(ops) first. Modify SELinux
    and SMACK to do so.
    
    Do not let SMACK register smackfs if it was not chosen on
    boot. Smackfs assumes that smack hooks are registered and
    the initial task security setup (swapper->security) is done.
    
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Acked-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 2ef593ec70f3..dd0c6baed494 100644
--- a/security/security.c
+++ b/security/security.c
@@ -17,6 +17,8 @@
 #include <linux/kernel.h>
 #include <linux/security.h>
 
+/* Boot-time LSM user choice */
+static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1];
 
 /* things that live in dummy.c */
 extern struct security_operations dummy_security_ops;
@@ -67,13 +69,47 @@ int __init security_init(void)
 	return 0;
 }
 
+/* Save user chosen LSM */
+static int __init choose_lsm(char *str)
+{
+	strncpy(chosen_lsm, str, SECURITY_NAME_MAX);
+	return 1;
+}
+__setup("security=", choose_lsm);
+
+/**
+ * security_module_enable - Load given security module on boot ?
+ * @ops: a pointer to the struct security_operations that is to be checked.
+ *
+ * Each LSM must pass this method before registering its own operations
+ * to avoid security registration races. This method may also be used
+ * to check if your LSM is currently loaded.
+ *
+ * Return true if:
+ *	-The passed LSM is the one chosen by user at boot time,
+ *	-or user didsn't specify a specific LSM and we're the first to ask
+ *	 for registeration permissoin,
+ *	-or the passed LSM is currently loaded.
+ * Otherwise, return false.
+ */
+int __init security_module_enable(struct security_operations *ops)
+{
+	if (!*chosen_lsm)
+		strncpy(chosen_lsm, ops->name, SECURITY_NAME_MAX);
+	else if (strncmp(ops->name, chosen_lsm, SECURITY_NAME_MAX))
+		return 0;
+
+	return 1;
+}
+
 /**
  * register_security - registers a security framework with the kernel
  * @ops: a pointer to the struct security_options that is to be registered
  *
  * This function is to allow a security module to register itself with the
  * kernel security subsystem.  Some rudimentary checking is done on the @ops
- * value passed to this function.
+ * value passed to this function. You'll need to check first if your LSM
+ * is allowed to register its @ops by calling security_module_enable(@ops).
  *
  * If there is already a security module registered with the kernel,
  * an error will be returned.  Otherwise 0 is returned on success.

commit 03d37d25e0f91b28c4b6d002be6221f1af4b19d8
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Sat Mar 1 22:00:05 2008 +0200

    LSM/Audit: Introduce generic Audit LSM hooks
    
    Introduce a generic Audit interface for security modules
    by adding the following new LSM hooks:
    
    audit_rule_init(field, op, rulestr, lsmrule)
    audit_rule_known(krule)
    audit_rule_match(secid, field, op, rule, actx)
    audit_rule_free(rule)
    
    Those hooks are only available if CONFIG_AUDIT is enabled.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Acked-by: James Morris <jmorris@namei.org>
    Reviewed-by: Paul Moore <paul.moore@hp.com>

diff --git a/security/security.c b/security/security.c
index 290482bdbbb0..2ef593ec70f3 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1120,3 +1120,28 @@ int security_key_permission(key_ref_t key_ref,
 }
 
 #endif	/* CONFIG_KEYS */
+
+#ifdef CONFIG_AUDIT
+
+int security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
+{
+	return security_ops->audit_rule_init(field, op, rulestr, lsmrule);
+}
+
+int security_audit_rule_known(struct audit_krule *krule)
+{
+	return security_ops->audit_rule_known(krule);
+}
+
+void security_audit_rule_free(void *lsmrule)
+{
+	security_ops->audit_rule_free(lsmrule);
+}
+
+int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
+			      struct audit_context *actx)
+{
+	return security_ops->audit_rule_match(secid, field, op, lsmrule, actx);
+}
+
+#endif /* CONFIG_AUDIT */

commit 8a076191f373abaeb4aa5f6755d22e49db98940f
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Sat Mar 1 21:51:09 2008 +0200

    LSM: Introduce inode_getsecid and ipc_getsecid hooks
    
    Introduce inode_getsecid(inode, secid) and ipc_getsecid(ipcp, secid)
    LSM hooks. These hooks will be used instead of similar exported
    SELinux interfaces.
    
    Let {inode,ipc,task}_getsecid hooks set the secid to 0 by default
    if CONFIG_SECURITY is not defined or if the hook is set to
    NULL (dummy). This is done to notify the caller that no valid
    secid exists.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Acked-by: James Morris <jmorris@namei.org>
    Reviewed-by: Paul Moore <paul.moore@hp.com>

diff --git a/security/security.c b/security/security.c
index 9beecac933b4..290482bdbbb0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -523,6 +523,11 @@ int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer
 	return security_ops->inode_listsecurity(inode, buffer, buffer_size);
 }
 
+void security_inode_getsecid(const struct inode *inode, u32 *secid)
+{
+	security_ops->inode_getsecid(inode, secid);
+}
+
 int security_file_permission(struct file *file, int mask)
 {
 	return security_ops->file_permission(file, mask);
@@ -712,6 +717,11 @@ int security_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
 	return security_ops->ipc_permission(ipcp, flag);
 }
 
+void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
+{
+	security_ops->ipc_getsecid(ipcp, secid);
+}
+
 int security_msg_msg_alloc(struct msg_msg *msg)
 {
 	return security_ops->msg_msg_alloc_security(msg);

commit dd6f953adb5c4deb9cd7b6a5054e7d5eafe4ed71
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Mar 6 10:03:59 2008 +1100

    security: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index b1387a6b416d..9beecac933b4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -57,7 +57,7 @@ int __init security_init(void)
 
 	if (verify(&dummy_security_ops)) {
 		printk(KERN_ERR "%s could not verify "
-		       "dummy_security_ops structure.\n", __FUNCTION__);
+		       "dummy_security_ops structure.\n", __func__);
 		return -EIO;
 	}
 
@@ -82,7 +82,7 @@ int register_security(struct security_operations *ops)
 {
 	if (verify(ops)) {
 		printk(KERN_DEBUG "%s could not verify "
-		       "security_operations structure.\n", __FUNCTION__);
+		       "security_operations structure.\n", __func__);
 		return -EINVAL;
 	}
 
@@ -110,13 +110,13 @@ int mod_reg_security(const char *name, struct security_operations *ops)
 {
 	if (verify(ops)) {
 		printk(KERN_INFO "%s could not verify "
-		       "security operations.\n", __FUNCTION__);
+		       "security operations.\n", __func__);
 		return -EINVAL;
 	}
 
 	if (ops == security_ops) {
 		printk(KERN_INFO "%s security operations "
-		       "already registered.\n", __FUNCTION__);
+		       "already registered.\n", __func__);
 		return -EINVAL;
 	}
 

commit 03e1ad7b5d871d4189b1da3125c2f12d1b5f7d0b
Author: Paul Moore <paul.moore@hp.com>
Date:   Sat Apr 12 19:07:52 2008 -0700

    LSM: Make the Labeled IPsec hooks more stack friendly
    
    The xfrm_get_policy() and xfrm_add_pol_expire() put some rather large structs
    on the stack to work around the LSM API.  This patch attempts to fix that
    problem by changing the LSM API to require only the relevant "security"
    pointers instead of the entire SPD entry; we do this for all of the
    security_xfrm_policy*() functions to keep things consistent.
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/security/security.c b/security/security.c
index b1387a6b416d..c9ff7d18c2f4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1014,26 +1014,27 @@ void security_inet_conn_established(struct sock *sk,
 
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 
-int security_xfrm_policy_alloc(struct xfrm_policy *xp, struct xfrm_user_sec_ctx *sec_ctx)
+int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx)
 {
-	return security_ops->xfrm_policy_alloc_security(xp, sec_ctx);
+	return security_ops->xfrm_policy_alloc_security(ctxp, sec_ctx);
 }
 EXPORT_SYMBOL(security_xfrm_policy_alloc);
 
-int security_xfrm_policy_clone(struct xfrm_policy *old, struct xfrm_policy *new)
+int security_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,
+			      struct xfrm_sec_ctx **new_ctxp)
 {
-	return security_ops->xfrm_policy_clone_security(old, new);
+	return security_ops->xfrm_policy_clone_security(old_ctx, new_ctxp);
 }
 
-void security_xfrm_policy_free(struct xfrm_policy *xp)
+void security_xfrm_policy_free(struct xfrm_sec_ctx *ctx)
 {
-	security_ops->xfrm_policy_free_security(xp);
+	security_ops->xfrm_policy_free_security(ctx);
 }
 EXPORT_SYMBOL(security_xfrm_policy_free);
 
-int security_xfrm_policy_delete(struct xfrm_policy *xp)
+int security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)
 {
-	return security_ops->xfrm_policy_delete_security(xp);
+	return security_ops->xfrm_policy_delete_security(ctx);
 }
 
 int security_xfrm_state_alloc(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx)
@@ -1065,9 +1066,9 @@ void security_xfrm_state_free(struct xfrm_state *x)
 	security_ops->xfrm_state_free_security(x);
 }
 
-int security_xfrm_policy_lookup(struct xfrm_policy *xp, u32 fl_secid, u8 dir)
+int security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)
 {
-	return security_ops->xfrm_policy_lookup(xp, fl_secid, dir);
+	return security_ops->xfrm_policy_lookup(ctx, fl_secid, dir);
 }
 
 int security_xfrm_state_pol_flow_match(struct xfrm_state *x,

commit e0007529893c1c064be90bd21422ca0da4a0198e
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Mar 5 10:31:54 2008 -0500

    LSM/SELinux: Interfaces to allow FS to control mount options
    
    Introduce new LSM interfaces to allow an FS to deal with their own mount
    options.  This includes a new string parsing function exported from the
    LSM that an FS can use to get a security data blob and a new security
    data blob.  This is particularly useful for an FS which uses binary
    mount data, like NFS, which does not pass strings into the vfs to be
    handled by the loaded LSM.  Also fix a BUG() in both SELinux and SMACK
    when dealing with binary mount data.  If the binary mount data is less
    than one page the copy_page() in security_sb_copy_data() can cause an
    illegal page fault and boom.  Remove all NFSisms from the SELinux code
    since they were broken by past NFS changes.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index d15e56cbaade..b1387a6b416d 100644
--- a/security/security.c
+++ b/security/security.c
@@ -244,10 +244,11 @@ void security_sb_free(struct super_block *sb)
 	security_ops->sb_free_security(sb);
 }
 
-int security_sb_copy_data(struct file_system_type *type, void *orig, void *copy)
+int security_sb_copy_data(char *orig, char *copy)
 {
-	return security_ops->sb_copy_data(type, orig, copy);
+	return security_ops->sb_copy_data(orig, copy);
 }
+EXPORT_SYMBOL(security_sb_copy_data);
 
 int security_sb_kern_mount(struct super_block *sb, void *data)
 {
@@ -306,24 +307,30 @@ void security_sb_post_pivotroot(struct nameidata *old_nd, struct nameidata *new_
 }
 
 int security_sb_get_mnt_opts(const struct super_block *sb,
-			      char ***mount_options,
-			      int **flags, int *num_opts)
+				struct security_mnt_opts *opts)
 {
-	return security_ops->sb_get_mnt_opts(sb, mount_options, flags, num_opts);
+	return security_ops->sb_get_mnt_opts(sb, opts);
 }
 
 int security_sb_set_mnt_opts(struct super_block *sb,
-			      char **mount_options,
-			      int *flags, int num_opts)
+				struct security_mnt_opts *opts)
 {
-	return security_ops->sb_set_mnt_opts(sb, mount_options, flags, num_opts);
+	return security_ops->sb_set_mnt_opts(sb, opts);
 }
+EXPORT_SYMBOL(security_sb_set_mnt_opts);
 
 void security_sb_clone_mnt_opts(const struct super_block *oldsb,
 				struct super_block *newsb)
 {
 	security_ops->sb_clone_mnt_opts(oldsb, newsb);
 }
+EXPORT_SYMBOL(security_sb_clone_mnt_opts);
+
+int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)
+{
+	return security_ops->sb_parse_opts_str(options, opts);
+}
+EXPORT_SYMBOL(security_sb_parse_opts_str);
 
 int security_inode_alloc(struct inode *inode)
 {

commit a5ecbcb8c13ea8a822d243bf782d0dc9525b4f84
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Jan 31 15:11:22 2008 -0500

    security: allow Kconfig to set default mmap_min_addr protection
    
    Since it was decided that low memory protection from userspace couldn't
    be turned on by default add a Kconfig option to allow users/distros to
    set a default at compile time.  This value is still tunable after boot
    in /proc/sys/vm/mmap_min_addr
    
    Discussion:
    http://www.mail-archive.com/linux-security-module@vger.kernel.org/msg02543.html
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index b6c57a6b2ff5..d15e56cbaade 100644
--- a/security/security.c
+++ b/security/security.c
@@ -23,7 +23,9 @@ extern struct security_operations dummy_security_ops;
 extern void security_fixup_ops(struct security_operations *ops);
 
 struct security_operations *security_ops;	/* Initialized to NULL */
-unsigned long mmap_min_addr;		/* 0 means no protection */
+
+/* amount of vm to protect from userspace access */
+unsigned long mmap_min_addr = CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR;
 
 static inline int verify(struct security_operations *ops)
 {

commit 42492594043d621a7910ff5877c3eb9202870b45
Author: David P. Quigley <dpquigl@tycho.nsa.gov>
Date:   Mon Feb 4 22:29:39 2008 -0800

    VFS/Security: Rework inode_getsecurity and callers to return resulting buffer
    
    This patch modifies the interface to inode_getsecurity to have the function
    return a buffer containing the security blob and its length via parameters
    instead of relying on the calling function to give it an appropriately sized
    buffer.
    
    Security blobs obtained with this function should be freed using the
    release_secctx LSM hook.  This alleviates the problem of the caller having to
    guess a length and preallocate a buffer for this function allowing it to be
    used elsewhere for Labeled NFS.
    
    The patch also removed the unused err parameter.  The conversion is similar to
    the one performed by Al Viro for the security_getprocattr hook.
    
    Signed-off-by: David P. Quigley <dpquigl@tycho.nsa.gov>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index ca475ca206e4..b6c57a6b2ff5 100644
--- a/security/security.c
+++ b/security/security.c
@@ -493,11 +493,11 @@ int security_inode_killpriv(struct dentry *dentry)
 	return security_ops->inode_killpriv(dentry);
 }
 
-int security_inode_getsecurity(const struct inode *inode, const char *name, void *buffer, size_t size, int err)
+int security_inode_getsecurity(const struct inode *inode, const char *name, void **buffer, bool alloc)
 {
 	if (unlikely(IS_PRIVATE(inode)))
 		return 0;
-	return security_ops->inode_getsecurity(inode, name, buffer, size, err);
+	return security_ops->inode_getsecurity(inode, name, buffer, alloc);
 }
 
 int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)

commit 63cb34492351078479b2d4bae6a881806a396286
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 15 23:47:35 2008 +0000

    security: add a secctx_to_secid() hook
    
    Add a secctx_to_secid() LSM hook to go along with the existing
    secid_to_secctx() LSM hook.  This patch also includes the SELinux
    implementation for this hook.
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 5068808343d0..ca475ca206e4 100644
--- a/security/security.c
+++ b/security/security.c
@@ -831,6 +831,12 @@ int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 }
 EXPORT_SYMBOL(security_secid_to_secctx);
 
+int security_secctx_to_secid(char *secdata, u32 seclen, u32 *secid)
+{
+	return security_ops->secctx_to_secid(secdata, seclen, secid);
+}
+EXPORT_SYMBOL(security_secctx_to_secid);
+
 void security_release_secctx(char *secdata, u32 seclen)
 {
 	return security_ops->release_secctx(secdata, seclen);

commit bced95283e9434611cbad8f2ff903cd396eaea72
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Sat Dec 29 16:20:25 2007 -0800

    security: remove security_sb_post_mountroot hook
    
    The security_sb_post_mountroot() hook is long-since obsolete, and is
    fundamentally broken: it is never invoked if someone uses initramfs.
    This is particularly damaging, because the existence of this hook has
    been used as motivation for not using initramfs.
    
    Stephen Smalley confirmed on 2007-07-19 that this hook was originally
    used by SELinux but can now be safely removed:
    
         http://marc.info/?l=linux-kernel&m=118485683612916&w=2
    
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index b13b54f0af85..5068808343d0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -288,11 +288,6 @@ void security_sb_post_remount(struct vfsmount *mnt, unsigned long flags, void *d
 	security_ops->sb_post_remount(mnt, flags, data);
 }
 
-void security_sb_post_mountroot(void)
-{
-	security_ops->sb_post_mountroot();
-}
-
 void security_sb_post_addmount(struct vfsmount *mnt, struct nameidata *mountpoint_nd)
 {
 	security_ops->sb_post_addmount(mnt, mountpoint_nd);

commit c9180a57a9ab2d5525faf8815a332364ee9e89b7
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Nov 30 13:00:35 2007 -0500

    Security: add get, set, and cloning of superblock security information
    
    Adds security_get_sb_mnt_opts, security_set_sb_mnt_opts, and
    security_clont_sb_mnt_opts to the LSM and to SELinux.  This will allow
    filesystems to directly own and control all of their mount options if they
    so choose.  This interface deals only with option identifiers and strings so
    it should generic enough for any LSM which may come in the future.
    
    Filesystems which pass text mount data around in the kernel (almost all of
    them) need not currently make use of this interface when dealing with
    SELinux since it will still parse those strings as it always has.  I assume
    future LSM's would do the same.  NFS is the primary FS which does not use
    text mount data and thus must make use of this interface.
    
    An LSM would need to implement these functions only if they had mount time
    options, such as selinux has context= or fscontext=.  If the LSM has no
    mount time options they could simply not implement and let the dummy ops
    take care of things.
    
    An LSM other than SELinux would need to define new option numbers in
    security.h and any FS which decides to own there own security options would
    need to be patched to use this new interface for every possible LSM.  This
    is because it was stated to me very clearly that LSM's should not attempt to
    understand FS mount data and the burdon to understand security should be in
    the FS which owns the options.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Stephen D. Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 0e1f1f124368..b13b54f0af85 100644
--- a/security/security.c
+++ b/security/security.c
@@ -308,6 +308,26 @@ void security_sb_post_pivotroot(struct nameidata *old_nd, struct nameidata *new_
 	security_ops->sb_post_pivotroot(old_nd, new_nd);
 }
 
+int security_sb_get_mnt_opts(const struct super_block *sb,
+			      char ***mount_options,
+			      int **flags, int *num_opts)
+{
+	return security_ops->sb_get_mnt_opts(sb, mount_options, flags, num_opts);
+}
+
+int security_sb_set_mnt_opts(struct super_block *sb,
+			      char **mount_options,
+			      int *flags, int num_opts)
+{
+	return security_ops->sb_set_mnt_opts(sb, mount_options, flags, num_opts);
+}
+
+void security_sb_clone_mnt_opts(const struct super_block *oldsb,
+				struct super_block *newsb)
+{
+	security_ops->sb_clone_mnt_opts(oldsb, newsb);
+}
+
 int security_inode_alloc(struct inode *inode)
 {
 	inode->i_security = NULL;

commit cbfee34520666862f8ff539e580c48958fbb7706
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 16 23:31:38 2007 -0700

    security/ cleanups
    
    This patch contains the following cleanups that are now possible:
    - remove the unused security_operations->inode_xattr_getsuffix
    - remove the no longer used security_operations->unregister_security
    - remove some no longer required exit code
    - remove a bunch of no longer used exports
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: James Morris <jmorris@namei.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 2e1b35dd2550..0e1f1f124368 100644
--- a/security/security.c
+++ b/security/security.c
@@ -71,8 +71,7 @@ int __init security_init(void)
  *
  * This function is to allow a security module to register itself with the
  * kernel security subsystem.  Some rudimentary checking is done on the @ops
- * value passed to this function.  A call to unregister_security() should be
- * done to remove this security_options structure from the kernel.
+ * value passed to this function.
  *
  * If there is already a security module registered with the kernel,
  * an error will be returned.  Otherwise 0 is returned on success.
@@ -93,31 +92,6 @@ int register_security(struct security_operations *ops)
 	return 0;
 }
 
-/**
- * unregister_security - unregisters a security framework with the kernel
- * @ops: a pointer to the struct security_options that is to be registered
- *
- * This function removes a struct security_operations variable that had
- * previously been registered with a successful call to register_security().
- *
- * If @ops does not match the valued previously passed to register_security()
- * an error is returned.  Otherwise the default security options is set to the
- * the dummy_security_ops structure, and 0 is returned.
- */
-int unregister_security(struct security_operations *ops)
-{
-	if (ops != security_ops) {
-		printk(KERN_INFO "%s: trying to unregister "
-		       "a security_opts structure that is not "
-		       "registered, failing.\n", __FUNCTION__);
-		return -EINVAL;
-	}
-
-	security_ops = &dummy_security_ops;
-
-	return 0;
-}
-
 /**
  * mod_reg_security - allows security modules to be "stacked"
  * @name: a pointer to a string with the name of the security_options to be registered
@@ -147,30 +121,6 @@ int mod_reg_security(const char *name, struct security_operations *ops)
 	return security_ops->register_security(name, ops);
 }
 
-/**
- * mod_unreg_security - allows a security module registered with mod_reg_security() to be unloaded
- * @name: a pointer to a string with the name of the security_options to be removed
- * @ops: a pointer to the struct security_options that is to be removed
- *
- * This function allows security modules that have been successfully registered
- * with a call to mod_reg_security() to be unloaded from the system.
- * This calls the currently loaded security module's unregister_security() call
- * with the @name and @ops variables.
- *
- * The return value depends on the currently loaded security module, with 0 as
- * success.
- */
-int mod_unreg_security(const char *name, struct security_operations *ops)
-{
-	if (ops == security_ops) {
-		printk(KERN_INFO "%s invalid attempt to unregister "
-		       " primary security ops.\n", __FUNCTION__);
-		return -EINVAL;
-	}
-
-	return security_ops->unregister_security(name, ops);
-}
-
 /* Security operations */
 
 int security_ptrace(struct task_struct *parent, struct task_struct *child)
@@ -528,11 +478,6 @@ int security_inode_killpriv(struct dentry *dentry)
 	return security_ops->inode_killpriv(dentry);
 }
 
-const char *security_inode_xattr_getsuffix(void)
-{
-	return security_ops->inode_xattr_getsuffix();
-}
-
 int security_inode_getsecurity(const struct inode *inode, const char *name, void *buffer, size_t size, int err)
 {
 	if (unlikely(IS_PRIVATE(inode)))
@@ -858,7 +803,6 @@ int security_netlink_send(struct sock *sk, struct sk_buff *skb)
 {
 	return security_ops->netlink_send(sk, skb);
 }
-EXPORT_SYMBOL(security_netlink_send);
 
 int security_netlink_recv(struct sk_buff *skb, int cap)
 {

commit b53767719b6cd8789392ea3e7e2eb7b8906898f0
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Tue Oct 16 23:31:36 2007 -0700

    Implement file posix capabilities
    
    Implement file posix capabilities.  This allows programs to be given a
    subset of root's powers regardless of who runs them, without having to use
    setuid and giving the binary all of root's powers.
    
    This version works with Kaigai Kohei's userspace tools, found at
    http://www.kaigai.gr.jp/index.php.  For more information on how to use this
    patch, Chris Friedhoff has posted a nice page at
    http://www.friedhoff.org/fscaps.html.
    
    Changelog:
            Nov 27:
            Incorporate fixes from Andrew Morton
            (security-introduce-file-caps-tweaks and
            security-introduce-file-caps-warning-fix)
            Fix Kconfig dependency.
            Fix change signaling behavior when file caps are not compiled in.
    
            Nov 13:
            Integrate comments from Alexey: Remove CONFIG_ ifdef from
            capability.h, and use %zd for printing a size_t.
    
            Nov 13:
            Fix endianness warnings by sparse as suggested by Alexey
            Dobriyan.
    
            Nov 09:
            Address warnings of unused variables at cap_bprm_set_security
            when file capabilities are disabled, and simultaneously clean
            up the code a little, by pulling the new code into a helper
            function.
    
            Nov 08:
            For pointers to required userspace tools and how to use
            them, see http://www.friedhoff.org/fscaps.html.
    
            Nov 07:
            Fix the calculation of the highest bit checked in
            check_cap_sanity().
    
            Nov 07:
            Allow file caps to be enabled without CONFIG_SECURITY, since
            capabilities are the default.
            Hook cap_task_setscheduler when !CONFIG_SECURITY.
            Move capable(TASK_KILL) to end of cap_task_kill to reduce
            audit messages.
    
            Nov 05:
            Add secondary calls in selinux/hooks.c to task_setioprio and
            task_setscheduler so that selinux and capabilities with file
            cap support can be stacked.
    
            Sep 05:
            As Seth Arnold points out, uid checks are out of place
            for capability code.
    
            Sep 01:
            Define task_setscheduler, task_setioprio, cap_task_kill, and
            task_setnice to make sure a user cannot affect a process in which
            they called a program with some fscaps.
    
            One remaining question is the note under task_setscheduler: are we
            ok with CAP_SYS_NICE being sufficient to confine a process to a
            cpuset?
    
            It is a semantic change, as without fsccaps, attach_task doesn't
            allow CAP_SYS_NICE to override the uid equivalence check.  But since
            it uses security_task_setscheduler, which elsewhere is used where
            CAP_SYS_NICE can be used to override the uid equivalence check,
            fixing it might be tough.
    
                 task_setscheduler
                     note: this also controls cpuset:attach_task.  Are we ok with
                         CAP_SYS_NICE being used to confine to a cpuset?
                 task_setioprio
                 task_setnice
                     sys_setpriority uses this (through set_one_prio) for another
                     process.  Need same checks as setrlimit
    
            Aug 21:
            Updated secureexec implementation to reflect the fact that
            euid and uid might be the same and nonzero, but the process
            might still have elevated caps.
    
            Aug 15:
            Handle endianness of xattrs.
            Enforce capability version match between kernel and disk.
            Enforce that no bits beyond the known max capability are
            set, else return -EPERM.
            With this extra processing, it may be worth reconsidering
            doing all the work at bprm_set_security rather than
            d_instantiate.
    
            Aug 10:
            Always call getxattr at bprm_set_security, rather than
            caching it at d_instantiate.
    
    [morgan@kernel.org: file-caps clean up for linux/capability.h]
    [bunk@kernel.org: unexport cap_inode_killpriv]
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Andrew Morgan <morgan@kernel.org>
    Signed-off-by: Andrew Morgan <morgan@kernel.org>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 5b1c034815a8..2e1b35dd2550 100644
--- a/security/security.c
+++ b/security/security.c
@@ -518,6 +518,16 @@ int security_inode_removexattr(struct dentry *dentry, char *name)
 	return security_ops->inode_removexattr(dentry, name);
 }
 
+int security_inode_need_killpriv(struct dentry *dentry)
+{
+	return security_ops->inode_need_killpriv(dentry);
+}
+
+int security_inode_killpriv(struct dentry *dentry)
+{
+	return security_ops->inode_killpriv(dentry);
+}
+
 const char *security_inode_xattr_getsuffix(void)
 {
 	return security_ops->inode_xattr_getsuffix();

commit 20510f2f4e2dabb0ff6c13901807627ec9452f98
Author: James Morris <jmorris@namei.org>
Date:   Tue Oct 16 23:31:32 2007 -0700

    security: Convert LSM into a static interface
    
    Convert LSM into a static interface, as the ability to unload a security
    module is not required by in-tree users and potentially complicates the
    overall security architecture.
    
    Needlessly exported LSM symbols have been unexported, to help reduce API
    abuse.
    
    Parameters for the capability and root_plug modules are now specified
    at boot.
    
    The SECURITY_FRAMEWORK_VERSION macro has also been removed.
    
    In a nutshell, there is no safe way to unload an LSM.  The modular interface
    is thus unecessary and broken infrastructure.  It is used only by out-of-tree
    modules, which are often binary-only, illegal, abusive of the API and
    dangerous, e.g.  silently re-vectoring SELinux.
    
    [akpm@linux-foundation.org: cleanups]
    [akpm@linux-foundation.org: USB Kconfig fix]
    [randy.dunlap@oracle.com: fix LSM kernel-doc]
    Signed-off-by: James Morris <jmorris@namei.org>
    Acked-by: Chris Wright <chrisw@sous-sol.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: "Serge E. Hallyn" <serue@us.ibm.com>
    Acked-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index 27e5863d30f1..5b1c034815a8 100644
--- a/security/security.c
+++ b/security/security.c
@@ -17,7 +17,6 @@
 #include <linux/kernel.h>
 #include <linux/security.h>
 
-#define SECURITY_FRAMEWORK_VERSION	"1.0.0"
 
 /* things that live in dummy.c */
 extern struct security_operations dummy_security_ops;
@@ -52,8 +51,7 @@ static void __init do_security_initcalls(void)
  */
 int __init security_init(void)
 {
-	printk(KERN_INFO "Security Framework v" SECURITY_FRAMEWORK_VERSION
-	       " initialized\n");
+	printk(KERN_INFO "Security Framework initialized\n");
 
 	if (verify(&dummy_security_ops)) {
 		printk(KERN_ERR "%s could not verify "
@@ -173,8 +171,958 @@ int mod_unreg_security(const char *name, struct security_operations *ops)
 	return security_ops->unregister_security(name, ops);
 }
 
-EXPORT_SYMBOL_GPL(register_security);
-EXPORT_SYMBOL_GPL(unregister_security);
-EXPORT_SYMBOL_GPL(mod_reg_security);
-EXPORT_SYMBOL_GPL(mod_unreg_security);
-EXPORT_SYMBOL(security_ops);
+/* Security operations */
+
+int security_ptrace(struct task_struct *parent, struct task_struct *child)
+{
+	return security_ops->ptrace(parent, child);
+}
+
+int security_capget(struct task_struct *target,
+		     kernel_cap_t *effective,
+		     kernel_cap_t *inheritable,
+		     kernel_cap_t *permitted)
+{
+	return security_ops->capget(target, effective, inheritable, permitted);
+}
+
+int security_capset_check(struct task_struct *target,
+			   kernel_cap_t *effective,
+			   kernel_cap_t *inheritable,
+			   kernel_cap_t *permitted)
+{
+	return security_ops->capset_check(target, effective, inheritable, permitted);
+}
+
+void security_capset_set(struct task_struct *target,
+			  kernel_cap_t *effective,
+			  kernel_cap_t *inheritable,
+			  kernel_cap_t *permitted)
+{
+	security_ops->capset_set(target, effective, inheritable, permitted);
+}
+
+int security_capable(struct task_struct *tsk, int cap)
+{
+	return security_ops->capable(tsk, cap);
+}
+
+int security_acct(struct file *file)
+{
+	return security_ops->acct(file);
+}
+
+int security_sysctl(struct ctl_table *table, int op)
+{
+	return security_ops->sysctl(table, op);
+}
+
+int security_quotactl(int cmds, int type, int id, struct super_block *sb)
+{
+	return security_ops->quotactl(cmds, type, id, sb);
+}
+
+int security_quota_on(struct dentry *dentry)
+{
+	return security_ops->quota_on(dentry);
+}
+
+int security_syslog(int type)
+{
+	return security_ops->syslog(type);
+}
+
+int security_settime(struct timespec *ts, struct timezone *tz)
+{
+	return security_ops->settime(ts, tz);
+}
+
+int security_vm_enough_memory(long pages)
+{
+	return security_ops->vm_enough_memory(current->mm, pages);
+}
+
+int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
+{
+	return security_ops->vm_enough_memory(mm, pages);
+}
+
+int security_bprm_alloc(struct linux_binprm *bprm)
+{
+	return security_ops->bprm_alloc_security(bprm);
+}
+
+void security_bprm_free(struct linux_binprm *bprm)
+{
+	security_ops->bprm_free_security(bprm);
+}
+
+void security_bprm_apply_creds(struct linux_binprm *bprm, int unsafe)
+{
+	security_ops->bprm_apply_creds(bprm, unsafe);
+}
+
+void security_bprm_post_apply_creds(struct linux_binprm *bprm)
+{
+	security_ops->bprm_post_apply_creds(bprm);
+}
+
+int security_bprm_set(struct linux_binprm *bprm)
+{
+	return security_ops->bprm_set_security(bprm);
+}
+
+int security_bprm_check(struct linux_binprm *bprm)
+{
+	return security_ops->bprm_check_security(bprm);
+}
+
+int security_bprm_secureexec(struct linux_binprm *bprm)
+{
+	return security_ops->bprm_secureexec(bprm);
+}
+
+int security_sb_alloc(struct super_block *sb)
+{
+	return security_ops->sb_alloc_security(sb);
+}
+
+void security_sb_free(struct super_block *sb)
+{
+	security_ops->sb_free_security(sb);
+}
+
+int security_sb_copy_data(struct file_system_type *type, void *orig, void *copy)
+{
+	return security_ops->sb_copy_data(type, orig, copy);
+}
+
+int security_sb_kern_mount(struct super_block *sb, void *data)
+{
+	return security_ops->sb_kern_mount(sb, data);
+}
+
+int security_sb_statfs(struct dentry *dentry)
+{
+	return security_ops->sb_statfs(dentry);
+}
+
+int security_sb_mount(char *dev_name, struct nameidata *nd,
+                       char *type, unsigned long flags, void *data)
+{
+	return security_ops->sb_mount(dev_name, nd, type, flags, data);
+}
+
+int security_sb_check_sb(struct vfsmount *mnt, struct nameidata *nd)
+{
+	return security_ops->sb_check_sb(mnt, nd);
+}
+
+int security_sb_umount(struct vfsmount *mnt, int flags)
+{
+	return security_ops->sb_umount(mnt, flags);
+}
+
+void security_sb_umount_close(struct vfsmount *mnt)
+{
+	security_ops->sb_umount_close(mnt);
+}
+
+void security_sb_umount_busy(struct vfsmount *mnt)
+{
+	security_ops->sb_umount_busy(mnt);
+}
+
+void security_sb_post_remount(struct vfsmount *mnt, unsigned long flags, void *data)
+{
+	security_ops->sb_post_remount(mnt, flags, data);
+}
+
+void security_sb_post_mountroot(void)
+{
+	security_ops->sb_post_mountroot();
+}
+
+void security_sb_post_addmount(struct vfsmount *mnt, struct nameidata *mountpoint_nd)
+{
+	security_ops->sb_post_addmount(mnt, mountpoint_nd);
+}
+
+int security_sb_pivotroot(struct nameidata *old_nd, struct nameidata *new_nd)
+{
+	return security_ops->sb_pivotroot(old_nd, new_nd);
+}
+
+void security_sb_post_pivotroot(struct nameidata *old_nd, struct nameidata *new_nd)
+{
+	security_ops->sb_post_pivotroot(old_nd, new_nd);
+}
+
+int security_inode_alloc(struct inode *inode)
+{
+	inode->i_security = NULL;
+	return security_ops->inode_alloc_security(inode);
+}
+
+void security_inode_free(struct inode *inode)
+{
+	security_ops->inode_free_security(inode);
+}
+
+int security_inode_init_security(struct inode *inode, struct inode *dir,
+				  char **name, void **value, size_t *len)
+{
+	if (unlikely(IS_PRIVATE(inode)))
+		return -EOPNOTSUPP;
+	return security_ops->inode_init_security(inode, dir, name, value, len);
+}
+EXPORT_SYMBOL(security_inode_init_security);
+
+int security_inode_create(struct inode *dir, struct dentry *dentry, int mode)
+{
+	if (unlikely(IS_PRIVATE(dir)))
+		return 0;
+	return security_ops->inode_create(dir, dentry, mode);
+}
+
+int security_inode_link(struct dentry *old_dentry, struct inode *dir,
+			 struct dentry *new_dentry)
+{
+	if (unlikely(IS_PRIVATE(old_dentry->d_inode)))
+		return 0;
+	return security_ops->inode_link(old_dentry, dir, new_dentry);
+}
+
+int security_inode_unlink(struct inode *dir, struct dentry *dentry)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_unlink(dir, dentry);
+}
+
+int security_inode_symlink(struct inode *dir, struct dentry *dentry,
+			    const char *old_name)
+{
+	if (unlikely(IS_PRIVATE(dir)))
+		return 0;
+	return security_ops->inode_symlink(dir, dentry, old_name);
+}
+
+int security_inode_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	if (unlikely(IS_PRIVATE(dir)))
+		return 0;
+	return security_ops->inode_mkdir(dir, dentry, mode);
+}
+
+int security_inode_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_rmdir(dir, dentry);
+}
+
+int security_inode_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	if (unlikely(IS_PRIVATE(dir)))
+		return 0;
+	return security_ops->inode_mknod(dir, dentry, mode, dev);
+}
+
+int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,
+			   struct inode *new_dir, struct dentry *new_dentry)
+{
+        if (unlikely(IS_PRIVATE(old_dentry->d_inode) ||
+            (new_dentry->d_inode && IS_PRIVATE(new_dentry->d_inode))))
+		return 0;
+	return security_ops->inode_rename(old_dir, old_dentry,
+					   new_dir, new_dentry);
+}
+
+int security_inode_readlink(struct dentry *dentry)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_readlink(dentry);
+}
+
+int security_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_follow_link(dentry, nd);
+}
+
+int security_inode_permission(struct inode *inode, int mask, struct nameidata *nd)
+{
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+	return security_ops->inode_permission(inode, mask, nd);
+}
+
+int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_setattr(dentry, attr);
+}
+
+int security_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_getattr(mnt, dentry);
+}
+
+void security_inode_delete(struct inode *inode)
+{
+	if (unlikely(IS_PRIVATE(inode)))
+		return;
+	security_ops->inode_delete(inode);
+}
+
+int security_inode_setxattr(struct dentry *dentry, char *name,
+			     void *value, size_t size, int flags)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_setxattr(dentry, name, value, size, flags);
+}
+
+void security_inode_post_setxattr(struct dentry *dentry, char *name,
+				   void *value, size_t size, int flags)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return;
+	security_ops->inode_post_setxattr(dentry, name, value, size, flags);
+}
+
+int security_inode_getxattr(struct dentry *dentry, char *name)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_getxattr(dentry, name);
+}
+
+int security_inode_listxattr(struct dentry *dentry)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_listxattr(dentry);
+}
+
+int security_inode_removexattr(struct dentry *dentry, char *name)
+{
+	if (unlikely(IS_PRIVATE(dentry->d_inode)))
+		return 0;
+	return security_ops->inode_removexattr(dentry, name);
+}
+
+const char *security_inode_xattr_getsuffix(void)
+{
+	return security_ops->inode_xattr_getsuffix();
+}
+
+int security_inode_getsecurity(const struct inode *inode, const char *name, void *buffer, size_t size, int err)
+{
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+	return security_ops->inode_getsecurity(inode, name, buffer, size, err);
+}
+
+int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)
+{
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+	return security_ops->inode_setsecurity(inode, name, value, size, flags);
+}
+
+int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)
+{
+	if (unlikely(IS_PRIVATE(inode)))
+		return 0;
+	return security_ops->inode_listsecurity(inode, buffer, buffer_size);
+}
+
+int security_file_permission(struct file *file, int mask)
+{
+	return security_ops->file_permission(file, mask);
+}
+
+int security_file_alloc(struct file *file)
+{
+	return security_ops->file_alloc_security(file);
+}
+
+void security_file_free(struct file *file)
+{
+	security_ops->file_free_security(file);
+}
+
+int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	return security_ops->file_ioctl(file, cmd, arg);
+}
+
+int security_file_mmap(struct file *file, unsigned long reqprot,
+			unsigned long prot, unsigned long flags,
+			unsigned long addr, unsigned long addr_only)
+{
+	return security_ops->file_mmap(file, reqprot, prot, flags, addr, addr_only);
+}
+
+int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,
+			    unsigned long prot)
+{
+	return security_ops->file_mprotect(vma, reqprot, prot);
+}
+
+int security_file_lock(struct file *file, unsigned int cmd)
+{
+	return security_ops->file_lock(file, cmd);
+}
+
+int security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	return security_ops->file_fcntl(file, cmd, arg);
+}
+
+int security_file_set_fowner(struct file *file)
+{
+	return security_ops->file_set_fowner(file);
+}
+
+int security_file_send_sigiotask(struct task_struct *tsk,
+				  struct fown_struct *fown, int sig)
+{
+	return security_ops->file_send_sigiotask(tsk, fown, sig);
+}
+
+int security_file_receive(struct file *file)
+{
+	return security_ops->file_receive(file);
+}
+
+int security_dentry_open(struct file *file)
+{
+	return security_ops->dentry_open(file);
+}
+
+int security_task_create(unsigned long clone_flags)
+{
+	return security_ops->task_create(clone_flags);
+}
+
+int security_task_alloc(struct task_struct *p)
+{
+	return security_ops->task_alloc_security(p);
+}
+
+void security_task_free(struct task_struct *p)
+{
+	security_ops->task_free_security(p);
+}
+
+int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
+{
+	return security_ops->task_setuid(id0, id1, id2, flags);
+}
+
+int security_task_post_setuid(uid_t old_ruid, uid_t old_euid,
+			       uid_t old_suid, int flags)
+{
+	return security_ops->task_post_setuid(old_ruid, old_euid, old_suid, flags);
+}
+
+int security_task_setgid(gid_t id0, gid_t id1, gid_t id2, int flags)
+{
+	return security_ops->task_setgid(id0, id1, id2, flags);
+}
+
+int security_task_setpgid(struct task_struct *p, pid_t pgid)
+{
+	return security_ops->task_setpgid(p, pgid);
+}
+
+int security_task_getpgid(struct task_struct *p)
+{
+	return security_ops->task_getpgid(p);
+}
+
+int security_task_getsid(struct task_struct *p)
+{
+	return security_ops->task_getsid(p);
+}
+
+void security_task_getsecid(struct task_struct *p, u32 *secid)
+{
+	security_ops->task_getsecid(p, secid);
+}
+EXPORT_SYMBOL(security_task_getsecid);
+
+int security_task_setgroups(struct group_info *group_info)
+{
+	return security_ops->task_setgroups(group_info);
+}
+
+int security_task_setnice(struct task_struct *p, int nice)
+{
+	return security_ops->task_setnice(p, nice);
+}
+
+int security_task_setioprio(struct task_struct *p, int ioprio)
+{
+	return security_ops->task_setioprio(p, ioprio);
+}
+
+int security_task_getioprio(struct task_struct *p)
+{
+	return security_ops->task_getioprio(p);
+}
+
+int security_task_setrlimit(unsigned int resource, struct rlimit *new_rlim)
+{
+	return security_ops->task_setrlimit(resource, new_rlim);
+}
+
+int security_task_setscheduler(struct task_struct *p,
+				int policy, struct sched_param *lp)
+{
+	return security_ops->task_setscheduler(p, policy, lp);
+}
+
+int security_task_getscheduler(struct task_struct *p)
+{
+	return security_ops->task_getscheduler(p);
+}
+
+int security_task_movememory(struct task_struct *p)
+{
+	return security_ops->task_movememory(p);
+}
+
+int security_task_kill(struct task_struct *p, struct siginfo *info,
+			int sig, u32 secid)
+{
+	return security_ops->task_kill(p, info, sig, secid);
+}
+
+int security_task_wait(struct task_struct *p)
+{
+	return security_ops->task_wait(p);
+}
+
+int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
+			 unsigned long arg4, unsigned long arg5)
+{
+	return security_ops->task_prctl(option, arg2, arg3, arg4, arg5);
+}
+
+void security_task_reparent_to_init(struct task_struct *p)
+{
+	security_ops->task_reparent_to_init(p);
+}
+
+void security_task_to_inode(struct task_struct *p, struct inode *inode)
+{
+	security_ops->task_to_inode(p, inode);
+}
+
+int security_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
+{
+	return security_ops->ipc_permission(ipcp, flag);
+}
+
+int security_msg_msg_alloc(struct msg_msg *msg)
+{
+	return security_ops->msg_msg_alloc_security(msg);
+}
+
+void security_msg_msg_free(struct msg_msg *msg)
+{
+	security_ops->msg_msg_free_security(msg);
+}
+
+int security_msg_queue_alloc(struct msg_queue *msq)
+{
+	return security_ops->msg_queue_alloc_security(msq);
+}
+
+void security_msg_queue_free(struct msg_queue *msq)
+{
+	security_ops->msg_queue_free_security(msq);
+}
+
+int security_msg_queue_associate(struct msg_queue *msq, int msqflg)
+{
+	return security_ops->msg_queue_associate(msq, msqflg);
+}
+
+int security_msg_queue_msgctl(struct msg_queue *msq, int cmd)
+{
+	return security_ops->msg_queue_msgctl(msq, cmd);
+}
+
+int security_msg_queue_msgsnd(struct msg_queue *msq,
+			       struct msg_msg *msg, int msqflg)
+{
+	return security_ops->msg_queue_msgsnd(msq, msg, msqflg);
+}
+
+int security_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+			       struct task_struct *target, long type, int mode)
+{
+	return security_ops->msg_queue_msgrcv(msq, msg, target, type, mode);
+}
+
+int security_shm_alloc(struct shmid_kernel *shp)
+{
+	return security_ops->shm_alloc_security(shp);
+}
+
+void security_shm_free(struct shmid_kernel *shp)
+{
+	security_ops->shm_free_security(shp);
+}
+
+int security_shm_associate(struct shmid_kernel *shp, int shmflg)
+{
+	return security_ops->shm_associate(shp, shmflg);
+}
+
+int security_shm_shmctl(struct shmid_kernel *shp, int cmd)
+{
+	return security_ops->shm_shmctl(shp, cmd);
+}
+
+int security_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmflg)
+{
+	return security_ops->shm_shmat(shp, shmaddr, shmflg);
+}
+
+int security_sem_alloc(struct sem_array *sma)
+{
+	return security_ops->sem_alloc_security(sma);
+}
+
+void security_sem_free(struct sem_array *sma)
+{
+	security_ops->sem_free_security(sma);
+}
+
+int security_sem_associate(struct sem_array *sma, int semflg)
+{
+	return security_ops->sem_associate(sma, semflg);
+}
+
+int security_sem_semctl(struct sem_array *sma, int cmd)
+{
+	return security_ops->sem_semctl(sma, cmd);
+}
+
+int security_sem_semop(struct sem_array *sma, struct sembuf *sops,
+			unsigned nsops, int alter)
+{
+	return security_ops->sem_semop(sma, sops, nsops, alter);
+}
+
+void security_d_instantiate(struct dentry *dentry, struct inode *inode)
+{
+	if (unlikely(inode && IS_PRIVATE(inode)))
+		return;
+	security_ops->d_instantiate(dentry, inode);
+}
+EXPORT_SYMBOL(security_d_instantiate);
+
+int security_getprocattr(struct task_struct *p, char *name, char **value)
+{
+	return security_ops->getprocattr(p, name, value);
+}
+
+int security_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+	return security_ops->setprocattr(p, name, value, size);
+}
+
+int security_netlink_send(struct sock *sk, struct sk_buff *skb)
+{
+	return security_ops->netlink_send(sk, skb);
+}
+EXPORT_SYMBOL(security_netlink_send);
+
+int security_netlink_recv(struct sk_buff *skb, int cap)
+{
+	return security_ops->netlink_recv(skb, cap);
+}
+EXPORT_SYMBOL(security_netlink_recv);
+
+int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
+{
+	return security_ops->secid_to_secctx(secid, secdata, seclen);
+}
+EXPORT_SYMBOL(security_secid_to_secctx);
+
+void security_release_secctx(char *secdata, u32 seclen)
+{
+	return security_ops->release_secctx(secdata, seclen);
+}
+EXPORT_SYMBOL(security_release_secctx);
+
+#ifdef CONFIG_SECURITY_NETWORK
+
+int security_unix_stream_connect(struct socket *sock, struct socket *other,
+				 struct sock *newsk)
+{
+	return security_ops->unix_stream_connect(sock, other, newsk);
+}
+EXPORT_SYMBOL(security_unix_stream_connect);
+
+int security_unix_may_send(struct socket *sock,  struct socket *other)
+{
+	return security_ops->unix_may_send(sock, other);
+}
+EXPORT_SYMBOL(security_unix_may_send);
+
+int security_socket_create(int family, int type, int protocol, int kern)
+{
+	return security_ops->socket_create(family, type, protocol, kern);
+}
+
+int security_socket_post_create(struct socket *sock, int family,
+				int type, int protocol, int kern)
+{
+	return security_ops->socket_post_create(sock, family, type,
+						protocol, kern);
+}
+
+int security_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+	return security_ops->socket_bind(sock, address, addrlen);
+}
+
+int security_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+	return security_ops->socket_connect(sock, address, addrlen);
+}
+
+int security_socket_listen(struct socket *sock, int backlog)
+{
+	return security_ops->socket_listen(sock, backlog);
+}
+
+int security_socket_accept(struct socket *sock, struct socket *newsock)
+{
+	return security_ops->socket_accept(sock, newsock);
+}
+
+void security_socket_post_accept(struct socket *sock, struct socket *newsock)
+{
+	security_ops->socket_post_accept(sock, newsock);
+}
+
+int security_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size)
+{
+	return security_ops->socket_sendmsg(sock, msg, size);
+}
+
+int security_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+			    int size, int flags)
+{
+	return security_ops->socket_recvmsg(sock, msg, size, flags);
+}
+
+int security_socket_getsockname(struct socket *sock)
+{
+	return security_ops->socket_getsockname(sock);
+}
+
+int security_socket_getpeername(struct socket *sock)
+{
+	return security_ops->socket_getpeername(sock);
+}
+
+int security_socket_getsockopt(struct socket *sock, int level, int optname)
+{
+	return security_ops->socket_getsockopt(sock, level, optname);
+}
+
+int security_socket_setsockopt(struct socket *sock, int level, int optname)
+{
+	return security_ops->socket_setsockopt(sock, level, optname);
+}
+
+int security_socket_shutdown(struct socket *sock, int how)
+{
+	return security_ops->socket_shutdown(sock, how);
+}
+
+int security_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	return security_ops->socket_sock_rcv_skb(sk, skb);
+}
+EXPORT_SYMBOL(security_sock_rcv_skb);
+
+int security_socket_getpeersec_stream(struct socket *sock, char __user *optval,
+				      int __user *optlen, unsigned len)
+{
+	return security_ops->socket_getpeersec_stream(sock, optval, optlen, len);
+}
+
+int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)
+{
+	return security_ops->socket_getpeersec_dgram(sock, skb, secid);
+}
+EXPORT_SYMBOL(security_socket_getpeersec_dgram);
+
+int security_sk_alloc(struct sock *sk, int family, gfp_t priority)
+{
+	return security_ops->sk_alloc_security(sk, family, priority);
+}
+
+void security_sk_free(struct sock *sk)
+{
+	return security_ops->sk_free_security(sk);
+}
+
+void security_sk_clone(const struct sock *sk, struct sock *newsk)
+{
+	return security_ops->sk_clone_security(sk, newsk);
+}
+
+void security_sk_classify_flow(struct sock *sk, struct flowi *fl)
+{
+	security_ops->sk_getsecid(sk, &fl->secid);
+}
+EXPORT_SYMBOL(security_sk_classify_flow);
+
+void security_req_classify_flow(const struct request_sock *req, struct flowi *fl)
+{
+	security_ops->req_classify_flow(req, fl);
+}
+EXPORT_SYMBOL(security_req_classify_flow);
+
+void security_sock_graft(struct sock *sk, struct socket *parent)
+{
+	security_ops->sock_graft(sk, parent);
+}
+EXPORT_SYMBOL(security_sock_graft);
+
+int security_inet_conn_request(struct sock *sk,
+			struct sk_buff *skb, struct request_sock *req)
+{
+	return security_ops->inet_conn_request(sk, skb, req);
+}
+EXPORT_SYMBOL(security_inet_conn_request);
+
+void security_inet_csk_clone(struct sock *newsk,
+			const struct request_sock *req)
+{
+	security_ops->inet_csk_clone(newsk, req);
+}
+
+void security_inet_conn_established(struct sock *sk,
+			struct sk_buff *skb)
+{
+	security_ops->inet_conn_established(sk, skb);
+}
+
+#endif	/* CONFIG_SECURITY_NETWORK */
+
+#ifdef CONFIG_SECURITY_NETWORK_XFRM
+
+int security_xfrm_policy_alloc(struct xfrm_policy *xp, struct xfrm_user_sec_ctx *sec_ctx)
+{
+	return security_ops->xfrm_policy_alloc_security(xp, sec_ctx);
+}
+EXPORT_SYMBOL(security_xfrm_policy_alloc);
+
+int security_xfrm_policy_clone(struct xfrm_policy *old, struct xfrm_policy *new)
+{
+	return security_ops->xfrm_policy_clone_security(old, new);
+}
+
+void security_xfrm_policy_free(struct xfrm_policy *xp)
+{
+	security_ops->xfrm_policy_free_security(xp);
+}
+EXPORT_SYMBOL(security_xfrm_policy_free);
+
+int security_xfrm_policy_delete(struct xfrm_policy *xp)
+{
+	return security_ops->xfrm_policy_delete_security(xp);
+}
+
+int security_xfrm_state_alloc(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx)
+{
+	return security_ops->xfrm_state_alloc_security(x, sec_ctx, 0);
+}
+EXPORT_SYMBOL(security_xfrm_state_alloc);
+
+int security_xfrm_state_alloc_acquire(struct xfrm_state *x,
+				      struct xfrm_sec_ctx *polsec, u32 secid)
+{
+	if (!polsec)
+		return 0;
+	/*
+	 * We want the context to be taken from secid which is usually
+	 * from the sock.
+	 */
+	return security_ops->xfrm_state_alloc_security(x, NULL, secid);
+}
+
+int security_xfrm_state_delete(struct xfrm_state *x)
+{
+	return security_ops->xfrm_state_delete_security(x);
+}
+EXPORT_SYMBOL(security_xfrm_state_delete);
+
+void security_xfrm_state_free(struct xfrm_state *x)
+{
+	security_ops->xfrm_state_free_security(x);
+}
+
+int security_xfrm_policy_lookup(struct xfrm_policy *xp, u32 fl_secid, u8 dir)
+{
+	return security_ops->xfrm_policy_lookup(xp, fl_secid, dir);
+}
+
+int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
+				       struct xfrm_policy *xp, struct flowi *fl)
+{
+	return security_ops->xfrm_state_pol_flow_match(x, xp, fl);
+}
+
+int security_xfrm_decode_session(struct sk_buff *skb, u32 *secid)
+{
+	return security_ops->xfrm_decode_session(skb, secid, 1);
+}
+
+void security_skb_classify_flow(struct sk_buff *skb, struct flowi *fl)
+{
+	int rc = security_ops->xfrm_decode_session(skb, &fl->secid, 0);
+
+	BUG_ON(rc);
+}
+EXPORT_SYMBOL(security_skb_classify_flow);
+
+#endif	/* CONFIG_SECURITY_NETWORK_XFRM */
+
+#ifdef CONFIG_KEYS
+
+int security_key_alloc(struct key *key, struct task_struct *tsk, unsigned long flags)
+{
+	return security_ops->key_alloc(key, tsk, flags);
+}
+
+void security_key_free(struct key *key)
+{
+	security_ops->key_free(key);
+}
+
+int security_key_permission(key_ref_t key_ref,
+			    struct task_struct *context, key_perm_t perm)
+{
+	return security_ops->key_permission(key_ref, context, perm);
+}
+
+#endif	/* CONFIG_KEYS */

commit d4cf291526a74cc33d33700a35b74395eec812fd
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Jul 1 22:23:53 2007 +0200

    security: unexport mmap_min_addr
    
    Remove unneeded export.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index 024484fc59b0..27e5863d30f1 100644
--- a/security/security.c
+++ b/security/security.c
@@ -177,5 +177,4 @@ EXPORT_SYMBOL_GPL(register_security);
 EXPORT_SYMBOL_GPL(unregister_security);
 EXPORT_SYMBOL_GPL(mod_reg_security);
 EXPORT_SYMBOL_GPL(mod_unreg_security);
-EXPORT_SYMBOL_GPL(mmap_min_addr);
 EXPORT_SYMBOL(security_ops);

commit ed0321895182ffb6ecf210e066d87911b270d587
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Jun 28 15:55:21 2007 -0400

    security: Protection for exploiting null dereference using mmap
    
    Add a new security check on mmap operations to see if the user is attempting
    to mmap to low area of the address space.  The amount of space protected is
    indicated by the new proc tunable /proc/sys/vm/mmap_min_addr and defaults to
    0, preserving existing behavior.
    
    This patch uses a new SELinux security class "memprotect."  Policy already
    contains a number of allow rules like a_t self:process * (unconfined_t being
    one of them) which mean that putting this check in the process class (its
    best current fit) would make it useless as all user processes, which we also
    want to protect against, would be allowed. By taking the memprotect name of
    the new class it will also make it possible for us to move some of the other
    memory protect permissions out of 'process' and into the new class next time
    we bump the policy version number (which I also think is a good future idea)
    
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/security.c b/security/security.c
index fc8601b2b7ac..024484fc59b0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -24,6 +24,7 @@ extern struct security_operations dummy_security_ops;
 extern void security_fixup_ops(struct security_operations *ops);
 
 struct security_operations *security_ops;	/* Initialized to NULL */
+unsigned long mmap_min_addr;		/* 0 means no protection */
 
 static inline int verify(struct security_operations *ops)
 {
@@ -176,4 +177,5 @@ EXPORT_SYMBOL_GPL(register_security);
 EXPORT_SYMBOL_GPL(unregister_security);
 EXPORT_SYMBOL_GPL(mod_reg_security);
 EXPORT_SYMBOL_GPL(mod_unreg_security);
+EXPORT_SYMBOL_GPL(mmap_min_addr);
 EXPORT_SYMBOL(security_ops);

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/security.c b/security/security.c
index ee4e0701b6e0..fc8601b2b7ac 100644
--- a/security/security.c
+++ b/security/security.c
@@ -15,7 +15,6 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/security.h>
 
 #define SECURITY_FRAMEWORK_VERSION	"1.0.0"

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/security/security.c b/security/security.c
index 51ef509710b9..ee4e0701b6e0 100644
--- a/security/security.c
+++ b/security/security.c
@@ -12,7 +12,6 @@
  */
 
 #include <linux/capability.h>
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>

commit 12b5989be10011387a9da5dee82e5c0d6f9d02e7
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Sat Mar 25 03:07:41 2006 -0800

    [PATCH] refactor capable() to one implementation, add __capable() helper
    
    Move capable() to kernel/capability.c and eliminate duplicate
    implementations.  Add __capable() function which can be used to check for
    capabiilty of any process.
    
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/security.c b/security/security.c
index f693e1f66b98..51ef509710b9 100644
--- a/security/security.c
+++ b/security/security.c
@@ -174,31 +174,8 @@ int mod_unreg_security(const char *name, struct security_operations *ops)
 	return security_ops->unregister_security(name, ops);
 }
 
-/**
- * capable - calls the currently loaded security module's capable() function with the specified capability
- * @cap: the requested capability level.
- *
- * This function calls the currently loaded security module's capable()
- * function with a pointer to the current task and the specified @cap value.
- *
- * This allows the security module to implement the capable function call
- * however it chooses to.
- */
-int capable(int cap)
-{
-	if (security_ops->capable(current, cap)) {
-		/* capability denied */
-		return 0;
-	}
-
-	/* capability granted */
-	current->flags |= PF_SUPERPRIV;
-	return 1;
-}
-
 EXPORT_SYMBOL_GPL(register_security);
 EXPORT_SYMBOL_GPL(unregister_security);
 EXPORT_SYMBOL_GPL(mod_reg_security);
 EXPORT_SYMBOL_GPL(mod_unreg_security);
-EXPORT_SYMBOL(capable);
 EXPORT_SYMBOL(security_ops);

commit c59ede7b78db329949d9cdcd7064e22d357560ef
Author: Randy.Dunlap <rdunlap@xenotime.net>
Date:   Wed Jan 11 12:17:46 2006 -0800

    [PATCH] move capable() to capability.h
    
    - Move capable() from sched.h to capability.h;
    
    - Use <linux/capability.h> where capable() is used
            (in include/, block/, ipc/, kernel/, a few drivers/,
            mm/, security/, & sound/;
            many more drivers/ to go)
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/security.c b/security/security.c
index ed5fb80769c3..f693e1f66b98 100644
--- a/security/security.c
+++ b/security/security.c
@@ -11,6 +11,7 @@
  *	(at your option) any later version.
  */
 
+#include <linux/capability.h>
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/security/security.c b/security/security.c
new file mode 100644
index 000000000000..ed5fb80769c3
--- /dev/null
+++ b/security/security.c
@@ -0,0 +1,203 @@
+/*
+ * Security plug functions
+ *
+ * Copyright (C) 2001 WireX Communications, Inc <chris@wirex.com>
+ * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>
+ * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/security.h>
+
+#define SECURITY_FRAMEWORK_VERSION	"1.0.0"
+
+/* things that live in dummy.c */
+extern struct security_operations dummy_security_ops;
+extern void security_fixup_ops(struct security_operations *ops);
+
+struct security_operations *security_ops;	/* Initialized to NULL */
+
+static inline int verify(struct security_operations *ops)
+{
+	/* verify the security_operations structure exists */
+	if (!ops)
+		return -EINVAL;
+	security_fixup_ops(ops);
+	return 0;
+}
+
+static void __init do_security_initcalls(void)
+{
+	initcall_t *call;
+	call = __security_initcall_start;
+	while (call < __security_initcall_end) {
+		(*call) ();
+		call++;
+	}
+}
+
+/**
+ * security_init - initializes the security framework
+ *
+ * This should be called early in the kernel initialization sequence.
+ */
+int __init security_init(void)
+{
+	printk(KERN_INFO "Security Framework v" SECURITY_FRAMEWORK_VERSION
+	       " initialized\n");
+
+	if (verify(&dummy_security_ops)) {
+		printk(KERN_ERR "%s could not verify "
+		       "dummy_security_ops structure.\n", __FUNCTION__);
+		return -EIO;
+	}
+
+	security_ops = &dummy_security_ops;
+	do_security_initcalls();
+
+	return 0;
+}
+
+/**
+ * register_security - registers a security framework with the kernel
+ * @ops: a pointer to the struct security_options that is to be registered
+ *
+ * This function is to allow a security module to register itself with the
+ * kernel security subsystem.  Some rudimentary checking is done on the @ops
+ * value passed to this function.  A call to unregister_security() should be
+ * done to remove this security_options structure from the kernel.
+ *
+ * If there is already a security module registered with the kernel,
+ * an error will be returned.  Otherwise 0 is returned on success.
+ */
+int register_security(struct security_operations *ops)
+{
+	if (verify(ops)) {
+		printk(KERN_DEBUG "%s could not verify "
+		       "security_operations structure.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (security_ops != &dummy_security_ops)
+		return -EAGAIN;
+
+	security_ops = ops;
+
+	return 0;
+}
+
+/**
+ * unregister_security - unregisters a security framework with the kernel
+ * @ops: a pointer to the struct security_options that is to be registered
+ *
+ * This function removes a struct security_operations variable that had
+ * previously been registered with a successful call to register_security().
+ *
+ * If @ops does not match the valued previously passed to register_security()
+ * an error is returned.  Otherwise the default security options is set to the
+ * the dummy_security_ops structure, and 0 is returned.
+ */
+int unregister_security(struct security_operations *ops)
+{
+	if (ops != security_ops) {
+		printk(KERN_INFO "%s: trying to unregister "
+		       "a security_opts structure that is not "
+		       "registered, failing.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	security_ops = &dummy_security_ops;
+
+	return 0;
+}
+
+/**
+ * mod_reg_security - allows security modules to be "stacked"
+ * @name: a pointer to a string with the name of the security_options to be registered
+ * @ops: a pointer to the struct security_options that is to be registered
+ *
+ * This function allows security modules to be stacked if the currently loaded
+ * security module allows this to happen.  It passes the @name and @ops to the
+ * register_security function of the currently loaded security module.
+ *
+ * The return value depends on the currently loaded security module, with 0 as
+ * success.
+ */
+int mod_reg_security(const char *name, struct security_operations *ops)
+{
+	if (verify(ops)) {
+		printk(KERN_INFO "%s could not verify "
+		       "security operations.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (ops == security_ops) {
+		printk(KERN_INFO "%s security operations "
+		       "already registered.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	return security_ops->register_security(name, ops);
+}
+
+/**
+ * mod_unreg_security - allows a security module registered with mod_reg_security() to be unloaded
+ * @name: a pointer to a string with the name of the security_options to be removed
+ * @ops: a pointer to the struct security_options that is to be removed
+ *
+ * This function allows security modules that have been successfully registered
+ * with a call to mod_reg_security() to be unloaded from the system.
+ * This calls the currently loaded security module's unregister_security() call
+ * with the @name and @ops variables.
+ *
+ * The return value depends on the currently loaded security module, with 0 as
+ * success.
+ */
+int mod_unreg_security(const char *name, struct security_operations *ops)
+{
+	if (ops == security_ops) {
+		printk(KERN_INFO "%s invalid attempt to unregister "
+		       " primary security ops.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	return security_ops->unregister_security(name, ops);
+}
+
+/**
+ * capable - calls the currently loaded security module's capable() function with the specified capability
+ * @cap: the requested capability level.
+ *
+ * This function calls the currently loaded security module's capable()
+ * function with a pointer to the current task and the specified @cap value.
+ *
+ * This allows the security module to implement the capable function call
+ * however it chooses to.
+ */
+int capable(int cap)
+{
+	if (security_ops->capable(current, cap)) {
+		/* capability denied */
+		return 0;
+	}
+
+	/* capability granted */
+	current->flags |= PF_SUPERPRIV;
+	return 1;
+}
+
+EXPORT_SYMBOL_GPL(register_security);
+EXPORT_SYMBOL_GPL(unregister_security);
+EXPORT_SYMBOL_GPL(mod_reg_security);
+EXPORT_SYMBOL_GPL(mod_unreg_security);
+EXPORT_SYMBOL(capable);
+EXPORT_SYMBOL(security_ops);
