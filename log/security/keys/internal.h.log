commit 6c3297841472b4e53e22e53826eea9e483d993e5
Merge: df2fbf5bfa0e a8478a602913
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 13 09:56:21 2020 -0700

    Merge tag 'notifications-20200601' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull notification queue from David Howells:
     "This adds a general notification queue concept and adds an event
      source for keys/keyrings, such as linking and unlinking keys and
      changing their attributes.
    
      Thanks to Debarshi Ray, we do have a pull request to use this to fix a
      problem with gnome-online-accounts - as mentioned last time:
    
         https://gitlab.gnome.org/GNOME/gnome-online-accounts/merge_requests/47
    
      Without this, g-o-a has to constantly poll a keyring-based kerberos
      cache to find out if kinit has changed anything.
    
      [ There are other notification pending: mount/sb fsinfo notifications
        for libmount that Karel Zak and Ian Kent have been working on, and
        Christian Brauner would like to use them in lxc, but let's see how
        this one works first ]
    
      LSM hooks are included:
    
       - A set of hooks are provided that allow an LSM to rule on whether or
         not a watch may be set. Each of these hooks takes a different
         "watched object" parameter, so they're not really shareable. The
         LSM should use current's credentials. [Wanted by SELinux & Smack]
    
       - A hook is provided to allow an LSM to rule on whether or not a
         particular message may be posted to a particular queue. This is
         given the credentials from the event generator (which may be the
         system) and the watch setter. [Wanted by Smack]
    
      I've provided SELinux and Smack with implementations of some of these
      hooks.
    
      WHY
      ===
    
      Key/keyring notifications are desirable because if you have your
      kerberos tickets in a file/directory, your Gnome desktop will monitor
      that using something like fanotify and tell you if your credentials
      cache changes.
    
      However, we also have the ability to cache your kerberos tickets in
      the session, user or persistent keyring so that it isn't left around
      on disk across a reboot or logout. Keyrings, however, cannot currently
      be monitored asynchronously, so the desktop has to poll for it - not
      so good on a laptop. This facility will allow the desktop to avoid the
      need to poll.
    
      DESIGN DECISIONS
      ================
    
       - The notification queue is built on top of a standard pipe. Messages
         are effectively spliced in. The pipe is opened with a special flag:
    
            pipe2(fds, O_NOTIFICATION_PIPE);
    
         The special flag has the same value as O_EXCL (which doesn't seem
         like it will ever be applicable in this context)[?]. It is given up
         front to make it a lot easier to prohibit splice&co from accessing
         the pipe.
    
         [?] Should this be done some other way?  I'd rather not use up a new
             O_* flag if I can avoid it - should I add a pipe3() system call
             instead?
    
         The pipe is then configured::
    
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_SIZE, queue_depth);
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_FILTER, &filter);
    
         Messages are then read out of the pipe using read().
    
       - It should be possible to allow write() to insert data into the
         notification pipes too, but this is currently disabled as the
         kernel has to be able to insert messages into the pipe *without*
         holding pipe->mutex and the code to make this work needs careful
         auditing.
    
       - sendfile(), splice() and vmsplice() are disabled on notification
         pipes because of the pipe->mutex issue and also because they
         sometimes want to revert what they just did - but one or more
         notification messages might've been interleaved in the ring.
    
       - The kernel inserts messages with the wait queue spinlock held. This
         means that pipe_read() and pipe_write() have to take the spinlock
         to update the queue pointers.
    
       - Records in the buffer are binary, typed and have a length so that
         they can be of varying size.
    
         This allows multiple heterogeneous sources to share a common
         buffer; there are 16 million types available, of which I've used
         just a few, so there is scope for others to be used. Tags may be
         specified when a watchpoint is created to help distinguish the
         sources.
    
       - Records are filterable as types have up to 256 subtypes that can be
         individually filtered. Other filtration is also available.
    
       - Notification pipes don't interfere with each other; each may be
         bound to a different set of watches. Any particular notification
         will be copied to all the queues that are currently watching for it
         - and only those that are watching for it.
    
       - When recording a notification, the kernel will not sleep, but will
         rather mark a queue as having lost a message if there's
         insufficient space. read() will fabricate a loss notification
         message at an appropriate point later.
    
       - The notification pipe is created and then watchpoints are attached
         to it, using one of:
    
            keyctl_watch_key(KEY_SPEC_SESSION_KEYRING, fds[1], 0x01);
            watch_mount(AT_FDCWD, "/", 0, fd, 0x02);
            watch_sb(AT_FDCWD, "/mnt", 0, fd, 0x03);
    
         where in both cases, fd indicates the queue and the number after is
         a tag between 0 and 255.
    
       - Watches are removed if either the notification pipe is destroyed or
         the watched object is destroyed. In the latter case, a message will
         be generated indicating the enforced watch removal.
    
      Things I want to avoid:
    
       - Introducing features that make the core VFS dependent on the
         network stack or networking namespaces (ie. usage of netlink).
    
       - Dumping all this stuff into dmesg and having a daemon that sits
         there parsing the output and distributing it as this then puts the
         responsibility for security into userspace and makes handling
         namespaces tricky. Further, dmesg might not exist or might be
         inaccessible inside a container.
    
       - Letting users see events they shouldn't be able to see.
    
      TESTING AND MANPAGES
      ====================
    
       - The keyutils tree has a pipe-watch branch that has keyctl commands
         for making use of notifications. Proposed manual pages can also be
         found on this branch, though a couple of them really need to go to
         the main manpages repository instead.
    
         If the kernel supports the watching of keys, then running "make
         test" on that branch will cause the testing infrastructure to spawn
         a monitoring process on the side that monitors a notifications pipe
         for all the key/keyring changes induced by the tests and they'll
         all be checked off to make sure they happened.
    
            https://git.kernel.org/pub/scm/linux/kernel/git/dhowells/keyutils.git/log/?h=pipe-watch
    
       - A test program is provided (samples/watch_queue/watch_test) that
         can be used to monitor for keyrings, mount and superblock events.
         Information on the notifications is simply logged to stdout"
    
    * tag 'notifications-20200601' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      smack: Implement the watch_key and post_notification hooks
      selinux: Implement the watch_key security hook
      keys: Make the KEY_NEED_* perms an enum rather than a mask
      pipe: Add notification lossage handling
      pipe: Allow buffers to be marked read-whole-or-error for notifications
      Add sample notification program
      watch_queue: Add a key/keyring notification facility
      security: Add hooks to rule on setting a watch
      pipe: Add general notification queue support
      pipe: Add O_NOTIFICATION_PIPE
      security: Add a hook for the point of notification insertion
      uapi: General notification queue definitions

commit d4eaa2837851db2bfed572898bfc17f9a9f9151e
Author: Waiman Long <longman@redhat.com>
Date:   Thu Jun 4 16:48:21 2020 -0700

    mm: add kvfree_sensitive() for freeing sensitive data objects
    
    For kvmalloc'ed data object that contains sensitive information like
    cryptographic keys, we need to make sure that the buffer is always cleared
    before freeing it.  Using memset() alone for buffer clearing may not
    provide certainty as the compiler may compile it away.  To be sure, the
    special memzero_explicit() has to be used.
    
    This patch introduces a new kvfree_sensitive() for freeing those sensitive
    data objects allocated by kvmalloc().  The relevant places where
    kvfree_sensitive() can be used are modified to use it.
    
    Fixes: 4f0882491a14 ("KEYS: Avoid false positive ENOMEM error on key read")
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Waiman Long <longman@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Uladzislau Rezki <urezki@gmail.com>
    Link: http://lkml.kernel.org/r/20200407200318.11711-1-longman@redhat.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 6d0ca48ae9a5..153d35c20d3d 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -350,15 +350,4 @@ static inline void key_check(const struct key *key)
 #define key_check(key) do {} while(0)
 
 #endif
-
-/*
- * Helper function to clear and free a kvmalloc'ed memory object.
- */
-static inline void __kvzfree(const void *addr, size_t len)
-{
-	if (addr) {
-		memset((void *)addr, 0, len);
-		kvfree(addr);
-	}
-}
 #endif /* _INTERNAL_H */

commit 8c0637e950d68933a67f7438f779d79b049b5e5c
Author: David Howells <dhowells@redhat.com>
Date:   Tue May 12 15:16:29 2020 +0100

    keys: Make the KEY_NEED_* perms an enum rather than a mask
    
    Since the meaning of combining the KEY_NEED_* constants is undefined, make
    it so that you can't do that by turning them into an enum.
    
    The enum is also given some extra values to represent special
    circumstances, such as:
    
     (1) The '0' value is reserved and causes a warning to trap the parameter
         being unset.
    
     (2) The key is to be unlinked and we require no permissions on it, only
         the keyring, (this replaces the KEY_LOOKUP_FOR_UNLINK flag).
    
     (3) An override due to CAP_SYS_ADMIN.
    
     (4) An override due to an instantiation token being present.
    
     (5) The permissions check is being deferred to later key_permission()
         calls.
    
    The extra values give the opportunity for LSMs to audit these situations.
    
    [Note: This really needs overhauling so that lookup_user_key() tells
     key_task_permission() and the LSM what operation is being done and leaves
     it to those functions to decide how to map that onto the available
     permits.  However, I don't really want to make these change in the middle
     of the notifications patchset.]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    cc: Paul Moore <paul@paul-moore.com>
    cc: Stephen Smalley <stephen.smalley.work@gmail.com>
    cc: Casey Schaufler <casey@schaufler-ca.com>
    cc: keyrings@vger.kernel.org
    cc: selinux@vger.kernel.org

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 28e17f4f3328..1fc17cb317a9 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -167,7 +167,6 @@ extern bool lookup_user_key_possessed(const struct key *key,
 				      const struct key_match_data *match_data);
 #define KEY_LOOKUP_CREATE	0x01
 #define KEY_LOOKUP_PARTIAL	0x02
-#define KEY_LOOKUP_FOR_UNLINK	0x04
 
 extern long join_session_keyring(const char *name);
 extern void key_change_session_keyring(struct callback_head *twork);
@@ -183,7 +182,7 @@ extern void key_gc_keytype(struct key_type *ktype);
 
 extern int key_task_permission(const key_ref_t key_ref,
 			       const struct cred *cred,
-			       key_perm_t perm);
+			       enum key_need_perm need_perm);
 
 static inline void notify_key(struct key *key,
 			      enum key_notification_subtype subtype, u32 aux)
@@ -205,9 +204,10 @@ static inline void notify_key(struct key *key,
 /*
  * Check to see whether permission is granted to use a key in the desired way.
  */
-static inline int key_permission(const key_ref_t key_ref, unsigned perm)
+static inline int key_permission(const key_ref_t key_ref,
+				 enum key_need_perm need_perm)
 {
-	return key_task_permission(key_ref, current_cred(), perm);
+	return key_task_permission(key_ref, current_cred(), need_perm);
 }
 
 extern struct key_type key_type_request_key_auth;

commit f7e47677e39a03057dcced2016c92a9c868693ec
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 14 17:07:11 2020 +0000

    watch_queue: Add a key/keyring notification facility
    
    Add a key/keyring change notification facility whereby notifications about
    changes in key and keyring content and attributes can be received.
    
    Firstly, an event queue needs to be created:
    
            pipe2(fds, O_NOTIFICATION_PIPE);
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_SIZE, 256);
    
    then a notification can be set up to report notifications via that queue:
    
            struct watch_notification_filter filter = {
                    .nr_filters = 1,
                    .filters = {
                            [0] = {
                                    .type = WATCH_TYPE_KEY_NOTIFY,
                                    .subtype_filter[0] = UINT_MAX,
                            },
                    },
            };
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_FILTER, &filter);
            keyctl_watch_key(KEY_SPEC_SESSION_KEYRING, fds[1], 0x01);
    
    After that, records will be placed into the queue when events occur in
    which keys are changed in some way.  Records are of the following format:
    
            struct key_notification {
                    struct watch_notification watch;
                    __u32   key_id;
                    __u32   aux;
            } *n;
    
    Where:
    
            n->watch.type will be WATCH_TYPE_KEY_NOTIFY.
    
            n->watch.subtype will indicate the type of event, such as
            NOTIFY_KEY_REVOKED.
    
            n->watch.info & WATCH_INFO_LENGTH will indicate the length of the
            record.
    
            n->watch.info & WATCH_INFO_ID will be the second argument to
            keyctl_watch_key(), shifted.
    
            n->key will be the ID of the affected key.
    
            n->aux will hold subtype-dependent information, such as the key
            being linked into the keyring specified by n->key in the case of
            NOTIFY_KEY_LINKED.
    
    Note that it is permissible for event records to be of variable length -
    or, at least, the length may be dependent on the subtype.  Note also that
    the queue can be shared between multiple notifications of various types.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jamorris@linux.microsoft.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 6d0ca48ae9a5..28e17f4f3328 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -15,6 +15,7 @@
 #include <linux/task_work.h>
 #include <linux/keyctl.h>
 #include <linux/refcount.h>
+#include <linux/watch_queue.h>
 #include <linux/compat.h>
 #include <linux/mm.h>
 #include <linux/vmalloc.h>
@@ -99,7 +100,8 @@ extern int __key_link_begin(struct key *keyring,
 			    const struct keyring_index_key *index_key,
 			    struct assoc_array_edit **_edit);
 extern int __key_link_check_live_key(struct key *keyring, struct key *key);
-extern void __key_link(struct key *key, struct assoc_array_edit **_edit);
+extern void __key_link(struct key *keyring, struct key *key,
+		       struct assoc_array_edit **_edit);
 extern void __key_link_end(struct key *keyring,
 			   const struct keyring_index_key *index_key,
 			   struct assoc_array_edit *edit);
@@ -183,6 +185,23 @@ extern int key_task_permission(const key_ref_t key_ref,
 			       const struct cred *cred,
 			       key_perm_t perm);
 
+static inline void notify_key(struct key *key,
+			      enum key_notification_subtype subtype, u32 aux)
+{
+#ifdef CONFIG_KEY_NOTIFICATIONS
+	struct key_notification n = {
+		.watch.type	= WATCH_TYPE_KEY_NOTIFY,
+		.watch.subtype	= subtype,
+		.watch.info	= watch_sizeof(n),
+		.key_id		= key_serial(key),
+		.aux		= aux,
+	};
+
+	post_watch_notification(key->watchers, &n.watch, current_cred(),
+				n.key_id);
+#endif
+}
+
 /*
  * Check to see whether permission is granted to use a key in the desired way.
  */
@@ -333,6 +352,15 @@ static inline long keyctl_pkey_e_d_s(int op,
 
 extern long keyctl_capabilities(unsigned char __user *_buffer, size_t buflen);
 
+#ifdef CONFIG_KEY_NOTIFICATIONS
+extern long keyctl_watch_key(key_serial_t, int, int);
+#else
+static inline long keyctl_watch_key(key_serial_t key_id, int watch_fd, int watch_id)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
 /*
  * Debugging key validation
  */

commit 4f0882491a148059a52480e753b7f07fc550e188
Author: Waiman Long <longman@redhat.com>
Date:   Sat Mar 21 21:11:25 2020 -0400

    KEYS: Avoid false positive ENOMEM error on key read
    
    By allocating a kernel buffer with a user-supplied buffer length, it
    is possible that a false positive ENOMEM error may be returned because
    the user-supplied length is just too large even if the system do have
    enough memory to hold the actual key data.
    
    Moreover, if the buffer length is larger than the maximum amount of
    memory that can be returned by kmalloc() (2^(MAX_ORDER-1) number of
    pages), a warning message will also be printed.
    
    To reduce this possibility, we set a threshold (PAGE_SIZE) over which we
    do check the actual key length first before allocating a buffer of the
    right size to hold it. The threshold is arbitrary, it is just used to
    trigger a buffer length check. It does not limit the actual key length
    as long as there is enough memory to satisfy the memory request.
    
    To further avoid large buffer allocation failure due to page
    fragmentation, kvmalloc() is used to allocate the buffer so that vmapped
    pages can be used when there is not a large enough contiguous set of
    pages available for allocation.
    
    In the extremely unlikely scenario that the key keeps on being changed
    and made longer (still <= buflen) in between 2 __keyctl_read_key()
    calls, the __keyctl_read_key() calling loop in keyctl_read_key() may
    have to be iterated a large number of times, but definitely not infinite.
    
    Signed-off-by: Waiman Long <longman@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index ba3e2da14cef..6d0ca48ae9a5 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -16,6 +16,8 @@
 #include <linux/keyctl.h>
 #include <linux/refcount.h>
 #include <linux/compat.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
 
 struct iovec;
 
@@ -349,4 +351,14 @@ static inline void key_check(const struct key *key)
 
 #endif
 
+/*
+ * Helper function to clear and free a kvmalloc'ed memory object.
+ */
+static inline void __kvzfree(const void *addr, size_t len)
+{
+	if (addr) {
+		memset((void *)addr, 0, len);
+		kvfree(addr);
+	}
+}
 #endif /* _INTERNAL_H */

commit 601f0093f2647db67be40b62e13cd0660990a7c8
Author: Eric Biggers <ebiggers@google.com>
Date:   Wed Oct 9 16:04:43 2019 -0700

    KEYS: remove CONFIG_KEYS_COMPAT
    
    KEYS_COMPAT now always takes the value of COMPAT && KEYS.  But the
    security/keys/ directory is only compiled if KEYS is enabled, so in
    practice KEYS_COMPAT is the same as COMPAT.  Therefore, remove the
    unnecessary KEYS_COMPAT and just use COMPAT directly.
    
    (Also remove an outdated comment from compat.c.)
    
    Reviewed-by: James Morris <jamorris@linux.microsoft.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index c039373488bd..ba3e2da14cef 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -264,7 +264,7 @@ extern long keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,
 			      size_t, struct keyctl_kdf_params __user *);
 extern long __keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,
 				size_t, struct keyctl_kdf_params *);
-#ifdef CONFIG_KEYS_COMPAT
+#ifdef CONFIG_COMPAT
 extern long compat_keyctl_dh_compute(struct keyctl_dh_params __user *params,
 				char __user *buffer, size_t buflen,
 				struct compat_keyctl_kdf_params __user *kdf);
@@ -279,7 +279,7 @@ static inline long keyctl_dh_compute(struct keyctl_dh_params __user *params,
 	return -EOPNOTSUPP;
 }
 
-#ifdef CONFIG_KEYS_COMPAT
+#ifdef CONFIG_COMPAT
 static inline long compat_keyctl_dh_compute(
 				struct keyctl_dh_params __user *params,
 				char __user *buffer, size_t buflen,

commit 028db3e290f15ac509084c0fc3b9d021f668f877
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 18:43:43 2019 -0700

    Revert "Merge tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs"
    
    This reverts merge 0f75ef6a9cff49ff612f7ce0578bced9d0b38325 (and thus
    effectively commits
    
       7a1ade847596 ("keys: Provide KEYCTL_GRANT_PERMISSION")
       2e12256b9a76 ("keys: Replace uid/gid/perm permissions checking with an ACL")
    
    that the merge brought in).
    
    It turns out that it breaks booting with an encrypted volume, and Eric
    biggers reports that it also breaks the fscrypt tests [1] and loading of
    in-kernel X.509 certificates [2].
    
    The root cause of all the breakage is likely the same, but David Howells
    is off email so rather than try to work it out it's getting reverted in
    order to not impact the rest of the merge window.
    
     [1] https://lore.kernel.org/lkml/20190710011559.GA7973@sol.localdomain/
     [2] https://lore.kernel.org/lkml/20190710013225.GB7973@sol.localdomain/
    
    Link: https://lore.kernel.org/lkml/CAHk-=wjxoeMJfeBahnWH=9zShKp2bsVy527vo3_y8HfOdhwAAw@mail.gmail.com/
    Reported-by: Eric Biggers <ebiggers@kernel.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index e0c5bb8b1685..c039373488bd 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -84,11 +84,8 @@ extern struct rb_root key_serial_tree;
 extern spinlock_t key_serial_lock;
 extern struct mutex key_construction_mutex;
 extern wait_queue_head_t request_key_conswq;
-extern struct key_acl default_key_acl;
-extern struct key_acl joinable_keyring_acl;
 
 extern void key_set_index_key(struct keyring_index_key *index_key);
-
 extern struct key_type *key_type_lookup(const char *type);
 extern void key_type_put(struct key_type *ktype);
 
@@ -159,7 +156,6 @@ extern struct key *request_key_and_link(struct key_type *type,
 					const void *callout_info,
 					size_t callout_len,
 					void *aux,
-					struct key_acl *acl,
 					struct key *dest_keyring,
 					unsigned long flags);
 
@@ -183,10 +179,7 @@ extern void key_gc_keytype(struct key_type *ktype);
 
 extern int key_task_permission(const key_ref_t key_ref,
 			       const struct cred *cred,
-			       u32 desired_perm);
-extern unsigned int key_acl_to_perm(const struct key_acl *acl);
-extern long key_set_acl(struct key *key, struct key_acl *acl);
-extern void key_put_acl(struct key_acl *acl);
+			       key_perm_t perm);
 
 /*
  * Check to see whether permission is granted to use a key in the desired way.
@@ -233,7 +226,7 @@ extern long keyctl_keyring_search(key_serial_t, const char __user *,
 				  const char __user *, key_serial_t);
 extern long keyctl_read_key(key_serial_t, char __user *, size_t);
 extern long keyctl_chown_key(key_serial_t, uid_t, gid_t);
-extern long keyctl_setperm_key(key_serial_t, unsigned int);
+extern long keyctl_setperm_key(key_serial_t, key_perm_t);
 extern long keyctl_instantiate_key(key_serial_t, const void __user *,
 				   size_t, key_serial_t);
 extern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);
@@ -338,11 +331,6 @@ static inline long keyctl_pkey_e_d_s(int op,
 
 extern long keyctl_capabilities(unsigned char __user *_buffer, size_t buflen);
 
-extern long keyctl_grant_permission(key_serial_t keyid,
-				    enum key_ace_subject_type type,
-				    unsigned int subject,
-				    unsigned int perm);
-
 /*
  * Debugging key validation
  */

commit 0f75ef6a9cff49ff612f7ce0578bced9d0b38325
Merge: c84ca912b079 7a1ade847596
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:56:57 2019 -0700

    Merge tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull keyring ACL support from David Howells:
     "This changes the permissions model used by keys and keyrings to be
      based on an internal ACL by the following means:
    
       - Replace the permissions mask internally with an ACL that contains a
         list of ACEs, each with a specific subject with a permissions mask.
         Potted default ACLs are available for new keys and keyrings.
    
         ACE subjects can be macroised to indicate the UID and GID specified
         on the key (which remain). Future commits will be able to add
         additional subject types, such as specific UIDs or domain
         tags/namespaces.
    
         Also split a number of permissions to give finer control. Examples
         include splitting the revocation permit from the change-attributes
         permit, thereby allowing someone to be granted permission to revoke
         a key without allowing them to change the owner; also the ability
         to join a keyring is split from the ability to link to it, thereby
         stopping a process accessing a keyring by joining it and thus
         acquiring use of possessor permits.
    
       - Provide a keyctl to allow the granting or denial of one or more
         permits to a specific subject. Direct access to the ACL is not
         granted, and the ACL cannot be viewed"
    
    * tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Provide KEYCTL_GRANT_PERMISSION
      keys: Replace uid/gid/perm permissions checking with an ACL

commit c84ca912b07901be528e5184fd254fca1dddf2ac
Merge: c236b6dd48dc a58946c158a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:36:47 2019 -0700

    Merge tag 'keys-namespace-20190627' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull keyring namespacing from David Howells:
     "These patches help make keys and keyrings more namespace aware.
    
      Firstly some miscellaneous patches to make the process easier:
    
       - Simplify key index_key handling so that the word-sized chunks
         assoc_array requires don't have to be shifted about, making it
         easier to add more bits into the key.
    
       - Cache the hash value in the key so that we don't have to calculate
         on every key we examine during a search (it involves a bunch of
         multiplications).
    
       - Allow keying_search() to search non-recursively.
    
      Then the main patches:
    
       - Make it so that keyring names are per-user_namespace from the point
         of view of KEYCTL_JOIN_SESSION_KEYRING so that they're not
         accessible cross-user_namespace.
    
         keyctl_capabilities() shows KEYCTL_CAPS1_NS_KEYRING_NAME for this.
    
       - Move the user and user-session keyrings to the user_namespace
         rather than the user_struct. This prevents them propagating
         directly across user_namespaces boundaries (ie. the KEY_SPEC_*
         flags will only pick from the current user_namespace).
    
       - Make it possible to include the target namespace in which the key
         shall operate in the index_key. This will allow the possibility of
         multiple keys with the same description, but different target
         domains to be held in the same keyring.
    
         keyctl_capabilities() shows KEYCTL_CAPS1_NS_KEY_TAG for this.
    
       - Make it so that keys are implicitly invalidated by removal of a
         domain tag, causing them to be garbage collected.
    
       - Institute a network namespace domain tag that allows keys to be
         differentiated by the network namespace in which they operate. New
         keys that are of a type marked 'KEY_TYPE_NET_DOMAIN' are assigned
         the network domain in force when they are created.
    
       - Make it so that the desired network namespace can be handed down
         into the request_key() mechanism. This allows AFS, NFS, etc. to
         request keys specific to the network namespace of the superblock.
    
         This also means that the keys in the DNS record cache are
         thenceforth namespaced, provided network filesystems pass the
         appropriate network namespace down into dns_query().
    
         For DNS, AFS and NFS are good, whilst CIFS and Ceph are not. Other
         cache keyrings, such as idmapper keyrings, also need to set the
         domain tag - for which they need access to the network namespace of
         the superblock"
    
    * tag 'keys-namespace-20190627' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Pass the network namespace into request_key mechanism
      keys: Network namespace domain tag
      keys: Garbage collect keys for which the domain has been removed
      keys: Include target namespace in match criteria
      keys: Move the user and user-session keyrings to the user_namespace
      keys: Namespace keyring names
      keys: Add a 'recurse' flag for keyring searches
      keys: Cache the hash value to avoid lots of recalculation
      keys: Simplify key description management

commit c236b6dd48dcf2ae6ed14b9068830eccc3e181e6
Merge: d44a62742dec 3b8c4a08a471
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:19:37 2019 -0700

    Merge tag 'keys-request-20190626' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull request_key improvements from David Howells:
     "These are all request_key()-related, including a fix and some improvements:
    
       - Fix the lack of a Link permission check on a key found by
         request_key(), thereby enabling request_key() to link keys that
         don't grant this permission to the target keyring (which must still
         grant Write permission).
    
         Note that the key must be in the caller's keyrings already to be
         found.
    
       - Invalidate used request_key authentication keys rather than
         revoking them, so that they get cleaned up immediately rather than
         hanging around till the expiry time is passed.
    
       - Move the RCU locks outwards from the keyring search functions so
         that a request_key_rcu() can be provided. This can be called in RCU
         mode, so it can't sleep and can't upcall - but it can be called
         from LOOKUP_RCU pathwalk mode.
    
       - Cache the latest positive result of request_key*() temporarily in
         task_struct so that filesystems that make a lot of request_key()
         calls during pathwalk can take advantage of it to avoid having to
         redo the searching. This requires CONFIG_KEYS_REQUEST_CACHE=y.
    
         It is assumed that the key just found is likely to be used multiple
         times in each step in an RCU pathwalk, and is likely to be reused
         for the next step too.
    
         Note that the cleanup of the cache is done on TIF_NOTIFY_RESUME,
         just before userspace resumes, and on exit"
    
    * tag 'keys-request-20190626' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Kill off request_key_async{,_with_auxdata}
      keys: Cache result of request_key*() temporarily in task_struct
      keys: Provide request_key_rcu()
      keys: Move the RCU locks outwards from the keyring search functions
      keys: Invalidate used request_key authentication keys
      keys: Fix request_key() lack of Link perm check on found key

commit d44a62742decca5ae5688a562584dc0fe9fc63f6
Merge: 7c0f89634892 45e0f30c30bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 19:02:11 2019 -0700

    Merge tag 'keys-misc-20190619' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull misc keyring updates from David Howells:
     "These are some miscellaneous keyrings fixes and improvements:
    
       - Fix a bunch of warnings from sparse, including missing RCU bits and
         kdoc-function argument mismatches
    
       - Implement a keyctl to allow a key to be moved from one keyring to
         another, with the option of prohibiting key replacement in the
         destination keyring.
    
       - Grant Link permission to possessors of request_key_auth tokens so
         that upcall servicing daemons can more easily arrange things such
         that only the necessary auth key is passed to the actual service
         program, and not all the auth keys a daemon might possesss.
    
       - Improvement in lookup_user_key().
    
       - Implement a keyctl to allow keyrings subsystem capabilities to be
         queried.
    
      The keyutils next branch has commits to make available, document and
      test the move-key and capabilities code:
    
            https://git.kernel.org/pub/scm/linux/kernel/git/dhowells/keyutils.git/log
    
      They're currently on the 'next' branch"
    
    * tag 'keys-misc-20190619' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      keys: Add capability-checking keyctl function
      keys: Reuse keyring_index_key::desc_len in lookup_user_key()
      keys: Grant Link permission to possessers of request_key auth keys
      keys: Add a keyctl to move a key between keyrings
      keys: Hoist locking out of __key_link_begin()
      keys: Break bits out of key_unlink()
      keys: Change keyring_serialise_link_sem to a mutex
      keys: sparse: Fix kdoc mismatches
      keys: sparse: Fix incorrect RCU accesses
      keys: sparse: Fix key_fs[ug]id_changed()

commit 7a1ade847596dadc94b37e49f8c03f167fd71748
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 27 23:03:07 2019 +0100

    keys: Provide KEYCTL_GRANT_PERMISSION
    
    Provide a keyctl() operation to grant/remove permissions.  The grant
    operation, wrapped by libkeyutils, looks like:
    
            int ret = keyctl_grant_permission(key_serial_t key,
                                              enum key_ace_subject_type type,
                                              unsigned int subject,
                                              unsigned int perm);
    
    Where key is the key to be modified, type and subject represent the subject
    to which permission is to be granted (or removed) and perm is the set of
    permissions to be granted.  0 is returned on success.  SET_SECURITY
    permission is required for this.
    
    The subject type currently must be KEY_ACE_SUBJ_STANDARD for the moment
    (other subject types will come along later).
    
    For subject type KEY_ACE_SUBJ_STANDARD, the following subject values are
    available:
    
            KEY_ACE_POSSESSOR       The possessor of the key
            KEY_ACE_OWNER           The owner of the key
            KEY_ACE_GROUP           The key's group
            KEY_ACE_EVERYONE        Everyone
    
    perm lists the permissions to be granted:
    
            KEY_ACE_VIEW            Can view the key metadata
            KEY_ACE_READ            Can read the key content
            KEY_ACE_WRITE           Can update/modify the key content
            KEY_ACE_SEARCH          Can find the key by searching/requesting
            KEY_ACE_LINK            Can make a link to the key
            KEY_ACE_SET_SECURITY    Can set security
            KEY_ACE_INVAL           Can invalidate
            KEY_ACE_REVOKE          Can revoke
            KEY_ACE_JOIN            Can join this keyring
            KEY_ACE_CLEAR           Can clear this keyring
    
    If an ACE already exists for the subject, then the permissions mask will be
    overwritten; if perm is 0, it will be deleted.
    
    Currently, the internal ACL is limited to a maximum of 16 entries.
    
    For example:
    
            int ret = keyctl_grant_permission(key,
                                              KEY_ACE_SUBJ_STANDARD,
                                              KEY_ACE_OWNER,
                                              KEY_ACE_VIEW | KEY_ACE_READ);
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 9375d6289bb9..5e27ebdf1937 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -342,6 +342,11 @@ static inline long keyctl_pkey_e_d_s(int op,
 
 extern long keyctl_capabilities(unsigned char __user *_buffer, size_t buflen);
 
+extern long keyctl_grant_permission(key_serial_t keyid,
+				    enum key_ace_subject_type type,
+				    unsigned int subject,
+				    unsigned int perm);
+
 /*
  * Debugging key validation
  */

commit 2e12256b9a76584fa3a6da19210509d4775aee36
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 27 23:03:07 2019 +0100

    keys: Replace uid/gid/perm permissions checking with an ACL
    
    Replace the uid/gid/perm permissions checking on a key with an ACL to allow
    the SETATTR and SEARCH permissions to be split.  This will also allow a
    greater range of subjects to represented.
    
    ============
    WHY DO THIS?
    ============
    
    The problem is that SETATTR and SEARCH cover a slew of actions, not all of
    which should be grouped together.
    
    For SETATTR, this includes actions that are about controlling access to a
    key:
    
     (1) Changing a key's ownership.
    
     (2) Changing a key's security information.
    
     (3) Setting a keyring's restriction.
    
    And actions that are about managing a key's lifetime:
    
     (4) Setting an expiry time.
    
     (5) Revoking a key.
    
    and (proposed) managing a key as part of a cache:
    
     (6) Invalidating a key.
    
    Managing a key's lifetime doesn't really have anything to do with
    controlling access to that key.
    
    Expiry time is awkward since it's more about the lifetime of the content
    and so, in some ways goes better with WRITE permission.  It can, however,
    be set unconditionally by a process with an appropriate authorisation token
    for instantiating a key, and can also be set by the key type driver when a
    key is instantiated, so lumping it with the access-controlling actions is
    probably okay.
    
    As for SEARCH permission, that currently covers:
    
     (1) Finding keys in a keyring tree during a search.
    
     (2) Permitting keyrings to be joined.
    
     (3) Invalidation.
    
    But these don't really belong together either, since these actions really
    need to be controlled separately.
    
    Finally, there are number of special cases to do with granting the
    administrator special rights to invalidate or clear keys that I would like
    to handle with the ACL rather than key flags and special checks.
    
    
    ===============
    WHAT IS CHANGED
    ===============
    
    The SETATTR permission is split to create two new permissions:
    
     (1) SET_SECURITY - which allows the key's owner, group and ACL to be
         changed and a restriction to be placed on a keyring.
    
     (2) REVOKE - which allows a key to be revoked.
    
    The SEARCH permission is split to create:
    
     (1) SEARCH - which allows a keyring to be search and a key to be found.
    
     (2) JOIN - which allows a keyring to be joined as a session keyring.
    
     (3) INVAL - which allows a key to be invalidated.
    
    The WRITE permission is also split to create:
    
     (1) WRITE - which allows a key's content to be altered and links to be
         added, removed and replaced in a keyring.
    
     (2) CLEAR - which allows a keyring to be cleared completely.  This is
         split out to make it possible to give just this to an administrator.
    
     (3) REVOKE - see above.
    
    
    Keys acquire ACLs which consist of a series of ACEs, and all that apply are
    unioned together.  An ACE specifies a subject, such as:
    
     (*) Possessor - permitted to anyone who 'possesses' a key
     (*) Owner - permitted to the key owner
     (*) Group - permitted to the key group
     (*) Everyone - permitted to everyone
    
    Note that 'Other' has been replaced with 'Everyone' on the assumption that
    you wouldn't grant a permit to 'Other' that you wouldn't also grant to
    everyone else.
    
    Further subjects may be made available by later patches.
    
    The ACE also specifies a permissions mask.  The set of permissions is now:
    
            VIEW            Can view the key metadata
            READ            Can read the key content
            WRITE           Can update/modify the key content
            SEARCH          Can find the key by searching/requesting
            LINK            Can make a link to the key
            SET_SECURITY    Can change owner, ACL, expiry
            INVAL           Can invalidate
            REVOKE          Can revoke
            JOIN            Can join this keyring
            CLEAR           Can clear this keyring
    
    
    The KEYCTL_SETPERM function is then deprecated.
    
    The KEYCTL_SET_TIMEOUT function then is permitted if SET_SECURITY is set,
    or if the caller has a valid instantiation auth token.
    
    The KEYCTL_INVALIDATE function then requires INVAL.
    
    The KEYCTL_REVOKE function then requires REVOKE.
    
    The KEYCTL_JOIN_SESSION_KEYRING function then requires JOIN to join an
    existing keyring.
    
    The JOIN permission is enabled by default for session keyrings and manually
    created keyrings only.
    
    
    ======================
    BACKWARD COMPATIBILITY
    ======================
    
    To maintain backward compatibility, KEYCTL_SETPERM will translate the
    permissions mask it is given into a new ACL for a key - unless
    KEYCTL_SET_ACL has been called on that key, in which case an error will be
    returned.
    
    It will convert possessor, owner, group and other permissions into separate
    ACEs, if each portion of the mask is non-zero.
    
    SETATTR permission turns on all of INVAL, REVOKE and SET_SECURITY.  WRITE
    permission turns on WRITE, REVOKE and, if a keyring, CLEAR.  JOIN is turned
    on if a keyring is being altered.
    
    The KEYCTL_DESCRIBE function translates the ACL back into a permissions
    mask to return depending on possessor, owner, group and everyone ACEs.
    
    It will make the following mappings:
    
     (1) INVAL, JOIN -> SEARCH
    
     (2) SET_SECURITY -> SETATTR
    
     (3) REVOKE -> WRITE if SETATTR isn't already set
    
     (4) CLEAR -> WRITE
    
    Note that the value subsequently returned by KEYCTL_DESCRIBE may not match
    the value set with KEYCTL_SETATTR.
    
    
    =======
    TESTING
    =======
    
    This passes the keyutils testsuite for all but a couple of tests:
    
     (1) tests/keyctl/dh_compute/badargs: The first wrong-key-type test now
         returns EOPNOTSUPP rather than ENOKEY as READ permission isn't removed
         if the type doesn't have ->read().  You still can't actually read the
         key.
    
     (2) tests/keyctl/permitting/valid: The view-other-permissions test doesn't
         work as Other has been replaced with Everyone in the ACL.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index f1f2b076f3a1..9375d6289bb9 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -88,8 +88,11 @@ extern struct rb_root key_serial_tree;
 extern spinlock_t key_serial_lock;
 extern struct mutex key_construction_mutex;
 extern wait_queue_head_t request_key_conswq;
+extern struct key_acl default_key_acl;
+extern struct key_acl joinable_keyring_acl;
 
 extern void key_set_index_key(struct keyring_index_key *index_key);
+
 extern struct key_type *key_type_lookup(const char *type);
 extern void key_type_put(struct key_type *ktype);
 
@@ -160,6 +163,7 @@ extern struct key *request_key_and_link(struct key_type *type,
 					const void *callout_info,
 					size_t callout_len,
 					void *aux,
+					struct key_acl *acl,
 					struct key *dest_keyring,
 					unsigned long flags);
 
@@ -183,7 +187,10 @@ extern void key_gc_keytype(struct key_type *ktype);
 
 extern int key_task_permission(const key_ref_t key_ref,
 			       const struct cred *cred,
-			       key_perm_t perm);
+			       u32 desired_perm);
+extern unsigned int key_acl_to_perm(const struct key_acl *acl);
+extern long key_set_acl(struct key *key, struct key_acl *acl);
+extern void key_put_acl(struct key_acl *acl);
 
 /*
  * Check to see whether permission is granted to use a key in the desired way.
@@ -230,7 +237,7 @@ extern long keyctl_keyring_search(key_serial_t, const char __user *,
 				  const char __user *, key_serial_t);
 extern long keyctl_read_key(key_serial_t, char __user *, size_t);
 extern long keyctl_chown_key(key_serial_t, uid_t, gid_t);
-extern long keyctl_setperm_key(key_serial_t, key_perm_t);
+extern long keyctl_setperm_key(key_serial_t, unsigned int);
 extern long keyctl_instantiate_key(key_serial_t, const void __user *,
 				   size_t, key_serial_t);
 extern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);

commit a58946c158a040068e7c94dc1d58bbd273258068
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:33 2019 +0100

    keys: Pass the network namespace into request_key mechanism
    
    Create a request_key_net() function and use it to pass the network
    namespace domain tag into DNS revolver keys and rxrpc/AFS keys so that keys
    for different domains can coexist in the same keyring.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: netdev@vger.kernel.org
    cc: linux-nfs@vger.kernel.org
    cc: linux-cifs@vger.kernel.org
    cc: linux-afs@lists.infradead.org

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 5a561f5f199e..f1f2b076f3a1 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -156,6 +156,7 @@ extern int install_session_keyring_to_cred(struct cred *, struct key *);
 
 extern struct key *request_key_and_link(struct key_type *type,
 					const char *description,
+					struct key_tag *domain_tag,
 					const void *callout_info,
 					size_t callout_len,
 					void *aux,

commit 218e6424e711ceee31eeba93212fed8ee92d6a11
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Garbage collect keys for which the domain has been removed
    
    If a key operation domain (such as a network namespace) has been removed
    then attempt to garbage collect all the keys that use it.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index d3a9439e2386..5a561f5f199e 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -209,7 +209,8 @@ static inline bool key_is_dead(const struct key *key, time64_t limit)
 	return
 		key->flags & ((1 << KEY_FLAG_DEAD) |
 			      (1 << KEY_FLAG_INVALIDATED)) ||
-		(key->expiry > 0 && key->expiry <= limit);
+		(key->expiry > 0 && key->expiry <= limit) ||
+		key->domain_tag->removed;
 }
 
 /*

commit 0f44e4d976f96c6439da0d6717238efa4b91196e
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Move the user and user-session keyrings to the user_namespace
    
    Move the user and user-session keyrings to the user_namespace struct rather
    than pinning them from the user_struct struct.  This prevents these
    keyrings from propagating across user-namespaces boundaries with regard to
    the KEY_SPEC_* flags, thereby making them more useful in a containerised
    environment.
    
    The issue is that a single user_struct may be represent UIDs in several
    different namespaces.
    
    The way the patch does this is by attaching a 'register keyring' in each
    user_namespace and then sticking the user and user-session keyrings into
    that.  It can then be searched to retrieve them.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jann Horn <jannh@google.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index aa361299a3ec..d3a9439e2386 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -148,7 +148,8 @@ extern key_ref_t search_process_keyrings_rcu(struct keyring_search_context *ctx)
 
 extern struct key *find_keyring_by_name(const char *name, bool uid_keyring);
 
-extern int install_user_keyrings(void);
+extern int look_up_user_keyrings(struct key **, struct key **);
+extern struct key *get_user_session_keyring_rcu(const struct cred *);
 extern int install_thread_keyring_to_cred(struct cred *);
 extern int install_process_keyring_to_cred(struct cred *);
 extern int install_session_keyring_to_cred(struct cred *, struct key *);

commit dcf49dbc8077e278ddd1bc7298abc781496e8a08
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Add a 'recurse' flag for keyring searches
    
    Add a 'recurse' flag for keyring searches so that the flag can be omitted
    and recursion disabled, thereby allowing just the nominated keyring to be
    searched and none of the children.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 4305414795ae..aa361299a3ec 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -127,6 +127,7 @@ struct keyring_search_context {
 #define KEYRING_SEARCH_NO_CHECK_PERM	0x0008	/* Don't check permissions */
 #define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0010	/* Give an error on excessive depth */
 #define KEYRING_SEARCH_SKIP_EXPIRED	0x0020	/* Ignore expired keys (intention to replace) */
+#define KEYRING_SEARCH_RECURSE		0x0040	/* Search child keyrings also */
 
 	int (*iterator)(const void *object, void *iterator_data);
 

commit 355ef8e15885020da88f5ba2d85ce42b1d01f537
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Cache the hash value to avoid lots of recalculation
    
    Cache the hash of the key's type and description in the index key so that
    we're not recalculating it every time we look at a key during a search.
    The hash function does a bunch of multiplications, so evading those is
    probably worthwhile - especially as this is done for every key examined
    during a search.
    
    This also allows the methods used by assoc_array to get chunks of index-key
    to be simplified.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index ee71c72fc5f0..4305414795ae 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -89,13 +89,7 @@ extern spinlock_t key_serial_lock;
 extern struct mutex key_construction_mutex;
 extern wait_queue_head_t request_key_conswq;
 
-
-static inline void key_set_index_key(struct keyring_index_key *index_key)
-{
-	size_t n = min_t(size_t, index_key->desc_len, sizeof(index_key->desc));
-	memcpy(index_key->desc, index_key->description, n);
-}
-
+extern void key_set_index_key(struct keyring_index_key *index_key);
 extern struct key_type *key_type_lookup(const char *type);
 extern void key_type_put(struct key_type *ktype);
 

commit f771fde82051976a6fc0fd570f8b86de4a92124b
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:31 2019 +0100

    keys: Simplify key description management
    
    Simplify key description management by cramming the word containing the
    length with the first few chars of the description also.  This simplifies
    the code that generates the index-key used by assoc_array.  It should speed
    up key searching a bit too.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 3d5c08db74d2..ee71c72fc5f0 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -90,6 +90,12 @@ extern struct mutex key_construction_mutex;
 extern wait_queue_head_t request_key_conswq;
 
 
+static inline void key_set_index_key(struct keyring_index_key *index_key)
+{
+	size_t n = min_t(size_t, index_key->desc_len, sizeof(index_key->desc));
+	memcpy(index_key->desc, index_key->description, n);
+}
+
 extern struct key_type *key_type_lookup(const char *type);
 extern void key_type_put(struct key_type *ktype);
 

commit e59428f721ee096d8a020504ea908a6f0d952735
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 19 16:10:15 2019 +0100

    keys: Move the RCU locks outwards from the keyring search functions
    
    Move the RCU locks outwards from the keyring search functions so that it
    will become possible to provide an RCU-capable partial request_key()
    function in a later commit.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index d04bff631227..3d5c08db74d2 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -139,11 +139,11 @@ struct keyring_search_context {
 
 extern bool key_default_cmp(const struct key *key,
 			    const struct key_match_data *match_data);
-extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
+extern key_ref_t keyring_search_rcu(key_ref_t keyring_ref,
 				    struct keyring_search_context *ctx);
 
-extern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);
-extern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);
+extern key_ref_t search_cred_keyrings_rcu(struct keyring_search_context *ctx);
+extern key_ref_t search_process_keyrings_rcu(struct keyring_search_context *ctx);
 
 extern struct key *find_keyring_by_name(const char *name, bool uid_keyring);
 

commit 45e0f30c30bb131663fbe1752974d6f2e39611e2
Author: David Howells <dhowells@redhat.com>
Date:   Thu May 30 14:53:10 2019 +0100

    keys: Add capability-checking keyctl function
    
    Add a keyctl function that requests a set of capability bits to find out
    what features are supported.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index b54a58c025ae..d04bff631227 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -329,6 +329,8 @@ static inline long keyctl_pkey_e_d_s(int op,
 }
 #endif
 
+extern long keyctl_capabilities(unsigned char __user *_buffer, size_t buflen);
+
 /*
  * Debugging key validation
  */

commit ed0ac5c7ec3763e3261c48e3c5d4b7528b60fd85
Author: David Howells <dhowells@redhat.com>
Date:   Mon May 20 21:51:50 2019 +0100

    keys: Add a keyctl to move a key between keyrings
    
    Add a keyctl to atomically move a link to a key from one keyring to
    another.  The key must exist in "from" keyring and a flag can be given to
    cause the operation to fail if there's a matching key already in the "to"
    keyring.
    
    This can be done with:
    
            keyctl(KEYCTL_MOVE,
                   key_serial_t key,
                   key_serial_t from_keyring,
                   key_serial_t to_keyring,
                   unsigned int flags);
    
    The key being moved must grant Link permission and both keyrings must grant
    Write permission.
    
    flags should be 0 or KEYCTL_MOVE_EXCL, with the latter preventing
    displacement of a matching key from the "to" keyring.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 25cdd0cbdc06..b54a58c025ae 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -95,6 +95,8 @@ extern void key_type_put(struct key_type *ktype);
 
 extern int __key_link_lock(struct key *keyring,
 			   const struct keyring_index_key *index_key);
+extern int __key_move_lock(struct key *l_keyring, struct key *u_keyring,
+			   const struct keyring_index_key *index_key);
 extern int __key_link_begin(struct key *keyring,
 			    const struct keyring_index_key *index_key,
 			    struct assoc_array_edit **_edit);
@@ -217,6 +219,7 @@ extern long keyctl_update_key(key_serial_t, const void __user *, size_t);
 extern long keyctl_revoke_key(key_serial_t);
 extern long keyctl_keyring_clear(key_serial_t);
 extern long keyctl_keyring_link(key_serial_t, key_serial_t);
+extern long keyctl_keyring_move(key_serial_t, key_serial_t, key_serial_t, unsigned int);
 extern long keyctl_keyring_unlink(key_serial_t, key_serial_t);
 extern long keyctl_describe_key(key_serial_t, char __user *, size_t);
 extern long keyctl_keyring_search(key_serial_t, const char __user *,

commit df593ee23e05cdda16c8c995e5818779431bb29f
Author: David Howells <dhowells@redhat.com>
Date:   Thu May 30 11:37:39 2019 +0100

    keys: Hoist locking out of __key_link_begin()
    
    Hoist the locking of out of __key_link_begin() and into its callers.  This
    is necessary to allow the upcoming key_move() operation to correctly order
    taking of the source keyring semaphore, the destination keyring semaphore
    and the keyring serialisation lock.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 8f533c81aa8d..25cdd0cbdc06 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -93,6 +93,8 @@ extern wait_queue_head_t request_key_conswq;
 extern struct key_type *key_type_lookup(const char *type);
 extern void key_type_put(struct key_type *ktype);
 
+extern int __key_link_lock(struct key *keyring,
+			   const struct keyring_index_key *index_key);
 extern int __key_link_begin(struct key *keyring,
 			    const struct keyring_index_key *index_key,
 			    struct assoc_array_edit **_edit);

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 8f533c81aa8d..d59bc25a9249 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* Authentication token and access key management internal defs
  *
  * Copyright (C) 2003-5, 2007 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #ifndef _INTERNAL_H

commit 822ad64d7e46a8e2c8b8a796738d7b657cbb146d
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 14 16:20:25 2019 +0000

    keys: Fix dependency loop between construction record and auth key
    
    In the request_key() upcall mechanism there's a dependency loop by which if
    a key type driver overrides the ->request_key hook and the userspace side
    manages to lose the authorisation key, the auth key and the internal
    construction record (struct key_construction) can keep each other pinned.
    
    Fix this by the following changes:
    
     (1) Killing off the construction record and using the auth key instead.
    
     (2) Including the operation name in the auth key payload and making the
         payload available outside of security/keys/.
    
     (3) The ->request_key hook is given the authkey instead of the cons
         record and operation name.
    
    Changes (2) and (3) allow the auth key to naturally be cleaned up if the
    keyring it is in is destroyed or cleared or the auth key is unlinked.
    
    Fixes: 7ee02a316600 ("keys: Fix dependency loop between construction record and auth key")
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 479909b858c7..8f533c81aa8d 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -186,20 +186,9 @@ static inline int key_permission(const key_ref_t key_ref, unsigned perm)
 	return key_task_permission(key_ref, current_cred(), perm);
 }
 
-/*
- * Authorisation record for request_key().
- */
-struct request_key_auth {
-	struct key		*target_key;
-	struct key		*dest_keyring;
-	const struct cred	*cred;
-	void			*callout_info;
-	size_t			callout_len;
-	pid_t			pid;
-} __randomize_layout;
-
 extern struct key_type key_type_request_key_auth;
 extern struct key *request_key_auth_new(struct key *target,
+					const char *op,
 					const void *callout_info,
 					size_t callout_len,
 					struct key *dest_keyring);

commit 76ef5e17252789da79db78341851922af0c16181
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Tue Dec 4 10:31:27 2018 -0800

    keys: Export lookup_user_key to external users
    
    Export lookup_user_key() symbol in order to allow nvdimm passphrase
    update to retrieve user injected keys.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 74cb0ff42fed..479909b858c7 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -158,8 +158,6 @@ extern struct key *request_key_and_link(struct key_type *type,
 
 extern bool lookup_user_key_possessed(const struct key *key,
 				      const struct key_match_data *match_data);
-extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
-				 key_perm_t perm);
 #define KEY_LOOKUP_CREATE	0x01
 #define KEY_LOOKUP_PARTIAL	0x02
 #define KEY_LOOKUP_FOR_UNLINK	0x04

commit 00d60fd3b93219ea854220f0fd264b86398cbc53
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 9 17:46:59 2018 +0100

    KEYS: Provide keyctls to drive the new key type ops for asymmetric keys [ver #2]
    
    Provide five keyctl functions that permit userspace to make use of the new
    key type ops for accessing and driving asymmetric keys.
    
     (*) Query an asymmetric key.
    
            long keyctl(KEYCTL_PKEY_QUERY,
                        key_serial_t key, unsigned long reserved,
                        struct keyctl_pkey_query *info);
    
         Get information about an asymmetric key.  The information is returned
         in the keyctl_pkey_query struct:
    
            __u32   supported_ops;
    
         A bit mask of flags indicating which ops are supported.  This is
         constructed from a bitwise-OR of:
    
            KEYCTL_SUPPORTS_{ENCRYPT,DECRYPT,SIGN,VERIFY}
    
            __u32   key_size;
    
         The size in bits of the key.
    
            __u16   max_data_size;
            __u16   max_sig_size;
            __u16   max_enc_size;
            __u16   max_dec_size;
    
         The maximum sizes in bytes of a blob of data to be signed, a signature
         blob, a blob to be encrypted and a blob to be decrypted.
    
         reserved must be set to 0.  This is intended for future use to hand
         over one or more passphrases needed unlock a key.
    
         If successful, 0 is returned.  If the key is not an asymmetric key,
         EOPNOTSUPP is returned.
    
     (*) Encrypt, decrypt, sign or verify a blob using an asymmetric key.
    
            long keyctl(KEYCTL_PKEY_ENCRYPT,
                        const struct keyctl_pkey_params *params,
                        const char *info,
                        const void *in,
                        void *out);
    
            long keyctl(KEYCTL_PKEY_DECRYPT,
                        const struct keyctl_pkey_params *params,
                        const char *info,
                        const void *in,
                        void *out);
    
            long keyctl(KEYCTL_PKEY_SIGN,
                        const struct keyctl_pkey_params *params,
                        const char *info,
                        const void *in,
                        void *out);
    
            long keyctl(KEYCTL_PKEY_VERIFY,
                        const struct keyctl_pkey_params *params,
                        const char *info,
                        const void *in,
                        const void *in2);
    
         Use an asymmetric key to perform a public-key cryptographic operation
         a blob of data.
    
         The parameter block pointed to by params contains a number of integer
         values:
    
            __s32           key_id;
            __u32           in_len;
            __u32           out_len;
            __u32           in2_len;
    
         For a given operation, the in and out buffers are used as follows:
    
            Operation ID            in,in_len       out,out_len     in2,in2_len
            ======================= =============== =============== ===========
            KEYCTL_PKEY_ENCRYPT     Raw data        Encrypted data  -
            KEYCTL_PKEY_DECRYPT     Encrypted data  Raw data        -
            KEYCTL_PKEY_SIGN        Raw data        Signature       -
            KEYCTL_PKEY_VERIFY      Raw data        -               Signature
    
         info is a string of key=value pairs that supply supplementary
         information.
    
         The __spare space in the parameter block must be set to 0.  This is
         intended, amongst other things, to allow the passing of passphrases
         required to unlock a key.
    
         If successful, encrypt, decrypt and sign all return the amount of data
         written into the output buffer.  Verification returns 0 on success.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Denis Kenzior <denkenz@gmail.com>
    Tested-by: Denis Kenzior <denkenz@gmail.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 9f8208dc0e55..74cb0ff42fed 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -298,6 +298,45 @@ static inline long compat_keyctl_dh_compute(
 #endif
 #endif
 
+#ifdef CONFIG_ASYMMETRIC_KEY_TYPE
+extern long keyctl_pkey_query(key_serial_t,
+			      const char __user *,
+			      struct keyctl_pkey_query __user *);
+
+extern long keyctl_pkey_verify(const struct keyctl_pkey_params __user *,
+			       const char __user *,
+			       const void __user *, const void __user *);
+
+extern long keyctl_pkey_e_d_s(int,
+			      const struct keyctl_pkey_params __user *,
+			      const char __user *,
+			      const void __user *, void __user *);
+#else
+static inline long keyctl_pkey_query(key_serial_t id,
+				     const char __user *_info,
+				     struct keyctl_pkey_query __user *_res)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline long keyctl_pkey_verify(const struct keyctl_pkey_params __user *params,
+				      const char __user *_info,
+				      const void __user *_in,
+				      const void __user *_in2)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline long keyctl_pkey_e_d_s(int op,
+				     const struct keyctl_pkey_params __user *params,
+				     const char __user *_info,
+				     const void __user *_in,
+				     void __user *_out)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
 /*
  * Debugging key validation
  */

commit 074d58989569b39f04294c90ef36dd82b8c2cc1a
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Nov 15 16:38:45 2017 +0000

    security: keys: Replace time_t/timespec with time64_t
    
    The 'struct key' will use 'time_t' which we try to remove in the
    kernel, since 'time_t' is not year 2038 safe on 32bit systems.
    Also the 'struct keyring_search_context' will use 'timespec' type
    to record current time, which is also not year 2038 safe on 32bit
    systems.
    
    Thus this patch replaces 'time_t' with 'time64_t' which is year 2038
    safe for 'struct key', and replace 'timespec' with 'time64_t' for the
    'struct keyring_search_context', since we only look at the the seconds
    part of 'timespec' variable. Moreover we also change the codes where
    using the 'time_t' and 'timespec', and we can get current time by
    ktime_get_real_seconds() instead of current_kernel_time(), and use
    'TIME64_MAX' macro to initialize the 'time64_t' type variable.
    
    Especially in proc.c file, we have replaced 'unsigned long' and 'timespec'
    type with 'u64' and 'time64_t' type to save the timeout value, which means
    user will get one 'u64' type timeout value by issuing proc_keys_show()
    function.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 503adbae7b0d..9f8208dc0e55 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -130,7 +130,7 @@ struct keyring_search_context {
 	int			skipped_ret;
 	bool			possessed;
 	key_ref_t		result;
-	struct timespec		now;
+	time64_t		now;
 };
 
 extern bool key_default_cmp(const struct key *key,
@@ -169,10 +169,10 @@ extern void key_change_session_keyring(struct callback_head *twork);
 
 extern struct work_struct key_gc_work;
 extern unsigned key_gc_delay;
-extern void keyring_gc(struct key *keyring, time_t limit);
+extern void keyring_gc(struct key *keyring, time64_t limit);
 extern void keyring_restriction_gc(struct key *keyring,
 				   struct key_type *dead_type);
-extern void key_schedule_gc(time_t gc_at);
+extern void key_schedule_gc(time64_t gc_at);
 extern void key_schedule_gc_links(void);
 extern void key_gc_keytype(struct key_type *ktype);
 
@@ -211,7 +211,7 @@ extern struct key *key_get_instantiation_authkey(key_serial_t target_id);
 /*
  * Determine whether a key is dead.
  */
-static inline bool key_is_dead(const struct key *key, time_t limit)
+static inline bool key_is_dead(const struct key *key, time64_t limit)
 {
 	return
 		key->flags & ((1 << KEY_FLAG_DEAD) |

commit 237bbd29f7a049d310d907f4b2716a7feef9abf3
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Sep 18 11:37:03 2017 -0700

    KEYS: prevent creating a different user's keyrings
    
    It was possible for an unprivileged user to create the user and user
    session keyrings for another user.  For example:
    
        sudo -u '#3000' sh -c 'keyctl add keyring _uid.4000 "" @u
                               keyctl add keyring _uid_ses.4000 "" @u
                               sleep 15' &
        sleep 1
        sudo -u '#4000' keyctl describe @u
        sudo -u '#4000' keyctl describe @us
    
    This is problematic because these "fake" keyrings won't have the right
    permissions.  In particular, the user who created them first will own
    them and will have full access to them via the possessor permissions,
    which can be used to compromise the security of a user's keys:
    
        -4: alswrv-----v------------  3000     0 keyring: _uid.4000
        -5: alswrv-----v------------  3000     0 keyring: _uid_ses.4000
    
    Fix it by marking user and user session keyrings with a flag
    KEY_FLAG_UID_KEYRING.  Then, when searching for a user or user session
    keyring by name, skip all keyrings that don't have the flag set.
    
    Fixes: 69664cf16af4 ("keys: don't generate user and user session keyrings unless they're accessed")
    Cc: <stable@vger.kernel.org>    [v2.6.26+]
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 1c02c6547038..503adbae7b0d 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -141,7 +141,7 @@ extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 extern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);
 extern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);
 
-extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);
+extern struct key *find_keyring_by_name(const char *name, bool uid_keyring);
 
 extern int install_user_keyrings(void);
 extern int install_thread_keyring_to_cred(struct cred *);

commit e06fdaf40a5c021dd4a2ec797e8b724f07360070
Merge: a90c6ac2b565 8acdf5055974
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 19 08:55:18 2017 -0700

    Merge tag 'gcc-plugins-v4.13-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull structure randomization updates from Kees Cook:
     "Now that IPC and other changes have landed, enable manual markings for
      randstruct plugin, including the task_struct.
    
      This is the rest of what was staged in -next for the gcc-plugins, and
      comes in three patches, largest first:
    
       - mark "easy" structs with __randomize_layout
    
       - mark task_struct with an optional anonymous struct to isolate the
         __randomize_layout section
    
       - mark structs to opt _out_ of automated marking (which will come
         later)
    
      And, FWIW, this continues to pass allmodconfig (normal and patched to
      enable gcc-plugins) builds of x86_64, i386, arm64, arm, powerpc, and
      s390 for me"
    
    * tag 'gcc-plugins-v4.13-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux:
      randstruct: opt-out externally exposed function pointer structs
      task_struct: Allow randomized layout
      randstruct: Mark various structs for randomization

commit 3859a271a003aba01e45b85c9d8b355eb7bf25f9
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Oct 28 01:22:25 2016 -0700

    randstruct: Mark various structs for randomization
    
    This marks many critical kernel structures for randomization. These are
    structures that have been targeted in the past in security exploits, or
    contain functions pointers, pointers to function pointer tables, lists,
    workqueues, ref-counters, credentials, permissions, or are otherwise
    sensitive. This initial list was extracted from Brad Spengler/PaX Team's
    code in the last public patch of grsecurity/PaX based on my understanding
    of the code. Changes or omissions from the original code are mine and
    don't reflect the original grsecurity/PaX code.
    
    Left out of this list is task_struct, which requires special handling
    and will be covered in a subsequent patch.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index c0f8682eba69..6494954e9980 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -197,7 +197,7 @@ struct request_key_auth {
 	void			*callout_info;
 	size_t			callout_len;
 	pid_t			pid;
-};
+} __randomize_layout;
 
 extern struct key_type key_type_request_key_auth;
 extern struct key *request_key_auth_new(struct key *target,

commit 5dd43ce2f69d42a71dcacdb13d17d8c0ac1fe8f7
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:19:09 2017 +0200

    sched/wait: Split out the wait_bit*() APIs from <linux/wait.h> into <linux/wait_bit.h>
    
    The wait_bit*() types and APIs are mixed into wait.h, but they
    are a pretty orthogonal extension of wait-queues.
    
    Furthermore, only about 50 kernel files use these APIs, while
    over 1000 use the regular wait-queue functionality.
    
    So clean up the main wait.h by moving the wait-bit functionality
    out of it, into a separate .h and .c file:
    
      include/linux/wait_bit.h  for types and APIs
      kernel/sched/wait_bit.c   for the implementation
    
    Update all header dependencies.
    
    This reduces the size of wait.h rather significantly, by about 30%.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index c0f8682eba69..91bc6214ae57 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -13,6 +13,7 @@
 #define _INTERNAL_H
 
 #include <linux/sched.h>
+#include <linux/wait_bit.h>
 #include <linux/cred.h>
 #include <linux/key-type.h>
 #include <linux/task_work.h>

commit f1c316a3ab9d24df6022682422fe897492f2c0c8
Author: Stephan Mueller <smueller@chronox.de>
Date:   Fri Aug 19 20:39:09 2016 +0200

    KEYS: add SP800-56A KDF support for DH
    
    SP800-56A defines the use of DH with key derivation function based on a
    counter. The input to the KDF is defined as (DH shared secret || other
    information). The value for the "other information" is to be provided by
    the caller.
    
    The KDF is implemented using the hash support from the kernel crypto API.
    The implementation uses the symmetric hash support as the input to the
    hash operation is usually very small. The caller is allowed to specify
    the hash name that he wants to use to derive the key material allowing
    the use of all supported hashes provided with the kernel crypto API.
    
    As the KDF implements the proper truncation of the DH shared secret to
    the requested size, this patch fills the caller buffer up to its size.
    
    The patch is tested with a new test added to the keyutils user space
    code which uses a CAVS test vector testing the compliance with
    SP800-56A.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 6ce016314897..c0f8682eba69 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -18,6 +18,7 @@
 #include <linux/task_work.h>
 #include <linux/keyctl.h>
 #include <linux/refcount.h>
+#include <linux/compat.h>
 
 struct iovec;
 
@@ -267,15 +268,34 @@ static inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)
 
 #ifdef CONFIG_KEY_DH_OPERATIONS
 extern long keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,
-			      size_t, void __user *);
+			      size_t, struct keyctl_kdf_params __user *);
+extern long __keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,
+				size_t, struct keyctl_kdf_params *);
+#ifdef CONFIG_KEYS_COMPAT
+extern long compat_keyctl_dh_compute(struct keyctl_dh_params __user *params,
+				char __user *buffer, size_t buflen,
+				struct compat_keyctl_kdf_params __user *kdf);
+#endif
+#define KEYCTL_KDF_MAX_OUTPUT_LEN	1024	/* max length of KDF output */
+#define KEYCTL_KDF_MAX_OI_LEN		64	/* max length of otherinfo */
 #else
 static inline long keyctl_dh_compute(struct keyctl_dh_params __user *params,
 				     char __user *buffer, size_t buflen,
-				     void __user *reserved)
+				     struct keyctl_kdf_params __user *kdf)
+{
+	return -EOPNOTSUPP;
+}
+
+#ifdef CONFIG_KEYS_COMPAT
+static inline long compat_keyctl_dh_compute(
+				struct keyctl_dh_params __user *params,
+				char __user *buffer, size_t buflen,
+				struct keyctl_kdf_params __user *kdf)
 {
 	return -EOPNOTSUPP;
 }
 #endif
+#endif
 
 /*
  * Debugging key validation

commit 6563c91fd645556c7801748f15bc727c77fcd311
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Wed Mar 1 16:44:09 2017 -0800

    KEYS: Add KEYCTL_RESTRICT_KEYRING
    
    Keyrings recently gained restrict_link capabilities that allow
    individual keys to be validated prior to linking.  This functionality
    was only available using internal kernel APIs.
    
    With the KEYCTL_RESTRICT_KEYRING command existing keyrings can be
    configured to check the content of keys before they are linked, and
    then allow or disallow linkage of that key to the keyring.
    
    To restrict a keyring, call:
    
      keyctl(KEYCTL_RESTRICT_KEYRING, key_serial_t keyring, const char *type,
             const char *restriction)
    
    where 'type' is the name of a registered key type and 'restriction' is a
    string describing how key linkage is to be restricted. The restriction
    option syntax is specific to each key type.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 24762ae9a198..6ce016314897 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -252,6 +252,9 @@ struct iov_iter;
 extern long keyctl_instantiate_key_common(key_serial_t,
 					  struct iov_iter *,
 					  key_serial_t);
+extern long keyctl_restrict_keyring(key_serial_t id,
+				    const char __user *_type,
+				    const char __user *_restriction);
 #ifdef CONFIG_PERSISTENT_KEYRINGS
 extern long keyctl_get_persistent(uid_t, key_serial_t);
 extern unsigned persistent_keyring_expiry;

commit 2b6aa412ff23a02ac777ad307249c60a839cfd25
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Wed Aug 31 16:05:43 2016 -0700

    KEYS: Use structure to capture key restriction function and data
    
    Replace struct key's restrict_link function pointer with a pointer to
    the new struct key_restriction. The structure contains pointers to the
    restriction function as well as relevant data for evaluating the
    restriction.
    
    The garbage collector checks restrict_link->keytype when key types are
    unregistered. Restrictions involving a removed key type are converted
    to use restrict_link_reject so that restrictions cannot be removed by
    unregistering key types.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 6bee06ae026d..24762ae9a198 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -168,6 +168,8 @@ extern void key_change_session_keyring(struct callback_head *twork);
 extern struct work_struct key_gc_work;
 extern unsigned key_gc_delay;
 extern void keyring_gc(struct key *keyring, time_t limit);
+extern void keyring_restriction_gc(struct key *keyring,
+				   struct key_type *dead_type);
 extern void key_schedule_gc(time_t gc_at);
 extern void key_schedule_gc_links(void);
 extern void key_gc_keytype(struct key_type *ktype);

commit ddb99e118e37f324a4be65a411bb60ae62795cf9
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Fri Mar 31 15:20:49 2017 +0300

    security, keys: convert key_user.usage from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index a2f4c0abb8d8..6bee06ae026d 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -17,6 +17,7 @@
 #include <linux/key-type.h>
 #include <linux/task_work.h>
 #include <linux/keyctl.h>
+#include <linux/refcount.h>
 
 struct iovec;
 
@@ -53,7 +54,7 @@ struct key_user {
 	struct rb_node		node;
 	struct mutex		cons_lock;	/* construction initiation lock */
 	spinlock_t		lock;
-	atomic_t		usage;		/* for accessing qnkeys & qnbytes */
+	refcount_t		usage;		/* for accessing qnkeys & qnbytes */
 	atomic_t		nkeys;		/* number of keys */
 	atomic_t		nikeys;		/* number of instantiated keys */
 	kuid_t			uid;

commit 5b825c3af1d8a0af4deb4a5eb349d0d0050c62e5
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 17:54:15 2017 +0100

    sched/headers: Prepare to remove <linux/cred.h> inclusion from <linux/sched.h>
    
    Add #include <linux/cred.h> dependencies to all .c files rely on sched.h
    doing that for them.
    
    Note that even if the count where we need to add extra headers seems high,
    it's still a net win, because <linux/sched.h> is included in over
    2,200 files ...
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index a705a7d92ad7..a2f4c0abb8d8 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -13,6 +13,7 @@
 #define _INTERNAL_H
 
 #include <linux/sched.h>
+#include <linux/cred.h>
 #include <linux/key-type.h>
 #include <linux/task_work.h>
 #include <linux/keyctl.h>

commit 4693fc734d675c5518ea9bd4c9623db45bc37402
Author: Stephan Mueller <smueller@chronox.de>
Date:   Thu May 26 23:38:12 2016 +0200

    KEYS: Add placeholder for KDF usage with DH
    
    The values computed during Diffie-Hellman key exchange are often used
    in combination with key derivation functions to create cryptographic
    keys.  Add a placeholder for a later implementation to configure a
    key derivation function that will transform the Diffie-Hellman
    result returned by the KEYCTL_DH_COMPUTE command.
    
    [This patch was stripped down from a patch produced by Mat Martineau that
     had a bug in the compat code - so for the moment Stephan's patch simply
     requires that the placeholder argument must be NULL]
    
    Original-signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 8ec7a528365d..a705a7d92ad7 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -260,10 +260,11 @@ static inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)
 
 #ifdef CONFIG_KEY_DH_OPERATIONS
 extern long keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,
-			      size_t);
+			      size_t, void __user *);
 #else
 static inline long keyctl_dh_compute(struct keyctl_dh_params __user *params,
-				     char __user *buffer, size_t buflen)
+				     char __user *buffer, size_t buflen,
+				     void __user *reserved)
 {
 	return -EOPNOTSUPP;
 }

commit ddbb41148724367394d0880c516bfaeed127b52e
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Tue Apr 12 19:54:58 2016 +0100

    KEYS: Add KEYCTL_DH_COMPUTE command
    
    This adds userspace access to Diffie-Hellman computations through a
    new keyctl() syscall command to calculate shared secrets or public
    keys using input parameters stored in the keyring.
    
    Input key ids are provided in a struct due to the current 5-arg limit
    for the keyctl syscall. Only user keys are supported in order to avoid
    exposing the content of logon or encrypted keys.
    
    The output is written to the provided buffer, based on the assumption
    that the values are only needed in userspace.
    
    Future support for other types of key derivation would involve a new
    command, like KEYCTL_ECDH_COMPUTE.
    
    Once Diffie-Hellman support is included in the crypto API, this code
    can be converted to use the crypto API to take advantage of possible
    hardware acceleration and reduce redundant code.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 5105c2c2da75..8ec7a528365d 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -15,6 +15,7 @@
 #include <linux/sched.h>
 #include <linux/key-type.h>
 #include <linux/task_work.h>
+#include <linux/keyctl.h>
 
 struct iovec;
 
@@ -257,6 +258,17 @@ static inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)
 }
 #endif
 
+#ifdef CONFIG_KEY_DH_OPERATIONS
+extern long keyctl_dh_compute(struct keyctl_dh_params __user *, char __user *,
+			      size_t);
+#else
+static inline long keyctl_dh_compute(struct keyctl_dh_params __user *params,
+				     char __user *buffer, size_t buflen)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
 /*
  * Debugging key validation
  */

commit b353a1f7bbd6c015e8563e902f7c78710348e28f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 17 09:59:38 2015 -0400

    switch keyctl_instantiate_key_common() to iov_iter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 200e37867336..5105c2c2da75 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -243,9 +243,10 @@ extern long keyctl_instantiate_key_iov(key_serial_t,
 				       unsigned, key_serial_t);
 extern long keyctl_invalidate_key(key_serial_t);
 
+struct iov_iter;
 extern long keyctl_instantiate_key_common(key_serial_t,
-					  const struct iovec *,
-					  unsigned, size_t, key_serial_t);
+					  struct iov_iter *,
+					  key_serial_t);
 #ifdef CONFIG_PERSISTENT_KEYRINGS
 extern long keyctl_get_persistent(uid_t, key_serial_t);
 extern unsigned persistent_keyring_expiry;

commit 0b0a84154eff56913e91df29de5c3a03a0029e38
Author: David Howells <dhowells@redhat.com>
Date:   Mon Dec 1 22:52:53 2014 +0000

    KEYS: request_key() should reget expired keys rather than give EKEYEXPIRED
    
    Since the keyring facility can be viewed as a cache (at least in some
    applications), the local expiration time on the key should probably be viewed
    as a 'needs updating after this time' property rather than an absolute 'anyone
    now wanting to use this object is out of luck' property.
    
    Since request_key() is the main interface for the usage of keys, this should
    update or replace an expired key rather than issuing EKEYEXPIRED if the local
    expiration has been reached (ie. it should refresh the cache).
    
    For absolute conditions where refreshing the cache probably doesn't help, the
    key can be negatively instantiated using KEYCTL_REJECT_KEY with EKEYEXPIRED
    given as the error to issue.  This will still cause request_key() to return
    EKEYEXPIRED as that was explicitly set.
    
    In the future, if the key type has an update op available, we might want to
    upcall with the expired key and allow the upcall to update it.  We would pass
    a different operation name (the first column in /etc/request-key.conf) to the
    request-key program.
    
    request_key() returning EKEYEXPIRED is causing an NFS problem which Chuck
    Lever describes thusly:
    
            After about 10 minutes, my NFSv4 functional tests fail because the
            ownership of the test files goes to "-2". Looking at /proc/keys
            shows that the id_resolv keys that map to my test user ID have
            expired. The ownership problem persists until the expired keys are
            purged from the keyring, and fresh keys are obtained.
    
            I bisected the problem to 3.13 commit b2a4df200d57 ("KEYS: Expand
            the capacity of a keyring"). This commit inadvertantly changes the
            API contract of the internal function keyring_search_aux().
    
            The root cause appears to be that b2a4df200d57 made "no state check"
            the default behavior. "No state check" means the keyring search
            iterator function skips checking the key's expiry timeout, and
            returns expired keys.  request_key_and_link() depends on getting
            an -EAGAIN result code to know when to perform an upcall to refresh
            an expired key.
    
    This patch can be tested directly by:
    
            keyctl request2 user debug:fred a @s
            keyctl timeout %user:debug:fred 3
            sleep 4
            keyctl request2 user debug:fred a @s
    
    Without the patch, the last command gives error EKEYEXPIRED, but with the
    command it gives a new key.
    
    Reported-by: Carl Hetherington <cth@carlh.net>
    Reported-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index b8960c4959a5..200e37867336 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -117,6 +117,7 @@ struct keyring_search_context {
 #define KEYRING_SEARCH_NO_UPDATE_TIME	0x0004	/* Don't update times */
 #define KEYRING_SEARCH_NO_CHECK_PERM	0x0008	/* Don't check permissions */
 #define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0010	/* Give an error on excessive depth */
+#define KEYRING_SEARCH_SKIP_EXPIRED	0x0020	/* Ignore expired keys (intention to replace) */
 
 	int (*iterator)(const void *object, void *iterator_data);
 

commit 0c903ab64feb0fe83eac9f67a06e2f5b9508de16
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:08 2014 +0100

    KEYS: Make the key matching functions return bool
    
    Make the key matching functions pointed to by key_match_data::cmp return bool
    rather than int.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index e66a16cb63e1..b8960c4959a5 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -127,8 +127,8 @@ struct keyring_search_context {
 	struct timespec		now;
 };
 
-extern int key_default_cmp(const struct key *key,
-			   const struct key_match_data *match_data);
+extern bool key_default_cmp(const struct key *key,
+			    const struct key_match_data *match_data);
 extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 				    struct keyring_search_context *ctx);
 
@@ -150,8 +150,8 @@ extern struct key *request_key_and_link(struct key_type *type,
 					struct key *dest_keyring,
 					unsigned long flags);
 
-extern int lookup_user_key_possessed(const struct key *key,
-				     const struct key_match_data *match_data);
+extern bool lookup_user_key_possessed(const struct key *key,
+				      const struct key_match_data *match_data);
 extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 				 key_perm_t perm);
 #define KEY_LOOKUP_CREATE	0x01

commit c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:06 2014 +0100

    KEYS: Remove key_type::match in favour of overriding default by match_preparse
    
    A previous patch added a ->match_preparse() method to the key type.  This is
    allowed to override the function called by the iteration algorithm.
    Therefore, we can just set a default that simply checks for an exact match of
    the key description with the original criterion data and allow match_preparse
    to override it as needed.
    
    The key_type::match op is then redundant and can be removed, as can the
    user_match() function.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index b47cc532be1e..e66a16cb63e1 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -127,6 +127,8 @@ struct keyring_search_context {
 	struct timespec		now;
 };
 
+extern int key_default_cmp(const struct key *key,
+			   const struct key_match_data *match_data);
 extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 				    struct keyring_search_context *ctx);
 

commit 614d8c39014c185aa0f7254f0a470cc33fc1b284
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:04 2014 +0100

    KEYS: Remove key_type::def_lookup_type
    
    Remove key_type::def_lookup_type as it's no longer used.  The information now
    defaults to KEYRING_SEARCH_LOOKUP_DIRECT but may be overridden by
    type->match_preparse().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 805e60b0b87e..b47cc532be1e 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -112,12 +112,11 @@ struct keyring_search_context {
 	const struct cred	*cred;
 	struct key_match_data	match_data;
 	unsigned		flags;
-#define KEYRING_SEARCH_LOOKUP_TYPE	0x0001	/* [as type->def_lookup_type] */
-#define KEYRING_SEARCH_NO_STATE_CHECK	0x0002	/* Skip state checks */
-#define KEYRING_SEARCH_DO_STATE_CHECK	0x0004	/* Override NO_STATE_CHECK */
-#define KEYRING_SEARCH_NO_UPDATE_TIME	0x0008	/* Don't update times */
-#define KEYRING_SEARCH_NO_CHECK_PERM	0x0010	/* Don't check permissions */
-#define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0020	/* Give an error on excessive depth */
+#define KEYRING_SEARCH_NO_STATE_CHECK	0x0001	/* Skip state checks */
+#define KEYRING_SEARCH_DO_STATE_CHECK	0x0002	/* Override NO_STATE_CHECK */
+#define KEYRING_SEARCH_NO_UPDATE_TIME	0x0004	/* Don't update times */
+#define KEYRING_SEARCH_NO_CHECK_PERM	0x0008	/* Don't check permissions */
+#define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0010	/* Give an error on excessive depth */
 
 	int (*iterator)(const void *object, void *iterator_data);
 

commit 462919591a1791e76042dc5c1e0148715df59beb
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:02 2014 +0100

    KEYS: Preparse match data
    
    Preparse the match data.  This provides several advantages:
    
     (1) The preparser can reject invalid criteria up front.
    
     (2) The preparser can convert the criteria to binary data if necessary (the
         asymmetric key type really wants to do binary comparison of the key IDs).
    
     (3) The preparser can set the type of search to be performed.  This means
         that it's not then a one-off setting in the key type.
    
     (4) The preparser can set an appropriate comparator function.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 5f20da01fd8d..805e60b0b87e 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -107,13 +107,10 @@ extern int iterate_over_keyring(const struct key *keyring,
 				int (*func)(const struct key *key, void *data),
 				void *data);
 
-typedef int (*key_match_func_t)(const struct key *, const void *);
-
 struct keyring_search_context {
 	struct keyring_index_key index_key;
 	const struct cred	*cred;
-	key_match_func_t	match;
-	const void		*match_data;
+	struct key_match_data	match_data;
 	unsigned		flags;
 #define KEYRING_SEARCH_LOOKUP_TYPE	0x0001	/* [as type->def_lookup_type] */
 #define KEYRING_SEARCH_NO_STATE_CHECK	0x0002	/* Skip state checks */
@@ -152,7 +149,8 @@ extern struct key *request_key_and_link(struct key_type *type,
 					struct key *dest_keyring,
 					unsigned long flags);
 
-extern int lookup_user_key_possessed(const struct key *key, const void *target);
+extern int lookup_user_key_possessed(const struct key *key,
+				     const struct key_match_data *match_data);
 extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 				 key_perm_t perm);
 #define KEY_LOOKUP_CREATE	0x01

commit f5895943d91b41b0368830cdb6eaffb8eda0f4c8
Author: David Howells <dhowells@redhat.com>
Date:   Fri Mar 14 17:44:49 2014 +0000

    KEYS: Move the flags representing required permission to linux/key.h
    
    Move the flags representing required permission to linux/key.h as the perm
    parameter of security_key_permission() is in terms of them - and not the
    permissions mask flags used in key->perm.
    
    Whilst we're at it:
    
     (1) Rename them to be KEY_NEED_xxx rather than KEY_xxx to avoid collisions
         with symbols in uapi/linux/input.h.
    
     (2) Don't use key_perm_t for a mask of required permissions, but rather limit
         it to the permissions mask attached to the key and arguments related
         directly to that.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Dmitry Kasatkin <d.kasatkin@samsung.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 80b2aac4f50c..5f20da01fd8d 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -176,20 +176,11 @@ extern int key_task_permission(const key_ref_t key_ref,
 /*
  * Check to see whether permission is granted to use a key in the desired way.
  */
-static inline int key_permission(const key_ref_t key_ref, key_perm_t perm)
+static inline int key_permission(const key_ref_t key_ref, unsigned perm)
 {
 	return key_task_permission(key_ref, current_cred(), perm);
 }
 
-/* required permissions */
-#define	KEY_VIEW	0x01	/* require permission to view attributes */
-#define	KEY_READ	0x02	/* require permission to read content */
-#define	KEY_WRITE	0x04	/* require permission to update / modify */
-#define	KEY_SEARCH	0x08	/* require permission to search (keyring) or find (key) */
-#define	KEY_LINK	0x10	/* require permission to link */
-#define	KEY_SETATTR	0x20	/* require permission to change attributes */
-#define	KEY_ALL		0x3f	/* all the above permissions */
-
 /*
  * Authorisation record for request_key().
  */

commit f36f8c75ae2e7d4da34f4c908cebdb4aa42c977e
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:19 2013 +0100

    KEYS: Add per-user_namespace registers for persistent per-UID kerberos caches
    
    Add support for per-user_namespace registers of persistent per-UID kerberos
    caches held within the kernel.
    
    This allows the kerberos cache to be retained beyond the life of all a user's
    processes so that the user's cron jobs can work.
    
    The kerberos cache is envisioned as a keyring/key tree looking something like:
    
            struct user_namespace
              \___ .krb_cache keyring               - The register
                    \___ _krb.0 keyring             - Root's Kerberos cache
                    \___ _krb.5000 keyring          - User 5000's Kerberos cache
                    \___ _krb.5001 keyring          - User 5001's Kerberos cache
                            \___ tkt785 big_key     - A ccache blob
                            \___ tkt12345 big_key   - Another ccache blob
    
    Or possibly:
    
            struct user_namespace
              \___ .krb_cache keyring               - The register
                    \___ _krb.0 keyring             - Root's Kerberos cache
                    \___ _krb.5000 keyring          - User 5000's Kerberos cache
                    \___ _krb.5001 keyring          - User 5001's Kerberos cache
                            \___ tkt785 keyring     - A ccache
                                    \___ krbtgt/REDHAT.COM@REDHAT.COM big_key
                                    \___ http/REDHAT.COM@REDHAT.COM user
                                    \___ afs/REDHAT.COM@REDHAT.COM user
                                    \___ nfs/REDHAT.COM@REDHAT.COM user
                                    \___ krbtgt/KERNEL.ORG@KERNEL.ORG big_key
                                    \___ http/KERNEL.ORG@KERNEL.ORG big_key
    
    What goes into a particular Kerberos cache is entirely up to userspace.  Kernel
    support is limited to giving you the Kerberos cache keyring that you want.
    
    The user asks for their Kerberos cache by:
    
            krb_cache = keyctl_get_krbcache(uid, dest_keyring);
    
    The uid is -1 or the user's own UID for the user's own cache or the uid of some
    other user's cache (requires CAP_SETUID).  This permits rpc.gssd or whatever to
    mess with the cache.
    
    The cache returned is a keyring named "_krb.<uid>" that the possessor can read,
    search, clear, invalidate, unlink from and add links to.  Active LSMs get a
    chance to rule on whether the caller is permitted to make a link.
    
    Each uid's cache keyring is created when it first accessed and is given a
    timeout that is extended each time this function is called so that the keyring
    goes away after a while.  The timeout is configurable by sysctl but defaults to
    three days.
    
    Each user_namespace struct gets a lazily-created keyring that serves as the
    register.  The cache keyrings are added to it.  This means that standard key
    search and garbage collection facilities are available.
    
    The user_namespace struct's register goes away when it does and anything left
    in it is then automatically gc'd.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Simo Sorce <simo@redhat.com>
    cc: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    cc: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 581c6f688352..80b2aac4f50c 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -255,6 +255,15 @@ extern long keyctl_invalidate_key(key_serial_t);
 extern long keyctl_instantiate_key_common(key_serial_t,
 					  const struct iovec *,
 					  unsigned, size_t, key_serial_t);
+#ifdef CONFIG_PERSISTENT_KEYRINGS
+extern long keyctl_get_persistent(uid_t, key_serial_t);
+extern unsigned persistent_keyring_expiry;
+#else
+static inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)
+{
+	return -EOPNOTSUPP;
+}
+#endif
 
 /*
  * Debugging key validation

commit b2a4df200d570b2c33a57e1ebfa5896e4bc81b69
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:18 2013 +0100

    KEYS: Expand the capacity of a keyring
    
    Expand the capacity of a keyring to be able to hold a lot more keys by using
    the previously added associative array implementation.  Currently the maximum
    capacity is:
    
            (PAGE_SIZE - sizeof(header)) / sizeof(struct key *)
    
    which, on a 64-bit system, is a little more 500.  However, since this is being
    used for the NFS uid mapper, we need more than that.  The new implementation
    gives us effectively unlimited capacity.
    
    With some alterations, the keyutils testsuite runs successfully to completion
    after this patch is applied.  The alterations are because (a) keyrings that
    are simply added to no longer appear ordered and (b) some of the errors have
    changed a bit.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 73950bf8f875..581c6f688352 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -90,20 +90,23 @@ extern void key_type_put(struct key_type *ktype);
 
 extern int __key_link_begin(struct key *keyring,
 			    const struct keyring_index_key *index_key,
-			    unsigned long *_prealloc);
+			    struct assoc_array_edit **_edit);
 extern int __key_link_check_live_key(struct key *keyring, struct key *key);
-extern void __key_link(struct key *keyring, struct key *key,
-		       unsigned long *_prealloc);
+extern void __key_link(struct key *key, struct assoc_array_edit **_edit);
 extern void __key_link_end(struct key *keyring,
 			   const struct keyring_index_key *index_key,
-			   unsigned long prealloc);
+			   struct assoc_array_edit *edit);
 
-extern key_ref_t __keyring_search_one(key_ref_t keyring_ref,
-				      const struct keyring_index_key *index_key);
+extern key_ref_t find_key_to_update(key_ref_t keyring_ref,
+				    const struct keyring_index_key *index_key);
 
 extern struct key *keyring_search_instkey(struct key *keyring,
 					  key_serial_t target_id);
 
+extern int iterate_over_keyring(const struct key *keyring,
+				int (*func)(const struct key *key, void *data),
+				void *data);
+
 typedef int (*key_match_func_t)(const struct key *, const void *);
 
 struct keyring_search_context {
@@ -119,6 +122,8 @@ struct keyring_search_context {
 #define KEYRING_SEARCH_NO_CHECK_PERM	0x0010	/* Don't check permissions */
 #define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0020	/* Give an error on excessive depth */
 
+	int (*iterator)(const void *object, void *iterator_data);
+
 	/* Internal stuff */
 	int			skipped_ret;
 	bool			possessed;

commit e57e8669f2ab8350d30f771dd2fdd5377f183db2
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:17 2013 +0100

    KEYS: Drop the permissions argument from __keyring_search_one()
    
    Drop the permissions argument from __keyring_search_one() as the only caller
    passes 0 here - which causes all checks to be skipped.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index f4bf938b68b4..73950bf8f875 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -99,8 +99,7 @@ extern void __key_link_end(struct key *keyring,
 			   unsigned long prealloc);
 
 extern key_ref_t __keyring_search_one(key_ref_t keyring_ref,
-				      const struct keyring_index_key *index_key,
-				      key_perm_t perm);
+				      const struct keyring_index_key *index_key);
 
 extern struct key *keyring_search_instkey(struct key *keyring,
 					  key_serial_t target_id);

commit 4bdf0bc300314141e5475e145acb8b5ad846f00d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:15 2013 +0100

    KEYS: Introduce a search context structure
    
    Search functions pass around a bunch of arguments, each of which gets copied
    with each call.  Introduce a search context structure to hold these.
    
    Whilst we're at it, create a search flag that indicates whether the search
    should be directly to the description or whether it should iterate through all
    keys looking for a non-description match.
    
    This will be useful when keyrings use a generic data struct with generic
    routines to manage their content as the search terms can just be passed
    through to the iterator callback function.
    
    Also, for future use, the data to be supplied to the match function is
    separated from the description pointer in the search context.  This makes it
    clear which is being supplied.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 77441dd1f9d4..f4bf938b68b4 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -107,23 +107,31 @@ extern struct key *keyring_search_instkey(struct key *keyring,
 
 typedef int (*key_match_func_t)(const struct key *, const void *);
 
+struct keyring_search_context {
+	struct keyring_index_key index_key;
+	const struct cred	*cred;
+	key_match_func_t	match;
+	const void		*match_data;
+	unsigned		flags;
+#define KEYRING_SEARCH_LOOKUP_TYPE	0x0001	/* [as type->def_lookup_type] */
+#define KEYRING_SEARCH_NO_STATE_CHECK	0x0002	/* Skip state checks */
+#define KEYRING_SEARCH_DO_STATE_CHECK	0x0004	/* Override NO_STATE_CHECK */
+#define KEYRING_SEARCH_NO_UPDATE_TIME	0x0008	/* Don't update times */
+#define KEYRING_SEARCH_NO_CHECK_PERM	0x0010	/* Don't check permissions */
+#define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0020	/* Give an error on excessive depth */
+
+	/* Internal stuff */
+	int			skipped_ret;
+	bool			possessed;
+	key_ref_t		result;
+	struct timespec		now;
+};
+
 extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
-				    const struct cred *cred,
-				    struct key_type *type,
-				    const void *description,
-				    key_match_func_t match,
-				    bool no_state_check);
-
-extern key_ref_t search_my_process_keyrings(struct key_type *type,
-					    const void *description,
-					    key_match_func_t match,
-					    bool no_state_check,
-					    const struct cred *cred);
-extern key_ref_t search_process_keyrings(struct key_type *type,
-					 const void *description,
-					 key_match_func_t match,
-					 bool no_state_check,
-					 const struct cred *cred);
+				    struct keyring_search_context *ctx);
+
+extern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);
+extern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);
 
 extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);
 

commit 16feef4340172b7dbb9cba60850e78fa6388adf1
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:15 2013 +0100

    KEYS: Consolidate the concept of an 'index key' for key access
    
    Consolidate the concept of an 'index key' for accessing keys.  The index key
    is the search term needed to find a key directly - basically the key type and
    the key description.  We can add to that the description length.
    
    This will be useful when turning a keyring into an associative array rather
    than just a pointer block.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 490aef5ba34b..77441dd1f9d4 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -89,19 +89,17 @@ extern struct key_type *key_type_lookup(const char *type);
 extern void key_type_put(struct key_type *ktype);
 
 extern int __key_link_begin(struct key *keyring,
-			    const struct key_type *type,
-			    const char *description,
+			    const struct keyring_index_key *index_key,
 			    unsigned long *_prealloc);
 extern int __key_link_check_live_key(struct key *keyring, struct key *key);
 extern void __key_link(struct key *keyring, struct key *key,
 		       unsigned long *_prealloc);
 extern void __key_link_end(struct key *keyring,
-			   struct key_type *type,
+			   const struct keyring_index_key *index_key,
 			   unsigned long prealloc);
 
 extern key_ref_t __keyring_search_one(key_ref_t keyring_ref,
-				      const struct key_type *type,
-				      const char *description,
+				      const struct keyring_index_key *index_key,
 				      key_perm_t perm);
 
 extern struct key *keyring_search_instkey(struct key *keyring,

commit 7e55ca6dcd07b45619035df343c9614a3ab35034
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:14 2013 +0100

    KEYS: key_is_dead() should take a const key pointer argument
    
    key_is_dead() should take a const key pointer argument as it doesn't modify
    what it points to.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index df971feceaf2..490aef5ba34b 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -203,7 +203,7 @@ extern struct key *key_get_instantiation_authkey(key_serial_t target_id);
 /*
  * Determine whether a key is dead.
  */
-static inline bool key_is_dead(struct key *key, time_t limit)
+static inline bool key_is_dead(const struct key *key, time_t limit)
 {
 	return
 		key->flags & ((1 << KEY_FLAG_DEAD) |

commit 61ea0c0ba904a55f55317d850c1072ff7835ac92
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:13 2013 +0100

    KEYS: Skip key state checks when checking for possession
    
    Skip key state checks (invalidation, revocation and expiration) when checking
    for possession.  Without this, keys that have been marked invalid, revoked
    keys and expired keys are not given a possession attribute - which means the
    possessor is not granted any possession permits and cannot do anything with
    them unless they also have one a user, group or other permit.
    
    This causes failures in the keyutils test suite's revocation and expiration
    tests now that commit 96b5c8fea6c0861621051290d705ec2e971963f1 reduced the
    initial permissions granted to a key.
    
    The failures are due to accesses to revoked and expired keys being given
    EACCES instead of EKEYREVOKED or EKEYEXPIRED.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index d4f1468b9b50..df971feceaf2 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -124,6 +124,7 @@ extern key_ref_t search_my_process_keyrings(struct key_type *type,
 extern key_ref_t search_process_keyrings(struct key_type *type,
 					 const void *description,
 					 key_match_func_t match,
+					 bool no_state_check,
 					 const struct cred *cred);
 
 extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);

commit a27bb332c04cec8c4afd7912df0dc7890db27560
Author: Kent Overstreet <koverstreet@google.com>
Date:   Tue May 7 16:19:08 2013 -0700

    aio: don't include aio.h in sched.h
    
    Faster kernel compiles by way of fewer unnecessary includes.
    
    [akpm@linux-foundation.org: fix fallout]
    [akpm@linux-foundation.org: fix build]
    Signed-off-by: Kent Overstreet <koverstreet@google.com>
    Cc: Zach Brown <zab@redhat.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Asai Thambi S P <asamymuthupa@micron.com>
    Cc: Selvan Mani <smani@micron.com>
    Cc: Sam Bradshaw <sbradshaw@micron.com>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Benjamin LaHaise <bcrl@kvack.org>
    Reviewed-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 8bbefc3b55d4..d4f1468b9b50 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -16,6 +16,8 @@
 #include <linux/key-type.h>
 #include <linux/task_work.h>
 
+struct iovec;
+
 #ifdef __KDEBUG
 #define kenter(FMT, ...) \
 	printk(KERN_DEBUG "==> %s("FMT")\n", __func__, ##__VA_ARGS__)

commit 9a56c2db49e7349c7963f0ce66c1ef578d44ebd3
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 8 07:53:04 2012 -0800

    userns: Convert security/keys to the new userns infrastructure
    
    - Replace key_user ->user_ns equality checks with kuid_has_mapping checks.
    - Use from_kuid to generate key descriptions
    - Use kuid_t and kgid_t and the associated helpers instead of uid_t and gid_t
    - Avoid potential problems with file descriptor passing by displaying
      keys in the user namespace of the opener of key status proc files.
    
    Cc: linux-security-module@vger.kernel.org
    Cc: keyrings@linux-nfs.org
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 22ff05269e3d..8bbefc3b55d4 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -52,8 +52,7 @@ struct key_user {
 	atomic_t		usage;		/* for accessing qnkeys & qnbytes */
 	atomic_t		nkeys;		/* number of keys */
 	atomic_t		nikeys;		/* number of instantiated keys */
-	uid_t			uid;
-	struct user_namespace	*user_ns;
+	kuid_t			uid;
 	int			qnkeys;		/* number of keys allocated to this user */
 	int			qnbytes;	/* number of bytes allocated to this user */
 };
@@ -62,8 +61,7 @@ extern struct rb_root	key_user_tree;
 extern spinlock_t	key_user_lock;
 extern struct key_user	root_key_user;
 
-extern struct key_user *key_user_lookup(uid_t uid,
-					struct user_namespace *user_ns);
+extern struct key_user *key_user_lookup(kuid_t uid);
 extern void key_user_put(struct key_user *user);
 
 /*

commit e05644e17e744315bce12b0948cdc36910b9a76e
Merge: 97e7292ab5cc 663728418e34
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 23 18:49:06 2012 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Nothing groundbreaking for this kernel, just cleanups and fixes, and a
      couple of Smack enhancements."
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (21 commits)
      Smack: Maintainer Record
      Smack: don't show empty rules when /smack/load or /smack/load2 is read
      Smack: user access check bounds
      Smack: onlycap limits on CAP_MAC_ADMIN
      Smack: fix smack_new_inode bogosities
      ima: audit is compiled only when enabled
      ima: ima_initialized is set only if successful
      ima: add policy for pseudo fs
      ima: remove unused cleanup functions
      ima: free securityfs violations file
      ima: use full pathnames in measurement list
      security: Fix nommu build.
      samples: seccomp: add .gitignore for untracked executables
      tpm: check the chip reference before using it
      TPM: fix memleak when register hardware fails
      TPM: chip disabled state erronously being reported as error
      MAINTAINERS: TPM maintainers' contacts update
      Merge branches 'next-queue' and 'next' into next
      Remove unused code from MPI library
      Revert "crypto: GnuPG based MPI lib - additional sources (part 4)"
      ...

commit 67d1214551e800f9fe7dc7c47a346d2df0fafed5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 27 11:07:19 2012 +0400

    merge task_work and rcu_head, get rid of separate allocation for keyring case
    
    task_work and rcu_head are identical now; merge them (calling the result
    struct callback_head, rcu_head #define'd to it), kill separate allocation
    in security/keys since we can just use cred->rcu now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index b510a316874a..c246ba5d43ab 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -148,12 +148,8 @@ extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 #define KEY_LOOKUP_PARTIAL	0x02
 #define KEY_LOOKUP_FOR_UNLINK	0x04
 
-struct kludge {	/* this will die off very soon */
-	struct task_work twork;
-	struct cred *cred;
-};
 extern long join_session_keyring(const char *name);
-extern void key_change_session_keyring(struct task_work *twork);
+extern void key_change_session_keyring(struct callback_head *twork);
 
 extern struct work_struct key_gc_work;
 extern unsigned key_gc_delay;

commit 41f9d29f09ca0b22c3631e8a39676e74cda9bcc0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 26 22:10:04 2012 +0400

    trimming task_work: kill ->data
    
    get rid of the only user of ->data; this is _not_ the final variant - in the
    end we'll have task_work and rcu_head identical and just use cred->rcu,
    at which point the separate allocation will be gone completely.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 3dcbf86b0d31..b510a316874a 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -148,6 +148,10 @@ extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 #define KEY_LOOKUP_PARTIAL	0x02
 #define KEY_LOOKUP_FOR_UNLINK	0x04
 
+struct kludge {	/* this will die off very soon */
+	struct task_work twork;
+	struct cred *cred;
+};
 extern long join_session_keyring(const char *name);
 extern void key_change_session_keyring(struct task_work *twork);
 

commit 66dd07b88a1c9d446f32253da606b87324fa620e
Merge: f52c44cd27b4 cfaf025112d3
Author: James Morris <james.l.morris@oracle.com>
Date:   Sun Jun 10 22:52:10 2012 +1000

    Merge commit 'v3.5-rc2' into next

commit 423b9788023263364ea5de04189f02bd9b6a12db
Author: David Howells <dhowells@redhat.com>
Date:   Mon May 21 12:32:13 2012 +0100

    KEYS: Fix some sparse warnings
    
    Fix some sparse warnings in the keyrings code:
    
     (1) compat_keyctl_instantiate_key_iov() should be static.
    
     (2) There were a couple of places where a pointer was being compared against
         integer 0 rather than NULL.
    
     (3) keyctl_instantiate_key_common() should not take a __user-labelled iovec
         pointer as the caller must have copied the iovec to kernel space.
    
     (4) __key_link_begin() takes and __key_link_end() releases
         keyring_serialise_link_sem under some circumstances and so this should be
         declared.
    
         Note that adding __acquires() and __releases() for this doesn't help cure
         the warnings messages - something only commenting out both helps.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index f711b094ed41..f173be2ce3ea 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -240,7 +240,7 @@ extern long keyctl_instantiate_key_iov(key_serial_t,
 extern long keyctl_invalidate_key(key_serial_t);
 
 extern long keyctl_instantiate_key_common(key_serial_t,
-					  const struct iovec __user *,
+					  const struct iovec *,
 					  unsigned, size_t, key_serial_t);
 
 /*

commit 413cd3d9abeaef590e5ce00564f7a443165db238
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri May 11 10:59:08 2012 +1000

    keys: change keyctl_session_to_parent() to use task_work_add()
    
    Change keyctl_session_to_parent() to use task_work_add() and move
    key_replace_session_keyring() logic into task_work->func().
    
    Note that we do task_work_cancel() before task_work_add() to ensure that
    only one work can be pending at any time.  This is important, we must not
    allow user-space to abuse the parent's ->task_works list.
    
    The callback, replace_session_keyring(), checks PF_EXITING.  I guess this
    is not really needed but looks better.
    
    As a side effect, this fixes the (unlikely) race.  The callers of
    key_replace_session_keyring() and keyctl_session_to_parent() lack the
    necessary barriers, the parent can miss the request.
    
    Now we can remove task_struct->replacement_session_keyring and related
    code.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alexander Gordeev <agordeev@redhat.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: David Smith <dsmith@redhat.com>
    Cc: "Frank Ch. Eigler" <fche@redhat.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index f711b094ed41..3dcbf86b0d31 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -14,6 +14,7 @@
 
 #include <linux/sched.h>
 #include <linux/key-type.h>
+#include <linux/task_work.h>
 
 #ifdef __KDEBUG
 #define kenter(FMT, ...) \
@@ -148,6 +149,7 @@ extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 #define KEY_LOOKUP_FOR_UNLINK	0x04
 
 extern long join_session_keyring(const char *name);
+extern void key_change_session_keyring(struct task_work *twork);
 
 extern struct work_struct key_gc_work;
 extern unsigned key_gc_delay;

commit fd75815f727f157a05f4c96b5294a4617c0557da
Author: David Howells <dhowells@redhat.com>
Date:   Fri May 11 10:56:56 2012 +0100

    KEYS: Add invalidation support
    
    Add support for invalidating a key - which renders it immediately invisible to
    further searches and causes the garbage collector to immediately wake up,
    remove it from keyrings and then destroy it when it's no longer referenced.
    
    It's better not to do this with keyctl_revoke() as that marks the key to start
    returning -EKEYREVOKED to searches when what is actually desired is to have the
    key refetched.
    
    To invalidate a key the caller must be granted SEARCH permission by the key.
    This may be too strict.  It may be better to also permit invalidation if the
    caller has any of READ, WRITE or SETATTR permission.
    
    The primary use for this is to evict keys that are cached in special keyrings,
    such as the DNS resolver or an ID mapper.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 65647f825584..f711b094ed41 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -152,7 +152,8 @@ extern long join_session_keyring(const char *name);
 extern struct work_struct key_gc_work;
 extern unsigned key_gc_delay;
 extern void keyring_gc(struct key *keyring, time_t limit);
-extern void key_schedule_gc(time_t expiry_at);
+extern void key_schedule_gc(time_t gc_at);
+extern void key_schedule_gc_links(void);
 extern void key_gc_keytype(struct key_type *ktype);
 
 extern int key_task_permission(const key_ref_t key_ref,
@@ -196,6 +197,17 @@ extern struct key *request_key_auth_new(struct key *target,
 
 extern struct key *key_get_instantiation_authkey(key_serial_t target_id);
 
+/*
+ * Determine whether a key is dead.
+ */
+static inline bool key_is_dead(struct key *key, time_t limit)
+{
+	return
+		key->flags & ((1 << KEY_FLAG_DEAD) |
+			      (1 << KEY_FLAG_INVALIDATED)) ||
+		(key->expiry > 0 && key->expiry <= limit);
+}
+
 /*
  * keyctl() functions
  */
@@ -225,6 +237,7 @@ extern long keyctl_reject_key(key_serial_t, unsigned, unsigned, key_serial_t);
 extern long keyctl_instantiate_key_iov(key_serial_t,
 				       const struct iovec __user *,
 				       unsigned, key_serial_t);
+extern long keyctl_invalidate_key(key_serial_t);
 
 extern long keyctl_instantiate_key_common(key_serial_t,
 					  const struct iovec __user *,

commit 9f6ed2ca257fa8650b876377833e6f14e272848b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Jan 17 16:09:11 2012 -0500

    keys: add a "logon" key type
    
    For CIFS, we want to be able to store NTLM credentials (aka username
    and password) in the keyring. We do not, however want to allow users
    to fetch those keys back out of the keyring since that would be a
    security risk.
    
    Unfortunately, due to the nuances of key permission bits, it's not
    possible to do this. We need to grant search permissions so the kernel
    can find these keys, but that also implies permissions to read the
    payload.
    
    Resolve this by adding a new key_type. This key type is essentially
    the same as key_type_user, but does not define a .read op. This
    prevents the payload from ever being visible from userspace. This
    key type also vets the description to ensure that it's "qualified"
    by checking to ensure that it has a ':' in it that is preceded by
    other characters.
    
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index c7a7caec4830..65647f825584 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -33,6 +33,7 @@
 
 extern struct key_type key_type_dead;
 extern struct key_type key_type_user;
+extern struct key_type key_type_logon;
 
 /*****************************************************************************/
 /*

commit 0c061b5707ab84ebfe8f18f1c9c3110ae5cd6073
Author: David Howells <dhowells@redhat.com>
Date:   Mon Aug 22 14:09:36 2011 +0100

    KEYS: Correctly destroy key payloads when their keytype is removed
    
    unregister_key_type() has code to mark a key as dead and make it unavailable in
    one loop and then destroy all those unavailable key payloads in the next loop.
    However, the loop to mark keys dead renders the key undetectable to the second
    loop by changing the key type pointer also.
    
    Fix this by the following means:
    
     (1) The key code has two garbage collectors: one deletes unreferenced keys and
         the other alters keyrings to delete links to old dead, revoked and expired
         keys.  They can end up holding each other up as both want to scan the key
         serial tree under spinlock.  Combine these into a single routine.
    
     (2) Move the dead key marking, dead link removal and dead key removal into the
         garbage collector as a three phase process running over the three cycles
         of the normal garbage collection procedure.  This is tracked by the
         KEY_GC_REAPING_DEAD_1, _2 and _3 state flags.
    
         unregister_key_type() then just unlinks the key type from the list, wakes
         up the garbage collector and waits for the third phase to complete.
    
     (3) Downgrade the key types sem in unregister_key_type() once it has deleted
         the key type from the list so that it doesn't block the keyctl() syscall.
    
     (4) Dead keys that cannot be simply removed in the third phase have their
         payloads destroyed with the key's semaphore write-locked to prevent
         interference by the keyctl() syscall.  There should be no in-kernel users
         of dead keys of that type by the point of unregistration, though keyctl()
         may be holding a reference.
    
     (5) Only perform timer recalculation in the GC if the timer actually expired.
         If it didn't, we'll get another cycle when it goes off - and if the key
         that actually triggered it has been removed, it's not a problem.
    
     (6) Only garbage collect link if the timer expired or if we're doing dead key
         clean up phase 2.
    
     (7) As only key_garbage_collector() is permitted to use rb_erase() on the key
         serial tree, it doesn't need to revalidate its cursor after dropping the
         spinlock as the node the cursor points to must still exist in the tree.
    
     (8) Drop the spinlock in the GC if there is contention on it or if we need to
         reschedule.  After dealing with that, get the spinlock again and resume
         scanning.
    
    This has been tested in the following ways:
    
     (1) Run the keyutils testsuite against it.
    
     (2) Using the AF_RXRPC and RxKAD modules to test keytype removal:
    
         Load the rxrpc_s key type:
    
            # insmod /tmp/af-rxrpc.ko
            # insmod /tmp/rxkad.ko
    
         Create a key (http://people.redhat.com/~dhowells/rxrpc/listen.c):
    
            # /tmp/listen &
            [1] 8173
    
         Find the key:
    
            # grep rxrpc_s /proc/keys
            091086e1 I--Q--     1 perm 39390000     0     0 rxrpc_s   52:2
    
         Link it to a session keyring, preferably one with a higher serial number:
    
            # keyctl link 0x20e36251 @s
    
         Kill the process (the key should remain as it's linked to another place):
    
            # fg
            /tmp/listen
            ^C
    
         Remove the key type:
    
            rmmod rxkad
            rmmod af-rxrpc
    
         This can be made a more effective test by altering the following part of
         the patch:
    
            if (unlikely(gc_state & KEY_GC_REAPING_DEAD_2)) {
                    /* Make sure everyone revalidates their keys if we marked a
                     * bunch as being dead and make sure all keyring ex-payloads
                     * are destroyed.
                     */
                    kdebug("dead sync");
                    synchronize_rcu();
    
         To call synchronize_rcu() in GC phase 1 instead.  That causes that the
         keyring's old payload content to hang around longer until it's RCU
         destroyed - which usually happens after GC phase 3 is complete.  This
         allows the destroy_dead_key branch to be tested.
    
    Reported-by: Benjamin Coddington <bcodding@gmail.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index a7cd1a682321..c7a7caec4830 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -31,6 +31,7 @@
 	no_printk(KERN_DEBUG FMT"\n", ##__VA_ARGS__)
 #endif
 
+extern struct key_type key_type_dead;
 extern struct key_type key_type_user;
 
 /*****************************************************************************/
@@ -147,10 +148,11 @@ extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 
 extern long join_session_keyring(const char *name);
 
-extern struct work_struct key_gc_unused_work;
+extern struct work_struct key_gc_work;
 extern unsigned key_gc_delay;
 extern void keyring_gc(struct key *keyring, time_t limit);
 extern void key_schedule_gc(time_t expiry_at);
+extern void key_gc_keytype(struct key_type *ktype);
 
 extern int key_task_permission(const key_ref_t key_ref,
 			       const struct cred *cred,

commit 8bc16deabce7649e480e94b648c88d4e90c34352
Author: David Howells <dhowells@redhat.com>
Date:   Mon Aug 22 14:09:11 2011 +0100

    KEYS: Move the unreferenced key reaper to the keys garbage collector file
    
    Move the unreferenced key reaper function to the keys garbage collector file
    as that's a more appropriate place with the dead key link reaper.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index f375152a2500..a7cd1a682321 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -75,6 +75,7 @@ extern unsigned key_quota_maxbytes;
 #define KEYQUOTA_LINK_BYTES	4		/* a link in a keyring is worth 4 bytes */
 
 
+extern struct kmem_cache *key_jar;
 extern struct rb_root key_serial_tree;
 extern spinlock_t key_serial_lock;
 extern struct mutex key_construction_mutex;
@@ -146,6 +147,7 @@ extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 
 extern long join_session_keyring(const char *name);
 
+extern struct work_struct key_gc_unused_work;
 extern unsigned key_gc_delay;
 extern void keyring_gc(struct key *keyring, time_t limit);
 extern void key_schedule_gc(time_t expiry_at);

commit 78b7280cce23293f7570ad52c1ffe1485c6d9669
Author: David Howells <dhowells@redhat.com>
Date:   Fri Mar 11 17:57:23 2011 +0000

    KEYS: Improve /proc/keys
    
    Improve /proc/keys by:
    
     (1) Don't attempt to summarise the payload of a negated key.  It won't have
         one.  To this end, a helper function - key_is_instantiated() has been
         added that allows the caller to find out whether the key is positively
         instantiated (as opposed to being uninstantiated or negatively
         instantiated).
    
     (2) Do show keys that are negative, expired or revoked rather than hiding
         them.  This requires an override flag (no_state_check) to be passed to
         search_my_process_keyrings() and keyring_search_aux() to suppress this
         check.
    
         Without this, keys that are possessed by the caller, but only grant
         permissions to the caller if possessed are skipped as the possession check
         fails.
    
         Keys that are visible due to user, group or other checks are visible with
         or without this patch.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 07a025f81902..f375152a2500 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -109,11 +109,13 @@ extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 				    const struct cred *cred,
 				    struct key_type *type,
 				    const void *description,
-				    key_match_func_t match);
+				    key_match_func_t match,
+				    bool no_state_check);
 
 extern key_ref_t search_my_process_keyrings(struct key_type *type,
 					    const void *description,
 					    key_match_func_t match,
+					    bool no_state_check,
 					    const struct cred *cred);
 extern key_ref_t search_process_keyrings(struct key_type *type,
 					 const void *description,

commit ee009e4a0d4555ed522a631bae9896399674f064
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 7 15:06:20 2011 +0000

    KEYS: Add an iovec version of KEYCTL_INSTANTIATE
    
    Add a keyctl op (KEYCTL_INSTANTIATE_IOV) that is like KEYCTL_INSTANTIATE, but
    takes an iovec array and concatenates the data in-kernel into one buffer.
    Since the KEYCTL_INSTANTIATE copies the data anyway, this isn't too much of a
    problem.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 286c0959ee51..07a025f81902 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -215,6 +215,13 @@ extern long keyctl_get_security(key_serial_t keyid, char __user *buffer,
 				size_t buflen);
 extern long keyctl_session_to_parent(void);
 extern long keyctl_reject_key(key_serial_t, unsigned, unsigned, key_serial_t);
+extern long keyctl_instantiate_key_iov(key_serial_t,
+				       const struct iovec __user *,
+				       unsigned, key_serial_t);
+
+extern long keyctl_instantiate_key_common(key_serial_t,
+					  const struct iovec __user *,
+					  unsigned, size_t, key_serial_t);
 
 /*
  * Debugging key validation

commit fdd1b94581782a2ddf9124414e5b7a5f48ce2f9c
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 7 15:06:09 2011 +0000

    KEYS: Add a new keyctl op to reject a key with a specified error code
    
    Add a new keyctl op to reject a key with a specified error code.  This works
    much the same as negating a key, and so keyctl_negate_key() is made a special
    case of keyctl_reject_key().  The difference is that keyctl_negate_key()
    selects ENOKEY as the error to be reported.
    
    Typically the key would be rejected with EKEYEXPIRED, EKEYREVOKED or
    EKEYREJECTED, but this is not mandatory.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index a52aa7c88b41..286c0959ee51 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -214,6 +214,7 @@ extern long keyctl_assume_authority(key_serial_t);
 extern long keyctl_get_security(key_serial_t keyid, char __user *buffer,
 				size_t buflen);
 extern long keyctl_session_to_parent(void);
+extern long keyctl_reject_key(key_serial_t, unsigned, unsigned, key_serial_t);
 
 /*
  * Debugging key validation

commit ceb73c12047b8d543570b23353e7848eb7c540a1
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 25 16:34:28 2011 +0000

    KEYS: Fix __key_link_end() quota fixup on error
    
    Fix __key_link_end()'s attempt to fix up the quota if an error occurs.
    
    There are two erroneous cases: Firstly, we always decrease the quota if
    the preallocated replacement keyring needs cleaning up, irrespective of
    whether or not we should (we may have replaced a pointer rather than
    adding another pointer).
    
    Secondly, we never clean up the quota if we added a pointer without the
    keyring storage being extended (we allocate multiple pointers at a time,
    even if we're not going to use them all immediately).
    
    We handle this by setting the bottom bit of the preallocation pointer in
    __key_link_begin() to indicate that the quota needs fixing up, which is
    then passed to __key_link() (which clears the whole thing) and
    __key_link_end().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index edfa50dbd6f5..a52aa7c88b41 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -87,13 +87,13 @@ extern void key_type_put(struct key_type *ktype);
 extern int __key_link_begin(struct key *keyring,
 			    const struct key_type *type,
 			    const char *description,
-			    struct keyring_list **_prealloc);
+			    unsigned long *_prealloc);
 extern int __key_link_check_live_key(struct key *keyring, struct key *key);
 extern void __key_link(struct key *keyring, struct key *key,
-		       struct keyring_list **_prealloc);
+		       unsigned long *_prealloc);
 extern void __key_link_end(struct key *keyring,
 			   struct key_type *type,
-			   struct keyring_list *prealloc);
+			   unsigned long prealloc);
 
 extern key_ref_t __keyring_search_one(key_ref_t keyring_ref,
 				      const struct key_type *type,

commit 973c9f4f49ca96a53bcf6384c4c59ccd26c33906
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jan 20 16:38:33 2011 +0000

    KEYS: Fix up comments in key management code
    
    Fix up comments in the key management code.  No functional changes.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 56a133d8f37d..edfa50dbd6f5 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -1,4 +1,4 @@
-/* internal.h: authentication token and access key management internal defs
+/* Authentication token and access key management internal defs
  *
  * Copyright (C) 2003-5, 2007 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
@@ -35,10 +35,12 @@ extern struct key_type key_type_user;
 
 /*****************************************************************************/
 /*
- * keep track of keys for a user
- * - this needs to be separate to user_struct to avoid a refcount-loop
- *   (user_struct pins some keyrings which pin this struct)
- * - this also keeps track of keys under request from userspace for this UID
+ * Keep track of keys for a user.
+ *
+ * This needs to be separate to user_struct to avoid a refcount-loop
+ * (user_struct pins some keyrings which pin this struct).
+ *
+ * We also keep track of keys under request from userspace for this UID here.
  */
 struct key_user {
 	struct rb_node		node;
@@ -62,7 +64,7 @@ extern struct key_user *key_user_lookup(uid_t uid,
 extern void key_user_put(struct key_user *user);
 
 /*
- * key quota limits
+ * Key quota limits.
  * - root has its own separate limits to everyone else
  */
 extern unsigned key_quota_root_maxkeys;
@@ -146,13 +148,13 @@ extern unsigned key_gc_delay;
 extern void keyring_gc(struct key *keyring, time_t limit);
 extern void key_schedule_gc(time_t expiry_at);
 
-/*
- * check to see whether permission is granted to use a key in the desired way
- */
 extern int key_task_permission(const key_ref_t key_ref,
 			       const struct cred *cred,
 			       key_perm_t perm);
 
+/*
+ * Check to see whether permission is granted to use a key in the desired way.
+ */
 static inline int key_permission(const key_ref_t key_ref, key_perm_t perm)
 {
 	return key_task_permission(key_ref, current_cred(), perm);
@@ -168,7 +170,7 @@ static inline int key_permission(const key_ref_t key_ref, key_perm_t perm)
 #define	KEY_ALL		0x3f	/* all the above permissions */
 
 /*
- * request_key authorisation
+ * Authorisation record for request_key().
  */
 struct request_key_auth {
 	struct key		*target_key;
@@ -188,7 +190,7 @@ extern struct key *request_key_auth_new(struct key *target,
 extern struct key *key_get_instantiation_authkey(key_serial_t target_id);
 
 /*
- * keyctl functions
+ * keyctl() functions
  */
 extern long keyctl_get_keyring_ID(key_serial_t, int);
 extern long keyctl_join_session_keyring(const char __user *);
@@ -214,7 +216,7 @@ extern long keyctl_get_security(key_serial_t keyid, char __user *buffer,
 extern long keyctl_session_to_parent(void);
 
 /*
- * debugging key validation
+ * Debugging key validation
  */
 #ifdef KEY_DEBUGGING
 extern void __key_check(const struct key *);

commit 12fdff3fc2483f906ae6404a6e8dcf2550310b6f
Author: David Howells <dhowells@redhat.com>
Date:   Thu Aug 12 16:54:57 2010 +0100

    Add a dummy printk function for the maintenance of unused printks
    
    Add a dummy printk function for the maintenance of unused printks through gcc
    format checking, and also so that side-effect checking is maintained too.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index addb67b169f4..56a133d8f37d 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -15,11 +15,6 @@
 #include <linux/sched.h>
 #include <linux/key-type.h>
 
-static inline __attribute__((format(printf, 1, 2)))
-void no_printk(const char *fmt, ...)
-{
-}
-
 #ifdef __KDEBUG
 #define kenter(FMT, ...) \
 	printk(KERN_DEBUG "==> %s("FMT")\n", __func__, ##__VA_ARGS__)

commit 927942aabbbe506bf9bc70a16dc5460ecc64c148
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jun 11 17:31:10 2010 +0100

    KEYS: Make /proc/keys check to see if a key is possessed before security check
    
    Make /proc/keys check to see if the calling process possesses each key before
    performing the security check.  The possession check can be skipped if the key
    doesn't have the possessor-view permission bit set.
    
    This causes the keys a process possesses to show up in /proc/keys, even if they
    don't have matching user/group/other view permissions.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 38783dcf6c61..addb67b169f4 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -114,6 +114,10 @@ extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 				    const void *description,
 				    key_match_func_t match);
 
+extern key_ref_t search_my_process_keyrings(struct key_type *type,
+					    const void *description,
+					    key_match_func_t match,
+					    const struct cred *cred);
 extern key_ref_t search_process_keyrings(struct key_type *type,
 					 const void *description,
 					 key_match_func_t match,
@@ -134,6 +138,7 @@ extern struct key *request_key_and_link(struct key_type *type,
 					struct key *dest_keyring,
 					unsigned long flags);
 
+extern int lookup_user_key_possessed(const struct key *key, const void *target);
 extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 				 key_perm_t perm);
 #define KEY_LOOKUP_CREATE	0x01

commit 685bfd2c48bb3284d31e73ff3151c957d76deda9
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed May 26 14:43:00 2010 -0700

    umh: creds: convert call_usermodehelper_keys() to use subprocess_info->init()
    
    call_usermodehelper_keys() uses call_usermodehelper_setkeys() to change
    subprocess_info->cred in advance.  Now that we have info->init() we can
    change this code to set tgcred->session_keyring in context of execing
    kernel thread.
    
    Note: since currently call_usermodehelper_keys() is never called with
    UMH_NO_WAIT, call_usermodehelper_keys()->key_get() and umh_keys_cleanup()
    are not really needed, we could rely on install_session_keyring_to_cred()
    which does key_get() on success.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 5d4402a1161a..38783dcf6c61 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -124,6 +124,7 @@ extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);
 extern int install_user_keyrings(void);
 extern int install_thread_keyring_to_cred(struct cred *);
 extern int install_process_keyring_to_cred(struct cred *);
+extern int install_session_keyring_to_cred(struct cred *, struct key *);
 
 extern struct key *request_key_and_link(struct key_type *type,
 					const char *description,

commit f70e2e06196ad4c1c762037da2f75354f6c16b81
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 30 14:32:39 2010 +0100

    KEYS: Do preallocation for __key_link()
    
    Do preallocation for __key_link() so that the various callers in request_key.c
    can deal with any errors from this source before attempting to construct a key.
    This allows them to assume that the actual linkage step is guaranteed to be
    successful.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 24ba0307b7ad..5d4402a1161a 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -87,7 +87,16 @@ extern wait_queue_head_t request_key_conswq;
 extern struct key_type *key_type_lookup(const char *type);
 extern void key_type_put(struct key_type *ktype);
 
-extern int __key_link(struct key *keyring, struct key *key);
+extern int __key_link_begin(struct key *keyring,
+			    const struct key_type *type,
+			    const char *description,
+			    struct keyring_list **_prealloc);
+extern int __key_link_check_live_key(struct key *keyring, struct key *key);
+extern void __key_link(struct key *keyring, struct key *key,
+		       struct keyring_list **_prealloc);
+extern void __key_link_end(struct key *keyring,
+			   struct key_type *type,
+			   struct keyring_list *prealloc);
 
 extern key_ref_t __keyring_search_one(key_ref_t keyring_ref,
 				      const struct key_type *type,

commit ee18d64c1f632043a02e6f5ba5e045bb26a5465f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:14:21 2009 +0100

    KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]
    
    Add a keyctl to install a process's session keyring onto its parent.  This
    replaces the parent's session keyring.  Because the COW credential code does
    not permit one process to change another process's credentials directly, the
    change is deferred until userspace next starts executing again.  Normally this
    will be after a wait*() syscall.
    
    To support this, three new security hooks have been provided:
    cred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in
    the blank security creds and key_session_to_parent() - which asks the LSM if
    the process may replace its parent's session keyring.
    
    The replacement may only happen if the process has the same ownership details
    as its parent, and the process has LINK permission on the session keyring, and
    the session keyring is owned by the process, and the LSM permits it.
    
    Note that this requires alteration to each architecture's notify_resume path.
    This has been done for all arches barring blackfin, m68k* and xtensa, all of
    which need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the
    replacement to be performed at the point the parent process resumes userspace
    execution.
    
    This allows the userspace AFS pioctl emulation to fully emulate newpag() and
    the VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to
    alter the parent process's PAG membership.  However, since kAFS doesn't use
    PAGs per se, but rather dumps the keys into the session keyring, the session
    keyring of the parent must be replaced if, for example, VIOCSETTOK is passed
    the newpag flag.
    
    This can be tested with the following program:
    
            #include <stdio.h>
            #include <stdlib.h>
            #include <keyutils.h>
    
            #define KEYCTL_SESSION_TO_PARENT        18
    
            #define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)
    
            int main(int argc, char **argv)
            {
                    key_serial_t keyring, key;
                    long ret;
    
                    keyring = keyctl_join_session_keyring(argv[1]);
                    OSERROR(keyring, "keyctl_join_session_keyring");
    
                    key = add_key("user", "a", "b", 1, keyring);
                    OSERROR(key, "add_key");
    
                    ret = keyctl(KEYCTL_SESSION_TO_PARENT);
                    OSERROR(ret, "KEYCTL_SESSION_TO_PARENT");
    
                    return 0;
            }
    
    Compiled and linked with -lkeyutils, you should see something like:
    
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            355907932 --alswrv   4043    -1   \_ keyring: _uid.4043
            [dhowells@andromeda ~]$ /tmp/newpag
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: _ses
            1055658746 --alswrv   4043  4043   \_ user: a
            [dhowells@andromeda ~]$ /tmp/newpag hello
            [dhowells@andromeda ~]$ keyctl show
            Session Keyring
                   -3 --alswrv   4043  4043  keyring: hello
            340417692 --alswrv   4043  4043   \_ user: a
    
    Where the test program creates a new session keyring, sticks a user key named
    'a' into it and then installs it on its parent.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index fb830514c337..24ba0307b7ad 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -201,6 +201,7 @@ extern long keyctl_set_timeout(key_serial_t, unsigned);
 extern long keyctl_assume_authority(key_serial_t);
 extern long keyctl_get_security(key_serial_t keyid, char __user *buffer,
 				size_t buflen);
+extern long keyctl_session_to_parent(void);
 
 /*
  * debugging key validation

commit 5d135440faf7db8d566de0c6fab36b16cf9cfc3b
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:14:00 2009 +0100

    KEYS: Add garbage collection for dead, revoked and expired keys. [try #6]
    
    Add garbage collection for dead, revoked and expired keys.  This involved
    erasing all links to such keys from keyrings that point to them.  At that
    point, the key will be deleted in the normal manner.
    
    Keyrings from which garbage collection occurs are shrunk and their quota
    consumption reduced as appropriate.
    
    Dead keys (for which the key type has been removed) will be garbage collected
    immediately.
    
    Revoked and expired keys will hang around for a number of seconds, as set in
    /proc/sys/kernel/keys/gc_delay before being automatically removed.  The default
    is 5 minutes.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index a7252e7b2e05..fb830514c337 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -132,6 +132,10 @@ extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 
 extern long join_session_keyring(const char *name);
 
+extern unsigned key_gc_delay;
+extern void keyring_gc(struct key *keyring, time_t limit);
+extern void key_schedule_gc(time_t expiry_at);
+
 /*
  * check to see whether permission is granted to use a key in the desired way
  */

commit 5593122eec26b061cc0b6fbff32118f1aadf4a27
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 2 09:13:45 2009 +0100

    KEYS: Deal with dead-type keys appropriately [try #6]
    
    Allow keys for which the key type has been removed to be unlinked.  Currently
    dead-type keys can only be disposed of by completely clearing the keyrings
    that point to them.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 9fb679c66b8a..a7252e7b2e05 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -124,8 +124,11 @@ extern struct key *request_key_and_link(struct key_type *type,
 					struct key *dest_keyring,
 					unsigned long flags);
 
-extern key_ref_t lookup_user_key(key_serial_t id, int create, int partial,
+extern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,
 				 key_perm_t perm);
+#define KEY_LOOKUP_CREATE	0x01
+#define KEY_LOOKUP_PARTIAL	0x02
+#define KEY_LOOKUP_FOR_UNLINK	0x04
 
 extern long join_session_keyring(const char *name);
 

commit 1d1e97562e5e2ac60fb7b25437ba619f95f67fab
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Thu Feb 26 18:27:38 2009 -0600

    keys: distinguish per-uid keys in different namespaces
    
    per-uid keys were looked by uid only.  Use the user namespace
    to distinguish the same uid in different namespaces.
    
    This does not address key_permission.  So a task can for instance
    try to join a keyring owned by the same uid in another namespace.
    That will be handled by a separate patch.
    
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 81932abefe7b..9fb679c66b8a 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -53,6 +53,7 @@ struct key_user {
 	atomic_t		nkeys;		/* number of keys */
 	atomic_t		nikeys;		/* number of instantiated keys */
 	uid_t			uid;
+	struct user_namespace	*user_ns;
 	int			qnkeys;		/* number of keys allocated to this user */
 	int			qnbytes;	/* number of bytes allocated to this user */
 };
@@ -61,7 +62,8 @@ extern struct rb_root	key_user_tree;
 extern spinlock_t	key_user_lock;
 extern struct key_user	root_key_user;
 
-extern struct key_user *key_user_lookup(uid_t uid);
+extern struct key_user *key_user_lookup(uid_t uid,
+					struct user_namespace *user_ns);
 extern void key_user_put(struct key_user *user);
 
 /*

commit d84f4f992cbd76e8f39c488cf0c5d123843923b1
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:23 2008 +1100

    CRED: Inaugurate COW credentials
    
    Inaugurate copy-on-write credentials management.  This uses RCU to manage the
    credentials pointer in the task_struct with respect to accesses by other tasks.
    A process may only modify its own credentials, and so does not need locking to
    access or modify its own credentials.
    
    A mutex (cred_replace_mutex) is added to the task_struct to control the effect
    of PTRACE_ATTACHED on credential calculations, particularly with respect to
    execve().
    
    With this patch, the contents of an active credentials struct may not be
    changed directly; rather a new set of credentials must be prepared, modified
    and committed using something like the following sequence of events:
    
            struct cred *new = prepare_creds();
            int ret = blah(new);
            if (ret < 0) {
                    abort_creds(new);
                    return ret;
            }
            return commit_creds(new);
    
    There are some exceptions to this rule: the keyrings pointed to by the active
    credentials may be instantiated - keyrings violate the COW rule as managing
    COW keyrings is tricky, given that it is possible for a task to directly alter
    the keys in a keyring in use by another task.
    
    To help enforce this, various pointers to sets of credentials, such as those in
    the task_struct, are declared const.  The purpose of this is compile-time
    discouragement of altering credentials through those pointers.  Once a set of
    credentials has been made public through one of these pointers, it may not be
    modified, except under special circumstances:
    
      (1) Its reference count may incremented and decremented.
    
      (2) The keyrings to which it points may be modified, but not replaced.
    
    The only safe way to modify anything else is to create a replacement and commit
    using the functions described in Documentation/credentials.txt (which will be
    added by a later patch).
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         This now prepares and commits credentials in various places in the
         security code rather than altering the current creds directly.
    
     (2) Temporary credential overrides.
    
         do_coredump() and sys_faccessat() now prepare their own credentials and
         temporarily override the ones currently on the acting thread, whilst
         preventing interference from other threads by holding cred_replace_mutex
         on the thread being dumped.
    
         This will be replaced in a future patch by something that hands down the
         credentials directly to the functions being called, rather than altering
         the task's objective credentials.
    
     (3) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_capset_check(), ->capset_check()
         (*) security_capset_set(), ->capset_set()
    
             Removed in favour of security_capset().
    
         (*) security_capset(), ->capset()
    
             New.  This is passed a pointer to the new creds, a pointer to the old
             creds and the proposed capability sets.  It should fill in the new
             creds or return an error.  All pointers, barring the pointer to the
             new creds, are now const.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
    
             Changed; now returns a value, which will cause the process to be
             killed if it's an error.
    
         (*) security_task_alloc(), ->task_alloc_security()
    
             Removed in favour of security_prepare_creds().
    
         (*) security_cred_free(), ->cred_free()
    
             New.  Free security data attached to cred->security.
    
         (*) security_prepare_creds(), ->cred_prepare()
    
             New. Duplicate any security data attached to cred->security.
    
         (*) security_commit_creds(), ->cred_commit()
    
             New. Apply any security effects for the upcoming installation of new
             security by commit_creds().
    
         (*) security_task_post_setuid(), ->task_post_setuid()
    
             Removed in favour of security_task_fix_setuid().
    
         (*) security_task_fix_setuid(), ->task_fix_setuid()
    
             Fix up the proposed new credentials for setuid().  This is used by
             cap_set_fix_setuid() to implicitly adjust capabilities in line with
             setuid() changes.  Changes are made to the new credentials, rather
             than the task itself as in security_task_post_setuid().
    
         (*) security_task_reparent_to_init(), ->task_reparent_to_init()
    
             Removed.  Instead the task being reparented to init is referred
             directly to init's credentials.
    
             NOTE!  This results in the loss of some state: SELinux's osid no
             longer records the sid of the thread that forked it.
    
         (*) security_key_alloc(), ->key_alloc()
         (*) security_key_permission(), ->key_permission()
    
             Changed.  These now take cred pointers rather than task pointers to
             refer to the security context.
    
     (4) sys_capset().
    
         This has been simplified and uses less locking.  The LSM functions it
         calls have been merged.
    
     (5) reparent_to_kthreadd().
    
         This gives the current thread the same credentials as init by simply using
         commit_thread() to point that way.
    
     (6) __sigqueue_alloc() and switch_uid()
    
         __sigqueue_alloc() can't stop the target task from changing its creds
         beneath it, so this function gets a reference to the currently applicable
         user_struct which it then passes into the sigqueue struct it returns if
         successful.
    
         switch_uid() is now called from commit_creds(), and possibly should be
         folded into that.  commit_creds() should take care of protecting
         __sigqueue_alloc().
    
     (7) [sg]et[ug]id() and co and [sg]et_current_groups.
    
         The set functions now all use prepare_creds(), commit_creds() and
         abort_creds() to build and check a new set of credentials before applying
         it.
    
         security_task_set[ug]id() is called inside the prepared section.  This
         guarantees that nothing else will affect the creds until we've finished.
    
         The calling of set_dumpable() has been moved into commit_creds().
    
         Much of the functionality of set_user() has been moved into
         commit_creds().
    
         The get functions all simply access the data directly.
    
     (8) security_task_prctl() and cap_task_prctl().
    
         security_task_prctl() has been modified to return -ENOSYS if it doesn't
         want to handle a function, or otherwise return the return value directly
         rather than through an argument.
    
         Additionally, cap_task_prctl() now prepares a new set of credentials, even
         if it doesn't end up using it.
    
     (9) Keyrings.
    
         A number of changes have been made to the keyrings code:
    
         (a) switch_uid_keyring(), copy_keys(), exit_keys() and suid_keys() have
             all been dropped and built in to the credentials functions directly.
             They may want separating out again later.
    
         (b) key_alloc() and search_process_keyrings() now take a cred pointer
             rather than a task pointer to specify the security context.
    
         (c) copy_creds() gives a new thread within the same thread group a new
             thread keyring if its parent had one, otherwise it discards the thread
             keyring.
    
         (d) The authorisation key now points directly to the credentials to extend
             the search into rather pointing to the task that carries them.
    
         (e) Installing thread, process or session keyrings causes a new set of
             credentials to be created, even though it's not strictly necessary for
             process or session keyrings (they're shared).
    
    (10) Usermode helper.
    
         The usermode helper code now carries a cred struct pointer in its
         subprocess_info struct instead of a new session keyring pointer.  This set
         of credentials is derived from init_cred and installed on the new process
         after it has been cloned.
    
         call_usermodehelper_setup() allocates the new credentials and
         call_usermodehelper_freeinfo() discards them if they haven't been used.  A
         special cred function (prepare_usermodeinfo_creds()) is provided
         specifically for call_usermodehelper_setup() to call.
    
         call_usermodehelper_setkeys() adjusts the credentials to sport the
         supplied keyring as the new session keyring.
    
    (11) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) selinux_setprocattr() no longer does its check for whether the
             current ptracer can access processes with the new SID inside the lock
             that covers getting the ptracer's SID.  Whilst this lock ensures that
             the check is done with the ptracer pinned, the result is only valid
             until the lock is released, so there's no point doing it inside the
             lock.
    
    (12) is_single_threaded().
    
         This function has been extracted from selinux_setprocattr() and put into
         a file of its own in the lib/ directory as join_session_keyring() now
         wants to use it too.
    
         The code in SELinux just checked to see whether a task shared mm_structs
         with other tasks (CLONE_VM), but that isn't good enough.  We really want
         to know if they're part of the same thread group (CLONE_THREAD).
    
    (13) nfsd.
    
         The NFS server daemon now has to use the COW credentials to set the
         credentials it is going to use.  It really needs to pass the credentials
         down to the functions it calls, but it can't do that until other patches
         in this series have been applied.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index d1586c629788..81932abefe7b 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -12,6 +12,7 @@
 #ifndef _INTERNAL_H
 #define _INTERNAL_H
 
+#include <linux/sched.h>
 #include <linux/key-type.h>
 
 static inline __attribute__((format(printf, 1, 2)))
@@ -25,7 +26,7 @@ void no_printk(const char *fmt, ...)
 #define kleave(FMT, ...) \
 	printk(KERN_DEBUG "<== %s()"FMT"\n", __func__, ##__VA_ARGS__)
 #define kdebug(FMT, ...) \
-	printk(KERN_DEBUG "xxx" FMT"yyy\n", ##__VA_ARGS__)
+	printk(KERN_DEBUG "   "FMT"\n", ##__VA_ARGS__)
 #else
 #define kenter(FMT, ...) \
 	no_printk(KERN_DEBUG "==> %s("FMT")\n", __func__, ##__VA_ARGS__)
@@ -97,7 +98,7 @@ extern struct key *keyring_search_instkey(struct key *keyring,
 typedef int (*key_match_func_t)(const struct key *, const void *);
 
 extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
-				    struct task_struct *tsk,
+				    const struct cred *cred,
 				    struct key_type *type,
 				    const void *description,
 				    key_match_func_t match);
@@ -105,13 +106,13 @@ extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 extern key_ref_t search_process_keyrings(struct key_type *type,
 					 const void *description,
 					 key_match_func_t match,
-					 struct task_struct *tsk);
+					 const struct cred *cred);
 
 extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);
 
 extern int install_user_keyrings(void);
-extern int install_thread_keyring(void);
-extern int install_process_keyring(void);
+extern int install_thread_keyring_to_cred(struct cred *);
+extern int install_process_keyring_to_cred(struct cred *);
 
 extern struct key *request_key_and_link(struct key_type *type,
 					const char *description,
@@ -130,12 +131,12 @@ extern long join_session_keyring(const char *name);
  * check to see whether permission is granted to use a key in the desired way
  */
 extern int key_task_permission(const key_ref_t key_ref,
-			       struct task_struct *context,
+			       const struct cred *cred,
 			       key_perm_t perm);
 
 static inline int key_permission(const key_ref_t key_ref, key_perm_t perm)
 {
-	return key_task_permission(key_ref, current, perm);
+	return key_task_permission(key_ref, current_cred(), perm);
 }
 
 /* required permissions */
@@ -153,7 +154,7 @@ static inline int key_permission(const key_ref_t key_ref, key_perm_t perm)
 struct request_key_auth {
 	struct key		*target_key;
 	struct key		*dest_keyring;
-	struct task_struct	*context;
+	const struct cred	*cred;
 	void			*callout_info;
 	size_t			callout_len;
 	pid_t			pid;

commit 8bbf4976b59fc9fc2861e79cab7beb3f6d647640
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:14 2008 +1100

    KEYS: Alter use of key instantiation link-to-keyring argument
    
    Alter the use of the key instantiation and negation functions' link-to-keyring
    arguments.  Currently this specifies a keyring in the target process to link
    the key into, creating the keyring if it doesn't exist.  This, however, can be
    a problem for copy-on-write credentials as it means that the instantiating
    process can alter the credentials of the requesting process.
    
    This patch alters the behaviour such that:
    
     (1) If keyctl_instantiate_key() or keyctl_negate_key() are given a specific
         keyring by ID (ringid >= 0), then that keyring will be used.
    
     (2) If keyctl_instantiate_key() or keyctl_negate_key() are given one of the
         special constants that refer to the requesting process's keyrings
         (KEY_SPEC_*_KEYRING, all <= 0), then:
    
         (a) If sys_request_key() was given a keyring to use (destringid) then the
             key will be attached to that keyring.
    
         (b) If sys_request_key() was given a NULL keyring, then the key being
             instantiated will be attached to the default keyring as set by
             keyctl_set_reqkey_keyring().
    
     (3) No extra link will be made.
    
    Decision point (1) follows current behaviour, and allows those instantiators
    who've searched for a specifically named keyring in the requestor's keyring so
    as to partition the keys by type to still have their named keyrings.
    
    Decision point (2) allows the requestor to make sure that the key or keys that
    get produced by request_key() go where they want, whilst allowing the
    instantiator to request that the key is retained.  This is mainly useful for
    situations where the instantiator makes a secondary request, the key for which
    should be retained by the initial requestor:
    
            +-----------+        +--------------+        +--------------+
            |           |        |              |        |              |
            | Requestor |------->| Instantiator |------->| Instantiator |
            |           |        |              |        |              |
            +-----------+        +--------------+        +--------------+
                       request_key()           request_key()
    
    This might be useful, for example, in Kerberos, where the requestor requests a
    ticket, and then the ticket instantiator requests the TGT, which someone else
    then has to go and fetch.  The TGT, however, should be retained in the
    keyrings of the requestor, not the first instantiator.  To make this explict
    an extra special keyring constant is also added.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index a60c68138b4d..d1586c629788 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -109,8 +109,9 @@ extern key_ref_t search_process_keyrings(struct key_type *type,
 
 extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);
 
-extern int install_thread_keyring(struct task_struct *tsk);
-extern int install_process_keyring(struct task_struct *tsk);
+extern int install_user_keyrings(void);
+extern int install_thread_keyring(void);
+extern int install_process_keyring(void);
 
 extern struct key *request_key_and_link(struct key_type *type,
 					const char *description,
@@ -120,8 +121,7 @@ extern struct key *request_key_and_link(struct key_type *type,
 					struct key *dest_keyring,
 					unsigned long flags);
 
-extern key_ref_t lookup_user_key(struct task_struct *context,
-				 key_serial_t id, int create, int partial,
+extern key_ref_t lookup_user_key(key_serial_t id, int create, int partial,
 				 key_perm_t perm);
 
 extern long join_session_keyring(const char *name);
@@ -152,6 +152,7 @@ static inline int key_permission(const key_ref_t key_ref, key_perm_t perm)
  */
 struct request_key_auth {
 	struct key		*target_key;
+	struct key		*dest_keyring;
 	struct task_struct	*context;
 	void			*callout_info;
 	size_t			callout_len;
@@ -161,7 +162,8 @@ struct request_key_auth {
 extern struct key_type key_type_request_key_auth;
 extern struct key *request_key_auth_new(struct key *target,
 					const void *callout_info,
-					size_t callout_len);
+					size_t callout_len,
+					struct key *dest_keyring);
 
 extern struct key *key_get_instantiation_authkey(key_serial_t target_id);
 

commit e9e349b051d98799b743ebf248cc2d986fedf090
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:13 2008 +1100

    KEYS: Disperse linux/key_ui.h
    
    Disperse the bits of linux/key_ui.h as the reason they were put here (keyfs)
    didn't get in.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index b39f5c2e2c4b..a60c68138b4d 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -13,7 +13,6 @@
 #define _INTERNAL_H
 
 #include <linux/key-type.h>
-#include <linux/key-ui.h>
 
 static inline __attribute__((format(printf, 1, 2)))
 void no_printk(const char *fmt, ...)
@@ -82,6 +81,9 @@ extern struct mutex key_construction_mutex;
 extern wait_queue_head_t request_key_conswq;
 
 
+extern struct key_type *key_type_lookup(const char *type);
+extern void key_type_put(struct key_type *ktype);
+
 extern int __key_link(struct key *keyring, struct key *key);
 
 extern key_ref_t __keyring_search_one(key_ref_t keyring_ref,
@@ -118,6 +120,33 @@ extern struct key *request_key_and_link(struct key_type *type,
 					struct key *dest_keyring,
 					unsigned long flags);
 
+extern key_ref_t lookup_user_key(struct task_struct *context,
+				 key_serial_t id, int create, int partial,
+				 key_perm_t perm);
+
+extern long join_session_keyring(const char *name);
+
+/*
+ * check to see whether permission is granted to use a key in the desired way
+ */
+extern int key_task_permission(const key_ref_t key_ref,
+			       struct task_struct *context,
+			       key_perm_t perm);
+
+static inline int key_permission(const key_ref_t key_ref, key_perm_t perm)
+{
+	return key_task_permission(key_ref, current, perm);
+}
+
+/* required permissions */
+#define	KEY_VIEW	0x01	/* require permission to view attributes */
+#define	KEY_READ	0x02	/* require permission to read content */
+#define	KEY_WRITE	0x04	/* require permission to update / modify */
+#define	KEY_SEARCH	0x08	/* require permission to search (keyring) or find (key) */
+#define	KEY_LINK	0x10	/* require permission to link */
+#define	KEY_SETATTR	0x20	/* require permission to change attributes */
+#define	KEY_ALL		0x3f	/* all the above permissions */
+
 /*
  * request_key authorisation
  */

commit dba6a4d32d8677c99e73798d3375417f8a6d46de
Author: Daniel Walker <dwalker@mvista.com>
Date:   Thu Jun 5 22:46:32 2008 -0700

    keys: remove unused key_alloc_sem
    
    This semaphore doesn't appear to be used, so remove it.
    
    Signed-off-by: Daniel Walker <dwalker@mvista.com>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 8c05587f5018..b39f5c2e2c4b 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -78,7 +78,6 @@ extern unsigned key_quota_maxbytes;
 
 extern struct rb_root key_serial_tree;
 extern spinlock_t key_serial_lock;
-extern struct semaphore key_alloc_sem;
 extern struct mutex key_construction_mutex;
 extern wait_queue_head_t request_key_conswq;
 

commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:32 2008 -0700

    keys: make the keyring quotas controllable through /proc/sys
    
    Make the keyring quotas controllable through /proc/sys files:
    
     (*) /proc/sys/kernel/keys/root_maxkeys
         /proc/sys/kernel/keys/root_maxbytes
    
         Maximum number of keys that root may have and the maximum total number of
         bytes of data that root may have stored in those keys.
    
     (*) /proc/sys/kernel/keys/maxkeys
         /proc/sys/kernel/keys/maxbytes
    
         Maximum number of keys that each non-root user may have and the maximum
         total number of bytes of data that each of those users may have stored in
         their keys.
    
    Also increase the quotas as a number of people have been complaining that it's
    not big enough.  I'm not sure that it's big enough now either, but on the
    other hand, it can now be set in /etc/sysctl.conf.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: <kwc@citi.umich.edu>
    Cc: <arunsr@cse.iitk.ac.in>
    Cc: <dwalsh@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 2ab38854c47f..8c05587f5018 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -57,10 +57,6 @@ struct key_user {
 	int			qnbytes;	/* number of bytes allocated to this user */
 };
 
-#define KEYQUOTA_MAX_KEYS	100
-#define KEYQUOTA_MAX_BYTES	10000
-#define KEYQUOTA_LINK_BYTES	4		/* a link in a keyring is worth 4 bytes */
-
 extern struct rb_root	key_user_tree;
 extern spinlock_t	key_user_lock;
 extern struct key_user	root_key_user;
@@ -68,6 +64,16 @@ extern struct key_user	root_key_user;
 extern struct key_user *key_user_lookup(uid_t uid);
 extern void key_user_put(struct key_user *user);
 
+/*
+ * key quota limits
+ * - root has its own separate limits to everyone else
+ */
+extern unsigned key_quota_root_maxkeys;
+extern unsigned key_quota_root_maxbytes;
+extern unsigned key_quota_maxkeys;
+extern unsigned key_quota_maxbytes;
+
+#define KEYQUOTA_LINK_BYTES	4		/* a link in a keyring is worth 4 bytes */
 
 
 extern struct rb_root key_serial_tree;

commit 69664cf16af4f31cd54d77948a4baf9c7e0ca7b9
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:31 2008 -0700

    keys: don't generate user and user session keyrings unless they're accessed
    
    Don't generate the per-UID user and user session keyrings unless they're
    explicitly accessed.  This solves a problem during a login process whereby
    set*uid() is called before the SELinux PAM module, resulting in the per-UID
    keyrings having the wrong security labels.
    
    This also cures the problem of multiple per-UID keyrings sometimes appearing
    due to PAM modules (including pam_keyinit) setuiding and causing user_structs
    to come into and go out of existence whilst the session keyring pins the user
    keyring.  This is achieved by first searching for extant per-UID keyrings
    before inventing new ones.
    
    The serial bound argument is also dropped from find_keyring_by_name() as it's
    not currently made use of (setting it to 0 disables the feature).
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: <kwc@citi.umich.edu>
    Cc: <arunsr@cse.iitk.ac.in>
    Cc: <dwalsh@redhat.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 6361d3736dbc..2ab38854c47f 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -77,8 +77,6 @@ extern struct mutex key_construction_mutex;
 extern wait_queue_head_t request_key_conswq;
 
 
-extern void keyring_publish_name(struct key *keyring);
-
 extern int __key_link(struct key *keyring, struct key *key);
 
 extern key_ref_t __keyring_search_one(key_ref_t keyring_ref,
@@ -102,7 +100,7 @@ extern key_ref_t search_process_keyrings(struct key_type *type,
 					 key_match_func_t match,
 					 struct task_struct *tsk);
 
-extern struct key *find_keyring_by_name(const char *name, key_serial_t bound);
+extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);
 
 extern int install_thread_keyring(struct task_struct *tsk);
 extern int install_process_keyring(struct task_struct *tsk);

commit 70a5bb72b55e82fbfbf1e22cae6975fac58a1e2d
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:26 2008 -0700

    keys: add keyctl function to get a security label
    
    Add a keyctl() function to get the security label of a key.
    
    The following is added to Documentation/keys.txt:
    
     (*) Get the LSM security context attached to a key.
    
            long keyctl(KEYCTL_GET_SECURITY, key_serial_t key, char *buffer,
                        size_t buflen)
    
         This function returns a string that represents the LSM security context
         attached to a key in the buffer provided.
    
         Unless there's an error, it always returns the amount of data it could
         produce, even if that's too big for the buffer, but it won't copy more
         than requested to userspace. If the buffer pointer is NULL then no copy
         will take place.
    
         A NUL character is included at the end of the string if the buffer is
         sufficiently big.  This is included in the returned count.  If no LSM is
         in force then an empty string will be returned.
    
         A process must have view permission on the key for this function to be
         successful.
    
    [akpm@linux-foundation.org: declare keyctl_get_security()]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Paul Moore <paul.moore@hp.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: James Morris <jmorris@namei.org>
    Cc: Kevin Coffman <kwc@citi.umich.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 3cc04c2afe1c..6361d3736dbc 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -155,7 +155,8 @@ extern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);
 extern long keyctl_set_reqkey_keyring(int);
 extern long keyctl_set_timeout(key_serial_t, unsigned);
 extern long keyctl_assume_authority(key_serial_t);
-
+extern long keyctl_get_security(key_serial_t keyid, char __user *buffer,
+				size_t buflen);
 
 /*
  * debugging key validation

commit 4a38e122e2cc6294779021ff4ccc784a3997059e
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 29 01:01:24 2008 -0700

    keys: allow the callout data to be passed as a blob rather than a string
    
    Allow the callout data to be passed as a blob rather than a string for
    internal kernel services that call any request_key_*() interface other than
    request_key().  request_key() itself still takes a NUL-terminated string.
    
    The functions that change are:
    
            request_key_with_auxdata()
            request_key_async()
            request_key_async_with_auxdata()
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Paul Moore <paul.moore@hp.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Kevin Coffman <kwc@citi.umich.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 7d894ef70370..3cc04c2afe1c 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -109,7 +109,8 @@ extern int install_process_keyring(struct task_struct *tsk);
 
 extern struct key *request_key_and_link(struct key_type *type,
 					const char *description,
-					const char *callout_info,
+					const void *callout_info,
+					size_t callout_len,
 					void *aux,
 					struct key *dest_keyring,
 					unsigned long flags);
@@ -120,13 +121,15 @@ extern struct key *request_key_and_link(struct key_type *type,
 struct request_key_auth {
 	struct key		*target_key;
 	struct task_struct	*context;
-	char			*callout_info;
+	void			*callout_info;
+	size_t			callout_len;
 	pid_t			pid;
 };
 
 extern struct key_type key_type_request_key_auth;
 extern struct key *request_key_auth_new(struct key *target,
-					const char *callout_info);
+					const void *callout_info,
+					size_t callout_len);
 
 extern struct key *key_get_instantiation_authkey(key_serial_t target_id);
 

commit dd6f953adb5c4deb9cd7b6a5054e7d5eafe4ed71
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Mar 6 10:03:59 2008 +1100

    security: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index d36d69393356..7d894ef70370 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -22,16 +22,16 @@ void no_printk(const char *fmt, ...)
 
 #ifdef __KDEBUG
 #define kenter(FMT, ...) \
-	printk(KERN_DEBUG "==> %s("FMT")\n", __FUNCTION__, ##__VA_ARGS__)
+	printk(KERN_DEBUG "==> %s("FMT")\n", __func__, ##__VA_ARGS__)
 #define kleave(FMT, ...) \
-	printk(KERN_DEBUG "<== %s()"FMT"\n", __FUNCTION__, ##__VA_ARGS__)
+	printk(KERN_DEBUG "<== %s()"FMT"\n", __func__, ##__VA_ARGS__)
 #define kdebug(FMT, ...) \
 	printk(KERN_DEBUG "xxx" FMT"yyy\n", ##__VA_ARGS__)
 #else
 #define kenter(FMT, ...) \
-	no_printk(KERN_DEBUG "==> %s("FMT")\n", __FUNCTION__, ##__VA_ARGS__)
+	no_printk(KERN_DEBUG "==> %s("FMT")\n", __func__, ##__VA_ARGS__)
 #define kleave(FMT, ...) \
-	no_printk(KERN_DEBUG "<== %s()"FMT"\n", __FUNCTION__, ##__VA_ARGS__)
+	no_printk(KERN_DEBUG "<== %s()"FMT"\n", __func__, ##__VA_ARGS__)
 #define kdebug(FMT, ...) \
 	no_printk(KERN_DEBUG FMT"\n", ##__VA_ARGS__)
 #endif

commit 76181c134f87479fa13bf2548ddf2999055d34d4
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 16 23:29:46 2007 -0700

    KEYS: Make request_key() and co fundamentally asynchronous
    
    Make request_key() and co fundamentally asynchronous to make it easier for
    NFS to make use of them.  There are now accessor functions that do
    asynchronous constructions, a wait function to wait for construction to
    complete, and a completion function for the key type to indicate completion
    of construction.
    
    Note that the construction queue is now gone.  Instead, keys under
    construction are linked in to the appropriate keyring in advance, and that
    anyone encountering one must wait for it to be complete before they can use
    it.  This is done automatically for userspace.
    
    The following auxiliary changes are also made:
    
     (1) Key type implementation stuff is split from linux/key.h into
         linux/key-type.h.
    
     (2) AF_RXRPC provides a way to allocate null rxrpc-type keys so that AFS does
         not need to call key_instantiate_and_link() directly.
    
     (3) Adjust the debugging macros so that they're -Wformat checked even if
         they are disabled, and make it so they can be enabled simply by defining
         __KDEBUG to be consistent with other code of mine.
    
     (3) Documentation.
    
    [alan@lxorguk.ukuu.org.uk: keys: missing word in documentation]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 1bb416f4bbce..d36d69393356 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -1,6 +1,6 @@
 /* internal.h: authentication token and access key management internal defs
  *
- * Copyright (C) 2003-5 Red Hat, Inc. All Rights Reserved.
+ * Copyright (C) 2003-5, 2007 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
  *
  * This program is free software; you can redistribute it and/or
@@ -12,17 +12,28 @@
 #ifndef _INTERNAL_H
 #define _INTERNAL_H
 
-#include <linux/key.h>
+#include <linux/key-type.h>
 #include <linux/key-ui.h>
 
-#if 0
-#define kenter(FMT, a...)	printk("==> %s("FMT")\n",__FUNCTION__ , ## a)
-#define kleave(FMT, a...)	printk("<== %s()"FMT"\n",__FUNCTION__ , ## a)
-#define kdebug(FMT, a...)	printk(FMT"\n" , ## a)
+static inline __attribute__((format(printf, 1, 2)))
+void no_printk(const char *fmt, ...)
+{
+}
+
+#ifdef __KDEBUG
+#define kenter(FMT, ...) \
+	printk(KERN_DEBUG "==> %s("FMT")\n", __FUNCTION__, ##__VA_ARGS__)
+#define kleave(FMT, ...) \
+	printk(KERN_DEBUG "<== %s()"FMT"\n", __FUNCTION__, ##__VA_ARGS__)
+#define kdebug(FMT, ...) \
+	printk(KERN_DEBUG "xxx" FMT"yyy\n", ##__VA_ARGS__)
 #else
-#define kenter(FMT, a...)	do {} while(0)
-#define kleave(FMT, a...)	do {} while(0)
-#define kdebug(FMT, a...)	do {} while(0)
+#define kenter(FMT, ...) \
+	no_printk(KERN_DEBUG "==> %s("FMT")\n", __FUNCTION__, ##__VA_ARGS__)
+#define kleave(FMT, ...) \
+	no_printk(KERN_DEBUG "<== %s()"FMT"\n", __FUNCTION__, ##__VA_ARGS__)
+#define kdebug(FMT, ...) \
+	no_printk(KERN_DEBUG FMT"\n", ##__VA_ARGS__)
 #endif
 
 extern struct key_type key_type_user;
@@ -36,7 +47,7 @@ extern struct key_type key_type_user;
  */
 struct key_user {
 	struct rb_node		node;
-	struct list_head	consq;		/* construction queue */
+	struct mutex		cons_lock;	/* construction initiation lock */
 	spinlock_t		lock;
 	atomic_t		usage;		/* for accessing qnkeys & qnbytes */
 	atomic_t		nkeys;		/* number of keys */
@@ -62,7 +73,7 @@ extern void key_user_put(struct key_user *user);
 extern struct rb_root key_serial_tree;
 extern spinlock_t key_serial_lock;
 extern struct semaphore key_alloc_sem;
-extern struct rw_semaphore key_construction_sem;
+extern struct mutex key_construction_mutex;
 extern wait_queue_head_t request_key_conswq;
 
 
@@ -109,7 +120,7 @@ extern struct key *request_key_and_link(struct key_type *type,
 struct request_key_auth {
 	struct key		*target_key;
 	struct task_struct	*context;
-	const char		*callout_info;
+	char			*callout_info;
 	pid_t			pid;
 };
 

commit 4e54f08543d05e519e601368571cc3787fefae96
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 29 02:24:28 2006 -0700

    [PATCH] Keys: Allow in-kernel key requestor to pass auxiliary data to upcaller
    
    The proposed NFS key type uses its own method of passing key requests to
    userspace (upcalling) rather than invoking /sbin/request-key.  This is
    because the responsible userspace daemon should already be running and will
    be contacted through rpc_pipefs.
    
    This patch permits the NFS filesystem to pass auxiliary data to the upcall
    operation (struct key_type::request_key) so that the upcaller can use a
    pre-existing communications channel more easily.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-By: Kevin Coffman <kwc@citi.umich.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 3c2877f0663e..1bb416f4bbce 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -99,6 +99,7 @@ extern int install_process_keyring(struct task_struct *tsk);
 extern struct key *request_key_and_link(struct key_type *type,
 					const char *description,
 					const char *callout_info,
+					void *aux,
 					struct key *dest_keyring,
 					unsigned long flags);
 

commit 7e047ef5fe2d52e83020e856b1bf2556a6a2ce98
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jun 26 00:24:50 2006 -0700

    [PATCH] keys: sort out key quota system
    
    Add the ability for key creation to overrun the user's quota in some
    circumstances - notably when a session keyring is created and assigned to a
    process that didn't previously have one.
    
    This means it's still possible to log in, should PAM require the creation of a
    new session keyring, and fix an overburdened key quota.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index e066e6057955..3c2877f0663e 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -99,7 +99,8 @@ extern int install_process_keyring(struct task_struct *tsk);
 extern struct key *request_key_and_link(struct key_type *type,
 					const char *description,
 					const char *callout_info,
-					struct key *dest_keyring);
+					struct key *dest_keyring,
+					unsigned long flags);
 
 /*
  * request_key authorisation

commit b5f545c880a2a47947ba2118b2509644ab7a2969
Author: David Howells <dhowells@redhat.com>
Date:   Sun Jan 8 01:02:47 2006 -0800

    [PATCH] keys: Permit running process to instantiate keys
    
    Make it possible for a running process (such as gssapid) to be able to
    instantiate a key, as was requested by Trond Myklebust for NFS4.
    
    The patch makes the following changes:
    
     (1) A new, optional key type method has been added. This permits a key type
         to intercept requests at the point /sbin/request-key is about to be
         spawned and do something else with them - passing them over the
         rpc_pipefs files or netlink sockets for instance.
    
         The uninstantiated key, the authorisation key and the intended operation
         name are passed to the method.
    
     (2) The callout_info is no longer passed as an argument to /sbin/request-key
         to prevent unauthorised viewing of this data using ps or by looking in
         /proc/pid/cmdline.
    
         This means that the old /sbin/request-key program will not work with the
         patched kernel as it will expect to see an extra argument that is no
         longer there.
    
         A revised keyutils package will be made available tomorrow.
    
     (3) The callout_info is now attached to the authorisation key. Reading this
         key will retrieve the information.
    
     (4) A new field has been added to the task_struct. This holds the
         authorisation key currently active for a thread. Searches now look here
         for the caller's set of keys rather than looking for an auth key in the
         lowest level of the session keyring.
    
         This permits a thread to be servicing multiple requests at once and to
         switch between them. Note that this is per-thread, not per-process, and
         so is usable in multithreaded programs.
    
         The setting of this field is inherited across fork and exec.
    
     (5) A new keyctl function (KEYCTL_ASSUME_AUTHORITY) has been added that
         permits a thread to assume the authority to deal with an uninstantiated
         key. Assumption is only permitted if the authorisation key associated
         with the uninstantiated key is somewhere in the thread's keyrings.
    
         This function can also clear the assumption.
    
     (6) A new magic key specifier has been added to refer to the currently
         assumed authorisation key (KEY_SPEC_REQKEY_AUTH_KEY).
    
     (7) Instantiation will only proceed if the appropriate authorisation key is
         assumed first. The assumed authorisation key is discarded if
         instantiation is successful.
    
     (8) key_validate() is moved from the file of request_key functions to the
         file of permissions functions.
    
     (9) The documentation is updated.
    
    From: <Valdis.Kletnieks@vt.edu>
    
        Build fix.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Alexander Zangerl <az@bond.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 51f37c0bdb32..e066e6057955 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -107,12 +107,13 @@ extern struct key *request_key_and_link(struct key_type *type,
 struct request_key_auth {
 	struct key		*target_key;
 	struct task_struct	*context;
+	const char		*callout_info;
 	pid_t			pid;
 };
 
 extern struct key_type key_type_request_key_auth;
 extern struct key *request_key_auth_new(struct key *target,
-					struct key **_rkakey);
+					const char *callout_info);
 
 extern struct key *key_get_instantiation_authkey(key_serial_t target_id);
 
@@ -137,6 +138,7 @@ extern long keyctl_instantiate_key(key_serial_t, const void __user *,
 extern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);
 extern long keyctl_set_reqkey_keyring(int);
 extern long keyctl_set_timeout(key_serial_t, unsigned);
+extern long keyctl_assume_authority(key_serial_t);
 
 
 /*

commit 017679c4d45783158dba1dd6f79e712c22bb3d9a
Author: David Howells <dhowells@redhat.com>
Date:   Sun Jan 8 01:02:43 2006 -0800

    [PATCH] keys: Permit key expiry time to be set
    
    Add a new keyctl function that allows the expiry time to be set on a key or
    removed from a key, provided the caller has attribute modification access.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Alexander Zangerl <az@bond.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 39cba97c5eb9..51f37c0bdb32 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -136,6 +136,7 @@ extern long keyctl_instantiate_key(key_serial_t, const void __user *,
 				   size_t, key_serial_t);
 extern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);
 extern long keyctl_set_reqkey_keyring(int);
+extern long keyctl_set_timeout(key_serial_t, unsigned);
 
 
 /*

commit 1ae8f40767a3afc6244719a2c8fbcf546767d5b0
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Jan 6 00:11:25 2006 -0800

    [PATCH] security/: possible cleanups
    
    make needlessly global code static
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index db99ed434f3a..39cba97c5eb9 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -25,7 +25,6 @@
 #define kdebug(FMT, a...)	do {} while(0)
 #endif
 
-extern struct key_type key_type_dead;
 extern struct key_type key_type_user;
 
 /*****************************************************************************/

commit 664cceb0093b755739e56572b836a99104ee8a75
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 28 17:03:15 2005 +0100

    [PATCH] Keys: Add possessor permissions to keys [try #3]
    
    The attached patch adds extra permission grants to keys for the possessor of a
    key in addition to the owner, group and other permissions bits. This makes
    SUID binaries easier to support without going as far as labelling keys and key
    targets using the LSM facilities.
    
    This patch adds a second "pointer type" to key structures (struct key_ref *)
    that can have the bottom bit of the address set to indicate the possession of
    a key. This is propagated through searches from the keyring to the discovered
    key. It has been made a separate type so that the compiler can spot attempts
    to dereference a potentially incorrect pointer.
    
    The "possession" attribute can't be attached to a key structure directly as
    it's not an intrinsic property of a key.
    
    Pointers to keys have been replaced with struct key_ref *'s wherever
    possession information needs to be passed through.
    
    This does assume that the bottom bit of the pointer will always be zero on
    return from kmem_cache_alloc().
    
    The key reference type has been made into a typedef so that at least it can be
    located in the sources, even though it's basically a pointer to an undefined
    type. I've also renamed the accessor functions to be more useful, and all
    reference variables should now end in "_ref".
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 46c8602661c9..db99ed434f3a 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -71,26 +71,26 @@ extern void keyring_publish_name(struct key *keyring);
 
 extern int __key_link(struct key *keyring, struct key *key);
 
-extern struct key *__keyring_search_one(struct key *keyring,
-					const struct key_type *type,
-					const char *description,
-					key_perm_t perm);
+extern key_ref_t __keyring_search_one(key_ref_t keyring_ref,
+				      const struct key_type *type,
+				      const char *description,
+				      key_perm_t perm);
 
 extern struct key *keyring_search_instkey(struct key *keyring,
 					  key_serial_t target_id);
 
 typedef int (*key_match_func_t)(const struct key *, const void *);
 
-extern struct key *keyring_search_aux(struct key *keyring,
-				      struct task_struct *tsk,
-				      struct key_type *type,
-				      const void *description,
-				      key_match_func_t match);
+extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
+				    struct task_struct *tsk,
+				    struct key_type *type,
+				    const void *description,
+				    key_match_func_t match);
 
-extern struct key *search_process_keyrings(struct key_type *type,
-					   const void *description,
-					   key_match_func_t match,
-					   struct task_struct *tsk);
+extern key_ref_t search_process_keyrings(struct key_type *type,
+					 const void *description,
+					 key_match_func_t match,
+					 struct task_struct *tsk);
 
 extern struct key *find_keyring_by_name(const char *name, key_serial_t bound);
 

commit 3e30148c3d524a9c1c63ca28261bc24c457eb07a
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 23 22:00:56 2005 -0700

    [PATCH] Keys: Make request-key create an authorisation key
    
    The attached patch makes the following changes:
    
     (1) There's a new special key type called ".request_key_auth".
    
         This is an authorisation key for when one process requests a key and
         another process is started to construct it. This type of key cannot be
         created by the user; nor can it be requested by kernel services.
    
         Authorisation keys hold two references:
    
         (a) Each refers to a key being constructed. When the key being
             constructed is instantiated the authorisation key is revoked,
             rendering it of no further use.
    
         (b) The "authorising process". This is either:
    
             (i) the process that called request_key(), or:
    
             (ii) if the process that called request_key() itself had an
                  authorisation key in its session keyring, then the authorising
                  process referred to by that authorisation key will also be
                  referred to by the new authorisation key.
    
             This means that the process that initiated a chain of key requests
             will authorise the lot of them, and will, by default, wind up with
             the keys obtained from them in its keyrings.
    
     (2) request_key() creates an authorisation key which is then passed to
         /sbin/request-key in as part of a new session keyring.
    
     (3) When request_key() is searching for a key to hand back to the caller, if
         it comes across an authorisation key in the session keyring of the
         calling process, it will also search the keyrings of the process
         specified therein and it will use the specified process's credentials
         (fsuid, fsgid, groups) to do that rather than the calling process's
         credentials.
    
         This allows a process started by /sbin/request-key to find keys belonging
         to the authorising process.
    
     (4) A key can be read, even if the process executing KEYCTL_READ doesn't have
         direct read or search permission if that key is contained within the
         keyrings of a process specified by an authorisation key found within the
         calling process's session keyring, and is searchable using the
         credentials of the authorising process.
    
         This allows a process started by /sbin/request-key to read keys belonging
         to the authorising process.
    
     (5) The magic KEY_SPEC_*_KEYRING key IDs when passed to KEYCTL_INSTANTIATE or
         KEYCTL_NEGATE will specify a keyring of the authorising process, rather
         than the process doing the instantiation.
    
     (6) One of the process keyrings can be nominated as the default to which
         request_key() should attach new keys if not otherwise specified. This is
         done with KEYCTL_SET_REQKEY_KEYRING and one of the KEY_REQKEY_DEFL_*
         constants. The current setting can also be read using this call.
    
     (7) request_key() is partially interruptible. If it is waiting for another
         process to finish constructing a key, it can be interrupted. This permits
         a request-key cycle to be broken without recourse to rebooting.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-Off-By: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/security/keys/internal.h b/security/keys/internal.h
index 67b2b93a7489..46c8602661c9 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -1,6 +1,6 @@
 /* internal.h: authentication token and access key management internal defs
  *
- * Copyright (C) 2003 Red Hat, Inc. All Rights Reserved.
+ * Copyright (C) 2003-5 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
  *
  * This program is free software; you can redistribute it and/or
@@ -15,6 +15,16 @@
 #include <linux/key.h>
 #include <linux/key-ui.h>
 
+#if 0
+#define kenter(FMT, a...)	printk("==> %s("FMT")\n",__FUNCTION__ , ## a)
+#define kleave(FMT, a...)	printk("<== %s()"FMT"\n",__FUNCTION__ , ## a)
+#define kdebug(FMT, a...)	printk(FMT"\n" , ## a)
+#else
+#define kenter(FMT, a...)	do {} while(0)
+#define kleave(FMT, a...)	do {} while(0)
+#define kdebug(FMT, a...)	do {} while(0)
+#endif
+
 extern struct key_type key_type_dead;
 extern struct key_type key_type_user;
 
@@ -66,20 +76,46 @@ extern struct key *__keyring_search_one(struct key *keyring,
 					const char *description,
 					key_perm_t perm);
 
+extern struct key *keyring_search_instkey(struct key *keyring,
+					  key_serial_t target_id);
+
 typedef int (*key_match_func_t)(const struct key *, const void *);
 
 extern struct key *keyring_search_aux(struct key *keyring,
+				      struct task_struct *tsk,
 				      struct key_type *type,
 				      const void *description,
 				      key_match_func_t match);
 
-extern struct key *search_process_keyrings_aux(struct key_type *type,
-					       const void *description,
-					       key_match_func_t match);
+extern struct key *search_process_keyrings(struct key_type *type,
+					   const void *description,
+					   key_match_func_t match,
+					   struct task_struct *tsk);
 
 extern struct key *find_keyring_by_name(const char *name, key_serial_t bound);
 
 extern int install_thread_keyring(struct task_struct *tsk);
+extern int install_process_keyring(struct task_struct *tsk);
+
+extern struct key *request_key_and_link(struct key_type *type,
+					const char *description,
+					const char *callout_info,
+					struct key *dest_keyring);
+
+/*
+ * request_key authorisation
+ */
+struct request_key_auth {
+	struct key		*target_key;
+	struct task_struct	*context;
+	pid_t			pid;
+};
+
+extern struct key_type key_type_request_key_auth;
+extern struct key *request_key_auth_new(struct key *target,
+					struct key **_rkakey);
+
+extern struct key *key_get_instantiation_authkey(key_serial_t target_id);
 
 /*
  * keyctl functions
@@ -100,6 +136,7 @@ extern long keyctl_setperm_key(key_serial_t, key_perm_t);
 extern long keyctl_instantiate_key(key_serial_t, const void __user *,
 				   size_t, key_serial_t);
 extern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);
+extern long keyctl_set_reqkey_keyring(int);
 
 
 /*

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/security/keys/internal.h b/security/keys/internal.h
new file mode 100644
index 000000000000..67b2b93a7489
--- /dev/null
+++ b/security/keys/internal.h
@@ -0,0 +1,123 @@
+/* internal.h: authentication token and access key management internal defs
+ *
+ * Copyright (C) 2003 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _INTERNAL_H
+#define _INTERNAL_H
+
+#include <linux/key.h>
+#include <linux/key-ui.h>
+
+extern struct key_type key_type_dead;
+extern struct key_type key_type_user;
+
+/*****************************************************************************/
+/*
+ * keep track of keys for a user
+ * - this needs to be separate to user_struct to avoid a refcount-loop
+ *   (user_struct pins some keyrings which pin this struct)
+ * - this also keeps track of keys under request from userspace for this UID
+ */
+struct key_user {
+	struct rb_node		node;
+	struct list_head	consq;		/* construction queue */
+	spinlock_t		lock;
+	atomic_t		usage;		/* for accessing qnkeys & qnbytes */
+	atomic_t		nkeys;		/* number of keys */
+	atomic_t		nikeys;		/* number of instantiated keys */
+	uid_t			uid;
+	int			qnkeys;		/* number of keys allocated to this user */
+	int			qnbytes;	/* number of bytes allocated to this user */
+};
+
+#define KEYQUOTA_MAX_KEYS	100
+#define KEYQUOTA_MAX_BYTES	10000
+#define KEYQUOTA_LINK_BYTES	4		/* a link in a keyring is worth 4 bytes */
+
+extern struct rb_root	key_user_tree;
+extern spinlock_t	key_user_lock;
+extern struct key_user	root_key_user;
+
+extern struct key_user *key_user_lookup(uid_t uid);
+extern void key_user_put(struct key_user *user);
+
+
+
+extern struct rb_root key_serial_tree;
+extern spinlock_t key_serial_lock;
+extern struct semaphore key_alloc_sem;
+extern struct rw_semaphore key_construction_sem;
+extern wait_queue_head_t request_key_conswq;
+
+
+extern void keyring_publish_name(struct key *keyring);
+
+extern int __key_link(struct key *keyring, struct key *key);
+
+extern struct key *__keyring_search_one(struct key *keyring,
+					const struct key_type *type,
+					const char *description,
+					key_perm_t perm);
+
+typedef int (*key_match_func_t)(const struct key *, const void *);
+
+extern struct key *keyring_search_aux(struct key *keyring,
+				      struct key_type *type,
+				      const void *description,
+				      key_match_func_t match);
+
+extern struct key *search_process_keyrings_aux(struct key_type *type,
+					       const void *description,
+					       key_match_func_t match);
+
+extern struct key *find_keyring_by_name(const char *name, key_serial_t bound);
+
+extern int install_thread_keyring(struct task_struct *tsk);
+
+/*
+ * keyctl functions
+ */
+extern long keyctl_get_keyring_ID(key_serial_t, int);
+extern long keyctl_join_session_keyring(const char __user *);
+extern long keyctl_update_key(key_serial_t, const void __user *, size_t);
+extern long keyctl_revoke_key(key_serial_t);
+extern long keyctl_keyring_clear(key_serial_t);
+extern long keyctl_keyring_link(key_serial_t, key_serial_t);
+extern long keyctl_keyring_unlink(key_serial_t, key_serial_t);
+extern long keyctl_describe_key(key_serial_t, char __user *, size_t);
+extern long keyctl_keyring_search(key_serial_t, const char __user *,
+				  const char __user *, key_serial_t);
+extern long keyctl_read_key(key_serial_t, char __user *, size_t);
+extern long keyctl_chown_key(key_serial_t, uid_t, gid_t);
+extern long keyctl_setperm_key(key_serial_t, key_perm_t);
+extern long keyctl_instantiate_key(key_serial_t, const void __user *,
+				   size_t, key_serial_t);
+extern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);
+
+
+/*
+ * debugging key validation
+ */
+#ifdef KEY_DEBUGGING
+extern void __key_check(const struct key *);
+
+static inline void key_check(const struct key *key)
+{
+	if (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))
+		__key_check(key);
+}
+
+#else
+
+#define key_check(key) do {} while(0)
+
+#endif
+
+#endif /* _INTERNAL_H */
