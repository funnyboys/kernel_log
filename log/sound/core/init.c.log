commit d4cfb30fce03093ad944e0b44bd8f40bdad5330e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 20 13:44:22 2020 +0100

    ALSA: pcm: Set per-card upper limit of PCM buffer allocations
    
    Currently, the available buffer allocation size for a PCM stream
    depends on the preallocated size; when a buffer has been preallocated,
    the max buffer size is set to that size, so that application won't
    re-allocate too much memory.  OTOH, when no preallocation is done,
    each substream may allocate arbitrary size of buffers as long as
    snd_pcm_hardware.buffer_bytes_max allows -- which can be quite high,
    HD-audio sets 1GB there.
    
    It means that the system may consume a high amount of pages for PCM
    buffers, and they are pinned and never swapped out.  This can lead to
    OOM easily.
    
    For avoiding such a situation, this patch adds the upper limit per
    card.  Each snd_pcm_lib_malloc_pages() and _free_pages() calls are
    tracked and it will return an error if the total amount of buffers
    goes over the defined upper limit.  The default value is set to 32MB,
    which should be really large enough for usual operations.
    
    If larger buffers are needed for any specific usage, it can be
    adjusted (also dynamically) via snd_pcm.max_alloc_per_card option.
    Setting zero there means no chceck is performed, and again, unlimited
    amount of buffers are allowed.
    
    Link: https://lore.kernel.org/r/20200120124423.11862-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index faa9f03c01ca..b02a99766351 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -211,6 +211,7 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	INIT_LIST_HEAD(&card->ctl_files);
 	spin_lock_init(&card->files_lock);
 	INIT_LIST_HEAD(&card->files_list);
+	mutex_init(&card->memory_mutex);
 #ifdef CONFIG_PM
 	init_waitqueue_head(&card->power_sleep);
 #endif

commit fabb26dcd104027b971c018275fe40f2ebe09ae3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Nov 17 09:53:07 2019 +0100

    ALSA: pcm: Add card sync_irq field
    
    Many PCI and other drivers performs snd_pcm_period_elapsed() simply in
    its interrupt handler, so the sync_stop operation is just to call
    synchronize_irq().  Instead of putting this call multiple times,
    introduce the common card->sync_irq field.  When this field is set,
    PCM core performs synchronize_irq() for sync-stop operation.  Each
    driver just needs to copy its local IRQ number to card->sync_irq, and
    that's all we need.
    
    Link: https://lore.kernel.org/r/20191117085308.23915-8-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index db99b7fad6ad..faa9f03c01ca 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -215,6 +215,7 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	init_waitqueue_head(&card->power_sleep);
 #endif
 	init_waitqueue_head(&card->remove_sleep);
+	card->sync_irq = -1;
 
 	device_initialize(&card->card_dev);
 	card->card_dev.parent = parent;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/init.c b/sound/core/init.c
index d64416f0a281..db99b7fad6ad 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Initialization routines
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/init.h>

commit 17b89c80319c2a66d33142112e06bf15893e6ecb
Merge: 78ff2afc2625 3887c26c0e24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 6 15:07:50 2019 +0200

    Merge branch 'for-linus' into for-next
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit f4fa968950aef7efb98a0899bb0132405e2edaf1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 16 18:18:47 2019 +0200

    ALSA: core: Don't refer to snd_cards array directly
    
    The snd_cards[] array holds the card pointers that have been currently
    registered, and it's exported for the external modules that may need
    to refer a card object.  But accessing to this array can be racy
    against the driver probe or removal, as the card registration or free
    may happen concurrently.
    
    This patch gets rid of the direct access to snd_cards[] array and
    provides a helper function to give the card object from the index
    number with a refcount management.  Then the caller can access to the
    given card object safely, and releases it via snd_card_unref().
    
    While we're at it, add a proper comment to snd_card_unref() and make
    it an inlined function for type-safety, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 0c4dc40376a7..356d41e4f3a4 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -49,8 +49,7 @@ static const struct file_operations snd_shutdown_f_ops;
 
 /* locked for registering/using */
 static DECLARE_BITMAP(snd_cards_lock, SNDRV_CARDS);
-struct snd_card *snd_cards[SNDRV_CARDS];
-EXPORT_SYMBOL(snd_cards);
+static struct snd_card *snd_cards[SNDRV_CARDS];
 
 static DEFINE_MUTEX(snd_card_mutex);
 
@@ -268,6 +267,26 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 }
 EXPORT_SYMBOL(snd_card_new);
 
+/**
+ * snd_card_ref - Get the card object from the index
+ * @idx: the card index
+ *
+ * Returns a card object corresponding to the given index or NULL if not found.
+ * Release the object via snd_card_unref().
+ */
+struct snd_card *snd_card_ref(int idx)
+{
+	struct snd_card *card;
+
+	mutex_lock(&snd_card_mutex);
+	card = snd_cards[idx];
+	if (card)
+		get_device(&card->card_dev);
+	mutex_unlock(&snd_card_mutex);
+	return card;
+}
+EXPORT_SYMBOL_GPL(snd_card_ref);
+
 /* return non-zero if a card is already locked */
 int snd_card_locked(int card)
 {

commit 2a3f7221acddfe1caa9ff09b3a8158c39b2fdeac
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 16 17:06:33 2019 +0200

    ALSA: core: Fix card races between register and disconnect
    
    There is a small race window in the card disconnection code that
    allows the registration of another card with the very same card id.
    This leads to a warning in procfs creation as caught by syzkaller.
    
    The problem is that we delete snd_cards and snd_cards_lock entries at
    the very beginning of the disconnection procedure.  This makes the
    slot available to be assigned for another card object while the
    disconnection procedure is being processed.  Then it becomes possible
    to issue a procfs registration with the existing file name although we
    check the conflict beforehand.
    
    The fix is simply to move the snd_cards and snd_cards_lock clearances
    at the end of the disconnection procedure.  The references to these
    entries are merely either from the global proc files like
    /proc/asound/cards or from the card registration / disconnection, so
    it should be fine to shift at the very end.
    
    Reported-by: syzbot+48df349490c36f9f54ab@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 0c4dc40376a7..079c12d64b0e 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -382,14 +382,7 @@ int snd_card_disconnect(struct snd_card *card)
 	card->shutdown = 1;
 	spin_unlock(&card->files_lock);
 
-	/* phase 1: disable fops (user space) operations for ALSA API */
-	mutex_lock(&snd_card_mutex);
-	snd_cards[card->number] = NULL;
-	clear_bit(card->number, snd_cards_lock);
-	mutex_unlock(&snd_card_mutex);
-	
-	/* phase 2: replace file->f_op with special dummy operations */
-	
+	/* replace file->f_op with special dummy operations */
 	spin_lock(&card->files_lock);
 	list_for_each_entry(mfile, &card->files_list, list) {
 		/* it's critical part, use endless loop */
@@ -405,7 +398,7 @@ int snd_card_disconnect(struct snd_card *card)
 	}
 	spin_unlock(&card->files_lock);	
 
-	/* phase 3: notify all connected devices about disconnection */
+	/* notify all connected devices about disconnection */
 	/* at this point, they cannot respond to any calls except release() */
 
 #if IS_ENABLED(CONFIG_SND_MIXER_OSS)
@@ -421,6 +414,13 @@ int snd_card_disconnect(struct snd_card *card)
 		device_del(&card->card_dev);
 		card->registered = false;
 	}
+
+	/* disable fops (user space) operations for ALSA API */
+	mutex_lock(&snd_card_mutex);
+	snd_cards[card->number] = NULL;
+	clear_bit(card->number, snd_cards_lock);
+	mutex_unlock(&snd_card_mutex);
+
 #ifdef CONFIG_PM
 	wake_up(&card->power_sleep);
 #endif

commit 29b2625ff605394ecd0b078e0cb67a151bb4d80c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 5 16:26:06 2019 +0100

    ALSA: info: Move card id proc creation into info.c
    
    The creation of card's id proc file can be moved gracefully into
    info.c.  Also, the assignment of card->proc_id is superfluous and can
    be dropped.  So let's do it.
    
    Basically this is no functional change but code refactoring, but one
    potential behavior change is that now it returns properly the error
    code from snd_info_card_register(), which is a good thing (tm).
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 5252a9ce13dc..0c4dc40376a7 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -100,33 +100,6 @@ int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);
 EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
 #endif
 
-#ifdef CONFIG_SND_PROC_FS
-static void snd_card_id_read(struct snd_info_entry *entry,
-			     struct snd_info_buffer *buffer)
-{
-	struct snd_card *card = entry->private_data;
-
-	snd_iprintf(buffer, "%s\n", card->id);
-}
-
-static int init_info_for_card(struct snd_card *card)
-{
-	struct snd_info_entry *entry;
-
-	entry = snd_info_create_card_entry(card, "id", card->proc_root);
-	if (!entry) {
-		dev_dbg(card->dev, "unable to create card entry\n");
-		return -ENOMEM;
-	}
-	snd_info_set_text_ops(entry, card, snd_card_id_read);
-	card->proc_id = entry;
-
-	return snd_info_card_register(card);
-}
-#else /* !CONFIG_SND_PROC_FS */
-#define init_info_for_card(card)
-#endif
-
 static int check_empty_slot(struct module *module, int slot)
 {
 	return !slots[slot] || !*slots[slot];
@@ -493,7 +466,6 @@ static int snd_card_do_free(struct snd_card *card)
 	snd_device_free_all(card);
 	if (card->private_free)
 		card->private_free(card);
-	snd_info_free_entry(card->proc_id);
 	if (snd_info_card_free(card) < 0) {
 		dev_warn(card->dev, "unable to free card info\n");
 		/* Not fatal error */
@@ -797,7 +769,10 @@ int snd_card_register(struct snd_card *card)
 	}
 	snd_cards[card->number] = card;
 	mutex_unlock(&snd_card_mutex);
-	init_info_for_card(card);
+	err = snd_info_card_register(card);
+	if (err < 0)
+		return err;
+
 #if IS_ENABLED(CONFIG_SND_MIXER_OSS)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);

commit 9725752867cb158e076bcb6bc4bdb35d9710b1bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 5 16:10:00 2019 +0100

    ALSA: info: Drop unused snd_info_entry.card field
    
    It's referred only in snd_card_id_read() which can receive the card
    object via private_data.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 4849c611c0fe..5252a9ce13dc 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -104,7 +104,9 @@ EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
 static void snd_card_id_read(struct snd_info_entry *entry,
 			     struct snd_info_buffer *buffer)
 {
-	snd_iprintf(buffer, "%s\n", entry->card->id);
+	struct snd_card *card = entry->private_data;
+
+	snd_iprintf(buffer, "%s\n", card->id);
 }
 
 static int init_info_for_card(struct snd_card *card)
@@ -116,7 +118,7 @@ static int init_info_for_card(struct snd_card *card)
 		dev_dbg(card->dev, "unable to create card entry\n");
 		return -ENOMEM;
 	}
-	entry->c.text.read = snd_card_id_read;
+	snd_info_set_text_ops(entry, card, snd_card_id_read);
 	card->proc_id = entry;
 
 	return snd_info_card_register(card);

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 79b4df1c1dc7..4849c611c0fe 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -703,7 +703,7 @@ card_id_store_attr(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-static DEVICE_ATTR(id, S_IRUGO | S_IWUSR, card_id_show_attr, card_id_store_attr);
+static DEVICE_ATTR(id, 0644, card_id_show_attr, card_id_store_attr);
 
 static ssize_t
 card_number_show_attr(struct device *dev,
@@ -713,7 +713,7 @@ card_number_show_attr(struct device *dev,
 	return scnprintf(buf, PAGE_SIZE, "%i\n", card->number);
 }
 
-static DEVICE_ATTR(number, S_IRUGO, card_number_show_attr, NULL);
+static DEVICE_ATTR(number, 0444, card_number_show_attr, NULL);
 
 static struct attribute *card_dev_attrs[] = {
 	&dev_attr_id.attr,

commit ef21e1750158558d8369067e94d02d285011c37e
Author: Jaejoong Kim <climbbb.kim@gmail.com>
Date:   Tue Feb 27 11:15:59 2018 +0900

    ALSA: Use scnprintf() instead of snprintf() for show
    
    The show() method should use scnprintf() not snprintf() because snprintf()
    may returns a value that exceeds its second argument.
    
    Signed-off-by: Jaejoong Kim <climbbb.kim@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 4fa5dd955740..79b4df1c1dc7 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -670,7 +670,7 @@ card_id_show_attr(struct device *dev,
 		  struct device_attribute *attr, char *buf)
 {
 	struct snd_card *card = container_of(dev, struct snd_card, card_dev);
-	return snprintf(buf, PAGE_SIZE, "%s\n", card->id);
+	return scnprintf(buf, PAGE_SIZE, "%s\n", card->id);
 }
 
 static ssize_t
@@ -710,7 +710,7 @@ card_number_show_attr(struct device *dev,
 		     struct device_attribute *attr, char *buf)
 {
 	struct snd_card *card = container_of(dev, struct snd_card, card_dev);
-	return snprintf(buf, PAGE_SIZE, "%i\n", card->number);
+	return scnprintf(buf, PAGE_SIZE, "%i\n", card->number);
 }
 
 static DEVICE_ATTR(number, S_IRUGO, card_number_show_attr, NULL);

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/init.c b/sound/core/init.c
index 8753440c3a6e..4fa5dd955740 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -346,7 +346,7 @@ static int snd_disconnect_release(struct inode *inode, struct file *file)
 
 static __poll_t snd_disconnect_poll(struct file * file, poll_table * wait)
 {
-	return POLLERR | POLLNVAL;
+	return EPOLLERR | EPOLLNVAL;
 }
 
 static long snd_disconnect_ioctl(struct file *file,

commit 680ef72abd84cbe0b722453d6be4e412305c9060
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 2 23:27:36 2017 -0400

    sound: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/init.c b/sound/core/init.c
index 168ae03d3a1c..8753440c3a6e 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -344,7 +344,7 @@ static int snd_disconnect_release(struct inode *inode, struct file *file)
 	panic("%s(%p, %p) failed!", __func__, inode, file);
 }
 
-static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)
+static __poll_t snd_disconnect_poll(struct file * file, poll_table * wait)
 {
 	return POLLERR | POLLNVAL;
 }

commit c44027c89e19adafccd404bbe6f9686722ff4217
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 06:36:13 2017 +0000

    ALSA: add snd_card_disconnect_sync()
    
    In case of user unbind ALSA driver during playing back / capturing,
    each driver needs to stop and remove it correctly. One note here is
    that we can't cancel from remove function in such case, because
    unbind operation doesn't check return value from remove function.
    So, we *must* stop and remove in this case.
    
    For this purpose, we need to sync (= wait) until the all top-level
    operations are canceled at remove function.
    For example, snd_card_free() processes the disconnection procedure at
    first, then waits for the completion. That's how the hot-unplug works
    safely. It's implemented, at least, in the top-level driver removal.
    
    Now for the lower level driver, we need a similar strategy. Notify to
    the toplevel for hot-unplug (disconnect in ALSA), and sync with the
    stop operation, then continue the rest of its own remove procedure.
    
    This patch adds snd_card_disconnect_sync(), and driver can use it from
    remove function.
    
    Note: the "lower level" driver here refers to a middle layer driver
    (e.g. ASoC components) that can be unbound freely during operation.
    Most of legacy ALSA helper drivers don't have such a problem because
    they can't be unbound.
    
    Note#2: snd_card_disconnect_sync() merely calls snd_card_disconnect()
    and syncs with closing all pending files.  It takes only the files
    opened by user-space into account, and doesn't care about object
    refcounts.  (The latter is handled by snd_card_free() completion call,
    BTW.)  Also, the function doesn't free resources by itself.
    
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 32ebe2f6bc59..168ae03d3a1c 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -255,6 +255,7 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 #ifdef CONFIG_PM
 	init_waitqueue_head(&card->power_sleep);
 #endif
+	init_waitqueue_head(&card->remove_sleep);
 
 	device_initialize(&card->card_dev);
 	card->card_dev.parent = parent;
@@ -452,6 +453,35 @@ int snd_card_disconnect(struct snd_card *card)
 }
 EXPORT_SYMBOL(snd_card_disconnect);
 
+/**
+ * snd_card_disconnect_sync - disconnect card and wait until files get closed
+ * @card: card object to disconnect
+ *
+ * This calls snd_card_disconnect() for disconnecting all belonging components
+ * and waits until all pending files get closed.
+ * It assures that all accesses from user-space finished so that the driver
+ * can release its resources gracefully.
+ */
+void snd_card_disconnect_sync(struct snd_card *card)
+{
+	int err;
+
+	err = snd_card_disconnect(card);
+	if (err < 0) {
+		dev_err(card->dev,
+			"snd_card_disconnect error (%d), skipping sync\n",
+			err);
+		return;
+	}
+
+	spin_lock_irq(&card->files_lock);
+	wait_event_lock_irq(card->remove_sleep,
+			    list_empty(&card->files_list),
+			    card->files_lock);
+	spin_unlock_irq(&card->files_lock);
+}
+EXPORT_SYMBOL_GPL(snd_card_disconnect_sync);
+
 static int snd_card_do_free(struct snd_card *card)
 {
 #if IS_ENABLED(CONFIG_SND_MIXER_OSS)
@@ -957,6 +987,8 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 			break;
 		}
 	}
+	if (list_empty(&card->files_list))
+		wake_up_all(&card->remove_sleep);
 	spin_unlock(&card->files_lock);
 	if (!found) {
 		dev_err(card->dev, "card file remove problem (%p)\n", file);

commit 7d8e8292013ab72ae1f1500cbc91f198ccb1826d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 30 16:13:25 2017 +0200

    ALSA: Get rid of card power_lock
    
    Currently we're taking power_lock at each card component for assuring
    the power-up sequence, but it doesn't help anything in the
    implementation at the moment: it just serializes unnecessarily the
    callers, but it doesn't protect about the power state change itself.
    It used to have some usefulness in the early days where we managed the
    PM manually.  But now the suspend/resume core procedure is beyond our
    hands, and power_lock lost its meaning.
    
    This patch drops the power_lock from allover the places.
    There shouldn't be any issues by this change, as it's no helper
    regarding the power state change.  Rather we'll get better performance
    by removing the serialization; which is the only slight concern of any
    behavior change, but it can't be a showstopper, after all.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 6e219dc23f96..32ebe2f6bc59 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -253,7 +253,6 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	spin_lock_init(&card->files_lock);
 	INIT_LIST_HEAD(&card->files_list);
 #ifdef CONFIG_PM
-	mutex_init(&card->power_lock);
 	init_waitqueue_head(&card->power_sleep);
 #endif
 
@@ -978,8 +977,6 @@ EXPORT_SYMBOL(snd_card_file_remove);
  *  Waits until the power-state is changed.
  *
  *  Return: Zero if successful, or a negative error code.
- *
- *  Note: the power lock must be active before call.
  */
 int snd_power_wait(struct snd_card *card, unsigned int power_state)
 {
@@ -999,9 +996,7 @@ int snd_power_wait(struct snd_card *card, unsigned int power_state)
 		if (snd_power_get_state(card) == power_state)
 			break;
 		set_current_state(TASK_UNINTERRUPTIBLE);
-		snd_power_unlock(card);
 		schedule_timeout(30 * HZ);
-		snd_power_lock(card);
 	}
 	remove_wait_queue(&card->power_sleep, &wait);
 	return result;

commit 30d8340b5857550007ab6fe9744e4384dfa6e55c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Aug 3 20:20:42 2017 +0900

    ALSA: control: obsolete user_ctl_lock
    
    At a previous commit, concurrent requests for TLV data are maintained
    exclusively between read requests and write/command requests. TLV
    callback handlers in each driver has no risk from concurrent access for
    reference/change.
    
    In current implementation, 'struct snd_card' has a mutex to control
    concurrent accesses to user-defined element sets. This commit obsoletes it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index b4365bcf28a7..6e219dc23f96 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -248,7 +248,6 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	INIT_LIST_HEAD(&card->devices);
 	init_rwsem(&card->controls_rwsem);
 	rwlock_init(&card->ctl_files_rwlock);
-	mutex_init(&card->user_ctl_lock);
 	INIT_LIST_HEAD(&card->controls);
 	INIT_LIST_HEAD(&card->ctl_files);
 	spin_lock_init(&card->files_lock);

commit 920f2ecdf6c3b3526f60fbd38c68597953cad3ee
Merge: 9ced560b8260 fc18282cdcba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 6 10:56:51 2017 -0700

    Merge tag 'sound-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This development cycle resulted in a fair amount of changes in both
      core and driver sides. The most significant change in ALSA core is
      about PCM. Also the support of of-graph card and the new DAPM widget
      for DSP are noteworthy changes in ASoC core. And there're lots of
      small changes splat over the tree, as you can see in diffstat.
    
      Below are a few highlights:
    
      ALSA core:
       - Removal of set_fs() hackery from PCM core stuff, and the code
         reorganization / optimization thereafter
       - Improved support of PCM ack ops, and a new ABI for improved
         control/status mmap handling
       - Lots of constifications in various codes
    
      ASoC core:
       - The support of of-graph card, which may work as a better generic
         device for a replacement of simple-card
       - New widget types intended mainly for use with DSPs
    
      ASoC drivers:
       - New drivers for Allwinner V3s SoCs
       - Ensonic ES8316 codec support
       - More Intel SKL and KBL works
       - More device support for Intel SST Atom (mostly for cheap tablets
         and 2-in-1 devices)
       - Support for Rockchip PDM controllers
       - Support for STM32 I2S and S/PDIF controllers
       - Support for ZTE AUD96P22 codecs
    
      HD-audio:
       - Support of new Realtek codecs (ALC215/ALC285/ALC289), more quirks
         for HP and Dell machines
       - A few more fixes for i915 component binding"
    
    * tag 'sound-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (418 commits)
      ALSA: hda - Fix unbalance of i915 module refcount
      ASoC: Intel: Skylake: Remove driver debugfs exit
      ASoC: Intel: Skylake: explicitly add the headers sst-dsp.h
      ALSA: hda/realtek - Remove GPIO_MASK
      ALSA: hda/realtek - Fix typo of pincfg for Dell quirk
      ALSA: pcm: add a documentation for tracepoints
      ALSA: atmel: ac97c: fix error return code in atmel_ac97c_probe()
      ALSA: x86: fix error return code in hdmi_lpe_audio_probe()
      ASoC: Intel: Skylake: Add support to read firmware registers
      ASoC: Intel: Skylake: Add sram address to sst_addr structure
      ASoC: Intel: Skylake: Debugfs facility to dump module config
      ASoC: Intel: Skylake: Add debugfs support
      ASoC: fix semicolon.cocci warnings
      ASoC: rt5645: Add quirk override by module option
      ASoC: rsnd: make arrays path and cmd_case static const
      ASoC: audio-graph-card: add widgets and routing for external amplifier support
      ASoC: audio-graph-card: update bindings for amplifier support
      ASoC: rt5665: calibration should be done before jack detection
      ASoC: rsnd: constify dev_pm_ops structures.
      ASoC: nau8825: change crosstalk-bypass property to bool type
      ...

commit ac6424b981bce1c4bc55675c6ce11bfe1bbfa64f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:06:13 2017 +0200

    sched/wait: Rename wait_queue_t => wait_queue_entry_t
    
    Rename:
    
            wait_queue_t            =>      wait_queue_entry_t
    
    'wait_queue_t' was always a slight misnomer: its name implies that it's a "queue",
    but in reality it's a queue *entry*. The 'real' queue is the wait queue head,
    which had to carry the name.
    
    Start sorting this out by renaming it to 'wait_queue_entry_t'.
    
    This also allows the real structure name 'struct __wait_queue' to
    lose its double underscore and become 'struct wait_queue_entry',
    which is the more canonical nomenclature for such data types.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/core/init.c b/sound/core/init.c
index 6bda8436d765..d61d2b3cd521 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -989,7 +989,7 @@ EXPORT_SYMBOL(snd_card_file_remove);
  */
 int snd_power_wait(struct snd_card *card, unsigned int power_state)
 {
-	wait_queue_t wait;
+	wait_queue_entry_t wait;
 	int result = 0;
 
 	/* fastpath */

commit 35f8001415d301ba47124f463f98eee0e7d0792c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 16 16:16:33 2017 +0200

    ALSA: core: Follow standard EXPORT_SYMBOL() declarations
    
    Just a tidy up to follow the standard EXPORT_SYMBOL*() declarations
    in order to improve grep-ability.
    
    - Move EXPORT_SYMBOL*() to the position right after its definition
    - Remove superfluous blank line before EXPORT_SYMBOL*() lines
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 6bda8436d765..00f2cbb76e69 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -452,7 +452,6 @@ int snd_card_disconnect(struct snd_card *card)
 #endif
 	return 0;	
 }
-
 EXPORT_SYMBOL(snd_card_disconnect);
 
 static int snd_card_do_free(struct snd_card *card)
@@ -718,7 +717,7 @@ int snd_card_add_dev_attr(struct snd_card *card,
 
 	dev_err(card->dev, "Too many groups assigned\n");
 	return -ENOSPC;
-};
+}
 EXPORT_SYMBOL_GPL(snd_card_add_dev_attr);
 
 /**
@@ -775,7 +774,6 @@ int snd_card_register(struct snd_card *card)
 #endif
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_card_register);
 
 #ifdef CONFIG_SND_PROC_FS
@@ -895,7 +893,6 @@ int snd_component_add(struct snd_card *card, const char *component)
 	strcat(card->components, component);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_component_add);
 
 /**
@@ -930,7 +927,6 @@ int snd_card_file_add(struct snd_card *card, struct file *file)
 	spin_unlock(&card->files_lock);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_card_file_add);
 
 /**
@@ -972,7 +968,6 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 	put_device(&card->card_dev);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_card_file_remove);
 
 #ifdef CONFIG_PM
@@ -1012,6 +1007,5 @@ int snd_power_wait(struct snd_card *card, unsigned int power_state)
 	remove_wait_queue(&card->power_sleep, &wait);
 	return result;
 }
-
 EXPORT_SYMBOL(snd_power_wait);
 #endif /* CONFIG_PM */

commit de65360be0239a63268de589c4189f8ee52dad6c
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Dec 22 19:09:05 2015 +0100

    ALSA: hda_intel: add card number to irq description
    
    Currently the info in /proc/interrupts doesn't allow to figure out which
    interrupt belongs to which card (HDMI, PCH, ..).
    Therefore add card details to the interrupt description.
    With the patch the info in /proc/interrupts looks like this:
    
    PCI-MSI 442368-edge      snd_hda_intel:card1
    PCI-MSI 49152-edge      snd_hda_intel:card0
    
    NOTE: this patch adds the new irq_descr field snd_card struct that is
    filled automatically at a card object creation.  This can be used
    generically for other drivers as well.  The changes for others will
    follow later -- tiwai
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 20f37fb3800e..6bda8436d765 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -268,6 +268,9 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	if (err < 0)
 		goto __error;
 
+	snprintf(card->irq_descr, sizeof(card->irq_descr), "%s:%s",
+		 dev_driver_string(card->dev), dev_name(&card->card_dev));
+
 	/* the control interface cannot be accessed from the user space until */
 	/* snd_cards_bitmask and snd_cards are set with snd_card_register */
 	err = snd_ctl_create(card);

commit 0755e74b8f04d17cea09fa342a788025b2b50e2e
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jun 29 17:10:22 2015 +0100

    ALSA: Fix uninintialized error return
    
    Static analysis with cppcheck found the following error:
      [sound/core/init.c:118]: (error) Uninitialized variable: err
    
    ..this was introduced by commit 2471b6c80a70e80de69f5ff4c37187c3912e5874
    ("ALSA: info: Register proc entries recursively, too") where the call
    to snd_info_card_register was removed and no longer setting the error
    return in err.  When snd_info_create_card_entry fails to allocate a
    an entry, the error path exits with garbage in err.  Fix is to return
    -ENOMEM if entry fails to be allocated.
    
    Fixes: 2471b6c80a ("ALSA: info: Register proc entries recursively, too")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 3e0cebacefe1..20f37fb3800e 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -109,13 +109,12 @@ static void snd_card_id_read(struct snd_info_entry *entry,
 
 static int init_info_for_card(struct snd_card *card)
 {
-	int err;
 	struct snd_info_entry *entry;
 
 	entry = snd_info_create_card_entry(card, "id", card->proc_root);
 	if (!entry) {
 		dev_dbg(card->dev, "unable to create card entry\n");
-		return err;
+		return -ENOMEM;
 	}
 	entry->c.text.read = snd_card_id_read;
 	card->proc_id = entry;

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index f8abd2d8144e..3e0cebacefe1 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -100,7 +100,7 @@ int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);
 EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
 #endif
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 static void snd_card_id_read(struct snd_info_entry *entry,
 			     struct snd_info_buffer *buffer)
 {
@@ -122,7 +122,7 @@ static int init_info_for_card(struct snd_card *card)
 
 	return snd_info_card_register(card);
 }
-#else /* !CONFIG_PROC_FS */
+#else /* !CONFIG_SND_PROC_FS */
 #define init_info_for_card(card)
 #endif
 
@@ -776,7 +776,7 @@ int snd_card_register(struct snd_card *card)
 
 EXPORT_SYMBOL(snd_card_register);
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 static void snd_card_info_read(struct snd_info_entry *entry,
 			       struct snd_info_buffer *buffer)
 {
@@ -861,7 +861,7 @@ int __init snd_card_info_init(void)
 
 	return 0;
 }
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */
 
 /**
  *  snd_component_add - add a component string

commit 2471b6c80a70e80de69f5ff4c37187c3912e5874
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 18 09:20:24 2015 +0200

    ALSA: info: Register proc entries recursively, too
    
    The commit [c560a6797e3b: ALSA: core: Remove child proc file elements
    recursively] converted snd_card_proc_new() with the normal
    snd_info_*() call and removed snd_device chain for such info
    entries. However, it misses one point: the creation of the proc entry
    was managed by snd_device chain in the former code, and now it's also
    gone, which results in no proc files creation at all.  Mea culpa.
    
    This patch makes snd_info_card_register() creating the all pending
    child proc entries in a shot.  Also, since snd_card_register() might
    be called multiple times, this function is also changed to be callable
    multiple times.
    
    Along with the changes above, now the linked list of snd_info_entry is
    added at creation time instead of snd_info_register() for keeping eyes
    of pending info entries.
    
    Fixes: c560a6797e3b ('ALSA: core: Remove child proc file elements recursively')
    Reported-by: "Lu, Han" <han.lu@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 769a783757ff..f8abd2d8144e 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -107,26 +107,20 @@ static void snd_card_id_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "%s\n", entry->card->id);
 }
 
-static inline int init_info_for_card(struct snd_card *card)
+static int init_info_for_card(struct snd_card *card)
 {
 	int err;
 	struct snd_info_entry *entry;
 
-	if ((err = snd_info_card_register(card)) < 0) {
-		dev_dbg(card->dev, "unable to create card info\n");
-		return err;
-	}
-	if ((entry = snd_info_create_card_entry(card, "id", card->proc_root)) == NULL) {
+	entry = snd_info_create_card_entry(card, "id", card->proc_root);
+	if (!entry) {
 		dev_dbg(card->dev, "unable to create card entry\n");
 		return err;
 	}
 	entry->c.text.read = snd_card_id_read;
-	if (snd_info_register(entry) < 0) {
-		snd_info_free_entry(entry);
-		entry = NULL;
-	}
 	card->proc_id = entry;
-	return 0;
+
+	return snd_info_card_register(card);
 }
 #else /* !CONFIG_PROC_FS */
 #define init_info_for_card(card)
@@ -756,7 +750,7 @@ int snd_card_register(struct snd_card *card)
 	if (snd_cards[card->number]) {
 		/* already registered */
 		mutex_unlock(&snd_card_mutex);
-		return 0;
+		return snd_info_card_register(card); /* register pending info */
 	}
 	if (*card->id) {
 		/* make a unique id name from the given string */

commit b591b6e9e99017137888e2e397f0ddd8adb77c5d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 22:29:10 2015 +0200

    ALSA: core: Don't ignore errors at creating proc files
    
    So far we've ignored the errors at creating proc files in many places.
    But they should be rather treated seriously.
    
    Also, by assuring the error handling, we can get rid of superfluous
    snd_info_free_entry() calls as they will be removed by the parent in
    the caller side.
    
    This patch fixes the missing error checks and reduces the superfluous
    free calls.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 0af34fac0499..769a783757ff 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -853,18 +853,16 @@ int __init snd_card_info_init(void)
 	if (! entry)
 		return -ENOMEM;
 	entry->c.text.read = snd_card_info_read;
-	if (snd_info_register(entry) < 0) {
-		snd_info_free_entry(entry);
-		return -ENOMEM;
-	}
+	if (snd_info_register(entry) < 0)
+		return -ENOMEM; /* freed in error path */
 
 #ifdef MODULE
 	entry = snd_info_create_module_entry(THIS_MODULE, "modules", NULL);
-	if (entry) {
-		entry->c.text.read = snd_card_module_info_read;
-		if (snd_info_register(entry) < 0)
-			snd_info_free_entry(entry);
-	}
+	if (!entry)
+		return -ENOMEM;
+	entry->c.text.read = snd_card_module_info_read;
+	if (snd_info_register(entry) < 0)
+		return -ENOMEM; /* freed in error path */
 #endif
 
 	return 0;

commit b046d244e2290e3d114af2e91503ee3d08fc605a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 21:33:41 2015 +0200

    ALSA: core: Remove superfluous exit calls for proc entries
    
    Since each proc entry is freed automatically by the parent, we don't
    have to take care of its life cycle any longer.  This allows us to
    reduce a few more lines of codes.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 04734e047bfe..0af34fac0499 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -783,8 +783,6 @@ int snd_card_register(struct snd_card *card)
 EXPORT_SYMBOL(snd_card_register);
 
 #ifdef CONFIG_PROC_FS
-static struct snd_info_entry *snd_card_info_entry;
-
 static void snd_card_info_read(struct snd_info_entry *entry,
 			       struct snd_info_buffer *buffer)
 {
@@ -810,7 +808,6 @@ static void snd_card_info_read(struct snd_info_entry *entry,
 }
 
 #ifdef CONFIG_SND_OSSEMUL
-
 void snd_card_info_read_oss(struct snd_info_buffer *buffer)
 {
 	int idx, count;
@@ -832,7 +829,6 @@ void snd_card_info_read_oss(struct snd_info_buffer *buffer)
 #endif
 
 #ifdef MODULE
-static struct snd_info_entry *snd_card_module_info_entry;
 static void snd_card_module_info_read(struct snd_info_entry *entry,
 				      struct snd_info_buffer *buffer)
 {
@@ -861,7 +857,6 @@ int __init snd_card_info_init(void)
 		snd_info_free_entry(entry);
 		return -ENOMEM;
 	}
-	snd_card_info_entry = entry;
 
 #ifdef MODULE
 	entry = snd_info_create_module_entry(THIS_MODULE, "modules", NULL);
@@ -869,23 +864,11 @@ int __init snd_card_info_init(void)
 		entry->c.text.read = snd_card_module_info_read;
 		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);
-		else
-			snd_card_module_info_entry = entry;
 	}
 #endif
 
 	return 0;
 }
-
-int __exit snd_card_info_done(void)
-{
-	snd_info_free_entry(snd_card_info_entry);
-#ifdef MODULE
-	snd_info_free_entry(snd_card_module_info_entry);
-#endif
-	return 0;
-}
-
 #endif /* CONFIG_PROC_FS */
 
 /**

commit e086e3035e0691b362755d1b5e24df631eee335a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 27 18:01:22 2015 +0100

    ALSA: core: Re-add snd_device_disconnect()
    
    Revive snd_device_disconnect() again so that it can be called from the
    individual driver.  This time, HD-audio will need it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 35419054821c..04734e047bfe 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -400,7 +400,6 @@ static const struct file_operations snd_shutdown_f_ops =
 int snd_card_disconnect(struct snd_card *card)
 {
 	struct snd_monitor_file *mfile;
-	int err;
 
 	if (!card)
 		return -EINVAL;
@@ -445,9 +444,7 @@ int snd_card_disconnect(struct snd_card *card)
 #endif
 
 	/* notify all devices that we are disconnected */
-	err = snd_device_disconnect_all(card);
-	if (err < 0)
-		dev_err(card->dev, "not all devices for card %i can be disconnected\n", card->number);
+	snd_device_disconnect_all(card);
 
 	snd_info_card_disconnect(card);
 	if (card->registered) {

commit 6bbc7fed849597ec35ffdcaf677910dd11d71d08
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 30 12:27:43 2015 +0100

    ALSA: Add a helper to add a new attribute group to card
    
    For assigning sysfs entries for a card device from the driver,
    introduce a new helper function, snd_card_add_dev_attr().  In this
    way, we can avoid the possible race between the device registration
    and the sysfs addition / removal.
    
    The driver can pass a new attribute group to add freely.  This has to
    be called before snd_card_register().
    
    Currently, up to two extra groups can be added.  More than that, it'll
    return an error.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 96194599e82e..35419054821c 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -181,7 +181,7 @@ void snd_device_initialize(struct device *dev, struct snd_card *card)
 EXPORT_SYMBOL_GPL(snd_device_initialize);
 
 static int snd_card_do_free(struct snd_card *card);
-static const struct attribute_group *card_dev_attr_groups[];
+static const struct attribute_group card_dev_attr_group;
 
 static void release_card_device(struct device *dev)
 {
@@ -269,7 +269,8 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	card->card_dev.parent = parent;
 	card->card_dev.class = sound_class;
 	card->card_dev.release = release_card_device;
-	card->card_dev.groups = card_dev_attr_groups;
+	card->card_dev.groups = card->dev_groups;
+	card->dev_groups[0] = &card_dev_attr_group;
 	err = kobject_set_name(&card->card_dev.kobj, "card%d", idx);
 	if (err < 0)
 		goto __error;
@@ -700,14 +701,32 @@ static struct attribute *card_dev_attrs[] = {
 	NULL
 };
 
-static struct attribute_group card_dev_attr_group = {
+static const struct attribute_group card_dev_attr_group = {
 	.attrs	= card_dev_attrs,
 };
 
-static const struct attribute_group *card_dev_attr_groups[] = {
-	&card_dev_attr_group,
-	NULL
+/**
+ * snd_card_add_dev_attr - Append a new sysfs attribute group to card
+ * @card: card instance
+ * @group: attribute group to append
+ */
+int snd_card_add_dev_attr(struct snd_card *card,
+			  const struct attribute_group *group)
+{
+	int i;
+
+	/* loop for (arraysize-1) here to keep NULL at the last entry */
+	for (i = 0; i < ARRAY_SIZE(card->dev_groups) - 1; i++) {
+		if (!card->dev_groups[i]) {
+			card->dev_groups[i] = group;
+			return 0;
+		}
+	}
+
+	dev_err(card->dev, "Too many groups assigned\n");
+	return -ENOSPC;
 };
+EXPORT_SYMBOL_GPL(snd_card_add_dev_attr);
 
 /**
  *  snd_card_register - register the soundcard

commit 4b440be667c6187717c99e4d427119fa415ced29
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 21:32:47 2015 +0100

    ALSA: Add a helper to initialize device
    
    Introduce a new helper function snd_device_initialize() to initialize
    the device object for sound devices.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 074875d68c15..96194599e82e 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -157,6 +157,29 @@ static int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),
 	return mask; /* unchanged */
 }
 
+/* the default release callback set in snd_device_initialize() below;
+ * this is just NOP for now, as almost all jobs are already done in
+ * dev_free callback of snd_device chain instead.
+ */
+static void default_release(struct device *dev)
+{
+}
+
+/**
+ * snd_device_initialize - Initialize struct device for sound devices
+ * @dev: device to initialize
+ * @card: card to assign, optional
+ */
+void snd_device_initialize(struct device *dev, struct snd_card *card)
+{
+	device_initialize(dev);
+	if (card)
+		dev->parent = &card->card_dev;
+	dev->class = sound_class;
+	dev->release = default_release;
+}
+EXPORT_SYMBOL_GPL(snd_device_initialize);
+
 static int snd_card_do_free(struct snd_card *card);
 static const struct attribute_group *card_dev_attr_groups[];
 

commit eb9c38d54c9cad72101dfe7fefe4a784dd67da86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 30 15:19:43 2014 +0100

    ALSA: doc: More kerneldoc comments on core components
    
    Some functions missed the proper kerneldoc comments.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 7bdfd19e24a8..074875d68c15 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -438,17 +438,6 @@ int snd_card_disconnect(struct snd_card *card)
 
 EXPORT_SYMBOL(snd_card_disconnect);
 
-/**
- *  snd_card_free - frees given soundcard structure
- *  @card: soundcard structure
- *
- *  This function releases the soundcard structure and the all assigned
- *  devices automatically.  That is, you don't have to release the devices
- *  by yourself.
- *
- *  Return: Zero. Frees all associated devices and frees the control
- *  interface associated to given soundcard.
- */
 static int snd_card_do_free(struct snd_card *card)
 {
 #if IS_ENABLED(CONFIG_SND_MIXER_OSS)
@@ -469,6 +458,15 @@ static int snd_card_do_free(struct snd_card *card)
 	return 0;
 }
 
+/**
+ * snd_card_free_when_closed - Disconnect the card, free it later eventually
+ * @card: soundcard structure
+ *
+ * Unlike snd_card_free(), this function doesn't try to release the card
+ * resource immediately, but tries to disconnect at first.  When the card
+ * is still in use, the function returns before freeing the resources.
+ * The card resources will be freed when the refcount gets to zero.
+ */
 int snd_card_free_when_closed(struct snd_card *card)
 {
 	int ret = snd_card_disconnect(card);
@@ -479,6 +477,19 @@ int snd_card_free_when_closed(struct snd_card *card)
 }
 EXPORT_SYMBOL(snd_card_free_when_closed);
 
+/**
+ * snd_card_free - frees given soundcard structure
+ * @card: soundcard structure
+ *
+ * This function releases the soundcard structure and the all assigned
+ * devices automatically.  That is, you don't have to release the devices
+ * by yourself.
+ *
+ * This function waits until the all resources are properly released.
+ *
+ * Return: Zero. Frees all associated devices and frees the control
+ * interface associated to given soundcard.
+ */
 int snd_card_free(struct snd_card *card)
 {
 	struct completion released;

commit 07f4d9d74a04aa7c72c5dae0ef97565f28f17b92
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jun 18 13:32:31 2014 +0200

    ALSA: control: Protect user controls against concurrent access
    
    The user-control put and get handlers as well as the tlv do not protect against
    concurrent access from multiple threads. Since the state of the control is not
    updated atomically it is possible that either two write operations or a write
    and a read operation race against each other. Both can lead to arbitrary memory
    disclosure. This patch introduces a new lock that protects user-controls from
    concurrent access. Since applications typically access controls sequentially
    than in parallel a single lock per card should be fine.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 5ee83845c5de..7bdfd19e24a8 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -232,6 +232,7 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	INIT_LIST_HEAD(&card->devices);
 	init_rwsem(&card->controls_rwsem);
 	rwlock_init(&card->ctl_files_rwlock);
+	mutex_init(&card->user_ctl_lock);
 	INIT_LIST_HEAD(&card->controls);
 	INIT_LIST_HEAD(&card->ctl_files);
 	spin_lock_init(&card->files_lock);

commit 72620d6048445bda3f748c97fb2f18e47b19a9e5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 11:36:11 2014 +0100

    ALSA: Clean up snd_device_*() codes
    
    A few code cleanups and optimizations.  In addition, drop
    snd_device_disconnect() that isn't used at all, and drop the return
    values from snd_device_free*().
    
    Another slight difference by this change is that now the device state
    will become always SNDRV_DEV_REGISTERED no matter whether dev_register
    ops is present or not.  It's for better consistency.  There should be
    no impact for the current tree, as the state isn't checked.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 9e7f17b72fb6..5ee83845c5de 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -454,10 +454,7 @@ static int snd_card_do_free(struct snd_card *card)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);
 #endif
-	if (snd_device_free_all(card) < 0) {
-		dev_err(card->dev, "unable to free all devices\n");
-		/* Fatal, but this situation should never occur */
-	}
+	snd_device_free_all(card);
 	if (card->private_free)
 		card->private_free(card);
 	snd_info_free_entry(card->proc_id);

commit 289ca025ee1d78223e3368801fc2b984e5efbfc7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 15:53:35 2014 +0100

    ALSA: Use priority list for managing device list
    
    Basically, the device type specifies the priority of the device to be
    registered / freed, too.  However, the priority value isn't well
    utilized but only it's checked as a group.  This results in
    inconsistent register and free order (where each of them should be in
    reversed direction).
    
    This patch simplifies the device list management code by simply
    inserting a list entry at creation time in an incremental order for
    the priority value.  Since we can just follow the link for register,
    disconnect and free calls, we don't have to specify the group; so the
    whole enum definitions are also simplified as well.
    
    The visible change to outside is that the priorities of some object
    types are revisited.  For example, now the SNDRV_DEV_LOWLEVEL object
    is registered before others (control, PCM, etc) and, in return,
    released after others.  Similarly, SNDRV_DEV_CODEC is in a lower
    priority than SNDRV_DEV_BUS for ensuring the dependency.
    
    Also, the unused SNDRV_DEV_TOPLEVEL, SNDRV_DEV_LOWLEVEL_PRE and
    SNDRV_DEV_LOWLEVEL_NORMAL are removed as a cleanup.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index b7085eb19079..9e7f17b72fb6 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -266,7 +266,7 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	return 0;
 
       __error_ctl:
-	snd_device_free_all(card, SNDRV_DEV_CMD_PRE);
+	snd_device_free_all(card);
       __error:
 	put_device(&card->card_dev);
   	return err;
@@ -454,16 +454,8 @@ static int snd_card_do_free(struct snd_card *card)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);
 #endif
-	if (snd_device_free_all(card, SNDRV_DEV_CMD_PRE) < 0) {
-		dev_err(card->dev, "unable to free all devices (pre)\n");
-		/* Fatal, but this situation should never occur */
-	}
-	if (snd_device_free_all(card, SNDRV_DEV_CMD_NORMAL) < 0) {
-		dev_err(card->dev, "unable to free all devices (normal)\n");
-		/* Fatal, but this situation should never occur */
-	}
-	if (snd_device_free_all(card, SNDRV_DEV_CMD_POST) < 0) {
-		dev_err(card->dev, "unable to free all devices (post)\n");
+	if (snd_device_free_all(card) < 0) {
+		dev_err(card->dev, "unable to free all devices\n");
 		/* Fatal, but this situation should never occur */
 	}
 	if (card->private_free)

commit b203dbab0838afa4b2de8b5bd880fb124446b764
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 19 11:18:10 2014 +0100

    ALSA: core: Fix missing card sysfs contents
    
    While moving the card device into struct snd_card, the reference to
    the assigned card in sysfs show/store callbacks were forgotten to be
    refreshed, still accessing to the no longer used drvdata.  Fix these
    places to refer correctly via container_of().
    
    Also, remove the superfluous NULL checks since it's guaranteed to be
    non-NULL now.
    
    Fixes: 8bfb181c17d2 ('ALSA: Embed card device into struct snd_card')
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 0095a530ff12..b7085eb19079 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -624,15 +624,15 @@ static ssize_t
 card_id_show_attr(struct device *dev,
 		  struct device_attribute *attr, char *buf)
 {
-	struct snd_card *card = dev_get_drvdata(dev);
-	return snprintf(buf, PAGE_SIZE, "%s\n", card ? card->id : "(null)");
+	struct snd_card *card = container_of(dev, struct snd_card, card_dev);
+	return snprintf(buf, PAGE_SIZE, "%s\n", card->id);
 }
 
 static ssize_t
 card_id_store_attr(struct device *dev, struct device_attribute *attr,
 		   const char *buf, size_t count)
 {
-	struct snd_card *card = dev_get_drvdata(dev);
+	struct snd_card *card = container_of(dev, struct snd_card, card_dev);
 	char buf1[sizeof(card->id)];
 	size_t copy = count > sizeof(card->id) - 1 ?
 					sizeof(card->id) - 1 : count;
@@ -664,8 +664,8 @@ static ssize_t
 card_number_show_attr(struct device *dev,
 		     struct device_attribute *attr, char *buf)
 {
-	struct snd_card *card = dev_get_drvdata(dev);
-	return snprintf(buf, PAGE_SIZE, "%i\n", card ? card->number : -1);
+	struct snd_card *card = container_of(dev, struct snd_card, card_dev);
+	return snprintf(buf, PAGE_SIZE, "%i\n", card->number);
 }
 
 static DEVICE_ATTR(number, S_IRUGO, card_number_show_attr, NULL);

commit f2f9307a4f26a9fbe47fff486a9cee5885af748f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:21:03 2014 +0100

    ALSA: core: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 5b7c4eb46c10..0095a530ff12 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -113,11 +113,11 @@ static inline int init_info_for_card(struct snd_card *card)
 	struct snd_info_entry *entry;
 
 	if ((err = snd_info_card_register(card)) < 0) {
-		snd_printd("unable to create card info\n");
+		dev_dbg(card->dev, "unable to create card info\n");
 		return err;
 	}
 	if ((entry = snd_info_create_card_entry(card, "id", card->proc_root)) == NULL) {
-		snd_printd("unable to create card entry\n");
+		dev_dbg(card->dev, "unable to create card entry\n");
 		return err;
 	}
 	entry->c.text.read = snd_card_id_read;
@@ -217,7 +217,7 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 		err = -ENODEV;
 	if (err < 0) {
 		mutex_unlock(&snd_card_mutex);
-		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i), error: %d\n",
+		dev_err(parent, "cannot find the slot for index %d (range 0-%i), error: %d\n",
 			 idx, snd_ecards_limit - 1, err);
 		kfree(card);
 		return err;
@@ -254,12 +254,12 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	/* snd_cards_bitmask and snd_cards are set with snd_card_register */
 	err = snd_ctl_create(card);
 	if (err < 0) {
-		snd_printk(KERN_ERR "unable to register control minors\n");
+		dev_err(parent, "unable to register control minors\n");
 		goto __error;
 	}
 	err = snd_info_card_create(card);
 	if (err < 0) {
-		snd_printk(KERN_ERR "unable to create card info\n");
+		dev_err(parent, "unable to create card info\n");
 		goto __error_ctl;
 	}
 	*card_ret = card;
@@ -422,7 +422,7 @@ int snd_card_disconnect(struct snd_card *card)
 	/* notify all devices that we are disconnected */
 	err = snd_device_disconnect_all(card);
 	if (err < 0)
-		snd_printk(KERN_ERR "not all devices for card %i can be disconnected\n", card->number);
+		dev_err(card->dev, "not all devices for card %i can be disconnected\n", card->number);
 
 	snd_info_card_disconnect(card);
 	if (card->registered) {
@@ -455,22 +455,22 @@ static int snd_card_do_free(struct snd_card *card)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);
 #endif
 	if (snd_device_free_all(card, SNDRV_DEV_CMD_PRE) < 0) {
-		snd_printk(KERN_ERR "unable to free all devices (pre)\n");
+		dev_err(card->dev, "unable to free all devices (pre)\n");
 		/* Fatal, but this situation should never occur */
 	}
 	if (snd_device_free_all(card, SNDRV_DEV_CMD_NORMAL) < 0) {
-		snd_printk(KERN_ERR "unable to free all devices (normal)\n");
+		dev_err(card->dev, "unable to free all devices (normal)\n");
 		/* Fatal, but this situation should never occur */
 	}
 	if (snd_device_free_all(card, SNDRV_DEV_CMD_POST) < 0) {
-		snd_printk(KERN_ERR "unable to free all devices (post)\n");
+		dev_err(card->dev, "unable to free all devices (post)\n");
 		/* Fatal, but this situation should never occur */
 	}
 	if (card->private_free)
 		card->private_free(card);
 	snd_info_free_entry(card->proc_id);
 	if (snd_info_card_free(card) < 0) {
-		snd_printk(KERN_WARNING "unable to free card info\n");
+		dev_warn(card->dev, "unable to free card info\n");
 		/* Not fatal error */
 	}
 	if (card->release_completion)
@@ -596,7 +596,7 @@ static void snd_card_set_id_no_lock(struct snd_card *card, const char *src,
 		goto again;
 	}
 	/* last resort... */
-	snd_printk(KERN_ERR "unable to set card id (%s)\n", id);
+	dev_err(card->dev, "unable to set card id (%s)\n", id);
 	if (card->proc_root->name)
 		strlcpy(card->id, card->proc_root->name, sizeof(card->id));
 }
@@ -948,7 +948,7 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 	}
 	spin_unlock(&card->files_lock);
 	if (!found) {
-		snd_printk(KERN_ERR "ALSA card file remove problem (%p)\n", file);
+		dev_err(card->dev, "card file remove problem (%p)\n", file);
 		return -ENOENT;
 	}
 	kfree(found);

commit f24640648186b59bd39f8cd640d631bdb61a3197
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 12:13:43 2014 +0100

    ALSA: Use standard device refcount for card accounting
    
    Drop the own refcount but use the standard device refcounting via
    get_device() and put_device().  Introduce a new completion to snd_card
    instead of the wait queue for syncing the last release, which is used
    in snd_card_free().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index ff96eda898e3..5b7c4eb46c10 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -28,6 +28,7 @@
 #include <linux/time.h>
 #include <linux/ctype.h>
 #include <linux/pm.h>
+#include <linux/completion.h>
 
 #include <sound/core.h>
 #include <sound/control.h>
@@ -235,8 +236,6 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	INIT_LIST_HEAD(&card->ctl_files);
 	spin_lock_init(&card->files_lock);
 	INIT_LIST_HEAD(&card->files_list);
-	init_waitqueue_head(&card->shutdown_sleep);
-	atomic_set(&card->refcount, 0);
 #ifdef CONFIG_PM
 	mutex_init(&card->power_lock);
 	init_waitqueue_head(&card->power_sleep);
@@ -474,58 +473,36 @@ static int snd_card_do_free(struct snd_card *card)
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
 	}
+	if (card->release_completion)
+		complete(card->release_completion);
 	kfree(card);
 	return 0;
 }
 
-/**
- * snd_card_unref - release the reference counter
- * @card: the card instance
- *
- * Decrements the reference counter.  When it reaches to zero, wake up
- * the sleeper and call the destructor if needed.
- */
-void snd_card_unref(struct snd_card *card)
-{
-	if (atomic_dec_and_test(&card->refcount)) {
-		wake_up(&card->shutdown_sleep);
-		if (card->free_on_last_close)
-			put_device(&card->card_dev);
-	}
-}
-EXPORT_SYMBOL(snd_card_unref);
-
 int snd_card_free_when_closed(struct snd_card *card)
 {
-	int ret;
-
-	atomic_inc(&card->refcount);
-	ret = snd_card_disconnect(card);
-	if (ret) {
-		atomic_dec(&card->refcount);
+	int ret = snd_card_disconnect(card);
+	if (ret)
 		return ret;
-	}
-
-	card->free_on_last_close = 1;
-	if (atomic_dec_and_test(&card->refcount))
-		put_device(&card->card_dev);
+	put_device(&card->card_dev);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_card_free_when_closed);
 
 int snd_card_free(struct snd_card *card)
 {
-	int ret = snd_card_disconnect(card);
+	struct completion released;
+	int ret;
+
+	init_completion(&released);
+	card->release_completion = &released;
+	ret = snd_card_free_when_closed(card);
 	if (ret)
 		return ret;
-
 	/* wait, until all devices are ready for the free operation */
-	wait_event(card->shutdown_sleep, !atomic_read(&card->refcount));
-	put_device(&card->card_dev);
+	wait_for_completion(&released);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_card_free);
 
 /* retrieve the last word of shortname or longname */
@@ -932,7 +909,7 @@ int snd_card_file_add(struct snd_card *card, struct file *file)
 		return -ENODEV;
 	}
 	list_add(&mfile->list, &card->files_list);
-	atomic_inc(&card->refcount);
+	get_device(&card->card_dev);
 	spin_unlock(&card->files_lock);
 	return 0;
 }
@@ -975,7 +952,7 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 		return -ENOENT;
 	}
 	kfree(found);
-	snd_card_unref(card);
+	put_device(&card->card_dev);
 	return 0;
 }
 

commit 34356dbdb64e9f12cc8ce1bb0d9e38a75b1e4638
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 11:54:10 2014 +0100

    ALSA: Use static groups for id and number card sysfs attr files
    
    ... instead of calling device_create_file() manually.
    No functional change.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index f7875049c5e1..ff96eda898e3 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -157,6 +157,7 @@ static int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),
 }
 
 static int snd_card_do_free(struct snd_card *card);
+static const struct attribute_group *card_dev_attr_groups[];
 
 static void release_card_device(struct device *dev)
 {
@@ -245,6 +246,7 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	card->card_dev.parent = parent;
 	card->card_dev.class = sound_class;
 	card->card_dev.release = release_card_device;
+	card->card_dev.groups = card_dev_attr_groups;
 	err = kobject_set_name(&card->card_dev.kobj, "card%d", idx);
 	if (err < 0)
 		goto __error;
@@ -679,8 +681,7 @@ card_id_store_attr(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-static struct device_attribute card_id_attrs =
-	__ATTR(id, S_IRUGO | S_IWUSR, card_id_show_attr, card_id_store_attr);
+static DEVICE_ATTR(id, S_IRUGO | S_IWUSR, card_id_show_attr, card_id_store_attr);
 
 static ssize_t
 card_number_show_attr(struct device *dev,
@@ -690,8 +691,22 @@ card_number_show_attr(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%i\n", card ? card->number : -1);
 }
 
-static struct device_attribute card_number_attrs =
-	__ATTR(number, S_IRUGO, card_number_show_attr, NULL);
+static DEVICE_ATTR(number, S_IRUGO, card_number_show_attr, NULL);
+
+static struct attribute *card_dev_attrs[] = {
+	&dev_attr_id.attr,
+	&dev_attr_number.attr,
+	NULL
+};
+
+static struct attribute_group card_dev_attr_group = {
+	.attrs	= card_dev_attrs,
+};
+
+static const struct attribute_group *card_dev_attr_groups[] = {
+	&card_dev_attr_group,
+	NULL
+};
 
 /**
  *  snd_card_register - register the soundcard
@@ -745,15 +760,6 @@ int snd_card_register(struct snd_card *card)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);
 #endif
-	if (card->registered) {
-		err = device_create_file(&card->card_dev, &card_id_attrs);
-		if (err < 0)
-			return err;
-		err = device_create_file(&card->card_dev, &card_number_attrs);
-		if (err < 0)
-			return err;
-	}
-
 	return 0;
 }
 

commit 8bfb181c17d20956f156e84638912e00e1aaca86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 11:46:11 2014 +0100

    ALSA: Embed card device into struct snd_card
    
    As prepared in the previous patch, we are ready to create a device
    struct for the card object in snd_card_create() now.  This patch
    changes the scheme from the old style to:
    
    - embed a device struct for the card object into snd_card struct,
    - initialize the card device in snd_card_create() (but not register),
    - registration is done in snd_card_register() via device_add()
    
    The actual card device is stored in card->card_dev.  The card->dev
    pointer is kept unchanged and pointing to the parent device as before
    for compatibility reason.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index f4d3ac633ff8..f7875049c5e1 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -156,6 +156,13 @@ static int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),
 	return mask; /* unchanged */
 }
 
+static int snd_card_do_free(struct snd_card *card);
+
+static void release_card_device(struct device *dev)
+{
+	snd_card_do_free(dev_to_snd_card(dev));
+}
+
 /**
  *  snd_card_new - create and initialize a soundcard structure
  *  @parent: the parent device object
@@ -189,6 +196,8 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	card = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);
 	if (!card)
 		return -ENOMEM;
+	if (extra_size > 0)
+		card->private_data = (char *)card + sizeof(struct snd_card);
 	if (xid)
 		strlcpy(card->id, xid, sizeof(card->id));
 	err = 0;
@@ -208,7 +217,8 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 		mutex_unlock(&snd_card_mutex);
 		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i), error: %d\n",
 			 idx, snd_ecards_limit - 1, err);
-		goto __error;
+		kfree(card);
+		return err;
 	}
 	set_bit(idx, snd_cards_lock);		/* lock it */
 	if (idx >= snd_ecards_limit)
@@ -230,6 +240,15 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 	mutex_init(&card->power_lock);
 	init_waitqueue_head(&card->power_sleep);
 #endif
+
+	device_initialize(&card->card_dev);
+	card->card_dev.parent = parent;
+	card->card_dev.class = sound_class;
+	card->card_dev.release = release_card_device;
+	err = kobject_set_name(&card->card_dev.kobj, "card%d", idx);
+	if (err < 0)
+		goto __error;
+
 	/* the control interface cannot be accessed from the user space until */
 	/* snd_cards_bitmask and snd_cards are set with snd_card_register */
 	err = snd_ctl_create(card);
@@ -242,15 +261,13 @@ int snd_card_new(struct device *parent, int idx, const char *xid,
 		snd_printk(KERN_ERR "unable to create card info\n");
 		goto __error_ctl;
 	}
-	if (extra_size > 0)
-		card->private_data = (char *)card + sizeof(struct snd_card);
 	*card_ret = card;
 	return 0;
 
       __error_ctl:
 	snd_device_free_all(card, SNDRV_DEV_CMD_PRE);
       __error:
-	kfree(card);
+	put_device(&card->card_dev);
   	return err;
 }
 EXPORT_SYMBOL(snd_card_new);
@@ -407,9 +424,9 @@ int snd_card_disconnect(struct snd_card *card)
 		snd_printk(KERN_ERR "not all devices for card %i can be disconnected\n", card->number);
 
 	snd_info_card_disconnect(card);
-	if (card->card_dev) {
-		device_unregister(card->card_dev);
-		card->card_dev = NULL;
+	if (card->registered) {
+		device_del(&card->card_dev);
+		card->registered = false;
 	}
 #ifdef CONFIG_PM
 	wake_up(&card->power_sleep);
@@ -471,7 +488,7 @@ void snd_card_unref(struct snd_card *card)
 	if (atomic_dec_and_test(&card->refcount)) {
 		wake_up(&card->shutdown_sleep);
 		if (card->free_on_last_close)
-			snd_card_do_free(card);
+			put_device(&card->card_dev);
 	}
 }
 EXPORT_SYMBOL(snd_card_unref);
@@ -489,7 +506,7 @@ int snd_card_free_when_closed(struct snd_card *card)
 
 	card->free_on_last_close = 1;
 	if (atomic_dec_and_test(&card->refcount))
-		snd_card_do_free(card);
+		put_device(&card->card_dev);
 	return 0;
 }
 
@@ -503,7 +520,7 @@ int snd_card_free(struct snd_card *card)
 
 	/* wait, until all devices are ready for the free operation */
 	wait_event(card->shutdown_sleep, !atomic_read(&card->refcount));
-	snd_card_do_free(card);
+	put_device(&card->card_dev);
 	return 0;
 }
 
@@ -694,12 +711,11 @@ int snd_card_register(struct snd_card *card)
 	if (snd_BUG_ON(!card))
 		return -EINVAL;
 
-	if (!card->card_dev) {
-		card->card_dev = device_create(sound_class, card->dev,
-					       MKDEV(0, 0), card,
-					       "card%i", card->number);
-		if (IS_ERR(card->card_dev))
-			card->card_dev = NULL;
+	if (!card->registered) {
+		err = device_add(&card->card_dev);
+		if (err < 0)
+			return err;
+		card->registered = true;
 	}
 
 	if ((err = snd_device_register_all(card)) < 0)
@@ -729,11 +745,11 @@ int snd_card_register(struct snd_card *card)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);
 #endif
-	if (card->card_dev) {
-		err = device_create_file(card->card_dev, &card_id_attrs);
+	if (card->registered) {
+		err = device_create_file(&card->card_dev, &card_id_attrs);
 		if (err < 0)
 			return err;
-		err = device_create_file(card->card_dev, &card_number_attrs);
+		err = device_create_file(&card->card_dev, &card_number_attrs);
 		if (err < 0)
 			return err;
 	}

commit 393aa9c1cc514774332d7bc861307a76206e358d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 12:51:12 2014 +0100

    ALSA: Mandate to pass a device pointer at card creation time
    
    This is a part of preliminary works for modernizing the ALSA device
    structure.  So far, we set card->dev at later point after the object
    creation.  Because of this, the core layer doesn't always know which
    device is being handled before it's actually registered, and it makes
    impossible to show the device in error messages, for example.  The
    first goal is to achieve a proper struct device initialization at the
    very beginning of probing.
    
    As a first step, this patch introduces snd_card_new() function (yes
    there was the same named function in the very past), in order to
    receive the parent device pointer from the very beginning.
    snd_card_create() is marked as deprecated.
    
    At this point, there is no functional change other than that.  The
    actual change of the device creation scheme will follow later.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index a16d765cdf47..f4d3ac633ff8 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -157,7 +157,8 @@ static int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),
 }
 
 /**
- *  snd_card_create - create and initialize a soundcard structure
+ *  snd_card_new - create and initialize a soundcard structure
+ *  @parent: the parent device object
  *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]
  *  @xid: card identification (ASCII string)
  *  @module: top level module for locking
@@ -172,7 +173,7 @@ static int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),
  *
  *  Return: Zero if successful or a negative error code.
  */
-int snd_card_create(int idx, const char *xid,
+int snd_card_new(struct device *parent, int idx, const char *xid,
 		    struct module *module, int extra_size,
 		    struct snd_card **card_ret)
 {
@@ -213,6 +214,7 @@ int snd_card_create(int idx, const char *xid,
 	if (idx >= snd_ecards_limit)
 		snd_ecards_limit = idx + 1; /* increase the limit */
 	mutex_unlock(&snd_card_mutex);
+	card->dev = parent;
 	card->number = idx;
 	card->module = module;
 	INIT_LIST_HEAD(&card->devices);
@@ -251,7 +253,7 @@ int snd_card_create(int idx, const char *xid,
 	kfree(card);
   	return err;
 }
-EXPORT_SYMBOL(snd_card_create);
+EXPORT_SYMBOL(snd_card_new);
 
 /* return non-zero if a card is already locked */
 int snd_card_locked(int card)

commit 8eeaa2f9e06dcfb45593a0fcd91e81abc7f5d209
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 10 09:48:47 2014 +0100

    ALSA: Replace with IS_ENABLED()
    
    Replace the lengthy #if defined(XXX) || defined(XXX_MODULE) with the
    new IS_ENABLED() macro.
    
    The patch still doesn't cover all ifdefs.  For example, the dependency
    on CONFIG_GAMEPORT is still open-coded because this also has an extra
    dependency on MODULE.  Similarly, an open-coded ifdef in pcm_oss.c and
    some sequencer-related stuff are left untouched.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 0d42fcda0de2..a16d765cdf47 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -94,7 +94,7 @@ static int module_slot_match(struct module *module, int idx)
 	return match;
 }
 
-#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_MIXER_OSS)
 int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);
 EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
 #endif
@@ -394,7 +394,7 @@ int snd_card_disconnect(struct snd_card *card)
 	/* phase 3: notify all connected devices about disconnection */
 	/* at this point, they cannot respond to any calls except release() */
 
-#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_MIXER_OSS)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);
 #endif
@@ -430,7 +430,7 @@ EXPORT_SYMBOL(snd_card_disconnect);
  */
 static int snd_card_do_free(struct snd_card *card)
 {
-#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_MIXER_OSS)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);
 #endif
@@ -723,7 +723,7 @@ int snd_card_register(struct snd_card *card)
 	snd_cards[card->number] = card;
 	mutex_unlock(&snd_card_mutex);
 	init_info_for_card(card);
-#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_MIXER_OSS)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);
 #endif

commit deb6596f163b7340ff8f5a7c23e25317e165c669
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 23 11:02:15 2014 +0100

    ALSA: Refactor slot assignment code
    
    There are two loops that are almost identical but only with different
    checks.  Refactor them with a simple helper, and give a bit more
    comments what's doing there.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index e3c93cd77ee7..0d42fcda0de2 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -131,6 +131,31 @@ static inline int init_info_for_card(struct snd_card *card)
 #define init_info_for_card(card)
 #endif
 
+static int check_empty_slot(struct module *module, int slot)
+{
+	return !slots[slot] || !*slots[slot];
+}
+
+/* return an empty slot number (>= 0) found in the given bitmask @mask.
+ * @mask == -1 == 0xffffffff means: take any free slot up to 32
+ * when no slot is available, return the original @mask as is.
+ */
+static int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),
+				 struct module *module)
+{
+	int slot;
+
+	for (slot = 0; slot < SNDRV_CARDS; slot++) {
+		if (slot < 32 && !(mask & (1U << slot)))
+			continue;
+		if (!test_bit(slot, snd_cards_lock)) {
+			if (check(module, slot))
+				return slot; /* found */
+		}
+	}
+	return mask; /* unchanged */
+}
+
 /**
  *  snd_card_create - create and initialize a soundcard structure
  *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]
@@ -152,7 +177,7 @@ int snd_card_create(int idx, const char *xid,
 		    struct snd_card **card_ret)
 {
 	struct snd_card *card;
-	int err, idx2;
+	int err;
 
 	if (snd_BUG_ON(!card_ret))
 		return -EINVAL;
@@ -167,32 +192,10 @@ int snd_card_create(int idx, const char *xid,
 		strlcpy(card->id, xid, sizeof(card->id));
 	err = 0;
 	mutex_lock(&snd_card_mutex);
-	if (idx < 0) {
-		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++) {
-			/* idx == -1 == 0xffff means: take any free slot */
-			if (idx2 < 32 && !(idx & (1U << idx2)))
-				continue;
-			if (!test_bit(idx2, snd_cards_lock)) {
-				if (module_slot_match(module, idx2)) {
-					idx = idx2;
-					break;
-				}
-			}
-		}
-	}
-	if (idx < 0) {
-		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++) {
-			/* idx == -1 == 0xffff means: take any free slot */
-			if (idx2 < 32 && !(idx & (1U << idx2)))
-				continue;
-			if (!test_bit(idx2, snd_cards_lock)) {
-				if (!slots[idx2] || !*slots[idx2]) {
-					idx = idx2;
-					break;
-				}
-			}
-		}
-	}
+	if (idx < 0) /* first check the matching module-name slot */
+		idx = get_slot_from_bitmask(idx, module_slot_match, module);
+	if (idx < 0) /* if not matched, assign an empty slot */
+		idx = get_slot_from_bitmask(idx, check_empty_slot, module);
 	if (idx < 0)
 		err = -ENODEV;
 	else if (idx < snd_ecards_limit) {

commit 4c3773eda49c872a3034382f8ec3080002e715bf
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jan 23 11:21:28 2014 +0300

    ALSA: bits vs bytes bug in snd_card_create()
    
    The test here is intended intended to prevent shift wrapping bugs when
    we do "1U << idx2".  We should consider the number of bits in a u32
    instead of the number of bytes.
    
    [fix another chunk similarly by tiwai]
    
    Fixes: 7bb2491b35a2 ('ALSA: Add kconfig to specify the max card numbers')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 1351f22f651c..e3c93cd77ee7 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -170,7 +170,7 @@ int snd_card_create(int idx, const char *xid,
 	if (idx < 0) {
 		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++) {
 			/* idx == -1 == 0xffff means: take any free slot */
-			if (idx2 < sizeof(int) && !(idx & (1U << idx2)))
+			if (idx2 < 32 && !(idx & (1U << idx2)))
 				continue;
 			if (!test_bit(idx2, snd_cards_lock)) {
 				if (module_slot_match(module, idx2)) {
@@ -183,7 +183,7 @@ int snd_card_create(int idx, const char *xid,
 	if (idx < 0) {
 		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++) {
 			/* idx == -1 == 0xffff means: take any free slot */
-			if (idx2 < sizeof(int) && !(idx & (1U << idx2)))
+			if (idx2 < 32 && !(idx & (1U << idx2)))
 				continue;
 			if (!test_bit(idx2, snd_cards_lock)) {
 				if (!slots[idx2] || !*slots[idx2]) {

commit 97f44f56ca94709f45bc348f5d2c88696eae5f9b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 29 15:20:06 2013 +0100

    ALSA: Limit the fallback card id string size
    
    When no proper id string is given, the driver tries to fall back to
    copy the proc_root name string via strcpy(), but this might overflow
    the fixed string size.  Let's use strlcpy().
    
    Spotted by coverity CID 139008.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 01a89383a062..1351f22f651c 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -597,7 +597,7 @@ static void snd_card_set_id_no_lock(struct snd_card *card, const char *src,
 	/* last resort... */
 	snd_printk(KERN_ERR "unable to set card id (%s)\n", id);
 	if (card->proc_root->name)
-		strcpy(card->id, card->proc_root->name);
+		strlcpy(card->id, card->proc_root->name, sizeof(card->id));
 }
 
 /**

commit 60f6fef877d52525b8887d27cfacf74a279e3e12
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 28 12:54:52 2013 +0100

    ALSA: Optimize module name check
    
    module->name is a fixed array, so we can check the empty contents
    straightforwardly in module_slot_match().
    
    Spotted by coverity CID 1056786.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 6b9087115da2..01a89383a062 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -66,7 +66,7 @@ static int module_slot_match(struct module *module, int idx)
 #ifdef MODULE
 	const char *s1, *s2;
 
-	if (!module || !module->name || !slots[idx])
+	if (!module || !*module->name || !slots[idx])
 		return 0;
 
 	s1 = module->name;

commit 7bb2491b35a254fe6fd592c32a142a2f2f31fe6e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 15 08:46:39 2013 +0200

    ALSA: Add kconfig to specify the max card numbers
    
    Currently ALSA supports up to 32 card instances when the dynamic minor
    is used.  While 32 cards are usually big enough for normal use cases,
    there are sometimes weird requirements with more card support.
    
    Actually, this limitation, 32, comes from the index option, where you
    can pass the bit mask to assign the card.  Other than that, we can
    actually give more cards up to the minor number limits (currently 256,
    which can be extended more, too).
    
    This patch adds a new Kconfig to specify the max card numbers, and
    changes a few places to accept more than 32 cards.
    
    The only incompatibility with high card numbers would be the handling
    of index option.  The index option can be still used to pass the
    bitmask for card assignments, but this works only up to 32 slots.
    More than 32, no bitmask style option is available but only a single
    slot can be specified via index option.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index ed4a4811b6a1..6b9087115da2 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -46,7 +46,8 @@ static LIST_HEAD(shutdown_files);
 
 static const struct file_operations snd_shutdown_f_ops;
 
-static unsigned int snd_cards_lock;	/* locked for registering/using */
+/* locked for registering/using */
+static DECLARE_BITMAP(snd_cards_lock, SNDRV_CARDS);
 struct snd_card *snd_cards[SNDRV_CARDS];
 EXPORT_SYMBOL(snd_cards);
 
@@ -167,29 +168,35 @@ int snd_card_create(int idx, const char *xid,
 	err = 0;
 	mutex_lock(&snd_card_mutex);
 	if (idx < 0) {
-		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
+		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++) {
 			/* idx == -1 == 0xffff means: take any free slot */
-			if (~snd_cards_lock & idx & 1<<idx2) {
+			if (idx2 < sizeof(int) && !(idx & (1U << idx2)))
+				continue;
+			if (!test_bit(idx2, snd_cards_lock)) {
 				if (module_slot_match(module, idx2)) {
 					idx = idx2;
 					break;
 				}
 			}
+		}
 	}
 	if (idx < 0) {
-		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
+		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++) {
 			/* idx == -1 == 0xffff means: take any free slot */
-			if (~snd_cards_lock & idx & 1<<idx2) {
+			if (idx2 < sizeof(int) && !(idx & (1U << idx2)))
+				continue;
+			if (!test_bit(idx2, snd_cards_lock)) {
 				if (!slots[idx2] || !*slots[idx2]) {
 					idx = idx2;
 					break;
 				}
 			}
+		}
 	}
 	if (idx < 0)
 		err = -ENODEV;
 	else if (idx < snd_ecards_limit) {
-		if (snd_cards_lock & (1 << idx))
+		if (test_bit(idx, snd_cards_lock))
 			err = -EBUSY;	/* invalid */
 	} else if (idx >= SNDRV_CARDS)
 		err = -ENODEV;
@@ -199,7 +206,7 @@ int snd_card_create(int idx, const char *xid,
 			 idx, snd_ecards_limit - 1, err);
 		goto __error;
 	}
-	snd_cards_lock |= 1 << idx;		/* lock it */
+	set_bit(idx, snd_cards_lock);		/* lock it */
 	if (idx >= snd_ecards_limit)
 		snd_ecards_limit = idx + 1; /* increase the limit */
 	mutex_unlock(&snd_card_mutex);
@@ -249,7 +256,7 @@ int snd_card_locked(int card)
 	int locked;
 
 	mutex_lock(&snd_card_mutex);
-	locked = snd_cards_lock & (1 << card);
+	locked = test_bit(card, snd_cards_lock);
 	mutex_unlock(&snd_card_mutex);
 	return locked;
 }
@@ -361,7 +368,7 @@ int snd_card_disconnect(struct snd_card *card)
 	/* phase 1: disable fops (user space) operations for ALSA API */
 	mutex_lock(&snd_card_mutex);
 	snd_cards[card->number] = NULL;
-	snd_cards_lock &= ~(1 << card->number);
+	clear_bit(card->number, snd_cards_lock);
 	mutex_unlock(&snd_card_mutex);
 	
 	/* phase 2: replace file->f_op with special dummy operations */

commit 8edbb198a62e2c3d0bea06ce50a4d45a009849b6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 24 16:30:39 2013 +0200

    ALSA: Fix the default suffix string with high card number
    
    ALSA core tries to add a suffix as "_1" automatically when the given
    id string conflicts.  The current code assumes implicitly that the max
    card number is 16 so that the single hex "_X" suffix can be put.
    However, with the dynamic device management, the card can be at most
    32, so it can put even a non-hex character there.  Also, when the max
    card number is increased in future, this would result in worse.
    
    This patch rewrites the code to add the suffix string in a simpler
    (thus cleaner) way.  It can support up to three digits, so it should
    suffice for most requirements.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 6ef06400dfc8..ed4a4811b6a1 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -549,7 +549,6 @@ static void snd_card_set_id_no_lock(struct snd_card *card, const char *src,
 				    const char *nid)
 {
 	int len, loops;
-	bool with_suffix;
 	bool is_default = false;
 	char *id;
 	
@@ -565,26 +564,23 @@ static void snd_card_set_id_no_lock(struct snd_card *card, const char *src,
 		is_default = true;
 	}
 
-	with_suffix = false;
+	len = strlen(id);
 	for (loops = 0; loops < SNDRV_CARDS; loops++) {
+		char *spos;
+		char sfxstr[5]; /* "_012" */
+		int sfxlen;
+
 		if (card_id_ok(card, id))
 			return; /* OK */
 
-		len = strlen(id);
-		if (!with_suffix) {
-			/* add the "_X" suffix */
-			char *spos = id + len;
-			if (len >  sizeof(card->id) - 3)
-				spos = id + sizeof(card->id) - 3;
-			strcpy(spos, "_1");
-			with_suffix = true;
-		} else {
-			/* modify the existing suffix */
-			if (id[len - 1] != '9')
-				id[len - 1]++;
-			else
-				id[len - 1] = 'A';
-		}
+		/* Add _XYZ suffix */
+		sprintf(sfxstr, "_%X", loops + 1);
+		sfxlen = strlen(sfxstr);
+		if (len + sfxlen >= sizeof(card->id))
+			spos = id + sizeof(card->id) - sfxlen - 1;
+		else
+			spos = id + len;
+		strcpy(spos, sfxstr);
 	}
 	/* fallback to the default id */
 	if (!is_default) {

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 7b012d15c2cf..6ef06400dfc8 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -144,7 +144,7 @@ static inline int init_info_for_card(struct snd_card *card)
  *  space for the driver to use freely.  The allocated struct is stored
  *  in the given card_ret pointer.
  *
- *  Returns zero if successful or a negative error code.
+ *  Return: Zero if successful or a negative error code.
  */
 int snd_card_create(int idx, const char *xid,
 		    struct module *module, int extra_size,
@@ -337,7 +337,7 @@ static const struct file_operations snd_shutdown_f_ops =
  *
  *  Disconnects all APIs from the file-operations (user space).
  *
- *  Returns zero, otherwise a negative error code.
+ *  Return: Zero, otherwise a negative error code.
  *
  *  Note: The current implementation replaces all active file->f_op with special
  *        dummy file operations (they do nothing except release).
@@ -415,7 +415,7 @@ EXPORT_SYMBOL(snd_card_disconnect);
  *  devices automatically.  That is, you don't have to release the devices
  *  by yourself.
  *
- *  Returns zero. Frees all associated devices and frees the control
+ *  Return: Zero. Frees all associated devices and frees the control
  *  interface associated to given soundcard.
  */
 static int snd_card_do_free(struct snd_card *card)
@@ -677,7 +677,7 @@ static struct device_attribute card_number_attrs =
  *  external accesses.  Thus, you should call this function at the end
  *  of the initialization of the card.
  *
- *  Returns zero otherwise a negative error code if the registration failed.
+ *  Return: Zero otherwise a negative error code if the registration failed.
  */
 int snd_card_register(struct snd_card *card)
 {
@@ -849,7 +849,7 @@ int __exit snd_card_info_done(void)
  *  This function adds the component id string to the supported list.
  *  The component can be referred from the alsa-lib.
  *
- *  Returns zero otherwise a negative error code.
+ *  Return: Zero otherwise a negative error code.
  */
   
 int snd_component_add(struct snd_card *card, const char *component)
@@ -883,7 +883,7 @@ EXPORT_SYMBOL(snd_component_add);
  *  This linked-list is used to keep tracking the connection state,
  *  and to avoid the release of busy resources by hotplug.
  *
- *  Returns zero or a negative error code.
+ *  Return: zero or a negative error code.
  */
 int snd_card_file_add(struct snd_card *card, struct file *file)
 {
@@ -920,7 +920,7 @@ EXPORT_SYMBOL(snd_card_file_add);
  *  called beforehand, it processes the pending release of
  *  resources.
  *
- *  Returns zero or a negative error code.
+ *  Return: Zero or a negative error code.
  */
 int snd_card_file_remove(struct snd_card *card, struct file *file)
 {
@@ -959,6 +959,8 @@ EXPORT_SYMBOL(snd_card_file_remove);
  *
  *  Waits until the power-state is changed.
  *
+ *  Return: Zero if successful, or a negative error code.
+ *
  *  Note: the power lock must be active before call.
  */
 int snd_power_wait(struct snd_card *card, unsigned int power_state)

commit a0830dbd4e42b38aefdf3fb61ba5019a1a99ea85
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 16 13:05:59 2012 +0200

    ALSA: Add a reference counter to card instance
    
    For more strict protection for wild disconnections, a refcount is
    introduced to the card instance, and let it up/down when an object is
    referred via snd_lookup_*() in the open ops.
    
    The free-after-last-close check is also changed to check this refcount
    instead of the empty list, too.
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index d8ec849af128..7b012d15c2cf 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -213,6 +213,7 @@ int snd_card_create(int idx, const char *xid,
 	spin_lock_init(&card->files_lock);
 	INIT_LIST_HEAD(&card->files_list);
 	init_waitqueue_head(&card->shutdown_sleep);
+	atomic_set(&card->refcount, 0);
 #ifdef CONFIG_PM
 	mutex_init(&card->power_lock);
 	init_waitqueue_head(&card->power_sleep);
@@ -446,21 +447,36 @@ static int snd_card_do_free(struct snd_card *card)
 	return 0;
 }
 
+/**
+ * snd_card_unref - release the reference counter
+ * @card: the card instance
+ *
+ * Decrements the reference counter.  When it reaches to zero, wake up
+ * the sleeper and call the destructor if needed.
+ */
+void snd_card_unref(struct snd_card *card)
+{
+	if (atomic_dec_and_test(&card->refcount)) {
+		wake_up(&card->shutdown_sleep);
+		if (card->free_on_last_close)
+			snd_card_do_free(card);
+	}
+}
+EXPORT_SYMBOL(snd_card_unref);
+
 int snd_card_free_when_closed(struct snd_card *card)
 {
-	int free_now = 0;
-	int ret = snd_card_disconnect(card);
-	if (ret)
-		return ret;
+	int ret;
 
-	spin_lock(&card->files_lock);
-	if (list_empty(&card->files_list))
-		free_now = 1;
-	else
-		card->free_on_last_close = 1;
-	spin_unlock(&card->files_lock);
+	atomic_inc(&card->refcount);
+	ret = snd_card_disconnect(card);
+	if (ret) {
+		atomic_dec(&card->refcount);
+		return ret;
+	}
 
-	if (free_now)
+	card->free_on_last_close = 1;
+	if (atomic_dec_and_test(&card->refcount))
 		snd_card_do_free(card);
 	return 0;
 }
@@ -474,7 +490,7 @@ int snd_card_free(struct snd_card *card)
 		return ret;
 
 	/* wait, until all devices are ready for the free operation */
-	wait_event(card->shutdown_sleep, list_empty(&card->files_list));
+	wait_event(card->shutdown_sleep, !atomic_read(&card->refcount));
 	snd_card_do_free(card);
 	return 0;
 }
@@ -886,6 +902,7 @@ int snd_card_file_add(struct snd_card *card, struct file *file)
 		return -ENODEV;
 	}
 	list_add(&mfile->list, &card->files_list);
+	atomic_inc(&card->refcount);
 	spin_unlock(&card->files_lock);
 	return 0;
 }
@@ -908,7 +925,6 @@ EXPORT_SYMBOL(snd_card_file_add);
 int snd_card_file_remove(struct snd_card *card, struct file *file)
 {
 	struct snd_monitor_file *mfile, *found = NULL;
-	int last_close = 0;
 
 	spin_lock(&card->files_lock);
 	list_for_each_entry(mfile, &card->files_list, list) {
@@ -923,19 +939,13 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 			break;
 		}
 	}
-	if (list_empty(&card->files_list))
-		last_close = 1;
 	spin_unlock(&card->files_lock);
-	if (last_close) {
-		wake_up(&card->shutdown_sleep);
-		if (card->free_on_last_close)
-			snd_card_do_free(card);
-	}
 	if (!found) {
 		snd_printk(KERN_ERR "ALSA card file remove problem (%p)\n", file);
 		return -ENOENT;
 	}
 	kfree(found);
+	snd_card_unref(card);
 	return 0;
 }
 

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit 51990e825431089747f8896244b5c17d3a6423f1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jan 22 11:23:42 2012 -0500

    device.h: cleanup users outside of linux/include (C files)
    
    For files that are actively using linux/device.h, make sure
    that they call it out.  This will allow us to clean up some
    of the implicit uses of linux/device.h within include/*
    without introducing build regressions.
    
    Yes, this was created by "cheating" -- i.e. the headers were
    cleaned up, and then the fallout was found and fixed, and then
    the two commits were reordered.  This ensures we don't introduce
    build regressions into the git history.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/init.c b/sound/core/init.c
index 3ac49b1b7cb8..995fc5d4b1a3 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/module.h>
+#include <linux/device.h>
 #include <linux/file.h>
 #include <linux/slab.h>
 #include <linux/time.h>

commit e7df2a3ae569ed6d178510f58b22308edac7a4c7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 9 17:41:53 2012 +0100

    ALSA: core - Refactor card id string creation code
    
    The code to handle the card id string is fairly messy, so here is a
    tidy up.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 3ac49b1b7cb8..068cf08d3ffb 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -480,74 +480,104 @@ int snd_card_free(struct snd_card *card)
 
 EXPORT_SYMBOL(snd_card_free);
 
-static void snd_card_set_id_no_lock(struct snd_card *card, const char *nid)
+/* retrieve the last word of shortname or longname */
+static const char *retrieve_id_from_card_name(const char *name)
 {
-	int i, len, idx_flag = 0, loops = SNDRV_CARDS;
-	const char *spos, *src;
-	char *id;
-	
-	if (nid == NULL) {
-		id = card->shortname;
-		spos = src = id;
-		while (*id != '\0') {
-			if (*id == ' ')
-				spos = id + 1;
-			id++;
-		}
-	} else {
-		spos = src = nid;
+	const char *spos = name;
+
+	while (*name) {
+		if (isspace(*name) && isalnum(name[1]))
+			spos = name + 1;
+		name++;
 	}
-	id = card->id;
-	while (*spos != '\0' && !isalnum(*spos))
-		spos++;
-	if (isdigit(*spos))
-		*id++ = isalpha(src[0]) ? src[0] : 'D';
-	while (*spos != '\0' && (size_t)(id - card->id) < sizeof(card->id) - 1) {
-		if (isalnum(*spos))
-			*id++ = *spos;
-		spos++;
+	return spos;
+}
+
+/* return true if the given id string doesn't conflict any other card ids */
+static bool card_id_ok(struct snd_card *card, const char *id)
+{
+	int i;
+	if (!snd_info_check_reserved_words(id))
+		return false;
+	for (i = 0; i < snd_ecards_limit; i++) {
+		if (snd_cards[i] && snd_cards[i] != card &&
+		    !strcmp(snd_cards[i]->id, id))
+			return false;
 	}
-	*id = '\0';
+	return true;
+}
 
-	id = card->id;
+/* copy to card->id only with valid letters from nid */
+static void copy_valid_id_string(struct snd_card *card, const char *src,
+				 const char *nid)
+{
+	char *id = card->id;
+
+	while (*nid && !isalnum(*nid))
+		nid++;
+	if (isdigit(*nid))
+		*id++ = isalpha(*src) ? *src : 'D';
+	while (*nid && (size_t)(id - card->id) < sizeof(card->id) - 1) {
+		if (isalnum(*nid))
+			*id++ = *nid;
+		nid++;
+	}
+	*id = 0;
+}
+
+/* Set card->id from the given string
+ * If the string conflicts with other ids, add a suffix to make it unique.
+ */
+static void snd_card_set_id_no_lock(struct snd_card *card, const char *src,
+				    const char *nid)
+{
+	int len, loops;
+	bool with_suffix;
+	bool is_default = false;
+	char *id;
 	
-	if (*id == '\0')
+	copy_valid_id_string(card, src, nid);
+	id = card->id;
+
+ again:
+	/* use "Default" for obviously invalid strings
+	 * ("card" conflicts with proc directories)
+	 */
+	if (!*id || !strncmp(id, "card", 4)) {
 		strcpy(id, "Default");
+		is_default = true;
+	}
 
-	while (1) {
-	      	if (loops-- == 0) {
-			snd_printk(KERN_ERR "unable to set card id (%s)\n", id);
-      			strcpy(card->id, card->proc_root->name);
-      			return;
-      		}
-	      	if (!snd_info_check_reserved_words(id))
-      			goto __change;
-		for (i = 0; i < snd_ecards_limit; i++) {
-			if (snd_cards[i] && !strcmp(snd_cards[i]->id, id))
-				goto __change;
-		}
-		break;
+	with_suffix = false;
+	for (loops = 0; loops < SNDRV_CARDS; loops++) {
+		if (card_id_ok(card, id))
+			return; /* OK */
 
-	      __change:
 		len = strlen(id);
-		if (idx_flag) {
-			if (id[len-1] != '9')
-				id[len-1]++;
-			else
-				id[len-1] = 'A';
-		} else if ((size_t)len <= sizeof(card->id) - 3) {
-			strcat(id, "_1");
-			idx_flag++;
+		if (!with_suffix) {
+			/* add the "_X" suffix */
+			char *spos = id + len;
+			if (len >  sizeof(card->id) - 3)
+				spos = id + sizeof(card->id) - 3;
+			strcpy(spos, "_1");
+			with_suffix = true;
 		} else {
-			spos = id + len - 2;
-			if ((size_t)len <= sizeof(card->id) - 2)
-				spos++;
-			*(char *)spos++ = '_';
-			*(char *)spos++ = '1';
-			*(char *)spos++ = '\0';
-			idx_flag++;
+			/* modify the existing suffix */
+			if (id[len - 1] != '9')
+				id[len - 1]++;
+			else
+				id[len - 1] = 'A';
 		}
 	}
+	/* fallback to the default id */
+	if (!is_default) {
+		*id = 0;
+		goto again;
+	}
+	/* last resort... */
+	snd_printk(KERN_ERR "unable to set card id (%s)\n", id);
+	if (card->proc_root->name)
+		strcpy(card->id, card->proc_root->name);
 }
 
 /**
@@ -564,7 +594,7 @@ void snd_card_set_id(struct snd_card *card, const char *nid)
 	if (card->id[0] != '\0')
 		return;
 	mutex_lock(&snd_card_mutex);
-	snd_card_set_id_no_lock(card, nid);
+	snd_card_set_id_no_lock(card, nid, nid);
 	mutex_unlock(&snd_card_mutex);
 }
 EXPORT_SYMBOL(snd_card_set_id);
@@ -596,22 +626,12 @@ card_id_store_attr(struct device *dev, struct device_attribute *attr,
 	memcpy(buf1, buf, copy);
 	buf1[copy] = '\0';
 	mutex_lock(&snd_card_mutex);
-	if (!snd_info_check_reserved_words(buf1)) {
-	     __exist:
+	if (!card_id_ok(NULL, buf1)) {
 		mutex_unlock(&snd_card_mutex);
 		return -EEXIST;
 	}
-	for (idx = 0; idx < snd_ecards_limit; idx++) {
-		if (snd_cards[idx] && !strcmp(snd_cards[idx]->id, buf1)) {
-			if (card == snd_cards[idx])
-				goto __ok;
-			else
-				goto __exist;
-		}
-	}
 	strcpy(card->id, buf1);
 	snd_info_card_id_change(card);
-__ok:
 	mutex_unlock(&snd_card_mutex);
 
 	return count;
@@ -665,7 +685,18 @@ int snd_card_register(struct snd_card *card)
 		mutex_unlock(&snd_card_mutex);
 		return 0;
 	}
-	snd_card_set_id_no_lock(card, card->id[0] == '\0' ? NULL : card->id);
+	if (*card->id) {
+		/* make a unique id name from the given string */
+		char tmpid[sizeof(card->id)];
+		memcpy(tmpid, card->id, sizeof(card->id));
+		snd_card_set_id_no_lock(card, tmpid, tmpid);
+	} else {
+		/* create an id from either shortname or longname */
+		const char *src;
+		src = *card->shortname ? card->shortname : card->longname;
+		snd_card_set_id_no_lock(card, src,
+					retrieve_id_from_card_name(src));
+	}
 	snd_cards[card->number] = card;
 	mutex_unlock(&snd_card_mutex);
 	init_info_for_card(card);

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/init.c b/sound/core/init.c
index 2c041bb36ab3..3ac49b1b7cb8 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -21,6 +21,7 @@
 
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/module.h>
 #include <linux/file.h>
 #include <linux/slab.h>
 #include <linux/time.h>

commit 78fa2c4d2465d014e67d3e12d948425856587251
Author: Luca Tettamanti <kronos.it@gmail.com>
Date:   Wed May 25 22:43:27 2011 +0200

    ALSA: core: remove unused variables.
    
    Drop a few variables that are never read.
    
    Signed-off-by: Luca Tettamanti <kronos.it@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 30ecad41403c..2c041bb36ab3 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -342,7 +342,6 @@ static const struct file_operations snd_shutdown_f_ops =
 int snd_card_disconnect(struct snd_card *card)
 {
 	struct snd_monitor_file *mfile;
-	struct file *file;
 	int err;
 
 	if (!card)
@@ -366,8 +365,6 @@ int snd_card_disconnect(struct snd_card *card)
 	
 	spin_lock(&card->files_lock);
 	list_for_each_entry(mfile, &card->files_list, list) {
-		file = mfile->file;
-
 		/* it's critical part, use endless loop */
 		/* we have no room to fail */
 		mfile->disconnected_f_op = mfile->file->f_op;

commit d8e4f9aed82c68b60f81b2e7977c46868d51062f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 4 12:43:23 2011 +0200

    ALSA: core - Don't use "default' for default
    
    The card-id parser assigns the string "default" when no appropriate word
    is found in the card name.  But this string may confuse the alsa-lib, so
    better to avoid.  Use "Default" now instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index a0080aa45ae9..30ecad41403c 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -514,7 +514,7 @@ static void snd_card_set_id_no_lock(struct snd_card *card, const char *nid)
 	id = card->id;
 	
 	if (*id == '\0')
-		strcpy(id, "default");
+		strcpy(id, "Default");
 
 	while (1) {
 	      	if (loops-- == 0) {

commit a45e3d6b13e97506b616980c0f122c3389bcefa4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 24 09:50:15 2011 +0100

    ALSA: Fix yet another race in disconnection
    
    This patch fixes a race between snd_card_file_remove() and
    snd_card_disconnect().  When the card is added to shutdown_files list
    in snd_card_disconnect(), but it's freed in snd_card_file_remove() at
    the same time, the shutdown_files list gets corrupted.  The list member
    must be freed in snd_card_file_remove() as well.
    
    Reported-and-tested-by: Russ Dill <russ.dill@gmail.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 3e65da21a08c..a0080aa45ae9 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -848,6 +848,7 @@ int snd_card_file_add(struct snd_card *card, struct file *file)
 		return -ENOMEM;
 	mfile->file = file;
 	mfile->disconnected_f_op = NULL;
+	INIT_LIST_HEAD(&mfile->shutdown_list);
 	spin_lock(&card->files_lock);
 	if (card->shutdown) {
 		spin_unlock(&card->files_lock);
@@ -883,6 +884,9 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 	list_for_each_entry(mfile, &card->files_list, list) {
 		if (mfile->file == file) {
 			list_del(&mfile->list);
+			spin_lock(&shutdown_lock);
+			list_del(&mfile->shutdown_list);
+			spin_unlock(&shutdown_lock);
 			if (mfile->disconnected_f_op)
 				fops_put(mfile->disconnected_f_op);
 			found = mfile;

commit b595076a180a56d1bb170e6eceda6eb9d76f4cd3
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Mon Nov 1 15:38:34 2010 -0400

    tree-wide: fix comment/printk typos
    
    "gadget", "through", "command", "maintain", "maintain", "controller", "address",
    "between", "initiali[zs]e", "instead", "function", "select", "already",
    "equal", "access", "management", "hierarchy", "registration", "interest",
    "relative", "memory", "offset", "already",
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index 57b792e2439a..3e65da21a08c 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -642,7 +642,7 @@ static struct device_attribute card_number_attrs =
  *  external accesses.  Thus, you should call this function at the end
  *  of the initialization of the card.
  *
- *  Returns zero otherwise a negative error code if the registrain failed.
+ *  Returns zero otherwise a negative error code if the registration failed.
  */
 int snd_card_register(struct snd_card *card)
 {

commit 33081adf8b89d5a716d7e1c60171768d39795b39
Merge: c55960499f81 506ecbca71d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 25 08:32:05 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6: (365 commits)
      ALSA: hda - Disable sticky PCM stream assignment for AD codecs
      ALSA: usb - Creative USB X-Fi volume knob support
      ALSA: ca0106: Use card specific dac id for mute controls.
      ALSA: ca0106: Allow different sound cards to use different SPI channel mappings.
      ALSA: ca0106: Create a nice spot for mapping channels to dacs.
      ALSA: ca0106: Move enabling of front dac out of hardcoded setup sequence.
      ALSA: ca0106: Pull out dac powering routine into separate function.
      ALSA: ca0106 - add Sound Blaster 5.1vx info.
      ASoC: tlv320dac33: Use usleep_range for delays
      ALSA: usb-audio: add Novation Launchpad support
      ALSA: hda - Add workarounds for CT-IBG controllers
      ALSA: hda - Fix wrong TLV mute bit for STAC/IDT codecs
      ASoC: tpa6130a2: Error handling for broken chip
      ASoC: max98088: Staticise m98088_eq_band
      ASoC: soc-core: Fix codec->name memory leak
      ALSA: hda - Apply ideapad quirk to Acer laptops with Cxt5066
      ALSA: hda - Add some workarounds for Creative IBG
      ALSA: hda - Fix wrong SPDIF NID assignment for CA0110
      ALSA: hda - Fix codec rename rules for ALC662-compatible codecs
      ALSA: hda - Add alc_init_jacks() call to other codecs
      ...

commit 39aba963d937edb20db7d9d93e6dda5d2adfdcdd
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Sep 4 22:33:14 2010 -0700

    driver core: remove CONFIG_SYSFS_DEPRECATED_V2 but keep it for block devices
    
    This patch removes the old CONFIG_SYSFS_DEPRECATED_V2 config option,
    but it keeps the logic around to handle block devices in the old manner
    as some people like to run new kernel versions on old (pre 2007/2008)
    distros.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: "James E.J. Bottomley" <James.Bottomley@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index ec4a50ce5656..f7c3df8b521b 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -395,12 +395,10 @@ int snd_card_disconnect(struct snd_card *card)
 		snd_printk(KERN_ERR "not all devices for card %i can be disconnected\n", card->number);
 
 	snd_info_card_disconnect(card);
-#ifndef CONFIG_SYSFS_DEPRECATED
 	if (card->card_dev) {
 		device_unregister(card->card_dev);
 		card->card_dev = NULL;
 	}
-#endif
 #ifdef CONFIG_PM
 	wake_up(&card->power_sleep);
 #endif
@@ -573,7 +571,6 @@ void snd_card_set_id(struct snd_card *card, const char *nid)
 }
 EXPORT_SYMBOL(snd_card_set_id);
 
-#ifndef CONFIG_SYSFS_DEPRECATED
 static ssize_t
 card_id_show_attr(struct device *dev,
 		  struct device_attribute *attr, char *buf)
@@ -630,7 +627,6 @@ card_number_show_attr(struct device *dev,
 
 static struct device_attribute card_number_attrs =
 	__ATTR(number, S_IRUGO, card_number_show_attr, NULL);
-#endif /* CONFIG_SYSFS_DEPRECATED */
 
 /**
  *  snd_card_register - register the soundcard
@@ -649,7 +645,7 @@ int snd_card_register(struct snd_card *card)
 
 	if (snd_BUG_ON(!card))
 		return -EINVAL;
-#ifndef CONFIG_SYSFS_DEPRECATED
+
 	if (!card->card_dev) {
 		card->card_dev = device_create(sound_class, card->dev,
 					       MKDEV(0, 0), card,
@@ -657,7 +653,7 @@ int snd_card_register(struct snd_card *card)
 		if (IS_ERR(card->card_dev))
 			card->card_dev = NULL;
 	}
-#endif
+
 	if ((err = snd_device_register_all(card)) < 0)
 		return err;
 	mutex_lock(&snd_card_mutex);
@@ -674,7 +670,6 @@ int snd_card_register(struct snd_card *card)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);
 #endif
-#ifndef CONFIG_SYSFS_DEPRECATED
 	if (card->card_dev) {
 		err = device_create_file(card->card_dev, &card_id_attrs);
 		if (err < 0)
@@ -683,7 +678,7 @@ int snd_card_register(struct snd_card *card)
 		if (err < 0)
 			return err;
 	}
-#endif
+
 	return 0;
 }
 

commit 4437ecdc7190302ed02fb1467c116aff29c325b2
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Thu Sep 16 10:26:54 2010 +0300

    ALSA: core: Allow card id change to the same string
    
    When user want to change the card id to the same string
    on the card via /sys/class/sound/cardX/id, do not
    report error. Instead return with success without
    doing anything.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index ec4a50ce5656..2de45fbd70fb 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -607,11 +607,16 @@ card_id_store_attr(struct device *dev, struct device_attribute *attr,
 		return -EEXIST;
 	}
 	for (idx = 0; idx < snd_ecards_limit; idx++) {
-		if (snd_cards[idx] && !strcmp(snd_cards[idx]->id, buf1))
-			goto __exist;
+		if (snd_cards[idx] && !strcmp(snd_cards[idx]->id, buf1)) {
+			if (card == snd_cards[idx])
+				goto __ok;
+			else
+				goto __exist;
+		}
 	}
 	strcpy(card->id, buf1);
 	snd_info_card_id_change(card);
+__ok:
 	mutex_unlock(&snd_card_mutex);
 
 	return count;

commit 82a783f4bcb878e6c4f02e24c7cd0687bdea7443
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 7 15:50:18 2009 +0200

    ALSA: Remove struct snd_monitor_file from public sound/core.h
    
    The struct snd_monitor_file is used locally only in sound/core/init.c,
    thus it should be moved there from the public sound/core.h.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index d5d40d78c409..ec4a50ce5656 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -31,6 +31,14 @@
 #include <sound/control.h>
 #include <sound/info.h>
 
+/* monitor files for graceful shutdown (hotplug) */
+struct snd_monitor_file {
+	struct file *file;
+	const struct file_operations *disconnected_f_op;
+	struct list_head shutdown_list;	/* still need to shutdown */
+	struct list_head list;	/* link of monitor files */
+};
+
 static DEFINE_SPINLOCK(shutdown_lock);
 static LIST_HEAD(shutdown_files);
 

commit 5fdc18d938c99399b73fe894bc24cb9400a1a2ee
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Jun 4 00:12:18 2009 +0200

    ALSA: Core - clean up snd_card_set_id* calls and remove possible id collision
    
    Move locking outside snd_card_set_id_internal() function and rename it
    to snd_card_set_id_no_lock() for better function description.
    
    User defined id is just copied to card structure at allocation time.
    The real unique id procedure is called in snd_card_register() to
    ensure real atomicity.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index a578d05f9e13..d5d40d78c409 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -153,7 +153,7 @@ int snd_card_create(int idx, const char *xid,
 	if (!card)
 		return -ENOMEM;
 	if (xid)
-		snd_card_set_id(card, xid);
+		strlcpy(card->id, xid, sizeof(card->id));
 	err = 0;
 	mutex_lock(&snd_card_mutex);
 	if (idx < 0) {
@@ -476,16 +476,12 @@ int snd_card_free(struct snd_card *card)
 
 EXPORT_SYMBOL(snd_card_free);
 
-static void snd_card_set_id_internal(struct snd_card *card, const char *nid,
-				     int do_locking)
+static void snd_card_set_id_no_lock(struct snd_card *card, const char *nid)
 {
 	int i, len, idx_flag = 0, loops = SNDRV_CARDS;
 	const char *spos, *src;
 	char *id;
 	
-	/* check if user specified own card->id */
-	if (card->id[0] != '\0')
-		return;
 	if (nid == NULL) {
 		id = card->shortname;
 		spos = src = id;
@@ -522,16 +518,10 @@ static void snd_card_set_id_internal(struct snd_card *card, const char *nid,
       		}
 	      	if (!snd_info_check_reserved_words(id))
       			goto __change;
-		if (do_locking)
-			mutex_lock(&snd_card_mutex);
 		for (i = 0; i < snd_ecards_limit; i++) {
-			if (snd_cards[i] && !strcmp(snd_cards[i]->id, id)) {
-				mutex_unlock(&snd_card_mutex);
+			if (snd_cards[i] && !strcmp(snd_cards[i]->id, id))
 				goto __change;
-			}
 		}
-		if (do_locking)
-			mutex_unlock(&snd_card_mutex);
 		break;
 
 	      __change:
@@ -566,7 +556,12 @@ static void snd_card_set_id_internal(struct snd_card *card, const char *nid,
  */
 void snd_card_set_id(struct snd_card *card, const char *nid)
 {
-	snd_card_set_id_internal(card, nid, 1);
+	/* check if user specified own card->id */
+	if (card->id[0] != '\0')
+		return;
+	mutex_lock(&snd_card_mutex);
+	snd_card_set_id_no_lock(card, nid);
+	mutex_unlock(&snd_card_mutex);
 }
 EXPORT_SYMBOL(snd_card_set_id);
 
@@ -663,8 +658,7 @@ int snd_card_register(struct snd_card *card)
 		mutex_unlock(&snd_card_mutex);
 		return 0;
 	}
-	if (card->id[0] == '\0')
-		snd_card_set_id_internal(card, NULL, 0);
+	snd_card_set_id_no_lock(card, card->id[0] == '\0' ? NULL : card->id);
 	snd_cards[card->number] = card;
 	mutex_unlock(&snd_card_mutex);
 	init_info_for_card(card);

commit 872c78202c58d26596e25743791ee81a7d24abad
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jun 3 20:43:29 2009 +0100

    ALSA: Fix double locking of card list in snd_card_register()
    
    The introduction of snd_card_set_id() added a lock on the card list
    to the old choose_default_id() function when using it to implement
    the new API call. This lock is needed to allow us to walk the list
    and check to see if our new name is a duplicate. Unfortunately this
    causes a lockup when called from snd_card_register() (in cases
    where no ID is supplied for the card) since the card list is already
    locked there.
    
    Fix this fairly hideously by factoring out the implementation and
    using a flag to indicate if the lock should be held. A better fix
    would probably be to refactor snd_card_register() to move the
    _set_id() outside the locking region but I can't immediately see
    anything I can convince myself is safe.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 6557dd85e191..a578d05f9e13 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -476,15 +476,8 @@ int snd_card_free(struct snd_card *card)
 
 EXPORT_SYMBOL(snd_card_free);
 
-/**
- *  snd_card_set_id - set card identification name
- *  @card: soundcard structure
- *  @nid: new identification string
- *
- *  This function sets the card identification and checks for name
- *  collisions.
- */
-void snd_card_set_id(struct snd_card *card, const char *nid)
+static void snd_card_set_id_internal(struct snd_card *card, const char *nid,
+				     int do_locking)
 {
 	int i, len, idx_flag = 0, loops = SNDRV_CARDS;
 	const char *spos, *src;
@@ -529,14 +522,16 @@ void snd_card_set_id(struct snd_card *card, const char *nid)
       		}
 	      	if (!snd_info_check_reserved_words(id))
       			goto __change;
-		mutex_lock(&snd_card_mutex);
+		if (do_locking)
+			mutex_lock(&snd_card_mutex);
 		for (i = 0; i < snd_ecards_limit; i++) {
 			if (snd_cards[i] && !strcmp(snd_cards[i]->id, id)) {
 				mutex_unlock(&snd_card_mutex);
 				goto __change;
 			}
 		}
-		mutex_unlock(&snd_card_mutex);
+		if (do_locking)
+			mutex_unlock(&snd_card_mutex);
 		break;
 
 	      __change:
@@ -561,6 +556,18 @@ void snd_card_set_id(struct snd_card *card, const char *nid)
 	}
 }
 
+/**
+ *  snd_card_set_id - set card identification name
+ *  @card: soundcard structure
+ *  @nid: new identification string
+ *
+ *  This function sets the card identification and checks for name
+ *  collisions.
+ */
+void snd_card_set_id(struct snd_card *card, const char *nid)
+{
+	snd_card_set_id_internal(card, nid, 1);
+}
 EXPORT_SYMBOL(snd_card_set_id);
 
 #ifndef CONFIG_SYSFS_DEPRECATED
@@ -657,7 +664,7 @@ int snd_card_register(struct snd_card *card)
 		return 0;
 	}
 	if (card->id[0] == '\0')
-		snd_card_set_id(card, NULL);
+		snd_card_set_id_internal(card, NULL, 0);
 	snd_cards[card->number] = card;
 	mutex_unlock(&snd_card_mutex);
 	init_info_for_card(card);

commit 10a8ebbb08c4b08292598947bbe534e04d6ee705
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Jun 2 12:02:38 2009 +0200

    ALSA: Core - add snd_card_set_id() function
    
    Introduce snd_card_set_id() function to allow lowlevel drivers to set
    default identification name for card slot. The function checks also
    for identification name collisions and tries to create unique name.
    
    Also, the snd_card_create() function is simplified, because this new
    function is used. As bonus, proper name collision checks are evaluated
    at the card create time.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index fd56afe846ed..6557dd85e191 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -152,15 +152,8 @@ int snd_card_create(int idx, const char *xid,
 	card = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);
 	if (!card)
 		return -ENOMEM;
-	if (xid) {
-		if (!snd_info_check_reserved_words(xid)) {
-			snd_printk(KERN_ERR
-				   "given id string '%s' is reserved.\n", xid);
-			err = -EBUSY;
-			goto __error;
-		}
-		strlcpy(card->id, xid, sizeof(card->id));
-	}
+	if (xid)
+		snd_card_set_id(card, xid);
 	err = 0;
 	mutex_lock(&snd_card_mutex);
 	if (idx < 0) {
@@ -483,22 +476,39 @@ int snd_card_free(struct snd_card *card)
 
 EXPORT_SYMBOL(snd_card_free);
 
-static void choose_default_id(struct snd_card *card)
+/**
+ *  snd_card_set_id - set card identification name
+ *  @card: soundcard structure
+ *  @nid: new identification string
+ *
+ *  This function sets the card identification and checks for name
+ *  collisions.
+ */
+void snd_card_set_id(struct snd_card *card, const char *nid)
 {
 	int i, len, idx_flag = 0, loops = SNDRV_CARDS;
-	char *id, *spos;
+	const char *spos, *src;
+	char *id;
 	
-	id = spos = card->shortname;	
-	while (*id != '\0') {
-		if (*id == ' ')
-			spos = id + 1;
-		id++;
+	/* check if user specified own card->id */
+	if (card->id[0] != '\0')
+		return;
+	if (nid == NULL) {
+		id = card->shortname;
+		spos = src = id;
+		while (*id != '\0') {
+			if (*id == ' ')
+				spos = id + 1;
+			id++;
+		}
+	} else {
+		spos = src = nid;
 	}
 	id = card->id;
 	while (*spos != '\0' && !isalnum(*spos))
 		spos++;
 	if (isdigit(*spos))
-		*id++ = isalpha(card->shortname[0]) ? card->shortname[0] : 'D';
+		*id++ = isalpha(src[0]) ? src[0] : 'D';
 	while (*spos != '\0' && (size_t)(id - card->id) < sizeof(card->id) - 1) {
 		if (isalnum(*spos))
 			*id++ = *spos;
@@ -513,16 +523,20 @@ static void choose_default_id(struct snd_card *card)
 
 	while (1) {
 	      	if (loops-- == 0) {
-      			snd_printk(KERN_ERR "unable to choose default card id (%s)\n", id);
+			snd_printk(KERN_ERR "unable to set card id (%s)\n", id);
       			strcpy(card->id, card->proc_root->name);
       			return;
       		}
 	      	if (!snd_info_check_reserved_words(id))
       			goto __change;
+		mutex_lock(&snd_card_mutex);
 		for (i = 0; i < snd_ecards_limit; i++) {
-			if (snd_cards[i] && !strcmp(snd_cards[i]->id, id))
+			if (snd_cards[i] && !strcmp(snd_cards[i]->id, id)) {
+				mutex_unlock(&snd_card_mutex);
 				goto __change;
+			}
 		}
+		mutex_unlock(&snd_card_mutex);
 		break;
 
 	      __change:
@@ -539,14 +553,16 @@ static void choose_default_id(struct snd_card *card)
 			spos = id + len - 2;
 			if ((size_t)len <= sizeof(card->id) - 2)
 				spos++;
-			*spos++ = '_';
-			*spos++ = '1';
-			*spos++ = '\0';
+			*(char *)spos++ = '_';
+			*(char *)spos++ = '1';
+			*(char *)spos++ = '\0';
 			idx_flag++;
 		}
 	}
 }
 
+EXPORT_SYMBOL(snd_card_set_id);
+
 #ifndef CONFIG_SYSFS_DEPRECATED
 static ssize_t
 card_id_show_attr(struct device *dev,
@@ -641,7 +657,7 @@ int snd_card_register(struct snd_card *card)
 		return 0;
 	}
 	if (card->id[0] == '\0')
-		choose_default_id(card);
+		snd_card_set_id(card, NULL);
 	snd_cards[card->number] = card;
 	mutex_unlock(&snd_card_mutex);
 	init_info_for_card(card);

commit 65b3864b85485a91f70988e1a222e3935bce87e4
Merge: bafdb7278cb6 118dd6bfe7e0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:45 2009 +0100

    Merge branch 'topic/ctl-list-cleanup' into for-linus

commit 118dd6bfe7e0cddc8ab417ead19cc76000e92773
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 23 16:35:21 2009 +0100

    ALSA: Clean up snd_monitor_file management
    
    Use the standard linked list for snd_monitor_file management.
    Also, move the list deletion of shutdown_list element into
    snd_disconnect_release() (for simplification).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 0d5520c415d3..05c6da554cbf 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -195,6 +195,7 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 	INIT_LIST_HEAD(&card->controls);
 	INIT_LIST_HEAD(&card->ctl_files);
 	spin_lock_init(&card->files_lock);
+	INIT_LIST_HEAD(&card->files_list);
 	init_waitqueue_head(&card->shutdown_sleep);
 #ifdef CONFIG_PM
 	mutex_init(&card->power_lock);
@@ -259,6 +260,7 @@ static int snd_disconnect_release(struct inode *inode, struct file *file)
 	list_for_each_entry(_df, &shutdown_files, shutdown_list) {
 		if (_df->file == file) {
 			df = _df;
+			list_del_init(&df->shutdown_list);
 			break;
 		}
 	}
@@ -347,8 +349,7 @@ int snd_card_disconnect(struct snd_card *card)
 	/* phase 2: replace file->f_op with special dummy operations */
 	
 	spin_lock(&card->files_lock);
-	mfile = card->files;
-	while (mfile) {
+	list_for_each_entry(mfile, &card->files_list, list) {
 		file = mfile->file;
 
 		/* it's critical part, use endless loop */
@@ -361,8 +362,6 @@ int snd_card_disconnect(struct snd_card *card)
 
 		mfile->file->f_op = &snd_shutdown_f_ops;
 		fops_get(mfile->file->f_op);
-		
-		mfile = mfile->next;
 	}
 	spin_unlock(&card->files_lock);	
 
@@ -442,7 +441,7 @@ int snd_card_free_when_closed(struct snd_card *card)
 		return ret;
 
 	spin_lock(&card->files_lock);
-	if (card->files == NULL)
+	if (list_empty(&card->files_list))
 		free_now = 1;
 	else
 		card->free_on_last_close = 1;
@@ -462,7 +461,7 @@ int snd_card_free(struct snd_card *card)
 		return ret;
 
 	/* wait, until all devices are ready for the free operation */
-	wait_event(card->shutdown_sleep, card->files == NULL);
+	wait_event(card->shutdown_sleep, list_empty(&card->files_list));
 	snd_card_do_free(card);
 	return 0;
 }
@@ -809,15 +808,13 @@ int snd_card_file_add(struct snd_card *card, struct file *file)
 		return -ENOMEM;
 	mfile->file = file;
 	mfile->disconnected_f_op = NULL;
-	mfile->next = NULL;
 	spin_lock(&card->files_lock);
 	if (card->shutdown) {
 		spin_unlock(&card->files_lock);
 		kfree(mfile);
 		return -ENODEV;
 	}
-	mfile->next = card->files;
-	card->files = mfile;
+	list_add(&mfile->list, &card->files_list);
 	spin_unlock(&card->files_lock);
 	return 0;
 }
@@ -839,29 +836,20 @@ EXPORT_SYMBOL(snd_card_file_add);
  */
 int snd_card_file_remove(struct snd_card *card, struct file *file)
 {
-	struct snd_monitor_file *mfile, *pfile = NULL;
+	struct snd_monitor_file *mfile, *found = NULL;
 	int last_close = 0;
 
 	spin_lock(&card->files_lock);
-	mfile = card->files;
-	while (mfile) {
+	list_for_each_entry(mfile, &card->files_list, list) {
 		if (mfile->file == file) {
-			if (pfile)
-				pfile->next = mfile->next;
-			else
-				card->files = mfile->next;
+			list_del(&mfile->list);
+			if (mfile->disconnected_f_op)
+				fops_put(mfile->disconnected_f_op);
+			found = mfile;
 			break;
 		}
-		pfile = mfile;
-		mfile = mfile->next;
-	}
-	if (mfile && mfile->disconnected_f_op) {
-		fops_put(mfile->disconnected_f_op);
-		spin_lock(&shutdown_lock);
-		list_del(&mfile->shutdown_list);
-		spin_unlock(&shutdown_lock);
 	}
-	if (card->files == NULL)
+	if (list_empty(&card->files_list))
 		last_close = 1;
 	spin_unlock(&card->files_lock);
 	if (last_close) {
@@ -869,11 +857,11 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 		if (card->free_on_last_close)
 			snd_card_do_free(card);
 	}
-	if (!mfile) {
+	if (!found) {
 		snd_printk(KERN_ERR "ALSA card file remove problem (%p)\n", file);
 		return -ENOENT;
 	}
-	kfree(mfile);
+	kfree(found);
 	return 0;
 }
 

commit 53fb1e63599438bd5f6fbb852023d80916d83983
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:32:08 2008 +0100

    ALSA: Introduce snd_card_create()
    
    Introduced snd_card_create() function as a replacement of snd_card_new().
    The new function returns a negative error code so that the probe callback
    can return the proper error code, while snd_card_new() can give only NULL
    check.
    
    The old snd_card_new() is still provided as an inline function but with
    __deprecated attribute.  It'll be removed soon later.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 0d5520c415d3..dc4b80c7f311 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -121,31 +121,44 @@ static inline int init_info_for_card(struct snd_card *card)
 #endif
 
 /**
- *  snd_card_new - create and initialize a soundcard structure
+ *  snd_card_create - create and initialize a soundcard structure
  *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]
  *  @xid: card identification (ASCII string)
  *  @module: top level module for locking
  *  @extra_size: allocate this extra size after the main soundcard structure
+ *  @card_ret: the pointer to store the created card instance
  *
  *  Creates and initializes a soundcard structure.
  *
- *  Returns kmallocated snd_card structure. Creates the ALSA control interface
- *  (which is blocked until snd_card_register function is called).
+ *  The function allocates snd_card instance via kzalloc with the given
+ *  space for the driver to use freely.  The allocated struct is stored
+ *  in the given card_ret pointer.
+ *
+ *  Returns zero if successful or a negative error code.
  */
-struct snd_card *snd_card_new(int idx, const char *xid,
-			 struct module *module, int extra_size)
+int snd_card_create(int idx, const char *xid,
+		    struct module *module, int extra_size,
+		    struct snd_card **card_ret)
 {
 	struct snd_card *card;
 	int err, idx2;
 
+	if (snd_BUG_ON(!card_ret))
+		return -EINVAL;
+	*card_ret = NULL;
+
 	if (extra_size < 0)
 		extra_size = 0;
 	card = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);
-	if (card == NULL)
-		return NULL;
+	if (!card)
+		return -ENOMEM;
 	if (xid) {
-		if (!snd_info_check_reserved_words(xid))
+		if (!snd_info_check_reserved_words(xid)) {
+			snd_printk(KERN_ERR
+				   "given id string '%s' is reserved.\n", xid);
+			err = -EBUSY;
 			goto __error;
+		}
 		strlcpy(card->id, xid, sizeof(card->id));
 	}
 	err = 0;
@@ -202,26 +215,28 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 #endif
 	/* the control interface cannot be accessed from the user space until */
 	/* snd_cards_bitmask and snd_cards are set with snd_card_register */
-	if ((err = snd_ctl_create(card)) < 0) {
-		snd_printd("unable to register control minors\n");
+	err = snd_ctl_create(card);
+	if (err < 0) {
+		snd_printk(KERN_ERR "unable to register control minors\n");
 		goto __error;
 	}
-	if ((err = snd_info_card_create(card)) < 0) {
-		snd_printd("unable to create card info\n");
+	err = snd_info_card_create(card);
+	if (err < 0) {
+		snd_printk(KERN_ERR "unable to create card info\n");
 		goto __error_ctl;
 	}
 	if (extra_size > 0)
 		card->private_data = (char *)card + sizeof(struct snd_card);
-	return card;
+	*card_ret = card;
+	return 0;
 
       __error_ctl:
 	snd_device_free_all(card, SNDRV_DEV_CMD_PRE);
       __error:
 	kfree(card);
-      	return NULL;
+  	return err;
 }
-
-EXPORT_SYMBOL(snd_card_new);
+EXPORT_SYMBOL(snd_card_create);
 
 /* return non-zero if a card is already locked */
 int snd_card_locked(int card)

commit 2af752936b311a846622668f8b0f1893d8eccade
Author: Hannes Eder <hannes@hanneseder.net>
Date:   Tue Nov 18 12:25:06 2008 -0500

    sound: Fix warnings relating to ignored return value in snd_card_register
    
    Do not ignore the return of 'device_create_file' in
    'snd_card_register' and thereby fixing the following warnings:
    
    sound/core/init.c: In function 'snd_card_register':
    sound/core/init.c:640: warning: ignoring return value of
    'device_create_file', declared with attribute warn_unused_result
    sound/core/init.c:641: warning: ignoring return value of
    'device_create_file', declared with attribute warn_unused_result
    
    Signed-off-by: Hannes Eder <hannes@hanneseder.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index af1e407ca27f..0d5520c415d3 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -637,8 +637,12 @@ int snd_card_register(struct snd_card *card)
 #endif
 #ifndef CONFIG_SYSFS_DEPRECATED
 	if (card->card_dev) {
-		device_create_file(card->card_dev, &card_id_attrs);
-		device_create_file(card->card_dev, &card_number_attrs);
+		err = device_create_file(card->card_dev, &card_id_attrs);
+		if (err < 0)
+			return err;
+		err = device_create_file(card->card_dev, &card_number_attrs);
+		if (err < 0)
+			return err;
 	}
 #endif
 	return 0;

commit c2eb9c4ea383aee154e7139395872c4da629e715
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Nov 12 16:31:37 2008 +0100

    ALSA: when card identification is changed, change also /proc/asound symlink
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 5ff297d1d89a..af1e407ca27f 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -571,6 +571,7 @@ card_id_store_attr(struct device *dev, struct device_attribute *attr,
 			goto __exist;
 	}
 	strcpy(card->id, buf1);
+	snd_info_card_id_change(card);
 	mutex_unlock(&snd_card_mutex);
 
 	return count;

commit 9fb6198e8c574c6547fbfac0ae1eaf7894ddfdcc
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Nov 11 16:51:02 2008 +0100

    ALSA: add /sys/class/sound/card#/id (r/w) and card#/number (r/o) files
    
    For udev, we need a way to rename soundcard names. The soundcard numbers
    (indexes) are hardwired but we have a text identification which can be
    changed at run-time. The ALSA user space tools already allow using of
    this text identification.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index b47ff8b44be8..5ff297d1d89a 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -533,6 +533,64 @@ static void choose_default_id(struct snd_card *card)
 	}
 }
 
+#ifndef CONFIG_SYSFS_DEPRECATED
+static ssize_t
+card_id_show_attr(struct device *dev,
+		  struct device_attribute *attr, char *buf)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%s\n", card ? card->id : "(null)");
+}
+
+static ssize_t
+card_id_store_attr(struct device *dev, struct device_attribute *attr,
+		   const char *buf, size_t count)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	char buf1[sizeof(card->id)];
+	size_t copy = count > sizeof(card->id) - 1 ?
+					sizeof(card->id) - 1 : count;
+	size_t idx;
+	int c;
+
+	for (idx = 0; idx < copy; idx++) {
+		c = buf[idx];
+		if (!isalnum(c) && c != '_' && c != '-')
+			return -EINVAL;
+	}
+	memcpy(buf1, buf, copy);
+	buf1[copy] = '\0';
+	mutex_lock(&snd_card_mutex);
+	if (!snd_info_check_reserved_words(buf1)) {
+	     __exist:
+		mutex_unlock(&snd_card_mutex);
+		return -EEXIST;
+	}
+	for (idx = 0; idx < snd_ecards_limit; idx++) {
+		if (snd_cards[idx] && !strcmp(snd_cards[idx]->id, buf1))
+			goto __exist;
+	}
+	strcpy(card->id, buf1);
+	mutex_unlock(&snd_card_mutex);
+
+	return count;
+}
+
+static struct device_attribute card_id_attrs =
+	__ATTR(id, S_IRUGO | S_IWUSR, card_id_show_attr, card_id_store_attr);
+
+static ssize_t
+card_number_show_attr(struct device *dev,
+		     struct device_attribute *attr, char *buf)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%i\n", card ? card->number : -1);
+}
+
+static struct device_attribute card_number_attrs =
+	__ATTR(number, S_IRUGO, card_number_show_attr, NULL);
+#endif /* CONFIG_SYSFS_DEPRECATED */
+
 /**
  *  snd_card_register - register the soundcard
  *  @card: soundcard structure
@@ -553,7 +611,7 @@ int snd_card_register(struct snd_card *card)
 #ifndef CONFIG_SYSFS_DEPRECATED
 	if (!card->card_dev) {
 		card->card_dev = device_create(sound_class, card->dev,
-					       MKDEV(0, 0), NULL,
+					       MKDEV(0, 0), card,
 					       "card%i", card->number);
 		if (IS_ERR(card->card_dev))
 			card->card_dev = NULL;
@@ -575,6 +633,12 @@ int snd_card_register(struct snd_card *card)
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);
+#endif
+#ifndef CONFIG_SYSFS_DEPRECATED
+	if (card->card_dev) {
+		device_create_file(card->card_dev, &card_id_attrs);
+		device_create_file(card->card_dev, &card_number_attrs);
+	}
 #endif
 	return 0;
 }

commit 233e70f4228e78eb2f80dc6650f65d3ae3dbf17c
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Fri Oct 31 23:28:30 2008 +0000

    saner FASYNC handling on file close
    
    As it is, all instances of ->release() for files that have ->fasync()
    need to remember to evict file from fasync lists; forgetting that
    creates a hole and we actually have a bunch that *does* forget.
    
    So let's keep our lives simple - let __fput() check FASYNC in
    file->f_flags and call ->fasync() there if it's been set.  And lose that
    crap in ->release() instances - leaving it there is still valid, but we
    don't have to bother anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/init.c b/sound/core/init.c
index ef2352c2e451..b47ff8b44be8 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -264,8 +264,11 @@ static int snd_disconnect_release(struct inode *inode, struct file *file)
 	}
 	spin_unlock(&shutdown_lock);
 
-	if (likely(df))
+	if (likely(df)) {
+		if ((file->f_flags & FASYNC) && df->disconnected_f_op->fasync)
+			df->disconnected_f_op->fasync(-1, file, 0);
 		return df->disconnected_f_op->release(inode, file);
+	}
 
 	panic("%s(%p, %p) failed!", __func__, inode, file);
 }

commit abe9ab8f62203ced11119fb96acc3b8dd107ebc4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jul 21 20:03:34 2008 -0700

    device create: sound: convert device_create_drvdata to device_create
    
    Now that device_create() has been audited, rename things back to the
    original call to be sane.
    
    Cc: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 8af467df9245..ef2352c2e451 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -549,9 +549,9 @@ int snd_card_register(struct snd_card *card)
 		return -EINVAL;
 #ifndef CONFIG_SYSFS_DEPRECATED
 	if (!card->card_dev) {
-		card->card_dev = device_create_drvdata(sound_class, card->dev,
-						       MKDEV(0, 0), NULL,
-						       "card%i", card->number);
+		card->card_dev = device_create(sound_class, card->dev,
+					       MKDEV(0, 0), NULL,
+					       "card%i", card->number);
 		if (IS_ERR(card->card_dev))
 			card->card_dev = NULL;
 	}

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index df46bbc25dc2..8af467df9245 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -545,7 +545,8 @@ int snd_card_register(struct snd_card *card)
 {
 	int err;
 
-	snd_assert(card != NULL, return -EINVAL);
+	if (snd_BUG_ON(!card))
+		return -EINVAL;
 #ifndef CONFIG_SYSFS_DEPRECATED
 	if (!card->card_dev) {
 		card->card_dev = device_create_drvdata(sound_class, card->dev,

commit 89409211ff97bf82295d1fb98ab18302a03e9199
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 21 12:52:33 2008 -0700

    device create: sound: convert device_create to device_create_drvdata
    
    device_create() is race-prone, so use the race-free
    device_create_drvdata() instead as device_create() is going away.
    
    Cc: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 5c254d498ae0..df46bbc25dc2 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -548,8 +548,9 @@ int snd_card_register(struct snd_card *card)
 	snd_assert(card != NULL, return -EINVAL);
 #ifndef CONFIG_SYSFS_DEPRECATED
 	if (!card->card_dev) {
-		card->card_dev = device_create(sound_class, card->dev, 0,
-					       "card%i", card->number);
+		card->card_dev = device_create_drvdata(sound_class, card->dev,
+						       MKDEV(0, 0), NULL,
+						       "card%i", card->number);
 		if (IS_ERR(card->card_dev))
 			card->card_dev = NULL;
 	}

commit a93bbaa77ea61c6bad684263a65f812b31bf9791
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 27 17:59:24 2008 +0200

    [ALSA] Improve the slots option handling
    
    Fix and improve the slots option handling.  The sound core tries to
    find the slot with the given module name first and assign if it's
    still available.  If all pre-given slots are unavailable, then try
    to find another free slot.
    
    Also, when a module name begins with '!', it means the negative match:
    the slot will be given for any modules but that one.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index ac0573416130..5c254d498ae0 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -46,17 +46,24 @@ static char *slots[SNDRV_CARDS];
 module_param_array(slots, charp, NULL, 0444);
 MODULE_PARM_DESC(slots, "Module names assigned to the slots.");
 
-/* return non-zero if the given index is already reserved for another
+/* return non-zero if the given index is reserved for the given
  * module via slots option
  */
-static int module_slot_mismatch(struct module *module, int idx)
+static int module_slot_match(struct module *module, int idx)
 {
+	int match = 1;
 #ifdef MODULE
-	char *s1, *s2;
+	const char *s1, *s2;
+
 	if (!module || !module->name || !slots[idx])
 		return 0;
-	s1 = slots[idx];
-	s2 = module->name;
+
+	s1 = module->name;
+	s2 = slots[idx];
+	if (*s2 == '!') {
+		match = 0; /* negative match */
+		s2++;
+	}
 	/* compare module name strings
 	 * hyphens are handled as equivalent with underscore
 	 */
@@ -68,12 +75,12 @@ static int module_slot_mismatch(struct module *module, int idx)
 		if (c2 == '-')
 			c2 = '_';
 		if (c1 != c2)
-			return 1;
+			return !match;
 		if (!c1)
 			break;
 	}
-#endif
-	return 0;
+#endif /* MODULE */
+	return match;
 }
 
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
@@ -129,7 +136,7 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 			 struct module *module, int extra_size)
 {
 	struct snd_card *card;
-	int err;
+	int err, idx2;
 
 	if (extra_size < 0)
 		extra_size = 0;
@@ -144,35 +151,41 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 	err = 0;
 	mutex_lock(&snd_card_mutex);
 	if (idx < 0) {
-		int idx2;
 		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
 			/* idx == -1 == 0xffff means: take any free slot */
 			if (~snd_cards_lock & idx & 1<<idx2) {
-				if (module_slot_mismatch(module, idx2))
-					continue;
-				idx = idx2;
-				if (idx >= snd_ecards_limit)
-					snd_ecards_limit = idx + 1;
-				break;
+				if (module_slot_match(module, idx2)) {
+					idx = idx2;
+					break;
+				}
+			}
+	}
+	if (idx < 0) {
+		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
+			/* idx == -1 == 0xffff means: take any free slot */
+			if (~snd_cards_lock & idx & 1<<idx2) {
+				if (!slots[idx2] || !*slots[idx2]) {
+					idx = idx2;
+					break;
+				}
 			}
-	} else {
-		 if (idx < snd_ecards_limit) {
-			if (snd_cards_lock & (1 << idx))
-				err = -EBUSY;	/* invalid */
-		} else {
-			if (idx < SNDRV_CARDS)
-				snd_ecards_limit = idx + 1; /* increase the limit */
-			else
-				err = -ENODEV;
-		}
 	}
-	if (idx < 0 || err < 0) {
+	if (idx < 0)
+		err = -ENODEV;
+	else if (idx < snd_ecards_limit) {
+		if (snd_cards_lock & (1 << idx))
+			err = -EBUSY;	/* invalid */
+	} else if (idx >= SNDRV_CARDS)
+		err = -ENODEV;
+	if (err < 0) {
 		mutex_unlock(&snd_card_mutex);
 		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i), error: %d\n",
 			 idx, snd_ecards_limit - 1, err);
 		goto __error;
 	}
 	snd_cards_lock |= 1 << idx;		/* lock it */
+	if (idx >= snd_ecards_limit)
+		snd_ecards_limit = idx + 1; /* increase the limit */
 	mutex_unlock(&snd_card_mutex);
 	card->number = idx;
 	card->module = module;

commit f18638dcf0c481eca2430206ebcdc7295aec8623
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 17 12:52:02 2008 +0200

    [ALSA] Clean up snd_card_free*()
    
    A little clean up of snd_card_free*().
    Removed snd_card_free_prepare() since it's actually almost identical
    with snd_card_disconnect().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 07acac77ea45..ac0573416130 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -311,6 +311,9 @@ int snd_card_disconnect(struct snd_card *card)
 	struct file *file;
 	int err;
 
+	if (!card)
+		return -EINVAL;
+
 	spin_lock(&card->files_lock);
 	if (card->shutdown) {
 		spin_unlock(&card->files_lock);
@@ -322,6 +325,7 @@ int snd_card_disconnect(struct snd_card *card)
 	/* phase 1: disable fops (user space) operations for ALSA API */
 	mutex_lock(&snd_card_mutex);
 	snd_cards[card->number] = NULL;
+	snd_cards_lock &= ~(1 << card->number);
 	mutex_unlock(&snd_card_mutex);
 	
 	/* phase 2: replace file->f_op with special dummy operations */
@@ -365,6 +369,9 @@ int snd_card_disconnect(struct snd_card *card)
 		device_unregister(card->card_dev);
 		card->card_dev = NULL;
 	}
+#endif
+#ifdef CONFIG_PM
+	wake_up(&card->power_sleep);
 #endif
 	return 0;	
 }
@@ -411,25 +418,10 @@ static int snd_card_do_free(struct snd_card *card)
 	return 0;
 }
 
-static int snd_card_free_prepare(struct snd_card *card)
-{
-	if (card == NULL)
-		return -EINVAL;
-	(void) snd_card_disconnect(card);
-	mutex_lock(&snd_card_mutex);
-	snd_cards[card->number] = NULL;
-	snd_cards_lock &= ~(1 << card->number);
-	mutex_unlock(&snd_card_mutex);
-#ifdef CONFIG_PM
-	wake_up(&card->power_sleep);
-#endif
-	return 0;
-}
-
 int snd_card_free_when_closed(struct snd_card *card)
 {
 	int free_now = 0;
-	int ret = snd_card_free_prepare(card);
+	int ret = snd_card_disconnect(card);
 	if (ret)
 		return ret;
 
@@ -449,7 +441,7 @@ EXPORT_SYMBOL(snd_card_free_when_closed);
 
 int snd_card_free(struct snd_card *card)
 {
-	int ret = snd_card_free_prepare(card);
+	int ret = snd_card_disconnect(card);
 	if (ret)
 		return ret;
 

commit 73d38b13ffb105ab633bd91969c8d218b2de38d4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 17 12:50:47 2008 +0200

    [ALSA] Fix the race of card instance unregistration
    
    Move the call of device_unregister() for the card instance in
    snd_card_disconnect() to avoid the race of sysfs card entry, which
    can be typically found on usb-audio reconnection.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index f045f7db3ab4..07acac77ea45 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -360,6 +360,12 @@ int snd_card_disconnect(struct snd_card *card)
 		snd_printk(KERN_ERR "not all devices for card %i can be disconnected\n", card->number);
 
 	snd_info_card_disconnect(card);
+#ifndef CONFIG_SYSFS_DEPRECATED
+	if (card->card_dev) {
+		device_unregister(card->card_dev);
+		card->card_dev = NULL;
+	}
+#endif
 	return 0;	
 }
 
@@ -401,10 +407,6 @@ static int snd_card_do_free(struct snd_card *card)
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
 	}
-#ifndef CONFIG_SYSFS_DEPRECATED
-	if (card->card_dev)
-		device_unregister(card->card_dev);
-#endif
 	kfree(card);
 	return 0;
 }

commit 9bf8e7ddeaf57f1ec534014c447705ad31d5d721
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 15:32:18 2008 -0800

    [ALSA] sound: replace remaining __FUNCTION__ occurences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index e3338d6071ef..f045f7db3ab4 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -254,7 +254,7 @@ static int snd_disconnect_release(struct inode *inode, struct file *file)
 	if (likely(df))
 		return df->disconnected_f_op->release(inode, file);
 
-	panic("%s(%p, %p) failed!", __FUNCTION__, inode, file);
+	panic("%s(%p, %p) failed!", __func__, inode, file);
 }
 
 static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)

commit bc9abce0de0b180817bc7e9f73145ef0b6a464ef
Author: Miguel Boton <mboton@gmail.com>
Date:   Sun Jan 13 12:03:53 2008 +0100

    [ALSA] fix compilation warning in GCC
    
    'snd_shutdown_f_ops' is not a pointer so its address will never be NULL.
    GCC will complain because 'fops_get' will do an unnecessary check because
    '&snd_shutdown_f_ops' is always true.
    
    Signed-off-by: Miguel Boton <mboton@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index dc06e79ca09f..e3338d6071ef 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -339,8 +339,8 @@ int snd_card_disconnect(struct snd_card *card)
 		list_add(&mfile->shutdown_list, &shutdown_files);
 		spin_unlock(&shutdown_lock);
 
-		fops_get(&snd_shutdown_f_ops);
 		mfile->file->f_op = &snd_shutdown_f_ops;
+		fops_get(mfile->file->f_op);
 		
 		mfile = mfile->next;
 	}

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index 48d38a79cbbb..dc06e79ca09f 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/file.h>

commit 304cd07f92027af7e92d742d9554c3be9fa4d4cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 26 15:10:15 2007 +0200

    [ALSA] Introduce slots option to snd module
    
    Introduced the global 'slots' option to snd module.  This option provides
    an alternative way to handle the order of multiple sound card instances.
    It's an easier approach to avoid conflict with hotplug devices, and can
    be used together with the existing 'order' option of each card driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index 2cb7099eb1e1..48d38a79cbbb 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -43,6 +43,40 @@ EXPORT_SYMBOL(snd_cards);
 
 static DEFINE_MUTEX(snd_card_mutex);
 
+static char *slots[SNDRV_CARDS];
+module_param_array(slots, charp, NULL, 0444);
+MODULE_PARM_DESC(slots, "Module names assigned to the slots.");
+
+/* return non-zero if the given index is already reserved for another
+ * module via slots option
+ */
+static int module_slot_mismatch(struct module *module, int idx)
+{
+#ifdef MODULE
+	char *s1, *s2;
+	if (!module || !module->name || !slots[idx])
+		return 0;
+	s1 = slots[idx];
+	s2 = module->name;
+	/* compare module name strings
+	 * hyphens are handled as equivalent with underscore
+	 */
+	for (;;) {
+		char c1 = *s1++;
+		char c2 = *s2++;
+		if (c1 == '-')
+			c1 = '_';
+		if (c2 == '-')
+			c2 = '_';
+		if (c1 != c2)
+			return 1;
+		if (!c1)
+			break;
+	}
+#endif
+	return 0;
+}
+
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);
 EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
@@ -115,6 +149,8 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
 			/* idx == -1 == 0xffff means: take any free slot */
 			if (~snd_cards_lock & idx & 1<<idx2) {
+				if (module_slot_mismatch(module, idx2))
+					continue;
 				idx = idx2;
 				if (idx >= snd_ecards_limit)
 					snd_ecards_limit = idx + 1;

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index f2fe35737186..2cb7099eb1e1 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -1,6 +1,6 @@
 /*
  *  Initialization routines
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify

commit 6473d160b4aba8023bcf38519a5989694dfd51a7
Author: Jean Delvare <khali@linux-fr.org>
Date:   Tue Mar 6 02:45:12 2007 -0800

    PCI: Cleanup the includes of <linux/pci.h>
    
    I noticed that many source files include <linux/pci.h> while they do
    not appear to need it. Here is an attempt to clean it all up.
    
    In order to find all possibly affected files, I searched for all
    files including <linux/pci.h> but without any other occurence of "pci"
    or "PCI". I removed the include statement from all of these, then I
    compiled an allmodconfig kernel on both i386 and x86_64 and fixed the
    false positives manually.
    
    My tests covered 66% of the affected files, so there could be false
    positives remaining. Untested files are:
    
    arch/alpha/kernel/err_common.c
    arch/alpha/kernel/err_ev6.c
    arch/alpha/kernel/err_ev7.c
    arch/ia64/sn/kernel/huberror.c
    arch/ia64/sn/kernel/xpnet.c
    arch/m68knommu/kernel/dma.c
    arch/mips/lib/iomap.c
    arch/powerpc/platforms/pseries/ras.c
    arch/ppc/8260_io/enet.c
    arch/ppc/8260_io/fcc_enet.c
    arch/ppc/8xx_io/enet.c
    arch/ppc/syslib/ppc4xx_sgdma.c
    arch/sh64/mach-cayman/iomap.c
    arch/xtensa/kernel/xtensa_ksyms.c
    arch/xtensa/platform-iss/setup.c
    drivers/i2c/busses/i2c-at91.c
    drivers/i2c/busses/i2c-mpc.c
    drivers/media/video/saa711x.c
    drivers/misc/hdpuftrs/hdpu_cpustate.c
    drivers/misc/hdpuftrs/hdpu_nexus.c
    drivers/net/au1000_eth.c
    drivers/net/fec_8xx/fec_main.c
    drivers/net/fec_8xx/fec_mii.c
    drivers/net/fs_enet/fs_enet-main.c
    drivers/net/fs_enet/mac-fcc.c
    drivers/net/fs_enet/mac-fec.c
    drivers/net/fs_enet/mac-scc.c
    drivers/net/fs_enet/mii-bitbang.c
    drivers/net/fs_enet/mii-fec.c
    drivers/net/ibm_emac/ibm_emac_core.c
    drivers/net/lasi_82596.c
    drivers/parisc/hppb.c
    drivers/sbus/sbus.c
    drivers/video/g364fb.c
    drivers/video/platinumfb.c
    drivers/video/stifb.c
    drivers/video/valkyriefb.c
    include/asm-arm/arch-ixp4xx/dma.h
    sound/oss/au1550_ac97.c
    
    I would welcome test reports for these files. I am fine with removing
    the untested files from the patch if the general opinion is that these
    changes aren't safe. The tested part would still be nice to have.
    
    Note that this patch depends on another header fixup patch I submitted
    to LKML yesterday:
      [PATCH] scatterlist.h needs types.h
      http://lkml.org/lkml/2007/3/01/141
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 4a431e3ea3a2..f2fe35737186 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -26,7 +26,6 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/ctype.h>
-#include <linux/pci.h>
 #include <linux/pm.h>
 
 #include <sound/core.h>

commit 9c2e08c592cd357a8330c34def1e8ecfdcf53275
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:37 2007 -0800

    [PATCH] mark struct file_operations const 9
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/init.c b/sound/core/init.c
index db6103733742..4a431e3ea3a2 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -36,7 +36,7 @@
 static DEFINE_SPINLOCK(shutdown_lock);
 static LIST_HEAD(shutdown_files);
 
-static struct file_operations snd_shutdown_f_ops;
+static const struct file_operations snd_shutdown_f_ops;
 
 static unsigned int snd_cards_lock;	/* locked for registering/using */
 struct snd_card *snd_cards[SNDRV_CARDS];
@@ -244,7 +244,7 @@ static int snd_disconnect_fasync(int fd, struct file *file, int on)
 	return -ENODEV;
 }
 
-static struct file_operations snd_shutdown_f_ops =
+static const struct file_operations snd_shutdown_f_ops =
 {
 	.owner = 	THIS_MODULE,
 	.llseek =	snd_disconnect_llseek,

commit 5c33dd70b51be0617a75562aa896d5ccf1840455
Author: Oliver Neukum <oneukum@suse.de>
Date:   Tue Jan 16 17:49:21 2007 +0100

    [ALSA] cleanup and error reporting for sound/core/init.c
    
    Make the control flow clear with indentation, adds some comments
    and improves error reporting.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index a4cc6b155ae9..db6103733742 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -114,22 +114,28 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 	if (idx < 0) {
 		int idx2;
 		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
+			/* idx == -1 == 0xffff means: take any free slot */
 			if (~snd_cards_lock & idx & 1<<idx2) {
 				idx = idx2;
 				if (idx >= snd_ecards_limit)
 					snd_ecards_limit = idx + 1;
 				break;
 			}
-	} else if (idx < snd_ecards_limit) {
-		if (snd_cards_lock & (1 << idx))
-			err = -ENODEV;	/* invalid */
-	} else if (idx < SNDRV_CARDS)
-		snd_ecards_limit = idx + 1; /* increase the limit */
-	else
-		err = -ENODEV;
+	} else {
+		 if (idx < snd_ecards_limit) {
+			if (snd_cards_lock & (1 << idx))
+				err = -EBUSY;	/* invalid */
+		} else {
+			if (idx < SNDRV_CARDS)
+				snd_ecards_limit = idx + 1; /* increase the limit */
+			else
+				err = -ENODEV;
+		}
+	}
 	if (idx < 0 || err < 0) {
 		mutex_unlock(&snd_card_mutex);
-		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i)\n", idx, snd_ecards_limit - 1);
+		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i), error: %d\n",
+			 idx, snd_ecards_limit - 1, err);
 		goto __error;
 	}
 	snd_cards_lock |= 1 << idx;		/* lock it */

commit 7d2aae1e88660cf09be913e9754e45189dc33412
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 26 12:40:31 2007 +0100

    [PATCH] ALSA: Fix sysfs breakage
    
    The recent change for a new sysfs tree with card* object breaks the
    /sys/class/sound tree if CONFIG_SYSFS_DEPRECATED is enabled.
    The device in each entry doesn't point the correct device object:
    
      /sys/class/sound
      ...
      |-- pcmC0D0c
      |   |-- dev
      |   |-- device -> ../../../class/sound/card0
      |   |-- pcm_class
      |   |-- power
      |   |   `-- wakeup
      |   |-- subsystem -> ../../../class/sound
      |   `-- uevent
    
    Also, this change breaks some drivers (like sound/arm/*) referring
    card->dev directly to obtain the device object for memory handling.
    
    This patch reverts the semantics of card->dev to the former version,
    which points to a real device object.  The card* object is stored in a
    new card->card_dev field, instead.  The device parent is chosen either
    card->dev or card->card_dev according to CONFIG_SYSFS_DEPRECATED to
    keep the tree compatibility.
    Also, card* isn't created if CONFIG_SYSFS_DEPRECATED is enabled.  The
    reason of card* object is a root of all beloing devices, and it makes
    little sense if each sound device points to the real device object
    directly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Monty Montgomery <xiphmont@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 6152a7554dfd..a4cc6b155ae9 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -361,8 +361,10 @@ static int snd_card_do_free(struct snd_card *card)
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
 	}
-	if (card->dev)
-		device_unregister(card->dev);
+#ifndef CONFIG_SYSFS_DEPRECATED
+	if (card->card_dev)
+		device_unregister(card->card_dev);
+#endif
 	kfree(card);
 	return 0;
 }
@@ -497,12 +499,14 @@ int snd_card_register(struct snd_card *card)
 	int err;
 
 	snd_assert(card != NULL, return -EINVAL);
-	if (!card->dev) {
-		card->dev = device_create(sound_class, card->parent, 0,
-					  "card%i", card->number);
-		if (IS_ERR(card->dev))
-			card->dev = NULL;
+#ifndef CONFIG_SYSFS_DEPRECATED
+	if (!card->card_dev) {
+		card->card_dev = device_create(sound_class, card->dev, 0,
+					       "card%i", card->number);
+		if (IS_ERR(card->card_dev))
+			card->card_dev = NULL;
 	}
+#endif
 	if ((err = snd_device_register_all(card)) < 0)
 		return err;
 	mutex_lock(&snd_card_mutex);

commit d80f19fab89cba8a6d16193154c8ff3edab00942
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 7 22:19:37 2006 -0700

    Driver core: convert sound core to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    It also makes the struct sound_card to show up as a "real" device
    where all the different sound class devices are placed as childs
    and different card attribute files can hang off of. /sys/class/sound is
    still a flat directory, but the symlink targets of all devices belonging
    to the same card, point the the /sys/devices tree below the new card
    device object.
    
    Thanks to Kay for the updates to this patch.
    
    Signed-off-by: Kay Sievers <kay.sievers@novell.com>
    Acked-by: Jaroslav Kysela <perex@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 3058d626a90a..6152a7554dfd 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -361,6 +361,8 @@ static int snd_card_do_free(struct snd_card *card)
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
 	}
+	if (card->dev)
+		device_unregister(card->dev);
 	kfree(card);
 	return 0;
 }
@@ -495,6 +497,12 @@ int snd_card_register(struct snd_card *card)
 	int err;
 
 	snd_assert(card != NULL, return -EINVAL);
+	if (!card->dev) {
+		card->dev = device_create(sound_class, card->parent, 0,
+					  "card%i", card->number);
+		if (IS_ERR(card->dev))
+			card->dev = NULL;
+	}
 	if ((err = snd_device_register_all(card)) < 0)
 		return err;
 	mutex_lock(&snd_card_mutex);

commit a9edfc60227a1dc5c741666ff252a6055b73b184
Author: Karsten Wiese <fzu@wemgehoertderstaat.de>
Date:   Fri Oct 6 16:08:27 2006 +0200

    [ALSA] Handle file operations during snd_card disconnects using static file->f_op
    
    Alsa used to kmalloc one file->f_op per file per disconnecting snd_card.
    This led to oopses sometimes when file->f_op was freed before __fput()
    finished.
    Patch adds a virtual device for disconnect: VDD.
    VDD consists of:
            LIST_HEAD(shutdown_files)
                protected by DEFINE_SPINLOCK(shutdown_mutex)
            static struct file_operations snd_shutdown_f_ops
                and functions assigned to it
            Additions to struct snd_monitor_file
                to specify if instance is hidden by VDD or not.
    A VDD's instance is
            created in snd_card_disconnect() under the card->files_lock.
            cleaned up in snd_card_file_remove() under the card->files_lock.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index d7607a25acdf..3058d626a90a 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -33,10 +33,10 @@
 #include <sound/control.h>
 #include <sound/info.h>
 
-struct snd_shutdown_f_ops {
-	struct file_operations f_ops;
-	struct snd_shutdown_f_ops *next;
-};
+static DEFINE_SPINLOCK(shutdown_lock);
+static LIST_HEAD(shutdown_files);
+
+static struct file_operations snd_shutdown_f_ops;
 
 static unsigned int snd_cards_lock;	/* locked for registering/using */
 struct snd_card *snd_cards[SNDRV_CARDS];
@@ -198,6 +198,25 @@ static ssize_t snd_disconnect_write(struct file *file, const char __user *buf,
 	return -ENODEV;
 }
 
+static int snd_disconnect_release(struct inode *inode, struct file *file)
+{
+	struct snd_monitor_file *df = NULL, *_df;
+
+	spin_lock(&shutdown_lock);
+	list_for_each_entry(_df, &shutdown_files, shutdown_list) {
+		if (_df->file == file) {
+			df = _df;
+			break;
+		}
+	}
+	spin_unlock(&shutdown_lock);
+
+	if (likely(df))
+		return df->disconnected_f_op->release(inode, file);
+
+	panic("%s(%p, %p) failed!", __FUNCTION__, inode, file);
+}
+
 static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)
 {
 	return POLLERR | POLLNVAL;
@@ -219,6 +238,22 @@ static int snd_disconnect_fasync(int fd, struct file *file, int on)
 	return -ENODEV;
 }
 
+static struct file_operations snd_shutdown_f_ops =
+{
+	.owner = 	THIS_MODULE,
+	.llseek =	snd_disconnect_llseek,
+	.read = 	snd_disconnect_read,
+	.write =	snd_disconnect_write,
+	.release =	snd_disconnect_release,
+	.poll =		snd_disconnect_poll,
+	.unlocked_ioctl = snd_disconnect_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = snd_disconnect_ioctl,
+#endif
+	.mmap =		snd_disconnect_mmap,
+	.fasync =	snd_disconnect_fasync
+};
+
 /**
  *  snd_card_disconnect - disconnect all APIs from the file-operations (user space)
  *  @card: soundcard structure
@@ -234,9 +269,6 @@ int snd_card_disconnect(struct snd_card *card)
 {
 	struct snd_monitor_file *mfile;
 	struct file *file;
-	struct snd_shutdown_f_ops *s_f_ops;
-	struct file_operations *f_ops;
-	const struct file_operations *old_f_ops;
 	int err;
 
 	spin_lock(&card->files_lock);
@@ -261,34 +293,14 @@ int snd_card_disconnect(struct snd_card *card)
 
 		/* it's critical part, use endless loop */
 		/* we have no room to fail */
-		s_f_ops = kmalloc(sizeof(struct snd_shutdown_f_ops), GFP_ATOMIC);
-		if (s_f_ops == NULL)
-			panic("Atomic allocation failed for snd_shutdown_f_ops!");
-
-		f_ops = &s_f_ops->f_ops;
-
-		memset(f_ops, 0, sizeof(*f_ops));
-		f_ops->owner = file->f_op->owner;
-		f_ops->release = file->f_op->release;
-		f_ops->llseek = snd_disconnect_llseek;
-		f_ops->read = snd_disconnect_read;
-		f_ops->write = snd_disconnect_write;
-		f_ops->poll = snd_disconnect_poll;
-		f_ops->unlocked_ioctl = snd_disconnect_ioctl;
-#ifdef CONFIG_COMPAT
-		f_ops->compat_ioctl = snd_disconnect_ioctl;
-#endif
-		f_ops->mmap = snd_disconnect_mmap;
-		f_ops->fasync = snd_disconnect_fasync;
+		mfile->disconnected_f_op = mfile->file->f_op;
 
-		s_f_ops->next = card->s_f_ops;
-		card->s_f_ops = s_f_ops;
-		
-		f_ops = fops_get(f_ops);
+		spin_lock(&shutdown_lock);
+		list_add(&mfile->shutdown_list, &shutdown_files);
+		spin_unlock(&shutdown_lock);
 
-		old_f_ops = file->f_op;
-		file->f_op = f_ops;	/* must be atomic */
-		fops_put(old_f_ops);
+		fops_get(&snd_shutdown_f_ops);
+		mfile->file->f_op = &snd_shutdown_f_ops;
 		
 		mfile = mfile->next;
 	}
@@ -326,8 +338,6 @@ EXPORT_SYMBOL(snd_card_disconnect);
  */
 static int snd_card_do_free(struct snd_card *card)
 {
-	struct snd_shutdown_f_ops *s_f_ops;
-
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);
@@ -351,11 +361,6 @@ static int snd_card_do_free(struct snd_card *card)
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
 	}
-	while (card->s_f_ops) {
-		s_f_ops = card->s_f_ops;
-		card->s_f_ops = s_f_ops->next;
-		kfree(s_f_ops);
-	}
 	kfree(card);
 	return 0;
 }
@@ -670,6 +675,7 @@ int snd_card_file_add(struct snd_card *card, struct file *file)
 	if (mfile == NULL)
 		return -ENOMEM;
 	mfile->file = file;
+	mfile->disconnected_f_op = NULL;
 	mfile->next = NULL;
 	spin_lock(&card->files_lock);
 	if (card->shutdown) {
@@ -716,6 +722,12 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 		pfile = mfile;
 		mfile = mfile->next;
 	}
+	if (mfile && mfile->disconnected_f_op) {
+		fops_put(mfile->disconnected_f_op);
+		spin_lock(&shutdown_lock);
+		list_del(&mfile->shutdown_list);
+		spin_unlock(&shutdown_lock);
+	}
 	if (card->files == NULL)
 		last_close = 1;
 	spin_unlock(&card->files_lock);

commit 2b29b13c5794f648cd5e839796496704d787f5a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:38:26 2006 +0200

    [ALSA] Deprecate snd_card_free_in_thread()
    
    Deprecated snd_card_free_in_thread(), replaced with
    snd_card_free_when_closed().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index 5850d99d21e3..d7607a25acdf 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -81,8 +81,6 @@ static inline int init_info_for_card(struct snd_card *card)
 #define init_info_for_card(card)
 #endif
 
-static void snd_card_free_thread(void * __card);
-
 /**
  *  snd_card_new - create and initialize a soundcard structure
  *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]
@@ -145,7 +143,6 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 	INIT_LIST_HEAD(&card->ctl_files);
 	spin_lock_init(&card->files_lock);
 	init_waitqueue_head(&card->shutdown_sleep);
-	INIT_WORK(&card->free_workq, snd_card_free_thread, card);
 #ifdef CONFIG_PM
 	mutex_init(&card->power_lock);
 	init_waitqueue_head(&card->power_sleep);
@@ -413,53 +410,6 @@ int snd_card_free(struct snd_card *card)
 
 EXPORT_SYMBOL(snd_card_free);
 
-static void snd_card_free_thread(void * __card)
-{
-	struct snd_card *card = __card;
-	struct module * module = card->module;
-
-	if (!try_module_get(module)) {
-		snd_printk(KERN_ERR "unable to lock toplevel module for card %i in free thread\n", card->number);
-		module = NULL;
-	}
-
-	snd_card_free(card);
-
-	module_put(module);
-}
-
-/**
- *  snd_card_free_in_thread - call snd_card_free() in thread
- *  @card: soundcard structure
- *
- *  This function schedules the call of snd_card_free() function in a
- *  work queue.  When all devices are released (non-busy), the work
- *  is woken up and calls snd_card_free().
- *
- *  When a card can be disconnected at any time by hotplug service,
- *  this function should be used in disconnect (or detach) callback
- *  instead of calling snd_card_free() directly.
- *  
- *  Returns - zero otherwise a negative error code if the start of thread failed.
- */
-int snd_card_free_in_thread(struct snd_card *card)
-{
-	if (card->files == NULL) {
-		snd_card_free(card);
-		return 0;
-	}
-
-	if (schedule_work(&card->free_workq))
-		return 0;
-
-	snd_printk(KERN_ERR "schedule_work() failed in snd_card_free_in_thread for card %i\n", card->number);
-	/* try to free the structure immediately */
-	snd_card_free(card);
-	return -EFAULT;
-}
-
-EXPORT_SYMBOL(snd_card_free_in_thread);
-
 static void choose_default_id(struct snd_card *card)
 {
 	int i, len, idx_flag = 0, loops = SNDRV_CARDS;
@@ -742,9 +692,9 @@ EXPORT_SYMBOL(snd_card_file_add);
  *
  *  This function removes the file formerly added to the card via
  *  snd_card_file_add() function.
- *  If all files are removed and the release of the card is
- *  scheduled, it will wake up the the thread to call snd_card_free()
- *  (see snd_card_free_in_thread() function).
+ *  If all files are removed and snd_card_free_when_closed() was
+ *  called beforehand, it processes the pending release of
+ *  resources.
  *
  *  Returns zero or a negative error code.
  */

commit c461482c8072bb073e6146db320d3da85cdc89ad
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:38:23 2006 +0200

    [ALSA] Unregister device files at disconnection
    
    Orignally proposed by Sam Revitch <sam.revitch@gmail.com>.
    Unregister device files at disconnection to avoid the futher accesses.
    Also, the dev_unregister callback is removed and replaced with the
    combination of disconnect + free.
    A new function snd_card_free_when_closed() is introduced, which is
    used in USB disconnect callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index 1ecb029ff4c9..5850d99d21e3 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -327,22 +327,10 @@ EXPORT_SYMBOL(snd_card_disconnect);
  *  Returns zero. Frees all associated devices and frees the control
  *  interface associated to given soundcard.
  */
-int snd_card_free(struct snd_card *card)
+static int snd_card_do_free(struct snd_card *card)
 {
 	struct snd_shutdown_f_ops *s_f_ops;
 
-	if (card == NULL)
-		return -EINVAL;
-	mutex_lock(&snd_card_mutex);
-	snd_cards[card->number] = NULL;
-	mutex_unlock(&snd_card_mutex);
-
-#ifdef CONFIG_PM
-	wake_up(&card->power_sleep);
-#endif
-	/* wait, until all devices are ready for the free operation */
-	wait_event(card->shutdown_sleep, card->files == NULL);
-
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);
@@ -371,10 +359,55 @@ int snd_card_free(struct snd_card *card)
 		card->s_f_ops = s_f_ops->next;
 		kfree(s_f_ops);
 	}
+	kfree(card);
+	return 0;
+}
+
+static int snd_card_free_prepare(struct snd_card *card)
+{
+	if (card == NULL)
+		return -EINVAL;
+	(void) snd_card_disconnect(card);
 	mutex_lock(&snd_card_mutex);
+	snd_cards[card->number] = NULL;
 	snd_cards_lock &= ~(1 << card->number);
 	mutex_unlock(&snd_card_mutex);
-	kfree(card);
+#ifdef CONFIG_PM
+	wake_up(&card->power_sleep);
+#endif
+	return 0;
+}
+
+int snd_card_free_when_closed(struct snd_card *card)
+{
+	int free_now = 0;
+	int ret = snd_card_free_prepare(card);
+	if (ret)
+		return ret;
+
+	spin_lock(&card->files_lock);
+	if (card->files == NULL)
+		free_now = 1;
+	else
+		card->free_on_last_close = 1;
+	spin_unlock(&card->files_lock);
+
+	if (free_now)
+		snd_card_do_free(card);
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_card_free_when_closed);
+
+int snd_card_free(struct snd_card *card)
+{
+	int ret = snd_card_free_prepare(card);
+	if (ret)
+		return ret;
+
+	/* wait, until all devices are ready for the free operation */
+	wait_event(card->shutdown_sleep, card->files == NULL);
+	snd_card_do_free(card);
 	return 0;
 }
 
@@ -718,6 +751,7 @@ EXPORT_SYMBOL(snd_card_file_add);
 int snd_card_file_remove(struct snd_card *card, struct file *file)
 {
 	struct snd_monitor_file *mfile, *pfile = NULL;
+	int last_close = 0;
 
 	spin_lock(&card->files_lock);
 	mfile = card->files;
@@ -732,9 +766,14 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 		pfile = mfile;
 		mfile = mfile->next;
 	}
-	spin_unlock(&card->files_lock);
 	if (card->files == NULL)
+		last_close = 1;
+	spin_unlock(&card->files_lock);
+	if (last_close) {
 		wake_up(&card->shutdown_sleep);
+		if (card->free_on_last_close)
+			snd_card_do_free(card);
+	}
 	if (!mfile) {
 		snd_printk(KERN_ERR "ALSA card file remove problem (%p)\n", file);
 		return -ENOENT;

commit 746d4a02e68499fc6c1f8d0c43d2271853ade181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:37:59 2006 +0200

    [ALSA] Fix disconnection of proc interface
    
    - Add the linked list to each proc entry to enable a single-shot
      disconnection (unregister)
    - Deprecate snd_info_unregister(), use snd_info_free_entry()
    - Removed NULL checks of snd_info_free_entry()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/init.c b/sound/core/init.c
index 4d9258884e44..1ecb029ff4c9 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -310,6 +310,7 @@ int snd_card_disconnect(struct snd_card *card)
 	if (err < 0)
 		snd_printk(KERN_ERR "not all devices for card %i can be disconnected\n", card->number);
 
+	snd_info_card_disconnect(card);
 	return 0;	
 }
 
@@ -360,7 +361,7 @@ int snd_card_free(struct snd_card *card)
 	}
 	if (card->private_free)
 		card->private_free(card);
-	snd_info_unregister(card->proc_id);
+	snd_info_free_entry(card->proc_id);
 	if (snd_info_card_free(card) < 0) {
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
@@ -625,9 +626,9 @@ int __init snd_card_info_init(void)
 
 int __exit snd_card_info_done(void)
 {
-	snd_info_unregister(snd_card_info_entry);
+	snd_info_free_entry(snd_card_info_entry);
 #ifdef MODULE
-	snd_info_unregister(snd_card_module_info_entry);
+	snd_info_free_entry(snd_card_module_info_entry);
 #endif
 	return 0;
 }

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 38b2d4a9d672..4d9258884e44 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -38,8 +38,8 @@ struct snd_shutdown_f_ops {
 	struct snd_shutdown_f_ops *next;
 };
 
-static unsigned int snd_cards_lock = 0;	/* locked for registering/using */
-struct snd_card *snd_cards[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = NULL};
+static unsigned int snd_cards_lock;	/* locked for registering/using */
+struct snd_card *snd_cards[SNDRV_CARDS];
 EXPORT_SYMBOL(snd_cards);
 
 static DEFINE_MUTEX(snd_card_mutex);
@@ -529,7 +529,7 @@ int snd_card_register(struct snd_card *card)
 EXPORT_SYMBOL(snd_card_register);
 
 #ifdef CONFIG_PROC_FS
-static struct snd_info_entry *snd_card_info_entry = NULL;
+static struct snd_info_entry *snd_card_info_entry;
 
 static void snd_card_info_read(struct snd_info_entry *entry,
 			       struct snd_info_buffer *buffer)

commit 746df94898554b3d8e91d855e934852e626c701c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 15 19:49:05 2006 +0200

    [ALSA] Fix rwlock around snd_iprintf() in sound core
    
    Fixed rwlock around snd_iprintf() in sound core part.
    Replaced with mutex.
    Also, make mutex and flags static variables with addition of
    snd_card_locked() function (just for sound.c).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 2ff0e5e90865..38b2d4a9d672 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -38,11 +38,11 @@ struct snd_shutdown_f_ops {
 	struct snd_shutdown_f_ops *next;
 };
 
-unsigned int snd_cards_lock = 0;	/* locked for registering/using */
+static unsigned int snd_cards_lock = 0;	/* locked for registering/using */
 struct snd_card *snd_cards[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = NULL};
 EXPORT_SYMBOL(snd_cards);
 
-DEFINE_RWLOCK(snd_card_rwlock);
+static DEFINE_MUTEX(snd_card_mutex);
 
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);
@@ -112,7 +112,7 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 		strlcpy(card->id, xid, sizeof(card->id));
 	}
 	err = 0;
-	write_lock(&snd_card_rwlock);
+	mutex_lock(&snd_card_mutex);
 	if (idx < 0) {
 		int idx2;
 		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
@@ -130,12 +130,12 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 	else
 		err = -ENODEV;
 	if (idx < 0 || err < 0) {
-		write_unlock(&snd_card_rwlock);
+		mutex_unlock(&snd_card_mutex);
 		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i)\n", idx, snd_ecards_limit - 1);
 		goto __error;
 	}
 	snd_cards_lock |= 1 << idx;		/* lock it */
-	write_unlock(&snd_card_rwlock);
+	mutex_unlock(&snd_card_mutex);
 	card->number = idx;
 	card->module = module;
 	INIT_LIST_HEAD(&card->devices);
@@ -173,6 +173,17 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 
 EXPORT_SYMBOL(snd_card_new);
 
+/* return non-zero if a card is already locked */
+int snd_card_locked(int card)
+{
+	int locked;
+
+	mutex_lock(&snd_card_mutex);
+	locked = snd_cards_lock & (1 << card);
+	mutex_unlock(&snd_card_mutex);
+	return locked;
+}
+
 static loff_t snd_disconnect_llseek(struct file *file, loff_t offset, int orig)
 {
 	return -ENODEV;
@@ -240,9 +251,9 @@ int snd_card_disconnect(struct snd_card *card)
 	spin_unlock(&card->files_lock);
 
 	/* phase 1: disable fops (user space) operations for ALSA API */
-	write_lock(&snd_card_rwlock);
+	mutex_lock(&snd_card_mutex);
 	snd_cards[card->number] = NULL;
-	write_unlock(&snd_card_rwlock);
+	mutex_unlock(&snd_card_mutex);
 	
 	/* phase 2: replace file->f_op with special dummy operations */
 	
@@ -321,9 +332,9 @@ int snd_card_free(struct snd_card *card)
 
 	if (card == NULL)
 		return -EINVAL;
-	write_lock(&snd_card_rwlock);
+	mutex_lock(&snd_card_mutex);
 	snd_cards[card->number] = NULL;
-	write_unlock(&snd_card_rwlock);
+	mutex_unlock(&snd_card_mutex);
 
 #ifdef CONFIG_PM
 	wake_up(&card->power_sleep);
@@ -359,9 +370,9 @@ int snd_card_free(struct snd_card *card)
 		card->s_f_ops = s_f_ops->next;
 		kfree(s_f_ops);
 	}
-	write_lock(&snd_card_rwlock);
+	mutex_lock(&snd_card_mutex);
 	snd_cards_lock &= ~(1 << card->number);
-	write_unlock(&snd_card_rwlock);
+	mutex_unlock(&snd_card_mutex);
 	kfree(card);
 	return 0;
 }
@@ -497,16 +508,16 @@ int snd_card_register(struct snd_card *card)
 	snd_assert(card != NULL, return -EINVAL);
 	if ((err = snd_device_register_all(card)) < 0)
 		return err;
-	write_lock(&snd_card_rwlock);
+	mutex_lock(&snd_card_mutex);
 	if (snd_cards[card->number]) {
 		/* already registered */
-		write_unlock(&snd_card_rwlock);
+		mutex_unlock(&snd_card_mutex);
 		return 0;
 	}
 	if (card->id[0] == '\0')
 		choose_default_id(card);
 	snd_cards[card->number] = card;
-	write_unlock(&snd_card_rwlock);
+	mutex_unlock(&snd_card_mutex);
 	init_info_for_card(card);
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
@@ -527,7 +538,7 @@ static void snd_card_info_read(struct snd_info_entry *entry,
 	struct snd_card *card;
 
 	for (idx = count = 0; idx < SNDRV_CARDS; idx++) {
-		read_lock(&snd_card_rwlock);
+		mutex_lock(&snd_card_mutex);
 		if ((card = snd_cards[idx]) != NULL) {
 			count++;
 			snd_iprintf(buffer, "%2i [%-15s]: %s - %s\n",
@@ -538,7 +549,7 @@ static void snd_card_info_read(struct snd_info_entry *entry,
 			snd_iprintf(buffer, "                      %s\n",
 					card->longname);
 		}
-		read_unlock(&snd_card_rwlock);
+		mutex_unlock(&snd_card_mutex);
 	}
 	if (!count)
 		snd_iprintf(buffer, "--- no soundcards ---\n");
@@ -552,12 +563,12 @@ void snd_card_info_read_oss(struct snd_info_buffer *buffer)
 	struct snd_card *card;
 
 	for (idx = count = 0; idx < SNDRV_CARDS; idx++) {
-		read_lock(&snd_card_rwlock);
+		mutex_lock(&snd_card_mutex);
 		if ((card = snd_cards[idx]) != NULL) {
 			count++;
 			snd_iprintf(buffer, "%s\n", card->longname);
 		}
-		read_unlock(&snd_card_rwlock);
+		mutex_unlock(&snd_card_mutex);
 	}
 	if (!count) {
 		snd_iprintf(buffer, "--- no soundcards ---\n");
@@ -575,11 +586,11 @@ static void snd_card_module_info_read(struct snd_info_entry *entry,
 	struct snd_card *card;
 
 	for (idx = 0; idx < SNDRV_CARDS; idx++) {
-		read_lock(&snd_card_rwlock);
+		mutex_lock(&snd_card_mutex);
 		if ((card = snd_cards[idx]) != NULL)
 			snd_iprintf(buffer, "%2i %s\n",
 				    idx, card->module->name);
-		read_unlock(&snd_card_rwlock);
+		mutex_unlock(&snd_card_mutex);
 	}
 }
 #endif

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index b145d17ba3b2..2ff0e5e90865 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -69,7 +69,6 @@ static inline int init_info_for_card(struct snd_card *card)
 		snd_printd("unable to create card entry\n");
 		return err;
 	}
-	entry->c.text.read_size = PAGE_SIZE;
 	entry->c.text.read = snd_card_id_read;
 	if (snd_info_register(entry) < 0) {
 		snd_info_free_entry(entry);
@@ -592,7 +591,6 @@ int __init snd_card_info_init(void)
 	entry = snd_info_create_module_entry(THIS_MODULE, "cards", NULL);
 	if (! entry)
 		return -ENOMEM;
-	entry->c.text.read_size = PAGE_SIZE;
 	entry->c.text.read = snd_card_info_read;
 	if (snd_info_register(entry) < 0) {
 		snd_info_free_entry(entry);
@@ -603,7 +601,6 @@ int __init snd_card_info_init(void)
 #ifdef MODULE
 	entry = snd_info_create_module_entry(THIS_MODULE, "modules", NULL);
 	if (entry) {
-		entry->c.text.read_size = PAGE_SIZE;
 		entry->c.text.read = snd_card_module_info_read;
 		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);

commit c0d3fb39e9511c6fad17d059a3a50d1be33add24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:39 2006 +0200

    [ALSA] Clean up EXPORT_SYMBOL()s in snd module
    
    Move EXPORT_SYMBOL()s to places adjacent to functions/variables.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 39ed2e5bb0af..b145d17ba3b2 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -40,10 +40,13 @@ struct snd_shutdown_f_ops {
 
 unsigned int snd_cards_lock = 0;	/* locked for registering/using */
 struct snd_card *snd_cards[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = NULL};
+EXPORT_SYMBOL(snd_cards);
+
 DEFINE_RWLOCK(snd_card_rwlock);
 
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);
+EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
 #endif
 
 #ifdef CONFIG_PROC_FS
@@ -169,6 +172,8 @@ struct snd_card *snd_card_new(int idx, const char *xid,
       	return NULL;
 }
 
+EXPORT_SYMBOL(snd_card_new);
+
 static loff_t snd_disconnect_llseek(struct file *file, loff_t offset, int orig)
 {
 	return -ENODEV;
@@ -298,6 +303,8 @@ int snd_card_disconnect(struct snd_card *card)
 	return 0;	
 }
 
+EXPORT_SYMBOL(snd_card_disconnect);
+
 /**
  *  snd_card_free - frees given soundcard structure
  *  @card: soundcard structure
@@ -360,6 +367,8 @@ int snd_card_free(struct snd_card *card)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_card_free);
+
 static void snd_card_free_thread(void * __card)
 {
 	struct snd_card *card = __card;
@@ -405,6 +414,8 @@ int snd_card_free_in_thread(struct snd_card *card)
 	return -EFAULT;
 }
 
+EXPORT_SYMBOL(snd_card_free_in_thread);
+
 static void choose_default_id(struct snd_card *card)
 {
 	int i, len, idx_flag = 0, loops = SNDRV_CARDS;
@@ -505,6 +516,8 @@ int snd_card_register(struct snd_card *card)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_card_register);
+
 #ifdef CONFIG_PROC_FS
 static struct snd_info_entry *snd_card_info_entry = NULL;
 
@@ -644,6 +657,8 @@ int snd_component_add(struct snd_card *card, const char *component)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_component_add);
+
 /**
  *  snd_card_file_add - add the file to the file list of the card
  *  @card: soundcard structure
@@ -676,6 +691,8 @@ int snd_card_file_add(struct snd_card *card, struct file *file)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_card_file_add);
+
 /**
  *  snd_card_file_remove - remove the file from the file list
  *  @card: soundcard structure
@@ -717,6 +734,8 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_card_file_remove);
+
 #ifdef CONFIG_PM
 /**
  *  snd_power_wait - wait until the power-state is changed.
@@ -753,4 +772,5 @@ int snd_power_wait(struct snd_card *card, unsigned int power_state)
 	return result;
 }
 
+EXPORT_SYMBOL(snd_power_wait);
 #endif /* CONFIG_PM */

commit cbac4b0cb62d01cb0aaec7778410b8856f01186b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 27 12:38:07 2006 +0200

    [ALSA] Cleanup unused argument for snd_power_wait()
    
    Removed the unused file argument of snd_power_wait().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 5bb8a8b23d51..39ed2e5bb0af 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -722,13 +722,12 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
  *  snd_power_wait - wait until the power-state is changed.
  *  @card: soundcard structure
  *  @power_state: expected power state
- *  @file: file structure for the O_NONBLOCK check (optional)
  *
  *  Waits until the power-state is changed.
  *
  *  Note: the power lock must be active before call.
  */
-int snd_power_wait(struct snd_card *card, unsigned int power_state, struct file *file)
+int snd_power_wait(struct snd_card *card, unsigned int power_state)
 {
 	wait_queue_t wait;
 	int result = 0;
@@ -745,12 +744,6 @@ int snd_power_wait(struct snd_card *card, unsigned int power_state, struct file
 		}
 		if (snd_power_get_state(card) == power_state)
 			break;
-#if 0 /* block all devices */
-		if (file && (file->f_flags & O_NONBLOCK)) {
-			result = -EAGAIN;
-			break;
-		}
-#endif
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		snd_power_unlock(card);
 		schedule_timeout(30 * HZ);

commit 99ac48f54a91d02140c497edc31dc57d4bc5c85d
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:41 2006 -0800

    [PATCH] mark f_ops const in the inode
    
    Mark the f_ops members of inodes as const, as well as fix the
    ripple-through this causes by places that copy this f_ops and then "do
    stuff" with it.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/init.c b/sound/core/init.c
index ad68761abba1..5bb8a8b23d51 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -223,7 +223,8 @@ int snd_card_disconnect(struct snd_card *card)
 	struct snd_monitor_file *mfile;
 	struct file *file;
 	struct snd_shutdown_f_ops *s_f_ops;
-	struct file_operations *f_ops, *old_f_ops;
+	struct file_operations *f_ops;
+	const struct file_operations *old_f_ops;
 	int err;
 
 	spin_lock(&card->files_lock);

commit b3b0abe11d606fa2344793edd3d69b98b430b0d4
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Mar 3 14:08:43 2006 +0100

    [ALSA] return ENODEV for disconnected devices
    
    Modules: ALSA Core
    
    Add dummy functions that return -ENODEV for the struct file_operations
    of a disconnected device.  Without such functions, userspace would get
    ENOTTY.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 17fbd6c14fb8..ad68761abba1 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -169,11 +169,44 @@ struct snd_card *snd_card_new(int idx, const char *xid,
       	return NULL;
 }
 
+static loff_t snd_disconnect_llseek(struct file *file, loff_t offset, int orig)
+{
+	return -ENODEV;
+}
+
+static ssize_t snd_disconnect_read(struct file *file, char __user *buf,
+				   size_t count, loff_t *offset)
+{
+	return -ENODEV;
+}
+
+static ssize_t snd_disconnect_write(struct file *file, const char __user *buf,
+				    size_t count, loff_t *offset)
+{
+	return -ENODEV;
+}
+
 static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)
 {
 	return POLLERR | POLLNVAL;
 }
 
+static long snd_disconnect_ioctl(struct file *file,
+				 unsigned int cmd, unsigned long arg)
+{
+	return -ENODEV;
+}
+
+static int snd_disconnect_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	return -ENODEV;
+}
+
+static int snd_disconnect_fasync(int fd, struct file *file, int on)
+{
+	return -ENODEV;
+}
+
 /**
  *  snd_card_disconnect - disconnect all APIs from the file-operations (user space)
  *  @card: soundcard structure
@@ -224,7 +257,16 @@ int snd_card_disconnect(struct snd_card *card)
 		memset(f_ops, 0, sizeof(*f_ops));
 		f_ops->owner = file->f_op->owner;
 		f_ops->release = file->f_op->release;
+		f_ops->llseek = snd_disconnect_llseek;
+		f_ops->read = snd_disconnect_read;
+		f_ops->write = snd_disconnect_write;
 		f_ops->poll = snd_disconnect_poll;
+		f_ops->unlocked_ioctl = snd_disconnect_ioctl;
+#ifdef CONFIG_COMPAT
+		f_ops->compat_ioctl = snd_disconnect_ioctl;
+#endif
+		f_ops->mmap = snd_disconnect_mmap;
+		f_ops->fasync = snd_disconnect_fasync;
 
 		s_f_ops->next = card->s_f_ops;
 		card->s_f_ops = s_f_ops;

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 75816688607c..17fbd6c14fb8 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -145,7 +145,7 @@ struct snd_card *snd_card_new(int idx, const char *xid,
 	init_waitqueue_head(&card->shutdown_sleep);
 	INIT_WORK(&card->free_workq, snd_card_free_thread, card);
 #ifdef CONFIG_PM
-	init_MUTEX(&card->power_lock);
+	mutex_init(&card->power_lock);
 	init_waitqueue_head(&card->power_sleep);
 #endif
 	/* the control interface cannot be accessed from the user space until */

commit e28563cceb9f258ebe3c50fc27d8f4ff0ac4bfa4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:42:42 2005 +0100

    [ALSA] Optimize for config without PROC_FS
    
    Modules: HWDEP Midlevel,ALSA Core,PCM Midlevel,Timer Midlevel
    
    Optimize the code when compiled without CONFIG_PROC_FS.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 58e17d385f8d..75816688607c 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -46,12 +46,39 @@ DEFINE_RWLOCK(snd_card_rwlock);
 int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);
 #endif
 
+#ifdef CONFIG_PROC_FS
 static void snd_card_id_read(struct snd_info_entry *entry,
 			     struct snd_info_buffer *buffer)
 {
 	snd_iprintf(buffer, "%s\n", entry->card->id);
 }
 
+static inline int init_info_for_card(struct snd_card *card)
+{
+	int err;
+	struct snd_info_entry *entry;
+
+	if ((err = snd_info_card_register(card)) < 0) {
+		snd_printd("unable to create card info\n");
+		return err;
+	}
+	if ((entry = snd_info_create_card_entry(card, "id", card->proc_root)) == NULL) {
+		snd_printd("unable to create card entry\n");
+		return err;
+	}
+	entry->c.text.read_size = PAGE_SIZE;
+	entry->c.text.read = snd_card_id_read;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		entry = NULL;
+	}
+	card->proc_id = entry;
+	return 0;
+}
+#else /* !CONFIG_PROC_FS */
+#define init_info_for_card(card)
+#endif
+
 static void snd_card_free_thread(void * __card);
 
 /**
@@ -273,8 +300,7 @@ int snd_card_free(struct snd_card *card)
 	}
 	if (card->private_free)
 		card->private_free(card);
-	if (card->proc_id)
-		snd_info_unregister(card->proc_id);
+	snd_info_unregister(card->proc_id);
 	if (snd_info_card_free(card) < 0) {
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
@@ -414,7 +440,6 @@ static void choose_default_id(struct snd_card *card)
 int snd_card_register(struct snd_card *card)
 {
 	int err;
-	struct snd_info_entry *entry;
 
 	snd_assert(card != NULL, return -EINVAL);
 	if ((err = snd_device_register_all(card)) < 0)
@@ -429,22 +454,7 @@ int snd_card_register(struct snd_card *card)
 		choose_default_id(card);
 	snd_cards[card->number] = card;
 	write_unlock(&snd_card_rwlock);
-	if ((err = snd_info_card_register(card)) < 0) {
-		snd_printd("unable to create card info\n");
-		goto __skip_info;
-	}
-	if ((entry = snd_info_create_card_entry(card, "id", card->proc_root)) == NULL) {
-		snd_printd("unable to create card entry\n");
-		goto __skip_info;
-	}
-	entry->c.text.read_size = PAGE_SIZE;
-	entry->c.text.read = snd_card_id_read;
-	if (snd_info_register(entry) < 0) {
-		snd_info_free_entry(entry);
-		entry = NULL;
-	}
-	card->proc_id = entry;
-      __skip_info:
+	init_info_for_card(card);
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);
@@ -452,6 +462,7 @@ int snd_card_register(struct snd_card *card)
 	return 0;
 }
 
+#ifdef CONFIG_PROC_FS
 static struct snd_info_entry *snd_card_info_entry = NULL;
 
 static void snd_card_info_read(struct snd_info_entry *entry,
@@ -478,7 +489,7 @@ static void snd_card_info_read(struct snd_info_entry *entry,
 		snd_iprintf(buffer, "--- no soundcards ---\n");
 }
 
-#if defined(CONFIG_SND_OSSEMUL) && defined(CONFIG_PROC_FS)
+#ifdef CONFIG_SND_OSSEMUL
 
 void snd_card_info_read_oss(struct snd_info_buffer *buffer)
 {
@@ -550,15 +561,15 @@ int __init snd_card_info_init(void)
 
 int __exit snd_card_info_done(void)
 {
-	if (snd_card_info_entry)
-		snd_info_unregister(snd_card_info_entry);
+	snd_info_unregister(snd_card_info_entry);
 #ifdef MODULE
-	if (snd_card_module_info_entry)
-		snd_info_unregister(snd_card_module_info_entry);
+	snd_info_unregister(snd_card_module_info_entry);
 #endif
 	return 0;
 }
 
+#endif /* CONFIG_PROC_FS */
+
 /**
  *  snd_component_add - add a component string
  *  @card: soundcard structure

commit d001544ded23ddb1116f945ccc2d89a7f98ab7e8
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:09:05 2005 +0100

    [ALSA] dynamic minors (6/6): increase maximum number of sound cards
    
    Modules: ALSA Core,Memalloc module,ALSA sequencer
    
    With dynamic minor numbers, we can increase the number of sound cards.
    
    This requires that the sequencer client numbers of some kernel drivers
    are allocated dynamically, too.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 728bb2ce0bc7..58e17d385f8d 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -338,7 +338,7 @@ int snd_card_free_in_thread(struct snd_card *card)
 
 static void choose_default_id(struct snd_card *card)
 {
-	int i, len, idx_flag = 0, loops = 8;
+	int i, len, idx_flag = 0, loops = SNDRV_CARDS;
 	char *id, *spos;
 	
 	id = spos = card->shortname;	
@@ -380,9 +380,12 @@ static void choose_default_id(struct snd_card *card)
 
 	      __change:
 		len = strlen(id);
-		if (idx_flag)
-			id[len-1]++;
-		else if ((size_t)len <= sizeof(card->id) - 3) {
+		if (idx_flag) {
+			if (id[len-1] != '9')
+				id[len-1]++;
+			else
+				id[len-1] = 'A';
+		} else if ((size_t)len <= sizeof(card->id) - 3) {
 			strcat(id, "_1");
 			idx_flag++;
 		} else {
@@ -461,12 +464,12 @@ static void snd_card_info_read(struct snd_info_entry *entry,
 		read_lock(&snd_card_rwlock);
 		if ((card = snd_cards[idx]) != NULL) {
 			count++;
-			snd_iprintf(buffer, "%i [%-15s]: %s - %s\n",
+			snd_iprintf(buffer, "%2i [%-15s]: %s - %s\n",
 					idx,
 					card->id,
 					card->driver,
 					card->shortname);
-			snd_iprintf(buffer, "                     %s\n",
+			snd_iprintf(buffer, "                      %s\n",
 					card->longname);
 		}
 		read_unlock(&snd_card_rwlock);
@@ -508,7 +511,8 @@ static void snd_card_module_info_read(struct snd_info_entry *entry,
 	for (idx = 0; idx < SNDRV_CARDS; idx++) {
 		read_lock(&snd_card_rwlock);
 		if ((card = snd_cards[idx]) != NULL)
-			snd_iprintf(buffer, "%i %s\n", idx, card->module->name);
+			snd_iprintf(buffer, "%2i %s\n",
+				    idx, card->module->name);
 		read_unlock(&snd_card_rwlock);
 	}
 }

commit a381a7a66486f11606eccb8866e29848f995278f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:55:49 2005 +0100

    [ALSA] Decentralize PM control
    
    Modules: ALSA Core,Control Midlevel,/oss/Makefile
    
    Remove the centralized PM control in the sound core.
    Each driver is responsible to get callbacks from bus/driver now.
    
    SND_GENERIC_DRIVER is removed together with this action.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index dca64d199cbe..728bb2ce0bc7 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -28,7 +28,6 @@
 #include <linux/ctype.h>
 #include <linux/pci.h>
 #include <linux/pm.h>
-#include <linux/platform_device.h>
 
 #include <sound/core.h>
 #include <sound/control.h>
@@ -229,12 +228,6 @@ int snd_card_disconnect(struct snd_card *card)
 	return 0;	
 }
 
-#ifdef CONFIG_SND_GENERIC_DRIVER
-static void snd_generic_device_unregister(struct snd_card *card);
-#else
-#define snd_generic_device_unregister(x) /*NOP*/
-#endif
-
 /**
  *  snd_card_free - frees given soundcard structure
  *  @card: soundcard structure
@@ -286,7 +279,6 @@ int snd_card_free(struct snd_card *card)
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
 	}
-	snd_generic_device_unregister(card);
 	while (card->s_f_ops) {
 		s_f_ops = card->s_f_ops;
 		card->s_f_ops = s_f_ops->next;
@@ -459,7 +451,8 @@ int snd_card_register(struct snd_card *card)
 
 static struct snd_info_entry *snd_card_info_entry = NULL;
 
-static void snd_card_info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+static void snd_card_info_read(struct snd_info_entry *entry,
+			       struct snd_info_buffer *buffer)
 {
 	int idx, count;
 	struct snd_card *card;
@@ -666,97 +659,6 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 	return 0;
 }
 
-#ifdef CONFIG_SND_GENERIC_DRIVER
-/*
- * generic device without a proper bus using platform_device
- * (e.g. ISA)
- */
-struct snd_generic_device {
-	struct platform_device pdev;
-	struct snd_card *card;
-};
-
-#define get_snd_generic_card(dev)	container_of(dev, struct snd_generic_device, pdev)->card
-
-#define SND_GENERIC_NAME	"snd_generic"
-
-#ifdef CONFIG_PM
-static int snd_generic_suspend(struct platform_device *dev, pm_message_t state);
-static int snd_generic_resume(struct platform_device *dev);
-#endif
-
-/* initialized in sound.c */
-struct platform_driver snd_generic_driver = {
-#ifdef CONFIG_PM
-	.suspend	= snd_generic_suspend,
-	.resume		= snd_generic_resume,
-#endif
-	.driver		= {
-		.name	= SND_GENERIC_NAME,
-	},
-};
-
-void snd_generic_device_release(struct device *dev)
-{
-}
-
-static int snd_generic_device_register(struct snd_card *card)
-{
-	struct snd_generic_device *dev;
-	int err;
-
-	if (card->generic_dev)
-		return 0; /* already registered */
-
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (! dev) {
-		snd_printk(KERN_ERR "can't allocate generic_device\n");
-		return -ENOMEM;
-	}
-
-	dev->pdev.name = SND_GENERIC_NAME;
-	dev->pdev.id = card->number;
-	dev->pdev.dev.release = snd_generic_device_release;
-	dev->card = card;
-	if ((err = platform_device_register(&dev->pdev)) < 0) {
-		kfree(dev);
-		return err;
-	}
-	card->generic_dev = dev;
-	return 0;
-}
-
-static void snd_generic_device_unregister(struct snd_card *card)
-{
-	struct snd_generic_device *dev = card->generic_dev;
-	if (dev) {
-		platform_device_unregister(&dev->pdev);
-		kfree(dev);
-		card->generic_dev = NULL;
-	}
-}
-
-/**
- * snd_card_set_generic_dev - assign the generic device to the card
- * @card: soundcard structure
- *
- * Assigns a generic device to the card.  This function is provided as the
- * last resort, for devices without any proper bus.  Thus this won't override
- * the device already assigned to the card.
- * 
- * Returns zero if successful, or a negative error code.
- */
-int snd_card_set_generic_dev(struct snd_card *card)
-{
-	int err;
-	if ((err = snd_generic_device_register(card)) < 0)
-		return err;
-	if (! card->dev)
-		snd_card_set_dev(card, &card->generic_dev->pdev.dev);
-	return 0;
-}
-#endif /* CONFIG_SND_GENERIC_DRIVER */
-
 #ifdef CONFIG_PM
 /**
  *  snd_power_wait - wait until the power-state is changed.
@@ -800,107 +702,4 @@ int snd_power_wait(struct snd_card *card, unsigned int power_state, struct file
 	return result;
 }
 
-/**
- * snd_card_set_pm_callback - set the PCI power-management callbacks
- * @card: soundcard structure
- * @suspend: suspend callback function
- * @resume: resume callback function
- * @private_data: private data to pass to the callback functions
- *
- * Sets the power-management callback functions of the card.
- * These callbacks are called from ALSA's common PCI suspend/resume
- * handler and from the control API.
- */
-int snd_card_set_pm_callback(struct snd_card *card,
-			     int (*suspend)(struct snd_card *, pm_message_t),
-			     int (*resume)(struct snd_card *),
-			     void *private_data)
-{
-	card->pm_suspend = suspend;
-	card->pm_resume = resume;
-	card->pm_private_data = private_data;
-	return 0;
-}
-
-#ifdef CONFIG_SND_GENERIC_DRIVER
-/* suspend/resume callbacks for snd_generic platform device */
-static int snd_generic_suspend(struct platform_device *dev, pm_message_t state)
-{
-	struct snd_card *card;
-
-	card = get_snd_generic_card(dev);
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return 0;
-	if (card->pm_suspend)
-		card->pm_suspend(card, PMSG_SUSPEND);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	return 0;
-}
-
-static int snd_generic_resume(struct platform_device *dev)
-{
-	struct snd_card *card;
-
-	card = get_snd_generic_card(dev);
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return 0;
-	if (card->pm_resume)
-		card->pm_resume(card);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-	return 0;
-}
-
-/**
- * snd_card_set_generic_pm_callback - set the generic power-management callbacks
- * @card: soundcard structure
- * @suspend: suspend callback function
- * @resume: resume callback function
- * @private_data: private data to pass to the callback functions
- *
- * Registers the power-management and sets the lowlevel callbacks for
- * the given card.  These callbacks are called from the ALSA's common
- * PM handler and from the control API.
- */
-int snd_card_set_generic_pm_callback(struct snd_card *card,
-				 int (*suspend)(struct snd_card *, pm_message_t),
-				 int (*resume)(struct snd_card *),
-				 void *private_data)
-{
-	int err;
-	if ((err = snd_generic_device_register(card)) < 0)
-		return err;
-	return snd_card_set_pm_callback(card, suspend, resume, private_data);
-}
-#endif /* CONFIG_SND_GENERIC_DRIVER */
-
-#ifdef CONFIG_PCI
-int snd_card_pci_suspend(struct pci_dev *dev, pm_message_t state)
-{
-	struct snd_card *card = pci_get_drvdata(dev);
-	int err;
-	if (! card || ! card->pm_suspend)
-		return 0;
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return 0;
-	err = card->pm_suspend(card, PMSG_SUSPEND);
-	pci_save_state(dev);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	return err;
-}
-
-int snd_card_pci_resume(struct pci_dev *dev)
-{
-	struct snd_card *card = pci_get_drvdata(dev);
-	if (! card || ! card->pm_resume)
-		return 0;
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return 0;
-	/* restore the PCI config space */
-	pci_restore_state(dev);
-	card->pm_resume(card);
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-	return 0;
-}
-#endif
-
 #endif /* CONFIG_PM */

commit 512bbd6a85230f16389f0dd51925472e72fc8a91
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:51:18 2005 +0100

    [ALSA] Remove xxx_t typedefs: Core component
    
    Modules: ALSA Core
    
    Remove xxx_t typedefs from the core component.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 33813f92ab52..dca64d199cbe 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -40,14 +40,15 @@ struct snd_shutdown_f_ops {
 };
 
 unsigned int snd_cards_lock = 0;	/* locked for registering/using */
-snd_card_t *snd_cards[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = NULL};
+struct snd_card *snd_cards[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = NULL};
 DEFINE_RWLOCK(snd_card_rwlock);
 
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
-int (*snd_mixer_oss_notify_callback)(snd_card_t *card, int free_flag);
+int (*snd_mixer_oss_notify_callback)(struct snd_card *card, int free_flag);
 #endif
 
-static void snd_card_id_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void snd_card_id_read(struct snd_info_entry *entry,
+			     struct snd_info_buffer *buffer)
 {
 	snd_iprintf(buffer, "%s\n", entry->card->id);
 }
@@ -63,13 +64,13 @@ static void snd_card_free_thread(void * __card);
  *
  *  Creates and initializes a soundcard structure.
  *
- *  Returns kmallocated snd_card_t structure. Creates the ALSA control interface
+ *  Returns kmallocated snd_card structure. Creates the ALSA control interface
  *  (which is blocked until snd_card_register function is called).
  */
-snd_card_t *snd_card_new(int idx, const char *xid,
+struct snd_card *snd_card_new(int idx, const char *xid,
 			 struct module *module, int extra_size)
 {
-	snd_card_t *card;
+	struct snd_card *card;
 	int err;
 
 	if (extra_size < 0)
@@ -132,7 +133,7 @@ snd_card_t *snd_card_new(int idx, const char *xid,
 		goto __error_ctl;
 	}
 	if (extra_size > 0)
-		card->private_data = (char *)card + sizeof(snd_card_t);
+		card->private_data = (char *)card + sizeof(struct snd_card);
 	return card;
 
       __error_ctl:
@@ -158,7 +159,7 @@ static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)
  *  Note: The current implementation replaces all active file->f_op with special
  *        dummy file operations (they do nothing except release).
  */
-int snd_card_disconnect(snd_card_t * card)
+int snd_card_disconnect(struct snd_card *card)
 {
 	struct snd_monitor_file *mfile;
 	struct file *file;
@@ -229,7 +230,7 @@ int snd_card_disconnect(snd_card_t * card)
 }
 
 #ifdef CONFIG_SND_GENERIC_DRIVER
-static void snd_generic_device_unregister(snd_card_t *card);
+static void snd_generic_device_unregister(struct snd_card *card);
 #else
 #define snd_generic_device_unregister(x) /*NOP*/
 #endif
@@ -245,7 +246,7 @@ static void snd_generic_device_unregister(snd_card_t *card);
  *  Returns zero. Frees all associated devices and frees the control
  *  interface associated to given soundcard.
  */
-int snd_card_free(snd_card_t * card)
+int snd_card_free(struct snd_card *card)
 {
 	struct snd_shutdown_f_ops *s_f_ops;
 
@@ -300,7 +301,7 @@ int snd_card_free(snd_card_t * card)
 
 static void snd_card_free_thread(void * __card)
 {
-	snd_card_t *card = __card;
+	struct snd_card *card = __card;
 	struct module * module = card->module;
 
 	if (!try_module_get(module)) {
@@ -327,7 +328,7 @@ static void snd_card_free_thread(void * __card)
  *  
  *  Returns - zero otherwise a negative error code if the start of thread failed.
  */
-int snd_card_free_in_thread(snd_card_t * card)
+int snd_card_free_in_thread(struct snd_card *card)
 {
 	if (card->files == NULL) {
 		snd_card_free(card);
@@ -343,7 +344,7 @@ int snd_card_free_in_thread(snd_card_t * card)
 	return -EFAULT;
 }
 
-static void choose_default_id(snd_card_t * card)
+static void choose_default_id(struct snd_card *card)
 {
 	int i, len, idx_flag = 0, loops = 8;
 	char *id, *spos;
@@ -415,10 +416,10 @@ static void choose_default_id(snd_card_t * card)
  *
  *  Returns zero otherwise a negative error code if the registrain failed.
  */
-int snd_card_register(snd_card_t * card)
+int snd_card_register(struct snd_card *card)
 {
 	int err;
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	snd_assert(card != NULL, return -EINVAL);
 	if ((err = snd_device_register_all(card)) < 0)
@@ -456,12 +457,12 @@ int snd_card_register(snd_card_t * card)
 	return 0;
 }
 
-static snd_info_entry_t *snd_card_info_entry = NULL;
+static struct snd_info_entry *snd_card_info_entry = NULL;
 
-static void snd_card_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void snd_card_info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	int idx, count;
-	snd_card_t *card;
+	struct snd_card *card;
 
 	for (idx = count = 0; idx < SNDRV_CARDS; idx++) {
 		read_lock(&snd_card_rwlock);
@@ -483,10 +484,10 @@ static void snd_card_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buff
 
 #if defined(CONFIG_SND_OSSEMUL) && defined(CONFIG_PROC_FS)
 
-void snd_card_info_read_oss(snd_info_buffer_t * buffer)
+void snd_card_info_read_oss(struct snd_info_buffer *buffer)
 {
 	int idx, count;
-	snd_card_t *card;
+	struct snd_card *card;
 
 	for (idx = count = 0; idx < SNDRV_CARDS; idx++) {
 		read_lock(&snd_card_rwlock);
@@ -504,11 +505,12 @@ void snd_card_info_read_oss(snd_info_buffer_t * buffer)
 #endif
 
 #ifdef MODULE
-static snd_info_entry_t *snd_card_module_info_entry;
-static void snd_card_module_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static struct snd_info_entry *snd_card_module_info_entry;
+static void snd_card_module_info_read(struct snd_info_entry *entry,
+				      struct snd_info_buffer *buffer)
 {
 	int idx;
-	snd_card_t *card;
+	struct snd_card *card;
 
 	for (idx = 0; idx < SNDRV_CARDS; idx++) {
 		read_lock(&snd_card_rwlock);
@@ -521,7 +523,7 @@ static void snd_card_module_info_read(snd_info_entry_t *entry, snd_info_buffer_t
 
 int __init snd_card_info_init(void)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	entry = snd_info_create_module_entry(THIS_MODULE, "cards", NULL);
 	if (! entry)
@@ -571,7 +573,7 @@ int __exit snd_card_info_done(void)
  *  Returns zero otherwise a negative error code.
  */
   
-int snd_component_add(snd_card_t *card, const char *component)
+int snd_component_add(struct snd_card *card, const char *component)
 {
 	char *ptr;
 	int len = strlen(component);
@@ -602,7 +604,7 @@ int snd_component_add(snd_card_t *card, const char *component)
  *
  *  Returns zero or a negative error code.
  */
-int snd_card_file_add(snd_card_t *card, struct file *file)
+int snd_card_file_add(struct snd_card *card, struct file *file)
 {
 	struct snd_monitor_file *mfile;
 
@@ -636,7 +638,7 @@ int snd_card_file_add(snd_card_t *card, struct file *file)
  *
  *  Returns zero or a negative error code.
  */
-int snd_card_file_remove(snd_card_t *card, struct file *file)
+int snd_card_file_remove(struct snd_card *card, struct file *file)
 {
 	struct snd_monitor_file *mfile, *pfile = NULL;
 
@@ -671,7 +673,7 @@ int snd_card_file_remove(snd_card_t *card, struct file *file)
  */
 struct snd_generic_device {
 	struct platform_device pdev;
-	snd_card_t *card;
+	struct snd_card *card;
 };
 
 #define get_snd_generic_card(dev)	container_of(dev, struct snd_generic_device, pdev)->card
@@ -698,7 +700,7 @@ void snd_generic_device_release(struct device *dev)
 {
 }
 
-static int snd_generic_device_register(snd_card_t *card)
+static int snd_generic_device_register(struct snd_card *card)
 {
 	struct snd_generic_device *dev;
 	int err;
@@ -724,7 +726,7 @@ static int snd_generic_device_register(snd_card_t *card)
 	return 0;
 }
 
-static void snd_generic_device_unregister(snd_card_t *card)
+static void snd_generic_device_unregister(struct snd_card *card)
 {
 	struct snd_generic_device *dev = card->generic_dev;
 	if (dev) {
@@ -744,7 +746,7 @@ static void snd_generic_device_unregister(snd_card_t *card)
  * 
  * Returns zero if successful, or a negative error code.
  */
-int snd_card_set_generic_dev(snd_card_t *card)
+int snd_card_set_generic_dev(struct snd_card *card)
 {
 	int err;
 	if ((err = snd_generic_device_register(card)) < 0)
@@ -766,7 +768,7 @@ int snd_card_set_generic_dev(snd_card_t *card)
  *
  *  Note: the power lock must be active before call.
  */
-int snd_power_wait(snd_card_t *card, unsigned int power_state, struct file *file)
+int snd_power_wait(struct snd_card *card, unsigned int power_state, struct file *file)
 {
 	wait_queue_t wait;
 	int result = 0;
@@ -809,9 +811,9 @@ int snd_power_wait(snd_card_t *card, unsigned int power_state, struct file *file
  * These callbacks are called from ALSA's common PCI suspend/resume
  * handler and from the control API.
  */
-int snd_card_set_pm_callback(snd_card_t *card,
-			     int (*suspend)(snd_card_t *, pm_message_t),
-			     int (*resume)(snd_card_t *),
+int snd_card_set_pm_callback(struct snd_card *card,
+			     int (*suspend)(struct snd_card *, pm_message_t),
+			     int (*resume)(struct snd_card *),
 			     void *private_data)
 {
 	card->pm_suspend = suspend;
@@ -824,7 +826,7 @@ int snd_card_set_pm_callback(snd_card_t *card,
 /* suspend/resume callbacks for snd_generic platform device */
 static int snd_generic_suspend(struct platform_device *dev, pm_message_t state)
 {
-	snd_card_t *card;
+	struct snd_card *card;
 
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D3hot)
@@ -837,7 +839,7 @@ static int snd_generic_suspend(struct platform_device *dev, pm_message_t state)
 
 static int snd_generic_resume(struct platform_device *dev)
 {
-	snd_card_t *card;
+	struct snd_card *card;
 
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D0)
@@ -859,9 +861,9 @@ static int snd_generic_resume(struct platform_device *dev)
  * the given card.  These callbacks are called from the ALSA's common
  * PM handler and from the control API.
  */
-int snd_card_set_generic_pm_callback(snd_card_t *card,
-				 int (*suspend)(snd_card_t *, pm_message_t),
-				 int (*resume)(snd_card_t *),
+int snd_card_set_generic_pm_callback(struct snd_card *card,
+				 int (*suspend)(struct snd_card *, pm_message_t),
+				 int (*resume)(struct snd_card *),
 				 void *private_data)
 {
 	int err;
@@ -874,7 +876,7 @@ int snd_card_set_generic_pm_callback(snd_card_t *card,
 #ifdef CONFIG_PCI
 int snd_card_pci_suspend(struct pci_dev *dev, pm_message_t state)
 {
-	snd_card_t *card = pci_get_drvdata(dev);
+	struct snd_card *card = pci_get_drvdata(dev);
 	int err;
 	if (! card || ! card->pm_suspend)
 		return 0;
@@ -888,7 +890,7 @@ int snd_card_pci_suspend(struct pci_dev *dev, pm_message_t state)
 
 int snd_card_pci_resume(struct pci_dev *dev)
 {
-	snd_card_t *card = pci_get_drvdata(dev);
+	struct snd_card *card = pci_get_drvdata(dev);
 	if (! card || ! card->pm_resume)
 		return 0;
 	if (card->power_state == SNDRV_CTL_POWER_D0)

commit 3ae5eaec1d2d9c0cf53745352e7d4b152810ba24
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Nov 9 22:32:44 2005 +0000

    [DRIVER MODEL] Convert platform drivers to use struct platform_driver
    
    This allows us to eliminate the casts in the drivers, and eventually
    remove the use of the device_driver function pointer methods for
    platform device drivers.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index d9ee27ae9a51..33813f92ab52 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -674,23 +674,24 @@ struct snd_generic_device {
 	snd_card_t *card;
 };
 
-#define get_snd_generic_card(dev)	container_of(to_platform_device(dev), struct snd_generic_device, pdev)->card
+#define get_snd_generic_card(dev)	container_of(dev, struct snd_generic_device, pdev)->card
 
 #define SND_GENERIC_NAME	"snd_generic"
 
 #ifdef CONFIG_PM
-static int snd_generic_suspend(struct device *dev, pm_message_t state);
-static int snd_generic_resume(struct device *dev);
+static int snd_generic_suspend(struct platform_device *dev, pm_message_t state);
+static int snd_generic_resume(struct platform_device *dev);
 #endif
 
 /* initialized in sound.c */
-struct device_driver snd_generic_driver = {
-	.name		= SND_GENERIC_NAME,
-	.bus		= &platform_bus_type,
+struct platform_driver snd_generic_driver = {
 #ifdef CONFIG_PM
 	.suspend	= snd_generic_suspend,
 	.resume		= snd_generic_resume,
 #endif
+	.driver		= {
+		.name	= SND_GENERIC_NAME,
+	},
 };
 
 void snd_generic_device_release(struct device *dev)
@@ -821,7 +822,7 @@ int snd_card_set_pm_callback(snd_card_t *card,
 
 #ifdef CONFIG_SND_GENERIC_DRIVER
 /* suspend/resume callbacks for snd_generic platform device */
-static int snd_generic_suspend(struct device *dev, pm_message_t state)
+static int snd_generic_suspend(struct platform_device *dev, pm_message_t state)
 {
 	snd_card_t *card;
 
@@ -834,7 +835,7 @@ static int snd_generic_suspend(struct device *dev, pm_message_t state)
 	return 0;
 }
 
-static int snd_generic_resume(struct device *dev)
+static int snd_generic_resume(struct platform_device *dev)
 {
 	snd_card_t *card;
 

commit aa92c4af15224d8a96343286cdcf7c73b2ad3809
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 25 10:58:59 2005 +0200

    [ALSA] Fix a typo in the last fix
    
    Modules: ALSA Core
    
    Fix a typo (bogus check) in the last patch to fix Oops with suspend/resume.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index b98f7c6310c5..d9ee27ae9a51 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -841,7 +841,7 @@ static int snd_generic_resume(struct device *dev)
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D0)
 		return 0;
-	if (card->pm_suspend)
+	if (card->pm_resume)
 		card->pm_resume(card);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;

commit 7c22f1aaa23370bf9ba2dd3abbccbed70dced216
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:46:31 2005 +0200

    [ALSA] Remove snd_runtime_check() macro
    
    Remove snd_runtime_check() macro.
    This macro worsens the readability of codes.  They should be either
    normal if() or removable asserts.
    
    Also, the assert displays stack-dump, instead of only the last caller
    pointer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 41e224986f35..b98f7c6310c5 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -420,7 +420,7 @@ int snd_card_register(snd_card_t * card)
 	int err;
 	snd_info_entry_t *entry;
 
-	snd_runtime_check(card != NULL, return -EINVAL);
+	snd_assert(card != NULL, return -EINVAL);
 	if ((err = snd_device_register_all(card)) < 0)
 		return err;
 	write_lock(&snd_card_rwlock);
@@ -524,7 +524,8 @@ int __init snd_card_info_init(void)
 	snd_info_entry_t *entry;
 
 	entry = snd_info_create_module_entry(THIS_MODULE, "cards", NULL);
-	snd_runtime_check(entry != NULL, return -ENOMEM);
+	if (! entry)
+		return -ENOMEM;
 	entry->c.text.read_size = PAGE_SIZE;
 	entry->c.text.read = snd_card_info_read;
 	if (snd_info_register(entry) < 0) {

commit d052d1beff706920e82c5d55006b08e256b5df09
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Oct 29 19:07:23 2005 +0100

    Create platform_device.h to contain all the platform device details.
    Convert everyone who uses platform_bus_type to include
    linux/platform_device.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index 59202de1d2ce..41e224986f35 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -28,6 +28,8 @@
 #include <linux/ctype.h>
 #include <linux/pci.h>
 #include <linux/pm.h>
+#include <linux/platform_device.h>
+
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/info.h>

commit 9480e307cd88ef09ec9294c7d97ebec18e6d2221
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Fri Oct 28 09:52:56 2005 -0700

    [PATCH] DRIVER MODEL: Get rid of the obsolete tri-level suspend/resume callbacks
    
    In PM v1, all devices were called at SUSPEND_DISABLE level.  Then
    all devices were called at SUSPEND_SAVE_STATE level, and finally
    SUSPEND_POWER_DOWN level.  However, with PM v2, to maintain
    compatibility for platform devices, I arranged for the PM v2
    suspend/resume callbacks to call the old PM v1 suspend/resume
    callbacks three times with each level in order so that existing
    drivers continued to work.
    
    Since this is obsolete infrastructure which is no longer necessary,
    we can remove it.  Here's an (untested) patch to do exactly that.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index c72a79115cca..59202de1d2ce 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -676,8 +676,8 @@ struct snd_generic_device {
 #define SND_GENERIC_NAME	"snd_generic"
 
 #ifdef CONFIG_PM
-static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level);
-static int snd_generic_resume(struct device *dev, u32 level);
+static int snd_generic_suspend(struct device *dev, pm_message_t state);
+static int snd_generic_resume(struct device *dev);
 #endif
 
 /* initialized in sound.c */
@@ -818,13 +818,10 @@ int snd_card_set_pm_callback(snd_card_t *card,
 
 #ifdef CONFIG_SND_GENERIC_DRIVER
 /* suspend/resume callbacks for snd_generic platform device */
-static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level)
+static int snd_generic_suspend(struct device *dev, pm_message_t state)
 {
 	snd_card_t *card;
 
-	if (level != SUSPEND_DISABLE)
-		return 0;
-
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D3hot)
 		return 0;
@@ -834,13 +831,10 @@ static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level
 	return 0;
 }
 
-static int snd_generic_resume(struct device *dev, u32 level)
+static int snd_generic_resume(struct device *dev)
 {
 	snd_card_t *card;
 
-	if (level != RESUME_ENABLE)
-		return 0;
-
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D0)
 		return 0;

commit d5c5d8fe32a4b9b14363c6031061e98e26da59a2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 24 18:16:50 2005 +0200

    [PATCH] ALSA: Fix Oops of suspend/resume with generic drivers
    
    The patch fixes Oops from sound drivers using generic platform device
    but have no suspend/resume callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/init.c b/sound/core/init.c
index a5702014a704..c72a79115cca 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -828,7 +828,8 @@ static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D3hot)
 		return 0;
-	card->pm_suspend(card, PMSG_SUSPEND);
+	if (card->pm_suspend)
+		card->pm_suspend(card, PMSG_SUSPEND);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return 0;
 }
@@ -843,7 +844,8 @@ static int snd_generic_resume(struct device *dev, u32 level)
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D0)
 		return 0;
-	card->pm_resume(card);
+	if (card->pm_suspend)
+		card->pm_resume(card);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }

commit ca2c0966562cfbf9273167a5b60e8fddc24078d6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:23 2005 +0200

    [ALSA] Replace with kzalloc() - core stuff
    
    Control Midlevel,ALSA Core,HWDEP Midlevel,PCM Midlevel,RawMidi Midlevel
    Timer Midlevel,ALSA<-OSS emulation
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index c9c9929121d5..a5702014a704 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -72,7 +72,7 @@ snd_card_t *snd_card_new(int idx, const char *xid,
 
 	if (extra_size < 0)
 		extra_size = 0;
-	card = kcalloc(1, sizeof(*card) + extra_size, GFP_KERNEL);
+	card = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);
 	if (card == NULL)
 		return NULL;
 	if (xid) {
@@ -702,7 +702,7 @@ static int snd_generic_device_register(snd_card_t *card)
 	if (card->generic_dev)
 		return 0; /* already registered */
 
-	dev = kcalloc(1, sizeof(*dev), GFP_KERNEL);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (! dev) {
 		snd_printk(KERN_ERR "can't allocate generic_device\n");
 		return -ENOMEM;

commit ecbcfe36fa882e9f8f2be63ac0c42978336bf997
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:15:37 2005 +0200

    [ALSA] Introduce snd_card_set_generic_dev()
    
    ALSA Core
    A new function snd_card_set_generic_dev() is introduced to add the
    'generic device' support for devices without proper bus on sysfs.
    It's a last resort, and should be removed in future when they have
    a proper bus, instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/init.c b/sound/core/init.c
index d72f58f450ce..c9c9929121d5 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -226,8 +226,10 @@ int snd_card_disconnect(snd_card_t * card)
 	return 0;	
 }
 
-#if defined(CONFIG_PM) && defined(CONFIG_SND_GENERIC_PM)
-static void snd_generic_device_unregister(struct snd_generic_device *dev);
+#ifdef CONFIG_SND_GENERIC_DRIVER
+static void snd_generic_device_unregister(snd_card_t *card);
+#else
+#define snd_generic_device_unregister(x) /*NOP*/
 #endif
 
 /**
@@ -253,14 +255,7 @@ int snd_card_free(snd_card_t * card)
 
 #ifdef CONFIG_PM
 	wake_up(&card->power_sleep);
-#ifdef CONFIG_SND_GENERIC_PM
-	if (card->pm_dev) {
-		snd_generic_device_unregister(card->pm_dev);
-		card->pm_dev = NULL;
-	}
-#endif
 #endif
-
 	/* wait, until all devices are ready for the free operation */
 	wait_event(card->shutdown_sleep, card->files == NULL);
 
@@ -288,6 +283,7 @@ int snd_card_free(snd_card_t * card)
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
 	}
+	snd_generic_device_unregister(card);
 	while (card->s_f_ops) {
 		s_f_ops = card->s_f_ops;
 		card->s_f_ops = s_f_ops->next;
@@ -665,6 +661,96 @@ int snd_card_file_remove(snd_card_t *card, struct file *file)
 	return 0;
 }
 
+#ifdef CONFIG_SND_GENERIC_DRIVER
+/*
+ * generic device without a proper bus using platform_device
+ * (e.g. ISA)
+ */
+struct snd_generic_device {
+	struct platform_device pdev;
+	snd_card_t *card;
+};
+
+#define get_snd_generic_card(dev)	container_of(to_platform_device(dev), struct snd_generic_device, pdev)->card
+
+#define SND_GENERIC_NAME	"snd_generic"
+
+#ifdef CONFIG_PM
+static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level);
+static int snd_generic_resume(struct device *dev, u32 level);
+#endif
+
+/* initialized in sound.c */
+struct device_driver snd_generic_driver = {
+	.name		= SND_GENERIC_NAME,
+	.bus		= &platform_bus_type,
+#ifdef CONFIG_PM
+	.suspend	= snd_generic_suspend,
+	.resume		= snd_generic_resume,
+#endif
+};
+
+void snd_generic_device_release(struct device *dev)
+{
+}
+
+static int snd_generic_device_register(snd_card_t *card)
+{
+	struct snd_generic_device *dev;
+	int err;
+
+	if (card->generic_dev)
+		return 0; /* already registered */
+
+	dev = kcalloc(1, sizeof(*dev), GFP_KERNEL);
+	if (! dev) {
+		snd_printk(KERN_ERR "can't allocate generic_device\n");
+		return -ENOMEM;
+	}
+
+	dev->pdev.name = SND_GENERIC_NAME;
+	dev->pdev.id = card->number;
+	dev->pdev.dev.release = snd_generic_device_release;
+	dev->card = card;
+	if ((err = platform_device_register(&dev->pdev)) < 0) {
+		kfree(dev);
+		return err;
+	}
+	card->generic_dev = dev;
+	return 0;
+}
+
+static void snd_generic_device_unregister(snd_card_t *card)
+{
+	struct snd_generic_device *dev = card->generic_dev;
+	if (dev) {
+		platform_device_unregister(&dev->pdev);
+		kfree(dev);
+		card->generic_dev = NULL;
+	}
+}
+
+/**
+ * snd_card_set_generic_dev - assign the generic device to the card
+ * @card: soundcard structure
+ *
+ * Assigns a generic device to the card.  This function is provided as the
+ * last resort, for devices without any proper bus.  Thus this won't override
+ * the device already assigned to the card.
+ * 
+ * Returns zero if successful, or a negative error code.
+ */
+int snd_card_set_generic_dev(snd_card_t *card)
+{
+	int err;
+	if ((err = snd_generic_device_register(card)) < 0)
+		return err;
+	if (! card->dev)
+		snd_card_set_dev(card, &card->generic_dev->pdev.dev);
+	return 0;
+}
+#endif /* CONFIG_SND_GENERIC_DRIVER */
+
 #ifdef CONFIG_PM
 /**
  *  snd_power_wait - wait until the power-state is changed.
@@ -730,75 +816,7 @@ int snd_card_set_pm_callback(snd_card_t *card,
 	return 0;
 }
 
-#ifdef CONFIG_SND_GENERIC_PM
-/*
- * use platform_device for generic power-management without a proper bus
- * (e.g. ISA)
- */
-struct snd_generic_device {
-	struct platform_device pdev;
-	snd_card_t *card;
-};
-
-#define get_snd_generic_card(dev)	container_of(to_platform_device(dev), struct snd_generic_device, pdev)->card
-
-#define SND_GENERIC_NAME	"snd_generic_pm"
-
-static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level);
-static int snd_generic_resume(struct device *dev, u32 level);
-
-static struct device_driver snd_generic_driver = {
-	.name		= SND_GENERIC_NAME,
-	.bus		= &platform_bus_type,
-	.suspend	= snd_generic_suspend,
-	.resume		= snd_generic_resume,
-};
-
-static int generic_driver_registered;
-
-static void generic_driver_unregister(void)
-{
-	if (generic_driver_registered) {
-		generic_driver_registered--;
-		if (! generic_driver_registered)
-			driver_unregister(&snd_generic_driver);
-	}
-}
-
-static struct snd_generic_device *snd_generic_device_register(snd_card_t *card)
-{
-	struct snd_generic_device *dev;
-
-	if (! generic_driver_registered) {
-		if (driver_register(&snd_generic_driver) < 0)
-			return NULL;
-	}
-	generic_driver_registered++;
-
-	dev = kcalloc(1, sizeof(*dev), GFP_KERNEL);
-	if (! dev) {
-		generic_driver_unregister();
-		return NULL;
-	}
-
-	dev->pdev.name = SND_GENERIC_NAME;
-	dev->pdev.id = card->number;
-	dev->card = card;
-	if (platform_device_register(&dev->pdev) < 0) {
-		kfree(dev);
-		generic_driver_unregister();
-		return NULL;
-	}
-	return dev;
-}
-
-static void snd_generic_device_unregister(struct snd_generic_device *dev)
-{
-	platform_device_unregister(&dev->pdev);
-	kfree(dev);
-	generic_driver_unregister();
-}
-
+#ifdef CONFIG_SND_GENERIC_DRIVER
 /* suspend/resume callbacks for snd_generic platform device */
 static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level)
 {
@@ -846,13 +864,12 @@ int snd_card_set_generic_pm_callback(snd_card_t *card,
 				 int (*resume)(snd_card_t *),
 				 void *private_data)
 {
-	card->pm_dev = snd_generic_device_register(card);
-	if (! card->pm_dev)
-		return -ENOMEM;
-	snd_card_set_pm_callback(card, suspend, resume, private_data);
-	return 0;
+	int err;
+	if ((err = snd_generic_device_register(card)) < 0)
+		return err;
+	return snd_card_set_pm_callback(card, suspend, resume, private_data);
 }
-#endif /* CONFIG_SND_GENERIC_PM */
+#endif /* CONFIG_SND_GENERIC_DRIVER */
 
 #ifdef CONFIG_PCI
 int snd_card_pci_suspend(struct pci_dev *dev, pm_message_t state)

commit e2d53566a757c8d12246d8daf8c5a2f21a0c4293
Author: Pavel Machek <pavel@suse.cz>
Date:   Sat Apr 16 15:25:30 2005 -0700

    [PATCH] fix pm_message_t vs. u32 in alsa
    
    I thought I'm done with fixing u32 vs.  pm_message_t ...  unfortunately that
    turned out not to be the case as Russel King pointed out.  This fixes last few
    bits in alsa.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/init.c b/sound/core/init.c
index 3f1fa8eabb72..d72f58f450ce 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -744,7 +744,7 @@ struct snd_generic_device {
 
 #define SND_GENERIC_NAME	"snd_generic_pm"
 
-static int snd_generic_suspend(struct device *dev, u32 state, u32 level);
+static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level);
 static int snd_generic_resume(struct device *dev, u32 level);
 
 static struct device_driver snd_generic_driver = {
@@ -800,7 +800,7 @@ static void snd_generic_device_unregister(struct snd_generic_device *dev)
 }
 
 /* suspend/resume callbacks for snd_generic platform device */
-static int snd_generic_suspend(struct device *dev, u32 state, u32 level)
+static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level)
 {
 	snd_card_t *card;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/init.c b/sound/core/init.c
new file mode 100644
index 000000000000..3f1fa8eabb72
--- /dev/null
+++ b/sound/core/init.c
@@ -0,0 +1,887 @@
+/*
+ *  Initialization routines
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/ctype.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/info.h>
+
+struct snd_shutdown_f_ops {
+	struct file_operations f_ops;
+	struct snd_shutdown_f_ops *next;
+};
+
+unsigned int snd_cards_lock = 0;	/* locked for registering/using */
+snd_card_t *snd_cards[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = NULL};
+DEFINE_RWLOCK(snd_card_rwlock);
+
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+int (*snd_mixer_oss_notify_callback)(snd_card_t *card, int free_flag);
+#endif
+
+static void snd_card_id_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	snd_iprintf(buffer, "%s\n", entry->card->id);
+}
+
+static void snd_card_free_thread(void * __card);
+
+/**
+ *  snd_card_new - create and initialize a soundcard structure
+ *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]
+ *  @xid: card identification (ASCII string)
+ *  @module: top level module for locking
+ *  @extra_size: allocate this extra size after the main soundcard structure
+ *
+ *  Creates and initializes a soundcard structure.
+ *
+ *  Returns kmallocated snd_card_t structure. Creates the ALSA control interface
+ *  (which is blocked until snd_card_register function is called).
+ */
+snd_card_t *snd_card_new(int idx, const char *xid,
+			 struct module *module, int extra_size)
+{
+	snd_card_t *card;
+	int err;
+
+	if (extra_size < 0)
+		extra_size = 0;
+	card = kcalloc(1, sizeof(*card) + extra_size, GFP_KERNEL);
+	if (card == NULL)
+		return NULL;
+	if (xid) {
+		if (!snd_info_check_reserved_words(xid))
+			goto __error;
+		strlcpy(card->id, xid, sizeof(card->id));
+	}
+	err = 0;
+	write_lock(&snd_card_rwlock);
+	if (idx < 0) {
+		int idx2;
+		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
+			if (~snd_cards_lock & idx & 1<<idx2) {
+				idx = idx2;
+				if (idx >= snd_ecards_limit)
+					snd_ecards_limit = idx + 1;
+				break;
+			}
+	} else if (idx < snd_ecards_limit) {
+		if (snd_cards_lock & (1 << idx))
+			err = -ENODEV;	/* invalid */
+	} else if (idx < SNDRV_CARDS)
+		snd_ecards_limit = idx + 1; /* increase the limit */
+	else
+		err = -ENODEV;
+	if (idx < 0 || err < 0) {
+		write_unlock(&snd_card_rwlock);
+		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i)\n", idx, snd_ecards_limit - 1);
+		goto __error;
+	}
+	snd_cards_lock |= 1 << idx;		/* lock it */
+	write_unlock(&snd_card_rwlock);
+	card->number = idx;
+	card->module = module;
+	INIT_LIST_HEAD(&card->devices);
+	init_rwsem(&card->controls_rwsem);
+	rwlock_init(&card->ctl_files_rwlock);
+	INIT_LIST_HEAD(&card->controls);
+	INIT_LIST_HEAD(&card->ctl_files);
+	spin_lock_init(&card->files_lock);
+	init_waitqueue_head(&card->shutdown_sleep);
+	INIT_WORK(&card->free_workq, snd_card_free_thread, card);
+#ifdef CONFIG_PM
+	init_MUTEX(&card->power_lock);
+	init_waitqueue_head(&card->power_sleep);
+#endif
+	/* the control interface cannot be accessed from the user space until */
+	/* snd_cards_bitmask and snd_cards are set with snd_card_register */
+	if ((err = snd_ctl_create(card)) < 0) {
+		snd_printd("unable to register control minors\n");
+		goto __error;
+	}
+	if ((err = snd_info_card_create(card)) < 0) {
+		snd_printd("unable to create card info\n");
+		goto __error_ctl;
+	}
+	if (extra_size > 0)
+		card->private_data = (char *)card + sizeof(snd_card_t);
+	return card;
+
+      __error_ctl:
+	snd_device_free_all(card, SNDRV_DEV_CMD_PRE);
+      __error:
+	kfree(card);
+      	return NULL;
+}
+
+static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)
+{
+	return POLLERR | POLLNVAL;
+}
+
+/**
+ *  snd_card_disconnect - disconnect all APIs from the file-operations (user space)
+ *  @card: soundcard structure
+ *
+ *  Disconnects all APIs from the file-operations (user space).
+ *
+ *  Returns zero, otherwise a negative error code.
+ *
+ *  Note: The current implementation replaces all active file->f_op with special
+ *        dummy file operations (they do nothing except release).
+ */
+int snd_card_disconnect(snd_card_t * card)
+{
+	struct snd_monitor_file *mfile;
+	struct file *file;
+	struct snd_shutdown_f_ops *s_f_ops;
+	struct file_operations *f_ops, *old_f_ops;
+	int err;
+
+	spin_lock(&card->files_lock);
+	if (card->shutdown) {
+		spin_unlock(&card->files_lock);
+		return 0;
+	}
+	card->shutdown = 1;
+	spin_unlock(&card->files_lock);
+
+	/* phase 1: disable fops (user space) operations for ALSA API */
+	write_lock(&snd_card_rwlock);
+	snd_cards[card->number] = NULL;
+	write_unlock(&snd_card_rwlock);
+	
+	/* phase 2: replace file->f_op with special dummy operations */
+	
+	spin_lock(&card->files_lock);
+	mfile = card->files;
+	while (mfile) {
+		file = mfile->file;
+
+		/* it's critical part, use endless loop */
+		/* we have no room to fail */
+		s_f_ops = kmalloc(sizeof(struct snd_shutdown_f_ops), GFP_ATOMIC);
+		if (s_f_ops == NULL)
+			panic("Atomic allocation failed for snd_shutdown_f_ops!");
+
+		f_ops = &s_f_ops->f_ops;
+
+		memset(f_ops, 0, sizeof(*f_ops));
+		f_ops->owner = file->f_op->owner;
+		f_ops->release = file->f_op->release;
+		f_ops->poll = snd_disconnect_poll;
+
+		s_f_ops->next = card->s_f_ops;
+		card->s_f_ops = s_f_ops;
+		
+		f_ops = fops_get(f_ops);
+
+		old_f_ops = file->f_op;
+		file->f_op = f_ops;	/* must be atomic */
+		fops_put(old_f_ops);
+		
+		mfile = mfile->next;
+	}
+	spin_unlock(&card->files_lock);	
+
+	/* phase 3: notify all connected devices about disconnection */
+	/* at this point, they cannot respond to any calls except release() */
+
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+	if (snd_mixer_oss_notify_callback)
+		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);
+#endif
+
+	/* notify all devices that we are disconnected */
+	err = snd_device_disconnect_all(card);
+	if (err < 0)
+		snd_printk(KERN_ERR "not all devices for card %i can be disconnected\n", card->number);
+
+	return 0;	
+}
+
+#if defined(CONFIG_PM) && defined(CONFIG_SND_GENERIC_PM)
+static void snd_generic_device_unregister(struct snd_generic_device *dev);
+#endif
+
+/**
+ *  snd_card_free - frees given soundcard structure
+ *  @card: soundcard structure
+ *
+ *  This function releases the soundcard structure and the all assigned
+ *  devices automatically.  That is, you don't have to release the devices
+ *  by yourself.
+ *
+ *  Returns zero. Frees all associated devices and frees the control
+ *  interface associated to given soundcard.
+ */
+int snd_card_free(snd_card_t * card)
+{
+	struct snd_shutdown_f_ops *s_f_ops;
+
+	if (card == NULL)
+		return -EINVAL;
+	write_lock(&snd_card_rwlock);
+	snd_cards[card->number] = NULL;
+	write_unlock(&snd_card_rwlock);
+
+#ifdef CONFIG_PM
+	wake_up(&card->power_sleep);
+#ifdef CONFIG_SND_GENERIC_PM
+	if (card->pm_dev) {
+		snd_generic_device_unregister(card->pm_dev);
+		card->pm_dev = NULL;
+	}
+#endif
+#endif
+
+	/* wait, until all devices are ready for the free operation */
+	wait_event(card->shutdown_sleep, card->files == NULL);
+
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+	if (snd_mixer_oss_notify_callback)
+		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);
+#endif
+	if (snd_device_free_all(card, SNDRV_DEV_CMD_PRE) < 0) {
+		snd_printk(KERN_ERR "unable to free all devices (pre)\n");
+		/* Fatal, but this situation should never occur */
+	}
+	if (snd_device_free_all(card, SNDRV_DEV_CMD_NORMAL) < 0) {
+		snd_printk(KERN_ERR "unable to free all devices (normal)\n");
+		/* Fatal, but this situation should never occur */
+	}
+	if (snd_device_free_all(card, SNDRV_DEV_CMD_POST) < 0) {
+		snd_printk(KERN_ERR "unable to free all devices (post)\n");
+		/* Fatal, but this situation should never occur */
+	}
+	if (card->private_free)
+		card->private_free(card);
+	if (card->proc_id)
+		snd_info_unregister(card->proc_id);
+	if (snd_info_card_free(card) < 0) {
+		snd_printk(KERN_WARNING "unable to free card info\n");
+		/* Not fatal error */
+	}
+	while (card->s_f_ops) {
+		s_f_ops = card->s_f_ops;
+		card->s_f_ops = s_f_ops->next;
+		kfree(s_f_ops);
+	}
+	write_lock(&snd_card_rwlock);
+	snd_cards_lock &= ~(1 << card->number);
+	write_unlock(&snd_card_rwlock);
+	kfree(card);
+	return 0;
+}
+
+static void snd_card_free_thread(void * __card)
+{
+	snd_card_t *card = __card;
+	struct module * module = card->module;
+
+	if (!try_module_get(module)) {
+		snd_printk(KERN_ERR "unable to lock toplevel module for card %i in free thread\n", card->number);
+		module = NULL;
+	}
+
+	snd_card_free(card);
+
+	module_put(module);
+}
+
+/**
+ *  snd_card_free_in_thread - call snd_card_free() in thread
+ *  @card: soundcard structure
+ *
+ *  This function schedules the call of snd_card_free() function in a
+ *  work queue.  When all devices are released (non-busy), the work
+ *  is woken up and calls snd_card_free().
+ *
+ *  When a card can be disconnected at any time by hotplug service,
+ *  this function should be used in disconnect (or detach) callback
+ *  instead of calling snd_card_free() directly.
+ *  
+ *  Returns - zero otherwise a negative error code if the start of thread failed.
+ */
+int snd_card_free_in_thread(snd_card_t * card)
+{
+	if (card->files == NULL) {
+		snd_card_free(card);
+		return 0;
+	}
+
+	if (schedule_work(&card->free_workq))
+		return 0;
+
+	snd_printk(KERN_ERR "schedule_work() failed in snd_card_free_in_thread for card %i\n", card->number);
+	/* try to free the structure immediately */
+	snd_card_free(card);
+	return -EFAULT;
+}
+
+static void choose_default_id(snd_card_t * card)
+{
+	int i, len, idx_flag = 0, loops = 8;
+	char *id, *spos;
+	
+	id = spos = card->shortname;	
+	while (*id != '\0') {
+		if (*id == ' ')
+			spos = id + 1;
+		id++;
+	}
+	id = card->id;
+	while (*spos != '\0' && !isalnum(*spos))
+		spos++;
+	if (isdigit(*spos))
+		*id++ = isalpha(card->shortname[0]) ? card->shortname[0] : 'D';
+	while (*spos != '\0' && (size_t)(id - card->id) < sizeof(card->id) - 1) {
+		if (isalnum(*spos))
+			*id++ = *spos;
+		spos++;
+	}
+	*id = '\0';
+
+	id = card->id;
+	
+	if (*id == '\0')
+		strcpy(id, "default");
+
+	while (1) {
+	      	if (loops-- == 0) {
+      			snd_printk(KERN_ERR "unable to choose default card id (%s)\n", id);
+      			strcpy(card->id, card->proc_root->name);
+      			return;
+      		}
+	      	if (!snd_info_check_reserved_words(id))
+      			goto __change;
+		for (i = 0; i < snd_ecards_limit; i++) {
+			if (snd_cards[i] && !strcmp(snd_cards[i]->id, id))
+				goto __change;
+		}
+		break;
+
+	      __change:
+		len = strlen(id);
+		if (idx_flag)
+			id[len-1]++;
+		else if ((size_t)len <= sizeof(card->id) - 3) {
+			strcat(id, "_1");
+			idx_flag++;
+		} else {
+			spos = id + len - 2;
+			if ((size_t)len <= sizeof(card->id) - 2)
+				spos++;
+			*spos++ = '_';
+			*spos++ = '1';
+			*spos++ = '\0';
+			idx_flag++;
+		}
+	}
+}
+
+/**
+ *  snd_card_register - register the soundcard
+ *  @card: soundcard structure
+ *
+ *  This function registers all the devices assigned to the soundcard.
+ *  Until calling this, the ALSA control interface is blocked from the
+ *  external accesses.  Thus, you should call this function at the end
+ *  of the initialization of the card.
+ *
+ *  Returns zero otherwise a negative error code if the registrain failed.
+ */
+int snd_card_register(snd_card_t * card)
+{
+	int err;
+	snd_info_entry_t *entry;
+
+	snd_runtime_check(card != NULL, return -EINVAL);
+	if ((err = snd_device_register_all(card)) < 0)
+		return err;
+	write_lock(&snd_card_rwlock);
+	if (snd_cards[card->number]) {
+		/* already registered */
+		write_unlock(&snd_card_rwlock);
+		return 0;
+	}
+	if (card->id[0] == '\0')
+		choose_default_id(card);
+	snd_cards[card->number] = card;
+	write_unlock(&snd_card_rwlock);
+	if ((err = snd_info_card_register(card)) < 0) {
+		snd_printd("unable to create card info\n");
+		goto __skip_info;
+	}
+	if ((entry = snd_info_create_card_entry(card, "id", card->proc_root)) == NULL) {
+		snd_printd("unable to create card entry\n");
+		goto __skip_info;
+	}
+	entry->c.text.read_size = PAGE_SIZE;
+	entry->c.text.read = snd_card_id_read;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		entry = NULL;
+	}
+	card->proc_id = entry;
+      __skip_info:
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+	if (snd_mixer_oss_notify_callback)
+		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);
+#endif
+	return 0;
+}
+
+static snd_info_entry_t *snd_card_info_entry = NULL;
+
+static void snd_card_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	int idx, count;
+	snd_card_t *card;
+
+	for (idx = count = 0; idx < SNDRV_CARDS; idx++) {
+		read_lock(&snd_card_rwlock);
+		if ((card = snd_cards[idx]) != NULL) {
+			count++;
+			snd_iprintf(buffer, "%i [%-15s]: %s - %s\n",
+					idx,
+					card->id,
+					card->driver,
+					card->shortname);
+			snd_iprintf(buffer, "                     %s\n",
+					card->longname);
+		}
+		read_unlock(&snd_card_rwlock);
+	}
+	if (!count)
+		snd_iprintf(buffer, "--- no soundcards ---\n");
+}
+
+#if defined(CONFIG_SND_OSSEMUL) && defined(CONFIG_PROC_FS)
+
+void snd_card_info_read_oss(snd_info_buffer_t * buffer)
+{
+	int idx, count;
+	snd_card_t *card;
+
+	for (idx = count = 0; idx < SNDRV_CARDS; idx++) {
+		read_lock(&snd_card_rwlock);
+		if ((card = snd_cards[idx]) != NULL) {
+			count++;
+			snd_iprintf(buffer, "%s\n", card->longname);
+		}
+		read_unlock(&snd_card_rwlock);
+	}
+	if (!count) {
+		snd_iprintf(buffer, "--- no soundcards ---\n");
+	}
+}
+
+#endif
+
+#ifdef MODULE
+static snd_info_entry_t *snd_card_module_info_entry;
+static void snd_card_module_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	int idx;
+	snd_card_t *card;
+
+	for (idx = 0; idx < SNDRV_CARDS; idx++) {
+		read_lock(&snd_card_rwlock);
+		if ((card = snd_cards[idx]) != NULL)
+			snd_iprintf(buffer, "%i %s\n", idx, card->module->name);
+		read_unlock(&snd_card_rwlock);
+	}
+}
+#endif
+
+int __init snd_card_info_init(void)
+{
+	snd_info_entry_t *entry;
+
+	entry = snd_info_create_module_entry(THIS_MODULE, "cards", NULL);
+	snd_runtime_check(entry != NULL, return -ENOMEM);
+	entry->c.text.read_size = PAGE_SIZE;
+	entry->c.text.read = snd_card_info_read;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		return -ENOMEM;
+	}
+	snd_card_info_entry = entry;
+
+#ifdef MODULE
+	entry = snd_info_create_module_entry(THIS_MODULE, "modules", NULL);
+	if (entry) {
+		entry->c.text.read_size = PAGE_SIZE;
+		entry->c.text.read = snd_card_module_info_read;
+		if (snd_info_register(entry) < 0)
+			snd_info_free_entry(entry);
+		else
+			snd_card_module_info_entry = entry;
+	}
+#endif
+
+	return 0;
+}
+
+int __exit snd_card_info_done(void)
+{
+	if (snd_card_info_entry)
+		snd_info_unregister(snd_card_info_entry);
+#ifdef MODULE
+	if (snd_card_module_info_entry)
+		snd_info_unregister(snd_card_module_info_entry);
+#endif
+	return 0;
+}
+
+/**
+ *  snd_component_add - add a component string
+ *  @card: soundcard structure
+ *  @component: the component id string
+ *
+ *  This function adds the component id string to the supported list.
+ *  The component can be referred from the alsa-lib.
+ *
+ *  Returns zero otherwise a negative error code.
+ */
+  
+int snd_component_add(snd_card_t *card, const char *component)
+{
+	char *ptr;
+	int len = strlen(component);
+
+	ptr = strstr(card->components, component);
+	if (ptr != NULL) {
+		if (ptr[len] == '\0' || ptr[len] == ' ')	/* already there */
+			return 1;
+	}
+	if (strlen(card->components) + 1 + len + 1 > sizeof(card->components)) {
+		snd_BUG();
+		return -ENOMEM;
+	}
+	if (card->components[0] != '\0')
+		strcat(card->components, " ");
+	strcat(card->components, component);
+	return 0;
+}
+
+/**
+ *  snd_card_file_add - add the file to the file list of the card
+ *  @card: soundcard structure
+ *  @file: file pointer
+ *
+ *  This function adds the file to the file linked-list of the card.
+ *  This linked-list is used to keep tracking the connection state,
+ *  and to avoid the release of busy resources by hotplug.
+ *
+ *  Returns zero or a negative error code.
+ */
+int snd_card_file_add(snd_card_t *card, struct file *file)
+{
+	struct snd_monitor_file *mfile;
+
+	mfile = kmalloc(sizeof(*mfile), GFP_KERNEL);
+	if (mfile == NULL)
+		return -ENOMEM;
+	mfile->file = file;
+	mfile->next = NULL;
+	spin_lock(&card->files_lock);
+	if (card->shutdown) {
+		spin_unlock(&card->files_lock);
+		kfree(mfile);
+		return -ENODEV;
+	}
+	mfile->next = card->files;
+	card->files = mfile;
+	spin_unlock(&card->files_lock);
+	return 0;
+}
+
+/**
+ *  snd_card_file_remove - remove the file from the file list
+ *  @card: soundcard structure
+ *  @file: file pointer
+ *
+ *  This function removes the file formerly added to the card via
+ *  snd_card_file_add() function.
+ *  If all files are removed and the release of the card is
+ *  scheduled, it will wake up the the thread to call snd_card_free()
+ *  (see snd_card_free_in_thread() function).
+ *
+ *  Returns zero or a negative error code.
+ */
+int snd_card_file_remove(snd_card_t *card, struct file *file)
+{
+	struct snd_monitor_file *mfile, *pfile = NULL;
+
+	spin_lock(&card->files_lock);
+	mfile = card->files;
+	while (mfile) {
+		if (mfile->file == file) {
+			if (pfile)
+				pfile->next = mfile->next;
+			else
+				card->files = mfile->next;
+			break;
+		}
+		pfile = mfile;
+		mfile = mfile->next;
+	}
+	spin_unlock(&card->files_lock);
+	if (card->files == NULL)
+		wake_up(&card->shutdown_sleep);
+	if (!mfile) {
+		snd_printk(KERN_ERR "ALSA card file remove problem (%p)\n", file);
+		return -ENOENT;
+	}
+	kfree(mfile);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/**
+ *  snd_power_wait - wait until the power-state is changed.
+ *  @card: soundcard structure
+ *  @power_state: expected power state
+ *  @file: file structure for the O_NONBLOCK check (optional)
+ *
+ *  Waits until the power-state is changed.
+ *
+ *  Note: the power lock must be active before call.
+ */
+int snd_power_wait(snd_card_t *card, unsigned int power_state, struct file *file)
+{
+	wait_queue_t wait;
+	int result = 0;
+
+	/* fastpath */
+	if (snd_power_get_state(card) == power_state)
+		return 0;
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(&card->power_sleep, &wait);
+	while (1) {
+		if (card->shutdown) {
+			result = -ENODEV;
+			break;
+		}
+		if (snd_power_get_state(card) == power_state)
+			break;
+#if 0 /* block all devices */
+		if (file && (file->f_flags & O_NONBLOCK)) {
+			result = -EAGAIN;
+			break;
+		}
+#endif
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		snd_power_unlock(card);
+		schedule_timeout(30 * HZ);
+		snd_power_lock(card);
+	}
+	remove_wait_queue(&card->power_sleep, &wait);
+	return result;
+}
+
+/**
+ * snd_card_set_pm_callback - set the PCI power-management callbacks
+ * @card: soundcard structure
+ * @suspend: suspend callback function
+ * @resume: resume callback function
+ * @private_data: private data to pass to the callback functions
+ *
+ * Sets the power-management callback functions of the card.
+ * These callbacks are called from ALSA's common PCI suspend/resume
+ * handler and from the control API.
+ */
+int snd_card_set_pm_callback(snd_card_t *card,
+			     int (*suspend)(snd_card_t *, pm_message_t),
+			     int (*resume)(snd_card_t *),
+			     void *private_data)
+{
+	card->pm_suspend = suspend;
+	card->pm_resume = resume;
+	card->pm_private_data = private_data;
+	return 0;
+}
+
+#ifdef CONFIG_SND_GENERIC_PM
+/*
+ * use platform_device for generic power-management without a proper bus
+ * (e.g. ISA)
+ */
+struct snd_generic_device {
+	struct platform_device pdev;
+	snd_card_t *card;
+};
+
+#define get_snd_generic_card(dev)	container_of(to_platform_device(dev), struct snd_generic_device, pdev)->card
+
+#define SND_GENERIC_NAME	"snd_generic_pm"
+
+static int snd_generic_suspend(struct device *dev, u32 state, u32 level);
+static int snd_generic_resume(struct device *dev, u32 level);
+
+static struct device_driver snd_generic_driver = {
+	.name		= SND_GENERIC_NAME,
+	.bus		= &platform_bus_type,
+	.suspend	= snd_generic_suspend,
+	.resume		= snd_generic_resume,
+};
+
+static int generic_driver_registered;
+
+static void generic_driver_unregister(void)
+{
+	if (generic_driver_registered) {
+		generic_driver_registered--;
+		if (! generic_driver_registered)
+			driver_unregister(&snd_generic_driver);
+	}
+}
+
+static struct snd_generic_device *snd_generic_device_register(snd_card_t *card)
+{
+	struct snd_generic_device *dev;
+
+	if (! generic_driver_registered) {
+		if (driver_register(&snd_generic_driver) < 0)
+			return NULL;
+	}
+	generic_driver_registered++;
+
+	dev = kcalloc(1, sizeof(*dev), GFP_KERNEL);
+	if (! dev) {
+		generic_driver_unregister();
+		return NULL;
+	}
+
+	dev->pdev.name = SND_GENERIC_NAME;
+	dev->pdev.id = card->number;
+	dev->card = card;
+	if (platform_device_register(&dev->pdev) < 0) {
+		kfree(dev);
+		generic_driver_unregister();
+		return NULL;
+	}
+	return dev;
+}
+
+static void snd_generic_device_unregister(struct snd_generic_device *dev)
+{
+	platform_device_unregister(&dev->pdev);
+	kfree(dev);
+	generic_driver_unregister();
+}
+
+/* suspend/resume callbacks for snd_generic platform device */
+static int snd_generic_suspend(struct device *dev, u32 state, u32 level)
+{
+	snd_card_t *card;
+
+	if (level != SUSPEND_DISABLE)
+		return 0;
+
+	card = get_snd_generic_card(dev);
+	if (card->power_state == SNDRV_CTL_POWER_D3hot)
+		return 0;
+	card->pm_suspend(card, PMSG_SUSPEND);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
+}
+
+static int snd_generic_resume(struct device *dev, u32 level)
+{
+	snd_card_t *card;
+
+	if (level != RESUME_ENABLE)
+		return 0;
+
+	card = get_snd_generic_card(dev);
+	if (card->power_state == SNDRV_CTL_POWER_D0)
+		return 0;
+	card->pm_resume(card);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+
+/**
+ * snd_card_set_generic_pm_callback - set the generic power-management callbacks
+ * @card: soundcard structure
+ * @suspend: suspend callback function
+ * @resume: resume callback function
+ * @private_data: private data to pass to the callback functions
+ *
+ * Registers the power-management and sets the lowlevel callbacks for
+ * the given card.  These callbacks are called from the ALSA's common
+ * PM handler and from the control API.
+ */
+int snd_card_set_generic_pm_callback(snd_card_t *card,
+				 int (*suspend)(snd_card_t *, pm_message_t),
+				 int (*resume)(snd_card_t *),
+				 void *private_data)
+{
+	card->pm_dev = snd_generic_device_register(card);
+	if (! card->pm_dev)
+		return -ENOMEM;
+	snd_card_set_pm_callback(card, suspend, resume, private_data);
+	return 0;
+}
+#endif /* CONFIG_SND_GENERIC_PM */
+
+#ifdef CONFIG_PCI
+int snd_card_pci_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	snd_card_t *card = pci_get_drvdata(dev);
+	int err;
+	if (! card || ! card->pm_suspend)
+		return 0;
+	if (card->power_state == SNDRV_CTL_POWER_D3hot)
+		return 0;
+	err = card->pm_suspend(card, PMSG_SUSPEND);
+	pci_save_state(dev);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return err;
+}
+
+int snd_card_pci_resume(struct pci_dev *dev)
+{
+	snd_card_t *card = pci_get_drvdata(dev);
+	if (! card || ! card->pm_resume)
+		return 0;
+	if (card->power_state == SNDRV_CTL_POWER_D0)
+		return 0;
+	/* restore the PCI config space */
+	pci_restore_state(dev);
+	card->pm_resume(card);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+#endif
+
+#endif /* CONFIG_PM */
