commit e7513c5786f8b33f0c107b3759e433bc6cbb2efa
Author: Brent Lu <brent.lu@intel.com>
Date:   Mon May 18 12:30:38 2020 +0800

    ALSA: pcm: fix incorrect hw_base increase
    
    There is a corner case that ALSA keeps increasing the hw_ptr but DMA
    already stop working/updating the position for a long time.
    
    In following log we can see the position returned from DMA driver does
    not move at all but the hw_ptr got increased at some point of time so
    snd_pcm_avail() will return a large number which seems to be a buffer
    underrun event from user space program point of view. The program
    thinks there is space in the buffer and fill more data.
    
    [  418.510086] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 4096 avail 12368
    [  418.510149] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 6910 avail 9554
    ...
    [  418.681052] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 15102 avail 1362
    [  418.681130] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 16464 avail 0
    [  418.726515] sound pcmC0D5p: pos 96 hw_ptr 16464 appl_ptr 16464 avail 16368
    
    This is because the hw_base will be increased by runtime->buffer_size
    frames unconditionally if the hw_ptr is not updated for over half of
    buffer time. As the hw_base increases, so does the hw_ptr increased
    by the same number.
    
    The avail value returned from snd_pcm_avail() could exceed the limit
    (buffer_size) easily becase the hw_ptr itself got increased by same
    buffer_size samples when the corner case happens. In following log,
    the buffer_size is 16368 samples but the avail is 21810 samples so
    CRAS server complains about it.
    
    [  418.851755] sound pcmC0D5p: pos 96 hw_ptr 16464 appl_ptr 27390 avail 5442
    [  418.926491] sound pcmC0D5p: pos 96 hw_ptr 32832 appl_ptr 27390 avail 21810
    
    cras_server[1907]: pcm_avail returned frames larger than buf_size:
    sof-glkda7219max: :0,5: 21810 > 16368
    
    By updating runtime->hw_ptr_jiffies each time the HWSYNC is called,
    the hw_base will keep the same when buffer stall happens at long as
    the interval between each HWSYNC call is shorter than half of buffer
    time.
    
    Following is a log captured by a patched kernel. The hw_base/hw_ptr
    value is fixed in this corner case and user space program should be
    aware of the buffer stall and handle it.
    
    [  293.525543] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 4096 avail 12368
    [  293.525606] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 6880 avail 9584
    [  293.525975] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 10976 avail 5488
    [  293.611178] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 15072 avail 1392
    [  293.696429] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 16464 avail 0
    ...
    [  381.139517] sound pcmC0D5p: pos 96 hw_ptr 96 appl_ptr 16464 avail 0
    
    Signed-off-by: Brent Lu <brent.lu@intel.com>
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/1589776238-23877-1-git-send-email-brent.lu@intel.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 872a852de75c..d531e1bc2b81 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -433,6 +433,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 
  no_delta_check:
 	if (runtime->status->hw_ptr == new_hw_ptr) {
+		runtime->hw_ptr_jiffies = curr_jiffies;
 		update_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);
 		return 0;
 	}

commit d03af9b8ea7e8655869834f2eed1f1d583cc5672
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:20 2020 +0100

    ALSA: pcm: More constifications
    
    Apply const prefix to more possible places: the string tables for PCM
    format and co, the table for the PCM type helpers, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 18f498ab7af1..872a852de75c 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1452,7 +1452,7 @@ EXPORT_SYMBOL(snd_pcm_hw_constraint_step);
 
 static int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)
 {
-	static unsigned int pow2_sizes[] = {
+	static const unsigned int pow2_sizes[] = {
 		1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,
 		1<<8, 1<<9, 1<<10, 1<<11, 1<<12, 1<<13, 1<<14, 1<<15,
 		1<<16, 1<<17, 1<<18, 1<<19, 1<<20, 1<<21, 1<<22, 1<<23,

commit fbd3eb7f66c5b4f37a959bc2deaeb1d7b5ddf0d4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Jan 4 09:35:56 2020 +0100

    ALSA: control: Add verification for kctl accesses
    
    The current implementation of ALSA control API fully relies on the
    callbacks of each driver, and there is no verification of the values
    passed via API.  This patch is an attempt to improve the situation
    slightly by adding the validation code for the values stored via info
    and get callbacks.
    
    The patch adds a new kconfig, CONFIG_SND_CTL_VALIDATION.  It depends
    on CONFIG_SND_DEBUG and off as default since the validation would
    require a slight overhead including the additional call of info
    callback at each get callback invocation.
    
    When this config is enabled, the values stored by each info callback
    invocation are verified, namely:
    - Whether the info type is valid
    - Whether the number of enum items is non-zero
    - Whether the given info count is within the allowed boundary
    
    Similarly, the values stored at each get callback are verified as
    well:
    - Whether the values are within the given range
    - Whether the values are aligned with the given step
    - Whether any further changes are seen in the data array over the
      given info count
    
    The last point helps identifying a possibly invalid data type access,
    typically a case where the info callback declares the type being
    SNDRV_CTL_ELEM_TYPE_ENUMERATED while the get/put callbacks store
    the values in value.integer.value[] array.
    
    When a validation fails, the ALSA core logs an error message including
    the device and the control ID, and the API call also returns an
    error.  So, with the new validation turned on, the driver behavior
    difference may be visible on user-space, too -- it's intentional,
    though, so that we can catch an error more clearly.
    
    The patch also introduces a new ctl access type,
    SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK.  A driver may pass this flag with
    other access bits to indicate that the ctl element won't be verified.
    It's useful when a driver code is specially written to access the data
    greater than info->count size by some reason.  For example, this flag
    is actually set now in HD-audio HDMI codec driver which needs to clear
    the data array in the case of the disconnected monitor.
    
    Also, the PCM channel-map helper code is slightly modified to avoid
    the false-positive hit by this validation code, too.
    
    Link: https://lore.kernel.org/r/20200104083556.27789-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ce3a36cb58da..18f498ab7af1 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2341,7 +2341,7 @@ static int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,
 	if (!substream)
 		return -ENODEV;
 	memset(ucontrol->value.integer.value, 0,
-	       sizeof(ucontrol->value.integer.value));
+	       sizeof(long) * info->max_channels);
 	if (!substream->runtime)
 		return 0; /* no channels set */
 	for (map = info->chmap; map->channels; map++) {

commit df1d6ea05a75104b8e7dc642cc5d3f9c4b80d58b
Merge: d8cac6207ec1 1cfaef961703
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 17 23:12:39 2019 +0100

    Merge tag 'y2038-alsa-v8-signed' of git://git.kernel.org:/pub/scm/linux/kernel/git/arnd/playground into for-next
    
    ALSA: Fix year 2038 issue for sound subsystem
    
    This is a series I worked on with Baolin in 2017 and 2018, but we
    never quite managed to finish up the last pieces. During the
    ALSA developer meetup at ELC-E 2018 in Edinburgh, a decision was
    made to go with this approach for keeping best compatibility
    with existing source code, and then I failed to follow up by
    resending the patches.
    
    Now I have patches for all remaining time_t uses in the kernel,
    so it's absolutely time to revisit them. I have done more
    review of the patches myself and found a couple of minor issues
    that I have fixed up, otherwise the series is still the same as
    before.
    
    Conceptually, the idea of these patches is:
    
    - 64-bit applications should see no changes at all, neither
      compile-time nor run-time.
    
    - 32-bit code compiled with a 64-bit time_t currently
      does not work with ALSA, and requires kernel changes and/or
      sound/asound.h changes
    
    - Most 32-bit code using these interfaces will work correctly
      on a modified kernel, with or without the uapi header changes.
    
    - 32-bit code using SNDRV_TIMER_IOCTL_TREAD requires the
      updated header file for 64-bit time_t support
    
    - 32-bit i386 user space with 64-bit time_t is broken for
      SNDRV_PCM_IOCTL_STATUS, SNDRV_RAWMIDI_IOCTL_STATUS and
      SNDRV_PCM_IOCTL_SYNC_PTR because of i386 alignment. This is also
      addressed by the updated uapi header.
    
    - PCM mmap is currently supported on native x86 kernels
      (both 32-bit and 64-bit) but not for compat mode. This series breaks
      the 32-bit native mmap support for 32-bit time_t, but instead allows
      it for 64-bit time_t on both native and compat kernels. This seems to
      be the best trade-off, as mmap support is optional already, and most
      32-bit code runs in compat mode anyway.
    
    - I've tried to avoid breaking compilation of 32-bit code
      as much as possible. Anything that does break however is likely code
      that is already broken on 64-bit time_t and needs source changes to
      fix them.
    
    [1] https://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground.git y2038-alsa-v8
    [2] https://lore.kernel.org/lkml/CAK8P3a2Os66+iwQYf97qh05W2JP8rmWao8zmKoHiXqVHvyYAJA@mail.gmail.com/T/#m6519cb07cfda08adf1dedea6596bb98892b4d5dc
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    
    Changes since v7: (Arnd):
     - Fix a typo found by Ben Hutchings
    
    Changes since v6: (Arnd):
     - Add a patch to update the API versions
     - Hide a timespec reference in #ifndef __KERNEL__ to remove the
       last reference to time_t
     - Use a more readable way to do padding and describe it in the
       changelog
     - Rebase to linux-5.5-rc1, changing include/sound/soc-component.h
       and sound/drivers/aloop.c as needed.
    
    Changes since v5 (Arnd):
     - Rebased to linux-5.4-rc4
     - Updated to completely remove timespec and time_t references from alsa
     - found and fixed a few bugs
    
    Changes since v4 (Baolin):
     - Add patch 5 to change trigger_tstamp member of struct snd_pcm_runtime.
     - Add patch 8 to change internal timespec.
     - Add more explanation in commit message.
     - Use ktime_get_real_ts64() in patch 6.
     - Split common code out into a separate function in patch 6.
     - Fix tu->tread bug in patch 6 and remove #if __BITS_PER_LONG == 64 macro.
    
    Changes since v3:
     - Move struct snd_pcm_status32 to pcm.h file.
     - Modify comments and commit message.
     - Add new patch2 ~ patch6.
    
    Changes since v2:
     - Renamed all structures to make clear.
     - Remove CONFIG_X86_X32 macro and introduced new compat_snd_pcm_status64_x86_32.
    
    Changes since v1:
     - Add one macro for struct snd_pcm_status_32 which only active in 32bits kernel.
     - Convert pcm_compat.c to use struct snd_pcm_status_64.
     - Convert pcm_native.c to use struct snd_pcm_status_64.

commit 1faa9d3a3ea7852761ff403f5a9d4a409c0bb199
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Dec 14 22:13:51 2019 +0900

    ALSA: control: remove useless assignment in .info callback of PCM chmap element
    
    Control elements for PCM chmap return information to userspace abount
    the maximum number of available PCM channels as the number of values
    in the element.
    
    In current implementation the number is once initialized to zero, then
    assigned to. This is useless and this commit fixes it.
    
    Fixes: 2d3391ec0ecc ("ALSA: PCM: channel mapping API implementation")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191214131351.28950-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 2236b5e0c1f2..6f0a00fd3ae5 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2308,7 +2308,6 @@ static int pcm_chmap_ctl_info(struct snd_kcontrol *kcontrol,
 	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 0;
 	uinfo->count = info->max_channels;
 	uinfo->value.integer.min = 0;
 	uinfo->value.integer.max = SNDRV_CHMAP_LAST;

commit 80fe7430c7085951d1246d83f638cc17e6c0be36
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 24 20:06:15 2018 +0800

    ALSA: add new 32-bit layout for snd_pcm_mmap_status/control
    
    The snd_pcm_mmap_status and snd_pcm_mmap_control interfaces are one of the
    trickiest areas to get right when moving to 64-bit time_t in user space.
    
    The snd_pcm_mmap_status structure layout is incompatible with user space
    that uses a 64-bit time_t, so we need a new layout for it. Since the
    SNDRV_PCM_IOCTL_SYNC_PTR ioctl combines it with snd_pcm_mmap_control
    into snd_pcm_sync_ptr, we need to change those two as well.
    
    Both structures are also exported via an mmap() operation on certain
    architectures, and this suffers from incompatibility between 32-bit
    and 64-bit user space. As we have to change both structures anyway,
    this is a good opportunity to fix the mmap() problem as well, so let's
    standardize on the existing 64-bit layout of the structure where possible.
    
    The downside is that we lose mmap() support for existing 32-bit x86 and
    powerpc applications, adding that would introduce very noticeable runtime
    overhead and complexity. My assumption here is that not too many people
    will miss the removed feature, given that:
    
    - Almost all x86 and powerpc users these days are on 64-bit kernels,
    the majority of today's 32-bit users are on architectures that never
    supported mmap (ARM, MIPS, ...).
    - It never worked in compat mode (it was intentionally disabled there)
    - The application already needs to work with a fallback to
    SNDRV_PCM_IOCTL_SYNC_PTR, which will keep working with both the old
    and new structure layout.
    
    Both the ioctl() and mmap() based interfaces are changed at the same
    time, as they are based on the same structures. Unlike other interfaces,
    we change the uapi header to export both the traditional structure and
    a version that is portable between 32-bit and 64-bit user space code
    and that corresponds to the existing 64-bit layout. We further check the
    __USE_TIME_BITS64 macro that will be defined by future C library versions
    whenever we use the new time_t definition, so any existing user space
    source code will not see any changes until it gets rebuilt against a new
    C library. However, the new structures are all visible in addition to the
    old ones, allowing applications to explicitly request the new structures.
    
    In order to detect the difference between the old snd_pcm_mmap_status and
    the new __snd_pcm_mmap_status64 structure from the ioctl command number,
    we rely on one quirk in the structure definition: snd_pcm_mmap_status
    must be aligned to alignof(time_t), which leads the compiler to insert
    four bytes of padding in struct snd_pcm_sync_ptr after 'flags' and a
    corresponding change in the size of snd_pcm_sync_ptr itself. On x86-32
    (and only there), the compiler doesn't use 64-bit alignment in structure,
    so I'm adding an explicit pad in the structure that has no effect on the
    existing 64-bit architectures but ensures that the layout matches for x86.
    
    The snd_pcm_uframes_t type compatibility requires another hack: we can't
    easily make that 64 bit wide, so I leave the type as 'unsigned long',
    but add padding before and after it, to ensure that the data is properly
    aligned to the respective 64-bit field in the in-kernel structure.
    
    For the SNDRV_PCM_MMAP_OFFSET_STATUS/CONTROL constants that are used
    as the virtual file offset in the mmap() function, we also have to
    introduce new constants that depend on hte __USE_TIME_BITS64 macro:
    The existing macros are renamed to SNDRV_PCM_MMAP_OFFSET_STATUS_OLD
    and SNDRV_PCM_MMAP_OFFSET_CONTROL_OLD, they continue to work fine on
    64-bit architectures, but stop working on native 32-bit user space.
    The replacement _NEW constants are now used by default for user space
    built with __USE_TIME_BITS64, those now work on all new kernels for x86,
    ppc and alpha (32 and 64 bit, native and compat). It might be a good idea
    for a future alsa-lib to support both the _OLD and _NEW macros and use
    the corresponding structures directly. Unmodified alsa-lib source code
    will retain the current behavior, so it will no longer be able to use
    mmap() for the status/control structures on 32-bit systems, until either
    the C library gets updated to 64-bit time_t or alsa-lib gets updated to
    support both mmap() layouts.
    
    Co-developed-with: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ea5518d44e66..0271802bfba9 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -148,7 +148,8 @@ void __snd_pcm_xrun(struct snd_pcm_substream *substream)
 		struct timespec64 tstamp;
 
 		snd_pcm_gettime(runtime, &tstamp);
-		runtime->status->tstamp = timespec64_to_timespec(tstamp);
+		runtime->status->tstamp.tv_sec = tstamp.tv_sec;
+		runtime->status->tstamp.tv_nsec = tstamp.tv_nsec;
 	}
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {
@@ -238,9 +239,10 @@ static void update_audio_tstamp(struct snd_pcm_substream *substream,
 
 	if (runtime->status->audio_tstamp.tv_sec != audio_tstamp->tv_sec ||
 	    runtime->status->audio_tstamp.tv_nsec != audio_tstamp->tv_nsec) {
-		runtime->status->audio_tstamp =
-			timespec64_to_timespec(*audio_tstamp);
-		runtime->status->tstamp = timespec64_to_timespec(*curr_tstamp);
+		runtime->status->audio_tstamp.tv_sec = audio_tstamp->tv_sec;
+		runtime->status->audio_tstamp.tv_nsec = audio_tstamp->tv_nsec;
+		runtime->status->tstamp.tv_sec = curr_tstamp->tv_sec;
+		runtime->status->tstamp.tv_nsec = curr_tstamp->tv_nsec;
 	}
 
 

commit fcae40c99fb3d09f4407f549a7f17761abe5e1bc
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Apr 24 20:06:08 2018 +0800

    ALSA: Replace timespec with timespec64
    
    Since timespec is not year 2038 safe on 32bit system, and we need to
    convert all timespec variables to timespec64 type for sound subsystem.
    
    This patch is used to do preparation for following patches, that will
    convert all structures defined in uapi/sound/asound.h to use 64-bit
    time_t.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 2236b5e0c1f2..ea5518d44e66 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -144,8 +144,12 @@ void __snd_pcm_xrun(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	trace_xrun(substream);
-	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
-		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {
+		struct timespec64 tstamp;
+
+		snd_pcm_gettime(runtime, &tstamp);
+		runtime->status->tstamp = timespec64_to_timespec(tstamp);
+	}
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {
 		char name[16];
@@ -200,12 +204,12 @@ int snd_pcm_update_state(struct snd_pcm_substream *substream,
 }
 
 static void update_audio_tstamp(struct snd_pcm_substream *substream,
-				struct timespec *curr_tstamp,
-				struct timespec *audio_tstamp)
+				struct timespec64 *curr_tstamp,
+				struct timespec64 *audio_tstamp)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	u64 audio_frames, audio_nsecs;
-	struct timespec driver_tstamp;
+	struct timespec64 driver_tstamp;
 
 	if (runtime->tstamp_mode != SNDRV_PCM_TSTAMP_ENABLE)
 		return;
@@ -229,18 +233,22 @@ static void update_audio_tstamp(struct snd_pcm_substream *substream,
 		}
 		audio_nsecs = div_u64(audio_frames * 1000000000LL,
 				runtime->rate);
-		*audio_tstamp = ns_to_timespec(audio_nsecs);
+		*audio_tstamp = ns_to_timespec64(audio_nsecs);
 	}
-	if (!timespec_equal(&runtime->status->audio_tstamp, audio_tstamp)) {
-		runtime->status->audio_tstamp = *audio_tstamp;
-		runtime->status->tstamp = *curr_tstamp;
+
+	if (runtime->status->audio_tstamp.tv_sec != audio_tstamp->tv_sec ||
+	    runtime->status->audio_tstamp.tv_nsec != audio_tstamp->tv_nsec) {
+		runtime->status->audio_tstamp =
+			timespec64_to_timespec(*audio_tstamp);
+		runtime->status->tstamp = timespec64_to_timespec(*curr_tstamp);
 	}
 
+
 	/*
 	 * re-take a driver timestamp to let apps detect if the reference tstamp
 	 * read by low-level hardware was provided with a delay
 	 */
-	snd_pcm_gettime(substream->runtime, (struct timespec *)&driver_tstamp);
+	snd_pcm_gettime(substream->runtime, &driver_tstamp);
 	runtime->driver_tstamp = driver_tstamp;
 }
 
@@ -253,8 +261,8 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	snd_pcm_sframes_t hdelta, delta;
 	unsigned long jdelta;
 	unsigned long curr_jiffies;
-	struct timespec curr_tstamp;
-	struct timespec audio_tstamp;
+	struct timespec64 curr_tstamp;
+	struct timespec64 audio_tstamp;
 	int crossed_boundary = 0;
 
 	old_hw_ptr = runtime->status->hw_ptr;
@@ -277,9 +285,9 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 
 			/* re-test in case tstamp type is not supported in hardware and was demoted to DEFAULT */
 			if (runtime->audio_tstamp_report.actual_type == SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)
-				snd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);
+				snd_pcm_gettime(runtime, &curr_tstamp);
 		} else
-			snd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);
+			snd_pcm_gettime(runtime, &curr_tstamp);
 	}
 
 	if (pos == SNDRV_PCM_POS_XRUN) {

commit f5cdc9d4003a2f66ea57b3edd3e04acc2b1a4439
Author: paulhsia <paulhsia@chromium.org>
Date:   Wed Nov 13 01:17:14 2019 +0800

    ALSA: pcm: Fix stream lock usage in snd_pcm_period_elapsed()
    
    If the nullity check for `substream->runtime` is outside of the lock
    region, it is possible to have a null runtime in the critical section
    if snd_pcm_detach_substream is called right before the lock.
    
    Signed-off-by: paulhsia <paulhsia@chromium.org>
    Link: https://lore.kernel.org/r/20191112171715.128727-2-paulhsia@chromium.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index d80041ea4e01..2236b5e0c1f2 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1782,11 +1782,14 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime;
 	unsigned long flags;
 
-	if (PCM_RUNTIME_CHECK(substream))
+	if (snd_BUG_ON(!substream))
 		return;
-	runtime = substream->runtime;
 
 	snd_pcm_stream_lock_irqsave(substream, flags);
+	if (PCM_RUNTIME_CHECK(substream))
+		goto _unlock;
+	runtime = substream->runtime;
+
 	if (!snd_pcm_running(substream) ||
 	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
 		goto _end;
@@ -1797,6 +1800,7 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 #endif
  _end:
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
+ _unlock:
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
 EXPORT_SYMBOL(snd_pcm_period_elapsed);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 345ab1ab2cac..d80041ea4e01 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1,23 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Digital Audio (PCM) abstract layer
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *                   Abramo Bagnara <abramo@alsa-project.org>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/slab.h>

commit 932a81519572156a88dbc2349d183c603446f9c4
Author: Ricardo Biehl Pasquali <pasqualirb@gmail.com>
Date:   Wed Feb 13 00:57:51 2019 -0200

    ALSA: pcm: Comment why read blocks when PCM is not running
    
    This avoids bringing back the problem introduced by
    62ba568f7aef ("ALSA: pcm: Return 0 when size <
    start_threshold in capture") and fixed in 00a399cad1a0
    ("ALSA: pcm: Revert capture stream behavior change in
    blocking mode"), which prevented the user from starting
    capture from another thread.
    
    Signed-off-by: Ricardo Biehl Pasquali <pasqualirb@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index bcb06bd3d81d..345ab1ab2cac 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2176,6 +2176,10 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 		snd_pcm_update_hw_ptr(substream);
 
+	/*
+	 * If size < start_threshold, wait indefinitely. Another
+	 * thread may start capture
+	 */
 	if (!is_playback &&
 	    runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
 	    size >= runtime->start_threshold) {

commit 5a23f385686fe0e9cd8e19cb09dff9a3b68082de
Merge: d9c0b2afe820 00a399cad1a0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 13 08:00:47 2019 +0100

    Merge branch 'for-linus' into for-next
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 00a399cad1a063e7665f06b6497a807db20441fd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 6 07:30:44 2019 +0100

    ALSA: pcm: Revert capture stream behavior change in blocking mode
    
    In the commit 62ba568f7aef ("ALSA: pcm: Return 0 when size <
    start_threshold in capture"), we changed the behavior of
    __snd_pcm_lib_xfer() to return immediately with 0 when a capture
    stream has a high start_threshold.  This was intended to be a
    correction of the behavior consistency and looked harmless, but this
    was the culprit of the recent breakage reported by syzkaller, which
    was fixed by the commit e190161f96b8 ("ALSA: pcm: Fix tight loop of
    OSS capture stream").
    
    At the time for the OSS fix, I didn't touch the behavior for ALSA
    native API, as assuming that this behavior actually is good.  But this
    turned out to be also broken actually for a similar deployment,
    e.g. one thread goes to a write loop in blocking mode while another
    thread controls the start/stop of the stream manually.
    
    Overall, the original commit is harmful, and it brings less merit to
    keep that behavior.  Let's revert it.
    
    Fixes: 62ba568f7aef ("ALSA: pcm: Return 0 when size < start_threshold in capture")
    Fixes: e190161f96b8 ("ALSA: pcm: Fix tight loop of OSS capture stream")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 6c99fa8ac5fa..6c0b30391ba9 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2112,13 +2112,6 @@ int pcm_lib_apply_appl_ptr(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-/* allow waiting for a capture stream that hasn't been started */
-#if IS_ENABLED(CONFIG_SND_PCM_OSS)
-#define wait_capture_start(substream)	((substream)->oss.oss)
-#else
-#define wait_capture_start(substream)	false
-#endif
-
 /* the common loop for read/write data */
 snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 				     void *data, bool interleaved,
@@ -2184,16 +2177,11 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 		snd_pcm_update_hw_ptr(substream);
 
 	if (!is_playback &&
-	    runtime->status->state == SNDRV_PCM_STATE_PREPARED) {
-		if (size >= runtime->start_threshold) {
-			err = snd_pcm_start(substream);
-			if (err < 0)
-				goto _end_unlock;
-		} else if (!wait_capture_start(substream)) {
-			/* nothing to do */
-			err = 0;
+	    runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
+	    size >= runtime->start_threshold) {
+		err = snd_pcm_start(substream);
+		if (err < 0)
 			goto _end_unlock;
-		}
 	}
 
 	avail = snd_pcm_avail(substream);

commit 286406c2e198b199c348447b3a7c54c6324db147
Merge: b2e9e1c8810e e190161f96b8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 29 11:07:24 2019 +0100

    Merge branch 'for-linus' into for-next
    
    Pull 5.0 branch for further development of USB-audio quirks
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit e190161f96b88ffae870405fd6c3fdd1d2e7f98d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 25 17:11:32 2019 +0100

    ALSA: pcm: Fix tight loop of OSS capture stream
    
    When the trigger=off is passed for a PCM OSS stream, it sets the
    start_threshold of the given substream to the boundary size, so that
    it won't be automatically started.  This can be problematic for a
    capture stream, unfortunately, as detected by syzkaller.  The scenario
    is like the following:
    
    - In __snd_pcm_lib_xfer() that is invoked from snd_pcm_oss_read()
      loop, we have a check whether the stream was already started or the
      stream can be auto-started.
    - The function at this check returns 0 with trigger=off since we
      explicitly disable the auto-start.
    - The loop continues and repeats calling __snd_pcm_lib_xfer() tightly,
      which may lead to an RCU stall.
    
    This patch fixes the bug by simply allowing the wait for non-started
    stream in the case of OSS capture.  For native usages, it's supposed
    to be done by the caller side (which is user-space), hence it returns
    zero like before.
    
    (In theory, __snd_pcm_lib_xfer() could wait even for the native API
     usage cases, too; but I'd like to stay in a safer side for not
     breaking the existing stuff for now.)
    
    Reported-by: syzbot+fbe0496f92a0ce7b786c@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 40013b26f671..6c99fa8ac5fa 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2112,6 +2112,13 @@ int pcm_lib_apply_appl_ptr(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+/* allow waiting for a capture stream that hasn't been started */
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
+#define wait_capture_start(substream)	((substream)->oss.oss)
+#else
+#define wait_capture_start(substream)	false
+#endif
+
 /* the common loop for read/write data */
 snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 				     void *data, bool interleaved,
@@ -2182,7 +2189,7 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 			err = snd_pcm_start(substream);
 			if (err < 0)
 				goto _end_unlock;
-		} else {
+		} else if (!wait_capture_start(substream)) {
 			/* nothing to do */
 			err = 0;
 			goto _end_unlock;

commit 315d9f1bee40b20d399176acb1e27036abbd4384
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 25 17:31:59 2019 +0100

    ALSA: pcm: Use the common error path in __snd_pcm_lib_xfer()
    
    An open-coded error path in __snd_pcm_lib_xfer() can be replaced with
    the simple goto to the common error path.  This also makes the error
    handling more consistent, i.e. when some samples have been already
    processed, return that size instead of the error code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 40013b26f671..f48efce937ad 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2219,9 +2219,8 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 		if (frames > cont)
 			frames = cont;
 		if (snd_BUG_ON(!frames)) {
-			runtime->twake = 0;
-			snd_pcm_stream_unlock_irq(substream);
-			return -EINVAL;
+			err = -EINVAL;
+			goto _end_unlock;
 		}
 		snd_pcm_stream_unlock_irq(substream);
 		err = writer(substream, appl_ofs, data, offset, frames,

commit 64b6acf60b665fffd419c23886a1cbeeb253cfb4
Author: Ricardo Biehl Pasquali <pasqualirb@gmail.com>
Date:   Fri Sep 7 16:58:54 2018 -0300

    ALSA: pcm: Update hardware pointer before start capture
    
    This ensures the transfer loop won't waste a run to read
    the few frames (if any) between start and hw_ptr update.
    It will wait for the next interrupt with wait_for_avail().
    
    Signed-off-by: Ricardo Biehl Pasquali <pasqualirb@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 7f71c2449af5..40013b26f671 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2172,6 +2172,10 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 	if (err < 0)
 		goto _end_unlock;
 
+	runtime->twake = runtime->control->avail_min ? : 1;
+	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+		snd_pcm_update_hw_ptr(substream);
+
 	if (!is_playback &&
 	    runtime->status->state == SNDRV_PCM_STATE_PREPARED) {
 		if (size >= runtime->start_threshold) {
@@ -2185,10 +2189,8 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 		}
 	}
 
-	runtime->twake = runtime->control->avail_min ? : 1;
-	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
-		snd_pcm_update_hw_ptr(substream);
 	avail = snd_pcm_avail(substream);
+
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t cont;

commit 62ba568f7aef4beb0eda945a2b2a91b7a2b8f215
Author: Ricardo Biehl Pasquali <pasqualirb@gmail.com>
Date:   Sat Aug 25 16:53:23 2018 -0300

    ALSA: pcm: Return 0 when size < start_threshold in capture
    
    In __snd_pcm_lib_xfer(), when capture, if state is PREPARED
    and size is less than start_threshold nothing can be done.
    As there is no error, 0 is returned.
    
    Signed-off-by: Ricardo Biehl Pasquali <pasqualirb@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 4e6110d778bd..7f71c2449af5 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2173,11 +2173,16 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 		goto _end_unlock;
 
 	if (!is_playback &&
-	    runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
-	    size >= runtime->start_threshold) {
-		err = snd_pcm_start(substream);
-		if (err < 0)
+	    runtime->status->state == SNDRV_PCM_STATE_PREPARED) {
+		if (size >= runtime->start_threshold) {
+			err = snd_pcm_start(substream);
+			if (err < 0)
+				goto _end_unlock;
+		} else {
+			/* nothing to do */
+			err = 0;
 			goto _end_unlock;
+		}
 	}
 
 	runtime->twake = runtime->control->avail_min ? : 1;

commit ff2d6acdf6f13d9f8fdcd890844c6d7535ac1f10
Author: Timo Wischer <twischer@de.adit-jv.com>
Date:   Tue Jul 10 17:28:45 2018 +0200

    ALSA: pcm: Fix snd_interval_refine first/last with open min/max
    
    Without this commit the following intervals [x y), (x y) were be
    replaced to (y-1 y) by snd_interval_refine_last(). This was also done
    if y-1 is part of the previous interval.
    With this changes it will be replaced with [y-1 y) in case of y-1 is
    part of the previous interval. A similar behavior will be used for
    snd_interval_refine_first().
    
    This commit adapts the changes for alsa-lib of commit
    9bb985c ("pcm: snd_interval_refine_first/last: exclude value only if
    also excluded before")
    
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 5736860f325b..4e6110d778bd 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -627,27 +627,33 @@ EXPORT_SYMBOL(snd_interval_refine);
 
 static int snd_interval_refine_first(struct snd_interval *i)
 {
+	const unsigned int last_max = i->max;
+
 	if (snd_BUG_ON(snd_interval_empty(i)))
 		return -EINVAL;
 	if (snd_interval_single(i))
 		return 0;
 	i->max = i->min;
-	i->openmax = i->openmin;
-	if (i->openmax)
+	if (i->openmin)
 		i->max++;
+	/* only exclude max value if also excluded before refine */
+	i->openmax = (i->openmax && i->max >= last_max);
 	return 1;
 }
 
 static int snd_interval_refine_last(struct snd_interval *i)
 {
+	const unsigned int last_min = i->min;
+
 	if (snd_BUG_ON(snd_interval_empty(i)))
 		return -EINVAL;
 	if (snd_interval_single(i))
 		return 0;
 	i->min = i->max;
-	i->openmin = i->openmax;
-	if (i->openmin)
+	if (i->openmax)
 		i->min--;
+	/* only exclude min value if also excluded before refine */
+	i->openmin = (i->openmin && i->min <= last_min);
 	return 1;
 }
 

commit d64c5cf8e89d124355924c513a42b16f0d7d3a03
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri Jul 6 13:50:36 2018 +0100

    ALSA: pcm: Allow drivers to set R/W wait time.
    
    Currently ALSA core blocks userspace for about 10 seconds for PCM R/W IO.
    This needs to be configurable for modern hardware like DSPs where no
    pointer update in milliseconds can indicate terminal DSP errors.
    
    Add a substream variable to set the wait time in ms. This allows userspace
    and drivers to recover more quickly from terminal DSP errors.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index c1d2e8e1fc6b..5736860f325b 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1833,12 +1833,19 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 	if (runtime->no_period_wakeup)
 		wait_time = MAX_SCHEDULE_TIMEOUT;
 	else {
-		wait_time = 10;
-		if (runtime->rate) {
-			long t = runtime->period_size * 2 / runtime->rate;
-			wait_time = max(t, wait_time);
+		/* use wait time from substream if available */
+		if (substream->wait_time) {
+			wait_time = substream->wait_time;
+		} else {
+			wait_time = 10;
+
+			if (runtime->rate) {
+				long t = runtime->period_size * 2 /
+					 runtime->rate;
+				wait_time = max(t, wait_time);
+			}
+			wait_time = msecs_to_jiffies(wait_time * 1000);
 		}
-		wait_time = msecs_to_jiffies(wait_time * 1000);
 	}
 
 	for (;;) {

commit 9cd641ed31f576d08f7b784850ba93eef050f32f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 4 14:46:27 2018 +0200

    ALSA: pcm: trace XRUN event at injection, too
    
    The PCM xrun injection triggers directly snd_pcm_stop() without the
    standard xrun handler, hence it's not recorded on the event buffer.
    Ditto for snd_pcm_stop_xrun() call and SNDRV_PCM_IOCTL_XRUN ioctl.
    They are inconvenient from the debugging POV.
    
    Let's make them to trigger XRUN via the standard helper more
    consistently.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 44b5ae833082..c1d2e8e1fc6b 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -153,7 +153,8 @@ EXPORT_SYMBOL(snd_pcm_debug_name);
 			dump_stack();				\
 	} while (0)
 
-static void xrun(struct snd_pcm_substream *substream)
+/* call with stream lock held */
+void __snd_pcm_xrun(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
@@ -201,7 +202,7 @@ int snd_pcm_update_state(struct snd_pcm_substream *substream,
 		}
 	} else {
 		if (avail >= runtime->stop_threshold) {
-			xrun(substream);
+			__snd_pcm_xrun(substream);
 			return -EPIPE;
 		}
 	}
@@ -297,7 +298,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	}
 
 	if (pos == SNDRV_PCM_POS_XRUN) {
-		xrun(substream);
+		__snd_pcm_xrun(substream);
 		return -EPIPE;
 	}
 	if (pos >= runtime->buffer_size) {

commit 763e5067aac91ce569a8b1212e6c31968bc7d325
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 11 17:56:52 2018 +0200

    ALSA: pcm: Clean up with snd_pcm_avail() and snd_pcm_hw_avail() helpers
    
    Introduce two new direction-neutral helpers to calculate the avail and
    hw_avail values, and clean up the code with them.
    
    The two separated forward and rewind functions are gathered to the
    unified functions.
    
    No functional change but only code reductions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index f4a19509cccf..44b5ae833082 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -191,10 +191,7 @@ int snd_pcm_update_state(struct snd_pcm_substream *substream,
 {
 	snd_pcm_uframes_t avail;
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		avail = snd_pcm_playback_avail(runtime);
-	else
-		avail = snd_pcm_capture_avail(runtime);
+	avail = snd_pcm_avail(substream);
 	if (avail > runtime->avail_max)
 		runtime->avail_max = avail;
 	if (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
@@ -1856,10 +1853,7 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 		 * This check must happen after been added to the waitqueue
 		 * and having current state be INTERRUPTIBLE.
 		 */
-		if (is_playback)
-			avail = snd_pcm_playback_avail(runtime);
-		else
-			avail = snd_pcm_capture_avail(runtime);
+		avail = snd_pcm_avail(substream);
 		if (avail >= runtime->twake)
 			break;
 		snd_pcm_stream_unlock_irq(substream);
@@ -2175,10 +2169,7 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 	runtime->twake = runtime->control->avail_min ? : 1;
 	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 		snd_pcm_update_hw_ptr(substream);
-	if (is_playback)
-		avail = snd_pcm_playback_avail(runtime);
-	else
-		avail = snd_pcm_capture_avail(runtime);
+	avail = snd_pcm_avail(substream);
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t cont;

commit 09b9ddfaa18317f463085d602cf5f60a5fa88665
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 13 11:31:25 2018 +0100

    ALSA: pcm: Use krealloc() for resizing the rules array
    
    Just a minor simplification.  Change from kcalloc() shouldn't matter
    as each array element is fully initialized.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a83152e7d387..f4a19509cccf 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1129,16 +1129,12 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 	if (constrs->rules_num >= constrs->rules_all) {
 		struct snd_pcm_hw_rule *new;
 		unsigned int new_rules = constrs->rules_all + 16;
-		new = kcalloc(new_rules, sizeof(*c), GFP_KERNEL);
+		new = krealloc(constrs->rules, new_rules * sizeof(*c),
+			       GFP_KERNEL);
 		if (!new) {
 			va_end(args);
 			return -ENOMEM;
 		}
-		if (constrs->rules) {
-			memcpy(new, constrs->rules,
-			       constrs->rules_num * sizeof(*c));
-			kfree(constrs->rules);
-		}
 		constrs->rules = new;
 		constrs->rules_all = new_rules;
 	}

commit 4ea5553a51e55664f86bed29e62e67ecb45bedd8
Merge: 33193dca671c b3defb791b26
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 15 16:45:11 2018 +0100

    Merge branch 'for-linus' into for-next
    
    Back-merge to the development branch for further fixes of sequencer
    stuff.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 23b19b7b50fe1867da8d431eea9cd3e4b6328c2c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 10 23:48:05 2018 +0100

    ALSA: pcm: Remove yet superfluous WARN_ON()
    
    muldiv32() contains a snd_BUG_ON() (which is morphed as WARN_ON() with
    debug option) for checking the case of 0 / 0.  This would be helpful
    if this happens only as a logical error; however, since the hw refine
    is performed with any data set provided by user, the inconsistent
    values that can trigger such a condition might be passed easily.
    Actually, syzbot caught this by passing some zero'ed old hw_params
    ioctl.
    
    So, having snd_BUG_ON() there is simply superfluous and rather
    harmful to give unnecessary confusions.  Let's get rid of it.
    
    Reported-by: syzbot+7e6ee55011deeebce15d@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index db7894bb028c..faa67861cbc1 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -560,7 +560,6 @@ static inline unsigned int muldiv32(unsigned int a, unsigned int b,
 {
 	u_int64_t n = (u_int64_t) a * b;
 	if (c == 0) {
-		snd_BUG_ON(!n);
 		*r = 0;
 		return UINT_MAX;
 	}

commit 9dd55cb419769f8cb363d764815f119b98a816fa
Merge: da911b1f5e98 900498a34a3a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 9 08:49:41 2018 +0100

    Merge branch 'for-linus' into for-next
    
    Back-merge to continue fixing the OSS emulation code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 7a0a87160a1dc09220ec485b31d0f82f687a053f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 2 11:00:57 2018 +0100

    ALSA: pcm: Set config update bits only when really changed
    
    The PCM config space refine codes touch the parameter rmask and cmask
    bits when the given config parameter is changed.  But in most places
    it checks only whether the changed value is non-zero or not, and they
    don't consider whether a negative error value is returned.  This will
    lead to the incorrect update bits set upon the error path.
    
    Fix the codes to check properly the return code whether it's really
    updated or an error.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 10e7ef7a8804..bfff8d001466 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1603,7 +1603,7 @@ static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
 		changed = snd_interval_refine_first(hw_param_interval(params, var));
 	else
 		return -EINVAL;
-	if (changed) {
+	if (changed > 0) {
 		params->cmask |= 1 << var;
 		params->rmask |= 1 << var;
 	}
@@ -1649,7 +1649,7 @@ static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
 		changed = snd_interval_refine_last(hw_param_interval(params, var));
 	else
 		return -EINVAL;
-	if (changed) {
+	if (changed > 0) {
 		params->cmask |= 1 << var;
 		params->rmask |= 1 << var;
 	}

commit fe08f34d066f4404934a509b6806db1a4f700c86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 1 09:50:50 2018 +0100

    ALSA: pcm: Remove incorrect snd_BUG_ON() usages
    
    syzkaller triggered kernel warnings through PCM OSS emulation at
    closing a stream:
      WARNING: CPU: 0 PID: 3502 at sound/core/pcm_lib.c:1635
      snd_pcm_hw_param_first+0x289/0x690 sound/core/pcm_lib.c:1635
      Call Trace:
      ....
       snd_pcm_hw_param_near.constprop.27+0x78d/0x9a0 sound/core/oss/pcm_oss.c:457
       snd_pcm_oss_change_params+0x17d3/0x3720 sound/core/oss/pcm_oss.c:969
       snd_pcm_oss_make_ready+0xaa/0x130 sound/core/oss/pcm_oss.c:1128
       snd_pcm_oss_sync+0x257/0x830 sound/core/oss/pcm_oss.c:1638
       snd_pcm_oss_release+0x20b/0x280 sound/core/oss/pcm_oss.c:2431
       __fput+0x327/0x7e0 fs/file_table.c:210
       ....
    
    This happens while it tries to open and set up the aloop device
    concurrently.  The warning above (invoked from snd_BUG_ON() macro) is
    to detect the unexpected logical error where snd_pcm_hw_refine() call
    shouldn't fail.  The theory is true for the case where the hw_params
    config rules are static.  But for an aloop device, the hw_params rule
    condition does vary dynamically depending on the connected target;
    when another device is opened and changes the parameters, the device
    connected in another side is also affected, and it caused the error
    from snd_pcm_hw_refine().
    
    That is, the simplest "solution" for this is to remove the incorrect
    assumption of static rules, and treat such an error as a normal error
    path.  As there are a couple of other places using snd_BUG_ON()
    incorrectly, this patch removes these spurious snd_BUG_ON() calls.
    
    Reported-by: syzbot+6f11c7e2a1b91d466432@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 10e7ef7a8804..db7894bb028c 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1632,7 +1632,7 @@ int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm,
 		return changed;
 	if (params->rmask) {
 		int err = snd_pcm_hw_refine(pcm, params);
-		if (snd_BUG_ON(err < 0))
+		if (err < 0)
 			return err;
 	}
 	return snd_pcm_hw_param_value(params, var, dir);
@@ -1678,7 +1678,7 @@ int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm,
 		return changed;
 	if (params->rmask) {
 		int err = snd_pcm_hw_refine(pcm, params);
-		if (snd_BUG_ON(err < 0))
+		if (err < 0)
 			return err;
 	}
 	return snd_pcm_hw_param_value(params, var, dir);

commit 20e3f985bb875fea4f86b04eba4b6cc29bfd6b71
Author: Henrik Eriksson <henrik.eriksson@axis.com>
Date:   Tue Nov 21 09:29:28 2017 +0100

    ALSA: pcm: update tstamp only if audio_tstamp changed
    
    commit 3179f6200188 ("ALSA: core: add .get_time_info") had a side effect
    of changing the behaviour of the PCM runtime tstamp.  Prior to this
    change tstamp was not updated by snd_pcm_update_hw_ptr0() unless the
    hw_ptr had moved, after this change tstamp was always updated.
    
    For an application using alsa-lib, doing snd_pcm_readi() followed by
    snd_pcm_status() to estimate the age of the read samples by subtracting
    status->avail * [sample rate] from status->tstamp this change degraded
    the accuracy of the estimate on devices where the pcm hw does not
    provide a granular hw_ptr, e.g., devices using
    soc-generic-dmaengine-pcm.c and a dma-engine with residue_granularity
    DMA_RESIDUE_GRANULARITY_DESCRIPTOR.  The accuracy of the estimate
    depended on the latency between the PCM hw completing a period and the
    driver called snd_pcm_period_elapsed() to notify ALSA core, typically
    determined by interrupt handling latency.  After the change the accuracy
    of the estimate depended on the latency between the PCM hw completing a
    period and the application calling snd_pcm_status(), determined by the
    scheduling of the application process.  The maximum error of the
    estimate is one period length in both cases, but the error average and
    variance is smaller when it depends on interrupt latency.
    
    Instead of always updating tstamp, update it only if audio_tstamp
    changed.
    
    Fixes: 3179f6200188 ("ALSA: core: add .get_time_info")
    Suggested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Henrik Eriksson <henrik.eriksson@axis.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a93a4235a332..10e7ef7a8804 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -248,8 +248,10 @@ static void update_audio_tstamp(struct snd_pcm_substream *substream,
 				runtime->rate);
 		*audio_tstamp = ns_to_timespec(audio_nsecs);
 	}
-	runtime->status->audio_tstamp = *audio_tstamp;
-	runtime->status->tstamp = *curr_tstamp;
+	if (!timespec_equal(&runtime->status->audio_tstamp, audio_tstamp)) {
+		runtime->status->audio_tstamp = *audio_tstamp;
+		runtime->status->tstamp = *curr_tstamp;
+	}
 
 	/*
 	 * re-take a driver timestamp to let apps detect if the reference tstamp

commit 920f2ecdf6c3b3526f60fbd38c68597953cad3ee
Merge: 9ced560b8260 fc18282cdcba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 6 10:56:51 2017 -0700

    Merge tag 'sound-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This development cycle resulted in a fair amount of changes in both
      core and driver sides. The most significant change in ALSA core is
      about PCM. Also the support of of-graph card and the new DAPM widget
      for DSP are noteworthy changes in ASoC core. And there're lots of
      small changes splat over the tree, as you can see in diffstat.
    
      Below are a few highlights:
    
      ALSA core:
       - Removal of set_fs() hackery from PCM core stuff, and the code
         reorganization / optimization thereafter
       - Improved support of PCM ack ops, and a new ABI for improved
         control/status mmap handling
       - Lots of constifications in various codes
    
      ASoC core:
       - The support of of-graph card, which may work as a better generic
         device for a replacement of simple-card
       - New widget types intended mainly for use with DSPs
    
      ASoC drivers:
       - New drivers for Allwinner V3s SoCs
       - Ensonic ES8316 codec support
       - More Intel SKL and KBL works
       - More device support for Intel SST Atom (mostly for cheap tablets
         and 2-in-1 devices)
       - Support for Rockchip PDM controllers
       - Support for STM32 I2S and S/PDIF controllers
       - Support for ZTE AUD96P22 codecs
    
      HD-audio:
       - Support of new Realtek codecs (ALC215/ALC285/ALC289), more quirks
         for HP and Dell machines
       - A few more fixes for i915 component binding"
    
    * tag 'sound-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (418 commits)
      ALSA: hda - Fix unbalance of i915 module refcount
      ASoC: Intel: Skylake: Remove driver debugfs exit
      ASoC: Intel: Skylake: explicitly add the headers sst-dsp.h
      ALSA: hda/realtek - Remove GPIO_MASK
      ALSA: hda/realtek - Fix typo of pincfg for Dell quirk
      ALSA: pcm: add a documentation for tracepoints
      ALSA: atmel: ac97c: fix error return code in atmel_ac97c_probe()
      ALSA: x86: fix error return code in hdmi_lpe_audio_probe()
      ASoC: Intel: Skylake: Add support to read firmware registers
      ASoC: Intel: Skylake: Add sram address to sst_addr structure
      ASoC: Intel: Skylake: Debugfs facility to dump module config
      ASoC: Intel: Skylake: Add debugfs support
      ASoC: fix semicolon.cocci warnings
      ASoC: rt5645: Add quirk override by module option
      ASoC: rsnd: make arrays path and cmd_case static const
      ASoC: audio-graph-card: add widgets and routing for external amplifier support
      ASoC: audio-graph-card: update bindings for amplifier support
      ASoC: rt5665: calibration should be done before jack detection
      ASoC: rsnd: constify dev_pm_ops structures.
      ASoC: nau8825: change crosstalk-bypass property to bool type
      ...

commit 1bc3cd4dfa9f2f5385ee15de2301d25e51cf43f0
Merge: 8887cd99038b 94a6df251dd0
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Jun 24 08:57:20 2017 +0200

    Merge branch 'linus' into sched/core, to pick up fixes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit ac6424b981bce1c4bc55675c6ce11bfe1bbfa64f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:06:13 2017 +0200

    sched/wait: Rename wait_queue_t => wait_queue_entry_t
    
    Rename:
    
            wait_queue_t            =>      wait_queue_entry_t
    
    'wait_queue_t' was always a slight misnomer: its name implies that it's a "queue",
    but in reality it's a queue *entry*. The 'real' queue is the wait queue head,
    which had to carry the name.
    
    Start sorting this out by renaming it to 'wait_queue_entry_t'.
    
    This also allows the real structure name 'struct __wait_queue' to
    lose its double underscore and become 'struct wait_queue_entry',
    which is the more canonical nomenclature for such data types.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 5088d4b8db22..dd5254077ef7 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1904,7 +1904,7 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
-	wait_queue_t wait;
+	wait_queue_entry_t wait;
 	int err = 0;
 	snd_pcm_uframes_t avail = 0;
 	long wait_time, tout;

commit aa30db060121f688d01f74f8d3fe603f7c4c731c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 16 22:29:55 2017 +0200

    ALSA: pcm: Fix possible inconsistent appl_ptr update via mmap
    
    The ALSA PCM core refers to the appl_ptr value stored on the mmapped
    page that is shared between kernel and user-space.  Although the
    reference is performed in the PCM stream lock, it doesn't guarantee
    the atomic access when the value gets updated concurrently from the
    user-space on another CPU.
    
    In most of codes, this is no big problem, but still there are a few
    places that may result in slight inconsistencies because they access
    runtime->control->appl_ptr multiple times; that is, the second read
    might be a different value from the first value.  It can be even
    backward or jumping, as we have no control for it.  Hence, the
    calculation may give an unexpected value.  Luckily, there is no
    security vulnerability by that, as far as I've checked.  But still we
    should address it.
    
    This patch tries to reduce such possible cases.  The fix is simple --
    we just read once, store it to a local variable and use it for the
    rest calculations.  The READ_ONCE() macro is used for it in order to
    avoid the ill-effect by possible compiler optimizations.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index e8131c060c86..e76d55a4d1b2 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -65,15 +65,16 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 
 	if (runtime->silence_size < runtime->boundary) {
 		snd_pcm_sframes_t noise_dist, n;
-		if (runtime->silence_start != runtime->control->appl_ptr) {
-			n = runtime->control->appl_ptr - runtime->silence_start;
+		snd_pcm_uframes_t appl_ptr = READ_ONCE(runtime->control->appl_ptr);
+		if (runtime->silence_start != appl_ptr) {
+			n = appl_ptr - runtime->silence_start;
 			if (n < 0)
 				n += runtime->boundary;
 			if ((snd_pcm_uframes_t)n < runtime->silence_filled)
 				runtime->silence_filled -= n;
 			else
 				runtime->silence_filled = 0;
-			runtime->silence_start = runtime->control->appl_ptr;
+			runtime->silence_start = appl_ptr;
 		}
 		if (runtime->silence_filled >= runtime->buffer_size)
 			return;
@@ -2203,7 +2204,9 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 				continue; /* draining */
 		}
 		frames = size > avail ? avail : size;
-		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
+		appl_ptr = READ_ONCE(runtime->control->appl_ptr);
+		appl_ofs = appl_ptr % runtime->buffer_size;
+		cont = runtime->buffer_size - appl_ofs;
 		if (frames > cont)
 			frames = cont;
 		if (snd_BUG_ON(!frames)) {
@@ -2211,8 +2214,6 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 			snd_pcm_stream_unlock_irq(substream);
 			return -EINVAL;
 		}
-		appl_ptr = runtime->control->appl_ptr;
-		appl_ofs = appl_ptr % runtime->buffer_size;
 		snd_pcm_stream_unlock_irq(substream);
 		err = writer(substream, appl_ofs, data, offset, frames,
 			     transfer);

commit 7fc8e7c1d9787ab8cb0f91adb3bc9c2c64c00ef8
Merge: 8cad7a3db658 c7ecb9068e67
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 20 07:53:07 2017 +0200

    Merge branch 'for-linus' into for-next

commit 602d7d72c8255f80898e94562f777635efd1ddaf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 16 16:12:30 2017 +0200

    ALSA: pcm: Follow standard EXPORT_SYMBOL() declarations
    
    Just a tidy up to follow the standard EXPORT_SYMBOL*() declarations
    in order to improve grep-ability.
    
    - Remove superfluous blank line before EXPORT_SYMBOL*() lines
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 631cd598ba6c..461c21f21caf 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -490,7 +490,6 @@ void snd_pcm_set_ops(struct snd_pcm *pcm, int direction,
 	for (substream = stream->substream; substream != NULL; substream = substream->next)
 		substream->ops = ops;
 }
-
 EXPORT_SYMBOL(snd_pcm_set_ops);
 
 /**
@@ -508,7 +507,6 @@ void snd_pcm_set_sync(struct snd_pcm_substream *substream)
 	runtime->sync.id32[2] = -1;
 	runtime->sync.id32[3] = -1;
 }
-
 EXPORT_SYMBOL(snd_pcm_set_sync);
 
 /*
@@ -625,7 +623,6 @@ int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)
 	}
 	return changed;
 }
-
 EXPORT_SYMBOL(snd_interval_refine);
 
 static int snd_interval_refine_first(struct snd_interval *i)
@@ -888,7 +885,6 @@ int snd_interval_ratnum(struct snd_interval *i,
 	}
 	return err;
 }
-
 EXPORT_SYMBOL(snd_interval_ratnum);
 
 /**
@@ -1026,7 +1022,6 @@ int snd_interval_list(struct snd_interval *i, unsigned int count,
         }
 	return snd_interval_refine(i, &list_range);
 }
-
 EXPORT_SYMBOL(snd_interval_list);
 
 /**
@@ -1165,7 +1160,6 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 	va_end(args);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_rule_add);
 
 /**
@@ -1229,7 +1223,6 @@ int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_pa
 	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
 	return snd_interval_setinteger(constrs_interval(constrs, var));
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_constraint_integer);
 
 /**
@@ -1255,7 +1248,6 @@ int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_par
 	t.integer = 0;
 	return snd_interval_refine(constrs_interval(constrs, var), &t);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_constraint_minmax);
 
 static int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,
@@ -1286,7 +1278,6 @@ int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
 				   snd_pcm_hw_rule_list, (void *)l,
 				   var, -1);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_constraint_list);
 
 static int snd_pcm_hw_rule_ranges(struct snd_pcm_hw_params *params,
@@ -1353,7 +1344,6 @@ int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime,
 				   snd_pcm_hw_rule_ratnums, (void *)r,
 				   var, -1);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);
 
 static int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,
@@ -1388,7 +1378,6 @@ int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime,
 				   snd_pcm_hw_rule_ratdens, (void *)r,
 				   var, -1);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_constraint_ratdens);
 
 static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
@@ -1435,7 +1424,6 @@ int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime,
 				    (void*) l,
 				    SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_constraint_msbits);
 
 static int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,
@@ -1463,7 +1451,6 @@ int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
 				   snd_pcm_hw_rule_step, (void *) step,
 				   var, -1);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_constraint_step);
 
 static int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)
@@ -1494,7 +1481,6 @@ int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
 				   snd_pcm_hw_rule_pow2, NULL,
 				   var, -1);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);
 
 static int snd_pcm_hw_rule_noresample_func(struct snd_pcm_hw_params *params,
@@ -1553,7 +1539,6 @@ void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)
 		_snd_pcm_hw_param_any(params, k);
 	params->info = ~0U;
 }
-
 EXPORT_SYMBOL(_snd_pcm_hw_params_any);
 
 /**
@@ -1586,7 +1571,6 @@ int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
 	}
 	return -EINVAL;
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_param_value);
 
 void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,
@@ -1604,7 +1588,6 @@ void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,
 		snd_BUG();
 	}
 }
-
 EXPORT_SYMBOL(_snd_pcm_hw_param_setempty);
 
 static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
@@ -1651,7 +1634,6 @@ int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm,
 	}
 	return snd_pcm_hw_param_value(params, var, dir);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_param_first);
 
 static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
@@ -1698,7 +1680,6 @@ int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm,
 	}
 	return snd_pcm_hw_param_value(params, var, dir);
 }
-
 EXPORT_SYMBOL(snd_pcm_hw_param_last);
 
 static int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,
@@ -1796,7 +1777,6 @@ int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 	}
 	return -ENXIO;
 }
-
 EXPORT_SYMBOL(snd_pcm_lib_ioctl);
 
 /**
@@ -1832,7 +1812,6 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
-
 EXPORT_SYMBOL(snd_pcm_period_elapsed);
 
 /*

commit 2deaeaf102d692cb6f764123b1df7aa118a8e97c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 14 16:20:32 2017 +0200

    ALSA: pcm: Don't treat NULL chmap as a fatal error
    
    The standard PCM chmap helper callbacks treat the NULL info->chmap as
    a fatal error and spews the kernel warning with stack trace when
    CONFIG_SND_DEBUG is on.  This was OK, originally it was supposed to be
    always static and non-NULL.  But, as the recent addition of Intel LPE
    audio driver shows, the chmap content may vary dynamically, and it can
    be even NULL when disconnected.  The user still sees the kernel
    warning unnecessarily.
    
    For clearing such a confusion, this patch simply removes the
    snd_BUG_ON() in each place, just returns an error without warning.
    
    Cc: <stable@vger.kernel.org> # v4.11+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 5088d4b8db22..009e6c98754e 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2492,7 +2492,7 @@ static int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,
 	struct snd_pcm_substream *substream;
 	const struct snd_pcm_chmap_elem *map;
 
-	if (snd_BUG_ON(!info->chmap))
+	if (!info->chmap)
 		return -EINVAL;
 	substream = snd_pcm_chmap_substream(info, idx);
 	if (!substream)
@@ -2524,7 +2524,7 @@ static int pcm_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,
 	unsigned int __user *dst;
 	int c, count = 0;
 
-	if (snd_BUG_ON(!info->chmap))
+	if (!info->chmap)
 		return -EINVAL;
 	if (size < 8)
 		return -ENOMEM;

commit e11f0f90a626f93899687b1cc909ee37dd6c5809
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 14 19:30:03 2017 +0900

    ALSA: pcm: remove SNDRV_PCM_IOCTL1_INFO internal command
    
    Drivers can implement 'struct snd_pcm_ops.ioctl' to handle some requests
    from ALSA PCM core. These requests are internal purpose in kernel land.
    Usually common set of operations are used for it.
    
    SNDRV_PCM_IOCTL1_INFO is one of the requests. According to code comment,
    it has been obsoleted in the old days.
    
    We can see old releases in ftp.alsa-project.org. The command was firstly
    introduced in v0.5.0 release as SND_PCM_IOCTL1_INFO, to allow drivers to
    fill data of 'struct snd_pcm_channel_info' type. In v0.9.0 release,
    this was obsoleted by the other commands for ioctl(2) such as
    SNDRV_PCM_IOCTL_CHANNEL_INFO.
    
    This commit removes the long-abandoned command, bye.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 75308ddc54ca..631cd598ba6c 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1787,8 +1787,6 @@ int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg)
 {
 	switch (cmd) {
-	case SNDRV_PCM_IOCTL1_INFO:
-		return 0;
 	case SNDRV_PCM_IOCTL1_RESET:
 		return snd_pcm_lib_ioctl_reset(substream, arg);
 	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:

commit f8ff2f28ba49fa41a06215ac3187dede347bc9a7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 13 15:57:28 2017 +0200

    ALSA: pcm: Skip ack callback without actual appl_ptr update
    
    We call ack callback whenever appl_ptr gets updated via
    pcm_lib_apply_appl_ptr().  There are various code paths to call this
    function.  A part of them are for read/write/forward/rewind, where the
    appl_ptr is always changed and thus the call of ack is mandatory.
    OTOH, another part of code paths are from the explicit user call,
    e.g. via SYNC_PTR ioctl.  There, we may receive the same appl_ptr
    value, and in such a case, calling ack is obviously superfluous.
    
    This patch adds the check of the given appl_ptr value, and returns
    immediately if it's no real update.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index e73b6e4135f6..75308ddc54ca 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2112,6 +2112,9 @@ int pcm_lib_apply_appl_ptr(struct snd_pcm_substream *substream,
 	snd_pcm_uframes_t old_appl_ptr = runtime->control->appl_ptr;
 	int ret;
 
+	if (old_appl_ptr == appl_ptr)
+		return 0;
+
 	runtime->control->appl_ptr = appl_ptr;
 	if (substream->ops->ack) {
 		ret = substream->ops->ack(substream);

commit fccf53881e9b564321326f62ed5f85130fa6e569
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 12 09:41:45 2017 +0900

    ALSA: pcm: add 'applptr' event of tracepoint
    
    In design of ALSA PCM core, status and control data for runtime of ALSA
    PCM substream are shared between kernel/user spaces by page frame
    mapping with read-only attribute. Both of hardware-side and
    application-side position on PCM buffer are maintained as a part of
    the status data. In a view of ALSA PCM application, these two positions
    can be updated by executing ioctl(2) with some commands.
    
    There's an event of tracepoint for hardware-side position; 'hwptr'.
    On the other hand, no events for application-side position. This commit
    adds a new event for this purpose; 'applptr'. When the application-side
    position is changed in kernel space, this event is probed with useful
    information for developers.
    
    I note that the event is not probed for all of ALSA PCM applications, When
    applications are written by read/write programming scenario, the event is
    surely probed. The applications execute ioctl(2) with
    SNDRV_PCM_IOCTL_[READ|WRITE][N/I]_FRAMES to read/write any PCM frame, then
    ALSA PCM core updates the application-side position in kernel land.
    However, when applications are written by mmap programming scenario, if
    maintaining the application side position in kernel space accurately,
    applications should voluntarily execute ioctl(2) with
    SNDRV_PCM_IOCTL_SYNC_PTR to commit the number of handled PCM frames. If
    not voluntarily, the application-side position is not changed, thus the
    added event is not probed.
    
    There's a loophole, using architectures to which ALSA PCM core judges
    non cache coherent. In this case, the status and control data is not mapped
    into processe's VMA for any applications. Userland library, alsa-lib, is
    programmed for this case. It executes ioctl(2) with
    SNDRV_PCM_IOCTL_SYNC_PTR command every time to requiring the status and
    control data.
    
    ARM is such an architecture. Below is an example with serial sound interface
    (ssi) on i.mx6 quad core SoC. I use v4.1 kernel released by fsl-community
    with patches from VIA Tech. Inc. for VAB820, and my backport patches for
    relevant features for this patchset. I use Ubuntu 17.04 from
    ports.ubuntu.com as user land for armhf architecture.
    
    $ aplay -v -M -D hw:imx6vab820sgtl5,0 /dev/urandom -f S16_LE -r 48000 --period-size=128 --buffer-size=256
    Playing raw data '/dev/urandom' : Signed 16 bit Little Endian, Rate 48000 Hz, Mono
    Hardware PCM card 0 'imx6-vab820-sgtl5000' device 0 subdevice 0
    Its setup is:
      stream       : PLAYBACK
      access       : MMAP_INTERLEAVED
      format       : S16_LE
      subformat    : STD
      channels     : 1
      rate         : 48000
      exact rate   : 48000 (48000/1)
      msbits       : 16
      buffer_size  : 256
      period_size  : 128
      period_time  : 2666
      tstamp_mode  : NONE
      tstamp_type  : MONOTONIC
      period_step  : 1
      avail_min    : 128
      period_event : 0
      start_threshold  : 256
      stop_threshold   : 256
      silence_threshold: 0
      silence_size : 0
      boundary     : 1073741824
      appl_ptr     : 0
      hw_ptr       : 0
    mmap_area[0] = 0x76f98000,0,16 (16)
    
    $ trace-cmd record -e snd_pcm:hwptr -e snd_pcm:applptr
    $ trace-cmd report
    ...
    60.208495: applptr: pcmC0D0p/sub0: prev=1792, curr=1792, avail=0, period=128, buf=256
    60.208633: applptr: pcmC0D0p/sub0: prev=1792, curr=1792, avail=0, period=128, buf=256
    60.210022: hwptr:   pcmC0D0p/sub0: IRQ: pos=128, old=1536, base=1536, period=128, buf=256
    60.210202: applptr: pcmC0D0p/sub0: prev=1792, curr=1792, avail=128, period=128, buf=256
    60.210344: hwptr:   pcmC0D0p/sub0: POS: pos=128, old=1664, base=1536, period=128, buf=256
    60.210348: applptr: pcmC0D0p/sub0: prev=1792, curr=1792, avail=128, period=128, buf=256
    60.210486: applptr: pcmC0D0p/sub0: prev=1792, curr=1792, avail=128, period=128, buf=256
    60.210626: applptr: pcmC0D0p/sub0: prev=1792, curr=1920, avail=0, period=128, buf=256
    60.211002: applptr: pcmC0D0p/sub0: prev=1920, curr=1920, avail=0, period=128, buf=256
    60.211142: hwptr:   pcmC0D0p/sub0: POS: pos=128, old=1664, base=1536, period=128, buf=256
    60.211146: applptr: pcmC0D0p/sub0: prev=1920, curr=1920, avail=0, period=128, buf=256
    60.211287: applptr: pcmC0D0p/sub0: prev=1920, curr=1920, avail=0, period=128, buf=256
    60.212690: hwptr:   pcmC0D0p/sub0: IRQ: pos=0, old=1664, base=1536, period=128, buf=256
    60.212866: applptr: pcmC0D0p/sub0: prev=1920, curr=1920, avail=128, period=128, buf=256
    60.212999: hwptr:   pcmC0D0p/sub0: POS: pos=0, old=1792, base=1792, period=128, buf=256
    60.213003: applptr: pcmC0D0p/sub0: prev=1920, curr=1920, avail=128, period=128, buf=256
    60.213135: applptr: pcmC0D0p/sub0: prev=1920, curr=1920, avail=128, period=128, buf=256
    60.213276: applptr: pcmC0D0p/sub0: prev=1920, curr=2048, avail=0, period=128, buf=256
    60.213654: applptr: pcmC0D0p/sub0: prev=2048, curr=2048, avail=0, period=128, buf=256
    60.213796: hwptr:   pcmC0D0p/sub0: POS: pos=0, old=1792, base=1792, period=128, buf=256
    60.213800: applptr: pcmC0D0p/sub0: prev=2048, curr=2048, avail=0, period=128, buf=256
    60.213937: applptr: pcmC0D0p/sub0: prev=2048, curr=2048, avail=0, period=128, buf=256
    60.215356: hwptr:   pcmC0D0p/sub0: IRQ: pos=128, old=1792, base=1792, period=128, buf=256
    60.215542: applptr: pcmC0D0p/sub0: prev=2048, curr=2048, avail=128, period=128, buf=256
    60.215679: hwptr:   pcmC0D0p/sub0: POS: pos=128, old=1920, base=1792, period=128, buf=256
    60.215683: applptr: pcmC0D0p/sub0: prev=2048, curr=2048, avail=128, period=128, buf=256
    60.215813: applptr: pcmC0D0p/sub0: prev=2048, curr=2048, avail=128, period=128, buf=256
    60.215947: applptr: pcmC0D0p/sub0: prev=2048, curr=2176, avail=0, period=128, buf=256
    ...
    
    We can surely see 'applptr' event is probed even if the application run
    for mmap programming scenario ('-M' option and 'hw' plugin). Below is a
    result of strace:
    
    02:44:15.886382 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.887203 poll([{fd=4, events=POLLOUT|POLLERR|POLLNVAL}], 1, -1) = 1 ([{fd=4, revents=POLLOUT}])
    02:44:15.887471 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.887637 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.887805 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.887969 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.888132 read(3, "..."..., 256) = 256
    02:44:15.889040 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.889221 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.889431 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.889606 poll([{fd=4, events=POLLOUT|POLLERR|POLLNVAL}], 1, -1) = 1 ([{fd=4, revents=POLLOUT}])
    02:44:15.889833 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.889998 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.890164 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.891048 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.891228 read(3, "..."..., 256) = 256
    02:44:15.891497 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.891661 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.891829 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    02:44:15.891991 poll([{fd=4, events=POLLOUT|POLLERR|POLLNVAL}], 1, -1) = 1 ([{fd=4, revents=POLLOUT}])
    02:44:15.893007 ioctl(4, SNDRV_PCM_IOCTL_SYNC_PTR, 0x56a32b30) = 0
    
    We can see 7 calls of ioctl(2) with SNDRV_PCM_IOCTL_SYNC_PTR per loop with
    call of poll(2). 128 PCM frames are transferred per loop of one poll(2),
    because the PCM substream is configured with S16_LE format and 1 channel
    (2 byte * 1 * 128 = 256 bytes). This equals to the size of period of PCM
    buffer. Comparing to the probed data, one of the 7 calls of ioctl(2) is
    actually used to commit the number of copied PCM frames to kernel space.
    The other calls are just used to check runtime status of PCM substream;
    e.g. XRUN.
    
    The tracepoint event is useful to investigate this case. I note that below
    modules are related to the above sample.
    
     * snd-soc-dummy.ko
     * snd-soc-imx-sgtl5000.ko
     * snd-soc-fsl-ssi.ko
     * snd-soc-imx-pcm-dma.ko
     * snd-soc-sgtl5000.ko
    
    My additional note is lock acquisition. The event is probed under acquiring
    PCM stream lock. This means that calculation in the event is free from
    any hardware events.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index d82f1437667f..e73b6e4135f6 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -42,6 +42,7 @@
 #define trace_hwptr(substream, pos, in_interrupt)
 #define trace_xrun(substream)
 #define trace_hw_ptr_error(substream, reason)
+#define trace_applptr(substream, prev, curr)
 #endif
 
 static int fill_silence_frames(struct snd_pcm_substream *substream,
@@ -2119,6 +2120,9 @@ int pcm_lib_apply_appl_ptr(struct snd_pcm_substream *substream,
 			return ret;
 		}
 	}
+
+	trace_applptr(substream, old_appl_ptr, appl_ptr);
+
 	return 0;
 }
 

commit 66e01a5cf63f2b132059d0d3d78ed737207489f2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 12 09:41:44 2017 +0900

    ALSA: pcm: unify codes to operate application-side position on PCM buffer
    
    In a series of recent work, ALSA PCM core got some arrangements to handle
    application-side position on PCM buffer. However, relevant codes still
    disperse to two translation units
    
    This commit unifies these codes into a helper function.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 9dc7bbfe8853..d82f1437667f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2101,6 +2101,27 @@ static int pcm_accessible_state(struct snd_pcm_runtime *runtime)
 	}
 }
 
+/* update to the given appl_ptr and call ack callback if needed;
+ * when an error is returned, take back to the original value
+ */
+int pcm_lib_apply_appl_ptr(struct snd_pcm_substream *substream,
+			   snd_pcm_uframes_t appl_ptr)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t old_appl_ptr = runtime->control->appl_ptr;
+	int ret;
+
+	runtime->control->appl_ptr = appl_ptr;
+	if (substream->ops->ack) {
+		ret = substream->ops->ack(substream);
+		if (ret < 0) {
+			runtime->control->appl_ptr = old_appl_ptr;
+			return ret;
+		}
+	}
+	return 0;
+}
+
 /* the common loop for read/write data */
 snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 				     void *data, bool interleaved,
@@ -2220,9 +2241,9 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 		appl_ptr += frames;
 		if (appl_ptr >= runtime->boundary)
 			appl_ptr -= runtime->boundary;
-		runtime->control->appl_ptr = appl_ptr;
-		if (substream->ops->ack)
-			substream->ops->ack(substream);
+		err = pcm_lib_apply_appl_ptr(substream, appl_ptr);
+		if (err < 0)
+			goto _end_unlock;
 
 		offset += frames;
 		size -= frames;

commit 60f96aaecb19ca294addfff0d2d0335293f3c379
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Jun 9 21:46:48 2017 +0900

    ALSA: pcm: localize snd_pcm_hw_params_choose()
    
    As of v4.12, snd_pcm_hw_params_choose() is just called in a process
    context of ioctl(2) with SNDRV_PCM_IOCTL_HW_PARAMS. The function locates
    in a different file, which has no tracepoints.
    
    This commit moves the function to a file with the tracepoints for later
    commit.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 95b8ef15029f..9dc7bbfe8853 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1700,46 +1700,6 @@ int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm,
 
 EXPORT_SYMBOL(snd_pcm_hw_param_last);
 
-/**
- * snd_pcm_hw_param_choose - choose a configuration defined by @params
- * @pcm: PCM instance
- * @params: the hw_params instance
- *
- * Choose one configuration from configuration space defined by @params.
- * The configuration chosen is that obtained fixing in this order:
- * first access, first format, first subformat, min channels,
- * min rate, min period time, max buffer size, min tick time
- *
- * Return: Zero if successful, or a negative error code on failure.
- */
-int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,
-			     struct snd_pcm_hw_params *params)
-{
-	static const int vars[] = {
-		SNDRV_PCM_HW_PARAM_ACCESS,
-		SNDRV_PCM_HW_PARAM_FORMAT,
-		SNDRV_PCM_HW_PARAM_SUBFORMAT,
-		SNDRV_PCM_HW_PARAM_CHANNELS,
-		SNDRV_PCM_HW_PARAM_RATE,
-		SNDRV_PCM_HW_PARAM_PERIOD_TIME,
-		SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
-		SNDRV_PCM_HW_PARAM_TICK_TIME,
-		-1
-	};
-	const int *v;
-	int err;
-
-	for (v = vars; *v != -1; v++) {
-		if (*v != SNDRV_PCM_HW_PARAM_BUFFER_SIZE)
-			err = snd_pcm_hw_param_first(pcm, params, *v, NULL);
-		else
-			err = snd_pcm_hw_param_last(pcm, params, *v, NULL);
-		if (snd_BUG_ON(err < 0))
-			return err;
-	}
-	return 0;
-}
-
 static int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,
 				   void *arg)
 {

commit 68541213720df9bb7904cc1fecab563d424849ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 18:23:20 2017 +0200

    ALSA: pcm: Direct in-kernel read/write support
    
    Now all materials are ready, let's allow the direct in-kernel
    read/write, i.e. a kernel-space buffer is passed for read or write,
    instead of the normal user-space buffer.  This feature is used by OSS
    layer and UAC1 driver, for example.
    
    The __snd_pcm_lib_xfer() takes in_kernel argument that indicates the
    in-kernel buffer copy.  When this flag is set, another transfer code
    is used.  It's either via copy_kernel PCM ops or the normal memcpy(),
    depending on the driver setup.
    
    As external API, snd_pcm_kernel_read(), *_write() and other variants
    are provided.
    
    That's all.  This support is really simple because of the code
    refactoring until now.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index f31949b20c0d..95b8ef15029f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1994,6 +1994,15 @@ static int default_write_copy(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+/* default copy_kernel ops for write */
+static int default_write_copy_kernel(struct snd_pcm_substream *substream,
+				     int channel, unsigned long hwoff,
+				     void *buf, unsigned long bytes)
+{
+	memcpy(get_dma_ptr(substream->runtime, channel, hwoff), buf, bytes);
+	return 0;
+}
+
 /* fill silence instead of copy data; called as a transfer helper
  * from __snd_pcm_lib_write() or directly from noninterleaved_copy() when
  * a NULL buffer is passed
@@ -2027,6 +2036,15 @@ static int default_read_copy(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+/* default copy_kernel ops for read */
+static int default_read_copy_kernel(struct snd_pcm_substream *substream,
+				    int channel, unsigned long hwoff,
+				    void *buf, unsigned long bytes)
+{
+	memcpy(buf, get_dma_ptr(substream->runtime, channel, hwoff), bytes);
+	return 0;
+}
+
 /* call transfer function with the converted pointers and sizes;
  * for interleaved mode, it's one shot for all samples
  */
@@ -2126,7 +2144,7 @@ static int pcm_accessible_state(struct snd_pcm_runtime *runtime)
 /* the common loop for read/write data */
 snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 				     void *data, bool interleaved,
-				     snd_pcm_uframes_t size)
+				     snd_pcm_uframes_t size, bool in_kernel)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t xfer = 0;
@@ -2159,6 +2177,12 @@ snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
 			transfer = fill_silence;
 		else
 			return -EINVAL;
+	} else if (in_kernel) {
+		if (substream->ops->copy_kernel)
+			transfer = substream->ops->copy_kernel;
+		else
+			transfer = is_playback ?
+				default_write_copy_kernel : default_read_copy_kernel;
 	} else {
 		if (substream->ops->copy_user)
 			transfer = (pcm_transfer_f)substream->ops->copy_user;

commit a9cd29e79965f0f769d13edcf2e9adb389698e7b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 18:18:15 2017 +0200

    ALSA: pcm: Simplify snd_pcm_playback_silence()
    
    Use the existing silence helper codes for simplification.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index af73c629a6b2..f31949b20c0d 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -44,6 +44,9 @@
 #define trace_hw_ptr_error(substream, reason)
 #endif
 
+static int fill_silence_frames(struct snd_pcm_substream *substream,
+			       snd_pcm_uframes_t off, snd_pcm_uframes_t frames);
+
 /*
  * fill ring buffer with silence
  * runtime->silence_start: starting pointer to silence area
@@ -57,7 +60,6 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t frames, ofs, transfer;
-	char *hwbuf;
 	int err;
 
 	if (runtime->silence_size < runtime->boundary) {
@@ -111,35 +113,8 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 	ofs = runtime->silence_start % runtime->buffer_size;
 	while (frames > 0) {
 		transfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;
-		if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||
-		    runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
-			if (substream->ops->fill_silence) {
-				err = substream->ops->fill_silence(substream, 0,
-								   frames_to_bytes(runtime, ofs),
-								   frames_to_bytes(runtime, transfer));
-				snd_BUG_ON(err < 0);
-			} else {
-				hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);
-				snd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);
-			}
-		} else {
-			unsigned int c;
-			unsigned int channels = runtime->channels;
-			if (substream->ops->fill_silence) {
-				for (c = 0; c < channels; ++c) {
-					err = substream->ops->fill_silence(substream, c,
-									   samples_to_bytes(runtime, ofs),
-									   samples_to_bytes(runtime, transfer));
-					snd_BUG_ON(err < 0);
-				}
-			} else {
-				size_t dma_csize = runtime->dma_bytes / channels;
-				for (c = 0; c < channels; ++c) {
-					hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, ofs);
-					snd_pcm_format_set_silence(runtime->format, hwbuf, transfer);
-				}
-			}
-		}
+		err = fill_silence_frames(substream, ofs, transfer);
+		snd_BUG_ON(err < 0);
 		runtime->silence_filled += transfer;
 		frames -= transfer;
 		ofs = 0;
@@ -2103,6 +2078,21 @@ static int noninterleaved_copy(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+/* fill silence on the given buffer position;
+ * called from snd_pcm_playback_silence()
+ */
+static int fill_silence_frames(struct snd_pcm_substream *substream,
+			       snd_pcm_uframes_t off, snd_pcm_uframes_t frames)
+{
+	if (substream->runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||
+	    substream->runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED)
+		return interleaved_copy(substream, off, NULL, 0, frames,
+					fill_silence);
+	else
+		return noninterleaved_copy(substream, off, NULL, 0, frames,
+					   fill_silence);
+}
+
 /* sanity-check for read/write methods */
 static int pcm_sanity_check(struct snd_pcm_substream *substream)
 {

commit 5c7264cfbb209efea04bbbd69b8b4f5f2fc5f86d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 22:36:23 2017 +0200

    ALSA: pcm: Unify read/write loop
    
    Both __snd_pcm_lib_read() and __snd_pcm_write() functions have almost
    the same code to loop over samples.  For simplification, this patch
    unifies both as the single helper, __snd_pcm_lib_xfer().
    
    Other than that, there should be no functional change by this patch.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 0c53a34201c1..af73c629a6b2 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2008,13 +2008,13 @@ static void *get_dma_ptr(struct snd_pcm_runtime *runtime,
 		channel * (runtime->dma_bytes / runtime->channels);
 }
 
-/* default copy_user ops for write */
-static int default_write_copy_user(struct snd_pcm_substream *substream,
-				   int channel, unsigned long hwoff,
-				   void __user *buf, unsigned long bytes)
+/* default copy_user ops for write; used for both interleaved and non- modes */
+static int default_write_copy(struct snd_pcm_substream *substream,
+			      int channel, unsigned long hwoff,
+			      void *buf, unsigned long bytes)
 {
 	if (copy_from_user(get_dma_ptr(substream->runtime, channel, hwoff),
-			   buf, bytes))
+			   (void __user *)buf, bytes))
 		return -EFAULT;
 	return 0;
 }
@@ -2040,6 +2040,18 @@ static int fill_silence(struct snd_pcm_substream *substream, int channel,
 	return 0;
 }
 
+/* default copy_user ops for read; used for both interleaved and non- modes */
+static int default_read_copy(struct snd_pcm_substream *substream,
+			     int channel, unsigned long hwoff,
+			     void *buf, unsigned long bytes)
+{
+	if (copy_to_user((void __user *)buf,
+			 get_dma_ptr(substream->runtime, channel, hwoff),
+			 bytes))
+		return -EFAULT;
+	return 0;
+}
+
 /* call transfer function with the converted pointers and sizes;
  * for interleaved mode, it's one shot for all samples
  */
@@ -2121,9 +2133,10 @@ static int pcm_accessible_state(struct snd_pcm_runtime *runtime)
 	}
 }
 
-snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
-				      void *data, bool interleaved,
-				      snd_pcm_uframes_t size)
+/* the common loop for read/write data */
+snd_pcm_sframes_t __snd_pcm_lib_xfer(struct snd_pcm_substream *substream,
+				     void *data, bool interleaved,
+				     snd_pcm_uframes_t size)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t xfer = 0;
@@ -2132,12 +2145,14 @@ snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
 	pcm_copy_f writer;
 	pcm_transfer_f transfer;
 	bool nonblock;
+	bool is_playback;
 	int err;
 
 	err = pcm_sanity_check(substream);
 	if (err < 0)
 		return err;
 
+	is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 	if (interleaved) {
 		if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
 		    runtime->channels > 1)
@@ -2150,12 +2165,16 @@ snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
 	}
 
 	if (!data) {
-		transfer = fill_silence;
+		if (is_playback)
+			transfer = fill_silence;
+		else
+			return -EINVAL;
 	} else {
 		if (substream->ops->copy_user)
 			transfer = (pcm_transfer_f)substream->ops->copy_user;
 		else
-			transfer = default_write_copy_user;
+			transfer = is_playback ?
+				default_write_copy : default_read_copy;
 	}
 
 	if (size == 0)
@@ -2168,129 +2187,8 @@ snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
 	if (err < 0)
 		goto _end_unlock;
 
-	runtime->twake = runtime->control->avail_min ? : 1;
-	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
-		snd_pcm_update_hw_ptr(substream);
-	avail = snd_pcm_playback_avail(runtime);
-	while (size > 0) {
-		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
-		snd_pcm_uframes_t cont;
-		if (!avail) {
-			if (nonblock) {
-				err = -EAGAIN;
-				goto _end_unlock;
-			}
-			runtime->twake = min_t(snd_pcm_uframes_t, size,
-					runtime->control->avail_min ? : 1);
-			err = wait_for_avail(substream, &avail);
-			if (err < 0)
-				goto _end_unlock;
-		}
-		frames = size > avail ? avail : size;
-		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
-		if (frames > cont)
-			frames = cont;
-		if (snd_BUG_ON(!frames)) {
-			runtime->twake = 0;
-			snd_pcm_stream_unlock_irq(substream);
-			return -EINVAL;
-		}
-		appl_ptr = runtime->control->appl_ptr;
-		appl_ofs = appl_ptr % runtime->buffer_size;
-		snd_pcm_stream_unlock_irq(substream);
-		err = writer(substream, appl_ofs, data, offset, frames,
-			     transfer);
-		snd_pcm_stream_lock_irq(substream);
-		if (err < 0)
-			goto _end_unlock;
-		err = pcm_accessible_state(runtime);
-		if (err < 0)
-			goto _end_unlock;
-		appl_ptr += frames;
-		if (appl_ptr >= runtime->boundary)
-			appl_ptr -= runtime->boundary;
-		runtime->control->appl_ptr = appl_ptr;
-		if (substream->ops->ack)
-			substream->ops->ack(substream);
-
-		offset += frames;
-		size -= frames;
-		xfer += frames;
-		avail -= frames;
-		if (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
-		    snd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {
-			err = snd_pcm_start(substream);
-			if (err < 0)
-				goto _end_unlock;
-		}
-	}
- _end_unlock:
-	runtime->twake = 0;
-	if (xfer > 0 && err >= 0)
-		snd_pcm_update_state(substream, runtime);
-	snd_pcm_stream_unlock_irq(substream);
-	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
-}
-EXPORT_SYMBOL(__snd_pcm_lib_write);
-
-/* default copy_user ops for read */
-static int default_read_copy_user(struct snd_pcm_substream *substream,
-				  int channel, unsigned long hwoff,
-				  void *buf, unsigned long bytes)
-{
-	if (copy_to_user((void __user *)buf,
-			 get_dma_ptr(substream->runtime, channel, hwoff),
-			 bytes))
-		return -EFAULT;
-	return 0;
-}
-
-snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
-				     void *data, bool interleaved,
-				     snd_pcm_uframes_t size)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	snd_pcm_uframes_t xfer = 0;
-	snd_pcm_uframes_t offset = 0;
-	snd_pcm_uframes_t avail;
-	pcm_copy_f reader;
-	pcm_transfer_f transfer;
-	bool nonblock;
-	int err;
-
-	err = pcm_sanity_check(substream);
-	if (err < 0)
-		return err;
-
-	if (!data)
-		return -EINVAL;
-
-	if (interleaved) {
-		if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
-		    runtime->channels > 1)
-			return -EINVAL;
-		reader = interleaved_copy;
-	} else {
-		if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
-			return -EINVAL;
-		reader = noninterleaved_copy;
-	}
-
-	if (substream->ops->copy_user)
-		transfer = (pcm_transfer_f)substream->ops->copy_user;
-	else
-		transfer = default_read_copy_user;
-
-	if (size == 0)
-		return 0;
-
-	nonblock = !!(substream->f_flags & O_NONBLOCK);
-
-	snd_pcm_stream_lock_irq(substream);
-	err = pcm_accessible_state(runtime);
-	if (err < 0)
-		goto _end_unlock;
-	if (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
+	if (!is_playback &&
+	    runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
 	    size >= runtime->start_threshold) {
 		err = snd_pcm_start(substream);
 		if (err < 0)
@@ -2300,13 +2198,16 @@ snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
 	runtime->twake = runtime->control->avail_min ? : 1;
 	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 		snd_pcm_update_hw_ptr(substream);
-	avail = snd_pcm_capture_avail(runtime);
+	if (is_playback)
+		avail = snd_pcm_playback_avail(runtime);
+	else
+		avail = snd_pcm_capture_avail(runtime);
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t cont;
 		if (!avail) {
-			if (runtime->status->state ==
-			    SNDRV_PCM_STATE_DRAINING) {
+			if (!is_playback &&
+			    runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
 				snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
 				goto _end_unlock;
 			}
@@ -2334,7 +2235,7 @@ snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
 		appl_ptr = runtime->control->appl_ptr;
 		appl_ofs = appl_ptr % runtime->buffer_size;
 		snd_pcm_stream_unlock_irq(substream);
-		err = reader(substream, appl_ofs, data, offset, frames,
+		err = writer(substream, appl_ofs, data, offset, frames,
 			     transfer);
 		snd_pcm_stream_lock_irq(substream);
 		if (err < 0)
@@ -2353,6 +2254,13 @@ snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
 		size -= frames;
 		xfer += frames;
 		avail -= frames;
+		if (is_playback &&
+		    runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
+		    snd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {
+			err = snd_pcm_start(substream);
+			if (err < 0)
+				goto _end_unlock;
+		}
 	}
  _end_unlock:
 	runtime->twake = 0;
@@ -2361,7 +2269,7 @@ snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
 	snd_pcm_stream_unlock_irq(substream);
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
-EXPORT_SYMBOL(__snd_pcm_lib_read);
+EXPORT_SYMBOL(__snd_pcm_lib_xfer);
 
 /*
  * standard channel mapping helpers

commit 9f60063094ba72e2767be18289baf5151f1f1c2f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 18:15:26 2017 +0200

    ALSA: pcm: More unification of PCM transfer codes
    
    This patch proceeds more abstraction of PCM read/write loop codes.
    
    For both interleaved and non-interleaved transfers, the same copy or
    silence transfer code (which is defined as pcm_transfer_f) is used
    now.  This became possible since we switched to byte size to copy_*
    and fill_silence ops argument instead of frames.
    
    And, for both read and write, we can use the same copy function (which
    is defined as pcm_copy_f), just depending on whether interleaved or
    non-interleaved mode.
    
    The transfer function is determined at the beginning of the loop,
    depending on whether the driver gives the specific copy ops or it's
    the standard read/write.
    
    Another bonus by this change is that we now guarantee the silencing
    behavior when NULL buffer is passed to write helpers.  It'll simplify
    some codes later.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ae030c5eb7c6..0c53a34201c1 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1993,77 +1993,100 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 	return err;
 }
 	
-typedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwoff,
-			  void  *data, unsigned int off,
-			  snd_pcm_uframes_t size);
+typedef int (*pcm_transfer_f)(struct snd_pcm_substream *substream,
+			      int channel, unsigned long hwoff,
+			      void *buf, unsigned long bytes);
 
-static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
-				      unsigned int hwoff,
-				      void *data, unsigned int off,
-				      snd_pcm_uframes_t frames)
+typedef int (*pcm_copy_f)(struct snd_pcm_substream *, snd_pcm_uframes_t, void *,
+			  snd_pcm_uframes_t, snd_pcm_uframes_t, pcm_transfer_f);
+
+/* calculate the target DMA-buffer position to be written/read */
+static void *get_dma_ptr(struct snd_pcm_runtime *runtime,
+			   int channel, unsigned long hwoff)
+{
+	return runtime->dma_area + hwoff +
+		channel * (runtime->dma_bytes / runtime->channels);
+}
+
+/* default copy_user ops for write */
+static int default_write_copy_user(struct snd_pcm_substream *substream,
+				   int channel, unsigned long hwoff,
+				   void __user *buf, unsigned long bytes)
+{
+	if (copy_from_user(get_dma_ptr(substream->runtime, channel, hwoff),
+			   buf, bytes))
+		return -EFAULT;
+	return 0;
+}
+
+/* fill silence instead of copy data; called as a transfer helper
+ * from __snd_pcm_lib_write() or directly from noninterleaved_copy() when
+ * a NULL buffer is passed
+ */
+static int fill_silence(struct snd_pcm_substream *substream, int channel,
+			unsigned long hwoff, void *buf, unsigned long bytes)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	int err;
-	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
-	if (substream->ops->copy_user) {
-		hwoff = frames_to_bytes(runtime, hwoff);
-		frames = frames_to_bytes(runtime, frames);
-		err = substream->ops->copy_user(substream, 0, hwoff, buf, frames);
-		if (err < 0)
-			return err;
-	} else {
-		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
-		if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))
-			return -EFAULT;
-	}
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return 0;
+	if (substream->ops->fill_silence)
+		return substream->ops->fill_silence(substream, channel,
+						    hwoff, bytes);
+
+	snd_pcm_format_set_silence(runtime->format,
+				   get_dma_ptr(runtime, channel, hwoff),
+				   bytes_to_samples(runtime, bytes));
 	return 0;
 }
- 
-static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
-				       unsigned int hwoff,
-				       void *data, unsigned int off,
-				       snd_pcm_uframes_t frames)
+
+/* call transfer function with the converted pointers and sizes;
+ * for interleaved mode, it's one shot for all samples
+ */
+static int interleaved_copy(struct snd_pcm_substream *substream,
+			    snd_pcm_uframes_t hwoff, void *data,
+			    snd_pcm_uframes_t off,
+			    snd_pcm_uframes_t frames,
+			    pcm_transfer_f transfer)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	/* convert to bytes */
+	hwoff = frames_to_bytes(runtime, hwoff);
+	off = frames_to_bytes(runtime, off);
+	frames = frames_to_bytes(runtime, frames);
+	return transfer(substream, 0, hwoff, data + off, frames);
+}
+
+/* call transfer function with the converted pointers and sizes for each
+ * non-interleaved channel; when buffer is NULL, silencing instead of copying
+ */
+static int noninterleaved_copy(struct snd_pcm_substream *substream,
+			       snd_pcm_uframes_t hwoff, void *data,
+			       snd_pcm_uframes_t off,
+			       snd_pcm_uframes_t frames,
+			       pcm_transfer_f transfer)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	int err;
-	void __user **bufs = (void __user **)data;
 	int channels = runtime->channels;
-	char __user *buf;
-	int c;
-
-	if (substream->ops->copy_user) {
-		hwoff = samples_to_bytes(runtime, hwoff);
-		off = samples_to_bytes(runtime, off);
-		frames = samples_to_bytes(runtime, frames);
-		for (c = 0; c < channels; ++c, ++bufs) {
-			buf = *bufs + off;
-			if (!*bufs) {
-				if (snd_BUG_ON(!substream->ops->fill_silence))
-					return -EINVAL;
-				err = substream->ops->fill_silence(substream, c,
-								   hwoff,
-								   frames);
-			} else {
-				err = substream->ops->copy_user(substream, c,
-								hwoff, buf,
-								frames);
-			}
-			if (err < 0)
-				return err;
-		}
-	} else {
-		/* default transfer behaviour */
-		size_t dma_csize = runtime->dma_bytes / channels;
-		for (c = 0; c < channels; ++c, ++bufs) {
-			char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
-			if (*bufs == NULL) {
-				snd_pcm_format_set_silence(runtime->format, hwbuf, frames);
-			} else {
-				char __user *buf = *bufs + samples_to_bytes(runtime, off);
-				if (copy_from_user(hwbuf, buf, samples_to_bytes(runtime, frames)))
-					return -EFAULT;
-			}
-		}
+	void **bufs = data;
+	int c, err;
+
+	/* convert to bytes; note that it's not frames_to_bytes() here.
+	 * in non-interleaved mode, we copy for each channel, thus
+	 * each copy is n_samples bytes x channels = whole frames.
+	 */
+	off = samples_to_bytes(runtime, off);
+	frames = samples_to_bytes(runtime, frames);
+	hwoff = samples_to_bytes(runtime, hwoff);
+	for (c = 0; c < channels; ++c, ++bufs) {
+		if (!data || !*bufs)
+			err = fill_silence(substream, c, hwoff, NULL, frames);
+		else
+			err = transfer(substream, c, hwoff, *bufs + off,
+				       frames);
+		if (err < 0)
+			return err;
 	}
 	return 0;
 }
@@ -2106,24 +2129,33 @@ snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
 	snd_pcm_uframes_t avail;
-	transfer_f transfer;
+	pcm_copy_f writer;
+	pcm_transfer_f transfer;
 	bool nonblock;
 	int err;
 
 	err = pcm_sanity_check(substream);
 	if (err < 0)
 		return err;
-	runtime = substream->runtime;
 
 	if (interleaved) {
 		if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
 		    runtime->channels > 1)
 			return -EINVAL;
-		transfer = snd_pcm_lib_write_transfer;
+		writer = interleaved_copy;
 	} else {
 		if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
 			return -EINVAL;
-		transfer = snd_pcm_lib_writev_transfer;
+		writer = noninterleaved_copy;
+	}
+
+	if (!data) {
+		transfer = fill_silence;
+	} else {
+		if (substream->ops->copy_user)
+			transfer = (pcm_transfer_f)substream->ops->copy_user;
+		else
+			transfer = default_write_copy_user;
 	}
 
 	if (size == 0)
@@ -2166,7 +2198,8 @@ snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
 		appl_ptr = runtime->control->appl_ptr;
 		appl_ofs = appl_ptr % runtime->buffer_size;
 		snd_pcm_stream_unlock_irq(substream);
-		err = transfer(substream, appl_ofs, data, offset, frames);
+		err = writer(substream, appl_ofs, data, offset, frames,
+			     transfer);
 		snd_pcm_stream_lock_irq(substream);
 		if (err < 0)
 			goto _end_unlock;
@@ -2200,65 +2233,15 @@ snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
 }
 EXPORT_SYMBOL(__snd_pcm_lib_write);
 
-static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, 
-				     unsigned int hwoff,
-				     void *data, unsigned int off,
-				     snd_pcm_uframes_t frames)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int err;
-	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
-	if (substream->ops->copy_user) {
-		hwoff = frames_to_bytes(runtime, hwoff);
-		frames = frames_to_bytes(runtime, frames);
-		err = substream->ops->copy_user(substream, 0, hwoff, buf, frames);
-		if (err < 0)
-			return err;
-	} else {
-		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
-		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))
-			return -EFAULT;
-	}
-	return 0;
-}
-
-static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
-				      unsigned int hwoff,
-				      void *data, unsigned int off,
-				      snd_pcm_uframes_t frames)
+/* default copy_user ops for read */
+static int default_read_copy_user(struct snd_pcm_substream *substream,
+				  int channel, unsigned long hwoff,
+				  void *buf, unsigned long bytes)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int err;
-	void __user **bufs = (void __user **)data;
-	int channels = runtime->channels;
-	char __user *buf;
-	char *hwbuf;
-	int c;
-
-	if (substream->ops->copy_user) {
-		hwoff = samples_to_bytes(runtime, hwoff);
-		off = samples_to_bytes(runtime, off);
-		frames = samples_to_bytes(runtime, frames);
-		for (c = 0; c < channels; ++c, ++bufs) {
-			if (!*bufs)
-				continue;
-			err = substream->ops->copy_user(substream, c, hwoff,
-							*bufs + off, frames);
-			if (err < 0)
-				return err;
-		}
-	} else {
-		snd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;
-		for (c = 0; c < channels; ++c, ++bufs) {
-			if (*bufs == NULL)
-				continue;
-
-			hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
-			buf = *bufs + samples_to_bytes(runtime, off);
-			if (copy_to_user(buf, hwbuf, samples_to_bytes(runtime, frames)))
-				return -EFAULT;
-		}
-	}
+	if (copy_to_user((void __user *)buf,
+			 get_dma_ptr(substream->runtime, channel, hwoff),
+			 bytes))
+		return -EFAULT;
 	return 0;
 }
 
@@ -2270,26 +2253,34 @@ snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
 	snd_pcm_uframes_t avail;
-	transfer_f transfer;
+	pcm_copy_f reader;
+	pcm_transfer_f transfer;
 	bool nonblock;
 	int err;
 
 	err = pcm_sanity_check(substream);
 	if (err < 0)
 		return err;
-	runtime = substream->runtime;
+
+	if (!data)
+		return -EINVAL;
 
 	if (interleaved) {
 		if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
 		    runtime->channels > 1)
 			return -EINVAL;
-		transfer = snd_pcm_lib_read_transfer;
+		reader = interleaved_copy;
 	} else {
 		if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
 			return -EINVAL;
-		transfer = snd_pcm_lib_readv_transfer;
+		reader = noninterleaved_copy;
 	}
 
+	if (substream->ops->copy_user)
+		transfer = (pcm_transfer_f)substream->ops->copy_user;
+	else
+		transfer = default_read_copy_user;
+
 	if (size == 0)
 		return 0;
 
@@ -2343,7 +2334,8 @@ snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
 		appl_ptr = runtime->control->appl_ptr;
 		appl_ofs = appl_ptr % runtime->buffer_size;
 		snd_pcm_stream_unlock_irq(substream);
-		err = transfer(substream, appl_ofs, data, offset, frames);
+		err = reader(substream, appl_ofs, data, offset, frames,
+			     transfer);
 		snd_pcm_stream_lock_irq(substream);
 		if (err < 0)
 			goto _end_unlock;

commit c48f12ee0acbd431d6c3ed249f79a6d68b757058
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 21 09:35:21 2017 +0200

    ALSA: pcm: Call directly the common read/write helpers
    
    Make snd_pcm_lib_read() and *_write() static inline functions that
    call the common helper functions directly.  This reduces a slight
    amount of codes, and at the same time, it's a preparation for the
    further cleanups / fixes.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 51eeea9088de..ae030c5eb7c6 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1994,12 +1994,12 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 }
 	
 typedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwoff,
-			  unsigned long data, unsigned int off,
+			  void  *data, unsigned int off,
 			  snd_pcm_uframes_t size);
 
 static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 				      unsigned int hwoff,
-				      unsigned long data, unsigned int off,
+				      void *data, unsigned int off,
 				      snd_pcm_uframes_t frames)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -2021,7 +2021,7 @@ static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
  
 static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
 				       unsigned int hwoff,
-				       unsigned long data, unsigned int off,
+				       void *data, unsigned int off,
 				       snd_pcm_uframes_t frames)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -2098,21 +2098,39 @@ static int pcm_accessible_state(struct snd_pcm_runtime *runtime)
 	}
 }
 
-static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream, 
-					    unsigned long data,
-					    snd_pcm_uframes_t size,
-					    int nonblock,
-					    transfer_f transfer)
+snd_pcm_sframes_t __snd_pcm_lib_write(struct snd_pcm_substream *substream,
+				      void *data, bool interleaved,
+				      snd_pcm_uframes_t size)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
 	snd_pcm_uframes_t avail;
-	int err = 0;
+	transfer_f transfer;
+	bool nonblock;
+	int err;
+
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
+	runtime = substream->runtime;
+
+	if (interleaved) {
+		if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
+		    runtime->channels > 1)
+			return -EINVAL;
+		transfer = snd_pcm_lib_write_transfer;
+	} else {
+		if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
+			return -EINVAL;
+		transfer = snd_pcm_lib_writev_transfer;
+	}
 
 	if (size == 0)
 		return 0;
 
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
+
 	snd_pcm_stream_lock_irq(substream);
 	err = pcm_accessible_state(runtime);
 	if (err < 0)
@@ -2180,53 +2198,11 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 	snd_pcm_stream_unlock_irq(substream);
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
-
-snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)
-{
-	struct snd_pcm_runtime *runtime;
-	int nonblock;
-	int err;
-
-	err = pcm_sanity_check(substream);
-	if (err < 0)
-		return err;
-	runtime = substream->runtime;
-	nonblock = !!(substream->f_flags & O_NONBLOCK);
-
-	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
-	    runtime->channels > 1)
-		return -EINVAL;
-	return snd_pcm_lib_write1(substream, (unsigned long)buf, size, nonblock,
-				  snd_pcm_lib_write_transfer);
-}
-
-EXPORT_SYMBOL(snd_pcm_lib_write);
-
-snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
-				     void __user **bufs,
-				     snd_pcm_uframes_t frames)
-{
-	struct snd_pcm_runtime *runtime;
-	int nonblock;
-	int err;
-
-	err = pcm_sanity_check(substream);
-	if (err < 0)
-		return err;
-	runtime = substream->runtime;
-	nonblock = !!(substream->f_flags & O_NONBLOCK);
-
-	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
-		return -EINVAL;
-	return snd_pcm_lib_write1(substream, (unsigned long)bufs, frames,
-				  nonblock, snd_pcm_lib_writev_transfer);
-}
-
-EXPORT_SYMBOL(snd_pcm_lib_writev);
+EXPORT_SYMBOL(__snd_pcm_lib_write);
 
 static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, 
 				     unsigned int hwoff,
-				     unsigned long data, unsigned int off,
+				     void *data, unsigned int off,
 				     snd_pcm_uframes_t frames)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -2248,7 +2224,7 @@ static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream,
 
 static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
 				      unsigned int hwoff,
-				      unsigned long data, unsigned int off,
+				      void *data, unsigned int off,
 				      snd_pcm_uframes_t frames)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -2286,21 +2262,39 @@ static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
-					   unsigned long data,
-					   snd_pcm_uframes_t size,
-					   int nonblock,
-					   transfer_f transfer)
+snd_pcm_sframes_t __snd_pcm_lib_read(struct snd_pcm_substream *substream,
+				     void *data, bool interleaved,
+				     snd_pcm_uframes_t size)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
 	snd_pcm_uframes_t avail;
-	int err = 0;
+	transfer_f transfer;
+	bool nonblock;
+	int err;
+
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
+	runtime = substream->runtime;
+
+	if (interleaved) {
+		if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
+		    runtime->channels > 1)
+			return -EINVAL;
+		transfer = snd_pcm_lib_read_transfer;
+	} else {
+		if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
+			return -EINVAL;
+		transfer = snd_pcm_lib_readv_transfer;
+	}
 
 	if (size == 0)
 		return 0;
 
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
+
 	snd_pcm_stream_lock_irq(substream);
 	err = pcm_accessible_state(runtime);
 	if (err < 0)
@@ -2375,47 +2369,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 	snd_pcm_stream_unlock_irq(substream);
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
-
-snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __user *buf, snd_pcm_uframes_t size)
-{
-	struct snd_pcm_runtime *runtime;
-	int nonblock;
-	int err;
-	
-	err = pcm_sanity_check(substream);
-	if (err < 0)
-		return err;
-	runtime = substream->runtime;
-	nonblock = !!(substream->f_flags & O_NONBLOCK);
-	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)
-		return -EINVAL;
-	return snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);
-}
-
-EXPORT_SYMBOL(snd_pcm_lib_read);
-
-snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
-				    void __user **bufs,
-				    snd_pcm_uframes_t frames)
-{
-	struct snd_pcm_runtime *runtime;
-	int nonblock;
-	int err;
-
-	err = pcm_sanity_check(substream);
-	if (err < 0)
-		return err;
-	runtime = substream->runtime;
-	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
-		return -EBADFD;
-
-	nonblock = !!(substream->f_flags & O_NONBLOCK);
-	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
-		return -EINVAL;
-	return snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);
-}
-
-EXPORT_SYMBOL(snd_pcm_lib_readv);
+EXPORT_SYMBOL(__snd_pcm_lib_read);
 
 /*
  * standard channel mapping helpers

commit bdc4acf7f6eb14a64c549c04c741b18e3afb350e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 17:59:17 2017 +0200

    ALSA: pcm: Shuffle codes
    
    Just shuffle the codes, without any change otherwise.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 5fcd798672b4..51eeea9088de 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1993,6 +1993,10 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 	return err;
 }
 	
+typedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwoff,
+			  unsigned long data, unsigned int off,
+			  snd_pcm_uframes_t size);
+
 static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 				      unsigned int hwoff,
 				      unsigned long data, unsigned int off,
@@ -2015,9 +2019,68 @@ static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 	return 0;
 }
  
-typedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwoff,
-			  unsigned long data, unsigned int off,
-			  snd_pcm_uframes_t size);
+static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
+				       unsigned int hwoff,
+				       unsigned long data, unsigned int off,
+				       snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	void __user **bufs = (void __user **)data;
+	int channels = runtime->channels;
+	char __user *buf;
+	int c;
+
+	if (substream->ops->copy_user) {
+		hwoff = samples_to_bytes(runtime, hwoff);
+		off = samples_to_bytes(runtime, off);
+		frames = samples_to_bytes(runtime, frames);
+		for (c = 0; c < channels; ++c, ++bufs) {
+			buf = *bufs + off;
+			if (!*bufs) {
+				if (snd_BUG_ON(!substream->ops->fill_silence))
+					return -EINVAL;
+				err = substream->ops->fill_silence(substream, c,
+								   hwoff,
+								   frames);
+			} else {
+				err = substream->ops->copy_user(substream, c,
+								hwoff, buf,
+								frames);
+			}
+			if (err < 0)
+				return err;
+		}
+	} else {
+		/* default transfer behaviour */
+		size_t dma_csize = runtime->dma_bytes / channels;
+		for (c = 0; c < channels; ++c, ++bufs) {
+			char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
+			if (*bufs == NULL) {
+				snd_pcm_format_set_silence(runtime->format, hwbuf, frames);
+			} else {
+				char __user *buf = *bufs + samples_to_bytes(runtime, off);
+				if (copy_from_user(hwbuf, buf, samples_to_bytes(runtime, frames)))
+					return -EFAULT;
+			}
+		}
+	}
+	return 0;
+}
+
+/* sanity-check for read/write methods */
+static int pcm_sanity_check(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime;
+	if (PCM_RUNTIME_CHECK(substream))
+		return -ENXIO;
+	runtime = substream->runtime;
+	if (snd_BUG_ON(!substream->ops->copy_user && !runtime->dma_area))
+		return -EINVAL;
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+		return -EBADFD;
+	return 0;
+}
 
 static int pcm_accessible_state(struct snd_pcm_runtime *runtime)
 {
@@ -2118,20 +2181,6 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
 
-/* sanity-check for read/write methods */
-static int pcm_sanity_check(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime;
-	if (PCM_RUNTIME_CHECK(substream))
-		return -ENXIO;
-	runtime = substream->runtime;
-	if (snd_BUG_ON(!substream->ops->copy_user && !runtime->dma_area))
-		return -EINVAL;
-	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
-		return -EBADFD;
-	return 0;
-}
-
 snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)
 {
 	struct snd_pcm_runtime *runtime;
@@ -2153,55 +2202,6 @@ snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const v
 
 EXPORT_SYMBOL(snd_pcm_lib_write);
 
-static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
-				       unsigned int hwoff,
-				       unsigned long data, unsigned int off,
-				       snd_pcm_uframes_t frames)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int err;
-	void __user **bufs = (void __user **)data;
-	int channels = runtime->channels;
-	char __user *buf;
-	int c;
-
-	if (substream->ops->copy_user) {
-		hwoff = samples_to_bytes(runtime, hwoff);
-		off = samples_to_bytes(runtime, off);
-		frames = samples_to_bytes(runtime, frames);
-		for (c = 0; c < channels; ++c, ++bufs) {
-			buf = *bufs + off;
-			if (!*bufs) {
-				if (snd_BUG_ON(!substream->ops->fill_silence))
-					return -EINVAL;
-				err = substream->ops->fill_silence(substream, c,
-								   hwoff,
-								   frames);
-			} else {
-				err = substream->ops->copy_user(substream, c,
-								hwoff, buf,
-								frames);
-			}
-			if (err < 0)
-				return err;
-		}
-	} else {
-		/* default transfer behaviour */
-		size_t dma_csize = runtime->dma_bytes / channels;
-		for (c = 0; c < channels; ++c, ++bufs) {
-			char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
-			if (*bufs == NULL) {
-				snd_pcm_format_set_silence(runtime->format, hwbuf, frames);
-			} else {
-				char __user *buf = *bufs + samples_to_bytes(runtime, off);
-				if (copy_from_user(hwbuf, buf, samples_to_bytes(runtime, frames)))
-					return -EFAULT;
-			}
-		}
-	}
-	return 0;
-}
- 
 snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 				     void __user **bufs,
 				     snd_pcm_uframes_t frames)
@@ -2246,6 +2246,46 @@ static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
+				      unsigned int hwoff,
+				      unsigned long data, unsigned int off,
+				      snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	void __user **bufs = (void __user **)data;
+	int channels = runtime->channels;
+	char __user *buf;
+	char *hwbuf;
+	int c;
+
+	if (substream->ops->copy_user) {
+		hwoff = samples_to_bytes(runtime, hwoff);
+		off = samples_to_bytes(runtime, off);
+		frames = samples_to_bytes(runtime, frames);
+		for (c = 0; c < channels; ++c, ++bufs) {
+			if (!*bufs)
+				continue;
+			err = substream->ops->copy_user(substream, c, hwoff,
+							*bufs + off, frames);
+			if (err < 0)
+				return err;
+		}
+	} else {
+		snd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;
+		for (c = 0; c < channels; ++c, ++bufs) {
+			if (*bufs == NULL)
+				continue;
+
+			hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
+			buf = *bufs + samples_to_bytes(runtime, off);
+			if (copy_to_user(buf, hwbuf, samples_to_bytes(runtime, frames)))
+				return -EFAULT;
+		}
+	}
+	return 0;
+}
+
 static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 					   unsigned long data,
 					   snd_pcm_uframes_t size,
@@ -2354,46 +2394,6 @@ snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __u
 
 EXPORT_SYMBOL(snd_pcm_lib_read);
 
-static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
-				      unsigned int hwoff,
-				      unsigned long data, unsigned int off,
-				      snd_pcm_uframes_t frames)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int err;
-	void __user **bufs = (void __user **)data;
-	int channels = runtime->channels;
-	char __user *buf;
-	char *hwbuf;
-	int c;
-
-	if (substream->ops->copy_user) {
-		hwoff = samples_to_bytes(runtime, hwoff);
-		off = samples_to_bytes(runtime, off);
-		frames = samples_to_bytes(runtime, frames);
-		for (c = 0; c < channels; ++c, ++bufs) {
-			if (!*bufs)
-				continue;
-			err = substream->ops->copy_user(substream, c, hwoff,
-							*bufs + off, frames);
-			if (err < 0)
-				return err;
-		}
-	} else {
-		snd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;
-		for (c = 0; c < channels; ++c, ++bufs) {
-			if (*bufs == NULL)
-				continue;
-
-			hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
-			buf = *bufs + samples_to_bytes(runtime, off);
-			if (copy_to_user(buf, hwbuf, samples_to_bytes(runtime, frames)))
-				return -EFAULT;
-		}
-	}
-	return 0;
-}
- 
 snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 				    void __user **bufs,
 				    snd_pcm_uframes_t frames)

commit 6ba63929ae76e5aaafa14021517fab41cfcd5c83
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 17:51:30 2017 +0200

    ALSA: pcm: Check PCM state by a common helper function
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 9c5fe62e2c51..5fcd798672b4 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2019,6 +2019,22 @@ typedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwof
 			  unsigned long data, unsigned int off,
 			  snd_pcm_uframes_t size);
 
+static int pcm_accessible_state(struct snd_pcm_runtime *runtime)
+{
+	switch (runtime->status->state) {
+	case SNDRV_PCM_STATE_PREPARED:
+	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_PAUSED:
+		return 0;
+	case SNDRV_PCM_STATE_XRUN:
+		return -EPIPE;
+	case SNDRV_PCM_STATE_SUSPENDED:
+		return -ESTRPIPE;
+	default:
+		return -EBADFD;
+	}
+}
+
 static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream, 
 					    unsigned long data,
 					    snd_pcm_uframes_t size,
@@ -2035,21 +2051,9 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		return 0;
 
 	snd_pcm_stream_lock_irq(substream);
-	switch (runtime->status->state) {
-	case SNDRV_PCM_STATE_PREPARED:
-	case SNDRV_PCM_STATE_RUNNING:
-	case SNDRV_PCM_STATE_PAUSED:
-		break;
-	case SNDRV_PCM_STATE_XRUN:
-		err = -EPIPE;
-		goto _end_unlock;
-	case SNDRV_PCM_STATE_SUSPENDED:
-		err = -ESTRPIPE;
-		goto _end_unlock;
-	default:
-		err = -EBADFD;
+	err = pcm_accessible_state(runtime);
+	if (err < 0)
 		goto _end_unlock;
-	}
 
 	runtime->twake = runtime->control->avail_min ? : 1;
 	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
@@ -2085,16 +2089,9 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		snd_pcm_stream_lock_irq(substream);
 		if (err < 0)
 			goto _end_unlock;
-		switch (runtime->status->state) {
-		case SNDRV_PCM_STATE_XRUN:
-			err = -EPIPE;
-			goto _end_unlock;
-		case SNDRV_PCM_STATE_SUSPENDED:
-			err = -ESTRPIPE;
+		err = pcm_accessible_state(runtime);
+		if (err < 0)
 			goto _end_unlock;
-		default:
-			break;
-		}
 		appl_ptr += frames;
 		if (appl_ptr >= runtime->boundary)
 			appl_ptr -= runtime->boundary;
@@ -2265,27 +2262,14 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		return 0;
 
 	snd_pcm_stream_lock_irq(substream);
-	switch (runtime->status->state) {
-	case SNDRV_PCM_STATE_PREPARED:
-		if (size >= runtime->start_threshold) {
-			err = snd_pcm_start(substream);
-			if (err < 0)
-				goto _end_unlock;
-		}
-		break;
-	case SNDRV_PCM_STATE_DRAINING:
-	case SNDRV_PCM_STATE_RUNNING:
-	case SNDRV_PCM_STATE_PAUSED:
-		break;
-	case SNDRV_PCM_STATE_XRUN:
-		err = -EPIPE;
-		goto _end_unlock;
-	case SNDRV_PCM_STATE_SUSPENDED:
-		err = -ESTRPIPE;
-		goto _end_unlock;
-	default:
-		err = -EBADFD;
+	err = pcm_accessible_state(runtime);
+	if (err < 0)
 		goto _end_unlock;
+	if (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
+	    size >= runtime->start_threshold) {
+		err = snd_pcm_start(substream);
+		if (err < 0)
+			goto _end_unlock;
 	}
 
 	runtime->twake = runtime->control->avail_min ? : 1;
@@ -2329,16 +2313,9 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		snd_pcm_stream_lock_irq(substream);
 		if (err < 0)
 			goto _end_unlock;
-		switch (runtime->status->state) {
-		case SNDRV_PCM_STATE_XRUN:
-			err = -EPIPE;
-			goto _end_unlock;
-		case SNDRV_PCM_STATE_SUSPENDED:
-			err = -ESTRPIPE;
+		err = pcm_accessible_state(runtime);
+		if (err < 0)
 			goto _end_unlock;
-		default:
-			break;
-		}
 		appl_ptr += frames;
 		if (appl_ptr >= runtime->boundary)
 			appl_ptr -= runtime->boundary;

commit 2ae48354a1a7afbec0c61280e6410a90894a21e7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 22:21:52 2017 +0200

    ALSA: pcm: Drop the old copy and silence ops
    
    Now that all users of old copy and silence ops have been converted to
    the new PCM ops, the old stuff can be retired and go away.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 1fca1ffd235e..9c5fe62e2c51 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -118,9 +118,6 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 								   frames_to_bytes(runtime, ofs),
 								   frames_to_bytes(runtime, transfer));
 				snd_BUG_ON(err < 0);
-			} else if (substream->ops->silence) {
-				err = substream->ops->silence(substream, -1, ofs, transfer);
-				snd_BUG_ON(err < 0);
 			} else {
 				hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);
 				snd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);
@@ -135,11 +132,6 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 									   samples_to_bytes(runtime, transfer));
 					snd_BUG_ON(err < 0);
 				}
-			} else if (substream->ops->silence) {
-				for (c = 0; c < channels; ++c) {
-					err = substream->ops->silence(substream, c, ofs, transfer);
-					snd_BUG_ON(err < 0);
-				}
 			} else {
 				size_t dma_csize = runtime->dma_bytes / channels;
 				for (c = 0; c < channels; ++c) {
@@ -2015,9 +2007,6 @@ static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 		err = substream->ops->copy_user(substream, 0, hwoff, buf, frames);
 		if (err < 0)
 			return err;
-	} else if (substream->ops->copy) {
-		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
-			return err;
 	} else {
 		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
 		if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))
@@ -2139,8 +2128,7 @@ static int pcm_sanity_check(struct snd_pcm_substream *substream)
 	if (PCM_RUNTIME_CHECK(substream))
 		return -ENXIO;
 	runtime = substream->runtime;
-	if (snd_BUG_ON(!substream->ops->copy_user && !substream->ops->copy
-		       && !runtime->dma_area))
+	if (snd_BUG_ON(!substream->ops->copy_user && !runtime->dma_area))
 		return -EINVAL;
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
@@ -2200,19 +2188,6 @@ static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
 			if (err < 0)
 				return err;
 		}
-	} else if (substream->ops->copy) {
-		if (snd_BUG_ON(!substream->ops->silence))
-			return -EINVAL;
-		for (c = 0; c < channels; ++c, ++bufs) {
-			if (*bufs == NULL) {
-				if ((err = substream->ops->silence(substream, c, hwoff, frames)) < 0)
-					return err;
-			} else {
-				buf = *bufs + samples_to_bytes(runtime, off);
-				if ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)
-					return err;
-			}
-		}
 	} else {
 		/* default transfer behaviour */
 		size_t dma_csize = runtime->dma_bytes / channels;
@@ -2266,9 +2241,6 @@ static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream,
 		err = substream->ops->copy_user(substream, 0, hwoff, buf, frames);
 		if (err < 0)
 			return err;
-	} else if (substream->ops->copy) {
-		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
-			return err;
 	} else {
 		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
 		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))
@@ -2430,14 +2402,6 @@ static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
 			if (err < 0)
 				return err;
 		}
-	} else if (substream->ops->copy) {
-		for (c = 0; c < channels; ++c, ++bufs) {
-			if (*bufs == NULL)
-				continue;
-			buf = *bufs + samples_to_bytes(runtime, off);
-			if ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)
-				return err;
-		}
 	} else {
 		snd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;
 		for (c = 0; c < channels; ++c, ++bufs) {

commit 29d1a873de542cbb46d0641037d2601cb76be5b1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 20:02:35 2017 +0200

    ALSA: pcm: Introduce copy_user, copy_kernel and fill_silence ops
    
    For supporting the explicit in-kernel copy of PCM buffer data, and
    also for further code refactoring, three new PCM ops, copy_user,
    copy_kernel and fill_silence, are introduced.  The old copy and
    silence ops will be deprecated and removed later once when all callers
    are converted.
    
    The copy_kernel ops is the new one, and it's supposed to transfer the
    PCM data from the given kernel buffer to the hardware ring-buffer (or
    vice-versa depending on the stream direction), while the copy_user ops
    is equivalent with the former copy ops, to transfer the data from the
    user-space buffer.
    
    The major difference of the new copy_* and fill_silence ops from the
    previous ops is that the new ops take bytes instead of frames for size
    and position arguments.  It has two merits: first, it allows the
    callback implementation often simpler (just call directly memcpy() &
    co), and second, it may unify the implementations of both interleaved
    and non-interleaved cases, as we'll see in the later patch.
    
    As of this stage, copy_kernel ops isn't referred yet, but only
    copy_user is used.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index e50548af4004..1fca1ffd235e 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -57,6 +57,8 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t frames, ofs, transfer;
+	char *hwbuf;
+	int err;
 
 	if (runtime->silence_size < runtime->boundary) {
 		snd_pcm_sframes_t noise_dist, n;
@@ -111,27 +113,37 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 		transfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;
 		if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||
 		    runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
-			if (substream->ops->silence) {
-				int err;
+			if (substream->ops->fill_silence) {
+				err = substream->ops->fill_silence(substream, 0,
+								   frames_to_bytes(runtime, ofs),
+								   frames_to_bytes(runtime, transfer));
+				snd_BUG_ON(err < 0);
+			} else if (substream->ops->silence) {
 				err = substream->ops->silence(substream, -1, ofs, transfer);
 				snd_BUG_ON(err < 0);
 			} else {
-				char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);
+				hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);
 				snd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);
 			}
 		} else {
 			unsigned int c;
 			unsigned int channels = runtime->channels;
-			if (substream->ops->silence) {
+			if (substream->ops->fill_silence) {
+				for (c = 0; c < channels; ++c) {
+					err = substream->ops->fill_silence(substream, c,
+									   samples_to_bytes(runtime, ofs),
+									   samples_to_bytes(runtime, transfer));
+					snd_BUG_ON(err < 0);
+				}
+			} else if (substream->ops->silence) {
 				for (c = 0; c < channels; ++c) {
-					int err;
 					err = substream->ops->silence(substream, c, ofs, transfer);
 					snd_BUG_ON(err < 0);
 				}
 			} else {
 				size_t dma_csize = runtime->dma_bytes / channels;
 				for (c = 0; c < channels; ++c) {
-					char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, ofs);
+					hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, ofs);
 					snd_pcm_format_set_silence(runtime->format, hwbuf, transfer);
 				}
 			}
@@ -1997,7 +2009,13 @@ static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
-	if (substream->ops->copy) {
+	if (substream->ops->copy_user) {
+		hwoff = frames_to_bytes(runtime, hwoff);
+		frames = frames_to_bytes(runtime, frames);
+		err = substream->ops->copy_user(substream, 0, hwoff, buf, frames);
+		if (err < 0)
+			return err;
+	} else if (substream->ops->copy) {
 		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
 			return err;
 	} else {
@@ -2121,7 +2139,8 @@ static int pcm_sanity_check(struct snd_pcm_substream *substream)
 	if (PCM_RUNTIME_CHECK(substream))
 		return -ENXIO;
 	runtime = substream->runtime;
-	if (snd_BUG_ON(!substream->ops->copy && !runtime->dma_area))
+	if (snd_BUG_ON(!substream->ops->copy_user && !substream->ops->copy
+		       && !runtime->dma_area))
 		return -EINVAL;
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
@@ -2158,8 +2177,30 @@ static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
 	int err;
 	void __user **bufs = (void __user **)data;
 	int channels = runtime->channels;
+	char __user *buf;
 	int c;
-	if (substream->ops->copy) {
+
+	if (substream->ops->copy_user) {
+		hwoff = samples_to_bytes(runtime, hwoff);
+		off = samples_to_bytes(runtime, off);
+		frames = samples_to_bytes(runtime, frames);
+		for (c = 0; c < channels; ++c, ++bufs) {
+			buf = *bufs + off;
+			if (!*bufs) {
+				if (snd_BUG_ON(!substream->ops->fill_silence))
+					return -EINVAL;
+				err = substream->ops->fill_silence(substream, c,
+								   hwoff,
+								   frames);
+			} else {
+				err = substream->ops->copy_user(substream, c,
+								hwoff, buf,
+								frames);
+			}
+			if (err < 0)
+				return err;
+		}
+	} else if (substream->ops->copy) {
 		if (snd_BUG_ON(!substream->ops->silence))
 			return -EINVAL;
 		for (c = 0; c < channels; ++c, ++bufs) {
@@ -2167,7 +2208,7 @@ static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
 				if ((err = substream->ops->silence(substream, c, hwoff, frames)) < 0)
 					return err;
 			} else {
-				char __user *buf = *bufs + samples_to_bytes(runtime, off);
+				buf = *bufs + samples_to_bytes(runtime, off);
 				if ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)
 					return err;
 			}
@@ -2219,7 +2260,13 @@ static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
-	if (substream->ops->copy) {
+	if (substream->ops->copy_user) {
+		hwoff = frames_to_bytes(runtime, hwoff);
+		frames = frames_to_bytes(runtime, frames);
+		err = substream->ops->copy_user(substream, 0, hwoff, buf, frames);
+		if (err < 0)
+			return err;
+	} else if (substream->ops->copy) {
 		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
 			return err;
 	} else {
@@ -2367,10 +2414,24 @@ static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
 	int err;
 	void __user **bufs = (void __user **)data;
 	int channels = runtime->channels;
+	char __user *buf;
+	char *hwbuf;
 	int c;
-	if (substream->ops->copy) {
+
+	if (substream->ops->copy_user) {
+		hwoff = samples_to_bytes(runtime, hwoff);
+		off = samples_to_bytes(runtime, off);
+		frames = samples_to_bytes(runtime, frames);
+		for (c = 0; c < channels; ++c, ++bufs) {
+			if (!*bufs)
+				continue;
+			err = substream->ops->copy_user(substream, c, hwoff,
+							*bufs + off, frames);
+			if (err < 0)
+				return err;
+		}
+	} else if (substream->ops->copy) {
 		for (c = 0; c < channels; ++c, ++bufs) {
-			char __user *buf;
 			if (*bufs == NULL)
 				continue;
 			buf = *bufs + samples_to_bytes(runtime, off);
@@ -2380,8 +2441,6 @@ static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
 	} else {
 		snd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;
 		for (c = 0; c < channels; ++c, ++bufs) {
-			char *hwbuf;
-			char __user *buf;
 			if (*bufs == NULL)
 				continue;
 

commit 2c4842d3b6b3cf6db0f21e487da7e9bd3aa23090
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 26 09:30:46 2017 +0900

    ALSA: pcm: add local header file for snd-pcm module
    
    Several files are used to construct PCM core module, a.k.a snd-pcm.
    Although available APIs are described in 'include/sound/pcm.h', some of
    them are not exported as symbols in kernel space. Such APIs are just for
    module local usage.
    
    This commit adds module local header file and move some function prototypes
    into it so that scopes of them are controlled properly and developers
    get no confusion from unavailable symbols.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ab4b1d1e44ee..e50548af4004 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -33,6 +33,8 @@
 #include <sound/pcm_params.h>
 #include <sound/timer.h>
 
+#include "pcm_local.h"
+
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 #define CREATE_TRACE_POINTS
 #include "pcm_trace.h"

commit b46fe5d9607c2a14618c746a02892ead0f0f4637
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 17 08:48:18 2017 +0900

    ALSA: pcm: constify function local and read-only table
    
    In a function snd_pcm_hw_params_choose(), target parameters are arranged
    into a table. Though each entry of this table is read-only, they don't
    have const qualifier.
    
    This commit adds the qualifier.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index af439e5554b6..ab4b1d1e44ee 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1734,7 +1734,7 @@ EXPORT_SYMBOL(snd_pcm_hw_param_last);
 int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,
 			     struct snd_pcm_hw_params *params)
 {
-	static int vars[] = {
+	static const int vars[] = {
 		SNDRV_PCM_HW_PARAM_ACCESS,
 		SNDRV_PCM_HW_PARAM_FORMAT,
 		SNDRV_PCM_HW_PARAM_SUBFORMAT,
@@ -1745,7 +1745,8 @@ int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,
 		SNDRV_PCM_HW_PARAM_TICK_TIME,
 		-1
 	};
-	int err, *v;
+	const int *v;
+	int err;
 
 	for (v = vars; *v != -1; v++) {
 		if (*v != SNDRV_PCM_HW_PARAM_BUFFER_SIZE)

commit b55f9fdcd3f0b3da7c9d4b6c67d75a1878653221
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 17 08:48:20 2017 +0900

    ALSA: pcm: use helper function to refer parameter as read-only
    
    ALSA pcm core has hw_param_interval_c() to pick up parameter with const
    qualifier for safe programming.
    
    This commit applies it to the cases.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 5088d4b8db22..af439e5554b6 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1415,7 +1415,8 @@ static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
 	unsigned int l = (unsigned long) rule->private;
 	int width = l & 0xffff;
 	unsigned int msbits = l >> 16;
-	struct snd_interval *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
+	const struct snd_interval *i =
+		hw_param_interval_c(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
 
 	if (!snd_interval_single(i))
 		return 0;

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index bb1261591a1f..5088d4b8db22 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -21,6 +21,7 @@
  */
 
 #include <linux/slab.h>
+#include <linux/sched/signal.h>
 #include <linux/time.h>
 #include <linux/math64.h>
 #include <linux/export.h>

commit 8d879be882ba5a8bd4c2bc39bd2c336392564e13
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 10 16:07:40 2016 +0200

    ALSA: pcm: Bail out when chmap is already present
    
    When snd_pcm_add_chmap_ctls() is called to the PCM stream to which a
    chmap has been already assigned, it returns as an error due to the
    conflicting snd_ctl_add() result.  However, this also clears the
    already assigned chmap_kctl field via pcm_chmap_ctl_private_free(),
    and becomes inconsistent in the later operation.
    
    This patch adds the check of the conflicting chmap kctl before
    actually trying to allocate / assign.  The check failure is treated as
    a kernel warning, as the double call of snd_pcm_add_chmap_ctls() is
    basically a driver bug and having the stack trace would help
    developers to figure out the bad code path.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 0aca39762ed0..bb1261591a1f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2595,6 +2595,8 @@ int snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,
 	};
 	int err;
 
+	if (WARN_ON(pcm->streams[stream].chmap_kctl))
+		return -EBUSY;
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info)
 		return -ENOMEM;

commit 3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 14 18:02:37 2016 +0200

    ALSA: pcm : Call kill_fasync() in stream lock
    
    Currently kill_fasync() is called outside the stream lock in
    snd_pcm_period_elapsed().  This is potentially racy, since the stream
    may get released even during the irq handler is running.  Although
    snd_pcm_release_substream() calls snd_pcm_drop(), this doesn't
    guarantee that the irq handler finishes, thus the kill_fasync() call
    outside the stream spin lock may be invoked after the substream is
    detached, as recently reported by KASAN.
    
    As a quick workaround, move kill_fasync() call inside the stream
    lock.  The fasync is rarely used interface, so this shouldn't have a
    big impact from the performance POV.
    
    Ideally, we should implement some sync mechanism for the proper finish
    of stream and irq handler.  But this oneliner should suffice for most
    cases, so far.
    
    Reported-by: Baozeng Ding <sploving1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3a9b66c6e09c..0aca39762ed0 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1886,8 +1886,8 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
-	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
 
 EXPORT_SYMBOL(snd_pcm_period_elapsed);

commit 0ab1ace856205d10cbc1924b2d931c01ffd216a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 10 20:56:20 2016 +0100

    ALSA: pcm: Avoid "BUG:" string for warnings again
    
    The commit [d507941beb1e: ALSA: pcm: Correct PCM BUG error message]
    made the warning prefix back to "BUG:" due to its previous wrong
    prefix.  But a kernel message containing "BUG:" seems taken as an Oops
    message wrongly by some brain-dead daemons, and it annoys users in the
    end.  Instead of teaching daemons, change the string again to a more
    reasonable one.
    
    Fixes: 507941beb1e ('ALSA: pcm: Correct PCM BUG error message')
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 6b5a811e01a5..3a9b66c6e09c 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -322,7 +322,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			char name[16];
 			snd_pcm_debug_name(substream, name, sizeof(name));
 			pcm_err(substream->pcm,
-				"BUG: %s, pos = %ld, buffer size = %ld, period size = %ld\n",
+				"invalid position: %s, pos = %ld, buffer size = %ld, period size = %ld\n",
 				name, pos, runtime->buffer_size,
 				runtime->period_size);
 		}

commit e5e113cf0d19392f26c6b63e63ad4680ee4ec5da
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Oct 28 11:37:53 2015 +0100

    ALSA: Constify ratden/ratnum constraints
    
    The ALSA core does not modify the constraints provided by a driver. Most
    constraint helper functions already take a const pointer to the constraint
    description, the exception at the moment being the ratden and ratnum
    constraints. Make those const as well, this allows a driver to declare them
    as const.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 05a3ca93c647..6b5a811e01a5 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -801,7 +801,7 @@ void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
  * negative error code.
  */
 int snd_interval_ratnum(struct snd_interval *i,
-			unsigned int rats_count, struct snd_ratnum *rats,
+			unsigned int rats_count, const struct snd_ratnum *rats,
 			unsigned int *nump, unsigned int *denp)
 {
 	unsigned int best_num, best_den;
@@ -920,7 +920,8 @@ EXPORT_SYMBOL(snd_interval_ratnum);
  * negative error code.
  */
 static int snd_interval_ratden(struct snd_interval *i,
-			       unsigned int rats_count, struct snd_ratden *rats,
+			       unsigned int rats_count,
+			       const struct snd_ratden *rats,
 			       unsigned int *nump, unsigned int *denp)
 {
 	unsigned int best_num, best_diff, best_den;
@@ -1339,7 +1340,7 @@ EXPORT_SYMBOL(snd_pcm_hw_constraint_ranges);
 static int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,
 				   struct snd_pcm_hw_rule *rule)
 {
-	struct snd_pcm_hw_constraint_ratnums *r = rule->private;
+	const struct snd_pcm_hw_constraint_ratnums *r = rule->private;
 	unsigned int num = 0, den = 0;
 	int err;
 	err = snd_interval_ratnum(hw_param_interval(params, rule->var),
@@ -1363,10 +1364,10 @@ static int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,
 int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,
-				  struct snd_pcm_hw_constraint_ratnums *r)
+				  const struct snd_pcm_hw_constraint_ratnums *r)
 {
 	return snd_pcm_hw_rule_add(runtime, cond, var,
-				   snd_pcm_hw_rule_ratnums, r,
+				   snd_pcm_hw_rule_ratnums, (void *)r,
 				   var, -1);
 }
 
@@ -1375,7 +1376,7 @@ EXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);
 static int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,
 				   struct snd_pcm_hw_rule *rule)
 {
-	struct snd_pcm_hw_constraint_ratdens *r = rule->private;
+	const struct snd_pcm_hw_constraint_ratdens *r = rule->private;
 	unsigned int num = 0, den = 0;
 	int err = snd_interval_ratden(hw_param_interval(params, rule->var),
 				  r->nrats, r->rats, &num, &den);
@@ -1398,10 +1399,10 @@ static int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,
 int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,
-				  struct snd_pcm_hw_constraint_ratdens *r)
+				  const struct snd_pcm_hw_constraint_ratdens *r)
 {
 	return snd_pcm_hw_rule_add(runtime, cond, var,
-				   snd_pcm_hw_rule_ratdens, r,
+				   snd_pcm_hw_rule_ratdens, (void *)r,
 				   var, -1);
 }
 

commit 53e597b1d194910bef53ed0632da329fef497904
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Oct 22 13:11:56 2015 +0200

    ALSA: Remove transfer_ack_{begin,end} callbacks from struct snd_pcm_runtime
    
    While there is nothing wrong with the transfer_ack_begin and
    transfer_ack_end callbacks per-se, the last documented user was part of the
    alsa-driver 0.5.12a package, which was released 14 years ago and even
    predates the upstream integration of the ALSA core and has subsequently
    been superseded by newer alsa-driver releases.
    
    This seems to indicate that there is no need for having these callbacks and
    they are just cruft that can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 6dc4277937b8..05a3ca93c647 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1875,9 +1875,6 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 		return;
 	runtime = substream->runtime;
 
-	if (runtime->transfer_ack_begin)
-		runtime->transfer_ack_begin(substream);
-
 	snd_pcm_stream_lock_irqsave(substream, flags);
 	if (!snd_pcm_running(substream) ||
 	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
@@ -1889,8 +1886,6 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 #endif
  _end:
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
-	if (runtime->transfer_ack_end)
-		runtime->transfer_ack_end(substream);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 }
 

commit 90bbaf66ee7b946952f1e82a0069639dea5fd893
Author: Jie Yang <yang.jie@intel.com>
Date:   Fri Oct 16 17:57:46 2015 +0800

    ALSA: timer: add config item to export PCM timer disabling for expert
    
    PCM timer is not always used. For embedded device, we need an interface
    to disable it when it is not needed, to shrink the kernel size and
    memory footprint, here add CONFIG_SND_PCM_TIMER for it.
    
    When both CONFIG_SND_PCM_TIMER and CONFIG_SND_TIMER is unselected,
    about 25KB saving bonus we can get.
    
    Please be noted that when disabled, those stubs who using pcm timer
    (e.g. dmix, dsnoop & co) may work incorrectlly.
    
    Suggested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 7d45645f10ba..6dc4277937b8 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1883,8 +1883,10 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
 		goto _end;
 
+#ifdef CONFIG_SND_PCM_TIMER
 	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
+#endif
  _end:
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	if (runtime->transfer_ack_end)

commit 13a988396cab68e6c6afd33e461a9e52ce23ff63
Author: Koro Chen <koro.chen@mediatek.com>
Date:   Wed May 13 22:39:03 2015 +0800

    ALSA: pcm: Modify double acknowledged interrupts check condition
    
    Currently in snd_pcm_update_hw_ptr0 during interrupt,
    we consider there were double acknowledged interrupts when:
    1. HW reported pointer is smaller than expected, and
    2. Time from last update time (hdelta) is over half a buffer time.
    
    However, when HW reported pointer is only a few bytes smaller than
    expected, and when hdelta is just a little larger than half a buffer time
    (e.g. ping-pong buffer), it wrongly treats this IRQ as double acknowledged.
    
    The condition #2 uses jiffies, but jiffies is not high resolution
    since it is integer. We should consider jiffies inaccuracy.
    
    Signed-off-by: Koro Chen <koro.chen@mediatek.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ac6b33f3779c..7d45645f10ba 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -339,7 +339,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		if (delta > new_hw_ptr) {
 			/* check for double acknowledged interrupts */
 			hdelta = curr_jiffies - runtime->hw_ptr_jiffies;
-			if (hdelta > runtime->hw_ptr_buffer_jiffies/2) {
+			if (hdelta > runtime->hw_ptr_buffer_jiffies/2 + 1) {
 				hw_base += runtime->buffer_size;
 				if (hw_base >= runtime->boundary) {
 					hw_base = 0;

commit 3179f62001880e588e229db3006a59ad87b7792a
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Feb 13 15:14:06 2015 -0600

    ALSA: core: add .get_time_info
    
    Introduce more generic .get_time_info to retrieve
    system timestamp and audio timestamp in single routine.
    Backwards compatibility is preserved with same functionality
    as with .wall_clock method (to be removed in following commits
    to avoid breaking git bisect)
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ffd656012ab8..ac6b33f3779c 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -232,6 +232,49 @@ int snd_pcm_update_state(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static void update_audio_tstamp(struct snd_pcm_substream *substream,
+				struct timespec *curr_tstamp,
+				struct timespec *audio_tstamp)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	u64 audio_frames, audio_nsecs;
+	struct timespec driver_tstamp;
+
+	if (runtime->tstamp_mode != SNDRV_PCM_TSTAMP_ENABLE)
+		return;
+
+	if (!(substream->ops->get_time_info) ||
+		(runtime->audio_tstamp_report.actual_type ==
+			SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {
+
+		/*
+		 * provide audio timestamp derived from pointer position
+		 * add delay only if requested
+		 */
+
+		audio_frames = runtime->hw_ptr_wrap + runtime->status->hw_ptr;
+
+		if (runtime->audio_tstamp_config.report_delay) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				audio_frames -=  runtime->delay;
+			else
+				audio_frames +=  runtime->delay;
+		}
+		audio_nsecs = div_u64(audio_frames * 1000000000LL,
+				runtime->rate);
+		*audio_tstamp = ns_to_timespec(audio_nsecs);
+	}
+	runtime->status->audio_tstamp = *audio_tstamp;
+	runtime->status->tstamp = *curr_tstamp;
+
+	/*
+	 * re-take a driver timestamp to let apps detect if the reference tstamp
+	 * read by low-level hardware was provided with a delay
+	 */
+	snd_pcm_gettime(substream->runtime, (struct timespec *)&driver_tstamp);
+	runtime->driver_tstamp = driver_tstamp;
+}
+
 static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 				  unsigned int in_interrupt)
 {
@@ -256,11 +299,18 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	pos = substream->ops->pointer(substream);
 	curr_jiffies = jiffies;
 	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {
-		snd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);
-
-		if ((runtime->hw.info & SNDRV_PCM_INFO_HAS_WALL_CLOCK) &&
-			(substream->ops->wall_clock))
-			substream->ops->wall_clock(substream, &audio_tstamp);
+		if ((substream->ops->get_time_info) &&
+			(runtime->audio_tstamp_config.type_requested != SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {
+			substream->ops->get_time_info(substream, &curr_tstamp,
+						&audio_tstamp,
+						&runtime->audio_tstamp_config,
+						&runtime->audio_tstamp_report);
+
+			/* re-test in case tstamp type is not supported in hardware and was demoted to DEFAULT */
+			if (runtime->audio_tstamp_report.actual_type == SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)
+				snd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);
+		} else
+			snd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);
 	}
 
 	if (pos == SNDRV_PCM_POS_XRUN) {
@@ -403,8 +453,10 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	}
 
  no_delta_check:
-	if (runtime->status->hw_ptr == new_hw_ptr)
+	if (runtime->status->hw_ptr == new_hw_ptr) {
+		update_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);
 		return 0;
+	}
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    runtime->silence_size > 0)
@@ -426,30 +478,8 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		snd_BUG_ON(crossed_boundary != 1);
 		runtime->hw_ptr_wrap += runtime->boundary;
 	}
-	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {
-		runtime->status->tstamp = curr_tstamp;
 
-		if (!(runtime->hw.info & SNDRV_PCM_INFO_HAS_WALL_CLOCK)) {
-			/*
-			 * no wall clock available, provide audio timestamp
-			 * derived from pointer position+delay
-			 */
-			u64 audio_frames, audio_nsecs;
-
-			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-				audio_frames = runtime->hw_ptr_wrap
-					+ runtime->status->hw_ptr
-					- runtime->delay;
-			else
-				audio_frames = runtime->hw_ptr_wrap
-					+ runtime->status->hw_ptr
-					+ runtime->delay;
-			audio_nsecs = div_u64(audio_frames * 1000000000LL,
-					runtime->rate);
-			audio_tstamp = ns_to_timespec(audio_nsecs);
-		}
-		runtime->status->audio_tstamp = audio_tstamp;
-	}
+	update_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);
 
 	return snd_pcm_update_state(substream, runtime);
 }

commit a3ae255e3729c1bb4507412ea29be804f703d44c
Merge: 3fe9cf390f6d 16ca41c6cc90
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 07:08:35 2015 +0100

    Merge tag 'asoc-v3.20-2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for v3.20
    
    More updates for v3.20:
    
     - Lots of refactoring from Lars-Peter Clausen, moving drivers to more
       data driven initialization and rationalizing a lot of DAPM usage.
     - Much improved handling of CDCLK clocks on Samsung I2S controllers.
     - Lots of driver specific cleanups and feature improvements.
     - CODEC support for TI PCM514x and TLV320AIC3104 devices.
     - Board support for Tegra systems with Realtek RT5677.
    
    Conflicts:
            sound/soc/intel/sst-mfld-platform-pcm.c

commit f66f898e953d56779367a6cbc39cbb4808b208c0
Author: Peter Rosin <peda@axentia.se>
Date:   Wed Jan 28 15:16:06 2015 +0100

    ALSA: pcm: Add snd_interval_ranges() and snd_pcm_hw_constraint_ranges()
    
    Add helper functions to allow drivers to specify several disjoint
    ranges for a variable. In particular, there is a codec (PCM512x) that
    has a hole in its supported range of rates, due to PLL and divider
    restrictions.
    
    This is like snd_pcm_hw_constraint_list(), but for ranges instead of
    points.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ec9e7866177f..446c00bd908b 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1015,6 +1015,60 @@ int snd_interval_list(struct snd_interval *i, unsigned int count,
 
 EXPORT_SYMBOL(snd_interval_list);
 
+/**
+ * snd_interval_ranges - refine the interval value from the list of ranges
+ * @i: the interval value to refine
+ * @count: the number of elements in the list of ranges
+ * @ranges: the ranges list
+ * @mask: the bit-mask to evaluate
+ *
+ * Refines the interval value from the list of ranges.
+ * When mask is non-zero, only the elements corresponding to bit 1 are
+ * evaluated.
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
+ */
+int snd_interval_ranges(struct snd_interval *i, unsigned int count,
+			const struct snd_interval *ranges, unsigned int mask)
+{
+	unsigned int k;
+	struct snd_interval range_union;
+	struct snd_interval range;
+
+	if (!count) {
+		snd_interval_none(i);
+		return -EINVAL;
+	}
+	snd_interval_any(&range_union);
+	range_union.min = UINT_MAX;
+	range_union.max = 0;
+	for (k = 0; k < count; k++) {
+		if (mask && !(mask & (1 << k)))
+			continue;
+		snd_interval_copy(&range, &ranges[k]);
+		if (snd_interval_refine(&range, i) < 0)
+			continue;
+		if (snd_interval_empty(&range))
+			continue;
+
+		if (range.min < range_union.min) {
+			range_union.min = range.min;
+			range_union.openmin = 1;
+		}
+		if (range.min == range_union.min && !range.openmin)
+			range_union.openmin = 0;
+		if (range.max > range_union.max) {
+			range_union.max = range.max;
+			range_union.openmax = 1;
+		}
+		if (range.max == range_union.max && !range.openmax)
+			range_union.openmax = 0;
+	}
+	return snd_interval_refine(i, &range_union);
+}
+EXPORT_SYMBOL(snd_interval_ranges);
+
 static int snd_interval_step(struct snd_interval *i, unsigned int step)
 {
 	unsigned int n;
@@ -1221,6 +1275,37 @@ int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
 
 EXPORT_SYMBOL(snd_pcm_hw_constraint_list);
 
+static int snd_pcm_hw_rule_ranges(struct snd_pcm_hw_params *params,
+				  struct snd_pcm_hw_rule *rule)
+{
+	struct snd_pcm_hw_constraint_ranges *r = rule->private;
+	return snd_interval_ranges(hw_param_interval(params, rule->var),
+				   r->count, r->ranges, r->mask);
+}
+
+
+/**
+ * snd_pcm_hw_constraint_ranges - apply list of range constraints to a parameter
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the list of range constraints
+ * @r: ranges
+ *
+ * Apply the list of range constraints to an interval parameter.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_ranges(struct snd_pcm_runtime *runtime,
+				 unsigned int cond,
+				 snd_pcm_hw_param_t var,
+				 const struct snd_pcm_hw_constraint_ranges *r)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var,
+				   snd_pcm_hw_rule_ranges, (void *)r,
+				   var, -1);
+}
+EXPORT_SYMBOL(snd_pcm_hw_constraint_ranges);
+
 static int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,
 				   struct snd_pcm_hw_rule *rule)
 {

commit 8ef9df55a72425e269575fa74cbbedec4672bdc4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 18:43:37 2014 +0100

    ALSA: Add support for wildcard msbits constraints
    
    Currently the msbits constraints requires to specify a specific sample
    format width for which the constraint should be applied. But often the
    number of most significant bits is not sample format specific, but rather a
    absolute limit. E.g. the PCM interface might accept 32-bit and 24-bit
    samples, but the DAC has a 16-bit resolution and throws away the LSBs. In
    this case for both 32-bit and 24-bit format msbits should be set to 16. This
    patch extends snd_pcm_hw_constraint_msbits() so that a wildcard constraint
    can be setup that is applied for all formats with a sample width larger than
    the specified msbits. Choosing the wildcard constraint is done by setting
    the sample width parameter of the function to 0.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index b0c153534a29..db05e04d0070 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1299,8 +1299,14 @@ static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
 	int width = l & 0xffff;
 	unsigned int msbits = l >> 16;
 	struct snd_interval *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
-	if (snd_interval_single(i) && snd_interval_value(i) == width)
+
+	if (!snd_interval_single(i))
+		return 0;
+
+	if ((snd_interval_value(i) == width) ||
+	    (width == 0 && snd_interval_value(i) > msbits))
 		params->msbits = min_not_zero(params->msbits, msbits);
+
 	return 0;
 }
 
@@ -1311,6 +1317,11 @@ static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
  * @width: sample bits width
  * @msbits: msbits width
  *
+ * This constraint will set the number of most significant bits (msbits) if a
+ * sample format with the specified width has been select. If width is set to 0
+ * the msbits will be set for any sample format with a width larger than the
+ * specified msbits.
+ *
  * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, 

commit 19f52fae5adb7f2fd5b75251f9bd761f43a36476
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 29 18:43:36 2014 +0100

    ALSA: Fix handling of multiple msbits constraints on the same runtime
    
    If the sound card is made up of discrete components, each with their own
    driver (e.g. like in the ASoC case), we might end up with multiple msbits
    constraint rules installed. Currently this will result in msbits being set
    to whatever the last rule set it to.
    
    This patch updates the behavior of the rule to choose the minimum (other
    than zero) of all the installed rules.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ec9e7866177f..b0c153534a29 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1300,7 +1300,7 @@ static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
 	unsigned int msbits = l >> 16;
 	struct snd_interval *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
 	if (snd_interval_single(i) && snd_interval_value(i) == width)
-		params->msbits = msbits;
+		params->msbits = min_not_zero(params->msbits, msbits);
 	return 0;
 }
 

commit f5914908a5b7b2338f210e56827a1ef35585dc6d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 4 12:45:59 2014 +0100

    ALSA: pcm: Replace PCM hwptr tracking with tracepoints
    
    ALSA PCM core has a mechanism tracking the PCM hwptr updates for
    analyzing XRUNs.  But its log is limited (up to 10) and its log output
    is a kernel message, which is hard to handle.
    
    In this patch, the hwptr logging is moved to the tracing
    infrastructure instead of its own.  Not only the hwptr updates but
    also XRUN and hwptr errors are recorded on the trace log, so that user
    can see such events at the exact timing.
    
    The new "snd_pcm" entry will appear in the tracing events:
      # ls -F /sys/kernel/debug/tracing/events/snd_pcm
      enable  filter  hw_ptr_error/  hwptr/  xrun/
    
    The hwptr is for the regular hwptr update events.  An event trace
    looks like:
    
      aplay-26187 [004] d..3  4012.834761: hwptr: pcmC0D0p/sub0: POS: pos=488, old=0, base=0, period=1024, buf=16384
    
    "POS" shows the hwptr update by the explicit position update call and
    "IRQ" means the hwptr update by the interrupt,
    i.e. snd_pcm_period_elapsed() call.  The "pos" is the passed
    ring-buffer offset by the caller, "old" is the previous hwptr, "base"
    is the hwptr base position, "period" and "buf" are period- and
    buffer-size of the target PCM substream.
    (Note that the hwptr position displayed here isn't the ring-buffer
     offset.  It increments up to the PCM position boundary.)
    
    The XRUN event appears similarly, but without "pos" field.
    The hwptr error events appear with the PCM identifier and its reason
    string, such as "Lost interrupt?".
    
    The XRUN and hwptr error reports on kernel message are still left, can
    be turned on/off via xrun_debug proc like before.  But the bit 3, 4, 5
    and 6 bits of xrun_debug proc are dropped by this patch.  Also, along
    with the change, the message strings have been reformatted to be a bit
    more consistent.
    
    Last but not least, the hwptr reporting is enabled only when
    CONFIG_SND_PCM_XRUN_DEBUG is set.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 7b9e2fb35a86..ec9e7866177f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -32,6 +32,15 @@
 #include <sound/pcm_params.h>
 #include <sound/timer.h>
 
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+#define CREATE_TRACE_POINTS
+#include "pcm_trace.h"
+#else
+#define trace_hwptr(substream, pos, in_interrupt)
+#define trace_xrun(substream)
+#define trace_hw_ptr_error(substream, reason)
+#endif
+
 /*
  * fill ring buffer with silence
  * runtime->silence_start: starting pointer to silence area
@@ -146,10 +155,6 @@ EXPORT_SYMBOL(snd_pcm_debug_name);
 #define XRUN_DEBUG_BASIC	(1<<0)
 #define XRUN_DEBUG_STACK	(1<<1)	/* dump also stack */
 #define XRUN_DEBUG_JIFFIESCHECK	(1<<2)	/* do jiffies check */
-#define XRUN_DEBUG_PERIODUPDATE	(1<<3)	/* full period update info */
-#define XRUN_DEBUG_HWPTRUPDATE	(1<<4)	/* full hwptr update info */
-#define XRUN_DEBUG_LOG		(1<<5)	/* show last 10 positions on err */
-#define XRUN_DEBUG_LOGONCE	(1<<6)	/* do above only once */
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 
@@ -168,6 +173,7 @@ static void xrun(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
+	trace_xrun(substream);
 	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
 		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
@@ -180,97 +186,19 @@ static void xrun(struct snd_pcm_substream *substream)
 }
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
-#define hw_ptr_error(substream, fmt, args...)				\
+#define hw_ptr_error(substream, in_interrupt, reason, fmt, args...)	\
 	do {								\
+		trace_hw_ptr_error(substream, reason);	\
 		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
-			xrun_log_show(substream);			\
-			pr_err_ratelimited("ALSA: PCM: " fmt, ##args);	\
+			pr_err_ratelimited("ALSA: PCM: [%c] " reason ": " fmt, \
+					   (in_interrupt) ? 'Q' : 'P', ##args);	\
 			dump_stack_on_xrun(substream);			\
 		}							\
 	} while (0)
 
-#define XRUN_LOG_CNT	10
-
-struct hwptr_log_entry {
-	unsigned int in_interrupt;
-	unsigned long jiffies;
-	snd_pcm_uframes_t pos;
-	snd_pcm_uframes_t period_size;
-	snd_pcm_uframes_t buffer_size;
-	snd_pcm_uframes_t old_hw_ptr;
-	snd_pcm_uframes_t hw_ptr_base;
-};
-
-struct snd_pcm_hwptr_log {
-	unsigned int idx;
-	unsigned int hit: 1;
-	struct hwptr_log_entry entries[XRUN_LOG_CNT];
-};
-
-static void xrun_log(struct snd_pcm_substream *substream,
-		     snd_pcm_uframes_t pos, int in_interrupt)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_pcm_hwptr_log *log = runtime->hwptr_log;
-	struct hwptr_log_entry *entry;
-
-	if (log == NULL) {
-		log = kzalloc(sizeof(*log), GFP_ATOMIC);
-		if (log == NULL)
-			return;
-		runtime->hwptr_log = log;
-	} else {
-		if (xrun_debug(substream, XRUN_DEBUG_LOGONCE) && log->hit)
-			return;
-	}
-	entry = &log->entries[log->idx];
-	entry->in_interrupt = in_interrupt;
-	entry->jiffies = jiffies;
-	entry->pos = pos;
-	entry->period_size = runtime->period_size;
-	entry->buffer_size = runtime->buffer_size;
-	entry->old_hw_ptr = runtime->status->hw_ptr;
-	entry->hw_ptr_base = runtime->hw_ptr_base;
-	log->idx = (log->idx + 1) % XRUN_LOG_CNT;
-}
-
-static void xrun_log_show(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_hwptr_log *log = substream->runtime->hwptr_log;
-	struct hwptr_log_entry *entry;
-	char name[16];
-	unsigned int idx;
-	int cnt;
-
-	if (log == NULL)
-		return;
-	if (xrun_debug(substream, XRUN_DEBUG_LOGONCE) && log->hit)
-		return;
-	snd_pcm_debug_name(substream, name, sizeof(name));
-	for (cnt = 0, idx = log->idx; cnt < XRUN_LOG_CNT; cnt++) {
-		entry = &log->entries[idx];
-		if (entry->period_size == 0)
-			break;
-		pr_info("hwptr log: %s: %sj=%lu, pos=%ld/%ld/%ld, "
-			   "hwptr=%ld/%ld\n",
-			   name, entry->in_interrupt ? "[Q] " : "",
-			   entry->jiffies,
-			   (unsigned long)entry->pos,
-			   (unsigned long)entry->period_size,
-			   (unsigned long)entry->buffer_size,
-			   (unsigned long)entry->old_hw_ptr,
-			   (unsigned long)entry->hw_ptr_base);
-		idx++;
-		idx %= XRUN_LOG_CNT;
-	}
-	log->hit = 1;
-}
-
 #else /* ! CONFIG_SND_PCM_XRUN_DEBUG */
 
 #define hw_ptr_error(substream, fmt, args...) do { } while (0)
-#define xrun_log(substream, pos, in_interrupt)	do { } while (0)
-#define xrun_log_show(substream)	do { } while (0)
 
 #endif
 
@@ -343,7 +271,6 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		if (printk_ratelimit()) {
 			char name[16];
 			snd_pcm_debug_name(substream, name, sizeof(name));
-			xrun_log_show(substream);
 			pcm_err(substream->pcm,
 				"BUG: %s, pos = %ld, buffer size = %ld, period size = %ld\n",
 				name, pos, runtime->buffer_size,
@@ -352,8 +279,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		pos = 0;
 	}
 	pos -= pos % runtime->min_align;
-	if (xrun_debug(substream, XRUN_DEBUG_LOG))
-		xrun_log(substream, pos, in_interrupt);
+	trace_hwptr(substream, pos, in_interrupt);
 	hw_base = runtime->hw_ptr_base;
 	new_hw_ptr = hw_base + pos;
 	if (in_interrupt) {
@@ -388,22 +314,6 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	delta = new_hw_ptr - old_hw_ptr;
 	if (delta < 0)
 		delta += runtime->boundary;
-	if (xrun_debug(substream, in_interrupt ?
-			XRUN_DEBUG_PERIODUPDATE : XRUN_DEBUG_HWPTRUPDATE)) {
-		char name[16];
-		snd_pcm_debug_name(substream, name, sizeof(name));
-		pcm_dbg(substream->pcm,
-			"%s_update: %s: pos=%u/%u/%u, hwptr=%ld/%ld/%ld/%ld\n",
-			   in_interrupt ? "period" : "hwptr",
-			   name,
-			   (unsigned int)pos,
-			   (unsigned int)runtime->period_size,
-			   (unsigned int)runtime->buffer_size,
-			   (unsigned long)delta,
-			   (unsigned long)old_hw_ptr,
-			   (unsigned long)new_hw_ptr,
-			   (unsigned long)runtime->hw_ptr_base);
-	}
 
 	if (runtime->no_period_wakeup) {
 		snd_pcm_sframes_t xrun_threshold;
@@ -431,13 +341,10 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 
 	/* something must be really wrong */
 	if (delta >= runtime->buffer_size + runtime->period_size) {
-		hw_ptr_error(substream,
-			       "Unexpected hw_pointer value %s"
-			       "(stream=%i, pos=%ld, new_hw_ptr=%ld, "
-			       "old_hw_ptr=%ld)\n",
-				     in_interrupt ? "[Q] " : "[P]",
-				     substream->stream, (long)pos,
-				     (long)new_hw_ptr, (long)old_hw_ptr);
+		hw_ptr_error(substream, in_interrupt, "Unexpected hw_ptr",
+			     "(stream=%i, pos=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\n",
+			     substream->stream, (long)pos,
+			     (long)new_hw_ptr, (long)old_hw_ptr);
 		return 0;
 	}
 
@@ -474,11 +381,8 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			delta--;
 		}
 		/* align hw_base to buffer_size */
-		hw_ptr_error(substream,
-			     "hw_ptr skipping! %s"
-			     "(pos=%ld, delta=%ld, period=%ld, "
-			     "jdelta=%lu/%lu/%lu, hw_ptr=%ld/%ld)\n",
-			     in_interrupt ? "[Q] " : "",
+		hw_ptr_error(substream, in_interrupt, "hw_ptr skipping",
+			     "(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu/%lu, hw_ptr=%ld/%ld)\n",
 			     (long)pos, (long)hdelta,
 			     (long)runtime->period_size, jdelta,
 			     ((hdelta * HZ) / runtime->rate), hw_base,
@@ -490,11 +394,9 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	}
  no_jiffies_check:
 	if (delta > runtime->period_size + runtime->period_size / 2) {
-		hw_ptr_error(substream,
-			     "Lost interrupts? %s"
-			     "(stream=%i, delta=%ld, new_hw_ptr=%ld, "
-			     "old_hw_ptr=%ld)\n",
-			     in_interrupt ? "[Q] " : "",
+		hw_ptr_error(substream, in_interrupt,
+			     "Lost interrupts?",
+			     "(stream=%i, delta=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\n",
 			     substream->stream, (long)delta,
 			     (long)new_hw_ptr,
 			     (long)old_hw_ptr);

commit d507941beb1ef98c19e2902007aee4faf36f854f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 4 13:57:15 2014 +0100

    ALSA: pcm: Correct PCM BUG error message
    
    While converting to dev_*(), the message showing the invalid PCM
    position was wrongly tagged as if an XRUN although it's actually a
    BUG.  This patch corrects the message again.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index dfc28542a007..7b9e2fb35a86 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -345,7 +345,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			snd_pcm_debug_name(substream, name, sizeof(name));
 			xrun_log_show(substream);
 			pcm_err(substream->pcm,
-				"XRUN: %s, pos = %ld, buffer size = %ld, period size = %ld\n",
+				"BUG: %s, pos = %ld, buffer size = %ld, period size = %ld\n",
 				name, pos, runtime->buffer_size,
 				runtime->period_size);
 		}

commit 8df22a4d6f5b81c9c1703579d4907b57002689ed
Merge: 0cae90a96c15 a5448c88b812
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 6 14:01:11 2014 +0200

    Merge tag 'asoc-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for v3.18
    
     - More componentisation work from Lars-Peter, this time mainly
       cleaning up the suspend and bias level transition callbacks.
     - Real system support for the Intel drivers and a bunch of fixes and
       enhancements for the associated CODEC drivers, this is going to need
       a lot quirks over time due to the lack of any firmware description of
       the boards.
     - Jack detect support for simple card from Dylan Reid.
     - A bunch of small fixes and enhancements for the Freescale drivers.
     - New drivers for Analog Devices SSM4567, Cirrus Logic CS35L32, Everest
       Semiconductor ES8328 and Freescale cards using the ASRC in newer i.MX
       processors.

commit a9960e6a293e6fc3ed414643bb4e4106272e4d0a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Sep 21 22:50:57 2014 +0200

    ALSA: pcm: fix fifo_size frame calculation
    
    The calculated frame size was wrong because snd_pcm_format_physical_width()
    actually returns the number of bits, not bytes.
    
    Use snd_pcm_format_size() instead, which not only returns bytes, but also
    simplifies the calculation.
    
    Fixes: 8bea869c5e56 ("ALSA: PCM midlevel: improve fifo_size handling")
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 9acc77eae487..0032278567ad 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1782,14 +1782,16 @@ static int snd_pcm_lib_ioctl_fifo_size(struct snd_pcm_substream *substream,
 {
 	struct snd_pcm_hw_params *params = arg;
 	snd_pcm_format_t format;
-	int channels, width;
+	int channels;
+	ssize_t frame_size;
 
 	params->fifo_size = substream->runtime->hw.fifo_size;
 	if (!(substream->runtime->hw.info & SNDRV_PCM_INFO_FIFO_IN_FRAMES)) {
 		format = params_format(params);
 		channels = params_channels(params);
-		width = snd_pcm_format_physical_width(format);
-		params->fifo_size /= width * channels;
+		frame_size = snd_pcm_format_size(format, channels);
+		if (frame_size > 0)
+			params->fifo_size /= (unsigned)frame_size;
 	}
 	return 0;
 }

commit df1e471966479526ae64b64d8851a89db26b30bb
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Sep 7 21:43:41 2014 +0200

    ALSA: pcm: snd_interval_step: fix changes of open intervals
    
    Changing an interval boundary to a multiple of the step size makes that
    boundary exact.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 6fd5e1ce5462..b03c7ae5f4e3 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1120,11 +1120,13 @@ static int snd_interval_step(struct snd_interval *i, unsigned int step)
 	n = i->min % step;
 	if (n != 0 || i->openmin) {
 		i->min += step - n;
+		i->openmin = 0;
 		changed = 1;
 	}
 	n = i->max % step;
 	if (n != 0 || i->openmax) {
 		i->max -= n;
+		i->openmax = 0;
 		changed = 1;
 	}
 	if (snd_interval_checkempty(i)) {

commit 0f519b622151339b7754d0406ddc40940063572a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Sep 7 21:43:07 2014 +0200

    ALSA: pcm: snd_interval_step: drop the min parameter
    
    The min parameter was not used by any caller.  And if it were used,
    underflows in the calculations could lead to incorrect results.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 9acc77eae487..6fd5e1ce5462 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1113,16 +1113,16 @@ int snd_interval_list(struct snd_interval *i, unsigned int count,
 
 EXPORT_SYMBOL(snd_interval_list);
 
-static int snd_interval_step(struct snd_interval *i, unsigned int min, unsigned int step)
+static int snd_interval_step(struct snd_interval *i, unsigned int step)
 {
 	unsigned int n;
 	int changed = 0;
-	n = (i->min - min) % step;
+	n = i->min % step;
 	if (n != 0 || i->openmin) {
 		i->min += step - n;
 		changed = 1;
 	}
-	n = (i->max - min) % step;
+	n = i->max % step;
 	if (n != 0 || i->openmax) {
 		i->max -= n;
 		changed = 1;
@@ -1427,7 +1427,7 @@ static int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,
 				struct snd_pcm_hw_rule *rule)
 {
 	unsigned long step = (unsigned long) rule->private;
-	return snd_interval_step(hw_param_interval(params, rule->var), 0, step);
+	return snd_interval_step(hw_param_interval(params, rule->var), step);
 }
 
 /**

commit 00d90154404ae6218730068d25bf2faad3186631
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Wed Apr 16 08:18:35 2014 -0600

    ALSA: pcm: 'BUG:' message unnecessarily triggers kerneloops
    
    BugLink: http://bugs.launchpad.net/bugs/1305480
    
    The kerneloops-daemon scans dmesg for common crash signatures, among
    which is 'BUG:'. The message emitted by the PCM library is really a
    warning, so the most expedient thing to do seems to be to change the
    string.
    
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ce83def9f43b..9acc77eae487 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -345,7 +345,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			snd_pcm_debug_name(substream, name, sizeof(name));
 			xrun_log_show(substream);
 			pcm_err(substream->pcm,
-				"BUG: %s, pos = %ld, buffer size = %ld, period size = %ld\n",
+				"XRUN: %s, pos = %ld, buffer size = %ld, period size = %ld\n",
 				name, pos, runtime->buffer_size,
 				runtime->period_size);
 		}

commit 5fdb83f190ee2218d113a46b190b70aa1c979325
Merge: 4c16ecc4c071 deeed33850c8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 13 09:53:25 2014 +0100

    Merge tag 'asoc-v3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for v3.15
    
    Quite a busy release for ASoC this time, more on janitorial work than
    exciting new features but welcome nontheless:
    
     - Lots of cleanups from Takashi for enumerations; the original API for
       these was error prone so he's refactored lots of code to use more
       modern APIs which avoid issues.
     - Elimination of the ASoC level wrappers for I2C and SPI moving us
       closer to converting to regmap completely and avoiding some
       randconfig hassle.
     - Provide both manually and transparently locked DAPM APIs rather than
       a mix of the two fixing some concurrency issues.
     - Start converting CODEC drivers to use separate bus interface drivers
       rather than having them all in one file helping avoid dependency
       issues.
     - DPCM support for Intel Haswell and Bay Trail platforms.
     - Lots of work on improvements for simple-card, DaVinci and the Renesas
       rcar drivers.
     - New drivers for Analog Devices ADAU1977, TI PCM512x and parts of the
       CSR SiRF SoC.

commit 63a5d4c6a71fda7ac567627d6ac4a74e9555e97c
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Feb 20 12:13:52 2014 +0900

    ALSA: Export snd_pcm_constraint_mask64()
    
    Allow modules to use it, fixing a build failure when the newly added
    ADAU1977 driver is built as a module.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Acked-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a2104671f51d..5dcf88bed9b7 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1242,6 +1242,7 @@ int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_par
 		return -EINVAL;
 	return 0;
 }
+EXPORT_SYMBOL(snd_pcm_hw_constraint_mask64);
 
 /**
  * snd_pcm_hw_constraint_integer - apply an integer constraint to an interval

commit 09e56df8b37f5e751614a0d140b8bf8250812912
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:19:48 2014 +0100

    ALSA: pcm: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    For simplicity, introduce new helpers for pcm stream, pcm_err(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a2104671f51d..6630a4eb8393 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -174,7 +174,7 @@ static void xrun(struct snd_pcm_substream *substream)
 	if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {
 		char name[16];
 		snd_pcm_debug_name(substream, name, sizeof(name));
-		snd_printd(KERN_DEBUG "XRUN: %s\n", name);
+		pcm_warn(substream->pcm, "XRUN: %s\n", name);
 		dump_stack_on_xrun(substream);
 	}
 }
@@ -184,9 +184,7 @@ static void xrun(struct snd_pcm_substream *substream)
 	do {								\
 		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
 			xrun_log_show(substream);			\
-			if (snd_printd_ratelimit()) {			\
-				snd_printd("PCM: " fmt, ##args);	\
-			}						\
+			pr_err_ratelimited("ALSA: PCM: " fmt, ##args);	\
 			dump_stack_on_xrun(substream);			\
 		}							\
 	} while (0)
@@ -253,7 +251,7 @@ static void xrun_log_show(struct snd_pcm_substream *substream)
 		entry = &log->entries[idx];
 		if (entry->period_size == 0)
 			break;
-		snd_printd("hwptr log: %s: %sj=%lu, pos=%ld/%ld/%ld, "
+		pr_info("hwptr log: %s: %sj=%lu, pos=%ld/%ld/%ld, "
 			   "hwptr=%ld/%ld\n",
 			   name, entry->in_interrupt ? "[Q] " : "",
 			   entry->jiffies,
@@ -342,14 +340,14 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		return -EPIPE;
 	}
 	if (pos >= runtime->buffer_size) {
-		if (snd_printd_ratelimit()) {
+		if (printk_ratelimit()) {
 			char name[16];
 			snd_pcm_debug_name(substream, name, sizeof(name));
 			xrun_log_show(substream);
-			snd_printd(KERN_ERR  "BUG: %s, pos = %ld, "
-				   "buffer size = %ld, period size = %ld\n",
-				   name, pos, runtime->buffer_size,
-				   runtime->period_size);
+			pcm_err(substream->pcm,
+				"BUG: %s, pos = %ld, buffer size = %ld, period size = %ld\n",
+				name, pos, runtime->buffer_size,
+				runtime->period_size);
 		}
 		pos = 0;
 	}
@@ -394,8 +392,8 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			XRUN_DEBUG_PERIODUPDATE : XRUN_DEBUG_HWPTRUPDATE)) {
 		char name[16];
 		snd_pcm_debug_name(substream, name, sizeof(name));
-		snd_printd("%s_update: %s: pos=%u/%u/%u, "
-			   "hwptr=%ld/%ld/%ld/%ld\n",
+		pcm_dbg(substream->pcm,
+			"%s_update: %s: pos=%u/%u/%u, hwptr=%ld/%ld/%ld/%ld\n",
 			   in_interrupt ? "period" : "hwptr",
 			   name,
 			   (unsigned int)pos,
@@ -1941,8 +1939,9 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 			continue;
 		}
 		if (!tout) {
-			snd_printd("%s write error (DMA or IRQ trouble?)\n",
-				   is_playback ? "playback" : "capture");
+			pcm_dbg(substream->pcm,
+				"%s write error (DMA or IRQ trouble?)\n",
+				is_playback ? "playback" : "capture");
 			err = -EIO;
 			break;
 		}

commit ed697e1aaf7237b1a62af39f64463b05c262808d
Author: JongHo Kim <furmuwon@gmail.com>
Date:   Tue Dec 17 23:02:24 2013 +0900

    ALSA: Add SNDRV_PCM_STATE_PAUSED case in wait_for_avail function
    
    When the process is sleeping at the SNDRV_PCM_STATE_PAUSED
    state from the wait_for_avail function, the sleep process will be woken by
    timeout(10 seconds). Even if the sleep process wake up by timeout, by this
    patch, the process will continue with sleep and wait for the other state.
    
    Signed-off-by: JongHo Kim <furmuwon@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 6e03b465e44e..a2104671f51d 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1937,6 +1937,8 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 		case SNDRV_PCM_STATE_DISCONNECTED:
 			err = -EBADFD;
 			goto _endloop;
+		case SNDRV_PCM_STATE_PAUSED:
+			continue;
 		}
 		if (!tout) {
 			snd_printd("%s write error (DMA or IRQ trouble?)\n",

commit 74d779ab7c9f9024cfead259206e0e0b20ee37e4
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Fri Aug 16 11:19:00 2013 -0600

    ALSA: pcm: Use snd_printd_ratelimit()
    
    The use of snd_printd_ratelimit() supresses superfluous output from
    printk_ratelimit() when CONFIG_SND_DEBUG is not defined. For example,
    
    [   43.753692] snd_pcm_update_hw_ptr0: 26 callbacks suppressed
    [   48.822131] snd_pcm_update_hw_ptr0: 25 callbacks suppressed
    [   53.894953] snd_pcm_update_hw_ptr0: 25 callbacks suppressed
    [   58.997761] snd_pcm_update_hw_ptr0: 25 callbacks suppressed
    [   64.100952] snd_pcm_update_hw_ptr0: 25 callbacks suppressed
    
    fills the log even when no debug output is actually produced.
    
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 82bb029d4414..6e03b465e44e 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -184,7 +184,7 @@ static void xrun(struct snd_pcm_substream *substream)
 	do {								\
 		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
 			xrun_log_show(substream);			\
-			if (printk_ratelimit()) {			\
+			if (snd_printd_ratelimit()) {			\
 				snd_printd("PCM: " fmt, ##args);	\
 			}						\
 			dump_stack_on_xrun(substream);			\
@@ -342,7 +342,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		return -EPIPE;
 	}
 	if (pos >= runtime->buffer_size) {
-		if (printk_ratelimit()) {
+		if (snd_printd_ratelimit()) {
 			char name[16];
 			snd_pcm_debug_name(substream, name, sizeof(name));
 			xrun_log_show(substream);

commit e6c2e7eb27fc512af6875d7f2cf313e29c61be0b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri May 24 15:18:10 2013 +0200

    ALSA: Constify the snd_pcm_substream struct ops field
    
    The ops field of the snd_pcm_substream struct is never modified inside the ALSA
    core. Making it const allows drivers to declare their snd_pcm_ops struct as
    const.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 41b3dfe68698..82bb029d4414 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -568,7 +568,8 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
  *
  * Sets the given PCM operators to the pcm instance.
  */
-void snd_pcm_set_ops(struct snd_pcm *pcm, int direction, struct snd_pcm_ops *ops)
+void snd_pcm_set_ops(struct snd_pcm *pcm, int direction,
+		     const struct snd_pcm_ops *ops)
 {
 	struct snd_pcm_str *stream = &pcm->streams[direction];
 	struct snd_pcm_substream *substream;

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index c4840ff75d00..41b3dfe68698 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -666,7 +666,8 @@ static inline unsigned int muldiv32(unsigned int a, unsigned int b,
  * The interval is changed to the range satisfying both intervals.
  * The interval status (min, max, integer, etc.) are evaluated.
  *
- * Returns non-zero if the value is changed, zero if not changed.
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
  */
 int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)
 {
@@ -865,7 +866,8 @@ void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
  * @nump: pointer to store the resultant numerator
  * @denp: pointer to store the resultant denominator
  *
- * Returns non-zero if the value is changed, zero if not changed.
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
  */
 int snd_interval_ratnum(struct snd_interval *i,
 			unsigned int rats_count, struct snd_ratnum *rats,
@@ -983,7 +985,8 @@ EXPORT_SYMBOL(snd_interval_ratnum);
  * @nump: pointer to store the resultant numerator
  * @denp: pointer to store the resultant denominator
  *
- * Returns non-zero if the value is changed, zero if not changed.
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
  */
 static int snd_interval_ratden(struct snd_interval *i,
 			       unsigned int rats_count, struct snd_ratden *rats,
@@ -1082,7 +1085,8 @@ static int snd_interval_ratden(struct snd_interval *i,
  * When mask is non-zero, only the elements corresponding to bit 1 are
  * evaluated.
  *
- * Returns non-zero if the value is changed, zero if not changed.
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
  */
 int snd_interval_list(struct snd_interval *i, unsigned int count,
 		      const unsigned int *list, unsigned int mask)
@@ -1142,7 +1146,7 @@ static int snd_interval_step(struct snd_interval *i, unsigned int min, unsigned
  * @private: the private data pointer passed to function
  * @dep: the dependent variables
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 			int var,
@@ -1200,6 +1204,8 @@ EXPORT_SYMBOL(snd_pcm_hw_rule_add);
  * @mask: the bitmap mask
  *
  * Apply the constraint of the given bitmap mask to a 32-bit mask parameter.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 			       u_int32_t mask)
@@ -1220,6 +1226,8 @@ int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param
  * @mask: the 64bit bitmap mask
  *
  * Apply the constraint of the given bitmap mask to a 64-bit mask parameter.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 				 u_int64_t mask)
@@ -1240,6 +1248,9 @@ int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_par
  * @var: hw_params variable to apply the integer constraint
  *
  * Apply the constraint of integer to an interval parameter.
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
  */
 int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var)
 {
@@ -1257,6 +1268,9 @@ EXPORT_SYMBOL(snd_pcm_hw_constraint_integer);
  * @max: the maximal value
  * 
  * Apply the min/max range constraint to an interval parameter.
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
  */
 int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 				 unsigned int min, unsigned int max)
@@ -1288,6 +1302,8 @@ static int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,
  * @l: list
  * 
  * Apply the list of constraints to an interval parameter.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
@@ -1322,6 +1338,8 @@ static int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,
  * @cond: condition bits
  * @var: hw_params variable to apply the ratnums constraint
  * @r: struct snd_ratnums constriants
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
@@ -1355,6 +1373,8 @@ static int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,
  * @cond: condition bits
  * @var: hw_params variable to apply the ratdens constraint
  * @r: struct snd_ratdens constriants
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
@@ -1386,6 +1406,8 @@ static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
  * @cond: condition bits
  * @width: sample bits width
  * @msbits: msbits width
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, 
 				 unsigned int cond,
@@ -1414,6 +1436,8 @@ static int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,
  * @cond: condition bits
  * @var: hw_params variable to apply the step constraint
  * @step: step size
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
@@ -1444,6 +1468,8 @@ static int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @var: hw_params variable to apply the power-of-2 constraint
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
@@ -1470,6 +1496,8 @@ static int snd_pcm_hw_rule_noresample_func(struct snd_pcm_hw_params *params,
  * snd_pcm_hw_rule_noresample - add a rule to allow disabling hw resampling
  * @runtime: PCM runtime instance
  * @base_rate: the rate at which the hardware does not resample
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,
 			       unsigned int base_rate)
@@ -1519,8 +1547,8 @@ EXPORT_SYMBOL(_snd_pcm_hw_params_any);
  * @var: parameter to retrieve
  * @dir: pointer to the direction (-1,0,1) or %NULL
  *
- * Return the value for field @var if it's fixed in configuration space
- * defined by @params. Return -%EINVAL otherwise.
+ * Return: The value for field @var if it's fixed in configuration space
+ * defined by @params. -%EINVAL otherwise.
  */
 int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
 			   snd_pcm_hw_param_t var, int *dir)
@@ -1591,7 +1619,8 @@ static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
  *
  * Inside configuration space defined by @params remove from @var all
  * values > minimum. Reduce configuration space accordingly.
- * Return the minimum.
+ *
+ * Return: The minimum, or a negative error code on failure.
  */
 int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, 
 			   struct snd_pcm_hw_params *params, 
@@ -1637,7 +1666,8 @@ static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
  *
  * Inside configuration space defined by @params remove from @var all
  * values < maximum. Reduce configuration space accordingly.
- * Return the maximum.
+ *
+ * Return: The maximum, or a negative error code on failure.
  */
 int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, 
 			  struct snd_pcm_hw_params *params,
@@ -1665,6 +1695,8 @@ EXPORT_SYMBOL(snd_pcm_hw_param_last);
  * The configuration chosen is that obtained fixing in this order:
  * first access, first format, first subformat, min channels,
  * min rate, min period time, max buffer size, min tick time
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,
 			     struct snd_pcm_hw_params *params)
@@ -1771,7 +1803,7 @@ static int snd_pcm_lib_ioctl_fifo_size(struct snd_pcm_substream *substream,
  * Processes the generic ioctl commands for PCM.
  * Can be passed as the ioctl callback for PCM ops.
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg)
@@ -2510,7 +2542,7 @@ static void pcm_chmap_ctl_private_free(struct snd_kcontrol *kcontrol)
  * @info_ret: store struct snd_pcm_chmap instance if non-NULL
  *
  * Create channel-mapping control elements assigned to the given PCM stream(s).
- * Returns zero if succeed, or a negative error value.
+ * Return: Zero if successful, or a negative error value.
  */
 int snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,
 			   const struct snd_pcm_chmap_elem *chmap,

commit 4eeaaeaea1cec60a25979678182720dc91308550
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Mon Oct 22 16:42:15 2012 -0500

    ALSA: core: add hooks for audio timestamps
    
    ALSA did not provide any direct means to infer the audio time for A/V
    sync and system/audio time correlations (eg. PulseAudio).
    Applications had to track the number of samples read/written and
    add/subtract the number of samples queued in the ring buffer.  This
    accounting led to small errors, typically several samples, due to the
    two-step process.  Computing the audio time in the kernel is more
    direct, as all the information is available in the same routines.
    
    Also add new .audio_wallclock routine to enable fine-grain synchronization
    between monotonic system time and audio hardware time.
    Using the wallclock, if supported in hardware, allows for a
    much better sub-microsecond precision and a common drift tracking for
    all devices sharing the same wall clock (master clock).
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3dc029e106a2..c4840ff75d00 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -316,6 +316,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	unsigned long jdelta;
 	unsigned long curr_jiffies;
 	struct timespec curr_tstamp;
+	struct timespec audio_tstamp;
 	int crossed_boundary = 0;
 
 	old_hw_ptr = runtime->status->hw_ptr;
@@ -328,9 +329,14 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	 */
 	pos = substream->ops->pointer(substream);
 	curr_jiffies = jiffies;
-	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {
 		snd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);
 
+		if ((runtime->hw.info & SNDRV_PCM_INFO_HAS_WALL_CLOCK) &&
+			(substream->ops->wall_clock))
+			substream->ops->wall_clock(substream, &audio_tstamp);
+	}
+
 	if (pos == SNDRV_PCM_POS_XRUN) {
 		xrun(substream);
 		return -EPIPE;
@@ -520,9 +526,31 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		snd_BUG_ON(crossed_boundary != 1);
 		runtime->hw_ptr_wrap += runtime->boundary;
 	}
-	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {
 		runtime->status->tstamp = curr_tstamp;
 
+		if (!(runtime->hw.info & SNDRV_PCM_INFO_HAS_WALL_CLOCK)) {
+			/*
+			 * no wall clock available, provide audio timestamp
+			 * derived from pointer position+delay
+			 */
+			u64 audio_frames, audio_nsecs;
+
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				audio_frames = runtime->hw_ptr_wrap
+					+ runtime->status->hw_ptr
+					- runtime->delay;
+			else
+				audio_frames = runtime->hw_ptr_wrap
+					+ runtime->status->hw_ptr
+					+ runtime->delay;
+			audio_nsecs = div_u64(audio_frames * 1000000000LL,
+					runtime->rate);
+			audio_tstamp = ns_to_timespec(audio_nsecs);
+		}
+		runtime->status->audio_tstamp = audio_tstamp;
+	}
+
 	return snd_pcm_update_state(substream, runtime);
 }
 

commit 0e8014d772a7639f48d234b23dc4ce97335cce7f
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Mon Oct 22 16:42:14 2012 -0500

    ALSA: core: keep track of boundary wrap-around
    
    Keep track of boundary crossing when hw_ptr
    exceeds boundary limit and wraps-around. This
    will help keep track of total number
    of frames played/received at the kernel level
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index f42c10a43315..3dc029e106a2 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -316,6 +316,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	unsigned long jdelta;
 	unsigned long curr_jiffies;
 	struct timespec curr_tstamp;
+	int crossed_boundary = 0;
 
 	old_hw_ptr = runtime->status->hw_ptr;
 
@@ -360,8 +361,10 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			hdelta = curr_jiffies - runtime->hw_ptr_jiffies;
 			if (hdelta > runtime->hw_ptr_buffer_jiffies/2) {
 				hw_base += runtime->buffer_size;
-				if (hw_base >= runtime->boundary)
+				if (hw_base >= runtime->boundary) {
 					hw_base = 0;
+					crossed_boundary++;
+				}
 				new_hw_ptr = hw_base + pos;
 				goto __delta;
 			}
@@ -371,8 +374,10 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	/* pointer crosses the end of the ring buffer */
 	if (new_hw_ptr < old_hw_ptr) {
 		hw_base += runtime->buffer_size;
-		if (hw_base >= runtime->boundary)
+		if (hw_base >= runtime->boundary) {
 			hw_base = 0;
+			crossed_boundary++;
+		}
 		new_hw_ptr = hw_base + pos;
 	}
       __delta:
@@ -410,8 +415,10 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		while (hdelta > xrun_threshold) {
 			delta += runtime->buffer_size;
 			hw_base += runtime->buffer_size;
-			if (hw_base >= runtime->boundary)
+			if (hw_base >= runtime->boundary) {
 				hw_base = 0;
+				crossed_boundary++;
+			}
 			new_hw_ptr = hw_base + pos;
 			hdelta -= runtime->hw_ptr_buffer_jiffies;
 		}
@@ -456,8 +463,10 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		/* the delta value is small or zero in most cases */
 		while (delta > 0) {
 			new_hw_ptr += runtime->period_size;
-			if (new_hw_ptr >= runtime->boundary)
+			if (new_hw_ptr >= runtime->boundary) {
 				new_hw_ptr -= runtime->boundary;
+				crossed_boundary--;
+			}
 			delta--;
 		}
 		/* align hw_base to buffer_size */
@@ -507,6 +516,10 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
 	runtime->hw_ptr_jiffies = curr_jiffies;
+	if (crossed_boundary) {
+		snd_BUG_ON(crossed_boundary != 1);
+		runtime->hw_ptr_wrap += runtime->boundary;
+	}
 	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
 		runtime->status->tstamp = curr_tstamp;
 
@@ -1661,8 +1674,10 @@ static int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,
 	if (snd_pcm_running(substream) &&
 	    snd_pcm_update_hw_ptr(substream) >= 0)
 		runtime->status->hw_ptr %= runtime->buffer_size;
-	else
+	else {
 		runtime->status->hw_ptr = 0;
+		runtime->hw_ptr_wrap = 0;
+	}
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	return 0;
 }

commit 5efbc2610a7b2aac6c51f8fc943c019106568939
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 13 14:48:46 2012 +0200

    ALSA: Fix leftover chmap UNKNOWN -> MONO conversions
    
    A few files have been slipped from the previous commit to add MONO
    channel type.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 9647a22ed69a..f42c10a43315 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2311,7 +2311,7 @@ EXPORT_SYMBOL(snd_pcm_lib_readv);
 /* default channel maps for multi-channel playbacks, up to 8 channels */
 const struct snd_pcm_chmap_elem snd_pcm_std_chmaps[] = {
 	{ .channels = 1,
-	  .map = { SNDRV_CHMAP_UNKNOWN } },
+	  .map = { SNDRV_CHMAP_MONO } },
 	{ .channels = 2,
 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
 	{ .channels = 4,
@@ -2333,7 +2333,7 @@ EXPORT_SYMBOL_GPL(snd_pcm_std_chmaps);
 /* alternative channel maps with CLFE <-> surround swapped for 6/8 channels */
 const struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[] = {
 	{ .channels = 1,
-	  .map = { SNDRV_CHMAP_UNKNOWN } },
+	  .map = { SNDRV_CHMAP_MONO } },
 	{ .channels = 2,
 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
 	{ .channels = 4,

commit 2dc6fbf0078e8148b571f1bbec704ca5c8e2ec2c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 11 14:24:43 2012 +0200

    ALSA: pcm - Use UNKNOWN chmap for mono streams
    
    In general, mono streams have no dedicated speaker assignment, thus
    they should be rather marked as UNKNOWN position.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 0a750ec5c400..9647a22ed69a 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2311,7 +2311,7 @@ EXPORT_SYMBOL(snd_pcm_lib_readv);
 /* default channel maps for multi-channel playbacks, up to 8 channels */
 const struct snd_pcm_chmap_elem snd_pcm_std_chmaps[] = {
 	{ .channels = 1,
-	  .map = { SNDRV_CHMAP_FC } },
+	  .map = { SNDRV_CHMAP_UNKNOWN } },
 	{ .channels = 2,
 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
 	{ .channels = 4,
@@ -2333,7 +2333,7 @@ EXPORT_SYMBOL_GPL(snd_pcm_std_chmaps);
 /* alternative channel maps with CLFE <-> surround swapped for 6/8 channels */
 const struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[] = {
 	{ .channels = 1,
-	  .map = { SNDRV_CHMAP_FC } },
+	  .map = { SNDRV_CHMAP_UNKNOWN } },
 	{ .channels = 2,
 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
 	{ .channels = 4,

commit 6e67683d718c627aa585a82ae0eb44a7058eae5a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 21 14:49:47 2012 +0200

    ALSA: Remove VOLATILE flag from chmap ctls
    
    The VOLATILE flag was added to control elements by
    snd_pcm_add_chmap_ctls() just because I didn't want to have a
    side-effect of "alsactl restore".  But now the set operation doesn't
    allow to change the value unless the PCM stream is in PREAPRED state,
    there is no reason to keep this flag.  Let's rip it off.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 565102705eda..0a750ec5c400 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2479,7 +2479,6 @@ int snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,
 	struct snd_kcontrol_new knew = {
 		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 		.access = SNDRV_CTL_ELEM_ACCESS_READ |
-			SNDRV_CTL_ELEM_ACCESS_VOLATILE | /* no notification */
 			SNDRV_CTL_ELEM_ACCESS_TLV_READ |
 			SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,
 		.info = pcm_chmap_ctl_info,

commit 2d3391ec0ecca37efb6bc995906292f47522b471
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 27 18:27:00 2012 +0200

    ALSA: PCM: channel mapping API implementation
    
    This patch implements the basic data types for the standard channel
    mapping API handling.
    
    - The definitions of the channel positions and the new TLV types are
      added in sound/asound.h and sound/tlv.h, so that they can be
      referred from user-space.
    
    - Introduced a new helper function snd_pcm_add_chmap_ctls() to create
      control elements representing the channel maps for each PCM
      (sub)stream.
    
    - Some standard pre-defined channel maps are provided for
      convenience.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 7ae671923393..565102705eda 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -26,6 +26,7 @@
 #include <linux/export.h>
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/info.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -2302,3 +2303,217 @@ snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 }
 
 EXPORT_SYMBOL(snd_pcm_lib_readv);
+
+/*
+ * standard channel mapping helpers
+ */
+
+/* default channel maps for multi-channel playbacks, up to 8 channels */
+const struct snd_pcm_chmap_elem snd_pcm_std_chmaps[] = {
+	{ .channels = 1,
+	  .map = { SNDRV_CHMAP_FC } },
+	{ .channels = 2,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
+	{ .channels = 4,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+	{ .channels = 6,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,
+		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE } },
+	{ .channels = 8,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,
+		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+		   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },
+	{ }
+};
+EXPORT_SYMBOL_GPL(snd_pcm_std_chmaps);
+
+/* alternative channel maps with CLFE <-> surround swapped for 6/8 channels */
+const struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[] = {
+	{ .channels = 1,
+	  .map = { SNDRV_CHMAP_FC } },
+	{ .channels = 2,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
+	{ .channels = 4,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+	{ .channels = 6,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+	{ .channels = 8,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,
+		   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },
+	{ }
+};
+EXPORT_SYMBOL_GPL(snd_pcm_alt_chmaps);
+
+static bool valid_chmap_channels(const struct snd_pcm_chmap *info, int ch)
+{
+	if (ch > info->max_channels)
+		return false;
+	return !info->channel_mask || (info->channel_mask & (1U << ch));
+}
+
+static int pcm_chmap_ctl_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 0;
+	uinfo->count = info->max_channels;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = SNDRV_CHMAP_LAST;
+	return 0;
+}
+
+/* get callback for channel map ctl element
+ * stores the channel position firstly matching with the current channels
+ */
+static int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+	unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	struct snd_pcm_substream *substream;
+	const struct snd_pcm_chmap_elem *map;
+
+	if (snd_BUG_ON(!info->chmap))
+		return -EINVAL;
+	substream = snd_pcm_chmap_substream(info, idx);
+	if (!substream)
+		return -ENODEV;
+	memset(ucontrol->value.integer.value, 0,
+	       sizeof(ucontrol->value.integer.value));
+	if (!substream->runtime)
+		return 0; /* no channels set */
+	for (map = info->chmap; map->channels; map++) {
+		int i;
+		if (map->channels == substream->runtime->channels &&
+		    valid_chmap_channels(info, map->channels)) {
+			for (i = 0; i < map->channels; i++)
+				ucontrol->value.integer.value[i] = map->map[i];
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/* tlv callback for channel map ctl element
+ * expands the pre-defined channel maps in a form of TLV
+ */
+static int pcm_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,
+			     unsigned int size, unsigned int __user *tlv)
+{
+	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+	const struct snd_pcm_chmap_elem *map;
+	unsigned int __user *dst;
+	int c, count = 0;
+
+	if (snd_BUG_ON(!info->chmap))
+		return -EINVAL;
+	if (size < 8)
+		return -ENOMEM;
+	if (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))
+		return -EFAULT;
+	size -= 8;
+	dst = tlv + 2;
+	for (map = info->chmap; map->channels; map++) {
+		int chs_bytes = map->channels * 4;
+		if (!valid_chmap_channels(info, map->channels))
+			continue;
+		if (size < 8)
+			return -ENOMEM;
+		if (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||
+		    put_user(chs_bytes, dst + 1))
+			return -EFAULT;
+		dst += 2;
+		size -= 8;
+		count += 8;
+		if (size < chs_bytes)
+			return -ENOMEM;
+		size -= chs_bytes;
+		count += chs_bytes;
+		for (c = 0; c < map->channels; c++) {
+			if (put_user(map->map[c], dst))
+				return -EFAULT;
+			dst++;
+		}
+	}
+	if (put_user(count, tlv + 1))
+		return -EFAULT;
+	return 0;
+}
+
+static void pcm_chmap_ctl_private_free(struct snd_kcontrol *kcontrol)
+{
+	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+	info->pcm->streams[info->stream].chmap_kctl = NULL;
+	kfree(info);
+}
+
+/**
+ * snd_pcm_add_chmap_ctls - create channel-mapping control elements
+ * @pcm: the assigned PCM instance
+ * @stream: stream direction
+ * @chmap: channel map elements (for query)
+ * @max_channels: the max number of channels for the stream
+ * @private_value: the value passed to each kcontrol's private_value field
+ * @info_ret: store struct snd_pcm_chmap instance if non-NULL
+ *
+ * Create channel-mapping control elements assigned to the given PCM stream(s).
+ * Returns zero if succeed, or a negative error value.
+ */
+int snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,
+			   const struct snd_pcm_chmap_elem *chmap,
+			   int max_channels,
+			   unsigned long private_value,
+			   struct snd_pcm_chmap **info_ret)
+{
+	struct snd_pcm_chmap *info;
+	struct snd_kcontrol_new knew = {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE | /* no notification */
+			SNDRV_CTL_ELEM_ACCESS_TLV_READ |
+			SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,
+		.info = pcm_chmap_ctl_info,
+		.get = pcm_chmap_ctl_get,
+		.tlv.c = pcm_chmap_ctl_tlv,
+	};
+	int err;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+	info->pcm = pcm;
+	info->stream = stream;
+	info->chmap = chmap;
+	info->max_channels = max_channels;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		knew.name = "Playback Channel Map";
+	else
+		knew.name = "Capture Channel Map";
+	knew.device = pcm->device;
+	knew.count = pcm->streams[stream].substream_count;
+	knew.private_value = private_value;
+	info->kctl = snd_ctl_new1(&knew, info);
+	if (!info->kctl) {
+		kfree(info);
+		return -ENOMEM;
+	}
+	info->kctl->private_free = pcm_chmap_ctl_private_free;
+	err = snd_ctl_add(pcm->card, info->kctl);
+	if (err < 0)
+		return err;
+	pcm->streams[stream].chmap_kctl = info->kctl;
+	if (info_ret)
+		*info_ret = info;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_pcm_add_chmap_ctls);

commit 1464189f8c2a5341722437ef916786afaf241c44
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jul 5 12:15:01 2012 +0100

    ALSA: pcm: Make constraints lists const
    
    They aren't modified by the core so the drivers can declare them const.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 8f312fa6c282..7ae671923393 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1250,10 +1250,10 @@ static int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,
 int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var,
-			       struct snd_pcm_hw_constraint_list *l)
+			       const struct snd_pcm_hw_constraint_list *l)
 {
 	return snd_pcm_hw_rule_add(runtime, cond, var,
-				   snd_pcm_hw_rule_list, l,
+				   snd_pcm_hw_rule_list, (void *)l,
 				   var, -1);
 }
 

commit 3509a03f4dcf7fedb8880180fed3f7f791ce5598
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Tue May 22 14:54:02 2012 -0500

    ALSA: core: group read of pointer, tstamp and jiffies
    
    Group read of hw_ptr, tstamp and jiffies in a sequence
    for better correlation. Previous code took timestamp at the
    end, which could introduce delays between audio time and
    system time.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index faedb1481b24..8f312fa6c282 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -313,9 +313,22 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;
 	snd_pcm_sframes_t hdelta, delta;
 	unsigned long jdelta;
+	unsigned long curr_jiffies;
+	struct timespec curr_tstamp;
 
 	old_hw_ptr = runtime->status->hw_ptr;
+
+	/*
+	 * group pointer, time and jiffies reads to allow for more
+	 * accurate correlations/corrections.
+	 * The values are stored at the end of this routine after
+	 * corrections for hw_ptr position
+	 */
 	pos = substream->ops->pointer(substream);
+	curr_jiffies = jiffies;
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+		snd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);
+
 	if (pos == SNDRV_PCM_POS_XRUN) {
 		xrun(substream);
 		return -EPIPE;
@@ -343,7 +356,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		delta = runtime->hw_ptr_interrupt + runtime->period_size;
 		if (delta > new_hw_ptr) {
 			/* check for double acknowledged interrupts */
-			hdelta = jiffies - runtime->hw_ptr_jiffies;
+			hdelta = curr_jiffies - runtime->hw_ptr_jiffies;
 			if (hdelta > runtime->hw_ptr_buffer_jiffies/2) {
 				hw_base += runtime->buffer_size;
 				if (hw_base >= runtime->boundary)
@@ -388,7 +401,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		 * Without regular period interrupts, we have to check
 		 * the elapsed time to detect xruns.
 		 */
-		jdelta = jiffies - runtime->hw_ptr_jiffies;
+		jdelta = curr_jiffies - runtime->hw_ptr_jiffies;
 		if (jdelta < runtime->hw_ptr_buffer_jiffies / 2)
 			goto no_delta_check;
 		hdelta = jdelta - delta * HZ / runtime->rate;
@@ -430,7 +443,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	if (hdelta < runtime->delay)
 		goto no_jiffies_check;
 	hdelta -= runtime->delay;
-	jdelta = jiffies - runtime->hw_ptr_jiffies;
+	jdelta = curr_jiffies - runtime->hw_ptr_jiffies;
 	if (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {
 		delta = jdelta /
 			(((runtime->period_size * HZ) / runtime->rate)
@@ -492,9 +505,9 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	}
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
-	runtime->hw_ptr_jiffies = jiffies;
+	runtime->hw_ptr_jiffies = curr_jiffies;
 	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
-		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
+		runtime->status->tstamp = curr_tstamp;
 
 	return snd_pcm_update_state(substream, runtime);
 }

commit 0910c216f78d1097a4ac6dcc83b38809dea94160
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 11 17:50:49 2012 +0200

    ALSA: pcm - Optimize the call of snd_pcm_update_hw_ptr() in read/write loop
    
    In the PCM read/write loop, the driver calls snd_pcm_update_hw_ptr()
    at each time at the beginning of the loop.  Russell King reported that
    this hogs CPU significantly.
    
    The current code assumes that the pointer callback is very fast and
    cheap, also not too much fine grained.  It's not true in all cases.
    When the pointer advances short samples while the read/write copy has
    been performed, the driver updates the hw_ptr and gets avail > 0
    again.  Then it tries to read/write these small chunks.  This repeats
    until the avail really gets to zero.
    
    For avoiding this situation, a simple workaround is to call
    snd_pcm_update_hw_ptr() only once at starting the loop, assuming that
    the read/write copy is performed fast enough.  If the available count
    becomes short, it goes to snd_pcm_wait_avail() anyway, and this
    processes right.
    
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 4d18941178e6..faedb1481b24 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1894,6 +1894,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
+	snd_pcm_uframes_t avail;
 	int err = 0;
 
 	if (size == 0)
@@ -1917,13 +1918,12 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 	}
 
 	runtime->twake = runtime->control->avail_min ? : 1;
+	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+		snd_pcm_update_hw_ptr(substream);
+	avail = snd_pcm_playback_avail(runtime);
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
-		snd_pcm_uframes_t avail;
 		snd_pcm_uframes_t cont;
-		if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
-			snd_pcm_update_hw_ptr(substream);
-		avail = snd_pcm_playback_avail(runtime);
 		if (!avail) {
 			if (nonblock) {
 				err = -EAGAIN;
@@ -1971,6 +1971,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		offset += frames;
 		size -= frames;
 		xfer += frames;
+		avail -= frames;
 		if (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
 		    snd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {
 			err = snd_pcm_start(substream);
@@ -2111,6 +2112,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
+	snd_pcm_uframes_t avail;
 	int err = 0;
 
 	if (size == 0)
@@ -2141,13 +2143,12 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 	}
 
 	runtime->twake = runtime->control->avail_min ? : 1;
+	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+		snd_pcm_update_hw_ptr(substream);
+	avail = snd_pcm_capture_avail(runtime);
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
-		snd_pcm_uframes_t avail;
 		snd_pcm_uframes_t cont;
-		if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
-			snd_pcm_update_hw_ptr(substream);
-		avail = snd_pcm_capture_avail(runtime);
 		if (!avail) {
 			if (runtime->status->state ==
 			    SNDRV_PCM_STATE_DRAINING) {
@@ -2202,6 +2203,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		offset += frames;
 		size -= frames;
 		xfer += frames;
+		avail -= frames;
 	}
  _end_unlock:
 	runtime->twake = 0;

commit 4af87a939ef7092fdca267fba473cf8407d6d8e2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 14 19:48:43 2012 +0000

    ALSA: pcm: Constify the list in snd_pcm_hw_constraint_list
    
    Allows the constraint lists to be declared const by drivers which seems
    reasonable; there's plenty of other constification we could do if we were
    being complete but this was easy and quick.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3420bd3da5d7..4d18941178e6 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1029,7 +1029,8 @@ static int snd_interval_ratden(struct snd_interval *i,
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *list, unsigned int mask)
+int snd_interval_list(struct snd_interval *i, unsigned int count,
+		      const unsigned int *list, unsigned int mask)
 {
         unsigned int k;
 	struct snd_interval list_range;

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 95d1e789715f..3420bd3da5d7 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/math64.h>
+#include <linux/export.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/info.h>

commit d5b702a64b4c273c8eed7e4e721364493d01fdc9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Sep 16 23:03:02 2011 +0200

    ALSA: pcm: add snd_pcm_hw_rule_noresample()
    
    Add a helper function to allow drivers to disable hardware resampling
    when the application has specified the SNDRV_PCM_HW_PARAMS_NORESAMPLE
    flag.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 62e90b862a0d..95d1e789715f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1399,6 +1399,32 @@ int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
 
 EXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);
 
+static int snd_pcm_hw_rule_noresample_func(struct snd_pcm_hw_params *params,
+					   struct snd_pcm_hw_rule *rule)
+{
+	unsigned int base_rate = (unsigned int)(uintptr_t)rule->private;
+	struct snd_interval *rate;
+
+	rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	return snd_interval_list(rate, 1, &base_rate, 0);
+}
+
+/**
+ * snd_pcm_hw_rule_noresample - add a rule to allow disabling hw resampling
+ * @runtime: PCM runtime instance
+ * @base_rate: the rate at which the hardware does not resample
+ */
+int snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,
+			       unsigned int base_rate)
+{
+	return snd_pcm_hw_rule_add(runtime, SNDRV_PCM_HW_PARAMS_NORESAMPLE,
+				   SNDRV_PCM_HW_PARAM_RATE,
+				   snd_pcm_hw_rule_noresample_func,
+				   (void *)(uintptr_t)base_rate,
+				   SNDRV_PCM_HW_PARAM_RATE, -1);
+}
+EXPORT_SYMBOL(snd_pcm_hw_rule_noresample);
+
 static void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,
 				  snd_pcm_hw_param_t var)
 {

commit 763437a9e7737535b2fc72175ad4974048769be6
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Thu Sep 15 08:49:25 2011 +0200

    ALSA: pcm - fix race condition in wait_for_avail()
    
    wait_for_avail() in pcm_lib.c has a race in it (observed in practice by an
    Intel validation group).
    
    The function is supposed to return once space in the buffer has become
    available, or if some timeout happens.  The entity that creates space (irq
    handler of sound driver and some such) will do a wake up on a waitqueue
    that this function registers for.
    
    However there are two races in the existing code
    
    1) If space became available between the caller noticing there was no
       space and this function actually sleeping, the wakeup is missed and the
       timeout condition will happen instead
    
    2) If a wakeup happened but not sufficient space became available, the
       code will loop again and wait for more space.  However, if the second
       wake comes in prior to hitting the schedule_timeout_interruptible(), it
       will be missed, and potentially you'll wait out until the timeout
       happens.
    
    The fix consists of using more careful setting of the current state (so
    that if a wakeup happens in the main loop window, the schedule_timeout()
    falls through) and by checking for available space prior to going into the
    schedule_timeout() loop, but after being on the waitqueue and having the
    state set to interruptible.
    
    [tiwai: the following changes have been added to Arjan's original patch:
     - merged akpm's fix for waitqueue adding order into a single patch
     - reduction of duplicated code of avail check
    ]
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 86d0caf91b35..62e90b862a0d 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1761,6 +1761,10 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 	snd_pcm_uframes_t avail = 0;
 	long wait_time, tout;
 
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&runtime->tsleep, &wait);
+
 	if (runtime->no_period_wakeup)
 		wait_time = MAX_SCHEDULE_TIMEOUT;
 	else {
@@ -1771,16 +1775,32 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 		}
 		wait_time = msecs_to_jiffies(wait_time * 1000);
 	}
-	init_waitqueue_entry(&wait, current);
-	add_wait_queue(&runtime->tsleep, &wait);
+
 	for (;;) {
 		if (signal_pending(current)) {
 			err = -ERESTARTSYS;
 			break;
 		}
+
+		/*
+		 * We need to check if space became available already
+		 * (and thus the wakeup happened already) first to close
+		 * the race of space already having become available.
+		 * This check must happen after been added to the waitqueue
+		 * and having current state be INTERRUPTIBLE.
+		 */
+		if (is_playback)
+			avail = snd_pcm_playback_avail(runtime);
+		else
+			avail = snd_pcm_capture_avail(runtime);
+		if (avail >= runtime->twake)
+			break;
 		snd_pcm_stream_unlock_irq(substream);
-		tout = schedule_timeout_interruptible(wait_time);
+
+		tout = schedule_timeout(wait_time);
+
 		snd_pcm_stream_lock_irq(substream);
+		set_current_state(TASK_INTERRUPTIBLE);
 		switch (runtime->status->state) {
 		case SNDRV_PCM_STATE_SUSPENDED:
 			err = -ESTRPIPE;
@@ -1806,14 +1826,9 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 			err = -EIO;
 			break;
 		}
-		if (is_playback)
-			avail = snd_pcm_playback_avail(runtime);
-		else
-			avail = snd_pcm_capture_avail(runtime);
-		if (avail >= runtime->twake)
-			break;
 	}
  _endloop:
+	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&runtime->tsleep, &wait);
 	*availp = avail;
 	return err;

commit acb03d440b8a723181e1d45e3517e43cb0792f8a
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Sat Jul 23 12:36:25 2011 +1200

    ALSA: Make snd_pcm_debug_name usable outside pcm_lib
    
    Formatting a PCM name is useful for module debug too.
    Add snd_prefix when making function public.
    
    [minor coding-style fixes by tiwai]
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index f1341308beda..86d0caf91b35 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -128,7 +128,8 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 	}
 }
 
-static void pcm_debug_name(struct snd_pcm_substream *substream,
+#ifdef CONFIG_SND_DEBUG
+void snd_pcm_debug_name(struct snd_pcm_substream *substream,
 			   char *name, size_t len)
 {
 	snprintf(name, len, "pcmC%dD%d%c:%d",
@@ -137,6 +138,8 @@ static void pcm_debug_name(struct snd_pcm_substream *substream,
 		 substream->stream ? 'c' : 'p',
 		 substream->number);
 }
+EXPORT_SYMBOL(snd_pcm_debug_name);
+#endif
 
 #define XRUN_DEBUG_BASIC	(1<<0)
 #define XRUN_DEBUG_STACK	(1<<1)	/* dump also stack */
@@ -168,7 +171,7 @@ static void xrun(struct snd_pcm_substream *substream)
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {
 		char name[16];
-		pcm_debug_name(substream, name, sizeof(name));
+		snd_pcm_debug_name(substream, name, sizeof(name));
 		snd_printd(KERN_DEBUG "XRUN: %s\n", name);
 		dump_stack_on_xrun(substream);
 	}
@@ -243,7 +246,7 @@ static void xrun_log_show(struct snd_pcm_substream *substream)
 		return;
 	if (xrun_debug(substream, XRUN_DEBUG_LOGONCE) && log->hit)
 		return;
-	pcm_debug_name(substream, name, sizeof(name));
+	snd_pcm_debug_name(substream, name, sizeof(name));
 	for (cnt = 0, idx = log->idx; cnt < XRUN_LOG_CNT; cnt++) {
 		entry = &log->entries[idx];
 		if (entry->period_size == 0)
@@ -319,7 +322,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	if (pos >= runtime->buffer_size) {
 		if (printk_ratelimit()) {
 			char name[16];
-			pcm_debug_name(substream, name, sizeof(name));
+			snd_pcm_debug_name(substream, name, sizeof(name));
 			xrun_log_show(substream);
 			snd_printd(KERN_ERR  "BUG: %s, pos = %ld, "
 				   "buffer size = %ld, period size = %ld\n",
@@ -364,7 +367,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	if (xrun_debug(substream, in_interrupt ?
 			XRUN_DEBUG_PERIODUPDATE : XRUN_DEBUG_HWPTRUPDATE)) {
 		char name[16];
-		pcm_debug_name(substream, name, sizeof(name));
+		snd_pcm_debug_name(substream, name, sizeof(name));
 		snd_printd("%s_update: %s: pos=%u/%u/%u, "
 			   "hwptr=%ld/%ld/%ld/%ld\n",
 			   in_interrupt ? "period" : "hwptr",

commit f2b3614cefb61ee6046a0aaee503ee37f227d310
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 26 08:09:38 2011 +0200

    ALSA: PCM - Don't check DMA time-out too shortly
    
    When the PCM period size is set larger than 10 seconds, currently the
    PCM core may abort the operation with DMA-error due to the fixed timeout
    for 10 seconds.  A similar problem is seen in the drain operation that
    has a fixed timeout of 10 seconds, too.
    
    This patch fixes the timeout length depending on the period size and
    rate, also including the consideration of no_period_wakeup flag.
    
    Reported-by: Raymond Yau <superquad.vortex2@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index abfeff1611ce..f1341308beda 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1756,8 +1756,18 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 	wait_queue_t wait;
 	int err = 0;
 	snd_pcm_uframes_t avail = 0;
-	long tout;
-
+	long wait_time, tout;
+
+	if (runtime->no_period_wakeup)
+		wait_time = MAX_SCHEDULE_TIMEOUT;
+	else {
+		wait_time = 10;
+		if (runtime->rate) {
+			long t = runtime->period_size * 2 / runtime->rate;
+			wait_time = max(t, wait_time);
+		}
+		wait_time = msecs_to_jiffies(wait_time * 1000);
+	}
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(&runtime->tsleep, &wait);
 	for (;;) {
@@ -1765,9 +1775,8 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 			err = -ERESTARTSYS;
 			break;
 		}
-		set_current_state(TASK_INTERRUPTIBLE);
 		snd_pcm_stream_unlock_irq(substream);
-		tout = schedule_timeout(msecs_to_jiffies(10000));
+		tout = schedule_timeout_interruptible(wait_time);
 		snd_pcm_stream_lock_irq(substream);
 		switch (runtime->status->state) {
 		case SNDRV_PCM_STATE_SUSPENDED:

commit 217658f46c2dbfe260f8f5976f2a201911a2f4c6
Author: Ben Gardiner <bengardiner@nanometrics.ca>
Date:   Wed May 18 23:52:38 2011 -0400

    ALSA: sound, core, pcm_lib: fix xrun_log
    
    The xrun_log function was augmented with the in_interrupt parameter whereas the
    empty macro definition used when xrun logging is disabled was not.
    
    Add a third parameter to the empty macro definition so as to not cause compiler
    errors when xrun logging (CONFIG_SND_PCM_XRUN_DEBUG) is disabled.
    
    Signed-off-by: Ben Gardiner <bengardiner@nanometrics.ca>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index c8c8091f9a71..abfeff1611ce 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -266,7 +266,7 @@ static void xrun_log_show(struct snd_pcm_substream *substream)
 #else /* ! CONFIG_SND_PCM_XRUN_DEBUG */
 
 #define hw_ptr_error(substream, fmt, args...) do { } while (0)
-#define xrun_log(substream, pos)	do { } while (0)
+#define xrun_log(substream, pos, in_interrupt)	do { } while (0)
 #define xrun_log_show(substream)	do { } while (0)
 
 #endif

commit ec08b14483de0702ca43e3a8506e149486975f9b
Author: Ben Gardiner <bengardiner@nanometrics.ca>
Date:   Wed May 18 10:03:34 2011 -0400

    ALSA: sound, core, pcm_lib: xrun_log: log also in_interrupt
    
    When debugging pcm drivers I found the "period" or "hw" prefix printed
    by either XRUN_DEBUG_PERIODUPDATE or XRUN_DEBUG_PERIODUPDATE events,
    respectively to be very useful is observing the interplay between
    interrupt-context updates and syscall-context updates.
    
    Similarly, when debugging overruns with XRUN_DEBUG_LOG it is useful to
    see the context of the last 10 positions.
    
    Add an in_interrupt member to hwptr_log_entry which stores the value of
    the in_interrupt parameter of snd_pcm_update_hw_ptr0 when the log entry
    is created. Print a "[Q]" prefix when dumping the log entries if
    in_interrupt was true.
    
    Signed-off-by: Ben Gardiner <bengardiner@nanometrics.ca>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 64449cb8f873..c8c8091f9a71 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -189,6 +189,7 @@ static void xrun(struct snd_pcm_substream *substream)
 #define XRUN_LOG_CNT	10
 
 struct hwptr_log_entry {
+	unsigned int in_interrupt;
 	unsigned long jiffies;
 	snd_pcm_uframes_t pos;
 	snd_pcm_uframes_t period_size;
@@ -204,7 +205,7 @@ struct snd_pcm_hwptr_log {
 };
 
 static void xrun_log(struct snd_pcm_substream *substream,
-		     snd_pcm_uframes_t pos)
+		     snd_pcm_uframes_t pos, int in_interrupt)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_pcm_hwptr_log *log = runtime->hwptr_log;
@@ -220,6 +221,7 @@ static void xrun_log(struct snd_pcm_substream *substream,
 			return;
 	}
 	entry = &log->entries[log->idx];
+	entry->in_interrupt = in_interrupt;
 	entry->jiffies = jiffies;
 	entry->pos = pos;
 	entry->period_size = runtime->period_size;
@@ -246,9 +248,11 @@ static void xrun_log_show(struct snd_pcm_substream *substream)
 		entry = &log->entries[idx];
 		if (entry->period_size == 0)
 			break;
-		snd_printd("hwptr log: %s: j=%lu, pos=%ld/%ld/%ld, "
+		snd_printd("hwptr log: %s: %sj=%lu, pos=%ld/%ld/%ld, "
 			   "hwptr=%ld/%ld\n",
-			   name, entry->jiffies, (unsigned long)entry->pos,
+			   name, entry->in_interrupt ? "[Q] " : "",
+			   entry->jiffies,
+			   (unsigned long)entry->pos,
 			   (unsigned long)entry->period_size,
 			   (unsigned long)entry->buffer_size,
 			   (unsigned long)entry->old_hw_ptr,
@@ -326,7 +330,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	}
 	pos -= pos % runtime->min_align;
 	if (xrun_debug(substream, XRUN_DEBUG_LOG))
-		xrun_log(substream, pos);
+		xrun_log(substream, pos, in_interrupt);
 	hw_base = runtime->hw_ptr_base;
 	new_hw_ptr = hw_base + pos;
 	if (in_interrupt) {

commit 12ff414e2e4512f59fe191dc18e856e2939a1c79
Author: Kelly Anderson <kelly@silka.with-linux.com>
Date:   Fri Apr 1 11:58:25 2011 +0200

    ALSA: pcm: fix infinite loop in snd_pcm_update_hw_ptr0()
    
    When period interrupts are disabled, snd_pcm_update_hw_ptr0() compares
    the current time against the time estimated for the current hardware
    pointer to detect xruns.  The somewhat fuzzy threshold in the while loop
    makes it possible that hdelta becomes negative; the comparison being
    done with unsigned types then makes the loop go through the entire 263
    negative range, and, depending on the value, never reach an unsigned
    value that is small enough to stop the loop.  Doing this with interrupts
    disabled results in the machine locking up.
    
    To prevent this, ensure that the loop condition uses signed types for
    both operands so that the comparison is correctly done.
    
    Many thanks to Kelly Anderson for debugging this.
    
    Reported-by: Nix <nix@esperi.org.uk>
    Reported-by: "Christopher K." <c.krooss@googlemail.com>
    Reported-and-tested-by: Kelly Anderson <kelly@silka.with-linux.com>
    Signed-off-by: Kelly Anderson <kelly@silka.with-linux.com>
    [cl: remove unneeded casts; use a temp variable]
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: 2.6.38 <stable@kernel.org>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a82e3756a72d..64449cb8f873 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -375,6 +375,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	}
 
 	if (runtime->no_period_wakeup) {
+		snd_pcm_sframes_t xrun_threshold;
 		/*
 		 * Without regular period interrupts, we have to check
 		 * the elapsed time to detect xruns.
@@ -383,7 +384,8 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		if (jdelta < runtime->hw_ptr_buffer_jiffies / 2)
 			goto no_delta_check;
 		hdelta = jdelta - delta * HZ / runtime->rate;
-		while (hdelta > runtime->hw_ptr_buffer_jiffies / 2 + 1) {
+		xrun_threshold = runtime->hw_ptr_buffer_jiffies / 2 + 1;
+		while (hdelta > xrun_threshold) {
 			delta += runtime->buffer_size;
 			hw_base += runtime->buffer_size;
 			if (hw_base >= runtime->boundary)

commit e38302f78284e3e80ffc2eef54001fce7d183bd4
Merge: 3c0eee3fe6a3 c386735264da
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 13 08:37:14 2011 +0100

    Merge branch 'topic/misc' into for-linus

commit 87a1c8aaa0bced8acf4cd64672362492460c31ae
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Tue Dec 21 00:03:17 2010 +0100

    ALSA: pcm: remember to always call va_end() on stuff that we va_start()
    
    The Coverity checker spotted that we do not always remember to call
    va_end() on 'args' in failure paths in snd_pcm_hw_rule_add().
    Here's a patch to fix that up (compile tested only) - it also removes
    some annoying trailing whitespace that caught my eye while I was in the
    area..
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index b75db8e9cc0f..11446a1506da 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1070,8 +1070,10 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 		struct snd_pcm_hw_rule *new;
 		unsigned int new_rules = constrs->rules_all + 16;
 		new = kcalloc(new_rules, sizeof(*c), GFP_KERNEL);
-		if (!new)
+		if (!new) {
+			va_end(args);
 			return -ENOMEM;
+		}
 		if (constrs->rules) {
 			memcpy(new, constrs->rules,
 			       constrs->rules_num * sizeof(*c));
@@ -1087,8 +1089,10 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 	c->private = private;
 	k = 0;
 	while (1) {
-		if (snd_BUG_ON(k >= ARRAY_SIZE(c->deps)))
+		if (snd_BUG_ON(k >= ARRAY_SIZE(c->deps))) {
+			va_end(args);
 			return -EINVAL;
+		}
 		c->deps[k++] = dep;
 		if (dep < 0)
 			break;
@@ -1097,7 +1101,7 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 	constrs->rules_num++;
 	va_end(args);
 	return 0;
-}				    
+}
 
 EXPORT_SYMBOL(snd_pcm_hw_rule_add);
 

commit 47228e48aecdbec423a1275a5e27697d47f1f912
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Nov 18 09:53:07 2010 +0100

    ALSA: pcm: optimize xrun detection in no-period-wakeup mode
    
    Add a lightweight condition on top of the xrun checking so that we can
    avoid the division when the application is calling the update function
    often enough.
    
    Suggested-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index e9debaabf376..fd18c3c6484f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -380,6 +380,8 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		 * the elapsed time to detect xruns.
 		 */
 		jdelta = jiffies - runtime->hw_ptr_jiffies;
+		if (jdelta < runtime->hw_ptr_buffer_jiffies / 2)
+			goto no_delta_check;
 		hdelta = jdelta - delta * HZ / runtime->rate;
 		while (hdelta > runtime->hw_ptr_buffer_jiffies / 2 + 1) {
 			delta += runtime->buffer_size;

commit 59ff878ffb26bc0be812ca8295799164f413ae88
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Nov 18 09:43:52 2010 +0100

    ALSA: pcm: detect xruns in no-period-wakeup mode
    
    When period wakeups are disabled, successive calls to the pointer update
    function do not have a maximum allowed distance, so xruns cannot be
    detected with the pointer value only.
    
    To detect xruns, compare the actually elapsed time with the time that
    should have theoretically elapsed since the last update.  When the
    hardware pointer has wrapped around due to an xrun, the actually elapsed
    time will be too big by about hw_ptr_buffer_jiffies.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index bc57501c584a..e9debaabf376 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -374,9 +374,23 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			   (unsigned long)runtime->hw_ptr_base);
 	}
 
-	/* without period interrupts, there are no regular pointer updates */
-	if (runtime->no_period_wakeup)
+	if (runtime->no_period_wakeup) {
+		/*
+		 * Without regular period interrupts, we have to check
+		 * the elapsed time to detect xruns.
+		 */
+		jdelta = jiffies - runtime->hw_ptr_jiffies;
+		hdelta = jdelta - delta * HZ / runtime->rate;
+		while (hdelta > runtime->hw_ptr_buffer_jiffies / 2 + 1) {
+			delta += runtime->buffer_size;
+			hw_base += runtime->buffer_size;
+			if (hw_base >= runtime->boundary)
+				hw_base = 0;
+			new_hw_ptr = hw_base + pos;
+			hdelta -= runtime->hw_ptr_buffer_jiffies;
+		}
 		goto no_delta_check;
+	}
 
 	/* something must be really wrong */
 	if (delta >= runtime->buffer_size + runtime->period_size) {

commit ab69a4904b5dd4d7cd6996587ba066bca8d13838
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Nov 15 10:46:23 2010 +0100

    ALSA: pcm: support for period wakeup disabling
    
    This patch allows to disable period interrupts which are
    not needed when the application relies on a system timer
    to wake-up and refill the ring buffer. The behavior of
    the driver is left unchanged, and interrupts are only
    disabled if the application requests this configuration.
    The behavior in case of underruns is slightly different,
    instead of being detected during the period interrupts the
    underruns are detected when the application calls
    snd_pcm_update_avail, which in turns forces a refresh of the
    hw pointer and shows the buffer is empty.
    
    More specifically this patch makes a lot of sense when
    PulseAudio relies on timer-based scheduling to access audio
    devices such as HDAudio or Intel SST. Disabling interrupts
    removes two unwanted wake-ups due to period elapsed events
    in low-power playback modes. It also simplifies PulseAudio
    voice modules used for speech calls.
    
    To quote Lennart "This patch looks very interesting and
    desirable. This is something have long been waiting for."
    
    Support for this in hardware drivers is optional.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@intel.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index b75db8e9cc0f..bc57501c584a 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -373,6 +373,11 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			   (unsigned long)new_hw_ptr,
 			   (unsigned long)runtime->hw_ptr_base);
 	}
+
+	/* without period interrupts, there are no regular pointer updates */
+	if (runtime->no_period_wakeup)
+		goto no_delta_check;
+
 	/* something must be really wrong */
 	if (delta >= runtime->buffer_size + runtime->period_size) {
 		hw_ptr_error(substream,
@@ -442,6 +447,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			     (long)old_hw_ptr);
 	}
 
+ no_delta_check:
 	if (runtime->status->hw_ptr == new_hw_ptr)
 		return 0;
 

commit c80c1d542744dd7851cc8da748c6ada99680fb4d
Author: Joe Perches <joe@perches.com>
Date:   Sun Nov 14 19:05:02 2010 -0800

    ALSA: sound/core/pcm_lib.c: Remove unnecessary semicolons
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a1707cca9c66..b75db8e9cc0f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -223,7 +223,7 @@ static void xrun_log(struct snd_pcm_substream *substream,
 	entry->jiffies = jiffies;
 	entry->pos = pos;
 	entry->period_size = runtime->period_size;
-	entry->buffer_size = runtime->buffer_size;;
+	entry->buffer_size = runtime->buffer_size;
 	entry->old_hw_ptr = runtime->status->hw_ptr;
 	entry->hw_ptr_base = runtime->hw_ptr_base;
 	log->idx = (log->idx + 1) % XRUN_LOG_CNT;

commit bd76af0f87f7a1815b311bde269a3f18305b3169
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Aug 18 14:16:54 2010 +0200

    ALSA: pcm midlevel code - add time check for double interrupt acknowledge
    
    The current code in pcm_lib.c do all checks using only the position
    in the ring buffer. Unfortunately, where the interrupts gets delayed or
    merged into one, we need another timing source to check when the
    buffer size boundary overlaps to avoid the wrong updating of the
    ring buffer pointers.
    
    This code uses jiffies to check the right time window without any
    performance impact.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index e23e0e7ab26f..a1707cca9c66 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -334,11 +334,15 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		/* delta = "expected next hw_ptr" for in_interrupt != 0 */
 		delta = runtime->hw_ptr_interrupt + runtime->period_size;
 		if (delta > new_hw_ptr) {
-			hw_base += runtime->buffer_size;
-			if (hw_base >= runtime->boundary)
-				hw_base = 0;
-			new_hw_ptr = hw_base + pos;
-			goto __delta;
+			/* check for double acknowledged interrupts */
+			hdelta = jiffies - runtime->hw_ptr_jiffies;
+			if (hdelta > runtime->hw_ptr_buffer_jiffies/2) {
+				hw_base += runtime->buffer_size;
+				if (hw_base >= runtime->boundary)
+					hw_base = 0;
+				new_hw_ptr = hw_base + pos;
+				goto __delta;
+			}
 		}
 	}
 	/* new_hw_ptr might be lower than old_hw_ptr in case when */

commit 9e216e8a40428cbf689222148c28d0256fbd0186
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Jul 19 16:37:39 2010 +0200

    ALSA: pcm core - add a safe check to the silence filling function
    
    In situation when appl_ptr is far greater then hw_ptr, the hw_avail value
    can be greater than buffer_size. Check for this.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index bcf95d3ff5c7..e23e0e7ab26f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -67,6 +67,8 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 	} else {
 		if (new_hw_ptr == ULONG_MAX) {	/* initialization */
 			snd_pcm_sframes_t avail = snd_pcm_playback_hw_avail(runtime);
+			if (avail > runtime->buffer_size)
+				avail = runtime->buffer_size;
 			runtime->silence_filled = avail > 0 ? avail : 0;
 			runtime->silence_start = (runtime->status->hw_ptr +
 						  runtime->silence_filled) %

commit 5daeba34d2aab669aea07abee13d53cd116578fb
Author: David Dillow <dave@thedillows.org>
Date:   Sun Jun 27 00:13:20 2010 +0200

    ALSA: pcm_lib: avoid timing jitter in snd_pcm_read/write()
    
    When using poll() to wait for the next period -- or avail_min samples --
    one gets a consistent delay for each system call that is usually just a
    little short of the selected period time. However, When using
    snd_pcm_read/write(), one gets a jittery delay that alternates between
    less than a millisecond and approximately two period times. This is
    caused by snd_pcm_lib_{read,write}1() transferring any available samples
    to the user's buffer and adjusting the application pointer prior to
    sleeping to the end of the current period. When the next period
    interrupt occurs, there is then less than avail_min samples remaining to
    be transferred in the period, so we end up sleeping until a second
    period occurs.
    
    This is solved by using runtime->twake as the number of samples needed
    for a wakeup in addition to selecting the proper wait queue to wake in
    snd_pcm_update_state(). This requires twake to be non-zero when used
    by snd_pcm_lib_{read,write}1() even if avail_min is zero.
    
    Signed-off-by: Dave Dillow <dave@thedillows.org>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index e9d98be190c5..bcf95d3ff5c7 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -287,8 +287,11 @@ int snd_pcm_update_state(struct snd_pcm_substream *substream,
 			return -EPIPE;
 		}
 	}
-	if (avail >= runtime->control->avail_min)
-		wake_up(runtime->twake ? &runtime->tsleep : &runtime->sleep);
+	if (runtime->twake) {
+		if (avail >= runtime->twake)
+			wake_up(&runtime->tsleep);
+	} else if (avail >= runtime->control->avail_min)
+		wake_up(&runtime->sleep);
 	return 0;
 }
 
@@ -1707,7 +1710,7 @@ EXPORT_SYMBOL(snd_pcm_period_elapsed);
  * The available space is stored on availp.  When err = 0 and avail = 0
  * on the capture stream, it indicates the stream is in DRAINING state.
  */
-static int wait_for_avail_min(struct snd_pcm_substream *substream,
+static int wait_for_avail(struct snd_pcm_substream *substream,
 			      snd_pcm_uframes_t *availp)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -1757,7 +1760,7 @@ static int wait_for_avail_min(struct snd_pcm_substream *substream,
 			avail = snd_pcm_playback_avail(runtime);
 		else
 			avail = snd_pcm_capture_avail(runtime);
-		if (avail >= runtime->control->avail_min)
+		if (avail >= runtime->twake)
 			break;
 	}
  _endloop:
@@ -1820,7 +1823,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		goto _end_unlock;
 	}
 
-	runtime->twake = 1;
+	runtime->twake = runtime->control->avail_min ? : 1;
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t avail;
@@ -1833,7 +1836,9 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 				err = -EAGAIN;
 				goto _end_unlock;
 			}
-			err = wait_for_avail_min(substream, &avail);
+			runtime->twake = min_t(snd_pcm_uframes_t, size,
+					runtime->control->avail_min ? : 1);
+			err = wait_for_avail(substream, &avail);
 			if (err < 0)
 				goto _end_unlock;
 		}
@@ -2042,7 +2047,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		goto _end_unlock;
 	}
 
-	runtime->twake = 1;
+	runtime->twake = runtime->control->avail_min ? : 1;
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t avail;
@@ -2060,7 +2065,9 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 				err = -EAGAIN;
 				goto _end_unlock;
 			}
-			err = wait_for_avail_min(substream, &avail);
+			runtime->twake = min_t(snd_pcm_uframes_t, size,
+					runtime->control->avail_min ? : 1);
+			err = wait_for_avail(substream, &avail);
 			if (err < 0)
 				goto _end_unlock;
 			if (!avail)

commit b406e6103baa3da85950f22d3d46d21a8da654c5
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 25 09:01:46 2010 +0200

    ALSA: pcm: fix delta calculation at boundary wraparound
    
    In the cleanup of the hw_ptr update functions in 2.6.33, the calculation
    of the delta value was changed to use the modulo operator to protect
    against a negative difference due to the pointer wrapping around at the
    boundary.
    
    However, the ptr variables are unsigned, so a negative difference would
    result in the two complement's value which has no relation to the actual
    difference relative to the boundary; the result is typically some value
    near LONG_MAX-boundary.  Furthermore, even if the modulo operation would
    be done with signed types, the result of a negative dividend could be
    negative.
    
    The invalid delta value is then caught by the following checks, but this
    means that the pointer update is ignored.
    
    To fix this, use a range check as in the other pointer calculations.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 22aff180dd1f..e9d98be190c5 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -345,7 +345,9 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		new_hw_ptr = hw_base + pos;
 	}
       __delta:
-	delta = (new_hw_ptr - old_hw_ptr) % runtime->boundary;
+	delta = new_hw_ptr - old_hw_ptr;
+	if (delta < 0)
+		delta += runtime->boundary;
 	if (xrun_debug(substream, in_interrupt ?
 			XRUN_DEBUG_PERIODUPDATE : XRUN_DEBUG_HWPTRUPDATE)) {
 		char name[16];

commit ead4046b2fdfd69acc4272e693afd249ad3eb689
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri May 21 09:15:59 2010 +0200

    ALSA: pcm: fix the fix of the runtime->boundary calculation
    
    Commit 7910b4a1db63fefc3d291853d33c34c5b6352e8e in 2.6.34 changed the
    runtime->boundary calculation to make this value a multiple of both the
    buffer_size and the period_size, because the latter is assumed by the
    runtime->hw_ptr_interrupt calculation.
    
    However, due to the lack of a ioctl that could read the software
    parameters before they are set, the kernel requires that alsa-lib
    calculates the boundary value, too.  The changed algorithm leads to
    a different boundary value used by alsa-lib, which makes, e.g., mplayer
    fail to play a 44.1 kHz file because the silence_size parameter is now
    invalid; bug report:
    <https://bugtrack.alsa-project.org/alsa-bug/view.php?id=5015>.
    
    This patch reverts the change to the boundary calculation, and instead
    fixes the hw_ptr_interrupt calculation to be period-aligned regardless
    of the boundary value.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a2ff86189d2a..22aff180dd1f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -439,8 +439,13 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 		snd_pcm_playback_silence(substream, new_hw_ptr);
 
 	if (in_interrupt) {
-		runtime->hw_ptr_interrupt = new_hw_ptr -
-				(new_hw_ptr % runtime->period_size);
+		delta = new_hw_ptr - runtime->hw_ptr_interrupt;
+		if (delta < 0)
+			delta += runtime->boundary;
+		delta -= (snd_pcm_uframes_t)delta % runtime->period_size;
+		runtime->hw_ptr_interrupt += delta;
+		if (runtime->hw_ptr_interrupt >= runtime->boundary)
+			runtime->hw_ptr_interrupt -= runtime->boundary;
 	}
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;

commit 0f17014b340b98465fcf0de4c0d6c84a002ec53b
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Fri Mar 26 16:07:25 2010 +0200

    ALSA: pcm_lib - fix xrun functionality
    
    The commit 4d96eb255c53ab5e39b37fd4d484ea3dc39ab456 broke the interrupt
    time xrun functionality (stream stop etc.) if the CONFIG_SND_PCM_XRUN_DEBUG
    is not set. This is because the xrun() is null defined without it.
    
    Fix this by letting the function xrun() to be always defined as it was
    before.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index b546ac2660f9..a2ff86189d2a 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -148,6 +148,9 @@ static void pcm_debug_name(struct snd_pcm_substream *substream,
 
 #define xrun_debug(substream, mask) \
 			((substream)->pstr->xrun_debug & (mask))
+#else
+#define xrun_debug(substream, mask)	0
+#endif
 
 #define dump_stack_on_xrun(substream) do {			\
 		if (xrun_debug(substream, XRUN_DEBUG_STACK))	\
@@ -169,6 +172,7 @@ static void xrun(struct snd_pcm_substream *substream)
 	}
 }
 
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
 #define hw_ptr_error(substream, fmt, args...)				\
 	do {								\
 		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
@@ -255,8 +259,6 @@ static void xrun_log_show(struct snd_pcm_substream *substream)
 
 #else /* ! CONFIG_SND_PCM_XRUN_DEBUG */
 
-#define xrun_debug(substream, mask)	0
-#define xrun(substream)			do { } while (0)
 #define hw_ptr_error(substream, fmt, args...) do { } while (0)
 #define xrun_log(substream, pos)	do { } while (0)
 #define xrun_log_show(substream)	do { } while (0)

commit d0d2c38e3963f4f86a9e62d74f45a371458f2787
Merge: cf944ee55cc3 e7636925789b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 26 18:13:04 2010 +0100

    Merge remote branch 'alsa/devel' into topic/misc

commit e7636925789b042ff9d98c51d48392e8c5549480
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Jan 26 17:08:24 2010 +0100

    ALSA: pcm_lib - return back hw_ptr_interrupt
    
    Clemens Ladisch noted for hw_ptr_removal in "cleanup & merge hw_ptr
    update functions" commit:
    
    "It is possible for the status/delay ioctls to be called when the sound
    card's pointer register alreay shows a position at the beginning of the
    new period, but immediately before the interrupt is actually executed.
    (This happens regularly on a SMP machine with mplayer.)  When that
    happens, the code thinks that the position must be at least one period
    ahead of the current position and drops an entire buffer of data."
    
    Return back the hw_ptr_interrupt variable. The last interrupt pointer
    is always computed from the latest hw_ptr instead of tracking it
    separately (in this case all hw_ptr checks and modifications might
    influence also hw_ptr_interrupt and it is difficult to keep it
    consistent).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index e2a817eac2a9..aa54195ef3b0 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -325,8 +325,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	if (in_interrupt) {
 		/* we know that one period was processed */
 		/* delta = "expected next hw_ptr" for in_interrupt != 0 */
-		delta = old_hw_ptr - (old_hw_ptr % runtime->period_size)
-			+ runtime->period_size;
+		delta = runtime->hw_ptr_interrupt + runtime->period_size;
 		if (delta > new_hw_ptr) {
 			hw_base += runtime->buffer_size;
 			if (hw_base >= runtime->boundary)
@@ -437,6 +436,10 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);
 
+	if (in_interrupt) {
+		runtime->hw_ptr_interrupt = new_hw_ptr -
+				(new_hw_ptr % runtime->period_size);
+	}
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
 	runtime->hw_ptr_jiffies = jiffies;

commit 8b296c8f9f660b70e958e6e6b9b4293e6ae854f2
Merge: 88501ce18eaa c91a988dc655
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 21 14:27:14 2010 +0100

    Merge remote branch 'alsa/devel' into topic/misc

commit c91a988dc6551c66418690e36b2a23cdb0255da8
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Jan 21 10:32:15 2010 +0100

    ALSA: pcm_core: Fix wake_up() optimization
    
    This change fixes the "ALSA: pcm_lib - optimize wake_up() calls for PCM I/O"
    commit. New sleeping queue is introduced to separate user space and kernel
    space wake_ups. runtime->nowake is renamed to twake (transfer wake).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 5417f7dce834..e2a817eac2a9 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -285,8 +285,8 @@ int snd_pcm_update_state(struct snd_pcm_substream *substream,
 			return -EPIPE;
 		}
 	}
-	if (!runtime->nowake && avail >= runtime->control->avail_min)
-		wake_up(&runtime->sleep);
+	if (avail >= runtime->control->avail_min)
+		wake_up(runtime->twake ? &runtime->tsleep : &runtime->sleep);
 	return 0;
 }
 
@@ -1692,7 +1692,7 @@ static int wait_for_avail_min(struct snd_pcm_substream *substream,
 	long tout;
 
 	init_waitqueue_entry(&wait, current);
-	add_wait_queue(&runtime->sleep, &wait);
+	add_wait_queue(&runtime->tsleep, &wait);
 	for (;;) {
 		if (signal_pending(current)) {
 			err = -ERESTARTSYS;
@@ -1735,7 +1735,7 @@ static int wait_for_avail_min(struct snd_pcm_substream *substream,
 			break;
 	}
  _endloop:
-	remove_wait_queue(&runtime->sleep, &wait);
+	remove_wait_queue(&runtime->tsleep, &wait);
 	*availp = avail;
 	return err;
 }
@@ -1794,7 +1794,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		goto _end_unlock;
 	}
 
-	runtime->nowake = 1;
+	runtime->twake = 1;
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t avail;
@@ -1816,7 +1816,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		if (frames > cont)
 			frames = cont;
 		if (snd_BUG_ON(!frames)) {
-			runtime->nowake = 0;
+			runtime->twake = 0;
 			snd_pcm_stream_unlock_irq(substream);
 			return -EINVAL;
 		}
@@ -1855,7 +1855,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		}
 	}
  _end_unlock:
-	runtime->nowake = 0;
+	runtime->twake = 0;
 	if (xfer > 0 && err >= 0)
 		snd_pcm_update_state(substream, runtime);
 	snd_pcm_stream_unlock_irq(substream);
@@ -2016,7 +2016,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		goto _end_unlock;
 	}
 
-	runtime->nowake = 1;
+	runtime->twake = 1;
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t avail;
@@ -2045,7 +2045,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		if (frames > cont)
 			frames = cont;
 		if (snd_BUG_ON(!frames)) {
-			runtime->nowake = 0;
+			runtime->twake = 0;
 			snd_pcm_stream_unlock_irq(substream);
 			return -EINVAL;
 		}
@@ -2078,7 +2078,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		xfer += frames;
 	}
  _end_unlock:
-	runtime->nowake = 0;
+	runtime->twake = 0;
 	if (xfer > 0 && err >= 0)
 		snd_pcm_update_state(substream, runtime);
 	snd_pcm_stream_unlock_irq(substream);

commit 47e91348459901c30cc1bb4897e62ced21ca243a
Merge: 6b98515a6205 ed69c6a8eef6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 13 08:32:53 2010 +0100

    Merge branch 'devel' of git.alsa-project.org:alsa-kernel into topic/misc

commit ed69c6a8eef679f2783848ed624897a937a434ac
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Jan 13 08:12:31 2010 +0100

    ALSA: pcm_lib - fix wrong delta print for jiffies check
    
    The previous jiffies delta was 0 in all cases. Use hw_ptr variable to
    store and print original value.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 0ee7e807c964..5417f7dce834 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -394,6 +394,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 								+ HZ/100);
 		/* move new_hw_ptr according jiffies not pos variable */
 		new_hw_ptr = old_hw_ptr;
+		hw_base = delta;
 		/* use loop to avoid checks for delta overflows */
 		/* the delta value is small or zero in most cases */
 		while (delta > 0) {
@@ -403,8 +404,6 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			delta--;
 		}
 		/* align hw_base to buffer_size */
-		hw_base = new_hw_ptr - (new_hw_ptr % runtime->buffer_size);
-		delta = 0;
 		hw_ptr_error(substream,
 			     "hw_ptr skipping! %s"
 			     "(pos=%ld, delta=%ld, period=%ld, "
@@ -412,9 +411,12 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			     in_interrupt ? "[Q] " : "",
 			     (long)pos, (long)hdelta,
 			     (long)runtime->period_size, jdelta,
-			     ((hdelta * HZ) / runtime->rate), delta,
+			     ((hdelta * HZ) / runtime->rate), hw_base,
 			     (unsigned long)old_hw_ptr,
 			     (unsigned long)new_hw_ptr);
+		/* reset values to proper state */
+		delta = 0;
+		hw_base = new_hw_ptr - (new_hw_ptr % runtime->buffer_size);
 	}
  no_jiffies_check:
 	if (delta > runtime->period_size + runtime->period_size / 2) {

commit a29fb94ff48cba620e1ac1317f5eef5920ead3ff
Merge: 52a7a5835173 dd3533eca859
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 12 09:40:08 2010 +0100

    Merge commit alsa/devel into topic/misc
    
    Conflicts:
            include/sound/version.h

commit a4ad68d57e4dc4138304df23d1817eb094149389
Merge: cd9d95a55550 c97259df3f2e
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Jan 8 09:11:18 2010 +0100

    Merge branch 'topic/hda' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6 into devel

commit 7b3a177b0d4f92b3431b8dca777313a07533a710
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Jan 8 08:43:01 2010 +0100

    ALSA: pcm_lib: fix "something must be really wrong" condition
    
    When runtime->periods == 1 or when pointer crosses end of ring buffer,
    the delta might be greater than buffer_size.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a63226232ef4..c7b35b20e659 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -362,7 +362,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			   (unsigned long)runtime->hw_ptr_base);
 	}
 	/* something must be really wrong */
-	if (delta >= runtime->buffer_size) {
+	if (delta >= runtime->buffer_size + runtime->period_size) {
 		hw_ptr_error(substream,
 			       "Unexpected hw_pointer value %s"
 			       "(stream=%i, pos=%ld, new_hw_ptr=%ld, "

commit 1250932e48d3b698415b1f04775433cf1da688d6
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Jan 7 15:36:31 2010 +0100

    ALSA: pcm_lib - optimize wake_up() calls for PCM I/O
    
    As noted by pl bossart <bossart.nospam@gmail.com>, the PCM I/O routines
    (snd_pcm_lib_write1, snd_pcm_lib_read1) should block wake_up() calls
    until all samples are not processed.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 70a4f7428d78..a63226232ef4 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -263,8 +263,8 @@ static void xrun_log_show(struct snd_pcm_substream *substream)
 
 #endif
 
-static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
-				      struct snd_pcm_runtime *runtime)
+int snd_pcm_update_state(struct snd_pcm_substream *substream,
+			 struct snd_pcm_runtime *runtime)
 {
 	snd_pcm_uframes_t avail;
 
@@ -285,7 +285,7 @@ static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
 			return -EPIPE;
 		}
 	}
-	if (avail >= runtime->control->avail_min)
+	if (!runtime->nowake && avail >= runtime->control->avail_min)
 		wake_up(&runtime->sleep);
 	return 0;
 }
@@ -441,7 +441,7 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
 		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 
-	return snd_pcm_update_hw_ptr_post(substream, runtime);
+	return snd_pcm_update_state(substream, runtime);
 }
 
 /* CAUTION: call it with irq disabled */
@@ -1792,6 +1792,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		goto _end_unlock;
 	}
 
+	runtime->nowake = 1;
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t avail;
@@ -1813,15 +1814,17 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		if (frames > cont)
 			frames = cont;
 		if (snd_BUG_ON(!frames)) {
+			runtime->nowake = 0;
 			snd_pcm_stream_unlock_irq(substream);
 			return -EINVAL;
 		}
 		appl_ptr = runtime->control->appl_ptr;
 		appl_ofs = appl_ptr % runtime->buffer_size;
 		snd_pcm_stream_unlock_irq(substream);
-		if ((err = transfer(substream, appl_ofs, data, offset, frames)) < 0)
-			goto _end;
+		err = transfer(substream, appl_ofs, data, offset, frames);
 		snd_pcm_stream_lock_irq(substream);
+		if (err < 0)
+			goto _end_unlock;
 		switch (runtime->status->state) {
 		case SNDRV_PCM_STATE_XRUN:
 			err = -EPIPE;
@@ -1850,8 +1853,10 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		}
 	}
  _end_unlock:
+	runtime->nowake = 0;
+	if (xfer > 0 && err >= 0)
+		snd_pcm_update_state(substream, runtime);
 	snd_pcm_stream_unlock_irq(substream);
- _end:
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
 
@@ -2009,6 +2014,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		goto _end_unlock;
 	}
 
+	runtime->nowake = 1;
 	while (size > 0) {
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t avail;
@@ -2037,15 +2043,17 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		if (frames > cont)
 			frames = cont;
 		if (snd_BUG_ON(!frames)) {
+			runtime->nowake = 0;
 			snd_pcm_stream_unlock_irq(substream);
 			return -EINVAL;
 		}
 		appl_ptr = runtime->control->appl_ptr;
 		appl_ofs = appl_ptr % runtime->buffer_size;
 		snd_pcm_stream_unlock_irq(substream);
-		if ((err = transfer(substream, appl_ofs, data, offset, frames)) < 0)
-			goto _end;
+		err = transfer(substream, appl_ofs, data, offset, frames);
 		snd_pcm_stream_lock_irq(substream);
+		if (err < 0)
+			goto _end_unlock;
 		switch (runtime->status->state) {
 		case SNDRV_PCM_STATE_XRUN:
 			err = -EPIPE;
@@ -2068,8 +2076,10 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		xfer += frames;
 	}
  _end_unlock:
+	runtime->nowake = 0;
+	if (xfer > 0 && err >= 0)
+		snd_pcm_update_state(substream, runtime);
 	snd_pcm_stream_unlock_irq(substream);
- _end:
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
 

commit f240406babfe1526998e10583ea5eccc2676a433
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Jan 5 17:19:34 2010 +0100

    ALSA: pcm_lib - cleanup & merge hw_ptr update functions
    
    Do general cleanup in snd_pcm_update_hw_ptr*() routines and merge them.
    The main change is hw_ptr_interrupt variable removal to simplify code
    logic. This variable can be computed directly from hw_ptr.
    
    Ensure that updated hw_ptr is not lower than previous one (it was possible
    with old code in some obscure situations when interrupt was delayed or
    the lowlevel driver returns wrong ring buffer position value).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 1990afb8a735..70a4f7428d78 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -172,6 +172,7 @@ static void xrun(struct snd_pcm_substream *substream)
 #define hw_ptr_error(substream, fmt, args...)				\
 	do {								\
 		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
+			xrun_log_show(substream);			\
 			if (printk_ratelimit()) {			\
 				snd_printd("PCM: " fmt, ##args);	\
 			}						\
@@ -188,7 +189,6 @@ struct hwptr_log_entry {
 	snd_pcm_uframes_t buffer_size;
 	snd_pcm_uframes_t old_hw_ptr;
 	snd_pcm_uframes_t hw_ptr_base;
-	snd_pcm_uframes_t hw_ptr_interrupt;
 };
 
 struct snd_pcm_hwptr_log {
@@ -220,7 +220,6 @@ static void xrun_log(struct snd_pcm_substream *substream,
 	entry->buffer_size = runtime->buffer_size;;
 	entry->old_hw_ptr = runtime->status->hw_ptr;
 	entry->hw_ptr_base = runtime->hw_ptr_base;
-	entry->hw_ptr_interrupt = runtime->hw_ptr_interrupt;;
 	log->idx = (log->idx + 1) % XRUN_LOG_CNT;
 }
 
@@ -241,14 +240,13 @@ static void xrun_log_show(struct snd_pcm_substream *substream)
 		entry = &log->entries[idx];
 		if (entry->period_size == 0)
 			break;
-		snd_printd("hwptr log: %s: j=%lu, pos=0x%lx/0x%lx/0x%lx, "
-			   "hwptr=0x%lx, hw_base=0x%lx, hw_intr=0x%lx\n",
+		snd_printd("hwptr log: %s: j=%lu, pos=%ld/%ld/%ld, "
+			   "hwptr=%ld/%ld\n",
 			   name, entry->jiffies, (unsigned long)entry->pos,
 			   (unsigned long)entry->period_size,
 			   (unsigned long)entry->buffer_size,
 			   (unsigned long)entry->old_hw_ptr,
-			   (unsigned long)entry->hw_ptr_base,
-			   (unsigned long)entry->hw_ptr_interrupt);
+			   (unsigned long)entry->hw_ptr_base);
 		idx++;
 		idx %= XRUN_LOG_CNT;
 	}
@@ -265,33 +263,6 @@ static void xrun_log_show(struct snd_pcm_substream *substream)
 
 #endif
 
-static snd_pcm_uframes_t
-snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
-			  struct snd_pcm_runtime *runtime)
-{
-	snd_pcm_uframes_t pos;
-
-	pos = substream->ops->pointer(substream);
-	if (pos == SNDRV_PCM_POS_XRUN)
-		return pos; /* XRUN */
-	if (pos >= runtime->buffer_size) {
-		if (printk_ratelimit()) {
-			char name[16];
-			pcm_debug_name(substream, name, sizeof(name));
-			xrun_log_show(substream);
-			snd_printd(KERN_ERR  "BUG: %s, pos = 0x%lx, "
-				   "buffer size = 0x%lx, period size = 0x%lx\n",
-				   name, pos, runtime->buffer_size,
-				   runtime->period_size);
-		}
-		pos = 0;
-	}
-	pos -= pos % runtime->min_align;
-	if (xrun_debug(substream, XRUN_DEBUG_LOG))
-		xrun_log(substream, pos);
-	return pos;
-}
-
 static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
 				      struct snd_pcm_runtime *runtime)
 {
@@ -319,72 +290,88 @@ static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
+static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
+				  unsigned int in_interrupt)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t pos;
-	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_ptr_interrupt, hw_base;
+	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;
 	snd_pcm_sframes_t hdelta, delta;
 	unsigned long jdelta;
 
 	old_hw_ptr = runtime->status->hw_ptr;
-	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
+	pos = substream->ops->pointer(substream);
 	if (pos == SNDRV_PCM_POS_XRUN) {
 		xrun(substream);
 		return -EPIPE;
 	}
-	if (xrun_debug(substream, XRUN_DEBUG_PERIODUPDATE)) {
-		char name[16];
-		pcm_debug_name(substream, name, sizeof(name));
-		snd_printd("period_update: %s: pos=0x%x/0x%x/0x%x, "
-			   "hwptr=0x%lx, hw_base=0x%lx, hw_intr=0x%lx\n",
-			   name, (unsigned int)pos,
-			   (unsigned int)runtime->period_size,
-			   (unsigned int)runtime->buffer_size,
-			   (unsigned long)old_hw_ptr,
-			   (unsigned long)runtime->hw_ptr_base,
-			   (unsigned long)runtime->hw_ptr_interrupt);
+	if (pos >= runtime->buffer_size) {
+		if (printk_ratelimit()) {
+			char name[16];
+			pcm_debug_name(substream, name, sizeof(name));
+			xrun_log_show(substream);
+			snd_printd(KERN_ERR  "BUG: %s, pos = %ld, "
+				   "buffer size = %ld, period size = %ld\n",
+				   name, pos, runtime->buffer_size,
+				   runtime->period_size);
+		}
+		pos = 0;
 	}
+	pos -= pos % runtime->min_align;
+	if (xrun_debug(substream, XRUN_DEBUG_LOG))
+		xrun_log(substream, pos);
 	hw_base = runtime->hw_ptr_base;
 	new_hw_ptr = hw_base + pos;
-	hw_ptr_interrupt = runtime->hw_ptr_interrupt + runtime->period_size;
-	delta = new_hw_ptr - hw_ptr_interrupt;
-	if (hw_ptr_interrupt >= runtime->boundary) {
-		hw_ptr_interrupt -= runtime->boundary;
-		if (hw_base < runtime->boundary / 2)
-			/* hw_base was already lapped; recalc delta */
-			delta = new_hw_ptr - hw_ptr_interrupt;
-	}
-	if (delta < 0) {
-		if (runtime->periods == 1 || new_hw_ptr < old_hw_ptr)
-			delta += runtime->buffer_size;
-		if (delta < 0) {
-			xrun_log_show(substream);
-			hw_ptr_error(substream, 
-				     "Unexpected hw_pointer value "
-				     "(stream=%i, pos=%ld, intr_ptr=%ld)\n",
-				     substream->stream, (long)pos,
-				     (long)hw_ptr_interrupt);
-#if 1
-			/* simply skipping the hwptr update seems more
-			 * robust in some cases, e.g. on VMware with
-			 * inaccurate timer source
-			 */
-			return 0; /* skip this update */
-#else
-			/* rebase to interrupt position */
-			hw_base = new_hw_ptr = hw_ptr_interrupt;
-			/* align hw_base to buffer_size */
-			hw_base -= hw_base % runtime->buffer_size;
-			delta = 0;
-#endif
-		} else {
+	if (in_interrupt) {
+		/* we know that one period was processed */
+		/* delta = "expected next hw_ptr" for in_interrupt != 0 */
+		delta = old_hw_ptr - (old_hw_ptr % runtime->period_size)
+			+ runtime->period_size;
+		if (delta > new_hw_ptr) {
 			hw_base += runtime->buffer_size;
 			if (hw_base >= runtime->boundary)
 				hw_base = 0;
 			new_hw_ptr = hw_base + pos;
+			goto __delta;
 		}
 	}
+	/* new_hw_ptr might be lower than old_hw_ptr in case when */
+	/* pointer crosses the end of the ring buffer */
+	if (new_hw_ptr < old_hw_ptr) {
+		hw_base += runtime->buffer_size;
+		if (hw_base >= runtime->boundary)
+			hw_base = 0;
+		new_hw_ptr = hw_base + pos;
+	}
+      __delta:
+	delta = (new_hw_ptr - old_hw_ptr) % runtime->boundary;
+	if (xrun_debug(substream, in_interrupt ?
+			XRUN_DEBUG_PERIODUPDATE : XRUN_DEBUG_HWPTRUPDATE)) {
+		char name[16];
+		pcm_debug_name(substream, name, sizeof(name));
+		snd_printd("%s_update: %s: pos=%u/%u/%u, "
+			   "hwptr=%ld/%ld/%ld/%ld\n",
+			   in_interrupt ? "period" : "hwptr",
+			   name,
+			   (unsigned int)pos,
+			   (unsigned int)runtime->period_size,
+			   (unsigned int)runtime->buffer_size,
+			   (unsigned long)delta,
+			   (unsigned long)old_hw_ptr,
+			   (unsigned long)new_hw_ptr,
+			   (unsigned long)runtime->hw_ptr_base);
+	}
+	/* something must be really wrong */
+	if (delta >= runtime->buffer_size) {
+		hw_ptr_error(substream,
+			       "Unexpected hw_pointer value %s"
+			       "(stream=%i, pos=%ld, new_hw_ptr=%ld, "
+			       "old_hw_ptr=%ld)\n",
+				     in_interrupt ? "[Q] " : "[P]",
+				     substream->stream, (long)pos,
+				     (long)new_hw_ptr, (long)old_hw_ptr);
+		return 0;
+	}
 
 	/* Do jiffies check only in xrun_debug mode */
 	if (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))
@@ -396,7 +383,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	 */
 	if (runtime->hw.info & SNDRV_PCM_INFO_BATCH)
 		goto no_jiffies_check;
-	hdelta = new_hw_ptr - old_hw_ptr;
+	hdelta = delta;
 	if (hdelta < runtime->delay)
 		goto no_jiffies_check;
 	hdelta -= runtime->delay;
@@ -405,45 +392,49 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 		delta = jdelta /
 			(((runtime->period_size * HZ) / runtime->rate)
 								+ HZ/100);
-		xrun_log_show(substream);
+		/* move new_hw_ptr according jiffies not pos variable */
+		new_hw_ptr = old_hw_ptr;
+		/* use loop to avoid checks for delta overflows */
+		/* the delta value is small or zero in most cases */
+		while (delta > 0) {
+			new_hw_ptr += runtime->period_size;
+			if (new_hw_ptr >= runtime->boundary)
+				new_hw_ptr -= runtime->boundary;
+			delta--;
+		}
+		/* align hw_base to buffer_size */
+		hw_base = new_hw_ptr - (new_hw_ptr % runtime->buffer_size);
+		delta = 0;
 		hw_ptr_error(substream,
-			     "hw_ptr skipping! [Q] "
+			     "hw_ptr skipping! %s"
 			     "(pos=%ld, delta=%ld, period=%ld, "
-			     "jdelta=%lu/%lu/%lu)\n",
+			     "jdelta=%lu/%lu/%lu, hw_ptr=%ld/%ld)\n",
+			     in_interrupt ? "[Q] " : "",
 			     (long)pos, (long)hdelta,
 			     (long)runtime->period_size, jdelta,
-			     ((hdelta * HZ) / runtime->rate), delta);
-		hw_ptr_interrupt = runtime->hw_ptr_interrupt +
-				   runtime->period_size * delta;
-		if (hw_ptr_interrupt >= runtime->boundary)
-			hw_ptr_interrupt -= runtime->boundary;
-		/* rebase to interrupt position */
-		hw_base = new_hw_ptr = hw_ptr_interrupt;
-		/* align hw_base to buffer_size */
-		hw_base -= hw_base % runtime->buffer_size;
-		delta = 0;
+			     ((hdelta * HZ) / runtime->rate), delta,
+			     (unsigned long)old_hw_ptr,
+			     (unsigned long)new_hw_ptr);
 	}
  no_jiffies_check:
 	if (delta > runtime->period_size + runtime->period_size / 2) {
-		xrun_log_show(substream);
 		hw_ptr_error(substream,
-			     "Lost interrupts? "
-			     "(stream=%i, delta=%ld, intr_ptr=%ld)\n",
+			     "Lost interrupts? %s"
+			     "(stream=%i, delta=%ld, new_hw_ptr=%ld, "
+			     "old_hw_ptr=%ld)\n",
+			     in_interrupt ? "[Q] " : "",
 			     substream->stream, (long)delta,
-			     (long)hw_ptr_interrupt);
-		/* rebase hw_ptr_interrupt */
-		hw_ptr_interrupt =
-			new_hw_ptr - new_hw_ptr % runtime->period_size;
+			     (long)new_hw_ptr,
+			     (long)old_hw_ptr);
 	}
-	runtime->hw_ptr_interrupt = hw_ptr_interrupt;
+
+	if (runtime->status->hw_ptr == new_hw_ptr)
+		return 0;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);
 
-	if (runtime->status->hw_ptr == new_hw_ptr)
-		return 0;
-
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
 	runtime->hw_ptr_jiffies = jiffies;
@@ -456,83 +447,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 /* CAUTION: call it with irq disabled */
 int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	snd_pcm_uframes_t pos;
-	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;
-	snd_pcm_sframes_t delta;
-	unsigned long jdelta;
-
-	old_hw_ptr = runtime->status->hw_ptr;
-	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
-	if (pos == SNDRV_PCM_POS_XRUN) {
-		xrun(substream);
-		return -EPIPE;
-	}
-	if (xrun_debug(substream, XRUN_DEBUG_HWPTRUPDATE)) {
-		char name[16];
-		pcm_debug_name(substream, name, sizeof(name));
-		snd_printd("hw_update: %s: pos=0x%x/0x%x/0x%x, "
-			   "hwptr=0x%lx, hw_base=0x%lx, hw_intr=0x%lx\n",
-			   name, (unsigned int)pos,
-			   (unsigned int)runtime->period_size,
-			   (unsigned int)runtime->buffer_size,
-			   (unsigned long)old_hw_ptr,
-			   (unsigned long)runtime->hw_ptr_base,
-			   (unsigned long)runtime->hw_ptr_interrupt);
-	}
-
-	hw_base = runtime->hw_ptr_base;
-	new_hw_ptr = hw_base + pos;
-
-	delta = new_hw_ptr - old_hw_ptr;
-	jdelta = jiffies - runtime->hw_ptr_jiffies;
-	if (delta < 0) {
-		delta += runtime->buffer_size;
-		if (delta < 0) {
-			xrun_log_show(substream);
-			hw_ptr_error(substream, 
-				     "Unexpected hw_pointer value [2] "
-				     "(stream=%i, pos=%ld, old_ptr=%ld, jdelta=%li)\n",
-				     substream->stream, (long)pos,
-				     (long)old_hw_ptr, jdelta);
-			return 0;
-		}
-		hw_base += runtime->buffer_size;
-		if (hw_base >= runtime->boundary)
-			hw_base = 0;
-		new_hw_ptr = hw_base + pos;
-	}
-	/* Do jiffies check only in xrun_debug mode */
-	if (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))
-		goto no_jiffies_check;
-	if (delta < runtime->delay)
-		goto no_jiffies_check;
-	delta -= runtime->delay;
-	if (((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
-		xrun_log_show(substream);
-		hw_ptr_error(substream,
-			     "hw_ptr skipping! "
-			     "(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu)\n",
-			     (long)pos, (long)delta,
-			     (long)runtime->period_size, jdelta,
-			     ((delta * HZ) / runtime->rate));
-		return 0;
-	}
- no_jiffies_check:
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
-	    runtime->silence_size > 0)
-		snd_pcm_playback_silence(substream, new_hw_ptr);
-
-	if (runtime->status->hw_ptr == new_hw_ptr)
-		return 0;
-
-	runtime->hw_ptr_base = hw_base;
-	runtime->status->hw_ptr = new_hw_ptr;
-	runtime->hw_ptr_jiffies = jiffies;
-	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
-		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
-
-	return snd_pcm_update_hw_ptr_post(substream, runtime);
+	return snd_pcm_update_hw_ptr0(substream, 0);
 }
 
 /**
@@ -1744,7 +1659,7 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 
 	snd_pcm_stream_lock_irqsave(substream, flags);
 	if (!snd_pcm_running(substream) ||
-	    snd_pcm_update_hw_ptr_interrupt(substream) < 0)
+	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
 		goto _end;
 
 	if (substream->timer_running)

commit 4d96eb255c53ab5e39b37fd4d484ea3dc39ab456
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Sun Dec 20 11:47:57 2009 +0100

    ALSA: pcm_lib - add possibility to log last 10 DMA ring buffer positions
    
    In some debug cases, it might be usefull to see previous ring buffer
    positions to determine position problems from the lowlevel drivers.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 9621236b2fef..1990afb8a735 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -126,34 +126,34 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 	}
 }
 
+static void pcm_debug_name(struct snd_pcm_substream *substream,
+			   char *name, size_t len)
+{
+	snprintf(name, len, "pcmC%dD%d%c:%d",
+		 substream->pcm->card->number,
+		 substream->pcm->device,
+		 substream->stream ? 'c' : 'p',
+		 substream->number);
+}
+
 #define XRUN_DEBUG_BASIC	(1<<0)
 #define XRUN_DEBUG_STACK	(1<<1)	/* dump also stack */
 #define XRUN_DEBUG_JIFFIESCHECK	(1<<2)	/* do jiffies check */
 #define XRUN_DEBUG_PERIODUPDATE	(1<<3)	/* full period update info */
 #define XRUN_DEBUG_HWPTRUPDATE	(1<<4)	/* full hwptr update info */
+#define XRUN_DEBUG_LOG		(1<<5)	/* show last 10 positions on err */
+#define XRUN_DEBUG_LOGONCE	(1<<6)	/* do above only once */
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
+
 #define xrun_debug(substream, mask) \
 			((substream)->pstr->xrun_debug & (mask))
-#else
-#define xrun_debug(substream, mask)	0
-#endif
 
 #define dump_stack_on_xrun(substream) do {			\
 		if (xrun_debug(substream, XRUN_DEBUG_STACK))	\
 			dump_stack();				\
 	} while (0)
 
-static void pcm_debug_name(struct snd_pcm_substream *substream,
-			   char *name, size_t len)
-{
-	snprintf(name, len, "pcmC%dD%d%c:%d",
-		 substream->pcm->card->number,
-		 substream->pcm->device,
-		 substream->stream ? 'c' : 'p',
-		 substream->number);
-}
-
 static void xrun(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -169,6 +169,102 @@ static void xrun(struct snd_pcm_substream *substream)
 	}
 }
 
+#define hw_ptr_error(substream, fmt, args...)				\
+	do {								\
+		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
+			if (printk_ratelimit()) {			\
+				snd_printd("PCM: " fmt, ##args);	\
+			}						\
+			dump_stack_on_xrun(substream);			\
+		}							\
+	} while (0)
+
+#define XRUN_LOG_CNT	10
+
+struct hwptr_log_entry {
+	unsigned long jiffies;
+	snd_pcm_uframes_t pos;
+	snd_pcm_uframes_t period_size;
+	snd_pcm_uframes_t buffer_size;
+	snd_pcm_uframes_t old_hw_ptr;
+	snd_pcm_uframes_t hw_ptr_base;
+	snd_pcm_uframes_t hw_ptr_interrupt;
+};
+
+struct snd_pcm_hwptr_log {
+	unsigned int idx;
+	unsigned int hit: 1;
+	struct hwptr_log_entry entries[XRUN_LOG_CNT];
+};
+
+static void xrun_log(struct snd_pcm_substream *substream,
+		     snd_pcm_uframes_t pos)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_pcm_hwptr_log *log = runtime->hwptr_log;
+	struct hwptr_log_entry *entry;
+
+	if (log == NULL) {
+		log = kzalloc(sizeof(*log), GFP_ATOMIC);
+		if (log == NULL)
+			return;
+		runtime->hwptr_log = log;
+	} else {
+		if (xrun_debug(substream, XRUN_DEBUG_LOGONCE) && log->hit)
+			return;
+	}
+	entry = &log->entries[log->idx];
+	entry->jiffies = jiffies;
+	entry->pos = pos;
+	entry->period_size = runtime->period_size;
+	entry->buffer_size = runtime->buffer_size;;
+	entry->old_hw_ptr = runtime->status->hw_ptr;
+	entry->hw_ptr_base = runtime->hw_ptr_base;
+	entry->hw_ptr_interrupt = runtime->hw_ptr_interrupt;;
+	log->idx = (log->idx + 1) % XRUN_LOG_CNT;
+}
+
+static void xrun_log_show(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_hwptr_log *log = substream->runtime->hwptr_log;
+	struct hwptr_log_entry *entry;
+	char name[16];
+	unsigned int idx;
+	int cnt;
+
+	if (log == NULL)
+		return;
+	if (xrun_debug(substream, XRUN_DEBUG_LOGONCE) && log->hit)
+		return;
+	pcm_debug_name(substream, name, sizeof(name));
+	for (cnt = 0, idx = log->idx; cnt < XRUN_LOG_CNT; cnt++) {
+		entry = &log->entries[idx];
+		if (entry->period_size == 0)
+			break;
+		snd_printd("hwptr log: %s: j=%lu, pos=0x%lx/0x%lx/0x%lx, "
+			   "hwptr=0x%lx, hw_base=0x%lx, hw_intr=0x%lx\n",
+			   name, entry->jiffies, (unsigned long)entry->pos,
+			   (unsigned long)entry->period_size,
+			   (unsigned long)entry->buffer_size,
+			   (unsigned long)entry->old_hw_ptr,
+			   (unsigned long)entry->hw_ptr_base,
+			   (unsigned long)entry->hw_ptr_interrupt);
+		idx++;
+		idx %= XRUN_LOG_CNT;
+	}
+	log->hit = 1;
+}
+
+#else /* ! CONFIG_SND_PCM_XRUN_DEBUG */
+
+#define xrun_debug(substream, mask)	0
+#define xrun(substream)			do { } while (0)
+#define hw_ptr_error(substream, fmt, args...) do { } while (0)
+#define xrun_log(substream, pos)	do { } while (0)
+#define xrun_log_show(substream)	do { } while (0)
+
+#endif
+
 static snd_pcm_uframes_t
 snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
 			  struct snd_pcm_runtime *runtime)
@@ -182,6 +278,7 @@ snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
 		if (printk_ratelimit()) {
 			char name[16];
 			pcm_debug_name(substream, name, sizeof(name));
+			xrun_log_show(substream);
 			snd_printd(KERN_ERR  "BUG: %s, pos = 0x%lx, "
 				   "buffer size = 0x%lx, period size = 0x%lx\n",
 				   name, pos, runtime->buffer_size,
@@ -190,6 +287,8 @@ snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
 		pos = 0;
 	}
 	pos -= pos % runtime->min_align;
+	if (xrun_debug(substream, XRUN_DEBUG_LOG))
+		xrun_log(substream, pos);
 	return pos;
 }
 
@@ -220,16 +319,6 @@ static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-#define hw_ptr_error(substream, fmt, args...)				\
-	do {								\
-		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
-			if (printk_ratelimit()) {			\
-				snd_printd("PCM: " fmt, ##args);	\
-			}						\
-			dump_stack_on_xrun(substream);			\
-		}							\
-	} while (0)
-
 static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -270,6 +359,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 		if (runtime->periods == 1 || new_hw_ptr < old_hw_ptr)
 			delta += runtime->buffer_size;
 		if (delta < 0) {
+			xrun_log_show(substream);
 			hw_ptr_error(substream, 
 				     "Unexpected hw_pointer value "
 				     "(stream=%i, pos=%ld, intr_ptr=%ld)\n",
@@ -315,6 +405,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 		delta = jdelta /
 			(((runtime->period_size * HZ) / runtime->rate)
 								+ HZ/100);
+		xrun_log_show(substream);
 		hw_ptr_error(substream,
 			     "hw_ptr skipping! [Q] "
 			     "(pos=%ld, delta=%ld, period=%ld, "
@@ -334,6 +425,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	}
  no_jiffies_check:
 	if (delta > runtime->period_size + runtime->period_size / 2) {
+		xrun_log_show(substream);
 		hw_ptr_error(substream,
 			     "Lost interrupts? "
 			     "(stream=%i, delta=%ld, intr_ptr=%ld)\n",
@@ -397,6 +489,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 	if (delta < 0) {
 		delta += runtime->buffer_size;
 		if (delta < 0) {
+			xrun_log_show(substream);
 			hw_ptr_error(substream, 
 				     "Unexpected hw_pointer value [2] "
 				     "(stream=%i, pos=%ld, old_ptr=%ld, jdelta=%li)\n",
@@ -416,6 +509,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 		goto no_jiffies_check;
 	delta -= runtime->delay;
 	if (((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
+		xrun_log_show(substream);
 		hw_ptr_error(substream,
 			     "hw_ptr skipping! "
 			     "(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu)\n",

commit 741b20cfb9109760937f403d18d731bfde31f56f
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Dec 17 17:34:39 2009 +0100

    ALSA: pcm_lib.c - convert second xrun_debug() parameter to use defines
    
    To increase code readability, convert send xrun_debug() argument to
    use defines.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 30f410832a25..9621236b2fef 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -126,15 +126,22 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 	}
 }
 
+#define XRUN_DEBUG_BASIC	(1<<0)
+#define XRUN_DEBUG_STACK	(1<<1)	/* dump also stack */
+#define XRUN_DEBUG_JIFFIESCHECK	(1<<2)	/* do jiffies check */
+#define XRUN_DEBUG_PERIODUPDATE	(1<<3)	/* full period update info */
+#define XRUN_DEBUG_HWPTRUPDATE	(1<<4)	/* full hwptr update info */
+
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
-#define xrun_debug(substream, mask)	((substream)->pstr->xrun_debug & (mask))
+#define xrun_debug(substream, mask) \
+			((substream)->pstr->xrun_debug & (mask))
 #else
 #define xrun_debug(substream, mask)	0
 #endif
 
-#define dump_stack_on_xrun(substream) do {		\
-		if (xrun_debug(substream, 2))		\
-			dump_stack();			\
+#define dump_stack_on_xrun(substream) do {			\
+		if (xrun_debug(substream, XRUN_DEBUG_STACK))	\
+			dump_stack();				\
 	} while (0)
 
 static void pcm_debug_name(struct snd_pcm_substream *substream,
@@ -154,7 +161,7 @@ static void xrun(struct snd_pcm_substream *substream)
 	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
 		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
-	if (xrun_debug(substream, 1)) {
+	if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {
 		char name[16];
 		pcm_debug_name(substream, name, sizeof(name));
 		snd_printd(KERN_DEBUG "XRUN: %s\n", name);
@@ -215,7 +222,7 @@ static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
 
 #define hw_ptr_error(substream, fmt, args...)				\
 	do {								\
-		if (xrun_debug(substream, 1)) {				\
+		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
 			if (printk_ratelimit()) {			\
 				snd_printd("PCM: " fmt, ##args);	\
 			}						\
@@ -237,7 +244,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 		xrun(substream);
 		return -EPIPE;
 	}
-	if (xrun_debug(substream, 8)) {
+	if (xrun_debug(substream, XRUN_DEBUG_PERIODUPDATE)) {
 		char name[16];
 		pcm_debug_name(substream, name, sizeof(name));
 		snd_printd("period_update: %s: pos=0x%x/0x%x/0x%x, "
@@ -290,7 +297,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	}
 
 	/* Do jiffies check only in xrun_debug mode */
-	if (!xrun_debug(substream, 4))
+	if (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))
 		goto no_jiffies_check;
 
 	/* Skip the jiffies check for hardwares with BATCH flag.
@@ -369,7 +376,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 		xrun(substream);
 		return -EPIPE;
 	}
-	if (xrun_debug(substream, 16)) {
+	if (xrun_debug(substream, XRUN_DEBUG_HWPTRUPDATE)) {
 		char name[16];
 		pcm_debug_name(substream, name, sizeof(name));
 		snd_printd("hw_update: %s: pos=0x%x/0x%x/0x%x, "
@@ -403,7 +410,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 		new_hw_ptr = hw_base + pos;
 	}
 	/* Do jiffies check only in xrun_debug mode */
-	if (!xrun_debug(substream, 4))
+	if (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))
 		goto no_jiffies_check;
 	if (delta < runtime->delay)
 		goto no_jiffies_check;

commit 8374e24c23448cabf6e78db2c83841c56c5df1e1
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Mon Dec 21 17:07:08 2009 +0100

    ALSA: refine rate selection in snd_interval_ratnum()
    
    Refine the rate selection by choosing the rate
    closer to the requested one in case of selecting
    single frequency. Previously, the higher rate was
    always selected.
    
    Also, fix problem with the best_diff unsigned int
    value wrapping (turning negative).
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a27545b23ee9..b07cc361afb1 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -745,10 +745,13 @@ int snd_interval_ratnum(struct snd_interval *i,
 			unsigned int rats_count, struct snd_ratnum *rats,
 			unsigned int *nump, unsigned int *denp)
 {
-	unsigned int best_num, best_diff, best_den;
+	unsigned int best_num, best_den;
+	int best_diff;
 	unsigned int k;
 	struct snd_interval t;
 	int err;
+	unsigned int result_num, result_den;
+	int result_diff;
 
 	best_num = best_den = best_diff = 0;
 	for (k = 0; k < rats_count; ++k) {
@@ -770,6 +773,8 @@ int snd_interval_ratnum(struct snd_interval *i,
 				den -= r;
 		}
 		diff = num - q * den;
+		if (diff < 0)
+			diff = -diff;
 		if (best_num == 0 ||
 		    diff * best_den < best_diff * den) {
 			best_diff = diff;
@@ -784,6 +789,9 @@ int snd_interval_ratnum(struct snd_interval *i,
 	t.min = div_down(best_num, best_den);
 	t.openmin = !!(best_num % best_den);
 	
+	result_num = best_num;
+	result_diff = best_diff;
+	result_den = best_den;
 	best_num = best_den = best_diff = 0;
 	for (k = 0; k < rats_count; ++k) {
 		unsigned int num = rats[k].num;
@@ -806,6 +814,8 @@ int snd_interval_ratnum(struct snd_interval *i,
 				den += rats[k].den_step - r;
 		}
 		diff = q * den - num;
+		if (diff < 0)
+			diff = -diff;
 		if (best_num == 0 ||
 		    diff * best_den < best_diff * den) {
 			best_diff = diff;
@@ -825,10 +835,14 @@ int snd_interval_ratnum(struct snd_interval *i,
 		return err;
 
 	if (snd_interval_single(i)) {
+		if (best_diff * result_den < result_diff * best_den) {
+			result_num = best_num;
+			result_den = best_den;
+		}
 		if (nump)
-			*nump = best_num;
+			*nump = result_num;
 		if (denp)
-			*denp = best_den;
+			*denp = result_den;
 	}
 	return err;
 }

commit 40962d7c741de1c21b6ce8516c1d9f8836fb383e
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sat Dec 19 18:31:04 2009 +0100

    ALSA: fix incorrect rounding direction in snd_interval_ratnum()
    
    The direction of rounding is incorrect in the snd_interval_ratnum()
    It was detected with following parameters (sb8 driver playing
    8kHz stereo file):
     - num is always 1000000
     - requested frequency rate is from 7999 to 7999 (single frequency)
    
    The first loop calculates div_down(num, freq->min) which is 125.
    Thus, a frequency range's minimum value is 1000000 / 125 = 8000 Hz.
    The second loop calculates div_up(num, freq->max) which is 126
    The frequency range's maximum value is 1000000 / 126 = 7936 Hz.
    The range maximum is lower than the range minimum so the function
    fails due to empty result range.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 30f410832a25..a27545b23ee9 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -758,7 +758,7 @@ int snd_interval_ratnum(struct snd_interval *i,
 		int diff;
 		if (q == 0)
 			q = 1;
-		den = div_down(num, q);
+		den = div_up(num, q);
 		if (den < rats[k].den_min)
 			continue;
 		if (den > rats[k].den_max)
@@ -794,7 +794,7 @@ int snd_interval_ratnum(struct snd_interval *i,
 			i->empty = 1;
 			return -EINVAL;
 		}
-		den = div_up(num, q);
+		den = div_down(num, q);
 		if (den > rats[k].den_max)
 			continue;
 		if (den < rats[k].den_min)

commit 2c0d19a78de1ea5d0e92d86be0b16ccab0feccec
Merge: 05a33e3d6fdc 5a53a7640a7a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 10 15:33:00 2009 +0200

    Merge branch 'topic/pcm-drain-nonblock' into for-linus
    
    * topic/pcm-drain-nonblock:
      ALSA: pcm - Increase protocol version
      ALSA: pcm - Fix drain behavior in non-blocking mode

commit a206e9417f19cf42156249953b72223a0076dc6b
Merge: 7cafe6055046 b1ddaf681e36
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 25 09:47:06 2009 -0700

    Merge branch 'fix/misc' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'fix/misc' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6:
      sound: pcm_lib: fix unsorted list constraint handling
      sound: vx222: fix input level control range check
      ALSA: ali5451: fix timeout handling in snd_ali_{codecs,timer}_ready()

commit b1ddaf681e362ed453182ddee1699d7487069a16
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Aug 25 08:15:41 2009 +0200

    sound: pcm_lib: fix unsorted list constraint handling
    
    snd_interval_list() expected a sorted list but did not document this, so
    there are drivers that give it an unsorted list.  To fix this, change
    the algorithm to work with any list.
    
    This fixes the "Slave PCM not usable" error with USB devices that have
    multiple alternate settings with sample rates in decreasing order, such
    as the Philips Askey VC010 WebCam.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=14028
    
    Reported-and-tested-by: Andrzej <adkadk@gmail.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 333e4dd29450..d8a7bb28cd83 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -909,47 +909,24 @@ static int snd_interval_ratden(struct snd_interval *i,
 int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *list, unsigned int mask)
 {
         unsigned int k;
-	int changed = 0;
+	struct snd_interval list_range;
 
 	if (!count) {
 		i->empty = 1;
 		return -EINVAL;
 	}
+	snd_interval_any(&list_range);
+	list_range.min = UINT_MAX;
+	list_range.max = 0;
         for (k = 0; k < count; k++) {
 		if (mask && !(mask & (1 << k)))
 			continue;
-                if (i->min == list[k] && !i->openmin)
-                        goto _l1;
-                if (i->min < list[k]) {
-                        i->min = list[k];
-			i->openmin = 0;
-			changed = 1;
-                        goto _l1;
-                }
-        }
-        i->empty = 1;
-        return -EINVAL;
- _l1:
-        for (k = count; k-- > 0;) {
-		if (mask && !(mask & (1 << k)))
+		if (!snd_interval_test(i, list[k]))
 			continue;
-                if (i->max == list[k] && !i->openmax)
-                        goto _l2;
-                if (i->max > list[k]) {
-                        i->max = list[k];
-			i->openmax = 0;
-			changed = 1;
-                        goto _l2;
-                }
+		list_range.min = min(list_range.min, list[k]);
+		list_range.max = max(list_range.max, list[k]);
         }
-        i->empty = 1;
-        return -EINVAL;
- _l2:
-	if (snd_interval_checkempty(i)) {
-		i->empty = 1;
-		return -EINVAL;
-	}
-        return changed;
+	return snd_interval_refine(i, &list_range);
 }
 
 EXPORT_SYMBOL(snd_interval_list);

commit 4cdc115fd38b54642e8536a5c2389483bcb9b2e9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 20 16:40:16 2009 +0200

    ALSA: pcm - Fix drain behavior in non-blocking mode
    
    The current PCM core has the following problems regarding PCM draining
    in non-blocking mode:
    
    - the current f_flags isn't checked in snd_pcm_drain(), thus changing
      the mode dynamically via snd_pcm_nonblock() after open doesn't work.
    - calling drain in non-blocking mode just return -EAGAIN error, but
      doesn't provide any way to sync with draining.
    
    This patch fixes these issues.
    - check file->f_flags in snd_pcm_drain() properly
    - when O_NONBLOCK is set, PCM core sets the stream(s) to DRAIN state
      but quits ioctl immediately without waiting the whole drain; the
      caller can sync the drain manually via poll()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 72cfd47af6b8..e3e78c7f2745 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -197,12 +197,16 @@ static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
 		avail = snd_pcm_capture_avail(runtime);
 	if (avail > runtime->avail_max)
 		runtime->avail_max = avail;
-	if (avail >= runtime->stop_threshold) {
-		if (substream->runtime->status->state == SNDRV_PCM_STATE_DRAINING)
+	if (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
+		if (avail >= runtime->buffer_size) {
 			snd_pcm_drain_done(substream);
-		else
+			return -EPIPE;
+		}
+	} else {
+		if (avail >= runtime->stop_threshold) {
 			xrun(substream);
-		return -EPIPE;
+			return -EPIPE;
+		}
 	}
 	if (avail >= runtime->control->avail_min)
 		wake_up(&runtime->sleep);

commit 947ca210f1df7656e19890832cb71fc3bdd88707
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 23 16:21:08 2009 +0200

    ALSA: pcm - Fix hwptr buffer-size overlap bug
    
    The fix 79452f0a28aa5a40522c487b42a5fc423647ad98 introduced another
    bug due to the missing offset for the overlapped hwptr.
    When the hwptr goes back to zero, the delta value has to be corrected
    with the buffer size.  Otherwise this causes looping sounds.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index d315f72949f4..72cfd47af6b8 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -256,7 +256,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 			delta = new_hw_ptr - hw_ptr_interrupt;
 	}
 	if (delta < 0) {
-		if (runtime->periods == 1)
+		if (runtime->periods == 1 || new_hw_ptr < old_hw_ptr)
 			delta += runtime->buffer_size;
 		if (delta < 0) {
 			hw_ptr_error(substream, 

commit 89350640439e0160056de26995d52deb18202b3e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 23 14:28:37 2009 +0200

    ALSA: pcm - Fix warnings in debug loggings
    
    Add proper cast.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 065eaf0a386c..d315f72949f4 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -238,12 +238,12 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 		pcm_debug_name(substream, name, sizeof(name));
 		snd_printd("period_update: %s: pos=0x%x/0x%x/0x%x, "
 			   "hwptr=0x%lx, hw_base=0x%lx, hw_intr=0x%lx\n",
-			   name, pos,
-			   (int)runtime->period_size,
-			   (int)runtime->buffer_size,
-			   (long)old_hw_ptr,
-			   (long)runtime->hw_ptr_base,
-			   (long)runtime->hw_ptr_interrupt);
+			   name, (unsigned int)pos,
+			   (unsigned int)runtime->period_size,
+			   (unsigned int)runtime->buffer_size,
+			   (unsigned long)old_hw_ptr,
+			   (unsigned long)runtime->hw_ptr_base,
+			   (unsigned long)runtime->hw_ptr_interrupt);
 	}
 	hw_base = runtime->hw_ptr_base;
 	new_hw_ptr = hw_base + pos;
@@ -370,12 +370,12 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 		pcm_debug_name(substream, name, sizeof(name));
 		snd_printd("hw_update: %s: pos=0x%x/0x%x/0x%x, "
 			   "hwptr=0x%lx, hw_base=0x%lx, hw_intr=0x%lx\n",
-			   name, pos,
-			   (int)runtime->period_size,
-			   (int)runtime->buffer_size,
-			   (long)old_hw_ptr,
-			   (long)runtime->hw_ptr_base,
-			   (long)runtime->hw_ptr_interrupt);
+			   name, (unsigned int)pos,
+			   (unsigned int)runtime->period_size,
+			   (unsigned int)runtime->buffer_size,
+			   (unsigned long)old_hw_ptr,
+			   (unsigned long)runtime->hw_ptr_base,
+			   (unsigned long)runtime->hw_ptr_interrupt);
 	}
 
 	hw_base = runtime->hw_ptr_base;

commit cedb8118e8cef21a2b73fd9cb70660ac19124c16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 23 11:04:13 2009 +0200

    ALSA: pcm - Add logging of hwptr updates and interrupt updates
    
    Added the logging functionality to xrun_debug to record the hwptr
    updates via snd_pcm_update_hw_ptr() and snd_pcm_update_hwptr_interrupt(),
    corresponding to 16 and 8, respectively.
    
    For example,
            # echo 9 > /proc/asound/card0/pcm0p/xrun_debug
    will record the position and other parameters at each period interrupt
    together with the normal XRUN debugging.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3b673e2f991d..065eaf0a386c 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -233,6 +233,18 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 		xrun(substream);
 		return -EPIPE;
 	}
+	if (xrun_debug(substream, 8)) {
+		char name[16];
+		pcm_debug_name(substream, name, sizeof(name));
+		snd_printd("period_update: %s: pos=0x%x/0x%x/0x%x, "
+			   "hwptr=0x%lx, hw_base=0x%lx, hw_intr=0x%lx\n",
+			   name, pos,
+			   (int)runtime->period_size,
+			   (int)runtime->buffer_size,
+			   (long)old_hw_ptr,
+			   (long)runtime->hw_ptr_base,
+			   (long)runtime->hw_ptr_interrupt);
+	}
 	hw_base = runtime->hw_ptr_base;
 	new_hw_ptr = hw_base + pos;
 	hw_ptr_interrupt = runtime->hw_ptr_interrupt + runtime->period_size;
@@ -353,6 +365,19 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 		xrun(substream);
 		return -EPIPE;
 	}
+	if (xrun_debug(substream, 16)) {
+		char name[16];
+		pcm_debug_name(substream, name, sizeof(name));
+		snd_printd("hw_update: %s: pos=0x%x/0x%x/0x%x, "
+			   "hwptr=0x%lx, hw_base=0x%lx, hw_intr=0x%lx\n",
+			   name, pos,
+			   (int)runtime->period_size,
+			   (int)runtime->buffer_size,
+			   (long)old_hw_ptr,
+			   (long)runtime->hw_ptr_base,
+			   (long)runtime->hw_ptr_interrupt);
+	}
+
 	hw_base = runtime->hw_ptr_base;
 	new_hw_ptr = hw_base + pos;
 

commit 79452f0a28aa5a40522c487b42a5fc423647ad98
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 22 12:51:51 2009 +0200

    ALSA: pcm - Fix regressions with VMware
    
    VMware tends to report PCM positions and period updates at utterly
    wrong timing.  This screws up the recent PCM core code that tries
    to correct the position based on the irq timing.
    
    Now, when a backward irq position is detected, skip the update
    instead of rebasing.  (This is almost the old behavior before
    2.6.30.)
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 333e4dd29450..3b673e2f991d 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -244,18 +244,27 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 			delta = new_hw_ptr - hw_ptr_interrupt;
 	}
 	if (delta < 0) {
-		delta += runtime->buffer_size;
+		if (runtime->periods == 1)
+			delta += runtime->buffer_size;
 		if (delta < 0) {
 			hw_ptr_error(substream, 
 				     "Unexpected hw_pointer value "
 				     "(stream=%i, pos=%ld, intr_ptr=%ld)\n",
 				     substream->stream, (long)pos,
 				     (long)hw_ptr_interrupt);
+#if 1
+			/* simply skipping the hwptr update seems more
+			 * robust in some cases, e.g. on VMware with
+			 * inaccurate timer source
+			 */
+			return 0; /* skip this update */
+#else
 			/* rebase to interrupt position */
 			hw_base = new_hw_ptr = hw_ptr_interrupt;
 			/* align hw_base to buffer_size */
 			hw_base -= hw_base % runtime->buffer_size;
 			delta = 0;
+#endif
 		} else {
 			hw_base += runtime->buffer_size;
 			if (hw_base >= runtime->boundary)

commit 3b88bc522986ae853670fcba71bb3761c84f7867
Merge: eabaf0634a90 c00701101b82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 10 07:26:41 2009 +0200

    Merge branch 'topic/pcm-jiffies-check' into for-linus
    
    * topic/pcm-jiffies-check:
      ALSA: pcm - A helper function to compose PCM stream name for debug prints
      ALSA: pcm - Fix update of runtime->hw_ptr_interrupt
      ALSA: pcm - Fix a typo in hw_ptr update check
      ALSA: PCM midlevel: lower jiffies check margin using runtime->delay value
      ALSA: PCM midlevel: Do not update hw_ptr_jiffies when hw_ptr is not changed
      ALSA: PCM midlevel: introduce mask for xrun_debug() macro
      ALSA: PCM midlevel: improve fifo_size handling

commit c00701101b82f2bc61dfc259748ec6e5288af6a9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jun 8 15:58:48 2009 +0200

    ALSA: pcm - A helper function to compose PCM stream name for debug prints
    
    Use a common helper function for the PCM stream name displayed in
    XRUN and buffer-pointer debug prints.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index adb306fd5525..2288fa07bf59 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -136,6 +136,16 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 			dump_stack();			\
 	} while (0)
 
+static void pcm_debug_name(struct snd_pcm_substream *substream,
+			   char *name, size_t len)
+{
+	snprintf(name, len, "pcmC%dD%d%c:%d",
+		 substream->pcm->card->number,
+		 substream->pcm->device,
+		 substream->stream ? 'c' : 'p',
+		 substream->number);
+}
+
 static void xrun(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -144,10 +154,9 @@ static void xrun(struct snd_pcm_substream *substream)
 		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	if (xrun_debug(substream, 1)) {
-		snd_printd(KERN_DEBUG "XRUN: pcmC%dD%d%c\n",
-			   substream->pcm->card->number,
-			   substream->pcm->device,
-			   substream->stream ? 'c' : 'p');
+		char name[16];
+		pcm_debug_name(substream, name, sizeof(name));
+		snd_printd(KERN_DEBUG "XRUN: %s\n", name);
 		dump_stack_on_xrun(substream);
 	}
 }
@@ -163,9 +172,11 @@ snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
 		return pos; /* XRUN */
 	if (pos >= runtime->buffer_size) {
 		if (printk_ratelimit()) {
-			snd_printd(KERN_ERR  "BUG: stream = %i, pos = 0x%lx, "
+			char name[16];
+			pcm_debug_name(substream, name, sizeof(name));
+			snd_printd(KERN_ERR  "BUG: %s, pos = 0x%lx, "
 				   "buffer size = 0x%lx, period size = 0x%lx\n",
-				   substream->stream, pos, runtime->buffer_size,
+				   name, pos, runtime->buffer_size,
 				   runtime->period_size);
 		}
 		pos = 0;

commit ab1863fc9bc18c806338564124b1e5e7e3ef53d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jun 7 12:09:17 2009 +0200

    ALSA: pcm - Fix update of runtime->hw_ptr_interrupt
    
    The commit 13f040f9e55d41e92e485389123654971e03b819 made another
    regression, the missing update of runtime->hw_ptr_interrupt.
    Since this field is only checked in snd_pcmupdate__hw_ptr_interrupt(),
    not in snd_pcm_update_hw_ptr(), it must be updated before the hw_ptr
    change check.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index bf34603a7a38..adb306fd5525 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -299,6 +299,8 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 		hw_ptr_interrupt =
 			new_hw_ptr - new_hw_ptr % runtime->period_size;
 	}
+	runtime->hw_ptr_interrupt = hw_ptr_interrupt;
+
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);
@@ -309,7 +311,6 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
 	runtime->hw_ptr_jiffies = jiffies;
-	runtime->hw_ptr_interrupt = hw_ptr_interrupt;
 	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
 		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 

commit d86bf92313bfd47885a92c7de63bde392d585f95
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Sat Jun 6 18:32:06 2009 +0200

    ALSA: pcm - Fix a typo in hw_ptr update check
    
    Fix a typo in the commit 13f040f9e55d41e92e485389123654971e03b819
      ALSA: PCM midlevel: Do not update hw_ptr_jiffies when hw_ptr is not changed
    which causes obvious problems with PA.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index dd9126b92c19..bf34603a7a38 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -371,7 +371,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);
 
-	if (runtime->status->hw_ptr != new_hw_ptr)
+	if (runtime->status->hw_ptr == new_hw_ptr)
 		return 0;
 
 	runtime->hw_ptr_base = hw_base;

commit 3f7440a6b771169e1f11fa582e53a4259b682809
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 5 17:40:04 2009 +0200

    ALSA: Clean up 64bit division functions
    
    Replace the house-made div64_32() with the standard div_u64*() functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index d659995ac3ac..a7482874c451 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -22,6 +22,7 @@
 
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/math64.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/info.h>
@@ -452,7 +453,7 @@ static inline unsigned int muldiv32(unsigned int a, unsigned int b,
 		*r = 0;
 		return UINT_MAX;
 	}
-	div64_32(&n, c, r);
+	n = div_u64_rem(n, c, r);
 	if (n >= UINT_MAX) {
 		*r = 0;
 		return UINT_MAX;

commit a4444da31ec92f89cd6923579c20a9c240439cfc
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu May 28 12:31:56 2009 +0200

    ALSA: PCM midlevel: lower jiffies check margin using runtime->delay value
    
    When hardware has large FIFO, it is necessary to lower jiffies margin
    by count of queued samples.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 0f299a5ad6da..dd9126b92c19 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -263,6 +263,9 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	if (runtime->hw.info & SNDRV_PCM_INFO_BATCH)
 		goto no_jiffies_check;
 	hdelta = new_hw_ptr - old_hw_ptr;
+	if (hdelta < runtime->delay)
+		goto no_jiffies_check;
+	hdelta -= runtime->delay;
 	jdelta = jiffies - runtime->hw_ptr_jiffies;
 	if (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {
 		delta = jdelta /
@@ -349,8 +352,12 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 		new_hw_ptr = hw_base + pos;
 	}
 	/* Do jiffies check only in xrun_debug mode */
-	if (xrun_debug(substream, 4) &&
-	    ((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
+	if (!xrun_debug(substream, 4))
+		goto no_jiffies_check;
+	if (delta < runtime->delay)
+		goto no_jiffies_check;
+	delta -= runtime->delay;
+	if (((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
 		hw_ptr_error(substream,
 			     "hw_ptr skipping! "
 			     "(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu)\n",
@@ -359,6 +366,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 			     ((delta * HZ) / runtime->rate));
 		return 0;
 	}
+ no_jiffies_check:
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);

commit 13f040f9e55d41e92e485389123654971e03b819
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu May 28 11:31:20 2009 +0200

    ALSA: PCM midlevel: Do not update hw_ptr_jiffies when hw_ptr is not changed
    
    Some hardware might have bigger FIFOs and DMA pointer value will be updated
    in large chunks. Do not update hw_ptr_jiffies and position timestamp when
    hw_ptr value was not changed.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 25cb36710ef4..0f299a5ad6da 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -138,6 +138,10 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 
 static void xrun(struct snd_pcm_substream *substream)
 {
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	if (xrun_debug(substream, 1)) {
 		snd_printd(KERN_DEBUG "XRUN: pcmC%dD%d%c\n",
@@ -154,8 +158,6 @@ snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
 {
 	snd_pcm_uframes_t pos;
 
-	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
-		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 	pos = substream->ops->pointer(substream);
 	if (pos == SNDRV_PCM_POS_XRUN)
 		return pos; /* XRUN */
@@ -298,10 +300,15 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);
 
+	if (runtime->status->hw_ptr == new_hw_ptr)
+		return 0;
+
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
 	runtime->hw_ptr_jiffies = jiffies;
 	runtime->hw_ptr_interrupt = hw_ptr_interrupt;
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 
 	return snd_pcm_update_hw_ptr_post(substream, runtime);
 }
@@ -356,9 +363,14 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);
 
+	if (runtime->status->hw_ptr != new_hw_ptr)
+		return 0;
+
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
 	runtime->hw_ptr_jiffies = jiffies;
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 
 	return snd_pcm_update_hw_ptr_post(substream, runtime);
 }

commit c62a01ad6e746fae9c93f51ea67e0abfd8d94b58
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu May 28 11:21:52 2009 +0200

    ALSA: PCM midlevel: introduce mask for xrun_debug() macro
    
    For debugging purposes, it is better to separate actions.
    
    Bit-values:
    
            1: show bad PCM ring buffer pointer
            2: show also stack (to debug kernel latency issues)
            4: check pointer against system jiffies
    
    Example:
    
            5: show bad PCM ring buffer pointer and do jiffies check
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index adc2b0bd1132..25cb36710ef4 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -126,20 +126,20 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 }
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
-#define xrun_debug(substream)	((substream)->pstr->xrun_debug)
+#define xrun_debug(substream, mask)	((substream)->pstr->xrun_debug & (mask))
 #else
-#define xrun_debug(substream)	0
+#define xrun_debug(substream, mask)	0
 #endif
 
-#define dump_stack_on_xrun(substream) do {	\
-		if (xrun_debug(substream) > 1)	\
-			dump_stack();		\
+#define dump_stack_on_xrun(substream) do {		\
+		if (xrun_debug(substream, 2))		\
+			dump_stack();			\
 	} while (0)
 
 static void xrun(struct snd_pcm_substream *substream)
 {
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
-	if (xrun_debug(substream)) {
+	if (xrun_debug(substream, 1)) {
 		snd_printd(KERN_DEBUG "XRUN: pcmC%dD%d%c\n",
 			   substream->pcm->card->number,
 			   substream->pcm->device,
@@ -197,7 +197,7 @@ static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
 
 #define hw_ptr_error(substream, fmt, args...)				\
 	do {								\
-		if (xrun_debug(substream)) {				\
+		if (xrun_debug(substream, 1)) {				\
 			if (printk_ratelimit()) {			\
 				snd_printd("PCM: " fmt, ##args);	\
 			}						\
@@ -251,7 +251,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	}
 
 	/* Do jiffies check only in xrun_debug mode */
-	if (!xrun_debug(substream))
+	if (!xrun_debug(substream, 4))
 		goto no_jiffies_check;
 
 	/* Skip the jiffies check for hardwares with BATCH flag.
@@ -342,7 +342,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 		new_hw_ptr = hw_base + pos;
 	}
 	/* Do jiffies check only in xrun_debug mode */
-	if (xrun_debug(substream) &&
+	if (xrun_debug(substream, 4) &&
 	    ((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
 		hw_ptr_error(substream,
 			     "hw_ptr skipping! "

commit 8bea869c5e56234990e6bad92a543437115bfc18
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Apr 27 09:44:40 2009 +0200

    ALSA: PCM midlevel: improve fifo_size handling
    
    Move the fifo_size assignment to hw->ioctl callback to allow lowlevel
    drivers overwrite the default behaviour.
    
    fifo_size is in frames not bytes as specified in asound.h and alsa-lib's
    documentation, but most hardware have fixed byte based FIFOs. Introduce
    internal SNDRV_PCM_INFO_FIFO_IN_FRAMES.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index d659995ac3ac..adc2b0bd1132 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1524,6 +1524,23 @@ static int snd_pcm_lib_ioctl_channel_info(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static int snd_pcm_lib_ioctl_fifo_size(struct snd_pcm_substream *substream,
+				       void *arg)
+{
+	struct snd_pcm_hw_params *params = arg;
+	snd_pcm_format_t format;
+	int channels, width;
+
+	params->fifo_size = substream->runtime->hw.fifo_size;
+	if (!(substream->runtime->hw.info & SNDRV_PCM_INFO_FIFO_IN_FRAMES)) {
+		format = params_format(params);
+		channels = params_channels(params);
+		width = snd_pcm_format_physical_width(format);
+		params->fifo_size /= width * channels;
+	}
+	return 0;
+}
+
 /**
  * snd_pcm_lib_ioctl - a generic PCM ioctl callback
  * @substream: the pcm substream instance
@@ -1545,6 +1562,8 @@ int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		return snd_pcm_lib_ioctl_reset(substream, arg);
 	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
 		return snd_pcm_lib_ioctl_channel_info(substream, arg);
+	case SNDRV_PCM_IOCTL1_FIFO_SIZE:
+		return snd_pcm_lib_ioctl_fifo_size(substream, arg);
 	}
 	return -ENXIO;
 }

commit c87d9732004b3f8fd82d729f12ccfb96c0df279e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 27 10:53:33 2009 +0200

    ALSA: Enable PCM hw_ptr_jiffies check only in xrun_debug mode
    
    The PCM hw_ptr jiffies check results sometimes in problems when a
    hardware doesn't give smooth hw_ptr updates.  So far, au88x0 and some
    other drivers appear not working due to this strict check.
    However, this check is a nice debug tool, and the capability should be
    still kept.
    
    Hence, we disable this check now as default unless the user enables it
    by setting the xrun_debug mode to the specific stream via a proc file.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3eea98a4e65a..d659995ac3ac 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -249,6 +249,11 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 			new_hw_ptr = hw_base + pos;
 		}
 	}
+
+	/* Do jiffies check only in xrun_debug mode */
+	if (!xrun_debug(substream))
+		goto no_jiffies_check;
+
 	/* Skip the jiffies check for hardwares with BATCH flag.
 	 * Such hardware usually just increases the position at each IRQ,
 	 * thus it can't give any strange position.
@@ -336,7 +341,9 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 			hw_base = 0;
 		new_hw_ptr = hw_base + pos;
 	}
-	if (((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
+	/* Do jiffies check only in xrun_debug mode */
+	if (xrun_debug(substream) &&
+	    ((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
 		hw_ptr_error(substream,
 			     "hw_ptr skipping! "
 			     "(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu)\n",

commit 6af3fb72d2437239e5eb13a59e95dc43ccab3e8f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 27 10:49:26 2009 +0200

    ALSA: Fix invalid jiffies check after pause
    
    The hw_ptr_jiffies has to be reset properly to avoid the invalid
    check of jiffies delta in snd_pcm_update_hw_ptr*() functions.
    Especailly this patch fixes the bogus jiffies check after the puase
    and resume.
    
    This patch is a modified version of the original patch by Jaroslav.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a2a792c18c40..3eea98a4e65a 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1478,7 +1478,6 @@ static int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,
 		runtime->status->hw_ptr %= runtime->buffer_size;
 	else
 		runtime->status->hw_ptr = 0;
-	runtime->hw_ptr_jiffies = jiffies;
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	return 0;
 }

commit 3e5b50165fd0be080044586f43fcdd460ed27610
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 28 12:07:08 2009 +0200

    ALSA: pcm core - Avoid jiffies check for devices with BATCH flag
    
    The hardware devices with SNDRV_PCM_INFO_BATCH flag can't give the
    precise current position.  And such hardwares have often big FIFO
    in addition to the ring buffer, and it screws up the jiffies check
    in pcm_lib.c.
    
    This patch adds a simple check of info flag so that the driver skips
    the jiffies check in snd_pcm_period_elapsed() when BATCH flag is set.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 63d088f2265f..a2a792c18c40 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -249,6 +249,12 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 			new_hw_ptr = hw_base + pos;
 		}
 	}
+	/* Skip the jiffies check for hardwares with BATCH flag.
+	 * Such hardware usually just increases the position at each IRQ,
+	 * thus it can't give any strange position.
+	 */
+	if (runtime->hw.info & SNDRV_PCM_INFO_BATCH)
+		goto no_jiffies_check;
 	hdelta = new_hw_ptr - old_hw_ptr;
 	jdelta = jiffies - runtime->hw_ptr_jiffies;
 	if (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {
@@ -272,6 +278,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 		hw_base -= hw_base % runtime->buffer_size;
 		delta = 0;
 	}
+ no_jiffies_check:
 	if (delta > runtime->period_size + runtime->period_size / 2) {
 		hw_ptr_error(substream,
 			     "Lost interrupts? "

commit bbf6ad1399e9516b0a95de3ad58ffbaed670e4cc
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Apr 10 12:28:58 2009 +0200

    [ALSA] pcm-midlevel: Add more strict buffer position checks based on jiffies
    
    Some drivers like Intel8x0 or Intel HDA are broken for some hardware variants.
    This patch adds more strict buffer position checks based on jiffies when
    internal hw_ptr is updated. Enable xrun_debug to see mangling of wrong
    positions.
    
    As a side effect, the hw_ptr interrupt update routine might do slightly better
    job when many interrupts are lost.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index fbb2e391591e..63d088f2265f 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -209,9 +209,11 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t pos;
-	snd_pcm_uframes_t new_hw_ptr, hw_ptr_interrupt, hw_base;
-	snd_pcm_sframes_t delta;
+	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_ptr_interrupt, hw_base;
+	snd_pcm_sframes_t hdelta, delta;
+	unsigned long jdelta;
 
+	old_hw_ptr = runtime->status->hw_ptr;
 	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
 	if (pos == SNDRV_PCM_POS_XRUN) {
 		xrun(substream);
@@ -247,7 +249,30 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 			new_hw_ptr = hw_base + pos;
 		}
 	}
-	if (delta > runtime->period_size) {
+	hdelta = new_hw_ptr - old_hw_ptr;
+	jdelta = jiffies - runtime->hw_ptr_jiffies;
+	if (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {
+		delta = jdelta /
+			(((runtime->period_size * HZ) / runtime->rate)
+								+ HZ/100);
+		hw_ptr_error(substream,
+			     "hw_ptr skipping! [Q] "
+			     "(pos=%ld, delta=%ld, period=%ld, "
+			     "jdelta=%lu/%lu/%lu)\n",
+			     (long)pos, (long)hdelta,
+			     (long)runtime->period_size, jdelta,
+			     ((hdelta * HZ) / runtime->rate), delta);
+		hw_ptr_interrupt = runtime->hw_ptr_interrupt +
+				   runtime->period_size * delta;
+		if (hw_ptr_interrupt >= runtime->boundary)
+			hw_ptr_interrupt -= runtime->boundary;
+		/* rebase to interrupt position */
+		hw_base = new_hw_ptr = hw_ptr_interrupt;
+		/* align hw_base to buffer_size */
+		hw_base -= hw_base % runtime->buffer_size;
+		delta = 0;
+	}
+	if (delta > runtime->period_size + runtime->period_size / 2) {
 		hw_ptr_error(substream,
 			     "Lost interrupts? "
 			     "(stream=%i, delta=%ld, intr_ptr=%ld)\n",
@@ -263,6 +288,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
+	runtime->hw_ptr_jiffies = jiffies;
 	runtime->hw_ptr_interrupt = hw_ptr_interrupt;
 
 	return snd_pcm_update_hw_ptr_post(substream, runtime);
@@ -275,6 +301,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 	snd_pcm_uframes_t pos;
 	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;
 	snd_pcm_sframes_t delta;
+	unsigned long jdelta;
 
 	old_hw_ptr = runtime->status->hw_ptr;
 	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
@@ -286,14 +313,15 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 	new_hw_ptr = hw_base + pos;
 
 	delta = new_hw_ptr - old_hw_ptr;
+	jdelta = jiffies - runtime->hw_ptr_jiffies;
 	if (delta < 0) {
 		delta += runtime->buffer_size;
 		if (delta < 0) {
 			hw_ptr_error(substream, 
 				     "Unexpected hw_pointer value [2] "
-				     "(stream=%i, pos=%ld, old_ptr=%ld)\n",
+				     "(stream=%i, pos=%ld, old_ptr=%ld, jdelta=%li)\n",
 				     substream->stream, (long)pos,
-				     (long)old_hw_ptr);
+				     (long)old_hw_ptr, jdelta);
 			return 0;
 		}
 		hw_base += runtime->buffer_size;
@@ -301,12 +329,13 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 			hw_base = 0;
 		new_hw_ptr = hw_base + pos;
 	}
-	if (delta > runtime->period_size && runtime->periods > 1) {
+	if (((delta * HZ) / runtime->rate) > jdelta + HZ/100) {
 		hw_ptr_error(substream,
 			     "hw_ptr skipping! "
-			     "(pos=%ld, delta=%ld, period=%ld)\n",
+			     "(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu)\n",
 			     (long)pos, (long)delta,
-			     (long)runtime->period_size);
+			     (long)runtime->period_size, jdelta,
+			     ((delta * HZ) / runtime->rate));
 		return 0;
 	}
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
@@ -315,6 +344,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 
 	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
+	runtime->hw_ptr_jiffies = jiffies;
 
 	return snd_pcm_update_hw_ptr_post(substream, runtime);
 }
@@ -1441,6 +1471,7 @@ static int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,
 		runtime->status->hw_ptr %= runtime->buffer_size;
 	else
 		runtime->status->hw_ptr = 0;
+	runtime->hw_ptr_jiffies = jiffies;
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	return 0;
 }

commit 8b22d943c34b616eefbd6d2f8f197a53b1f29fd0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 20 16:26:15 2009 +0100

    ALSA: pcm - Safer boundary checks
    
    Make the boundary checks a bit safer.
    These caese are rare or theoretically won't happen, but nothing
    bad to keep the checks safer...
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 063c675177a9..fbb2e391591e 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -222,8 +222,9 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	hw_ptr_interrupt = runtime->hw_ptr_interrupt + runtime->period_size;
 	delta = new_hw_ptr - hw_ptr_interrupt;
 	if (hw_ptr_interrupt >= runtime->boundary) {
-		hw_ptr_interrupt %= runtime->boundary;
-		if (!hw_base) /* hw_base was already lapped; recalc delta */
+		hw_ptr_interrupt -= runtime->boundary;
+		if (hw_base < runtime->boundary / 2)
+			/* hw_base was already lapped; recalc delta */
 			delta = new_hw_ptr - hw_ptr_interrupt;
 	}
 	if (delta < 0) {
@@ -241,7 +242,7 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 			delta = 0;
 		} else {
 			hw_base += runtime->buffer_size;
-			if (hw_base == runtime->boundary)
+			if (hw_base >= runtime->boundary)
 				hw_base = 0;
 			new_hw_ptr = hw_base + pos;
 		}
@@ -296,7 +297,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 			return 0;
 		}
 		hw_base += runtime->buffer_size;
-		if (hw_base == runtime->boundary)
+		if (hw_base >= runtime->boundary)
 			hw_base = 0;
 		new_hw_ptr = hw_base + pos;
 	}

commit ded652f7024bc2d7b6118b561a44187af30841b0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 19 10:08:49 2009 +0100

    ALSA: pcm - Fix delta calculation at boundary overlap
    
    When the hw_ptr_interrupt reaches the boundary, it must check whether
    the hw_base was already lapped and corret the delta value appropriately.
    
    Also, rebasing the hw_ptr needs a correction because buffer_size isn't
    always aligned to period_size.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 92ed6d819225..063c675177a9 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -221,8 +221,11 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 	new_hw_ptr = hw_base + pos;
 	hw_ptr_interrupt = runtime->hw_ptr_interrupt + runtime->period_size;
 	delta = new_hw_ptr - hw_ptr_interrupt;
-	if (hw_ptr_interrupt == runtime->boundary)
-		hw_ptr_interrupt = 0;
+	if (hw_ptr_interrupt >= runtime->boundary) {
+		hw_ptr_interrupt %= runtime->boundary;
+		if (!hw_base) /* hw_base was already lapped; recalc delta */
+			delta = new_hw_ptr - hw_ptr_interrupt;
+	}
 	if (delta < 0) {
 		delta += runtime->buffer_size;
 		if (delta < 0) {
@@ -233,6 +236,8 @@ static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 				     (long)hw_ptr_interrupt);
 			/* rebase to interrupt position */
 			hw_base = new_hw_ptr = hw_ptr_interrupt;
+			/* align hw_base to buffer_size */
+			hw_base -= hw_base % runtime->buffer_size;
 			delta = 0;
 		} else {
 			hw_base += runtime->buffer_size;

commit 5f513e1197f27e9a0bcfec0feaac59f976f4a37e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 19 10:01:47 2009 +0100

    ALSA: pcm - Reset invalid position even without debug option
    
    Always reset the invalind hw_ptr position returned by the pointer
    callback.  The behavior should be consitent independently from the
    debug option.
    
    Also, add the printk_ratelimit() check to avoid flooding debug
    prints.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 302654769faf..92ed6d819225 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -159,11 +159,15 @@ snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
 	pos = substream->ops->pointer(substream);
 	if (pos == SNDRV_PCM_POS_XRUN)
 		return pos; /* XRUN */
-#ifdef CONFIG_SND_DEBUG
 	if (pos >= runtime->buffer_size) {
-		snd_printk(KERN_ERR  "BUG: stream = %i, pos = 0x%lx, buffer size = 0x%lx, period size = 0x%lx\n", substream->stream, pos, runtime->buffer_size, runtime->period_size);
+		if (printk_ratelimit()) {
+			snd_printd(KERN_ERR  "BUG: stream = %i, pos = 0x%lx, "
+				   "buffer size = 0x%lx, period size = 0x%lx\n",
+				   substream->stream, pos, runtime->buffer_size,
+				   runtime->period_size);
+		}
+		pos = 0;
 	}
-#endif
 	pos -= pos % runtime->min_align;
 	return pos;
 }

commit 98204646f2b15d368701265e4194b773a6f94600
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 19 09:59:21 2009 +0100

    ALSA: pcm - avoid unnecessary inline
    
    Remove unnecessary explicit inlininig of internal functions.
    Let compiler optimize.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 2ff25ed4d834..302654769faf 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -148,8 +148,9 @@ static void xrun(struct snd_pcm_substream *substream)
 	}
 }
 
-static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
-							  struct snd_pcm_runtime *runtime)
+static snd_pcm_uframes_t
+snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
+			  struct snd_pcm_runtime *runtime)
 {
 	snd_pcm_uframes_t pos;
 
@@ -167,8 +168,8 @@ static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(struct snd_pcm_substre
 	return pos;
 }
 
-static inline int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
-					     struct snd_pcm_runtime *runtime)
+static int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
+				      struct snd_pcm_runtime *runtime)
 {
 	snd_pcm_uframes_t avail;
 
@@ -200,7 +201,7 @@ static inline int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream
 		}							\
 	} while (0)
 
-static inline int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
+static int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t pos;

commit cad377acf3d6af6279622048e96680e79e352183
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 19 09:55:15 2009 +0100

    ALSA: pcm - Fix a typo in error messages
    
    Fix a typo in error messages; forgotten after a copy&paste error.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 86ac9ae9460e..2ff25ed4d834 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -194,7 +194,7 @@ static inline int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream
 	do {								\
 		if (xrun_debug(substream)) {				\
 			if (printk_ratelimit()) {			\
-				snd_printd("hda_codec: " fmt, ##args);	\
+				snd_printd("PCM: " fmt, ##args);	\
 			}						\
 			dump_stack_on_xrun(substream);			\
 		}							\

commit ed3da3d9a0ef13c6fe1414ec73c9c1be12747b62
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 3 17:00:15 2009 +0100

    ALSA: Rewrite hw_ptr updaters
    
    Clean up and improve snd_pcm_update_hw_ptr*() functions.
    
    snd_pcm_update_hw_ptr() tries to detect the unexpected hwptr jumps
    more strictly to avoid the position mess-up, which often results in
    the bad quality I/O with pulseaudio.
    
    The hw-ptr skip error messages are printed when xrun proc is set to
    non-zero.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 921691080f35..86ac9ae9460e 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -125,19 +125,27 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 	}
 }
 
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+#define xrun_debug(substream)	((substream)->pstr->xrun_debug)
+#else
+#define xrun_debug(substream)	0
+#endif
+
+#define dump_stack_on_xrun(substream) do {	\
+		if (xrun_debug(substream) > 1)	\
+			dump_stack();		\
+	} while (0)
+
 static void xrun(struct snd_pcm_substream *substream)
 {
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
-#ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	if (substream->pstr->xrun_debug) {
+	if (xrun_debug(substream)) {
 		snd_printd(KERN_DEBUG "XRUN: pcmC%dD%d%c\n",
 			   substream->pcm->card->number,
 			   substream->pcm->device,
 			   substream->stream ? 'c' : 'p');
-		if (substream->pstr->xrun_debug > 1)
-			dump_stack();
+		dump_stack_on_xrun(substream);
 	}
-#endif
 }
 
 static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
@@ -182,11 +190,21 @@ static inline int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream
 	return 0;
 }
 
+#define hw_ptr_error(substream, fmt, args...)				\
+	do {								\
+		if (xrun_debug(substream)) {				\
+			if (printk_ratelimit()) {			\
+				snd_printd("hda_codec: " fmt, ##args);	\
+			}						\
+			dump_stack_on_xrun(substream);			\
+		}							\
+	} while (0)
+
 static inline int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t pos;
-	snd_pcm_uframes_t new_hw_ptr, hw_ptr_interrupt;
+	snd_pcm_uframes_t new_hw_ptr, hw_ptr_interrupt, hw_base;
 	snd_pcm_sframes_t delta;
 
 	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
@@ -194,36 +212,47 @@ static inline int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *subs
 		xrun(substream);
 		return -EPIPE;
 	}
-	if (runtime->period_size == runtime->buffer_size)
-		goto __next_buf;
-	new_hw_ptr = runtime->hw_ptr_base + pos;
+	hw_base = runtime->hw_ptr_base;
+	new_hw_ptr = hw_base + pos;
 	hw_ptr_interrupt = runtime->hw_ptr_interrupt + runtime->period_size;
-
-	delta = hw_ptr_interrupt - new_hw_ptr;
-	if (delta > 0) {
-		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
-#ifdef CONFIG_SND_PCM_XRUN_DEBUG
-			if (runtime->periods > 1 && substream->pstr->xrun_debug) {
-				snd_printd(KERN_ERR "Unexpected hw_pointer value [1] (stream = %i, delta: -%ld, max jitter = %ld): wrong interrupt acknowledge?\n", substream->stream, (long) delta, runtime->buffer_size / 2);
-				if (substream->pstr->xrun_debug > 1)
-					dump_stack();
-			}
-#endif
-			return 0;
+	delta = new_hw_ptr - hw_ptr_interrupt;
+	if (hw_ptr_interrupt == runtime->boundary)
+		hw_ptr_interrupt = 0;
+	if (delta < 0) {
+		delta += runtime->buffer_size;
+		if (delta < 0) {
+			hw_ptr_error(substream, 
+				     "Unexpected hw_pointer value "
+				     "(stream=%i, pos=%ld, intr_ptr=%ld)\n",
+				     substream->stream, (long)pos,
+				     (long)hw_ptr_interrupt);
+			/* rebase to interrupt position */
+			hw_base = new_hw_ptr = hw_ptr_interrupt;
+			delta = 0;
+		} else {
+			hw_base += runtime->buffer_size;
+			if (hw_base == runtime->boundary)
+				hw_base = 0;
+			new_hw_ptr = hw_base + pos;
 		}
-	      __next_buf:
-		runtime->hw_ptr_base += runtime->buffer_size;
-		if (runtime->hw_ptr_base == runtime->boundary)
-			runtime->hw_ptr_base = 0;
-		new_hw_ptr = runtime->hw_ptr_base + pos;
 	}
-
+	if (delta > runtime->period_size) {
+		hw_ptr_error(substream,
+			     "Lost interrupts? "
+			     "(stream=%i, delta=%ld, intr_ptr=%ld)\n",
+			     substream->stream, (long)delta,
+			     (long)hw_ptr_interrupt);
+		/* rebase hw_ptr_interrupt */
+		hw_ptr_interrupt =
+			new_hw_ptr - new_hw_ptr % runtime->period_size;
+	}
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);
 
+	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
-	runtime->hw_ptr_interrupt = new_hw_ptr - new_hw_ptr % runtime->period_size;
+	runtime->hw_ptr_interrupt = hw_ptr_interrupt;
 
 	return snd_pcm_update_hw_ptr_post(substream, runtime);
 }
@@ -233,7 +262,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t pos;
-	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr;
+	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;
 	snd_pcm_sframes_t delta;
 
 	old_hw_ptr = runtime->status->hw_ptr;
@@ -242,29 +271,38 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 		xrun(substream);
 		return -EPIPE;
 	}
-	new_hw_ptr = runtime->hw_ptr_base + pos;
-
-	delta = old_hw_ptr - new_hw_ptr;
-	if (delta > 0) {
-		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
-#ifdef CONFIG_SND_PCM_XRUN_DEBUG
-			if (runtime->periods > 2 && substream->pstr->xrun_debug) {
-				snd_printd(KERN_ERR "Unexpected hw_pointer value [2] (stream = %i, delta: -%ld, max jitter = %ld): wrong interrupt acknowledge?\n", substream->stream, (long) delta, runtime->buffer_size / 2);
-				if (substream->pstr->xrun_debug > 1)
-					dump_stack();
-			}
-#endif
+	hw_base = runtime->hw_ptr_base;
+	new_hw_ptr = hw_base + pos;
+
+	delta = new_hw_ptr - old_hw_ptr;
+	if (delta < 0) {
+		delta += runtime->buffer_size;
+		if (delta < 0) {
+			hw_ptr_error(substream, 
+				     "Unexpected hw_pointer value [2] "
+				     "(stream=%i, pos=%ld, old_ptr=%ld)\n",
+				     substream->stream, (long)pos,
+				     (long)old_hw_ptr);
 			return 0;
 		}
-		runtime->hw_ptr_base += runtime->buffer_size;
-		if (runtime->hw_ptr_base == runtime->boundary)
-			runtime->hw_ptr_base = 0;
-		new_hw_ptr = runtime->hw_ptr_base + pos;
+		hw_base += runtime->buffer_size;
+		if (hw_base == runtime->boundary)
+			hw_base = 0;
+		new_hw_ptr = hw_base + pos;
+	}
+	if (delta > runtime->period_size && runtime->periods > 1) {
+		hw_ptr_error(substream,
+			     "hw_ptr skipping! "
+			     "(pos=%ld, delta=%ld, period=%ld)\n",
+			     (long)pos, (long)delta,
+			     (long)runtime->period_size);
+		return 0;
 	}
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    runtime->silence_size > 0)
 		snd_pcm_playback_silence(substream, new_hw_ptr);
 
+	runtime->hw_ptr_base = hw_base;
 	runtime->status->hw_ptr = new_hw_ptr;
 
 	return snd_pcm_update_hw_ptr_post(substream, runtime);

commit 1c85cc64456c97f3b265788abafec5c482c6a908
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Oct 15 14:38:40 2008 -0700

    ALSA: kernel docs: fix sound/core/ kernel-doc
    
    Add kernel-doc function short descriptions to sound/core functions that
    are missing this short description.  Mostly this involves moving some of
    the function description onto the @funcname line.
    
    Also correct a few variable names and fix other kernel-doc notation.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 6ea5cfb83998..921691080f35 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -908,12 +908,12 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 EXPORT_SYMBOL(snd_pcm_hw_rule_add);
 
 /**
- * snd_pcm_hw_constraint_mask
+ * snd_pcm_hw_constraint_mask - apply the given bitmap mask constraint
  * @runtime: PCM runtime instance
  * @var: hw_params variable to apply the mask
  * @mask: the bitmap mask
  *
- * Apply the constraint of the given bitmap mask to a mask parameter.
+ * Apply the constraint of the given bitmap mask to a 32-bit mask parameter.
  */
 int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 			       u_int32_t mask)
@@ -928,12 +928,12 @@ int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param
 }
 
 /**
- * snd_pcm_hw_constraint_mask64
+ * snd_pcm_hw_constraint_mask64 - apply the given bitmap mask constraint
  * @runtime: PCM runtime instance
  * @var: hw_params variable to apply the mask
  * @mask: the 64bit bitmap mask
  *
- * Apply the constraint of the given bitmap mask to a mask parameter.
+ * Apply the constraint of the given bitmap mask to a 64-bit mask parameter.
  */
 int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 				 u_int64_t mask)
@@ -949,7 +949,7 @@ int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_par
 }
 
 /**
- * snd_pcm_hw_constraint_integer
+ * snd_pcm_hw_constraint_integer - apply an integer constraint to an interval
  * @runtime: PCM runtime instance
  * @var: hw_params variable to apply the integer constraint
  *
@@ -964,7 +964,7 @@ int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_pa
 EXPORT_SYMBOL(snd_pcm_hw_constraint_integer);
 
 /**
- * snd_pcm_hw_constraint_minmax
+ * snd_pcm_hw_constraint_minmax - apply a min/max range constraint to an interval
  * @runtime: PCM runtime instance
  * @var: hw_params variable to apply the range
  * @min: the minimal value
@@ -995,7 +995,7 @@ static int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,
 
 
 /**
- * snd_pcm_hw_constraint_list
+ * snd_pcm_hw_constraint_list - apply a list of constraints to a parameter
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @var: hw_params variable to apply the list constraint
@@ -1031,7 +1031,7 @@ static int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,
 }
 
 /**
- * snd_pcm_hw_constraint_ratnums
+ * snd_pcm_hw_constraint_ratnums - apply ratnums constraint to a parameter
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @var: hw_params variable to apply the ratnums constraint
@@ -1064,7 +1064,7 @@ static int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,
 }
 
 /**
- * snd_pcm_hw_constraint_ratdens
+ * snd_pcm_hw_constraint_ratdens - apply ratdens constraint to a parameter
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @var: hw_params variable to apply the ratdens constraint
@@ -1095,7 +1095,7 @@ static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
 }
 
 /**
- * snd_pcm_hw_constraint_msbits
+ * snd_pcm_hw_constraint_msbits - add a hw constraint msbits rule
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @width: sample bits width
@@ -1123,7 +1123,7 @@ static int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,
 }
 
 /**
- * snd_pcm_hw_constraint_step
+ * snd_pcm_hw_constraint_step - add a hw constraint step rule
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @var: hw_params variable to apply the step constraint
@@ -1154,7 +1154,7 @@ static int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm
 }		
 
 /**
- * snd_pcm_hw_constraint_pow2
+ * snd_pcm_hw_constraint_pow2 - add a hw constraint power-of-2 rule
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @var: hw_params variable to apply the power-of-2 constraint
@@ -1202,13 +1202,13 @@ void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)
 EXPORT_SYMBOL(_snd_pcm_hw_params_any);
 
 /**
- * snd_pcm_hw_param_value
+ * snd_pcm_hw_param_value - return @params field @var value
  * @params: the hw_params instance
  * @var: parameter to retrieve
- * @dir: pointer to the direction (-1,0,1) or NULL
+ * @dir: pointer to the direction (-1,0,1) or %NULL
  *
- * Return the value for field PAR if it's fixed in configuration space 
- *  defined by PARAMS. Return -EINVAL otherwise
+ * Return the value for field @var if it's fixed in configuration space
+ * defined by @params. Return -%EINVAL otherwise.
  */
 int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
 			   snd_pcm_hw_param_t var, int *dir)
@@ -1271,13 +1271,13 @@ static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
 
 
 /**
- * snd_pcm_hw_param_first
+ * snd_pcm_hw_param_first - refine config space and return minimum value
  * @pcm: PCM instance
  * @params: the hw_params instance
  * @var: parameter to retrieve
- * @dir: pointer to the direction (-1,0,1) or NULL
+ * @dir: pointer to the direction (-1,0,1) or %NULL
  *
- * Inside configuration space defined by PARAMS remove from PAR all 
+ * Inside configuration space defined by @params remove from @var all
  * values > minimum. Reduce configuration space accordingly.
  * Return the minimum.
  */
@@ -1317,13 +1317,13 @@ static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
 
 
 /**
- * snd_pcm_hw_param_last
+ * snd_pcm_hw_param_last - refine config space and return maximum value
  * @pcm: PCM instance
  * @params: the hw_params instance
  * @var: parameter to retrieve
- * @dir: pointer to the direction (-1,0,1) or NULL
+ * @dir: pointer to the direction (-1,0,1) or %NULL
  *
- * Inside configuration space defined by PARAMS remove from PAR all 
+ * Inside configuration space defined by @params remove from @var all
  * values < maximum. Reduce configuration space accordingly.
  * Return the maximum.
  */
@@ -1345,11 +1345,11 @@ int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm,
 EXPORT_SYMBOL(snd_pcm_hw_param_last);
 
 /**
- * snd_pcm_hw_param_choose
+ * snd_pcm_hw_param_choose - choose a configuration defined by @params
  * @pcm: PCM instance
  * @params: the hw_params instance
  *
- * Choose one configuration from configuration space defined by PARAMS
+ * Choose one configuration from configuration space defined by @params.
  * The configuration chosen is that obtained fixing in this order:
  * first access, first format, first subformat, min channels,
  * min rate, min period time, max buffer size, min tick time

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 1533f0379e9d..6ea5cfb83998 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -85,7 +85,8 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 		}
 		frames = runtime->buffer_size - runtime->silence_filled;
 	}
-	snd_assert(frames <= runtime->buffer_size, return);
+	if (snd_BUG_ON(frames > runtime->buffer_size))
+		return;
 	if (frames == 0)
 		return;
 	ofs = runtime->silence_start % runtime->buffer_size;
@@ -96,7 +97,7 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 			if (substream->ops->silence) {
 				int err;
 				err = substream->ops->silence(substream, -1, ofs, transfer);
-				snd_assert(err >= 0, );
+				snd_BUG_ON(err < 0);
 			} else {
 				char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);
 				snd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);
@@ -108,7 +109,7 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 				for (c = 0; c < channels; ++c) {
 					int err;
 					err = substream->ops->silence(substream, c, ofs, transfer);
-					snd_assert(err >= 0, );
+					snd_BUG_ON(err < 0);
 				}
 			} else {
 				size_t dma_csize = runtime->dma_bytes / channels;
@@ -354,7 +355,7 @@ static inline unsigned int muldiv32(unsigned int a, unsigned int b,
 {
 	u_int64_t n = (u_int64_t) a * b;
 	if (c == 0) {
-		snd_assert(n > 0, );
+		snd_BUG_ON(!n);
 		*r = 0;
 		return UINT_MAX;
 	}
@@ -380,7 +381,8 @@ static inline unsigned int muldiv32(unsigned int a, unsigned int b,
 int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)
 {
 	int changed = 0;
-	snd_assert(!snd_interval_empty(i), return -EINVAL);
+	if (snd_BUG_ON(snd_interval_empty(i)))
+		return -EINVAL;
 	if (i->min < v->min) {
 		i->min = v->min;
 		i->openmin = v->openmin;
@@ -423,7 +425,8 @@ EXPORT_SYMBOL(snd_interval_refine);
 
 static int snd_interval_refine_first(struct snd_interval *i)
 {
-	snd_assert(!snd_interval_empty(i), return -EINVAL);
+	if (snd_BUG_ON(snd_interval_empty(i)))
+		return -EINVAL;
 	if (snd_interval_single(i))
 		return 0;
 	i->max = i->min;
@@ -435,7 +438,8 @@ static int snd_interval_refine_first(struct snd_interval *i)
 
 static int snd_interval_refine_last(struct snd_interval *i)
 {
-	snd_assert(!snd_interval_empty(i), return -EINVAL);
+	if (snd_BUG_ON(snd_interval_empty(i)))
+		return -EINVAL;
 	if (snd_interval_single(i))
 		return 0;
 	i->min = i->max;
@@ -889,7 +893,8 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 	c->private = private;
 	k = 0;
 	while (1) {
-		snd_assert(k < ARRAY_SIZE(c->deps), return -EINVAL);
+		if (snd_BUG_ON(k >= ARRAY_SIZE(c->deps)))
+			return -EINVAL;
 		c->deps[k++] = dep;
 		if (dep < 0)
 			break;
@@ -1285,7 +1290,8 @@ int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm,
 		return changed;
 	if (params->rmask) {
 		int err = snd_pcm_hw_refine(pcm, params);
-		snd_assert(err >= 0, return err);
+		if (snd_BUG_ON(err < 0))
+			return err;
 	}
 	return snd_pcm_hw_param_value(params, var, dir);
 }
@@ -1330,7 +1336,8 @@ int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm,
 		return changed;
 	if (params->rmask) {
 		int err = snd_pcm_hw_refine(pcm, params);
-		snd_assert(err >= 0, return err);
+		if (snd_BUG_ON(err < 0))
+			return err;
 	}
 	return snd_pcm_hw_param_value(params, var, dir);
 }
@@ -1368,7 +1375,8 @@ int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,
 			err = snd_pcm_hw_param_first(pcm, params, *v, NULL);
 		else
 			err = snd_pcm_hw_param_last(pcm, params, *v, NULL);
-		snd_assert(err >= 0, return err);
+		if (snd_BUG_ON(err < 0))
+			return err;
 	}
 	return 0;
 }
@@ -1466,9 +1474,9 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime;
 	unsigned long flags;
 
-	snd_assert(substream != NULL, return);
+	if (PCM_RUNTIME_CHECK(substream))
+		return;
 	runtime = substream->runtime;
-	snd_assert(runtime != NULL, return);
 
 	if (runtime->transfer_ack_begin)
 		runtime->transfer_ack_begin(substream);
@@ -1567,7 +1575,6 @@ static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 			return err;
 	} else {
 		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
-		snd_assert(runtime->dma_area, return -EFAULT);
 		if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))
 			return -EFAULT;
 	}
@@ -1629,7 +1636,10 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
 		if (frames > cont)
 			frames = cont;
-		snd_assert(frames != 0, snd_pcm_stream_unlock_irq(substream); return -EINVAL);
+		if (snd_BUG_ON(!frames)) {
+			snd_pcm_stream_unlock_irq(substream);
+			return -EINVAL;
+		}
 		appl_ptr = runtime->control->appl_ptr;
 		appl_ofs = appl_ptr % runtime->buffer_size;
 		snd_pcm_stream_unlock_irq(substream);
@@ -1669,18 +1679,30 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
 
-snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)
+/* sanity-check for read/write methods */
+static int pcm_sanity_check(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime;
-	int nonblock;
-
-	snd_assert(substream != NULL, return -ENXIO);
+	if (PCM_RUNTIME_CHECK(substream))
+		return -ENXIO;
 	runtime = substream->runtime;
-	snd_assert(runtime != NULL, return -ENXIO);
-	snd_assert(substream->ops->copy != NULL || runtime->dma_area != NULL, return -EINVAL);
+	if (snd_BUG_ON(!substream->ops->copy && !runtime->dma_area))
+		return -EINVAL;
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
+	return 0;
+}
+
+snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)
+{
+	struct snd_pcm_runtime *runtime;
+	int nonblock;
+	int err;
 
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
+	runtime = substream->runtime;
 	nonblock = !!(substream->f_flags & O_NONBLOCK);
 
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
@@ -1703,7 +1725,8 @@ static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
 	int channels = runtime->channels;
 	int c;
 	if (substream->ops->copy) {
-		snd_assert(substream->ops->silence != NULL, return -EINVAL);
+		if (snd_BUG_ON(!substream->ops->silence))
+			return -EINVAL;
 		for (c = 0; c < channels; ++c, ++bufs) {
 			if (*bufs == NULL) {
 				if ((err = substream->ops->silence(substream, c, hwoff, frames)) < 0)
@@ -1717,7 +1740,6 @@ static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
 	} else {
 		/* default transfer behaviour */
 		size_t dma_csize = runtime->dma_bytes / channels;
-		snd_assert(runtime->dma_area, return -EFAULT);
 		for (c = 0; c < channels; ++c, ++bufs) {
 			char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
 			if (*bufs == NULL) {
@@ -1738,14 +1760,12 @@ snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 {
 	struct snd_pcm_runtime *runtime;
 	int nonblock;
+	int err;
 
-	snd_assert(substream != NULL, return -ENXIO);
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
 	runtime = substream->runtime;
-	snd_assert(runtime != NULL, return -ENXIO);
-	snd_assert(substream->ops->copy != NULL || runtime->dma_area != NULL, return -EINVAL);
-	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
-		return -EBADFD;
-
 	nonblock = !!(substream->f_flags & O_NONBLOCK);
 
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
@@ -1769,7 +1789,6 @@ static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream,
 			return err;
 	} else {
 		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
-		snd_assert(runtime->dma_area, return -EFAULT);
 		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))
 			return -EFAULT;
 	}
@@ -1841,7 +1860,10 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
 		if (frames > cont)
 			frames = cont;
-		snd_assert(frames != 0, snd_pcm_stream_unlock_irq(substream); return -EINVAL);
+		if (snd_BUG_ON(!frames)) {
+			snd_pcm_stream_unlock_irq(substream);
+			return -EINVAL;
+		}
 		appl_ptr = runtime->control->appl_ptr;
 		appl_ofs = appl_ptr % runtime->buffer_size;
 		snd_pcm_stream_unlock_irq(substream);
@@ -1879,14 +1901,12 @@ snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __u
 {
 	struct snd_pcm_runtime *runtime;
 	int nonblock;
+	int err;
 	
-	snd_assert(substream != NULL, return -ENXIO);
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
 	runtime = substream->runtime;
-	snd_assert(runtime != NULL, return -ENXIO);
-	snd_assert(substream->ops->copy != NULL || runtime->dma_area != NULL, return -EINVAL);
-	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
-		return -EBADFD;
-
 	nonblock = !!(substream->f_flags & O_NONBLOCK);
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)
 		return -EINVAL;
@@ -1916,7 +1936,6 @@ static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
 		}
 	} else {
 		snd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;
-		snd_assert(runtime->dma_area, return -EFAULT);
 		for (c = 0; c < channels; ++c, ++bufs) {
 			char *hwbuf;
 			char __user *buf;
@@ -1938,11 +1957,12 @@ snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 {
 	struct snd_pcm_runtime *runtime;
 	int nonblock;
+	int err;
 
-	snd_assert(substream != NULL, return -ENXIO);
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
 	runtime = substream->runtime;
-	snd_assert(runtime != NULL, return -ENXIO);
-	snd_assert(substream->ops->copy != NULL || runtime->dma_area != NULL, return -EINVAL);
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 

commit 8c12158687fc78091730d5456336b7efbf6f2250
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Jan 11 08:45:08 2008 +0100

    [ALSA] PCM interface - rename SNDRV_PCM_TSTAMP_MMAP to SNDRV_PCM_TSTAMP_ENABLE
    
    Change semantics for SNDRV_PCM_TSTAMP_MMAP. Doing timestamping only in
    the interrupt handler might cause that hw_ptr is not related to actual
    timestamp. With this change, grab timestamp at every hw_ptr update to
    have always valid timestamp + ring buffer position pair.
    With this change, SNDRV_PCM_TSTAMP_MMAP was renamed to
    SNDRV_PCM_TSTAMP_ENABLE. It's no regression (I think).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index ed0223ca5c55..1533f0379e9d 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -144,6 +144,8 @@ static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(struct snd_pcm_substre
 {
 	snd_pcm_uframes_t pos;
 
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 	pos = substream->ops->pointer(substream);
 	if (pos == SNDRV_PCM_POS_XRUN)
 		return pos; /* XRUN */
@@ -186,8 +188,6 @@ static inline int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *subs
 	snd_pcm_uframes_t new_hw_ptr, hw_ptr_interrupt;
 	snd_pcm_sframes_t delta;
 
-	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_MMAP)
-		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
 	if (pos == SNDRV_PCM_POS_XRUN) {
 		xrun(substream);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index f00758c2bded..ed0223ca5c55 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -20,7 +20,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <sound/core.h>

commit 31e8960b35975ed235d283d6fb95d0e28dffded0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:09:57 2008 +0100

    [ALSA] Remove PCM sleep_min and tick
    
    The 'tick' in PCM is set (again) via sw_params.  And, nobody uses
    this feature at all except for a command line option of aplay.
    (This is literally 'nobody', as I checked alsa-lib API calls in all
     programs in major distros.)
    Above all, if we need finer wake-ups for the position update, it's
    basically an issue that the driver should solve, not tuned by each
    application.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index b406630d8fdf..f00758c2bded 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1451,112 +1451,13 @@ int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 
 EXPORT_SYMBOL(snd_pcm_lib_ioctl);
 
-/*
- *  Conditions
- */
-
-static void snd_pcm_system_tick_set(struct snd_pcm_substream *substream, 
-				    unsigned long ticks)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	if (ticks == 0)
-		del_timer(&runtime->tick_timer);
-	else {
-		ticks += (1000000 / HZ) - 1;
-		ticks /= (1000000 / HZ);
-		mod_timer(&runtime->tick_timer, jiffies + ticks);
-	}
-}
-
-/* Temporary alias */
-void snd_pcm_tick_set(struct snd_pcm_substream *substream, unsigned long ticks)
-{
-	snd_pcm_system_tick_set(substream, ticks);
-}
-
-void snd_pcm_tick_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	snd_pcm_uframes_t frames = ULONG_MAX;
-	snd_pcm_uframes_t avail, dist;
-	unsigned int ticks;
-	u_int64_t n;
-	u_int32_t r;
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (runtime->silence_size >= runtime->boundary) {
-			frames = 1;
-		} else if (runtime->silence_size > 0 &&
-			   runtime->silence_filled < runtime->buffer_size) {
-			snd_pcm_sframes_t noise_dist;
-			noise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;
-			if (noise_dist > (snd_pcm_sframes_t)runtime->silence_threshold)
-				frames = noise_dist - runtime->silence_threshold;
-		}
-		avail = snd_pcm_playback_avail(runtime);
-	} else {
-		avail = snd_pcm_capture_avail(runtime);
-	}
-	if (avail < runtime->control->avail_min) {
-		snd_pcm_sframes_t to_avail_min =
-			runtime->control->avail_min - avail;
-		if (to_avail_min > 0 &&
-		    frames > (snd_pcm_uframes_t)to_avail_min)
-			frames = to_avail_min;
-	}
-	if (avail < runtime->buffer_size) {
-		snd_pcm_sframes_t to_buffer_size =
-			runtime->buffer_size - avail;
-		if (to_buffer_size > 0 &&
-		    frames > (snd_pcm_uframes_t)to_buffer_size)
-			frames = to_buffer_size;
-	}
-	if (frames == ULONG_MAX) {
-		snd_pcm_tick_set(substream, 0);
-		return;
-	}
-	dist = runtime->status->hw_ptr - runtime->hw_ptr_base;
-	/* Distance to next interrupt */
-	dist = runtime->period_size - dist % runtime->period_size;
-	if (dist <= frames) {
-		snd_pcm_tick_set(substream, 0);
-		return;
-	}
-	/* the base time is us */
-	n = frames;
-	n *= 1000000;
-	div64_32(&n, runtime->tick_time * runtime->rate, &r);
-	ticks = n + (r > 0 ? 1 : 0);
-	if (ticks < runtime->sleep_min)
-		ticks = runtime->sleep_min;
-	snd_pcm_tick_set(substream, (unsigned long) ticks);
-}
-
-void snd_pcm_tick_elapsed(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime;
-	unsigned long flags;
-	
-	snd_assert(substream != NULL, return);
-	runtime = substream->runtime;
-	snd_assert(runtime != NULL, return);
-
-	snd_pcm_stream_lock_irqsave(substream, flags);
-	if (!snd_pcm_running(substream) ||
-	    snd_pcm_update_hw_ptr(substream) < 0)
-		goto _end;
-	if (runtime->sleep_min)
-		snd_pcm_tick_prepare(substream);
- _end:
-	snd_pcm_stream_unlock_irqrestore(substream, flags);
-}
-
 /**
  * snd_pcm_period_elapsed - update the pcm status for the next period
  * @substream: the pcm substream instance
  *
  * This function is called from the interrupt handler when the
  * PCM has processed the period size.  It will update the current
- * pointer, set up the tick, wake up sleepers, etc.
+ * pointer, wake up sleepers, etc.
  *
  * Even if more than one periods have elapsed since the last call, you
  * have to call this only once.
@@ -1580,8 +1481,6 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 
 	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
-	if (runtime->sleep_min)
-		snd_pcm_tick_prepare(substream);
  _end:
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	if (runtime->transfer_ack_end)
@@ -1715,7 +1614,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t avail;
 		snd_pcm_uframes_t cont;
-		if (runtime->sleep_min == 0 && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+		if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 			snd_pcm_update_hw_ptr(substream);
 		avail = snd_pcm_playback_avail(runtime);
 		if (!avail) {
@@ -1764,9 +1663,6 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 			if (err < 0)
 				goto _end_unlock;
 		}
-		if (runtime->sleep_min &&
-		    runtime->status->state == SNDRV_PCM_STATE_RUNNING)
-			snd_pcm_tick_prepare(substream);
 	}
  _end_unlock:
 	snd_pcm_stream_unlock_irq(substream);
@@ -1923,7 +1819,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
 		snd_pcm_uframes_t avail;
 		snd_pcm_uframes_t cont;
-		if (runtime->sleep_min == 0 && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+		if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 			snd_pcm_update_hw_ptr(substream);
 		avail = snd_pcm_capture_avail(runtime);
 		if (!avail) {
@@ -1973,9 +1869,6 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		offset += frames;
 		size -= frames;
 		xfer += frames;
-		if (runtime->sleep_min &&
-		    runtime->status->state == SNDRV_PCM_STATE_RUNNING)
-			snd_pcm_tick_prepare(substream);
 	}
  _end_unlock:
 	snd_pcm_stream_unlock_irq(substream);

commit 130755108ba03461f69da990e54e02a254accd23
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:08:14 2008 +0100

    [ALSA] PCM - clean up snd_pcm_lib_read/write
    
    Introduce a common helper function for snd_pcm_lib_read and snd_pcm_lib_write
    for cleaning up the code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index c1c1556105c0..b406630d8fdf 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1591,6 +1591,71 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 
 EXPORT_SYMBOL(snd_pcm_period_elapsed);
 
+/*
+ * Wait until avail_min data becomes available
+ * Returns a negative error code if any error occurs during operation.
+ * The available space is stored on availp.  When err = 0 and avail = 0
+ * on the capture stream, it indicates the stream is in DRAINING state.
+ */
+static int wait_for_avail_min(struct snd_pcm_substream *substream,
+			      snd_pcm_uframes_t *availp)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	wait_queue_t wait;
+	int err = 0;
+	snd_pcm_uframes_t avail = 0;
+	long tout;
+
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(&runtime->sleep, &wait);
+	for (;;) {
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		snd_pcm_stream_unlock_irq(substream);
+		tout = schedule_timeout(msecs_to_jiffies(10000));
+		snd_pcm_stream_lock_irq(substream);
+		switch (runtime->status->state) {
+		case SNDRV_PCM_STATE_SUSPENDED:
+			err = -ESTRPIPE;
+			goto _endloop;
+		case SNDRV_PCM_STATE_XRUN:
+			err = -EPIPE;
+			goto _endloop;
+		case SNDRV_PCM_STATE_DRAINING:
+			if (is_playback)
+				err = -EPIPE;
+			else 
+				avail = 0; /* indicate draining */
+			goto _endloop;
+		case SNDRV_PCM_STATE_OPEN:
+		case SNDRV_PCM_STATE_SETUP:
+		case SNDRV_PCM_STATE_DISCONNECTED:
+			err = -EBADFD;
+			goto _endloop;
+		}
+		if (!tout) {
+			snd_printd("%s write error (DMA or IRQ trouble?)\n",
+				   is_playback ? "playback" : "capture");
+			err = -EIO;
+			break;
+		}
+		if (is_playback)
+			avail = snd_pcm_playback_avail(runtime);
+		else
+			avail = snd_pcm_capture_avail(runtime);
+		if (avail >= runtime->control->avail_min)
+			break;
+	}
+ _endloop:
+	remove_wait_queue(&runtime->sleep, &wait);
+	*availp = avail;
+	return err;
+}
+	
 static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 				      unsigned int hwoff,
 				      unsigned long data, unsigned int off,
@@ -1653,79 +1718,14 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		if (runtime->sleep_min == 0 && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 			snd_pcm_update_hw_ptr(substream);
 		avail = snd_pcm_playback_avail(runtime);
-		if (!avail ||
-		    (snd_pcm_running(substream) &&
-		     (avail < runtime->control->avail_min && size > avail))) {
-			wait_queue_t wait;
-			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED, DROPPED } state;
-			long tout;
-
+		if (!avail) {
 			if (nonblock) {
 				err = -EAGAIN;
 				goto _end_unlock;
 			}
-
-			init_waitqueue_entry(&wait, current);
-			add_wait_queue(&runtime->sleep, &wait);
-			while (1) {
-				if (signal_pending(current)) {
-					state = SIGNALED;
-					break;
-				}
-				set_current_state(TASK_INTERRUPTIBLE);
-				snd_pcm_stream_unlock_irq(substream);
-				tout = schedule_timeout(10 * HZ);
-				snd_pcm_stream_lock_irq(substream);
-				if (tout == 0) {
-					if (runtime->status->state != SNDRV_PCM_STATE_PREPARED &&
-					    runtime->status->state != SNDRV_PCM_STATE_PAUSED) {
-						state = runtime->status->state == SNDRV_PCM_STATE_SUSPENDED ? SUSPENDED : EXPIRED;
-						break;
-					}
-				}
-				switch (runtime->status->state) {
-				case SNDRV_PCM_STATE_XRUN:
-				case SNDRV_PCM_STATE_DRAINING:
-					state = ERROR;
-					goto _end_loop;
-				case SNDRV_PCM_STATE_SUSPENDED:
-					state = SUSPENDED;
-					goto _end_loop;
-				case SNDRV_PCM_STATE_SETUP:
-					state = DROPPED;
-					goto _end_loop;
-				default:
-					break;
-				}
-				avail = snd_pcm_playback_avail(runtime);
-				if (avail >= runtime->control->avail_min) {
-					state = READY;
-					break;
-				}
-			}
-		       _end_loop:
-			remove_wait_queue(&runtime->sleep, &wait);
-
-			switch (state) {
-			case ERROR:
-				err = -EPIPE;
-				goto _end_unlock;
-			case SUSPENDED:
-				err = -ESTRPIPE;
-				goto _end_unlock;
-			case SIGNALED:
-				err = -ERESTARTSYS;
-				goto _end_unlock;
-			case EXPIRED:
-				snd_printd("playback write error (DMA or IRQ trouble?)\n");
-				err = -EIO;
-				goto _end_unlock;
-			case DROPPED:
-				err = -EBADFD;
+			err = wait_for_avail_min(substream, &avail);
+			if (err < 0)
 				goto _end_unlock;
-			default:
-				break;
-			}
 		}
 		frames = size > avail ? avail : size;
 		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
@@ -1925,86 +1925,22 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		snd_pcm_uframes_t cont;
 		if (runtime->sleep_min == 0 && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 			snd_pcm_update_hw_ptr(substream);
-	      __draining:
 		avail = snd_pcm_capture_avail(runtime);
-		if (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
-			if (!avail) {
-				err = -EPIPE;
+		if (!avail) {
+			if (runtime->status->state ==
+			    SNDRV_PCM_STATE_DRAINING) {
+				snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
 				goto _end_unlock;
 			}
-		} else if (avail < runtime->control->avail_min &&
-			   size > avail) {
-			wait_queue_t wait;
-			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED, DROPPED } state;
-			long tout;
-
 			if (nonblock) {
 				err = -EAGAIN;
 				goto _end_unlock;
 			}
-
-			init_waitqueue_entry(&wait, current);
-			add_wait_queue(&runtime->sleep, &wait);
-			while (1) {
-				if (signal_pending(current)) {
-					state = SIGNALED;
-					break;
-				}
-				set_current_state(TASK_INTERRUPTIBLE);
-				snd_pcm_stream_unlock_irq(substream);
-				tout = schedule_timeout(10 * HZ);
-				snd_pcm_stream_lock_irq(substream);
-				if (tout == 0) {
-					if (runtime->status->state != SNDRV_PCM_STATE_PREPARED &&
-					    runtime->status->state != SNDRV_PCM_STATE_PAUSED) {
-						state = runtime->status->state == SNDRV_PCM_STATE_SUSPENDED ? SUSPENDED : EXPIRED;
-						break;
-					}
-				}
-				switch (runtime->status->state) {
-				case SNDRV_PCM_STATE_XRUN:
-					state = ERROR;
-					goto _end_loop;
-				case SNDRV_PCM_STATE_SUSPENDED:
-					state = SUSPENDED;
-					goto _end_loop;
-				case SNDRV_PCM_STATE_DRAINING:
-					goto __draining;
-				case SNDRV_PCM_STATE_SETUP:
-					state = DROPPED;
-					goto _end_loop;
-				default:
-					break;
-				}
-				avail = snd_pcm_capture_avail(runtime);
-				if (avail >= runtime->control->avail_min) {
-					state = READY;
-					break;
-				}
-			}
-		       _end_loop:
-			remove_wait_queue(&runtime->sleep, &wait);
-
-			switch (state) {
-			case ERROR:
-				err = -EPIPE;
-				goto _end_unlock;
-			case SUSPENDED:
-				err = -ESTRPIPE;
-				goto _end_unlock;
-			case SIGNALED:
-				err = -ERESTARTSYS;
-				goto _end_unlock;
-			case EXPIRED:
-				snd_printd("capture read error (DMA or IRQ trouble?)\n");
-				err = -EIO;
-				goto _end_unlock;
-			case DROPPED:
-				err = -EBADFD;
+			err = wait_for_avail_min(substream, &avail);
+			if (err < 0)
 				goto _end_unlock;
-			default:
-				break;
-			}
+			if (!avail)
+				continue; /* draining */
 		}
 		frames = size > avail ? avail : size;
 		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;

commit d948035a928400ae127c873fbf771389bee18949
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:05:26 2008 +0100

    [ALSA] Remove PCM xfer_align sw params
    
    The xfer_align sw_params parameter has never been used in a sane manner,
    and no one understands what this does exactly.  The current
    implementation looks also buggy because it allows write of shorter size
    than xfer_align.  So, if you do partial writes, the write isn't actually
    aligned at all.
    Removing this parameter will make some pcm_lib_* code more readable
    (and less buggy).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index f9f9b3fe956e..c1c1556105c0 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1628,8 +1628,6 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 
 	if (size == 0)
 		return 0;
-	if (size > runtime->xfer_align)
-		size -= size % runtime->xfer_align;
 
 	snd_pcm_stream_lock_irq(substream);
 	switch (runtime->status->state) {
@@ -1657,9 +1655,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		avail = snd_pcm_playback_avail(runtime);
 		if (!avail ||
 		    (snd_pcm_running(substream) &&
-		     ((avail < runtime->control->avail_min && size > avail) ||
-		      (size >= runtime->xfer_align &&
-		       avail < runtime->xfer_align)))) {
+		     (avail < runtime->control->avail_min && size > avail))) {
 			wait_queue_t wait;
 			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED, DROPPED } state;
 			long tout;
@@ -1731,8 +1727,6 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 				break;
 			}
 		}
-		if (avail > runtime->xfer_align)
-			avail -= avail % runtime->xfer_align;
 		frames = size > avail ? avail : size;
 		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
 		if (frames > cont)
@@ -1900,8 +1894,6 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 
 	if (size == 0)
 		return 0;
-	if (size > runtime->xfer_align)
-		size -= size % runtime->xfer_align;
 
 	snd_pcm_stream_lock_irq(substream);
 	switch (runtime->status->state) {
@@ -1936,12 +1928,12 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 	      __draining:
 		avail = snd_pcm_capture_avail(runtime);
 		if (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
-			if (avail < runtime->xfer_align) {
+			if (!avail) {
 				err = -EPIPE;
 				goto _end_unlock;
 			}
-		} else if ((avail < runtime->control->avail_min && size > avail) ||
-			   (size >= runtime->xfer_align && avail < runtime->xfer_align)) {
+		} else if (avail < runtime->control->avail_min &&
+			   size > avail) {
 			wait_queue_t wait;
 			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED, DROPPED } state;
 			long tout;
@@ -2014,8 +2006,6 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 				break;
 			}
 		}
-		if (avail > runtime->xfer_align)
-			avail -= avail % runtime->xfer_align;
 		frames = size > avail ? avail : size;
 		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
 		if (frames > cont)

commit fa5717f2099aadb2083d5df4d19af8f9685fa03e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:00:04 2008 +0100

    [ALSA] Fix PCM write blocking
    
    The snd_pcm_lib_write1() may block in some weird condition:
      - the stream isn't started
      - avail_min is big (e.g. period size)
      - partial write up to buffer_size - avail_min
    The patch fixes this invalid blocking problem.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 48ffa40967a4..f9f9b3fe956e 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1655,8 +1655,11 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 		if (runtime->sleep_min == 0 && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
 			snd_pcm_update_hw_ptr(substream);
 		avail = snd_pcm_playback_avail(runtime);
-		if (((avail < runtime->control->avail_min && size > avail) ||
-		   (size >= runtime->xfer_align && avail < runtime->xfer_align))) {
+		if (!avail ||
+		    (snd_pcm_running(substream) &&
+		     ((avail < runtime->control->avail_min && size > avail) ||
+		      (size >= runtime->xfer_align &&
+		       avail < runtime->xfer_align)))) {
 			wait_queue_t wait;
 			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED, DROPPED } state;
 			long tout;

commit 67c393172c00a710121d61bb7aff31b1e4f44b8d
Author: Marcin Ślusarz <marcin.slusarz@gmail.com>
Date:   Fri Dec 14 12:53:21 2007 +0100

    [ALSA] pcm_lib: fix sparse warning about different signedness
    
    pcm_lib: fix sparse warning about different signedness
    
    Signed-off-by: Marcin Ślusarz <marcin.slusarz@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 2d3e70b2fe3e..48ffa40967a4 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1139,7 +1139,7 @@ EXPORT_SYMBOL(snd_pcm_hw_constraint_step);
 
 static int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)
 {
-	static int pow2_sizes[] = {
+	static unsigned int pow2_sizes[] = {
 		1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,
 		1<<8, 1<<9, 1<<10, 1<<11, 1<<12, 1<<13, 1<<14, 1<<15,
 		1<<16, 1<<17, 1<<18, 1<<19, 1<<20, 1<<21, 1<<22, 1<<23,

commit be3e0115e3732d77d357724a394ee465e5d0b872
Author: Marcin Ślusarz <marcin.slusarz@gmail.com>
Date:   Fri Dec 14 12:52:53 2007 +0100

    [ALSA] pcm_lib: fix sparse warning about shadowing 'n' symbol
    
    pcm_lib: fix sparse warning about shadowing 'n' symbol
    
    Signed-off-by: Marcin Ślusarz <marcin.slusarz@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index db3d7e934ec3..2d3e70b2fe3e 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1497,14 +1497,18 @@ void snd_pcm_tick_prepare(struct snd_pcm_substream *substream)
 		avail = snd_pcm_capture_avail(runtime);
 	}
 	if (avail < runtime->control->avail_min) {
-		snd_pcm_sframes_t n = runtime->control->avail_min - avail;
-		if (n > 0 && frames > (snd_pcm_uframes_t)n)
-			frames = n;
+		snd_pcm_sframes_t to_avail_min =
+			runtime->control->avail_min - avail;
+		if (to_avail_min > 0 &&
+		    frames > (snd_pcm_uframes_t)to_avail_min)
+			frames = to_avail_min;
 	}
 	if (avail < runtime->buffer_size) {
-		snd_pcm_sframes_t n = runtime->buffer_size - avail;
-		if (n > 0 && frames > (snd_pcm_uframes_t)n)
-			frames = n;
+		snd_pcm_sframes_t to_buffer_size =
+			runtime->buffer_size - avail;
+		if (to_buffer_size > 0 &&
+		    frames > (snd_pcm_uframes_t)to_buffer_size)
+			frames = to_buffer_size;
 	}
 	if (frames == ULONG_MAX) {
 		snd_pcm_tick_set(substream, 0);

commit b751eef1fdffca5532344285f2fad0c60d2f0158
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Dec 13 10:19:42 2007 +0100

    [ALSA] Use posix clock monotonic for PCM and timer timestamps
    
    We need an accurate and continuous (monotonic) time sources to do
    accurate synchronization among more timing sources. This patch allows
    to enable monotonic timestamps for ALSA PCM devices and enables monotonic
    timestamps for ALSA timer devices.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 93d7ca502730..db3d7e934ec3 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -188,7 +188,7 @@ static inline int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *subs
 	snd_pcm_sframes_t delta;
 
 	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_MMAP)
-		getnstimeofday((struct timespec *)&runtime->status->tstamp);
+		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
 	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
 	if (pos == SNDRV_PCM_POS_XRUN) {
 		xrun(substream);

commit 7c7fc2d44b7a660846115e65b67772b6742a14d8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 23 13:14:23 2007 +0100

    [ALSA] Fix PCM MMAP time-stamp mode
    
    When MMAP time-stamp mode is given, it's supposed to update the time-stamp
    only at period boundary.  However, it currently updates at each status call
    so this is just useless.  The patch fixes this misbehavior.
    Also it fixes the wrong check of tstamp_mode (don't use bit-and for enum).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 806f1fba5446..93d7ca502730 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -148,8 +148,6 @@ static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(struct snd_pcm_substre
 	pos = substream->ops->pointer(substream);
 	if (pos == SNDRV_PCM_POS_XRUN)
 		return pos; /* XRUN */
-	if (runtime->tstamp_mode & SNDRV_PCM_TSTAMP_MMAP)
-		getnstimeofday((struct timespec *)&runtime->status->tstamp);
 #ifdef CONFIG_SND_DEBUG
 	if (pos >= runtime->buffer_size) {
 		snd_printk(KERN_ERR  "BUG: stream = %i, pos = 0x%lx, buffer size = 0x%lx, period size = 0x%lx\n", substream->stream, pos, runtime->buffer_size, runtime->period_size);
@@ -189,6 +187,8 @@ static inline int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *subs
 	snd_pcm_uframes_t new_hw_ptr, hw_ptr_interrupt;
 	snd_pcm_sframes_t delta;
 
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_MMAP)
+		getnstimeofday((struct timespec *)&runtime->status->tstamp);
 	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
 	if (pos == SNDRV_PCM_POS_XRUN) {
 		xrun(substream);

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 9fefcaa2c324..806f1fba5446 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1,6 +1,6 @@
 /*
  *  Digital Audio (PCM) abstract layer
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *                   Abramo Bagnara <abramo@alsa-project.org>
  *
  *

commit 0981a260a1fe4a3f22cc70ef01ce38a73f548745
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 1 14:53:49 2007 +0100

    [ALSA] Fix possible invalid memory access in PCM core
    
    snd_internval_list() may access invalid memory in the case count = 0
    is given.  It shouldn't be passed, but it'd better to make the code
    a bit more robust.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index b336797be4fc..9fefcaa2c324 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -781,6 +781,11 @@ int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *
 {
         unsigned int k;
 	int changed = 0;
+
+	if (!count) {
+		i->empty = 1;
+		return -EINVAL;
+	}
         for (k = 0; k < count; k++) {
 		if (mask && !(mask & (1 << k)))
 			continue;

commit 9a826ddba6e087b1be24dd78cd0eac42f7eb7e97
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 23 16:26:57 2006 +0200

    [ALSA] pcm core: fix silence_start calculations
    
    The case where silence_size < boundary was broken because different
    parts of the snd_pcm_playback_silence() function disagreed about whether
    silence_start should point to the start or to the end of the buffer part
    to be silenced.
    This patch changes the code to always use to the start, which also
    simplifies several calculations.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 0bb142a28539..b336797be4fc 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -79,19 +79,17 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 			runtime->silence_filled -= frames;
 			if ((snd_pcm_sframes_t)runtime->silence_filled < 0) {
 				runtime->silence_filled = 0;
-				runtime->silence_start = (ofs + frames) - runtime->buffer_size;
+				runtime->silence_start = new_hw_ptr;
 			} else {
-				runtime->silence_start = ofs - runtime->silence_filled;
+				runtime->silence_start = ofs;
 			}
-			if ((snd_pcm_sframes_t)runtime->silence_start < 0)
-				runtime->silence_start += runtime->boundary;
 		}
 		frames = runtime->buffer_size - runtime->silence_filled;
 	}
 	snd_assert(frames <= runtime->buffer_size, return);
 	if (frames == 0)
 		return;
-	ofs = (runtime->silence_start + runtime->silence_filled) % runtime->buffer_size;
+	ofs = runtime->silence_start % runtime->buffer_size;
 	while (frames > 0) {
 		transfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;
 		if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||

commit 0df63e44c3e315ec0fe427ae62558231864108bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Add O_APPEND flag support to PCM
    
    Added O_APPEND flag support to PCM to enable shared substreams
    among multiple processes.  This mechanism is used by dmix and
    dsnoop plugins.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a21aa0050e4d..0bb142a28539 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1782,7 +1782,7 @@ snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const v
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
 
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
 	    runtime->channels > 1)
@@ -1847,7 +1847,7 @@ snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
 
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
 		return -EINVAL;
@@ -2059,7 +2059,7 @@ snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __u
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)
 		return -EINVAL;
 	return snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);
@@ -2118,7 +2118,7 @@ snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
 		return -EINVAL;
 	return snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);

commit 2f4ca8e5c7cf6a6f7935483d8ee4aa8b039bdd7d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] Clean up ugly hacks in pcm_lib.c
    
    Clean up ugly hacks for sync with alsa-lib code in pcm_lib.c.
    Also, optimize snd_pcm_hw_params_choose() with a loop.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 786f88145ee8..a21aa0050e4d 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1163,12 +1163,6 @@ int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
 
 EXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);
 
-/* To use the same code we have in alsa-lib */
-#define assert(i) snd_assert((i), return -EINVAL)
-#ifndef INT_MIN
-#define INT_MIN ((int)((unsigned int)INT_MAX+1))
-#endif
-
 static void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,
 				  snd_pcm_hw_param_t var)
 {
@@ -1228,7 +1222,6 @@ int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
 			*dir = i->openmin;
 		return snd_interval_value(i);
 	}
-	assert(0);
 	return -EINVAL;
 }
 
@@ -1260,10 +1253,8 @@ static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
 		changed = snd_mask_refine_first(hw_param_mask(params, var));
 	else if (hw_is_interval(var))
 		changed = snd_interval_refine_first(hw_param_interval(params, var));
-	else {
-		assert(0);
+	else
 		return -EINVAL;
-	}
 	if (changed) {
 		params->cmask |= 1 << var;
 		params->rmask |= 1 << var;
@@ -1292,7 +1283,7 @@ int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm,
 		return changed;
 	if (params->rmask) {
 		int err = snd_pcm_hw_refine(pcm, params);
-		assert(err >= 0);
+		snd_assert(err >= 0, return err);
 	}
 	return snd_pcm_hw_param_value(params, var, dir);
 }
@@ -1307,10 +1298,8 @@ static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
 		changed = snd_mask_refine_last(hw_param_mask(params, var));
 	else if (hw_is_interval(var))
 		changed = snd_interval_refine_last(hw_param_interval(params, var));
-	else {
-		assert(0);
+	else
 		return -EINVAL;
-	}
 	if (changed) {
 		params->cmask |= 1 << var;
 		params->rmask |= 1 << var;
@@ -1339,7 +1328,7 @@ int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm,
 		return changed;
 	if (params->rmask) {
 		int err = snd_pcm_hw_refine(pcm, params);
-		assert(err >= 0);
+		snd_assert(err >= 0, return err);
 	}
 	return snd_pcm_hw_param_value(params, var, dir);
 }
@@ -1356,39 +1345,32 @@ EXPORT_SYMBOL(snd_pcm_hw_param_last);
  * first access, first format, first subformat, min channels,
  * min rate, min period time, max buffer size, min tick time
  */
-int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params)
-{
-	int err;
-
-	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_ACCESS, NULL);
-	assert(err >= 0);
-
-	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_FORMAT, NULL);
-	assert(err >= 0);
-
-	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_SUBFORMAT, NULL);
-	assert(err >= 0);
-
-	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_CHANNELS, NULL);
-	assert(err >= 0);
-
-	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_RATE, NULL);
-	assert(err >= 0);
-
-	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_PERIOD_TIME, NULL);
-	assert(err >= 0);
-
-	err = snd_pcm_hw_param_last(pcm, params, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, NULL);
-	assert(err >= 0);
-
-	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_TICK_TIME, NULL);
-	assert(err >= 0);
+int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,
+			     struct snd_pcm_hw_params *params)
+{
+	static int vars[] = {
+		SNDRV_PCM_HW_PARAM_ACCESS,
+		SNDRV_PCM_HW_PARAM_FORMAT,
+		SNDRV_PCM_HW_PARAM_SUBFORMAT,
+		SNDRV_PCM_HW_PARAM_CHANNELS,
+		SNDRV_PCM_HW_PARAM_RATE,
+		SNDRV_PCM_HW_PARAM_PERIOD_TIME,
+		SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+		SNDRV_PCM_HW_PARAM_TICK_TIME,
+		-1
+	};
+	int err, *v;
 
+	for (v = vars; *v != -1; v++) {
+		if (*v != SNDRV_PCM_HW_PARAM_BUFFER_SIZE)
+			err = snd_pcm_hw_param_first(pcm, params, *v, NULL);
+		else
+			err = snd_pcm_hw_param_last(pcm, params, *v, NULL);
+		snd_assert(err >= 0, return err);
+	}
 	return 0;
 }
 
-#undef assert
-
 static int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,
 				   void *arg)
 {

commit e88e8ae639a4908b903d9406c54e99a729b01a28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] Move OSS-specific hw_params helper to snd-pcm-oss module
    
    Move EXPORT_SYMBOL()s to places adjacent to functions/variables.
    Also move OSS-specific hw_params helper functions to pcm_oss.c.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index eedc6cb038bb..786f88145ee8 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -289,6 +289,7 @@ void snd_pcm_set_ops(struct snd_pcm *pcm, int direction, struct snd_pcm_ops *ops
 		substream->ops = ops;
 }
 
+EXPORT_SYMBOL(snd_pcm_set_ops);
 
 /**
  * snd_pcm_sync - set the PCM sync id
@@ -306,13 +307,12 @@ void snd_pcm_set_sync(struct snd_pcm_substream *substream)
 	runtime->sync.id32[3] = -1;
 }
 
+EXPORT_SYMBOL(snd_pcm_set_sync);
+
 /*
  *  Standard ioctl routine
  */
 
-/* Code taken from alsa-lib */
-#define assert(a) snd_assert((a), return -EINVAL)
-
 static inline unsigned int div32(unsigned int a, unsigned int b, 
 				 unsigned int *r)
 {
@@ -369,56 +369,6 @@ static inline unsigned int muldiv32(unsigned int a, unsigned int b,
 	return n;
 }
 
-static int snd_interval_refine_min(struct snd_interval *i, unsigned int min, int openmin)
-{
-	int changed = 0;
-	assert(!snd_interval_empty(i));
-	if (i->min < min) {
-		i->min = min;
-		i->openmin = openmin;
-		changed = 1;
-	} else if (i->min == min && !i->openmin && openmin) {
-		i->openmin = 1;
-		changed = 1;
-	}
-	if (i->integer) {
-		if (i->openmin) {
-			i->min++;
-			i->openmin = 0;
-		}
-	}
-	if (snd_interval_checkempty(i)) {
-		snd_interval_none(i);
-		return -EINVAL;
-	}
-	return changed;
-}
-
-static int snd_interval_refine_max(struct snd_interval *i, unsigned int max, int openmax)
-{
-	int changed = 0;
-	assert(!snd_interval_empty(i));
-	if (i->max > max) {
-		i->max = max;
-		i->openmax = openmax;
-		changed = 1;
-	} else if (i->max == max && !i->openmax && openmax) {
-		i->openmax = 1;
-		changed = 1;
-	}
-	if (i->integer) {
-		if (i->openmax) {
-			i->max--;
-			i->openmax = 0;
-		}
-	}
-	if (snd_interval_checkempty(i)) {
-		snd_interval_none(i);
-		return -EINVAL;
-	}
-	return changed;
-}
-
 /**
  * snd_interval_refine - refine the interval value of configurator
  * @i: the interval value to refine
@@ -433,7 +383,7 @@ static int snd_interval_refine_max(struct snd_interval *i, unsigned int max, int
 int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)
 {
 	int changed = 0;
-	assert(!snd_interval_empty(i));
+	snd_assert(!snd_interval_empty(i), return -EINVAL);
 	if (i->min < v->min) {
 		i->min = v->min;
 		i->openmin = v->openmin;
@@ -472,9 +422,11 @@ int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)
 	return changed;
 }
 
+EXPORT_SYMBOL(snd_interval_refine);
+
 static int snd_interval_refine_first(struct snd_interval *i)
 {
-	assert(!snd_interval_empty(i));
+	snd_assert(!snd_interval_empty(i), return -EINVAL);
 	if (snd_interval_single(i))
 		return 0;
 	i->max = i->min;
@@ -486,7 +438,7 @@ static int snd_interval_refine_first(struct snd_interval *i)
 
 static int snd_interval_refine_last(struct snd_interval *i)
 {
-	assert(!snd_interval_empty(i));
+	snd_assert(!snd_interval_empty(i), return -EINVAL);
 	if (snd_interval_single(i))
 		return 0;
 	i->min = i->max;
@@ -496,16 +448,6 @@ static int snd_interval_refine_last(struct snd_interval *i)
 	return 1;
 }
 
-static int snd_interval_refine_set(struct snd_interval *i, unsigned int val)
-{
-	struct snd_interval t;
-	t.empty = 0;
-	t.min = t.max = val;
-	t.openmin = t.openmax = 0;
-	t.integer = 1;
-	return snd_interval_refine(i, &t);
-}
-
 void snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)
 {
 	if (a->empty || b->empty) {
@@ -621,7 +563,6 @@ void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
 	c->integer = 0;
 }
 
-#undef assert
 /* ---- */
 
 
@@ -727,6 +668,8 @@ int snd_interval_ratnum(struct snd_interval *i,
 	return err;
 }
 
+EXPORT_SYMBOL(snd_interval_ratnum);
+
 /**
  * snd_interval_ratden - refine the interval value
  * @i: interval to refine
@@ -877,6 +820,8 @@ int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *
         return changed;
 }
 
+EXPORT_SYMBOL(snd_interval_list);
+
 static int snd_interval_step(struct snd_interval *i, unsigned int min, unsigned int step)
 {
 	unsigned int n;
@@ -953,6 +898,8 @@ int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 	return 0;
 }				    
 
+EXPORT_SYMBOL(snd_pcm_hw_rule_add);
+
 /**
  * snd_pcm_hw_constraint_mask
  * @runtime: PCM runtime instance
@@ -1007,6 +954,8 @@ int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_pa
 	return snd_interval_setinteger(constrs_interval(constrs, var));
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_constraint_integer);
+
 /**
  * snd_pcm_hw_constraint_minmax
  * @runtime: PCM runtime instance
@@ -1028,6 +977,8 @@ int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_par
 	return snd_interval_refine(constrs_interval(constrs, var), &t);
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_constraint_minmax);
+
 static int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,
 				struct snd_pcm_hw_rule *rule)
 {
@@ -1055,6 +1006,8 @@ int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
 				   var, -1);
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_constraint_list);
+
 static int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,
 				   struct snd_pcm_hw_rule *rule)
 {
@@ -1087,6 +1040,8 @@ int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime,
 				   var, -1);
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);
+
 static int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,
 				   struct snd_pcm_hw_rule *rule)
 {
@@ -1118,6 +1073,8 @@ int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime,
 				   var, -1);
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_constraint_ratdens);
+
 static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
 				  struct snd_pcm_hw_rule *rule)
 {
@@ -1149,6 +1106,8 @@ int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime,
 				    SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_constraint_msbits);
+
 static int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,
 				struct snd_pcm_hw_rule *rule)
 {
@@ -1173,6 +1132,8 @@ int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
 				   var, -1);
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_constraint_step);
+
 static int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)
 {
 	static int pow2_sizes[] = {
@@ -1200,6 +1161,8 @@ int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
 				   var, -1);
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);
+
 /* To use the same code we have in alsa-lib */
 #define assert(i) snd_assert((i), return -EINVAL)
 #ifndef INT_MIN
@@ -1224,18 +1187,6 @@ static void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,
 	snd_BUG();
 }
 
-#if 0
-/*
- * snd_pcm_hw_param_any
- */
-int snd_pcm_hw_param_any(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
-			 snd_pcm_hw_param_t var)
-{
-	_snd_pcm_hw_param_any(params, var);
-	return snd_pcm_hw_refine(pcm, params);
-}
-#endif  /*  0  */
-
 void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)
 {
 	unsigned int k;
@@ -1247,18 +1198,7 @@ void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)
 	params->info = ~0U;
 }
 
-#if 0
-/*
- * snd_pcm_hw_params_any
- *
- * Fill PARAMS with full configuration space boundaries
- */
-int snd_pcm_hw_params_any(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params)
-{
-	_snd_pcm_hw_params_any(params);
-	return snd_pcm_hw_refine(pcm, params);
-}
-#endif  /*  0  */
+EXPORT_SYMBOL(_snd_pcm_hw_params_any);
 
 /**
  * snd_pcm_hw_param_value
@@ -1269,8 +1209,8 @@ int snd_pcm_hw_params_any(struct snd_pcm_substream *pcm, struct snd_pcm_hw_param
  * Return the value for field PAR if it's fixed in configuration space 
  *  defined by PARAMS. Return -EINVAL otherwise
  */
-static int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
-				  snd_pcm_hw_param_t var, int *dir)
+int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
+			   snd_pcm_hw_param_t var, int *dir)
 {
 	if (hw_is_mask(var)) {
 		const struct snd_mask *mask = hw_param_mask_c(params, var);
@@ -1292,57 +1232,7 @@ static int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
 	return -EINVAL;
 }
 
-/**
- * snd_pcm_hw_param_value_min
- * @params: the hw_params instance
- * @var: parameter to retrieve
- * @dir: pointer to the direction (-1,0,1) or NULL
- *
- * Return the minimum value for field PAR.
- */
-unsigned int snd_pcm_hw_param_value_min(const struct snd_pcm_hw_params *params,
-					snd_pcm_hw_param_t var, int *dir)
-{
-	if (hw_is_mask(var)) {
-		if (dir)
-			*dir = 0;
-		return snd_mask_min(hw_param_mask_c(params, var));
-	}
-	if (hw_is_interval(var)) {
-		const struct snd_interval *i = hw_param_interval_c(params, var);
-		if (dir)
-			*dir = i->openmin;
-		return snd_interval_min(i);
-	}
-	assert(0);
-	return -EINVAL;
-}
-
-/**
- * snd_pcm_hw_param_value_max
- * @params: the hw_params instance
- * @var: parameter to retrieve
- * @dir: pointer to the direction (-1,0,1) or NULL
- *
- * Return the maximum value for field PAR.
- */
-unsigned int snd_pcm_hw_param_value_max(const struct snd_pcm_hw_params *params,
-					snd_pcm_hw_param_t var, int *dir)
-{
-	if (hw_is_mask(var)) {
-		if (dir)
-			*dir = 0;
-		return snd_mask_max(hw_param_mask_c(params, var));
-	}
-	if (hw_is_interval(var)) {
-		const struct snd_interval *i = hw_param_interval_c(params, var);
-		if (dir)
-			*dir = - (int) i->openmax;
-		return snd_interval_max(i);
-	}
-	assert(0);
-	return -EINVAL;
-}
+EXPORT_SYMBOL(snd_pcm_hw_param_value);
 
 void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,
 				snd_pcm_hw_param_t var)
@@ -1360,42 +1250,7 @@ void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,
 	}
 }
 
-int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,
-				 snd_pcm_hw_param_t var)
-{
-	int changed;
-	assert(hw_is_interval(var));
-	changed = snd_interval_setinteger(hw_param_interval(params, var));
-	if (changed) {
-		params->cmask |= 1 << var;
-		params->rmask |= 1 << var;
-	}
-	return changed;
-}
-	
-#if 0
-/*
- * snd_pcm_hw_param_setinteger
- *
- * Inside configuration space defined by PARAMS remove from PAR all 
- * non integer values. Reduce configuration space accordingly.
- * Return -EINVAL if the configuration space is empty
- */
-int snd_pcm_hw_param_setinteger(struct snd_pcm_substream *pcm, 
-				struct snd_pcm_hw_params *params,
-				snd_pcm_hw_param_t var)
-{
-	int changed = _snd_pcm_hw_param_setinteger(params, var);
-	if (changed < 0)
-		return changed;
-	if (params->rmask) {
-		int err = snd_pcm_hw_refine(pcm, params);
-		if (err < 0)
-			return err;
-	}
-	return 0;
-}
-#endif  /*  0  */
+EXPORT_SYMBOL(_snd_pcm_hw_param_setempty);
 
 static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
 				   snd_pcm_hw_param_t var)
@@ -1428,9 +1283,9 @@ static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
  * values > minimum. Reduce configuration space accordingly.
  * Return the minimum.
  */
-static int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, 
-				  struct snd_pcm_hw_params *params, 
-				  snd_pcm_hw_param_t var, int *dir)
+int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, 
+			   struct snd_pcm_hw_params *params, 
+			   snd_pcm_hw_param_t var, int *dir)
 {
 	int changed = _snd_pcm_hw_param_first(params, var);
 	if (changed < 0)
@@ -1442,6 +1297,8 @@ static int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm,
 	return snd_pcm_hw_param_value(params, var, dir);
 }
 
+EXPORT_SYMBOL(snd_pcm_hw_param_first);
+
 static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
 				  snd_pcm_hw_param_t var)
 {
@@ -1473,9 +1330,9 @@ static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
  * values < maximum. Reduce configuration space accordingly.
  * Return the maximum.
  */
-static int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, 
-				 struct snd_pcm_hw_params *params,
-				 snd_pcm_hw_param_t var, int *dir)
+int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, 
+			  struct snd_pcm_hw_params *params,
+			  snd_pcm_hw_param_t var, int *dir)
 {
 	int changed = _snd_pcm_hw_param_last(params, var);
 	if (changed < 0)
@@ -1487,367 +1344,7 @@ static int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm,
 	return snd_pcm_hw_param_value(params, var, dir);
 }
 
-int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,
-			  snd_pcm_hw_param_t var, unsigned int val, int dir)
-{
-	int changed;
-	int open = 0;
-	if (dir) {
-		if (dir > 0) {
-			open = 1;
-		} else if (dir < 0) {
-			if (val > 0) {
-				open = 1;
-				val--;
-			}
-		}
-	}
-	if (hw_is_mask(var))
-		changed = snd_mask_refine_min(hw_param_mask(params, var), val + !!open);
-	else if (hw_is_interval(var))
-		changed = snd_interval_refine_min(hw_param_interval(params, var), val, open);
-	else {
-		assert(0);
-		return -EINVAL;
-	}
-	if (changed) {
-		params->cmask |= 1 << var;
-		params->rmask |= 1 << var;
-	}
-	return changed;
-}
-
-/**
- * snd_pcm_hw_param_min
- * @pcm: PCM instance
- * @params: the hw_params instance
- * @var: parameter to retrieve
- * @val: minimal value
- * @dir: pointer to the direction (-1,0,1) or NULL
- *
- * Inside configuration space defined by PARAMS remove from PAR all 
- * values < VAL. Reduce configuration space accordingly.
- * Return new minimum or -EINVAL if the configuration space is empty
- */
-static int snd_pcm_hw_param_min(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
-				snd_pcm_hw_param_t var, unsigned int val,
-				int *dir)
-{
-	int changed = _snd_pcm_hw_param_min(params, var, val, dir ? *dir : 0);
-	if (changed < 0)
-		return changed;
-	if (params->rmask) {
-		int err = snd_pcm_hw_refine(pcm, params);
-		if (err < 0)
-			return err;
-	}
-	return snd_pcm_hw_param_value_min(params, var, dir);
-}
-
-static int _snd_pcm_hw_param_max(struct snd_pcm_hw_params *params,
-				 snd_pcm_hw_param_t var, unsigned int val,
-				 int dir)
-{
-	int changed;
-	int open = 0;
-	if (dir) {
-		if (dir < 0) {
-			open = 1;
-		} else if (dir > 0) {
-			open = 1;
-			val++;
-		}
-	}
-	if (hw_is_mask(var)) {
-		if (val == 0 && open) {
-			snd_mask_none(hw_param_mask(params, var));
-			changed = -EINVAL;
-		} else
-			changed = snd_mask_refine_max(hw_param_mask(params, var), val - !!open);
-	} else if (hw_is_interval(var))
-		changed = snd_interval_refine_max(hw_param_interval(params, var), val, open);
-	else {
-		assert(0);
-		return -EINVAL;
-	}
-	if (changed) {
-		params->cmask |= 1 << var;
-		params->rmask |= 1 << var;
-	}
-	return changed;
-}
-
-/**
- * snd_pcm_hw_param_max
- * @pcm: PCM instance
- * @params: the hw_params instance
- * @var: parameter to retrieve
- * @val: maximal value
- * @dir: pointer to the direction (-1,0,1) or NULL
- *
- * Inside configuration space defined by PARAMS remove from PAR all 
- *  values >= VAL + 1. Reduce configuration space accordingly.
- *  Return new maximum or -EINVAL if the configuration space is empty
- */
-static int snd_pcm_hw_param_max(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
-				snd_pcm_hw_param_t var, unsigned int val,
-				int *dir)
-{
-	int changed = _snd_pcm_hw_param_max(params, var, val, dir ? *dir : 0);
-	if (changed < 0)
-		return changed;
-	if (params->rmask) {
-		int err = snd_pcm_hw_refine(pcm, params);
-		if (err < 0)
-			return err;
-	}
-	return snd_pcm_hw_param_value_max(params, var, dir);
-}
-
-int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,
-			  snd_pcm_hw_param_t var, unsigned int val, int dir)
-{
-	int changed;
-	if (hw_is_mask(var)) {
-		struct snd_mask *m = hw_param_mask(params, var);
-		if (val == 0 && dir < 0) {
-			changed = -EINVAL;
-			snd_mask_none(m);
-		} else {
-			if (dir > 0)
-				val++;
-			else if (dir < 0)
-				val--;
-			changed = snd_mask_refine_set(hw_param_mask(params, var), val);
-		}
-	} else if (hw_is_interval(var)) {
-		struct snd_interval *i = hw_param_interval(params, var);
-		if (val == 0 && dir < 0) {
-			changed = -EINVAL;
-			snd_interval_none(i);
-		} else if (dir == 0)
-			changed = snd_interval_refine_set(i, val);
-		else {
-			struct snd_interval t;
-			t.openmin = 1;
-			t.openmax = 1;
-			t.empty = 0;
-			t.integer = 0;
-			if (dir < 0) {
-				t.min = val - 1;
-				t.max = val;
-			} else {
-				t.min = val;
-				t.max = val+1;
-			}
-			changed = snd_interval_refine(i, &t);
-		}
-	} else {
-		assert(0);
-		return -EINVAL;
-	}
-	if (changed) {
-		params->cmask |= 1 << var;
-		params->rmask |= 1 << var;
-	}
-	return changed;
-}
-
-/**
- * snd_pcm_hw_param_set
- * @pcm: PCM instance
- * @params: the hw_params instance
- * @var: parameter to retrieve
- * @val: value to set
- * @dir: pointer to the direction (-1,0,1) or NULL
- *
- * Inside configuration space defined by PARAMS remove from PAR all 
- * values != VAL. Reduce configuration space accordingly.
- *  Return VAL or -EINVAL if the configuration space is empty
- */
-int snd_pcm_hw_param_set(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
-			 snd_pcm_hw_param_t var, unsigned int val, int dir)
-{
-	int changed = _snd_pcm_hw_param_set(params, var, val, dir);
-	if (changed < 0)
-		return changed;
-	if (params->rmask) {
-		int err = snd_pcm_hw_refine(pcm, params);
-		if (err < 0)
-			return err;
-	}
-	return snd_pcm_hw_param_value(params, var, NULL);
-}
-
-static int _snd_pcm_hw_param_mask(struct snd_pcm_hw_params *params,
-				  snd_pcm_hw_param_t var, const struct snd_mask *val)
-{
-	int changed;
-	assert(hw_is_mask(var));
-	changed = snd_mask_refine(hw_param_mask(params, var), val);
-	if (changed) {
-		params->cmask |= 1 << var;
-		params->rmask |= 1 << var;
-	}
-	return changed;
-}
-
-/**
- * snd_pcm_hw_param_mask
- * @pcm: PCM instance
- * @params: the hw_params instance
- * @var: parameter to retrieve
- * @val: mask to apply
- *
- * Inside configuration space defined by PARAMS remove from PAR all values
- * not contained in MASK. Reduce configuration space accordingly.
- * This function can be called only for SNDRV_PCM_HW_PARAM_ACCESS,
- * SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
- * Return 0 on success or -EINVAL
- * if the configuration space is empty
- */
-int snd_pcm_hw_param_mask(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
-			  snd_pcm_hw_param_t var, const struct snd_mask *val)
-{
-	int changed = _snd_pcm_hw_param_mask(params, var, val);
-	if (changed < 0)
-		return changed;
-	if (params->rmask) {
-		int err = snd_pcm_hw_refine(pcm, params);
-		if (err < 0)
-			return err;
-	}
-	return 0;
-}
-
-static int boundary_sub(int a, int adir,
-			int b, int bdir,
-			int *c, int *cdir)
-{
-	adir = adir < 0 ? -1 : (adir > 0 ? 1 : 0);
-	bdir = bdir < 0 ? -1 : (bdir > 0 ? 1 : 0);
-	*c = a - b;
-	*cdir = adir - bdir;
-	if (*cdir == -2) {
-		assert(*c > INT_MIN);
-		(*c)--;
-	} else if (*cdir == 2) {
-		assert(*c < INT_MAX);
-		(*c)++;
-	}
-	return 0;
-}
-
-static int boundary_lt(unsigned int a, int adir,
-		       unsigned int b, int bdir)
-{
-	assert(a > 0 || adir >= 0);
-	assert(b > 0 || bdir >= 0);
-	if (adir < 0) {
-		a--;
-		adir = 1;
-	} else if (adir > 0)
-		adir = 1;
-	if (bdir < 0) {
-		b--;
-		bdir = 1;
-	} else if (bdir > 0)
-		bdir = 1;
-	return a < b || (a == b && adir < bdir);
-}
-
-/* Return 1 if min is nearer to best than max */
-static int boundary_nearer(int min, int mindir,
-			   int best, int bestdir,
-			   int max, int maxdir)
-{
-	int dmin, dmindir;
-	int dmax, dmaxdir;
-	boundary_sub(best, bestdir, min, mindir, &dmin, &dmindir);
-	boundary_sub(max, maxdir, best, bestdir, &dmax, &dmaxdir);
-	return boundary_lt(dmin, dmindir, dmax, dmaxdir);
-}
-
-/**
- * snd_pcm_hw_param_near
- * @pcm: PCM instance
- * @params: the hw_params instance
- * @var: parameter to retrieve
- * @best: value to set
- * @dir: pointer to the direction (-1,0,1) or NULL
- *
- * Inside configuration space defined by PARAMS set PAR to the available value
- * nearest to VAL. Reduce configuration space accordingly.
- * This function cannot be called for SNDRV_PCM_HW_PARAM_ACCESS,
- * SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
- * Return the value found.
-  */
-int snd_pcm_hw_param_near(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
-			  snd_pcm_hw_param_t var, unsigned int best, int *dir)
-{
-	struct snd_pcm_hw_params *save = NULL;
-	int v;
-	unsigned int saved_min;
-	int last = 0;
-	int min, max;
-	int mindir, maxdir;
-	int valdir = dir ? *dir : 0;
-	/* FIXME */
-	if (best > INT_MAX)
-		best = INT_MAX;
-	min = max = best;
-	mindir = maxdir = valdir;
-	if (maxdir > 0)
-		maxdir = 0;
-	else if (maxdir == 0)
-		maxdir = -1;
-	else {
-		maxdir = 1;
-		max--;
-	}
-	save = kmalloc(sizeof(*save), GFP_KERNEL);
-	if (save == NULL)
-		return -ENOMEM;
-	*save = *params;
-	saved_min = min;
-	min = snd_pcm_hw_param_min(pcm, params, var, min, &mindir);
-	if (min >= 0) {
-		struct snd_pcm_hw_params *params1;
-		if (max < 0)
-			goto _end;
-		if ((unsigned int)min == saved_min && mindir == valdir)
-			goto _end;
-		params1 = kmalloc(sizeof(*params1), GFP_KERNEL);
-		if (params1 == NULL) {
-			kfree(save);
-			return -ENOMEM;
-		}
-		*params1 = *save;
-		max = snd_pcm_hw_param_max(pcm, params1, var, max, &maxdir);
-		if (max < 0) {
-			kfree(params1);
-			goto _end;
-		}
-		if (boundary_nearer(max, maxdir, best, valdir, min, mindir)) {
-			*params = *params1;
-			last = 1;
-		}
-		kfree(params1);
-	} else {
-		*params = *save;
-		max = snd_pcm_hw_param_max(pcm, params, var, max, &maxdir);
-		assert(max >= 0);
-		last = 1;
-	}
- _end:
- 	kfree(save);
-	if (last)
-		v = snd_pcm_hw_param_last(pcm, params, var, dir);
-	else
-		v = snd_pcm_hw_param_first(pcm, params, var, dir);
-	assert(v >= 0);
-	return v;
-}
+EXPORT_SYMBOL(snd_pcm_hw_param_last);
 
 /**
  * snd_pcm_hw_param_choose
@@ -1967,6 +1464,8 @@ int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 	return -ENXIO;
 }
 
+EXPORT_SYMBOL(snd_pcm_lib_ioctl);
+
 /*
  *  Conditions
  */
@@ -2101,6 +1600,8 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 }
 
+EXPORT_SYMBOL(snd_pcm_period_elapsed);
+
 static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 				      unsigned int hwoff,
 				      unsigned long data, unsigned int off,
@@ -2308,6 +1809,8 @@ snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const v
 				  snd_pcm_lib_write_transfer);
 }
 
+EXPORT_SYMBOL(snd_pcm_lib_write);
+
 static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
 				       unsigned int hwoff,
 				       unsigned long data, unsigned int off,
@@ -2370,6 +1873,8 @@ snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 				  nonblock, snd_pcm_lib_writev_transfer);
 }
 
+EXPORT_SYMBOL(snd_pcm_lib_writev);
+
 static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, 
 				     unsigned int hwoff,
 				     unsigned long data, unsigned int off,
@@ -2578,6 +2083,8 @@ snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __u
 	return snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);
 }
 
+EXPORT_SYMBOL(snd_pcm_lib_read);
+
 static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
 				      unsigned int hwoff,
 				      unsigned long data, unsigned int off,
@@ -2635,52 +2142,4 @@ snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 	return snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);
 }
 
-/*
- *  Exported symbols
- */
-
-EXPORT_SYMBOL(snd_interval_refine);
-EXPORT_SYMBOL(snd_interval_list);
-EXPORT_SYMBOL(snd_interval_ratnum);
-EXPORT_SYMBOL(_snd_pcm_hw_params_any);
-EXPORT_SYMBOL(_snd_pcm_hw_param_min);
-EXPORT_SYMBOL(_snd_pcm_hw_param_set);
-EXPORT_SYMBOL(_snd_pcm_hw_param_setempty);
-EXPORT_SYMBOL(_snd_pcm_hw_param_setinteger);
-EXPORT_SYMBOL(snd_pcm_hw_param_value_min);
-EXPORT_SYMBOL(snd_pcm_hw_param_value_max);
-EXPORT_SYMBOL(snd_pcm_hw_param_mask);
-EXPORT_SYMBOL(snd_pcm_hw_param_first);
-EXPORT_SYMBOL(snd_pcm_hw_param_last);
-EXPORT_SYMBOL(snd_pcm_hw_param_near);
-EXPORT_SYMBOL(snd_pcm_hw_param_set);
-EXPORT_SYMBOL(snd_pcm_hw_refine);
-EXPORT_SYMBOL(snd_pcm_hw_constraints_init);
-EXPORT_SYMBOL(snd_pcm_hw_constraints_complete);
-EXPORT_SYMBOL(snd_pcm_hw_constraint_list);
-EXPORT_SYMBOL(snd_pcm_hw_constraint_step);
-EXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);
-EXPORT_SYMBOL(snd_pcm_hw_constraint_ratdens);
-EXPORT_SYMBOL(snd_pcm_hw_constraint_msbits);
-EXPORT_SYMBOL(snd_pcm_hw_constraint_minmax);
-EXPORT_SYMBOL(snd_pcm_hw_constraint_integer);
-EXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);
-EXPORT_SYMBOL(snd_pcm_hw_rule_add);
-EXPORT_SYMBOL(snd_pcm_set_ops);
-EXPORT_SYMBOL(snd_pcm_set_sync);
-EXPORT_SYMBOL(snd_pcm_lib_ioctl);
-EXPORT_SYMBOL(snd_pcm_stop);
-EXPORT_SYMBOL(snd_pcm_period_elapsed);
-EXPORT_SYMBOL(snd_pcm_lib_write);
-EXPORT_SYMBOL(snd_pcm_lib_read);
-EXPORT_SYMBOL(snd_pcm_lib_writev);
 EXPORT_SYMBOL(snd_pcm_lib_readv);
-EXPORT_SYMBOL(snd_pcm_lib_buffer_bytes);
-EXPORT_SYMBOL(snd_pcm_lib_period_bytes);
-/* pcm_memory.c */
-EXPORT_SYMBOL(snd_pcm_lib_preallocate_free_for_all);
-EXPORT_SYMBOL(snd_pcm_lib_preallocate_pages);
-EXPORT_SYMBOL(snd_pcm_lib_preallocate_pages_for_all);
-EXPORT_SYMBOL(snd_pcm_sgbuf_ops_page);
-EXPORT_SYMBOL(snd_pcm_lib_malloc_pages);
-EXPORT_SYMBOL(snd_pcm_lib_free_pages);

commit 61fb63c096a2e88b87742eaecfe88912b89f57cf
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Mon Apr 24 21:57:16 2006 +0200

    [ALSA] PCM core - introduce CONFIG_SND_PCM_XRUN_DEBUG
    
    This patch makes the XRUN (overrun/underrun) notification code optional.
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 230a940d00bd..eedc6cb038bb 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -130,7 +130,7 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 static void xrun(struct snd_pcm_substream *substream)
 {
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
-#ifdef CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	if (substream->pstr->xrun_debug) {
 		snd_printd(KERN_DEBUG "XRUN: pcmC%dD%d%c\n",
 			   substream->pcm->card->number,
@@ -204,7 +204,7 @@ static inline int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *subs
 	delta = hw_ptr_interrupt - new_hw_ptr;
 	if (delta > 0) {
 		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
-#ifdef CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
 			if (runtime->periods > 1 && substream->pstr->xrun_debug) {
 				snd_printd(KERN_ERR "Unexpected hw_pointer value [1] (stream = %i, delta: -%ld, max jitter = %ld): wrong interrupt acknowledge?\n", substream->stream, (long) delta, runtime->buffer_size / 2);
 				if (substream->pstr->xrun_debug > 1)
@@ -249,7 +249,7 @@ int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 	delta = old_hw_ptr - new_hw_ptr;
 	if (delta > 0) {
 		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
-#ifdef CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
 			if (runtime->periods > 2 && substream->pstr->xrun_debug) {
 				snd_printd(KERN_ERR "Unexpected hw_pointer value [2] (stream = %i, delta: -%ld, max jitter = %ld): wrong interrupt acknowledge?\n", substream->stream, (long) delta, runtime->buffer_size / 2);
 				if (substream->pstr->xrun_debug > 1)

commit 3bf75f9b90c981f18f27a0d35a44f488ab68c8ea
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 27 16:40:49 2006 +0200

    [ALSA] Clean up PCM codes (take 2)
    
    - Clean up initialization and destruction of substream instance
      Now snd_pcm_open_substream() alone does most initialization jobs.
      Add pcm_release callback for cleaning up at snd_pcm_release_substream()
    - Tidy up PCM oss code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index eeba2f060955..230a940d00bd 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2299,19 +2299,7 @@ snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const v
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	snd_assert(substream->ffile != NULL, return -ENXIO);
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-	if (substream->oss.oss) {
-		struct snd_pcm_oss_setup *setup = substream->oss.setup;
-		if (setup != NULL) {
-			if (setup->nonblock)
-				nonblock = 1;
-			else if (setup->block)
-				nonblock = 0;
-		}
-	}
-#endif
 
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
 	    runtime->channels > 1)
@@ -2374,19 +2362,7 @@ snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	snd_assert(substream->ffile != NULL, return -ENXIO);
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-	if (substream->oss.oss) {
-		struct snd_pcm_oss_setup *setup = substream->oss.setup;
-		if (setup != NULL) {
-			if (setup->nonblock)
-				nonblock = 1;
-			else if (setup->block)
-				nonblock = 0;
-		}
-	}
-#endif
 
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
 		return -EINVAL;
@@ -2596,19 +2572,7 @@ snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __u
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	snd_assert(substream->ffile != NULL, return -ENXIO);
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-	if (substream->oss.oss) {
-		struct snd_pcm_oss_setup *setup = substream->oss.setup;
-		if (setup != NULL) {
-			if (setup->nonblock)
-				nonblock = 1;
-			else if (setup->block)
-				nonblock = 0;
-		}
-	}
-#endif
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)
 		return -EINVAL;
 	return snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);
@@ -2665,20 +2629,7 @@ snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
 
-	snd_assert(substream->ffile != NULL, return -ENXIO);
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-	if (substream->oss.oss) {
-		struct snd_pcm_oss_setup *setup = substream->oss.setup;
-		if (setup != NULL) {
-			if (setup->nonblock)
-				nonblock = 1;
-			else if (setup->block)
-				nonblock = 0;
-		}
-	}
-#endif
-
 	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
 		return -EINVAL;
 	return snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);

commit 235475cb7715852c42118fd8d8ec67b534ab6e8b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Dec 7 15:28:07 2005 +0100

    [ALSA] pcm - Fix wrong asserts
    
    Modules: PCM Midlevel
    
    Fixed wrong or supreflous snd_assert()'s.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index c58ec67d1cbf..eeba2f060955 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -56,9 +56,8 @@ void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_ufram
 				runtime->silence_filled = 0;
 			runtime->silence_start = runtime->control->appl_ptr;
 		}
-		if (runtime->silence_filled == runtime->buffer_size)
+		if (runtime->silence_filled >= runtime->buffer_size)
 			return;
-		snd_assert(runtime->silence_filled <= runtime->buffer_size, return);
 		noise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;
 		if (noise_dist >= (snd_pcm_sframes_t) runtime->silence_threshold)
 			return;
@@ -2006,8 +2005,8 @@ void snd_pcm_tick_prepare(struct snd_pcm_substream *substream)
 			   runtime->silence_filled < runtime->buffer_size) {
 			snd_pcm_sframes_t noise_dist;
 			noise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;
-			snd_assert(noise_dist <= (snd_pcm_sframes_t)runtime->silence_threshold, );
-			frames = noise_dist - runtime->silence_threshold;
+			if (noise_dist > (snd_pcm_sframes_t)runtime->silence_threshold)
+				frames = noise_dist - runtime->silence_threshold;
 		}
 		avail = snd_pcm_playback_avail(runtime);
 	} else {

commit 877211f5e1b1196179ba1290e8e1a3dc00427c55
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:59:38 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCM
    
    Modules: PCM Midlevel
    
    Remove xxx_t typedefs from the core PCM codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3dbf9bf2ac16..c58ec67d1cbf 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -39,9 +39,9 @@
  *
  * when runtime->silence_size >= runtime->boundary - fill processed area with silence immediately
  */
-void snd_pcm_playback_silence(snd_pcm_substream_t *substream, snd_pcm_uframes_t new_hw_ptr)
+void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t frames, ofs, transfer;
 
 	if (runtime->silence_size < runtime->boundary) {
@@ -128,7 +128,7 @@ void snd_pcm_playback_silence(snd_pcm_substream_t *substream, snd_pcm_uframes_t
 	}
 }
 
-static void xrun(snd_pcm_substream_t *substream)
+static void xrun(struct snd_pcm_substream *substream)
 {
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 #ifdef CONFIG_SND_DEBUG
@@ -143,8 +143,8 @@ static void xrun(snd_pcm_substream_t *substream)
 #endif
 }
 
-static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(snd_pcm_substream_t *substream,
-							  snd_pcm_runtime_t *runtime)
+static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(struct snd_pcm_substream *substream,
+							  struct snd_pcm_runtime *runtime)
 {
 	snd_pcm_uframes_t pos;
 
@@ -162,8 +162,8 @@ static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(snd_pcm_substream_t *s
 	return pos;
 }
 
-static inline int snd_pcm_update_hw_ptr_post(snd_pcm_substream_t *substream,
-					     snd_pcm_runtime_t *runtime)
+static inline int snd_pcm_update_hw_ptr_post(struct snd_pcm_substream *substream,
+					     struct snd_pcm_runtime *runtime)
 {
 	snd_pcm_uframes_t avail;
 
@@ -185,9 +185,9 @@ static inline int snd_pcm_update_hw_ptr_post(snd_pcm_substream_t *substream,
 	return 0;
 }
 
-static inline int snd_pcm_update_hw_ptr_interrupt(snd_pcm_substream_t *substream)
+static inline int snd_pcm_update_hw_ptr_interrupt(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t pos;
 	snd_pcm_uframes_t new_hw_ptr, hw_ptr_interrupt;
 	snd_pcm_sframes_t delta;
@@ -232,9 +232,9 @@ static inline int snd_pcm_update_hw_ptr_interrupt(snd_pcm_substream_t *substream
 }
 
 /* CAUTION: call it with irq disabled */
-int snd_pcm_update_hw_ptr(snd_pcm_substream_t *substream)
+int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t pos;
 	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr;
 	snd_pcm_sframes_t delta;
@@ -281,10 +281,10 @@ int snd_pcm_update_hw_ptr(snd_pcm_substream_t *substream)
  *
  * Sets the given PCM operators to the pcm instance.
  */
-void snd_pcm_set_ops(snd_pcm_t *pcm, int direction, snd_pcm_ops_t *ops)
+void snd_pcm_set_ops(struct snd_pcm *pcm, int direction, struct snd_pcm_ops *ops)
 {
-	snd_pcm_str_t *stream = &pcm->streams[direction];
-	snd_pcm_substream_t *substream;
+	struct snd_pcm_str *stream = &pcm->streams[direction];
+	struct snd_pcm_substream *substream;
 	
 	for (substream = stream->substream; substream != NULL; substream = substream->next)
 		substream->ops = ops;
@@ -297,9 +297,9 @@ void snd_pcm_set_ops(snd_pcm_t *pcm, int direction, snd_pcm_ops_t *ops)
  *
  * Sets the PCM sync identifier for the card.
  */
-void snd_pcm_set_sync(snd_pcm_substream_t * substream)
+void snd_pcm_set_sync(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	
 	runtime->sync.id32[0] = substream->pcm->card->number;
 	runtime->sync.id32[1] = -1;
@@ -370,7 +370,7 @@ static inline unsigned int muldiv32(unsigned int a, unsigned int b,
 	return n;
 }
 
-static int snd_interval_refine_min(snd_interval_t *i, unsigned int min, int openmin)
+static int snd_interval_refine_min(struct snd_interval *i, unsigned int min, int openmin)
 {
 	int changed = 0;
 	assert(!snd_interval_empty(i));
@@ -395,7 +395,7 @@ static int snd_interval_refine_min(snd_interval_t *i, unsigned int min, int open
 	return changed;
 }
 
-static int snd_interval_refine_max(snd_interval_t *i, unsigned int max, int openmax)
+static int snd_interval_refine_max(struct snd_interval *i, unsigned int max, int openmax)
 {
 	int changed = 0;
 	assert(!snd_interval_empty(i));
@@ -431,7 +431,7 @@ static int snd_interval_refine_max(snd_interval_t *i, unsigned int max, int open
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-int snd_interval_refine(snd_interval_t *i, const snd_interval_t *v)
+int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)
 {
 	int changed = 0;
 	assert(!snd_interval_empty(i));
@@ -473,7 +473,7 @@ int snd_interval_refine(snd_interval_t *i, const snd_interval_t *v)
 	return changed;
 }
 
-static int snd_interval_refine_first(snd_interval_t *i)
+static int snd_interval_refine_first(struct snd_interval *i)
 {
 	assert(!snd_interval_empty(i));
 	if (snd_interval_single(i))
@@ -485,7 +485,7 @@ static int snd_interval_refine_first(snd_interval_t *i)
 	return 1;
 }
 
-static int snd_interval_refine_last(snd_interval_t *i)
+static int snd_interval_refine_last(struct snd_interval *i)
 {
 	assert(!snd_interval_empty(i));
 	if (snd_interval_single(i))
@@ -497,9 +497,9 @@ static int snd_interval_refine_last(snd_interval_t *i)
 	return 1;
 }
 
-static int snd_interval_refine_set(snd_interval_t *i, unsigned int val)
+static int snd_interval_refine_set(struct snd_interval *i, unsigned int val)
 {
-	snd_interval_t t;
+	struct snd_interval t;
 	t.empty = 0;
 	t.min = t.max = val;
 	t.openmin = t.openmax = 0;
@@ -507,7 +507,7 @@ static int snd_interval_refine_set(snd_interval_t *i, unsigned int val)
 	return snd_interval_refine(i, &t);
 }
 
-void snd_interval_mul(const snd_interval_t *a, const snd_interval_t *b, snd_interval_t *c)
+void snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)
 {
 	if (a->empty || b->empty) {
 		snd_interval_none(c);
@@ -531,7 +531,7 @@ void snd_interval_mul(const snd_interval_t *a, const snd_interval_t *b, snd_inte
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-void snd_interval_div(const snd_interval_t *a, const snd_interval_t *b, snd_interval_t *c)
+void snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)
 {
 	unsigned int r;
 	if (a->empty || b->empty) {
@@ -566,8 +566,8 @@ void snd_interval_div(const snd_interval_t *a, const snd_interval_t *b, snd_inte
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-void snd_interval_muldivk(const snd_interval_t *a, const snd_interval_t *b,
-		      unsigned int k, snd_interval_t *c)
+void snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b,
+		      unsigned int k, struct snd_interval *c)
 {
 	unsigned int r;
 	if (a->empty || b->empty) {
@@ -597,8 +597,8 @@ void snd_interval_muldivk(const snd_interval_t *a, const snd_interval_t *b,
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-void snd_interval_mulkdiv(const snd_interval_t *a, unsigned int k,
-		      const snd_interval_t *b, snd_interval_t *c)
+void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
+		      const struct snd_interval *b, struct snd_interval *c)
 {
 	unsigned int r;
 	if (a->empty || b->empty) {
@@ -636,13 +636,13 @@ void snd_interval_mulkdiv(const snd_interval_t *a, unsigned int k,
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-int snd_interval_ratnum(snd_interval_t *i,
-		    unsigned int rats_count, ratnum_t *rats,
-		    unsigned int *nump, unsigned int *denp)
+int snd_interval_ratnum(struct snd_interval *i,
+			unsigned int rats_count, struct snd_ratnum *rats,
+			unsigned int *nump, unsigned int *denp)
 {
 	unsigned int best_num, best_diff, best_den;
 	unsigned int k;
-	snd_interval_t t;
+	struct snd_interval t;
 	int err;
 
 	best_num = best_den = best_diff = 0;
@@ -731,20 +731,20 @@ int snd_interval_ratnum(snd_interval_t *i,
 /**
  * snd_interval_ratden - refine the interval value
  * @i: interval to refine
- * @rats_count: number of ratden_t
- * @rats: ratden_t array
+ * @rats_count: number of struct ratden
+ * @rats: struct ratden array
  * @nump: pointer to store the resultant numerator
  * @denp: pointer to store the resultant denominator
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-static int snd_interval_ratden(snd_interval_t *i,
-			       unsigned int rats_count, ratden_t *rats,
+static int snd_interval_ratden(struct snd_interval *i,
+			       unsigned int rats_count, struct snd_ratden *rats,
 			       unsigned int *nump, unsigned int *denp)
 {
 	unsigned int best_num, best_diff, best_den;
 	unsigned int k;
-	snd_interval_t t;
+	struct snd_interval t;
 	int err;
 
 	best_num = best_den = best_diff = 0;
@@ -837,7 +837,7 @@ static int snd_interval_ratden(snd_interval_t *i,
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
-int snd_interval_list(snd_interval_t *i, unsigned int count, unsigned int *list, unsigned int mask)
+int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *list, unsigned int mask)
 {
         unsigned int k;
 	int changed = 0;
@@ -878,7 +878,7 @@ int snd_interval_list(snd_interval_t *i, unsigned int count, unsigned int *list,
         return changed;
 }
 
-static int snd_interval_step(snd_interval_t *i, unsigned int min, unsigned int step)
+static int snd_interval_step(struct snd_interval *i, unsigned int min, unsigned int step)
 {
 	unsigned int n;
 	int changed = 0;
@@ -912,18 +912,18 @@ static int snd_interval_step(snd_interval_t *i, unsigned int min, unsigned int s
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_pcm_hw_rule_add(snd_pcm_runtime_t *runtime, unsigned int cond,
+int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
 			int var,
 			snd_pcm_hw_rule_func_t func, void *private,
 			int dep, ...)
 {
-	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
-	snd_pcm_hw_rule_t *c;
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	struct snd_pcm_hw_rule *c;
 	unsigned int k;
 	va_list args;
 	va_start(args, dep);
 	if (constrs->rules_num >= constrs->rules_all) {
-		snd_pcm_hw_rule_t *new;
+		struct snd_pcm_hw_rule *new;
 		unsigned int new_rules = constrs->rules_all + 16;
 		new = kcalloc(new_rules, sizeof(*c), GFP_KERNEL);
 		if (!new)
@@ -962,11 +962,11 @@ int snd_pcm_hw_rule_add(snd_pcm_runtime_t *runtime, unsigned int cond,
  *
  * Apply the constraint of the given bitmap mask to a mask parameter.
  */
-int snd_pcm_hw_constraint_mask(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 			       u_int32_t mask)
 {
-	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
-	snd_mask_t *maskp = constrs_mask(constrs, var);
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	struct snd_mask *maskp = constrs_mask(constrs, var);
 	*maskp->bits &= mask;
 	memset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */
 	if (*maskp->bits == 0)
@@ -982,11 +982,11 @@ int snd_pcm_hw_constraint_mask(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t va
  *
  * Apply the constraint of the given bitmap mask to a mask parameter.
  */
-int snd_pcm_hw_constraint_mask64(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 				 u_int64_t mask)
 {
-	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
-	snd_mask_t *maskp = constrs_mask(constrs, var);
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	struct snd_mask *maskp = constrs_mask(constrs, var);
 	maskp->bits[0] &= (u_int32_t)mask;
 	maskp->bits[1] &= (u_int32_t)(mask >> 32);
 	memset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */
@@ -1002,9 +1002,9 @@ int snd_pcm_hw_constraint_mask64(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t
  *
  * Apply the constraint of integer to an interval parameter.
  */
-int snd_pcm_hw_constraint_integer(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var)
+int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var)
 {
-	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
 	return snd_interval_setinteger(constrs_interval(constrs, var));
 }
 
@@ -1017,11 +1017,11 @@ int snd_pcm_hw_constraint_integer(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t
  * 
  * Apply the min/max range constraint to an interval parameter.
  */
-int snd_pcm_hw_constraint_minmax(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
 				 unsigned int min, unsigned int max)
 {
-	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
-	snd_interval_t t;
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	struct snd_interval t;
 	t.min = min;
 	t.max = max;
 	t.openmin = t.openmax = 0;
@@ -1029,10 +1029,10 @@ int snd_pcm_hw_constraint_minmax(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t
 	return snd_interval_refine(constrs_interval(constrs, var), &t);
 }
 
-static int snd_pcm_hw_rule_list(snd_pcm_hw_params_t *params,
-				snd_pcm_hw_rule_t *rule)
+static int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,
+				struct snd_pcm_hw_rule *rule)
 {
-	snd_pcm_hw_constraint_list_t *list = rule->private;
+	struct snd_pcm_hw_constraint_list *list = rule->private;
 	return snd_interval_list(hw_param_interval(params, rule->var), list->count, list->list, list->mask);
 }		
 
@@ -1046,20 +1046,20 @@ static int snd_pcm_hw_rule_list(snd_pcm_hw_params_t *params,
  * 
  * Apply the list of constraints to an interval parameter.
  */
-int snd_pcm_hw_constraint_list(snd_pcm_runtime_t *runtime,
+int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var,
-			       snd_pcm_hw_constraint_list_t *l)
+			       struct snd_pcm_hw_constraint_list *l)
 {
 	return snd_pcm_hw_rule_add(runtime, cond, var,
 				   snd_pcm_hw_rule_list, l,
 				   var, -1);
 }
 
-static int snd_pcm_hw_rule_ratnums(snd_pcm_hw_params_t *params,
-				   snd_pcm_hw_rule_t *rule)
+static int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,
+				   struct snd_pcm_hw_rule *rule)
 {
-	snd_pcm_hw_constraint_ratnums_t *r = rule->private;
+	struct snd_pcm_hw_constraint_ratnums *r = rule->private;
 	unsigned int num = 0, den = 0;
 	int err;
 	err = snd_interval_ratnum(hw_param_interval(params, rule->var),
@@ -1076,22 +1076,22 @@ static int snd_pcm_hw_rule_ratnums(snd_pcm_hw_params_t *params,
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @var: hw_params variable to apply the ratnums constraint
- * @r: ratnums_t constriants
+ * @r: struct snd_ratnums constriants
  */
-int snd_pcm_hw_constraint_ratnums(snd_pcm_runtime_t *runtime, 
+int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,
-				  snd_pcm_hw_constraint_ratnums_t *r)
+				  struct snd_pcm_hw_constraint_ratnums *r)
 {
 	return snd_pcm_hw_rule_add(runtime, cond, var,
 				   snd_pcm_hw_rule_ratnums, r,
 				   var, -1);
 }
 
-static int snd_pcm_hw_rule_ratdens(snd_pcm_hw_params_t *params,
-				   snd_pcm_hw_rule_t *rule)
+static int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,
+				   struct snd_pcm_hw_rule *rule)
 {
-	snd_pcm_hw_constraint_ratdens_t *r = rule->private;
+	struct snd_pcm_hw_constraint_ratdens *r = rule->private;
 	unsigned int num = 0, den = 0;
 	int err = snd_interval_ratden(hw_param_interval(params, rule->var),
 				  r->nrats, r->rats, &num, &den);
@@ -1107,25 +1107,25 @@ static int snd_pcm_hw_rule_ratdens(snd_pcm_hw_params_t *params,
  * @runtime: PCM runtime instance
  * @cond: condition bits
  * @var: hw_params variable to apply the ratdens constraint
- * @r: ratdens_t constriants
+ * @r: struct snd_ratdens constriants
  */
-int snd_pcm_hw_constraint_ratdens(snd_pcm_runtime_t *runtime, 
+int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, 
 				  unsigned int cond,
 				  snd_pcm_hw_param_t var,
-				  snd_pcm_hw_constraint_ratdens_t *r)
+				  struct snd_pcm_hw_constraint_ratdens *r)
 {
 	return snd_pcm_hw_rule_add(runtime, cond, var,
 				   snd_pcm_hw_rule_ratdens, r,
 				   var, -1);
 }
 
-static int snd_pcm_hw_rule_msbits(snd_pcm_hw_params_t *params,
-				  snd_pcm_hw_rule_t *rule)
+static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
+				  struct snd_pcm_hw_rule *rule)
 {
 	unsigned int l = (unsigned long) rule->private;
 	int width = l & 0xffff;
 	unsigned int msbits = l >> 16;
-	snd_interval_t *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
+	struct snd_interval *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
 	if (snd_interval_single(i) && snd_interval_value(i) == width)
 		params->msbits = msbits;
 	return 0;
@@ -1138,7 +1138,7 @@ static int snd_pcm_hw_rule_msbits(snd_pcm_hw_params_t *params,
  * @width: sample bits width
  * @msbits: msbits width
  */
-int snd_pcm_hw_constraint_msbits(snd_pcm_runtime_t *runtime, 
+int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, 
 				 unsigned int cond,
 				 unsigned int width,
 				 unsigned int msbits)
@@ -1150,8 +1150,8 @@ int snd_pcm_hw_constraint_msbits(snd_pcm_runtime_t *runtime,
 				    SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);
 }
 
-static int snd_pcm_hw_rule_step(snd_pcm_hw_params_t *params,
-				snd_pcm_hw_rule_t *rule)
+static int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,
+				struct snd_pcm_hw_rule *rule)
 {
 	unsigned long step = (unsigned long) rule->private;
 	return snd_interval_step(hw_param_interval(params, rule->var), 0, step);
@@ -1164,7 +1164,7 @@ static int snd_pcm_hw_rule_step(snd_pcm_hw_params_t *params,
  * @var: hw_params variable to apply the step constraint
  * @step: step size
  */
-int snd_pcm_hw_constraint_step(snd_pcm_runtime_t *runtime,
+int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var,
 			       unsigned long step)
@@ -1174,7 +1174,7 @@ int snd_pcm_hw_constraint_step(snd_pcm_runtime_t *runtime,
 				   var, -1);
 }
 
-static int snd_pcm_hw_rule_pow2(snd_pcm_hw_params_t *params, snd_pcm_hw_rule_t *rule)
+static int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)
 {
 	static int pow2_sizes[] = {
 		1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,
@@ -1192,7 +1192,7 @@ static int snd_pcm_hw_rule_pow2(snd_pcm_hw_params_t *params, snd_pcm_hw_rule_t *
  * @cond: condition bits
  * @var: hw_params variable to apply the power-of-2 constraint
  */
-int snd_pcm_hw_constraint_pow2(snd_pcm_runtime_t *runtime,
+int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
 			       unsigned int cond,
 			       snd_pcm_hw_param_t var)
 {
@@ -1202,13 +1202,12 @@ int snd_pcm_hw_constraint_pow2(snd_pcm_runtime_t *runtime,
 }
 
 /* To use the same code we have in alsa-lib */
-#define snd_pcm_t snd_pcm_substream_t
 #define assert(i) snd_assert((i), return -EINVAL)
 #ifndef INT_MIN
 #define INT_MIN ((int)((unsigned int)INT_MAX+1))
 #endif
 
-static void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params,
+static void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,
 				  snd_pcm_hw_param_t var)
 {
 	if (hw_is_mask(var)) {
@@ -1230,7 +1229,7 @@ static void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params,
 /*
  * snd_pcm_hw_param_any
  */
-int snd_pcm_hw_param_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+int snd_pcm_hw_param_any(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
 			 snd_pcm_hw_param_t var)
 {
 	_snd_pcm_hw_param_any(params, var);
@@ -1238,7 +1237,7 @@ int snd_pcm_hw_param_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 }
 #endif  /*  0  */
 
-void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params)
+void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)
 {
 	unsigned int k;
 	memset(params, 0, sizeof(*params));
@@ -1255,7 +1254,7 @@ void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params)
  *
  * Fill PARAMS with full configuration space boundaries
  */
-int snd_pcm_hw_params_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
+int snd_pcm_hw_params_any(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params)
 {
 	_snd_pcm_hw_params_any(params);
 	return snd_pcm_hw_refine(pcm, params);
@@ -1271,11 +1270,11 @@ int snd_pcm_hw_params_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
  * Return the value for field PAR if it's fixed in configuration space 
  *  defined by PARAMS. Return -EINVAL otherwise
  */
-static int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
+static int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
 				  snd_pcm_hw_param_t var, int *dir)
 {
 	if (hw_is_mask(var)) {
-		const snd_mask_t *mask = hw_param_mask_c(params, var);
+		const struct snd_mask *mask = hw_param_mask_c(params, var);
 		if (!snd_mask_single(mask))
 			return -EINVAL;
 		if (dir)
@@ -1283,7 +1282,7 @@ static int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
 		return snd_mask_value(mask);
 	}
 	if (hw_is_interval(var)) {
-		const snd_interval_t *i = hw_param_interval_c(params, var);
+		const struct snd_interval *i = hw_param_interval_c(params, var);
 		if (!snd_interval_single(i))
 			return -EINVAL;
 		if (dir)
@@ -1302,7 +1301,7 @@ static int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
  *
  * Return the minimum value for field PAR.
  */
-unsigned int snd_pcm_hw_param_value_min(const snd_pcm_hw_params_t *params,
+unsigned int snd_pcm_hw_param_value_min(const struct snd_pcm_hw_params *params,
 					snd_pcm_hw_param_t var, int *dir)
 {
 	if (hw_is_mask(var)) {
@@ -1311,7 +1310,7 @@ unsigned int snd_pcm_hw_param_value_min(const snd_pcm_hw_params_t *params,
 		return snd_mask_min(hw_param_mask_c(params, var));
 	}
 	if (hw_is_interval(var)) {
-		const snd_interval_t *i = hw_param_interval_c(params, var);
+		const struct snd_interval *i = hw_param_interval_c(params, var);
 		if (dir)
 			*dir = i->openmin;
 		return snd_interval_min(i);
@@ -1328,7 +1327,7 @@ unsigned int snd_pcm_hw_param_value_min(const snd_pcm_hw_params_t *params,
  *
  * Return the maximum value for field PAR.
  */
-unsigned int snd_pcm_hw_param_value_max(const snd_pcm_hw_params_t *params,
+unsigned int snd_pcm_hw_param_value_max(const struct snd_pcm_hw_params *params,
 					snd_pcm_hw_param_t var, int *dir)
 {
 	if (hw_is_mask(var)) {
@@ -1337,7 +1336,7 @@ unsigned int snd_pcm_hw_param_value_max(const snd_pcm_hw_params_t *params,
 		return snd_mask_max(hw_param_mask_c(params, var));
 	}
 	if (hw_is_interval(var)) {
-		const snd_interval_t *i = hw_param_interval_c(params, var);
+		const struct snd_interval *i = hw_param_interval_c(params, var);
 		if (dir)
 			*dir = - (int) i->openmax;
 		return snd_interval_max(i);
@@ -1346,7 +1345,7 @@ unsigned int snd_pcm_hw_param_value_max(const snd_pcm_hw_params_t *params,
 	return -EINVAL;
 }
 
-void _snd_pcm_hw_param_setempty(snd_pcm_hw_params_t *params,
+void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,
 				snd_pcm_hw_param_t var)
 {
 	if (hw_is_mask(var)) {
@@ -1362,7 +1361,7 @@ void _snd_pcm_hw_param_setempty(snd_pcm_hw_params_t *params,
 	}
 }
 
-int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
+int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,
 				 snd_pcm_hw_param_t var)
 {
 	int changed;
@@ -1383,8 +1382,8 @@ int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
  * non integer values. Reduce configuration space accordingly.
  * Return -EINVAL if the configuration space is empty
  */
-int snd_pcm_hw_param_setinteger(snd_pcm_t *pcm, 
-				snd_pcm_hw_params_t *params,
+int snd_pcm_hw_param_setinteger(struct snd_pcm_substream *pcm, 
+				struct snd_pcm_hw_params *params,
 				snd_pcm_hw_param_t var)
 {
 	int changed = _snd_pcm_hw_param_setinteger(params, var);
@@ -1399,7 +1398,7 @@ int snd_pcm_hw_param_setinteger(snd_pcm_t *pcm,
 }
 #endif  /*  0  */
 
-static int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
+static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
 				   snd_pcm_hw_param_t var)
 {
 	int changed;
@@ -1430,8 +1429,8 @@ static int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
  * values > minimum. Reduce configuration space accordingly.
  * Return the minimum.
  */
-static int snd_pcm_hw_param_first(snd_pcm_t *pcm, 
-				  snd_pcm_hw_params_t *params, 
+static int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, 
+				  struct snd_pcm_hw_params *params, 
 				  snd_pcm_hw_param_t var, int *dir)
 {
 	int changed = _snd_pcm_hw_param_first(params, var);
@@ -1444,7 +1443,7 @@ static int snd_pcm_hw_param_first(snd_pcm_t *pcm,
 	return snd_pcm_hw_param_value(params, var, dir);
 }
 
-static int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
+static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
 				  snd_pcm_hw_param_t var)
 {
 	int changed;
@@ -1475,8 +1474,8 @@ static int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
  * values < maximum. Reduce configuration space accordingly.
  * Return the maximum.
  */
-static int snd_pcm_hw_param_last(snd_pcm_t *pcm, 
-				 snd_pcm_hw_params_t *params,
+static int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, 
+				 struct snd_pcm_hw_params *params,
 				 snd_pcm_hw_param_t var, int *dir)
 {
 	int changed = _snd_pcm_hw_param_last(params, var);
@@ -1489,7 +1488,7 @@ static int snd_pcm_hw_param_last(snd_pcm_t *pcm,
 	return snd_pcm_hw_param_value(params, var, dir);
 }
 
-int _snd_pcm_hw_param_min(snd_pcm_hw_params_t *params,
+int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,
 			  snd_pcm_hw_param_t var, unsigned int val, int dir)
 {
 	int changed;
@@ -1531,7 +1530,7 @@ int _snd_pcm_hw_param_min(snd_pcm_hw_params_t *params,
  * values < VAL. Reduce configuration space accordingly.
  * Return new minimum or -EINVAL if the configuration space is empty
  */
-static int snd_pcm_hw_param_min(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+static int snd_pcm_hw_param_min(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
 				snd_pcm_hw_param_t var, unsigned int val,
 				int *dir)
 {
@@ -1546,7 +1545,7 @@ static int snd_pcm_hw_param_min(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 	return snd_pcm_hw_param_value_min(params, var, dir);
 }
 
-static int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
+static int _snd_pcm_hw_param_max(struct snd_pcm_hw_params *params,
 				 snd_pcm_hw_param_t var, unsigned int val,
 				 int dir)
 {
@@ -1591,7 +1590,7 @@ static int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
  *  values >= VAL + 1. Reduce configuration space accordingly.
  *  Return new maximum or -EINVAL if the configuration space is empty
  */
-static int snd_pcm_hw_param_max(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+static int snd_pcm_hw_param_max(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
 				snd_pcm_hw_param_t var, unsigned int val,
 				int *dir)
 {
@@ -1606,12 +1605,12 @@ static int snd_pcm_hw_param_max(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 	return snd_pcm_hw_param_value_max(params, var, dir);
 }
 
-int _snd_pcm_hw_param_set(snd_pcm_hw_params_t *params,
+int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,
 			  snd_pcm_hw_param_t var, unsigned int val, int dir)
 {
 	int changed;
 	if (hw_is_mask(var)) {
-		snd_mask_t *m = hw_param_mask(params, var);
+		struct snd_mask *m = hw_param_mask(params, var);
 		if (val == 0 && dir < 0) {
 			changed = -EINVAL;
 			snd_mask_none(m);
@@ -1623,14 +1622,14 @@ int _snd_pcm_hw_param_set(snd_pcm_hw_params_t *params,
 			changed = snd_mask_refine_set(hw_param_mask(params, var), val);
 		}
 	} else if (hw_is_interval(var)) {
-		snd_interval_t *i = hw_param_interval(params, var);
+		struct snd_interval *i = hw_param_interval(params, var);
 		if (val == 0 && dir < 0) {
 			changed = -EINVAL;
 			snd_interval_none(i);
 		} else if (dir == 0)
 			changed = snd_interval_refine_set(i, val);
 		else {
-			snd_interval_t t;
+			struct snd_interval t;
 			t.openmin = 1;
 			t.openmax = 1;
 			t.empty = 0;
@@ -1667,7 +1666,7 @@ int _snd_pcm_hw_param_set(snd_pcm_hw_params_t *params,
  * values != VAL. Reduce configuration space accordingly.
  *  Return VAL or -EINVAL if the configuration space is empty
  */
-int snd_pcm_hw_param_set(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+int snd_pcm_hw_param_set(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
 			 snd_pcm_hw_param_t var, unsigned int val, int dir)
 {
 	int changed = _snd_pcm_hw_param_set(params, var, val, dir);
@@ -1681,8 +1680,8 @@ int snd_pcm_hw_param_set(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 	return snd_pcm_hw_param_value(params, var, NULL);
 }
 
-static int _snd_pcm_hw_param_mask(snd_pcm_hw_params_t *params,
-				  snd_pcm_hw_param_t var, const snd_mask_t *val)
+static int _snd_pcm_hw_param_mask(struct snd_pcm_hw_params *params,
+				  snd_pcm_hw_param_t var, const struct snd_mask *val)
 {
 	int changed;
 	assert(hw_is_mask(var));
@@ -1708,8 +1707,8 @@ static int _snd_pcm_hw_param_mask(snd_pcm_hw_params_t *params,
  * Return 0 on success or -EINVAL
  * if the configuration space is empty
  */
-int snd_pcm_hw_param_mask(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
-			  snd_pcm_hw_param_t var, const snd_mask_t *val)
+int snd_pcm_hw_param_mask(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
+			  snd_pcm_hw_param_t var, const struct snd_mask *val)
 {
 	int changed = _snd_pcm_hw_param_mask(params, var, val);
 	if (changed < 0)
@@ -1784,10 +1783,10 @@ static int boundary_nearer(int min, int mindir,
  * SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
  * Return the value found.
   */
-int snd_pcm_hw_param_near(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+int snd_pcm_hw_param_near(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params,
 			  snd_pcm_hw_param_t var, unsigned int best, int *dir)
 {
-	snd_pcm_hw_params_t *save = NULL;
+	struct snd_pcm_hw_params *save = NULL;
 	int v;
 	unsigned int saved_min;
 	int last = 0;
@@ -1814,7 +1813,7 @@ int snd_pcm_hw_param_near(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 	saved_min = min;
 	min = snd_pcm_hw_param_min(pcm, params, var, min, &mindir);
 	if (min >= 0) {
-		snd_pcm_hw_params_t *params1;
+		struct snd_pcm_hw_params *params1;
 		if (max < 0)
 			goto _end;
 		if ((unsigned int)min == saved_min && mindir == valdir)
@@ -1861,7 +1860,7 @@ int snd_pcm_hw_param_near(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
  * first access, first format, first subformat, min channels,
  * min rate, min period time, max buffer size, min tick time
  */
-int snd_pcm_hw_params_choose(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
+int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm, struct snd_pcm_hw_params *params)
 {
 	int err;
 
@@ -1892,13 +1891,12 @@ int snd_pcm_hw_params_choose(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
 	return 0;
 }
 
-#undef snd_pcm_t
 #undef assert
 
-static int snd_pcm_lib_ioctl_reset(snd_pcm_substream_t *substream,
+static int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,
 				   void *arg)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned long flags;
 	snd_pcm_stream_lock_irqsave(substream, flags);
 	if (snd_pcm_running(substream) &&
@@ -1910,11 +1908,11 @@ static int snd_pcm_lib_ioctl_reset(snd_pcm_substream_t *substream,
 	return 0;
 }
 
-static int snd_pcm_lib_ioctl_channel_info(snd_pcm_substream_t *substream,
+static int snd_pcm_lib_ioctl_channel_info(struct snd_pcm_substream *substream,
 					  void *arg)
 {
-	snd_pcm_channel_info_t *info = arg;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_channel_info *info = arg;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int width;
 	if (!(runtime->info & SNDRV_PCM_INFO_MMAP)) {
 		info->offset = -1;
@@ -1956,7 +1954,7 @@ static int snd_pcm_lib_ioctl_channel_info(snd_pcm_substream_t *substream,
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_pcm_lib_ioctl(snd_pcm_substream_t *substream,
+int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
 		      unsigned int cmd, void *arg)
 {
 	switch (cmd) {
@@ -1974,10 +1972,10 @@ int snd_pcm_lib_ioctl(snd_pcm_substream_t *substream,
  *  Conditions
  */
 
-static void snd_pcm_system_tick_set(snd_pcm_substream_t *substream, 
+static void snd_pcm_system_tick_set(struct snd_pcm_substream *substream, 
 				    unsigned long ticks)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (ticks == 0)
 		del_timer(&runtime->tick_timer);
 	else {
@@ -1988,14 +1986,14 @@ static void snd_pcm_system_tick_set(snd_pcm_substream_t *substream,
 }
 
 /* Temporary alias */
-void snd_pcm_tick_set(snd_pcm_substream_t *substream, unsigned long ticks)
+void snd_pcm_tick_set(struct snd_pcm_substream *substream, unsigned long ticks)
 {
 	snd_pcm_system_tick_set(substream, ticks);
 }
 
-void snd_pcm_tick_prepare(snd_pcm_substream_t *substream)
+void snd_pcm_tick_prepare(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t frames = ULONG_MAX;
 	snd_pcm_uframes_t avail, dist;
 	unsigned int ticks;
@@ -2046,9 +2044,9 @@ void snd_pcm_tick_prepare(snd_pcm_substream_t *substream)
 	snd_pcm_tick_set(substream, (unsigned long) ticks);
 }
 
-void snd_pcm_tick_elapsed(snd_pcm_substream_t *substream)
+void snd_pcm_tick_elapsed(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime;
+	struct snd_pcm_runtime *runtime;
 	unsigned long flags;
 	
 	snd_assert(substream != NULL, return);
@@ -2076,9 +2074,9 @@ void snd_pcm_tick_elapsed(snd_pcm_substream_t *substream)
  * Even if more than one periods have elapsed since the last call, you
  * have to call this only once.
  */
-void snd_pcm_period_elapsed(snd_pcm_substream_t *substream)
+void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime;
+	struct snd_pcm_runtime *runtime;
 	unsigned long flags;
 
 	snd_assert(substream != NULL, return);
@@ -2104,12 +2102,12 @@ void snd_pcm_period_elapsed(snd_pcm_substream_t *substream)
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 }
 
-static int snd_pcm_lib_write_transfer(snd_pcm_substream_t *substream,
+static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
 				      unsigned int hwoff,
 				      unsigned long data, unsigned int off,
 				      snd_pcm_uframes_t frames)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
 	if (substream->ops->copy) {
@@ -2124,17 +2122,17 @@ static int snd_pcm_lib_write_transfer(snd_pcm_substream_t *substream,
 	return 0;
 }
  
-typedef int (*transfer_f)(snd_pcm_substream_t *substream, unsigned int hwoff,
+typedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwoff,
 			  unsigned long data, unsigned int off,
 			  snd_pcm_uframes_t size);
 
-static snd_pcm_sframes_t snd_pcm_lib_write1(snd_pcm_substream_t *substream, 
+static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream, 
 					    unsigned long data,
 					    snd_pcm_uframes_t size,
 					    int nonblock,
 					    transfer_f transfer)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
 	int err = 0;
@@ -2290,9 +2288,9 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(snd_pcm_substream_t *substream,
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
 
-snd_pcm_sframes_t snd_pcm_lib_write(snd_pcm_substream_t *substream, const void __user *buf, snd_pcm_uframes_t size)
+snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)
 {
-	snd_pcm_runtime_t *runtime;
+	struct snd_pcm_runtime *runtime;
 	int nonblock;
 
 	snd_assert(substream != NULL, return -ENXIO);
@@ -2306,7 +2304,7 @@ snd_pcm_sframes_t snd_pcm_lib_write(snd_pcm_substream_t *substream, const void _
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
-		snd_pcm_oss_setup_t *setup = substream->oss.setup;
+		struct snd_pcm_oss_setup *setup = substream->oss.setup;
 		if (setup != NULL) {
 			if (setup->nonblock)
 				nonblock = 1;
@@ -2323,12 +2321,12 @@ snd_pcm_sframes_t snd_pcm_lib_write(snd_pcm_substream_t *substream, const void _
 				  snd_pcm_lib_write_transfer);
 }
 
-static int snd_pcm_lib_writev_transfer(snd_pcm_substream_t *substream,
+static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
 				       unsigned int hwoff,
 				       unsigned long data, unsigned int off,
 				       snd_pcm_uframes_t frames)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 	void __user **bufs = (void __user **)data;
 	int channels = runtime->channels;
@@ -2363,11 +2361,11 @@ static int snd_pcm_lib_writev_transfer(snd_pcm_substream_t *substream,
 	return 0;
 }
  
-snd_pcm_sframes_t snd_pcm_lib_writev(snd_pcm_substream_t *substream,
+snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 				     void __user **bufs,
 				     snd_pcm_uframes_t frames)
 {
-	snd_pcm_runtime_t *runtime;
+	struct snd_pcm_runtime *runtime;
 	int nonblock;
 
 	snd_assert(substream != NULL, return -ENXIO);
@@ -2381,7 +2379,7 @@ snd_pcm_sframes_t snd_pcm_lib_writev(snd_pcm_substream_t *substream,
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
-		snd_pcm_oss_setup_t *setup = substream->oss.setup;
+		struct snd_pcm_oss_setup *setup = substream->oss.setup;
 		if (setup != NULL) {
 			if (setup->nonblock)
 				nonblock = 1;
@@ -2397,12 +2395,12 @@ snd_pcm_sframes_t snd_pcm_lib_writev(snd_pcm_substream_t *substream,
 				  nonblock, snd_pcm_lib_writev_transfer);
 }
 
-static int snd_pcm_lib_read_transfer(snd_pcm_substream_t *substream, 
+static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, 
 				     unsigned int hwoff,
 				     unsigned long data, unsigned int off,
 				     snd_pcm_uframes_t frames)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
 	if (substream->ops->copy) {
@@ -2417,13 +2415,13 @@ static int snd_pcm_lib_read_transfer(snd_pcm_substream_t *substream,
 	return 0;
 }
 
-static snd_pcm_sframes_t snd_pcm_lib_read1(snd_pcm_substream_t *substream,
+static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 					   unsigned long data,
 					   snd_pcm_uframes_t size,
 					   int nonblock,
 					   transfer_f transfer)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
 	int err = 0;
@@ -2587,9 +2585,9 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(snd_pcm_substream_t *substream,
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
 
-snd_pcm_sframes_t snd_pcm_lib_read(snd_pcm_substream_t *substream, void __user *buf, snd_pcm_uframes_t size)
+snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __user *buf, snd_pcm_uframes_t size)
 {
-	snd_pcm_runtime_t *runtime;
+	struct snd_pcm_runtime *runtime;
 	int nonblock;
 	
 	snd_assert(substream != NULL, return -ENXIO);
@@ -2603,7 +2601,7 @@ snd_pcm_sframes_t snd_pcm_lib_read(snd_pcm_substream_t *substream, void __user *
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
-		snd_pcm_oss_setup_t *setup = substream->oss.setup;
+		struct snd_pcm_oss_setup *setup = substream->oss.setup;
 		if (setup != NULL) {
 			if (setup->nonblock)
 				nonblock = 1;
@@ -2617,12 +2615,12 @@ snd_pcm_sframes_t snd_pcm_lib_read(snd_pcm_substream_t *substream, void __user *
 	return snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);
 }
 
-static int snd_pcm_lib_readv_transfer(snd_pcm_substream_t *substream,
+static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
 				      unsigned int hwoff,
 				      unsigned long data, unsigned int off,
 				      snd_pcm_uframes_t frames)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 	void __user **bufs = (void __user **)data;
 	int channels = runtime->channels;
@@ -2654,11 +2652,11 @@ static int snd_pcm_lib_readv_transfer(snd_pcm_substream_t *substream,
 	return 0;
 }
  
-snd_pcm_sframes_t snd_pcm_lib_readv(snd_pcm_substream_t *substream,
+snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 				    void __user **bufs,
 				    snd_pcm_uframes_t frames)
 {
-	snd_pcm_runtime_t *runtime;
+	struct snd_pcm_runtime *runtime;
 	int nonblock;
 
 	snd_assert(substream != NULL, return -ENXIO);
@@ -2672,7 +2670,7 @@ snd_pcm_sframes_t snd_pcm_lib_readv(snd_pcm_substream_t *substream,
 	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
-		snd_pcm_oss_setup_t *setup = substream->oss.setup;
+		struct snd_pcm_oss_setup *setup = substream->oss.setup;
 		if (setup != NULL) {
 			if (setup->nonblock)
 				nonblock = 1;

commit 07799e756c76ecd52cb01a812ba48b7d8ac67633
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:49:49 2005 +0200

    [ALSA] Use getnstimeofday()
    
    Modules: Documentation,PCM Midlevel,Timer Midlevel,ALSA Core
    
    Use the standard getnstimeofday() function instead of ALSA's own one.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index dfc5f45f2748..3dbf9bf2ac16 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -152,7 +152,7 @@ static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(snd_pcm_substream_t *s
 	if (pos == SNDRV_PCM_POS_XRUN)
 		return pos; /* XRUN */
 	if (runtime->tstamp_mode & SNDRV_PCM_TSTAMP_MMAP)
-		snd_timestamp_now((snd_timestamp_t*)&runtime->status->tstamp, runtime->tstamp_timespec);
+		getnstimeofday((struct timespec *)&runtime->status->tstamp);
 #ifdef CONFIG_SND_DEBUG
 	if (pos >= runtime->buffer_size) {
 		snd_printk(KERN_ERR  "BUG: stream = %i, pos = 0x%lx, buffer size = 0x%lx, period size = 0x%lx\n", substream->stream, pos, runtime->buffer_size, runtime->period_size);

commit 7c22f1aaa23370bf9ba2dd3abbccbed70dced216
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:46:31 2005 +0200

    [ALSA] Remove snd_runtime_check() macro
    
    Remove snd_runtime_check() macro.
    This macro worsens the readability of codes.  They should be either
    normal if() or removable asserts.
    
    Also, the assert displays stack-dump, instead of only the last caller
    pointer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 0503980c23d9..dfc5f45f2748 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -156,9 +156,8 @@ static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(snd_pcm_substream_t *s
 #ifdef CONFIG_SND_DEBUG
 	if (pos >= runtime->buffer_size) {
 		snd_printk(KERN_ERR  "BUG: stream = %i, pos = 0x%lx, buffer size = 0x%lx, period size = 0x%lx\n", substream->stream, pos, runtime->buffer_size, runtime->period_size);
-	} else
+	}
 #endif
-	snd_runtime_check(pos < runtime->buffer_size, return 0);
 	pos -= pos % runtime->min_align;
 	return pos;
 }

commit df8db936e5e829ab3ff66346dbdf4033fa3ce588
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 13:38:19 2005 +0200

    [ALSA] Fix DocBook warnings
    
    PCM Midlevel,RawMidi Midlevel
    Fix DocBook warnings.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 0082914a7e33..0503980c23d9 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -524,6 +524,9 @@ void snd_interval_mul(const snd_interval_t *a, const snd_interval_t *b, snd_inte
 
 /**
  * snd_interval_div - refine the interval value with division
+ * @a: dividend
+ * @b: divisor
+ * @c: quotient
  *
  * c = a / b
  *
@@ -555,7 +558,11 @@ void snd_interval_div(const snd_interval_t *a, const snd_interval_t *b, snd_inte
 
 /**
  * snd_interval_muldivk - refine the interval value
- *
+ * @a: dividend 1
+ * @b: dividend 2
+ * @k: divisor (as integer)
+ * @c: result
+  *
  * c = a * b / k
  *
  * Returns non-zero if the value is changed, zero if not changed.
@@ -582,6 +589,10 @@ void snd_interval_muldivk(const snd_interval_t *a, const snd_interval_t *b,
 
 /**
  * snd_interval_mulkdiv - refine the interval value
+ * @a: dividend 1
+ * @k: dividend 2 (as integer)
+ * @b: divisor
+ * @c: result
  *
  * c = a * k / b
  *
@@ -618,6 +629,11 @@ void snd_interval_mulkdiv(const snd_interval_t *a, unsigned int k,
 
 /**
  * snd_interval_ratnum - refine the interval value
+ * @i: interval to refine
+ * @rats_count: number of ratnum_t 
+ * @rats: ratnum_t array
+ * @nump: pointer to store the resultant numerator
+ * @denp: pointer to store the resultant denominator
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
@@ -715,6 +731,11 @@ int snd_interval_ratnum(snd_interval_t *i,
 
 /**
  * snd_interval_ratden - refine the interval value
+ * @i: interval to refine
+ * @rats_count: number of ratden_t
+ * @rats: ratden_t array
+ * @nump: pointer to store the resultant numerator
+ * @denp: pointer to store the resultant denominator
  *
  * Returns non-zero if the value is changed, zero if not changed.
  */
@@ -936,6 +957,11 @@ int snd_pcm_hw_rule_add(snd_pcm_runtime_t *runtime, unsigned int cond,
 
 /**
  * snd_pcm_hw_constraint_mask
+ * @runtime: PCM runtime instance
+ * @var: hw_params variable to apply the mask
+ * @mask: the bitmap mask
+ *
+ * Apply the constraint of the given bitmap mask to a mask parameter.
  */
 int snd_pcm_hw_constraint_mask(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
 			       u_int32_t mask)
@@ -951,6 +977,11 @@ int snd_pcm_hw_constraint_mask(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t va
 
 /**
  * snd_pcm_hw_constraint_mask64
+ * @runtime: PCM runtime instance
+ * @var: hw_params variable to apply the mask
+ * @mask: the 64bit bitmap mask
+ *
+ * Apply the constraint of the given bitmap mask to a mask parameter.
  */
 int snd_pcm_hw_constraint_mask64(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
 				 u_int64_t mask)
@@ -967,6 +998,10 @@ int snd_pcm_hw_constraint_mask64(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t
 
 /**
  * snd_pcm_hw_constraint_integer
+ * @runtime: PCM runtime instance
+ * @var: hw_params variable to apply the integer constraint
+ *
+ * Apply the constraint of integer to an interval parameter.
  */
 int snd_pcm_hw_constraint_integer(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var)
 {
@@ -976,6 +1011,12 @@ int snd_pcm_hw_constraint_integer(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t
 
 /**
  * snd_pcm_hw_constraint_minmax
+ * @runtime: PCM runtime instance
+ * @var: hw_params variable to apply the range
+ * @min: the minimal value
+ * @max: the maximal value
+ * 
+ * Apply the min/max range constraint to an interval parameter.
  */
 int snd_pcm_hw_constraint_minmax(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
 				 unsigned int min, unsigned int max)
@@ -999,6 +1040,12 @@ static int snd_pcm_hw_rule_list(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_constraint_list
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the list constraint
+ * @l: list
+ * 
+ * Apply the list of constraints to an interval parameter.
  */
 int snd_pcm_hw_constraint_list(snd_pcm_runtime_t *runtime,
 			       unsigned int cond,
@@ -1027,6 +1074,10 @@ static int snd_pcm_hw_rule_ratnums(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_constraint_ratnums
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the ratnums constraint
+ * @r: ratnums_t constriants
  */
 int snd_pcm_hw_constraint_ratnums(snd_pcm_runtime_t *runtime, 
 				  unsigned int cond,
@@ -1054,6 +1105,10 @@ static int snd_pcm_hw_rule_ratdens(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_constraint_ratdens
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the ratdens constraint
+ * @r: ratdens_t constriants
  */
 int snd_pcm_hw_constraint_ratdens(snd_pcm_runtime_t *runtime, 
 				  unsigned int cond,
@@ -1079,6 +1134,10 @@ static int snd_pcm_hw_rule_msbits(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_constraint_msbits
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @width: sample bits width
+ * @msbits: msbits width
  */
 int snd_pcm_hw_constraint_msbits(snd_pcm_runtime_t *runtime, 
 				 unsigned int cond,
@@ -1101,6 +1160,10 @@ static int snd_pcm_hw_rule_step(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_constraint_step
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the step constraint
+ * @step: step size
  */
 int snd_pcm_hw_constraint_step(snd_pcm_runtime_t *runtime,
 			       unsigned int cond,
@@ -1126,6 +1189,9 @@ static int snd_pcm_hw_rule_pow2(snd_pcm_hw_params_t *params, snd_pcm_hw_rule_t *
 
 /**
  * snd_pcm_hw_constraint_pow2
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the power-of-2 constraint
  */
 int snd_pcm_hw_constraint_pow2(snd_pcm_runtime_t *runtime,
 			       unsigned int cond,
@@ -1162,7 +1228,7 @@ static void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params,
 }
 
 #if 0
-/**
+/*
  * snd_pcm_hw_param_any
  */
 int snd_pcm_hw_param_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
@@ -1185,7 +1251,7 @@ void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params)
 }
 
 #if 0
-/**
+/*
  * snd_pcm_hw_params_any
  *
  * Fill PARAMS with full configuration space boundaries
@@ -1199,6 +1265,9 @@ int snd_pcm_hw_params_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
 
 /**
  * snd_pcm_hw_param_value
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Return the value for field PAR if it's fixed in configuration space 
  *  defined by PARAMS. Return -EINVAL otherwise
@@ -1228,6 +1297,9 @@ static int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_value_min
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Return the minimum value for field PAR.
  */
@@ -1251,6 +1323,9 @@ unsigned int snd_pcm_hw_param_value_min(const snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_value_max
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Return the maximum value for field PAR.
  */
@@ -1302,7 +1377,7 @@ int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
 }
 	
 #if 0
-/**
+/*
  * snd_pcm_hw_param_setinteger
  *
  * Inside configuration space defined by PARAMS remove from PAR all 
@@ -1347,6 +1422,10 @@ static int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_first
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Inside configuration space defined by PARAMS remove from PAR all 
  * values > minimum. Reduce configuration space accordingly.
@@ -1388,6 +1467,10 @@ static int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_last
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Inside configuration space defined by PARAMS remove from PAR all 
  * values < maximum. Reduce configuration space accordingly.
@@ -1439,6 +1522,11 @@ int _snd_pcm_hw_param_min(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_min
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @val: minimal value
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Inside configuration space defined by PARAMS remove from PAR all 
  * values < VAL. Reduce configuration space accordingly.
@@ -1494,6 +1582,11 @@ static int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_max
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @val: maximal value
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Inside configuration space defined by PARAMS remove from PAR all 
  *  values >= VAL + 1. Reduce configuration space accordingly.
@@ -1565,6 +1658,11 @@ int _snd_pcm_hw_param_set(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_set
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @val: value to set
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Inside configuration space defined by PARAMS remove from PAR all 
  * values != VAL. Reduce configuration space accordingly.
@@ -1599,6 +1697,10 @@ static int _snd_pcm_hw_param_mask(snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_mask
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @val: mask to apply
  *
  * Inside configuration space defined by PARAMS remove from PAR all values
  * not contained in MASK. Reduce configuration space accordingly.
@@ -1671,6 +1773,11 @@ static int boundary_nearer(int min, int mindir,
 
 /**
  * snd_pcm_hw_param_near
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @best: value to set
+ * @dir: pointer to the direction (-1,0,1) or NULL
  *
  * Inside configuration space defined by PARAMS set PAR to the available value
  * nearest to VAL. Reduce configuration space accordingly.
@@ -1747,6 +1854,8 @@ int snd_pcm_hw_param_near(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 
 /**
  * snd_pcm_hw_param_choose
+ * @pcm: PCM instance
+ * @params: the hw_params instance
  *
  * Choose one configuration from configuration space defined by PARAMS
  * The configuration chosen is that obtained fixing in this order:

commit a53fc188ec6fc406276799da465fe789c40d96b2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Aug 11 15:59:17 2005 +0200

    [ALSA] make local objects static
    
    Memalloc module,PCM Midlevel,Timer Midlevel,GUS Library,AC97 Codec
    ALI5451 driver,RME9652 driver
    Make some functions/variables that are used in only one file static.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index c41ec2e9f201..0082914a7e33 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1584,8 +1584,8 @@ int snd_pcm_hw_param_set(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 	return snd_pcm_hw_param_value(params, var, NULL);
 }
 
-int _snd_pcm_hw_param_mask(snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var, const snd_mask_t *val)
+static int _snd_pcm_hw_param_mask(snd_pcm_hw_params_t *params,
+				  snd_pcm_hw_param_t var, const snd_mask_t *val)
 {
 	int changed;
 	assert(hw_is_mask(var));

commit 443feb882679e21ba5d1e0ff9eff067ac26d9461
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Wed Aug 10 11:18:19 2005 +0200

    [ALSA] ALSA's struct _snd_pcm_substream: Obsolete open_flag
    
    PCM Midlevel,ALSA<-OSS emulation,USB USX2Y
    This patch removes open_flag from struct _snd_pcm_substream.
    All of its uses are substituted by querying struct _snd_pcm_substream's
    member ffile instead.
    
    Signed-off-by: Karsten Wiese <annabellesgarden@yahoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index c5bfd0918cff..c41ec2e9f201 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2063,7 +2063,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(snd_pcm_substream_t *substream,
 		if (((avail < runtime->control->avail_min && size > avail) ||
 		   (size >= runtime->xfer_align && avail < runtime->xfer_align))) {
 			wait_queue_t wait;
-			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED } state;
+			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED, DROPPED } state;
 			long tout;
 
 			if (nonblock) {
@@ -2097,6 +2097,9 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(snd_pcm_substream_t *substream,
 				case SNDRV_PCM_STATE_SUSPENDED:
 					state = SUSPENDED;
 					goto _end_loop;
+				case SNDRV_PCM_STATE_SETUP:
+					state = DROPPED;
+					goto _end_loop;
 				default:
 					break;
 				}
@@ -2123,6 +2126,9 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(snd_pcm_substream_t *substream,
 				snd_printd("playback write error (DMA or IRQ trouble?)\n");
 				err = -EIO;
 				goto _end_unlock;
+			case DROPPED:
+				err = -EBADFD;
+				goto _end_unlock;
 			default:
 				break;
 			}
@@ -2359,7 +2365,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(snd_pcm_substream_t *substream,
 		} else if ((avail < runtime->control->avail_min && size > avail) ||
 			   (size >= runtime->xfer_align && avail < runtime->xfer_align)) {
 			wait_queue_t wait;
-			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED } state;
+			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED, DROPPED } state;
 			long tout;
 
 			if (nonblock) {
@@ -2394,6 +2400,9 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(snd_pcm_substream_t *substream,
 					goto _end_loop;
 				case SNDRV_PCM_STATE_DRAINING:
 					goto __draining;
+				case SNDRV_PCM_STATE_SETUP:
+					state = DROPPED;
+					goto _end_loop;
 				default:
 					break;
 				}
@@ -2420,6 +2429,9 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(snd_pcm_substream_t *substream,
 				snd_printd("capture read error (DMA or IRQ trouble?)\n");
 				err = -EIO;
 				goto _end_unlock;
+			case DROPPED:
+				err = -EBADFD;
+				goto _end_unlock;
 			default:
 				break;
 			}

commit 62144100471e940468d7a0f2d989df193afe870c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 24 17:24:59 2005 +0200

    [ALSA] Make docproc happy
    
    PCM Midlevel
    Make docproc happy by moving '#if 0' before comments.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 7ce8b2164f6c..c5bfd0918cff 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1161,10 +1161,10 @@ static void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params,
 	snd_BUG();
 }
 
+#if 0
 /**
  * snd_pcm_hw_param_any
  */
-#if 0
 int snd_pcm_hw_param_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 			 snd_pcm_hw_param_t var)
 {
@@ -1184,12 +1184,12 @@ void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params)
 	params->info = ~0U;
 }
 
+#if 0
 /**
  * snd_pcm_hw_params_any
  *
  * Fill PARAMS with full configuration space boundaries
  */
-#if 0
 int snd_pcm_hw_params_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
 {
 	_snd_pcm_hw_params_any(params);
@@ -1301,6 +1301,7 @@ int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
 	return changed;
 }
 	
+#if 0
 /**
  * snd_pcm_hw_param_setinteger
  *
@@ -1308,7 +1309,6 @@ int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
  * non integer values. Reduce configuration space accordingly.
  * Return -EINVAL if the configuration space is empty
  */
-#if 0
 int snd_pcm_hw_param_setinteger(snd_pcm_t *pcm, 
 				snd_pcm_hw_params_t *params,
 				snd_pcm_hw_param_t var)

commit 123992f728785e05f385d23893bd5ec69871aeb4
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed May 18 18:02:04 2005 +0200

    [ALSA] sound/core/: possible cleanups
    
    PCM Midlevel,ALSA Core,Timer Midlevel,ALSA sequencer,Virtual Midi
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global functions
    - remove the following unneeded EXPORT_SYMBOL's
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 151fd99ca2c9..7ce8b2164f6c 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1143,7 +1143,8 @@ int snd_pcm_hw_constraint_pow2(snd_pcm_runtime_t *runtime,
 #define INT_MIN ((int)((unsigned int)INT_MAX+1))
 #endif
 
-void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var)
+static void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params,
+				  snd_pcm_hw_param_t var)
 {
 	if (hw_is_mask(var)) {
 		snd_mask_any(hw_param_mask(params, var));
@@ -1163,12 +1164,14 @@ void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var)
 /**
  * snd_pcm_hw_param_any
  */
+#if 0
 int snd_pcm_hw_param_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 			 snd_pcm_hw_param_t var)
 {
 	_snd_pcm_hw_param_any(params, var);
 	return snd_pcm_hw_refine(pcm, params);
 }
+#endif  /*  0  */
 
 void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params)
 {
@@ -1186,11 +1189,13 @@ void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params)
  *
  * Fill PARAMS with full configuration space boundaries
  */
+#if 0
 int snd_pcm_hw_params_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
 {
 	_snd_pcm_hw_params_any(params);
 	return snd_pcm_hw_refine(pcm, params);
 }
+#endif  /*  0  */
 
 /**
  * snd_pcm_hw_param_value
@@ -1198,8 +1203,8 @@ int snd_pcm_hw_params_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
  * Return the value for field PAR if it's fixed in configuration space 
  *  defined by PARAMS. Return -EINVAL otherwise
  */
-int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var, int *dir)
+static int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
+				  snd_pcm_hw_param_t var, int *dir)
 {
 	if (hw_is_mask(var)) {
 		const snd_mask_t *mask = hw_param_mask_c(params, var);
@@ -1303,6 +1308,7 @@ int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
  * non integer values. Reduce configuration space accordingly.
  * Return -EINVAL if the configuration space is empty
  */
+#if 0
 int snd_pcm_hw_param_setinteger(snd_pcm_t *pcm, 
 				snd_pcm_hw_params_t *params,
 				snd_pcm_hw_param_t var)
@@ -1317,9 +1323,10 @@ int snd_pcm_hw_param_setinteger(snd_pcm_t *pcm,
 	}
 	return 0;
 }
+#endif  /*  0  */
 
-int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
-			    snd_pcm_hw_param_t var)
+static int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
+				   snd_pcm_hw_param_t var)
 {
 	int changed;
 	if (hw_is_mask(var))
@@ -1345,9 +1352,9 @@ int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
  * values > minimum. Reduce configuration space accordingly.
  * Return the minimum.
  */
-int snd_pcm_hw_param_first(snd_pcm_t *pcm, 
-			   snd_pcm_hw_params_t *params, 
-			   snd_pcm_hw_param_t var, int *dir)
+static int snd_pcm_hw_param_first(snd_pcm_t *pcm, 
+				  snd_pcm_hw_params_t *params, 
+				  snd_pcm_hw_param_t var, int *dir)
 {
 	int changed = _snd_pcm_hw_param_first(params, var);
 	if (changed < 0)
@@ -1359,8 +1366,8 @@ int snd_pcm_hw_param_first(snd_pcm_t *pcm,
 	return snd_pcm_hw_param_value(params, var, dir);
 }
 
-int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var)
+static int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
+				  snd_pcm_hw_param_t var)
 {
 	int changed;
 	if (hw_is_mask(var))
@@ -1386,9 +1393,9 @@ int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
  * values < maximum. Reduce configuration space accordingly.
  * Return the maximum.
  */
-int snd_pcm_hw_param_last(snd_pcm_t *pcm, 
-			  snd_pcm_hw_params_t *params,
-			  snd_pcm_hw_param_t var, int *dir)
+static int snd_pcm_hw_param_last(snd_pcm_t *pcm, 
+				 snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_param_t var, int *dir)
 {
 	int changed = _snd_pcm_hw_param_last(params, var);
 	if (changed < 0)
@@ -1437,8 +1444,9 @@ int _snd_pcm_hw_param_min(snd_pcm_hw_params_t *params,
  * values < VAL. Reduce configuration space accordingly.
  * Return new minimum or -EINVAL if the configuration space is empty
  */
-int snd_pcm_hw_param_min(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
-			 snd_pcm_hw_param_t var, unsigned int val, int *dir)
+static int snd_pcm_hw_param_min(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+				snd_pcm_hw_param_t var, unsigned int val,
+				int *dir)
 {
 	int changed = _snd_pcm_hw_param_min(params, var, val, dir ? *dir : 0);
 	if (changed < 0)
@@ -1451,8 +1459,9 @@ int snd_pcm_hw_param_min(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
 	return snd_pcm_hw_param_value_min(params, var, dir);
 }
 
-int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
-			   snd_pcm_hw_param_t var, unsigned int val, int dir)
+static int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_param_t var, unsigned int val,
+				 int dir)
 {
 	int changed;
 	int open = 0;
@@ -1490,8 +1499,9 @@ int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
  *  values >= VAL + 1. Reduce configuration space accordingly.
  *  Return new maximum or -EINVAL if the configuration space is empty
  */
-int snd_pcm_hw_param_max(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
-			  snd_pcm_hw_param_t var, unsigned int val, int *dir)
+static int snd_pcm_hw_param_max(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+				snd_pcm_hw_param_t var, unsigned int val,
+				int *dir)
 {
 	int changed = _snd_pcm_hw_param_max(params, var, val, dir ? *dir : 0);
 	if (changed < 0)
@@ -2564,9 +2574,6 @@ snd_pcm_sframes_t snd_pcm_lib_readv(snd_pcm_substream_t *substream,
 EXPORT_SYMBOL(snd_interval_refine);
 EXPORT_SYMBOL(snd_interval_list);
 EXPORT_SYMBOL(snd_interval_ratnum);
-EXPORT_SYMBOL(snd_interval_muldivk);
-EXPORT_SYMBOL(snd_interval_mulkdiv);
-EXPORT_SYMBOL(snd_interval_div);
 EXPORT_SYMBOL(_snd_pcm_hw_params_any);
 EXPORT_SYMBOL(_snd_pcm_hw_param_min);
 EXPORT_SYMBOL(_snd_pcm_hw_param_set);
@@ -2580,7 +2587,6 @@ EXPORT_SYMBOL(snd_pcm_hw_param_last);
 EXPORT_SYMBOL(snd_pcm_hw_param_near);
 EXPORT_SYMBOL(snd_pcm_hw_param_set);
 EXPORT_SYMBOL(snd_pcm_hw_refine);
-EXPORT_SYMBOL(snd_pcm_hw_params);
 EXPORT_SYMBOL(snd_pcm_hw_constraints_init);
 EXPORT_SYMBOL(snd_pcm_hw_constraints_complete);
 EXPORT_SYMBOL(snd_pcm_hw_constraint_list);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
new file mode 100644
index 000000000000..151fd99ca2c9
--- /dev/null
+++ b/sound/core/pcm_lib.c
@@ -0,0 +1,2612 @@
+/*
+ *  Digital Audio (PCM) abstract layer
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *                   Abramo Bagnara <abramo@alsa-project.org>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/timer.h>
+
+/*
+ * fill ring buffer with silence
+ * runtime->silence_start: starting pointer to silence area
+ * runtime->silence_filled: size filled with silence
+ * runtime->silence_threshold: threshold from application
+ * runtime->silence_size: maximal size from application
+ *
+ * when runtime->silence_size >= runtime->boundary - fill processed area with silence immediately
+ */
+void snd_pcm_playback_silence(snd_pcm_substream_t *substream, snd_pcm_uframes_t new_hw_ptr)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t frames, ofs, transfer;
+
+	if (runtime->silence_size < runtime->boundary) {
+		snd_pcm_sframes_t noise_dist, n;
+		if (runtime->silence_start != runtime->control->appl_ptr) {
+			n = runtime->control->appl_ptr - runtime->silence_start;
+			if (n < 0)
+				n += runtime->boundary;
+			if ((snd_pcm_uframes_t)n < runtime->silence_filled)
+				runtime->silence_filled -= n;
+			else
+				runtime->silence_filled = 0;
+			runtime->silence_start = runtime->control->appl_ptr;
+		}
+		if (runtime->silence_filled == runtime->buffer_size)
+			return;
+		snd_assert(runtime->silence_filled <= runtime->buffer_size, return);
+		noise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;
+		if (noise_dist >= (snd_pcm_sframes_t) runtime->silence_threshold)
+			return;
+		frames = runtime->silence_threshold - noise_dist;
+		if (frames > runtime->silence_size)
+			frames = runtime->silence_size;
+	} else {
+		if (new_hw_ptr == ULONG_MAX) {	/* initialization */
+			snd_pcm_sframes_t avail = snd_pcm_playback_hw_avail(runtime);
+			runtime->silence_filled = avail > 0 ? avail : 0;
+			runtime->silence_start = (runtime->status->hw_ptr +
+						  runtime->silence_filled) %
+						 runtime->boundary;
+		} else {
+			ofs = runtime->status->hw_ptr;
+			frames = new_hw_ptr - ofs;
+			if ((snd_pcm_sframes_t)frames < 0)
+				frames += runtime->boundary;
+			runtime->silence_filled -= frames;
+			if ((snd_pcm_sframes_t)runtime->silence_filled < 0) {
+				runtime->silence_filled = 0;
+				runtime->silence_start = (ofs + frames) - runtime->buffer_size;
+			} else {
+				runtime->silence_start = ofs - runtime->silence_filled;
+			}
+			if ((snd_pcm_sframes_t)runtime->silence_start < 0)
+				runtime->silence_start += runtime->boundary;
+		}
+		frames = runtime->buffer_size - runtime->silence_filled;
+	}
+	snd_assert(frames <= runtime->buffer_size, return);
+	if (frames == 0)
+		return;
+	ofs = (runtime->silence_start + runtime->silence_filled) % runtime->buffer_size;
+	while (frames > 0) {
+		transfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;
+		if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||
+		    runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
+			if (substream->ops->silence) {
+				int err;
+				err = substream->ops->silence(substream, -1, ofs, transfer);
+				snd_assert(err >= 0, );
+			} else {
+				char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);
+				snd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);
+			}
+		} else {
+			unsigned int c;
+			unsigned int channels = runtime->channels;
+			if (substream->ops->silence) {
+				for (c = 0; c < channels; ++c) {
+					int err;
+					err = substream->ops->silence(substream, c, ofs, transfer);
+					snd_assert(err >= 0, );
+				}
+			} else {
+				size_t dma_csize = runtime->dma_bytes / channels;
+				for (c = 0; c < channels; ++c) {
+					char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, ofs);
+					snd_pcm_format_set_silence(runtime->format, hwbuf, transfer);
+				}
+			}
+		}
+		runtime->silence_filled += transfer;
+		frames -= transfer;
+		ofs = 0;
+	}
+}
+
+static void xrun(snd_pcm_substream_t *substream)
+{
+	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
+#ifdef CONFIG_SND_DEBUG
+	if (substream->pstr->xrun_debug) {
+		snd_printd(KERN_DEBUG "XRUN: pcmC%dD%d%c\n",
+			   substream->pcm->card->number,
+			   substream->pcm->device,
+			   substream->stream ? 'c' : 'p');
+		if (substream->pstr->xrun_debug > 1)
+			dump_stack();
+	}
+#endif
+}
+
+static inline snd_pcm_uframes_t snd_pcm_update_hw_ptr_pos(snd_pcm_substream_t *substream,
+							  snd_pcm_runtime_t *runtime)
+{
+	snd_pcm_uframes_t pos;
+
+	pos = substream->ops->pointer(substream);
+	if (pos == SNDRV_PCM_POS_XRUN)
+		return pos; /* XRUN */
+	if (runtime->tstamp_mode & SNDRV_PCM_TSTAMP_MMAP)
+		snd_timestamp_now((snd_timestamp_t*)&runtime->status->tstamp, runtime->tstamp_timespec);
+#ifdef CONFIG_SND_DEBUG
+	if (pos >= runtime->buffer_size) {
+		snd_printk(KERN_ERR  "BUG: stream = %i, pos = 0x%lx, buffer size = 0x%lx, period size = 0x%lx\n", substream->stream, pos, runtime->buffer_size, runtime->period_size);
+	} else
+#endif
+	snd_runtime_check(pos < runtime->buffer_size, return 0);
+	pos -= pos % runtime->min_align;
+	return pos;
+}
+
+static inline int snd_pcm_update_hw_ptr_post(snd_pcm_substream_t *substream,
+					     snd_pcm_runtime_t *runtime)
+{
+	snd_pcm_uframes_t avail;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		avail = snd_pcm_playback_avail(runtime);
+	else
+		avail = snd_pcm_capture_avail(runtime);
+	if (avail > runtime->avail_max)
+		runtime->avail_max = avail;
+	if (avail >= runtime->stop_threshold) {
+		if (substream->runtime->status->state == SNDRV_PCM_STATE_DRAINING)
+			snd_pcm_drain_done(substream);
+		else
+			xrun(substream);
+		return -EPIPE;
+	}
+	if (avail >= runtime->control->avail_min)
+		wake_up(&runtime->sleep);
+	return 0;
+}
+
+static inline int snd_pcm_update_hw_ptr_interrupt(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	snd_pcm_uframes_t new_hw_ptr, hw_ptr_interrupt;
+	snd_pcm_sframes_t delta;
+
+	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
+	if (pos == SNDRV_PCM_POS_XRUN) {
+		xrun(substream);
+		return -EPIPE;
+	}
+	if (runtime->period_size == runtime->buffer_size)
+		goto __next_buf;
+	new_hw_ptr = runtime->hw_ptr_base + pos;
+	hw_ptr_interrupt = runtime->hw_ptr_interrupt + runtime->period_size;
+
+	delta = hw_ptr_interrupt - new_hw_ptr;
+	if (delta > 0) {
+		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
+#ifdef CONFIG_SND_DEBUG
+			if (runtime->periods > 1 && substream->pstr->xrun_debug) {
+				snd_printd(KERN_ERR "Unexpected hw_pointer value [1] (stream = %i, delta: -%ld, max jitter = %ld): wrong interrupt acknowledge?\n", substream->stream, (long) delta, runtime->buffer_size / 2);
+				if (substream->pstr->xrun_debug > 1)
+					dump_stack();
+			}
+#endif
+			return 0;
+		}
+	      __next_buf:
+		runtime->hw_ptr_base += runtime->buffer_size;
+		if (runtime->hw_ptr_base == runtime->boundary)
+			runtime->hw_ptr_base = 0;
+		new_hw_ptr = runtime->hw_ptr_base + pos;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+	    runtime->silence_size > 0)
+		snd_pcm_playback_silence(substream, new_hw_ptr);
+
+	runtime->status->hw_ptr = new_hw_ptr;
+	runtime->hw_ptr_interrupt = new_hw_ptr - new_hw_ptr % runtime->period_size;
+
+	return snd_pcm_update_hw_ptr_post(substream, runtime);
+}
+
+/* CAUTION: call it with irq disabled */
+int snd_pcm_update_hw_ptr(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr;
+	snd_pcm_sframes_t delta;
+
+	old_hw_ptr = runtime->status->hw_ptr;
+	pos = snd_pcm_update_hw_ptr_pos(substream, runtime);
+	if (pos == SNDRV_PCM_POS_XRUN) {
+		xrun(substream);
+		return -EPIPE;
+	}
+	new_hw_ptr = runtime->hw_ptr_base + pos;
+
+	delta = old_hw_ptr - new_hw_ptr;
+	if (delta > 0) {
+		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
+#ifdef CONFIG_SND_DEBUG
+			if (runtime->periods > 2 && substream->pstr->xrun_debug) {
+				snd_printd(KERN_ERR "Unexpected hw_pointer value [2] (stream = %i, delta: -%ld, max jitter = %ld): wrong interrupt acknowledge?\n", substream->stream, (long) delta, runtime->buffer_size / 2);
+				if (substream->pstr->xrun_debug > 1)
+					dump_stack();
+			}
+#endif
+			return 0;
+		}
+		runtime->hw_ptr_base += runtime->buffer_size;
+		if (runtime->hw_ptr_base == runtime->boundary)
+			runtime->hw_ptr_base = 0;
+		new_hw_ptr = runtime->hw_ptr_base + pos;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+	    runtime->silence_size > 0)
+		snd_pcm_playback_silence(substream, new_hw_ptr);
+
+	runtime->status->hw_ptr = new_hw_ptr;
+
+	return snd_pcm_update_hw_ptr_post(substream, runtime);
+}
+
+/**
+ * snd_pcm_set_ops - set the PCM operators
+ * @pcm: the pcm instance
+ * @direction: stream direction, SNDRV_PCM_STREAM_XXX
+ * @ops: the operator table
+ *
+ * Sets the given PCM operators to the pcm instance.
+ */
+void snd_pcm_set_ops(snd_pcm_t *pcm, int direction, snd_pcm_ops_t *ops)
+{
+	snd_pcm_str_t *stream = &pcm->streams[direction];
+	snd_pcm_substream_t *substream;
+	
+	for (substream = stream->substream; substream != NULL; substream = substream->next)
+		substream->ops = ops;
+}
+
+
+/**
+ * snd_pcm_sync - set the PCM sync id
+ * @substream: the pcm substream
+ *
+ * Sets the PCM sync identifier for the card.
+ */
+void snd_pcm_set_sync(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	
+	runtime->sync.id32[0] = substream->pcm->card->number;
+	runtime->sync.id32[1] = -1;
+	runtime->sync.id32[2] = -1;
+	runtime->sync.id32[3] = -1;
+}
+
+/*
+ *  Standard ioctl routine
+ */
+
+/* Code taken from alsa-lib */
+#define assert(a) snd_assert((a), return -EINVAL)
+
+static inline unsigned int div32(unsigned int a, unsigned int b, 
+				 unsigned int *r)
+{
+	if (b == 0) {
+		*r = 0;
+		return UINT_MAX;
+	}
+	*r = a % b;
+	return a / b;
+}
+
+static inline unsigned int div_down(unsigned int a, unsigned int b)
+{
+	if (b == 0)
+		return UINT_MAX;
+	return a / b;
+}
+
+static inline unsigned int div_up(unsigned int a, unsigned int b)
+{
+	unsigned int r;
+	unsigned int q;
+	if (b == 0)
+		return UINT_MAX;
+	q = div32(a, b, &r);
+	if (r)
+		++q;
+	return q;
+}
+
+static inline unsigned int mul(unsigned int a, unsigned int b)
+{
+	if (a == 0)
+		return 0;
+	if (div_down(UINT_MAX, a) < b)
+		return UINT_MAX;
+	return a * b;
+}
+
+static inline unsigned int muldiv32(unsigned int a, unsigned int b,
+				    unsigned int c, unsigned int *r)
+{
+	u_int64_t n = (u_int64_t) a * b;
+	if (c == 0) {
+		snd_assert(n > 0, );
+		*r = 0;
+		return UINT_MAX;
+	}
+	div64_32(&n, c, r);
+	if (n >= UINT_MAX) {
+		*r = 0;
+		return UINT_MAX;
+	}
+	return n;
+}
+
+static int snd_interval_refine_min(snd_interval_t *i, unsigned int min, int openmin)
+{
+	int changed = 0;
+	assert(!snd_interval_empty(i));
+	if (i->min < min) {
+		i->min = min;
+		i->openmin = openmin;
+		changed = 1;
+	} else if (i->min == min && !i->openmin && openmin) {
+		i->openmin = 1;
+		changed = 1;
+	}
+	if (i->integer) {
+		if (i->openmin) {
+			i->min++;
+			i->openmin = 0;
+		}
+	}
+	if (snd_interval_checkempty(i)) {
+		snd_interval_none(i);
+		return -EINVAL;
+	}
+	return changed;
+}
+
+static int snd_interval_refine_max(snd_interval_t *i, unsigned int max, int openmax)
+{
+	int changed = 0;
+	assert(!snd_interval_empty(i));
+	if (i->max > max) {
+		i->max = max;
+		i->openmax = openmax;
+		changed = 1;
+	} else if (i->max == max && !i->openmax && openmax) {
+		i->openmax = 1;
+		changed = 1;
+	}
+	if (i->integer) {
+		if (i->openmax) {
+			i->max--;
+			i->openmax = 0;
+		}
+	}
+	if (snd_interval_checkempty(i)) {
+		snd_interval_none(i);
+		return -EINVAL;
+	}
+	return changed;
+}
+
+/**
+ * snd_interval_refine - refine the interval value of configurator
+ * @i: the interval value to refine
+ * @v: the interval value to refer to
+ *
+ * Refines the interval value with the reference value.
+ * The interval is changed to the range satisfying both intervals.
+ * The interval status (min, max, integer, etc.) are evaluated.
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+int snd_interval_refine(snd_interval_t *i, const snd_interval_t *v)
+{
+	int changed = 0;
+	assert(!snd_interval_empty(i));
+	if (i->min < v->min) {
+		i->min = v->min;
+		i->openmin = v->openmin;
+		changed = 1;
+	} else if (i->min == v->min && !i->openmin && v->openmin) {
+		i->openmin = 1;
+		changed = 1;
+	}
+	if (i->max > v->max) {
+		i->max = v->max;
+		i->openmax = v->openmax;
+		changed = 1;
+	} else if (i->max == v->max && !i->openmax && v->openmax) {
+		i->openmax = 1;
+		changed = 1;
+	}
+	if (!i->integer && v->integer) {
+		i->integer = 1;
+		changed = 1;
+	}
+	if (i->integer) {
+		if (i->openmin) {
+			i->min++;
+			i->openmin = 0;
+		}
+		if (i->openmax) {
+			i->max--;
+			i->openmax = 0;
+		}
+	} else if (!i->openmin && !i->openmax && i->min == i->max)
+		i->integer = 1;
+	if (snd_interval_checkempty(i)) {
+		snd_interval_none(i);
+		return -EINVAL;
+	}
+	return changed;
+}
+
+static int snd_interval_refine_first(snd_interval_t *i)
+{
+	assert(!snd_interval_empty(i));
+	if (snd_interval_single(i))
+		return 0;
+	i->max = i->min;
+	i->openmax = i->openmin;
+	if (i->openmax)
+		i->max++;
+	return 1;
+}
+
+static int snd_interval_refine_last(snd_interval_t *i)
+{
+	assert(!snd_interval_empty(i));
+	if (snd_interval_single(i))
+		return 0;
+	i->min = i->max;
+	i->openmin = i->openmax;
+	if (i->openmin)
+		i->min--;
+	return 1;
+}
+
+static int snd_interval_refine_set(snd_interval_t *i, unsigned int val)
+{
+	snd_interval_t t;
+	t.empty = 0;
+	t.min = t.max = val;
+	t.openmin = t.openmax = 0;
+	t.integer = 1;
+	return snd_interval_refine(i, &t);
+}
+
+void snd_interval_mul(const snd_interval_t *a, const snd_interval_t *b, snd_interval_t *c)
+{
+	if (a->empty || b->empty) {
+		snd_interval_none(c);
+		return;
+	}
+	c->empty = 0;
+	c->min = mul(a->min, b->min);
+	c->openmin = (a->openmin || b->openmin);
+	c->max = mul(a->max,  b->max);
+	c->openmax = (a->openmax || b->openmax);
+	c->integer = (a->integer && b->integer);
+}
+
+/**
+ * snd_interval_div - refine the interval value with division
+ *
+ * c = a / b
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+void snd_interval_div(const snd_interval_t *a, const snd_interval_t *b, snd_interval_t *c)
+{
+	unsigned int r;
+	if (a->empty || b->empty) {
+		snd_interval_none(c);
+		return;
+	}
+	c->empty = 0;
+	c->min = div32(a->min, b->max, &r);
+	c->openmin = (r || a->openmin || b->openmax);
+	if (b->min > 0) {
+		c->max = div32(a->max, b->min, &r);
+		if (r) {
+			c->max++;
+			c->openmax = 1;
+		} else
+			c->openmax = (a->openmax || b->openmin);
+	} else {
+		c->max = UINT_MAX;
+		c->openmax = 0;
+	}
+	c->integer = 0;
+}
+
+/**
+ * snd_interval_muldivk - refine the interval value
+ *
+ * c = a * b / k
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+void snd_interval_muldivk(const snd_interval_t *a, const snd_interval_t *b,
+		      unsigned int k, snd_interval_t *c)
+{
+	unsigned int r;
+	if (a->empty || b->empty) {
+		snd_interval_none(c);
+		return;
+	}
+	c->empty = 0;
+	c->min = muldiv32(a->min, b->min, k, &r);
+	c->openmin = (r || a->openmin || b->openmin);
+	c->max = muldiv32(a->max, b->max, k, &r);
+	if (r) {
+		c->max++;
+		c->openmax = 1;
+	} else
+		c->openmax = (a->openmax || b->openmax);
+	c->integer = 0;
+}
+
+/**
+ * snd_interval_mulkdiv - refine the interval value
+ *
+ * c = a * k / b
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+void snd_interval_mulkdiv(const snd_interval_t *a, unsigned int k,
+		      const snd_interval_t *b, snd_interval_t *c)
+{
+	unsigned int r;
+	if (a->empty || b->empty) {
+		snd_interval_none(c);
+		return;
+	}
+	c->empty = 0;
+	c->min = muldiv32(a->min, k, b->max, &r);
+	c->openmin = (r || a->openmin || b->openmax);
+	if (b->min > 0) {
+		c->max = muldiv32(a->max, k, b->min, &r);
+		if (r) {
+			c->max++;
+			c->openmax = 1;
+		} else
+			c->openmax = (a->openmax || b->openmin);
+	} else {
+		c->max = UINT_MAX;
+		c->openmax = 0;
+	}
+	c->integer = 0;
+}
+
+#undef assert
+/* ---- */
+
+
+/**
+ * snd_interval_ratnum - refine the interval value
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+int snd_interval_ratnum(snd_interval_t *i,
+		    unsigned int rats_count, ratnum_t *rats,
+		    unsigned int *nump, unsigned int *denp)
+{
+	unsigned int best_num, best_diff, best_den;
+	unsigned int k;
+	snd_interval_t t;
+	int err;
+
+	best_num = best_den = best_diff = 0;
+	for (k = 0; k < rats_count; ++k) {
+		unsigned int num = rats[k].num;
+		unsigned int den;
+		unsigned int q = i->min;
+		int diff;
+		if (q == 0)
+			q = 1;
+		den = div_down(num, q);
+		if (den < rats[k].den_min)
+			continue;
+		if (den > rats[k].den_max)
+			den = rats[k].den_max;
+		else {
+			unsigned int r;
+			r = (den - rats[k].den_min) % rats[k].den_step;
+			if (r != 0)
+				den -= r;
+		}
+		diff = num - q * den;
+		if (best_num == 0 ||
+		    diff * best_den < best_diff * den) {
+			best_diff = diff;
+			best_den = den;
+			best_num = num;
+		}
+	}
+	if (best_den == 0) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	t.min = div_down(best_num, best_den);
+	t.openmin = !!(best_num % best_den);
+	
+	best_num = best_den = best_diff = 0;
+	for (k = 0; k < rats_count; ++k) {
+		unsigned int num = rats[k].num;
+		unsigned int den;
+		unsigned int q = i->max;
+		int diff;
+		if (q == 0) {
+			i->empty = 1;
+			return -EINVAL;
+		}
+		den = div_up(num, q);
+		if (den > rats[k].den_max)
+			continue;
+		if (den < rats[k].den_min)
+			den = rats[k].den_min;
+		else {
+			unsigned int r;
+			r = (den - rats[k].den_min) % rats[k].den_step;
+			if (r != 0)
+				den += rats[k].den_step - r;
+		}
+		diff = q * den - num;
+		if (best_num == 0 ||
+		    diff * best_den < best_diff * den) {
+			best_diff = diff;
+			best_den = den;
+			best_num = num;
+		}
+	}
+	if (best_den == 0) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	t.max = div_up(best_num, best_den);
+	t.openmax = !!(best_num % best_den);
+	t.integer = 0;
+	err = snd_interval_refine(i, &t);
+	if (err < 0)
+		return err;
+
+	if (snd_interval_single(i)) {
+		if (nump)
+			*nump = best_num;
+		if (denp)
+			*denp = best_den;
+	}
+	return err;
+}
+
+/**
+ * snd_interval_ratden - refine the interval value
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+static int snd_interval_ratden(snd_interval_t *i,
+			       unsigned int rats_count, ratden_t *rats,
+			       unsigned int *nump, unsigned int *denp)
+{
+	unsigned int best_num, best_diff, best_den;
+	unsigned int k;
+	snd_interval_t t;
+	int err;
+
+	best_num = best_den = best_diff = 0;
+	for (k = 0; k < rats_count; ++k) {
+		unsigned int num;
+		unsigned int den = rats[k].den;
+		unsigned int q = i->min;
+		int diff;
+		num = mul(q, den);
+		if (num > rats[k].num_max)
+			continue;
+		if (num < rats[k].num_min)
+			num = rats[k].num_max;
+		else {
+			unsigned int r;
+			r = (num - rats[k].num_min) % rats[k].num_step;
+			if (r != 0)
+				num += rats[k].num_step - r;
+		}
+		diff = num - q * den;
+		if (best_num == 0 ||
+		    diff * best_den < best_diff * den) {
+			best_diff = diff;
+			best_den = den;
+			best_num = num;
+		}
+	}
+	if (best_den == 0) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	t.min = div_down(best_num, best_den);
+	t.openmin = !!(best_num % best_den);
+	
+	best_num = best_den = best_diff = 0;
+	for (k = 0; k < rats_count; ++k) {
+		unsigned int num;
+		unsigned int den = rats[k].den;
+		unsigned int q = i->max;
+		int diff;
+		num = mul(q, den);
+		if (num < rats[k].num_min)
+			continue;
+		if (num > rats[k].num_max)
+			num = rats[k].num_max;
+		else {
+			unsigned int r;
+			r = (num - rats[k].num_min) % rats[k].num_step;
+			if (r != 0)
+				num -= r;
+		}
+		diff = q * den - num;
+		if (best_num == 0 ||
+		    diff * best_den < best_diff * den) {
+			best_diff = diff;
+			best_den = den;
+			best_num = num;
+		}
+	}
+	if (best_den == 0) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	t.max = div_up(best_num, best_den);
+	t.openmax = !!(best_num % best_den);
+	t.integer = 0;
+	err = snd_interval_refine(i, &t);
+	if (err < 0)
+		return err;
+
+	if (snd_interval_single(i)) {
+		if (nump)
+			*nump = best_num;
+		if (denp)
+			*denp = best_den;
+	}
+	return err;
+}
+
+/**
+ * snd_interval_list - refine the interval value from the list
+ * @i: the interval value to refine
+ * @count: the number of elements in the list
+ * @list: the value list
+ * @mask: the bit-mask to evaluate
+ *
+ * Refines the interval value from the list.
+ * When mask is non-zero, only the elements corresponding to bit 1 are
+ * evaluated.
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+int snd_interval_list(snd_interval_t *i, unsigned int count, unsigned int *list, unsigned int mask)
+{
+        unsigned int k;
+	int changed = 0;
+        for (k = 0; k < count; k++) {
+		if (mask && !(mask & (1 << k)))
+			continue;
+                if (i->min == list[k] && !i->openmin)
+                        goto _l1;
+                if (i->min < list[k]) {
+                        i->min = list[k];
+			i->openmin = 0;
+			changed = 1;
+                        goto _l1;
+                }
+        }
+        i->empty = 1;
+        return -EINVAL;
+ _l1:
+        for (k = count; k-- > 0;) {
+		if (mask && !(mask & (1 << k)))
+			continue;
+                if (i->max == list[k] && !i->openmax)
+                        goto _l2;
+                if (i->max > list[k]) {
+                        i->max = list[k];
+			i->openmax = 0;
+			changed = 1;
+                        goto _l2;
+                }
+        }
+        i->empty = 1;
+        return -EINVAL;
+ _l2:
+	if (snd_interval_checkempty(i)) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+        return changed;
+}
+
+static int snd_interval_step(snd_interval_t *i, unsigned int min, unsigned int step)
+{
+	unsigned int n;
+	int changed = 0;
+	n = (i->min - min) % step;
+	if (n != 0 || i->openmin) {
+		i->min += step - n;
+		changed = 1;
+	}
+	n = (i->max - min) % step;
+	if (n != 0 || i->openmax) {
+		i->max -= n;
+		changed = 1;
+	}
+	if (snd_interval_checkempty(i)) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	return changed;
+}
+
+/* Info constraints helpers */
+
+/**
+ * snd_pcm_hw_rule_add - add the hw-constraint rule
+ * @runtime: the pcm runtime instance
+ * @cond: condition bits
+ * @var: the variable to evaluate
+ * @func: the evaluation function
+ * @private: the private data pointer passed to function
+ * @dep: the dependent variables
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_rule_add(snd_pcm_runtime_t *runtime, unsigned int cond,
+			int var,
+			snd_pcm_hw_rule_func_t func, void *private,
+			int dep, ...)
+{
+	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
+	snd_pcm_hw_rule_t *c;
+	unsigned int k;
+	va_list args;
+	va_start(args, dep);
+	if (constrs->rules_num >= constrs->rules_all) {
+		snd_pcm_hw_rule_t *new;
+		unsigned int new_rules = constrs->rules_all + 16;
+		new = kcalloc(new_rules, sizeof(*c), GFP_KERNEL);
+		if (!new)
+			return -ENOMEM;
+		if (constrs->rules) {
+			memcpy(new, constrs->rules,
+			       constrs->rules_num * sizeof(*c));
+			kfree(constrs->rules);
+		}
+		constrs->rules = new;
+		constrs->rules_all = new_rules;
+	}
+	c = &constrs->rules[constrs->rules_num];
+	c->cond = cond;
+	c->func = func;
+	c->var = var;
+	c->private = private;
+	k = 0;
+	while (1) {
+		snd_assert(k < ARRAY_SIZE(c->deps), return -EINVAL);
+		c->deps[k++] = dep;
+		if (dep < 0)
+			break;
+		dep = va_arg(args, int);
+	}
+	constrs->rules_num++;
+	va_end(args);
+	return 0;
+}				    
+
+/**
+ * snd_pcm_hw_constraint_mask
+ */
+int snd_pcm_hw_constraint_mask(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+			       u_int32_t mask)
+{
+	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
+	snd_mask_t *maskp = constrs_mask(constrs, var);
+	*maskp->bits &= mask;
+	memset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */
+	if (*maskp->bits == 0)
+		return -EINVAL;
+	return 0;
+}
+
+/**
+ * snd_pcm_hw_constraint_mask64
+ */
+int snd_pcm_hw_constraint_mask64(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+				 u_int64_t mask)
+{
+	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
+	snd_mask_t *maskp = constrs_mask(constrs, var);
+	maskp->bits[0] &= (u_int32_t)mask;
+	maskp->bits[1] &= (u_int32_t)(mask >> 32);
+	memset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */
+	if (! maskp->bits[0] && ! maskp->bits[1])
+		return -EINVAL;
+	return 0;
+}
+
+/**
+ * snd_pcm_hw_constraint_integer
+ */
+int snd_pcm_hw_constraint_integer(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var)
+{
+	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
+	return snd_interval_setinteger(constrs_interval(constrs, var));
+}
+
+/**
+ * snd_pcm_hw_constraint_minmax
+ */
+int snd_pcm_hw_constraint_minmax(snd_pcm_runtime_t *runtime, snd_pcm_hw_param_t var,
+				 unsigned int min, unsigned int max)
+{
+	snd_pcm_hw_constraints_t *constrs = &runtime->hw_constraints;
+	snd_interval_t t;
+	t.min = min;
+	t.max = max;
+	t.openmin = t.openmax = 0;
+	t.integer = 0;
+	return snd_interval_refine(constrs_interval(constrs, var), &t);
+}
+
+static int snd_pcm_hw_rule_list(snd_pcm_hw_params_t *params,
+				snd_pcm_hw_rule_t *rule)
+{
+	snd_pcm_hw_constraint_list_t *list = rule->private;
+	return snd_interval_list(hw_param_interval(params, rule->var), list->count, list->list, list->mask);
+}		
+
+
+/**
+ * snd_pcm_hw_constraint_list
+ */
+int snd_pcm_hw_constraint_list(snd_pcm_runtime_t *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var,
+			       snd_pcm_hw_constraint_list_t *l)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var,
+				   snd_pcm_hw_rule_list, l,
+				   var, -1);
+}
+
+static int snd_pcm_hw_rule_ratnums(snd_pcm_hw_params_t *params,
+				   snd_pcm_hw_rule_t *rule)
+{
+	snd_pcm_hw_constraint_ratnums_t *r = rule->private;
+	unsigned int num = 0, den = 0;
+	int err;
+	err = snd_interval_ratnum(hw_param_interval(params, rule->var),
+				  r->nrats, r->rats, &num, &den);
+	if (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {
+		params->rate_num = num;
+		params->rate_den = den;
+	}
+	return err;
+}
+
+/**
+ * snd_pcm_hw_constraint_ratnums
+ */
+int snd_pcm_hw_constraint_ratnums(snd_pcm_runtime_t *runtime, 
+				  unsigned int cond,
+				  snd_pcm_hw_param_t var,
+				  snd_pcm_hw_constraint_ratnums_t *r)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var,
+				   snd_pcm_hw_rule_ratnums, r,
+				   var, -1);
+}
+
+static int snd_pcm_hw_rule_ratdens(snd_pcm_hw_params_t *params,
+				   snd_pcm_hw_rule_t *rule)
+{
+	snd_pcm_hw_constraint_ratdens_t *r = rule->private;
+	unsigned int num = 0, den = 0;
+	int err = snd_interval_ratden(hw_param_interval(params, rule->var),
+				  r->nrats, r->rats, &num, &den);
+	if (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {
+		params->rate_num = num;
+		params->rate_den = den;
+	}
+	return err;
+}
+
+/**
+ * snd_pcm_hw_constraint_ratdens
+ */
+int snd_pcm_hw_constraint_ratdens(snd_pcm_runtime_t *runtime, 
+				  unsigned int cond,
+				  snd_pcm_hw_param_t var,
+				  snd_pcm_hw_constraint_ratdens_t *r)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var,
+				   snd_pcm_hw_rule_ratdens, r,
+				   var, -1);
+}
+
+static int snd_pcm_hw_rule_msbits(snd_pcm_hw_params_t *params,
+				  snd_pcm_hw_rule_t *rule)
+{
+	unsigned int l = (unsigned long) rule->private;
+	int width = l & 0xffff;
+	unsigned int msbits = l >> 16;
+	snd_interval_t *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
+	if (snd_interval_single(i) && snd_interval_value(i) == width)
+		params->msbits = msbits;
+	return 0;
+}
+
+/**
+ * snd_pcm_hw_constraint_msbits
+ */
+int snd_pcm_hw_constraint_msbits(snd_pcm_runtime_t *runtime, 
+				 unsigned int cond,
+				 unsigned int width,
+				 unsigned int msbits)
+{
+	unsigned long l = (msbits << 16) | width;
+	return snd_pcm_hw_rule_add(runtime, cond, -1,
+				    snd_pcm_hw_rule_msbits,
+				    (void*) l,
+				    SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);
+}
+
+static int snd_pcm_hw_rule_step(snd_pcm_hw_params_t *params,
+				snd_pcm_hw_rule_t *rule)
+{
+	unsigned long step = (unsigned long) rule->private;
+	return snd_interval_step(hw_param_interval(params, rule->var), 0, step);
+}
+
+/**
+ * snd_pcm_hw_constraint_step
+ */
+int snd_pcm_hw_constraint_step(snd_pcm_runtime_t *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var,
+			       unsigned long step)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var, 
+				   snd_pcm_hw_rule_step, (void *) step,
+				   var, -1);
+}
+
+static int snd_pcm_hw_rule_pow2(snd_pcm_hw_params_t *params, snd_pcm_hw_rule_t *rule)
+{
+	static int pow2_sizes[] = {
+		1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,
+		1<<8, 1<<9, 1<<10, 1<<11, 1<<12, 1<<13, 1<<14, 1<<15,
+		1<<16, 1<<17, 1<<18, 1<<19, 1<<20, 1<<21, 1<<22, 1<<23,
+		1<<24, 1<<25, 1<<26, 1<<27, 1<<28, 1<<29, 1<<30
+	};
+	return snd_interval_list(hw_param_interval(params, rule->var),
+				 ARRAY_SIZE(pow2_sizes), pow2_sizes, 0);
+}		
+
+/**
+ * snd_pcm_hw_constraint_pow2
+ */
+int snd_pcm_hw_constraint_pow2(snd_pcm_runtime_t *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var, 
+				   snd_pcm_hw_rule_pow2, NULL,
+				   var, -1);
+}
+
+/* To use the same code we have in alsa-lib */
+#define snd_pcm_t snd_pcm_substream_t
+#define assert(i) snd_assert((i), return -EINVAL)
+#ifndef INT_MIN
+#define INT_MIN ((int)((unsigned int)INT_MAX+1))
+#endif
+
+void _snd_pcm_hw_param_any(snd_pcm_hw_params_t *params, snd_pcm_hw_param_t var)
+{
+	if (hw_is_mask(var)) {
+		snd_mask_any(hw_param_mask(params, var));
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+		return;
+	}
+	if (hw_is_interval(var)) {
+		snd_interval_any(hw_param_interval(params, var));
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+		return;
+	}
+	snd_BUG();
+}
+
+/**
+ * snd_pcm_hw_param_any
+ */
+int snd_pcm_hw_param_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+			 snd_pcm_hw_param_t var)
+{
+	_snd_pcm_hw_param_any(params, var);
+	return snd_pcm_hw_refine(pcm, params);
+}
+
+void _snd_pcm_hw_params_any(snd_pcm_hw_params_t *params)
+{
+	unsigned int k;
+	memset(params, 0, sizeof(*params));
+	for (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++)
+		_snd_pcm_hw_param_any(params, k);
+	for (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)
+		_snd_pcm_hw_param_any(params, k);
+	params->info = ~0U;
+}
+
+/**
+ * snd_pcm_hw_params_any
+ *
+ * Fill PARAMS with full configuration space boundaries
+ */
+int snd_pcm_hw_params_any(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
+{
+	_snd_pcm_hw_params_any(params);
+	return snd_pcm_hw_refine(pcm, params);
+}
+
+/**
+ * snd_pcm_hw_param_value
+ *
+ * Return the value for field PAR if it's fixed in configuration space 
+ *  defined by PARAMS. Return -EINVAL otherwise
+ */
+int snd_pcm_hw_param_value(const snd_pcm_hw_params_t *params,
+			   snd_pcm_hw_param_t var, int *dir)
+{
+	if (hw_is_mask(var)) {
+		const snd_mask_t *mask = hw_param_mask_c(params, var);
+		if (!snd_mask_single(mask))
+			return -EINVAL;
+		if (dir)
+			*dir = 0;
+		return snd_mask_value(mask);
+	}
+	if (hw_is_interval(var)) {
+		const snd_interval_t *i = hw_param_interval_c(params, var);
+		if (!snd_interval_single(i))
+			return -EINVAL;
+		if (dir)
+			*dir = i->openmin;
+		return snd_interval_value(i);
+	}
+	assert(0);
+	return -EINVAL;
+}
+
+/**
+ * snd_pcm_hw_param_value_min
+ *
+ * Return the minimum value for field PAR.
+ */
+unsigned int snd_pcm_hw_param_value_min(const snd_pcm_hw_params_t *params,
+					snd_pcm_hw_param_t var, int *dir)
+{
+	if (hw_is_mask(var)) {
+		if (dir)
+			*dir = 0;
+		return snd_mask_min(hw_param_mask_c(params, var));
+	}
+	if (hw_is_interval(var)) {
+		const snd_interval_t *i = hw_param_interval_c(params, var);
+		if (dir)
+			*dir = i->openmin;
+		return snd_interval_min(i);
+	}
+	assert(0);
+	return -EINVAL;
+}
+
+/**
+ * snd_pcm_hw_param_value_max
+ *
+ * Return the maximum value for field PAR.
+ */
+unsigned int snd_pcm_hw_param_value_max(const snd_pcm_hw_params_t *params,
+					snd_pcm_hw_param_t var, int *dir)
+{
+	if (hw_is_mask(var)) {
+		if (dir)
+			*dir = 0;
+		return snd_mask_max(hw_param_mask_c(params, var));
+	}
+	if (hw_is_interval(var)) {
+		const snd_interval_t *i = hw_param_interval_c(params, var);
+		if (dir)
+			*dir = - (int) i->openmax;
+		return snd_interval_max(i);
+	}
+	assert(0);
+	return -EINVAL;
+}
+
+void _snd_pcm_hw_param_setempty(snd_pcm_hw_params_t *params,
+				snd_pcm_hw_param_t var)
+{
+	if (hw_is_mask(var)) {
+		snd_mask_none(hw_param_mask(params, var));
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	} else if (hw_is_interval(var)) {
+		snd_interval_none(hw_param_interval(params, var));
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	} else {
+		snd_BUG();
+	}
+}
+
+int _snd_pcm_hw_param_setinteger(snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_param_t var)
+{
+	int changed;
+	assert(hw_is_interval(var));
+	changed = snd_interval_setinteger(hw_param_interval(params, var));
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+	
+/**
+ * snd_pcm_hw_param_setinteger
+ *
+ * Inside configuration space defined by PARAMS remove from PAR all 
+ * non integer values. Reduce configuration space accordingly.
+ * Return -EINVAL if the configuration space is empty
+ */
+int snd_pcm_hw_param_setinteger(snd_pcm_t *pcm, 
+				snd_pcm_hw_params_t *params,
+				snd_pcm_hw_param_t var)
+{
+	int changed = _snd_pcm_hw_param_setinteger(params, var);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+int _snd_pcm_hw_param_first(snd_pcm_hw_params_t *params,
+			    snd_pcm_hw_param_t var)
+{
+	int changed;
+	if (hw_is_mask(var))
+		changed = snd_mask_refine_first(hw_param_mask(params, var));
+	else if (hw_is_interval(var))
+		changed = snd_interval_refine_first(hw_param_interval(params, var));
+	else {
+		assert(0);
+		return -EINVAL;
+	}
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+
+
+/**
+ * snd_pcm_hw_param_first
+ *
+ * Inside configuration space defined by PARAMS remove from PAR all 
+ * values > minimum. Reduce configuration space accordingly.
+ * Return the minimum.
+ */
+int snd_pcm_hw_param_first(snd_pcm_t *pcm, 
+			   snd_pcm_hw_params_t *params, 
+			   snd_pcm_hw_param_t var, int *dir)
+{
+	int changed = _snd_pcm_hw_param_first(params, var);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		assert(err >= 0);
+	}
+	return snd_pcm_hw_param_value(params, var, dir);
+}
+
+int _snd_pcm_hw_param_last(snd_pcm_hw_params_t *params,
+			   snd_pcm_hw_param_t var)
+{
+	int changed;
+	if (hw_is_mask(var))
+		changed = snd_mask_refine_last(hw_param_mask(params, var));
+	else if (hw_is_interval(var))
+		changed = snd_interval_refine_last(hw_param_interval(params, var));
+	else {
+		assert(0);
+		return -EINVAL;
+	}
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+
+
+/**
+ * snd_pcm_hw_param_last
+ *
+ * Inside configuration space defined by PARAMS remove from PAR all 
+ * values < maximum. Reduce configuration space accordingly.
+ * Return the maximum.
+ */
+int snd_pcm_hw_param_last(snd_pcm_t *pcm, 
+			  snd_pcm_hw_params_t *params,
+			  snd_pcm_hw_param_t var, int *dir)
+{
+	int changed = _snd_pcm_hw_param_last(params, var);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		assert(err >= 0);
+	}
+	return snd_pcm_hw_param_value(params, var, dir);
+}
+
+int _snd_pcm_hw_param_min(snd_pcm_hw_params_t *params,
+			  snd_pcm_hw_param_t var, unsigned int val, int dir)
+{
+	int changed;
+	int open = 0;
+	if (dir) {
+		if (dir > 0) {
+			open = 1;
+		} else if (dir < 0) {
+			if (val > 0) {
+				open = 1;
+				val--;
+			}
+		}
+	}
+	if (hw_is_mask(var))
+		changed = snd_mask_refine_min(hw_param_mask(params, var), val + !!open);
+	else if (hw_is_interval(var))
+		changed = snd_interval_refine_min(hw_param_interval(params, var), val, open);
+	else {
+		assert(0);
+		return -EINVAL;
+	}
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+
+/**
+ * snd_pcm_hw_param_min
+ *
+ * Inside configuration space defined by PARAMS remove from PAR all 
+ * values < VAL. Reduce configuration space accordingly.
+ * Return new minimum or -EINVAL if the configuration space is empty
+ */
+int snd_pcm_hw_param_min(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+			 snd_pcm_hw_param_t var, unsigned int val, int *dir)
+{
+	int changed = _snd_pcm_hw_param_min(params, var, val, dir ? *dir : 0);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		if (err < 0)
+			return err;
+	}
+	return snd_pcm_hw_param_value_min(params, var, dir);
+}
+
+int _snd_pcm_hw_param_max(snd_pcm_hw_params_t *params,
+			   snd_pcm_hw_param_t var, unsigned int val, int dir)
+{
+	int changed;
+	int open = 0;
+	if (dir) {
+		if (dir < 0) {
+			open = 1;
+		} else if (dir > 0) {
+			open = 1;
+			val++;
+		}
+	}
+	if (hw_is_mask(var)) {
+		if (val == 0 && open) {
+			snd_mask_none(hw_param_mask(params, var));
+			changed = -EINVAL;
+		} else
+			changed = snd_mask_refine_max(hw_param_mask(params, var), val - !!open);
+	} else if (hw_is_interval(var))
+		changed = snd_interval_refine_max(hw_param_interval(params, var), val, open);
+	else {
+		assert(0);
+		return -EINVAL;
+	}
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+
+/**
+ * snd_pcm_hw_param_max
+ *
+ * Inside configuration space defined by PARAMS remove from PAR all 
+ *  values >= VAL + 1. Reduce configuration space accordingly.
+ *  Return new maximum or -EINVAL if the configuration space is empty
+ */
+int snd_pcm_hw_param_max(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+			  snd_pcm_hw_param_t var, unsigned int val, int *dir)
+{
+	int changed = _snd_pcm_hw_param_max(params, var, val, dir ? *dir : 0);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		if (err < 0)
+			return err;
+	}
+	return snd_pcm_hw_param_value_max(params, var, dir);
+}
+
+int _snd_pcm_hw_param_set(snd_pcm_hw_params_t *params,
+			  snd_pcm_hw_param_t var, unsigned int val, int dir)
+{
+	int changed;
+	if (hw_is_mask(var)) {
+		snd_mask_t *m = hw_param_mask(params, var);
+		if (val == 0 && dir < 0) {
+			changed = -EINVAL;
+			snd_mask_none(m);
+		} else {
+			if (dir > 0)
+				val++;
+			else if (dir < 0)
+				val--;
+			changed = snd_mask_refine_set(hw_param_mask(params, var), val);
+		}
+	} else if (hw_is_interval(var)) {
+		snd_interval_t *i = hw_param_interval(params, var);
+		if (val == 0 && dir < 0) {
+			changed = -EINVAL;
+			snd_interval_none(i);
+		} else if (dir == 0)
+			changed = snd_interval_refine_set(i, val);
+		else {
+			snd_interval_t t;
+			t.openmin = 1;
+			t.openmax = 1;
+			t.empty = 0;
+			t.integer = 0;
+			if (dir < 0) {
+				t.min = val - 1;
+				t.max = val;
+			} else {
+				t.min = val;
+				t.max = val+1;
+			}
+			changed = snd_interval_refine(i, &t);
+		}
+	} else {
+		assert(0);
+		return -EINVAL;
+	}
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+
+/**
+ * snd_pcm_hw_param_set
+ *
+ * Inside configuration space defined by PARAMS remove from PAR all 
+ * values != VAL. Reduce configuration space accordingly.
+ *  Return VAL or -EINVAL if the configuration space is empty
+ */
+int snd_pcm_hw_param_set(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+			 snd_pcm_hw_param_t var, unsigned int val, int dir)
+{
+	int changed = _snd_pcm_hw_param_set(params, var, val, dir);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		if (err < 0)
+			return err;
+	}
+	return snd_pcm_hw_param_value(params, var, NULL);
+}
+
+int _snd_pcm_hw_param_mask(snd_pcm_hw_params_t *params,
+			   snd_pcm_hw_param_t var, const snd_mask_t *val)
+{
+	int changed;
+	assert(hw_is_mask(var));
+	changed = snd_mask_refine(hw_param_mask(params, var), val);
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+
+/**
+ * snd_pcm_hw_param_mask
+ *
+ * Inside configuration space defined by PARAMS remove from PAR all values
+ * not contained in MASK. Reduce configuration space accordingly.
+ * This function can be called only for SNDRV_PCM_HW_PARAM_ACCESS,
+ * SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
+ * Return 0 on success or -EINVAL
+ * if the configuration space is empty
+ */
+int snd_pcm_hw_param_mask(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+			  snd_pcm_hw_param_t var, const snd_mask_t *val)
+{
+	int changed = _snd_pcm_hw_param_mask(params, var, val);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+static int boundary_sub(int a, int adir,
+			int b, int bdir,
+			int *c, int *cdir)
+{
+	adir = adir < 0 ? -1 : (adir > 0 ? 1 : 0);
+	bdir = bdir < 0 ? -1 : (bdir > 0 ? 1 : 0);
+	*c = a - b;
+	*cdir = adir - bdir;
+	if (*cdir == -2) {
+		assert(*c > INT_MIN);
+		(*c)--;
+	} else if (*cdir == 2) {
+		assert(*c < INT_MAX);
+		(*c)++;
+	}
+	return 0;
+}
+
+static int boundary_lt(unsigned int a, int adir,
+		       unsigned int b, int bdir)
+{
+	assert(a > 0 || adir >= 0);
+	assert(b > 0 || bdir >= 0);
+	if (adir < 0) {
+		a--;
+		adir = 1;
+	} else if (adir > 0)
+		adir = 1;
+	if (bdir < 0) {
+		b--;
+		bdir = 1;
+	} else if (bdir > 0)
+		bdir = 1;
+	return a < b || (a == b && adir < bdir);
+}
+
+/* Return 1 if min is nearer to best than max */
+static int boundary_nearer(int min, int mindir,
+			   int best, int bestdir,
+			   int max, int maxdir)
+{
+	int dmin, dmindir;
+	int dmax, dmaxdir;
+	boundary_sub(best, bestdir, min, mindir, &dmin, &dmindir);
+	boundary_sub(max, maxdir, best, bestdir, &dmax, &dmaxdir);
+	return boundary_lt(dmin, dmindir, dmax, dmaxdir);
+}
+
+/**
+ * snd_pcm_hw_param_near
+ *
+ * Inside configuration space defined by PARAMS set PAR to the available value
+ * nearest to VAL. Reduce configuration space accordingly.
+ * This function cannot be called for SNDRV_PCM_HW_PARAM_ACCESS,
+ * SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
+ * Return the value found.
+  */
+int snd_pcm_hw_param_near(snd_pcm_t *pcm, snd_pcm_hw_params_t *params,
+			  snd_pcm_hw_param_t var, unsigned int best, int *dir)
+{
+	snd_pcm_hw_params_t *save = NULL;
+	int v;
+	unsigned int saved_min;
+	int last = 0;
+	int min, max;
+	int mindir, maxdir;
+	int valdir = dir ? *dir : 0;
+	/* FIXME */
+	if (best > INT_MAX)
+		best = INT_MAX;
+	min = max = best;
+	mindir = maxdir = valdir;
+	if (maxdir > 0)
+		maxdir = 0;
+	else if (maxdir == 0)
+		maxdir = -1;
+	else {
+		maxdir = 1;
+		max--;
+	}
+	save = kmalloc(sizeof(*save), GFP_KERNEL);
+	if (save == NULL)
+		return -ENOMEM;
+	*save = *params;
+	saved_min = min;
+	min = snd_pcm_hw_param_min(pcm, params, var, min, &mindir);
+	if (min >= 0) {
+		snd_pcm_hw_params_t *params1;
+		if (max < 0)
+			goto _end;
+		if ((unsigned int)min == saved_min && mindir == valdir)
+			goto _end;
+		params1 = kmalloc(sizeof(*params1), GFP_KERNEL);
+		if (params1 == NULL) {
+			kfree(save);
+			return -ENOMEM;
+		}
+		*params1 = *save;
+		max = snd_pcm_hw_param_max(pcm, params1, var, max, &maxdir);
+		if (max < 0) {
+			kfree(params1);
+			goto _end;
+		}
+		if (boundary_nearer(max, maxdir, best, valdir, min, mindir)) {
+			*params = *params1;
+			last = 1;
+		}
+		kfree(params1);
+	} else {
+		*params = *save;
+		max = snd_pcm_hw_param_max(pcm, params, var, max, &maxdir);
+		assert(max >= 0);
+		last = 1;
+	}
+ _end:
+ 	kfree(save);
+	if (last)
+		v = snd_pcm_hw_param_last(pcm, params, var, dir);
+	else
+		v = snd_pcm_hw_param_first(pcm, params, var, dir);
+	assert(v >= 0);
+	return v;
+}
+
+/**
+ * snd_pcm_hw_param_choose
+ *
+ * Choose one configuration from configuration space defined by PARAMS
+ * The configuration chosen is that obtained fixing in this order:
+ * first access, first format, first subformat, min channels,
+ * min rate, min period time, max buffer size, min tick time
+ */
+int snd_pcm_hw_params_choose(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
+{
+	int err;
+
+	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_ACCESS, NULL);
+	assert(err >= 0);
+
+	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_FORMAT, NULL);
+	assert(err >= 0);
+
+	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_SUBFORMAT, NULL);
+	assert(err >= 0);
+
+	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_CHANNELS, NULL);
+	assert(err >= 0);
+
+	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_RATE, NULL);
+	assert(err >= 0);
+
+	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_PERIOD_TIME, NULL);
+	assert(err >= 0);
+
+	err = snd_pcm_hw_param_last(pcm, params, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, NULL);
+	assert(err >= 0);
+
+	err = snd_pcm_hw_param_first(pcm, params, SNDRV_PCM_HW_PARAM_TICK_TIME, NULL);
+	assert(err >= 0);
+
+	return 0;
+}
+
+#undef snd_pcm_t
+#undef assert
+
+static int snd_pcm_lib_ioctl_reset(snd_pcm_substream_t *substream,
+				   void *arg)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long flags;
+	snd_pcm_stream_lock_irqsave(substream, flags);
+	if (snd_pcm_running(substream) &&
+	    snd_pcm_update_hw_ptr(substream) >= 0)
+		runtime->status->hw_ptr %= runtime->buffer_size;
+	else
+		runtime->status->hw_ptr = 0;
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
+	return 0;
+}
+
+static int snd_pcm_lib_ioctl_channel_info(snd_pcm_substream_t *substream,
+					  void *arg)
+{
+	snd_pcm_channel_info_t *info = arg;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int width;
+	if (!(runtime->info & SNDRV_PCM_INFO_MMAP)) {
+		info->offset = -1;
+		return 0;
+	}
+	width = snd_pcm_format_physical_width(runtime->format);
+	if (width < 0)
+		return width;
+	info->offset = 0;
+	switch (runtime->access) {
+	case SNDRV_PCM_ACCESS_MMAP_INTERLEAVED:
+	case SNDRV_PCM_ACCESS_RW_INTERLEAVED:
+		info->first = info->channel * width;
+		info->step = runtime->channels * width;
+		break;
+	case SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED:
+	case SNDRV_PCM_ACCESS_RW_NONINTERLEAVED:
+	{
+		size_t size = runtime->dma_bytes / runtime->channels;
+		info->first = info->channel * size * 8;
+		info->step = width;
+		break;
+	}
+	default:
+		snd_BUG();
+		break;
+	}
+	return 0;
+}
+
+/**
+ * snd_pcm_lib_ioctl - a generic PCM ioctl callback
+ * @substream: the pcm substream instance
+ * @cmd: ioctl command
+ * @arg: ioctl argument
+ *
+ * Processes the generic ioctl commands for PCM.
+ * Can be passed as the ioctl callback for PCM ops.
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_lib_ioctl(snd_pcm_substream_t *substream,
+		      unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case SNDRV_PCM_IOCTL1_INFO:
+		return 0;
+	case SNDRV_PCM_IOCTL1_RESET:
+		return snd_pcm_lib_ioctl_reset(substream, arg);
+	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
+		return snd_pcm_lib_ioctl_channel_info(substream, arg);
+	}
+	return -ENXIO;
+}
+
+/*
+ *  Conditions
+ */
+
+static void snd_pcm_system_tick_set(snd_pcm_substream_t *substream, 
+				    unsigned long ticks)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	if (ticks == 0)
+		del_timer(&runtime->tick_timer);
+	else {
+		ticks += (1000000 / HZ) - 1;
+		ticks /= (1000000 / HZ);
+		mod_timer(&runtime->tick_timer, jiffies + ticks);
+	}
+}
+
+/* Temporary alias */
+void snd_pcm_tick_set(snd_pcm_substream_t *substream, unsigned long ticks)
+{
+	snd_pcm_system_tick_set(substream, ticks);
+}
+
+void snd_pcm_tick_prepare(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t frames = ULONG_MAX;
+	snd_pcm_uframes_t avail, dist;
+	unsigned int ticks;
+	u_int64_t n;
+	u_int32_t r;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (runtime->silence_size >= runtime->boundary) {
+			frames = 1;
+		} else if (runtime->silence_size > 0 &&
+			   runtime->silence_filled < runtime->buffer_size) {
+			snd_pcm_sframes_t noise_dist;
+			noise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;
+			snd_assert(noise_dist <= (snd_pcm_sframes_t)runtime->silence_threshold, );
+			frames = noise_dist - runtime->silence_threshold;
+		}
+		avail = snd_pcm_playback_avail(runtime);
+	} else {
+		avail = snd_pcm_capture_avail(runtime);
+	}
+	if (avail < runtime->control->avail_min) {
+		snd_pcm_sframes_t n = runtime->control->avail_min - avail;
+		if (n > 0 && frames > (snd_pcm_uframes_t)n)
+			frames = n;
+	}
+	if (avail < runtime->buffer_size) {
+		snd_pcm_sframes_t n = runtime->buffer_size - avail;
+		if (n > 0 && frames > (snd_pcm_uframes_t)n)
+			frames = n;
+	}
+	if (frames == ULONG_MAX) {
+		snd_pcm_tick_set(substream, 0);
+		return;
+	}
+	dist = runtime->status->hw_ptr - runtime->hw_ptr_base;
+	/* Distance to next interrupt */
+	dist = runtime->period_size - dist % runtime->period_size;
+	if (dist <= frames) {
+		snd_pcm_tick_set(substream, 0);
+		return;
+	}
+	/* the base time is us */
+	n = frames;
+	n *= 1000000;
+	div64_32(&n, runtime->tick_time * runtime->rate, &r);
+	ticks = n + (r > 0 ? 1 : 0);
+	if (ticks < runtime->sleep_min)
+		ticks = runtime->sleep_min;
+	snd_pcm_tick_set(substream, (unsigned long) ticks);
+}
+
+void snd_pcm_tick_elapsed(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime;
+	unsigned long flags;
+	
+	snd_assert(substream != NULL, return);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return);
+
+	snd_pcm_stream_lock_irqsave(substream, flags);
+	if (!snd_pcm_running(substream) ||
+	    snd_pcm_update_hw_ptr(substream) < 0)
+		goto _end;
+	if (runtime->sleep_min)
+		snd_pcm_tick_prepare(substream);
+ _end:
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
+}
+
+/**
+ * snd_pcm_period_elapsed - update the pcm status for the next period
+ * @substream: the pcm substream instance
+ *
+ * This function is called from the interrupt handler when the
+ * PCM has processed the period size.  It will update the current
+ * pointer, set up the tick, wake up sleepers, etc.
+ *
+ * Even if more than one periods have elapsed since the last call, you
+ * have to call this only once.
+ */
+void snd_pcm_period_elapsed(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime;
+	unsigned long flags;
+
+	snd_assert(substream != NULL, return);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return);
+
+	if (runtime->transfer_ack_begin)
+		runtime->transfer_ack_begin(substream);
+
+	snd_pcm_stream_lock_irqsave(substream, flags);
+	if (!snd_pcm_running(substream) ||
+	    snd_pcm_update_hw_ptr_interrupt(substream) < 0)
+		goto _end;
+
+	if (substream->timer_running)
+		snd_timer_interrupt(substream->timer, 1);
+	if (runtime->sleep_min)
+		snd_pcm_tick_prepare(substream);
+ _end:
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
+	if (runtime->transfer_ack_end)
+		runtime->transfer_ack_end(substream);
+	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
+}
+
+static int snd_pcm_lib_write_transfer(snd_pcm_substream_t *substream,
+				      unsigned int hwoff,
+				      unsigned long data, unsigned int off,
+				      snd_pcm_uframes_t frames)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
+	if (substream->ops->copy) {
+		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
+			return err;
+	} else {
+		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		snd_assert(runtime->dma_area, return -EFAULT);
+		if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))
+			return -EFAULT;
+	}
+	return 0;
+}
+ 
+typedef int (*transfer_f)(snd_pcm_substream_t *substream, unsigned int hwoff,
+			  unsigned long data, unsigned int off,
+			  snd_pcm_uframes_t size);
+
+static snd_pcm_sframes_t snd_pcm_lib_write1(snd_pcm_substream_t *substream, 
+					    unsigned long data,
+					    snd_pcm_uframes_t size,
+					    int nonblock,
+					    transfer_f transfer)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t xfer = 0;
+	snd_pcm_uframes_t offset = 0;
+	int err = 0;
+
+	if (size == 0)
+		return 0;
+	if (size > runtime->xfer_align)
+		size -= size % runtime->xfer_align;
+
+	snd_pcm_stream_lock_irq(substream);
+	switch (runtime->status->state) {
+	case SNDRV_PCM_STATE_PREPARED:
+	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_PAUSED:
+		break;
+	case SNDRV_PCM_STATE_XRUN:
+		err = -EPIPE;
+		goto _end_unlock;
+	case SNDRV_PCM_STATE_SUSPENDED:
+		err = -ESTRPIPE;
+		goto _end_unlock;
+	default:
+		err = -EBADFD;
+		goto _end_unlock;
+	}
+
+	while (size > 0) {
+		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
+		snd_pcm_uframes_t avail;
+		snd_pcm_uframes_t cont;
+		if (runtime->sleep_min == 0 && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+			snd_pcm_update_hw_ptr(substream);
+		avail = snd_pcm_playback_avail(runtime);
+		if (((avail < runtime->control->avail_min && size > avail) ||
+		   (size >= runtime->xfer_align && avail < runtime->xfer_align))) {
+			wait_queue_t wait;
+			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED } state;
+			long tout;
+
+			if (nonblock) {
+				err = -EAGAIN;
+				goto _end_unlock;
+			}
+
+			init_waitqueue_entry(&wait, current);
+			add_wait_queue(&runtime->sleep, &wait);
+			while (1) {
+				if (signal_pending(current)) {
+					state = SIGNALED;
+					break;
+				}
+				set_current_state(TASK_INTERRUPTIBLE);
+				snd_pcm_stream_unlock_irq(substream);
+				tout = schedule_timeout(10 * HZ);
+				snd_pcm_stream_lock_irq(substream);
+				if (tout == 0) {
+					if (runtime->status->state != SNDRV_PCM_STATE_PREPARED &&
+					    runtime->status->state != SNDRV_PCM_STATE_PAUSED) {
+						state = runtime->status->state == SNDRV_PCM_STATE_SUSPENDED ? SUSPENDED : EXPIRED;
+						break;
+					}
+				}
+				switch (runtime->status->state) {
+				case SNDRV_PCM_STATE_XRUN:
+				case SNDRV_PCM_STATE_DRAINING:
+					state = ERROR;
+					goto _end_loop;
+				case SNDRV_PCM_STATE_SUSPENDED:
+					state = SUSPENDED;
+					goto _end_loop;
+				default:
+					break;
+				}
+				avail = snd_pcm_playback_avail(runtime);
+				if (avail >= runtime->control->avail_min) {
+					state = READY;
+					break;
+				}
+			}
+		       _end_loop:
+			remove_wait_queue(&runtime->sleep, &wait);
+
+			switch (state) {
+			case ERROR:
+				err = -EPIPE;
+				goto _end_unlock;
+			case SUSPENDED:
+				err = -ESTRPIPE;
+				goto _end_unlock;
+			case SIGNALED:
+				err = -ERESTARTSYS;
+				goto _end_unlock;
+			case EXPIRED:
+				snd_printd("playback write error (DMA or IRQ trouble?)\n");
+				err = -EIO;
+				goto _end_unlock;
+			default:
+				break;
+			}
+		}
+		if (avail > runtime->xfer_align)
+			avail -= avail % runtime->xfer_align;
+		frames = size > avail ? avail : size;
+		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
+		if (frames > cont)
+			frames = cont;
+		snd_assert(frames != 0, snd_pcm_stream_unlock_irq(substream); return -EINVAL);
+		appl_ptr = runtime->control->appl_ptr;
+		appl_ofs = appl_ptr % runtime->buffer_size;
+		snd_pcm_stream_unlock_irq(substream);
+		if ((err = transfer(substream, appl_ofs, data, offset, frames)) < 0)
+			goto _end;
+		snd_pcm_stream_lock_irq(substream);
+		switch (runtime->status->state) {
+		case SNDRV_PCM_STATE_XRUN:
+			err = -EPIPE;
+			goto _end_unlock;
+		case SNDRV_PCM_STATE_SUSPENDED:
+			err = -ESTRPIPE;
+			goto _end_unlock;
+		default:
+			break;
+		}
+		appl_ptr += frames;
+		if (appl_ptr >= runtime->boundary)
+			appl_ptr -= runtime->boundary;
+		runtime->control->appl_ptr = appl_ptr;
+		if (substream->ops->ack)
+			substream->ops->ack(substream);
+
+		offset += frames;
+		size -= frames;
+		xfer += frames;
+		if (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
+		    snd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {
+			err = snd_pcm_start(substream);
+			if (err < 0)
+				goto _end_unlock;
+		}
+		if (runtime->sleep_min &&
+		    runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+			snd_pcm_tick_prepare(substream);
+	}
+ _end_unlock:
+	snd_pcm_stream_unlock_irq(substream);
+ _end:
+	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
+}
+
+snd_pcm_sframes_t snd_pcm_lib_write(snd_pcm_substream_t *substream, const void __user *buf, snd_pcm_uframes_t size)
+{
+	snd_pcm_runtime_t *runtime;
+	int nonblock;
+
+	snd_assert(substream != NULL, return -ENXIO);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -ENXIO);
+	snd_assert(substream->ops->copy != NULL || runtime->dma_area != NULL, return -EINVAL);
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+		return -EBADFD;
+
+	snd_assert(substream->ffile != NULL, return -ENXIO);
+	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	if (substream->oss.oss) {
+		snd_pcm_oss_setup_t *setup = substream->oss.setup;
+		if (setup != NULL) {
+			if (setup->nonblock)
+				nonblock = 1;
+			else if (setup->block)
+				nonblock = 0;
+		}
+	}
+#endif
+
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
+	    runtime->channels > 1)
+		return -EINVAL;
+	return snd_pcm_lib_write1(substream, (unsigned long)buf, size, nonblock,
+				  snd_pcm_lib_write_transfer);
+}
+
+static int snd_pcm_lib_writev_transfer(snd_pcm_substream_t *substream,
+				       unsigned int hwoff,
+				       unsigned long data, unsigned int off,
+				       snd_pcm_uframes_t frames)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+	void __user **bufs = (void __user **)data;
+	int channels = runtime->channels;
+	int c;
+	if (substream->ops->copy) {
+		snd_assert(substream->ops->silence != NULL, return -EINVAL);
+		for (c = 0; c < channels; ++c, ++bufs) {
+			if (*bufs == NULL) {
+				if ((err = substream->ops->silence(substream, c, hwoff, frames)) < 0)
+					return err;
+			} else {
+				char __user *buf = *bufs + samples_to_bytes(runtime, off);
+				if ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)
+					return err;
+			}
+		}
+	} else {
+		/* default transfer behaviour */
+		size_t dma_csize = runtime->dma_bytes / channels;
+		snd_assert(runtime->dma_area, return -EFAULT);
+		for (c = 0; c < channels; ++c, ++bufs) {
+			char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
+			if (*bufs == NULL) {
+				snd_pcm_format_set_silence(runtime->format, hwbuf, frames);
+			} else {
+				char __user *buf = *bufs + samples_to_bytes(runtime, off);
+				if (copy_from_user(hwbuf, buf, samples_to_bytes(runtime, frames)))
+					return -EFAULT;
+			}
+		}
+	}
+	return 0;
+}
+ 
+snd_pcm_sframes_t snd_pcm_lib_writev(snd_pcm_substream_t *substream,
+				     void __user **bufs,
+				     snd_pcm_uframes_t frames)
+{
+	snd_pcm_runtime_t *runtime;
+	int nonblock;
+
+	snd_assert(substream != NULL, return -ENXIO);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -ENXIO);
+	snd_assert(substream->ops->copy != NULL || runtime->dma_area != NULL, return -EINVAL);
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+		return -EBADFD;
+
+	snd_assert(substream->ffile != NULL, return -ENXIO);
+	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	if (substream->oss.oss) {
+		snd_pcm_oss_setup_t *setup = substream->oss.setup;
+		if (setup != NULL) {
+			if (setup->nonblock)
+				nonblock = 1;
+			else if (setup->block)
+				nonblock = 0;
+		}
+	}
+#endif
+
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
+		return -EINVAL;
+	return snd_pcm_lib_write1(substream, (unsigned long)bufs, frames,
+				  nonblock, snd_pcm_lib_writev_transfer);
+}
+
+static int snd_pcm_lib_read_transfer(snd_pcm_substream_t *substream, 
+				     unsigned int hwoff,
+				     unsigned long data, unsigned int off,
+				     snd_pcm_uframes_t frames)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
+	if (substream->ops->copy) {
+		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
+			return err;
+	} else {
+		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		snd_assert(runtime->dma_area, return -EFAULT);
+		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))
+			return -EFAULT;
+	}
+	return 0;
+}
+
+static snd_pcm_sframes_t snd_pcm_lib_read1(snd_pcm_substream_t *substream,
+					   unsigned long data,
+					   snd_pcm_uframes_t size,
+					   int nonblock,
+					   transfer_f transfer)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_uframes_t xfer = 0;
+	snd_pcm_uframes_t offset = 0;
+	int err = 0;
+
+	if (size == 0)
+		return 0;
+	if (size > runtime->xfer_align)
+		size -= size % runtime->xfer_align;
+
+	snd_pcm_stream_lock_irq(substream);
+	switch (runtime->status->state) {
+	case SNDRV_PCM_STATE_PREPARED:
+		if (size >= runtime->start_threshold) {
+			err = snd_pcm_start(substream);
+			if (err < 0)
+				goto _end_unlock;
+		}
+		break;
+	case SNDRV_PCM_STATE_DRAINING:
+	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_PAUSED:
+		break;
+	case SNDRV_PCM_STATE_XRUN:
+		err = -EPIPE;
+		goto _end_unlock;
+	case SNDRV_PCM_STATE_SUSPENDED:
+		err = -ESTRPIPE;
+		goto _end_unlock;
+	default:
+		err = -EBADFD;
+		goto _end_unlock;
+	}
+
+	while (size > 0) {
+		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
+		snd_pcm_uframes_t avail;
+		snd_pcm_uframes_t cont;
+		if (runtime->sleep_min == 0 && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+			snd_pcm_update_hw_ptr(substream);
+	      __draining:
+		avail = snd_pcm_capture_avail(runtime);
+		if (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
+			if (avail < runtime->xfer_align) {
+				err = -EPIPE;
+				goto _end_unlock;
+			}
+		} else if ((avail < runtime->control->avail_min && size > avail) ||
+			   (size >= runtime->xfer_align && avail < runtime->xfer_align)) {
+			wait_queue_t wait;
+			enum { READY, SIGNALED, ERROR, SUSPENDED, EXPIRED } state;
+			long tout;
+
+			if (nonblock) {
+				err = -EAGAIN;
+				goto _end_unlock;
+			}
+
+			init_waitqueue_entry(&wait, current);
+			add_wait_queue(&runtime->sleep, &wait);
+			while (1) {
+				if (signal_pending(current)) {
+					state = SIGNALED;
+					break;
+				}
+				set_current_state(TASK_INTERRUPTIBLE);
+				snd_pcm_stream_unlock_irq(substream);
+				tout = schedule_timeout(10 * HZ);
+				snd_pcm_stream_lock_irq(substream);
+				if (tout == 0) {
+					if (runtime->status->state != SNDRV_PCM_STATE_PREPARED &&
+					    runtime->status->state != SNDRV_PCM_STATE_PAUSED) {
+						state = runtime->status->state == SNDRV_PCM_STATE_SUSPENDED ? SUSPENDED : EXPIRED;
+						break;
+					}
+				}
+				switch (runtime->status->state) {
+				case SNDRV_PCM_STATE_XRUN:
+					state = ERROR;
+					goto _end_loop;
+				case SNDRV_PCM_STATE_SUSPENDED:
+					state = SUSPENDED;
+					goto _end_loop;
+				case SNDRV_PCM_STATE_DRAINING:
+					goto __draining;
+				default:
+					break;
+				}
+				avail = snd_pcm_capture_avail(runtime);
+				if (avail >= runtime->control->avail_min) {
+					state = READY;
+					break;
+				}
+			}
+		       _end_loop:
+			remove_wait_queue(&runtime->sleep, &wait);
+
+			switch (state) {
+			case ERROR:
+				err = -EPIPE;
+				goto _end_unlock;
+			case SUSPENDED:
+				err = -ESTRPIPE;
+				goto _end_unlock;
+			case SIGNALED:
+				err = -ERESTARTSYS;
+				goto _end_unlock;
+			case EXPIRED:
+				snd_printd("capture read error (DMA or IRQ trouble?)\n");
+				err = -EIO;
+				goto _end_unlock;
+			default:
+				break;
+			}
+		}
+		if (avail > runtime->xfer_align)
+			avail -= avail % runtime->xfer_align;
+		frames = size > avail ? avail : size;
+		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
+		if (frames > cont)
+			frames = cont;
+		snd_assert(frames != 0, snd_pcm_stream_unlock_irq(substream); return -EINVAL);
+		appl_ptr = runtime->control->appl_ptr;
+		appl_ofs = appl_ptr % runtime->buffer_size;
+		snd_pcm_stream_unlock_irq(substream);
+		if ((err = transfer(substream, appl_ofs, data, offset, frames)) < 0)
+			goto _end;
+		snd_pcm_stream_lock_irq(substream);
+		switch (runtime->status->state) {
+		case SNDRV_PCM_STATE_XRUN:
+			err = -EPIPE;
+			goto _end_unlock;
+		case SNDRV_PCM_STATE_SUSPENDED:
+			err = -ESTRPIPE;
+			goto _end_unlock;
+		default:
+			break;
+		}
+		appl_ptr += frames;
+		if (appl_ptr >= runtime->boundary)
+			appl_ptr -= runtime->boundary;
+		runtime->control->appl_ptr = appl_ptr;
+		if (substream->ops->ack)
+			substream->ops->ack(substream);
+
+		offset += frames;
+		size -= frames;
+		xfer += frames;
+		if (runtime->sleep_min &&
+		    runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+			snd_pcm_tick_prepare(substream);
+	}
+ _end_unlock:
+	snd_pcm_stream_unlock_irq(substream);
+ _end:
+	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
+}
+
+snd_pcm_sframes_t snd_pcm_lib_read(snd_pcm_substream_t *substream, void __user *buf, snd_pcm_uframes_t size)
+{
+	snd_pcm_runtime_t *runtime;
+	int nonblock;
+	
+	snd_assert(substream != NULL, return -ENXIO);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -ENXIO);
+	snd_assert(substream->ops->copy != NULL || runtime->dma_area != NULL, return -EINVAL);
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+		return -EBADFD;
+
+	snd_assert(substream->ffile != NULL, return -ENXIO);
+	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	if (substream->oss.oss) {
+		snd_pcm_oss_setup_t *setup = substream->oss.setup;
+		if (setup != NULL) {
+			if (setup->nonblock)
+				nonblock = 1;
+			else if (setup->block)
+				nonblock = 0;
+		}
+	}
+#endif
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)
+		return -EINVAL;
+	return snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);
+}
+
+static int snd_pcm_lib_readv_transfer(snd_pcm_substream_t *substream,
+				      unsigned int hwoff,
+				      unsigned long data, unsigned int off,
+				      snd_pcm_uframes_t frames)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+	void __user **bufs = (void __user **)data;
+	int channels = runtime->channels;
+	int c;
+	if (substream->ops->copy) {
+		for (c = 0; c < channels; ++c, ++bufs) {
+			char __user *buf;
+			if (*bufs == NULL)
+				continue;
+			buf = *bufs + samples_to_bytes(runtime, off);
+			if ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)
+				return err;
+		}
+	} else {
+		snd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;
+		snd_assert(runtime->dma_area, return -EFAULT);
+		for (c = 0; c < channels; ++c, ++bufs) {
+			char *hwbuf;
+			char __user *buf;
+			if (*bufs == NULL)
+				continue;
+
+			hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
+			buf = *bufs + samples_to_bytes(runtime, off);
+			if (copy_to_user(buf, hwbuf, samples_to_bytes(runtime, frames)))
+				return -EFAULT;
+		}
+	}
+	return 0;
+}
+ 
+snd_pcm_sframes_t snd_pcm_lib_readv(snd_pcm_substream_t *substream,
+				    void __user **bufs,
+				    snd_pcm_uframes_t frames)
+{
+	snd_pcm_runtime_t *runtime;
+	int nonblock;
+
+	snd_assert(substream != NULL, return -ENXIO);
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return -ENXIO);
+	snd_assert(substream->ops->copy != NULL || runtime->dma_area != NULL, return -EINVAL);
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+		return -EBADFD;
+
+	snd_assert(substream->ffile != NULL, return -ENXIO);
+	nonblock = !!(substream->ffile->f_flags & O_NONBLOCK);
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	if (substream->oss.oss) {
+		snd_pcm_oss_setup_t *setup = substream->oss.setup;
+		if (setup != NULL) {
+			if (setup->nonblock)
+				nonblock = 1;
+			else if (setup->block)
+				nonblock = 0;
+		}
+	}
+#endif
+
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
+		return -EINVAL;
+	return snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);
+}
+
+/*
+ *  Exported symbols
+ */
+
+EXPORT_SYMBOL(snd_interval_refine);
+EXPORT_SYMBOL(snd_interval_list);
+EXPORT_SYMBOL(snd_interval_ratnum);
+EXPORT_SYMBOL(snd_interval_muldivk);
+EXPORT_SYMBOL(snd_interval_mulkdiv);
+EXPORT_SYMBOL(snd_interval_div);
+EXPORT_SYMBOL(_snd_pcm_hw_params_any);
+EXPORT_SYMBOL(_snd_pcm_hw_param_min);
+EXPORT_SYMBOL(_snd_pcm_hw_param_set);
+EXPORT_SYMBOL(_snd_pcm_hw_param_setempty);
+EXPORT_SYMBOL(_snd_pcm_hw_param_setinteger);
+EXPORT_SYMBOL(snd_pcm_hw_param_value_min);
+EXPORT_SYMBOL(snd_pcm_hw_param_value_max);
+EXPORT_SYMBOL(snd_pcm_hw_param_mask);
+EXPORT_SYMBOL(snd_pcm_hw_param_first);
+EXPORT_SYMBOL(snd_pcm_hw_param_last);
+EXPORT_SYMBOL(snd_pcm_hw_param_near);
+EXPORT_SYMBOL(snd_pcm_hw_param_set);
+EXPORT_SYMBOL(snd_pcm_hw_refine);
+EXPORT_SYMBOL(snd_pcm_hw_params);
+EXPORT_SYMBOL(snd_pcm_hw_constraints_init);
+EXPORT_SYMBOL(snd_pcm_hw_constraints_complete);
+EXPORT_SYMBOL(snd_pcm_hw_constraint_list);
+EXPORT_SYMBOL(snd_pcm_hw_constraint_step);
+EXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);
+EXPORT_SYMBOL(snd_pcm_hw_constraint_ratdens);
+EXPORT_SYMBOL(snd_pcm_hw_constraint_msbits);
+EXPORT_SYMBOL(snd_pcm_hw_constraint_minmax);
+EXPORT_SYMBOL(snd_pcm_hw_constraint_integer);
+EXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);
+EXPORT_SYMBOL(snd_pcm_hw_rule_add);
+EXPORT_SYMBOL(snd_pcm_set_ops);
+EXPORT_SYMBOL(snd_pcm_set_sync);
+EXPORT_SYMBOL(snd_pcm_lib_ioctl);
+EXPORT_SYMBOL(snd_pcm_stop);
+EXPORT_SYMBOL(snd_pcm_period_elapsed);
+EXPORT_SYMBOL(snd_pcm_lib_write);
+EXPORT_SYMBOL(snd_pcm_lib_read);
+EXPORT_SYMBOL(snd_pcm_lib_writev);
+EXPORT_SYMBOL(snd_pcm_lib_readv);
+EXPORT_SYMBOL(snd_pcm_lib_buffer_bytes);
+EXPORT_SYMBOL(snd_pcm_lib_period_bytes);
+/* pcm_memory.c */
+EXPORT_SYMBOL(snd_pcm_lib_preallocate_free_for_all);
+EXPORT_SYMBOL(snd_pcm_lib_preallocate_pages);
+EXPORT_SYMBOL(snd_pcm_lib_preallocate_pages_for_all);
+EXPORT_SYMBOL(snd_pcm_sgbuf_ops_page);
+EXPORT_SYMBOL(snd_pcm_lib_malloc_pages);
+EXPORT_SYMBOL(snd_pcm_lib_free_pages);
