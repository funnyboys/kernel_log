commit fb8cd6481ffd126f35e9e146a0dcf0c4e8899f2e
Author: Changming Liu <liu.changm@northeastern.edu>
Date:   Tue May 26 00:39:21 2020 +0000

    ALSA: hwdep: fix a left shifting 1 by 31 UB bug
    
    The "info.index" variable can be 31 in "1 << info.index".
    This might trigger an undefined behavior since 1 is signed.
    
    Fix this by casting 1 to 1u just to be sure "1u << 31" is defined.
    
    Signed-off-by: Changming Liu <liu.changm@northeastern.edu>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/BL0PR06MB4548170B842CB055C9AF695DE5B00@BL0PR06MB4548.namprd06.prod.outlook.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index b412d3b3d5ff..21edb8ac95eb 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -216,12 +216,12 @@ static int snd_hwdep_dsp_load(struct snd_hwdep *hw,
 	if (info.index >= 32)
 		return -EINVAL;
 	/* check whether the dsp was already loaded */
-	if (hw->dsp_loaded & (1 << info.index))
+	if (hw->dsp_loaded & (1u << info.index))
 		return -EBUSY;
 	err = hw->ops.dsp_load(hw, &info);
 	if (err < 0)
 		return err;
-	hw->dsp_loaded |= (1 << info.index);
+	hw->dsp_loaded |= (1u << info.index);
 	return 0;
 }
 

commit f15ee210cdb87f82147df237d2fcfc4527523d62
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:20 2020 +0100

    ALSA: core: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-5-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 00cb5aed10a9..b412d3b3d5ff 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -353,7 +353,7 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 {
 	struct snd_hwdep *hwdep;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_hwdep_dev_free,
 		.dev_register = snd_hwdep_dev_register,
 		.dev_disconnect = snd_hwdep_dev_disconnect,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 26e71cf05f1e..00cb5aed10a9 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Hardware dependent layer
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/major.h>

commit 19e7b5f99474107e8d0b4b3e4652fa19ddb87efc
Merge: 26064ea409b4 ce4c253573ad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 09:25:20 2018 -0800

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "All kinds of misc stuff, without any unifying topic, from various
      people.
    
      Neil's d_anon patch, several bugfixes, introduction of kvmalloc
      analogue of kmemdup_user(), extending bitfield.h to deal with
      fixed-endians, assorted cleanups all over the place..."
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (28 commits)
      alpha: osf_sys.c: use timespec64 where appropriate
      alpha: osf_sys.c: fix put_tv32 regression
      jffs2: Fix use-after-free bug in jffs2_iget()'s error handling path
      dcache: delete unused d_hash_mask
      dcache: subtract d_hash_shift from 32 in advance
      fs/buffer.c: fold init_buffer() into init_page_buffers()
      fs: fold __inode_permission() into inode_permission()
      fs: add RWF_APPEND
      sctp: use vmemdup_user() rather than badly open-coding memdup_user()
      snd_ctl_elem_init_enum_names(): switch to vmemdup_user()
      replace_user_tlv(): switch to vmemdup_user()
      new primitive: vmemdup_user()
      memdup_user(): switch to GFP_USER
      eventfd: fold eventfd_ctx_get() into eventfd_ctx_fileget()
      eventfd: fold eventfd_ctx_read() into eventfd_read()
      eventfd: convert to use anon_inode_getfd()
      nfs4file: get rid of pointless include of btrfs.h
      uvc_v4l2: clean copyin/copyout up
      vme_user: don't use __copy_..._user()
      usx2y: don't bother with memdup_user() for 16-byte structure
      ...

commit 446bd647ceee73fbed50404daece9cbcec751f66
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 28 16:30:22 2017 -0500

    snd_hwdep_dsp_load(): don't bother with access_ok()
    
    the only remaining instance of ->dsp_load() doesn't need it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 8faae3d1455d..25b8f2234fc7 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -233,8 +233,6 @@ static int snd_hwdep_dsp_load(struct snd_hwdep *hw,
 	/* check whether the dsp was already loaded */
 	if (hw->dsp_loaded & (1 << info.index))
 		return -EBUSY;
-	if (!access_ok(VERIFY_READ, info.image, info.length))
-		return -EFAULT;
 	err = hw->ops.dsp_load(hw, &info);
 	if (err < 0)
 		return err;

commit 680ef72abd84cbe0b722453d6be4e412305c9060
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 2 23:27:36 2017 -0400

    sound: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 8faae3d1455d..cbda5c8b675f 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -177,7 +177,7 @@ static int snd_hwdep_release(struct inode *inode, struct file * file)
 	return err;
 }
 
-static unsigned int snd_hwdep_poll(struct file * file, poll_table * wait)
+static __poll_t snd_hwdep_poll(struct file * file, poll_table * wait)
 {
 	struct snd_hwdep *hw = file->private_data;
 	if (hw->ops.poll)

commit c4fd43793bdecb986bfc80e00c8792556c3f1c7f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 14 02:01:16 2017 +0300

    ALSA: hwdep: prevent a harmless shift wrapping bug
    
    The "info.index" variable represents a bit in hw->dsp_loaded which is
    an unsigned int.  If it's higher than 31 we hit a shift wrapping bug.
    This seems harmless, but I wanted to silence the static checker warning.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index a73baa1242be..8faae3d1455d 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -228,6 +228,8 @@ static int snd_hwdep_dsp_load(struct snd_hwdep *hw,
 	memset(&info, 0, sizeof(info));
 	if (copy_from_user(&info, _info, sizeof(info)))
 		return -EFAULT;
+	if (info.index >= 32)
+		return -EINVAL;
 	/* check whether the dsp was already loaded */
 	if (hw->dsp_loaded & (1 << info.index))
 		return -EBUSY;

commit ac6424b981bce1c4bc55675c6ce11bfe1bbfa64f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:06:13 2017 +0200

    sched/wait: Rename wait_queue_t => wait_queue_entry_t
    
    Rename:
    
            wait_queue_t            =>      wait_queue_entry_t
    
    'wait_queue_t' was always a slight misnomer: its name implies that it's a "queue",
    but in reality it's a queue *entry*. The 'real' queue is the wait queue head,
    which had to carry the name.
    
    Start sorting this out by renaming it to 'wait_queue_entry_t'.
    
    This also allows the real structure name 'struct __wait_queue' to
    lose its double underscore and become 'struct wait_queue_entry',
    which is the more canonical nomenclature for such data types.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 9602a7e38d8a..a73baa1242be 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -85,7 +85,7 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 	int major = imajor(inode);
 	struct snd_hwdep *hw;
 	int err;
-	wait_queue_t wait;
+	wait_queue_entry_t wait;
 
 	if (major == snd_major) {
 		hw = snd_lookup_minor_data(iminor(inode),

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 36d2416f90d9..9602a7e38d8a 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -25,6 +25,7 @@
 #include <linux/time.h>
 #include <linux/mutex.h>
 #include <linux/module.h>
+#include <linux/sched/signal.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/minors.h>

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 51692c8a39ea..36d2416f90d9 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -484,7 +484,7 @@ static int snd_hwdep_dev_disconnect(struct snd_device *device)
 	return 0;
 }
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /*
  *  Info interface
  */
@@ -521,10 +521,10 @@ static void __exit snd_hwdep_proc_done(void)
 {
 	snd_info_free_entry(snd_hwdep_proc_entry);
 }
-#else /* !CONFIG_PROC_FS */
+#else /* !CONFIG_SND_PROC_FS */
 #define snd_hwdep_proc_init()
 #define snd_hwdep_proc_done()
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */
 
 
 /*

commit ec0e9937aaa8b0a4b0633711c4d70d622acd9a7f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:42:14 2015 +0100

    ALSA: core: Drop superfluous error/debug messages after malloc failures
    
    The kernel memory allocators already report the errors when the
    requested allocation fails, thus we don't need to warn it again in
    each caller side.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 84244a5143cf..51692c8a39ea 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -378,10 +378,8 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 	if (rhwdep)
 		*rhwdep = NULL;
 	hwdep = kzalloc(sizeof(*hwdep), GFP_KERNEL);
-	if (hwdep == NULL) {
-		dev_err(card->dev, "hwdep: cannot allocate\n");
+	if (!hwdep)
 		return -ENOMEM;
-	}
 
 	init_waitqueue_head(&hwdep->open_wait);
 	mutex_init(&hwdep->open_mutex);

commit 40a4b263854346fe7c7d1c3964c106296f690816
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 30 08:34:58 2015 +0100

    ALSA: Simplify snd_device_register() variants
    
    Now that all callers have been replaced with
    snd_device_register_for_dev(), let's drop the obsolete device
    registration code and concentrate only on the code handling struct
    device directly.  That said,
    
    - remove the old snd_device_register(),
    - rename snd_device_register_for_dev() with snd_device_register(),
    - drop superfluous arguments from snd_device_register(),
    - change snd_unregister_device() to pass the device pointer directly
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 506387ba645d..84244a5143cf 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -432,10 +432,9 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		return -EBUSY;
 	}
 	list_add_tail(&hwdep->list, &snd_hwdep_devices);
-	err = snd_register_device_for_dev(SNDRV_DEVICE_TYPE_HWDEP,
-					  hwdep->card, hwdep->device,
-					  &snd_hwdep_f_ops, hwdep,
-					  &hwdep->dev, NULL, NULL);
+	err = snd_register_device(SNDRV_DEVICE_TYPE_HWDEP,
+				  hwdep->card, hwdep->device,
+				  &snd_hwdep_f_ops, hwdep, &hwdep->dev);
 	if (err < 0) {
 		dev_err(&hwdep->dev, "unable to register\n");
 		list_del(&hwdep->list);
@@ -480,7 +479,7 @@ static int snd_hwdep_dev_disconnect(struct snd_device *device)
 	if (hwdep->ossreg)
 		snd_unregister_oss_device(hwdep->oss_type, hwdep->card, hwdep->device);
 #endif
-	snd_unregister_device(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card, hwdep->device);
+	snd_unregister_device(&hwdep->dev);
 	list_del_init(&hwdep->list);
 	mutex_unlock(&hwdep->open_mutex);
 	mutex_unlock(&register_mutex);

commit 7b46160000197209f7ebca8b92bdbb75795c473f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 17:13:32 2015 +0100

    ALSA: hwdep: Embed struct device
    
    Like the previous patch, this one embeds the device object into hwdep
    object.  For a proper object lifecycle, it's freed in the release
    callback.
    
    This also allows us to create sysfs entries via passing to the groups
    field of the device without explicit function calls.  Since each
    driver can see the device and touch its groups field directly, we
    don't need to delegate in hwdep core any longer.  So, remove the
    groups field from snd_hwdep, and let the user (in this case only
    hda_hwdep.c) modify the device groups.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 85096a150eda..506387ba645d 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -38,7 +38,6 @@ MODULE_LICENSE("GPL");
 static LIST_HEAD(snd_hwdep_devices);
 static DEFINE_MUTEX(register_mutex);
 
-static int snd_hwdep_free(struct snd_hwdep *hwdep);
 static int snd_hwdep_dev_free(struct snd_device *device);
 static int snd_hwdep_dev_register(struct snd_device *device);
 static int snd_hwdep_dev_disconnect(struct snd_device *device);
@@ -345,6 +344,11 @@ static const struct file_operations snd_hwdep_f_ops =
 	.mmap =		snd_hwdep_mmap,
 };
 
+static void release_hwdep_device(struct device *dev)
+{
+	kfree(container_of(dev, struct snd_hwdep, dev));
+}
+
 /**
  * snd_hwdep_new - create a new hwdep instance
  * @card: the card instance
@@ -378,48 +382,49 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 		dev_err(card->dev, "hwdep: cannot allocate\n");
 		return -ENOMEM;
 	}
+
+	init_waitqueue_head(&hwdep->open_wait);
+	mutex_init(&hwdep->open_mutex);
 	hwdep->card = card;
 	hwdep->device = device;
 	if (id)
 		strlcpy(hwdep->id, id, sizeof(hwdep->id));
+
+	snd_device_initialize(&hwdep->dev, card);
+	hwdep->dev.release = release_hwdep_device;
+	dev_set_name(&hwdep->dev, "hwC%iD%i", card->number, device);
 #ifdef CONFIG_SND_OSSEMUL
 	hwdep->oss_type = -1;
 #endif
-	if ((err = snd_device_new(card, SNDRV_DEV_HWDEP, hwdep, &ops)) < 0) {
-		snd_hwdep_free(hwdep);
+
+	err = snd_device_new(card, SNDRV_DEV_HWDEP, hwdep, &ops);
+	if (err < 0) {
+		put_device(&hwdep->dev);
 		return err;
 	}
-	init_waitqueue_head(&hwdep->open_wait);
-	mutex_init(&hwdep->open_mutex);
+
 	if (rhwdep)
 		*rhwdep = hwdep;
 	return 0;
 }
 EXPORT_SYMBOL(snd_hwdep_new);
 
-static int snd_hwdep_free(struct snd_hwdep *hwdep)
+static int snd_hwdep_dev_free(struct snd_device *device)
 {
+	struct snd_hwdep *hwdep = device->device_data;
 	if (!hwdep)
 		return 0;
 	if (hwdep->private_free)
 		hwdep->private_free(hwdep);
-	kfree(hwdep);
+	put_device(&hwdep->dev);
 	return 0;
 }
 
-static int snd_hwdep_dev_free(struct snd_device *device)
-{
-	struct snd_hwdep *hwdep = device->device_data;
-	return snd_hwdep_free(hwdep);
-}
-
 static int snd_hwdep_dev_register(struct snd_device *device)
 {
 	struct snd_hwdep *hwdep = device->device_data;
 	struct snd_card *card = hwdep->card;
-	struct device *dev;
 	int err;
-	char name[32];
 
 	mutex_lock(&register_mutex);
 	if (snd_hwdep_search(card, hwdep->device)) {
@@ -427,54 +432,31 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		return -EBUSY;
 	}
 	list_add_tail(&hwdep->list, &snd_hwdep_devices);
-	sprintf(name, "hwC%iD%i", hwdep->card->number, hwdep->device);
-	dev = hwdep->dev;
-	if (!dev)
-		dev = snd_card_get_device_link(hwdep->card);
 	err = snd_register_device_for_dev(SNDRV_DEVICE_TYPE_HWDEP,
 					  hwdep->card, hwdep->device,
 					  &snd_hwdep_f_ops, hwdep,
-					  NULL, dev, name);
+					  &hwdep->dev, NULL, NULL);
 	if (err < 0) {
-		dev_err(dev,
-			"unable to register hardware dependent device %i:%i\n",
-			card->number, hwdep->device);
+		dev_err(&hwdep->dev, "unable to register\n");
 		list_del(&hwdep->list);
 		mutex_unlock(&register_mutex);
 		return err;
 	}
 
-	if (hwdep->groups) {
-		struct device *d = snd_get_device(SNDRV_DEVICE_TYPE_HWDEP,
-						  hwdep->card, hwdep->device);
-		if (d) {
-			if (hwdep->private_data)
-				dev_set_drvdata(d, hwdep->private_data);
-			err = sysfs_create_groups(&d->kobj, hwdep->groups);
-			if (err < 0)
-				dev_warn(dev,
-					 "hwdep %d:%d: cannot create sysfs groups\n",
-					 card->number, hwdep->device);
-			put_device(d);
-		}
-	}
-
 #ifdef CONFIG_SND_OSSEMUL
 	hwdep->ossreg = 0;
 	if (hwdep->oss_type >= 0) {
-		if ((hwdep->oss_type == SNDRV_OSS_DEVICE_TYPE_DMFM) && (hwdep->device != 0)) {
-			dev_warn(dev,
+		if (hwdep->oss_type == SNDRV_OSS_DEVICE_TYPE_DMFM &&
+		    hwdep->device)
+			dev_warn(&hwdep->dev,
 				 "only hwdep device 0 can be registered as OSS direct FM device!\n");
-		} else {
-			if (snd_register_oss_device(hwdep->oss_type,
-						    card, hwdep->device,
-						    &snd_hwdep_f_ops, hwdep) < 0) {
-				dev_err(dev,
-					"unable to register OSS compatibility device %i:%i\n",
-					card->number, hwdep->device);
-			} else
-				hwdep->ossreg = 1;
-		}
+		else if (snd_register_oss_device(hwdep->oss_type,
+						 card, hwdep->device,
+						 &snd_hwdep_f_ops, hwdep) < 0)
+			dev_warn(&hwdep->dev,
+				 "unable to register OSS compatibility device\n");
+		else
+			hwdep->ossreg = 1;
 	}
 #endif
 	mutex_unlock(&register_mutex);

commit 92b7952da8279189aad352efbf9f2e7001de9524
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 15:53:51 2015 +0100

    ALSA: Allow to pass the device object to snd_register_device*()
    
    This is a preliminary patch for the further work on embedding struct
    device into each sound device instance.  It changes
    snd_register_device*() helpers to receive the device object directly
    for skipping creating a device there.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 69459e5f712e..85096a150eda 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -433,7 +433,8 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		dev = snd_card_get_device_link(hwdep->card);
 	err = snd_register_device_for_dev(SNDRV_DEVICE_TYPE_HWDEP,
 					  hwdep->card, hwdep->device,
-					  &snd_hwdep_f_ops, hwdep, name, dev);
+					  &snd_hwdep_f_ops, hwdep,
+					  NULL, dev, name);
 	if (err < 0) {
 		dev_err(dev,
 			"unable to register hardware dependent device %i:%i\n",

commit 6776a5d712a1e670e9cf31c6693480d4d9b30e33
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 27 16:00:17 2014 +0100

    ALSA: Move EXPORT_SYMBOL() in appropriate places
    
    Just a cleanup to follow the standard coding style.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index d6eb3ef3e3c7..69459e5f712e 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -395,6 +395,7 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 		*rhwdep = hwdep;
 	return 0;
 }
+EXPORT_SYMBOL(snd_hwdep_new);
 
 static int snd_hwdep_free(struct snd_hwdep *hwdep)
 {
@@ -567,5 +568,3 @@ static void __exit alsa_hwdep_exit(void)
 
 module_init(alsa_hwdep_init)
 module_exit(alsa_hwdep_exit)
-
-EXPORT_SYMBOL(snd_hwdep_new);

commit 71e2e1c147e653ee4e861b8b5dc0ae5c394870d2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 08:05:21 2014 +0100

    ALSA: hwdep: Allow to assign the given parent
    
    Just like PCM, allow hwdep to be assigned to a different parent device
    than the card.  It'll be used for the HD-audio codec device in the
    later patches.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 825cd2847940..d6eb3ef3e3c7 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -416,6 +416,7 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 {
 	struct snd_hwdep *hwdep = device->device_data;
 	struct snd_card *card = hwdep->card;
+	struct device *dev;
 	int err;
 	char name[32];
 
@@ -426,10 +427,14 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 	}
 	list_add_tail(&hwdep->list, &snd_hwdep_devices);
 	sprintf(name, "hwC%iD%i", hwdep->card->number, hwdep->device);
-	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_HWDEP,
-				       hwdep->card, hwdep->device,
-				       &snd_hwdep_f_ops, hwdep, name)) < 0) {
-		dev_err(card->dev,
+	dev = hwdep->dev;
+	if (!dev)
+		dev = snd_card_get_device_link(hwdep->card);
+	err = snd_register_device_for_dev(SNDRV_DEVICE_TYPE_HWDEP,
+					  hwdep->card, hwdep->device,
+					  &snd_hwdep_f_ops, hwdep, name, dev);
+	if (err < 0) {
+		dev_err(dev,
 			"unable to register hardware dependent device %i:%i\n",
 			card->number, hwdep->device);
 		list_del(&hwdep->list);
@@ -445,7 +450,7 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 				dev_set_drvdata(d, hwdep->private_data);
 			err = sysfs_create_groups(&d->kobj, hwdep->groups);
 			if (err < 0)
-				dev_warn(card->dev,
+				dev_warn(dev,
 					 "hwdep %d:%d: cannot create sysfs groups\n",
 					 card->number, hwdep->device);
 			put_device(d);
@@ -456,13 +461,13 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 	hwdep->ossreg = 0;
 	if (hwdep->oss_type >= 0) {
 		if ((hwdep->oss_type == SNDRV_OSS_DEVICE_TYPE_DMFM) && (hwdep->device != 0)) {
-			dev_warn(card->dev,
+			dev_warn(dev,
 				 "only hwdep device 0 can be registered as OSS direct FM device!\n");
 		} else {
 			if (snd_register_oss_device(hwdep->oss_type,
 						    card, hwdep->device,
 						    &snd_hwdep_f_ops, hwdep) < 0) {
-				dev_err(card->dev,
+				dev_err(dev,
 					"unable to register OSS compatibility device %i:%i\n",
 					card->number, hwdep->device);
 			} else

commit f806bdb2f7235907fcd310e6d147b3bcd281fa97
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 10:00:58 2014 +0100

    ALSA: hwdep: Take private_data as drvdata for sysfs
    
    For referring to a different object from sysfs ops, take hwdep
    private_data as stored via dev_set_drvdata() at creating the device
    object.  In that way, the same sysfs ops can be used by different
    device types.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 99f7e8515ba1..825cd2847940 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -441,6 +441,8 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		struct device *d = snd_get_device(SNDRV_DEVICE_TYPE_HWDEP,
 						  hwdep->card, hwdep->device);
 		if (d) {
+			if (hwdep->private_data)
+				dev_set_drvdata(d, hwdep->private_data);
 			err = sysfs_create_groups(&d->kobj, hwdep->groups);
 			if (err < 0)
 				dev_warn(card->dev,

commit caa751bad444268d756b48ca03d7cceda3430cc8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 08:30:50 2014 +0100

    ALSA: Create sysfs attribute files via groups
    
    Instead of calling each time device_create_file(), create the groups
    of sysfs attribute files at once in a normal way.  Add a new helper
    function, snd_get_device(), to return the associated device object,
    so that we can handle the sysfs addition locally.
    
    Since the sysfs file addition is done differently now,
    snd_add_device_sysfs_file() helper function is removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 8c778659fa03..99f7e8515ba1 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -436,6 +436,20 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		mutex_unlock(&register_mutex);
 		return err;
 	}
+
+	if (hwdep->groups) {
+		struct device *d = snd_get_device(SNDRV_DEVICE_TYPE_HWDEP,
+						  hwdep->card, hwdep->device);
+		if (d) {
+			err = sysfs_create_groups(&d->kobj, hwdep->groups);
+			if (err < 0)
+				dev_warn(card->dev,
+					 "hwdep %d:%d: cannot create sysfs groups\n",
+					 card->number, hwdep->device);
+			put_device(d);
+		}
+	}
+
 #ifdef CONFIG_SND_OSSEMUL
 	hwdep->ossreg = 0;
 	if (hwdep->oss_type >= 0) {

commit 2ebef69fc5a69ff8ef04922020d8ceeb4f6c8fbb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:21:54 2014 +0100

    ALSA: hwdep: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 0f73f6951110..8c778659fa03 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -375,7 +375,7 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 		*rhwdep = NULL;
 	hwdep = kzalloc(sizeof(*hwdep), GFP_KERNEL);
 	if (hwdep == NULL) {
-		snd_printk(KERN_ERR "hwdep: cannot allocate\n");
+		dev_err(card->dev, "hwdep: cannot allocate\n");
 		return -ENOMEM;
 	}
 	hwdep->card = card;
@@ -415,11 +415,12 @@ static int snd_hwdep_dev_free(struct snd_device *device)
 static int snd_hwdep_dev_register(struct snd_device *device)
 {
 	struct snd_hwdep *hwdep = device->device_data;
+	struct snd_card *card = hwdep->card;
 	int err;
 	char name[32];
 
 	mutex_lock(&register_mutex);
-	if (snd_hwdep_search(hwdep->card, hwdep->device)) {
+	if (snd_hwdep_search(card, hwdep->device)) {
 		mutex_unlock(&register_mutex);
 		return -EBUSY;
 	}
@@ -428,8 +429,9 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_HWDEP,
 				       hwdep->card, hwdep->device,
 				       &snd_hwdep_f_ops, hwdep, name)) < 0) {
-		snd_printk(KERN_ERR "unable to register hardware dependent device %i:%i\n",
-			   hwdep->card->number, hwdep->device);
+		dev_err(card->dev,
+			"unable to register hardware dependent device %i:%i\n",
+			card->number, hwdep->device);
 		list_del(&hwdep->list);
 		mutex_unlock(&register_mutex);
 		return err;
@@ -438,13 +440,15 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 	hwdep->ossreg = 0;
 	if (hwdep->oss_type >= 0) {
 		if ((hwdep->oss_type == SNDRV_OSS_DEVICE_TYPE_DMFM) && (hwdep->device != 0)) {
-			snd_printk (KERN_WARNING "only hwdep device 0 can be registered as OSS direct FM device!\n");
+			dev_warn(card->dev,
+				 "only hwdep device 0 can be registered as OSS direct FM device!\n");
 		} else {
 			if (snd_register_oss_device(hwdep->oss_type,
-						    hwdep->card, hwdep->device,
+						    card, hwdep->device,
 						    &snd_hwdep_f_ops, hwdep) < 0) {
-				snd_printk(KERN_ERR "unable to register OSS compatibility device %i:%i\n",
-					   hwdep->card->number, hwdep->device);
+				dev_err(card->dev,
+					"unable to register OSS compatibility device %i:%i\n",
+					card->number, hwdep->device);
 			} else
 				hwdep->ossreg = 1;
 		}

commit 80d7d771ae839d6fc2286f443ad8445b6721a7f3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 13:51:45 2014 +0100

    ALSA: Drop unused name argument in snd_register_oss_device()
    
    The last argument, name, of snd_oss_register_device() is nowhere
    referred in the function in the current code.  Let's drop it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index d105073298cb..0f73f6951110 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -442,8 +442,7 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		} else {
 			if (snd_register_oss_device(hwdep->oss_type,
 						    hwdep->card, hwdep->device,
-						    &snd_hwdep_f_ops, hwdep,
-						    hwdep->oss_dev) < 0) {
+						    &snd_hwdep_f_ops, hwdep) < 0) {
 				snd_printk(KERN_ERR "unable to register OSS compatibility device %i:%i\n",
 					   hwdep->card->number, hwdep->device);
 			} else

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 3f7f6628cf7b..d105073298cb 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -356,7 +356,7 @@ static const struct file_operations snd_hwdep_f_ops =
  * The callbacks (hwdep->ops) must be set on the returned instance
  * after this call manually by the caller.
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_hwdep_new(struct snd_card *card, char *id, int device,
 		  struct snd_hwdep **rhwdep)

commit 0914f7961babbf28aaa2f19b453951fb4841c03f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 16 16:43:39 2012 +0200

    ALSA: Avoid endless sleep after disconnect
    
    When disconnect callback is called, each component should wake up
    sleepers and check card->shutdown flag for avoiding the endless sleep
    blocking the proper resource release.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 53a6ba5ad615..3f7f6628cf7b 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -131,6 +131,10 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 		mutex_unlock(&hw->open_mutex);
 		schedule();
 		mutex_lock(&hw->open_mutex);
+		if (hw->card->shutdown) {
+			err = -ENODEV;
+			break;
+		}
 		if (signal_pending(current)) {
 			err = -ERESTARTSYS;
 			break;
@@ -462,12 +466,15 @@ static int snd_hwdep_dev_disconnect(struct snd_device *device)
 		mutex_unlock(&register_mutex);
 		return -EINVAL;
 	}
+	mutex_lock(&hwdep->open_mutex);
+	wake_up(&hwdep->open_wait);
 #ifdef CONFIG_SND_OSSEMUL
 	if (hwdep->ossreg)
 		snd_unregister_oss_device(hwdep->oss_type, hwdep->card, hwdep->device);
 #endif
 	snd_unregister_device(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card, hwdep->device);
 	list_del_init(&hwdep->list);
+	mutex_unlock(&hwdep->open_mutex);
 	mutex_unlock(&register_mutex);
 	return 0;
 }

commit a0830dbd4e42b38aefdf3fb61ba5019a1a99ea85
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 16 13:05:59 2012 +0200

    ALSA: Add a reference counter to card instance
    
    For more strict protection for wild disconnections, a refcount is
    introduced to the card instance, and let it up/down when an object is
    referred via snd_lookup_*() in the open ops.
    
    The free-after-last-close check is also changed to check this refcount
    instead of the empty list, too.
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 75ea16f35b1a..53a6ba5ad615 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -100,8 +100,10 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 	if (hw == NULL)
 		return -ENODEV;
 
-	if (!try_module_get(hw->card->module))
+	if (!try_module_get(hw->card->module)) {
+		snd_card_unref(hw->card);
 		return -EFAULT;
+	}
 
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(&hw->open_wait, &wait);
@@ -148,6 +150,7 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 	mutex_unlock(&hw->open_mutex);
 	if (err < 0)
 		module_put(hw->card->module);
+	snd_card_unref(hw->card);
 	return err;
 }
 

commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb
Merge: 208bca086040 67b84999b1a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 19:44:47 2011 -0800

    Merge branch 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    * 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux: (230 commits)
      Revert "tracing: Include module.h in define_trace.h"
      irq: don't put module.h into irq.h for tracking irqgen modules.
      bluetooth: macroize two small inlines to avoid module.h
      ip_vs.h: fix implicit use of module_get/module_put from module.h
      nf_conntrack.h: fix up fallout from implicit moduleparam.h presence
      include: replace linux/module.h with "struct module" wherever possible
      include: convert various register fcns to macros to avoid include chaining
      crypto.h: remove unused crypto_tfm_alg_modname() inline
      uwb.h: fix implicit use of asm/page.h for PAGE_SIZE
      pm_runtime.h: explicitly requires notifier.h
      linux/dmaengine.h: fix implicit use of bitmap.h and asm/page.h
      miscdevice.h: fix up implicit use of lists and types
      stop_machine.h: fix implicit use of smp.h for smp_processor_id
      of: fix implicit use of errno.h in include/linux/of.h
      of_platform.h: delete needless include <linux/module.h>
      acpi: remove module.h include from platform/aclinux.h
      miscdevice.h: delete unnecessary inclusion of module.h
      device_cgroup.h: delete needless include <linux/module.h>
      net: sch_generic remove redundant use of <linux/module.h>
      net: inet_timewait_sock doesnt need <linux/module.h>
      ...
    
    Fix up trivial conflicts (other header files, and  removal of the ab3550 mfd driver) in
     - drivers/media/dvb/frontends/dibx000_common.c
     - drivers/media/video/{mt9m111.c,ov6650.c}
     - drivers/mfd/ab3550-core.c
     - include/linux/dmaengine.h

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index a70ee7f1ed98..c7ceb28d885d 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -24,6 +24,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/mutex.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/minors.h>

commit f7b2bb8549e352353427d0f8913c96914dd0baab
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Oct 28 09:46:01 2011 +0300

    ALSA: hwdep: silence integer overflow warning
    
    Smatch complains that if device is INT_MAX then device + 1 can
    overflow.  It just means we would have an annoying loop while we
    check all the devices from -2147483648 to SNDRV_MINOR_HWDEPS.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index a70ee7f1ed98..031e215b6dde 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -272,7 +272,14 @@ static int snd_hwdep_control_ioctl(struct snd_card *card,
 			if (get_user(device, (int __user *)arg))
 				return -EFAULT;
 			mutex_lock(&register_mutex);
-			device = device < 0 ? 0 : device + 1;
+
+			if (device < 0)
+				device = 0;
+			else if (device < SNDRV_MINOR_HWDEPS)
+				device++;
+			else
+				device = SNDRV_MINOR_HWDEPS;
+
 			while (device < SNDRV_MINOR_HWDEPS) {
 				if (snd_hwdep_search(card, device))
 					break;

commit 345d0b1964df83a6c3fff815fabd34e37265581f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 09:10:20 2009 +0100

    ALSA: hwdep - Make open callback optional
    
    Don't require the open callback as mandatory.
    Now all hwdeps ops can be optional.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 195cafc5a553..a70ee7f1ed98 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -99,9 +99,6 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 	if (hw == NULL)
 		return -ENODEV;
 
-	if (!hw->ops.open)
-		return -ENXIO;
-
 	if (!try_module_get(hw->card->module))
 		return -EFAULT;
 
@@ -113,6 +110,10 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 			err = -EBUSY;
 			break;
 		}
+		if (!hw->ops.open) {
+			err = 0;
+			break;
+		}
 		err = hw->ops.open(hw, file);
 		if (err >= 0)
 			break;
@@ -151,7 +152,7 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 
 static int snd_hwdep_release(struct inode *inode, struct file * file)
 {
-	int err = -ENXIO;
+	int err = 0;
 	struct snd_hwdep *hw = file->private_data;
 	struct module *mod = hw->card->module;
 

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 6d6589f93899..195cafc5a553 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -353,9 +353,10 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 		.dev_disconnect = snd_hwdep_dev_disconnect,
 	};
 
-	snd_assert(rhwdep != NULL, return -EINVAL);
-	*rhwdep = NULL;
-	snd_assert(card != NULL, return -ENXIO);
+	if (snd_BUG_ON(!card))
+		return -ENXIO;
+	if (rhwdep)
+		*rhwdep = NULL;
 	hwdep = kzalloc(sizeof(*hwdep), GFP_KERNEL);
 	if (hwdep == NULL) {
 		snd_printk(KERN_ERR "hwdep: cannot allocate\n");
@@ -374,13 +375,15 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 	}
 	init_waitqueue_head(&hwdep->open_wait);
 	mutex_init(&hwdep->open_mutex);
-	*rhwdep = hwdep;
+	if (rhwdep)
+		*rhwdep = hwdep;
 	return 0;
 }
 
 static int snd_hwdep_free(struct snd_hwdep *hwdep)
 {
-	snd_assert(hwdep != NULL, return -ENXIO);
+	if (!hwdep)
+		return 0;
 	if (hwdep->private_free)
 		hwdep->private_free(hwdep);
 	kfree(hwdep);
@@ -440,7 +443,8 @@ static int snd_hwdep_dev_disconnect(struct snd_device *device)
 {
 	struct snd_hwdep *hwdep = device->device_data;
 
-	snd_assert(hwdep != NULL, return -ENXIO);
+	if (snd_BUG_ON(!hwdep))
+		return -ENXIO;
 	mutex_lock(&register_mutex);
 	if (snd_hwdep_search(hwdep->card, hwdep->device) != hwdep) {
 		mutex_unlock(&register_mutex);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index bfd9d182b8a3..6d6589f93899 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/major.h>
 #include <linux/init.h>
 #include <linux/slab.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 51ad95b7c894..bfd9d182b8a3 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -1,6 +1,6 @@
 /*
  *  Hardware dependent layer
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -31,7 +31,7 @@
 #include <sound/hwdep.h>
 #include <sound/info.h>
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("Hardware dependent layer");
 MODULE_LICENSE("GPL");
 

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 96ffdf18c3fe..51ad95b7c894 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -22,7 +22,6 @@
 #include <sound/driver.h>
 #include <linux/major.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/mutex.h>

commit 9c2e08c592cd357a8330c34def1e8ecfdcf53275
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:37 2007 -0800

    [PATCH] mark struct file_operations const 9
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 39c03f3dfbfa..96ffdf18c3fe 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -317,7 +317,7 @@ static int snd_hwdep_control_ioctl(struct snd_card *card,
 
  */
 
-static struct file_operations snd_hwdep_f_ops =
+static const struct file_operations snd_hwdep_f_ops =
 {
 	.owner = 	THIS_MODULE,
 	.llseek =	snd_hwdep_llseek,

commit 8fa58af7db56077d6a042fd7b9dd4c9515e1c37b
Author: Karsten Wiese <fzu@wemgehoertderstaat.de>
Date:   Wed Jan 31 10:05:30 2007 +0100

    [ALSA] snd_hwdep_release() racefix
    
    snd_card_file_remove() can free the snd_card.
    Touch hw->* only before calling snd_card_file_remove().
    Unrelated: Allow hwdep devices not to have own ops.release();
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index a6a6ad0ad3c8..39c03f3dfbfa 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -156,15 +156,16 @@ static int snd_hwdep_release(struct inode *inode, struct file * file)
 	int err = -ENXIO;
 	struct snd_hwdep *hw = file->private_data;
 	struct module *mod = hw->card->module;
+
 	mutex_lock(&hw->open_mutex);
-	if (hw->ops.release) {
+	if (hw->ops.release)
 		err = hw->ops.release(hw, file);
-		wake_up(&hw->open_wait);
-	}
 	if (hw->used > 0)
 		hw->used--;
-	snd_card_file_remove(hw->card, file);
 	mutex_unlock(&hw->open_mutex);
+	wake_up(&hw->open_wait);
+
+	snd_card_file_remove(hw->card, file);
 	module_put(mod);
 	return err;
 }

commit 9244b2c3079faac79b3b961116bd548c45087e2c
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 5 16:02:22 2006 +0200

    [ALSA] alsa core: convert to list_for_each_entry*
    
    This patch converts most uses of list_for_each to list_for_each_entry all
    across alsa. In some place apparently an item can be on a list with
    different pointers so of course that isn't compatible with list_for_each, I
    therefore didn't touch those places.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 46b47689362c..a6a6ad0ad3c8 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -47,14 +47,11 @@ static int snd_hwdep_dev_disconnect(struct snd_device *device);
 
 static struct snd_hwdep *snd_hwdep_search(struct snd_card *card, int device)
 {
-	struct list_head *p;
 	struct snd_hwdep *hwdep;
 
-	list_for_each(p, &snd_hwdep_devices) {
-		hwdep = list_entry(p, struct snd_hwdep, list);
+	list_for_each_entry(hwdep, &snd_hwdep_devices, list)
 		if (hwdep->card == card && hwdep->device == device)
 			return hwdep;
-	}
 	return NULL;
 }
 
@@ -468,15 +465,12 @@ static int snd_hwdep_dev_disconnect(struct snd_device *device)
 static void snd_hwdep_proc_read(struct snd_info_entry *entry,
 				struct snd_info_buffer *buffer)
 {
-	struct list_head *p;
 	struct snd_hwdep *hwdep;
 
 	mutex_lock(&register_mutex);
-	list_for_each(p, &snd_hwdep_devices) {
-		hwdep = list_entry(p, struct snd_hwdep, list);
+	list_for_each_entry(hwdep, &snd_hwdep_devices, list)
 		snd_iprintf(buffer, "%02i-%02i: %s\n",
 			    hwdep->card->number, hwdep->device, hwdep->name);
-	}
 	mutex_unlock(&register_mutex);
 }
 

commit 104326f8df9925317cca64b84249d3eac5de7c74
Author: Florin Malita <fmalita@gmail.com>
Date:   Fri Sep 29 12:55:25 2006 +0200

    [ALSA] Dereference after free in snd_hwdep_release()
    
    snd_card_file_remove() may free hw->card so we can't dereference
    hw->card->module after that.
    Coverity ID 1420.
    
    Signed-off-by: Florin Malita <fmalita@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 9aa9d94891f0..46b47689362c 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -158,6 +158,7 @@ static int snd_hwdep_release(struct inode *inode, struct file * file)
 {
 	int err = -ENXIO;
 	struct snd_hwdep *hw = file->private_data;
+	struct module *mod = hw->card->module;
 	mutex_lock(&hw->open_mutex);
 	if (hw->ops.release) {
 		err = hw->ops.release(hw, file);
@@ -167,7 +168,7 @@ static int snd_hwdep_release(struct inode *inode, struct file * file)
 		hw->used--;
 	snd_card_file_remove(hw->card, file);
 	mutex_unlock(&hw->open_mutex);
-	module_put(hw->card->module);
+	module_put(mod);
 	return err;
 }
 

commit c461482c8072bb073e6146db320d3da85cdc89ad
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:38:23 2006 +0200

    [ALSA] Unregister device files at disconnection
    
    Orignally proposed by Sam Revitch <sam.revitch@gmail.com>.
    Unregister device files at disconnection to avoid the futher accesses.
    Also, the dev_unregister callback is removed and replaced with the
    combination of disconnect + free.
    A new function snd_card_free_when_closed() is introduced, which is
    used in USB disconnect callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index cbd8a63282b6..9aa9d94891f0 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -42,7 +42,7 @@ static DEFINE_MUTEX(register_mutex);
 static int snd_hwdep_free(struct snd_hwdep *hwdep);
 static int snd_hwdep_dev_free(struct snd_device *device);
 static int snd_hwdep_dev_register(struct snd_device *device);
-static int snd_hwdep_dev_unregister(struct snd_device *device);
+static int snd_hwdep_dev_disconnect(struct snd_device *device);
 
 
 static struct snd_hwdep *snd_hwdep_search(struct snd_card *card, int device)
@@ -353,7 +353,7 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 	static struct snd_device_ops ops = {
 		.dev_free = snd_hwdep_dev_free,
 		.dev_register = snd_hwdep_dev_register,
-		.dev_unregister = snd_hwdep_dev_unregister
+		.dev_disconnect = snd_hwdep_dev_disconnect,
 	};
 
 	snd_assert(rhwdep != NULL, return -EINVAL);
@@ -439,7 +439,7 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 	return 0;
 }
 
-static int snd_hwdep_dev_unregister(struct snd_device *device)
+static int snd_hwdep_dev_disconnect(struct snd_device *device)
 {
 	struct snd_hwdep *hwdep = device->device_data;
 
@@ -454,9 +454,9 @@ static int snd_hwdep_dev_unregister(struct snd_device *device)
 		snd_unregister_oss_device(hwdep->oss_type, hwdep->card, hwdep->device);
 #endif
 	snd_unregister_device(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card, hwdep->device);
-	list_del(&hwdep->list);
+	list_del_init(&hwdep->list);
 	mutex_unlock(&register_mutex);
-	return snd_hwdep_free(hwdep);
+	return 0;
 }
 
 #ifdef CONFIG_PROC_FS

commit 746d4a02e68499fc6c1f8d0c43d2271853ade181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:37:59 2006 +0200

    [ALSA] Fix disconnection of proc interface
    
    - Add the linked list to each proc entry to enable a single-shot
      disconnection (unregister)
    - Deprecate snd_info_unregister(), use snd_info_free_entry()
    - Removed NULL checks of snd_info_free_entry()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 8bd0dcc93eba..cbd8a63282b6 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -497,7 +497,7 @@ static void __init snd_hwdep_proc_init(void)
 
 static void __exit snd_hwdep_proc_done(void)
 {
-	snd_info_unregister(snd_hwdep_proc_entry);
+	snd_info_free_entry(snd_hwdep_proc_entry);
 }
 #else /* !CONFIG_PROC_FS */
 #define snd_hwdep_proc_init()

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 2524e66eccdd..8bd0dcc93eba 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -486,7 +486,6 @@ static void __init snd_hwdep_proc_init(void)
 	struct snd_info_entry *entry;
 
 	if ((entry = snd_info_create_module_entry(THIS_MODULE, "hwdep", NULL)) != NULL) {
-		entry->c.text.read_size = PAGE_SIZE;
 		entry->c.text.read = snd_hwdep_proc_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 618c43be0bc3..2524e66eccdd 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -25,6 +25,7 @@
 #include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/mutex.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/minors.h>
@@ -36,7 +37,7 @@ MODULE_DESCRIPTION("Hardware dependent layer");
 MODULE_LICENSE("GPL");
 
 static LIST_HEAD(snd_hwdep_devices);
-static DECLARE_MUTEX(register_mutex);
+static DEFINE_MUTEX(register_mutex);
 
 static int snd_hwdep_free(struct snd_hwdep *hwdep);
 static int snd_hwdep_dev_free(struct snd_device *device);
@@ -111,7 +112,7 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(&hw->open_wait, &wait);
-	down(&hw->open_mutex);
+	mutex_lock(&hw->open_mutex);
 	while (1) {
 		if (hw->exclusive && hw->used > 0) {
 			err = -EBUSY;
@@ -128,9 +129,9 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 		} else
 			break;
 		set_current_state(TASK_INTERRUPTIBLE);
-		up(&hw->open_mutex);
+		mutex_unlock(&hw->open_mutex);
 		schedule();
-		down(&hw->open_mutex);
+		mutex_lock(&hw->open_mutex);
 		if (signal_pending(current)) {
 			err = -ERESTARTSYS;
 			break;
@@ -147,7 +148,7 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 				hw->ops.release(hw, file);
 		}
 	}
-	up(&hw->open_mutex);
+	mutex_unlock(&hw->open_mutex);
 	if (err < 0)
 		module_put(hw->card->module);
 	return err;
@@ -157,7 +158,7 @@ static int snd_hwdep_release(struct inode *inode, struct file * file)
 {
 	int err = -ENXIO;
 	struct snd_hwdep *hw = file->private_data;
-	down(&hw->open_mutex);
+	mutex_lock(&hw->open_mutex);
 	if (hw->ops.release) {
 		err = hw->ops.release(hw, file);
 		wake_up(&hw->open_wait);
@@ -165,7 +166,7 @@ static int snd_hwdep_release(struct inode *inode, struct file * file)
 	if (hw->used > 0)
 		hw->used--;
 	snd_card_file_remove(hw->card, file);
-	up(&hw->open_mutex);
+	mutex_unlock(&hw->open_mutex);
 	module_put(hw->card->module);
 	return err;
 }
@@ -272,7 +273,7 @@ static int snd_hwdep_control_ioctl(struct snd_card *card,
 
 			if (get_user(device, (int __user *)arg))
 				return -EFAULT;
-			down(&register_mutex);
+			mutex_lock(&register_mutex);
 			device = device < 0 ? 0 : device + 1;
 			while (device < SNDRV_MINOR_HWDEPS) {
 				if (snd_hwdep_search(card, device))
@@ -281,7 +282,7 @@ static int snd_hwdep_control_ioctl(struct snd_card *card,
 			}
 			if (device >= SNDRV_MINOR_HWDEPS)
 				device = -1;
-			up(&register_mutex);
+			mutex_unlock(&register_mutex);
 			if (put_user(device, (int __user *)arg))
 				return -EFAULT;
 			return 0;
@@ -294,13 +295,13 @@ static int snd_hwdep_control_ioctl(struct snd_card *card,
 
 			if (get_user(device, &info->device))
 				return -EFAULT;
-			down(&register_mutex);
+			mutex_lock(&register_mutex);
 			hwdep = snd_hwdep_search(card, device);
 			if (hwdep)
 				err = snd_hwdep_info(hwdep, info);
 			else
 				err = -ENXIO;
-			up(&register_mutex);
+			mutex_unlock(&register_mutex);
 			return err;
 		}
 	}
@@ -375,7 +376,7 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 		return err;
 	}
 	init_waitqueue_head(&hwdep->open_wait);
-	init_MUTEX(&hwdep->open_mutex);
+	mutex_init(&hwdep->open_mutex);
 	*rhwdep = hwdep;
 	return 0;
 }
@@ -401,9 +402,9 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 	int err;
 	char name[32];
 
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	if (snd_hwdep_search(hwdep->card, hwdep->device)) {
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		return -EBUSY;
 	}
 	list_add_tail(&hwdep->list, &snd_hwdep_devices);
@@ -414,7 +415,7 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		snd_printk(KERN_ERR "unable to register hardware dependent device %i:%i\n",
 			   hwdep->card->number, hwdep->device);
 		list_del(&hwdep->list);
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		return err;
 	}
 #ifdef CONFIG_SND_OSSEMUL
@@ -434,7 +435,7 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		}
 	}
 #endif
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return 0;
 }
 
@@ -443,9 +444,9 @@ static int snd_hwdep_dev_unregister(struct snd_device *device)
 	struct snd_hwdep *hwdep = device->device_data;
 
 	snd_assert(hwdep != NULL, return -ENXIO);
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	if (snd_hwdep_search(hwdep->card, hwdep->device) != hwdep) {
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		return -EINVAL;
 	}
 #ifdef CONFIG_SND_OSSEMUL
@@ -454,7 +455,7 @@ static int snd_hwdep_dev_unregister(struct snd_device *device)
 #endif
 	snd_unregister_device(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card, hwdep->device);
 	list_del(&hwdep->list);
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return snd_hwdep_free(hwdep);
 }
 
@@ -469,13 +470,13 @@ static void snd_hwdep_proc_read(struct snd_info_entry *entry,
 	struct list_head *p;
 	struct snd_hwdep *hwdep;
 
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	list_for_each(p, &snd_hwdep_devices) {
 		hwdep = list_entry(p, struct snd_hwdep, list);
 		snd_iprintf(buffer, "%02i-%02i: %s\n",
 			    hwdep->card->number, hwdep->device, hwdep->name);
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 }
 
 static struct snd_info_entry *snd_hwdep_proc_entry;

commit e28563cceb9f258ebe3c50fc27d8f4ff0ac4bfa4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:42:42 2005 +0100

    [ALSA] Optimize for config without PROC_FS
    
    Modules: HWDEP Midlevel,ALSA Core,PCM Midlevel,Timer Midlevel
    
    Optimize the code when compiled without CONFIG_PROC_FS.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index b8c0c8c4d126..618c43be0bc3 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -458,6 +458,7 @@ static int snd_hwdep_dev_unregister(struct snd_device *device)
 	return snd_hwdep_free(hwdep);
 }
 
+#ifdef CONFIG_PROC_FS
 /*
  *  Info interface
  */
@@ -477,13 +478,9 @@ static void snd_hwdep_proc_read(struct snd_info_entry *entry,
 	up(&register_mutex);
 }
 
-/*
- *  ENTRY functions
- */
+static struct snd_info_entry *snd_hwdep_proc_entry;
 
-static struct snd_info_entry *snd_hwdep_proc_entry = NULL;
-
-static int __init alsa_hwdep_init(void)
+static void __init snd_hwdep_proc_init(void)
 {
 	struct snd_info_entry *entry;
 
@@ -496,6 +493,25 @@ static int __init alsa_hwdep_init(void)
 		}
 	}
 	snd_hwdep_proc_entry = entry;
+}
+
+static void __exit snd_hwdep_proc_done(void)
+{
+	snd_info_unregister(snd_hwdep_proc_entry);
+}
+#else /* !CONFIG_PROC_FS */
+#define snd_hwdep_proc_init()
+#define snd_hwdep_proc_done()
+#endif /* CONFIG_PROC_FS */
+
+
+/*
+ *  ENTRY functions
+ */
+
+static int __init alsa_hwdep_init(void)
+{
+	snd_hwdep_proc_init();
 	snd_ctl_register_ioctl(snd_hwdep_control_ioctl);
 	snd_ctl_register_ioctl_compat(snd_hwdep_control_ioctl);
 	return 0;
@@ -505,10 +521,7 @@ static void __exit alsa_hwdep_exit(void)
 {
 	snd_ctl_unregister_ioctl(snd_hwdep_control_ioctl);
 	snd_ctl_unregister_ioctl_compat(snd_hwdep_control_ioctl);
-	if (snd_hwdep_proc_entry) {
-		snd_info_unregister(snd_hwdep_proc_entry);
-		snd_hwdep_proc_entry = NULL;
-	}
+	snd_hwdep_proc_done();
 }
 
 module_init(alsa_hwdep_init)

commit f87135f56cb266e031f5ec081dfbde7e43f55e80
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:06:59 2005 +0100

    [ALSA] dynamic minors (3/6): store device-specific object pointers dynamically
    
    Instead of storing the pointers to the device-specific structures in an
    array, put them into the struct snd_minor, and look them up dynamically.
    
    This makes the device type modules independent of the minor number
    encoding.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 27d5bf7266f0..b8c0c8c4d126 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -35,8 +35,7 @@ MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Hardware dependent layer");
 MODULE_LICENSE("GPL");
 
-static struct snd_hwdep *snd_hwdep_devices[SNDRV_CARDS * SNDRV_MINOR_HWDEPS];
-
+static LIST_HEAD(snd_hwdep_devices);
 static DECLARE_MUTEX(register_mutex);
 
 static int snd_hwdep_free(struct snd_hwdep *hwdep);
@@ -44,9 +43,19 @@ static int snd_hwdep_dev_free(struct snd_device *device);
 static int snd_hwdep_dev_register(struct snd_device *device);
 static int snd_hwdep_dev_unregister(struct snd_device *device);
 
-/*
 
- */
+static struct snd_hwdep *snd_hwdep_search(struct snd_card *card, int device)
+{
+	struct list_head *p;
+	struct snd_hwdep *hwdep;
+
+	list_for_each(p, &snd_hwdep_devices) {
+		hwdep = list_entry(p, struct snd_hwdep, list);
+		if (hwdep->card == card && hwdep->device == device)
+			return hwdep;
+	}
+	return NULL;
+}
 
 static loff_t snd_hwdep_llseek(struct file * file, loff_t offset, int orig)
 {
@@ -77,34 +86,25 @@ static ssize_t snd_hwdep_write(struct file * file, const char __user *buf,
 static int snd_hwdep_open(struct inode *inode, struct file * file)
 {
 	int major = imajor(inode);
-	int cardnum;
-	int device;
 	struct snd_hwdep *hw;
 	int err;
 	wait_queue_t wait;
 
 	if (major == snd_major) {
-		cardnum = SNDRV_MINOR_CARD(iminor(inode));
-		device = SNDRV_MINOR_DEVICE(iminor(inode)) - SNDRV_MINOR_HWDEP;
+		hw = snd_lookup_minor_data(iminor(inode),
+					   SNDRV_DEVICE_TYPE_HWDEP);
 #ifdef CONFIG_SND_OSSEMUL
 	} else if (major == SOUND_MAJOR) {
-		cardnum = SNDRV_MINOR_OSS_CARD(iminor(inode));
-		device = 0;
+		hw = snd_lookup_oss_minor_data(iminor(inode),
+					       SNDRV_OSS_DEVICE_TYPE_DMFM);
 #endif
 	} else
 		return -ENXIO;
-	cardnum %= SNDRV_CARDS;
-	device %= SNDRV_MINOR_HWDEPS;
-	hw = snd_hwdep_devices[(cardnum * SNDRV_MINOR_HWDEPS) + device];
 	if (hw == NULL)
 		return -ENODEV;
 
 	if (!hw->ops.open)
 		return -ENXIO;
-#ifdef CONFIG_SND_OSSEMUL
-	if (major == SOUND_MAJOR && hw->oss_type < 0)
-		return -ENXIO;
-#endif
 
 	if (!try_module_get(hw->card->module))
 		return -EFAULT;
@@ -265,9 +265,6 @@ static int snd_hwdep_control_ioctl(struct snd_card *card,
 				   struct snd_ctl_file * control,
 				   unsigned int cmd, unsigned long arg)
 {
-	unsigned int tmp;
-	
-	tmp = card->number * SNDRV_MINOR_HWDEPS;
 	switch (cmd) {
 	case SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE:
 		{
@@ -275,14 +272,16 @@ static int snd_hwdep_control_ioctl(struct snd_card *card,
 
 			if (get_user(device, (int __user *)arg))
 				return -EFAULT;
+			down(&register_mutex);
 			device = device < 0 ? 0 : device + 1;
 			while (device < SNDRV_MINOR_HWDEPS) {
-				if (snd_hwdep_devices[tmp + device])
+				if (snd_hwdep_search(card, device))
 					break;
 				device++;
 			}
 			if (device >= SNDRV_MINOR_HWDEPS)
 				device = -1;
+			up(&register_mutex);
 			if (put_user(device, (int __user *)arg))
 				return -EFAULT;
 			return 0;
@@ -290,17 +289,19 @@ static int snd_hwdep_control_ioctl(struct snd_card *card,
 	case SNDRV_CTL_IOCTL_HWDEP_INFO:
 		{
 			struct snd_hwdep_info __user *info = (struct snd_hwdep_info __user *)arg;
-			int device;
+			int device, err;
 			struct snd_hwdep *hwdep;
 
 			if (get_user(device, &info->device))
 				return -EFAULT;
-			if (device < 0 || device >= SNDRV_MINOR_HWDEPS)
-				return -ENXIO;
-			hwdep = snd_hwdep_devices[tmp + device];
-			if (hwdep == NULL)
-				return -ENXIO;
-			return snd_hwdep_info(hwdep, info);
+			down(&register_mutex);
+			hwdep = snd_hwdep_search(card, device);
+			if (hwdep)
+				err = snd_hwdep_info(hwdep, info);
+			else
+				err = -ENXIO;
+			up(&register_mutex);
+			return err;
 		}
 	}
 	return -ENOIOCTLCMD;
@@ -397,23 +398,22 @@ static int snd_hwdep_dev_free(struct snd_device *device)
 static int snd_hwdep_dev_register(struct snd_device *device)
 {
 	struct snd_hwdep *hwdep = device->device_data;
-	int idx, err;
+	int err;
 	char name[32];
 
 	down(&register_mutex);
-	idx = (hwdep->card->number * SNDRV_MINOR_HWDEPS) + hwdep->device;
-	if (snd_hwdep_devices[idx]) {
+	if (snd_hwdep_search(hwdep->card, hwdep->device)) {
 		up(&register_mutex);
 		return -EBUSY;
 	}
-	snd_hwdep_devices[idx] = hwdep;
+	list_add_tail(&hwdep->list, &snd_hwdep_devices);
 	sprintf(name, "hwC%iD%i", hwdep->card->number, hwdep->device);
 	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_HWDEP,
 				       hwdep->card, hwdep->device,
-				       &snd_hwdep_f_ops, name)) < 0) {
+				       &snd_hwdep_f_ops, hwdep, name)) < 0) {
 		snd_printk(KERN_ERR "unable to register hardware dependent device %i:%i\n",
 			   hwdep->card->number, hwdep->device);
-		snd_hwdep_devices[idx] = NULL;
+		list_del(&hwdep->list);
 		up(&register_mutex);
 		return err;
 	}
@@ -425,7 +425,7 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		} else {
 			if (snd_register_oss_device(hwdep->oss_type,
 						    hwdep->card, hwdep->device,
-						    &snd_hwdep_f_ops,
+						    &snd_hwdep_f_ops, hwdep,
 						    hwdep->oss_dev) < 0) {
 				snd_printk(KERN_ERR "unable to register OSS compatibility device %i:%i\n",
 					   hwdep->card->number, hwdep->device);
@@ -441,12 +441,10 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 static int snd_hwdep_dev_unregister(struct snd_device *device)
 {
 	struct snd_hwdep *hwdep = device->device_data;
-	int idx;
 
 	snd_assert(hwdep != NULL, return -ENXIO);
 	down(&register_mutex);
-	idx = (hwdep->card->number * SNDRV_MINOR_HWDEPS) + hwdep->device;
-	if (snd_hwdep_devices[idx] != hwdep) {
+	if (snd_hwdep_search(hwdep->card, hwdep->device) != hwdep) {
 		up(&register_mutex);
 		return -EINVAL;
 	}
@@ -455,7 +453,7 @@ static int snd_hwdep_dev_unregister(struct snd_device *device)
 		snd_unregister_oss_device(hwdep->oss_type, hwdep->card, hwdep->device);
 #endif
 	snd_unregister_device(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card, hwdep->device);
-	snd_hwdep_devices[idx] = NULL;
+	list_del(&hwdep->list);
 	up(&register_mutex);
 	return snd_hwdep_free(hwdep);
 }
@@ -467,18 +465,14 @@ static int snd_hwdep_dev_unregister(struct snd_device *device)
 static void snd_hwdep_proc_read(struct snd_info_entry *entry,
 				struct snd_info_buffer *buffer)
 {
-	int idx;
+	struct list_head *p;
 	struct snd_hwdep *hwdep;
 
 	down(&register_mutex);
-	for (idx = 0; idx < SNDRV_CARDS * SNDRV_MINOR_HWDEPS; idx++) {
-		hwdep = snd_hwdep_devices[idx];
-		if (hwdep == NULL)
-			continue;
+	list_for_each(p, &snd_hwdep_devices) {
+		hwdep = list_entry(p, struct snd_hwdep, list);
 		snd_iprintf(buffer, "%02i-%02i: %s\n",
-					idx / SNDRV_MINOR_HWDEPS,
-					idx % SNDRV_MINOR_HWDEPS,
-					hwdep->name);
+			    hwdep->card->number, hwdep->device, hwdep->name);
 	}
 	up(&register_mutex);
 }
@@ -493,9 +487,8 @@ static int __init alsa_hwdep_init(void)
 {
 	struct snd_info_entry *entry;
 
-	memset(snd_hwdep_devices, 0, sizeof(snd_hwdep_devices));
 	if ((entry = snd_info_create_module_entry(THIS_MODULE, "hwdep", NULL)) != NULL) {
-		entry->c.text.read_size = 512;
+		entry->c.text.read_size = PAGE_SIZE;
 		entry->c.text.read = snd_hwdep_proc_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);

commit 2af677fc884fc6dc79e65c99050ea607ac8bab9b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:03:48 2005 +0100

    [ALSA] dynamic minors (1/6): store device type in struct snd_minor
    
    Instead of a comment string, store the device type in the snd_minor
    structure.  This makes snd_minor more flexible, and has the nice side
    effect that we don't need anymore to create a separate snd_minor
    template for registering a device but can pass the file_operations
    directly to snd_register_device().
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 444e266e7c48..27d5bf7266f0 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -330,12 +330,6 @@ static struct file_operations snd_hwdep_f_ops =
 	.mmap =		snd_hwdep_mmap,
 };
 
-static struct snd_minor snd_hwdep_reg =
-{
-	.comment =	"hardware dependent",
-	.f_ops =	&snd_hwdep_f_ops,
-};
-
 /**
  * snd_hwdep_new - create a new hwdep instance
  * @card: the card instance
@@ -416,7 +410,7 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 	sprintf(name, "hwC%iD%i", hwdep->card->number, hwdep->device);
 	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_HWDEP,
 				       hwdep->card, hwdep->device,
-				       &snd_hwdep_reg, name)) < 0) {
+				       &snd_hwdep_f_ops, name)) < 0) {
 		snd_printk(KERN_ERR "unable to register hardware dependent device %i:%i\n",
 			   hwdep->card->number, hwdep->device);
 		snd_hwdep_devices[idx] = NULL;
@@ -431,7 +425,8 @@ static int snd_hwdep_dev_register(struct snd_device *device)
 		} else {
 			if (snd_register_oss_device(hwdep->oss_type,
 						    hwdep->card, hwdep->device,
-						    &snd_hwdep_reg, hwdep->oss_dev) < 0) {
+						    &snd_hwdep_f_ops,
+						    hwdep->oss_dev) < 0) {
 				snd_printk(KERN_ERR "unable to register OSS compatibility device %i:%i\n",
 					   hwdep->card->number, hwdep->device);
 			} else

commit 73e77ba0235532bd7523ba90883d325f6e095acf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:44:01 2005 +0100

    [ALSA] Add error messages
    
    Add error messages in the critial error path to be more verbose.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index da0fb9f08413..444e266e7c48 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -364,13 +364,14 @@ int snd_hwdep_new(struct snd_card *card, char *id, int device,
 	*rhwdep = NULL;
 	snd_assert(card != NULL, return -ENXIO);
 	hwdep = kzalloc(sizeof(*hwdep), GFP_KERNEL);
-	if (hwdep == NULL)
+	if (hwdep == NULL) {
+		snd_printk(KERN_ERR "hwdep: cannot allocate\n");
 		return -ENOMEM;
+	}
 	hwdep->card = card;
 	hwdep->device = device;
-	if (id) {
+	if (id)
 		strlcpy(hwdep->id, id, sizeof(hwdep->id));
-	}
 #ifdef CONFIG_SND_OSSEMUL
 	hwdep->oss_type = -1;
 #endif

commit d9a98de218ce18befabb5782c43cb4a2766b4b02
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:58:21 2005 +0100

    [ALSA] Remove xxx_t typedefs: Hwdep
    
    Modules: HWDEP Midlevel
    
    Remove xxx_t typedefs from the core hwdep codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index e91cee35a4b9..da0fb9f08413 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -35,14 +35,14 @@ MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Hardware dependent layer");
 MODULE_LICENSE("GPL");
 
-static snd_hwdep_t *snd_hwdep_devices[SNDRV_CARDS * SNDRV_MINOR_HWDEPS];
+static struct snd_hwdep *snd_hwdep_devices[SNDRV_CARDS * SNDRV_MINOR_HWDEPS];
 
 static DECLARE_MUTEX(register_mutex);
 
-static int snd_hwdep_free(snd_hwdep_t *hwdep);
-static int snd_hwdep_dev_free(snd_device_t *device);
-static int snd_hwdep_dev_register(snd_device_t *device);
-static int snd_hwdep_dev_unregister(snd_device_t *device);
+static int snd_hwdep_free(struct snd_hwdep *hwdep);
+static int snd_hwdep_dev_free(struct snd_device *device);
+static int snd_hwdep_dev_register(struct snd_device *device);
+static int snd_hwdep_dev_unregister(struct snd_device *device);
 
 /*
 
@@ -50,23 +50,25 @@ static int snd_hwdep_dev_unregister(snd_device_t *device);
 
 static loff_t snd_hwdep_llseek(struct file * file, loff_t offset, int orig)
 {
-	snd_hwdep_t *hw = file->private_data;
+	struct snd_hwdep *hw = file->private_data;
 	if (hw->ops.llseek)
 		return hw->ops.llseek(hw, file, offset, orig);
 	return -ENXIO;
 }
 
-static ssize_t snd_hwdep_read(struct file * file, char __user *buf, size_t count, loff_t *offset)
+static ssize_t snd_hwdep_read(struct file * file, char __user *buf,
+			      size_t count, loff_t *offset)
 {
-	snd_hwdep_t *hw = file->private_data;
+	struct snd_hwdep *hw = file->private_data;
 	if (hw->ops.read)
 		return hw->ops.read(hw, buf, count, offset);
 	return -ENXIO;	
 }
 
-static ssize_t snd_hwdep_write(struct file * file, const char __user *buf, size_t count, loff_t *offset)
+static ssize_t snd_hwdep_write(struct file * file, const char __user *buf,
+			       size_t count, loff_t *offset)
 {
-	snd_hwdep_t *hw = file->private_data;
+	struct snd_hwdep *hw = file->private_data;
 	if (hw->ops.write)
 		return hw->ops.write(hw, buf, count, offset);
 	return -ENXIO;	
@@ -77,7 +79,7 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 	int major = imajor(inode);
 	int cardnum;
 	int device;
-	snd_hwdep_t *hw;
+	struct snd_hwdep *hw;
 	int err;
 	wait_queue_t wait;
 
@@ -154,7 +156,7 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 static int snd_hwdep_release(struct inode *inode, struct file * file)
 {
 	int err = -ENXIO;
-	snd_hwdep_t *hw = file->private_data;
+	struct snd_hwdep *hw = file->private_data;
 	down(&hw->open_mutex);
 	if (hw->ops.release) {
 		err = hw->ops.release(hw, file);
@@ -170,15 +172,16 @@ static int snd_hwdep_release(struct inode *inode, struct file * file)
 
 static unsigned int snd_hwdep_poll(struct file * file, poll_table * wait)
 {
-	snd_hwdep_t *hw = file->private_data;
+	struct snd_hwdep *hw = file->private_data;
 	if (hw->ops.poll)
 		return hw->ops.poll(hw, file, wait);
 	return 0;
 }
 
-static int snd_hwdep_info(snd_hwdep_t *hw, snd_hwdep_info_t __user *_info)
+static int snd_hwdep_info(struct snd_hwdep *hw,
+			  struct snd_hwdep_info __user *_info)
 {
-	snd_hwdep_info_t info;
+	struct snd_hwdep_info info;
 	
 	memset(&info, 0, sizeof(info));
 	info.card = hw->card->number;
@@ -190,9 +193,10 @@ static int snd_hwdep_info(snd_hwdep_t *hw, snd_hwdep_info_t __user *_info)
 	return 0;
 }
 
-static int snd_hwdep_dsp_status(snd_hwdep_t *hw, snd_hwdep_dsp_status_t __user *_info)
+static int snd_hwdep_dsp_status(struct snd_hwdep *hw,
+				struct snd_hwdep_dsp_status __user *_info)
 {
-	snd_hwdep_dsp_status_t info;
+	struct snd_hwdep_dsp_status info;
 	int err;
 	
 	if (! hw->ops.dsp_status)
@@ -206,9 +210,10 @@ static int snd_hwdep_dsp_status(snd_hwdep_t *hw, snd_hwdep_dsp_status_t __user *
 	return 0;
 }
 
-static int snd_hwdep_dsp_load(snd_hwdep_t *hw, snd_hwdep_dsp_image_t __user *_info)
+static int snd_hwdep_dsp_load(struct snd_hwdep *hw,
+			      struct snd_hwdep_dsp_image __user *_info)
 {
-	snd_hwdep_dsp_image_t info;
+	struct snd_hwdep_dsp_image info;
 	int err;
 	
 	if (! hw->ops.dsp_load)
@@ -228,9 +233,10 @@ static int snd_hwdep_dsp_load(snd_hwdep_t *hw, snd_hwdep_dsp_image_t __user *_in
 	return 0;
 }
 
-static long snd_hwdep_ioctl(struct file * file, unsigned int cmd, unsigned long arg)
+static long snd_hwdep_ioctl(struct file * file, unsigned int cmd,
+			    unsigned long arg)
 {
-	snd_hwdep_t *hw = file->private_data;
+	struct snd_hwdep *hw = file->private_data;
 	void __user *argp = (void __user *)arg;
 	switch (cmd) {
 	case SNDRV_HWDEP_IOCTL_PVERSION:
@@ -249,13 +255,14 @@ static long snd_hwdep_ioctl(struct file * file, unsigned int cmd, unsigned long
 
 static int snd_hwdep_mmap(struct file * file, struct vm_area_struct * vma)
 {
-	snd_hwdep_t *hw = file->private_data;
+	struct snd_hwdep *hw = file->private_data;
 	if (hw->ops.mmap)
 		return hw->ops.mmap(hw, file, vma);
 	return -ENXIO;
 }
 
-static int snd_hwdep_control_ioctl(snd_card_t * card, snd_ctl_file_t * control,
+static int snd_hwdep_control_ioctl(struct snd_card *card,
+				   struct snd_ctl_file * control,
 				   unsigned int cmd, unsigned long arg)
 {
 	unsigned int tmp;
@@ -282,9 +289,9 @@ static int snd_hwdep_control_ioctl(snd_card_t * card, snd_ctl_file_t * control,
 		}
 	case SNDRV_CTL_IOCTL_HWDEP_INFO:
 		{
-			snd_hwdep_info_t __user *info = (snd_hwdep_info_t __user *)arg;
+			struct snd_hwdep_info __user *info = (struct snd_hwdep_info __user *)arg;
 			int device;
-			snd_hwdep_t *hwdep;
+			struct snd_hwdep *hwdep;
 
 			if (get_user(device, &info->device))
 				return -EFAULT;
@@ -323,7 +330,7 @@ static struct file_operations snd_hwdep_f_ops =
 	.mmap =		snd_hwdep_mmap,
 };
 
-static snd_minor_t snd_hwdep_reg =
+static struct snd_minor snd_hwdep_reg =
 {
 	.comment =	"hardware dependent",
 	.f_ops =	&snd_hwdep_f_ops,
@@ -342,11 +349,12 @@ static snd_minor_t snd_hwdep_reg =
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_hwdep_new(snd_card_t * card, char *id, int device, snd_hwdep_t ** rhwdep)
+int snd_hwdep_new(struct snd_card *card, char *id, int device,
+		  struct snd_hwdep **rhwdep)
 {
-	snd_hwdep_t *hwdep;
+	struct snd_hwdep *hwdep;
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free = snd_hwdep_dev_free,
 		.dev_register = snd_hwdep_dev_register,
 		.dev_unregister = snd_hwdep_dev_unregister
@@ -376,7 +384,7 @@ int snd_hwdep_new(snd_card_t * card, char *id, int device, snd_hwdep_t ** rhwdep
 	return 0;
 }
 
-static int snd_hwdep_free(snd_hwdep_t *hwdep)
+static int snd_hwdep_free(struct snd_hwdep *hwdep)
 {
 	snd_assert(hwdep != NULL, return -ENXIO);
 	if (hwdep->private_free)
@@ -385,15 +393,15 @@ static int snd_hwdep_free(snd_hwdep_t *hwdep)
 	return 0;
 }
 
-static int snd_hwdep_dev_free(snd_device_t *device)
+static int snd_hwdep_dev_free(struct snd_device *device)
 {
-	snd_hwdep_t *hwdep = device->device_data;
+	struct snd_hwdep *hwdep = device->device_data;
 	return snd_hwdep_free(hwdep);
 }
 
-static int snd_hwdep_dev_register(snd_device_t *device)
+static int snd_hwdep_dev_register(struct snd_device *device)
 {
-	snd_hwdep_t *hwdep = device->device_data;
+	struct snd_hwdep *hwdep = device->device_data;
 	int idx, err;
 	char name[32];
 
@@ -434,9 +442,9 @@ static int snd_hwdep_dev_register(snd_device_t *device)
 	return 0;
 }
 
-static int snd_hwdep_dev_unregister(snd_device_t *device)
+static int snd_hwdep_dev_unregister(struct snd_device *device)
 {
-	snd_hwdep_t *hwdep = device->device_data;
+	struct snd_hwdep *hwdep = device->device_data;
 	int idx;
 
 	snd_assert(hwdep != NULL, return -ENXIO);
@@ -460,11 +468,11 @@ static int snd_hwdep_dev_unregister(snd_device_t *device)
  *  Info interface
  */
 
-static void snd_hwdep_proc_read(snd_info_entry_t *entry,
-				snd_info_buffer_t * buffer)
+static void snd_hwdep_proc_read(struct snd_info_entry *entry,
+				struct snd_info_buffer *buffer)
 {
 	int idx;
-	snd_hwdep_t *hwdep;
+	struct snd_hwdep *hwdep;
 
 	down(&register_mutex);
 	for (idx = 0; idx < SNDRV_CARDS * SNDRV_MINOR_HWDEPS; idx++) {
@@ -483,11 +491,11 @@ static void snd_hwdep_proc_read(snd_info_entry_t *entry,
  *  ENTRY functions
  */
 
-static snd_info_entry_t *snd_hwdep_proc_entry = NULL;
+static struct snd_info_entry *snd_hwdep_proc_entry = NULL;
 
 static int __init alsa_hwdep_init(void)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	memset(snd_hwdep_devices, 0, sizeof(snd_hwdep_devices));
 	if ((entry = snd_info_create_module_entry(THIS_MODULE, "hwdep", NULL)) != NULL) {

commit f1902860161ff212c515e7ea629e880fec856a37
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 24 17:05:03 2005 +0200

    [ALSA] fix improper CONFIG_SND_MAJOR usage
    
    Modules: HWDEP Midlevel,PCM Midlevel,RawMidi Midlevel,ALSA Core
    
    Replace usage of CONFIG_SND_MAJOR with snd_major, where appropriate.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 9383f1294fb5..e91cee35a4b9 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -81,20 +81,16 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 	int err;
 	wait_queue_t wait;
 
-	switch (major) {
-	case CONFIG_SND_MAJOR:
+	if (major == snd_major) {
 		cardnum = SNDRV_MINOR_CARD(iminor(inode));
 		device = SNDRV_MINOR_DEVICE(iminor(inode)) - SNDRV_MINOR_HWDEP;
-		break;
 #ifdef CONFIG_SND_OSSEMUL
-	case SOUND_MAJOR:
+	} else if (major == SOUND_MAJOR) {
 		cardnum = SNDRV_MINOR_OSS_CARD(iminor(inode));
 		device = 0;
-		break;
 #endif
-	default:
+	} else
 		return -ENXIO;
-	}
 	cardnum %= SNDRV_CARDS;
 	device %= SNDRV_MINOR_HWDEPS;
 	hw = snd_hwdep_devices[(cardnum * SNDRV_MINOR_HWDEPS) + device];

commit ca2c0966562cfbf9273167a5b60e8fddc24078d6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:23 2005 +0200

    [ALSA] Replace with kzalloc() - core stuff
    
    Control Midlevel,ALSA Core,HWDEP Midlevel,PCM Midlevel,RawMidi Midlevel
    Timer Midlevel,ALSA<-OSS emulation
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index 997dd41c584e..9383f1294fb5 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -359,7 +359,7 @@ int snd_hwdep_new(snd_card_t * card, char *id, int device, snd_hwdep_t ** rhwdep
 	snd_assert(rhwdep != NULL, return -EINVAL);
 	*rhwdep = NULL;
 	snd_assert(card != NULL, return -ENXIO);
-	hwdep = kcalloc(1, sizeof(*hwdep), GFP_KERNEL);
+	hwdep = kzalloc(sizeof(*hwdep), GFP_KERNEL);
 	if (hwdep == NULL)
 		return -ENOMEM;
 	hwdep->card = card;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
new file mode 100644
index 000000000000..997dd41c584e
--- /dev/null
+++ b/sound/core/hwdep.c
@@ -0,0 +1,524 @@
+/*
+ *  Hardware dependent layer
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/major.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/minors.h>
+#include <sound/hwdep.h>
+#include <sound/info.h>
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Hardware dependent layer");
+MODULE_LICENSE("GPL");
+
+static snd_hwdep_t *snd_hwdep_devices[SNDRV_CARDS * SNDRV_MINOR_HWDEPS];
+
+static DECLARE_MUTEX(register_mutex);
+
+static int snd_hwdep_free(snd_hwdep_t *hwdep);
+static int snd_hwdep_dev_free(snd_device_t *device);
+static int snd_hwdep_dev_register(snd_device_t *device);
+static int snd_hwdep_dev_unregister(snd_device_t *device);
+
+/*
+
+ */
+
+static loff_t snd_hwdep_llseek(struct file * file, loff_t offset, int orig)
+{
+	snd_hwdep_t *hw = file->private_data;
+	if (hw->ops.llseek)
+		return hw->ops.llseek(hw, file, offset, orig);
+	return -ENXIO;
+}
+
+static ssize_t snd_hwdep_read(struct file * file, char __user *buf, size_t count, loff_t *offset)
+{
+	snd_hwdep_t *hw = file->private_data;
+	if (hw->ops.read)
+		return hw->ops.read(hw, buf, count, offset);
+	return -ENXIO;	
+}
+
+static ssize_t snd_hwdep_write(struct file * file, const char __user *buf, size_t count, loff_t *offset)
+{
+	snd_hwdep_t *hw = file->private_data;
+	if (hw->ops.write)
+		return hw->ops.write(hw, buf, count, offset);
+	return -ENXIO;	
+}
+
+static int snd_hwdep_open(struct inode *inode, struct file * file)
+{
+	int major = imajor(inode);
+	int cardnum;
+	int device;
+	snd_hwdep_t *hw;
+	int err;
+	wait_queue_t wait;
+
+	switch (major) {
+	case CONFIG_SND_MAJOR:
+		cardnum = SNDRV_MINOR_CARD(iminor(inode));
+		device = SNDRV_MINOR_DEVICE(iminor(inode)) - SNDRV_MINOR_HWDEP;
+		break;
+#ifdef CONFIG_SND_OSSEMUL
+	case SOUND_MAJOR:
+		cardnum = SNDRV_MINOR_OSS_CARD(iminor(inode));
+		device = 0;
+		break;
+#endif
+	default:
+		return -ENXIO;
+	}
+	cardnum %= SNDRV_CARDS;
+	device %= SNDRV_MINOR_HWDEPS;
+	hw = snd_hwdep_devices[(cardnum * SNDRV_MINOR_HWDEPS) + device];
+	if (hw == NULL)
+		return -ENODEV;
+
+	if (!hw->ops.open)
+		return -ENXIO;
+#ifdef CONFIG_SND_OSSEMUL
+	if (major == SOUND_MAJOR && hw->oss_type < 0)
+		return -ENXIO;
+#endif
+
+	if (!try_module_get(hw->card->module))
+		return -EFAULT;
+
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(&hw->open_wait, &wait);
+	down(&hw->open_mutex);
+	while (1) {
+		if (hw->exclusive && hw->used > 0) {
+			err = -EBUSY;
+			break;
+		}
+		err = hw->ops.open(hw, file);
+		if (err >= 0)
+			break;
+		if (err == -EAGAIN) {
+			if (file->f_flags & O_NONBLOCK) {
+				err = -EBUSY;
+				break;
+			}
+		} else
+			break;
+		set_current_state(TASK_INTERRUPTIBLE);
+		up(&hw->open_mutex);
+		schedule();
+		down(&hw->open_mutex);
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+	}
+	remove_wait_queue(&hw->open_wait, &wait);
+	if (err >= 0) {
+		err = snd_card_file_add(hw->card, file);
+		if (err >= 0) {
+			file->private_data = hw;
+			hw->used++;
+		} else {
+			if (hw->ops.release)
+				hw->ops.release(hw, file);
+		}
+	}
+	up(&hw->open_mutex);
+	if (err < 0)
+		module_put(hw->card->module);
+	return err;
+}
+
+static int snd_hwdep_release(struct inode *inode, struct file * file)
+{
+	int err = -ENXIO;
+	snd_hwdep_t *hw = file->private_data;
+	down(&hw->open_mutex);
+	if (hw->ops.release) {
+		err = hw->ops.release(hw, file);
+		wake_up(&hw->open_wait);
+	}
+	if (hw->used > 0)
+		hw->used--;
+	snd_card_file_remove(hw->card, file);
+	up(&hw->open_mutex);
+	module_put(hw->card->module);
+	return err;
+}
+
+static unsigned int snd_hwdep_poll(struct file * file, poll_table * wait)
+{
+	snd_hwdep_t *hw = file->private_data;
+	if (hw->ops.poll)
+		return hw->ops.poll(hw, file, wait);
+	return 0;
+}
+
+static int snd_hwdep_info(snd_hwdep_t *hw, snd_hwdep_info_t __user *_info)
+{
+	snd_hwdep_info_t info;
+	
+	memset(&info, 0, sizeof(info));
+	info.card = hw->card->number;
+	strlcpy(info.id, hw->id, sizeof(info.id));	
+	strlcpy(info.name, hw->name, sizeof(info.name));
+	info.iface = hw->iface;
+	if (copy_to_user(_info, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+static int snd_hwdep_dsp_status(snd_hwdep_t *hw, snd_hwdep_dsp_status_t __user *_info)
+{
+	snd_hwdep_dsp_status_t info;
+	int err;
+	
+	if (! hw->ops.dsp_status)
+		return -ENXIO;
+	memset(&info, 0, sizeof(info));
+	info.dsp_loaded = hw->dsp_loaded;
+	if ((err = hw->ops.dsp_status(hw, &info)) < 0)
+		return err;
+	if (copy_to_user(_info, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+static int snd_hwdep_dsp_load(snd_hwdep_t *hw, snd_hwdep_dsp_image_t __user *_info)
+{
+	snd_hwdep_dsp_image_t info;
+	int err;
+	
+	if (! hw->ops.dsp_load)
+		return -ENXIO;
+	memset(&info, 0, sizeof(info));
+	if (copy_from_user(&info, _info, sizeof(info)))
+		return -EFAULT;
+	/* check whether the dsp was already loaded */
+	if (hw->dsp_loaded & (1 << info.index))
+		return -EBUSY;
+	if (!access_ok(VERIFY_READ, info.image, info.length))
+		return -EFAULT;
+	err = hw->ops.dsp_load(hw, &info);
+	if (err < 0)
+		return err;
+	hw->dsp_loaded |= (1 << info.index);
+	return 0;
+}
+
+static long snd_hwdep_ioctl(struct file * file, unsigned int cmd, unsigned long arg)
+{
+	snd_hwdep_t *hw = file->private_data;
+	void __user *argp = (void __user *)arg;
+	switch (cmd) {
+	case SNDRV_HWDEP_IOCTL_PVERSION:
+		return put_user(SNDRV_HWDEP_VERSION, (int __user *)argp);
+	case SNDRV_HWDEP_IOCTL_INFO:
+		return snd_hwdep_info(hw, argp);
+	case SNDRV_HWDEP_IOCTL_DSP_STATUS:
+		return snd_hwdep_dsp_status(hw, argp);
+	case SNDRV_HWDEP_IOCTL_DSP_LOAD:
+		return snd_hwdep_dsp_load(hw, argp);
+	}
+	if (hw->ops.ioctl)
+		return hw->ops.ioctl(hw, file, cmd, arg);
+	return -ENOTTY;
+}
+
+static int snd_hwdep_mmap(struct file * file, struct vm_area_struct * vma)
+{
+	snd_hwdep_t *hw = file->private_data;
+	if (hw->ops.mmap)
+		return hw->ops.mmap(hw, file, vma);
+	return -ENXIO;
+}
+
+static int snd_hwdep_control_ioctl(snd_card_t * card, snd_ctl_file_t * control,
+				   unsigned int cmd, unsigned long arg)
+{
+	unsigned int tmp;
+	
+	tmp = card->number * SNDRV_MINOR_HWDEPS;
+	switch (cmd) {
+	case SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE:
+		{
+			int device;
+
+			if (get_user(device, (int __user *)arg))
+				return -EFAULT;
+			device = device < 0 ? 0 : device + 1;
+			while (device < SNDRV_MINOR_HWDEPS) {
+				if (snd_hwdep_devices[tmp + device])
+					break;
+				device++;
+			}
+			if (device >= SNDRV_MINOR_HWDEPS)
+				device = -1;
+			if (put_user(device, (int __user *)arg))
+				return -EFAULT;
+			return 0;
+		}
+	case SNDRV_CTL_IOCTL_HWDEP_INFO:
+		{
+			snd_hwdep_info_t __user *info = (snd_hwdep_info_t __user *)arg;
+			int device;
+			snd_hwdep_t *hwdep;
+
+			if (get_user(device, &info->device))
+				return -EFAULT;
+			if (device < 0 || device >= SNDRV_MINOR_HWDEPS)
+				return -ENXIO;
+			hwdep = snd_hwdep_devices[tmp + device];
+			if (hwdep == NULL)
+				return -ENXIO;
+			return snd_hwdep_info(hwdep, info);
+		}
+	}
+	return -ENOIOCTLCMD;
+}
+
+#ifdef CONFIG_COMPAT
+#include "hwdep_compat.c"
+#else
+#define snd_hwdep_ioctl_compat	NULL
+#endif
+
+/*
+
+ */
+
+static struct file_operations snd_hwdep_f_ops =
+{
+	.owner = 	THIS_MODULE,
+	.llseek =	snd_hwdep_llseek,
+	.read = 	snd_hwdep_read,
+	.write =	snd_hwdep_write,
+	.open =		snd_hwdep_open,
+	.release =	snd_hwdep_release,
+	.poll =		snd_hwdep_poll,
+	.unlocked_ioctl =	snd_hwdep_ioctl,
+	.compat_ioctl =	snd_hwdep_ioctl_compat,
+	.mmap =		snd_hwdep_mmap,
+};
+
+static snd_minor_t snd_hwdep_reg =
+{
+	.comment =	"hardware dependent",
+	.f_ops =	&snd_hwdep_f_ops,
+};
+
+/**
+ * snd_hwdep_new - create a new hwdep instance
+ * @card: the card instance
+ * @id: the id string
+ * @device: the device index (zero-based)
+ * @rhwdep: the pointer to store the new hwdep instance
+ *
+ * Creates a new hwdep instance with the given index on the card.
+ * The callbacks (hwdep->ops) must be set on the returned instance
+ * after this call manually by the caller.
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_hwdep_new(snd_card_t * card, char *id, int device, snd_hwdep_t ** rhwdep)
+{
+	snd_hwdep_t *hwdep;
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free = snd_hwdep_dev_free,
+		.dev_register = snd_hwdep_dev_register,
+		.dev_unregister = snd_hwdep_dev_unregister
+	};
+
+	snd_assert(rhwdep != NULL, return -EINVAL);
+	*rhwdep = NULL;
+	snd_assert(card != NULL, return -ENXIO);
+	hwdep = kcalloc(1, sizeof(*hwdep), GFP_KERNEL);
+	if (hwdep == NULL)
+		return -ENOMEM;
+	hwdep->card = card;
+	hwdep->device = device;
+	if (id) {
+		strlcpy(hwdep->id, id, sizeof(hwdep->id));
+	}
+#ifdef CONFIG_SND_OSSEMUL
+	hwdep->oss_type = -1;
+#endif
+	if ((err = snd_device_new(card, SNDRV_DEV_HWDEP, hwdep, &ops)) < 0) {
+		snd_hwdep_free(hwdep);
+		return err;
+	}
+	init_waitqueue_head(&hwdep->open_wait);
+	init_MUTEX(&hwdep->open_mutex);
+	*rhwdep = hwdep;
+	return 0;
+}
+
+static int snd_hwdep_free(snd_hwdep_t *hwdep)
+{
+	snd_assert(hwdep != NULL, return -ENXIO);
+	if (hwdep->private_free)
+		hwdep->private_free(hwdep);
+	kfree(hwdep);
+	return 0;
+}
+
+static int snd_hwdep_dev_free(snd_device_t *device)
+{
+	snd_hwdep_t *hwdep = device->device_data;
+	return snd_hwdep_free(hwdep);
+}
+
+static int snd_hwdep_dev_register(snd_device_t *device)
+{
+	snd_hwdep_t *hwdep = device->device_data;
+	int idx, err;
+	char name[32];
+
+	down(&register_mutex);
+	idx = (hwdep->card->number * SNDRV_MINOR_HWDEPS) + hwdep->device;
+	if (snd_hwdep_devices[idx]) {
+		up(&register_mutex);
+		return -EBUSY;
+	}
+	snd_hwdep_devices[idx] = hwdep;
+	sprintf(name, "hwC%iD%i", hwdep->card->number, hwdep->device);
+	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_HWDEP,
+				       hwdep->card, hwdep->device,
+				       &snd_hwdep_reg, name)) < 0) {
+		snd_printk(KERN_ERR "unable to register hardware dependent device %i:%i\n",
+			   hwdep->card->number, hwdep->device);
+		snd_hwdep_devices[idx] = NULL;
+		up(&register_mutex);
+		return err;
+	}
+#ifdef CONFIG_SND_OSSEMUL
+	hwdep->ossreg = 0;
+	if (hwdep->oss_type >= 0) {
+		if ((hwdep->oss_type == SNDRV_OSS_DEVICE_TYPE_DMFM) && (hwdep->device != 0)) {
+			snd_printk (KERN_WARNING "only hwdep device 0 can be registered as OSS direct FM device!\n");
+		} else {
+			if (snd_register_oss_device(hwdep->oss_type,
+						    hwdep->card, hwdep->device,
+						    &snd_hwdep_reg, hwdep->oss_dev) < 0) {
+				snd_printk(KERN_ERR "unable to register OSS compatibility device %i:%i\n",
+					   hwdep->card->number, hwdep->device);
+			} else
+				hwdep->ossreg = 1;
+		}
+	}
+#endif
+	up(&register_mutex);
+	return 0;
+}
+
+static int snd_hwdep_dev_unregister(snd_device_t *device)
+{
+	snd_hwdep_t *hwdep = device->device_data;
+	int idx;
+
+	snd_assert(hwdep != NULL, return -ENXIO);
+	down(&register_mutex);
+	idx = (hwdep->card->number * SNDRV_MINOR_HWDEPS) + hwdep->device;
+	if (snd_hwdep_devices[idx] != hwdep) {
+		up(&register_mutex);
+		return -EINVAL;
+	}
+#ifdef CONFIG_SND_OSSEMUL
+	if (hwdep->ossreg)
+		snd_unregister_oss_device(hwdep->oss_type, hwdep->card, hwdep->device);
+#endif
+	snd_unregister_device(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card, hwdep->device);
+	snd_hwdep_devices[idx] = NULL;
+	up(&register_mutex);
+	return snd_hwdep_free(hwdep);
+}
+
+/*
+ *  Info interface
+ */
+
+static void snd_hwdep_proc_read(snd_info_entry_t *entry,
+				snd_info_buffer_t * buffer)
+{
+	int idx;
+	snd_hwdep_t *hwdep;
+
+	down(&register_mutex);
+	for (idx = 0; idx < SNDRV_CARDS * SNDRV_MINOR_HWDEPS; idx++) {
+		hwdep = snd_hwdep_devices[idx];
+		if (hwdep == NULL)
+			continue;
+		snd_iprintf(buffer, "%02i-%02i: %s\n",
+					idx / SNDRV_MINOR_HWDEPS,
+					idx % SNDRV_MINOR_HWDEPS,
+					hwdep->name);
+	}
+	up(&register_mutex);
+}
+
+/*
+ *  ENTRY functions
+ */
+
+static snd_info_entry_t *snd_hwdep_proc_entry = NULL;
+
+static int __init alsa_hwdep_init(void)
+{
+	snd_info_entry_t *entry;
+
+	memset(snd_hwdep_devices, 0, sizeof(snd_hwdep_devices));
+	if ((entry = snd_info_create_module_entry(THIS_MODULE, "hwdep", NULL)) != NULL) {
+		entry->c.text.read_size = 512;
+		entry->c.text.read = snd_hwdep_proc_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	snd_hwdep_proc_entry = entry;
+	snd_ctl_register_ioctl(snd_hwdep_control_ioctl);
+	snd_ctl_register_ioctl_compat(snd_hwdep_control_ioctl);
+	return 0;
+}
+
+static void __exit alsa_hwdep_exit(void)
+{
+	snd_ctl_unregister_ioctl(snd_hwdep_control_ioctl);
+	snd_ctl_unregister_ioctl_compat(snd_hwdep_control_ioctl);
+	if (snd_hwdep_proc_entry) {
+		snd_info_unregister(snd_hwdep_proc_entry);
+		snd_hwdep_proc_entry = NULL;
+	}
+}
+
+module_init(alsa_hwdep_init)
+module_exit(alsa_hwdep_exit)
+
+EXPORT_SYMBOL(snd_hwdep_new);
