commit 60379ba08532eca861e933b389526a4dc89e0c42
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 17 10:40:23 2020 +0200

    ALSA: info: Drop WARN_ON() from buffer NULL sanity check
    
    snd_info_get_line() has a sanity check of NULL buffer -- both buffer
    itself being NULL and buffer->buffer being NULL.  Basically both
    checks are valid and necessary, but the problem is that it's with
    snd_BUG_ON() macro that triggers WARN_ON().  The latter condition
    (NULL buffer->buffer) can be met arbitrarily by user since the buffer
    is allocated at the first write, so it means that user can trigger
    WARN_ON() at will.
    
    This patch addresses it by simply moving buffer->buffer NULL check out
    of snd_BUG_ON() so that spurious WARNING is no longer triggered.
    
    Reported-by: syzbot+e42d0746c3c3699b6061@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200717084023.5928-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 8c6bc5241df5..9fec3070f8ba 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -606,7 +606,9 @@ int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 {
 	int c;
 
-	if (snd_BUG_ON(!buffer || !buffer->buffer))
+	if (snd_BUG_ON(!buffer))
+		return 1;
+	if (!buffer->buffer)
 		return 1;
 	if (len <= 0 || buffer->stop || buffer->error)
 		return 1;

commit 0e023687ca552147a76540377be4c642b1313d53
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Feb 8 22:42:06 2020 +0000

    ALSA: info: remove redundant assignment to variable c
    
    Variable c is being assigned with the value -1 that is never read,
    it is assigned a new value in a following while-loop. The assignment
    is redundant and can be removed.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Link: https://lore.kernel.org/r/20200208224206.38540-1-colin.king@canonical.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index ca87ae4c30ba..8c6bc5241df5 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -604,7 +604,7 @@ int snd_info_card_free(struct snd_card *card)
  */
 int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 {
-	int c = -1;
+	int c;
 
 	if (snd_BUG_ON(!buffer || !buffer->buffer))
 		return 1;

commit 97a32539b9568bb653683349e5a76d02ff3c3e2c
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 3 17:37:17 2020 -0800

    proc: convert everything to "struct proc_ops"
    
    The most notable change is DEFINE_SHOW_ATTRIBUTE macro split in
    seq_file.h.
    
    Conversion rule is:
    
            llseek          => proc_lseek
            unlocked_ioctl  => proc_ioctl
    
            xxx             => proc_xxx
    
            delete ".owner = THIS_MODULE" line
    
    [akpm@linux-foundation.org: fix drivers/isdn/capi/kcapi_proc.c]
    [sfr@canb.auug.org.au: fix kernel/sched/psi.c]
      Link: http://lkml.kernel.org/r/20200122180545.36222f50@canb.auug.org.au
    Link: http://lkml.kernel.org/r/20191225172546.GB13378@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index 6801d8160866..ca87ae4c30ba 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -282,17 +282,16 @@ static int snd_info_entry_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static const struct file_operations snd_info_entry_operations =
-{
-	.owner =		THIS_MODULE,
-	.llseek =		snd_info_entry_llseek,
-	.read =			snd_info_entry_read,
-	.write =		snd_info_entry_write,
-	.poll =			snd_info_entry_poll,
-	.unlocked_ioctl =	snd_info_entry_ioctl,
-	.mmap =			snd_info_entry_mmap,
-	.open =			snd_info_entry_open,
-	.release =		snd_info_entry_release,
+static const struct proc_ops snd_info_entry_operations =
+{
+	.proc_lseek	= snd_info_entry_llseek,
+	.proc_read	= snd_info_entry_read,
+	.proc_write	= snd_info_entry_write,
+	.proc_poll	= snd_info_entry_poll,
+	.proc_ioctl	= snd_info_entry_ioctl,
+	.proc_mmap	= snd_info_entry_mmap,
+	.proc_open	= snd_info_entry_open,
+	.proc_release	= snd_info_entry_release,
 };
 
 /*
@@ -421,14 +420,13 @@ static int snd_info_text_entry_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static const struct file_operations snd_info_text_entry_ops =
+static const struct proc_ops snd_info_text_entry_ops =
 {
-	.owner =		THIS_MODULE,
-	.open =			snd_info_text_entry_open,
-	.release =		snd_info_text_entry_release,
-	.write =		snd_info_text_entry_write,
-	.llseek =		seq_lseek,
-	.read =			seq_read,
+	.proc_open	= snd_info_text_entry_open,
+	.proc_release	= snd_info_text_entry_release,
+	.proc_write	= snd_info_text_entry_write,
+	.proc_lseek	= seq_lseek,
+	.proc_read	= seq_read,
 };
 
 static struct snd_info_entry *create_subdir(struct module *mod,
@@ -810,7 +808,7 @@ static int __snd_info_register(struct snd_info_entry *entry)
 			return -ENOMEM;
 		}
 	} else {
-		const struct file_operations *ops;
+		const struct proc_ops *ops;
 		if (entry->content == SNDRV_INFO_CONTENT_DATA)
 			ops = &snd_info_entry_operations;
 		else

commit 51d7847a2d81ac6779b62fabd722b49b3b664de9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:53 2020 +0100

    ALSA: info: More constifications
    
    Apply const prefix to the string array and its callers.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-39-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index e051a029ccfb..6801d8160866 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -20,7 +20,7 @@
 
 int snd_info_check_reserved_words(const char *str)
 {
-	static char *reserved[] =
+	static const char * const reserved[] =
 	{
 		"version",
 		"meminfo",
@@ -35,7 +35,7 @@ int snd_info_check_reserved_words(const char *str)
 		"seq",
 		NULL
 	};
-	char **xstr = reserved;
+	const char * const *xstr = reserved;
 
 	while (*xstr) {
 		if (!strcmp(*xstr, str))

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index 0eb169acc850..e051a029ccfb 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Information interface for ALSA driver
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/init.h>

commit 8c2f870890fd28e023b0fcf49dcee333f2c8bad7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 16 15:25:00 2019 +0200

    ALSA: info: Fix racy addition/deletion of nodes
    
    The ALSA proc helper manages the child nodes in a linked list, but its
    addition and deletion is done without any lock.  This leads to a
    corruption if they are operated concurrently.  Usually this isn't a
    problem because the proc entries are added sequentially in the driver
    probe procedure itself.  But the card registrations are done often
    asynchronously, and the crash could be actually reproduced with
    syzkaller.
    
    This patch papers over it by protecting the link addition and deletion
    with the parent's mutex.  There is "access" mutex that is used for the
    file access, and this can be reused for this purpose as well.
    
    Reported-by: syzbot+48df349490c36f9f54ab@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 96a074019c33..0eb169acc850 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -713,8 +713,11 @@ snd_info_create_entry(const char *name, struct snd_info_entry *parent,
 	INIT_LIST_HEAD(&entry->list);
 	entry->parent = parent;
 	entry->module = module;
-	if (parent)
+	if (parent) {
+		mutex_lock(&parent->access);
 		list_add_tail(&entry->list, &parent->children);
+		mutex_unlock(&parent->access);
+	}
 	return entry;
 }
 
@@ -792,7 +795,12 @@ void snd_info_free_entry(struct snd_info_entry * entry)
 	list_for_each_entry_safe(p, n, &entry->children, list)
 		snd_info_free_entry(p);
 
-	list_del(&entry->list);
+	p = entry->parent;
+	if (p) {
+		mutex_lock(&p->access);
+		list_del(&entry->list);
+		mutex_unlock(&p->access);
+	}
 	kfree(entry->name);
 	if (entry->private_free)
 		entry->private_free(entry);

commit 29b2625ff605394ecd0b078e0cb67a151bb4d80c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 5 16:26:06 2019 +0100

    ALSA: info: Move card id proc creation into info.c
    
    The creation of card's id proc file can be moved gracefully into
    info.c.  Also, the assignment of card->proc_id is superfluous and can
    be dropped.  So let's do it.
    
    Basically this is no functional change but code refactoring, but one
    potential behavior change is that now it returns properly the error
    code from snd_info_card_register(), which is a good thing (tm).
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 7a4e733172ee..96a074019c33 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -504,6 +504,14 @@ int __exit snd_info_done(void)
 	return 0;
 }
 
+static void snd_card_id_read(struct snd_info_entry *entry,
+			     struct snd_info_buffer *buffer)
+{
+	struct snd_card *card = entry->private_data;
+
+	snd_iprintf(buffer, "%s\n", card->id);
+}
+
 /*
  * create a card proc file
  * called from init.c
@@ -521,7 +529,8 @@ int snd_info_card_create(struct snd_card *card)
 	if (!entry)
 		return -ENOMEM;
 	card->proc_root = entry;
-	return 0;
+
+	return snd_card_ro_proc_new(card, "id", card, snd_card_id_read);
 }
 
 /*

commit a858ee6655ca2f0fc6e2e5d426446bd898c92272
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 5 16:17:48 2019 +0100

    ALSA: info: Minor optimization
    
    Just a minor code optimization to reduce the source code size
    slightly.  No functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 4d23069e7928..7a4e733172ee 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -463,11 +463,12 @@ static struct snd_info_entry *create_subdir(struct module *mod,
 }
 
 static struct snd_info_entry *
-snd_info_create_entry(const char *name, struct snd_info_entry *parent);
+snd_info_create_entry(const char *name, struct snd_info_entry *parent,
+		      struct module *module);
 
 int __init snd_info_init(void)
 {
-	snd_proc_root = snd_info_create_entry("asound", NULL);
+	snd_proc_root = snd_info_create_entry("asound", NULL, THIS_MODULE);
 	if (!snd_proc_root)
 		return -ENOMEM;
 	snd_proc_root->mode = S_IFDIR | 0555;
@@ -684,7 +685,8 @@ EXPORT_SYMBOL(snd_info_get_str);
  * Return: The pointer of the new instance, or %NULL on failure.
  */
 static struct snd_info_entry *
-snd_info_create_entry(const char *name, struct snd_info_entry *parent)
+snd_info_create_entry(const char *name, struct snd_info_entry *parent,
+		      struct module *module)
 {
 	struct snd_info_entry *entry;
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
@@ -701,6 +703,7 @@ snd_info_create_entry(const char *name, struct snd_info_entry *parent)
 	INIT_LIST_HEAD(&entry->children);
 	INIT_LIST_HEAD(&entry->list);
 	entry->parent = parent;
+	entry->module = module;
 	if (parent)
 		list_add_tail(&entry->list, &parent->children);
 	return entry;
@@ -720,14 +723,9 @@ struct snd_info_entry *snd_info_create_module_entry(struct module * module,
 					       const char *name,
 					       struct snd_info_entry *parent)
 {
-	struct snd_info_entry *entry;
-
 	if (!parent)
 		parent = snd_proc_root;
-	entry = snd_info_create_entry(name, parent);
-	if (entry)
-		entry->module = module;
-	return entry;
+	return snd_info_create_entry(name, parent, module);
 }
 EXPORT_SYMBOL(snd_info_create_module_entry);
 
@@ -745,14 +743,9 @@ struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 					     const char *name,
 					     struct snd_info_entry * parent)
 {
-	struct snd_info_entry *entry;
-
 	if (!parent)
 		parent = card->proc_root;
-	entry = snd_info_create_entry(name, parent);
-	if (entry)
-		entry->module = card->module;
-	return entry;
+	return snd_info_create_entry(name, parent, card->module);
 }
 EXPORT_SYMBOL(snd_info_create_card_entry);
 

commit 9725752867cb158e076bcb6bc4bdb35d9710b1bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 5 16:10:00 2019 +0100

    ALSA: info: Drop unused snd_info_entry.card field
    
    It's referred only in snd_card_id_read() which can receive the card
    object via private_data.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 6c149fa54d2d..4d23069e7928 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -750,10 +750,8 @@ struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 	if (!parent)
 		parent = card->proc_root;
 	entry = snd_info_create_entry(name, parent);
-	if (entry) {
+	if (entry)
 		entry->module = card->module;
-		entry->card = card;
-	}
 	return entry;
 }
 EXPORT_SYMBOL(snd_info_create_card_entry);

commit 7453e1dafdec076f87384c8647d2960affd57ecc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 14:53:04 2019 +0100

    ALSA: info: Add standard helpers for card proc file entries
    
    Two new helper functions are added here for cleaning up the existing
    lengthy calls.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 5cd00629c0f5..6c149fa54d2d 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -866,6 +866,38 @@ int snd_info_register(struct snd_info_entry *entry)
 }
 EXPORT_SYMBOL(snd_info_register);
 
+/**
+ * snd_card_rw_proc_new - Create a read/write text proc file entry for the card
+ * @card: the card instance
+ * @name: the file name
+ * @private_data: the arbitrary private data
+ * @read: the read callback
+ * @write: the write callback, NULL for read-only
+ *
+ * This proc file entry will be registered via snd_card_register() call, and
+ * it will be removed automatically at the card removal, too.
+ */
+int snd_card_rw_proc_new(struct snd_card *card, const char *name,
+			 void *private_data,
+			 void (*read)(struct snd_info_entry *,
+				      struct snd_info_buffer *),
+			 void (*write)(struct snd_info_entry *entry,
+				       struct snd_info_buffer *buffer))
+{
+	struct snd_info_entry *entry;
+
+	entry = snd_info_create_card_entry(card, name, card->proc_root);
+	if (!entry)
+		return -ENOMEM;
+	snd_info_set_text_ops(entry, private_data, read);
+	if (write) {
+		entry->mode |= 0200;
+		entry->c.text.write = write;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_card_rw_proc_new);
+
 /*
 
  */

commit 348c5ad5d69cc0a3fb1f6e3f22787a9721e2a420
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 5 12:31:42 2019 +0100

    ALSA: info: Always register entries recursively
    
    Make sure that all children entries are registered by a single call of
    snd_info_register().  OTOH, don't register if a parent isn't
    registered yet.
    
    This allows us to create the whole procfs tree in a shot at the last
    stage of card registration phase in a later patch.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 2dfb6389c084..5cd00629c0f5 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -523,27 +523,6 @@ int snd_info_card_create(struct snd_card *card)
 	return 0;
 }
 
-/* register all pending info entries */
-static int snd_info_register_recursive(struct snd_info_entry *entry)
-{
-	struct snd_info_entry *p;
-	int err;
-
-	if (!entry->p) {
-		err = snd_info_register(entry);
-		if (err < 0)
-			return err;
-	}
-
-	list_for_each_entry(p, &entry->children, list) {
-		err = snd_info_register_recursive(p);
-		if (err < 0)
-			return err;
-	}
-
-	return 0;
-}
-
 /*
  * register the card proc file
  * called from init.c
@@ -557,7 +536,7 @@ int snd_info_card_register(struct snd_card *card)
 	if (snd_BUG_ON(!card))
 		return -ENXIO;
 
-	err = snd_info_register_recursive(card->proc_root);
+	err = snd_info_register(card->proc_root);
 	if (err < 0)
 		return err;
 
@@ -821,15 +800,7 @@ void snd_info_free_entry(struct snd_info_entry * entry)
 }
 EXPORT_SYMBOL(snd_info_free_entry);
 
-/**
- * snd_info_register - register the info entry
- * @entry: the info entry
- *
- * Registers the proc info entry.
- *
- * Return: Zero if successful, or a negative error code on failure.
- */
-int snd_info_register(struct snd_info_entry * entry)
+static int __snd_info_register(struct snd_info_entry *entry)
 {
 	struct proc_dir_entry *root, *p = NULL;
 
@@ -837,6 +808,8 @@ int snd_info_register(struct snd_info_entry * entry)
 		return -ENXIO;
 	root = entry->parent == NULL ? snd_proc_root->p : entry->parent->p;
 	mutex_lock(&info_mutex);
+	if (entry->p || !root)
+		goto unlock;
 	if (S_ISDIR(entry->mode)) {
 		p = proc_mkdir_mode(entry->name, entry->mode, root);
 		if (!p) {
@@ -858,9 +831,39 @@ int snd_info_register(struct snd_info_entry * entry)
 		proc_set_size(p, entry->size);
 	}
 	entry->p = p;
+ unlock:
 	mutex_unlock(&info_mutex);
 	return 0;
 }
+
+/**
+ * snd_info_register - register the info entry
+ * @entry: the info entry
+ *
+ * Registers the proc info entry.
+ * The all children entries are registered recursively.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_info_register(struct snd_info_entry *entry)
+{
+	struct snd_info_entry *p;
+	int err;
+
+	if (!entry->p) {
+		err = __snd_info_register(entry);
+		if (err < 0)
+			return err;
+	}
+
+	list_for_each_entry(p, &entry->children, list) {
+		err = snd_info_register(p);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
 EXPORT_SYMBOL(snd_info_register);
 
 /*

commit 3a55437141a1d287dead685b37fe240185144f15
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 23 17:59:40 2019 +0100

    ALSA: proc: Avoid possible leaks of snd_info_entry objects
    
    This patch changes the parent pointer assignment of snd_info_entry
    object to be always non-NULL.  More specifically,check the parent
    argument in snd_info_create_module_entry() & co, and assign
    snd_proc_root if NULL is passed there.
    
    This assures that the proc object is always freed when the root is
    freed, so avoid possible memory leaks.  For example, some error paths
    (e.g. snd_info_register() error at snd_minor_info_init()) may leave
    snd_info_entry object although the proc file itself is freed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index fe502bc5e6d2..2dfb6389c084 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -741,7 +741,11 @@ struct snd_info_entry *snd_info_create_module_entry(struct module * module,
 					       const char *name,
 					       struct snd_info_entry *parent)
 {
-	struct snd_info_entry *entry = snd_info_create_entry(name, parent);
+	struct snd_info_entry *entry;
+
+	if (!parent)
+		parent = snd_proc_root;
+	entry = snd_info_create_entry(name, parent);
 	if (entry)
 		entry->module = module;
 	return entry;
@@ -762,7 +766,11 @@ struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 					     const char *name,
 					     struct snd_info_entry * parent)
 {
-	struct snd_info_entry *entry = snd_info_create_entry(name, parent);
+	struct snd_info_entry *entry;
+
+	if (!parent)
+		parent = card->proc_root;
+	entry = snd_info_create_entry(name, parent);
 	if (entry) {
 		entry->module = card->module;
 		entry->card = card;

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 4b36767af9e1..fe502bc5e6d2 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -454,7 +454,7 @@ static struct snd_info_entry *create_subdir(struct module *mod,
 	entry = snd_info_create_module_entry(mod, name, NULL);
 	if (!entry)
 		return NULL;
-	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	entry->mode = S_IFDIR | 0555;
 	if (snd_info_register(entry) < 0) {
 		snd_info_free_entry(entry);
 		return NULL;
@@ -470,7 +470,7 @@ int __init snd_info_init(void)
 	snd_proc_root = snd_info_create_entry("asound", NULL);
 	if (!snd_proc_root)
 		return -ENOMEM;
-	snd_proc_root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	snd_proc_root->mode = S_IFDIR | 0555;
 	snd_proc_root->p = proc_mkdir("asound", NULL);
 	if (!snd_proc_root->p)
 		goto error;
@@ -716,7 +716,7 @@ snd_info_create_entry(const char *name, struct snd_info_entry *parent)
 		kfree(entry);
 		return NULL;
 	}
-	entry->mode = S_IFREG | S_IRUGO;
+	entry->mode = S_IFREG | 0444;
 	entry->content = SNDRV_INFO_CONTENT_TEXT;
 	mutex_init(&entry->access);
 	INIT_LIST_HEAD(&entry->children);

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index aa86f3f8e056..4b36767af9e1 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -214,9 +214,9 @@ static __poll_t snd_info_entry_poll(struct file *file, poll_table *wait)
 					  data->file_private_data,
 					  file, wait);
 	if (entry->c.ops->read)
-		mask |= POLLIN | POLLRDNORM;
+		mask |= EPOLLIN | EPOLLRDNORM;
 	if (entry->c.ops->write)
-		mask |= POLLOUT | POLLWRNORM;
+		mask |= EPOLLOUT | EPOLLWRNORM;
 	return mask;
 }
 

commit 680ef72abd84cbe0b722453d6be4e412305c9060
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 2 23:27:36 2017 -0400

    sound: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/info.c b/sound/core/info.c
index bcf6a48cc70d..aa86f3f8e056 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -203,11 +203,11 @@ static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer
 	return size;
 }
 
-static unsigned int snd_info_entry_poll(struct file *file, poll_table *wait)
+static __poll_t snd_info_entry_poll(struct file *file, poll_table *wait)
 {
 	struct snd_info_private_data *data = file->private_data;
 	struct snd_info_entry *entry = data->entry;
-	unsigned int mask = 0;
+	__poll_t mask = 0;
 
 	if (entry->c.ops->poll)
 		return entry->c.ops->poll(entry,

commit 35f8001415d301ba47124f463f98eee0e7d0792c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 16 16:16:33 2017 +0200

    ALSA: core: Follow standard EXPORT_SYMBOL() declarations
    
    Just a tidy up to follow the standard EXPORT_SYMBOL*() declarations
    in order to improve grep-ability.
    
    - Move EXPORT_SYMBOL*() to the position right after its definition
    - Remove superfluous blank line before EXPORT_SYMBOL*() lines
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index fc14ebe751d8..bcf6a48cc70d 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -652,7 +652,6 @@ int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 	*line = '\0';
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_info_get_line);
 
 /**
@@ -690,7 +689,6 @@ const char *snd_info_get_str(char *dest, const char *src, int len)
 		src++;
 	return src;
 }
-
 EXPORT_SYMBOL(snd_info_get_str);
 
 /*
@@ -748,7 +746,6 @@ struct snd_info_entry *snd_info_create_module_entry(struct module * module,
 		entry->module = module;
 	return entry;
 }
-
 EXPORT_SYMBOL(snd_info_create_module_entry);
 
 /**
@@ -772,7 +769,6 @@ struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 	}
 	return entry;
 }
-
 EXPORT_SYMBOL(snd_info_create_card_entry);
 
 static void snd_info_disconnect(struct snd_info_entry *entry)
@@ -815,7 +811,6 @@ void snd_info_free_entry(struct snd_info_entry * entry)
 		entry->private_free(entry);
 	kfree(entry);
 }
-
 EXPORT_SYMBOL(snd_info_free_entry);
 
 /**
@@ -858,7 +853,6 @@ int snd_info_register(struct snd_info_entry * entry)
 	mutex_unlock(&info_mutex);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_info_register);
 
 /*

commit ffb73b08e79418fbf3f2ea44a7818a6715399d2c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 22 17:39:13 2017 +0200

    ALSA: info: Use kvzalloc() for a temporary write buffer
    
    We used to use kmalloc (more exactly, krealloc()) for creating and
    growing the temporary buffer for text proc write.  It can grow up to
    16kB, and it's already a bit doubtful whether it's always safe to use
    kmalloc().  With the recent addition of kvmalloc(), we can have a
    better chance for succeed of memory allocation, so let's switch to
    that new API.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 8ab72e0f5932..fc14ebe751d8 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -344,12 +344,12 @@ static ssize_t snd_info_text_entry_write(struct file *file,
 		}
 	}
 	if (next > buf->len) {
-		char *nbuf = krealloc(buf->buffer, PAGE_ALIGN(next),
-				      GFP_KERNEL | __GFP_ZERO);
+		char *nbuf = kvzalloc(PAGE_ALIGN(next), GFP_KERNEL);
 		if (!nbuf) {
 			err = -ENOMEM;
 			goto error;
 		}
+		kvfree(buf->buffer);
 		buf->buffer = nbuf;
 		buf->len = PAGE_ALIGN(next);
 	}
@@ -427,7 +427,7 @@ static int snd_info_text_entry_release(struct inode *inode, struct file *file)
 	single_release(inode, file);
 	kfree(data->rbuffer);
 	if (data->wbuffer) {
-		kfree(data->wbuffer->buffer);
+		kvfree(data->wbuffer->buffer);
 		kfree(data->wbuffer);
 	}
 

commit 6809cd682b82dfff47943850d1a8c714f971b5ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Oct 30 22:13:19 2016 +0100

    ALSA: info: Return error for invalid read/write
    
    Currently the ALSA proc handler allows read or write even if the proc
    file were write-only or read-only.  It's mostly harmless, does thing
    but allocating memory and ignores the input/output.  But it doesn't
    tell user about the invalid use, and it's confusing and inconsistent
    in comparison with other proc files.
    
    This patch adds some sanity checks and let the proc handler returning
    an -EIO error when the invalid read/write is performed.
    
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 291d6ed80d80..8ab72e0f5932 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -325,6 +325,8 @@ static ssize_t snd_info_text_entry_write(struct file *file,
 	size_t next;
 	int err = 0;
 
+	if (!entry->c.text.write)
+		return -EIO;
 	pos = *offset;
 	if (!valid_pos(pos, count))
 		return -EIO;
@@ -369,7 +371,9 @@ static int snd_info_seq_show(struct seq_file *seq, void *p)
 	struct snd_info_private_data *data = seq->private;
 	struct snd_info_entry *entry = data->entry;
 
-	if (entry->c.text.read) {
+	if (!entry->c.text.read) {
+		return -EIO;
+	} else {
 		data->rbuffer->buffer = (char *)seq; /* XXX hack! */
 		entry->c.text.read(entry, data->rbuffer);
 	}

commit 027a9fe6835620422b6713892175716f3613dd9d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Oct 30 22:18:45 2016 +0100

    ALSA: info: Limit the proc text input size
    
    The ALSA proc handler allows currently the write in the unlimited size
    until kmalloc() fails.  But basically the write is supposed to be only
    for small inputs, mostly for one line inputs, and we don't have to
    handle too large sizes at all.  Since the kmalloc error results in the
    kernel warning, it's better to limit the size beforehand.
    
    This patch adds the limit of 16kB, which must be large enough for the
    currently existing code.
    
    Cc: stable@vger.kernel.org # v4.2+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 895362a696c9..291d6ed80d80 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -329,6 +329,9 @@ static ssize_t snd_info_text_entry_write(struct file *file,
 	if (!valid_pos(pos, count))
 		return -EIO;
 	next = pos + count;
+	/* don't handle too large text inputs */
+	if (next > 16 * 1024)
+		return -EIO;
 	mutex_lock(&entry->access);
 	buf = data->wbuffer;
 	if (!buf) {

commit c309c467edbe006f335af5947f89636bc5473a1b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 18 09:45:11 2015 +0200

    ALSA: info: Drop kerneldoc comment from snd_info_create_entry()
    
    It's no longer a part of API but merely a local function.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 76cdf1d21f17..895362a696c9 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -686,7 +686,7 @@ const char *snd_info_get_str(char *dest, const char *src, int len)
 
 EXPORT_SYMBOL(snd_info_get_str);
 
-/**
+/*
  * snd_info_create_entry - create an info entry
  * @name: the proc file name
  * @parent: the parent directory

commit 8e7ccb7ba3b67245e7be0cadbdd2aaf4a3ba1f40
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 18 09:43:30 2015 +0200

    ALSA: info: Move list addition to snd_info_create_entry()
    
    Just a minor refactoring, no functional changes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 13b174464cc8..76cdf1d21f17 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -455,11 +455,12 @@ static struct snd_info_entry *create_subdir(struct module *mod,
 	return entry;
 }
 
-static struct snd_info_entry *snd_info_create_entry(const char *name);
+static struct snd_info_entry *
+snd_info_create_entry(const char *name, struct snd_info_entry *parent);
 
 int __init snd_info_init(void)
 {
-	snd_proc_root = snd_info_create_entry("asound");
+	snd_proc_root = snd_info_create_entry("asound", NULL);
 	if (!snd_proc_root)
 		return -ENOMEM;
 	snd_proc_root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
@@ -688,6 +689,7 @@ EXPORT_SYMBOL(snd_info_get_str);
 /**
  * snd_info_create_entry - create an info entry
  * @name: the proc file name
+ * @parent: the parent directory
  *
  * Creates an info entry with the given file name and initializes as
  * the default state.
@@ -697,7 +699,8 @@ EXPORT_SYMBOL(snd_info_get_str);
  *
  * Return: The pointer of the new instance, or %NULL on failure.
  */
-static struct snd_info_entry *snd_info_create_entry(const char *name)
+static struct snd_info_entry *
+snd_info_create_entry(const char *name, struct snd_info_entry *parent)
 {
 	struct snd_info_entry *entry;
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
@@ -713,6 +716,9 @@ static struct snd_info_entry *snd_info_create_entry(const char *name)
 	mutex_init(&entry->access);
 	INIT_LIST_HEAD(&entry->children);
 	INIT_LIST_HEAD(&entry->list);
+	entry->parent = parent;
+	if (parent)
+		list_add_tail(&entry->list, &parent->children);
 	return entry;
 }
 
@@ -730,13 +736,9 @@ struct snd_info_entry *snd_info_create_module_entry(struct module * module,
 					       const char *name,
 					       struct snd_info_entry *parent)
 {
-	struct snd_info_entry *entry = snd_info_create_entry(name);
-	if (entry) {
+	struct snd_info_entry *entry = snd_info_create_entry(name, parent);
+	if (entry)
 		entry->module = module;
-		entry->parent = parent;
-		if (parent)
-			list_add_tail(&entry->list, &parent->children);
-	}
 	return entry;
 }
 
@@ -756,13 +758,10 @@ struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 					     const char *name,
 					     struct snd_info_entry * parent)
 {
-	struct snd_info_entry *entry = snd_info_create_entry(name);
+	struct snd_info_entry *entry = snd_info_create_entry(name, parent);
 	if (entry) {
 		entry->module = card->module;
 		entry->card = card;
-		entry->parent = parent;
-		if (parent)
-			list_add_tail(&entry->list, &parent->children);
 	}
 	return entry;
 }

commit 2471b6c80a70e80de69f5ff4c37187c3912e5874
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 18 09:20:24 2015 +0200

    ALSA: info: Register proc entries recursively, too
    
    The commit [c560a6797e3b: ALSA: core: Remove child proc file elements
    recursively] converted snd_card_proc_new() with the normal
    snd_info_*() call and removed snd_device chain for such info
    entries. However, it misses one point: the creation of the proc entry
    was managed by snd_device chain in the former code, and now it's also
    gone, which results in no proc files creation at all.  Mea culpa.
    
    This patch makes snd_info_card_register() creating the all pending
    child proc entries in a shot.  Also, since snd_card_register() might
    be called multiple times, this function is also changed to be callable
    multiple times.
    
    Along with the changes above, now the linked list of snd_info_entry is
    added at creation time instead of snd_info_register() for keeping eyes
    of pending info entries.
    
    Fixes: c560a6797e3b ('ALSA: core: Remove child proc file elements recursively')
    Reported-by: "Lu, Han" <han.lu@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 566279374683..13b174464cc8 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -515,22 +515,51 @@ int snd_info_card_create(struct snd_card *card)
 	return 0;
 }
 
+/* register all pending info entries */
+static int snd_info_register_recursive(struct snd_info_entry *entry)
+{
+	struct snd_info_entry *p;
+	int err;
+
+	if (!entry->p) {
+		err = snd_info_register(entry);
+		if (err < 0)
+			return err;
+	}
+
+	list_for_each_entry(p, &entry->children, list) {
+		err = snd_info_register_recursive(p);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
 /*
  * register the card proc file
  * called from init.c
+ * can be called multiple times for reinitialization
  */
 int snd_info_card_register(struct snd_card *card)
 {
 	struct proc_dir_entry *p;
+	int err;
 
 	if (snd_BUG_ON(!card))
 		return -ENXIO;
 
+	err = snd_info_register_recursive(card->proc_root);
+	if (err < 0)
+		return err;
+
 	if (!strcmp(card->id, card->proc_root->name))
 		return 0;
 
+	if (card->proc_root_link)
+		return 0;
 	p = proc_symlink(card->id, snd_proc_root->p, card->proc_root->name);
-	if (p == NULL)
+	if (!p)
 		return -ENOMEM;
 	card->proc_root_link = p;
 	return 0;
@@ -705,6 +734,8 @@ struct snd_info_entry *snd_info_create_module_entry(struct module * module,
 	if (entry) {
 		entry->module = module;
 		entry->parent = parent;
+		if (parent)
+			list_add_tail(&entry->list, &parent->children);
 	}
 	return entry;
 }
@@ -730,6 +761,8 @@ struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 		entry->module = card->module;
 		entry->card = card;
 		entry->parent = parent;
+		if (parent)
+			list_add_tail(&entry->list, &parent->children);
 	}
 	return entry;
 }
@@ -816,8 +849,6 @@ int snd_info_register(struct snd_info_entry * entry)
 		proc_set_size(p, entry->size);
 	}
 	entry->p = p;
-	if (entry->parent)
-		list_add_tail(&entry->list, &entry->parent->children);
 	mutex_unlock(&info_mutex);
 	return 0;
 }

commit 90a409aad45dedc41129e0ec257b41de901b8897
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 18 08:59:12 2015 +0200

    ALSA: info: Fix leaks of child entries at snd_info_free_entry()
    
    snd_info_free_entry() releases the all children nodes as well, but due
    to the wrong timing of releasing the link, the children nodes may be
    disconnected but left unreleased.  This patch fixes it by moving the
    link free at the right position.  Also it eases list_for_each_entry()
    without _safe option in snd_info_disconnect() because it no longer
    frees the children nodes there.
    
    Fixes: c560a6797e3b ('ALSA: core: Remove child proc file elements recursively')
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index c8a413d6cc9b..566279374683 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -738,13 +738,12 @@ EXPORT_SYMBOL(snd_info_create_card_entry);
 
 static void snd_info_disconnect(struct snd_info_entry *entry)
 {
-	struct snd_info_entry *p, *n;
+	struct snd_info_entry *p;
 
 	if (!entry->p)
 		return;
-	list_for_each_entry_safe(p, n, &entry->children, list)
+	list_for_each_entry(p, &entry->children, list)
 		snd_info_disconnect(p);
-	list_del_init(&entry->list);
 	proc_remove(entry->p);
 	entry->p = NULL;
 }
@@ -771,6 +770,7 @@ void snd_info_free_entry(struct snd_info_entry * entry)
 	list_for_each_entry_safe(p, n, &entry->children, list)
 		snd_info_free_entry(p);
 
+	list_del(&entry->list);
 	kfree(entry->name);
 	if (entry->private_free)
 		entry->private_free(entry);

commit a0dca822e923e605dbdc2f6ed4fcd96b74df9258
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 23 10:56:21 2015 +0200

    ALSA: core: Clean up OSS proc file management
    
    A few minor cleanups:
    - Move the call of snd_info_minor_register() into snd_info_init() so
      that we can call all proc-related stuff in a shot
    - Add missing __init prefix to snd_info_minor_register()
    - Return an error properly from snd_oss_info_register()
    - Drop snd_info_minor_unregister() that is superfluous now
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index f8bdd9b6f322..c8a413d6cc9b 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -479,7 +479,8 @@ int __init snd_info_init(void)
 	if (snd_info_version_init() < 0 ||
 	    snd_minor_info_init() < 0 ||
 	    snd_minor_info_oss_init() < 0 ||
-	    snd_card_info_init() < 0)
+	    snd_card_info_init() < 0 ||
+	    snd_info_minor_register() < 0)
 		goto error;
 	return 0;
 

commit 85d143180738475b89d76b18409c3125b01464e1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 23 10:34:34 2015 +0200

    ALSA: core: Build conditionally and remove superfluous ifdefs
    
    Minor cleanups of Makefile to build some codes conditionally so that
    a few ifdefs can be reduced.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 4169062fabf5..f8bdd9b6f322 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -33,12 +33,6 @@
 #include <linux/mutex.h>
 #include <stdarg.h>
 
-/*
- *
- */
-
-#ifdef CONFIG_PROC_FS
-
 int snd_info_check_reserved_words(const char *str)
 {
 	static char *reserved[] =
@@ -850,5 +844,3 @@ static int __init snd_info_version_init(void)
 	entry->c.text.read = snd_info_version_read;
 	return snd_info_register(entry); /* freed in error path */
 }
-
-#endif /* CONFIG_PROC_FS */

commit b591b6e9e99017137888e2e397f0ddd8adb77c5d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 22:29:10 2015 +0200

    ALSA: core: Don't ignore errors at creating proc files
    
    So far we've ignored the errors at creating proc files in many places.
    But they should be rather treated seriously.
    
    Also, by assuring the error handling, we can get rid of superfluous
    snd_info_free_entry() calls as they will be removed by the parent in
    the caller side.
    
    This patch fixes the missing error checks and reduces the superfluous
    free calls.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 339f90a3aa29..4169062fabf5 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -482,10 +482,11 @@ int __init snd_info_init(void)
 	if (!snd_seq_root)
 		goto error;
 #endif
-	snd_info_version_init();
-	snd_minor_info_init();
-	snd_minor_info_oss_init();
-	snd_card_info_init();
+	if (snd_info_version_init() < 0 ||
+	    snd_minor_info_init() < 0 ||
+	    snd_minor_info_oss_init() < 0 ||
+	    snd_card_info_init() < 0)
+		goto error;
 	return 0;
 
  error:
@@ -847,11 +848,7 @@ static int __init snd_info_version_init(void)
 	if (entry == NULL)
 		return -ENOMEM;
 	entry->c.text.read = snd_info_version_read;
-	if (snd_info_register(entry) < 0) {
-		snd_info_free_entry(entry);
-		return -ENOMEM;
-	}
-	return 0;
+	return snd_info_register(entry); /* freed in error path */
 }
 
 #endif /* CONFIG_PROC_FS */

commit b046d244e2290e3d114af2e91503ee3d08fc605a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 21:33:41 2015 +0200

    ALSA: core: Remove superfluous exit calls for proc entries
    
    Since each proc entry is freed automatically by the parent, we don't
    have to take care of its life cycle any longer.  This allows us to
    reduce a few more lines of codes.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 55c626eeb061..339f90a3aa29 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -495,9 +495,6 @@ int __init snd_info_init(void)
 
 int __exit snd_info_done(void)
 {
-	snd_card_info_done();
-	snd_minor_info_oss_done();
-	snd_minor_info_done();
 	snd_info_free_entry(snd_proc_root);
 	return 0;
 }

commit 644dbd64dcf0939e9838132a72d2ec9489496eb8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 22:14:41 2015 +0200

    ALSA: core: Manage asound root directory with snd_info_entry
    
    Using snd_info_entry for /proc/asound root makes easier to release the
    all children, too.  Further cleanups will follow.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 96451a130199..55c626eeb061 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -78,14 +78,13 @@ struct snd_info_private_data {
 };
 
 static int snd_info_version_init(void);
-static int snd_info_version_done(void);
 static void snd_info_disconnect(struct snd_info_entry *entry);
 
 /*
 
  */
 
-static struct proc_dir_entry *snd_proc_root;
+static struct snd_info_entry *snd_proc_root;
 struct snd_info_entry *snd_seq_root;
 EXPORT_SYMBOL(snd_seq_root);
 
@@ -462,14 +461,17 @@ static struct snd_info_entry *create_subdir(struct module *mod,
 	return entry;
 }
 
+static struct snd_info_entry *snd_info_create_entry(const char *name);
+
 int __init snd_info_init(void)
 {
-	struct proc_dir_entry *p;
-
-	p = proc_mkdir("asound", NULL);
-	if (p == NULL)
+	snd_proc_root = snd_info_create_entry("asound");
+	if (!snd_proc_root)
 		return -ENOMEM;
-	snd_proc_root = p;
+	snd_proc_root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	snd_proc_root->p = proc_mkdir("asound", NULL);
+	if (!snd_proc_root->p)
+		goto error;
 #ifdef CONFIG_SND_OSSEMUL
 	snd_oss_root = create_subdir(THIS_MODULE, "oss");
 	if (!snd_oss_root)
@@ -487,10 +489,7 @@ int __init snd_info_init(void)
 	return 0;
 
  error:
-#ifdef CONFIG_SND_OSSEMUL
-	snd_info_free_entry(snd_oss_root);
-#endif
-	proc_remove(snd_proc_root);
+	snd_info_free_entry(snd_proc_root);
 	return -ENOMEM;
 }
 
@@ -499,24 +498,10 @@ int __exit snd_info_done(void)
 	snd_card_info_done();
 	snd_minor_info_oss_done();
 	snd_minor_info_done();
-	snd_info_version_done();
-	if (snd_proc_root) {
-#if IS_ENABLED(CONFIG_SND_SEQUENCER)
-		snd_info_free_entry(snd_seq_root);
-#endif
-#ifdef CONFIG_SND_OSSEMUL
-		snd_info_free_entry(snd_oss_root);
-#endif
-		proc_remove(snd_proc_root);
-	}
+	snd_info_free_entry(snd_proc_root);
 	return 0;
 }
 
-/*
-
- */
-
-
 /*
  * create a card proc file
  * called from init.c
@@ -551,7 +536,7 @@ int snd_info_card_register(struct snd_card *card)
 	if (!strcmp(card->id, card->proc_root->name))
 		return 0;
 
-	p = proc_symlink(card->id, snd_proc_root, card->proc_root->name);
+	p = proc_symlink(card->id, snd_proc_root->p, card->proc_root->name);
 	if (p == NULL)
 		return -ENOMEM;
 	card->proc_root_link = p;
@@ -570,7 +555,7 @@ void snd_info_card_id_change(struct snd_card *card)
 	}
 	if (strcmp(card->id, card->proc_root->name))
 		card->proc_root_link = proc_symlink(card->id,
-						    snd_proc_root,
+						    snd_proc_root->p,
 						    card->proc_root->name);
 	mutex_unlock(&info_mutex);
 }
@@ -815,7 +800,7 @@ int snd_info_register(struct snd_info_entry * entry)
 
 	if (snd_BUG_ON(!entry))
 		return -ENXIO;
-	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
+	root = entry->parent == NULL ? snd_proc_root->p : entry->parent->p;
 	mutex_lock(&info_mutex);
 	if (S_ISDIR(entry->mode)) {
 		p = proc_mkdir_mode(entry->name, entry->mode, root);
@@ -850,8 +835,6 @@ EXPORT_SYMBOL(snd_info_register);
 
  */
 
-static struct snd_info_entry *snd_info_version_entry;
-
 static void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	snd_iprintf(buffer,
@@ -871,13 +854,6 @@ static int __init snd_info_version_init(void)
 		snd_info_free_entry(entry);
 		return -ENOMEM;
 	}
-	snd_info_version_entry = entry;
-	return 0;
-}
-
-static int __exit snd_info_version_done(void)
-{
-	snd_info_free_entry(snd_info_version_entry);
 	return 0;
 }
 

commit c560a6797e3bec1e04f1f6f9f3c2135db0f5c8ee
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 18:26:38 2015 +0200

    ALSA: core: Remove child proc file elements recursively
    
    This patch changes the way to manage the resource release of proc
    files: namely, let snd_info_free_entry() freeing the whole children.
    
    This makes it us possible to drop the snd_device_*() management.  Then
    snd_card_proc_new() becomes merely a wrapper to
    snd_info_create_card_entry().
    
    Together with this change, now you need to call snd_info_free_entry()
    for a proc entry created via snd_card_proc_new(), while it was freed
    via snd_device_free() beforehand.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 9c6db5c24da7..96451a130199 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -760,92 +760,39 @@ EXPORT_SYMBOL(snd_info_create_card_entry);
 
 static void snd_info_disconnect(struct snd_info_entry *entry)
 {
-	struct list_head *p, *n;
+	struct snd_info_entry *p, *n;
 
-	list_for_each_safe(p, n, &entry->children) {
-		snd_info_disconnect(list_entry(p, struct snd_info_entry, list));
-	}
-
-	if (! entry->p)
+	if (!entry->p)
 		return;
+	list_for_each_entry_safe(p, n, &entry->children, list)
+		snd_info_disconnect(p);
 	list_del_init(&entry->list);
 	proc_remove(entry->p);
 	entry->p = NULL;
 }
 
-static int snd_info_dev_free_entry(struct snd_device *device)
-{
-	struct snd_info_entry *entry = device->device_data;
-	snd_info_free_entry(entry);
-	return 0;
-}
-
-static int snd_info_dev_register_entry(struct snd_device *device)
-{
-	struct snd_info_entry *entry = device->device_data;
-	return snd_info_register(entry);
-}
-
-/**
- * snd_card_proc_new - create an info entry for the given card
- * @card: the card instance
- * @name: the file name
- * @entryp: the pointer to store the new info entry
- *
- * Creates a new info entry and assigns it to the given card.
- * Unlike snd_info_create_card_entry(), this function registers the
- * info entry as an ALSA device component, so that it can be
- * unregistered/released without explicit call.
- * Also, you don't have to register this entry via snd_info_register(),
- * since this will be registered by snd_card_register() automatically.
- *
- * The parent is assumed as card->proc_root.
- *
- * For releasing this entry, use snd_device_free() instead of
- * snd_info_free_entry(). 
- *
- * Return: Zero if successful, or a negative error code on failure.
- */
-int snd_card_proc_new(struct snd_card *card, const char *name,
-		      struct snd_info_entry **entryp)
-{
-	static struct snd_device_ops ops = {
-		.dev_free = snd_info_dev_free_entry,
-		.dev_register =	snd_info_dev_register_entry,
-		/* disconnect is done via snd_info_card_disconnect() */
-	};
-	struct snd_info_entry *entry;
-	int err;
-
-	entry = snd_info_create_card_entry(card, name, card->proc_root);
-	if (! entry)
-		return -ENOMEM;
-	if ((err = snd_device_new(card, SNDRV_DEV_INFO, entry, &ops)) < 0) {
-		snd_info_free_entry(entry);
-		return err;
-	}
-	if (entryp)
-		*entryp = entry;
-	return 0;
-}
-
-EXPORT_SYMBOL(snd_card_proc_new);
-
 /**
  * snd_info_free_entry - release the info entry
  * @entry: the info entry
  *
- * Releases the info entry.  Don't call this after registered.
+ * Releases the info entry.
  */
 void snd_info_free_entry(struct snd_info_entry * entry)
 {
-	if (entry == NULL)
+	struct snd_info_entry *p, *n;
+
+	if (!entry)
 		return;
 	if (entry->p) {
 		mutex_lock(&info_mutex);
 		snd_info_disconnect(entry);
 		mutex_unlock(&info_mutex);
 	}
+
+	/* free all children at first */
+	list_for_each_entry_safe(p, n, &entry->children, list)
+		snd_info_free_entry(p);
+
 	kfree(entry->name);
 	if (entry->private_free)
 		entry->private_free(entry);

commit 886364f679342a381c9cb4a0b2588fb103bb6a22
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 17:54:25 2015 +0200

    ALSA: core: Fix possible memory leaks at error path in info.c
    
    Currently, snd_info_init() just returns an error without releasing the
    previously assigned resources at error path.  The assigned proc and
    info entries have to be released properly.  This patch covers it.
    
    While we are at it, refactor the code a bit, too.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 8c1275f0fcbd..9c6db5c24da7 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -446,6 +446,22 @@ static const struct file_operations snd_info_text_entry_ops =
 	.read =			seq_read,
 };
 
+static struct snd_info_entry *create_subdir(struct module *mod,
+					    const char *name)
+{
+	struct snd_info_entry *entry;
+
+	entry = snd_info_create_module_entry(mod, name, NULL);
+	if (!entry)
+		return NULL;
+	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		return NULL;
+	}
+	return entry;
+}
+
 int __init snd_info_init(void)
 {
 	struct proc_dir_entry *p;
@@ -455,36 +471,27 @@ int __init snd_info_init(void)
 		return -ENOMEM;
 	snd_proc_root = p;
 #ifdef CONFIG_SND_OSSEMUL
-	{
-		struct snd_info_entry *entry;
-		if ((entry = snd_info_create_module_entry(THIS_MODULE, "oss", NULL)) == NULL)
-			return -ENOMEM;
-		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			return -ENOMEM;
-		}
-		snd_oss_root = entry;
-	}
+	snd_oss_root = create_subdir(THIS_MODULE, "oss");
+	if (!snd_oss_root)
+		goto error;
 #endif
 #if IS_ENABLED(CONFIG_SND_SEQUENCER)
-	{
-		struct snd_info_entry *entry;
-		if ((entry = snd_info_create_module_entry(THIS_MODULE, "seq", NULL)) == NULL)
-			return -ENOMEM;
-		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			return -ENOMEM;
-		}
-		snd_seq_root = entry;
-	}
+	snd_seq_root = create_subdir(THIS_MODULE, "seq");
+	if (!snd_seq_root)
+		goto error;
 #endif
 	snd_info_version_init();
 	snd_minor_info_init();
 	snd_minor_info_oss_init();
 	snd_card_info_init();
 	return 0;
+
+ error:
+#ifdef CONFIG_SND_OSSEMUL
+	snd_info_free_entry(snd_oss_root);
+#endif
+	proc_remove(snd_proc_root);
+	return -ENOMEM;
 }
 
 int __exit snd_info_done(void)
@@ -523,13 +530,9 @@ int snd_info_card_create(struct snd_card *card)
 		return -ENXIO;
 
 	sprintf(str, "card%i", card->number);
-	if ((entry = snd_info_create_module_entry(card->module, str, NULL)) == NULL)
-		return -ENOMEM;
-	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
-	if (snd_info_register(entry) < 0) {
-		snd_info_free_entry(entry);
+	entry = create_subdir(card->module, str);
+	if (!entry)
 		return -ENOMEM;
-	}
 	card->proc_root = entry;
 	return 0;
 }
@@ -758,7 +761,6 @@ EXPORT_SYMBOL(snd_info_create_card_entry);
 static void snd_info_disconnect(struct snd_info_entry *entry)
 {
 	struct list_head *p, *n;
-	struct proc_dir_entry *root;
 
 	list_for_each_safe(p, n, &entry->children) {
 		snd_info_disconnect(list_entry(p, struct snd_info_entry, list));
@@ -767,8 +769,6 @@ static void snd_info_disconnect(struct snd_info_entry *entry)
 	if (! entry->p)
 		return;
 	list_del_init(&entry->list);
-	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
-	snd_BUG_ON(!root);
 	proc_remove(entry->p);
 	entry->p = NULL;
 }

commit 4adb7bcbcb69d3bee0ed72de83adaee27daccdd8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 16:10:22 2015 +0200

    ALSA: core: Use seq_file for text proc file reads
    
    seq_file is _the_ standard interface for simple text proc files.
    Though, we still need to support the binary proc files and the text
    file write, and also we need to manage the device disconnection
    gracefully.  Thus this patch just replaces the text file read code
    with seq_file while keeping the rest intact.
    
    snd_iprintf() helper function is now a macro to expand itself to
    seq_printf() to be compatible with the existing code.  The seq_file
    object is stored to the unused entry->rbuffer->buffer pointer.
    
    When the output size is expected to be large (greater than PAGE_SIZE),
    the driver should set entry->size field beforehand.  Then the given
    size will be preallocated and the multiple show calls can be avoided.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 9f404e965ea2..8c1275f0fcbd 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -81,66 +81,6 @@ static int snd_info_version_init(void);
 static int snd_info_version_done(void);
 static void snd_info_disconnect(struct snd_info_entry *entry);
 
-
-/* resize the proc r/w buffer */
-static int resize_info_buffer(struct snd_info_buffer *buffer,
-			      unsigned int nsize)
-{
-	char *nbuf;
-
-	nsize = PAGE_ALIGN(nsize);
-	nbuf = krealloc(buffer->buffer, nsize, GFP_KERNEL | __GFP_ZERO);
-	if (! nbuf)
-		return -ENOMEM;
-
-	buffer->buffer = nbuf;
-	buffer->len = nsize;
-	return 0;
-}
-
-/**
- * snd_iprintf - printf on the procfs buffer
- * @buffer: the procfs buffer
- * @fmt: the printf format
- *
- * Outputs the string on the procfs buffer just like printf().
- *
- * Return: The size of output string, or a negative error code.
- */
-int snd_iprintf(struct snd_info_buffer *buffer, const char *fmt, ...)
-{
-	va_list args;
-	int len, res;
-	int err = 0;
-
-	might_sleep();
-	if (buffer->stop || buffer->error)
-		return 0;
-	len = buffer->len - buffer->size;
-	va_start(args, fmt);
-	for (;;) {
-		va_list ap;
-		va_copy(ap, args);
-		res = vsnprintf(buffer->buffer + buffer->curr, len, fmt, ap);
-		va_end(ap);
-		if (res < len)
-			break;
-		err = resize_info_buffer(buffer, buffer->len + PAGE_SIZE);
-		if (err < 0)
-			break;
-		len = buffer->len - buffer->size;
-	}
-	va_end(args);
-
-	if (err < 0)
-		return err;
-	buffer->curr += res;
-	buffer->size += res;
-	return res;
-}
-
-EXPORT_SYMBOL(snd_iprintf);
-
 /*
 
  */
@@ -153,6 +93,37 @@ EXPORT_SYMBOL(snd_seq_root);
 struct snd_info_entry *snd_oss_root;
 #endif
 
+static int alloc_info_private(struct snd_info_entry *entry,
+			      struct snd_info_private_data **ret)
+{
+	struct snd_info_private_data *data;
+
+	if (!entry || !entry->p)
+		return -ENODEV;
+	if (!try_module_get(entry->module))
+		return -EFAULT;
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		module_put(entry->module);
+		return -ENOMEM;
+	}
+	data->entry = entry;
+	*ret = data;
+	return 0;
+}
+
+static bool valid_pos(loff_t pos, size_t count)
+{
+	if (pos < 0 || (long) pos != pos || (ssize_t) count < 0)
+		return false;
+	if ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)
+		return false;
+	return true;
+}
+
+/*
+ * file ops for binary proc files
+ */
 static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 {
 	struct snd_info_private_data *data;
@@ -162,17 +133,14 @@ static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 	data = file->private_data;
 	entry = data->entry;
 	mutex_lock(&entry->access);
-	if (entry->content == SNDRV_INFO_CONTENT_DATA &&
-	    entry->c.ops->llseek) {
+	if (entry->c.ops->llseek) {
 		offset = entry->c.ops->llseek(entry,
 					      data->file_private_data,
 					      file, offset, orig);
 		goto out;
 	}
-	if (entry->content == SNDRV_INFO_CONTENT_DATA)
-		size = entry->size;
-	else
-		size = 0;
+
+	size = entry->size;
 	switch (orig) {
 	case SEEK_SET:
 		break;
@@ -201,45 +169,20 @@ static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 static ssize_t snd_info_entry_read(struct file *file, char __user *buffer,
 				   size_t count, loff_t * offset)
 {
-	struct snd_info_private_data *data;
-	struct snd_info_entry *entry;
-	struct snd_info_buffer *buf;
-	size_t size = 0;
+	struct snd_info_private_data *data = file->private_data;
+	struct snd_info_entry *entry = data->entry;
+	size_t size;
 	loff_t pos;
 
-	data = file->private_data;
-	if (snd_BUG_ON(!data))
-		return -ENXIO;
 	pos = *offset;
-	if (pos < 0 || (long) pos != pos || (ssize_t) count < 0)
-		return -EIO;
-	if ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)
+	if (!valid_pos(pos, count))
 		return -EIO;
-	entry = data->entry;
-	switch (entry->content) {
-	case SNDRV_INFO_CONTENT_TEXT:
-		buf = data->rbuffer;
-		if (buf == NULL)
-			return -EIO;
-		if (pos >= buf->size)
-			return 0;
-		size = buf->size - pos;
-		size = min(count, size);
-		if (copy_to_user(buffer, buf->buffer + pos, size))
-			return -EFAULT;
-		break;
-	case SNDRV_INFO_CONTENT_DATA:
-		if (pos >= entry->size)
-			return 0;
-		if (entry->c.ops->read) {
-			size = entry->size - pos;
-			size = min(count, size);
-			size = entry->c.ops->read(entry,
-						  data->file_private_data,
-						  file, buffer, size, pos);
-		}
-		break;
-	}
+	if (pos >= entry->size)
+		return 0;
+	size = entry->size - pos;
+	size = min(count, size);
+	size = entry->c.ops->read(entry, data->file_private_data,
+				  file, buffer, size, pos);
 	if ((ssize_t) size > 0)
 		*offset = pos + size;
 	return size;
@@ -248,280 +191,259 @@ static ssize_t snd_info_entry_read(struct file *file, char __user *buffer,
 static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer,
 				    size_t count, loff_t * offset)
 {
-	struct snd_info_private_data *data;
-	struct snd_info_entry *entry;
-	struct snd_info_buffer *buf;
+	struct snd_info_private_data *data = file->private_data;
+	struct snd_info_entry *entry = data->entry;
 	ssize_t size = 0;
 	loff_t pos;
 
-	data = file->private_data;
-	if (snd_BUG_ON(!data))
-		return -ENXIO;
-	entry = data->entry;
 	pos = *offset;
-	if (pos < 0 || (long) pos != pos || (ssize_t) count < 0)
+	if (!valid_pos(pos, count))
 		return -EIO;
-	if ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)
-		return -EIO;
-	switch (entry->content) {
-	case SNDRV_INFO_CONTENT_TEXT:
-		buf = data->wbuffer;
-		if (buf == NULL)
-			return -EIO;
-		mutex_lock(&entry->access);
-		if (pos + count >= buf->len) {
-			if (resize_info_buffer(buf, pos + count)) {
-				mutex_unlock(&entry->access);
-				return -ENOMEM;
-			}
-		}
-		if (copy_from_user(buf->buffer + pos, buffer, count)) {
-			mutex_unlock(&entry->access);
-			return -EFAULT;
-		}
-		buf->size = pos + count;
-		mutex_unlock(&entry->access);
-		size = count;
-		break;
-	case SNDRV_INFO_CONTENT_DATA:
-		if (entry->c.ops->write && count > 0) {
-			size_t maxsize = entry->size - pos;
-			count = min(count, maxsize);
-			size = entry->c.ops->write(entry,
-						   data->file_private_data,
-						   file, buffer, count, pos);
-		}
-		break;
+	if (count > 0) {
+		size_t maxsize = entry->size - pos;
+		count = min(count, maxsize);
+		size = entry->c.ops->write(entry, data->file_private_data,
+					   file, buffer, count, pos);
 	}
-	if ((ssize_t) size > 0)
+	if (size > 0)
 		*offset = pos + size;
 	return size;
 }
 
-static int snd_info_entry_open(struct inode *inode, struct file *file)
+static unsigned int snd_info_entry_poll(struct file *file, poll_table *wait)
+{
+	struct snd_info_private_data *data = file->private_data;
+	struct snd_info_entry *entry = data->entry;
+	unsigned int mask = 0;
+
+	if (entry->c.ops->poll)
+		return entry->c.ops->poll(entry,
+					  data->file_private_data,
+					  file, wait);
+	if (entry->c.ops->read)
+		mask |= POLLIN | POLLRDNORM;
+	if (entry->c.ops->write)
+		mask |= POLLOUT | POLLWRNORM;
+	return mask;
+}
+
+static long snd_info_entry_ioctl(struct file *file, unsigned int cmd,
+				unsigned long arg)
+{
+	struct snd_info_private_data *data = file->private_data;
+	struct snd_info_entry *entry = data->entry;
+
+	if (!entry->c.ops->ioctl)
+		return -ENOTTY;
+	return entry->c.ops->ioctl(entry, data->file_private_data,
+				   file, cmd, arg);
+}
+
+static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
 {
+	struct inode *inode = file_inode(file);
+	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
+
+	data = file->private_data;
+	if (data == NULL)
+		return 0;
+	entry = data->entry;
+	if (!entry->c.ops->mmap)
+		return -ENXIO;
+	return entry->c.ops->mmap(entry, data->file_private_data,
+				  inode, file, vma);
+}
+
+static int snd_info_entry_open(struct inode *inode, struct file *file)
+{
+	struct snd_info_entry *entry = PDE_DATA(inode);
 	struct snd_info_private_data *data;
-	struct snd_info_buffer *buffer;
 	int mode, err;
 
 	mutex_lock(&info_mutex);
-	entry = PDE_DATA(inode);
-	if (entry == NULL || ! entry->p) {
-		mutex_unlock(&info_mutex);
-		return -ENODEV;
-	}
-	if (!try_module_get(entry->module)) {
-		err = -EFAULT;
-		goto __error1;
-	}
+	err = alloc_info_private(entry, &data);
+	if (err < 0)
+		goto unlock;
+
 	mode = file->f_flags & O_ACCMODE;
-	if (mode == O_RDONLY || mode == O_RDWR) {
-		if ((entry->content == SNDRV_INFO_CONTENT_DATA &&
-		     entry->c.ops->read == NULL)) {
-		    	err = -ENODEV;
-		    	goto __error;
-		}
-	}
-	if (mode == O_WRONLY || mode == O_RDWR) {
-		if ((entry->content == SNDRV_INFO_CONTENT_DATA &&
-		     entry->c.ops->write == NULL)) {
-		    	err = -ENODEV;
-		    	goto __error;
-		}
+	if (((mode == O_RDONLY || mode == O_RDWR) && !entry->c.ops->read) ||
+	    ((mode == O_WRONLY || mode == O_RDWR) && !entry->c.ops->write)) {
+		err = -ENODEV;
+		goto error;
 	}
-	data = kzalloc(sizeof(*data), GFP_KERNEL);
-	if (data == NULL) {
-		err = -ENOMEM;
-		goto __error;
-	}
-	data->entry = entry;
-	switch (entry->content) {
-	case SNDRV_INFO_CONTENT_TEXT:
-		if (mode == O_RDONLY || mode == O_RDWR) {
-			buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
-			if (buffer == NULL)
-				goto __nomem;
-			data->rbuffer = buffer;
-			buffer->len = PAGE_SIZE;
-			buffer->buffer = kzalloc(buffer->len, GFP_KERNEL);
-			if (buffer->buffer == NULL)
-				goto __nomem;
-		}
-		if (mode == O_WRONLY || mode == O_RDWR) {
-			buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
-			if (buffer == NULL)
-				goto __nomem;
-			data->wbuffer = buffer;
-			buffer->len = PAGE_SIZE;
-			buffer->buffer = kmalloc(buffer->len, GFP_KERNEL);
-			if (buffer->buffer == NULL)
-				goto __nomem;
-		}
-		break;
-	case SNDRV_INFO_CONTENT_DATA:	/* data */
-		if (entry->c.ops->open) {
-			if ((err = entry->c.ops->open(entry, mode,
-						      &data->file_private_data)) < 0) {
-				kfree(data);
-				goto __error;
-			}
-		}
-		break;
+
+	if (entry->c.ops->open) {
+		err = entry->c.ops->open(entry, mode, &data->file_private_data);
+		if (err < 0)
+			goto error;
 	}
+
 	file->private_data = data;
 	mutex_unlock(&info_mutex);
-	if (entry->content == SNDRV_INFO_CONTENT_TEXT &&
-	    (mode == O_RDONLY || mode == O_RDWR)) {
-		if (entry->c.text.read) {
-			mutex_lock(&entry->access);
-			entry->c.text.read(entry, data->rbuffer);
-			mutex_unlock(&entry->access);
-		}
-	}
 	return 0;
 
- __nomem:
-	if (data->rbuffer) {
-		kfree(data->rbuffer->buffer);
-		kfree(data->rbuffer);
-	}
-	if (data->wbuffer) {
-		kfree(data->wbuffer->buffer);
-		kfree(data->wbuffer);
-	}
+ error:
 	kfree(data);
-	err = -ENOMEM;
-      __error:
 	module_put(entry->module);
-      __error1:
+ unlock:
 	mutex_unlock(&info_mutex);
 	return err;
 }
 
 static int snd_info_entry_release(struct inode *inode, struct file *file)
 {
-	struct snd_info_entry *entry;
-	struct snd_info_private_data *data;
-	int mode;
+	struct snd_info_private_data *data = file->private_data;
+	struct snd_info_entry *entry = data->entry;
 
-	mode = file->f_flags & O_ACCMODE;
-	data = file->private_data;
-	entry = data->entry;
-	switch (entry->content) {
-	case SNDRV_INFO_CONTENT_TEXT:
-		if (data->rbuffer) {
-			kfree(data->rbuffer->buffer);
-			kfree(data->rbuffer);
-		}
-		if (data->wbuffer) {
-			if (entry->c.text.write) {
-				entry->c.text.write(entry, data->wbuffer);
-				if (data->wbuffer->error) {
-					if (entry->card)
-						dev_warn(entry->card->dev, "info: data write error to %s (%i)\n",
-							 entry->name,
-							 data->wbuffer->error);
-					else
-						pr_warn("ALSA: info: data write error to %s (%i)\n",
-							entry->name,
-							data->wbuffer->error);
-				}
-			}
-			kfree(data->wbuffer->buffer);
-			kfree(data->wbuffer);
-		}
-		break;
-	case SNDRV_INFO_CONTENT_DATA:
-		if (entry->c.ops->release)
-			entry->c.ops->release(entry, mode,
-					      data->file_private_data);
-		break;
-	}
+	if (entry->c.ops->release)
+		entry->c.ops->release(entry, file->f_flags & O_ACCMODE,
+				      data->file_private_data);
 	module_put(entry->module);
 	kfree(data);
 	return 0;
 }
 
-static unsigned int snd_info_entry_poll(struct file *file, poll_table * wait)
+static const struct file_operations snd_info_entry_operations =
 {
-	struct snd_info_private_data *data;
-	struct snd_info_entry *entry;
-	unsigned int mask;
+	.owner =		THIS_MODULE,
+	.llseek =		snd_info_entry_llseek,
+	.read =			snd_info_entry_read,
+	.write =		snd_info_entry_write,
+	.poll =			snd_info_entry_poll,
+	.unlocked_ioctl =	snd_info_entry_ioctl,
+	.mmap =			snd_info_entry_mmap,
+	.open =			snd_info_entry_open,
+	.release =		snd_info_entry_release,
+};
 
-	data = file->private_data;
-	if (data == NULL)
-		return 0;
-	entry = data->entry;
-	mask = 0;
-	switch (entry->content) {
-	case SNDRV_INFO_CONTENT_DATA:
-		if (entry->c.ops->poll)
-			return entry->c.ops->poll(entry,
-						  data->file_private_data,
-						  file, wait);
-		if (entry->c.ops->read)
-			mask |= POLLIN | POLLRDNORM;
-		if (entry->c.ops->write)
-			mask |= POLLOUT | POLLWRNORM;
-		break;
+/*
+ * file ops for text proc files
+ */
+static ssize_t snd_info_text_entry_write(struct file *file,
+					 const char __user *buffer,
+					 size_t count, loff_t *offset)
+{
+	struct seq_file *m = file->private_data;
+	struct snd_info_private_data *data = m->private;
+	struct snd_info_entry *entry = data->entry;
+	struct snd_info_buffer *buf;
+	loff_t pos;
+	size_t next;
+	int err = 0;
+
+	pos = *offset;
+	if (!valid_pos(pos, count))
+		return -EIO;
+	next = pos + count;
+	mutex_lock(&entry->access);
+	buf = data->wbuffer;
+	if (!buf) {
+		data->wbuffer = buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+		if (!buf) {
+			err = -ENOMEM;
+			goto error;
+		}
 	}
-	return mask;
+	if (next > buf->len) {
+		char *nbuf = krealloc(buf->buffer, PAGE_ALIGN(next),
+				      GFP_KERNEL | __GFP_ZERO);
+		if (!nbuf) {
+			err = -ENOMEM;
+			goto error;
+		}
+		buf->buffer = nbuf;
+		buf->len = PAGE_ALIGN(next);
+	}
+	if (copy_from_user(buf->buffer + pos, buffer, count)) {
+		err = -EFAULT;
+		goto error;
+	}
+	buf->size = next;
+ error:
+	mutex_unlock(&entry->access);
+	if (err < 0)
+		return err;
+	*offset = next;
+	return count;
 }
 
-static long snd_info_entry_ioctl(struct file *file, unsigned int cmd,
-				unsigned long arg)
+static int snd_info_seq_show(struct seq_file *seq, void *p)
 {
-	struct snd_info_private_data *data;
-	struct snd_info_entry *entry;
+	struct snd_info_private_data *data = seq->private;
+	struct snd_info_entry *entry = data->entry;
 
-	data = file->private_data;
-	if (data == NULL)
-		return 0;
-	entry = data->entry;
-	switch (entry->content) {
-	case SNDRV_INFO_CONTENT_DATA:
-		if (entry->c.ops->ioctl)
-			return entry->c.ops->ioctl(entry,
-						   data->file_private_data,
-						   file, cmd, arg);
-		break;
+	if (entry->c.text.read) {
+		data->rbuffer->buffer = (char *)seq; /* XXX hack! */
+		entry->c.text.read(entry, data->rbuffer);
 	}
-	return -ENOTTY;
+	return 0;
 }
 
-static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
+static int snd_info_text_entry_open(struct inode *inode, struct file *file)
 {
-	struct inode *inode = file_inode(file);
+	struct snd_info_entry *entry = PDE_DATA(inode);
 	struct snd_info_private_data *data;
-	struct snd_info_entry *entry;
+	int err;
 
-	data = file->private_data;
-	if (data == NULL)
-		return 0;
-	entry = data->entry;
-	switch (entry->content) {
-	case SNDRV_INFO_CONTENT_DATA:
-		if (entry->c.ops->mmap)
-			return entry->c.ops->mmap(entry,
-						  data->file_private_data,
-						  inode, file, vma);
-		break;
+	mutex_lock(&info_mutex);
+	err = alloc_info_private(entry, &data);
+	if (err < 0)
+		goto unlock;
+
+	data->rbuffer = kzalloc(sizeof(*data->rbuffer), GFP_KERNEL);
+	if (!data->rbuffer) {
+		err = -ENOMEM;
+		goto error;
+	}
+	if (entry->size)
+		err = single_open_size(file, snd_info_seq_show, data,
+				       entry->size);
+	else
+		err = single_open(file, snd_info_seq_show, data);
+	if (err < 0)
+		goto error;
+	mutex_unlock(&info_mutex);
+	return 0;
+
+ error:
+	kfree(data->rbuffer);
+	kfree(data);
+	module_put(entry->module);
+ unlock:
+	mutex_unlock(&info_mutex);
+	return err;
+}
+
+static int snd_info_text_entry_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *m = file->private_data;
+	struct snd_info_private_data *data = m->private;
+	struct snd_info_entry *entry = data->entry;
+
+	if (data->wbuffer && entry->c.text.write)
+		entry->c.text.write(entry, data->wbuffer);
+
+	single_release(inode, file);
+	kfree(data->rbuffer);
+	if (data->wbuffer) {
+		kfree(data->wbuffer->buffer);
+		kfree(data->wbuffer);
 	}
-	return -ENXIO;
+
+	module_put(entry->module);
+	kfree(data);
+	return 0;
 }
 
-static const struct file_operations snd_info_entry_operations =
+static const struct file_operations snd_info_text_entry_ops =
 {
 	.owner =		THIS_MODULE,
-	.llseek =		snd_info_entry_llseek,
-	.read =			snd_info_entry_read,
-	.write =		snd_info_entry_write,
-	.poll =			snd_info_entry_poll,
-	.unlocked_ioctl =	snd_info_entry_ioctl,
-	.mmap =			snd_info_entry_mmap,
-	.open =			snd_info_entry_open,
-	.release =		snd_info_entry_release,
+	.open =			snd_info_text_entry_open,
+	.release =		snd_info_text_entry_release,
+	.write =		snd_info_text_entry_write,
+	.llseek =		seq_lseek,
+	.read =			seq_read,
 };
 
 int __init snd_info_init(void)
@@ -955,8 +877,13 @@ int snd_info_register(struct snd_info_entry * entry)
 			return -ENOMEM;
 		}
 	} else {
+		const struct file_operations *ops;
+		if (entry->content == SNDRV_INFO_CONTENT_DATA)
+			ops = &snd_info_entry_operations;
+		else
+			ops = &snd_info_text_entry_ops;
 		p = proc_create_data(entry->name, entry->mode, root,
-					&snd_info_entry_operations, entry);
+				     ops, entry);
 		if (!p) {
 			mutex_unlock(&info_mutex);
 			return -ENOMEM;

commit ddc64b278a4dda052390b3de1b551e59acdff105
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Aug 21 20:55:21 2014 +0200

    ALSA: core: fix buffer overflow in snd_info_get_line()
    
    snd_info_get_line() documents that its last parameter must be one
    less than the buffer size, but this API design guarantees that
    (literally) every caller gets it wrong.
    
    Just change this parameter to have its obvious meaning.
    
    Reported-by: Tommi Rantala <tt.rantala@gmail.com>
    Cc: <stable@vger.kernel.org> # v2.2.26+
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 051d55b05521..9f404e965ea2 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -684,7 +684,7 @@ int snd_info_card_free(struct snd_card *card)
  * snd_info_get_line - read one line from the procfs buffer
  * @buffer: the procfs buffer
  * @line: the buffer to store
- * @len: the max. buffer size - 1
+ * @len: the max. buffer size
  *
  * Reads one line from the buffer and stores the string.
  *
@@ -704,7 +704,7 @@ int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 			buffer->stop = 1;
 		if (c == '\n')
 			break;
-		if (len) {
+		if (len > 1) {
 			len--;
 			*line++ = c;
 		}

commit f2f9307a4f26a9fbe47fff486a9cee5885af748f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:21:03 2014 +0100

    ALSA: core: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 7916c07b9324..051d55b05521 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -418,9 +418,14 @@ static int snd_info_entry_release(struct inode *inode, struct file *file)
 			if (entry->c.text.write) {
 				entry->c.text.write(entry, data->wbuffer);
 				if (data->wbuffer->error) {
-					snd_printk(KERN_WARNING "data write error to %s (%i)\n",
-						entry->name,
-						data->wbuffer->error);
+					if (entry->card)
+						dev_warn(entry->card->dev, "info: data write error to %s (%i)\n",
+							 entry->name,
+							 data->wbuffer->error);
+					else
+						pr_warn("ALSA: info: data write error to %s (%i)\n",
+							entry->name,
+							data->wbuffer->error);
 				}
 			}
 			kfree(data->wbuffer->buffer);

commit 8eeaa2f9e06dcfb45593a0fcd91e81abc7f5d209
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 10 09:48:47 2014 +0100

    ALSA: Replace with IS_ENABLED()
    
    Replace the lengthy #if defined(XXX) || defined(XXX_MODULE) with the
    new IS_ENABLED() macro.
    
    The patch still doesn't cover all ifdefs.  For example, the dependency
    on CONFIG_GAMEPORT is still open-coded because this also has an extra
    dependency on MODULE.  Similarly, an open-coded ifdef in pcm_oss.c and
    some sequencer-related stuff are left untouched.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index e79baa11b60e..7916c07b9324 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -540,7 +540,7 @@ int __init snd_info_init(void)
 		snd_oss_root = entry;
 	}
 #endif
-#if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 	{
 		struct snd_info_entry *entry;
 		if ((entry = snd_info_create_module_entry(THIS_MODULE, "seq", NULL)) == NULL)
@@ -567,7 +567,7 @@ int __exit snd_info_done(void)
 	snd_minor_info_done();
 	snd_info_version_done();
 	if (snd_proc_root) {
-#if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 		snd_info_free_entry(snd_seq_root);
 #endif
 #ifdef CONFIG_SND_OSSEMUL

commit 9992ba72327fa0d8bdc9fb624e80f5cce338a711
Merge: 00fdffb51311 4ca231b2e6ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 3 09:10:23 2013 -0700

    Merge tag 'sound-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "Mostly many small changes spread as seen in diffstat in sound/*
      directory by this update.  A significant change in the subsystem level
      is the introduction of snd_soc_component, which will help more generic
      handling of SoC and off-SoC components.
    
      Also, snd_BUG_ON() macro is enabled unconditionally now due to its
      misuses, so people might hit kernel warnings (it's a good thing for
      us).
    
       - compress-offload: support for capture by Charles Keepax
       - HD-audio: codec delay support by Dylan Reid
       - HD-audio: improvements/fixes in generic parser: better headphone
         mic and headset mic support, jack_modes hint consolidation, proper
         beep attach/detachment, generalized power filter controls by David
         Henningsson, et al
       - HD-audio: Improved management of HDMI codec pins/converters
       - HD-audio: Better pin/DAC assignment for VIA codecs
       - HD-audio: Haswell HDMI workarounds
       - HD-audio: ALC268 codec support, a few new quirks for Chromebooks
       - USB: regression fixes: USB-MIDI autopm fix, the recent ISO latency
         fix by Clemens Ladisch
       - USB: support for DSD formats by Daniel Mack
       - USB: A few UAC2 device endian/cock fixes by Eldad Zack
       - USB: quirks for Emu 192kHz support, Novation Twitch DJ controller,
         Yamaha THRxx devices
       - HDSPM: updates for TCO controls by Adrian Knoth
       - ASoC: Add a snd_soc_component object type for generic handling of
         SoC and off-SoC components by Kuninori Morimoto,
       - dmaengine: a large set of cleanups and conversions by Lars-Peter
         Clausen
       - ASoC DAPM: performance optimizations from Ryo Tsutsui
       - ASoC DAPM: support for mixer control sharing by Stephen Warren
       - ASoC: multiplatform ARM cleanups from Arnd Bergmann
       - ASoC: new codec drivers for AK5385 and TAS5086 from Daniel Mack"
    
    * tag 'sound-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (315 commits)
      ALSA: usb-audio: caiaq: fix endianness bug in snd_usb_caiaq_maschine_dispatch
      ALSA: asihpi: add format support check in snd_card_asihpi_capture_formats
      ALSA: pcm_format_to_bits strong-typed conversion
      ALSA: compress: fix the states to check for allowing read
      ALSA: hda - Move Thinkpad X220 to use auto parser
      ALSA: USB: adjust for changed 3.8 USB API
      ALSA: usb - Avoid unnecessary sample rate changes on USB 2.0 clock sources
      sound: oss/dmabuf: use dma_map_single
      ALSA: ali5451: use mdelay instead of large udelay constants
      ALSA: hda - Add the support for ALC286 codec
      ALSA: usb-audio: USB quirk for Yamaha THR10C
      ALSA: usb-audio: USB quirk for Yamaha THR5A
      ALSA: usb-audio: USB quirk for Yamaha THR10
      ALSA: usb-audio: Fix autopm error during probing
      ALSA: snd-usb: try harder to find USB_DT_CS_ENDPOINT
      ALSA: sound kconfig typo
      ALSA: emu10k1: Fix dock firmware loading
      ASoC: ux500: forward declare msp_i2s_platform_data
      ASoC: davinci-mcasp: Add Support BCLK-to-LRCLK ratio for TDM modes
      ASoC: davinci-pcm, davinci-mcasp: Clean up active_serializers
      ...

commit a8ca16ea7b0abb0a7e49492d1123b715f0ec62e8
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 12 17:27:28 2013 +0100

    proc: Supply a function to remove a proc entry by PDE
    
    Supply a function (proc_remove()) to remove a proc entry (and any subtree
    rooted there) by proc_dir_entry pointer rather than by name and (optionally)
    root dir entry pointer.  This allows us to eliminate all remaining pde->name
    accesses outside of procfs.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Grant Likely <grant.likely@linaro.or>
    cc: linux-acpi@vger.kernel.org
    cc: openipmi-developer@lists.sourceforge.net
    cc: devicetree-discuss@lists.ozlabs.org
    cc: linux-pci@vger.kernel.org
    cc: netdev@vger.kernel.org
    cc: netfilter-devel@vger.kernel.org
    cc: alsa-devel@alsa-project.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/info.c b/sound/core/info.c
index c7f41c3bbd5c..3c9bd6b10a96 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -153,13 +153,6 @@ EXPORT_SYMBOL(snd_seq_root);
 struct snd_info_entry *snd_oss_root;
 #endif
 
-static void snd_remove_proc_entry(struct proc_dir_entry *parent,
-				  struct proc_dir_entry *de)
-{
-	if (de)
-		remove_proc_entry(de->name, parent);
-}
-
 static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 {
 	struct snd_info_private_data *data;
@@ -580,7 +573,7 @@ int __exit snd_info_done(void)
 #ifdef CONFIG_SND_OSSEMUL
 		snd_info_free_entry(snd_oss_root);
 #endif
-		snd_remove_proc_entry(NULL, snd_proc_root);
+		proc_remove(snd_proc_root);
 	}
 	return 0;
 }
@@ -642,7 +635,7 @@ void snd_info_card_id_change(struct snd_card *card)
 {
 	mutex_lock(&info_mutex);
 	if (card->proc_root_link) {
-		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
+		proc_remove(card->proc_root_link);
 		card->proc_root_link = NULL;
 	}
 	if (strcmp(card->id, card->proc_root->name))
@@ -661,10 +654,8 @@ void snd_info_card_disconnect(struct snd_card *card)
 	if (!card)
 		return;
 	mutex_lock(&info_mutex);
-	if (card->proc_root_link) {
-		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
-		card->proc_root_link = NULL;
-	}
+	proc_remove(card->proc_root_link);
+	card->proc_root_link = NULL;
 	if (card->proc_root)
 		snd_info_disconnect(card->proc_root);
 	mutex_unlock(&info_mutex);
@@ -856,7 +847,7 @@ static void snd_info_disconnect(struct snd_info_entry *entry)
 	list_del_init(&entry->list);
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
 	snd_BUG_ON(!root);
-	snd_remove_proc_entry(root, entry->p);
+	proc_remove(entry->p);
 	entry->p = NULL;
 }
 

commit 271a15eabe094538d958dc68ccfc9c36b699247a
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 12 00:38:51 2013 +0100

    proc: Supply PDE attribute setting accessor functions
    
    Supply accessor functions to set attributes in proc_dir_entry structs.
    
    The following are supplied: proc_set_size() and proc_set_user().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    cc: linuxppc-dev@lists.ozlabs.org
    cc: linux-media@vger.kernel.org
    cc: netdev@vger.kernel.org
    cc: linux-wireless@vger.kernel.org
    cc: linux-pci@vger.kernel.org
    cc: netfilter-devel@vger.kernel.org
    cc: alsa-devel@alsa-project.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/info.c b/sound/core/info.c
index 3aa88640808e..c7f41c3bbd5c 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -970,7 +970,7 @@ int snd_info_register(struct snd_info_entry * entry)
 			mutex_unlock(&info_mutex);
 			return -ENOMEM;
 		}
-		p->size = entry->size;
+		proc_set_size(p, entry->size);
 	}
 	entry->p = p;
 	if (entry->parent)

commit d9dda78bad879595d8c4220a067fc029d6484a16
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 18:16:14 2013 -0400

    procfs: new helper - PDE_DATA(inode)
    
    The only part of proc_dir_entry the code outside of fs/proc
    really cares about is PDE(inode)->data.  Provide a helper
    for that; static inline for now, eventually will be moved
    to fs/proc, along with the knowledge of struct proc_dir_entry
    layout.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/info.c b/sound/core/info.c
index a4e2de6874df..3aa88640808e 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -310,12 +310,10 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 	struct snd_info_entry *entry;
 	struct snd_info_private_data *data;
 	struct snd_info_buffer *buffer;
-	struct proc_dir_entry *p;
 	int mode, err;
 
 	mutex_lock(&info_mutex);
-	p = PDE(inode);
-	entry = p == NULL ? NULL : (struct snd_info_entry *)p->data;
+	entry = PDE_DATA(inode);
 	if (entry == NULL || ! entry->p) {
 		mutex_unlock(&info_mutex);
 		return -ENODEV;

commit aee0c612b12f57f4923f6649fa6fcba618182261
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Mar 28 23:01:34 2013 -0400

    snd_info_register: switch to proc_create_data/proc_mkdir_mode
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/info.c b/sound/core/info.c
index 5bb97e7d325a..a4e2de6874df 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -959,15 +959,21 @@ int snd_info_register(struct snd_info_entry * entry)
 		return -ENXIO;
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
 	mutex_lock(&info_mutex);
-	p = create_proc_entry(entry->name, entry->mode, root);
-	if (!p) {
-		mutex_unlock(&info_mutex);
-		return -ENOMEM;
+	if (S_ISDIR(entry->mode)) {
+		p = proc_mkdir_mode(entry->name, entry->mode, root);
+		if (!p) {
+			mutex_unlock(&info_mutex);
+			return -ENOMEM;
+		}
+	} else {
+		p = proc_create_data(entry->name, entry->mode, root,
+					&snd_info_entry_operations, entry);
+		if (!p) {
+			mutex_unlock(&info_mutex);
+			return -ENOMEM;
+		}
+		p->size = entry->size;
 	}
-	if (!S_ISDIR(entry->mode))
-		p->proc_fops = &snd_info_entry_operations;
-	p->size = entry->size;
-	p->data = entry;
 	entry->p = p;
 	if (entry->parent)
 		list_add_tail(&entry->list, &entry->parent->children);

commit 0bc0ec903c45163f1263d9936f8a218fe9d3a29e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 13 12:11:13 2013 +0100

    ALSA: info: Small refactoring and a sanity check in snd_info_get_line()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 58e97b35cceb..c9042b4d3695 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -700,26 +700,21 @@ int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 {
 	int c = -1;
 
+	if (snd_BUG_ON(!buffer || !buffer->buffer))
+		return 1;
 	if (len <= 0 || buffer->stop || buffer->error)
 		return 1;
-	while (--len > 0) {
+	while (!buffer->stop) {
 		c = buffer->buffer[buffer->curr++];
-		if (c == '\n') {
-			if (buffer->curr >= buffer->size)
-				buffer->stop = 1;
-			break;
-		}
-		*line++ = c;
-		if (buffer->curr >= buffer->size) {
+		if (buffer->curr >= buffer->size)
 			buffer->stop = 1;
+		if (c == '\n')
 			break;
+		if (len) {
+			len--;
+			*line++ = c;
 		}
 	}
-	while (c != '\n' && !buffer->stop) {
-		c = buffer->buffer[buffer->curr++];
-		if (buffer->curr >= buffer->size)
-			buffer->stop = 1;
-	}
 	*line = '\0';
 	return 0;
 }

commit 0d861ac23812428deae17de2038234b79818b964
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 13 12:01:13 2013 +0100

    ALSA: info: Avoid leaking kernel memory
    
    Make sure that the allocated buffer for reading the proc file won't
    expose the uncleared kernel memory.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index db308dbc8911..58e97b35cceb 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -89,7 +89,7 @@ static int resize_info_buffer(struct snd_info_buffer *buffer,
 	char *nbuf;
 
 	nsize = PAGE_ALIGN(nsize);
-	nbuf = krealloc(buffer->buffer, nsize, GFP_KERNEL);
+	nbuf = krealloc(buffer->buffer, nsize, GFP_KERNEL | __GFP_ZERO);
 	if (! nbuf)
 		return -ENOMEM;
 
@@ -353,7 +353,7 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 				goto __nomem;
 			data->rbuffer = buffer;
 			buffer->len = PAGE_SIZE;
-			buffer->buffer = kmalloc(buffer->len, GFP_KERNEL);
+			buffer->buffer = kzalloc(buffer->len, GFP_KERNEL);
 			if (buffer->buffer == NULL)
 				goto __nomem;
 		}

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 5bb97e7d325a..db308dbc8911 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -105,7 +105,7 @@ static int resize_info_buffer(struct snd_info_buffer *buffer,
  *
  * Outputs the string on the procfs buffer just like printf().
  *
- * Returns the size of output string.
+ * Return: The size of output string, or a negative error code.
  */
 int snd_iprintf(struct snd_info_buffer *buffer, const char *fmt, ...)
 {
@@ -694,7 +694,7 @@ int snd_info_card_free(struct snd_card *card)
  *
  * Reads one line from the buffer and stores the string.
  *
- * Returns zero if successful, or 1 if error or EOF.
+ * Return: Zero if successful, or 1 if error or EOF.
  */
 int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 {
@@ -735,7 +735,7 @@ EXPORT_SYMBOL(snd_info_get_line);
  * Parses the original string and copy a token to the given
  * string buffer.
  *
- * Returns the updated pointer of the original string so that
+ * Return: The updated pointer of the original string so that
  * it can be used for the next call.
  */
 const char *snd_info_get_str(char *dest, const char *src, int len)
@@ -774,7 +774,7 @@ EXPORT_SYMBOL(snd_info_get_str);
  * Usually called from other functions such as
  * snd_info_create_card_entry().
  *
- * Returns the pointer of the new instance, or NULL on failure.
+ * Return: The pointer of the new instance, or %NULL on failure.
  */
 static struct snd_info_entry *snd_info_create_entry(const char *name)
 {
@@ -803,7 +803,7 @@ static struct snd_info_entry *snd_info_create_entry(const char *name)
  *
  * Creates a new info entry and assigns it to the given module.
  *
- * Returns the pointer of the new instance, or NULL on failure.
+ * Return: The pointer of the new instance, or %NULL on failure.
  */
 struct snd_info_entry *snd_info_create_module_entry(struct module * module,
 					       const char *name,
@@ -827,7 +827,7 @@ EXPORT_SYMBOL(snd_info_create_module_entry);
  *
  * Creates a new info entry and assigns it to the given card.
  *
- * Returns the pointer of the new instance, or NULL on failure.
+ * Return: The pointer of the new instance, or %NULL on failure.
  */
 struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 					     const char *name,
@@ -893,7 +893,7 @@ static int snd_info_dev_register_entry(struct snd_device *device)
  * For releasing this entry, use snd_device_free() instead of
  * snd_info_free_entry(). 
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_card_proc_new(struct snd_card *card, const char *name,
 		      struct snd_info_entry **entryp)
@@ -949,7 +949,7 @@ EXPORT_SYMBOL(snd_info_free_entry);
  *
  * Registers the proc info entry.
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_info_register(struct snd_info_entry * entry)
 {

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/info.c b/sound/core/info.c
index 6b368d25073b..5bb97e7d325a 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -496,7 +496,7 @@ static long snd_info_entry_ioctl(struct file *file, unsigned int cmd,
 
 static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = file_inode(file);
 	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
 

commit 4266274836e81575ee82498d84f4bd08ab7a7378
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Sep 4 11:21:45 2012 +0200

    ALSA: remove the main version information
    
    Remove the main ALSA version number from the kernel ALSA driver.
    The ALSA driver package release diverges from the upstream. This may
    confuse users to see the same ALSA version for many kernel releases
    and this version lost it's original purpose and connection.
    
    The "ioctl" APIs have own version numbers, so the user space may check
    for specific API changes only.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/info.c b/sound/core/info.c
index c1e611c65c8f..6b368d25073b 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -28,7 +28,7 @@
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/info.h>
-#include <sound/version.h>
+#include <linux/utsname.h>
 #include <linux/proc_fs.h>
 #include <linux/mutex.h>
 #include <stdarg.h>
@@ -986,9 +986,8 @@ static struct snd_info_entry *snd_info_version_entry;
 static void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	snd_iprintf(buffer,
-		    "Advanced Linux Sound Architecture Driver Version "
-		    CONFIG_SND_VERSION CONFIG_SND_DATE ".\n"
-		   );
+		    "Advanced Linux Sound Architecture Driver Version k%s.\n",
+		    init_utsname()->release);
 }
 
 static int __init snd_info_version_init(void)

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/info.c b/sound/core/info.c
index 601f0ebb677b..c1e611c65c8f 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -24,6 +24,7 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/info.h>

commit e55d92b92d240189241c22bfdfc885d4225a4d61
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 24 02:07:46 2011 -0400

    get rid of create_proc_entry() abuses - proc_mkdir() is there for purpose
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/info.c b/sound/core/info.c
index 7077f601da5a..601f0ebb677b 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -531,7 +531,7 @@ int __init snd_info_init(void)
 {
 	struct proc_dir_entry *p;
 
-	p = create_proc_entry("asound", S_IFDIR | S_IRUGO | S_IXUGO, NULL);
+	p = proc_mkdir("asound", NULL);
 	if (p == NULL)
 		return -ENOMEM;
 	snd_proc_root = p;

commit 451a3c24b0135bce54542009b5fde43846c7cf67
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 17 16:26:55 2010 +0100

    BKL: remove extraneous #include <smp_lock.h>
    
    The big kernel lock has been removed from all these files at some point,
    leaving only the #include.
    
    Remove this too as a cleanup.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index b70564ed8b37..7077f601da5a 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -23,7 +23,6 @@
 #include <linux/time.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/string.h>
 #include <sound/core.h>
 #include <sound/minors.h>

commit 73029e0ff18dfac8a1aab1dc188e1e150bbe3adc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 13 11:39:47 2010 +0200

    ALSA: info - Implement common llseek for binary mode
    
    The llseek implementation is identical for existing driver implementations,
    so let's merge to the common layer.  The same code for the text proc file
    can be used even for the binary proc file.
    
    The driver can provide its own llseek method if needed.  Then the common
    code will be skipped.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index f90a6fd43fb4..b70564ed8b37 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -164,39 +164,43 @@ static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 {
 	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
-	loff_t ret;
+	loff_t ret = -EINVAL, size;
 
 	data = file->private_data;
 	entry = data->entry;
 	mutex_lock(&entry->access);
-	switch (entry->content) {
-	case SNDRV_INFO_CONTENT_TEXT:
-		switch (orig) {
-		case SEEK_SET:
-			file->f_pos = offset;
-			ret = file->f_pos;
-			goto out;
-		case SEEK_CUR:
-			file->f_pos += offset;
-			ret = file->f_pos;
-			goto out;
-		case SEEK_END:
-		default:
-			ret = -EINVAL;
-			goto out;
-		}
+	if (entry->content == SNDRV_INFO_CONTENT_DATA &&
+	    entry->c.ops->llseek) {
+		offset = entry->c.ops->llseek(entry,
+					      data->file_private_data,
+					      file, offset, orig);
+		goto out;
+	}
+	if (entry->content == SNDRV_INFO_CONTENT_DATA)
+		size = entry->size;
+	else
+		size = 0;
+	switch (orig) {
+	case SEEK_SET:
 		break;
-	case SNDRV_INFO_CONTENT_DATA:
-		if (entry->c.ops->llseek) {
-			ret = entry->c.ops->llseek(entry,
-						    data->file_private_data,
-						    file, offset, orig);
+	case SEEK_CUR:
+		offset += file->f_pos;
+		break;
+	case SEEK_END:
+		if (!size)
 			goto out;
-		}
+		offset += size;
 		break;
-	}
-	ret = -ENXIO;
-out:
+	default:
+		goto out;
+	}
+	if (offset < 0)
+		goto out;
+	if (size && offset > size)
+		offset = size;
+	file->f_pos = offset;
+	ret = offset;
+ out:
 	mutex_unlock(&entry->access);
 	return ret;
 }

commit d97e1b78239c7e7e441088e0b644bd3b076002e6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 13 11:33:54 2010 +0200

    ALSA: info - Check file position validity in common layer
    
    Check the validity of the file position in the common info layer before
    calling read or write callbacks in assumption that entry->size is set up
    properly to indicate the max file size.
    
    Removed the redundant checks from the callbacks as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index ff968be81678..f90a6fd43fb4 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -232,10 +232,15 @@ static ssize_t snd_info_entry_read(struct file *file, char __user *buffer,
 			return -EFAULT;
 		break;
 	case SNDRV_INFO_CONTENT_DATA:
-		if (entry->c.ops->read)
+		if (pos >= entry->size)
+			return 0;
+		if (entry->c.ops->read) {
+			size = entry->size - pos;
+			size = min(count, size);
 			size = entry->c.ops->read(entry,
 						  data->file_private_data,
-						  file, buffer, count, pos);
+						  file, buffer, size, pos);
+		}
 		break;
 	}
 	if ((ssize_t) size > 0)
@@ -282,10 +287,13 @@ static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer
 		size = count;
 		break;
 	case SNDRV_INFO_CONTENT_DATA:
-		if (entry->c.ops->write)
+		if (entry->c.ops->write && count > 0) {
+			size_t maxsize = entry->size - pos;
+			count = min(count, maxsize);
 			size = entry->c.ops->write(entry,
 						   data->file_private_data,
 						   file, buffer, count, pos);
+		}
 		break;
 	}
 	if ((ssize_t) size > 0)

commit 067e4a5d23422c9e9a0787b7e18fa2457226d999
Merge: 0d0fb0f9c5fd 4cf19b848f92
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 13 11:24:34 2010 +0200

    Merge branch 'topic/bkl' into topic/core-cleanup

commit 5b5cd553e3ac49e6a9bac148f07ab94d3d96dae5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 7 18:33:57 2010 +0200

    ALSA: info - Remove BKL
    
    Use the fine-grained mutex for the assigned info object, instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index d749a0d394a7..fe836618fa25 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -167,7 +167,7 @@ static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 
 	data = file->private_data;
 	entry = data->entry;
-	lock_kernel();
+	mutex_lock(&entry->access);
 	switch (entry->content) {
 	case SNDRV_INFO_CONTENT_TEXT:
 		switch (orig) {
@@ -196,7 +196,7 @@ static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 	}
 	ret = -ENXIO;
 out:
-	unlock_kernel();
+	mutex_unlock(&entry->access);
 	return ret;
 }
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/core/info.c b/sound/core/info.c
index d749a0d394a7..cc4a53d4b7f8 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/time.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/string.h>
 #include <sound/core.h>

commit 6a0f4021469727675b83d85ac91d106bfae0e2c3
Merge: f9892a52e240 b888d1ce82eb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 10 15:32:51 2009 +0200

    Merge branch 'topic/dummy' into for-linus
    
    * topic/dummy:
      ALSA: dummy - Increase MAX_PCM_SUBSTREAMS to 128
      ALSA: dummy - Add debug proc file
      ALSA: Add const prefix to proc helper functions
      ALSA: Re-export snd_pcm_format_name() function
      ALSA: dummy - Fake buffer allocations
      ALSA: dummy - Fix the timer calculation in systimer mode
      ALSA: dummy - Add more description
      ALSA: dummy - Better jiffies handling
      ALSA: dummy - Support high-res timer mode

commit 4f7454a9970fa0f3e9f1a68201520e3df1bb5224
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 8 14:29:58 2009 +0200

    ALSA: Add const prefix to proc helper functions
    
    Add appropriate const prefix to char * arguments in proc helper functions.
    Also fixed the caller side to be proper const pointers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 35df614f6c55..6eb53930ea1d 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -108,7 +108,7 @@ static int resize_info_buffer(struct snd_info_buffer *buffer,
  *
  * Returns the size of output string.
  */
-int snd_iprintf(struct snd_info_buffer *buffer, char *fmt,...)
+int snd_iprintf(struct snd_info_buffer *buffer, const char *fmt, ...)
 {
 	va_list args;
 	int len, res;
@@ -727,7 +727,7 @@ EXPORT_SYMBOL(snd_info_get_line);
  * Returns the updated pointer of the original string so that
  * it can be used for the next call.
  */
-char *snd_info_get_str(char *dest, char *src, int len)
+const char *snd_info_get_str(char *dest, const char *src, int len)
 {
 	int c;
 

commit 9983aa62c321a22774e47cf701b6d8b16d92a822
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 6 14:31:59 2009 +0200

    ALSA: info - Use krealloc()
    
    Use krealloc() to resize the buffer in sound/core/info.c.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 35df614f6c55..3d1f5137420a 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -88,12 +88,10 @@ static int resize_info_buffer(struct snd_info_buffer *buffer,
 	char *nbuf;
 
 	nsize = PAGE_ALIGN(nsize);
-	nbuf = kmalloc(nsize, GFP_KERNEL);
+	nbuf = krealloc(buffer->buffer, nsize, GFP_KERNEL);
 	if (! nbuf)
 		return -ENOMEM;
 
-	memcpy(nbuf, buffer->buffer, buffer->len);
-	kfree(buffer->buffer);
 	buffer->buffer = nbuf;
 	buffer->len = nsize;
 	return 0;

commit 99b76233803beab302123d243eea9e41149804f3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 25 22:48:06 2009 +0300

    proc 2/2: remove struct proc_dir_entry::owner
    
    Setting ->owner as done currently (pde->owner = THIS_MODULE) is racy
    as correctly noted at bug #12454. Someone can lookup entry with NULL
    ->owner, thus not pinning enything, and release it later resulting
    in module refcount underflow.
    
    We can keep ->owner and supply it at registration time like ->proc_fops
    and ->data.
    
    But this leaves ->owner as easy-manipulative field (just one C assignment)
    and somebody will forget to unpin previous/pin current module when
    switching ->owner. ->proc_fops is declared as "const" which should give
    some thoughts.
    
    ->read_proc/->write_proc were just fixed to not require ->owner for
    protection.
    
    rmmod'ed directories will be empty and return "." and ".." -- no harm.
    And directories with tricky enough readdir and lookup shouldn't be modular.
    We definitely don't want such modular code.
    
    Removing ->owner will also make PDE smaller.
    
    So, let's nuke it.
    
    Kudos to Jeff Layton for reminding about this, let's say, oversight.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12454
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/sound/core/info.c b/sound/core/info.c
index 70fa87189f36..35df614f6c55 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -154,11 +154,6 @@ EXPORT_SYMBOL(snd_seq_root);
 struct snd_info_entry *snd_oss_root;
 #endif
 
-static inline void snd_info_entry_prepare(struct proc_dir_entry *de)
-{
-	de->owner = THIS_MODULE;
-}
-
 static void snd_remove_proc_entry(struct proc_dir_entry *parent,
 				  struct proc_dir_entry *de)
 {
@@ -522,32 +517,11 @@ static const struct file_operations snd_info_entry_operations =
 	.release =		snd_info_entry_release,
 };
 
-/**
- * snd_create_proc_entry - create a procfs entry
- * @name: the name of the proc file
- * @mode: the file permission bits, S_Ixxx
- * @parent: the parent proc-directory entry
- *
- * Creates a new proc file entry with the given name and permission
- * on the given directory.
- *
- * Returns the pointer of new instance or NULL on failure.
- */
-static struct proc_dir_entry *snd_create_proc_entry(const char *name, mode_t mode,
-						    struct proc_dir_entry *parent)
-{
-	struct proc_dir_entry *p;
-	p = create_proc_entry(name, mode, parent);
-	if (p)
-		snd_info_entry_prepare(p);
-	return p;
-}
-
 int __init snd_info_init(void)
 {
 	struct proc_dir_entry *p;
 
-	p = snd_create_proc_entry("asound", S_IFDIR | S_IRUGO | S_IXUGO, NULL);
+	p = create_proc_entry("asound", S_IFDIR | S_IRUGO | S_IXUGO, NULL);
 	if (p == NULL)
 		return -ENOMEM;
 	snd_proc_root = p;
@@ -974,12 +948,11 @@ int snd_info_register(struct snd_info_entry * entry)
 		return -ENXIO;
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
 	mutex_lock(&info_mutex);
-	p = snd_create_proc_entry(entry->name, entry->mode, root);
+	p = create_proc_entry(entry->name, entry->mode, root);
 	if (!p) {
 		mutex_unlock(&info_mutex);
 		return -ENOMEM;
 	}
-	p->owner = entry->module;
 	if (!S_ISDIR(entry->mode))
 		p->proc_fops = &snd_info_entry_operations;
 	p->size = entry->size;

commit c2eb9c4ea383aee154e7139395872c4da629e715
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Nov 12 16:31:37 2008 +0100

    ALSA: when card identification is changed, change also /proc/asound symlink
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 527b207462b0..70fa87189f36 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -652,6 +652,23 @@ int snd_info_card_register(struct snd_card *card)
 	return 0;
 }
 
+/*
+ * called on card->id change
+ */
+void snd_info_card_id_change(struct snd_card *card)
+{
+	mutex_lock(&info_mutex);
+	if (card->proc_root_link) {
+		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
+		card->proc_root_link = NULL;
+	}
+	if (strcmp(card->id, card->proc_root->name))
+		card->proc_root_link = proc_symlink(card->id,
+						    snd_proc_root,
+						    card->proc_root->name);
+	mutex_unlock(&info_mutex);
+}
+
 /*
  * de-register the card proc file
  * called from init.c

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/info.c b/sound/core/info.c
index c67773ad9298..527b207462b0 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -217,7 +217,8 @@ static ssize_t snd_info_entry_read(struct file *file, char __user *buffer,
 	loff_t pos;
 
 	data = file->private_data;
-	snd_assert(data != NULL, return -ENXIO);
+	if (snd_BUG_ON(!data))
+		return -ENXIO;
 	pos = *offset;
 	if (pos < 0 || (long) pos != pos || (ssize_t) count < 0)
 		return -EIO;
@@ -258,7 +259,8 @@ static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer
 	loff_t pos;
 
 	data = file->private_data;
-	snd_assert(data != NULL, return -ENXIO);
+	if (snd_BUG_ON(!data))
+		return -ENXIO;
 	entry = data->entry;
 	pos = *offset;
 	if (pos < 0 || (long) pos != pos || (ssize_t) count < 0)
@@ -614,7 +616,8 @@ int snd_info_card_create(struct snd_card *card)
 	char str[8];
 	struct snd_info_entry *entry;
 
-	snd_assert(card != NULL, return -ENXIO);
+	if (snd_BUG_ON(!card))
+		return -ENXIO;
 
 	sprintf(str, "card%i", card->number);
 	if ((entry = snd_info_create_module_entry(card->module, str, NULL)) == NULL)
@@ -636,7 +639,8 @@ int snd_info_card_register(struct snd_card *card)
 {
 	struct proc_dir_entry *p;
 
-	snd_assert(card != NULL, return -ENXIO);
+	if (snd_BUG_ON(!card))
+		return -ENXIO;
 
 	if (!strcmp(card->id, card->proc_root->name))
 		return 0;
@@ -654,7 +658,8 @@ int snd_info_card_register(struct snd_card *card)
  */
 void snd_info_card_disconnect(struct snd_card *card)
 {
-	snd_assert(card != NULL, return);
+	if (!card)
+		return;
 	mutex_lock(&info_mutex);
 	if (card->proc_root_link) {
 		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
@@ -671,7 +676,8 @@ void snd_info_card_disconnect(struct snd_card *card)
  */
 int snd_info_card_free(struct snd_card *card)
 {
-	snd_assert(card != NULL, return -ENXIO);
+	if (!card)
+		return 0;
 	snd_info_free_entry(card->proc_root);
 	card->proc_root = NULL;
 	return 0;
@@ -849,7 +855,7 @@ static void snd_info_disconnect(struct snd_info_entry *entry)
 		return;
 	list_del_init(&entry->list);
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
-	snd_assert(root, return);
+	snd_BUG_ON(!root);
 	snd_remove_proc_entry(root, entry->p);
 	entry->p = NULL;
 }
@@ -947,7 +953,8 @@ int snd_info_register(struct snd_info_entry * entry)
 {
 	struct proc_dir_entry *root, *p = NULL;
 
-	snd_assert(entry != NULL, return -ENXIO);
+	if (snd_BUG_ON(!entry))
+		return -ENXIO;
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
 	mutex_lock(&info_mutex);
 	p = snd_create_proc_entry(entry->name, entry->mode, root);

commit 27ac792ca0b0a1e7e65f20342260650516c95864
Author: Andrea Righi <righi.andrea@gmail.com>
Date:   Wed Jul 23 21:28:13 2008 -0700

    PAGE_ALIGN(): correctly handle 64-bit values on 32-bit architectures
    
    On 32-bit architectures PAGE_ALIGN() truncates 64-bit values to the 32-bit
    boundary. For example:
    
            u64 val = PAGE_ALIGN(size);
    
    always returns a value < 4GB even if size is greater than 4GB.
    
    The problem resides in PAGE_MASK definition (from include/asm-x86/page.h for
    example):
    
    #define PAGE_SHIFT      12
    #define PAGE_SIZE       (_AC(1,UL) << PAGE_SHIFT)
    #define PAGE_MASK       (~(PAGE_SIZE-1))
    ...
    #define PAGE_ALIGN(addr)       (((addr)+PAGE_SIZE-1)&PAGE_MASK)
    
    The "~" is performed on a 32-bit value, so everything in "and" with
    PAGE_MASK greater than 4GB will be truncated to the 32-bit boundary.
    Using the ALIGN() macro seems to be the right way, because it uses
    typeof(addr) for the mask.
    
    Also move the PAGE_ALIGN() definitions out of include/asm-*/page.h in
    include/linux/mm.h.
    
    See also lkml discussion: http://lkml.org/lkml/2008/6/11/237
    
    [akpm@linux-foundation.org: fix drivers/media/video/uvc/uvc_queue.c]
    [akpm@linux-foundation.org: fix v850]
    [akpm@linux-foundation.org: fix powerpc]
    [akpm@linux-foundation.org: fix arm]
    [akpm@linux-foundation.org: fix mips]
    [akpm@linux-foundation.org: fix drivers/media/video/pvrusb2/pvrusb2-dvb.c]
    [akpm@linux-foundation.org: fix drivers/mtd/maps/uclinux.c]
    [akpm@linux-foundation.org: fix powerpc]
    Signed-off-by: Andrea Righi <righi.andrea@gmail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index cb5ead3e202d..c67773ad9298 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -21,6 +21,7 @@
 
 #include <linux/init.h>
 #include <linux/time.h>
+#include <linux/mm.h>
 #include <linux/smp_lock.h>
 #include <linux/string.h>
 #include <sound/core.h>

commit c74c120a21d87b0b6925ada5830d8cac21e852d9
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Apr 29 01:01:44 2008 -0700

    proc: remove proc_root from drivers
    
    Remove proc_root export.  Creation and removal works well if parent PDE is
    supplied as NULL -- it worked always that way.
    
    So, one useless export removed and consistency added, some drivers created
    PDEs with &proc_root as parent but removed them as NULL and so on.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index 9977ec2eace3..cb5ead3e202d 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -544,7 +544,7 @@ int __init snd_info_init(void)
 {
 	struct proc_dir_entry *p;
 
-	p = snd_create_proc_entry("asound", S_IFDIR | S_IRUGO | S_IXUGO, &proc_root);
+	p = snd_create_proc_entry("asound", S_IFDIR | S_IRUGO | S_IXUGO, NULL);
 	if (p == NULL)
 		return -ENOMEM;
 	snd_proc_root = p;
@@ -594,7 +594,7 @@ int __exit snd_info_done(void)
 #ifdef CONFIG_SND_OSSEMUL
 		snd_info_free_entry(snd_oss_root);
 #endif
-		snd_remove_proc_entry(&proc_root, snd_proc_root);
+		snd_remove_proc_entry(NULL, snd_proc_root);
 	}
 	return 0;
 }

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/info.c b/sound/core/info.c
index 1ffd29bb4cd0..9977ec2eace3 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/time.h>
 #include <linux/smp_lock.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/info.c b/sound/core/info.c
index bf6dbf99528b..1ffd29bb4cd0 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -1,6 +1,6 @@
 /*
  *  Information interface for ALSA driver
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify

commit 9c2e08c592cd357a8330c34def1e8ecfdcf53275
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:37 2007 -0800

    [PATCH] mark struct file_operations const 9
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index 54591e2eb6ee..bf6dbf99528b 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -507,7 +507,7 @@ static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
 	return -ENXIO;
 }
 
-static struct file_operations snd_info_entry_operations =
+static const struct file_operations snd_info_entry_operations =
 {
 	.owner =		THIS_MODULE,
 	.llseek =		snd_info_entry_llseek,

commit 7bc563239e4c276afebd11d2e6e67ddc0cc65f0d
Author: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
Date:   Fri Dec 8 02:37:40 2006 -0800

    [PATCH] struct path: convert sound
    
    Signed-off-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index 0b4aab3225e5..54591e2eb6ee 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -488,7 +488,7 @@ static long snd_info_entry_ioctl(struct file *file, unsigned int cmd,
 
 static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = file->f_path.dentry->d_inode;
 	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
 

commit dbedca39fe30db87b6401e4396f959c63d90082e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 18 19:09:46 2006 +0200

    [ALSA] Fix re-use of va_list
    
    The va_list is designed to be used only once.  The current code
    may pass va_list arguments multiple times and may cause Oops.
    Copy/release the arguments temporarily to avoid this problem.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/info.c b/sound/core/info.c
index e43662b33f16..0b4aab3225e5 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -120,7 +120,10 @@ int snd_iprintf(struct snd_info_buffer *buffer, char *fmt,...)
 	len = buffer->len - buffer->size;
 	va_start(args, fmt);
 	for (;;) {
-		res = vsnprintf(buffer->buffer + buffer->curr, len, fmt, args);
+		va_list ap;
+		va_copy(ap, args);
+		res = vsnprintf(buffer->buffer + buffer->curr, len, fmt, ap);
+		va_end(ap);
 		if (res < len)
 			break;
 		err = resize_info_buffer(buffer, buffer->len + PAGE_SIZE);

commit e6f8f108a19638d7c6535ab393a228ed9d4804a6
Author: Josef 'Jeff' Sipek <jeffpc@josefsipek.net>
Date:   Thu Sep 21 11:31:58 2006 +0200

    [ALSA] sound core: Use SEEK_{SET,CUR,END} instead of hardcoded values
    
    sound core: Use SEEK_{SET,CUR,END} instead of hardcoded values
    
    Signed-off-by: Josef 'Jeff' Sipek <jeffpc@josefsipek.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/info.c b/sound/core/info.c
index 9663b6be9c3a..e43662b33f16 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -175,15 +175,15 @@ static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 	switch (entry->content) {
 	case SNDRV_INFO_CONTENT_TEXT:
 		switch (orig) {
-		case 0:	/* SEEK_SET */
+		case SEEK_SET:
 			file->f_pos = offset;
 			ret = file->f_pos;
 			goto out;
-		case 1:	/* SEEK_CUR */
+		case SEEK_CUR:
 			file->f_pos += offset;
 			ret = file->f_pos;
 			goto out;
-		case 2:	/* SEEK_END */
+		case SEEK_END:
 		default:
 			ret = -EINVAL;
 			goto out;

commit 746d4a02e68499fc6c1f8d0c43d2271853ade181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:37:59 2006 +0200

    [ALSA] Fix disconnection of proc interface
    
    - Add the linked list to each proc entry to enable a single-shot
      disconnection (unregister)
    - Deprecate snd_info_unregister(), use snd_info_free_entry()
    - Removed NULL checks of snd_info_free_entry()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/info.c b/sound/core/info.c
index 340332c6d973..9663b6be9c3a 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -78,6 +78,7 @@ struct snd_info_private_data {
 
 static int snd_info_version_init(void);
 static int snd_info_version_done(void);
+static void snd_info_disconnect(struct snd_info_entry *entry);
 
 
 /* resize the proc r/w buffer */
@@ -304,7 +305,7 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 	mutex_lock(&info_mutex);
 	p = PDE(inode);
 	entry = p == NULL ? NULL : (struct snd_info_entry *)p->data;
-	if (entry == NULL || entry->disconnected) {
+	if (entry == NULL || ! entry->p) {
 		mutex_unlock(&info_mutex);
 		return -ENODEV;
 	}
@@ -586,10 +587,10 @@ int __exit snd_info_done(void)
 	snd_info_version_done();
 	if (snd_proc_root) {
 #if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
-		snd_info_unregister(snd_seq_root);
+		snd_info_free_entry(snd_seq_root);
 #endif
 #ifdef CONFIG_SND_OSSEMUL
-		snd_info_unregister(snd_oss_root);
+		snd_info_free_entry(snd_oss_root);
 #endif
 		snd_remove_proc_entry(&proc_root, snd_proc_root);
 	}
@@ -648,17 +649,28 @@ int snd_info_card_register(struct snd_card *card)
  * de-register the card proc file
  * called from init.c
  */
-int snd_info_card_free(struct snd_card *card)
+void snd_info_card_disconnect(struct snd_card *card)
 {
-	snd_assert(card != NULL, return -ENXIO);
+	snd_assert(card != NULL, return);
+	mutex_lock(&info_mutex);
 	if (card->proc_root_link) {
 		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
 		card->proc_root_link = NULL;
 	}
-	if (card->proc_root) {
-		snd_info_unregister(card->proc_root);
-		card->proc_root = NULL;
-	}
+	if (card->proc_root)
+		snd_info_disconnect(card->proc_root);
+	mutex_unlock(&info_mutex);
+}
+
+/*
+ * release the card proc file resources
+ * called from init.c
+ */
+int snd_info_card_free(struct snd_card *card)
+{
+	snd_assert(card != NULL, return -ENXIO);
+	snd_info_free_entry(card->proc_root);
+	card->proc_root = NULL;
 	return 0;
 }
 
@@ -767,6 +779,8 @@ static struct snd_info_entry *snd_info_create_entry(const char *name)
 	entry->mode = S_IFREG | S_IRUGO;
 	entry->content = SNDRV_INFO_CONTENT_TEXT;
 	mutex_init(&entry->access);
+	INIT_LIST_HEAD(&entry->children);
+	INIT_LIST_HEAD(&entry->list);
 	return entry;
 }
 
@@ -819,30 +833,35 @@ struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 
 EXPORT_SYMBOL(snd_info_create_card_entry);
 
-static int snd_info_dev_free_entry(struct snd_device *device)
+static void snd_info_disconnect(struct snd_info_entry *entry)
 {
-	struct snd_info_entry *entry = device->device_data;
-	snd_info_free_entry(entry);
-	return 0;
-}
+	struct list_head *p, *n;
+	struct proc_dir_entry *root;
 
-static int snd_info_dev_register_entry(struct snd_device *device)
-{
-	struct snd_info_entry *entry = device->device_data;
-	return snd_info_register(entry);
+	list_for_each_safe(p, n, &entry->children) {
+		snd_info_disconnect(list_entry(p, struct snd_info_entry, list));
+	}
+
+	if (! entry->p)
+		return;
+	list_del_init(&entry->list);
+	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
+	snd_assert(root, return);
+	snd_remove_proc_entry(root, entry->p);
+	entry->p = NULL;
 }
 
-static int snd_info_dev_disconnect_entry(struct snd_device *device)
+static int snd_info_dev_free_entry(struct snd_device *device)
 {
 	struct snd_info_entry *entry = device->device_data;
-	entry->disconnected = 1;
+	snd_info_free_entry(entry);
 	return 0;
 }
 
-static int snd_info_dev_unregister_entry(struct snd_device *device)
+static int snd_info_dev_register_entry(struct snd_device *device)
 {
 	struct snd_info_entry *entry = device->device_data;
-	return snd_info_unregister(entry);
+	return snd_info_register(entry);
 }
 
 /**
@@ -871,8 +890,7 @@ int snd_card_proc_new(struct snd_card *card, const char *name,
 	static struct snd_device_ops ops = {
 		.dev_free = snd_info_dev_free_entry,
 		.dev_register =	snd_info_dev_register_entry,
-		.dev_disconnect = snd_info_dev_disconnect_entry,
-		.dev_unregister = snd_info_dev_unregister_entry
+		/* disconnect is done via snd_info_card_disconnect() */
 	};
 	struct snd_info_entry *entry;
 	int err;
@@ -901,6 +919,11 @@ void snd_info_free_entry(struct snd_info_entry * entry)
 {
 	if (entry == NULL)
 		return;
+	if (entry->p) {
+		mutex_lock(&info_mutex);
+		snd_info_disconnect(entry);
+		mutex_unlock(&info_mutex);
+	}
 	kfree(entry->name);
 	if (entry->private_free)
 		entry->private_free(entry);
@@ -935,38 +958,14 @@ int snd_info_register(struct snd_info_entry * entry)
 	p->size = entry->size;
 	p->data = entry;
 	entry->p = p;
+	if (entry->parent)
+		list_add_tail(&entry->list, &entry->parent->children);
 	mutex_unlock(&info_mutex);
 	return 0;
 }
 
 EXPORT_SYMBOL(snd_info_register);
 
-/**
- * snd_info_unregister - de-register the info entry
- * @entry: the info entry
- *
- * De-registers the info entry and releases the instance.
- *
- * Returns zero if successful, or a negative error code on failure.
- */
-int snd_info_unregister(struct snd_info_entry * entry)
-{
-	struct proc_dir_entry *root;
-
-	if (! entry)
-		return 0;
-	snd_assert(entry->p != NULL, return -ENXIO);
-	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
-	snd_assert(root, return -ENXIO);
-	mutex_lock(&info_mutex);
-	snd_remove_proc_entry(root, entry->p);
-	mutex_unlock(&info_mutex);
-	snd_info_free_entry(entry);
-	return 0;
-}
-
-EXPORT_SYMBOL(snd_info_unregister);
-
 /*
 
  */
@@ -999,8 +998,7 @@ static int __init snd_info_version_init(void)
 
 static int __exit snd_info_version_done(void)
 {
-	if (snd_info_version_entry)
-		snd_info_unregister(snd_info_version_entry);
+	snd_info_free_entry(snd_info_version_entry);
 	return 0;
 }
 

commit 0936f26f55918af595b108208e64c37a0a481722
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Remove devfs support from the sound subsystem
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 10c1772bf3ea..340332c6d973 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -29,7 +29,6 @@
 #include <sound/info.h>
 #include <sound/version.h>
 #include <linux/proc_fs.h>
-#include <linux/devfs_fs_kernel.h>
 #include <linux/mutex.h>
 #include <stdarg.h>
 

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index c8eeaea9d695..10c1772bf3ea 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -143,12 +143,12 @@ EXPORT_SYMBOL(snd_iprintf);
 
  */
 
-static struct proc_dir_entry *snd_proc_root = NULL;
-struct snd_info_entry *snd_seq_root = NULL;
+static struct proc_dir_entry *snd_proc_root;
+struct snd_info_entry *snd_seq_root;
 EXPORT_SYMBOL(snd_seq_root);
 
 #ifdef CONFIG_SND_OSSEMUL
-struct snd_info_entry *snd_oss_root = NULL;
+struct snd_info_entry *snd_oss_root;
 #endif
 
 static inline void snd_info_entry_prepare(struct proc_dir_entry *de)
@@ -972,7 +972,7 @@ EXPORT_SYMBOL(snd_info_unregister);
 
  */
 
-static struct snd_info_entry *snd_info_version_entry = NULL;
+static struct snd_info_entry *snd_info_version_entry;
 
 static void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {

commit f4a747f155fe375231196ec3d26fcb6e3675d82f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 2 15:33:25 2006 +0200

    [ALSA] fix a wrong lock
    
    fix a typo in the info locking code
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 4188f76add75..c8eeaea9d695 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -267,7 +267,7 @@ static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer
 		buf = data->wbuffer;
 		if (buf == NULL)
 			return -EIO;
-		mutex_unlock(&entry->access);
+		mutex_lock(&entry->access);
 		if (pos + count >= buf->len) {
 			if (resize_info_buffer(buf, pos + count)) {
 				mutex_unlock(&entry->access);

commit f001c3acf64b8ca18fe40af592629abb261b321e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Insert might_sleep() in snd_iprintf()
    
    Inserted might_sleep() in snd_iprintf() for sanity check.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 86366839c4bb..4188f76add75 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -114,6 +114,7 @@ int snd_iprintf(struct snd_info_buffer *buffer, char *fmt,...)
 	int len, res;
 	int err = 0;
 
+	might_sleep();
 	if (buffer->stop || buffer->error)
 		return 0;
 	len = buffer->len - buffer->size;

commit 7e4eeec8a30fa9e00cac67a37ca9ddf6cbdb79c4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] Make buffer size of proc text interface variable
    
    Make the read/write buffer size of proc text interface variable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 9c288539e99d..86366839c4bb 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -21,7 +21,6 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/vmalloc.h>
 #include <linux/time.h>
 #include <linux/smp_lock.h>
 #include <linux/string.h>
@@ -82,6 +81,24 @@ static int snd_info_version_init(void);
 static int snd_info_version_done(void);
 
 
+/* resize the proc r/w buffer */
+static int resize_info_buffer(struct snd_info_buffer *buffer,
+			      unsigned int nsize)
+{
+	char *nbuf;
+
+	nsize = PAGE_ALIGN(nsize);
+	nbuf = kmalloc(nsize, GFP_KERNEL);
+	if (! nbuf)
+		return -ENOMEM;
+
+	memcpy(nbuf, buffer->buffer, buffer->len);
+	kfree(buffer->buffer);
+	buffer->buffer = nbuf;
+	buffer->len = nsize;
+	return 0;
+}
+
 /**
  * snd_iprintf - printf on the procfs buffer
  * @buffer: the procfs buffer
@@ -95,17 +112,25 @@ int snd_iprintf(struct snd_info_buffer *buffer, char *fmt,...)
 {
 	va_list args;
 	int len, res;
+	int err = 0;
 
 	if (buffer->stop || buffer->error)
 		return 0;
 	len = buffer->len - buffer->size;
 	va_start(args, fmt);
-	res = vsnprintf(buffer->curr, len, fmt, args);
-	va_end(args);
-	if (res >= len) {
-		buffer->stop = 1;
-		return 0;
+	for (;;) {
+		res = vsnprintf(buffer->buffer + buffer->curr, len, fmt, args);
+		if (res < len)
+			break;
+		err = resize_info_buffer(buffer, buffer->len + PAGE_SIZE);
+		if (err < 0)
+			break;
+		len = buffer->len - buffer->size;
 	}
+	va_end(args);
+
+	if (err < 0)
+		return err;
 	buffer->curr += res;
 	buffer->size += res;
 	return res;
@@ -225,7 +250,7 @@ static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer
 	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
 	struct snd_info_buffer *buf;
-	size_t size = 0;
+	ssize_t size = 0;
 	loff_t pos;
 
 	data = file->private_data;
@@ -241,14 +266,20 @@ static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer
 		buf = data->wbuffer;
 		if (buf == NULL)
 			return -EIO;
-		if (pos >= buf->len)
-			return -ENOMEM;
-		size = buf->len - pos;
-		size = min(count, size);
-		if (copy_from_user(buf->buffer + pos, buffer, size))
+		mutex_unlock(&entry->access);
+		if (pos + count >= buf->len) {
+			if (resize_info_buffer(buf, pos + count)) {
+				mutex_unlock(&entry->access);
+				return -ENOMEM;
+			}
+		}
+		if (copy_from_user(buf->buffer + pos, buffer, count)) {
+			mutex_unlock(&entry->access);
 			return -EFAULT;
-		if ((long)buf->size < pos + size)
-			buf->size = pos + size;
+		}
+		buf->size = pos + count;
+		mutex_unlock(&entry->access);
+		size = count;
 		break;
 	case SNDRV_INFO_CONTENT_DATA:
 		if (entry->c.ops->write)
@@ -283,18 +314,14 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 	}
 	mode = file->f_flags & O_ACCMODE;
 	if (mode == O_RDONLY || mode == O_RDWR) {
-		if ((entry->content == SNDRV_INFO_CONTENT_TEXT &&
-		     !entry->c.text.read_size) ||
-		    (entry->content == SNDRV_INFO_CONTENT_DATA &&
+		if ((entry->content == SNDRV_INFO_CONTENT_DATA &&
 		     entry->c.ops->read == NULL)) {
 		    	err = -ENODEV;
 		    	goto __error;
 		}
 	}
 	if (mode == O_WRONLY || mode == O_RDWR) {
-		if ((entry->content == SNDRV_INFO_CONTENT_TEXT &&
-		     !entry->c.text.write_size) ||
-		    (entry->content == SNDRV_INFO_CONTENT_DATA &&
+		if ((entry->content == SNDRV_INFO_CONTENT_DATA &&
 		     entry->c.ops->write == NULL)) {
 		    	err = -ENODEV;
 		    	goto __error;
@@ -310,49 +337,23 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 	case SNDRV_INFO_CONTENT_TEXT:
 		if (mode == O_RDONLY || mode == O_RDWR) {
 			buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
-			if (buffer == NULL) {
-				kfree(data);
-				err = -ENOMEM;
-				goto __error;
-			}
-			buffer->len = (entry->c.text.read_size +
-				      (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
-			buffer->buffer = vmalloc(buffer->len);
-			if (buffer->buffer == NULL) {
-				kfree(buffer);
-				kfree(data);
-				err = -ENOMEM;
-				goto __error;
-			}
-			buffer->curr = buffer->buffer;
+			if (buffer == NULL)
+				goto __nomem;
 			data->rbuffer = buffer;
+			buffer->len = PAGE_SIZE;
+			buffer->buffer = kmalloc(buffer->len, GFP_KERNEL);
+			if (buffer->buffer == NULL)
+				goto __nomem;
 		}
 		if (mode == O_WRONLY || mode == O_RDWR) {
 			buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
-			if (buffer == NULL) {
-				if (mode == O_RDWR) {
-					vfree(data->rbuffer->buffer);
-					kfree(data->rbuffer);
-				}
-				kfree(data);
-				err = -ENOMEM;
-				goto __error;
-			}
-			buffer->len = (entry->c.text.write_size +
-				      (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
-			buffer->buffer = vmalloc(buffer->len);
-			if (buffer->buffer == NULL) {
-				if (mode == O_RDWR) {
-					vfree(data->rbuffer->buffer);
-					kfree(data->rbuffer);
-				}
-				kfree(buffer);
-				kfree(data);
-				err = -ENOMEM;
-				goto __error;
-			}
-			buffer->curr = buffer->buffer;
+			if (buffer == NULL)
+				goto __nomem;
 			data->wbuffer = buffer;
+			buffer->len = PAGE_SIZE;
+			buffer->buffer = kmalloc(buffer->len, GFP_KERNEL);
+			if (buffer->buffer == NULL)
+				goto __nomem;
 		}
 		break;
 	case SNDRV_INFO_CONTENT_DATA:	/* data */
@@ -377,6 +378,17 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 	}
 	return 0;
 
+ __nomem:
+	if (data->rbuffer) {
+		kfree(data->rbuffer->buffer);
+		kfree(data->rbuffer);
+	}
+	if (data->wbuffer) {
+		kfree(data->wbuffer->buffer);
+		kfree(data->wbuffer);
+	}
+	kfree(data);
+	err = -ENOMEM;
       __error:
 	module_put(entry->module);
       __error1:
@@ -395,11 +407,11 @@ static int snd_info_entry_release(struct inode *inode, struct file *file)
 	entry = data->entry;
 	switch (entry->content) {
 	case SNDRV_INFO_CONTENT_TEXT:
-		if (mode == O_RDONLY || mode == O_RDWR) {
-			vfree(data->rbuffer->buffer);
+		if (data->rbuffer) {
+			kfree(data->rbuffer->buffer);
 			kfree(data->rbuffer);
 		}
-		if (mode == O_WRONLY || mode == O_RDWR) {
+		if (data->wbuffer) {
 			if (entry->c.text.write) {
 				entry->c.text.write(entry, data->wbuffer);
 				if (data->wbuffer->error) {
@@ -408,7 +420,7 @@ static int snd_info_entry_release(struct inode *inode, struct file *file)
 						data->wbuffer->error);
 				}
 			}
-			vfree(data->wbuffer->buffer);
+			kfree(data->wbuffer->buffer);
 			kfree(data->wbuffer);
 		}
 		break;
@@ -668,24 +680,22 @@ int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 	if (len <= 0 || buffer->stop || buffer->error)
 		return 1;
 	while (--len > 0) {
-		c = *buffer->curr++;
+		c = buffer->buffer[buffer->curr++];
 		if (c == '\n') {
-			if ((buffer->curr - buffer->buffer) >= (long)buffer->size) {
+			if (buffer->curr >= buffer->size)
 				buffer->stop = 1;
-			}
 			break;
 		}
 		*line++ = c;
-		if ((buffer->curr - buffer->buffer) >= (long)buffer->size) {
+		if (buffer->curr >= buffer->size) {
 			buffer->stop = 1;
 			break;
 		}
 	}
 	while (c != '\n' && !buffer->stop) {
-		c = *buffer->curr++;
-		if ((buffer->curr - buffer->buffer) >= (long)buffer->size) {
+		c = buffer->buffer[buffer->curr++];
+		if (buffer->curr >= buffer->size)
 			buffer->stop = 1;
-		}
 	}
 	*line = '\0';
 	return 0;
@@ -978,7 +988,6 @@ static int __init snd_info_version_init(void)
 	entry = snd_info_create_module_entry(THIS_MODULE, "version", NULL);
 	if (entry == NULL)
 		return -ENOMEM;
-	entry->c.text.read_size = 256;
 	entry->c.text.read = snd_info_version_read;
 	if (snd_info_register(entry) < 0) {
 		snd_info_free_entry(entry);

commit c0d3fb39e9511c6fad17d059a3a50d1be33add24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:39 2006 +0200

    [ALSA] Clean up EXPORT_SYMBOL()s in snd module
    
    Move EXPORT_SYMBOL()s to places adjacent to functions/variables.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 2582b74d3199..9c288539e99d 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -111,12 +111,16 @@ int snd_iprintf(struct snd_info_buffer *buffer, char *fmt,...)
 	return res;
 }
 
+EXPORT_SYMBOL(snd_iprintf);
+
 /*
 
  */
 
 static struct proc_dir_entry *snd_proc_root = NULL;
 struct snd_info_entry *snd_seq_root = NULL;
+EXPORT_SYMBOL(snd_seq_root);
+
 #ifdef CONFIG_SND_OSSEMUL
 struct snd_info_entry *snd_oss_root = NULL;
 #endif
@@ -687,6 +691,8 @@ int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_info_get_line);
+
 /**
  * snd_info_get_str - parse a string token
  * @dest: the buffer to store the string token
@@ -723,6 +729,8 @@ char *snd_info_get_str(char *dest, char *src, int len)
 	return src;
 }
 
+EXPORT_SYMBOL(snd_info_get_str);
+
 /**
  * snd_info_create_entry - create an info entry
  * @name: the proc file name
@@ -774,6 +782,8 @@ struct snd_info_entry *snd_info_create_module_entry(struct module * module,
 	return entry;
 }
 
+EXPORT_SYMBOL(snd_info_create_module_entry);
+
 /**
  * snd_info_create_card_entry - create an info entry for the given card
  * @card: the card instance
@@ -797,6 +807,8 @@ struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 	return entry;
 }
 
+EXPORT_SYMBOL(snd_info_create_card_entry);
+
 static int snd_info_dev_free_entry(struct snd_device *device)
 {
 	struct snd_info_entry *entry = device->device_data;
@@ -867,6 +879,8 @@ int snd_card_proc_new(struct snd_card *card, const char *name,
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_card_proc_new);
+
 /**
  * snd_info_free_entry - release the info entry
  * @entry: the info entry
@@ -883,6 +897,8 @@ void snd_info_free_entry(struct snd_info_entry * entry)
 	kfree(entry);
 }
 
+EXPORT_SYMBOL(snd_info_free_entry);
+
 /**
  * snd_info_register - register the info entry
  * @entry: the info entry
@@ -913,6 +929,8 @@ int snd_info_register(struct snd_info_entry * entry)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_info_register);
+
 /**
  * snd_info_unregister - de-register the info entry
  * @entry: the info entry
@@ -937,6 +955,8 @@ int snd_info_unregister(struct snd_info_entry * entry)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_info_unregister);
+
 /*
 
  */

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index af123e3bdb24..2582b74d3199 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -31,6 +31,7 @@
 #include <sound/version.h>
 #include <linux/proc_fs.h>
 #include <linux/devfs_fs_kernel.h>
+#include <linux/mutex.h>
 #include <stdarg.h>
 
 /*
@@ -68,7 +69,7 @@ int snd_info_check_reserved_words(const char *str)
 	return 1;
 }
 
-static DECLARE_MUTEX(info_mutex);
+static DEFINE_MUTEX(info_mutex);
 
 struct snd_info_private_data {
 	struct snd_info_buffer *rbuffer;
@@ -265,11 +266,11 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 	struct proc_dir_entry *p;
 	int mode, err;
 
-	down(&info_mutex);
+	mutex_lock(&info_mutex);
 	p = PDE(inode);
 	entry = p == NULL ? NULL : (struct snd_info_entry *)p->data;
 	if (entry == NULL || entry->disconnected) {
-		up(&info_mutex);
+		mutex_unlock(&info_mutex);
 		return -ENODEV;
 	}
 	if (!try_module_get(entry->module)) {
@@ -361,13 +362,13 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 		break;
 	}
 	file->private_data = data;
-	up(&info_mutex);
+	mutex_unlock(&info_mutex);
 	if (entry->content == SNDRV_INFO_CONTENT_TEXT &&
 	    (mode == O_RDONLY || mode == O_RDWR)) {
 		if (entry->c.text.read) {
-			down(&entry->access);
+			mutex_lock(&entry->access);
 			entry->c.text.read(entry, data->rbuffer);
-			up(&entry->access);
+			mutex_unlock(&entry->access);
 		}
 	}
 	return 0;
@@ -375,7 +376,7 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
       __error:
 	module_put(entry->module);
       __error1:
-	up(&info_mutex);
+	mutex_unlock(&info_mutex);
 	return err;
 }
 
@@ -747,7 +748,7 @@ static struct snd_info_entry *snd_info_create_entry(const char *name)
 	}
 	entry->mode = S_IFREG | S_IRUGO;
 	entry->content = SNDRV_INFO_CONTENT_TEXT;
-	init_MUTEX(&entry->access);
+	mutex_init(&entry->access);
 	return entry;
 }
 
@@ -896,10 +897,10 @@ int snd_info_register(struct snd_info_entry * entry)
 
 	snd_assert(entry != NULL, return -ENXIO);
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
-	down(&info_mutex);
+	mutex_lock(&info_mutex);
 	p = snd_create_proc_entry(entry->name, entry->mode, root);
 	if (!p) {
-		up(&info_mutex);
+		mutex_unlock(&info_mutex);
 		return -ENOMEM;
 	}
 	p->owner = entry->module;
@@ -908,7 +909,7 @@ int snd_info_register(struct snd_info_entry * entry)
 	p->size = entry->size;
 	p->data = entry;
 	entry->p = p;
-	up(&info_mutex);
+	mutex_unlock(&info_mutex);
 	return 0;
 }
 
@@ -929,9 +930,9 @@ int snd_info_unregister(struct snd_info_entry * entry)
 	snd_assert(entry->p != NULL, return -ENXIO);
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
 	snd_assert(root, return -ENXIO);
-	down(&info_mutex);
+	mutex_lock(&info_mutex);
 	snd_remove_proc_entry(root, entry->p);
-	up(&info_mutex);
+	mutex_unlock(&info_mutex);
 	snd_info_free_entry(entry);
 	return 0;
 }

commit d99e98891ccde745c6c25b7a11a139123e74db4c
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 9 16:44:46 2006 +0100

    [ALSA] Remove BKL from sound/core/info.c
    
    Modules: ALSA Core
    
    Remove BKL from sound/core/info.c
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index ae8853921464..af123e3bdb24 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -444,8 +444,8 @@ static unsigned int snd_info_entry_poll(struct file *file, poll_table * wait)
 	return mask;
 }
 
-static inline int _snd_info_entry_ioctl(struct inode *inode, struct file *file,
-					unsigned int cmd, unsigned long arg)
+static long snd_info_entry_ioctl(struct file *file, unsigned int cmd,
+				unsigned long arg)
 {
 	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
@@ -465,17 +465,6 @@ static inline int _snd_info_entry_ioctl(struct inode *inode, struct file *file,
 	return -ENOTTY;
 }
 
-/* FIXME: need to unlock BKL to allow preemption */
-static int snd_info_entry_ioctl(struct inode *inode, struct file *file,
-				unsigned int cmd, unsigned long arg)
-{
-	int err;
-	unlock_kernel();
-	err = _snd_info_entry_ioctl(inode, file, cmd, arg);
-	lock_kernel();
-	return err;
-}
-
 static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	struct inode *inode = file->f_dentry->d_inode;
@@ -499,15 +488,15 @@ static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
 
 static struct file_operations snd_info_entry_operations =
 {
-	.owner =	THIS_MODULE,
-	.llseek =	snd_info_entry_llseek,
-	.read =		snd_info_entry_read,
-	.write =	snd_info_entry_write,
-	.poll =		snd_info_entry_poll,
-	.ioctl =	snd_info_entry_ioctl,
-	.mmap =		snd_info_entry_mmap,
-	.open =		snd_info_entry_open,
-	.release =	snd_info_entry_release,
+	.owner =		THIS_MODULE,
+	.llseek =		snd_info_entry_llseek,
+	.read =			snd_info_entry_read,
+	.write =		snd_info_entry_write,
+	.poll =			snd_info_entry_poll,
+	.unlocked_ioctl =	snd_info_entry_ioctl,
+	.mmap =			snd_info_entry_mmap,
+	.open =			snd_info_entry_open,
+	.release =		snd_info_entry_release,
 };
 
 /**

commit e28563cceb9f258ebe3c50fc27d8f4ff0ac4bfa4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:42:42 2005 +0100

    [ALSA] Optimize for config without PROC_FS
    
    Modules: HWDEP Midlevel,ALSA Core,PCM Midlevel,Timer Midlevel
    
    Optimize the code when compiled without CONFIG_PROC_FS.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index ec3282f266f0..ae8853921464 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -37,6 +37,8 @@
  *
  */
 
+#ifdef CONFIG_PROC_FS
+
 int snd_info_check_reserved_words(const char *str)
 {
 	static char *reserved[] =
@@ -66,8 +68,6 @@ int snd_info_check_reserved_words(const char *str)
 	return 1;
 }
 
-#ifdef CONFIG_PROC_FS
-
 static DECLARE_MUTEX(info_mutex);
 
 struct snd_info_private_data {
@@ -580,12 +580,10 @@ int __exit snd_info_done(void)
 	snd_info_version_done();
 	if (snd_proc_root) {
 #if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
-		if (snd_seq_root)
-			snd_info_unregister(snd_seq_root);
+		snd_info_unregister(snd_seq_root);
 #endif
 #ifdef CONFIG_SND_OSSEMUL
-		if (snd_oss_root)
-			snd_info_unregister(snd_oss_root);
+		snd_info_unregister(snd_oss_root);
 #endif
 		snd_remove_proc_entry(&proc_root, snd_proc_root);
 	}
@@ -937,7 +935,8 @@ int snd_info_unregister(struct snd_info_entry * entry)
 {
 	struct proc_dir_entry *root;
 
-	snd_assert(entry != NULL, return -ENXIO);
+	if (! entry)
+		return 0;
 	snd_assert(entry->p != NULL, return -ENXIO);
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
 	snd_assert(root, return -ENXIO);

commit 24c1f93188b4438c7f30df5b4cd78340cdb28daf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:58:48 2005 +0100

    [ALSA] Remove xxx_t typedefs: Proc handler
    
    Modules: ALSA Core
    
    Remove xxx_t typedefs from the core proc handler codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 39f9b97d9219..ec3282f266f0 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -70,12 +70,12 @@ int snd_info_check_reserved_words(const char *str)
 
 static DECLARE_MUTEX(info_mutex);
 
-typedef struct _snd_info_private_data {
-	snd_info_buffer_t *rbuffer;
-	snd_info_buffer_t *wbuffer;
-	snd_info_entry_t *entry;
+struct snd_info_private_data {
+	struct snd_info_buffer *rbuffer;
+	struct snd_info_buffer *wbuffer;
+	struct snd_info_entry *entry;
 	void *file_private_data;
-} snd_info_private_data_t;
+};
 
 static int snd_info_version_init(void);
 static int snd_info_version_done(void);
@@ -90,7 +90,7 @@ static int snd_info_version_done(void);
  *
  * Returns the size of output string.
  */
-int snd_iprintf(snd_info_buffer_t * buffer, char *fmt,...)
+int snd_iprintf(struct snd_info_buffer *buffer, char *fmt,...)
 {
 	va_list args;
 	int len, res;
@@ -115,9 +115,9 @@ int snd_iprintf(snd_info_buffer_t * buffer, char *fmt,...)
  */
 
 static struct proc_dir_entry *snd_proc_root = NULL;
-snd_info_entry_t *snd_seq_root = NULL;
+struct snd_info_entry *snd_seq_root = NULL;
 #ifdef CONFIG_SND_OSSEMUL
-snd_info_entry_t *snd_oss_root = NULL;
+struct snd_info_entry *snd_oss_root = NULL;
 #endif
 
 static inline void snd_info_entry_prepare(struct proc_dir_entry *de)
@@ -134,7 +134,7 @@ static void snd_remove_proc_entry(struct proc_dir_entry *parent,
 
 static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 {
-	snd_info_private_data_t *data;
+	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
 	loff_t ret;
 
@@ -176,9 +176,9 @@ static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
 static ssize_t snd_info_entry_read(struct file *file, char __user *buffer,
 				   size_t count, loff_t * offset)
 {
-	snd_info_private_data_t *data;
+	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
-	snd_info_buffer_t *buf;
+	struct snd_info_buffer *buf;
 	size_t size = 0;
 	loff_t pos;
 
@@ -217,9 +217,9 @@ static ssize_t snd_info_entry_read(struct file *file, char __user *buffer,
 static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer,
 				    size_t count, loff_t * offset)
 {
-	snd_info_private_data_t *data;
+	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
-	snd_info_buffer_t *buf;
+	struct snd_info_buffer *buf;
 	size_t size = 0;
 	loff_t pos;
 
@@ -259,15 +259,15 @@ static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer
 
 static int snd_info_entry_open(struct inode *inode, struct file *file)
 {
-	snd_info_entry_t *entry;
-	snd_info_private_data_t *data;
-	snd_info_buffer_t *buffer;
+	struct snd_info_entry *entry;
+	struct snd_info_private_data *data;
+	struct snd_info_buffer *buffer;
 	struct proc_dir_entry *p;
 	int mode, err;
 
 	down(&info_mutex);
 	p = PDE(inode);
-	entry = p == NULL ? NULL : (snd_info_entry_t *)p->data;
+	entry = p == NULL ? NULL : (struct snd_info_entry *)p->data;
 	if (entry == NULL || entry->disconnected) {
 		up(&info_mutex);
 		return -ENODEV;
@@ -381,8 +381,8 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 
 static int snd_info_entry_release(struct inode *inode, struct file *file)
 {
-	snd_info_entry_t *entry;
-	snd_info_private_data_t *data;
+	struct snd_info_entry *entry;
+	struct snd_info_private_data *data;
 	int mode;
 
 	mode = file->f_flags & O_ACCMODE;
@@ -420,7 +420,7 @@ static int snd_info_entry_release(struct inode *inode, struct file *file)
 
 static unsigned int snd_info_entry_poll(struct file *file, poll_table * wait)
 {
-	snd_info_private_data_t *data;
+	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
 	unsigned int mask;
 
@@ -447,7 +447,7 @@ static unsigned int snd_info_entry_poll(struct file *file, poll_table * wait)
 static inline int _snd_info_entry_ioctl(struct inode *inode, struct file *file,
 					unsigned int cmd, unsigned long arg)
 {
-	snd_info_private_data_t *data;
+	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
 
 	data = file->private_data;
@@ -479,7 +479,7 @@ static int snd_info_entry_ioctl(struct inode *inode, struct file *file,
 static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	struct inode *inode = file->f_dentry->d_inode;
-	snd_info_private_data_t *data;
+	struct snd_info_private_data *data;
 	struct snd_info_entry *entry;
 
 	data = file->private_data;
@@ -541,7 +541,7 @@ int __init snd_info_init(void)
 	snd_proc_root = p;
 #ifdef CONFIG_SND_OSSEMUL
 	{
-		snd_info_entry_t *entry;
+		struct snd_info_entry *entry;
 		if ((entry = snd_info_create_module_entry(THIS_MODULE, "oss", NULL)) == NULL)
 			return -ENOMEM;
 		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
@@ -554,7 +554,7 @@ int __init snd_info_init(void)
 #endif
 #if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
 	{
-		snd_info_entry_t *entry;
+		struct snd_info_entry *entry;
 		if ((entry = snd_info_create_module_entry(THIS_MODULE, "seq", NULL)) == NULL)
 			return -ENOMEM;
 		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
@@ -601,10 +601,10 @@ int __exit snd_info_done(void)
  * create a card proc file
  * called from init.c
  */
-int snd_info_card_create(snd_card_t * card)
+int snd_info_card_create(struct snd_card *card)
 {
 	char str[8];
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	snd_assert(card != NULL, return -ENXIO);
 
@@ -624,7 +624,7 @@ int snd_info_card_create(snd_card_t * card)
  * register the card proc file
  * called from init.c
  */
-int snd_info_card_register(snd_card_t * card)
+int snd_info_card_register(struct snd_card *card)
 {
 	struct proc_dir_entry *p;
 
@@ -644,7 +644,7 @@ int snd_info_card_register(snd_card_t * card)
  * de-register the card proc file
  * called from init.c
  */
-int snd_info_card_free(snd_card_t * card)
+int snd_info_card_free(struct snd_card *card)
 {
 	snd_assert(card != NULL, return -ENXIO);
 	if (card->proc_root_link) {
@@ -669,7 +669,7 @@ int snd_info_card_free(snd_card_t * card)
  *
  * Returns zero if successful, or 1 if error or EOF.
  */
-int snd_info_get_line(snd_info_buffer_t * buffer, char *line, int len)
+int snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)
 {
 	int c = -1;
 
@@ -747,9 +747,9 @@ char *snd_info_get_str(char *dest, char *src, int len)
  *
  * Returns the pointer of the new instance, or NULL on failure.
  */
-static snd_info_entry_t *snd_info_create_entry(const char *name)
+static struct snd_info_entry *snd_info_create_entry(const char *name)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (entry == NULL)
 		return NULL;
@@ -774,11 +774,11 @@ static snd_info_entry_t *snd_info_create_entry(const char *name)
  *
  * Returns the pointer of the new instance, or NULL on failure.
  */
-snd_info_entry_t *snd_info_create_module_entry(struct module * module,
+struct snd_info_entry *snd_info_create_module_entry(struct module * module,
 					       const char *name,
-					       snd_info_entry_t *parent)
+					       struct snd_info_entry *parent)
 {
-	snd_info_entry_t *entry = snd_info_create_entry(name);
+	struct snd_info_entry *entry = snd_info_create_entry(name);
 	if (entry) {
 		entry->module = module;
 		entry->parent = parent;
@@ -796,11 +796,11 @@ snd_info_entry_t *snd_info_create_module_entry(struct module * module,
  *
  * Returns the pointer of the new instance, or NULL on failure.
  */
-snd_info_entry_t *snd_info_create_card_entry(snd_card_t * card,
+struct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,
 					     const char *name,
-					     snd_info_entry_t * parent)
+					     struct snd_info_entry * parent)
 {
-	snd_info_entry_t *entry = snd_info_create_entry(name);
+	struct snd_info_entry *entry = snd_info_create_entry(name);
 	if (entry) {
 		entry->module = card->module;
 		entry->card = card;
@@ -809,29 +809,29 @@ snd_info_entry_t *snd_info_create_card_entry(snd_card_t * card,
 	return entry;
 }
 
-static int snd_info_dev_free_entry(snd_device_t *device)
+static int snd_info_dev_free_entry(struct snd_device *device)
 {
-	snd_info_entry_t *entry = device->device_data;
+	struct snd_info_entry *entry = device->device_data;
 	snd_info_free_entry(entry);
 	return 0;
 }
 
-static int snd_info_dev_register_entry(snd_device_t *device)
+static int snd_info_dev_register_entry(struct snd_device *device)
 {
-	snd_info_entry_t *entry = device->device_data;
+	struct snd_info_entry *entry = device->device_data;
 	return snd_info_register(entry);
 }
 
-static int snd_info_dev_disconnect_entry(snd_device_t *device)
+static int snd_info_dev_disconnect_entry(struct snd_device *device)
 {
-	snd_info_entry_t *entry = device->device_data;
+	struct snd_info_entry *entry = device->device_data;
 	entry->disconnected = 1;
 	return 0;
 }
 
-static int snd_info_dev_unregister_entry(snd_device_t *device)
+static int snd_info_dev_unregister_entry(struct snd_device *device)
 {
-	snd_info_entry_t *entry = device->device_data;
+	struct snd_info_entry *entry = device->device_data;
 	return snd_info_unregister(entry);
 }
 
@@ -855,16 +855,16 @@ static int snd_info_dev_unregister_entry(snd_device_t *device)
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_card_proc_new(snd_card_t *card, const char *name,
-		      snd_info_entry_t **entryp)
+int snd_card_proc_new(struct snd_card *card, const char *name,
+		      struct snd_info_entry **entryp)
 {
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free = snd_info_dev_free_entry,
 		.dev_register =	snd_info_dev_register_entry,
 		.dev_disconnect = snd_info_dev_disconnect_entry,
 		.dev_unregister = snd_info_dev_unregister_entry
 	};
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 	int err;
 
 	entry = snd_info_create_card_entry(card, name, card->proc_root);
@@ -885,7 +885,7 @@ int snd_card_proc_new(snd_card_t *card, const char *name,
  *
  * Releases the info entry.  Don't call this after registered.
  */
-void snd_info_free_entry(snd_info_entry_t * entry)
+void snd_info_free_entry(struct snd_info_entry * entry)
 {
 	if (entry == NULL)
 		return;
@@ -903,7 +903,7 @@ void snd_info_free_entry(snd_info_entry_t * entry)
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_info_register(snd_info_entry_t * entry)
+int snd_info_register(struct snd_info_entry * entry)
 {
 	struct proc_dir_entry *root, *p = NULL;
 
@@ -933,7 +933,7 @@ int snd_info_register(snd_info_entry_t * entry)
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_info_unregister(snd_info_entry_t * entry)
+int snd_info_unregister(struct snd_info_entry * entry)
 {
 	struct proc_dir_entry *root;
 
@@ -952,9 +952,9 @@ int snd_info_unregister(snd_info_entry_t * entry)
 
  */
 
-static snd_info_entry_t *snd_info_version_entry = NULL;
+static struct snd_info_entry *snd_info_version_entry = NULL;
 
-static void snd_info_version_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	snd_iprintf(buffer,
 		    "Advanced Linux Sound Architecture Driver Version "
@@ -964,7 +964,7 @@ static void snd_info_version_read(snd_info_entry_t *entry, snd_info_buffer_t * b
 
 static int __init snd_info_version_init(void)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	entry = snd_info_create_module_entry(THIS_MODULE, "version", NULL);
 	if (entry == NULL)

commit e38e0cfa48ac38f4fe24453d2523852467c95b21
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:59:52 2005 +0200

    [ALSA] Remove kmalloc wrappers
    
    Modules: ALSA Core
    
    Remove kmalloc wrappers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 37024d68a26e..39f9b97d9219 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -566,7 +566,6 @@ int __init snd_info_init(void)
 	}
 #endif
 	snd_info_version_init();
-	snd_memory_info_init();
 	snd_minor_info_init();
 	snd_minor_info_oss_init();
 	snd_card_info_init();
@@ -578,7 +577,6 @@ int __exit snd_info_done(void)
 	snd_card_info_done();
 	snd_minor_info_oss_done();
 	snd_minor_info_done();
-	snd_memory_info_done();
 	snd_info_version_done();
 	if (snd_proc_root) {
 #if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)

commit ca2c0966562cfbf9273167a5b60e8fddc24078d6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:23 2005 +0200

    [ALSA] Replace with kzalloc() - core stuff
    
    Control Midlevel,ALSA Core,HWDEP Midlevel,PCM Midlevel,RawMidi Midlevel
    Timer Midlevel,ALSA<-OSS emulation
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 7f8bdf7b0058..37024d68a26e 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -295,7 +295,7 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 		    	goto __error;
 		}
 	}
-	data = kcalloc(1, sizeof(*data), GFP_KERNEL);
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (data == NULL) {
 		err = -ENOMEM;
 		goto __error;
@@ -304,7 +304,7 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 	switch (entry->content) {
 	case SNDRV_INFO_CONTENT_TEXT:
 		if (mode == O_RDONLY || mode == O_RDWR) {
-			buffer = kcalloc(1, sizeof(*buffer), GFP_KERNEL);
+			buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
 			if (buffer == NULL) {
 				kfree(data);
 				err = -ENOMEM;
@@ -323,7 +323,7 @@ static int snd_info_entry_open(struct inode *inode, struct file *file)
 			data->rbuffer = buffer;
 		}
 		if (mode == O_WRONLY || mode == O_RDWR) {
-			buffer = kcalloc(1, sizeof(*buffer), GFP_KERNEL);
+			buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
 			if (buffer == NULL) {
 				if (mode == O_RDWR) {
 					vfree(data->rbuffer->buffer);
@@ -752,7 +752,7 @@ char *snd_info_get_str(char *dest, char *src, int len)
 static snd_info_entry_t *snd_info_create_entry(const char *name)
 {
 	snd_info_entry_t *entry;
-	entry = kcalloc(1, sizeof(*entry), GFP_KERNEL);
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (entry == NULL)
 		return NULL;
 	entry->name = kstrdup(name, GFP_KERNEL);

commit 856def8a4695066e6cbd2919c5987f1df23dbe8a
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Fri Jul 8 13:53:42 2005 +0200

    [ALSA] typo-fix and snd_assert()-expression-split
    
    ALSA Core
    This patch corrects a typo in the kerneldocs of snd_info_get_str().
    It also splits the expressions of snd_assert() in snd_info_unregister()
    into one-expression-per-call for better debugging.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/info.c b/sound/core/info.c
index 5e122bbe7c92..7f8bdf7b0058 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -702,7 +702,7 @@ int snd_info_get_line(snd_info_buffer_t * buffer, char *line, int len)
 }
 
 /**
- * snd_info_get_line - parse a string token
+ * snd_info_get_str - parse a string token
  * @dest: the buffer to store the string token
  * @src: the original string
  * @len: the max. length of token - 1
@@ -939,7 +939,8 @@ int snd_info_unregister(snd_info_entry_t * entry)
 {
 	struct proc_dir_entry *root;
 
-	snd_assert(entry != NULL && entry->p != NULL, return -ENXIO);
+	snd_assert(entry != NULL, return -ENXIO);
+	snd_assert(entry->p != NULL, return -ENXIO);
 	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
 	snd_assert(root, return -ENXIO);
 	down(&info_mutex);

commit 543537bd922692bc978e2e356fcd8bfc9c2ee7d5
Author: Paulo Marques <pmarques@grupopie.com>
Date:   Thu Jun 23 00:09:02 2005 -0700

    [PATCH] create a kstrdup library function
    
    This patch creates a new kstrdup library function and changes the "local"
    implementations in several places to use this function.
    
    Most of the changes come from the sound and net subsystems.  The sound part
    had already been acknowledged by Takashi Iwai and the net part by David S.
    Miller.
    
    I left UML alone for now because I would need more time to read the code
    carefully before making changes there.
    
    Signed-off-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/info.c b/sound/core/info.c
index 31faffe01cb0..5e122bbe7c92 100644
--- a/sound/core/info.c
+++ b/sound/core/info.c
@@ -24,6 +24,7 @@
 #include <linux/vmalloc.h>
 #include <linux/time.h>
 #include <linux/smp_lock.h>
+#include <linux/string.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/info.h>
@@ -754,7 +755,7 @@ static snd_info_entry_t *snd_info_create_entry(const char *name)
 	entry = kcalloc(1, sizeof(*entry), GFP_KERNEL);
 	if (entry == NULL)
 		return NULL;
-	entry->name = snd_kmalloc_strdup(name, GFP_KERNEL);
+	entry->name = kstrdup(name, GFP_KERNEL);
 	if (entry->name == NULL) {
 		kfree(entry);
 		return NULL;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/info.c b/sound/core/info.c
new file mode 100644
index 000000000000..31faffe01cb0
--- /dev/null
+++ b/sound/core/info.c
@@ -0,0 +1,989 @@
+/*
+ *  Information interface for ALSA driver
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/time.h>
+#include <linux/smp_lock.h>
+#include <sound/core.h>
+#include <sound/minors.h>
+#include <sound/info.h>
+#include <sound/version.h>
+#include <linux/proc_fs.h>
+#include <linux/devfs_fs_kernel.h>
+#include <stdarg.h>
+
+/*
+ *
+ */
+
+int snd_info_check_reserved_words(const char *str)
+{
+	static char *reserved[] =
+	{
+		"version",
+		"meminfo",
+		"memdebug",
+		"detect",
+		"devices",
+		"oss",
+		"cards",
+		"timers",
+		"synth",
+		"pcm",
+		"seq",
+		NULL
+	};
+	char **xstr = reserved;
+
+	while (*xstr) {
+		if (!strcmp(*xstr, str))
+			return 0;
+		xstr++;
+	}
+	if (!strncmp(str, "card", 4))
+		return 0;
+	return 1;
+}
+
+#ifdef CONFIG_PROC_FS
+
+static DECLARE_MUTEX(info_mutex);
+
+typedef struct _snd_info_private_data {
+	snd_info_buffer_t *rbuffer;
+	snd_info_buffer_t *wbuffer;
+	snd_info_entry_t *entry;
+	void *file_private_data;
+} snd_info_private_data_t;
+
+static int snd_info_version_init(void);
+static int snd_info_version_done(void);
+
+
+/**
+ * snd_iprintf - printf on the procfs buffer
+ * @buffer: the procfs buffer
+ * @fmt: the printf format
+ *
+ * Outputs the string on the procfs buffer just like printf().
+ *
+ * Returns the size of output string.
+ */
+int snd_iprintf(snd_info_buffer_t * buffer, char *fmt,...)
+{
+	va_list args;
+	int len, res;
+
+	if (buffer->stop || buffer->error)
+		return 0;
+	len = buffer->len - buffer->size;
+	va_start(args, fmt);
+	res = vsnprintf(buffer->curr, len, fmt, args);
+	va_end(args);
+	if (res >= len) {
+		buffer->stop = 1;
+		return 0;
+	}
+	buffer->curr += res;
+	buffer->size += res;
+	return res;
+}
+
+/*
+
+ */
+
+static struct proc_dir_entry *snd_proc_root = NULL;
+snd_info_entry_t *snd_seq_root = NULL;
+#ifdef CONFIG_SND_OSSEMUL
+snd_info_entry_t *snd_oss_root = NULL;
+#endif
+
+static inline void snd_info_entry_prepare(struct proc_dir_entry *de)
+{
+	de->owner = THIS_MODULE;
+}
+
+static void snd_remove_proc_entry(struct proc_dir_entry *parent,
+				  struct proc_dir_entry *de)
+{
+	if (de)
+		remove_proc_entry(de->name, parent);
+}
+
+static loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)
+{
+	snd_info_private_data_t *data;
+	struct snd_info_entry *entry;
+	loff_t ret;
+
+	data = file->private_data;
+	entry = data->entry;
+	lock_kernel();
+	switch (entry->content) {
+	case SNDRV_INFO_CONTENT_TEXT:
+		switch (orig) {
+		case 0:	/* SEEK_SET */
+			file->f_pos = offset;
+			ret = file->f_pos;
+			goto out;
+		case 1:	/* SEEK_CUR */
+			file->f_pos += offset;
+			ret = file->f_pos;
+			goto out;
+		case 2:	/* SEEK_END */
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+		break;
+	case SNDRV_INFO_CONTENT_DATA:
+		if (entry->c.ops->llseek) {
+			ret = entry->c.ops->llseek(entry,
+						    data->file_private_data,
+						    file, offset, orig);
+			goto out;
+		}
+		break;
+	}
+	ret = -ENXIO;
+out:
+	unlock_kernel();
+	return ret;
+}
+
+static ssize_t snd_info_entry_read(struct file *file, char __user *buffer,
+				   size_t count, loff_t * offset)
+{
+	snd_info_private_data_t *data;
+	struct snd_info_entry *entry;
+	snd_info_buffer_t *buf;
+	size_t size = 0;
+	loff_t pos;
+
+	data = file->private_data;
+	snd_assert(data != NULL, return -ENXIO);
+	pos = *offset;
+	if (pos < 0 || (long) pos != pos || (ssize_t) count < 0)
+		return -EIO;
+	if ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)
+		return -EIO;
+	entry = data->entry;
+	switch (entry->content) {
+	case SNDRV_INFO_CONTENT_TEXT:
+		buf = data->rbuffer;
+		if (buf == NULL)
+			return -EIO;
+		if (pos >= buf->size)
+			return 0;
+		size = buf->size - pos;
+		size = min(count, size);
+		if (copy_to_user(buffer, buf->buffer + pos, size))
+			return -EFAULT;
+		break;
+	case SNDRV_INFO_CONTENT_DATA:
+		if (entry->c.ops->read)
+			size = entry->c.ops->read(entry,
+						  data->file_private_data,
+						  file, buffer, count, pos);
+		break;
+	}
+	if ((ssize_t) size > 0)
+		*offset = pos + size;
+	return size;
+}
+
+static ssize_t snd_info_entry_write(struct file *file, const char __user *buffer,
+				    size_t count, loff_t * offset)
+{
+	snd_info_private_data_t *data;
+	struct snd_info_entry *entry;
+	snd_info_buffer_t *buf;
+	size_t size = 0;
+	loff_t pos;
+
+	data = file->private_data;
+	snd_assert(data != NULL, return -ENXIO);
+	entry = data->entry;
+	pos = *offset;
+	if (pos < 0 || (long) pos != pos || (ssize_t) count < 0)
+		return -EIO;
+	if ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)
+		return -EIO;
+	switch (entry->content) {
+	case SNDRV_INFO_CONTENT_TEXT:
+		buf = data->wbuffer;
+		if (buf == NULL)
+			return -EIO;
+		if (pos >= buf->len)
+			return -ENOMEM;
+		size = buf->len - pos;
+		size = min(count, size);
+		if (copy_from_user(buf->buffer + pos, buffer, size))
+			return -EFAULT;
+		if ((long)buf->size < pos + size)
+			buf->size = pos + size;
+		break;
+	case SNDRV_INFO_CONTENT_DATA:
+		if (entry->c.ops->write)
+			size = entry->c.ops->write(entry,
+						   data->file_private_data,
+						   file, buffer, count, pos);
+		break;
+	}
+	if ((ssize_t) size > 0)
+		*offset = pos + size;
+	return size;
+}
+
+static int snd_info_entry_open(struct inode *inode, struct file *file)
+{
+	snd_info_entry_t *entry;
+	snd_info_private_data_t *data;
+	snd_info_buffer_t *buffer;
+	struct proc_dir_entry *p;
+	int mode, err;
+
+	down(&info_mutex);
+	p = PDE(inode);
+	entry = p == NULL ? NULL : (snd_info_entry_t *)p->data;
+	if (entry == NULL || entry->disconnected) {
+		up(&info_mutex);
+		return -ENODEV;
+	}
+	if (!try_module_get(entry->module)) {
+		err = -EFAULT;
+		goto __error1;
+	}
+	mode = file->f_flags & O_ACCMODE;
+	if (mode == O_RDONLY || mode == O_RDWR) {
+		if ((entry->content == SNDRV_INFO_CONTENT_TEXT &&
+		     !entry->c.text.read_size) ||
+		    (entry->content == SNDRV_INFO_CONTENT_DATA &&
+		     entry->c.ops->read == NULL)) {
+		    	err = -ENODEV;
+		    	goto __error;
+		}
+	}
+	if (mode == O_WRONLY || mode == O_RDWR) {
+		if ((entry->content == SNDRV_INFO_CONTENT_TEXT &&
+		     !entry->c.text.write_size) ||
+		    (entry->content == SNDRV_INFO_CONTENT_DATA &&
+		     entry->c.ops->write == NULL)) {
+		    	err = -ENODEV;
+		    	goto __error;
+		}
+	}
+	data = kcalloc(1, sizeof(*data), GFP_KERNEL);
+	if (data == NULL) {
+		err = -ENOMEM;
+		goto __error;
+	}
+	data->entry = entry;
+	switch (entry->content) {
+	case SNDRV_INFO_CONTENT_TEXT:
+		if (mode == O_RDONLY || mode == O_RDWR) {
+			buffer = kcalloc(1, sizeof(*buffer), GFP_KERNEL);
+			if (buffer == NULL) {
+				kfree(data);
+				err = -ENOMEM;
+				goto __error;
+			}
+			buffer->len = (entry->c.text.read_size +
+				      (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
+			buffer->buffer = vmalloc(buffer->len);
+			if (buffer->buffer == NULL) {
+				kfree(buffer);
+				kfree(data);
+				err = -ENOMEM;
+				goto __error;
+			}
+			buffer->curr = buffer->buffer;
+			data->rbuffer = buffer;
+		}
+		if (mode == O_WRONLY || mode == O_RDWR) {
+			buffer = kcalloc(1, sizeof(*buffer), GFP_KERNEL);
+			if (buffer == NULL) {
+				if (mode == O_RDWR) {
+					vfree(data->rbuffer->buffer);
+					kfree(data->rbuffer);
+				}
+				kfree(data);
+				err = -ENOMEM;
+				goto __error;
+			}
+			buffer->len = (entry->c.text.write_size +
+				      (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
+			buffer->buffer = vmalloc(buffer->len);
+			if (buffer->buffer == NULL) {
+				if (mode == O_RDWR) {
+					vfree(data->rbuffer->buffer);
+					kfree(data->rbuffer);
+				}
+				kfree(buffer);
+				kfree(data);
+				err = -ENOMEM;
+				goto __error;
+			}
+			buffer->curr = buffer->buffer;
+			data->wbuffer = buffer;
+		}
+		break;
+	case SNDRV_INFO_CONTENT_DATA:	/* data */
+		if (entry->c.ops->open) {
+			if ((err = entry->c.ops->open(entry, mode,
+						      &data->file_private_data)) < 0) {
+				kfree(data);
+				goto __error;
+			}
+		}
+		break;
+	}
+	file->private_data = data;
+	up(&info_mutex);
+	if (entry->content == SNDRV_INFO_CONTENT_TEXT &&
+	    (mode == O_RDONLY || mode == O_RDWR)) {
+		if (entry->c.text.read) {
+			down(&entry->access);
+			entry->c.text.read(entry, data->rbuffer);
+			up(&entry->access);
+		}
+	}
+	return 0;
+
+      __error:
+	module_put(entry->module);
+      __error1:
+	up(&info_mutex);
+	return err;
+}
+
+static int snd_info_entry_release(struct inode *inode, struct file *file)
+{
+	snd_info_entry_t *entry;
+	snd_info_private_data_t *data;
+	int mode;
+
+	mode = file->f_flags & O_ACCMODE;
+	data = file->private_data;
+	entry = data->entry;
+	switch (entry->content) {
+	case SNDRV_INFO_CONTENT_TEXT:
+		if (mode == O_RDONLY || mode == O_RDWR) {
+			vfree(data->rbuffer->buffer);
+			kfree(data->rbuffer);
+		}
+		if (mode == O_WRONLY || mode == O_RDWR) {
+			if (entry->c.text.write) {
+				entry->c.text.write(entry, data->wbuffer);
+				if (data->wbuffer->error) {
+					snd_printk(KERN_WARNING "data write error to %s (%i)\n",
+						entry->name,
+						data->wbuffer->error);
+				}
+			}
+			vfree(data->wbuffer->buffer);
+			kfree(data->wbuffer);
+		}
+		break;
+	case SNDRV_INFO_CONTENT_DATA:
+		if (entry->c.ops->release)
+			entry->c.ops->release(entry, mode,
+					      data->file_private_data);
+		break;
+	}
+	module_put(entry->module);
+	kfree(data);
+	return 0;
+}
+
+static unsigned int snd_info_entry_poll(struct file *file, poll_table * wait)
+{
+	snd_info_private_data_t *data;
+	struct snd_info_entry *entry;
+	unsigned int mask;
+
+	data = file->private_data;
+	if (data == NULL)
+		return 0;
+	entry = data->entry;
+	mask = 0;
+	switch (entry->content) {
+	case SNDRV_INFO_CONTENT_DATA:
+		if (entry->c.ops->poll)
+			return entry->c.ops->poll(entry,
+						  data->file_private_data,
+						  file, wait);
+		if (entry->c.ops->read)
+			mask |= POLLIN | POLLRDNORM;
+		if (entry->c.ops->write)
+			mask |= POLLOUT | POLLWRNORM;
+		break;
+	}
+	return mask;
+}
+
+static inline int _snd_info_entry_ioctl(struct inode *inode, struct file *file,
+					unsigned int cmd, unsigned long arg)
+{
+	snd_info_private_data_t *data;
+	struct snd_info_entry *entry;
+
+	data = file->private_data;
+	if (data == NULL)
+		return 0;
+	entry = data->entry;
+	switch (entry->content) {
+	case SNDRV_INFO_CONTENT_DATA:
+		if (entry->c.ops->ioctl)
+			return entry->c.ops->ioctl(entry,
+						   data->file_private_data,
+						   file, cmd, arg);
+		break;
+	}
+	return -ENOTTY;
+}
+
+/* FIXME: need to unlock BKL to allow preemption */
+static int snd_info_entry_ioctl(struct inode *inode, struct file *file,
+				unsigned int cmd, unsigned long arg)
+{
+	int err;
+	unlock_kernel();
+	err = _snd_info_entry_ioctl(inode, file, cmd, arg);
+	lock_kernel();
+	return err;
+}
+
+static int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	snd_info_private_data_t *data;
+	struct snd_info_entry *entry;
+
+	data = file->private_data;
+	if (data == NULL)
+		return 0;
+	entry = data->entry;
+	switch (entry->content) {
+	case SNDRV_INFO_CONTENT_DATA:
+		if (entry->c.ops->mmap)
+			return entry->c.ops->mmap(entry,
+						  data->file_private_data,
+						  inode, file, vma);
+		break;
+	}
+	return -ENXIO;
+}
+
+static struct file_operations snd_info_entry_operations =
+{
+	.owner =	THIS_MODULE,
+	.llseek =	snd_info_entry_llseek,
+	.read =		snd_info_entry_read,
+	.write =	snd_info_entry_write,
+	.poll =		snd_info_entry_poll,
+	.ioctl =	snd_info_entry_ioctl,
+	.mmap =		snd_info_entry_mmap,
+	.open =		snd_info_entry_open,
+	.release =	snd_info_entry_release,
+};
+
+/**
+ * snd_create_proc_entry - create a procfs entry
+ * @name: the name of the proc file
+ * @mode: the file permission bits, S_Ixxx
+ * @parent: the parent proc-directory entry
+ *
+ * Creates a new proc file entry with the given name and permission
+ * on the given directory.
+ *
+ * Returns the pointer of new instance or NULL on failure.
+ */
+static struct proc_dir_entry *snd_create_proc_entry(const char *name, mode_t mode,
+						    struct proc_dir_entry *parent)
+{
+	struct proc_dir_entry *p;
+	p = create_proc_entry(name, mode, parent);
+	if (p)
+		snd_info_entry_prepare(p);
+	return p;
+}
+
+int __init snd_info_init(void)
+{
+	struct proc_dir_entry *p;
+
+	p = snd_create_proc_entry("asound", S_IFDIR | S_IRUGO | S_IXUGO, &proc_root);
+	if (p == NULL)
+		return -ENOMEM;
+	snd_proc_root = p;
+#ifdef CONFIG_SND_OSSEMUL
+	{
+		snd_info_entry_t *entry;
+		if ((entry = snd_info_create_module_entry(THIS_MODULE, "oss", NULL)) == NULL)
+			return -ENOMEM;
+		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			return -ENOMEM;
+		}
+		snd_oss_root = entry;
+	}
+#endif
+#if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
+	{
+		snd_info_entry_t *entry;
+		if ((entry = snd_info_create_module_entry(THIS_MODULE, "seq", NULL)) == NULL)
+			return -ENOMEM;
+		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			return -ENOMEM;
+		}
+		snd_seq_root = entry;
+	}
+#endif
+	snd_info_version_init();
+	snd_memory_info_init();
+	snd_minor_info_init();
+	snd_minor_info_oss_init();
+	snd_card_info_init();
+	return 0;
+}
+
+int __exit snd_info_done(void)
+{
+	snd_card_info_done();
+	snd_minor_info_oss_done();
+	snd_minor_info_done();
+	snd_memory_info_done();
+	snd_info_version_done();
+	if (snd_proc_root) {
+#if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
+		if (snd_seq_root)
+			snd_info_unregister(snd_seq_root);
+#endif
+#ifdef CONFIG_SND_OSSEMUL
+		if (snd_oss_root)
+			snd_info_unregister(snd_oss_root);
+#endif
+		snd_remove_proc_entry(&proc_root, snd_proc_root);
+	}
+	return 0;
+}
+
+/*
+
+ */
+
+
+/*
+ * create a card proc file
+ * called from init.c
+ */
+int snd_info_card_create(snd_card_t * card)
+{
+	char str[8];
+	snd_info_entry_t *entry;
+
+	snd_assert(card != NULL, return -ENXIO);
+
+	sprintf(str, "card%i", card->number);
+	if ((entry = snd_info_create_module_entry(card->module, str, NULL)) == NULL)
+		return -ENOMEM;
+	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		return -ENOMEM;
+	}
+	card->proc_root = entry;
+	return 0;
+}
+
+/*
+ * register the card proc file
+ * called from init.c
+ */
+int snd_info_card_register(snd_card_t * card)
+{
+	struct proc_dir_entry *p;
+
+	snd_assert(card != NULL, return -ENXIO);
+
+	if (!strcmp(card->id, card->proc_root->name))
+		return 0;
+
+	p = proc_symlink(card->id, snd_proc_root, card->proc_root->name);
+	if (p == NULL)
+		return -ENOMEM;
+	card->proc_root_link = p;
+	return 0;
+}
+
+/*
+ * de-register the card proc file
+ * called from init.c
+ */
+int snd_info_card_free(snd_card_t * card)
+{
+	snd_assert(card != NULL, return -ENXIO);
+	if (card->proc_root_link) {
+		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
+		card->proc_root_link = NULL;
+	}
+	if (card->proc_root) {
+		snd_info_unregister(card->proc_root);
+		card->proc_root = NULL;
+	}
+	return 0;
+}
+
+
+/**
+ * snd_info_get_line - read one line from the procfs buffer
+ * @buffer: the procfs buffer
+ * @line: the buffer to store
+ * @len: the max. buffer size - 1
+ *
+ * Reads one line from the buffer and stores the string.
+ *
+ * Returns zero if successful, or 1 if error or EOF.
+ */
+int snd_info_get_line(snd_info_buffer_t * buffer, char *line, int len)
+{
+	int c = -1;
+
+	if (len <= 0 || buffer->stop || buffer->error)
+		return 1;
+	while (--len > 0) {
+		c = *buffer->curr++;
+		if (c == '\n') {
+			if ((buffer->curr - buffer->buffer) >= (long)buffer->size) {
+				buffer->stop = 1;
+			}
+			break;
+		}
+		*line++ = c;
+		if ((buffer->curr - buffer->buffer) >= (long)buffer->size) {
+			buffer->stop = 1;
+			break;
+		}
+	}
+	while (c != '\n' && !buffer->stop) {
+		c = *buffer->curr++;
+		if ((buffer->curr - buffer->buffer) >= (long)buffer->size) {
+			buffer->stop = 1;
+		}
+	}
+	*line = '\0';
+	return 0;
+}
+
+/**
+ * snd_info_get_line - parse a string token
+ * @dest: the buffer to store the string token
+ * @src: the original string
+ * @len: the max. length of token - 1
+ *
+ * Parses the original string and copy a token to the given
+ * string buffer.
+ *
+ * Returns the updated pointer of the original string so that
+ * it can be used for the next call.
+ */
+char *snd_info_get_str(char *dest, char *src, int len)
+{
+	int c;
+
+	while (*src == ' ' || *src == '\t')
+		src++;
+	if (*src == '"' || *src == '\'') {
+		c = *src++;
+		while (--len > 0 && *src && *src != c) {
+			*dest++ = *src++;
+		}
+		if (*src == c)
+			src++;
+	} else {
+		while (--len > 0 && *src && *src != ' ' && *src != '\t') {
+			*dest++ = *src++;
+		}
+	}
+	*dest = 0;
+	while (*src == ' ' || *src == '\t')
+		src++;
+	return src;
+}
+
+/**
+ * snd_info_create_entry - create an info entry
+ * @name: the proc file name
+ *
+ * Creates an info entry with the given file name and initializes as
+ * the default state.
+ *
+ * Usually called from other functions such as
+ * snd_info_create_card_entry().
+ *
+ * Returns the pointer of the new instance, or NULL on failure.
+ */
+static snd_info_entry_t *snd_info_create_entry(const char *name)
+{
+	snd_info_entry_t *entry;
+	entry = kcalloc(1, sizeof(*entry), GFP_KERNEL);
+	if (entry == NULL)
+		return NULL;
+	entry->name = snd_kmalloc_strdup(name, GFP_KERNEL);
+	if (entry->name == NULL) {
+		kfree(entry);
+		return NULL;
+	}
+	entry->mode = S_IFREG | S_IRUGO;
+	entry->content = SNDRV_INFO_CONTENT_TEXT;
+	init_MUTEX(&entry->access);
+	return entry;
+}
+
+/**
+ * snd_info_create_module_entry - create an info entry for the given module
+ * @module: the module pointer
+ * @name: the file name
+ * @parent: the parent directory
+ *
+ * Creates a new info entry and assigns it to the given module.
+ *
+ * Returns the pointer of the new instance, or NULL on failure.
+ */
+snd_info_entry_t *snd_info_create_module_entry(struct module * module,
+					       const char *name,
+					       snd_info_entry_t *parent)
+{
+	snd_info_entry_t *entry = snd_info_create_entry(name);
+	if (entry) {
+		entry->module = module;
+		entry->parent = parent;
+	}
+	return entry;
+}
+
+/**
+ * snd_info_create_card_entry - create an info entry for the given card
+ * @card: the card instance
+ * @name: the file name
+ * @parent: the parent directory
+ *
+ * Creates a new info entry and assigns it to the given card.
+ *
+ * Returns the pointer of the new instance, or NULL on failure.
+ */
+snd_info_entry_t *snd_info_create_card_entry(snd_card_t * card,
+					     const char *name,
+					     snd_info_entry_t * parent)
+{
+	snd_info_entry_t *entry = snd_info_create_entry(name);
+	if (entry) {
+		entry->module = card->module;
+		entry->card = card;
+		entry->parent = parent;
+	}
+	return entry;
+}
+
+static int snd_info_dev_free_entry(snd_device_t *device)
+{
+	snd_info_entry_t *entry = device->device_data;
+	snd_info_free_entry(entry);
+	return 0;
+}
+
+static int snd_info_dev_register_entry(snd_device_t *device)
+{
+	snd_info_entry_t *entry = device->device_data;
+	return snd_info_register(entry);
+}
+
+static int snd_info_dev_disconnect_entry(snd_device_t *device)
+{
+	snd_info_entry_t *entry = device->device_data;
+	entry->disconnected = 1;
+	return 0;
+}
+
+static int snd_info_dev_unregister_entry(snd_device_t *device)
+{
+	snd_info_entry_t *entry = device->device_data;
+	return snd_info_unregister(entry);
+}
+
+/**
+ * snd_card_proc_new - create an info entry for the given card
+ * @card: the card instance
+ * @name: the file name
+ * @entryp: the pointer to store the new info entry
+ *
+ * Creates a new info entry and assigns it to the given card.
+ * Unlike snd_info_create_card_entry(), this function registers the
+ * info entry as an ALSA device component, so that it can be
+ * unregistered/released without explicit call.
+ * Also, you don't have to register this entry via snd_info_register(),
+ * since this will be registered by snd_card_register() automatically.
+ *
+ * The parent is assumed as card->proc_root.
+ *
+ * For releasing this entry, use snd_device_free() instead of
+ * snd_info_free_entry(). 
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_card_proc_new(snd_card_t *card, const char *name,
+		      snd_info_entry_t **entryp)
+{
+	static snd_device_ops_t ops = {
+		.dev_free = snd_info_dev_free_entry,
+		.dev_register =	snd_info_dev_register_entry,
+		.dev_disconnect = snd_info_dev_disconnect_entry,
+		.dev_unregister = snd_info_dev_unregister_entry
+	};
+	snd_info_entry_t *entry;
+	int err;
+
+	entry = snd_info_create_card_entry(card, name, card->proc_root);
+	if (! entry)
+		return -ENOMEM;
+	if ((err = snd_device_new(card, SNDRV_DEV_INFO, entry, &ops)) < 0) {
+		snd_info_free_entry(entry);
+		return err;
+	}
+	if (entryp)
+		*entryp = entry;
+	return 0;
+}
+
+/**
+ * snd_info_free_entry - release the info entry
+ * @entry: the info entry
+ *
+ * Releases the info entry.  Don't call this after registered.
+ */
+void snd_info_free_entry(snd_info_entry_t * entry)
+{
+	if (entry == NULL)
+		return;
+	kfree(entry->name);
+	if (entry->private_free)
+		entry->private_free(entry);
+	kfree(entry);
+}
+
+/**
+ * snd_info_register - register the info entry
+ * @entry: the info entry
+ *
+ * Registers the proc info entry.
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_info_register(snd_info_entry_t * entry)
+{
+	struct proc_dir_entry *root, *p = NULL;
+
+	snd_assert(entry != NULL, return -ENXIO);
+	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
+	down(&info_mutex);
+	p = snd_create_proc_entry(entry->name, entry->mode, root);
+	if (!p) {
+		up(&info_mutex);
+		return -ENOMEM;
+	}
+	p->owner = entry->module;
+	if (!S_ISDIR(entry->mode))
+		p->proc_fops = &snd_info_entry_operations;
+	p->size = entry->size;
+	p->data = entry;
+	entry->p = p;
+	up(&info_mutex);
+	return 0;
+}
+
+/**
+ * snd_info_unregister - de-register the info entry
+ * @entry: the info entry
+ *
+ * De-registers the info entry and releases the instance.
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_info_unregister(snd_info_entry_t * entry)
+{
+	struct proc_dir_entry *root;
+
+	snd_assert(entry != NULL && entry->p != NULL, return -ENXIO);
+	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
+	snd_assert(root, return -ENXIO);
+	down(&info_mutex);
+	snd_remove_proc_entry(root, entry->p);
+	up(&info_mutex);
+	snd_info_free_entry(entry);
+	return 0;
+}
+
+/*
+
+ */
+
+static snd_info_entry_t *snd_info_version_entry = NULL;
+
+static void snd_info_version_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	snd_iprintf(buffer,
+		    "Advanced Linux Sound Architecture Driver Version "
+		    CONFIG_SND_VERSION CONFIG_SND_DATE ".\n"
+		   );
+}
+
+static int __init snd_info_version_init(void)
+{
+	snd_info_entry_t *entry;
+
+	entry = snd_info_create_module_entry(THIS_MODULE, "version", NULL);
+	if (entry == NULL)
+		return -ENOMEM;
+	entry->c.text.read_size = 256;
+	entry->c.text.read = snd_info_version_read;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		return -ENOMEM;
+	}
+	snd_info_version_entry = entry;
+	return 0;
+}
+
+static int __exit snd_info_version_done(void)
+{
+	if (snd_info_version_entry)
+		snd_info_unregister(snd_info_version_entry);
+	return 0;
+}
+
+#endif /* CONFIG_PROC_FS */
