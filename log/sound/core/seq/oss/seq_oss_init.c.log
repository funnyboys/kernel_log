commit 731922a5939e653ce501b7d72bfe8fbe79717abf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:21 2020 +0100

    ALSA: seq: More constifications
    
    Apply const prefix to the remaining sequencer code: the static tables
    for MIDI macros, RPN/NRPN, and some strings.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-7-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 6dc94efc19c9..4534a154b8c8 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -460,10 +460,10 @@ enabled_str(int bool)
 	return bool ? "enabled" : "disabled";
 }
 
-static char *
+static const char *
 filemode_str(int val)
 {
-	static char *str[] = {
+	static const char * const str[] = {
 		"none", "read", "write", "read/write",
 	};
 	return str[val & SNDRV_SEQ_OSS_FILE_ACMODE];

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 92c96a95a903..6dc94efc19c9 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * OSS compatible sequencer driver
  *
  * open/close and reset interface
  *
  * Copyright (C) 1998-1999 Takashi Iwai <tiwai@suse.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include "seq_oss_device.h"

commit 197b958c1e76a575d77038cc98b4bebc2134279f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 1 18:30:18 2016 +0100

    ALSA: seq: oss: Don't drain at closing a client
    
    The OSS sequencer client tries to drain the pending events at
    releasing.  Unfortunately, as spotted by syzkaller fuzzer, this may
    lead to an unkillable process state when the event has been queued at
    the far future.  Since the process being released can't be signaled
    any longer, it remains and waits for the echo-back event in that far
    future.
    
    Back to history, the draining feature was implemented at the time we
    misinterpreted POSIX definition for blocking file operation.
    Actually, such a behavior is superfluous at release, and we should
    just release the device as is instead of keeping it up forever.
    
    This patch just removes the draining call that may block the release
    for too long time unexpectedly.
    
    BugLink: http://lkml.kernel.org/r/CACT4Y+Y4kD-aBGj37rf-xBw9bH3GMU6P+MYg4W1e-s-paVD2pg@mail.gmail.com
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 6779e82b46dd..92c96a95a903 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -435,22 +435,6 @@ snd_seq_oss_release(struct seq_oss_devinfo *dp)
 }
 
 
-/*
- * Wait until the queue is empty (if we don't have nonblock)
- */
-void
-snd_seq_oss_drain_write(struct seq_oss_devinfo *dp)
-{
-	if (! dp->timer->running)
-		return;
-	if (is_write_mode(dp->file_mode) && !is_nonblock_mode(dp->file_mode) &&
-	    dp->writeq) {
-		while (snd_seq_oss_writeq_sync(dp->writeq))
-			;
-	}
-}
-
-
 /*
  * reset sequencer devices
  */

commit da10816e3d923565b470fec78a674baba794ed33
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 25 11:24:56 2016 +0100

    ALSA: seq: Degrade the error message for too many opens
    
    ALSA OSS sequencer spews a kernel error message ("ALSA: seq_oss: too
    many applications") when user-space tries to open more than the
    limit.  This means that it can easily fill the log buffer.
    
    Since it's merely a normal error, it's safe to suppress it via
    pr_debug() instead.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index b1221b29728e..6779e82b46dd 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -202,7 +202,7 @@ snd_seq_oss_open(struct file *file, int level)
 
 	dp->index = i;
 	if (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {
-		pr_err("ALSA: seq_oss: too many applications\n");
+		pr_debug("ALSA: seq_oss: too many applications\n");
 		rc = -ENOMEM;
 		goto _error;
 	}

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 2de3feff70d0..b1221b29728e 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -479,8 +479,7 @@ snd_seq_oss_reset(struct seq_oss_devinfo *dp)
 	snd_seq_oss_timer_stop(dp->timer);
 }
 
-
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /*
  * misc. functions for proc interface
  */
@@ -531,4 +530,4 @@ snd_seq_oss_system_info_read(struct snd_info_buffer *buf)
 			snd_seq_oss_readq_info_read(dp->readq, buf);
 	}
 }
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */

commit 8d98a0673f761f9b7be51a293ca9142ec0c037ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:39:55 2015 +0100

    ALSA: seq_oss: Drop superfluous error/debug messages after malloc failures
    
    The kernel memory allocators already report the errors when the
    requested allocation fails, thus we don't need to warn it again in
    each caller side.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index b0e32e161dd1..2de3feff70d0 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -188,10 +188,8 @@ snd_seq_oss_open(struct file *file, int level)
 	struct seq_oss_devinfo *dp;
 
 	dp = kzalloc(sizeof(*dp), GFP_KERNEL);
-	if (!dp) {
-		pr_err("ALSA: seq_oss: can't malloc device info\n");
+	if (!dp)
 		return -ENOMEM;
-	}
 
 	dp->cseq = system_client;
 	dp->port = -1;

commit d712eaf29d3fe5928d891a4a90ac58644ad595ed
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri Nov 21 18:34:48 2014 +0100

    ALSA: core: Deletion of unnecessary checks before two function calls
    
    The functions snd_seq_oss_timer_delete() and vunmap() perform also input
    parameter validation. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index b9184d20c39f..b0e32e161dd1 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -403,14 +403,11 @@ free_devinfo(void *private)
 {
 	struct seq_oss_devinfo *dp = (struct seq_oss_devinfo *)private;
 
-	if (dp->timer)
-		snd_seq_oss_timer_delete(dp->timer);
+	snd_seq_oss_timer_delete(dp->timer);
 		
-	if (dp->writeq)
-		snd_seq_oss_writeq_delete(dp->writeq);
+	snd_seq_oss_writeq_delete(dp->writeq);
 
-	if (dp->readq)
-		snd_seq_oss_readq_delete(dp->readq);
+	snd_seq_oss_readq_delete(dp->readq);
 	
 	kfree(dp);
 }

commit bb343e7969cb8a4b6b20bddc97098c87f4fae2b5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:24:04 2014 +0100

    ALSA: seq_oss: Use standard printk helpers
    
    Use the standard pr_xxx() helpers instead of home-baked snd_print*().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index b0ac6accf301..b9184d20c39f 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -189,7 +189,7 @@ snd_seq_oss_open(struct file *file, int level)
 
 	dp = kzalloc(sizeof(*dp), GFP_KERNEL);
 	if (!dp) {
-		snd_printk(KERN_ERR "can't malloc device info\n");
+		pr_err("ALSA: seq_oss: can't malloc device info\n");
 		return -ENOMEM;
 	}
 
@@ -204,7 +204,7 @@ snd_seq_oss_open(struct file *file, int level)
 
 	dp->index = i;
 	if (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {
-		snd_printk(KERN_ERR "too many applications\n");
+		pr_err("ALSA: seq_oss: too many applications\n");
 		rc = -ENOMEM;
 		goto _error;
 	}
@@ -214,7 +214,7 @@ snd_seq_oss_open(struct file *file, int level)
 	snd_seq_oss_midi_setup(dp);
 
 	if (dp->synth_opened == 0 && dp->max_mididev == 0) {
-		/* snd_printk(KERN_ERR "no device found\n"); */
+		/* pr_err("ALSA: seq_oss: no device found\n"); */
 		rc = -ENODEV;
 		goto _error;
 	}
@@ -222,7 +222,7 @@ snd_seq_oss_open(struct file *file, int level)
 	/* create port */
 	rc = create_port(dp);
 	if (rc < 0) {
-		snd_printk(KERN_ERR "can't create port\n");
+		pr_err("ALSA: seq_oss: can't create port\n");
 		goto _error;
 	}
 
@@ -263,7 +263,7 @@ snd_seq_oss_open(struct file *file, int level)
 	/* initialize timer */
 	dp->timer = snd_seq_oss_timer_new(dp);
 	if (!dp->timer) {
-		snd_printk(KERN_ERR "can't alloc timer\n");
+		pr_err("ALSA: seq_oss: can't alloc timer\n");
 		rc = -ENOMEM;
 		goto _error;
 	}
@@ -390,7 +390,7 @@ delete_seq_queue(int queue)
 	qinfo.queue = queue;
 	rc = call_ctl(SNDRV_SEQ_IOCTL_DELETE_QUEUE, &qinfo);
 	if (rc < 0)
-		printk(KERN_ERR "seq-oss: unable to delete queue %d (%d)\n", queue, rc);
+		pr_err("ALSA: seq_oss: unable to delete queue %d (%d)\n", queue, rc);
 	return rc;
 }
 

commit a67ca25b6cc6d2f3f24aebf1c83af3db28b5e304
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:04:49 2014 +0100

    ALSA: seq_oss: Drop debug prints
    
    The debug prints in snd-seq-oss module are rather useless.
    Let's clean up before further modifications.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index b3f39b5ed742..b0ac6accf301 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -92,7 +92,6 @@ snd_seq_oss_create_client(void)
 		goto __error;
 
 	system_client = rc;
-	debug_printk(("new client = %d\n", rc));
 
 	/* create annoucement receiver port */
 	memset(port, 0, sizeof(*port));
@@ -193,7 +192,6 @@ snd_seq_oss_open(struct file *file, int level)
 		snd_printk(KERN_ERR "can't malloc device info\n");
 		return -ENOMEM;
 	}
-	debug_printk(("oss_open: dp = %p\n", dp));
 
 	dp->cseq = system_client;
 	dp->port = -1;
@@ -222,7 +220,6 @@ snd_seq_oss_open(struct file *file, int level)
 	}
 
 	/* create port */
-	debug_printk(("create new port\n"));
 	rc = create_port(dp);
 	if (rc < 0) {
 		snd_printk(KERN_ERR "can't create port\n");
@@ -230,7 +227,6 @@ snd_seq_oss_open(struct file *file, int level)
 	}
 
 	/* allocate queue */
-	debug_printk(("allocate queue\n"));
 	rc = alloc_seq_queue(dp);
 	if (rc < 0)
 		goto _error;
@@ -247,7 +243,6 @@ snd_seq_oss_open(struct file *file, int level)
 	dp->file_mode = translate_mode(file);
 
 	/* initialize read queue */
-	debug_printk(("initialize read queue\n"));
 	if (is_read_mode(dp->file_mode)) {
 		dp->readq = snd_seq_oss_readq_new(dp, maxqlen);
 		if (!dp->readq) {
@@ -257,7 +252,6 @@ snd_seq_oss_open(struct file *file, int level)
 	}
 
 	/* initialize write queue */
-	debug_printk(("initialize write queue\n"));
 	if (is_write_mode(dp->file_mode)) {
 		dp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);
 		if (!dp->writeq) {
@@ -267,14 +261,12 @@ snd_seq_oss_open(struct file *file, int level)
 	}
 
 	/* initialize timer */
-	debug_printk(("initialize timer\n"));
 	dp->timer = snd_seq_oss_timer_new(dp);
 	if (!dp->timer) {
 		snd_printk(KERN_ERR "can't alloc timer\n");
 		rc = -ENOMEM;
 		goto _error;
 	}
-	debug_printk(("timer initialized\n"));
 
 	/* set private data pointer */
 	file->private_data = dp;
@@ -288,7 +280,6 @@ snd_seq_oss_open(struct file *file, int level)
 	client_table[dp->index] = dp;
 	num_clients++;
 
-	debug_printk(("open done\n"));
 	return 0;
 
  _error:
@@ -347,7 +338,6 @@ create_port(struct seq_oss_devinfo *dp)
 		return rc;
 
 	dp->port = port.addr.port;
-	debug_printk(("new port = %d\n", port.addr.port));
 
 	return 0;
 }
@@ -363,7 +353,6 @@ delete_port(struct seq_oss_devinfo *dp)
 		return 0;
 	}
 
-	debug_printk(("delete_port %i\n", dp->port));
 	return snd_seq_event_port_detach(dp->cseq, dp->port);
 }
 
@@ -438,21 +427,16 @@ snd_seq_oss_release(struct seq_oss_devinfo *dp)
 	client_table[dp->index] = NULL;
 	num_clients--;
 
-	debug_printk(("resetting..\n"));
 	snd_seq_oss_reset(dp);
 
-	debug_printk(("cleaning up..\n"));
 	snd_seq_oss_synth_cleanup(dp);
 	snd_seq_oss_midi_cleanup(dp);
 
 	/* clear slot */
-	debug_printk(("releasing resource..\n"));
 	queue = dp->queue;
 	if (dp->port >= 0)
 		delete_port(dp);
 	delete_seq_queue(queue);
-
-	debug_printk(("release done\n"));
 }
 
 
@@ -466,7 +450,6 @@ snd_seq_oss_drain_write(struct seq_oss_devinfo *dp)
 		return;
 	if (is_write_mode(dp->file_mode) && !is_nonblock_mode(dp->file_mode) &&
 	    dp->writeq) {
-		debug_printk(("syncing..\n"));
 		while (snd_seq_oss_writeq_sync(dp->writeq))
 			;
 	}

commit 256ca9c3ad5013ff8a8f165e5a82fab437628c8e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 16 12:17:49 2013 +0200

    ALSA: seq-oss: Initialize MIDI clients asynchronously
    
    We've got bug reports that the module loading stuck on Debian system
    with 3.10 kernel.  The debugging session revealed that the initial
    registration of OSS sequencer clients stuck at module loading time,
    which involves again with request_module() at the init phase.  This is
    triggered only by special --install stuff Debian is using, but it's
    still not good to have such loops.
    
    As a workaround, call the registration part asynchronously.  This is a
    better approach irrespective of the hang fix, in anyway.
    
    Reported-and-tested-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index e3cb46fef2c7..b3f39b5ed742 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -31,6 +31,7 @@
 #include <linux/export.h>
 #include <linux/moduleparam.h>
 #include <linux/slab.h>
+#include <linux/workqueue.h>
 
 /*
  * common variables
@@ -60,6 +61,14 @@ static void free_devinfo(void *private);
 #define call_ctl(type,rec) snd_seq_kernel_client_ctl(system_client, type, rec)
 
 
+/* call snd_seq_oss_midi_lookup_ports() asynchronously */
+static void async_call_lookup_ports(struct work_struct *work)
+{
+	snd_seq_oss_midi_lookup_ports(system_client);
+}
+
+static DECLARE_WORK(async_lookup_work, async_call_lookup_ports);
+
 /*
  * create sequencer client for OSS sequencer
  */
@@ -85,9 +94,6 @@ snd_seq_oss_create_client(void)
 	system_client = rc;
 	debug_printk(("new client = %d\n", rc));
 
-	/* look up midi devices */
-	snd_seq_oss_midi_lookup_ports(system_client);
-
 	/* create annoucement receiver port */
 	memset(port, 0, sizeof(*port));
 	strcpy(port->name, "Receiver");
@@ -115,6 +121,9 @@ snd_seq_oss_create_client(void)
 	}
 	rc = 0;
 
+	/* look up midi devices */
+	schedule_work(&async_lookup_work);
+
  __error:
 	kfree(port);
 	return rc;
@@ -160,6 +169,7 @@ receive_announce(struct snd_seq_event *ev, int direct, void *private, int atomic
 int
 snd_seq_oss_delete_client(void)
 {
+	cancel_work_sync(&async_lookup_work);
 	if (system_client >= 0)
 		snd_seq_delete_kernel_client(system_client);
 

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 69cd7b3c362d..e3cb46fef2c7 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -28,6 +28,7 @@
 #include "seq_oss_timer.h"
 #include "seq_oss_event.h"
 #include <linux/init.h>
+#include <linux/export.h>
 #include <linux/moduleparam.h>
 #include <linux/slab.h>
 

commit 27f7ad53829f79e799a253285318bff79ece15bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 6 09:13:45 2010 +0200

    ALSA: seq/oss - Fix double-free at error path of snd_seq_oss_open()
    
    The error handling in snd_seq_oss_open() has several bad codes that
    do dereferecing released pointers and double-free of kmalloc'ed data.
    The object dp is release in free_devinfo() that is called via
    private_free callback.  The rest shouldn't touch this object any more.
    
    The patch changes delete_port() to call kfree() in any case, and gets
    rid of unnecessary calls of destructors in snd_seq_oss_open().
    
    Fixes CVE-2010-3080.
    
    Reported-and-tested-by: Tavis Ormandy <taviso@cmpxchg8b.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 685712276ac9..69cd7b3c362d 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -281,13 +281,10 @@ snd_seq_oss_open(struct file *file, int level)
 	return 0;
 
  _error:
-	snd_seq_oss_writeq_delete(dp->writeq);
-	snd_seq_oss_readq_delete(dp->readq);
 	snd_seq_oss_synth_cleanup(dp);
 	snd_seq_oss_midi_cleanup(dp);
-	delete_port(dp);
 	delete_seq_queue(dp->queue);
-	kfree(dp);
+	delete_port(dp);
 
 	return rc;
 }
@@ -350,8 +347,10 @@ create_port(struct seq_oss_devinfo *dp)
 static int
 delete_port(struct seq_oss_devinfo *dp)
 {
-	if (dp->port < 0)
+	if (dp->port < 0) {
+		kfree(dp);
 		return 0;
+	}
 
 	debug_printk(("delete_port %i\n", dp->port));
 	return snd_seq_event_port_detach(dp->cseq, dp->port);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index d0d721c22eac..685712276ac9 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -29,6 +29,7 @@
 #include "seq_oss_event.h"
 #include <linux/init.h>
 #include <linux/moduleparam.h>
+#include <linux/slab.h>
 
 /*
  * common variables

commit 7034632d88b02960abee258056d2269e606707e9
Author: Eugene Teo <eugeneteo@kernel.sg>
Date:   Tue Aug 7 14:34:23 2007 +0200

    [ALSA] seq: resource leak fix and various code cleanups
    
    This patch fixes:
    1) a resource leak (CID: 1817)
    2) various code cleanups
    
    Signed-off-by: Eugene Teo <eugeneteo@kernel.sg>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index ca5a2ed4d7c3..d0d721c22eac 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -176,29 +176,29 @@ snd_seq_oss_open(struct file *file, int level)
 	int i, rc;
 	struct seq_oss_devinfo *dp;
 
-	if ((dp = kzalloc(sizeof(*dp), GFP_KERNEL)) == NULL) {
+	dp = kzalloc(sizeof(*dp), GFP_KERNEL);
+	if (!dp) {
 		snd_printk(KERN_ERR "can't malloc device info\n");
 		return -ENOMEM;
 	}
 	debug_printk(("oss_open: dp = %p\n", dp));
 
+	dp->cseq = system_client;
+	dp->port = -1;
+	dp->queue = -1;
+
 	for (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {
 		if (client_table[i] == NULL)
 			break;
 	}
+
+	dp->index = i;
 	if (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {
 		snd_printk(KERN_ERR "too many applications\n");
-		kfree(dp);
-		return -ENOMEM;
+		rc = -ENOMEM;
+		goto _error;
 	}
 
-	dp->index = i;
-	dp->cseq = system_client;
-	dp->port = -1;
-	dp->queue = -1;
-	dp->readq = NULL;
-	dp->writeq = NULL;
-
 	/* look up synth and midi devices */
 	snd_seq_oss_synth_setup(dp);
 	snd_seq_oss_midi_setup(dp);
@@ -211,14 +211,16 @@ snd_seq_oss_open(struct file *file, int level)
 
 	/* create port */
 	debug_printk(("create new port\n"));
-	if ((rc = create_port(dp)) < 0) {
+	rc = create_port(dp);
+	if (rc < 0) {
 		snd_printk(KERN_ERR "can't create port\n");
 		goto _error;
 	}
 
 	/* allocate queue */
 	debug_printk(("allocate queue\n"));
-	if ((rc = alloc_seq_queue(dp)) < 0)
+	rc = alloc_seq_queue(dp);
+	if (rc < 0)
 		goto _error;
 
 	/* set address */
@@ -235,7 +237,8 @@ snd_seq_oss_open(struct file *file, int level)
 	/* initialize read queue */
 	debug_printk(("initialize read queue\n"));
 	if (is_read_mode(dp->file_mode)) {
-		if ((dp->readq = snd_seq_oss_readq_new(dp, maxqlen)) == NULL) {
+		dp->readq = snd_seq_oss_readq_new(dp, maxqlen);
+		if (!dp->readq) {
 			rc = -ENOMEM;
 			goto _error;
 		}
@@ -245,7 +248,7 @@ snd_seq_oss_open(struct file *file, int level)
 	debug_printk(("initialize write queue\n"));
 	if (is_write_mode(dp->file_mode)) {
 		dp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);
-		if (dp->writeq == NULL) {
+		if (!dp->writeq) {
 			rc = -ENOMEM;
 			goto _error;
 		}
@@ -253,7 +256,8 @@ snd_seq_oss_open(struct file *file, int level)
 
 	/* initialize timer */
 	debug_printk(("initialize timer\n"));
-	if ((dp->timer = snd_seq_oss_timer_new(dp)) == NULL) {
+	dp->timer = snd_seq_oss_timer_new(dp);
+	if (!dp->timer) {
 		snd_printk(KERN_ERR "can't alloc timer\n");
 		rc = -ENOMEM;
 		goto _error;
@@ -276,11 +280,13 @@ snd_seq_oss_open(struct file *file, int level)
 	return 0;
 
  _error:
+	snd_seq_oss_writeq_delete(dp->writeq);
+	snd_seq_oss_readq_delete(dp->readq);
 	snd_seq_oss_synth_cleanup(dp);
 	snd_seq_oss_midi_cleanup(dp);
-	i = dp->queue;
 	delete_port(dp);
-	delete_seq_queue(i);
+	delete_seq_queue(dp->queue);
+	kfree(dp);
 
 	return rc;
 }

commit 7b6d92451ad5e1136dc347347e888b94638b8ba9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 12 09:33:37 2005 +0100

    [ALSA] seq: set client name in snd_seq_create_kernel_client()
    
    All users of snd_seq_create_kernel_client() have to set the client name
    anyway, so we can just pass the name as parameter.  This relieves us
    from having to muck around with a struct snd_seq_client_info in these
    cases.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index cd4139adec0b..ca5a2ed4d7c3 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -65,33 +65,24 @@ int __init
 snd_seq_oss_create_client(void)
 {
 	int rc;
-	struct snd_seq_client_info *info;
 	struct snd_seq_port_info *port;
 	struct snd_seq_port_callback port_callback;
 
-	info = kmalloc(sizeof(*info), GFP_KERNEL);
 	port = kmalloc(sizeof(*port), GFP_KERNEL);
-	if (!info || !port) {
+	if (!port) {
 		rc = -ENOMEM;
 		goto __error;
 	}
 
 	/* create ALSA client */
-	rc = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_OSS);
+	rc = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_OSS,
+					  "OSS sequencer");
 	if (rc < 0)
 		goto __error;
 
 	system_client = rc;
 	debug_printk(("new client = %d\n", rc));
 
-	/* set client information */
-	memset(info, 0, sizeof(*info));
-	info->client = system_client;
-	info->type = KERNEL_CLIENT;
-	strcpy(info->name, "OSS sequencer");
-
-	rc = call_ctl(SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, info);
-
 	/* look up midi devices */
 	snd_seq_oss_midi_lookup_ports(system_client);
 
@@ -124,7 +115,6 @@ snd_seq_oss_create_client(void)
 
  __error:
 	kfree(port);
-	kfree(info);
 	return rc;
 }
 

commit 83e8ad6984dccd6d848ac91ba0df379ff968180b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 12 09:30:43 2005 +0100

    [ALSA] seq: remove struct snd_seq_client_callback
    
    The fields of struct snd_seq_client_callback either aren't used or are
    always set to the same value, so we can get rid of it altogether.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 97e2493e931f..cd4139adec0b 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -65,7 +65,6 @@ int __init
 snd_seq_oss_create_client(void)
 {
 	int rc;
-	struct snd_seq_client_callback callback;
 	struct snd_seq_client_info *info;
 	struct snd_seq_port_info *port;
 	struct snd_seq_port_callback port_callback;
@@ -78,13 +77,7 @@ snd_seq_oss_create_client(void)
 	}
 
 	/* create ALSA client */
-	memset(&callback, 0, sizeof(callback));
-
-	callback.private_data = NULL;
-	callback.allow_input = 1;
-	callback.allow_output = 1;
-
-	rc = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_OSS, &callback);
+	rc = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_OSS);
 	if (rc < 0)
 		goto __error;
 

commit 04f141a8800d022981f0405a8d307c98aba55105
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:43:51 2005 +0100

    [ALSA] Optimize for config without PROC_FS (seq and oss parts)
    
    Modules: ALSA<-OSS emulation,ALSA sequencer,ALSA<-OSS sequencer
    
    Optimize the code when compiled without CONFIG_PROC_FS (in seq and oss
    emulation parts).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 1d4473eadcf3..97e2493e931f 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -502,6 +502,7 @@ snd_seq_oss_reset(struct seq_oss_devinfo *dp)
 }
 
 
+#ifdef CONFIG_PROC_FS
 /*
  * misc. functions for proc interface
  */
@@ -552,4 +553,4 @@ snd_seq_oss_system_info_read(struct snd_info_buffer *buf)
 			snd_seq_oss_readq_info_read(dp->readq, buf);
 	}
 }
-
+#endif /* CONFIG_PROC_FS */

commit 080dece3460b534bedc4ef4ba3abaa57e9486331
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:05:16 2005 +0100

    [ALSA] Remove xxx_t typedefs: Sequencer OSS-emulation
    
    Modules: ALSA<-OSS sequencer,ALSA sequencer
    
    Remove xxx_t typedefs from the core sequencer OSS-emulation codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index 1ab1cf8158c8..1d4473eadcf3 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -41,17 +41,17 @@ static int system_client = -1; /* ALSA sequencer client number */
 static int system_port = -1;
 
 static int num_clients;
-static seq_oss_devinfo_t *client_table[SNDRV_SEQ_OSS_MAX_CLIENTS];
+static struct seq_oss_devinfo *client_table[SNDRV_SEQ_OSS_MAX_CLIENTS];
 
 
 /*
  * prototypes
  */
-static int receive_announce(snd_seq_event_t *ev, int direct, void *private, int atomic, int hop);
+static int receive_announce(struct snd_seq_event *ev, int direct, void *private, int atomic, int hop);
 static int translate_mode(struct file *file);
-static int create_port(seq_oss_devinfo_t *dp);
-static int delete_port(seq_oss_devinfo_t *dp);
-static int alloc_seq_queue(seq_oss_devinfo_t *dp);
+static int create_port(struct seq_oss_devinfo *dp);
+static int delete_port(struct seq_oss_devinfo *dp);
+static int alloc_seq_queue(struct seq_oss_devinfo *dp);
 static int delete_seq_queue(int queue);
 static void free_devinfo(void *private);
 
@@ -65,10 +65,10 @@ int __init
 snd_seq_oss_create_client(void)
 {
 	int rc;
-	snd_seq_client_callback_t callback;
-	snd_seq_client_info_t *info;
-	snd_seq_port_info_t *port;
-	snd_seq_port_callback_t port_callback;
+	struct snd_seq_client_callback callback;
+	struct snd_seq_client_info *info;
+	struct snd_seq_port_info *port;
+	struct snd_seq_port_callback port_callback;
 
 	info = kmalloc(sizeof(*info), GFP_KERNEL);
 	port = kmalloc(sizeof(*port), GFP_KERNEL);
@@ -118,7 +118,7 @@ snd_seq_oss_create_client(void)
 	
 	call_ctl(SNDRV_SEQ_IOCTL_CREATE_PORT, port);
 	if ((system_port = port->addr.port) >= 0) {
-		snd_seq_port_subscribe_t subs;
+		struct snd_seq_port_subscribe subs;
 
 		memset(&subs, 0, sizeof(subs));
 		subs.sender.client = SNDRV_SEQ_CLIENT_SYSTEM;
@@ -140,9 +140,9 @@ snd_seq_oss_create_client(void)
  * receive annoucement from system port, and check the midi device
  */
 static int
-receive_announce(snd_seq_event_t *ev, int direct, void *private, int atomic, int hop)
+receive_announce(struct snd_seq_event *ev, int direct, void *private, int atomic, int hop)
 {
-	snd_seq_port_info_t pinfo;
+	struct snd_seq_port_info pinfo;
 
 	if (atomic)
 		return 0; /* it must not happen */
@@ -191,7 +191,7 @@ int
 snd_seq_oss_open(struct file *file, int level)
 {
 	int i, rc;
-	seq_oss_devinfo_t *dp;
+	struct seq_oss_devinfo *dp;
 
 	if ((dp = kzalloc(sizeof(*dp), GFP_KERNEL)) == NULL) {
 		snd_printk(KERN_ERR "can't malloc device info\n");
@@ -323,11 +323,11 @@ translate_mode(struct file *file)
  * create sequencer port
  */
 static int
-create_port(seq_oss_devinfo_t *dp)
+create_port(struct seq_oss_devinfo *dp)
 {
 	int rc;
-	snd_seq_port_info_t port;
-	snd_seq_port_callback_t callback;
+	struct snd_seq_port_info port;
+	struct snd_seq_port_callback callback;
 
 	memset(&port, 0, sizeof(port));
 	port.addr.client = dp->cseq;
@@ -358,7 +358,7 @@ create_port(seq_oss_devinfo_t *dp)
  * delete ALSA port
  */
 static int
-delete_port(seq_oss_devinfo_t *dp)
+delete_port(struct seq_oss_devinfo *dp)
 {
 	if (dp->port < 0)
 		return 0;
@@ -371,9 +371,9 @@ delete_port(seq_oss_devinfo_t *dp)
  * allocate a queue
  */
 static int
-alloc_seq_queue(seq_oss_devinfo_t *dp)
+alloc_seq_queue(struct seq_oss_devinfo *dp)
 {
-	snd_seq_queue_info_t qinfo;
+	struct snd_seq_queue_info qinfo;
 	int rc;
 
 	memset(&qinfo, 0, sizeof(qinfo));
@@ -392,7 +392,7 @@ alloc_seq_queue(seq_oss_devinfo_t *dp)
 static int
 delete_seq_queue(int queue)
 {
-	snd_seq_queue_info_t qinfo;
+	struct snd_seq_queue_info qinfo;
 	int rc;
 
 	if (queue < 0)
@@ -412,7 +412,7 @@ delete_seq_queue(int queue)
 static void
 free_devinfo(void *private)
 {
-	seq_oss_devinfo_t *dp = (seq_oss_devinfo_t *)private;
+	struct seq_oss_devinfo *dp = (struct seq_oss_devinfo *)private;
 
 	if (dp->timer)
 		snd_seq_oss_timer_delete(dp->timer);
@@ -431,7 +431,7 @@ free_devinfo(void *private)
  * close sequencer device
  */
 void
-snd_seq_oss_release(seq_oss_devinfo_t *dp)
+snd_seq_oss_release(struct seq_oss_devinfo *dp)
 {
 	int queue;
 
@@ -460,7 +460,7 @@ snd_seq_oss_release(seq_oss_devinfo_t *dp)
  * Wait until the queue is empty (if we don't have nonblock)
  */
 void
-snd_seq_oss_drain_write(seq_oss_devinfo_t *dp)
+snd_seq_oss_drain_write(struct seq_oss_devinfo *dp)
 {
 	if (! dp->timer->running)
 		return;
@@ -477,7 +477,7 @@ snd_seq_oss_drain_write(seq_oss_devinfo_t *dp)
  * reset sequencer devices
  */
 void
-snd_seq_oss_reset(seq_oss_devinfo_t *dp)
+snd_seq_oss_reset(struct seq_oss_devinfo *dp)
 {
 	int i;
 
@@ -525,10 +525,10 @@ filemode_str(int val)
  * proc interface
  */
 void
-snd_seq_oss_system_info_read(snd_info_buffer_t *buf)
+snd_seq_oss_system_info_read(struct snd_info_buffer *buf)
 {
 	int i;
-	seq_oss_devinfo_t *dp;
+	struct seq_oss_devinfo *dp;
 
 	snd_iprintf(buf, "ALSA client number %d\n", system_client);
 	snd_iprintf(buf, "ALSA receiver port %d\n", system_port);

commit ecca82b4b447f8df73c807a018dac3e2863912d9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:49 2005 +0200

    [ALSA] Replace with kzalloc() - seq stuff
    
    ALSA sequencer,Instrument layer,ALSA<-OSS sequencer
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index bac4b4f1a94e..1ab1cf8158c8 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -193,7 +193,7 @@ snd_seq_oss_open(struct file *file, int level)
 	int i, rc;
 	seq_oss_devinfo_t *dp;
 
-	if ((dp = kcalloc(1, sizeof(*dp), GFP_KERNEL)) == NULL) {
+	if ((dp = kzalloc(sizeof(*dp), GFP_KERNEL)) == NULL) {
 		snd_printk(KERN_ERR "can't malloc device info\n");
 		return -ENOMEM;
 	}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
new file mode 100644
index 000000000000..bac4b4f1a94e
--- /dev/null
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -0,0 +1,555 @@
+/*
+ * OSS compatible sequencer driver
+ *
+ * open/close and reset interface
+ *
+ * Copyright (C) 1998-1999 Takashi Iwai <tiwai@suse.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "seq_oss_device.h"
+#include "seq_oss_synth.h"
+#include "seq_oss_midi.h"
+#include "seq_oss_writeq.h"
+#include "seq_oss_readq.h"
+#include "seq_oss_timer.h"
+#include "seq_oss_event.h"
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+
+/*
+ * common variables
+ */
+static int maxqlen = SNDRV_SEQ_OSS_MAX_QLEN;
+module_param(maxqlen, int, 0444);
+MODULE_PARM_DESC(maxqlen, "maximum queue length");
+
+static int system_client = -1; /* ALSA sequencer client number */
+static int system_port = -1;
+
+static int num_clients;
+static seq_oss_devinfo_t *client_table[SNDRV_SEQ_OSS_MAX_CLIENTS];
+
+
+/*
+ * prototypes
+ */
+static int receive_announce(snd_seq_event_t *ev, int direct, void *private, int atomic, int hop);
+static int translate_mode(struct file *file);
+static int create_port(seq_oss_devinfo_t *dp);
+static int delete_port(seq_oss_devinfo_t *dp);
+static int alloc_seq_queue(seq_oss_devinfo_t *dp);
+static int delete_seq_queue(int queue);
+static void free_devinfo(void *private);
+
+#define call_ctl(type,rec) snd_seq_kernel_client_ctl(system_client, type, rec)
+
+
+/*
+ * create sequencer client for OSS sequencer
+ */
+int __init
+snd_seq_oss_create_client(void)
+{
+	int rc;
+	snd_seq_client_callback_t callback;
+	snd_seq_client_info_t *info;
+	snd_seq_port_info_t *port;
+	snd_seq_port_callback_t port_callback;
+
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	port = kmalloc(sizeof(*port), GFP_KERNEL);
+	if (!info || !port) {
+		rc = -ENOMEM;
+		goto __error;
+	}
+
+	/* create ALSA client */
+	memset(&callback, 0, sizeof(callback));
+
+	callback.private_data = NULL;
+	callback.allow_input = 1;
+	callback.allow_output = 1;
+
+	rc = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_OSS, &callback);
+	if (rc < 0)
+		goto __error;
+
+	system_client = rc;
+	debug_printk(("new client = %d\n", rc));
+
+	/* set client information */
+	memset(info, 0, sizeof(*info));
+	info->client = system_client;
+	info->type = KERNEL_CLIENT;
+	strcpy(info->name, "OSS sequencer");
+
+	rc = call_ctl(SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, info);
+
+	/* look up midi devices */
+	snd_seq_oss_midi_lookup_ports(system_client);
+
+	/* create annoucement receiver port */
+	memset(port, 0, sizeof(*port));
+	strcpy(port->name, "Receiver");
+	port->addr.client = system_client;
+	port->capability = SNDRV_SEQ_PORT_CAP_WRITE; /* receive only */
+	port->type = 0;
+
+	memset(&port_callback, 0, sizeof(port_callback));
+	/* don't set port_callback.owner here. otherwise the module counter
+	 * is incremented and we can no longer release the module..
+	 */
+	port_callback.event_input = receive_announce;
+	port->kernel = &port_callback;
+	
+	call_ctl(SNDRV_SEQ_IOCTL_CREATE_PORT, port);
+	if ((system_port = port->addr.port) >= 0) {
+		snd_seq_port_subscribe_t subs;
+
+		memset(&subs, 0, sizeof(subs));
+		subs.sender.client = SNDRV_SEQ_CLIENT_SYSTEM;
+		subs.sender.port = SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE;
+		subs.dest.client = system_client;
+		subs.dest.port = system_port;
+		call_ctl(SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs);
+	}
+	rc = 0;
+
+ __error:
+	kfree(port);
+	kfree(info);
+	return rc;
+}
+
+
+/*
+ * receive annoucement from system port, and check the midi device
+ */
+static int
+receive_announce(snd_seq_event_t *ev, int direct, void *private, int atomic, int hop)
+{
+	snd_seq_port_info_t pinfo;
+
+	if (atomic)
+		return 0; /* it must not happen */
+
+	switch (ev->type) {
+	case SNDRV_SEQ_EVENT_PORT_START:
+	case SNDRV_SEQ_EVENT_PORT_CHANGE:
+		if (ev->data.addr.client == system_client)
+			break; /* ignore myself */
+		memset(&pinfo, 0, sizeof(pinfo));
+		pinfo.addr = ev->data.addr;
+		if (call_ctl(SNDRV_SEQ_IOCTL_GET_PORT_INFO, &pinfo) >= 0)
+			snd_seq_oss_midi_check_new_port(&pinfo);
+		break;
+
+	case SNDRV_SEQ_EVENT_PORT_EXIT:
+		if (ev->data.addr.client == system_client)
+			break; /* ignore myself */
+		snd_seq_oss_midi_check_exit_port(ev->data.addr.client,
+						ev->data.addr.port);
+		break;
+	}
+	return 0;
+}
+
+
+/*
+ * delete OSS sequencer client
+ */
+int
+snd_seq_oss_delete_client(void)
+{
+	if (system_client >= 0)
+		snd_seq_delete_kernel_client(system_client);
+
+	snd_seq_oss_midi_clear_all();
+
+	return 0;
+}
+
+
+/*
+ * open sequencer device
+ */
+int
+snd_seq_oss_open(struct file *file, int level)
+{
+	int i, rc;
+	seq_oss_devinfo_t *dp;
+
+	if ((dp = kcalloc(1, sizeof(*dp), GFP_KERNEL)) == NULL) {
+		snd_printk(KERN_ERR "can't malloc device info\n");
+		return -ENOMEM;
+	}
+	debug_printk(("oss_open: dp = %p\n", dp));
+
+	for (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {
+		if (client_table[i] == NULL)
+			break;
+	}
+	if (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {
+		snd_printk(KERN_ERR "too many applications\n");
+		kfree(dp);
+		return -ENOMEM;
+	}
+
+	dp->index = i;
+	dp->cseq = system_client;
+	dp->port = -1;
+	dp->queue = -1;
+	dp->readq = NULL;
+	dp->writeq = NULL;
+
+	/* look up synth and midi devices */
+	snd_seq_oss_synth_setup(dp);
+	snd_seq_oss_midi_setup(dp);
+
+	if (dp->synth_opened == 0 && dp->max_mididev == 0) {
+		/* snd_printk(KERN_ERR "no device found\n"); */
+		rc = -ENODEV;
+		goto _error;
+	}
+
+	/* create port */
+	debug_printk(("create new port\n"));
+	if ((rc = create_port(dp)) < 0) {
+		snd_printk(KERN_ERR "can't create port\n");
+		goto _error;
+	}
+
+	/* allocate queue */
+	debug_printk(("allocate queue\n"));
+	if ((rc = alloc_seq_queue(dp)) < 0)
+		goto _error;
+
+	/* set address */
+	dp->addr.client = dp->cseq;
+	dp->addr.port = dp->port;
+	/*dp->addr.queue = dp->queue;*/
+	/*dp->addr.channel = 0;*/
+
+	dp->seq_mode = level;
+
+	/* set up file mode */
+	dp->file_mode = translate_mode(file);
+
+	/* initialize read queue */
+	debug_printk(("initialize read queue\n"));
+	if (is_read_mode(dp->file_mode)) {
+		if ((dp->readq = snd_seq_oss_readq_new(dp, maxqlen)) == NULL) {
+			rc = -ENOMEM;
+			goto _error;
+		}
+	}
+
+	/* initialize write queue */
+	debug_printk(("initialize write queue\n"));
+	if (is_write_mode(dp->file_mode)) {
+		dp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);
+		if (dp->writeq == NULL) {
+			rc = -ENOMEM;
+			goto _error;
+		}
+	}
+
+	/* initialize timer */
+	debug_printk(("initialize timer\n"));
+	if ((dp->timer = snd_seq_oss_timer_new(dp)) == NULL) {
+		snd_printk(KERN_ERR "can't alloc timer\n");
+		rc = -ENOMEM;
+		goto _error;
+	}
+	debug_printk(("timer initialized\n"));
+
+	/* set private data pointer */
+	file->private_data = dp;
+
+	/* set up for mode2 */
+	if (level == SNDRV_SEQ_OSS_MODE_MUSIC)
+		snd_seq_oss_synth_setup_midi(dp);
+	else if (is_read_mode(dp->file_mode))
+		snd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);
+
+	client_table[dp->index] = dp;
+	num_clients++;
+
+	debug_printk(("open done\n"));
+	return 0;
+
+ _error:
+	snd_seq_oss_synth_cleanup(dp);
+	snd_seq_oss_midi_cleanup(dp);
+	i = dp->queue;
+	delete_port(dp);
+	delete_seq_queue(i);
+
+	return rc;
+}
+
+/*
+ * translate file flags to private mode
+ */
+static int
+translate_mode(struct file *file)
+{
+	int file_mode = 0;
+	if ((file->f_flags & O_ACCMODE) != O_RDONLY)
+		file_mode |= SNDRV_SEQ_OSS_FILE_WRITE;
+	if ((file->f_flags & O_ACCMODE) != O_WRONLY)
+		file_mode |= SNDRV_SEQ_OSS_FILE_READ;
+	if (file->f_flags & O_NONBLOCK)
+		file_mode |= SNDRV_SEQ_OSS_FILE_NONBLOCK;
+	return file_mode;
+}
+
+
+/*
+ * create sequencer port
+ */
+static int
+create_port(seq_oss_devinfo_t *dp)
+{
+	int rc;
+	snd_seq_port_info_t port;
+	snd_seq_port_callback_t callback;
+
+	memset(&port, 0, sizeof(port));
+	port.addr.client = dp->cseq;
+	sprintf(port.name, "Sequencer-%d", dp->index);
+	port.capability = SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_WRITE; /* no subscription */
+	port.type = SNDRV_SEQ_PORT_TYPE_SPECIFIC;
+	port.midi_channels = 128;
+	port.synth_voices = 128;
+
+	memset(&callback, 0, sizeof(callback));
+	callback.owner = THIS_MODULE;
+	callback.private_data = dp;
+	callback.event_input = snd_seq_oss_event_input;
+	callback.private_free = free_devinfo;
+	port.kernel = &callback;
+
+	rc = call_ctl(SNDRV_SEQ_IOCTL_CREATE_PORT, &port);
+	if (rc < 0)
+		return rc;
+
+	dp->port = port.addr.port;
+	debug_printk(("new port = %d\n", port.addr.port));
+
+	return 0;
+}
+
+/*
+ * delete ALSA port
+ */
+static int
+delete_port(seq_oss_devinfo_t *dp)
+{
+	if (dp->port < 0)
+		return 0;
+
+	debug_printk(("delete_port %i\n", dp->port));
+	return snd_seq_event_port_detach(dp->cseq, dp->port);
+}
+
+/*
+ * allocate a queue
+ */
+static int
+alloc_seq_queue(seq_oss_devinfo_t *dp)
+{
+	snd_seq_queue_info_t qinfo;
+	int rc;
+
+	memset(&qinfo, 0, sizeof(qinfo));
+	qinfo.owner = system_client;
+	qinfo.locked = 1;
+	strcpy(qinfo.name, "OSS Sequencer Emulation");
+	if ((rc = call_ctl(SNDRV_SEQ_IOCTL_CREATE_QUEUE, &qinfo)) < 0)
+		return rc;
+	dp->queue = qinfo.queue;
+	return 0;
+}
+
+/*
+ * release queue
+ */
+static int
+delete_seq_queue(int queue)
+{
+	snd_seq_queue_info_t qinfo;
+	int rc;
+
+	if (queue < 0)
+		return 0;
+	memset(&qinfo, 0, sizeof(qinfo));
+	qinfo.queue = queue;
+	rc = call_ctl(SNDRV_SEQ_IOCTL_DELETE_QUEUE, &qinfo);
+	if (rc < 0)
+		printk(KERN_ERR "seq-oss: unable to delete queue %d (%d)\n", queue, rc);
+	return rc;
+}
+
+
+/*
+ * free device informations - private_free callback of port
+ */
+static void
+free_devinfo(void *private)
+{
+	seq_oss_devinfo_t *dp = (seq_oss_devinfo_t *)private;
+
+	if (dp->timer)
+		snd_seq_oss_timer_delete(dp->timer);
+		
+	if (dp->writeq)
+		snd_seq_oss_writeq_delete(dp->writeq);
+
+	if (dp->readq)
+		snd_seq_oss_readq_delete(dp->readq);
+	
+	kfree(dp);
+}
+
+
+/*
+ * close sequencer device
+ */
+void
+snd_seq_oss_release(seq_oss_devinfo_t *dp)
+{
+	int queue;
+
+	client_table[dp->index] = NULL;
+	num_clients--;
+
+	debug_printk(("resetting..\n"));
+	snd_seq_oss_reset(dp);
+
+	debug_printk(("cleaning up..\n"));
+	snd_seq_oss_synth_cleanup(dp);
+	snd_seq_oss_midi_cleanup(dp);
+
+	/* clear slot */
+	debug_printk(("releasing resource..\n"));
+	queue = dp->queue;
+	if (dp->port >= 0)
+		delete_port(dp);
+	delete_seq_queue(queue);
+
+	debug_printk(("release done\n"));
+}
+
+
+/*
+ * Wait until the queue is empty (if we don't have nonblock)
+ */
+void
+snd_seq_oss_drain_write(seq_oss_devinfo_t *dp)
+{
+	if (! dp->timer->running)
+		return;
+	if (is_write_mode(dp->file_mode) && !is_nonblock_mode(dp->file_mode) &&
+	    dp->writeq) {
+		debug_printk(("syncing..\n"));
+		while (snd_seq_oss_writeq_sync(dp->writeq))
+			;
+	}
+}
+
+
+/*
+ * reset sequencer devices
+ */
+void
+snd_seq_oss_reset(seq_oss_devinfo_t *dp)
+{
+	int i;
+
+	/* reset all synth devices */
+	for (i = 0; i < dp->max_synthdev; i++)
+		snd_seq_oss_synth_reset(dp, i);
+
+	/* reset all midi devices */
+	if (dp->seq_mode != SNDRV_SEQ_OSS_MODE_MUSIC) {
+		for (i = 0; i < dp->max_mididev; i++)
+			snd_seq_oss_midi_reset(dp, i);
+	}
+
+	/* remove queues */
+	if (dp->readq)
+		snd_seq_oss_readq_clear(dp->readq);
+	if (dp->writeq)
+		snd_seq_oss_writeq_clear(dp->writeq);
+
+	/* reset timer */
+	snd_seq_oss_timer_stop(dp->timer);
+}
+
+
+/*
+ * misc. functions for proc interface
+ */
+char *
+enabled_str(int bool)
+{
+	return bool ? "enabled" : "disabled";
+}
+
+static char *
+filemode_str(int val)
+{
+	static char *str[] = {
+		"none", "read", "write", "read/write",
+	};
+	return str[val & SNDRV_SEQ_OSS_FILE_ACMODE];
+}
+
+
+/*
+ * proc interface
+ */
+void
+snd_seq_oss_system_info_read(snd_info_buffer_t *buf)
+{
+	int i;
+	seq_oss_devinfo_t *dp;
+
+	snd_iprintf(buf, "ALSA client number %d\n", system_client);
+	snd_iprintf(buf, "ALSA receiver port %d\n", system_port);
+
+	snd_iprintf(buf, "\nNumber of applications: %d\n", num_clients);
+	for (i = 0; i < num_clients; i++) {
+		snd_iprintf(buf, "\nApplication %d: ", i);
+		if ((dp = client_table[i]) == NULL) {
+			snd_iprintf(buf, "*empty*\n");
+			continue;
+		}
+		snd_iprintf(buf, "port %d : queue %d\n", dp->port, dp->queue);
+		snd_iprintf(buf, "  sequencer mode = %s : file open mode = %s\n",
+			    (dp->seq_mode ? "music" : "synth"),
+			    filemode_str(dp->file_mode));
+		if (dp->seq_mode)
+			snd_iprintf(buf, "  timer tempo = %d, timebase = %d\n",
+				    dp->timer->oss_tempo, dp->timer->oss_timebase);
+		snd_iprintf(buf, "  max queue length %d\n", maxqlen);
+		if (is_read_mode(dp->file_mode) && dp->readq)
+			snd_seq_oss_readq_info_read(dp->readq, buf);
+	}
+}
+
