commit c212ddaee2fd21e8d756dbc3c6119e3259b38fd0
Merge: 6994eefb0053 3450121997ce
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 5 02:03:50 2019 +0900

    Merge tag 'sound-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound fixes from Takashi Iwai:
     "Here are a collection of small fixes for:
    
       - A race with ASoC HD-audio registration
    
       - LINE6 usb-audio memory overwrite by malformed descriptor
    
       - FireWire MIDI handling
    
       - Missing cast for bit shifts in a few USB-audio quirks
    
       - The wrong function calls in minor OSS sequencer code paths
    
       - A couple of HD-audio quirks"
    
    * tag 'sound-5.2' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:
      ALSA: line6: Fix write on zero-sized buffer
      ALSA: hda: Fix widget_mutex incomplete protection
      ALSA: firewire-lib/fireworks: fix miss detection of received MIDI messages
      ALSA: seq: fix incorrect order of dest_client/dest_ports arguments
      ALSA: hda/realtek - Change front mic location for Lenovo M710q
      ALSA: usb-audio: fix sign unintended sign extension on left shifts
      ALSA: hda/realtek: Add quirks for several Clevo notebook barebones

commit c3ea60c231446663afd6ea1054da6b7f830855ca
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Jun 28 10:54:29 2019 +0100

    ALSA: seq: fix incorrect order of dest_client/dest_ports arguments
    
    There are two occurrances of a call to snd_seq_oss_fill_addr where
    the dest_client and dest_port arguments are in the wrong order. Fix
    this by swapping them around.
    
    Addresses-Coverity: ("Arguments in wrong order")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_ioctl.c b/sound/core/seq/oss/seq_oss_ioctl.c
index 5b8520177b0e..7d72e3d48ad5 100644
--- a/sound/core/seq/oss/seq_oss_ioctl.c
+++ b/sound/core/seq/oss/seq_oss_ioctl.c
@@ -62,7 +62,7 @@ static int snd_seq_oss_oob_user(struct seq_oss_devinfo *dp, void __user *arg)
 	if (copy_from_user(ev, arg, 8))
 		return -EFAULT;
 	memset(&tmpev, 0, sizeof(tmpev));
-	snd_seq_oss_fill_addr(dp, &tmpev, dp->addr.port, dp->addr.client);
+	snd_seq_oss_fill_addr(dp, &tmpev, dp->addr.client, dp->addr.port);
 	tmpev.time.tick = 0;
 	if (! snd_seq_oss_process_event(dp, (union evrec *)ev, &tmpev)) {
 		snd_seq_oss_dispatch(dp, &tmpev, 0, 0);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/seq/oss/seq_oss_ioctl.c b/sound/core/seq/oss/seq_oss_ioctl.c
index 5b8520177b0e..96ad01fb668c 100644
--- a/sound/core/seq/oss/seq_oss_ioctl.c
+++ b/sound/core/seq/oss/seq_oss_ioctl.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * OSS compatible sequencer driver
  *
  * OSS compatible i/o control
  *
  * Copyright (C) 1998,99 Takashi Iwai <tiwai@suse.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include "seq_oss_device.h"

commit a67ca25b6cc6d2f3f24aebf1c83af3db28b5e304
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:04:49 2014 +0100

    ALSA: seq_oss: Drop debug prints
    
    The debug prints in snd-seq-oss module are rather useless.
    Let's clean up before further modifications.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_ioctl.c b/sound/core/seq/oss/seq_oss_ioctl.c
index 5ac701c903c1..5b8520177b0e 100644
--- a/sound/core/seq/oss/seq_oss_ioctl.c
+++ b/sound/core/seq/oss/seq_oss_ioctl.c
@@ -90,12 +90,10 @@ snd_seq_oss_ioctl(struct seq_oss_devinfo *dp, unsigned int cmd, unsigned long ca
 		return snd_seq_oss_timer_ioctl(dp->timer, cmd, arg);
 
 	case SNDCTL_SEQ_PANIC:
-		debug_printk(("panic\n"));
 		snd_seq_oss_reset(dp);
 		return -EINVAL;
 
 	case SNDCTL_SEQ_SYNC:
-		debug_printk(("sync\n"));
 		if (! is_write_mode(dp->file_mode) || dp->writeq == NULL)
 			return 0;
 		while (snd_seq_oss_writeq_sync(dp->writeq))
@@ -105,55 +103,45 @@ snd_seq_oss_ioctl(struct seq_oss_devinfo *dp, unsigned int cmd, unsigned long ca
 		return 0;
 
 	case SNDCTL_SEQ_RESET:
-		debug_printk(("reset\n"));
 		snd_seq_oss_reset(dp);
 		return 0;
 
 	case SNDCTL_SEQ_TESTMIDI:
-		debug_printk(("test midi\n"));
 		if (get_user(dev, p))
 			return -EFAULT;
 		return snd_seq_oss_midi_open(dp, dev, dp->file_mode);
 
 	case SNDCTL_SEQ_GETINCOUNT:
-		debug_printk(("get in count\n"));
 		if (dp->readq == NULL || ! is_read_mode(dp->file_mode))
 			return 0;
 		return put_user(dp->readq->qlen, p) ? -EFAULT : 0;
 
 	case SNDCTL_SEQ_GETOUTCOUNT:
-		debug_printk(("get out count\n"));
 		if (! is_write_mode(dp->file_mode) || dp->writeq == NULL)
 			return 0;
 		return put_user(snd_seq_oss_writeq_get_free_size(dp->writeq), p) ? -EFAULT : 0;
 
 	case SNDCTL_SEQ_GETTIME:
-		debug_printk(("get time\n"));
 		return put_user(snd_seq_oss_timer_cur_tick(dp->timer), p) ? -EFAULT : 0;
 
 	case SNDCTL_SEQ_RESETSAMPLES:
-		debug_printk(("reset samples\n"));
 		if (get_user(dev, p))
 			return -EFAULT;
 		return snd_seq_oss_synth_ioctl(dp, dev, cmd, carg);
 
 	case SNDCTL_SEQ_NRSYNTHS:
-		debug_printk(("nr synths\n"));
 		return put_user(dp->max_synthdev, p) ? -EFAULT : 0;
 
 	case SNDCTL_SEQ_NRMIDIS:
-		debug_printk(("nr midis\n"));
 		return put_user(dp->max_mididev, p) ? -EFAULT : 0;
 
 	case SNDCTL_SYNTH_MEMAVL:
-		debug_printk(("mem avail\n"));
 		if (get_user(dev, p))
 			return -EFAULT;
 		val = snd_seq_oss_synth_ioctl(dp, dev, cmd, carg);
 		return put_user(val, p) ? -EFAULT : 0;
 
 	case SNDCTL_FM_4OP_ENABLE:
-		debug_printk(("4op\n"));
 		if (get_user(dev, p))
 			return -EFAULT;
 		snd_seq_oss_synth_ioctl(dp, dev, cmd, carg);
@@ -161,19 +149,15 @@ snd_seq_oss_ioctl(struct seq_oss_devinfo *dp, unsigned int cmd, unsigned long ca
 
 	case SNDCTL_SYNTH_INFO:
 	case SNDCTL_SYNTH_ID:
-		debug_printk(("synth info\n"));
 		return snd_seq_oss_synth_info_user(dp, arg);
 
 	case SNDCTL_SEQ_OUTOFBAND:
-		debug_printk(("out of band\n"));
 		return snd_seq_oss_oob_user(dp, arg);
 
 	case SNDCTL_MIDI_INFO:
-		debug_printk(("midi info\n"));
 		return snd_seq_oss_midi_info_user(dp, arg);
 
 	case SNDCTL_SEQ_THRESHOLD:
-		debug_printk(("threshold\n"));
 		if (! is_write_mode(dp->file_mode))
 			return 0;
 		if (get_user(val, p))
@@ -186,7 +170,6 @@ snd_seq_oss_ioctl(struct seq_oss_devinfo *dp, unsigned int cmd, unsigned long ca
 		return 0;
 
 	case SNDCTL_MIDI_PRETIME:
-		debug_printk(("pretime\n"));
 		if (dp->readq == NULL || !is_read_mode(dp->file_mode))
 			return 0;
 		if (get_user(val, p))
@@ -199,7 +182,6 @@ snd_seq_oss_ioctl(struct seq_oss_devinfo *dp, unsigned int cmd, unsigned long ca
 		return put_user(val, p) ? -EFAULT : 0;
 
 	default:
-		debug_printk(("others\n"));
 		if (! is_write_mode(dp->file_mode))
 			return -EIO;
 		return snd_seq_oss_synth_ioctl(dp, 0, cmd, carg);

commit 080dece3460b534bedc4ef4ba3abaa57e9486331
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:05:16 2005 +0100

    [ALSA] Remove xxx_t typedefs: Sequencer OSS-emulation
    
    Modules: ALSA<-OSS sequencer,ALSA sequencer
    
    Remove xxx_t typedefs from the core sequencer OSS-emulation codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_ioctl.c b/sound/core/seq/oss/seq_oss_ioctl.c
index e86f18d00f39..5ac701c903c1 100644
--- a/sound/core/seq/oss/seq_oss_ioctl.c
+++ b/sound/core/seq/oss/seq_oss_ioctl.c
@@ -28,7 +28,7 @@
 #include "seq_oss_midi.h"
 #include "seq_oss_event.h"
 
-static int snd_seq_oss_synth_info_user(seq_oss_devinfo_t *dp, void __user *arg)
+static int snd_seq_oss_synth_info_user(struct seq_oss_devinfo *dp, void __user *arg)
 {
 	struct synth_info info;
 
@@ -41,7 +41,7 @@ static int snd_seq_oss_synth_info_user(seq_oss_devinfo_t *dp, void __user *arg)
 	return 0;
 }
 
-static int snd_seq_oss_midi_info_user(seq_oss_devinfo_t *dp, void __user *arg)
+static int snd_seq_oss_midi_info_user(struct seq_oss_devinfo *dp, void __user *arg)
 {
 	struct midi_info info;
 
@@ -54,24 +54,24 @@ static int snd_seq_oss_midi_info_user(seq_oss_devinfo_t *dp, void __user *arg)
 	return 0;
 }
 
-static int snd_seq_oss_oob_user(seq_oss_devinfo_t *dp, void __user *arg)
+static int snd_seq_oss_oob_user(struct seq_oss_devinfo *dp, void __user *arg)
 {
 	unsigned char ev[8];
-	snd_seq_event_t tmpev;
+	struct snd_seq_event tmpev;
 
 	if (copy_from_user(ev, arg, 8))
 		return -EFAULT;
 	memset(&tmpev, 0, sizeof(tmpev));
 	snd_seq_oss_fill_addr(dp, &tmpev, dp->addr.port, dp->addr.client);
 	tmpev.time.tick = 0;
-	if (! snd_seq_oss_process_event(dp, (evrec_t*)ev, &tmpev)) {
+	if (! snd_seq_oss_process_event(dp, (union evrec *)ev, &tmpev)) {
 		snd_seq_oss_dispatch(dp, &tmpev, 0, 0);
 	}
 	return 0;
 }
 
 int
-snd_seq_oss_ioctl(seq_oss_devinfo_t *dp, unsigned int cmd, unsigned long carg)
+snd_seq_oss_ioctl(struct seq_oss_devinfo *dp, unsigned int cmd, unsigned long carg)
 {
 	int dev, val;
 	void __user *arg = (void __user *)carg;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/seq/oss/seq_oss_ioctl.c b/sound/core/seq/oss/seq_oss_ioctl.c
new file mode 100644
index 000000000000..e86f18d00f39
--- /dev/null
+++ b/sound/core/seq/oss/seq_oss_ioctl.c
@@ -0,0 +1,209 @@
+/*
+ * OSS compatible sequencer driver
+ *
+ * OSS compatible i/o control
+ *
+ * Copyright (C) 1998,99 Takashi Iwai <tiwai@suse.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "seq_oss_device.h"
+#include "seq_oss_readq.h"
+#include "seq_oss_writeq.h"
+#include "seq_oss_timer.h"
+#include "seq_oss_synth.h"
+#include "seq_oss_midi.h"
+#include "seq_oss_event.h"
+
+static int snd_seq_oss_synth_info_user(seq_oss_devinfo_t *dp, void __user *arg)
+{
+	struct synth_info info;
+
+	if (copy_from_user(&info, arg, sizeof(info)))
+		return -EFAULT;
+	if (snd_seq_oss_synth_make_info(dp, info.device, &info) < 0)
+		return -EINVAL;
+	if (copy_to_user(arg, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+static int snd_seq_oss_midi_info_user(seq_oss_devinfo_t *dp, void __user *arg)
+{
+	struct midi_info info;
+
+	if (copy_from_user(&info, arg, sizeof(info)))
+		return -EFAULT;
+	if (snd_seq_oss_midi_make_info(dp, info.device, &info) < 0)
+		return -EINVAL;
+	if (copy_to_user(arg, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+static int snd_seq_oss_oob_user(seq_oss_devinfo_t *dp, void __user *arg)
+{
+	unsigned char ev[8];
+	snd_seq_event_t tmpev;
+
+	if (copy_from_user(ev, arg, 8))
+		return -EFAULT;
+	memset(&tmpev, 0, sizeof(tmpev));
+	snd_seq_oss_fill_addr(dp, &tmpev, dp->addr.port, dp->addr.client);
+	tmpev.time.tick = 0;
+	if (! snd_seq_oss_process_event(dp, (evrec_t*)ev, &tmpev)) {
+		snd_seq_oss_dispatch(dp, &tmpev, 0, 0);
+	}
+	return 0;
+}
+
+int
+snd_seq_oss_ioctl(seq_oss_devinfo_t *dp, unsigned int cmd, unsigned long carg)
+{
+	int dev, val;
+	void __user *arg = (void __user *)carg;
+	int __user *p = arg;
+
+	switch (cmd) {
+	case SNDCTL_TMR_TIMEBASE:
+	case SNDCTL_TMR_TEMPO:
+	case SNDCTL_TMR_START:
+	case SNDCTL_TMR_STOP:
+	case SNDCTL_TMR_CONTINUE:
+	case SNDCTL_TMR_METRONOME:
+	case SNDCTL_TMR_SOURCE:
+	case SNDCTL_TMR_SELECT:
+	case SNDCTL_SEQ_CTRLRATE:
+		return snd_seq_oss_timer_ioctl(dp->timer, cmd, arg);
+
+	case SNDCTL_SEQ_PANIC:
+		debug_printk(("panic\n"));
+		snd_seq_oss_reset(dp);
+		return -EINVAL;
+
+	case SNDCTL_SEQ_SYNC:
+		debug_printk(("sync\n"));
+		if (! is_write_mode(dp->file_mode) || dp->writeq == NULL)
+			return 0;
+		while (snd_seq_oss_writeq_sync(dp->writeq))
+			;
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+		return 0;
+
+	case SNDCTL_SEQ_RESET:
+		debug_printk(("reset\n"));
+		snd_seq_oss_reset(dp);
+		return 0;
+
+	case SNDCTL_SEQ_TESTMIDI:
+		debug_printk(("test midi\n"));
+		if (get_user(dev, p))
+			return -EFAULT;
+		return snd_seq_oss_midi_open(dp, dev, dp->file_mode);
+
+	case SNDCTL_SEQ_GETINCOUNT:
+		debug_printk(("get in count\n"));
+		if (dp->readq == NULL || ! is_read_mode(dp->file_mode))
+			return 0;
+		return put_user(dp->readq->qlen, p) ? -EFAULT : 0;
+
+	case SNDCTL_SEQ_GETOUTCOUNT:
+		debug_printk(("get out count\n"));
+		if (! is_write_mode(dp->file_mode) || dp->writeq == NULL)
+			return 0;
+		return put_user(snd_seq_oss_writeq_get_free_size(dp->writeq), p) ? -EFAULT : 0;
+
+	case SNDCTL_SEQ_GETTIME:
+		debug_printk(("get time\n"));
+		return put_user(snd_seq_oss_timer_cur_tick(dp->timer), p) ? -EFAULT : 0;
+
+	case SNDCTL_SEQ_RESETSAMPLES:
+		debug_printk(("reset samples\n"));
+		if (get_user(dev, p))
+			return -EFAULT;
+		return snd_seq_oss_synth_ioctl(dp, dev, cmd, carg);
+
+	case SNDCTL_SEQ_NRSYNTHS:
+		debug_printk(("nr synths\n"));
+		return put_user(dp->max_synthdev, p) ? -EFAULT : 0;
+
+	case SNDCTL_SEQ_NRMIDIS:
+		debug_printk(("nr midis\n"));
+		return put_user(dp->max_mididev, p) ? -EFAULT : 0;
+
+	case SNDCTL_SYNTH_MEMAVL:
+		debug_printk(("mem avail\n"));
+		if (get_user(dev, p))
+			return -EFAULT;
+		val = snd_seq_oss_synth_ioctl(dp, dev, cmd, carg);
+		return put_user(val, p) ? -EFAULT : 0;
+
+	case SNDCTL_FM_4OP_ENABLE:
+		debug_printk(("4op\n"));
+		if (get_user(dev, p))
+			return -EFAULT;
+		snd_seq_oss_synth_ioctl(dp, dev, cmd, carg);
+		return 0;
+
+	case SNDCTL_SYNTH_INFO:
+	case SNDCTL_SYNTH_ID:
+		debug_printk(("synth info\n"));
+		return snd_seq_oss_synth_info_user(dp, arg);
+
+	case SNDCTL_SEQ_OUTOFBAND:
+		debug_printk(("out of band\n"));
+		return snd_seq_oss_oob_user(dp, arg);
+
+	case SNDCTL_MIDI_INFO:
+		debug_printk(("midi info\n"));
+		return snd_seq_oss_midi_info_user(dp, arg);
+
+	case SNDCTL_SEQ_THRESHOLD:
+		debug_printk(("threshold\n"));
+		if (! is_write_mode(dp->file_mode))
+			return 0;
+		if (get_user(val, p))
+			return -EFAULT;
+		if (val < 1)
+			val = 1;
+		if (val >= dp->writeq->maxlen)
+			val = dp->writeq->maxlen - 1;
+		snd_seq_oss_writeq_set_output(dp->writeq, val);
+		return 0;
+
+	case SNDCTL_MIDI_PRETIME:
+		debug_printk(("pretime\n"));
+		if (dp->readq == NULL || !is_read_mode(dp->file_mode))
+			return 0;
+		if (get_user(val, p))
+			return -EFAULT;
+		if (val <= 0)
+			val = -1;
+		else
+			val = (HZ * val) / 10;
+		dp->readq->pre_event_timeout = val;
+		return put_user(val, p) ? -EFAULT : 0;
+
+	default:
+		debug_printk(("others\n"));
+		if (! is_write_mode(dp->file_mode))
+			return -EIO;
+		return snd_seq_oss_synth_ioctl(dp, 0, cmd, carg);
+	}
+	return 0;
+}
+
