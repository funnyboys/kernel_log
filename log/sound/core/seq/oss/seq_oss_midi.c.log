commit 6c3171ef76a0bad892050f6959a7eac02fb16df7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 16 10:05:06 2020 +0100

    ALSA: seq: oss: Fix running status after receiving sysex
    
    This is a similar bug like the previous case for virmidi: the invalid
    running status is kept after receiving a sysex message.
    
    Again the fix is to clear the running status after handling the sysex.
    
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/3b4a4e0f232b7afbaf0a843f63d0e538e3029bfd.camel@domdv.de
    Link: https://lore.kernel.org/r/20200316090506.23966-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index a88c235b2ea3..2ddfe2226651 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -602,6 +602,7 @@ send_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq
 		len = snd_seq_oss_timer_start(dp->timer);
 	if (ev->type == SNDRV_SEQ_EVENT_SYSEX) {
 		snd_seq_oss_readq_sysex(dp->readq, mdev->seq_device, ev);
+		snd_midi_event_reset_decode(mdev->coder);
 	} else {
 		len = snd_midi_event_decode(mdev->coder, msg, sizeof(msg), ev);
 		if (len > 0)

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 0d5f8b16d057..a88c235b2ea3 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * OSS compatible sequencer driver
  *
  * MIDI device handlers
  *
  * Copyright (C) 1998,99 Takashi Iwai <tiwai@suse.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <sound/asoundef.h>

commit ef965ad5a7697ff16e3be01954f5c57208e36c22
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 1 14:38:18 2018 +0200

    ALSA: seq: Minor cleanup of MIDI event parser helpers
    
    snd_midi_event_encode_byte() can never fail, and it can return rather
    true/false.  Change the return type to bool, adjust the argument to
    receive a MIDI byte as unsigned char, and adjust the comment
    accordingly.  This allows callers to drop error checks, which
    simplifies the code.
    
    Meanwhile, snd_midi_event_encode() helper is used only in seq_midi.c,
    and it can be better folded into it.  This will reduce the total
    amount of lines in the end.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 9debd1b8fd28..0d5f8b16d057 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -637,7 +637,7 @@ snd_seq_oss_midi_putc(struct seq_oss_devinfo *dp, int dev, unsigned char c, stru
 
 	if ((mdev = get_mididev(dp, dev)) == NULL)
 		return -ENODEV;
-	if (snd_midi_event_encode_byte(mdev->coder, c, ev) > 0) {
+	if (snd_midi_event_encode_byte(mdev->coder, c, ev)) {
 		snd_seq_oss_fill_addr(dp, ev, mdev->client, mdev->port);
 		snd_use_lock_free(&mdev->use_lock);
 		return 0;

commit 8d218dd8116695ecda7164f97631c069938aa22e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 07:31:54 2018 +0200

    ALSA: seq: oss: Hardening for potential Spectre v1
    
    As Smatch recently suggested, a few places in OSS sequencer codes may
    expand the array directly from the user-space value with speculation,
    namely there are a significant amount of references to either
    info->ch[] or dp->synths[] array:
    
      sound/core/seq/oss/seq_oss_event.c:315 note_on_event() warn: potential spectre issue 'info->ch' (local cap)
      sound/core/seq/oss/seq_oss_event.c:362 note_off_event() warn: potential spectre issue 'info->ch' (local cap)
      sound/core/seq/oss/seq_oss_synth.c:470 snd_seq_oss_synth_load_patch() warn: potential spectre issue 'dp->synths' (local cap)
      sound/core/seq/oss/seq_oss_event.c:293 note_on_event() warn: potential spectre issue 'dp->synths'
      sound/core/seq/oss/seq_oss_event.c:353 note_off_event() warn: potential spectre issue 'dp->synths'
      sound/core/seq/oss/seq_oss_synth.c:506 snd_seq_oss_synth_sysex() warn: potential spectre issue 'dp->synths'
      sound/core/seq/oss/seq_oss_synth.c:580 snd_seq_oss_synth_ioctl() warn: potential spectre issue 'dp->synths'
    
    Although all these seem doing only the first load without further
    reference, we may want to stay in a safer side, so hardening with
    array_index_nospec() would still make sense.
    
    We may put array_index_nospec() at each place, but here we take a
    different approach:
    
    - For dp->synths[], change the helpers to retrieve seq_oss_synthinfo
      pointer directly instead of the array expansion at each place
    
    - For info->ch[], harden in a normal way, as there are only a couple
      of places
    
    As a result, the existing helper, snd_seq_oss_synth_is_valid() is
    replaced with snd_seq_oss_synth_info().  Also, we cover MIDI device
    where a similar array expansion is done, too, although it wasn't
    reported by Smatch.
    
    BugLink: https://marc.info/?l=linux-kernel&m=152411496503418&w=2
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index b30b2139e3f0..9debd1b8fd28 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -29,6 +29,7 @@
 #include "../seq_lock.h"
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/nospec.h>
 
 
 /*
@@ -315,6 +316,7 @@ get_mididev(struct seq_oss_devinfo *dp, int dev)
 {
 	if (dev < 0 || dev >= dp->max_mididev)
 		return NULL;
+	dev = array_index_nospec(dev, dp->max_mididev);
 	return get_mdev(dev);
 }
 

commit 132d358b183ac6ad8b3fea32ad5e0663456d18d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 7 16:05:24 2017 +0100

    ALSA: seq: Fix OSS sysex delivery in OSS emulation
    
    The SYSEX event delivery in OSS sequencer emulation assumed that the
    event is encoded in the variable-length data with the straight
    buffering.  This was the normal behavior in the past, but during the
    development, the chained buffers were introduced for carrying more
    data, while the OSS code was left intact.  As a result, when a SYSEX
    event with the chained buffer data is passed to OSS sequencer port,
    it may end up with the wrong memory access, as if it were having a too
    large buffer.
    
    This patch addresses the bug, by applying the buffer data expansion by
    the generic snd_seq_dump_var_event() helper function.
    
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Reported-by: Mark Salyzyn <salyzyn@android.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index aaff9ee32695..b30b2139e3f0 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -612,9 +612,7 @@ send_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq
 	if (!dp->timer->running)
 		len = snd_seq_oss_timer_start(dp->timer);
 	if (ev->type == SNDRV_SEQ_EVENT_SYSEX) {
-		if ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) == SNDRV_SEQ_EVENT_LENGTH_VARIABLE)
-			snd_seq_oss_readq_puts(dp->readq, mdev->seq_device,
-					       ev->data.ext.ptr, ev->data.ext.len);
+		snd_seq_oss_readq_sysex(dp->readq, mdev->seq_device, ev);
 	} else {
 		len = snd_midi_event_decode(mdev->coder, msg, sizeof(msg), ev);
 		if (len > 0)

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 96e8395ae586..aaff9ee32695 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -665,7 +665,7 @@ snd_seq_oss_midi_make_info(struct seq_oss_devinfo *dp, int dev, struct midi_info
 }
 
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /*
  * proc interface
  */
@@ -705,4 +705,4 @@ snd_seq_oss_midi_info_read(struct snd_info_buffer *buf)
 		snd_use_lock_free(&mdev->use_lock);
 	}
 }
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */

commit 8d98a0673f761f9b7be51a293ca9142ec0c037ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:39:55 2015 +0100

    ALSA: seq_oss: Drop superfluous error/debug messages after malloc failures
    
    The kernel memory allocators already report the errors when the
    requested allocation fails, thus we don't need to warn it again in
    each caller side.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index e79cc44b1394..96e8395ae586 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -173,10 +173,9 @@ snd_seq_oss_midi_check_new_port(struct snd_seq_port_info *pinfo)
 	/*
 	 * allocate midi info record
 	 */
-	if ((mdev = kzalloc(sizeof(*mdev), GFP_KERNEL)) == NULL) {
-		pr_err("ALSA: seq_oss: can't malloc midi info\n");
+	mdev = kzalloc(sizeof(*mdev), GFP_KERNEL);
+	if (!mdev)
 		return -ENOMEM;
-	}
 
 	/* copy the port information */
 	mdev->client = pinfo->addr.client;

commit 57dca36ee25bcab20a71705175c00b6f114cdab4
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 14:54:56 2015 +0100

    ALSA: seq: Deletion of unnecessary checks before the function call "snd_midi_event_free"
    
    The snd_midi_event_free() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 3a4569669efa..e79cc44b1394 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -237,8 +237,7 @@ snd_seq_oss_midi_check_exit_port(int client, int port)
 		spin_unlock_irqrestore(&register_lock, flags);
 		snd_use_lock_free(&mdev->use_lock);
 		snd_use_lock_sync(&mdev->use_lock);
-		if (mdev->coder)
-			snd_midi_event_free(mdev->coder);
+		snd_midi_event_free(mdev->coder);
 		kfree(mdev);
 	}
 	spin_lock_irqsave(&register_lock, flags);
@@ -265,8 +264,7 @@ snd_seq_oss_midi_clear_all(void)
 	spin_lock_irqsave(&register_lock, flags);
 	for (i = 0; i < max_midi_devs; i++) {
 		if ((mdev = midi_devs[i]) != NULL) {
-			if (mdev->coder)
-				snd_midi_event_free(mdev->coder);
+			snd_midi_event_free(mdev->coder);
 			kfree(mdev);
 			midi_devs[i] = NULL;
 		}

commit bb343e7969cb8a4b6b20bddc97098c87f4fae2b5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:24:04 2014 +0100

    ALSA: seq_oss: Use standard printk helpers
    
    Use the standard pr_xxx() helpers instead of home-baked snd_print*().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 97f958b46542..3a4569669efa 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -174,7 +174,7 @@ snd_seq_oss_midi_check_new_port(struct snd_seq_port_info *pinfo)
 	 * allocate midi info record
 	 */
 	if ((mdev = kzalloc(sizeof(*mdev), GFP_KERNEL)) == NULL) {
-		snd_printk(KERN_ERR "can't malloc midi info\n");
+		pr_err("ALSA: seq_oss: can't malloc midi info\n");
 		return -ENOMEM;
 	}
 
@@ -190,7 +190,7 @@ snd_seq_oss_midi_check_new_port(struct snd_seq_port_info *pinfo)
 
 	/* create MIDI coder */
 	if (snd_midi_event_new(MAX_MIDI_EVENT_BUF, &mdev->coder) < 0) {
-		snd_printk(KERN_ERR "can't malloc midi coder\n");
+		pr_err("ALSA: seq_oss: can't malloc midi coder\n");
 		kfree(mdev);
 		return -ENOMEM;
 	}

commit a67ca25b6cc6d2f3f24aebf1c83af3db28b5e304
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:04:49 2014 +0100

    ALSA: seq_oss: Drop debug prints
    
    The debug prints in snd-seq-oss module are rather useless.
    Let's clean up before further modifications.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 862d84893ee8..97f958b46542 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -153,7 +153,6 @@ snd_seq_oss_midi_check_new_port(struct snd_seq_port_info *pinfo)
 	struct seq_oss_midi *mdev;
 	unsigned long flags;
 
-	debug_printk(("check for MIDI client %d port %d\n", pinfo->addr.client, pinfo->addr.port));
 	/* the port must include generic midi */
 	if (! (pinfo->type & SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC))
 		return 0;
@@ -406,7 +405,6 @@ snd_seq_oss_midi_close(struct seq_oss_devinfo *dp, int dev)
 		return 0;
 	}
 
-	debug_printk(("closing client %d port %d mode %d\n", mdev->client, mdev->port, mdev->opened));
 	memset(&subs, 0, sizeof(subs));
 	if (mdev->opened & PERM_WRITE) {
 		subs.sender = dp->addr;
@@ -470,7 +468,6 @@ snd_seq_oss_midi_reset(struct seq_oss_devinfo *dp, int dev)
 		struct snd_seq_event ev;
 		int c;
 
-		debug_printk(("resetting client %d port %d\n", mdev->client, mdev->port));
 		memset(&ev, 0, sizeof(ev));
 		ev.dest.client = mdev->client;
 		ev.dest.port = mdev->port;

commit 256ca9c3ad5013ff8a8f165e5a82fab437628c8e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 16 12:17:49 2013 +0200

    ALSA: seq-oss: Initialize MIDI clients asynchronously
    
    We've got bug reports that the module loading stuck on Debian system
    with 3.10 kernel.  The debugging session revealed that the initial
    registration of OSS sequencer clients stuck at module loading time,
    which involves again with request_module() at the init phase.  This is
    triggered only by special --install stuff Debian is using, but it's
    still not good to have such loops.
    
    As a workaround, call the registration part asynchronously.  This is a
    better approach irrespective of the hang fix, in anyway.
    
    Reported-and-tested-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 677dc84590c7..862d84893ee8 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -72,7 +72,7 @@ static int send_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev,
  * look up the existing ports
  * this looks a very exhausting job.
  */
-int __init
+int
 snd_seq_oss_midi_lookup_ports(int client)
 {
 	struct snd_seq_client_info *clinfo;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 9dfb2f77be60..677dc84590c7 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -28,6 +28,7 @@
 #include <sound/seq_midi_event.h>
 #include "../seq_lock.h"
 #include <linux/init.h>
+#include <linux/slab.h>
 
 
 /*

commit 08d033405a5a537d4197dad0fcb6be47062be2a9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jul 13 13:50:57 2009 +0200

    sound: seq_oss_midi: remove magic numbers
    
    Instead of using magic numbers for the controlles sent when resetting
    a port, use the symbols from asoundef.h.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 0a711d2d04f0..9dfb2f77be60 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -20,6 +20,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
+#include <sound/asoundef.h>
 #include "seq_oss_midi.h"
 #include "seq_oss_readq.h"
 #include "seq_oss_timer.h"
@@ -476,19 +477,20 @@ snd_seq_oss_midi_reset(struct seq_oss_devinfo *dp, int dev)
 		ev.source.port = dp->port;
 		if (dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH) {
 			ev.type = SNDRV_SEQ_EVENT_SENSING;
-			snd_seq_oss_dispatch(dp, &ev, 0, 0); /* active sensing */
+			snd_seq_oss_dispatch(dp, &ev, 0, 0);
 		}
 		for (c = 0; c < 16; c++) {
 			ev.type = SNDRV_SEQ_EVENT_CONTROLLER;
 			ev.data.control.channel = c;
-			ev.data.control.param = 123;
-			snd_seq_oss_dispatch(dp, &ev, 0, 0); /* all notes off */
+			ev.data.control.param = MIDI_CTL_ALL_NOTES_OFF;
+			snd_seq_oss_dispatch(dp, &ev, 0, 0);
 			if (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC) {
-				ev.data.control.param = 121;
-				snd_seq_oss_dispatch(dp, &ev, 0, 0); /* reset all controllers */
+				ev.data.control.param =
+					MIDI_CTL_RESET_CONTROLLERS;
+				snd_seq_oss_dispatch(dp, &ev, 0, 0);
 				ev.type = SNDRV_SEQ_EVENT_PITCHBEND;
 				ev.data.control.value = 0;
-				snd_seq_oss_dispatch(dp, &ev, 0, 0); /* bender off */
+				snd_seq_oss_dispatch(dp, &ev, 0, 0);
 			}
 		}
 	}

commit 04f141a8800d022981f0405a8d307c98aba55105
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:43:51 2005 +0100

    [ALSA] Optimize for config without PROC_FS (seq and oss parts)
    
    Modules: ALSA<-OSS emulation,ALSA sequencer,ALSA<-OSS sequencer
    
    Optimize the code when compiled without CONFIG_PROC_FS (in seq and oss
    emulation parts).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index eb7ae990965c..0a711d2d04f0 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -668,6 +668,7 @@ snd_seq_oss_midi_make_info(struct seq_oss_devinfo *dp, int dev, struct midi_info
 }
 
 
+#ifdef CONFIG_PROC_FS
 /*
  * proc interface
  */
@@ -707,4 +708,4 @@ snd_seq_oss_midi_info_read(struct snd_info_buffer *buf)
 		snd_use_lock_free(&mdev->use_lock);
 	}
 }
-
+#endif /* CONFIG_PROC_FS */

commit 080dece3460b534bedc4ef4ba3abaa57e9486331
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:05:16 2005 +0100

    [ALSA] Remove xxx_t typedefs: Sequencer OSS-emulation
    
    Modules: ALSA<-OSS sequencer,ALSA sequencer
    
    Remove xxx_t typedefs from the core sequencer OSS-emulation codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index f0e95c8f2eef..eb7ae990965c 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -37,15 +37,15 @@
 /*
  * definition of midi device record
  */
-struct seq_oss_midi_t {
+struct seq_oss_midi {
 	int seq_device;		/* device number */
 	int client;		/* sequencer client number */
 	int port;		/* sequencer port number */
 	unsigned int flags;	/* port capability */
 	int opened;		/* flag for opening */
 	unsigned char name[SNDRV_SEQ_OSS_MAX_MIDI_NAME];
-	snd_midi_event_t *coder;	/* MIDI event coder */
-	seq_oss_devinfo_t *devinfo;	/* assigned OSSseq device */
+	struct snd_midi_event *coder;	/* MIDI event coder */
+	struct seq_oss_devinfo *devinfo;	/* assigned OSSseq device */
 	snd_use_lock_t use_lock;
 };
 
@@ -54,17 +54,17 @@ struct seq_oss_midi_t {
  * midi device table
  */
 static int max_midi_devs;
-static seq_oss_midi_t *midi_devs[SNDRV_SEQ_OSS_MAX_MIDI_DEVS];
+static struct seq_oss_midi *midi_devs[SNDRV_SEQ_OSS_MAX_MIDI_DEVS];
 
 static DEFINE_SPINLOCK(register_lock);
 
 /*
  * prototypes
  */
-static seq_oss_midi_t *get_mdev(int dev);
-static seq_oss_midi_t *get_mididev(seq_oss_devinfo_t *dp, int dev);
-static int send_synth_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, int dev);
-static int send_midi_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, seq_oss_midi_t *mdev);
+static struct seq_oss_midi *get_mdev(int dev);
+static struct seq_oss_midi *get_mididev(struct seq_oss_devinfo *dp, int dev);
+static int send_synth_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, int dev);
+static int send_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq_oss_midi *mdev);
 
 /*
  * look up the existing ports
@@ -73,8 +73,8 @@ static int send_midi_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, seq_oss_m
 int __init
 snd_seq_oss_midi_lookup_ports(int client)
 {
-	snd_seq_client_info_t *clinfo;
-	snd_seq_port_info_t *pinfo;
+	struct snd_seq_client_info *clinfo;
+	struct snd_seq_port_info *pinfo;
 
 	clinfo = kzalloc(sizeof(*clinfo), GFP_KERNEL);
 	pinfo = kzalloc(sizeof(*pinfo), GFP_KERNEL);
@@ -100,10 +100,10 @@ snd_seq_oss_midi_lookup_ports(int client)
 
 /*
  */
-static seq_oss_midi_t *
+static struct seq_oss_midi *
 get_mdev(int dev)
 {
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 	unsigned long flags;
 
 	spin_lock_irqsave(&register_lock, flags);
@@ -117,11 +117,11 @@ get_mdev(int dev)
 /*
  * look for the identical slot
  */
-static seq_oss_midi_t *
+static struct seq_oss_midi *
 find_slot(int client, int port)
 {
 	int i;
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 	unsigned long flags;
 
 	spin_lock_irqsave(&register_lock, flags);
@@ -145,10 +145,10 @@ find_slot(int client, int port)
  * register a new port if it doesn't exist yet
  */
 int
-snd_seq_oss_midi_check_new_port(snd_seq_port_info_t *pinfo)
+snd_seq_oss_midi_check_new_port(struct snd_seq_port_info *pinfo)
 {
 	int i;
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 	unsigned long flags;
 
 	debug_printk(("check for MIDI client %d port %d\n", pinfo->addr.client, pinfo->addr.port));
@@ -226,7 +226,7 @@ snd_seq_oss_midi_check_new_port(snd_seq_port_info_t *pinfo)
 int
 snd_seq_oss_midi_check_exit_port(int client, int port)
 {
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 	unsigned long flags;
 	int index;
 
@@ -258,7 +258,7 @@ void
 snd_seq_oss_midi_clear_all(void)
 {
 	int i;
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 	unsigned long flags;
 
 	spin_lock_irqsave(&register_lock, flags);
@@ -279,7 +279,7 @@ snd_seq_oss_midi_clear_all(void)
  * set up midi tables
  */
 void
-snd_seq_oss_midi_setup(seq_oss_devinfo_t *dp)
+snd_seq_oss_midi_setup(struct seq_oss_devinfo *dp)
 {
 	dp->max_mididev = max_midi_devs;
 }
@@ -288,7 +288,7 @@ snd_seq_oss_midi_setup(seq_oss_devinfo_t *dp)
  * clean up midi tables
  */
 void
-snd_seq_oss_midi_cleanup(seq_oss_devinfo_t *dp)
+snd_seq_oss_midi_cleanup(struct seq_oss_devinfo *dp)
 {
 	int i;
 	for (i = 0; i < dp->max_mididev; i++)
@@ -301,7 +301,7 @@ snd_seq_oss_midi_cleanup(seq_oss_devinfo_t *dp)
  * open all midi devices.  ignore errors.
  */
 void
-snd_seq_oss_midi_open_all(seq_oss_devinfo_t *dp, int file_mode)
+snd_seq_oss_midi_open_all(struct seq_oss_devinfo *dp, int file_mode)
 {
 	int i;
 	for (i = 0; i < dp->max_mididev; i++)
@@ -312,8 +312,8 @@ snd_seq_oss_midi_open_all(seq_oss_devinfo_t *dp, int file_mode)
 /*
  * get the midi device information
  */
-static seq_oss_midi_t *
-get_mididev(seq_oss_devinfo_t *dp, int dev)
+static struct seq_oss_midi *
+get_mididev(struct seq_oss_devinfo *dp, int dev)
 {
 	if (dev < 0 || dev >= dp->max_mididev)
 		return NULL;
@@ -325,11 +325,11 @@ get_mididev(seq_oss_devinfo_t *dp, int dev)
  * open the midi device if not opened yet
  */
 int
-snd_seq_oss_midi_open(seq_oss_devinfo_t *dp, int dev, int fmode)
+snd_seq_oss_midi_open(struct seq_oss_devinfo *dp, int dev, int fmode)
 {
 	int perm;
-	seq_oss_midi_t *mdev;
-	snd_seq_port_subscribe_t subs;
+	struct seq_oss_midi *mdev;
+	struct snd_seq_port_subscribe subs;
 
 	if ((mdev = get_mididev(dp, dev)) == NULL)
 		return -ENODEV;
@@ -392,10 +392,10 @@ snd_seq_oss_midi_open(seq_oss_devinfo_t *dp, int dev, int fmode)
  * close the midi device if already opened
  */
 int
-snd_seq_oss_midi_close(seq_oss_devinfo_t *dp, int dev)
+snd_seq_oss_midi_close(struct seq_oss_devinfo *dp, int dev)
 {
-	seq_oss_midi_t *mdev;
-	snd_seq_port_subscribe_t subs;
+	struct seq_oss_midi *mdev;
+	struct snd_seq_port_subscribe subs;
 
 	if ((mdev = get_mididev(dp, dev)) == NULL)
 		return -ENODEV;
@@ -430,9 +430,9 @@ snd_seq_oss_midi_close(seq_oss_devinfo_t *dp, int dev)
  * change seq capability flags to file mode flags
  */
 int
-snd_seq_oss_midi_filemode(seq_oss_devinfo_t *dp, int dev)
+snd_seq_oss_midi_filemode(struct seq_oss_devinfo *dp, int dev)
 {
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 	int mode;
 
 	if ((mdev = get_mididev(dp, dev)) == NULL)
@@ -453,9 +453,9 @@ snd_seq_oss_midi_filemode(seq_oss_devinfo_t *dp, int dev)
  * so far, only close the device.
  */
 void
-snd_seq_oss_midi_reset(seq_oss_devinfo_t *dp, int dev)
+snd_seq_oss_midi_reset(struct seq_oss_devinfo *dp, int dev)
 {
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 
 	if ((mdev = get_mididev(dp, dev)) == NULL)
 		return;
@@ -465,7 +465,7 @@ snd_seq_oss_midi_reset(seq_oss_devinfo_t *dp, int dev)
 	}
 
 	if (mdev->opened & PERM_WRITE) {
-		snd_seq_event_t ev;
+		struct snd_seq_event ev;
 		int c;
 
 		debug_printk(("resetting client %d port %d\n", mdev->client, mdev->port));
@@ -501,9 +501,9 @@ snd_seq_oss_midi_reset(seq_oss_devinfo_t *dp, int dev)
  * get client/port of the specified MIDI device
  */
 void
-snd_seq_oss_midi_get_addr(seq_oss_devinfo_t *dp, int dev, snd_seq_addr_t *addr)
+snd_seq_oss_midi_get_addr(struct seq_oss_devinfo *dp, int dev, struct snd_seq_addr *addr)
 {
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 
 	if ((mdev = get_mididev(dp, dev)) == NULL)
 		return;
@@ -517,10 +517,10 @@ snd_seq_oss_midi_get_addr(seq_oss_devinfo_t *dp, int dev, snd_seq_addr_t *addr)
  * input callback - this can be atomic
  */
 int
-snd_seq_oss_midi_input(snd_seq_event_t *ev, int direct, void *private_data)
+snd_seq_oss_midi_input(struct snd_seq_event *ev, int direct, void *private_data)
 {
-	seq_oss_devinfo_t *dp = (seq_oss_devinfo_t *)private_data;
-	seq_oss_midi_t *mdev;
+	struct seq_oss_devinfo *dp = (struct seq_oss_devinfo *)private_data;
+	struct seq_oss_midi *mdev;
 	int rc;
 
 	if (dp->readq == NULL)
@@ -545,9 +545,9 @@ snd_seq_oss_midi_input(snd_seq_event_t *ev, int direct, void *private_data)
  * convert ALSA sequencer event to OSS synth event
  */
 static int
-send_synth_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, int dev)
+send_synth_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, int dev)
 {
-	evrec_t ossev;
+	union evrec ossev;
 
 	memset(&ossev, 0, sizeof(ossev));
 
@@ -606,7 +606,7 @@ send_synth_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, int dev)
  * decode event and send MIDI bytes to read queue
  */
 static int
-send_midi_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, seq_oss_midi_t *mdev)
+send_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq_oss_midi *mdev)
 {
 	char msg[32];
 	int len;
@@ -634,9 +634,9 @@ send_midi_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, seq_oss_midi_t *mdev
  *        non-zero : invalid - ignored
  */
 int
-snd_seq_oss_midi_putc(seq_oss_devinfo_t *dp, int dev, unsigned char c, snd_seq_event_t *ev)
+snd_seq_oss_midi_putc(struct seq_oss_devinfo *dp, int dev, unsigned char c, struct snd_seq_event *ev)
 {
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 
 	if ((mdev = get_mididev(dp, dev)) == NULL)
 		return -ENODEV;
@@ -653,9 +653,9 @@ snd_seq_oss_midi_putc(seq_oss_devinfo_t *dp, int dev, unsigned char c, snd_seq_e
  * create OSS compatible midi_info record
  */
 int
-snd_seq_oss_midi_make_info(seq_oss_devinfo_t *dp, int dev, struct midi_info *inf)
+snd_seq_oss_midi_make_info(struct seq_oss_devinfo *dp, int dev, struct midi_info *inf)
 {
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 
 	if ((mdev = get_mididev(dp, dev)) == NULL)
 		return -ENXIO;
@@ -686,10 +686,10 @@ capmode_str(int val)
 }
 
 void
-snd_seq_oss_midi_info_read(snd_info_buffer_t *buf)
+snd_seq_oss_midi_info_read(struct snd_info_buffer *buf)
 {
 	int i;
-	seq_oss_midi_t *mdev;
+	struct seq_oss_midi *mdev;
 
 	snd_iprintf(buf, "\nNumber of MIDI devices: %d\n", max_midi_devs);
 	for (i = 0; i < max_midi_devs; i++) {

commit ecca82b4b447f8df73c807a018dac3e2863912d9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:49 2005 +0200

    [ALSA] Replace with kzalloc() - seq stuff
    
    ALSA sequencer,Instrument layer,ALSA<-OSS sequencer
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
index 9aece6c65dbc..f0e95c8f2eef 100644
--- a/sound/core/seq/oss/seq_oss_midi.c
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -76,8 +76,8 @@ snd_seq_oss_midi_lookup_ports(int client)
 	snd_seq_client_info_t *clinfo;
 	snd_seq_port_info_t *pinfo;
 
-	clinfo = kcalloc(1, sizeof(*clinfo), GFP_KERNEL);
-	pinfo = kcalloc(1, sizeof(*pinfo), GFP_KERNEL);
+	clinfo = kzalloc(sizeof(*clinfo), GFP_KERNEL);
+	pinfo = kzalloc(sizeof(*pinfo), GFP_KERNEL);
 	if (! clinfo || ! pinfo) {
 		kfree(clinfo);
 		kfree(pinfo);
@@ -172,7 +172,7 @@ snd_seq_oss_midi_check_new_port(snd_seq_port_info_t *pinfo)
 	/*
 	 * allocate midi info record
 	 */
-	if ((mdev = kcalloc(1, sizeof(*mdev), GFP_KERNEL)) == NULL) {
+	if ((mdev = kzalloc(sizeof(*mdev), GFP_KERNEL)) == NULL) {
 		snd_printk(KERN_ERR "can't malloc midi info\n");
 		return -ENOMEM;
 	}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c
new file mode 100644
index 000000000000..9aece6c65dbc
--- /dev/null
+++ b/sound/core/seq/oss/seq_oss_midi.c
@@ -0,0 +1,710 @@
+/*
+ * OSS compatible sequencer driver
+ *
+ * MIDI device handlers
+ *
+ * Copyright (C) 1998,99 Takashi Iwai <tiwai@suse.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "seq_oss_midi.h"
+#include "seq_oss_readq.h"
+#include "seq_oss_timer.h"
+#include "seq_oss_event.h"
+#include <sound/seq_midi_event.h>
+#include "../seq_lock.h"
+#include <linux/init.h>
+
+
+/*
+ * constants
+ */
+#define SNDRV_SEQ_OSS_MAX_MIDI_NAME	30
+
+/*
+ * definition of midi device record
+ */
+struct seq_oss_midi_t {
+	int seq_device;		/* device number */
+	int client;		/* sequencer client number */
+	int port;		/* sequencer port number */
+	unsigned int flags;	/* port capability */
+	int opened;		/* flag for opening */
+	unsigned char name[SNDRV_SEQ_OSS_MAX_MIDI_NAME];
+	snd_midi_event_t *coder;	/* MIDI event coder */
+	seq_oss_devinfo_t *devinfo;	/* assigned OSSseq device */
+	snd_use_lock_t use_lock;
+};
+
+
+/*
+ * midi device table
+ */
+static int max_midi_devs;
+static seq_oss_midi_t *midi_devs[SNDRV_SEQ_OSS_MAX_MIDI_DEVS];
+
+static DEFINE_SPINLOCK(register_lock);
+
+/*
+ * prototypes
+ */
+static seq_oss_midi_t *get_mdev(int dev);
+static seq_oss_midi_t *get_mididev(seq_oss_devinfo_t *dp, int dev);
+static int send_synth_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, int dev);
+static int send_midi_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, seq_oss_midi_t *mdev);
+
+/*
+ * look up the existing ports
+ * this looks a very exhausting job.
+ */
+int __init
+snd_seq_oss_midi_lookup_ports(int client)
+{
+	snd_seq_client_info_t *clinfo;
+	snd_seq_port_info_t *pinfo;
+
+	clinfo = kcalloc(1, sizeof(*clinfo), GFP_KERNEL);
+	pinfo = kcalloc(1, sizeof(*pinfo), GFP_KERNEL);
+	if (! clinfo || ! pinfo) {
+		kfree(clinfo);
+		kfree(pinfo);
+		return -ENOMEM;
+	}
+	clinfo->client = -1;
+	while (snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT, clinfo) == 0) {
+		if (clinfo->client == client)
+			continue; /* ignore myself */
+		pinfo->addr.client = clinfo->client;
+		pinfo->addr.port = -1;
+		while (snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT, pinfo) == 0)
+			snd_seq_oss_midi_check_new_port(pinfo);
+	}
+	kfree(clinfo);
+	kfree(pinfo);
+	return 0;
+}
+
+
+/*
+ */
+static seq_oss_midi_t *
+get_mdev(int dev)
+{
+	seq_oss_midi_t *mdev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&register_lock, flags);
+	mdev = midi_devs[dev];
+	if (mdev)
+		snd_use_lock_use(&mdev->use_lock);
+	spin_unlock_irqrestore(&register_lock, flags);
+	return mdev;
+}
+
+/*
+ * look for the identical slot
+ */
+static seq_oss_midi_t *
+find_slot(int client, int port)
+{
+	int i;
+	seq_oss_midi_t *mdev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&register_lock, flags);
+	for (i = 0; i < max_midi_devs; i++) {
+		mdev = midi_devs[i];
+		if (mdev && mdev->client == client && mdev->port == port) {
+			/* found! */
+			snd_use_lock_use(&mdev->use_lock);
+			spin_unlock_irqrestore(&register_lock, flags);
+			return mdev;
+		}
+	}
+	spin_unlock_irqrestore(&register_lock, flags);
+	return NULL;
+}
+
+
+#define PERM_WRITE (SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_SUBS_WRITE)
+#define PERM_READ (SNDRV_SEQ_PORT_CAP_READ|SNDRV_SEQ_PORT_CAP_SUBS_READ)
+/*
+ * register a new port if it doesn't exist yet
+ */
+int
+snd_seq_oss_midi_check_new_port(snd_seq_port_info_t *pinfo)
+{
+	int i;
+	seq_oss_midi_t *mdev;
+	unsigned long flags;
+
+	debug_printk(("check for MIDI client %d port %d\n", pinfo->addr.client, pinfo->addr.port));
+	/* the port must include generic midi */
+	if (! (pinfo->type & SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC))
+		return 0;
+	/* either read or write subscribable */
+	if ((pinfo->capability & PERM_WRITE) != PERM_WRITE &&
+	    (pinfo->capability & PERM_READ) != PERM_READ)
+		return 0;
+
+	/*
+	 * look for the identical slot
+	 */
+	if ((mdev = find_slot(pinfo->addr.client, pinfo->addr.port)) != NULL) {
+		/* already exists */
+		snd_use_lock_free(&mdev->use_lock);
+		return 0;
+	}
+
+	/*
+	 * allocate midi info record
+	 */
+	if ((mdev = kcalloc(1, sizeof(*mdev), GFP_KERNEL)) == NULL) {
+		snd_printk(KERN_ERR "can't malloc midi info\n");
+		return -ENOMEM;
+	}
+
+	/* copy the port information */
+	mdev->client = pinfo->addr.client;
+	mdev->port = pinfo->addr.port;
+	mdev->flags = pinfo->capability;
+	mdev->opened = 0;
+	snd_use_lock_init(&mdev->use_lock);
+
+	/* copy and truncate the name of synth device */
+	strlcpy(mdev->name, pinfo->name, sizeof(mdev->name));
+
+	/* create MIDI coder */
+	if (snd_midi_event_new(MAX_MIDI_EVENT_BUF, &mdev->coder) < 0) {
+		snd_printk(KERN_ERR "can't malloc midi coder\n");
+		kfree(mdev);
+		return -ENOMEM;
+	}
+	/* OSS sequencer adds running status to all sequences */
+	snd_midi_event_no_status(mdev->coder, 1);
+
+	/*
+	 * look for en empty slot
+	 */
+	spin_lock_irqsave(&register_lock, flags);
+	for (i = 0; i < max_midi_devs; i++) {
+		if (midi_devs[i] == NULL)
+			break;
+	}
+	if (i >= max_midi_devs) {
+		if (max_midi_devs >= SNDRV_SEQ_OSS_MAX_MIDI_DEVS) {
+			spin_unlock_irqrestore(&register_lock, flags);
+			snd_midi_event_free(mdev->coder);
+			kfree(mdev);
+			return -ENOMEM;
+		}
+		max_midi_devs++;
+	}
+	mdev->seq_device = i;
+	midi_devs[mdev->seq_device] = mdev;
+	spin_unlock_irqrestore(&register_lock, flags);
+
+	return 0;
+}
+
+/*
+ * release the midi device if it was registered
+ */
+int
+snd_seq_oss_midi_check_exit_port(int client, int port)
+{
+	seq_oss_midi_t *mdev;
+	unsigned long flags;
+	int index;
+
+	if ((mdev = find_slot(client, port)) != NULL) {
+		spin_lock_irqsave(&register_lock, flags);
+		midi_devs[mdev->seq_device] = NULL;
+		spin_unlock_irqrestore(&register_lock, flags);
+		snd_use_lock_free(&mdev->use_lock);
+		snd_use_lock_sync(&mdev->use_lock);
+		if (mdev->coder)
+			snd_midi_event_free(mdev->coder);
+		kfree(mdev);
+	}
+	spin_lock_irqsave(&register_lock, flags);
+	for (index = max_midi_devs - 1; index >= 0; index--) {
+		if (midi_devs[index])
+			break;
+	}
+	max_midi_devs = index + 1;
+	spin_unlock_irqrestore(&register_lock, flags);
+	return 0;
+}
+
+
+/*
+ * release the midi device if it was registered
+ */
+void
+snd_seq_oss_midi_clear_all(void)
+{
+	int i;
+	seq_oss_midi_t *mdev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&register_lock, flags);
+	for (i = 0; i < max_midi_devs; i++) {
+		if ((mdev = midi_devs[i]) != NULL) {
+			if (mdev->coder)
+				snd_midi_event_free(mdev->coder);
+			kfree(mdev);
+			midi_devs[i] = NULL;
+		}
+	}
+	max_midi_devs = 0;
+	spin_unlock_irqrestore(&register_lock, flags);
+}
+
+
+/*
+ * set up midi tables
+ */
+void
+snd_seq_oss_midi_setup(seq_oss_devinfo_t *dp)
+{
+	dp->max_mididev = max_midi_devs;
+}
+
+/*
+ * clean up midi tables
+ */
+void
+snd_seq_oss_midi_cleanup(seq_oss_devinfo_t *dp)
+{
+	int i;
+	for (i = 0; i < dp->max_mididev; i++)
+		snd_seq_oss_midi_close(dp, i);
+	dp->max_mididev = 0;
+}
+
+
+/*
+ * open all midi devices.  ignore errors.
+ */
+void
+snd_seq_oss_midi_open_all(seq_oss_devinfo_t *dp, int file_mode)
+{
+	int i;
+	for (i = 0; i < dp->max_mididev; i++)
+		snd_seq_oss_midi_open(dp, i, file_mode);
+}
+
+
+/*
+ * get the midi device information
+ */
+static seq_oss_midi_t *
+get_mididev(seq_oss_devinfo_t *dp, int dev)
+{
+	if (dev < 0 || dev >= dp->max_mididev)
+		return NULL;
+	return get_mdev(dev);
+}
+
+
+/*
+ * open the midi device if not opened yet
+ */
+int
+snd_seq_oss_midi_open(seq_oss_devinfo_t *dp, int dev, int fmode)
+{
+	int perm;
+	seq_oss_midi_t *mdev;
+	snd_seq_port_subscribe_t subs;
+
+	if ((mdev = get_mididev(dp, dev)) == NULL)
+		return -ENODEV;
+
+	/* already used? */
+	if (mdev->opened && mdev->devinfo != dp) {
+		snd_use_lock_free(&mdev->use_lock);
+		return -EBUSY;
+	}
+
+	perm = 0;
+	if (is_write_mode(fmode))
+		perm |= PERM_WRITE;
+	if (is_read_mode(fmode))
+		perm |= PERM_READ;
+	perm &= mdev->flags;
+	if (perm == 0) {
+		snd_use_lock_free(&mdev->use_lock);
+		return -ENXIO;
+	}
+
+	/* already opened? */
+	if ((mdev->opened & perm) == perm) {
+		snd_use_lock_free(&mdev->use_lock);
+		return 0;
+	}
+
+	perm &= ~mdev->opened;
+
+	memset(&subs, 0, sizeof(subs));
+
+	if (perm & PERM_WRITE) {
+		subs.sender = dp->addr;
+		subs.dest.client = mdev->client;
+		subs.dest.port = mdev->port;
+		if (snd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs) >= 0)
+			mdev->opened |= PERM_WRITE;
+	}
+	if (perm & PERM_READ) {
+		subs.sender.client = mdev->client;
+		subs.sender.port = mdev->port;
+		subs.dest = dp->addr;
+		subs.flags = SNDRV_SEQ_PORT_SUBS_TIMESTAMP;
+		subs.queue = dp->queue;		/* queue for timestamps */
+		if (snd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs) >= 0)
+			mdev->opened |= PERM_READ;
+	}
+
+	if (! mdev->opened) {
+		snd_use_lock_free(&mdev->use_lock);
+		return -ENXIO;
+	}
+
+	mdev->devinfo = dp;
+	snd_use_lock_free(&mdev->use_lock);
+	return 0;
+}
+
+/*
+ * close the midi device if already opened
+ */
+int
+snd_seq_oss_midi_close(seq_oss_devinfo_t *dp, int dev)
+{
+	seq_oss_midi_t *mdev;
+	snd_seq_port_subscribe_t subs;
+
+	if ((mdev = get_mididev(dp, dev)) == NULL)
+		return -ENODEV;
+	if (! mdev->opened || mdev->devinfo != dp) {
+		snd_use_lock_free(&mdev->use_lock);
+		return 0;
+	}
+
+	debug_printk(("closing client %d port %d mode %d\n", mdev->client, mdev->port, mdev->opened));
+	memset(&subs, 0, sizeof(subs));
+	if (mdev->opened & PERM_WRITE) {
+		subs.sender = dp->addr;
+		subs.dest.client = mdev->client;
+		subs.dest.port = mdev->port;
+		snd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, &subs);
+	}
+	if (mdev->opened & PERM_READ) {
+		subs.sender.client = mdev->client;
+		subs.sender.port = mdev->port;
+		subs.dest = dp->addr;
+		snd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, &subs);
+	}
+
+	mdev->opened = 0;
+	mdev->devinfo = NULL;
+
+	snd_use_lock_free(&mdev->use_lock);
+	return 0;
+}
+
+/*
+ * change seq capability flags to file mode flags
+ */
+int
+snd_seq_oss_midi_filemode(seq_oss_devinfo_t *dp, int dev)
+{
+	seq_oss_midi_t *mdev;
+	int mode;
+
+	if ((mdev = get_mididev(dp, dev)) == NULL)
+		return 0;
+
+	mode = 0;
+	if (mdev->opened & PERM_WRITE)
+		mode |= SNDRV_SEQ_OSS_FILE_WRITE;
+	if (mdev->opened & PERM_READ)
+		mode |= SNDRV_SEQ_OSS_FILE_READ;
+
+	snd_use_lock_free(&mdev->use_lock);
+	return mode;
+}
+
+/*
+ * reset the midi device and close it:
+ * so far, only close the device.
+ */
+void
+snd_seq_oss_midi_reset(seq_oss_devinfo_t *dp, int dev)
+{
+	seq_oss_midi_t *mdev;
+
+	if ((mdev = get_mididev(dp, dev)) == NULL)
+		return;
+	if (! mdev->opened) {
+		snd_use_lock_free(&mdev->use_lock);
+		return;
+	}
+
+	if (mdev->opened & PERM_WRITE) {
+		snd_seq_event_t ev;
+		int c;
+
+		debug_printk(("resetting client %d port %d\n", mdev->client, mdev->port));
+		memset(&ev, 0, sizeof(ev));
+		ev.dest.client = mdev->client;
+		ev.dest.port = mdev->port;
+		ev.queue = dp->queue;
+		ev.source.port = dp->port;
+		if (dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH) {
+			ev.type = SNDRV_SEQ_EVENT_SENSING;
+			snd_seq_oss_dispatch(dp, &ev, 0, 0); /* active sensing */
+		}
+		for (c = 0; c < 16; c++) {
+			ev.type = SNDRV_SEQ_EVENT_CONTROLLER;
+			ev.data.control.channel = c;
+			ev.data.control.param = 123;
+			snd_seq_oss_dispatch(dp, &ev, 0, 0); /* all notes off */
+			if (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC) {
+				ev.data.control.param = 121;
+				snd_seq_oss_dispatch(dp, &ev, 0, 0); /* reset all controllers */
+				ev.type = SNDRV_SEQ_EVENT_PITCHBEND;
+				ev.data.control.value = 0;
+				snd_seq_oss_dispatch(dp, &ev, 0, 0); /* bender off */
+			}
+		}
+	}
+	// snd_seq_oss_midi_close(dp, dev);
+	snd_use_lock_free(&mdev->use_lock);
+}
+
+
+/*
+ * get client/port of the specified MIDI device
+ */
+void
+snd_seq_oss_midi_get_addr(seq_oss_devinfo_t *dp, int dev, snd_seq_addr_t *addr)
+{
+	seq_oss_midi_t *mdev;
+
+	if ((mdev = get_mididev(dp, dev)) == NULL)
+		return;
+	addr->client = mdev->client;
+	addr->port = mdev->port;
+	snd_use_lock_free(&mdev->use_lock);
+}
+
+
+/*
+ * input callback - this can be atomic
+ */
+int
+snd_seq_oss_midi_input(snd_seq_event_t *ev, int direct, void *private_data)
+{
+	seq_oss_devinfo_t *dp = (seq_oss_devinfo_t *)private_data;
+	seq_oss_midi_t *mdev;
+	int rc;
+
+	if (dp->readq == NULL)
+		return 0;
+	if ((mdev = find_slot(ev->source.client, ev->source.port)) == NULL)
+		return 0;
+	if (! (mdev->opened & PERM_READ)) {
+		snd_use_lock_free(&mdev->use_lock);
+		return 0;
+	}
+
+	if (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC)
+		rc = send_synth_event(dp, ev, mdev->seq_device);
+	else
+		rc = send_midi_event(dp, ev, mdev);
+
+	snd_use_lock_free(&mdev->use_lock);
+	return rc;
+}
+
+/*
+ * convert ALSA sequencer event to OSS synth event
+ */
+static int
+send_synth_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, int dev)
+{
+	evrec_t ossev;
+
+	memset(&ossev, 0, sizeof(ossev));
+
+	switch (ev->type) {
+	case SNDRV_SEQ_EVENT_NOTEON:
+		ossev.v.cmd = MIDI_NOTEON; break;
+	case SNDRV_SEQ_EVENT_NOTEOFF:
+		ossev.v.cmd = MIDI_NOTEOFF; break;
+	case SNDRV_SEQ_EVENT_KEYPRESS:
+		ossev.v.cmd = MIDI_KEY_PRESSURE; break;
+	case SNDRV_SEQ_EVENT_CONTROLLER:
+		ossev.l.cmd = MIDI_CTL_CHANGE; break;
+	case SNDRV_SEQ_EVENT_PGMCHANGE:
+		ossev.l.cmd = MIDI_PGM_CHANGE; break;
+	case SNDRV_SEQ_EVENT_CHANPRESS:
+		ossev.l.cmd = MIDI_CHN_PRESSURE; break;
+	case SNDRV_SEQ_EVENT_PITCHBEND:
+		ossev.l.cmd = MIDI_PITCH_BEND; break;
+	default:
+		return 0; /* not supported */
+	}
+
+	ossev.v.dev = dev;
+
+	switch (ev->type) {
+	case SNDRV_SEQ_EVENT_NOTEON:
+	case SNDRV_SEQ_EVENT_NOTEOFF:
+	case SNDRV_SEQ_EVENT_KEYPRESS:
+		ossev.v.code = EV_CHN_VOICE;
+		ossev.v.note = ev->data.note.note;
+		ossev.v.parm = ev->data.note.velocity;
+		ossev.v.chn = ev->data.note.channel;
+		break;
+	case SNDRV_SEQ_EVENT_CONTROLLER:
+	case SNDRV_SEQ_EVENT_PGMCHANGE:
+	case SNDRV_SEQ_EVENT_CHANPRESS:
+		ossev.l.code = EV_CHN_COMMON;
+		ossev.l.p1 = ev->data.control.param;
+		ossev.l.val = ev->data.control.value;
+		ossev.l.chn = ev->data.control.channel;
+		break;
+	case SNDRV_SEQ_EVENT_PITCHBEND:
+		ossev.l.code = EV_CHN_COMMON;
+		ossev.l.val = ev->data.control.value + 8192;
+		ossev.l.chn = ev->data.control.channel;
+		break;
+	}
+	
+	snd_seq_oss_readq_put_timestamp(dp->readq, ev->time.tick, dp->seq_mode);
+	snd_seq_oss_readq_put_event(dp->readq, &ossev);
+
+	return 0;
+}
+
+/*
+ * decode event and send MIDI bytes to read queue
+ */
+static int
+send_midi_event(seq_oss_devinfo_t *dp, snd_seq_event_t *ev, seq_oss_midi_t *mdev)
+{
+	char msg[32];
+	int len;
+	
+	snd_seq_oss_readq_put_timestamp(dp->readq, ev->time.tick, dp->seq_mode);
+	if (!dp->timer->running)
+		len = snd_seq_oss_timer_start(dp->timer);
+	if (ev->type == SNDRV_SEQ_EVENT_SYSEX) {
+		if ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) == SNDRV_SEQ_EVENT_LENGTH_VARIABLE)
+			snd_seq_oss_readq_puts(dp->readq, mdev->seq_device,
+					       ev->data.ext.ptr, ev->data.ext.len);
+	} else {
+		len = snd_midi_event_decode(mdev->coder, msg, sizeof(msg), ev);
+		if (len > 0)
+			snd_seq_oss_readq_puts(dp->readq, mdev->seq_device, msg, len);
+	}
+
+	return 0;
+}
+
+
+/*
+ * dump midi data
+ * return 0 : enqueued
+ *        non-zero : invalid - ignored
+ */
+int
+snd_seq_oss_midi_putc(seq_oss_devinfo_t *dp, int dev, unsigned char c, snd_seq_event_t *ev)
+{
+	seq_oss_midi_t *mdev;
+
+	if ((mdev = get_mididev(dp, dev)) == NULL)
+		return -ENODEV;
+	if (snd_midi_event_encode_byte(mdev->coder, c, ev) > 0) {
+		snd_seq_oss_fill_addr(dp, ev, mdev->client, mdev->port);
+		snd_use_lock_free(&mdev->use_lock);
+		return 0;
+	}
+	snd_use_lock_free(&mdev->use_lock);
+	return -EINVAL;
+}
+
+/*
+ * create OSS compatible midi_info record
+ */
+int
+snd_seq_oss_midi_make_info(seq_oss_devinfo_t *dp, int dev, struct midi_info *inf)
+{
+	seq_oss_midi_t *mdev;
+
+	if ((mdev = get_mididev(dp, dev)) == NULL)
+		return -ENXIO;
+	inf->device = dev;
+	inf->dev_type = 0; /* FIXME: ?? */
+	inf->capabilities = 0; /* FIXME: ?? */
+	strlcpy(inf->name, mdev->name, sizeof(inf->name));
+	snd_use_lock_free(&mdev->use_lock);
+	return 0;
+}
+
+
+/*
+ * proc interface
+ */
+static char *
+capmode_str(int val)
+{
+	val &= PERM_READ|PERM_WRITE;
+	if (val == (PERM_READ|PERM_WRITE))
+		return "read/write";
+	else if (val == PERM_READ)
+		return "read";
+	else if (val == PERM_WRITE)
+		return "write";
+	else
+		return "none";
+}
+
+void
+snd_seq_oss_midi_info_read(snd_info_buffer_t *buf)
+{
+	int i;
+	seq_oss_midi_t *mdev;
+
+	snd_iprintf(buf, "\nNumber of MIDI devices: %d\n", max_midi_devs);
+	for (i = 0; i < max_midi_devs; i++) {
+		snd_iprintf(buf, "\nmidi %d: ", i);
+		mdev = get_mdev(i);
+		if (mdev == NULL) {
+			snd_iprintf(buf, "*empty*\n");
+			continue;
+		}
+		snd_iprintf(buf, "[%s] ALSA port %d:%d\n", mdev->name,
+			    mdev->client, mdev->port);
+		snd_iprintf(buf, "  capability %s / opened %s\n",
+			    capmode_str(mdev->flags),
+			    capmode_str(mdev->opened));
+		snd_use_lock_free(&mdev->use_lock);
+	}
+}
+
