commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index c93945917235..11554d0412f0 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * OSS compatible sequencer driver
  *
  * synth device handlers
  *
  * Copyright (C) 1998,99 Takashi Iwai <tiwai@suse.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include "seq_oss_synth.h"

commit c709f14f0616482b67f9fbcb965e1493a03ff30b
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Mar 20 18:42:01 2019 -0500

    ALSA: seq: oss: Fix Spectre v1 vulnerability
    
    dev is indirectly controlled by user-space, hence leading to
    a potential exploitation of the Spectre variant 1 vulnerability.
    
    This issue was detected with the help of Smatch:
    
    sound/core/seq/oss/seq_oss_synth.c:626 snd_seq_oss_synth_make_info() warn: potential spectre issue 'dp->synths' [w] (local cap)
    
    Fix this by sanitizing dev before using it to index dp->synths.
    
    Notice that given that speculation windows are large, the policy is
    to kill the speculation on the first load and not worry if it can be
    completed with a dependent load/store [1].
    
    [1] https://lore.kernel.org/lkml/20180423164740.GY17484@dhcp22.suse.cz/
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 278ebb993122..c93945917235 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -617,13 +617,14 @@ int
 snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)
 {
 	struct seq_oss_synth *rec;
+	struct seq_oss_synthinfo *info = get_synthinfo_nospec(dp, dev);
 
-	if (dev < 0 || dev >= dp->max_synthdev)
+	if (!info)
 		return -ENXIO;
 
-	if (dp->synths[dev].is_midi) {
+	if (info->is_midi) {
 		struct midi_info minf;
-		snd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);
+		snd_seq_oss_midi_make_info(dp, info->midi_mapped, &minf);
 		inf->synth_type = SYNTH_TYPE_MIDI;
 		inf->synth_subtype = 0;
 		inf->nr_voices = 16;

commit 8d218dd8116695ecda7164f97631c069938aa22e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 07:31:54 2018 +0200

    ALSA: seq: oss: Hardening for potential Spectre v1
    
    As Smatch recently suggested, a few places in OSS sequencer codes may
    expand the array directly from the user-space value with speculation,
    namely there are a significant amount of references to either
    info->ch[] or dp->synths[] array:
    
      sound/core/seq/oss/seq_oss_event.c:315 note_on_event() warn: potential spectre issue 'info->ch' (local cap)
      sound/core/seq/oss/seq_oss_event.c:362 note_off_event() warn: potential spectre issue 'info->ch' (local cap)
      sound/core/seq/oss/seq_oss_synth.c:470 snd_seq_oss_synth_load_patch() warn: potential spectre issue 'dp->synths' (local cap)
      sound/core/seq/oss/seq_oss_event.c:293 note_on_event() warn: potential spectre issue 'dp->synths'
      sound/core/seq/oss/seq_oss_event.c:353 note_off_event() warn: potential spectre issue 'dp->synths'
      sound/core/seq/oss/seq_oss_synth.c:506 snd_seq_oss_synth_sysex() warn: potential spectre issue 'dp->synths'
      sound/core/seq/oss/seq_oss_synth.c:580 snd_seq_oss_synth_ioctl() warn: potential spectre issue 'dp->synths'
    
    Although all these seem doing only the first load without further
    reference, we may want to stay in a safer side, so hardening with
    array_index_nospec() would still make sense.
    
    We may put array_index_nospec() at each place, but here we take a
    different approach:
    
    - For dp->synths[], change the helpers to retrieve seq_oss_synthinfo
      pointer directly instead of the array expansion at each place
    
    - For info->ch[], harden in a normal way, as there are only a couple
      of places
    
    As a result, the existing helper, snd_seq_oss_synth_is_valid() is
    replaced with snd_seq_oss_synth_info().  Also, we cover MIDI device
    where a similar array expansion is done, too, although it wasn't
    reported by Smatch.
    
    BugLink: https://marc.info/?l=linux-kernel&m=152411496503418&w=2
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 9e2b250ae780..278ebb993122 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -26,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/nospec.h>
 
 /*
  * constants
@@ -339,17 +340,13 @@ snd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)
 	dp->max_synthdev = 0;
 }
 
-/*
- * check if the specified device is MIDI mapped device
- */
-static int
-is_midi_dev(struct seq_oss_devinfo *dp, int dev)
+static struct seq_oss_synthinfo *
+get_synthinfo_nospec(struct seq_oss_devinfo *dp, int dev)
 {
 	if (dev < 0 || dev >= dp->max_synthdev)
-		return 0;
-	if (dp->synths[dev].is_midi)
-		return 1;
-	return 0;
+		return NULL;
+	dev = array_index_nospec(dev, SNDRV_SEQ_OSS_MAX_SYNTH_DEVS);
+	return &dp->synths[dev];
 }
 
 /*
@@ -359,11 +356,13 @@ static struct seq_oss_synth *
 get_synthdev(struct seq_oss_devinfo *dp, int dev)
 {
 	struct seq_oss_synth *rec;
-	if (dev < 0 || dev >= dp->max_synthdev)
+	struct seq_oss_synthinfo *info = get_synthinfo_nospec(dp, dev);
+
+	if (!info)
 		return NULL;
-	if (! dp->synths[dev].opened)
+	if (!info->opened)
 		return NULL;
-	if (dp->synths[dev].is_midi) {
+	if (info->is_midi) {
 		rec = &midi_synth_dev;
 		snd_use_lock_use(&rec->use_lock);
 	} else {
@@ -406,10 +405,8 @@ snd_seq_oss_synth_reset(struct seq_oss_devinfo *dp, int dev)
 	struct seq_oss_synth *rec;
 	struct seq_oss_synthinfo *info;
 
-	if (snd_BUG_ON(dev < 0 || dev >= dp->max_synthdev))
-		return;
-	info = &dp->synths[dev];
-	if (! info->opened)
+	info = get_synthinfo_nospec(dp, dev);
+	if (!info || !info->opened)
 		return;
 	if (info->sysex)
 		info->sysex->len = 0; /* reset sysex */
@@ -458,12 +455,14 @@ snd_seq_oss_synth_load_patch(struct seq_oss_devinfo *dp, int dev, int fmt,
 			    const char __user *buf, int p, int c)
 {
 	struct seq_oss_synth *rec;
+	struct seq_oss_synthinfo *info;
 	int rc;
 
-	if (dev < 0 || dev >= dp->max_synthdev)
+	info = get_synthinfo_nospec(dp, dev);
+	if (!info)
 		return -ENXIO;
 
-	if (is_midi_dev(dp, dev))
+	if (info->is_midi)
 		return 0;
 	if ((rec = get_synthdev(dp, dev)) == NULL)
 		return -ENXIO;
@@ -471,24 +470,25 @@ snd_seq_oss_synth_load_patch(struct seq_oss_devinfo *dp, int dev, int fmt,
 	if (rec->oper.load_patch == NULL)
 		rc = -ENXIO;
 	else
-		rc = rec->oper.load_patch(&dp->synths[dev].arg, fmt, buf, p, c);
+		rc = rec->oper.load_patch(&info->arg, fmt, buf, p, c);
 	snd_use_lock_free(&rec->use_lock);
 	return rc;
 }
 
 /*
- * check if the device is valid synth device
+ * check if the device is valid synth device and return the synth info
  */
-int
-snd_seq_oss_synth_is_valid(struct seq_oss_devinfo *dp, int dev)
+struct seq_oss_synthinfo *
+snd_seq_oss_synth_info(struct seq_oss_devinfo *dp, int dev)
 {
 	struct seq_oss_synth *rec;
+
 	rec = get_synthdev(dp, dev);
 	if (rec) {
 		snd_use_lock_free(&rec->use_lock);
-		return 1;
+		return get_synthinfo_nospec(dp, dev);
 	}
-	return 0;
+	return NULL;
 }
 
 
@@ -503,16 +503,18 @@ snd_seq_oss_synth_sysex(struct seq_oss_devinfo *dp, int dev, unsigned char *buf,
 	int i, send;
 	unsigned char *dest;
 	struct seq_oss_synth_sysex *sysex;
+	struct seq_oss_synthinfo *info;
 
-	if (! snd_seq_oss_synth_is_valid(dp, dev))
+	info = snd_seq_oss_synth_info(dp, dev);
+	if (!info)
 		return -ENXIO;
 
-	sysex = dp->synths[dev].sysex;
+	sysex = info->sysex;
 	if (sysex == NULL) {
 		sysex = kzalloc(sizeof(*sysex), GFP_KERNEL);
 		if (sysex == NULL)
 			return -ENOMEM;
-		dp->synths[dev].sysex = sysex;
+		info->sysex = sysex;
 	}
 
 	send = 0;
@@ -557,10 +559,12 @@ snd_seq_oss_synth_sysex(struct seq_oss_devinfo *dp, int dev, unsigned char *buf,
 int
 snd_seq_oss_synth_addr(struct seq_oss_devinfo *dp, int dev, struct snd_seq_event *ev)
 {
-	if (! snd_seq_oss_synth_is_valid(dp, dev))
+	struct seq_oss_synthinfo *info = snd_seq_oss_synth_info(dp, dev);
+
+	if (!info)
 		return -EINVAL;
-	snd_seq_oss_fill_addr(dp, ev, dp->synths[dev].arg.addr.client,
-			      dp->synths[dev].arg.addr.port);
+	snd_seq_oss_fill_addr(dp, ev, info->arg.addr.client,
+			      info->arg.addr.port);
 	return 0;
 }
 
@@ -572,16 +576,18 @@ int
 snd_seq_oss_synth_ioctl(struct seq_oss_devinfo *dp, int dev, unsigned int cmd, unsigned long addr)
 {
 	struct seq_oss_synth *rec;
+	struct seq_oss_synthinfo *info;
 	int rc;
 
-	if (is_midi_dev(dp, dev))
+	info = get_synthinfo_nospec(dp, dev);
+	if (!info || info->is_midi)
 		return -ENXIO;
 	if ((rec = get_synthdev(dp, dev)) == NULL)
 		return -ENXIO;
 	if (rec->oper.ioctl == NULL)
 		rc = -ENXIO;
 	else
-		rc = rec->oper.ioctl(&dp->synths[dev].arg, cmd, addr);
+		rc = rec->oper.ioctl(&info->arg, cmd, addr);
 	snd_use_lock_free(&rec->use_lock);
 	return rc;
 }
@@ -593,7 +599,10 @@ snd_seq_oss_synth_ioctl(struct seq_oss_devinfo *dp, int dev, unsigned int cmd, u
 int
 snd_seq_oss_synth_raw_event(struct seq_oss_devinfo *dp, int dev, unsigned char *data, struct snd_seq_event *ev)
 {
-	if (! snd_seq_oss_synth_is_valid(dp, dev) || is_midi_dev(dp, dev))
+	struct seq_oss_synthinfo *info;
+
+	info = snd_seq_oss_synth_info(dp, dev);
+	if (!info || info->is_midi)
 		return -ENXIO;
 	ev->type = SNDRV_SEQ_EVENT_OSS;
 	memcpy(ev->data.raw8.d, data, 8);

commit f5e94b4c6ebdabe0f602d796e0430180927521a0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 07:26:59 2018 +0200

    ALSA: seq: oss: Fix unbalanced use lock for synth MIDI device
    
    When get_synthdev() is called for a MIDI device, it returns the fixed
    midi_synth_dev without the use refcounting.  OTOH, the caller is
    supposed to unreference unconditionally after the usage, so this would
    lead to unbalanced refcount.
    
    This patch corrects the behavior and keep up the refcount balance also
    for the MIDI synth device.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index cd0e0ebbfdb1..9e2b250ae780 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -363,10 +363,14 @@ get_synthdev(struct seq_oss_devinfo *dp, int dev)
 		return NULL;
 	if (! dp->synths[dev].opened)
 		return NULL;
-	if (dp->synths[dev].is_midi)
-		return &midi_synth_dev;
-	if ((rec = get_sdev(dev)) == NULL)
-		return NULL;
+	if (dp->synths[dev].is_midi) {
+		rec = &midi_synth_dev;
+		snd_use_lock_use(&rec->use_lock);
+	} else {
+		rec = get_sdev(dev);
+		if (!rec)
+			return NULL;
+	}
 	if (! rec->opened) {
 		snd_use_lock_free(&rec->use_lock);
 		return NULL;

commit 76f64b24e692978a90d3c2e8f57f3a1f0cd7172a
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Wed Jun 15 13:33:31 2016 +0530

    ALSA: seq_oss: Change structure initialisation to C99 style
    
    Replace the in order struct initialisation style with explicit field
    style.
    
    The Coccinelle semantic patch used to make this change is as follows:
    
    @decl@
    identifier i1,fld;
    type T;
    field list[n] fs;
    @@
    
    struct i1 {
     fs
     T fld;
     ...};
    
    @@
    identifier decl.i1,i2,decl.fld;
    expression e;
    position bad.p, bad.fix;
    @@
    
    struct i1 i2@p = { ...,
    + .fld = e
    - e@fix
     ,...};
    
    Also, removed some unnecessary comments.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index b16dbef04174..cd0e0ebbfdb1 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -70,11 +70,11 @@ struct seq_oss_synth {
 static int max_synth_devs;
 static struct seq_oss_synth *synth_devs[SNDRV_SEQ_OSS_MAX_SYNTH_DEVS];
 static struct seq_oss_synth midi_synth_dev = {
-	-1, /* seq_device */
-	SYNTH_TYPE_MIDI, /* synth_type */
-	0, /* synth_subtype */
-	16, /* nr_voices */
-	"MIDI", /* name */
+	.seq_device = -1,
+	.synth_type = SYNTH_TYPE_MIDI,
+	.synth_subtype = 0,
+	.nr_voices = 16,
+	.name = "MIDI",
 };
 
 static DEFINE_SPINLOCK(register_lock);

commit 599151336638d57b98d92338aa59c048e3a3e97d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 25 11:01:47 2016 +0100

    ALSA: seq: Fix incorrect sanity check at snd_seq_oss_synth_cleanup()
    
    ALSA sequencer OSS emulation code has a sanity check for currently
    opened devices, but there is a thinko there, eventually it spews
    warnings and skips the operation wrongly like:
      WARNING: CPU: 1 PID: 7573 at sound/core/seq/oss/seq_oss_synth.c:311
    
    Fix this off-by-one error.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 0f3b38184fe5..b16dbef04174 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -308,7 +308,7 @@ snd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)
 	struct seq_oss_synth *rec;
 	struct seq_oss_synthinfo *info;
 
-	if (snd_BUG_ON(dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))
+	if (snd_BUG_ON(dp->max_synthdev > SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))
 		return;
 	for (i = 0; i < dp->max_synthdev; i++) {
 		info = &dp->synths[i];

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 48e4fe1b68ab..0f3b38184fe5 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -630,7 +630,7 @@ snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_in
 }
 
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /*
  * proc interface
  */
@@ -658,4 +658,4 @@ snd_seq_oss_synth_info_read(struct snd_info_buffer *buf)
 		snd_use_lock_free(&rec->use_lock);
 	}
 }
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */

commit 8d98a0673f761f9b7be51a293ca9142ec0c037ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:39:55 2015 +0100

    ALSA: seq_oss: Drop superfluous error/debug messages after malloc failures
    
    The kernel memory allocators already report the errors when the
    requested allocation fails, thus we don't need to warn it again in
    each caller side.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 835edc80f918..48e4fe1b68ab 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -106,10 +106,9 @@ snd_seq_oss_synth_probe(struct device *_dev)
 	struct snd_seq_oss_reg *reg = SNDRV_SEQ_DEVICE_ARGPTR(dev);
 	unsigned long flags;
 
-	if ((rec = kzalloc(sizeof(*rec), GFP_KERNEL)) == NULL) {
-		pr_err("ALSA: seq_oss: can't malloc synth info\n");
+	rec = kzalloc(sizeof(*rec), GFP_KERNEL);
+	if (!rec)
 		return -ENOMEM;
-	}
 	rec->seq_device = -1;
 	rec->synth_type = reg->type;
 	rec->synth_subtype = reg->subtype;
@@ -249,7 +248,6 @@ snd_seq_oss_synth_setup(struct seq_oss_devinfo *dp)
 		if (info->nr_voices > 0) {
 			info->ch = kcalloc(info->nr_voices, sizeof(struct seq_oss_chinfo), GFP_KERNEL);
 			if (!info->ch) {
-				pr_err("ALSA: seq_oss: Cannot malloc voices\n");
 				rec->oper.close(&info->arg);
 				module_put(rec->oper.owner);
 				snd_use_lock_free(&rec->use_lock);

commit 056622053b8ae02978678ac1321b5bd956e7c812
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 12 13:43:22 2015 +0100

    ALSA: seq: Define driver object in each driver
    
    This patch moves the driver object initialization and allocation to
    each driver's module init/exit code like other normal drivers.  The
    snd_seq_driver struct is now published in seq_device.h, and each
    driver is responsible to define it with proper driver attributes
    (name, probe and remove) with snd_seq_driver specific attributes as id
    and argsize fields.  The helper functions snd_seq_driver_register(),
    snd_seq_driver_unregister() and module_snd_seq_driver() are used for
    simplifying codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 701feb71b700..835edc80f918 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -98,8 +98,9 @@ snd_seq_oss_synth_init(void)
  * registration of the synth device
  */
 int
-snd_seq_oss_synth_register(struct snd_seq_device *dev)
+snd_seq_oss_synth_probe(struct device *_dev)
 {
+	struct snd_seq_device *dev = to_seq_dev(_dev);
 	int i;
 	struct seq_oss_synth *rec;
 	struct snd_seq_oss_reg *reg = SNDRV_SEQ_DEVICE_ARGPTR(dev);
@@ -149,8 +150,9 @@ snd_seq_oss_synth_register(struct snd_seq_device *dev)
 
 
 int
-snd_seq_oss_synth_unregister(struct snd_seq_device *dev)
+snd_seq_oss_synth_remove(struct device *_dev)
 {
+	struct snd_seq_device *dev = to_seq_dev(_dev);
 	int index;
 	struct seq_oss_synth *rec = dev->driver_data;
 	unsigned long flags;

commit bb343e7969cb8a4b6b20bddc97098c87f4fae2b5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:24:04 2014 +0100

    ALSA: seq_oss: Use standard printk helpers
    
    Use the standard pr_xxx() helpers instead of home-baked snd_print*().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 7333bfe827a7..701feb71b700 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -106,7 +106,7 @@ snd_seq_oss_synth_register(struct snd_seq_device *dev)
 	unsigned long flags;
 
 	if ((rec = kzalloc(sizeof(*rec), GFP_KERNEL)) == NULL) {
-		snd_printk(KERN_ERR "can't malloc synth info\n");
+		pr_err("ALSA: seq_oss: can't malloc synth info\n");
 		return -ENOMEM;
 	}
 	rec->seq_device = -1;
@@ -130,7 +130,7 @@ snd_seq_oss_synth_register(struct snd_seq_device *dev)
 	if (i >= max_synth_devs) {
 		if (max_synth_devs >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS) {
 			spin_unlock_irqrestore(&register_lock, flags);
-			snd_printk(KERN_ERR "no more synth slot\n");
+			pr_err("ALSA: seq_oss: no more synth slot\n");
 			kfree(rec);
 			return -ENOMEM;
 		}
@@ -162,7 +162,7 @@ snd_seq_oss_synth_unregister(struct snd_seq_device *dev)
 	}
 	if (index >= max_synth_devs) {
 		spin_unlock_irqrestore(&register_lock, flags);
-		snd_printk(KERN_ERR "can't unregister synth\n");
+		pr_err("ALSA: seq_oss: can't unregister synth\n");
 		return -EINVAL;
 	}
 	synth_devs[index] = NULL;
@@ -247,7 +247,7 @@ snd_seq_oss_synth_setup(struct seq_oss_devinfo *dp)
 		if (info->nr_voices > 0) {
 			info->ch = kcalloc(info->nr_voices, sizeof(struct seq_oss_chinfo), GFP_KERNEL);
 			if (!info->ch) {
-				snd_printk(KERN_ERR "Cannot malloc\n");
+				pr_err("ALSA: seq_oss: Cannot malloc voices\n");
 				rec->oper.close(&info->arg);
 				module_put(rec->oper.owner);
 				snd_use_lock_free(&rec->use_lock);

commit a67ca25b6cc6d2f3f24aebf1c83af3db28b5e304
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:04:49 2014 +0100

    ALSA: seq_oss: Drop debug prints
    
    The debug prints in snd-seq-oss module are rather useless.
    Let's clean up before further modifications.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index c5b773a1eea9..7333bfe827a7 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -138,7 +138,6 @@ snd_seq_oss_synth_register(struct snd_seq_device *dev)
 	}
 	rec->seq_device = i;
 	synth_devs[i] = rec;
-	debug_printk(("synth %s registered %d\n", rec->name, i));
 	spin_unlock_irqrestore(&register_lock, flags);
 	dev->driver_data = rec;
 #ifdef SNDRV_OSS_INFO_DEV_SYNTH
@@ -256,7 +255,6 @@ snd_seq_oss_synth_setup(struct seq_oss_devinfo *dp)
 			}
 			reset_channels(info);
 		}
-		debug_printk(("synth %d assigned\n", i));
 		info->opened++;
 		rec->opened++;
 		dp->synth_opened++;
@@ -326,7 +324,6 @@ snd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)
 			if (rec == NULL)
 				continue;
 			if (rec->opened > 0) {
-				debug_printk(("synth %d closed\n", i));
 				rec->oper.close(&info->arg);
 				module_put(rec->oper.owner);
 				rec->opened = 0;

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index ee44ab9593c0..c5b773a1eea9 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -24,6 +24,7 @@
 #include "seq_oss_midi.h"
 #include "../seq_lock.h"
 #include <linux/init.h>
+#include <linux/module.h>
 #include <linux/slab.h>
 
 /*

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 945a27c34a9d..ee44ab9593c0 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -24,6 +24,7 @@
 #include "seq_oss_midi.h"
 #include "../seq_lock.h"
 #include <linux/init.h>
+#include <linux/slab.h>
 
 /*
  * constants

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index e024e4588b82..945a27c34a9d 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -308,7 +308,8 @@ snd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)
 	struct seq_oss_synth *rec;
 	struct seq_oss_synthinfo *info;
 
-	snd_assert(dp->max_synthdev <= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS, return);
+	if (snd_BUG_ON(dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))
+		return;
 	for (i = 0; i < dp->max_synthdev; i++) {
 		info = &dp->synths[i];
 		if (! info->opened)
@@ -402,7 +403,8 @@ snd_seq_oss_synth_reset(struct seq_oss_devinfo *dp, int dev)
 	struct seq_oss_synth *rec;
 	struct seq_oss_synthinfo *info;
 
-	snd_assert(dev >= 0 && dev < dp->max_synthdev, return);
+	if (snd_BUG_ON(dev < 0 || dev >= dp->max_synthdev))
+		return;
 	info = &dp->synths[dev];
 	if (! info->opened)
 		return;

commit 82e68f7ffec3800425f2391c8c86277606860442
Author: Willy Tarreau <w@1wt.eu>
Date:   Sat Aug 2 18:25:16 2008 +0200

    sound: ensure device number is valid in snd_seq_oss_synth_make_info
    
    snd_seq_oss_synth_make_info() incorrectly reports information
    to userspace without first checking for the validity of the
    device number, leading to possible information leak (CVE-2008-3272).
    
    Reported-By: Tobias Klein <tk@trapkit.de>
    Acked-and-tested-by: Takashi Iwai <tiwai@suse.de>
    Cc: stable@kernel.org
    Signed-off-by: Willy Tarreau <w@1wt.eu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 558dadbf45f1..e024e4588b82 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -604,6 +604,9 @@ snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_in
 {
 	struct seq_oss_synth *rec;
 
+	if (dev < 0 || dev >= dp->max_synthdev)
+		return -ENXIO;
+
 	if (dp->synths[dev].is_midi) {
 		struct midi_info minf;
 		snd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);

commit c354cd7d9627930dcfbcff8355d422fa1bca948a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 21 12:40:00 2008 +0100

    [ALSA] seq-oss - Remove invalid BUG()
    
    Removed invalid BUG() - the driver should handle the error case properly
    rather than issuing BUG().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index ab570a0a6183..558dadbf45f1 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -245,8 +245,13 @@ snd_seq_oss_synth_setup(struct seq_oss_devinfo *dp)
 		info->nr_voices = rec->nr_voices;
 		if (info->nr_voices > 0) {
 			info->ch = kcalloc(info->nr_voices, sizeof(struct seq_oss_chinfo), GFP_KERNEL);
-			if (!info->ch)
-				BUG();
+			if (!info->ch) {
+				snd_printk(KERN_ERR "Cannot malloc\n");
+				rec->oper.close(&info->arg);
+				module_put(rec->oper.owner);
+				snd_use_lock_free(&rec->use_lock);
+				continue;
+			}
 			reset_channels(info);
 		}
 		debug_printk(("synth %d assigned\n", i));

commit 04f141a8800d022981f0405a8d307c98aba55105
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:43:51 2005 +0100

    [ALSA] Optimize for config without PROC_FS (seq and oss parts)
    
    Modules: ALSA<-OSS emulation,ALSA sequencer,ALSA<-OSS sequencer
    
    Optimize the code when compiled without CONFIG_PROC_FS (in seq and oss
    emulation parts).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 0b6025c92b9e..ab570a0a6183 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -621,6 +621,7 @@ snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_in
 }
 
 
+#ifdef CONFIG_PROC_FS
 /*
  * proc interface
  */
@@ -648,4 +649,4 @@ snd_seq_oss_synth_info_read(struct snd_info_buffer *buf)
 		snd_use_lock_free(&rec->use_lock);
 	}
 }
-
+#endif /* CONFIG_PROC_FS */

commit 080dece3460b534bedc4ef4ba3abaa57e9486331
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:05:16 2005 +0100

    [ALSA] Remove xxx_t typedefs: Sequencer OSS-emulation
    
    Modules: ALSA<-OSS sequencer,ALSA sequencer
    
    Remove xxx_t typedefs from the core sequencer OSS-emulation codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 8257fce2ca1b..0b6025c92b9e 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -37,14 +37,14 @@
  */
 
 /* sysex buffer */
-struct seq_oss_synth_sysex_t {
+struct seq_oss_synth_sysex {
 	int len;
 	int skip;
 	unsigned char buf[MAX_SYSEX_BUFLEN];
 };
 
 /* synth info */
-struct seq_oss_synth_t {
+struct seq_oss_synth {
 	int seq_device;
 
 	/* for synth_info */
@@ -53,7 +53,7 @@ struct seq_oss_synth_t {
 	int nr_voices;
 
 	char name[SNDRV_SEQ_OSS_MAX_SYNTH_NAME];
-	snd_seq_oss_callback_t oper;
+	struct snd_seq_oss_callback oper;
 
 	int opened;
 
@@ -66,8 +66,8 @@ struct seq_oss_synth_t {
  * device table
  */
 static int max_synth_devs;
-static seq_oss_synth_t *synth_devs[SNDRV_SEQ_OSS_MAX_SYNTH_DEVS];
-static seq_oss_synth_t midi_synth_dev = {
+static struct seq_oss_synth *synth_devs[SNDRV_SEQ_OSS_MAX_SYNTH_DEVS];
+static struct seq_oss_synth midi_synth_dev = {
 	-1, /* seq_device */
 	SYNTH_TYPE_MIDI, /* synth_type */
 	0, /* synth_subtype */
@@ -80,8 +80,8 @@ static DEFINE_SPINLOCK(register_lock);
 /*
  * prototypes
  */
-static seq_oss_synth_t *get_synthdev(seq_oss_devinfo_t *dp, int dev);
-static void reset_channels(seq_oss_synthinfo_t *info);
+static struct seq_oss_synth *get_synthdev(struct seq_oss_devinfo *dp, int dev);
+static void reset_channels(struct seq_oss_synthinfo *info);
 
 /*
  * global initialization
@@ -96,11 +96,11 @@ snd_seq_oss_synth_init(void)
  * registration of the synth device
  */
 int
-snd_seq_oss_synth_register(snd_seq_device_t *dev)
+snd_seq_oss_synth_register(struct snd_seq_device *dev)
 {
 	int i;
-	seq_oss_synth_t *rec;
-	snd_seq_oss_reg_t *reg = SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	struct seq_oss_synth *rec;
+	struct snd_seq_oss_reg *reg = SNDRV_SEQ_DEVICE_ARGPTR(dev);
 	unsigned long flags;
 
 	if ((rec = kzalloc(sizeof(*rec), GFP_KERNEL)) == NULL) {
@@ -148,10 +148,10 @@ snd_seq_oss_synth_register(snd_seq_device_t *dev)
 
 
 int
-snd_seq_oss_synth_unregister(snd_seq_device_t *dev)
+snd_seq_oss_synth_unregister(struct snd_seq_device *dev)
 {
 	int index;
-	seq_oss_synth_t *rec = dev->driver_data;
+	struct seq_oss_synth *rec = dev->driver_data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&register_lock, flags);
@@ -187,10 +187,10 @@ snd_seq_oss_synth_unregister(snd_seq_device_t *dev)
 
 /*
  */
-static seq_oss_synth_t *
+static struct seq_oss_synth *
 get_sdev(int dev)
 {
-	seq_oss_synth_t *rec;
+	struct seq_oss_synth *rec;
 	unsigned long flags;
 
 	spin_lock_irqsave(&register_lock, flags);
@@ -207,11 +207,11 @@ get_sdev(int dev)
  */
 
 void
-snd_seq_oss_synth_setup(seq_oss_devinfo_t *dp)
+snd_seq_oss_synth_setup(struct seq_oss_devinfo *dp)
 {
 	int i;
-	seq_oss_synth_t *rec;
-	seq_oss_synthinfo_t *info;
+	struct seq_oss_synth *rec;
+	struct seq_oss_synthinfo *info;
 
 	dp->max_synthdev = max_synth_devs;
 	dp->synth_opened = 0;
@@ -244,7 +244,7 @@ snd_seq_oss_synth_setup(seq_oss_devinfo_t *dp)
 		}
 		info->nr_voices = rec->nr_voices;
 		if (info->nr_voices > 0) {
-			info->ch = kcalloc(info->nr_voices, sizeof(seq_oss_chinfo_t), GFP_KERNEL);
+			info->ch = kcalloc(info->nr_voices, sizeof(struct seq_oss_chinfo), GFP_KERNEL);
 			if (!info->ch)
 				BUG();
 			reset_channels(info);
@@ -263,7 +263,7 @@ snd_seq_oss_synth_setup(seq_oss_devinfo_t *dp)
  */
 
 void
-snd_seq_oss_synth_setup_midi(seq_oss_devinfo_t *dp)
+snd_seq_oss_synth_setup_midi(struct seq_oss_devinfo *dp)
 {
 	int i;
 
@@ -271,7 +271,7 @@ snd_seq_oss_synth_setup_midi(seq_oss_devinfo_t *dp)
 		return;
 
 	for (i = 0; i < dp->max_mididev; i++) {
-		seq_oss_synthinfo_t *info;
+		struct seq_oss_synthinfo *info;
 		info = &dp->synths[dp->max_synthdev];
 		if (snd_seq_oss_midi_open(dp, i, dp->file_mode) < 0)
 			continue;
@@ -297,11 +297,11 @@ snd_seq_oss_synth_setup_midi(seq_oss_devinfo_t *dp)
  */
 
 void
-snd_seq_oss_synth_cleanup(seq_oss_devinfo_t *dp)
+snd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)
 {
 	int i;
-	seq_oss_synth_t *rec;
-	seq_oss_synthinfo_t *info;
+	struct seq_oss_synth *rec;
+	struct seq_oss_synthinfo *info;
 
 	snd_assert(dp->max_synthdev <= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS, return);
 	for (i = 0; i < dp->max_synthdev; i++) {
@@ -338,7 +338,7 @@ snd_seq_oss_synth_cleanup(seq_oss_devinfo_t *dp)
  * check if the specified device is MIDI mapped device
  */
 static int
-is_midi_dev(seq_oss_devinfo_t *dp, int dev)
+is_midi_dev(struct seq_oss_devinfo *dp, int dev)
 {
 	if (dev < 0 || dev >= dp->max_synthdev)
 		return 0;
@@ -350,10 +350,10 @@ is_midi_dev(seq_oss_devinfo_t *dp, int dev)
 /*
  * return synth device information pointer
  */
-static seq_oss_synth_t *
-get_synthdev(seq_oss_devinfo_t *dp, int dev)
+static struct seq_oss_synth *
+get_synthdev(struct seq_oss_devinfo *dp, int dev)
 {
-	seq_oss_synth_t *rec;
+	struct seq_oss_synth *rec;
 	if (dev < 0 || dev >= dp->max_synthdev)
 		return NULL;
 	if (! dp->synths[dev].opened)
@@ -374,7 +374,7 @@ get_synthdev(seq_oss_devinfo_t *dp, int dev)
  * reset note and velocity on each channel.
  */
 static void
-reset_channels(seq_oss_synthinfo_t *info)
+reset_channels(struct seq_oss_synthinfo *info)
 {
 	int i;
 	if (info->ch == NULL || ! info->nr_voices)
@@ -392,10 +392,10 @@ reset_channels(seq_oss_synthinfo_t *info)
  * event to the corresponding port.
  */
 void
-snd_seq_oss_synth_reset(seq_oss_devinfo_t *dp, int dev)
+snd_seq_oss_synth_reset(struct seq_oss_devinfo *dp, int dev)
 {
-	seq_oss_synth_t *rec;
-	seq_oss_synthinfo_t *info;
+	struct seq_oss_synth *rec;
+	struct seq_oss_synthinfo *info;
 
 	snd_assert(dev >= 0 && dev < dp->max_synthdev, return);
 	info = &dp->synths[dev];
@@ -428,7 +428,7 @@ snd_seq_oss_synth_reset(seq_oss_devinfo_t *dp, int dev)
 	if (rec->oper.reset) {
 		rec->oper.reset(&info->arg);
 	} else {
-		snd_seq_event_t ev;
+		struct snd_seq_event ev;
 		memset(&ev, 0, sizeof(ev));
 		snd_seq_oss_fill_addr(dp, &ev, info->arg.addr.client,
 				      info->arg.addr.port);
@@ -444,10 +444,10 @@ snd_seq_oss_synth_reset(seq_oss_devinfo_t *dp, int dev)
  * call load_patch callback function
  */
 int
-snd_seq_oss_synth_load_patch(seq_oss_devinfo_t *dp, int dev, int fmt,
+snd_seq_oss_synth_load_patch(struct seq_oss_devinfo *dp, int dev, int fmt,
 			    const char __user *buf, int p, int c)
 {
-	seq_oss_synth_t *rec;
+	struct seq_oss_synth *rec;
 	int rc;
 
 	if (dev < 0 || dev >= dp->max_synthdev)
@@ -470,9 +470,9 @@ snd_seq_oss_synth_load_patch(seq_oss_devinfo_t *dp, int dev, int fmt,
  * check if the device is valid synth device
  */
 int
-snd_seq_oss_synth_is_valid(seq_oss_devinfo_t *dp, int dev)
+snd_seq_oss_synth_is_valid(struct seq_oss_devinfo *dp, int dev)
 {
-	seq_oss_synth_t *rec;
+	struct seq_oss_synth *rec;
 	rec = get_synthdev(dp, dev);
 	if (rec) {
 		snd_use_lock_free(&rec->use_lock);
@@ -488,11 +488,11 @@ snd_seq_oss_synth_is_valid(seq_oss_devinfo_t *dp, int dev)
  * (0xff).
  */
 int
-snd_seq_oss_synth_sysex(seq_oss_devinfo_t *dp, int dev, unsigned char *buf, snd_seq_event_t *ev)
+snd_seq_oss_synth_sysex(struct seq_oss_devinfo *dp, int dev, unsigned char *buf, struct snd_seq_event *ev)
 {
 	int i, send;
 	unsigned char *dest;
-	seq_oss_synth_sysex_t *sysex;
+	struct seq_oss_synth_sysex *sysex;
 
 	if (! snd_seq_oss_synth_is_valid(dp, dev))
 		return -ENXIO;
@@ -545,7 +545,7 @@ snd_seq_oss_synth_sysex(seq_oss_devinfo_t *dp, int dev, unsigned char *buf, snd_
  * fill the event source/destination addresses
  */
 int
-snd_seq_oss_synth_addr(seq_oss_devinfo_t *dp, int dev, snd_seq_event_t *ev)
+snd_seq_oss_synth_addr(struct seq_oss_devinfo *dp, int dev, struct snd_seq_event *ev)
 {
 	if (! snd_seq_oss_synth_is_valid(dp, dev))
 		return -EINVAL;
@@ -559,9 +559,9 @@ snd_seq_oss_synth_addr(seq_oss_devinfo_t *dp, int dev, snd_seq_event_t *ev)
  * OSS compatible ioctl
  */
 int
-snd_seq_oss_synth_ioctl(seq_oss_devinfo_t *dp, int dev, unsigned int cmd, unsigned long addr)
+snd_seq_oss_synth_ioctl(struct seq_oss_devinfo *dp, int dev, unsigned int cmd, unsigned long addr)
 {
-	seq_oss_synth_t *rec;
+	struct seq_oss_synth *rec;
 	int rc;
 
 	if (is_midi_dev(dp, dev))
@@ -581,7 +581,7 @@ snd_seq_oss_synth_ioctl(seq_oss_devinfo_t *dp, int dev, unsigned int cmd, unsign
  * send OSS raw events - SEQ_PRIVATE and SEQ_VOLUME
  */
 int
-snd_seq_oss_synth_raw_event(seq_oss_devinfo_t *dp, int dev, unsigned char *data, snd_seq_event_t *ev)
+snd_seq_oss_synth_raw_event(struct seq_oss_devinfo *dp, int dev, unsigned char *data, struct snd_seq_event *ev)
 {
 	if (! snd_seq_oss_synth_is_valid(dp, dev) || is_midi_dev(dp, dev))
 		return -ENXIO;
@@ -595,9 +595,9 @@ snd_seq_oss_synth_raw_event(seq_oss_devinfo_t *dp, int dev, unsigned char *data,
  * create OSS compatible synth_info record
  */
 int
-snd_seq_oss_synth_make_info(seq_oss_devinfo_t *dp, int dev, struct synth_info *inf)
+snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)
 {
-	seq_oss_synth_t *rec;
+	struct seq_oss_synth *rec;
 
 	if (dp->synths[dev].is_midi) {
 		struct midi_info minf;
@@ -625,10 +625,10 @@ snd_seq_oss_synth_make_info(seq_oss_devinfo_t *dp, int dev, struct synth_info *i
  * proc interface
  */
 void
-snd_seq_oss_synth_info_read(snd_info_buffer_t *buf)
+snd_seq_oss_synth_info_read(struct snd_info_buffer *buf)
 {
 	int i;
-	seq_oss_synth_t *rec;
+	struct seq_oss_synth *rec;
 
 	snd_iprintf(buf, "\nNumber of synth devices: %d\n", max_synth_devs);
 	for (i = 0; i < max_synth_devs; i++) {

commit ecca82b4b447f8df73c807a018dac3e2863912d9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:49 2005 +0200

    [ALSA] Replace with kzalloc() - seq stuff
    
    ALSA sequencer,Instrument layer,ALSA<-OSS sequencer
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 1a7736cbf3a4..8257fce2ca1b 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -103,7 +103,7 @@ snd_seq_oss_synth_register(snd_seq_device_t *dev)
 	snd_seq_oss_reg_t *reg = SNDRV_SEQ_DEVICE_ARGPTR(dev);
 	unsigned long flags;
 
-	if ((rec = kcalloc(1, sizeof(*rec), GFP_KERNEL)) == NULL) {
+	if ((rec = kzalloc(sizeof(*rec), GFP_KERNEL)) == NULL) {
 		snd_printk(KERN_ERR "can't malloc synth info\n");
 		return -ENOMEM;
 	}
@@ -499,7 +499,7 @@ snd_seq_oss_synth_sysex(seq_oss_devinfo_t *dp, int dev, unsigned char *buf, snd_
 
 	sysex = dp->synths[dev].sysex;
 	if (sysex == NULL) {
-		sysex = kcalloc(1, sizeof(*sysex), GFP_KERNEL);
+		sysex = kzalloc(sizeof(*sysex), GFP_KERNEL);
 		if (sysex == NULL)
 			return -ENOMEM;
 		dp->synths[dev].sysex = sysex;

commit 4d572776d4dfa2d5385a2ec3acec3cc059149e13
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Mon May 30 17:30:32 2005 +0200

    [ALSA] Remove redundant NULL checks before kfree
    
    Timer Midlevel,ALSA sequencer,ALSA<-OSS sequencer,Digigram VX core
    I2C tea6330t,GUS Library,VIA82xx driver,VIA82xx-modem driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,YMFPCI driver
    Digigram VX Pocket driver,Common EMU synth,USB generic driver,USB USX2Y
    Checking a pointer for NULL before calling kfree() on it is redundant,
    kfree() deals with NULL pointers just fine.
    This patch removes such checks from sound/
    
    This patch also makes another, but closely related, change.
    It avoids casting pointers about to be kfree()'ed.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index 638cc148706d..1a7736cbf3a4 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -325,14 +325,10 @@ snd_seq_oss_synth_cleanup(seq_oss_devinfo_t *dp)
 			}
 			snd_use_lock_free(&rec->use_lock);
 		}
-		if (info->sysex) {
-			kfree(info->sysex);
-			info->sysex = NULL;
-		}
-		if (info->ch) {
-			kfree(info->ch);
-			info->ch = NULL;
-		}
+		kfree(info->sysex);
+		info->sysex = NULL;
+		kfree(info->ch);
+		info->ch = NULL;
 	}
 	dp->synth_opened = 0;
 	dp->max_synthdev = 0;
@@ -418,14 +414,10 @@ snd_seq_oss_synth_reset(seq_oss_devinfo_t *dp, int dev)
 					  dp->file_mode) < 0) {
 			midi_synth_dev.opened--;
 			info->opened = 0;
-			if (info->sysex) {
-				kfree(info->sysex);
-				info->sysex = NULL;
-			}
-			if (info->ch) {
-				kfree(info->ch);
-				info->ch = NULL;
-			}
+			kfree(info->sysex);
+			info->sysex = NULL;
+			kfree(info->ch);
+			info->ch = NULL;
 		}
 		return;
 	}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
new file mode 100644
index 000000000000..638cc148706d
--- /dev/null
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -0,0 +1,659 @@
+/*
+ * OSS compatible sequencer driver
+ *
+ * synth device handlers
+ *
+ * Copyright (C) 1998,99 Takashi Iwai <tiwai@suse.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "seq_oss_synth.h"
+#include "seq_oss_midi.h"
+#include "../seq_lock.h"
+#include <linux/init.h>
+
+/*
+ * constants
+ */
+#define SNDRV_SEQ_OSS_MAX_SYNTH_NAME	30
+#define MAX_SYSEX_BUFLEN		128
+
+
+/*
+ * definition of synth info records
+ */
+
+/* sysex buffer */
+struct seq_oss_synth_sysex_t {
+	int len;
+	int skip;
+	unsigned char buf[MAX_SYSEX_BUFLEN];
+};
+
+/* synth info */
+struct seq_oss_synth_t {
+	int seq_device;
+
+	/* for synth_info */
+	int synth_type;
+	int synth_subtype;
+	int nr_voices;
+
+	char name[SNDRV_SEQ_OSS_MAX_SYNTH_NAME];
+	snd_seq_oss_callback_t oper;
+
+	int opened;
+
+	void *private_data;
+	snd_use_lock_t use_lock;
+};
+
+
+/*
+ * device table
+ */
+static int max_synth_devs;
+static seq_oss_synth_t *synth_devs[SNDRV_SEQ_OSS_MAX_SYNTH_DEVS];
+static seq_oss_synth_t midi_synth_dev = {
+	-1, /* seq_device */
+	SYNTH_TYPE_MIDI, /* synth_type */
+	0, /* synth_subtype */
+	16, /* nr_voices */
+	"MIDI", /* name */
+};
+
+static DEFINE_SPINLOCK(register_lock);
+
+/*
+ * prototypes
+ */
+static seq_oss_synth_t *get_synthdev(seq_oss_devinfo_t *dp, int dev);
+static void reset_channels(seq_oss_synthinfo_t *info);
+
+/*
+ * global initialization
+ */
+void __init
+snd_seq_oss_synth_init(void)
+{
+	snd_use_lock_init(&midi_synth_dev.use_lock);
+}
+
+/*
+ * registration of the synth device
+ */
+int
+snd_seq_oss_synth_register(snd_seq_device_t *dev)
+{
+	int i;
+	seq_oss_synth_t *rec;
+	snd_seq_oss_reg_t *reg = SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	unsigned long flags;
+
+	if ((rec = kcalloc(1, sizeof(*rec), GFP_KERNEL)) == NULL) {
+		snd_printk(KERN_ERR "can't malloc synth info\n");
+		return -ENOMEM;
+	}
+	rec->seq_device = -1;
+	rec->synth_type = reg->type;
+	rec->synth_subtype = reg->subtype;
+	rec->nr_voices = reg->nvoices;
+	rec->oper = reg->oper;
+	rec->private_data = reg->private_data;
+	rec->opened = 0;
+	snd_use_lock_init(&rec->use_lock);
+
+	/* copy and truncate the name of synth device */
+	strlcpy(rec->name, dev->name, sizeof(rec->name));
+
+	/* registration */
+	spin_lock_irqsave(&register_lock, flags);
+	for (i = 0; i < max_synth_devs; i++) {
+		if (synth_devs[i] == NULL)
+			break;
+	}
+	if (i >= max_synth_devs) {
+		if (max_synth_devs >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS) {
+			spin_unlock_irqrestore(&register_lock, flags);
+			snd_printk(KERN_ERR "no more synth slot\n");
+			kfree(rec);
+			return -ENOMEM;
+		}
+		max_synth_devs++;
+	}
+	rec->seq_device = i;
+	synth_devs[i] = rec;
+	debug_printk(("synth %s registered %d\n", rec->name, i));
+	spin_unlock_irqrestore(&register_lock, flags);
+	dev->driver_data = rec;
+#ifdef SNDRV_OSS_INFO_DEV_SYNTH
+	if (i < SNDRV_CARDS)
+		snd_oss_info_register(SNDRV_OSS_INFO_DEV_SYNTH, i, rec->name);
+#endif
+	return 0;
+}
+
+
+int
+snd_seq_oss_synth_unregister(snd_seq_device_t *dev)
+{
+	int index;
+	seq_oss_synth_t *rec = dev->driver_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&register_lock, flags);
+	for (index = 0; index < max_synth_devs; index++) {
+		if (synth_devs[index] == rec)
+			break;
+	}
+	if (index >= max_synth_devs) {
+		spin_unlock_irqrestore(&register_lock, flags);
+		snd_printk(KERN_ERR "can't unregister synth\n");
+		return -EINVAL;
+	}
+	synth_devs[index] = NULL;
+	if (index == max_synth_devs - 1) {
+		for (index--; index >= 0; index--) {
+			if (synth_devs[index])
+				break;
+		}
+		max_synth_devs = index + 1;
+	}
+	spin_unlock_irqrestore(&register_lock, flags);
+#ifdef SNDRV_OSS_INFO_DEV_SYNTH
+	if (rec->seq_device < SNDRV_CARDS)
+		snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_SYNTH, rec->seq_device);
+#endif
+
+	snd_use_lock_sync(&rec->use_lock);
+	kfree(rec);
+
+	return 0;
+}
+
+
+/*
+ */
+static seq_oss_synth_t *
+get_sdev(int dev)
+{
+	seq_oss_synth_t *rec;
+	unsigned long flags;
+
+	spin_lock_irqsave(&register_lock, flags);
+	rec = synth_devs[dev];
+	if (rec)
+		snd_use_lock_use(&rec->use_lock);
+	spin_unlock_irqrestore(&register_lock, flags);
+	return rec;
+}
+
+
+/*
+ * set up synth tables
+ */
+
+void
+snd_seq_oss_synth_setup(seq_oss_devinfo_t *dp)
+{
+	int i;
+	seq_oss_synth_t *rec;
+	seq_oss_synthinfo_t *info;
+
+	dp->max_synthdev = max_synth_devs;
+	dp->synth_opened = 0;
+	memset(dp->synths, 0, sizeof(dp->synths));
+	for (i = 0; i < dp->max_synthdev; i++) {
+		rec = get_sdev(i);
+		if (rec == NULL)
+			continue;
+		if (rec->oper.open == NULL || rec->oper.close == NULL) {
+			snd_use_lock_free(&rec->use_lock);
+			continue;
+		}
+		info = &dp->synths[i];
+		info->arg.app_index = dp->port;
+		info->arg.file_mode = dp->file_mode;
+		info->arg.seq_mode = dp->seq_mode;
+		if (dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH)
+			info->arg.event_passing = SNDRV_SEQ_OSS_PROCESS_EVENTS;
+		else
+			info->arg.event_passing = SNDRV_SEQ_OSS_PASS_EVENTS;
+		info->opened = 0;
+		if (!try_module_get(rec->oper.owner)) {
+			snd_use_lock_free(&rec->use_lock);
+			continue;
+		}
+		if (rec->oper.open(&info->arg, rec->private_data) < 0) {
+			module_put(rec->oper.owner);
+			snd_use_lock_free(&rec->use_lock);
+			continue;
+		}
+		info->nr_voices = rec->nr_voices;
+		if (info->nr_voices > 0) {
+			info->ch = kcalloc(info->nr_voices, sizeof(seq_oss_chinfo_t), GFP_KERNEL);
+			if (!info->ch)
+				BUG();
+			reset_channels(info);
+		}
+		debug_printk(("synth %d assigned\n", i));
+		info->opened++;
+		rec->opened++;
+		dp->synth_opened++;
+		snd_use_lock_free(&rec->use_lock);
+	}
+}
+
+
+/*
+ * set up synth tables for MIDI emulation - /dev/music mode only
+ */
+
+void
+snd_seq_oss_synth_setup_midi(seq_oss_devinfo_t *dp)
+{
+	int i;
+
+	if (dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS)
+		return;
+
+	for (i = 0; i < dp->max_mididev; i++) {
+		seq_oss_synthinfo_t *info;
+		info = &dp->synths[dp->max_synthdev];
+		if (snd_seq_oss_midi_open(dp, i, dp->file_mode) < 0)
+			continue;
+		info->arg.app_index = dp->port;
+		info->arg.file_mode = dp->file_mode;
+		info->arg.seq_mode = dp->seq_mode;
+		info->arg.private_data = info;
+		info->is_midi = 1;
+		info->midi_mapped = i;
+		info->arg.event_passing = SNDRV_SEQ_OSS_PASS_EVENTS;
+		snd_seq_oss_midi_get_addr(dp, i, &info->arg.addr);
+		info->opened = 1;
+		midi_synth_dev.opened++;
+		dp->max_synthdev++;
+		if (dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS)
+			break;
+	}
+}
+
+
+/*
+ * clean up synth tables
+ */
+
+void
+snd_seq_oss_synth_cleanup(seq_oss_devinfo_t *dp)
+{
+	int i;
+	seq_oss_synth_t *rec;
+	seq_oss_synthinfo_t *info;
+
+	snd_assert(dp->max_synthdev <= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS, return);
+	for (i = 0; i < dp->max_synthdev; i++) {
+		info = &dp->synths[i];
+		if (! info->opened)
+			continue;
+		if (info->is_midi) {
+			if (midi_synth_dev.opened > 0) {
+				snd_seq_oss_midi_close(dp, info->midi_mapped);
+				midi_synth_dev.opened--;
+			}
+		} else {
+			rec = get_sdev(i);
+			if (rec == NULL)
+				continue;
+			if (rec->opened > 0) {
+				debug_printk(("synth %d closed\n", i));
+				rec->oper.close(&info->arg);
+				module_put(rec->oper.owner);
+				rec->opened = 0;
+			}
+			snd_use_lock_free(&rec->use_lock);
+		}
+		if (info->sysex) {
+			kfree(info->sysex);
+			info->sysex = NULL;
+		}
+		if (info->ch) {
+			kfree(info->ch);
+			info->ch = NULL;
+		}
+	}
+	dp->synth_opened = 0;
+	dp->max_synthdev = 0;
+}
+
+/*
+ * check if the specified device is MIDI mapped device
+ */
+static int
+is_midi_dev(seq_oss_devinfo_t *dp, int dev)
+{
+	if (dev < 0 || dev >= dp->max_synthdev)
+		return 0;
+	if (dp->synths[dev].is_midi)
+		return 1;
+	return 0;
+}
+
+/*
+ * return synth device information pointer
+ */
+static seq_oss_synth_t *
+get_synthdev(seq_oss_devinfo_t *dp, int dev)
+{
+	seq_oss_synth_t *rec;
+	if (dev < 0 || dev >= dp->max_synthdev)
+		return NULL;
+	if (! dp->synths[dev].opened)
+		return NULL;
+	if (dp->synths[dev].is_midi)
+		return &midi_synth_dev;
+	if ((rec = get_sdev(dev)) == NULL)
+		return NULL;
+	if (! rec->opened) {
+		snd_use_lock_free(&rec->use_lock);
+		return NULL;
+	}
+	return rec;
+}
+
+
+/*
+ * reset note and velocity on each channel.
+ */
+static void
+reset_channels(seq_oss_synthinfo_t *info)
+{
+	int i;
+	if (info->ch == NULL || ! info->nr_voices)
+		return;
+	for (i = 0; i < info->nr_voices; i++) {
+		info->ch[i].note = -1;
+		info->ch[i].vel = 0;
+	}
+}
+
+
+/*
+ * reset synth device:
+ * call reset callback.  if no callback is defined, send a heartbeat
+ * event to the corresponding port.
+ */
+void
+snd_seq_oss_synth_reset(seq_oss_devinfo_t *dp, int dev)
+{
+	seq_oss_synth_t *rec;
+	seq_oss_synthinfo_t *info;
+
+	snd_assert(dev >= 0 && dev < dp->max_synthdev, return);
+	info = &dp->synths[dev];
+	if (! info->opened)
+		return;
+	if (info->sysex)
+		info->sysex->len = 0; /* reset sysex */
+	reset_channels(info);
+	if (info->is_midi) {
+		if (midi_synth_dev.opened <= 0)
+			return;
+		snd_seq_oss_midi_reset(dp, info->midi_mapped);
+		/* reopen the device */
+		snd_seq_oss_midi_close(dp, dev);
+		if (snd_seq_oss_midi_open(dp, info->midi_mapped,
+					  dp->file_mode) < 0) {
+			midi_synth_dev.opened--;
+			info->opened = 0;
+			if (info->sysex) {
+				kfree(info->sysex);
+				info->sysex = NULL;
+			}
+			if (info->ch) {
+				kfree(info->ch);
+				info->ch = NULL;
+			}
+		}
+		return;
+	}
+
+	rec = get_sdev(dev);
+	if (rec == NULL)
+		return;
+	if (rec->oper.reset) {
+		rec->oper.reset(&info->arg);
+	} else {
+		snd_seq_event_t ev;
+		memset(&ev, 0, sizeof(ev));
+		snd_seq_oss_fill_addr(dp, &ev, info->arg.addr.client,
+				      info->arg.addr.port);
+		ev.type = SNDRV_SEQ_EVENT_RESET;
+		snd_seq_oss_dispatch(dp, &ev, 0, 0);
+	}
+	snd_use_lock_free(&rec->use_lock);
+}
+
+
+/*
+ * load a patch record:
+ * call load_patch callback function
+ */
+int
+snd_seq_oss_synth_load_patch(seq_oss_devinfo_t *dp, int dev, int fmt,
+			    const char __user *buf, int p, int c)
+{
+	seq_oss_synth_t *rec;
+	int rc;
+
+	if (dev < 0 || dev >= dp->max_synthdev)
+		return -ENXIO;
+
+	if (is_midi_dev(dp, dev))
+		return 0;
+	if ((rec = get_synthdev(dp, dev)) == NULL)
+		return -ENXIO;
+
+	if (rec->oper.load_patch == NULL)
+		rc = -ENXIO;
+	else
+		rc = rec->oper.load_patch(&dp->synths[dev].arg, fmt, buf, p, c);
+	snd_use_lock_free(&rec->use_lock);
+	return rc;
+}
+
+/*
+ * check if the device is valid synth device
+ */
+int
+snd_seq_oss_synth_is_valid(seq_oss_devinfo_t *dp, int dev)
+{
+	seq_oss_synth_t *rec;
+	rec = get_synthdev(dp, dev);
+	if (rec) {
+		snd_use_lock_free(&rec->use_lock);
+		return 1;
+	}
+	return 0;
+}
+
+
+/*
+ * receive OSS 6 byte sysex packet:
+ * the full sysex message will be sent if it reaches to the end of data
+ * (0xff).
+ */
+int
+snd_seq_oss_synth_sysex(seq_oss_devinfo_t *dp, int dev, unsigned char *buf, snd_seq_event_t *ev)
+{
+	int i, send;
+	unsigned char *dest;
+	seq_oss_synth_sysex_t *sysex;
+
+	if (! snd_seq_oss_synth_is_valid(dp, dev))
+		return -ENXIO;
+
+	sysex = dp->synths[dev].sysex;
+	if (sysex == NULL) {
+		sysex = kcalloc(1, sizeof(*sysex), GFP_KERNEL);
+		if (sysex == NULL)
+			return -ENOMEM;
+		dp->synths[dev].sysex = sysex;
+	}
+
+	send = 0;
+	dest = sysex->buf + sysex->len;
+	/* copy 6 byte packet to the buffer */
+	for (i = 0; i < 6; i++) {
+		if (buf[i] == 0xff) {
+			send = 1;
+			break;
+		}
+		dest[i] = buf[i];
+		sysex->len++;
+		if (sysex->len >= MAX_SYSEX_BUFLEN) {
+			sysex->len = 0;
+			sysex->skip = 1;
+			break;
+		}
+	}
+
+	if (sysex->len && send) {
+		if (sysex->skip) {
+			sysex->skip = 0;
+			sysex->len = 0;
+			return -EINVAL; /* skip */
+		}
+		/* copy the data to event record and send it */
+		ev->flags = SNDRV_SEQ_EVENT_LENGTH_VARIABLE;
+		if (snd_seq_oss_synth_addr(dp, dev, ev))
+			return -EINVAL;
+		ev->data.ext.len = sysex->len;
+		ev->data.ext.ptr = sysex->buf;
+		sysex->len = 0;
+		return 0;
+	}
+
+	return -EINVAL; /* skip */
+}
+
+/*
+ * fill the event source/destination addresses
+ */
+int
+snd_seq_oss_synth_addr(seq_oss_devinfo_t *dp, int dev, snd_seq_event_t *ev)
+{
+	if (! snd_seq_oss_synth_is_valid(dp, dev))
+		return -EINVAL;
+	snd_seq_oss_fill_addr(dp, ev, dp->synths[dev].arg.addr.client,
+			      dp->synths[dev].arg.addr.port);
+	return 0;
+}
+
+
+/*
+ * OSS compatible ioctl
+ */
+int
+snd_seq_oss_synth_ioctl(seq_oss_devinfo_t *dp, int dev, unsigned int cmd, unsigned long addr)
+{
+	seq_oss_synth_t *rec;
+	int rc;
+
+	if (is_midi_dev(dp, dev))
+		return -ENXIO;
+	if ((rec = get_synthdev(dp, dev)) == NULL)
+		return -ENXIO;
+	if (rec->oper.ioctl == NULL)
+		rc = -ENXIO;
+	else
+		rc = rec->oper.ioctl(&dp->synths[dev].arg, cmd, addr);
+	snd_use_lock_free(&rec->use_lock);
+	return rc;
+}
+
+
+/*
+ * send OSS raw events - SEQ_PRIVATE and SEQ_VOLUME
+ */
+int
+snd_seq_oss_synth_raw_event(seq_oss_devinfo_t *dp, int dev, unsigned char *data, snd_seq_event_t *ev)
+{
+	if (! snd_seq_oss_synth_is_valid(dp, dev) || is_midi_dev(dp, dev))
+		return -ENXIO;
+	ev->type = SNDRV_SEQ_EVENT_OSS;
+	memcpy(ev->data.raw8.d, data, 8);
+	return snd_seq_oss_synth_addr(dp, dev, ev);
+}
+
+
+/*
+ * create OSS compatible synth_info record
+ */
+int
+snd_seq_oss_synth_make_info(seq_oss_devinfo_t *dp, int dev, struct synth_info *inf)
+{
+	seq_oss_synth_t *rec;
+
+	if (dp->synths[dev].is_midi) {
+		struct midi_info minf;
+		snd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);
+		inf->synth_type = SYNTH_TYPE_MIDI;
+		inf->synth_subtype = 0;
+		inf->nr_voices = 16;
+		inf->device = dev;
+		strlcpy(inf->name, minf.name, sizeof(inf->name));
+	} else {
+		if ((rec = get_synthdev(dp, dev)) == NULL)
+			return -ENXIO;
+		inf->synth_type = rec->synth_type;
+		inf->synth_subtype = rec->synth_subtype;
+		inf->nr_voices = rec->nr_voices;
+		inf->device = dev;
+		strlcpy(inf->name, rec->name, sizeof(inf->name));
+		snd_use_lock_free(&rec->use_lock);
+	}
+	return 0;
+}
+
+
+/*
+ * proc interface
+ */
+void
+snd_seq_oss_synth_info_read(snd_info_buffer_t *buf)
+{
+	int i;
+	seq_oss_synth_t *rec;
+
+	snd_iprintf(buf, "\nNumber of synth devices: %d\n", max_synth_devs);
+	for (i = 0; i < max_synth_devs; i++) {
+		snd_iprintf(buf, "\nsynth %d: ", i);
+		rec = get_sdev(i);
+		if (rec == NULL) {
+			snd_iprintf(buf, "*empty*\n");
+			continue;
+		}
+		snd_iprintf(buf, "[%s]\n", rec->name);
+		snd_iprintf(buf, "  type 0x%x : subtype 0x%x : voices %d\n",
+			    rec->synth_type, rec->synth_subtype,
+			    rec->nr_voices);
+		snd_iprintf(buf, "  capabilities : ioctl %s / load_patch %s\n",
+			    enabled_str((long)rec->oper.ioctl),
+			    enabled_str((long)rec->oper.load_patch));
+		snd_use_lock_free(&rec->use_lock);
+	}
+}
+
