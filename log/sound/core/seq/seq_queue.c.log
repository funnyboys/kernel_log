commit dc7497795e014d84699c3b8809ed6df35352dd74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 14 12:13:15 2020 +0100

    ALSA: seq: Fix concurrent access to queue current tick/time
    
    snd_seq_check_queue() passes the current tick and time of the given
    queue as a pointer to snd_seq_prioq_cell_out(), but those might be
    updated concurrently by the seq timer update.
    
    Fix it by retrieving the current tick and time via the proper helper
    functions at first, and pass those values to snd_seq_prioq_cell_out()
    later in the loops.
    
    snd_seq_timer_get_cur_time() takes a new argument and adjusts with the
    current system time only when it's requested so; this update isn't
    needed for snd_seq_check_queue(), as it's called either from the
    interrupt handler or right after queuing.
    
    Also, snd_seq_timer_get_cur_tick() is changed to read the value in the
    spinlock for the concurrency, too.
    
    Reported-by: syzbot+fd5e0eaa1a32999173b2@syzkaller.appspotmail.com
    Link: https://lore.kernel.org/r/20200214111316.26939-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 20c552cf8398..71a6ea62c3be 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -238,6 +238,8 @@ void snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop)
 {
 	unsigned long flags;
 	struct snd_seq_event_cell *cell;
+	snd_seq_tick_time_t cur_tick;
+	snd_seq_real_time_t cur_time;
 
 	if (q == NULL)
 		return;
@@ -254,17 +256,18 @@ void snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop)
 
       __again:
 	/* Process tick queue... */
+	cur_tick = snd_seq_timer_get_cur_tick(q->timer);
 	for (;;) {
-		cell = snd_seq_prioq_cell_out(q->tickq,
-					      &q->timer->tick.cur_tick);
+		cell = snd_seq_prioq_cell_out(q->tickq, &cur_tick);
 		if (!cell)
 			break;
 		snd_seq_dispatch_event(cell, atomic, hop);
 	}
 
 	/* Process time queue... */
+	cur_time = snd_seq_timer_get_cur_time(q->timer, false);
 	for (;;) {
-		cell = snd_seq_prioq_cell_out(q->timeq, &q->timer->cur_time);
+		cell = snd_seq_prioq_cell_out(q->timeq, &cur_time);
 		if (!cell)
 			break;
 		snd_seq_dispatch_event(cell, atomic, hop);

commit bb51e669fa49feb5904f452b2991b240ef31bc97
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 14 12:13:14 2020 +0100

    ALSA: seq: Avoid concurrent access to queue flags
    
    The queue flags are represented in bit fields and the concurrent
    access may result in unexpected results.  Although the current code
    should be mostly OK as it's only reading a field while writing other
    fields as KCSAN reported, it's safer to cover both with a proper
    spinlock protection.
    
    This patch fixes the possible concurrent read by protecting with
    q->owner_lock.  Also the queue owner field is protected as well since
    it's the field to be protected by the lock itself.
    
    Reported-by: syzbot+65c6c92d04304d0a8efc@syzkaller.appspotmail.com
    Reported-by: syzbot+e60ddfa48717579799dd@syzkaller.appspotmail.com
    Link: https://lore.kernel.org/r/20200214111316.26939-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index caf68bf42f13..20c552cf8398 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -392,6 +392,7 @@ int snd_seq_queue_check_access(int queueid, int client)
 int snd_seq_queue_set_owner(int queueid, int client, int locked)
 {
 	struct snd_seq_queue *q = queueptr(queueid);
+	unsigned long flags;
 
 	if (q == NULL)
 		return -EINVAL;
@@ -401,8 +402,10 @@ int snd_seq_queue_set_owner(int queueid, int client, int locked)
 		return -EPERM;
 	}
 
+	spin_lock_irqsave(&q->owner_lock, flags);
 	q->locked = locked ? 1 : 0;
 	q->owner = client;
+	spin_unlock_irqrestore(&q->owner_lock, flags);
 	queue_access_unlock(q);
 	queuefree(q);
 
@@ -539,15 +542,17 @@ void snd_seq_queue_client_termination(int client)
 	unsigned long flags;
 	int i;
 	struct snd_seq_queue *q;
+	bool matched;
 
 	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
 		if ((q = queueptr(i)) == NULL)
 			continue;
 		spin_lock_irqsave(&q->owner_lock, flags);
-		if (q->owner == client)
+		matched = (q->owner == client);
+		if (matched)
 			q->klocked = 1;
 		spin_unlock_irqrestore(&q->owner_lock, flags);
-		if (q->owner == client) {
+		if (matched) {
 			if (q->timer->running)
 				snd_seq_timer_stop(q->timer);
 			snd_seq_timer_reset(q->timer);
@@ -739,6 +744,8 @@ void snd_seq_info_queues_read(struct snd_info_entry *entry,
 	int i, bpm;
 	struct snd_seq_queue *q;
 	struct snd_seq_timer *tmr;
+	bool locked;
+	int owner;
 
 	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
 		if ((q = queueptr(i)) == NULL)
@@ -750,9 +757,14 @@ void snd_seq_info_queues_read(struct snd_info_entry *entry,
 		else
 			bpm = 0;
 
+		spin_lock_irq(&q->owner_lock);
+		locked = q->locked;
+		owner = q->owner;
+		spin_unlock_irq(&q->owner_lock);
+
 		snd_iprintf(buffer, "queue %d: [%s]\n", q->queue, q->name);
-		snd_iprintf(buffer, "owned by client    : %d\n", q->owner);
-		snd_iprintf(buffer, "lock status        : %s\n", q->locked ? "Locked" : "Free");
+		snd_iprintf(buffer, "owned by client    : %d\n", owner);
+		snd_iprintf(buffer, "lock status        : %s\n", locked ? "Locked" : "Free");
 		snd_iprintf(buffer, "queued time events : %d\n", snd_seq_prioq_avail(q->timeq));
 		snd_iprintf(buffer, "queued tick events : %d\n", snd_seq_prioq_avail(q->tickq));
 		snd_iprintf(buffer, "timer state        : %s\n", tmr->running ? "Running" : "Stopped");

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 3b3ac96f1f5f..caf68bf42f13 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   ALSA sequencer Timing queue handling
  *   Copyright (c) 1998-1999 by Frank van de Pol <fvdpol@coil.demon.nl>
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  * MAJOR CHANGES
  *   Nov. 13, 1999	Takashi Iwai <iwai@ww.uni-erlangen.de>
  *     - Queues are allocated dynamically via ioctl.

commit 00976ad5271999ba06d24319fd1031b178aff832
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 1 16:37:02 2018 +0200

    ALSA: seq: Fix leftovers at probe error path
    
    The sequencer core module doesn't call some destructors in the error
    path of the init code, which may leave some resources.
    
    This patch mainly fix these leaks by calling the destructors
    appropriately at alsa_seq_init().  Also the patch brings a few
    cleanups along with it, namely:
    
    - Expand the old "if ((err = xxx) < 0)" coding style
    - Get rid of empty seq_queue_init() and its caller
    - Change snd_seq_info_done() to void
    
    Last but not least, a couple of functions lose __exit annotation since
    they are called also in alsa_seq_init().
    
    No functional changes but minor code cleanups.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index b377f5048352..3b3ac96f1f5f 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -159,18 +159,8 @@ static void queue_delete(struct snd_seq_queue *q)
 
 /*----------------------------------------------------------------*/
 
-/* setup queues */
-int __init snd_seq_queues_init(void)
-{
-	/*
-	memset(queue_list, 0, sizeof(queue_list));
-	num_queues = 0;
-	*/
-	return 0;
-}
-
 /* delete all existing queues */
-void __exit snd_seq_queues_delete(void)
+void snd_seq_queues_delete(void)
 {
 	int i;
 

commit d0f833065221cbfcbadf19fd4102bcfa9330006a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 9 21:58:28 2018 +0100

    ALSA: seq: Fix possible UAF in snd_seq_check_queue()
    
    Although we've covered the races between concurrent write() and
    ioctl() in the previous patch series, there is still a possible UAF in
    the following scenario:
    
    A: user client closed           B: timer irq
      -> snd_seq_release()            -> snd_seq_timer_interrupt()
        -> snd_seq_free_client()        -> snd_seq_check_queue()
                                          -> cell = snd_seq_prioq_cell_peek()
          -> snd_seq_prioq_leave()
             .... removing all cells
          -> snd_seq_pool_done()
             .... vfree()
                                          -> snd_seq_compare_tick_time(cell)
                                             ... Oops
    
    So the problem is that a cell is peeked and accessed without any
    protection until it's retrieved from the queue again via
    snd_seq_prioq_cell_out().
    
    This patch tries to address it, also cleans up the code by a slight
    refactoring.  snd_seq_prioq_cell_out() now receives an extra pointer
    argument.  When it's non-NULL, the function checks the event timestamp
    with the given pointer.  The caller needs to pass the right reference
    either to snd_seq_tick or snd_seq_realtime depending on the event
    timestamp type.
    
    A good news is that the above change allows us to remove the
    snd_seq_prioq_cell_peek(), too, thus the patch actually reduces the
    code size.
    
    Reviewed-by: Nicolai Stange <nstange@suse.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 0428e9061b47..b377f5048352 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -277,30 +277,20 @@ void snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop)
 
       __again:
 	/* Process tick queue... */
-	while ((cell = snd_seq_prioq_cell_peek(q->tickq)) != NULL) {
-		if (snd_seq_compare_tick_time(&q->timer->tick.cur_tick,
-					      &cell->event.time.tick)) {
-			cell = snd_seq_prioq_cell_out(q->tickq);
-			if (cell)
-				snd_seq_dispatch_event(cell, atomic, hop);
-		} else {
-			/* event remains in the queue */
+	for (;;) {
+		cell = snd_seq_prioq_cell_out(q->tickq,
+					      &q->timer->tick.cur_tick);
+		if (!cell)
 			break;
-		}
+		snd_seq_dispatch_event(cell, atomic, hop);
 	}
 
-
 	/* Process time queue... */
-	while ((cell = snd_seq_prioq_cell_peek(q->timeq)) != NULL) {
-		if (snd_seq_compare_real_time(&q->timer->cur_time,
-					      &cell->event.time.time)) {
-			cell = snd_seq_prioq_cell_out(q->timeq);
-			if (cell)
-				snd_seq_dispatch_event(cell, atomic, hop);
-		} else {
-			/* event remains in the queue */
+	for (;;) {
+		cell = snd_seq_prioq_cell_out(q->timeq, &q->timer->cur_time);
+		if (!cell)
 			break;
-		}
+		snd_seq_dispatch_event(cell, atomic, hop);
 	}
 
 	/* free lock */

commit 671ec859e5ee06ab0bf968e639a25576b18865ad
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 15 16:48:36 2018 +0100

    ALSA: seq: Process queue tempo/ppq change in a shot
    
    The SNDRV_SEQ_IOCTL_SET_QUEUE_TEMPO ioctl sets the tempo and the ppq
    in a single call, while the current implementation updates each value
    one by one.  This is a bit racy, and also suboptimal from the
    performance POV, as each call does re-acquire the lock and invokes
    the update of ALSA timer resolution.
    
    This patch reorganizes the code slightly so that we change both the
    tempo and the ppq in a shot.  The skew value can be put into the same
    lock, but this is rather a rarely used feature and completely
    independent from the temp/ppq (it's evaluated only in the interrupt),
    so it's left as it was.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 79e0c5604ef8..0428e9061b47 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -497,9 +497,7 @@ int snd_seq_queue_timer_set_tempo(int queueid, int client,
 		return -EPERM;
 	}
 
-	result = snd_seq_timer_set_tempo(q->timer, info->tempo);
-	if (result >= 0)
-		result = snd_seq_timer_set_ppq(q->timer, info->ppq);
+	result = snd_seq_timer_set_tempo_ppq(q->timer, info->tempo, info->ppq);
 	if (result >= 0 && info->skew_base > 0)
 		result = snd_seq_timer_set_skew(q->timer, info->skew_value,
 						info->skew_base);

commit 7e1d90f60a0d501c8503e636942ca704a454d910
Author: Daniel Mentz <danielmentz@google.com>
Date:   Mon Aug 14 14:46:01 2017 -0700

    ALSA: seq: 2nd attempt at fixing race creating a queue
    
    commit 4842e98f26dd80be3623c4714a244ba52ea096a8 ("ALSA: seq: Fix race at
    creating a queue") attempted to fix a race reported by syzkaller. That
    fix has been described as follows:
    
    "
    When a sequencer queue is created in snd_seq_queue_alloc(),it adds the
    new queue element to the public list before referencing it.  Thus the
    queue might be deleted before the call of snd_seq_queue_use(), and it
    results in the use-after-free error, as spotted by syzkaller.
    
    The fix is to reference the queue object at the right time.
    "
    
    Even with that fix in place, syzkaller reported a use-after-free error.
    It specifically pointed to the last instruction "return q->queue" in
    snd_seq_queue_alloc(). The pointer q is being used after kfree() has
    been called on it.
    
    It turned out that there is still a small window where a race can
    happen. The window opens at
    snd_seq_ioctl_create_queue()->snd_seq_queue_alloc()->queue_list_add()
    and closes at
    snd_seq_ioctl_create_queue()->queueptr()->snd_use_lock_use(). Between
    these two calls, a different thread could delete the queue and possibly
    re-create a different queue in the same location in queue_list.
    
    This change prevents this situation by calling snd_use_lock_use() from
    snd_seq_queue_alloc() prior to calling queue_list_add(). It is then the
    caller's responsibility to call snd_use_lock_free(&q->use_lock).
    
    Fixes: 4842e98f26dd ("ALSA: seq: Fix race at creating a queue")
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Daniel Mentz <danielmentz@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 450c5187eecb..79e0c5604ef8 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -184,22 +184,26 @@ void __exit snd_seq_queues_delete(void)
 static void queue_use(struct snd_seq_queue *queue, int client, int use);
 
 /* allocate a new queue -
- * return queue index value or negative value for error
+ * return pointer to new queue or ERR_PTR(-errno) for error
+ * The new queue's use_lock is set to 1. It is the caller's responsibility to
+ * call snd_use_lock_free(&q->use_lock).
  */
-int snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)
+struct snd_seq_queue *snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)
 {
 	struct snd_seq_queue *q;
 
 	q = queue_new(client, locked);
 	if (q == NULL)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 	q->info_flags = info_flags;
 	queue_use(q, client, 1);
+	snd_use_lock_use(&q->use_lock);
 	if (queue_list_add(q) < 0) {
+		snd_use_lock_free(&q->use_lock);
 		queue_delete(q);
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 	}
-	return q->queue;
+	return q;
 }
 
 /* delete a queue - queue must be owned by the client */

commit 4842e98f26dd80be3623c4714a244ba52ea096a8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 8 12:35:39 2017 +0100

    ALSA: seq: Fix race at creating a queue
    
    When a sequencer queue is created in snd_seq_queue_alloc(),it adds the
    new queue element to the public list before referencing it.  Thus the
    queue might be deleted before the call of snd_seq_queue_use(), and it
    results in the use-after-free error, as spotted by syzkaller.
    
    The fix is to reference the queue object at the right time.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 0bec02e89d51..450c5187eecb 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -181,6 +181,8 @@ void __exit snd_seq_queues_delete(void)
 	}
 }
 
+static void queue_use(struct snd_seq_queue *queue, int client, int use);
+
 /* allocate a new queue -
  * return queue index value or negative value for error
  */
@@ -192,11 +194,11 @@ int snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)
 	if (q == NULL)
 		return -ENOMEM;
 	q->info_flags = info_flags;
+	queue_use(q, client, 1);
 	if (queue_list_add(q) < 0) {
 		queue_delete(q);
 		return -ENOMEM;
 	}
-	snd_seq_queue_use(q->queue, client, 1); /* use this queue */
 	return q->queue;
 }
 
@@ -502,19 +504,9 @@ int snd_seq_queue_timer_set_tempo(int queueid, int client,
 	return result;
 }
 
-
-/* use or unuse this queue -
- * if it is the first client, starts the timer.
- * if it is not longer used by any clients, stop the timer.
- */
-int snd_seq_queue_use(int queueid, int client, int use)
+/* use or unuse this queue */
+static void queue_use(struct snd_seq_queue *queue, int client, int use)
 {
-	struct snd_seq_queue *queue;
-
-	queue = queueptr(queueid);
-	if (queue == NULL)
-		return -EINVAL;
-	mutex_lock(&queue->timer_mutex);
 	if (use) {
 		if (!test_and_set_bit(client, queue->clients_bitmap))
 			queue->clients++;
@@ -529,6 +521,21 @@ int snd_seq_queue_use(int queueid, int client, int use)
 	} else {
 		snd_seq_timer_close(queue);
 	}
+}
+
+/* use or unuse this queue -
+ * if it is the first client, starts the timer.
+ * if it is not longer used by any clients, stop the timer.
+ */
+int snd_seq_queue_use(int queueid, int client, int use)
+{
+	struct snd_seq_queue *queue;
+
+	queue = queueptr(queueid);
+	if (queue == NULL)
+		return -EINVAL;
+	mutex_lock(&queue->timer_mutex);
+	queue_use(queue, client, use);
 	mutex_unlock(&queue->timer_mutex);
 	queuefree(queue);
 	return 0;

commit 3567eb6af614dac436c4b16a8d426f9faed639b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 12 15:36:27 2016 +0100

    ALSA: seq: Fix race at timer setup and close
    
    ALSA sequencer code has an open race between the timer setup ioctl and
    the close of the client.  This was triggered by syzkaller fuzzer, and
    a use-after-free was caught there as a result.
    
    This patch papers over it by adding a proper queue->timer_mutex lock
    around the timer-related calls in the relevant code path.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 7dfd0f429410..0bec02e89d51 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -142,8 +142,10 @@ static struct snd_seq_queue *queue_new(int owner, int locked)
 static void queue_delete(struct snd_seq_queue *q)
 {
 	/* stop and release the timer */
+	mutex_lock(&q->timer_mutex);
 	snd_seq_timer_stop(q->timer);
 	snd_seq_timer_close(q);
+	mutex_unlock(&q->timer_mutex);
 	/* wait until access free */
 	snd_use_lock_sync(&q->use_lock);
 	/* release resources... */

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index a0cda38205b9..7dfd0f429410 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -753,7 +753,7 @@ int snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop)
 
 /*----------------------------------------------------------------*/
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /* exported to seq_info.c */
 void snd_seq_info_queues_read(struct snd_info_entry *entry, 
 			      struct snd_info_buffer *buffer)
@@ -787,5 +787,5 @@ void snd_seq_info_queues_read(struct snd_info_entry *entry,
 		queuefree(q);
 	}
 }
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */
 

commit 24db8bbaa3fcfaf0c2faccbff5864b58088ac1f6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:41:18 2015 +0100

    ALSA: seq: Drop superfluous error/debug messages after malloc failures
    
    The kernel memory allocators already report the errors when the
    requested allocation fails, thus we don't need to warn it again in
    each caller side.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index aad4878cee55..a0cda38205b9 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -111,10 +111,8 @@ static struct snd_seq_queue *queue_new(int owner, int locked)
 	struct snd_seq_queue *q;
 
 	q = kzalloc(sizeof(*q), GFP_KERNEL);
-	if (q == NULL) {
-		pr_debug("ALSA: seq: malloc failed for snd_seq_queue_new()\n");
+	if (!q)
 		return NULL;
-	}
 
 	spin_lock_init(&q->owner_lock);
 	spin_lock_init(&q->check_lock);

commit 04cc79a048ee215ec39af05d61f1fc8a4ab3d8c1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:24:34 2014 +0100

    ALSA: seq: Use standard printk helpers
    
    Use the standard pr_xxx() helpers instead of home-baked snd_print*().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index f9077361c119..aad4878cee55 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -112,7 +112,7 @@ static struct snd_seq_queue *queue_new(int owner, int locked)
 
 	q = kzalloc(sizeof(*q), GFP_KERNEL);
 	if (q == NULL) {
-		snd_printd("malloc failed for snd_seq_queue_new()\n");
+		pr_debug("ALSA: seq: malloc failed for snd_seq_queue_new()\n");
 		return NULL;
 	}
 

commit 78fa2c4d2465d014e67d3e12d948425856587251
Author: Luca Tettamanti <kronos.it@gmail.com>
Date:   Wed May 25 22:43:27 2011 +0200

    ALSA: core: remove unused variables.
    
    Drop a few variables that are never read.
    
    Signed-off-by: Luca Tettamanti <kronos.it@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index e7a8e9e4edb2..f9077361c119 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -467,13 +467,11 @@ int snd_seq_queue_timer_open(int queueid)
 int snd_seq_queue_timer_close(int queueid)
 {
 	struct snd_seq_queue *queue;
-	struct snd_seq_timer *tmr;
 	int result = 0;
 
 	queue = queueptr(queueid);
 	if (queue == NULL)
 		return -EINVAL;
-	tmr = queue->timer;
 	snd_seq_timer_close(queue);
 	queuefree(queue);
 	return result;

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 4a48c6ee8ee8..e7a8e9e4edb2 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -315,7 +315,8 @@ int snd_seq_enqueue_event(struct snd_seq_event_cell *cell, int atomic, int hop)
 	int dest, err;
 	struct snd_seq_queue *q;
 
-	snd_assert(cell != NULL, return -EINVAL);
+	if (snd_BUG_ON(!cell))
+		return -EINVAL;
 	dest = cell->event.queue;	/* destination queue */
 	q = queueptr(dest);
 	if (q == NULL)
@@ -734,7 +735,8 @@ int snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop)
 {
 	struct snd_seq_queue *q;
 
-	snd_assert(ev != NULL, return -EINVAL);
+	if (snd_BUG_ON(!ev))
+		return -EINVAL;
 	q = queueptr(ev->data.queue.queue);
 
 	if (q == NULL)

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 9b87bb0c7f33..4a48c6ee8ee8 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -35,7 +35,6 @@
  *     - Addition of experimental sync support.
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <sound/core.h>

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 9cf20f045542..9b87bb0c7f33 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -119,7 +119,7 @@ static struct snd_seq_queue *queue_new(int owner, int locked)
 
 	spin_lock_init(&q->owner_lock);
 	spin_lock_init(&q->check_lock);
-	init_MUTEX(&q->timer_mutex);
+	mutex_init(&q->timer_mutex);
 	snd_use_lock_init(&q->use_lock);
 	q->queue = -1;
 
@@ -516,7 +516,7 @@ int snd_seq_queue_use(int queueid, int client, int use)
 	queue = queueptr(queueid);
 	if (queue == NULL)
 		return -EINVAL;
-	down(&queue->timer_mutex);
+	mutex_lock(&queue->timer_mutex);
 	if (use) {
 		if (!test_and_set_bit(client, queue->clients_bitmap))
 			queue->clients++;
@@ -531,7 +531,7 @@ int snd_seq_queue_use(int queueid, int client, int use)
 	} else {
 		snd_seq_timer_close(queue);
 	}
-	up(&queue->timer_mutex);
+	mutex_unlock(&queue->timer_mutex);
 	queuefree(queue);
 	return 0;
 }

commit 04f141a8800d022981f0405a8d307c98aba55105
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:43:51 2005 +0100

    [ALSA] Optimize for config without PROC_FS (seq and oss parts)
    
    Modules: ALSA<-OSS emulation,ALSA sequencer,ALSA<-OSS sequencer
    
    Optimize the code when compiled without CONFIG_PROC_FS (in seq and oss
    emulation parts).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index b537a71e1e19..9cf20f045542 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -756,6 +756,7 @@ int snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop)
 
 /*----------------------------------------------------------------*/
 
+#ifdef CONFIG_PROC_FS
 /* exported to seq_info.c */
 void snd_seq_info_queues_read(struct snd_info_entry *entry, 
 			      struct snd_info_buffer *buffer)
@@ -789,3 +790,5 @@ void snd_seq_info_queues_read(struct snd_info_entry *entry,
 		queuefree(q);
 	}
 }
+#endif /* CONFIG_PROC_FS */
+

commit c7e0b5bf9fff1b726495081447c107a2333fb82c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:04:02 2005 +0100

    [ALSA] Remove xxx_t typedefs: Sequencer
    
    Modules: ALSA sequencer
    
    Remove xxx_t typedefs from the core sequencer codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 5f5c3cb37cbf..b537a71e1e19 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -29,7 +29,7 @@
  *  Aug. 30, 2000	Takashi Iwai
  *     - Queues are managed in static array again, but with better way.
  *       The API itself is identical.
- *     - The queue is locked when queue_t pinter is returned via
+ *     - The queue is locked when struct snd_seq_queue pointer is returned via
  *       queueptr().  This pointer *MUST* be released afterward by
  *       queuefree(ptr).
  *     - Addition of experimental sync support.
@@ -48,7 +48,7 @@
 #include "seq_info.h"
 
 /* list of allocated queues */
-static queue_t *queue_list[SNDRV_SEQ_MAX_QUEUES];
+static struct snd_seq_queue *queue_list[SNDRV_SEQ_MAX_QUEUES];
 static DEFINE_SPINLOCK(queue_list_lock);
 /* number of queues allocated */
 static int num_queues;
@@ -61,7 +61,7 @@ int snd_seq_queue_get_cur_queues(void)
 /*----------------------------------------------------------------*/
 
 /* assign queue id and insert to list */
-static int queue_list_add(queue_t *q)
+static int queue_list_add(struct snd_seq_queue *q)
 {
 	int i;
 	unsigned long flags;
@@ -80,9 +80,9 @@ static int queue_list_add(queue_t *q)
 	return -1;
 }
 
-static queue_t *queue_list_remove(int id, int client)
+static struct snd_seq_queue *queue_list_remove(int id, int client)
 {
-	queue_t *q;
+	struct snd_seq_queue *q;
 	unsigned long flags;
 
 	spin_lock_irqsave(&queue_list_lock, flags);
@@ -107,9 +107,9 @@ static queue_t *queue_list_remove(int id, int client)
 /*----------------------------------------------------------------*/
 
 /* create new queue (constructor) */
-static queue_t *queue_new(int owner, int locked)
+static struct snd_seq_queue *queue_new(int owner, int locked)
 {
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	q = kzalloc(sizeof(*q), GFP_KERNEL);
 	if (q == NULL) {
@@ -142,7 +142,7 @@ static queue_t *queue_new(int owner, int locked)
 }
 
 /* delete queue (destructor) */
-static void queue_delete(queue_t *q)
+static void queue_delete(struct snd_seq_queue *q)
 {
 	/* stop and release the timer */
 	snd_seq_timer_stop(q->timer);
@@ -187,7 +187,7 @@ void __exit snd_seq_queues_delete(void)
  */
 int snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)
 {
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	q = queue_new(client, locked);
 	if (q == NULL)
@@ -204,7 +204,7 @@ int snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)
 /* delete a queue - queue must be owned by the client */
 int snd_seq_queue_delete(int client, int queueid)
 {
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	if (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)
 		return -EINVAL;
@@ -218,9 +218,9 @@ int snd_seq_queue_delete(int client, int queueid)
 
 
 /* return pointer to queue structure for specified id */
-queue_t *queueptr(int queueid)
+struct snd_seq_queue *queueptr(int queueid)
 {
-	queue_t *q;
+	struct snd_seq_queue *q;
 	unsigned long flags;
 
 	if (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)
@@ -234,10 +234,10 @@ queue_t *queueptr(int queueid)
 }
 
 /* return the (first) queue matching with the specified name */
-queue_t *snd_seq_queue_find_name(char *name)
+struct snd_seq_queue *snd_seq_queue_find_name(char *name)
 {
 	int i;
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
 		if ((q = queueptr(i)) != NULL) {
@@ -252,10 +252,10 @@ queue_t *snd_seq_queue_find_name(char *name)
 
 /* -------------------------------------------------------- */
 
-void snd_seq_check_queue(queue_t *q, int atomic, int hop)
+void snd_seq_check_queue(struct snd_seq_queue *q, int atomic, int hop)
 {
 	unsigned long flags;
-	snd_seq_event_cell_t *cell;
+	struct snd_seq_event_cell *cell;
 
 	if (q == NULL)
 		return;
@@ -273,7 +273,8 @@ void snd_seq_check_queue(queue_t *q, int atomic, int hop)
       __again:
 	/* Process tick queue... */
 	while ((cell = snd_seq_prioq_cell_peek(q->tickq)) != NULL) {
-		if (snd_seq_compare_tick_time(&q->timer->tick.cur_tick, &cell->event.time.tick)) {
+		if (snd_seq_compare_tick_time(&q->timer->tick.cur_tick,
+					      &cell->event.time.tick)) {
 			cell = snd_seq_prioq_cell_out(q->tickq);
 			if (cell)
 				snd_seq_dispatch_event(cell, atomic, hop);
@@ -286,7 +287,8 @@ void snd_seq_check_queue(queue_t *q, int atomic, int hop)
 
 	/* Process time queue... */
 	while ((cell = snd_seq_prioq_cell_peek(q->timeq)) != NULL) {
-		if (snd_seq_compare_real_time(&q->timer->cur_time, &cell->event.time.time)) {
+		if (snd_seq_compare_real_time(&q->timer->cur_time,
+					      &cell->event.time.time)) {
 			cell = snd_seq_prioq_cell_out(q->timeq);
 			if (cell)
 				snd_seq_dispatch_event(cell, atomic, hop);
@@ -309,10 +311,10 @@ void snd_seq_check_queue(queue_t *q, int atomic, int hop)
 
 
 /* enqueue a event to singe queue */
-int snd_seq_enqueue_event(snd_seq_event_cell_t *cell, int atomic, int hop)
+int snd_seq_enqueue_event(struct snd_seq_event_cell *cell, int atomic, int hop)
 {
 	int dest, err;
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	snd_assert(cell != NULL, return -EINVAL);
 	dest = cell->event.queue;	/* destination queue */
@@ -327,7 +329,8 @@ int snd_seq_enqueue_event(snd_seq_event_cell_t *cell, int atomic, int hop)
 			break;
 
 		case SNDRV_SEQ_TIME_STAMP_REAL:
-			snd_seq_inc_real_time(&cell->event.time.time, &q->timer->cur_time);
+			snd_seq_inc_real_time(&cell->event.time.time,
+					      &q->timer->cur_time);
 			break;
 		}
 		cell->event.flags &= ~SNDRV_SEQ_TIME_MODE_MASK;
@@ -361,7 +364,7 @@ int snd_seq_enqueue_event(snd_seq_event_cell_t *cell, int atomic, int hop)
 
 /*----------------------------------------------------------------*/
 
-static inline int check_access(queue_t *q, int client)
+static inline int check_access(struct snd_seq_queue *q, int client)
 {
 	return (q->owner == client) || (!q->locked && !q->klocked);
 }
@@ -369,7 +372,7 @@ static inline int check_access(queue_t *q, int client)
 /* check if the client has permission to modify queue parameters.
  * if it does, lock the queue
  */
-static int queue_access_lock(queue_t *q, int client)
+static int queue_access_lock(struct snd_seq_queue *q, int client)
 {
 	unsigned long flags;
 	int access_ok;
@@ -383,7 +386,7 @@ static int queue_access_lock(queue_t *q, int client)
 }
 
 /* unlock the queue */
-static inline void queue_access_unlock(queue_t *q)
+static inline void queue_access_unlock(struct snd_seq_queue *q)
 {
 	unsigned long flags;
 
@@ -395,7 +398,7 @@ static inline void queue_access_unlock(queue_t *q)
 /* exported - only checking permission */
 int snd_seq_queue_check_access(int queueid, int client)
 {
-	queue_t *q = queueptr(queueid);
+	struct snd_seq_queue *q = queueptr(queueid);
 	int access_ok;
 	unsigned long flags;
 
@@ -415,7 +418,7 @@ int snd_seq_queue_check_access(int queueid, int client)
  */
 int snd_seq_queue_set_owner(int queueid, int client, int locked)
 {
-	queue_t *q = queueptr(queueid);
+	struct snd_seq_queue *q = queueptr(queueid);
 
 	if (q == NULL)
 		return -EINVAL;
@@ -443,8 +446,8 @@ int snd_seq_queue_set_owner(int queueid, int client, int locked)
 int snd_seq_queue_timer_open(int queueid)
 {
 	int result = 0;
-	queue_t *queue;
-	seq_timer_t *tmr;
+	struct snd_seq_queue *queue;
+	struct snd_seq_timer *tmr;
 
 	queue = queueptr(queueid);
 	if (queue == NULL)
@@ -463,8 +466,8 @@ int snd_seq_queue_timer_open(int queueid)
  */
 int snd_seq_queue_timer_close(int queueid)
 {
-	queue_t *queue;
-	seq_timer_t *tmr;
+	struct snd_seq_queue *queue;
+	struct snd_seq_timer *tmr;
 	int result = 0;
 
 	queue = queueptr(queueid);
@@ -477,9 +480,10 @@ int snd_seq_queue_timer_close(int queueid)
 }
 
 /* change queue tempo and ppq */
-int snd_seq_queue_timer_set_tempo(int queueid, int client, snd_seq_queue_tempo_t *info)
+int snd_seq_queue_timer_set_tempo(int queueid, int client,
+				  struct snd_seq_queue_tempo *info)
 {
-	queue_t *q = queueptr(queueid);
+	struct snd_seq_queue *q = queueptr(queueid);
 	int result;
 
 	if (q == NULL)
@@ -493,7 +497,8 @@ int snd_seq_queue_timer_set_tempo(int queueid, int client, snd_seq_queue_tempo_t
 	if (result >= 0)
 		result = snd_seq_timer_set_ppq(q->timer, info->ppq);
 	if (result >= 0 && info->skew_base > 0)
-		result = snd_seq_timer_set_skew(q->timer, info->skew_value, info->skew_base);
+		result = snd_seq_timer_set_skew(q->timer, info->skew_value,
+						info->skew_base);
 	queue_access_unlock(q);
 	queuefree(q);
 	return result;
@@ -506,7 +511,7 @@ int snd_seq_queue_timer_set_tempo(int queueid, int client, snd_seq_queue_tempo_t
  */
 int snd_seq_queue_use(int queueid, int client, int use)
 {
-	queue_t *queue;
+	struct snd_seq_queue *queue;
 
 	queue = queueptr(queueid);
 	if (queue == NULL)
@@ -538,7 +543,7 @@ int snd_seq_queue_use(int queueid, int client, int use)
  */
 int snd_seq_queue_is_used(int queueid, int client)
 {
-	queue_t *q;
+	struct snd_seq_queue *q;
 	int result;
 
 	q = queueptr(queueid);
@@ -559,7 +564,7 @@ void snd_seq_queue_client_termination(int client)
 {
 	unsigned long flags;
 	int i;
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
 		if ((q = queueptr(i)) == NULL)
@@ -584,7 +589,7 @@ void snd_seq_queue_client_termination(int client)
 void snd_seq_queue_client_leave(int client)
 {
 	int i;
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	/* delete own queues from queue list */
 	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
@@ -615,7 +620,7 @@ void snd_seq_queue_client_leave(int client)
 void snd_seq_queue_client_leave_cells(int client)
 {
 	int i;
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
 		if ((q = queueptr(i)) == NULL)
@@ -627,10 +632,10 @@ void snd_seq_queue_client_leave_cells(int client)
 }
 
 /* remove cells based on flush criteria */
-void snd_seq_queue_remove_cells(int client, snd_seq_remove_events_t *info)
+void snd_seq_queue_remove_cells(int client, struct snd_seq_remove_events *info)
 {
 	int i;
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
 		if ((q = queueptr(i)) == NULL)
@@ -650,9 +655,10 @@ void snd_seq_queue_remove_cells(int client, snd_seq_remove_events_t *info)
 /*
  * send events to all subscribed ports
  */
-static void queue_broadcast_event(queue_t *q, snd_seq_event_t *ev, int atomic, int hop)
+static void queue_broadcast_event(struct snd_seq_queue *q, struct snd_seq_event *ev,
+				  int atomic, int hop)
 {
-	snd_seq_event_t sev;
+	struct snd_seq_event sev;
 
 	sev = *ev;
 	
@@ -672,7 +678,8 @@ static void queue_broadcast_event(queue_t *q, snd_seq_event_t *ev, int atomic, i
  * process a received queue-control event.
  * this function is exported for seq_sync.c.
  */
-static void snd_seq_queue_process_event(queue_t *q, snd_seq_event_t *ev,
+static void snd_seq_queue_process_event(struct snd_seq_queue *q,
+					struct snd_seq_event *ev,
 					int atomic, int hop)
 {
 	switch (ev->type) {
@@ -724,9 +731,9 @@ static void snd_seq_queue_process_event(queue_t *q, snd_seq_event_t *ev,
  * Queue control via timer control port:
  * this function is exported as a callback of timer port.
  */
-int snd_seq_control_queue(snd_seq_event_t *ev, int atomic, int hop)
+int snd_seq_control_queue(struct snd_seq_event *ev, int atomic, int hop)
 {
-	queue_t *q;
+	struct snd_seq_queue *q;
 
 	snd_assert(ev != NULL, return -EINVAL);
 	q = queueptr(ev->data.queue.queue);
@@ -750,12 +757,12 @@ int snd_seq_control_queue(snd_seq_event_t *ev, int atomic, int hop)
 /*----------------------------------------------------------------*/
 
 /* exported to seq_info.c */
-void snd_seq_info_queues_read(snd_info_entry_t *entry, 
-			      snd_info_buffer_t * buffer)
+void snd_seq_info_queues_read(struct snd_info_entry *entry, 
+			      struct snd_info_buffer *buffer)
 {
 	int i, bpm;
-	queue_t *q;
-	seq_timer_t *tmr;
+	struct snd_seq_queue *q;
+	struct snd_seq_timer *tmr;
 
 	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
 		if ((q = queueptr(i)) == NULL)

commit ecca82b4b447f8df73c807a018dac3e2863912d9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:49 2005 +0200

    [ALSA] Replace with kzalloc() - seq stuff
    
    ALSA sequencer,Instrument layer,ALSA<-OSS sequencer
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 98de2e711fde..5f5c3cb37cbf 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -111,7 +111,7 @@ static queue_t *queue_new(int owner, int locked)
 {
 	queue_t *q;
 
-	q = kcalloc(1, sizeof(*q), GFP_KERNEL);
+	q = kzalloc(sizeof(*q), GFP_KERNEL);
 	if (q == NULL) {
 		snd_printd("malloc failed for snd_seq_queue_new()\n");
 		return NULL;

commit 123992f728785e05f385d23893bd5ec69871aeb4
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed May 18 18:02:04 2005 +0200

    [ALSA] sound/core/: possible cleanups
    
    PCM Midlevel,ALSA Core,Timer Midlevel,ALSA sequencer,Virtual Midi
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global functions
    - remove the following unneeded EXPORT_SYMBOL's
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index 3afc7cc0c9a7..98de2e711fde 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -672,7 +672,8 @@ static void queue_broadcast_event(queue_t *q, snd_seq_event_t *ev, int atomic, i
  * process a received queue-control event.
  * this function is exported for seq_sync.c.
  */
-void snd_seq_queue_process_event(queue_t *q, snd_seq_event_t *ev, int atomic, int hop)
+static void snd_seq_queue_process_event(queue_t *q, snd_seq_event_t *ev,
+					int atomic, int hop)
 {
 	switch (ev->type) {
 	case SNDRV_SEQ_EVENT_START:

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
new file mode 100644
index 000000000000..3afc7cc0c9a7
--- /dev/null
+++ b/sound/core/seq/seq_queue.c
@@ -0,0 +1,783 @@
+/*
+ *   ALSA sequencer Timing queue handling
+ *   Copyright (c) 1998-1999 by Frank van de Pol <fvdpol@coil.demon.nl>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * MAJOR CHANGES
+ *   Nov. 13, 1999	Takashi Iwai <iwai@ww.uni-erlangen.de>
+ *     - Queues are allocated dynamically via ioctl.
+ *     - When owner client is deleted, all owned queues are deleted, too.
+ *     - Owner of unlocked queue is kept unmodified even if it is
+ *	 manipulated by other clients.
+ *     - Owner field in SET_QUEUE_OWNER ioctl must be identical with the
+ *       caller client.  i.e. Changing owner to a third client is not
+ *       allowed.
+ *
+ *  Aug. 30, 2000	Takashi Iwai
+ *     - Queues are managed in static array again, but with better way.
+ *       The API itself is identical.
+ *     - The queue is locked when queue_t pinter is returned via
+ *       queueptr().  This pointer *MUST* be released afterward by
+ *       queuefree(ptr).
+ *     - Addition of experimental sync support.
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+
+#include "seq_memory.h"
+#include "seq_queue.h"
+#include "seq_clientmgr.h"
+#include "seq_fifo.h"
+#include "seq_timer.h"
+#include "seq_info.h"
+
+/* list of allocated queues */
+static queue_t *queue_list[SNDRV_SEQ_MAX_QUEUES];
+static DEFINE_SPINLOCK(queue_list_lock);
+/* number of queues allocated */
+static int num_queues;
+
+int snd_seq_queue_get_cur_queues(void)
+{
+	return num_queues;
+}
+
+/*----------------------------------------------------------------*/
+
+/* assign queue id and insert to list */
+static int queue_list_add(queue_t *q)
+{
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&queue_list_lock, flags);
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if (! queue_list[i]) {
+			queue_list[i] = q;
+			q->queue = i;
+			num_queues++;
+			spin_unlock_irqrestore(&queue_list_lock, flags);
+			return i;
+		}
+	}
+	spin_unlock_irqrestore(&queue_list_lock, flags);
+	return -1;
+}
+
+static queue_t *queue_list_remove(int id, int client)
+{
+	queue_t *q;
+	unsigned long flags;
+
+	spin_lock_irqsave(&queue_list_lock, flags);
+	q = queue_list[id];
+	if (q) {
+		spin_lock(&q->owner_lock);
+		if (q->owner == client) {
+			/* found */
+			q->klocked = 1;
+			spin_unlock(&q->owner_lock);
+			queue_list[id] = NULL;
+			num_queues--;
+			spin_unlock_irqrestore(&queue_list_lock, flags);
+			return q;
+		}
+		spin_unlock(&q->owner_lock);
+	}
+	spin_unlock_irqrestore(&queue_list_lock, flags);
+	return NULL;
+}
+
+/*----------------------------------------------------------------*/
+
+/* create new queue (constructor) */
+static queue_t *queue_new(int owner, int locked)
+{
+	queue_t *q;
+
+	q = kcalloc(1, sizeof(*q), GFP_KERNEL);
+	if (q == NULL) {
+		snd_printd("malloc failed for snd_seq_queue_new()\n");
+		return NULL;
+	}
+
+	spin_lock_init(&q->owner_lock);
+	spin_lock_init(&q->check_lock);
+	init_MUTEX(&q->timer_mutex);
+	snd_use_lock_init(&q->use_lock);
+	q->queue = -1;
+
+	q->tickq = snd_seq_prioq_new();
+	q->timeq = snd_seq_prioq_new();
+	q->timer = snd_seq_timer_new();
+	if (q->tickq == NULL || q->timeq == NULL || q->timer == NULL) {
+		snd_seq_prioq_delete(&q->tickq);
+		snd_seq_prioq_delete(&q->timeq);
+		snd_seq_timer_delete(&q->timer);
+		kfree(q);
+		return NULL;
+	}
+
+	q->owner = owner;
+	q->locked = locked;
+	q->klocked = 0;
+
+	return q;
+}
+
+/* delete queue (destructor) */
+static void queue_delete(queue_t *q)
+{
+	/* stop and release the timer */
+	snd_seq_timer_stop(q->timer);
+	snd_seq_timer_close(q);
+	/* wait until access free */
+	snd_use_lock_sync(&q->use_lock);
+	/* release resources... */
+	snd_seq_prioq_delete(&q->tickq);
+	snd_seq_prioq_delete(&q->timeq);
+	snd_seq_timer_delete(&q->timer);
+
+	kfree(q);
+}
+
+
+/*----------------------------------------------------------------*/
+
+/* setup queues */
+int __init snd_seq_queues_init(void)
+{
+	/*
+	memset(queue_list, 0, sizeof(queue_list));
+	num_queues = 0;
+	*/
+	return 0;
+}
+
+/* delete all existing queues */
+void __exit snd_seq_queues_delete(void)
+{
+	int i;
+
+	/* clear list */
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if (queue_list[i])
+			queue_delete(queue_list[i]);
+	}
+}
+
+/* allocate a new queue -
+ * return queue index value or negative value for error
+ */
+int snd_seq_queue_alloc(int client, int locked, unsigned int info_flags)
+{
+	queue_t *q;
+
+	q = queue_new(client, locked);
+	if (q == NULL)
+		return -ENOMEM;
+	q->info_flags = info_flags;
+	if (queue_list_add(q) < 0) {
+		queue_delete(q);
+		return -ENOMEM;
+	}
+	snd_seq_queue_use(q->queue, client, 1); /* use this queue */
+	return q->queue;
+}
+
+/* delete a queue - queue must be owned by the client */
+int snd_seq_queue_delete(int client, int queueid)
+{
+	queue_t *q;
+
+	if (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)
+		return -EINVAL;
+	q = queue_list_remove(queueid, client);
+	if (q == NULL)
+		return -EINVAL;
+	queue_delete(q);
+
+	return 0;
+}
+
+
+/* return pointer to queue structure for specified id */
+queue_t *queueptr(int queueid)
+{
+	queue_t *q;
+	unsigned long flags;
+
+	if (queueid < 0 || queueid >= SNDRV_SEQ_MAX_QUEUES)
+		return NULL;
+	spin_lock_irqsave(&queue_list_lock, flags);
+	q = queue_list[queueid];
+	if (q)
+		snd_use_lock_use(&q->use_lock);
+	spin_unlock_irqrestore(&queue_list_lock, flags);
+	return q;
+}
+
+/* return the (first) queue matching with the specified name */
+queue_t *snd_seq_queue_find_name(char *name)
+{
+	int i;
+	queue_t *q;
+
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if ((q = queueptr(i)) != NULL) {
+			if (strncmp(q->name, name, sizeof(q->name)) == 0)
+				return q;
+			queuefree(q);
+		}
+	}
+	return NULL;
+}
+
+
+/* -------------------------------------------------------- */
+
+void snd_seq_check_queue(queue_t *q, int atomic, int hop)
+{
+	unsigned long flags;
+	snd_seq_event_cell_t *cell;
+
+	if (q == NULL)
+		return;
+
+	/* make this function non-reentrant */
+	spin_lock_irqsave(&q->check_lock, flags);
+	if (q->check_blocked) {
+		q->check_again = 1;
+		spin_unlock_irqrestore(&q->check_lock, flags);
+		return;		/* other thread is already checking queues */
+	}
+	q->check_blocked = 1;
+	spin_unlock_irqrestore(&q->check_lock, flags);
+
+      __again:
+	/* Process tick queue... */
+	while ((cell = snd_seq_prioq_cell_peek(q->tickq)) != NULL) {
+		if (snd_seq_compare_tick_time(&q->timer->tick.cur_tick, &cell->event.time.tick)) {
+			cell = snd_seq_prioq_cell_out(q->tickq);
+			if (cell)
+				snd_seq_dispatch_event(cell, atomic, hop);
+		} else {
+			/* event remains in the queue */
+			break;
+		}
+	}
+
+
+	/* Process time queue... */
+	while ((cell = snd_seq_prioq_cell_peek(q->timeq)) != NULL) {
+		if (snd_seq_compare_real_time(&q->timer->cur_time, &cell->event.time.time)) {
+			cell = snd_seq_prioq_cell_out(q->timeq);
+			if (cell)
+				snd_seq_dispatch_event(cell, atomic, hop);
+		} else {
+			/* event remains in the queue */
+			break;
+		}
+	}
+
+	/* free lock */
+	spin_lock_irqsave(&q->check_lock, flags);
+	if (q->check_again) {
+		q->check_again = 0;
+		spin_unlock_irqrestore(&q->check_lock, flags);
+		goto __again;
+	}
+	q->check_blocked = 0;
+	spin_unlock_irqrestore(&q->check_lock, flags);
+}
+
+
+/* enqueue a event to singe queue */
+int snd_seq_enqueue_event(snd_seq_event_cell_t *cell, int atomic, int hop)
+{
+	int dest, err;
+	queue_t *q;
+
+	snd_assert(cell != NULL, return -EINVAL);
+	dest = cell->event.queue;	/* destination queue */
+	q = queueptr(dest);
+	if (q == NULL)
+		return -EINVAL;
+	/* handle relative time stamps, convert them into absolute */
+	if ((cell->event.flags & SNDRV_SEQ_TIME_MODE_MASK) == SNDRV_SEQ_TIME_MODE_REL) {
+		switch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {
+		case SNDRV_SEQ_TIME_STAMP_TICK:
+			cell->event.time.tick += q->timer->tick.cur_tick;
+			break;
+
+		case SNDRV_SEQ_TIME_STAMP_REAL:
+			snd_seq_inc_real_time(&cell->event.time.time, &q->timer->cur_time);
+			break;
+		}
+		cell->event.flags &= ~SNDRV_SEQ_TIME_MODE_MASK;
+		cell->event.flags |= SNDRV_SEQ_TIME_MODE_ABS;
+	}
+	/* enqueue event in the real-time or midi queue */
+	switch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {
+	case SNDRV_SEQ_TIME_STAMP_TICK:
+		err = snd_seq_prioq_cell_in(q->tickq, cell);
+		break;
+
+	case SNDRV_SEQ_TIME_STAMP_REAL:
+	default:
+		err = snd_seq_prioq_cell_in(q->timeq, cell);
+		break;
+	}
+
+	if (err < 0) {
+		queuefree(q); /* unlock */
+		return err;
+	}
+
+	/* trigger dispatching */
+	snd_seq_check_queue(q, atomic, hop);
+
+	queuefree(q); /* unlock */
+
+	return 0;
+}
+
+
+/*----------------------------------------------------------------*/
+
+static inline int check_access(queue_t *q, int client)
+{
+	return (q->owner == client) || (!q->locked && !q->klocked);
+}
+
+/* check if the client has permission to modify queue parameters.
+ * if it does, lock the queue
+ */
+static int queue_access_lock(queue_t *q, int client)
+{
+	unsigned long flags;
+	int access_ok;
+	
+	spin_lock_irqsave(&q->owner_lock, flags);
+	access_ok = check_access(q, client);
+	if (access_ok)
+		q->klocked = 1;
+	spin_unlock_irqrestore(&q->owner_lock, flags);
+	return access_ok;
+}
+
+/* unlock the queue */
+static inline void queue_access_unlock(queue_t *q)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&q->owner_lock, flags);
+	q->klocked = 0;
+	spin_unlock_irqrestore(&q->owner_lock, flags);
+}
+
+/* exported - only checking permission */
+int snd_seq_queue_check_access(int queueid, int client)
+{
+	queue_t *q = queueptr(queueid);
+	int access_ok;
+	unsigned long flags;
+
+	if (! q)
+		return 0;
+	spin_lock_irqsave(&q->owner_lock, flags);
+	access_ok = check_access(q, client);
+	spin_unlock_irqrestore(&q->owner_lock, flags);
+	queuefree(q);
+	return access_ok;
+}
+
+/*----------------------------------------------------------------*/
+
+/*
+ * change queue's owner and permission
+ */
+int snd_seq_queue_set_owner(int queueid, int client, int locked)
+{
+	queue_t *q = queueptr(queueid);
+
+	if (q == NULL)
+		return -EINVAL;
+
+	if (! queue_access_lock(q, client)) {
+		queuefree(q);
+		return -EPERM;
+	}
+
+	q->locked = locked ? 1 : 0;
+	q->owner = client;
+	queue_access_unlock(q);
+	queuefree(q);
+
+	return 0;
+}
+
+
+/*----------------------------------------------------------------*/
+
+/* open timer -
+ * q->use mutex should be down before calling this function to avoid
+ * confliction with snd_seq_queue_use()
+ */
+int snd_seq_queue_timer_open(int queueid)
+{
+	int result = 0;
+	queue_t *queue;
+	seq_timer_t *tmr;
+
+	queue = queueptr(queueid);
+	if (queue == NULL)
+		return -EINVAL;
+	tmr = queue->timer;
+	if ((result = snd_seq_timer_open(queue)) < 0) {
+		snd_seq_timer_defaults(tmr);
+		result = snd_seq_timer_open(queue);
+	}
+	queuefree(queue);
+	return result;
+}
+
+/* close timer -
+ * q->use mutex should be down before calling this function
+ */
+int snd_seq_queue_timer_close(int queueid)
+{
+	queue_t *queue;
+	seq_timer_t *tmr;
+	int result = 0;
+
+	queue = queueptr(queueid);
+	if (queue == NULL)
+		return -EINVAL;
+	tmr = queue->timer;
+	snd_seq_timer_close(queue);
+	queuefree(queue);
+	return result;
+}
+
+/* change queue tempo and ppq */
+int snd_seq_queue_timer_set_tempo(int queueid, int client, snd_seq_queue_tempo_t *info)
+{
+	queue_t *q = queueptr(queueid);
+	int result;
+
+	if (q == NULL)
+		return -EINVAL;
+	if (! queue_access_lock(q, client)) {
+		queuefree(q);
+		return -EPERM;
+	}
+
+	result = snd_seq_timer_set_tempo(q->timer, info->tempo);
+	if (result >= 0)
+		result = snd_seq_timer_set_ppq(q->timer, info->ppq);
+	if (result >= 0 && info->skew_base > 0)
+		result = snd_seq_timer_set_skew(q->timer, info->skew_value, info->skew_base);
+	queue_access_unlock(q);
+	queuefree(q);
+	return result;
+}
+
+
+/* use or unuse this queue -
+ * if it is the first client, starts the timer.
+ * if it is not longer used by any clients, stop the timer.
+ */
+int snd_seq_queue_use(int queueid, int client, int use)
+{
+	queue_t *queue;
+
+	queue = queueptr(queueid);
+	if (queue == NULL)
+		return -EINVAL;
+	down(&queue->timer_mutex);
+	if (use) {
+		if (!test_and_set_bit(client, queue->clients_bitmap))
+			queue->clients++;
+	} else {
+		if (test_and_clear_bit(client, queue->clients_bitmap))
+			queue->clients--;
+	}
+	if (queue->clients) {
+		if (use && queue->clients == 1)
+			snd_seq_timer_defaults(queue->timer);
+		snd_seq_timer_open(queue);
+	} else {
+		snd_seq_timer_close(queue);
+	}
+	up(&queue->timer_mutex);
+	queuefree(queue);
+	return 0;
+}
+
+/*
+ * check if queue is used by the client
+ * return negative value if the queue is invalid.
+ * return 0 if not used, 1 if used.
+ */
+int snd_seq_queue_is_used(int queueid, int client)
+{
+	queue_t *q;
+	int result;
+
+	q = queueptr(queueid);
+	if (q == NULL)
+		return -EINVAL; /* invalid queue */
+	result = test_bit(client, q->clients_bitmap) ? 1 : 0;
+	queuefree(q);
+	return result;
+}
+
+
+/*----------------------------------------------------------------*/
+
+/* notification that client has left the system -
+ * stop the timer on all queues owned by this client
+ */
+void snd_seq_queue_client_termination(int client)
+{
+	unsigned long flags;
+	int i;
+	queue_t *q;
+
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if ((q = queueptr(i)) == NULL)
+			continue;
+		spin_lock_irqsave(&q->owner_lock, flags);
+		if (q->owner == client)
+			q->klocked = 1;
+		spin_unlock_irqrestore(&q->owner_lock, flags);
+		if (q->owner == client) {
+			if (q->timer->running)
+				snd_seq_timer_stop(q->timer);
+			snd_seq_timer_reset(q->timer);
+		}
+		queuefree(q);
+	}
+}
+
+/* final stage notification -
+ * remove cells for no longer exist client (for non-owned queue)
+ * or delete this queue (for owned queue)
+ */
+void snd_seq_queue_client_leave(int client)
+{
+	int i;
+	queue_t *q;
+
+	/* delete own queues from queue list */
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if ((q = queue_list_remove(i, client)) != NULL)
+			queue_delete(q);
+	}
+
+	/* remove cells from existing queues -
+	 * they are not owned by this client
+	 */
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if ((q = queueptr(i)) == NULL)
+			continue;
+		if (test_bit(client, q->clients_bitmap)) {
+			snd_seq_prioq_leave(q->tickq, client, 0);
+			snd_seq_prioq_leave(q->timeq, client, 0);
+			snd_seq_queue_use(q->queue, client, 0);
+		}
+		queuefree(q);
+	}
+}
+
+
+
+/*----------------------------------------------------------------*/
+
+/* remove cells from all queues */
+void snd_seq_queue_client_leave_cells(int client)
+{
+	int i;
+	queue_t *q;
+
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if ((q = queueptr(i)) == NULL)
+			continue;
+		snd_seq_prioq_leave(q->tickq, client, 0);
+		snd_seq_prioq_leave(q->timeq, client, 0);
+		queuefree(q);
+	}
+}
+
+/* remove cells based on flush criteria */
+void snd_seq_queue_remove_cells(int client, snd_seq_remove_events_t *info)
+{
+	int i;
+	queue_t *q;
+
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if ((q = queueptr(i)) == NULL)
+			continue;
+		if (test_bit(client, q->clients_bitmap) &&
+		    (! (info->remove_mode & SNDRV_SEQ_REMOVE_DEST) ||
+		     q->queue == info->queue)) {
+			snd_seq_prioq_remove_events(q->tickq, client, info);
+			snd_seq_prioq_remove_events(q->timeq, client, info);
+		}
+		queuefree(q);
+	}
+}
+
+/*----------------------------------------------------------------*/
+
+/*
+ * send events to all subscribed ports
+ */
+static void queue_broadcast_event(queue_t *q, snd_seq_event_t *ev, int atomic, int hop)
+{
+	snd_seq_event_t sev;
+
+	sev = *ev;
+	
+	sev.flags = SNDRV_SEQ_TIME_STAMP_TICK|SNDRV_SEQ_TIME_MODE_ABS;
+	sev.time.tick = q->timer->tick.cur_tick;
+	sev.queue = q->queue;
+	sev.data.queue.queue = q->queue;
+
+	/* broadcast events from Timer port */
+	sev.source.client = SNDRV_SEQ_CLIENT_SYSTEM;
+	sev.source.port = SNDRV_SEQ_PORT_SYSTEM_TIMER;
+	sev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;
+	snd_seq_kernel_client_dispatch(SNDRV_SEQ_CLIENT_SYSTEM, &sev, atomic, hop);
+}
+
+/*
+ * process a received queue-control event.
+ * this function is exported for seq_sync.c.
+ */
+void snd_seq_queue_process_event(queue_t *q, snd_seq_event_t *ev, int atomic, int hop)
+{
+	switch (ev->type) {
+	case SNDRV_SEQ_EVENT_START:
+		snd_seq_prioq_leave(q->tickq, ev->source.client, 1);
+		snd_seq_prioq_leave(q->timeq, ev->source.client, 1);
+		if (! snd_seq_timer_start(q->timer))
+			queue_broadcast_event(q, ev, atomic, hop);
+		break;
+
+	case SNDRV_SEQ_EVENT_CONTINUE:
+		if (! snd_seq_timer_continue(q->timer))
+			queue_broadcast_event(q, ev, atomic, hop);
+		break;
+
+	case SNDRV_SEQ_EVENT_STOP:
+		snd_seq_timer_stop(q->timer);
+		queue_broadcast_event(q, ev, atomic, hop);
+		break;
+
+	case SNDRV_SEQ_EVENT_TEMPO:
+		snd_seq_timer_set_tempo(q->timer, ev->data.queue.param.value);
+		queue_broadcast_event(q, ev, atomic, hop);
+		break;
+
+	case SNDRV_SEQ_EVENT_SETPOS_TICK:
+		if (snd_seq_timer_set_position_tick(q->timer, ev->data.queue.param.time.tick) == 0) {
+			queue_broadcast_event(q, ev, atomic, hop);
+		}
+		break;
+
+	case SNDRV_SEQ_EVENT_SETPOS_TIME:
+		if (snd_seq_timer_set_position_time(q->timer, ev->data.queue.param.time.time) == 0) {
+			queue_broadcast_event(q, ev, atomic, hop);
+		}
+		break;
+	case SNDRV_SEQ_EVENT_QUEUE_SKEW:
+		if (snd_seq_timer_set_skew(q->timer,
+					   ev->data.queue.param.skew.value,
+					   ev->data.queue.param.skew.base) == 0) {
+			queue_broadcast_event(q, ev, atomic, hop);
+		}
+		break;
+	}
+}
+
+
+/*
+ * Queue control via timer control port:
+ * this function is exported as a callback of timer port.
+ */
+int snd_seq_control_queue(snd_seq_event_t *ev, int atomic, int hop)
+{
+	queue_t *q;
+
+	snd_assert(ev != NULL, return -EINVAL);
+	q = queueptr(ev->data.queue.queue);
+
+	if (q == NULL)
+		return -EINVAL;
+
+	if (! queue_access_lock(q, ev->source.client)) {
+		queuefree(q);
+		return -EPERM;
+	}
+
+	snd_seq_queue_process_event(q, ev, atomic, hop);
+
+	queue_access_unlock(q);
+	queuefree(q);
+	return 0;
+}
+
+
+/*----------------------------------------------------------------*/
+
+/* exported to seq_info.c */
+void snd_seq_info_queues_read(snd_info_entry_t *entry, 
+			      snd_info_buffer_t * buffer)
+{
+	int i, bpm;
+	queue_t *q;
+	seq_timer_t *tmr;
+
+	for (i = 0; i < SNDRV_SEQ_MAX_QUEUES; i++) {
+		if ((q = queueptr(i)) == NULL)
+			continue;
+
+		tmr = q->timer;
+		if (tmr->tempo)
+			bpm = 60000000 / tmr->tempo;
+		else
+			bpm = 0;
+
+		snd_iprintf(buffer, "queue %d: [%s]\n", q->queue, q->name);
+		snd_iprintf(buffer, "owned by client    : %d\n", q->owner);
+		snd_iprintf(buffer, "lock status        : %s\n", q->locked ? "Locked" : "Free");
+		snd_iprintf(buffer, "queued time events : %d\n", snd_seq_prioq_avail(q->timeq));
+		snd_iprintf(buffer, "queued tick events : %d\n", snd_seq_prioq_avail(q->tickq));
+		snd_iprintf(buffer, "timer state        : %s\n", tmr->running ? "Running" : "Stopped");
+		snd_iprintf(buffer, "timer PPQ          : %d\n", tmr->ppq);
+		snd_iprintf(buffer, "current tempo      : %d\n", tmr->tempo);
+		snd_iprintf(buffer, "current BPM        : %d\n", bpm);
+		snd_iprintf(buffer, "current time       : %d.%09d s\n", tmr->cur_time.tv_sec, tmr->cur_time.tv_nsec);
+		snd_iprintf(buffer, "current tick       : %d\n", tmr->tick.cur_tick);
+		snd_iprintf(buffer, "\n");
+		queuefree(q);
+	}
+}
