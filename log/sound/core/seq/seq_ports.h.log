commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/seq/seq_ports.h b/sound/core/seq/seq_ports.h
index 06003b36652e..b1f2c4943174 100644
--- a/sound/core/seq/seq_ports.h
+++ b/sound/core/seq/seq_ports.h
@@ -1,22 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *   ALSA sequencer Ports 
  *   Copyright (c) 1998 by Frank van de Pol <fvdpol@coil.demon.nl>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 #ifndef __SND_SEQ_PORTS_H
 #define __SND_SEQ_PORTS_H

commit 2eabc5ec8ab4d4748a82050dfcb994119b983750
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 9 18:04:17 2019 +0200

    ALSA: seq: Fix race of get-subscription call vs port-delete ioctls
    
    The snd_seq_ioctl_get_subscription() retrieves the port subscriber
    information as a pointer, while the object isn't protected, hence it
    may be deleted before the actual reference.  This race was spotted by
    syzkaller and may lead to a UAF.
    
    The fix is simply copying the data in the lookup function that
    performs in the rwsem to protect against the deletion.
    
    Reported-by: syzbot+9437020c82413d00222d@syzkaller.appspotmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_ports.h b/sound/core/seq/seq_ports.h
index 26bd71f36c41..06003b36652e 100644
--- a/sound/core/seq/seq_ports.h
+++ b/sound/core/seq/seq_ports.h
@@ -135,7 +135,8 @@ int snd_seq_port_subscribe(struct snd_seq_client_port *port,
 			   struct snd_seq_port_subscribe *info);
 
 /* get matched subscriber */
-struct snd_seq_subscribers *snd_seq_port_get_subscription(struct snd_seq_port_subs_info *src_grp,
-							  struct snd_seq_addr *dest_addr);
+int snd_seq_port_get_subscription(struct snd_seq_port_subs_info *src_grp,
+				  struct snd_seq_addr *dest_addr,
+				  struct snd_seq_port_subscribe *subs);
 
 #endif

commit a55bdf1ec5945050bfce9c3b2c3d8b70e8fd01a1
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Jan 25 14:36:27 2015 +0100

    ALSA: seq: remove unused callback_all field
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_ports.h b/sound/core/seq/seq_ports.h
index 9d7117118ba4..26bd71f36c41 100644
--- a/sound/core/seq/seq_ports.h
+++ b/sound/core/seq/seq_ports.h
@@ -73,7 +73,6 @@ struct snd_seq_client_port {
 			   int atomic, int hop);
 	void (*private_free)(void *private_data);
 	void *private_data;
-	unsigned int callback_all : 1;
 	unsigned int closing : 1;
 	unsigned int timestamping: 1;
 	unsigned int time_real: 1;

commit c7e0b5bf9fff1b726495081447c107a2333fb82c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:04:02 2005 +0100

    [ALSA] Remove xxx_t typedefs: Sequencer
    
    Modules: ALSA sequencer
    
    Remove xxx_t typedefs from the core sequencer codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/seq/seq_ports.h b/sound/core/seq/seq_ports.h
index 89fd4416f6fa..9d7117118ba4 100644
--- a/sound/core/seq/seq_ports.h
+++ b/sound/core/seq/seq_ports.h
@@ -40,37 +40,38 @@
  
 */
 
-typedef struct subscribers_t {
-	snd_seq_port_subscribe_t info;	/* additional info */
+struct snd_seq_subscribers {
+	struct snd_seq_port_subscribe info;	/* additional info */
 	struct list_head src_list;	/* link of sources */
 	struct list_head dest_list;	/* link of destinations */
 	atomic_t ref_count;
-} subscribers_t;
+};
 
-typedef struct port_subs_info_t {
+struct snd_seq_port_subs_info {
 	struct list_head list_head;	/* list of subscribed ports */
 	unsigned int count;		/* count of subscribers */
 	unsigned int exclusive: 1;	/* exclusive mode */
 	struct rw_semaphore list_mutex;
 	rwlock_t list_lock;
-	snd_seq_kernel_port_open_t *open;
-	snd_seq_kernel_port_close_t *close;
-} port_subs_info_t;
+	int (*open)(void *private_data, struct snd_seq_port_subscribe *info);
+	int (*close)(void *private_data, struct snd_seq_port_subscribe *info);
+};
 
-typedef struct client_port_t {
+struct snd_seq_client_port {
 
-	snd_seq_addr_t addr;		/* client/port number */
+	struct snd_seq_addr addr;	/* client/port number */
 	struct module *owner;		/* owner of this port */
 	char name[64];			/* port name */	
 	struct list_head list;		/* port list */
 	snd_use_lock_t use_lock;
 
 	/* subscribers */
-	port_subs_info_t c_src;		/* read (sender) list */
-	port_subs_info_t c_dest;	/* write (dest) list */
+	struct snd_seq_port_subs_info c_src;	/* read (sender) list */
+	struct snd_seq_port_subs_info c_dest;	/* write (dest) list */
 
-	snd_seq_kernel_port_input_t *event_input;
-	snd_seq_kernel_port_private_free_t *private_free;
+	int (*event_input)(struct snd_seq_event *ev, int direct, void *private_data,
+			   int atomic, int hop);
+	void (*private_free)(void *private_data);
 	void *private_data;
 	unsigned int callback_all : 1;
 	unsigned int closing : 1;
@@ -87,42 +88,55 @@ typedef struct client_port_t {
 	int midi_voices;
 	int synth_voices;
 		
-} client_port_t;
+};
+
+struct snd_seq_client;
 
 /* return pointer to port structure and lock port */
-client_port_t *snd_seq_port_use_ptr(client_t *client, int num);
+struct snd_seq_client_port *snd_seq_port_use_ptr(struct snd_seq_client *client, int num);
 
 /* search for next port - port is locked if found */
-client_port_t *snd_seq_port_query_nearest(client_t *client, snd_seq_port_info_t *pinfo);
+struct snd_seq_client_port *snd_seq_port_query_nearest(struct snd_seq_client *client,
+						       struct snd_seq_port_info *pinfo);
 
 /* unlock the port */
 #define snd_seq_port_unlock(port) snd_use_lock_free(&(port)->use_lock)
 
 /* create a port, port number is returned (-1 on failure) */
-client_port_t *snd_seq_create_port(client_t *client, int port_index);
+struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client, int port_index);
 
 /* delete a port */
-int snd_seq_delete_port(client_t *client, int port);
+int snd_seq_delete_port(struct snd_seq_client *client, int port);
 
 /* delete all ports */
-int snd_seq_delete_all_ports(client_t *client);
+int snd_seq_delete_all_ports(struct snd_seq_client *client);
 
 /* set port info fields */
-int snd_seq_set_port_info(client_port_t *port, snd_seq_port_info_t *info);
+int snd_seq_set_port_info(struct snd_seq_client_port *port,
+			  struct snd_seq_port_info *info);
 
 /* get port info fields */
-int snd_seq_get_port_info(client_port_t *port, snd_seq_port_info_t *info);
+int snd_seq_get_port_info(struct snd_seq_client_port *port,
+			  struct snd_seq_port_info *info);
 
 /* add subscriber to subscription list */
-int snd_seq_port_connect(client_t *caller, client_t *s, client_port_t *sp, client_t *d, client_port_t *dp, snd_seq_port_subscribe_t *info);
+int snd_seq_port_connect(struct snd_seq_client *caller,
+			 struct snd_seq_client *s, struct snd_seq_client_port *sp,
+			 struct snd_seq_client *d, struct snd_seq_client_port *dp,
+			 struct snd_seq_port_subscribe *info);
 
 /* remove subscriber from subscription list */ 
-int snd_seq_port_disconnect(client_t *caller, client_t *s, client_port_t *sp, client_t *d, client_port_t *dp, snd_seq_port_subscribe_t *info);
+int snd_seq_port_disconnect(struct snd_seq_client *caller,
+			    struct snd_seq_client *s, struct snd_seq_client_port *sp,
+			    struct snd_seq_client *d, struct snd_seq_client_port *dp,
+			    struct snd_seq_port_subscribe *info);
 
 /* subscribe port */
-int snd_seq_port_subscribe(client_port_t *port, snd_seq_port_subscribe_t *info);
+int snd_seq_port_subscribe(struct snd_seq_client_port *port,
+			   struct snd_seq_port_subscribe *info);
 
 /* get matched subscriber */
-subscribers_t *snd_seq_port_get_subscription(port_subs_info_t *src_grp, snd_seq_addr_t *dest_addr);
+struct snd_seq_subscribers *snd_seq_port_get_subscription(struct snd_seq_port_subs_info *src_grp,
+							  struct snd_seq_addr *dest_addr);
 
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/seq/seq_ports.h b/sound/core/seq/seq_ports.h
new file mode 100644
index 000000000000..89fd4416f6fa
--- /dev/null
+++ b/sound/core/seq/seq_ports.h
@@ -0,0 +1,128 @@
+/*
+ *   ALSA sequencer Ports 
+ *   Copyright (c) 1998 by Frank van de Pol <fvdpol@coil.demon.nl>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef __SND_SEQ_PORTS_H
+#define __SND_SEQ_PORTS_H
+
+#include <sound/seq_kernel.h>
+#include "seq_lock.h"
+
+/* list of 'exported' ports */
+
+/* Client ports that are not exported are still accessible, but are
+ anonymous ports. 
+ 
+ If a port supports SUBSCRIPTION, that port can send events to all
+ subscribersto a special address, with address
+ (queue==SNDRV_SEQ_ADDRESS_SUBSCRIBERS). The message is then send to all
+ recipients that are registered in the subscription list. A typical
+ application for these SUBSCRIPTION events is handling of incoming MIDI
+ data. The port doesn't 'know' what other clients are interested in this
+ message. If for instance a MIDI recording application would like to receive
+ the events from that port, it will first have to subscribe with that port.
+ 
+*/
+
+typedef struct subscribers_t {
+	snd_seq_port_subscribe_t info;	/* additional info */
+	struct list_head src_list;	/* link of sources */
+	struct list_head dest_list;	/* link of destinations */
+	atomic_t ref_count;
+} subscribers_t;
+
+typedef struct port_subs_info_t {
+	struct list_head list_head;	/* list of subscribed ports */
+	unsigned int count;		/* count of subscribers */
+	unsigned int exclusive: 1;	/* exclusive mode */
+	struct rw_semaphore list_mutex;
+	rwlock_t list_lock;
+	snd_seq_kernel_port_open_t *open;
+	snd_seq_kernel_port_close_t *close;
+} port_subs_info_t;
+
+typedef struct client_port_t {
+
+	snd_seq_addr_t addr;		/* client/port number */
+	struct module *owner;		/* owner of this port */
+	char name[64];			/* port name */	
+	struct list_head list;		/* port list */
+	snd_use_lock_t use_lock;
+
+	/* subscribers */
+	port_subs_info_t c_src;		/* read (sender) list */
+	port_subs_info_t c_dest;	/* write (dest) list */
+
+	snd_seq_kernel_port_input_t *event_input;
+	snd_seq_kernel_port_private_free_t *private_free;
+	void *private_data;
+	unsigned int callback_all : 1;
+	unsigned int closing : 1;
+	unsigned int timestamping: 1;
+	unsigned int time_real: 1;
+	int time_queue;
+	
+	/* capability, inport, output, sync */
+	unsigned int capability;	/* port capability bits */
+	unsigned int type;		/* port type bits */
+
+	/* supported channels */
+	int midi_channels;
+	int midi_voices;
+	int synth_voices;
+		
+} client_port_t;
+
+/* return pointer to port structure and lock port */
+client_port_t *snd_seq_port_use_ptr(client_t *client, int num);
+
+/* search for next port - port is locked if found */
+client_port_t *snd_seq_port_query_nearest(client_t *client, snd_seq_port_info_t *pinfo);
+
+/* unlock the port */
+#define snd_seq_port_unlock(port) snd_use_lock_free(&(port)->use_lock)
+
+/* create a port, port number is returned (-1 on failure) */
+client_port_t *snd_seq_create_port(client_t *client, int port_index);
+
+/* delete a port */
+int snd_seq_delete_port(client_t *client, int port);
+
+/* delete all ports */
+int snd_seq_delete_all_ports(client_t *client);
+
+/* set port info fields */
+int snd_seq_set_port_info(client_port_t *port, snd_seq_port_info_t *info);
+
+/* get port info fields */
+int snd_seq_get_port_info(client_port_t *port, snd_seq_port_info_t *info);
+
+/* add subscriber to subscription list */
+int snd_seq_port_connect(client_t *caller, client_t *s, client_port_t *sp, client_t *d, client_port_t *dp, snd_seq_port_subscribe_t *info);
+
+/* remove subscriber from subscription list */ 
+int snd_seq_port_disconnect(client_t *caller, client_t *s, client_port_t *sp, client_t *d, client_port_t *dp, snd_seq_port_subscribe_t *info);
+
+/* subscribe port */
+int snd_seq_port_subscribe(client_port_t *port, snd_seq_port_subscribe_t *info);
+
+/* get matched subscriber */
+subscribers_t *snd_seq_port_get_subscription(port_subs_info_t *src_grp, snd_seq_addr_t *dest_addr);
+
+#endif
