commit 88dca4ca5a93d2c09e5bbc6a62fbfc3af83c4fca
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jun 1 21:51:40 2020 -0700

    mm: remove the pgprot argument to __vmalloc
    
    The pgprot argument to __vmalloc is always PAGE_KERNEL now, so remove it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com> [hyperv]
    Acked-by: Gao Xiang <xiang@kernel.org> [erofs]
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Wei Liu <wei.liu@kernel.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Laura Abbott <labbott@redhat.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Nitin Gupta <ngupta@vflare.org>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Sakari Ailus <sakari.ailus@linux.intel.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Sumit Semwal <sumit.semwal@linaro.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mackerras <paulus@ozlabs.org>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Will Deacon <will@kernel.org>
    Link: http://lkml.kernel.org/r/20200414131348.444715-22-hch@lst.de
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index a83553fbedf0..bea46ed157a6 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -143,7 +143,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		break;
 	case SNDRV_DMA_TYPE_VMALLOC:
 		gfp = snd_mem_get_gfp_flags(device, GFP_KERNEL | __GFP_HIGHMEM);
-		dmab->area = __vmalloc(size, gfp, PAGE_KERNEL);
+		dmab->area = __vmalloc(size, gfp);
 		dmab->addr = 0;
 		break;
 #ifdef CONFIG_HAS_DMA

commit 1fe7f397cfe229494a88c6496b53ba532d4d4a42
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 09:01:36 2019 +0100

    ALSA: memalloc: Add vmalloc buffer allocation support
    
    This patch adds the vmalloc buffer support to ALSA memalloc core.  A
    new type, SNDRV_DMA_TYPE_VMALLOC was added.
    
    The vmalloc buffer has been already supported in the PCM via a few own
    helper functions, but the user sometimes get confused and misuse
    them.  With this patch, the whole buffer management is integrated into
    the memalloc core, so they can be used in a sole common way.
    
    Link: https://lore.kernel.org/r/20191105080138.1260-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 1b1c7620cbda..a83553fbedf0 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -10,6 +10,7 @@
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
 #include <linux/genalloc.h>
+#include <linux/vmalloc.h>
 #ifdef CONFIG_X86
 #include <asm/set_memory.h>
 #endif
@@ -99,10 +100,11 @@ static void snd_free_dev_iram(struct snd_dma_buffer *dmab)
  *
  */
 
-static inline gfp_t snd_mem_get_gfp_flags(const struct device *dev)
+static inline gfp_t snd_mem_get_gfp_flags(const struct device *dev,
+					  gfp_t default_gfp)
 {
 	if (!dev)
-		return GFP_KERNEL;
+		return default_gfp;
 	else
 		return (__force gfp_t)(unsigned long)dev;
 }
@@ -123,6 +125,8 @@ static inline gfp_t snd_mem_get_gfp_flags(const struct device *dev)
 int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 			struct snd_dma_buffer *dmab)
 {
+	gfp_t gfp;
+
 	if (WARN_ON(!size))
 		return -ENXIO;
 	if (WARN_ON(!dmab))
@@ -133,8 +137,13 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 	dmab->bytes = 0;
 	switch (type) {
 	case SNDRV_DMA_TYPE_CONTINUOUS:
-		dmab->area = alloc_pages_exact(size,
-					       snd_mem_get_gfp_flags(device));
+		gfp = snd_mem_get_gfp_flags(device, GFP_KERNEL);
+		dmab->area = alloc_pages_exact(size, gfp);
+		dmab->addr = 0;
+		break;
+	case SNDRV_DMA_TYPE_VMALLOC:
+		gfp = snd_mem_get_gfp_flags(device, GFP_KERNEL | __GFP_HIGHMEM);
+		dmab->area = __vmalloc(size, gfp, PAGE_KERNEL);
 		dmab->addr = 0;
 		break;
 #ifdef CONFIG_HAS_DMA
@@ -220,6 +229,9 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 	case SNDRV_DMA_TYPE_CONTINUOUS:
 		free_pages_exact(dmab->area, dmab->bytes);
 		break;
+	case SNDRV_DMA_TYPE_VMALLOC:
+		vfree(dmab->area);
+		break;
 #ifdef CONFIG_HAS_DMA
 #ifdef CONFIG_GENERIC_ALLOCATOR
 	case SNDRV_DMA_TYPE_DEV_IRAM:

commit 08422d2c559d1119b17c14e79b2d8ff89f46a356
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 09:01:35 2019 +0100

    ALSA: memalloc: Allow NULL device for SNDRV_DMA_TYPE_CONTINUOUS type
    
    Currently we pass the artificial device pointer to the allocation
    helper in the case of SNDRV_DMA_TYPE_CONTINUOUS for passing the GFP
    flags.  But all common cases are the allocations with GFP_KERNEL, and
    it's messy to put this in each place.
    
    In this patch, the memalloc core helper is changed to accept the NULL
    device pointer and it treats as the default mode, GFP_KERNEL, so that
    all callers can omit the complex argument but just leave NULL.
    
    Link: https://lore.kernel.org/r/20191105080138.1260-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 6850d13aa98c..1b1c7620cbda 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -99,6 +99,13 @@ static void snd_free_dev_iram(struct snd_dma_buffer *dmab)
  *
  */
 
+static inline gfp_t snd_mem_get_gfp_flags(const struct device *dev)
+{
+	if (!dev)
+		return GFP_KERNEL;
+	else
+		return (__force gfp_t)(unsigned long)dev;
+}
 
 /**
  * snd_dma_alloc_pages - allocate the buffer area according to the given type
@@ -120,8 +127,6 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		return -ENXIO;
 	if (WARN_ON(!dmab))
 		return -ENXIO;
-	if (WARN_ON(!device))
-		return -EINVAL;
 
 	dmab->dev.type = type;
 	dmab->dev.dev = device;
@@ -129,7 +134,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 	switch (type) {
 	case SNDRV_DMA_TYPE_CONTINUOUS:
 		dmab->area = alloc_pages_exact(size,
-					       (__force gfp_t)(unsigned long)device);
+					       snd_mem_get_gfp_flags(device));
 		dmab->addr = 0;
 		break;
 #ifdef CONFIG_HAS_DMA

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 9f48e1d3a257..6850d13aa98c 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -1,24 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *                   Takashi Iwai <tiwai@suse.de>
  * 
  *  Generic memory allocators
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/slab.h>

commit 734b5a0bbdf43518e6739c8156a985e385e557fe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 23 19:38:13 2018 +0100

    ALSA: Replace snd_malloc_pages() and snd_free_pages() with standard helpers, take#2
    
    snd_malloc_pages() and snd_free_pages() are merely thin wrappers of
    the standard page allocator / free functions.  Even the arguments are
    compatible with some standard helpers, so there is little merit of
    keeping these wrappers.
    
    This patch replaces the all existing callers of snd_malloc_pages() and
    snd_free_pages() with the direct calls of the standard helper
    functions.  In this version, we use a recently introduced one,
    alloc_pages_exact(), which suits better than the old
    snd_malloc_pages() implementation for our purposes.  Then we can avoid
    the waste of pages by alignment to power-of-two.
    
    Since alloc_pages_exact() does split pages, we need no longer
    __GFP_COMP flag; or better to say, we must not pass __GFP_COMP to
    alloc_pages_exact().  So the former unconditional addition of
    __GFP_COMP flag in snd_malloc_pages() is dropped, as well as in most
    other places.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index eb974235c92b..9f48e1d3a257 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -30,53 +30,6 @@
 #endif
 #include <sound/memalloc.h>
 
-/*
- *
- *  Generic memory allocators
- *
- */
-
-/**
- * snd_malloc_pages - allocate pages with the given size
- * @size: the size to allocate in bytes
- * @gfp_flags: the allocation conditions, GFP_XXX
- *
- * Allocates the physically contiguous pages with the given size.
- *
- * Return: The pointer of the buffer, or %NULL if no enough memory.
- */
-void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
-{
-	int pg;
-
-	if (WARN_ON(!size))
-		return NULL;
-	if (WARN_ON(!gfp_flags))
-		return NULL;
-	gfp_flags |= __GFP_COMP;	/* compound page lets parts be mapped */
-	pg = get_order(size);
-	return (void *) __get_free_pages(gfp_flags, pg);
-}
-EXPORT_SYMBOL(snd_malloc_pages);
-
-/**
- * snd_free_pages - release the pages
- * @ptr: the buffer pointer to release
- * @size: the allocated buffer size
- *
- * Releases the buffer allocated via snd_malloc_pages().
- */
-void snd_free_pages(void *ptr, size_t size)
-{
-	int pg;
-
-	if (ptr == NULL)
-		return;
-	pg = get_order(size);
-	free_pages((unsigned long) ptr, pg);
-}
-EXPORT_SYMBOL(snd_free_pages);
-
 /*
  *
  *  Bus-specific memory allocators
@@ -190,8 +143,8 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 	dmab->bytes = 0;
 	switch (type) {
 	case SNDRV_DMA_TYPE_CONTINUOUS:
-		dmab->area = snd_malloc_pages(size,
-					(__force gfp_t)(unsigned long)device);
+		dmab->area = alloc_pages_exact(size,
+					       (__force gfp_t)(unsigned long)device);
 		dmab->addr = 0;
 		break;
 #ifdef CONFIG_HAS_DMA
@@ -275,7 +228,7 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 {
 	switch (dmab->dev.type) {
 	case SNDRV_DMA_TYPE_CONTINUOUS:
-		snd_free_pages(dmab->area, dmab->bytes);
+		free_pages_exact(dmab->area, dmab->bytes);
 		break;
 #ifdef CONFIG_HAS_DMA
 #ifdef CONFIG_GENERIC_ALLOCATOR

commit 6ce1d63ed7210e7120070297976460f868c36314
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 14:34:00 2019 +0100

    ALSA: core: Don't allow NULL device for memory allocation
    
    Since we covered all callers with NULL device pointer, let's catch the
    remaining calls with NULL and warn explicitly.
    
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 59a4adc286ed..eb974235c92b 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -182,6 +182,8 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		return -ENXIO;
 	if (WARN_ON(!dmab))
 		return -ENXIO;
+	if (WARN_ON(!device))
+		return -EINVAL;
 
 	dmab->dev.type = type;
 	dmab->dev.dev = device;

commit 3c4cfa7bf6075be035cff3cac0986395f6fca32b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 4 19:54:51 2018 +0200

    ALSA: memalloc: Add fall-through annotation
    
    As a preparatory patch for the upcoming -Wimplicit-fallthrough
    compiler checks, add the "fall through" annotation in
    snd_dma_alloc_pages().  Note that this seems necessary to be put
    exactly before the next label, so it's outside the ifdef block.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index aa266907ec9b..59a4adc286ed 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -203,6 +203,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		 */
 		dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 #endif /* CONFIG_GENERIC_ALLOCATOR */
+		/* fall through */
 	case SNDRV_DMA_TYPE_DEV:
 	case SNDRV_DMA_TYPE_DEV_UC:
 		snd_malloc_dev_pages(dmab, size);

commit 42e748a0b3251cca0de2c269ca106884907eb289
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 8 17:01:00 2018 +0200

    ALSA: memalloc: Add non-cached buffer type
    
    In some cases (mainly for x86), we need the DMA coherent buffer with
    non-cached pages.  Although this has been done in each driver side
    like HD-audio and intel8x0, it can be done cleaner in the core memory
    allocator.
    
    This patch adds the new types, SNDRV_DMA_TYPE_DEV_UC and
    SNDRV_DMA_TYPE_DEV_UC_SG, for allocating such non-cached buffer
    pages.  On non-x86 architectures, they work as same as the standard
    SNDRV_DMA_TYPE_DEV and *_SG.
    
    One additional change by this move is that we can assure to pass the
    non-cached pgprot to the vmapped buffer, too.  It eventually fixes the
    case like non-snoop mode without mmap access on HD-audio.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index cc051bfe2f6f..aa266907ec9b 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -25,6 +25,9 @@
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
 #include <linux/genalloc.h>
+#ifdef CONFIG_X86
+#include <asm/set_memory.h>
+#endif
 #include <sound/memalloc.h>
 
 /*
@@ -92,11 +95,21 @@ static void snd_malloc_dev_pages(struct snd_dma_buffer *dmab, size_t size)
 		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
 	dmab->area = dma_alloc_coherent(dmab->dev.dev, size, &dmab->addr,
 					gfp_flags);
+#ifdef CONFIG_X86
+	if (dmab->area && dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC)
+		set_memory_wc((unsigned long)dmab->area,
+			      PAGE_ALIGN(size) >> PAGE_SHIFT);
+#endif
 }
 
 /* free the coherent DMA pages */
 static void snd_free_dev_pages(struct snd_dma_buffer *dmab)
 {
+#ifdef CONFIG_X86
+	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_UC)
+		set_memory_wb((unsigned long)dmab->area,
+			      PAGE_ALIGN(dmab->bytes) >> PAGE_SHIFT);
+#endif
 	dma_free_coherent(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
 }
 
@@ -191,11 +204,13 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 #endif /* CONFIG_GENERIC_ALLOCATOR */
 	case SNDRV_DMA_TYPE_DEV:
+	case SNDRV_DMA_TYPE_DEV_UC:
 		snd_malloc_dev_pages(dmab, size);
 		break;
 #endif
 #ifdef CONFIG_SND_DMA_SGBUF
 	case SNDRV_DMA_TYPE_DEV_SG:
+	case SNDRV_DMA_TYPE_DEV_UC_SG:
 		snd_malloc_sgbuf_pages(device, size, dmab, NULL);
 		break;
 #endif
@@ -266,11 +281,13 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 		break;
 #endif /* CONFIG_GENERIC_ALLOCATOR */
 	case SNDRV_DMA_TYPE_DEV:
+	case SNDRV_DMA_TYPE_DEV_UC:
 		snd_free_dev_pages(dmab);
 		break;
 #endif
 #ifdef CONFIG_SND_DMA_SGBUF
 	case SNDRV_DMA_TYPE_DEV_SG:
+	case SNDRV_DMA_TYPE_DEV_UC_SG:
 		snd_free_sgbuf_pages(dmab);
 		break;
 #endif

commit 28f3f4f685d7d7226ba4ed4f78e04c75dd3a5b27
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 10 14:43:37 2018 +0200

    ALSA: memalloc: Simplify snd_malloc_dev_pages() calls
    
    snd_malloc_dev_pages() and snd_free_dev_pages() are local functions
    and the parameters passed there are all contained in snd_dma_buffer
    object.  As a code-simplification, pass snd_dma_buffer object and
    assign the address there like other allocators do (except for
    snd_malloc_pages() which is called from outside, hence we can't change
    easily).
    
    Only code refactoring, no functional changes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index d85df01bf055..cc051bfe2f6f 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -82,26 +82,22 @@ EXPORT_SYMBOL(snd_free_pages);
 
 #ifdef CONFIG_HAS_DMA
 /* allocate the coherent DMA pages */
-static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *dma)
+static void snd_malloc_dev_pages(struct snd_dma_buffer *dmab, size_t size)
 {
 	gfp_t gfp_flags;
 
-	if (WARN_ON(!dma))
-		return NULL;
 	gfp_flags = GFP_KERNEL
 		| __GFP_COMP	/* compound page lets parts be mapped */
 		| __GFP_NORETRY /* don't trigger OOM-killer */
 		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
-	return dma_alloc_coherent(dev, size, dma, gfp_flags);
+	dmab->area = dma_alloc_coherent(dmab->dev.dev, size, &dmab->addr,
+					gfp_flags);
 }
 
 /* free the coherent DMA pages */
-static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
-			       dma_addr_t dma)
+static void snd_free_dev_pages(struct snd_dma_buffer *dmab)
 {
-	if (ptr == NULL)
-		return;
-	dma_free_coherent(dev, size, ptr, dma);
+	dma_free_coherent(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
 }
 
 #ifdef CONFIG_GENERIC_ALLOCATOR
@@ -195,7 +191,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 #endif /* CONFIG_GENERIC_ALLOCATOR */
 	case SNDRV_DMA_TYPE_DEV:
-		dmab->area = snd_malloc_dev_pages(device, size, &dmab->addr);
+		snd_malloc_dev_pages(dmab, size);
 		break;
 #endif
 #ifdef CONFIG_SND_DMA_SGBUF
@@ -270,7 +266,7 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 		break;
 #endif /* CONFIG_GENERIC_ALLOCATOR */
 	case SNDRV_DMA_TYPE_DEV:
-		snd_free_dev_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+		snd_free_dev_pages(dmab);
 		break;
 #endif
 #ifdef CONFIG_SND_DMA_SGBUF

commit 03486830c577d3fe49c1f2c316414552a549ff00
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 8 16:56:46 2018 +0200

    ALSA: memalloc: Don't align the size to power-of-two
    
    The size passed to dma_alloc_coherent() doesn't have to be aligned
    with power-of-two, rather it should be the raw size.  As a minor
    optimization, remove the size adjustment in the current code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 753d5fc4b284..d85df01bf055 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -84,29 +84,24 @@ EXPORT_SYMBOL(snd_free_pages);
 /* allocate the coherent DMA pages */
 static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *dma)
 {
-	int pg;
 	gfp_t gfp_flags;
 
 	if (WARN_ON(!dma))
 		return NULL;
-	pg = get_order(size);
 	gfp_flags = GFP_KERNEL
 		| __GFP_COMP	/* compound page lets parts be mapped */
 		| __GFP_NORETRY /* don't trigger OOM-killer */
 		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
-	return dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);
+	return dma_alloc_coherent(dev, size, dma, gfp_flags);
 }
 
 /* free the coherent DMA pages */
 static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
 			       dma_addr_t dma)
 {
-	int pg;
-
 	if (ptr == NULL)
 		return;
-	pg = get_order(size);
-	dma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);
+	dma_free_coherent(dev, size, ptr, dma);
 }
 
 #ifdef CONFIG_GENERIC_ALLOCATOR

commit dfef01e150824b0e6da750cacda8958188d29aea
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 19 11:01:04 2018 +0200

    ALSA: memalloc: Don't exceed over the requested size
    
    snd_dma_alloc_pages_fallback() tries to allocate pages again when the
    allocation fails with reduced size.  But the first try actually
    *increases* the size to power-of-two, which may give back a larger
    chunk than the requested size.  This confuses the callers, e.g. sgbuf
    assumes that the size is equal or less, and it may result in a bad
    loop due to the underflow and eventually lead to Oops.
    
    The code of this function seems incorrectly assuming the usage of
    get_order().  We need to decrease at first, then align to
    power-of-two.
    
    Reported-and-tested-by: he, bo <bo.he@intel.com>
    Reported-by: zhang jun <jun.zhang@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 7f89d3c79a4b..753d5fc4b284 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -242,16 +242,12 @@ int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,
 	int err;
 
 	while ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {
-		size_t aligned_size;
 		if (err != -ENOMEM)
 			return err;
 		if (size <= PAGE_SIZE)
 			return -ENOMEM;
-		aligned_size = PAGE_SIZE << get_order(size);
-		if (size != aligned_size)
-			size = aligned_size;
-		else
-			size >>= 1;
+		size >>= 1;
+		size = PAGE_SIZE << get_order(size);
 	}
 	if (! dmab->area)
 		return -ENOMEM;

commit 35f8001415d301ba47124f463f98eee0e7d0792c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 16 16:16:33 2017 +0200

    ALSA: core: Follow standard EXPORT_SYMBOL() declarations
    
    Just a tidy up to follow the standard EXPORT_SYMBOL*() declarations
    in order to improve grep-ability.
    
    - Move EXPORT_SYMBOL*() to the position right after its definition
    - Remove superfluous blank line before EXPORT_SYMBOL*() lines
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index f05cb6a8cbe0..7f89d3c79a4b 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -54,6 +54,7 @@ void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
 	pg = get_order(size);
 	return (void *) __get_free_pages(gfp_flags, pg);
 }
+EXPORT_SYMBOL(snd_malloc_pages);
 
 /**
  * snd_free_pages - release the pages
@@ -71,6 +72,7 @@ void snd_free_pages(void *ptr, size_t size)
 	pg = get_order(size);
 	free_pages((unsigned long) ptr, pg);
 }
+EXPORT_SYMBOL(snd_free_pages);
 
 /*
  *
@@ -217,6 +219,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 	dmab->bytes = size;
 	return 0;
 }
+EXPORT_SYMBOL(snd_dma_alloc_pages);
 
 /**
  * snd_dma_alloc_pages_fallback - allocate the buffer area according to the given type with fallback
@@ -254,6 +257,7 @@ int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,
 		return -ENOMEM;
 	return 0;
 }
+EXPORT_SYMBOL(snd_dma_alloc_pages_fallback);
 
 
 /**
@@ -287,13 +291,4 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 		pr_err("snd-malloc: invalid device type %d\n", dmab->dev.type);
 	}
 }
-
-/*
- * exports
- */
-EXPORT_SYMBOL(snd_dma_alloc_pages);
-EXPORT_SYMBOL(snd_dma_alloc_pages_fallback);
 EXPORT_SYMBOL(snd_dma_free_pages);
-
-EXPORT_SYMBOL(snd_malloc_pages);
-EXPORT_SYMBOL(snd_free_pages);

commit abdd4a7025282fbe3737e1bcb5f51afc8d8ea1b8
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Tue Jun 30 15:00:07 2015 -0700

    genalloc: rename of_get_named_gen_pool() to of_gen_pool_get()
    
    To be consistent with other kernel interface namings, rename
    of_get_named_gen_pool() to of_gen_pool_get().  In the original function
    name "_named" suffix references to a device tree property, which contains
    a phandle to a device and the corresponding device driver is assumed to
    register a gen_pool object.
    
    Due to a weak relation and to avoid any confusion (e.g.  in future
    possible scenario if gen_pool objects are named) the suffix is removed.
    
    [sfr@canb.auug.org.au: crypto/marvell/cesa - fix up for of_get_named_gen_pool() rename]
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 082509eb805d..f05cb6a8cbe0 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -124,7 +124,7 @@ static void snd_malloc_dev_iram(struct snd_dma_buffer *dmab, size_t size)
 	dmab->addr = 0;
 
 	if (dev->of_node)
-		pool = of_get_named_gen_pool(dev->of_node, "iram", 0);
+		pool = of_gen_pool_get(dev->of_node, "iram", 0);
 
 	if (!pool)
 		return;

commit f2f9307a4f26a9fbe47fff486a9cee5885af748f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:21:03 2014 +0100

    ALSA: core: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 4595f93d151e..082509eb805d 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -207,7 +207,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		break;
 #endif
 	default:
-		printk(KERN_ERR "snd-malloc: invalid device type %d\n", type);
+		pr_err("snd-malloc: invalid device type %d\n", type);
 		dmab->area = NULL;
 		dmab->addr = 0;
 		return -ENXIO;
@@ -284,7 +284,7 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 		break;
 #endif
 	default:
-		printk(KERN_ERR "snd-malloc: invalid device type %d\n", dmab->dev.type);
+		pr_err("snd-malloc: invalid device type %d\n", dmab->dev.type);
 	}
 }
 

commit 2d82ea2005624a80b18916e37bce921d6e868b59
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 9 07:48:12 2014 +0100

    ALSA: Merge memalloc code into snd-pcm module
    
    Instead of keeping a separate snd-page-alloc module, merge into the
    core snd-pcm module, as we don't need to keep it as an individual
    module due to the drop of page reservation.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index e568c14ca88d..4595f93d151e 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -21,22 +21,12 @@
  *
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
-#include <asm/uaccess.h>
 #include <linux/dma-mapping.h>
 #include <linux/genalloc.h>
-#include <linux/moduleparam.h>
 #include <sound/memalloc.h>
 
-
-MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>, Jaroslav Kysela <perex@perex.cz>");
-MODULE_DESCRIPTION("Memory allocator for ALSA system.");
-MODULE_LICENSE("GPL");
-
-
 /*
  *
  *  Generic memory allocators

commit f5d8e6df4bfa749b4d029ba43ac8a027b1003c2a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 9 07:44:11 2014 +0100

    ALSA: Remove superfluous header inclusions in memalloc.c
    
    After cutting off the proc and page reservation codes, we don't need
    many headers any longer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index be1544ac4613..e568c14ca88d 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -22,17 +22,13 @@
  */
 
 #include <linux/module.h>
-#include <linux/proc_fs.h>
 #include <linux/init.h>
-#include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
-#include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include <linux/dma-mapping.h>
 #include <linux/genalloc.h>
 #include <linux/moduleparam.h>
-#include <linux/mutex.h>
 #include <sound/memalloc.h>
 
 

commit 47d98c026ef9a9888c36f3c4f26b81f548a0ca86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 8 16:12:25 2014 +0100

    ALSA: Remove memory reservation code from memalloc helper
    
    Nowadays we have CMA for obtaining the contiguous memory pages
    efficiently.  Let's kill the old kludge for reserving the memory pages
    for large buffers.  It was rarely useful (only for preserving pages
    among module reloading or a little help by an early boot scripting),
    used only by a couple of drivers, and yet it gives too much ugliness
    than its benefit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index bfaf4f04d91d..be1544ac4613 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -41,22 +41,6 @@ MODULE_DESCRIPTION("Memory allocator for ALSA system.");
 MODULE_LICENSE("GPL");
 
 
-/*
- */
-
-static DEFINE_MUTEX(list_mutex);
-static LIST_HEAD(mem_list_head);
-
-/* buffer preservation list */
-struct snd_mem_list {
-	struct snd_dma_buffer buffer;
-	unsigned int id;
-	struct list_head list;
-};
-
-/* id for pre-allocated buffers */
-#define SNDRV_DMA_DEVICE_UNUSED (unsigned int)-1
-
 /*
  *
  *  Generic memory allocators
@@ -318,251 +302,6 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 	}
 }
 
-
-/**
- * snd_dma_get_reserved - get the reserved buffer for the given device
- * @dmab: the buffer allocation record to store
- * @id: the buffer id
- *
- * Looks for the reserved-buffer list and re-uses if the same buffer
- * is found in the list.  When the buffer is found, it's removed from the free list.
- *
- * Return: The size of buffer if the buffer is found, or zero if not found.
- */
-size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
-{
-	struct snd_mem_list *mem;
-
-	if (WARN_ON(!dmab))
-		return 0;
-
-	mutex_lock(&list_mutex);
-	list_for_each_entry(mem, &mem_list_head, list) {
-		if (mem->id == id &&
-		    (mem->buffer.dev.dev == NULL || dmab->dev.dev == NULL ||
-		     ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev)))) {
-			struct device *dev = dmab->dev.dev;
-			list_del(&mem->list);
-			*dmab = mem->buffer;
-			if (dmab->dev.dev == NULL)
-				dmab->dev.dev = dev;
-			kfree(mem);
-			mutex_unlock(&list_mutex);
-			return dmab->bytes;
-		}
-	}
-	mutex_unlock(&list_mutex);
-	return 0;
-}
-
-/**
- * snd_dma_reserve_buf - reserve the buffer
- * @dmab: the buffer to reserve
- * @id: the buffer id
- *
- * Reserves the given buffer as a reserved buffer.
- *
- * Return: Zero if successful, or a negative code on error.
- */
-int snd_dma_reserve_buf(struct snd_dma_buffer *dmab, unsigned int id)
-{
-	struct snd_mem_list *mem;
-
-	if (WARN_ON(!dmab))
-		return -EINVAL;
-	mem = kmalloc(sizeof(*mem), GFP_KERNEL);
-	if (! mem)
-		return -ENOMEM;
-	mutex_lock(&list_mutex);
-	mem->buffer = *dmab;
-	mem->id = id;
-	list_add_tail(&mem->list, &mem_list_head);
-	mutex_unlock(&list_mutex);
-	return 0;
-}
-
-/*
- * purge all reserved buffers
- */
-static void free_all_reserved_pages(void)
-{
-	struct list_head *p;
-	struct snd_mem_list *mem;
-
-	mutex_lock(&list_mutex);
-	while (! list_empty(&mem_list_head)) {
-		p = mem_list_head.next;
-		mem = list_entry(p, struct snd_mem_list, list);
-		list_del(p);
-		snd_dma_free_pages(&mem->buffer);
-		kfree(mem);
-	}
-	mutex_unlock(&list_mutex);
-}
-
-
-#ifdef CONFIG_PROC_FS
-/*
- * proc file interface
- */
-#define SND_MEM_PROC_FILE	"driver/snd-page-alloc"
-static struct proc_dir_entry *snd_mem_proc;
-
-static int snd_mem_proc_read(struct seq_file *seq, void *offset)
-{
-	struct snd_mem_list *mem;
-	int devno;
-	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG" };
-
-	mutex_lock(&list_mutex);
-	devno = 0;
-	list_for_each_entry(mem, &mem_list_head, list) {
-		devno++;
-		seq_printf(seq, "buffer %d : ID %08x : type %s\n",
-			   devno, mem->id, types[mem->buffer.dev.type]);
-		seq_printf(seq, "  addr = 0x%lx, size = %d bytes\n",
-			   (unsigned long)mem->buffer.addr,
-			   (int)mem->buffer.bytes);
-	}
-	mutex_unlock(&list_mutex);
-	return 0;
-}
-
-static int snd_mem_proc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, snd_mem_proc_read, NULL);
-}
-
-/* FIXME: for pci only - other bus? */
-#ifdef CONFIG_PCI
-#define gettoken(bufp) strsep(bufp, " \t\n")
-
-static ssize_t snd_mem_proc_write(struct file *file, const char __user * buffer,
-				  size_t count, loff_t * ppos)
-{
-	char buf[128];
-	char *token, *p;
-
-	if (count > sizeof(buf) - 1)
-		return -EINVAL;
-	if (copy_from_user(buf, buffer, count))
-		return -EFAULT;
-	buf[count] = '\0';
-
-	p = buf;
-	token = gettoken(&p);
-	if (! token || *token == '#')
-		return count;
-	if (strcmp(token, "add") == 0) {
-		char *endp;
-		int vendor, device, size, buffers;
-		long mask;
-		int i, alloced;
-		struct pci_dev *pci;
-
-		if ((token = gettoken(&p)) == NULL ||
-		    (vendor = simple_strtol(token, NULL, 0)) <= 0 ||
-		    (token = gettoken(&p)) == NULL ||
-		    (device = simple_strtol(token, NULL, 0)) <= 0 ||
-		    (token = gettoken(&p)) == NULL ||
-		    (mask = simple_strtol(token, NULL, 0)) < 0 ||
-		    (token = gettoken(&p)) == NULL ||
-		    (size = memparse(token, &endp)) < 64*1024 ||
-		    size > 16*1024*1024 /* too big */ ||
-		    (token = gettoken(&p)) == NULL ||
-		    (buffers = simple_strtol(token, NULL, 0)) <= 0 ||
-		    buffers > 4) {
-			printk(KERN_ERR "snd-page-alloc: invalid proc write format\n");
-			return count;
-		}
-		vendor &= 0xffff;
-		device &= 0xffff;
-
-		alloced = 0;
-		pci = NULL;
-		while ((pci = pci_get_device(vendor, device, pci)) != NULL) {
-			if (mask > 0 && mask < 0xffffffff) {
-				if (pci_set_dma_mask(pci, mask) < 0 ||
-				    pci_set_consistent_dma_mask(pci, mask) < 0) {
-					printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", mask, vendor, device);
-					pci_dev_put(pci);
-					return count;
-				}
-			}
-			for (i = 0; i < buffers; i++) {
-				struct snd_dma_buffer dmab;
-				memset(&dmab, 0, sizeof(dmab));
-				if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-							size, &dmab) < 0) {
-					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
-					pci_dev_put(pci);
-					return count;
-				}
-				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));
-			}
-			alloced++;
-		}
-		if (! alloced) {
-			for (i = 0; i < buffers; i++) {
-				struct snd_dma_buffer dmab;
-				memset(&dmab, 0, sizeof(dmab));
-				/* FIXME: We can allocate only in ZONE_DMA
-				 * without a device pointer!
-				 */
-				if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, NULL,
-							size, &dmab) < 0) {
-					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
-					break;
-				}
-				snd_dma_reserve_buf(&dmab, (unsigned int)((vendor << 16) | device));
-			}
-		}
-	} else if (strcmp(token, "erase") == 0)
-		/* FIXME: need for releasing each buffer chunk? */
-		free_all_reserved_pages();
-	else
-		printk(KERN_ERR "snd-page-alloc: invalid proc cmd\n");
-	return count;
-}
-#endif /* CONFIG_PCI */
-
-static const struct file_operations snd_mem_proc_fops = {
-	.owner		= THIS_MODULE,
-	.open		= snd_mem_proc_open,
-	.read		= seq_read,
-#ifdef CONFIG_PCI
-	.write		= snd_mem_proc_write,
-#endif
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-#endif /* CONFIG_PROC_FS */
-
-/*
- * module entry
- */
-
-static int __init snd_mem_init(void)
-{
-#ifdef CONFIG_PROC_FS
-	snd_mem_proc = proc_create(SND_MEM_PROC_FILE, 0644, NULL,
-				   &snd_mem_proc_fops);
-#endif
-	return 0;
-}
-
-static void __exit snd_mem_exit(void)
-{
-	remove_proc_entry(SND_MEM_PROC_FILE, NULL);
-	free_all_reserved_pages();
-}
-
-
-module_init(snd_mem_init)
-module_exit(snd_mem_exit)
-
-
 /*
  * exports
  */
@@ -570,8 +309,5 @@ EXPORT_SYMBOL(snd_dma_alloc_pages);
 EXPORT_SYMBOL(snd_dma_alloc_pages_fallback);
 EXPORT_SYMBOL(snd_dma_free_pages);
 
-EXPORT_SYMBOL(snd_dma_get_reserved_buf);
-EXPORT_SYMBOL(snd_dma_reserve_buf);
-
 EXPORT_SYMBOL(snd_malloc_pages);
 EXPORT_SYMBOL(snd_free_pages);

commit d7b135410e1b2f5ad64e56df09d133a23aa9fbcb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 8 16:09:31 2014 +0100

    ALSA: Remove memory accounting in memalloc helper
    
    It's almost superfluous, and doesn't help much for real uses.
    Let's reduce the layer size.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 5e1c7bc73b29..bfaf4f04d91d 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -63,18 +63,6 @@ struct snd_mem_list {
  *
  */
 
-static long snd_allocated_pages; /* holding the number of allocated pages */
-
-static inline void inc_snd_pages(int order)
-{
-	snd_allocated_pages += 1 << order;
-}
-
-static inline void dec_snd_pages(int order)
-{
-	snd_allocated_pages -= 1 << order;
-}
-
 /**
  * snd_malloc_pages - allocate pages with the given size
  * @size: the size to allocate in bytes
@@ -87,7 +75,6 @@ static inline void dec_snd_pages(int order)
 void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
 {
 	int pg;
-	void *res;
 
 	if (WARN_ON(!size))
 		return NULL;
@@ -95,9 +82,7 @@ void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
 		return NULL;
 	gfp_flags |= __GFP_COMP;	/* compound page lets parts be mapped */
 	pg = get_order(size);
-	if ((res = (void *) __get_free_pages(gfp_flags, pg)) != NULL)
-		inc_snd_pages(pg);
-	return res;
+	return (void *) __get_free_pages(gfp_flags, pg);
 }
 
 /**
@@ -114,7 +99,6 @@ void snd_free_pages(void *ptr, size_t size)
 	if (ptr == NULL)
 		return;
 	pg = get_order(size);
-	dec_snd_pages(pg);
 	free_pages((unsigned long) ptr, pg);
 }
 
@@ -129,7 +113,6 @@ void snd_free_pages(void *ptr, size_t size)
 static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *dma)
 {
 	int pg;
-	void *res;
 	gfp_t gfp_flags;
 
 	if (WARN_ON(!dma))
@@ -139,11 +122,7 @@ static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *d
 		| __GFP_COMP	/* compound page lets parts be mapped */
 		| __GFP_NORETRY /* don't trigger OOM-killer */
 		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
-	res = dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);
-	if (res != NULL)
-		inc_snd_pages(pg);
-
-	return res;
+	return dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);
 }
 
 /* free the coherent DMA pages */
@@ -155,7 +134,6 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
 	if (ptr == NULL)
 		return;
 	pg = get_order(size);
-	dec_snd_pages(pg);
 	dma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);
 }
 
@@ -432,14 +410,11 @@ static struct proc_dir_entry *snd_mem_proc;
 
 static int snd_mem_proc_read(struct seq_file *seq, void *offset)
 {
-	long pages = snd_allocated_pages >> (PAGE_SHIFT-12);
 	struct snd_mem_list *mem;
 	int devno;
 	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG" };
 
 	mutex_lock(&list_mutex);
-	seq_printf(seq, "pages  : %li bytes (%li pages per %likB)\n",
-		   pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
 	devno = 0;
 	list_for_each_entry(mem, &mem_list_head, list) {
 		devno++;
@@ -581,8 +556,6 @@ static void __exit snd_mem_exit(void)
 {
 	remove_proc_entry(SND_MEM_PROC_FILE, NULL);
 	free_all_reserved_pages();
-	if (snd_allocated_pages > 0)
-		printk(KERN_ERR "snd-malloc: Memory leak?  pages not freed = %li\n", snd_allocated_pages);
 }
 
 

commit 07968fe4acec6d49e39520ef407ea7f6874b7c2e
Author: Nicolin Chen <b42378@freescale.com>
Date:   Thu Nov 14 14:32:15 2013 -0800

    sound/core/memalloc.c: use gen_pool_dma_alloc() to allocate iram buffer
    
    Since gen_pool_dma_alloc() is introduced, we implement it to simplify code.
    
    Signed-off-by: Nicolin Chen <b42378@freescale.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 9d93f02c6285..5e1c7bc73b29 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -184,11 +184,7 @@ static void snd_malloc_dev_iram(struct snd_dma_buffer *dmab, size_t size)
 	/* Assign the pool into private_data field */
 	dmab->private_data = pool;
 
-	dmab->area = (void *)gen_pool_alloc(pool, size);
-	if (!dmab->area)
-		return;
-
-	dmab->addr = gen_pool_virt_to_phys(pool, (unsigned long)dmab->area);
+	dmab->area = gen_pool_dma_alloc(pool, size, &dmab->addr);
 }
 
 /**

commit a40a3937222c728be925f2d78650cfe9b20be3f5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 29 11:59:31 2013 +0100

    ALSA: memalloc: NULL-initialize in snd_malloc_dev_iram()
    
    dmab->area and addr fields should be cleared at the head of
    snd_malloc_dev_iram() as especially dmab->area is used to indicate the
    allocation failure / fallback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 278248b8f22a..9d93f02c6285 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -172,6 +172,9 @@ static void snd_malloc_dev_iram(struct snd_dma_buffer *dmab, size_t size)
 	struct device *dev = dmab->dev.dev;
 	struct gen_pool *pool = NULL;
 
+	dmab->area = NULL;
+	dmab->addr = 0;
+
 	if (dev->of_node)
 		pool = of_get_named_gen_pool(dev->of_node, "iram", 0);
 

commit 9f694bc7936a7e4e9c9efac2900cddaf71303c0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 29 11:56:21 2013 +0100

    ALSA: memalloc: Make snd_{malloc|free}_dev_iram() static
    
    These are used only locally.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 809fd79ecad6..278248b8f22a 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -167,7 +167,7 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
  *
  * This function requires iram phandle provided via of_node
  */
-void snd_malloc_dev_iram(struct snd_dma_buffer *dmab, size_t size)
+static void snd_malloc_dev_iram(struct snd_dma_buffer *dmab, size_t size)
 {
 	struct device *dev = dmab->dev.dev;
 	struct gen_pool *pool = NULL;
@@ -192,7 +192,7 @@ void snd_malloc_dev_iram(struct snd_dma_buffer *dmab, size_t size)
  * snd_free_dev_iram - free allocated specific memory from on-chip internal ram
  * @dmab: buffer allocation record to store the allocated data
  */
-void snd_free_dev_iram(struct snd_dma_buffer *dmab)
+static void snd_free_dev_iram(struct snd_dma_buffer *dmab)
 {
 	struct gen_pool *pool = dmab->private_data;
 

commit 63437313daaf90b372d5b383a8cc6ec8dce185fa
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 28 16:08:27 2013 +0100

    ALSA: memalloc: Yet another ifdef CONFIG_GENERIC_ALLOCATOR protection
    
    I obviously forgot to merge the right version...
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 51a79218815b..809fd79ecad6 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -159,6 +159,7 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
 	dma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);
 }
 
+#ifdef CONFIG_GENERIC_ALLOCATOR
 /**
  * snd_malloc_dev_iram - allocate memory from on-chip internal ram
  * @dmab: buffer allocation record to store the allocated data
@@ -198,6 +199,7 @@ void snd_free_dev_iram(struct snd_dma_buffer *dmab)
 	if (pool && dmab->area)
 		gen_pool_free(pool, (unsigned long)dmab->area, dmab->bytes);
 }
+#endif /* CONFIG_GENERIC_ALLOCATOR */
 #endif /* CONFIG_HAS_DMA */
 
 /*

commit a5606f85611267047206d8ba055bc0e4ba166ad3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 24 14:25:32 2013 +0200

    ALSA: Add ifdef CONFIG_GENERIC_ALLOCATOR for SNDRV_DMA_TYPE_IRAM code
    
    It turned out that we can't use gen_pool_*() functions on archs
    without CONFIG_GENERIC_ALLOCATOR (resulting in missing symbols), since
    linux/genalloc.h doesn't provide dummy functions for all.  We'd be
    able to fix linux/genalloc.h size, but I take an easier path for
    now...
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 18c1d4759ccb..51a79218815b 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -238,6 +238,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		dmab->addr = 0;
 		break;
 #ifdef CONFIG_HAS_DMA
+#ifdef CONFIG_GENERIC_ALLOCATOR
 	case SNDRV_DMA_TYPE_DEV_IRAM:
 		snd_malloc_dev_iram(dmab, size);
 		if (dmab->area)
@@ -246,6 +247,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		 * so if we fail to malloc, try to fetch memory traditionally.
 		 */
 		dmab->dev.type = SNDRV_DMA_TYPE_DEV;
+#endif /* CONFIG_GENERIC_ALLOCATOR */
 	case SNDRV_DMA_TYPE_DEV:
 		dmab->area = snd_malloc_dev_pages(device, size, &dmab->addr);
 		break;
@@ -318,9 +320,11 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 		snd_free_pages(dmab->area, dmab->bytes);
 		break;
 #ifdef CONFIG_HAS_DMA
+#ifdef CONFIG_GENERIC_ALLOCATOR
 	case SNDRV_DMA_TYPE_DEV_IRAM:
 		snd_free_dev_iram(dmab);
 		break;
+#endif /* CONFIG_GENERIC_ALLOCATOR */
 	case SNDRV_DMA_TYPE_DEV:
 		snd_free_dev_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
 		break;

commit 055032142c42d2821c4aa617915292d6a08d56fc
Author: Nicolin Chen <b42378@freescale.com>
Date:   Wed Oct 23 11:47:43 2013 +0800

    ALSA: Add SoC on-chip internal ram support for DMA buffer allocation
    
    Now it's quite common that an SoC contains its on-chip internal RAM.
    By using this RAM space for DMA buffer during audio playback/record,
    we can shutdown the voltage for external RAM to save power.
    
    So add new DEV type with iram malloc()/free() and accordingly modify
    current default mmap() for the iram circumstance.
    
    Signed-off-by: Nicolin Chen <b42378@freescale.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index bdf826f4fe0c..18c1d4759ccb 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -30,6 +30,7 @@
 #include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include <linux/dma-mapping.h>
+#include <linux/genalloc.h>
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
 #include <sound/memalloc.h>
@@ -157,6 +158,46 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
 	dec_snd_pages(pg);
 	dma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);
 }
+
+/**
+ * snd_malloc_dev_iram - allocate memory from on-chip internal ram
+ * @dmab: buffer allocation record to store the allocated data
+ * @size: number of bytes to allocate from the iram
+ *
+ * This function requires iram phandle provided via of_node
+ */
+void snd_malloc_dev_iram(struct snd_dma_buffer *dmab, size_t size)
+{
+	struct device *dev = dmab->dev.dev;
+	struct gen_pool *pool = NULL;
+
+	if (dev->of_node)
+		pool = of_get_named_gen_pool(dev->of_node, "iram", 0);
+
+	if (!pool)
+		return;
+
+	/* Assign the pool into private_data field */
+	dmab->private_data = pool;
+
+	dmab->area = (void *)gen_pool_alloc(pool, size);
+	if (!dmab->area)
+		return;
+
+	dmab->addr = gen_pool_virt_to_phys(pool, (unsigned long)dmab->area);
+}
+
+/**
+ * snd_free_dev_iram - free allocated specific memory from on-chip internal ram
+ * @dmab: buffer allocation record to store the allocated data
+ */
+void snd_free_dev_iram(struct snd_dma_buffer *dmab)
+{
+	struct gen_pool *pool = dmab->private_data;
+
+	if (pool && dmab->area)
+		gen_pool_free(pool, (unsigned long)dmab->area, dmab->bytes);
+}
 #endif /* CONFIG_HAS_DMA */
 
 /*
@@ -197,6 +238,14 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		dmab->addr = 0;
 		break;
 #ifdef CONFIG_HAS_DMA
+	case SNDRV_DMA_TYPE_DEV_IRAM:
+		snd_malloc_dev_iram(dmab, size);
+		if (dmab->area)
+			break;
+		/* Internal memory might have limited size and no enough space,
+		 * so if we fail to malloc, try to fetch memory traditionally.
+		 */
+		dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 	case SNDRV_DMA_TYPE_DEV:
 		dmab->area = snd_malloc_dev_pages(device, size, &dmab->addr);
 		break;
@@ -269,6 +318,9 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 		snd_free_pages(dmab->area, dmab->bytes);
 		break;
 #ifdef CONFIG_HAS_DMA
+	case SNDRV_DMA_TYPE_DEV_IRAM:
+		snd_free_dev_iram(dmab);
+		break;
 	case SNDRV_DMA_TYPE_DEV:
 		snd_free_dev_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
 		break;

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 691569238435..bdf826f4fe0c 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -81,7 +81,7 @@ static inline void dec_snd_pages(int order)
  *
  * Allocates the physically contiguous pages with the given size.
  *
- * Returns the pointer of the buffer, or NULL if no enoguh memory.
+ * Return: The pointer of the buffer, or %NULL if no enough memory.
  */
 void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
 {
@@ -175,9 +175,9 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
  *
  * Calls the memory-allocator function for the corresponding
  * buffer type.
- * 
- * Returns zero if the buffer with the given size is allocated successfully,
- * other a negative value at error.
+ *
+ * Return: Zero if the buffer with the given size is allocated successfully,
+ * otherwise a negative value on error.
  */
 int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 			struct snd_dma_buffer *dmab)
@@ -229,9 +229,9 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
  * buffer type.  When no space is left, this function reduces the size and
  * tries to allocate again.  The size actually allocated is stored in
  * res_size argument.
- * 
- * Returns zero if the buffer with the given size is allocated successfully,
- * other a negative value at error.
+ *
+ * Return: Zero if the buffer with the given size is allocated successfully,
+ * otherwise a negative value on error.
  */
 int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,
 				 struct snd_dma_buffer *dmab)
@@ -292,7 +292,7 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
  * Looks for the reserved-buffer list and re-uses if the same buffer
  * is found in the list.  When the buffer is found, it's removed from the free list.
  *
- * Returns the size of buffer if the buffer is found, or zero if not found.
+ * Return: The size of buffer if the buffer is found, or zero if not found.
  */
 size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
 {
@@ -326,8 +326,8 @@ size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
  * @id: the buffer id
  *
  * Reserves the given buffer as a reserved buffer.
- * 
- * Returns zero if successful, or a negative code at error.
+ *
+ * Return: Zero if successful, or a negative code on error.
  */
 int snd_dma_reserve_buf(struct snd_dma_buffer *dmab, unsigned int id)
 {

commit bfb9035c98906aafcd3cf22694fba2550997bf53
Author: Joe Perches <joe@perches.com>
Date:   Wed Aug 17 06:58:04 2011 -0700

    treewide: Correct spelling of successfully in comments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 16bd9c03679b..691569238435 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -176,7 +176,7 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
  * Calls the memory-allocator function for the corresponding
  * buffer type.
  * 
- * Returns zero if the buffer with the given size is allocated successfuly,
+ * Returns zero if the buffer with the given size is allocated successfully,
  * other a negative value at error.
  */
 int snd_dma_alloc_pages(int type, struct device *device, size_t size,
@@ -230,7 +230,7 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
  * tries to allocate again.  The size actually allocated is stored in
  * res_size argument.
  * 
- * Returns zero if the buffer with the given size is allocated successfuly,
+ * Returns zero if the buffer with the given size is allocated successfully,
  * other a negative value at error.
  */
 int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,

commit fea952e5cc23ea94b4677ca20774cdc3cea014e2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Feb 14 11:00:47 2011 +0100

    ALSA: core: sparse cleanups
    
    Change the core code where sparse complains.  In most cases, this means
    just adding annotations to confirm that we indeed want to do the dirty
    things we're doing.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 9e92441f9b78..16bd9c03679b 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -192,7 +192,8 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 	dmab->bytes = 0;
 	switch (type) {
 	case SNDRV_DMA_TYPE_CONTINUOUS:
-		dmab->area = snd_malloc_pages(size, (unsigned long)device);
+		dmab->area = snd_malloc_pages(size,
+					(__force gfp_t)(unsigned long)device);
 		dmab->addr = 0;
 		break;
 #ifdef CONFIG_HAS_DMA

commit cc6a8acdeee932f6911d8b236d2c7d6bcc4616f6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 17 16:39:06 2008 +0200

    ALSA: Fix SG-buffer DMA with non-coherent architectures
    
    Using SG-buffers with dma_alloc_coherent() is often very inefficient
    on non-coherent architectures because a tracking record could be
    allocated in addition for each dma_alloc_coherent() call.
    Instead, simply disable SG-buffers but just allocate normal continuous
    buffers on non-supported (currently all but x86) architectures.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 1b3534d67686..9e92441f9b78 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -199,6 +199,8 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 	case SNDRV_DMA_TYPE_DEV:
 		dmab->area = snd_malloc_dev_pages(device, size, &dmab->addr);
 		break;
+#endif
+#ifdef CONFIG_SND_DMA_SGBUF
 	case SNDRV_DMA_TYPE_DEV_SG:
 		snd_malloc_sgbuf_pages(device, size, dmab, NULL);
 		break;
@@ -269,6 +271,8 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 	case SNDRV_DMA_TYPE_DEV:
 		snd_free_dev_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
 		break;
+#endif
+#ifdef CONFIG_SND_DMA_SGBUF
 	case SNDRV_DMA_TYPE_DEV_SG:
 		snd_free_sgbuf_pages(dmab);
 		break;

commit 56c5d900dbb8e042bfad035d18433476931d8f93
Merge: 4dd95b63ae25 ead9d23d803e
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Oct 11 12:39:35 2008 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            sound/core/memalloc.c

commit 759ee81be6d87c150ea2b300c221b4fec8b5f646
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 00:33:26 2008 -0700

    alsa: Remove special SBUS dma support code.
    
    No longer used.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index ccaaac45fafb..3733351a27f2 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -33,9 +33,6 @@
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
 #include <sound/memalloc.h>
-#ifdef CONFIG_SBUS
-#include <asm/sbus.h>
-#endif
 
 
 MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>, Jaroslav Kysela <perex@perex.cz>");
@@ -180,41 +177,6 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
 }
 #endif /* CONFIG_HAS_DMA */
 
-#ifdef CONFIG_SBUS
-
-static void *snd_malloc_sbus_pages(struct device *dev, size_t size,
-				   dma_addr_t *dma_addr)
-{
-	struct sbus_dev *sdev = (struct sbus_dev *)dev;
-	int pg;
-	void *res;
-
-	snd_assert(size > 0, return NULL);
-	snd_assert(dma_addr != NULL, return NULL);
-	pg = get_order(size);
-	res = dma_alloc_coherent(&sdev->ofdev.dev, PAGE_SIZE * (1 << pg),
-				 dma_addr, GFP_ATOMIC);
-	if (res != NULL)
-		inc_snd_pages(pg);
-	return res;
-}
-
-static void snd_free_sbus_pages(struct device *dev, size_t size,
-				void *ptr, dma_addr_t dma_addr)
-{
-	struct sbus_dev *sdev = (struct sbus_dev *)dev;
-	int pg;
-
-	if (ptr == NULL)
-		return;
-	pg = get_order(size);
-	dec_snd_pages(pg);
-	dma_free_coherent(&sdev->ofdev.dev, PAGE_SIZE * (1 << pg),
-			  ptr, dma_addr);
-}
-
-#endif /* CONFIG_SBUS */
-
 /*
  *
  *  ALSA generic memory management
@@ -249,11 +211,6 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		dmab->area = snd_malloc_pages(size, (unsigned long)device);
 		dmab->addr = 0;
 		break;
-#ifdef CONFIG_SBUS
-	case SNDRV_DMA_TYPE_SBUS:
-		dmab->area = snd_malloc_sbus_pages(device, size, &dmab->addr);
-		break;
-#endif
 #ifdef CONFIG_HAS_DMA
 	case SNDRV_DMA_TYPE_DEV:
 		dmab->area = snd_malloc_dev_pages(device, size, &dmab->addr);
@@ -322,11 +279,6 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 	case SNDRV_DMA_TYPE_CONTINUOUS:
 		snd_free_pages(dmab->area, dmab->bytes);
 		break;
-#ifdef CONFIG_SBUS
-	case SNDRV_DMA_TYPE_SBUS:
-		snd_free_sbus_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
-		break;
-#endif
 #ifdef CONFIG_HAS_DMA
 	case SNDRV_DMA_TYPE_DEV:
 		snd_free_dev_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
@@ -433,7 +385,7 @@ static int snd_mem_proc_read(struct seq_file *seq, void *offset)
 	long pages = snd_allocated_pages >> (PAGE_SHIFT-12);
 	struct snd_mem_list *mem;
 	int devno;
-	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG", "SBUS" };
+	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG" };
 
 	mutex_lock(&list_mutex);
 	seq_printf(seq, "pages  : %li bytes (%li pages per %likB)\n",

commit 738f2b7b813913e651f39387d007dd961755dee2
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 18:09:11 2008 -0700

    sparc: Convert all SBUS drivers to dma_*() interfaces.
    
    And all the SBUS dma interfaces are deleted.
    
    A private implementation remains inside of the 32-bit sparc port which
    exists only for the sake of the implementation of dma_*().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index cc803972c0fb..ccaaac45fafb 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -192,8 +192,8 @@ static void *snd_malloc_sbus_pages(struct device *dev, size_t size,
 	snd_assert(size > 0, return NULL);
 	snd_assert(dma_addr != NULL, return NULL);
 	pg = get_order(size);
-	res = sbus_alloc_consistent(&sdev->ofdev.dev, PAGE_SIZE * (1 << pg),
-				    dma_addr);
+	res = dma_alloc_coherent(&sdev->ofdev.dev, PAGE_SIZE * (1 << pg),
+				 dma_addr, GFP_ATOMIC);
 	if (res != NULL)
 		inc_snd_pages(pg);
 	return res;
@@ -209,8 +209,8 @@ static void snd_free_sbus_pages(struct device *dev, size_t size,
 		return;
 	pg = get_order(size);
 	dec_snd_pages(pg);
-	sbus_free_consistent(&sdev->ofdev.dev, PAGE_SIZE * (1 << pg),
-			     ptr, dma_addr);
+	dma_free_coherent(&sdev->ofdev.dev, PAGE_SIZE * (1 << pg),
+			  ptr, dma_addr);
 }
 
 #endif /* CONFIG_SBUS */

commit 7a715f46012f3552294154978aed59cba9804928
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 18:37:58 2008 -0700

    sparc: Make SBUS DMA interfaces take struct device.
    
    This is the first step in converting all the SBUS drivers
    over to generic dma_*().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index f5d6d8d12979..cc803972c0fb 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -192,7 +192,8 @@ static void *snd_malloc_sbus_pages(struct device *dev, size_t size,
 	snd_assert(size > 0, return NULL);
 	snd_assert(dma_addr != NULL, return NULL);
 	pg = get_order(size);
-	res = sbus_alloc_consistent(sdev, PAGE_SIZE * (1 << pg), dma_addr);
+	res = sbus_alloc_consistent(&sdev->ofdev.dev, PAGE_SIZE * (1 << pg),
+				    dma_addr);
 	if (res != NULL)
 		inc_snd_pages(pg);
 	return res;
@@ -208,7 +209,8 @@ static void snd_free_sbus_pages(struct device *dev, size_t size,
 		return;
 	pg = get_order(size);
 	dec_snd_pages(pg);
-	sbus_free_consistent(sdev, PAGE_SIZE * (1 << pg), ptr, dma_addr);
+	sbus_free_consistent(&sdev->ofdev.dev, PAGE_SIZE * (1 << pg),
+			     ptr, dma_addr);
 }
 
 #endif /* CONFIG_SBUS */

commit 4e184f8fc06411f35fdcf4b9bc6187c857bf7214
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 30 15:13:33 2008 +0200

    ALSA: Fix allocation size calculation in snd_dma_alloc_pages_fallback()
    
    snd_dma_alloc_pages_fallback() always tries to reduce the size in a half,
    but it's not good when the given size isn't a power-of-two.
    Check it first then try to align.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index f0c3b1d6da81..a7b46ec72f32 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -277,11 +277,16 @@ int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,
 	int err;
 
 	while ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {
+		size_t aligned_size;
 		if (err != -ENOMEM)
 			return err;
-		size >>= 1;
 		if (size <= PAGE_SIZE)
 			return -ENOMEM;
+		aligned_size = PAGE_SIZE << get_order(size);
+		if (size != aligned_size)
+			size = aligned_size;
+		else
+			size >>= 1;
 	}
 	if (! dmab->area)
 		return -ENOMEM;

commit 77a23f2695bb2de0cd74599400dc55109c531b72
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 21 13:00:13 2008 +0200

    ALSA: Clean up SG-buffer helper functions and macros
    
    Clean up SG-buffer helper functions and macros.  Helpers take substream
    as arguments now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 4a649976cc8a..f0c3b1d6da81 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -43,14 +43,6 @@ MODULE_DESCRIPTION("Memory allocator for ALSA system.");
 MODULE_LICENSE("GPL");
 
 
-/*
- */
-
-void *snd_malloc_sgbuf_pages(struct device *device,
-                             size_t size, struct snd_dma_buffer *dmab,
-			     size_t *res_size);
-int snd_free_sgbuf_pages(struct snd_dma_buffer *dmab);
-
 /*
  */
 

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index f5d6d8d12979..4a649976cc8a 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -67,18 +67,6 @@ struct snd_mem_list {
 /* id for pre-allocated buffers */
 #define SNDRV_DMA_DEVICE_UNUSED (unsigned int)-1
 
-#ifdef CONFIG_SND_DEBUG
-#define __ASTRING__(x) #x
-#define snd_assert(expr, args...) do {\
-	if (!(expr)) {\
-		printk(KERN_ERR "snd-malloc: BUG? (%s) (called from %p)\n", __ASTRING__(expr), __builtin_return_address(0));\
-		args;\
-	}\
-} while (0)
-#else
-#define snd_assert(expr, args...) /**/
-#endif
-
 /*
  *
  *  Generic memory allocators
@@ -111,8 +99,10 @@ void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
 	int pg;
 	void *res;
 
-	snd_assert(size > 0, return NULL);
-	snd_assert(gfp_flags != 0, return NULL);
+	if (WARN_ON(!size))
+		return NULL;
+	if (WARN_ON(!gfp_flags))
+		return NULL;
 	gfp_flags |= __GFP_COMP;	/* compound page lets parts be mapped */
 	pg = get_order(size);
 	if ((res = (void *) __get_free_pages(gfp_flags, pg)) != NULL)
@@ -152,8 +142,8 @@ static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *d
 	void *res;
 	gfp_t gfp_flags;
 
-	snd_assert(size > 0, return NULL);
-	snd_assert(dma != NULL, return NULL);
+	if (WARN_ON(!dma))
+		return NULL;
 	pg = get_order(size);
 	gfp_flags = GFP_KERNEL
 		| __GFP_COMP	/* compound page lets parts be mapped */
@@ -189,8 +179,8 @@ static void *snd_malloc_sbus_pages(struct device *dev, size_t size,
 	int pg;
 	void *res;
 
-	snd_assert(size > 0, return NULL);
-	snd_assert(dma_addr != NULL, return NULL);
+	if (WARN_ON(!dma_addr))
+		return NULL;
 	pg = get_order(size);
 	res = sbus_alloc_consistent(sdev, PAGE_SIZE * (1 << pg), dma_addr);
 	if (res != NULL)
@@ -236,8 +226,10 @@ static void snd_free_sbus_pages(struct device *dev, size_t size,
 int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 			struct snd_dma_buffer *dmab)
 {
-	snd_assert(size > 0, return -ENXIO);
-	snd_assert(dmab != NULL, return -ENXIO);
+	if (WARN_ON(!size))
+		return -ENXIO;
+	if (WARN_ON(!dmab))
+		return -ENXIO;
 
 	dmab->dev.type = type;
 	dmab->dev.dev = device;
@@ -292,9 +284,6 @@ int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,
 {
 	int err;
 
-	snd_assert(size > 0, return -ENXIO);
-	snd_assert(dmab != NULL, return -ENXIO);
-
 	while ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {
 		if (err != -ENOMEM)
 			return err;
@@ -353,7 +342,8 @@ size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
 {
 	struct snd_mem_list *mem;
 
-	snd_assert(dmab, return 0);
+	if (WARN_ON(!dmab))
+		return 0;
 
 	mutex_lock(&list_mutex);
 	list_for_each_entry(mem, &mem_list_head, list) {
@@ -387,7 +377,8 @@ int snd_dma_reserve_buf(struct snd_dma_buffer *dmab, unsigned int id)
 {
 	struct snd_mem_list *mem;
 
-	snd_assert(dmab, return -EINVAL);
+	if (WARN_ON(!dmab))
+		return -EINVAL;
 	mem = kmalloc(sizeof(*mem), GFP_KERNEL);
 	if (! mem)
 		return -ENOMEM;

commit c17cf06bfc4417a79d452c266e819c510f6a8344
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 9 12:45:56 2008 +0200

    [ALSA] Remove unneeded ugly hack for i386 in memalloc.c
    
    The hack for dma_alloc_coherent() is no longer needed on 2.6.26 since
    the base code was improved.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 23b7bc02728b..f5d6d8d12979 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -79,68 +79,6 @@ struct snd_mem_list {
 #define snd_assert(expr, args...) /**/
 #endif
 
-/*
- *  Hacks
- */
-
-#if defined(__i386__)
-/*
- * A hack to allocate large buffers via dma_alloc_coherent()
- *
- * since dma_alloc_coherent always tries GFP_DMA when the requested
- * pci memory region is below 32bit, it happens quite often that even
- * 2 order of pages cannot be allocated.
- *
- * so in the following, we allocate at first without dma_mask, so that
- * allocation will be done without GFP_DMA.  if the area doesn't match
- * with the requested region, then realloate with the original dma_mask
- * again.
- *
- * Really, we want to move this type of thing into dma_alloc_coherent()
- * so dma_mask doesn't have to be messed with.
- */
-
-static void *snd_dma_hack_alloc_coherent(struct device *dev, size_t size,
-					 dma_addr_t *dma_handle,
-					 gfp_t flags)
-{
-	void *ret;
-	u64 dma_mask, coherent_dma_mask;
-
-	if (dev == NULL || !dev->dma_mask)
-		return dma_alloc_coherent(dev, size, dma_handle, flags);
-	dma_mask = *dev->dma_mask;
-	coherent_dma_mask = dev->coherent_dma_mask;
-	*dev->dma_mask = 0xffffffff; 	/* do without masking */
-	dev->coherent_dma_mask = 0xffffffff; 	/* do without masking */
-	ret = dma_alloc_coherent(dev, size, dma_handle, flags);
-	*dev->dma_mask = dma_mask;	/* restore */
-	dev->coherent_dma_mask = coherent_dma_mask;	/* restore */
-	if (ret) {
-		/* obtained address is out of range? */
-		if (((unsigned long)*dma_handle + size - 1) & ~dma_mask) {
-			/* reallocate with the proper mask */
-			dma_free_coherent(dev, size, ret, *dma_handle);
-			ret = dma_alloc_coherent(dev, size, dma_handle, flags);
-		}
-	} else {
-		/* wish to success now with the proper mask... */
-		if (dma_mask != 0xffffffffUL) {
-			/* allocation with GFP_ATOMIC to avoid the long stall */
-			flags &= ~GFP_KERNEL;
-			flags |= GFP_ATOMIC;
-			ret = dma_alloc_coherent(dev, size, dma_handle, flags);
-		}
-	}
-	return ret;
-}
-
-/* redefine dma_alloc_coherent for some architectures */
-#undef dma_alloc_coherent
-#define dma_alloc_coherent snd_dma_hack_alloc_coherent
-
-#endif /* arch */
-
 /*
  *
  *  Generic memory allocators

commit 7bf4e6d3e948e38893c718fa9c5bd0dfbfa49670
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Apr 29 01:02:13 2008 -0700

    sound: use non-racy method for /proc/driver/snd-page-alloc creation
    
    Use proc_create() to make sure that ->proc_fops be setup before gluing PDE to
    main tree.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 920e5780c228..23b7bc02728b 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -629,9 +629,8 @@ static const struct file_operations snd_mem_proc_fops = {
 static int __init snd_mem_init(void)
 {
 #ifdef CONFIG_PROC_FS
-	snd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);
-	if (snd_mem_proc)
-		snd_mem_proc->proc_fops = &snd_mem_proc_fops;
+	snd_mem_proc = proc_create(SND_MEM_PROC_FILE, 0644, NULL,
+				   &snd_mem_proc_fops);
 #endif
 	return 0;
 }

commit df1deb67532ea26f1a033a5f48bf34b30bec8e1d
Author: Julia Lawall <julia@diku.dk>
Date:   Wed Nov 28 11:58:56 2007 +0100

    [ALSA] sound/core/memalloc.c: Add missing pci_dev_put
    
    There should be a pci_dev_put when breaking out of a loop that iterates
    over calls to pci_get_device and similar functions.
    In this case, the return under the initial if needs a pci_dev_put in the
    same way that the return under the subsequent for loop has a pci_dev_put.
    This was fixed using the following semantic patch.
    // <smpl>
    @@
    type T;
    identifier d;
    expression e;
    @@
    T *d;
    ...
    while ((d = \(pci_get_device\|pci_get_device_reverse\|pci_get_subsys\|pci_get_class\)(..., d)) != NULL)
      {... when != pci_dev_put(d)
           when != e = d
    (
        return d;
    |
    +  pci_dev_put(d);
    ?  return ...;
    )
    ...}
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 9b4992eab479..920e5780c228 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -568,6 +568,7 @@ static ssize_t snd_mem_proc_write(struct file *file, const char __user * buffer,
 				if (pci_set_dma_mask(pci, mask) < 0 ||
 				    pci_set_consistent_dma_mask(pci, mask) < 0) {
 					printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", mask, vendor, device);
+					pci_dev_put(pci);
 					return count;
 				}
 			}

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 6f99b6f54870..9b4992eab479 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *                   Takashi Iwai <tiwai@suse.de>
  * 
  *  Generic memory allocators
@@ -38,7 +38,7 @@
 #endif
 
 
-MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>, Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>, Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("Memory allocator for ALSA system.");
 MODULE_LICENSE("GPL");
 

commit 8f11551b1798170dcffdd28475075ca4f1c6c990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 26 18:59:36 2007 +0200

    [ALSA] Fix build error without CONFIG_HAS_DMA
    
    The recent change of include/asm-generic/dma-mapping-broken.h breaks
    the build without CONFIG_HAS_DMA.  This patch is an ad hoc fix.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 9b5656d8bcca..6f99b6f54870 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -206,6 +206,7 @@ void snd_free_pages(void *ptr, size_t size)
  *
  */
 
+#ifdef CONFIG_HAS_DMA
 /* allocate the coherent DMA pages */
 static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *dma)
 {
@@ -239,6 +240,7 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
 	dec_snd_pages(pg);
 	dma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);
 }
+#endif /* CONFIG_HAS_DMA */
 
 #ifdef CONFIG_SBUS
 
@@ -312,12 +314,14 @@ int snd_dma_alloc_pages(int type, struct device *device, size_t size,
 		dmab->area = snd_malloc_sbus_pages(device, size, &dmab->addr);
 		break;
 #endif
+#ifdef CONFIG_HAS_DMA
 	case SNDRV_DMA_TYPE_DEV:
 		dmab->area = snd_malloc_dev_pages(device, size, &dmab->addr);
 		break;
 	case SNDRV_DMA_TYPE_DEV_SG:
 		snd_malloc_sgbuf_pages(device, size, dmab, NULL);
 		break;
+#endif
 	default:
 		printk(KERN_ERR "snd-malloc: invalid device type %d\n", type);
 		dmab->area = NULL;
@@ -383,12 +387,14 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
 		snd_free_sbus_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
 		break;
 #endif
+#ifdef CONFIG_HAS_DMA
 	case SNDRV_DMA_TYPE_DEV:
 		snd_free_dev_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
 		break;
 	case SNDRV_DMA_TYPE_DEV_SG:
 		snd_free_sgbuf_pages(dmab);
 		break;
+#endif
 	default:
 		printk(KERN_ERR "snd-malloc: invalid device type %d\n", dmab->dev.type);
 	}

commit ccec6e2c4a74adf76ed4e2478091a311b1806212
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 17 21:55:10 2007 +0200

    Convert snd-page-alloc proc file to use seq_file
    
    Use seq_file for the proc file read/write of snd-page-alloc module.
    This automatically fixes bugs in the old proc code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index f057430db0d0..9b5656d8bcca 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -27,6 +27,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
+#include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include <linux/dma-mapping.h>
 #include <linux/moduleparam.h>
@@ -481,53 +482,54 @@ static void free_all_reserved_pages(void)
 #define SND_MEM_PROC_FILE	"driver/snd-page-alloc"
 static struct proc_dir_entry *snd_mem_proc;
 
-static int snd_mem_proc_read(char *page, char **start, off_t off,
-			     int count, int *eof, void *data)
+static int snd_mem_proc_read(struct seq_file *seq, void *offset)
 {
-	int len = 0;
 	long pages = snd_allocated_pages >> (PAGE_SHIFT-12);
 	struct snd_mem_list *mem;
 	int devno;
 	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG", "SBUS" };
 
 	mutex_lock(&list_mutex);
-	len += snprintf(page + len, count - len,
-			"pages  : %li bytes (%li pages per %likB)\n",
-			pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
+	seq_printf(seq, "pages  : %li bytes (%li pages per %likB)\n",
+		   pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
 	devno = 0;
 	list_for_each_entry(mem, &mem_list_head, list) {
 		devno++;
-		len += snprintf(page + len, count - len,
-				"buffer %d : ID %08x : type %s\n",
-				devno, mem->id, types[mem->buffer.dev.type]);
-		len += snprintf(page + len, count - len,
-				"  addr = 0x%lx, size = %d bytes\n",
-				(unsigned long)mem->buffer.addr, (int)mem->buffer.bytes);
+		seq_printf(seq, "buffer %d : ID %08x : type %s\n",
+			   devno, mem->id, types[mem->buffer.dev.type]);
+		seq_printf(seq, "  addr = 0x%lx, size = %d bytes\n",
+			   (unsigned long)mem->buffer.addr,
+			   (int)mem->buffer.bytes);
 	}
 	mutex_unlock(&list_mutex);
-	return len;
+	return 0;
+}
+
+static int snd_mem_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, snd_mem_proc_read, NULL);
 }
 
 /* FIXME: for pci only - other bus? */
 #ifdef CONFIG_PCI
 #define gettoken(bufp) strsep(bufp, " \t\n")
 
-static int snd_mem_proc_write(struct file *file, const char __user *buffer,
-			      unsigned long count, void *data)
+static ssize_t snd_mem_proc_write(struct file *file, const char __user * buffer,
+				  size_t count, loff_t * ppos)
 {
 	char buf[128];
 	char *token, *p;
 
-	if (count > ARRAY_SIZE(buf) - 1)
-		count = ARRAY_SIZE(buf) - 1;
+	if (count > sizeof(buf) - 1)
+		return -EINVAL;
 	if (copy_from_user(buf, buffer, count))
 		return -EFAULT;
-	buf[ARRAY_SIZE(buf) - 1] = '\0';
+	buf[count] = '\0';
 
 	p = buf;
 	token = gettoken(&p);
 	if (! token || *token == '#')
-		return (int)count;
+		return count;
 	if (strcmp(token, "add") == 0) {
 		char *endp;
 		int vendor, device, size, buffers;
@@ -548,7 +550,7 @@ static int snd_mem_proc_write(struct file *file, const char __user *buffer,
 		    (buffers = simple_strtol(token, NULL, 0)) <= 0 ||
 		    buffers > 4) {
 			printk(KERN_ERR "snd-page-alloc: invalid proc write format\n");
-			return (int)count;
+			return count;
 		}
 		vendor &= 0xffff;
 		device &= 0xffff;
@@ -560,7 +562,7 @@ static int snd_mem_proc_write(struct file *file, const char __user *buffer,
 				if (pci_set_dma_mask(pci, mask) < 0 ||
 				    pci_set_consistent_dma_mask(pci, mask) < 0) {
 					printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", mask, vendor, device);
-					return (int)count;
+					return count;
 				}
 			}
 			for (i = 0; i < buffers; i++) {
@@ -570,7 +572,7 @@ static int snd_mem_proc_write(struct file *file, const char __user *buffer,
 							size, &dmab) < 0) {
 					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
 					pci_dev_put(pci);
-					return (int)count;
+					return count;
 				}
 				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));
 			}
@@ -596,9 +598,21 @@ static int snd_mem_proc_write(struct file *file, const char __user *buffer,
 		free_all_reserved_pages();
 	else
 		printk(KERN_ERR "snd-page-alloc: invalid proc cmd\n");
-	return (int)count;
+	return count;
 }
 #endif /* CONFIG_PCI */
+
+static const struct file_operations snd_mem_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= snd_mem_proc_open,
+	.read		= seq_read,
+#ifdef CONFIG_PCI
+	.write		= snd_mem_proc_write,
+#endif
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 #endif /* CONFIG_PROC_FS */
 
 /*
@@ -609,12 +623,8 @@ static int __init snd_mem_init(void)
 {
 #ifdef CONFIG_PROC_FS
 	snd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);
-	if (snd_mem_proc) {
-		snd_mem_proc->read_proc = snd_mem_proc_read;
-#ifdef CONFIG_PCI
-		snd_mem_proc->write_proc = snd_mem_proc_write;
-#endif
-	}
+	if (snd_mem_proc)
+		snd_mem_proc->proc_fops = &snd_mem_proc_fops;
 #endif
 	return 0;
 }

commit 9244b2c3079faac79b3b961116bd548c45087e2c
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 5 16:02:22 2006 +0200

    [ALSA] alsa core: convert to list_for_each_entry*
    
    This patch converts most uses of list_for_each to list_for_each_entry all
    across alsa. In some place apparently an item can be on a list with
    different pointers so of course that isn't compatible with list_for_each, I
    therefore didn't touch those places.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index bc0bd0910a62..f057430db0d0 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -406,19 +406,17 @@ void snd_dma_free_pages(struct snd_dma_buffer *dmab)
  */
 size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
 {
-	struct list_head *p;
 	struct snd_mem_list *mem;
 
 	snd_assert(dmab, return 0);
 
 	mutex_lock(&list_mutex);
-	list_for_each(p, &mem_list_head) {
-		mem = list_entry(p, struct snd_mem_list, list);
+	list_for_each_entry(mem, &mem_list_head, list) {
 		if (mem->id == id &&
 		    (mem->buffer.dev.dev == NULL || dmab->dev.dev == NULL ||
 		     ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev)))) {
 			struct device *dev = dmab->dev.dev;
-			list_del(p);
+			list_del(&mem->list);
 			*dmab = mem->buffer;
 			if (dmab->dev.dev == NULL)
 				dmab->dev.dev = dev;
@@ -488,7 +486,6 @@ static int snd_mem_proc_read(char *page, char **start, off_t off,
 {
 	int len = 0;
 	long pages = snd_allocated_pages >> (PAGE_SHIFT-12);
-	struct list_head *p;
 	struct snd_mem_list *mem;
 	int devno;
 	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG", "SBUS" };
@@ -498,8 +495,7 @@ static int snd_mem_proc_read(char *page, char **start, off_t off,
 			"pages  : %li bytes (%li pages per %likB)\n",
 			pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
 	devno = 0;
-	list_for_each(p, &mem_list_head) {
-		mem = list_entry(p, struct snd_mem_list, list);
+	list_for_each_entry(mem, &mem_list_head, list) {
 		devno++;
 		len += snprintf(page + len, count - len,
 				"buffer %d : ID %08x : type %s\n",

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 3fc6f97075ed..bc0bd0910a62 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -21,7 +21,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/proc_fs.h>
 #include <linux/init.h>

commit 2ba8c15c738b64b4d3acaace1e19750362ff2b69
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 31 14:44:28 2006 +0100

    [ALSA] Removed unneeded page-reserve
    
    Modules: Memalloc module
    
    Removed unneeded page-reservation.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 8360418d333e..3fc6f97075ed 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -141,10 +141,6 @@ static void *snd_dma_hack_alloc_coherent(struct device *dev, size_t size,
 
 #endif /* arch */
 
-#if ! defined(__arm__)
-#define NEED_RESERVE_PAGES
-#endif
-
 /*
  *
  *  Generic memory allocators
@@ -163,20 +159,6 @@ static inline void dec_snd_pages(int order)
 	snd_allocated_pages -= 1 << order;
 }
 
-static void mark_pages(struct page *page, int order)
-{
-	struct page *last_page = page + (1 << order);
-	while (page < last_page)
-		SetPageReserved(page++);
-}
-
-static void unmark_pages(struct page *page, int order)
-{
-	struct page *last_page = page + (1 << order);
-	while (page < last_page)
-		ClearPageReserved(page++);
-}
-
 /**
  * snd_malloc_pages - allocate pages with the given size
  * @size: the size to allocate in bytes
@@ -195,10 +177,8 @@ void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
 	snd_assert(gfp_flags != 0, return NULL);
 	gfp_flags |= __GFP_COMP;	/* compound page lets parts be mapped */
 	pg = get_order(size);
-	if ((res = (void *) __get_free_pages(gfp_flags, pg)) != NULL) {
-		mark_pages(virt_to_page(res), pg);
+	if ((res = (void *) __get_free_pages(gfp_flags, pg)) != NULL)
 		inc_snd_pages(pg);
-	}
 	return res;
 }
 
@@ -217,7 +197,6 @@ void snd_free_pages(void *ptr, size_t size)
 		return;
 	pg = get_order(size);
 	dec_snd_pages(pg);
-	unmark_pages(virt_to_page(ptr), pg);
 	free_pages((unsigned long) ptr, pg);
 }
 
@@ -242,12 +221,8 @@ static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *d
 		| __GFP_NORETRY /* don't trigger OOM-killer */
 		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
 	res = dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);
-	if (res != NULL) {
-#ifdef NEED_RESERVE_PAGES
-		mark_pages(virt_to_page(res), pg); /* should be dma_to_page() */
-#endif
+	if (res != NULL)
 		inc_snd_pages(pg);
-	}
 
 	return res;
 }
@@ -262,9 +237,6 @@ static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
 		return;
 	pg = get_order(size);
 	dec_snd_pages(pg);
-#ifdef NEED_RESERVE_PAGES
-	unmark_pages(virt_to_page(ptr), pg); /* should be dma_to_page() */
-#endif
 	dma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);
 }
 

commit ea50888d83cfb797ff7efadedc033b33bc2064bc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 23 15:49:18 2006 +0100

    [ALSA] Use dma_alloc_coherent() hack on i386 only
    
    Modules: Memalloc module
    
    Use dma_alloc_coherent() hack on i386 only (as a valid arch).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 9f2b88cb5877..8360418d333e 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -83,7 +83,7 @@ struct snd_mem_list {
  *  Hacks
  */
 
-#if defined(__i386__) || defined(__ppc__) || defined(__x86_64__)
+#if defined(__i386__)
 /*
  * A hack to allocate large buffers via dma_alloc_coherent()
  *

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 19b3dcbb09c2..9f2b88cb5877 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -31,7 +31,7 @@
 #include <asm/uaccess.h>
 #include <linux/dma-mapping.h>
 #include <linux/moduleparam.h>
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
 #include <sound/memalloc.h>
 #ifdef CONFIG_SBUS
 #include <asm/sbus.h>
@@ -54,7 +54,7 @@ int snd_free_sgbuf_pages(struct snd_dma_buffer *dmab);
 /*
  */
 
-static DECLARE_MUTEX(list_mutex);
+static DEFINE_MUTEX(list_mutex);
 static LIST_HEAD(mem_list_head);
 
 /* buffer preservation list */
@@ -440,7 +440,7 @@ size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
 
 	snd_assert(dmab, return 0);
 
-	down(&list_mutex);
+	mutex_lock(&list_mutex);
 	list_for_each(p, &mem_list_head) {
 		mem = list_entry(p, struct snd_mem_list, list);
 		if (mem->id == id &&
@@ -452,11 +452,11 @@ size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
 			if (dmab->dev.dev == NULL)
 				dmab->dev.dev = dev;
 			kfree(mem);
-			up(&list_mutex);
+			mutex_unlock(&list_mutex);
 			return dmab->bytes;
 		}
 	}
-	up(&list_mutex);
+	mutex_unlock(&list_mutex);
 	return 0;
 }
 
@@ -477,11 +477,11 @@ int snd_dma_reserve_buf(struct snd_dma_buffer *dmab, unsigned int id)
 	mem = kmalloc(sizeof(*mem), GFP_KERNEL);
 	if (! mem)
 		return -ENOMEM;
-	down(&list_mutex);
+	mutex_lock(&list_mutex);
 	mem->buffer = *dmab;
 	mem->id = id;
 	list_add_tail(&mem->list, &mem_list_head);
-	up(&list_mutex);
+	mutex_unlock(&list_mutex);
 	return 0;
 }
 
@@ -493,7 +493,7 @@ static void free_all_reserved_pages(void)
 	struct list_head *p;
 	struct snd_mem_list *mem;
 
-	down(&list_mutex);
+	mutex_lock(&list_mutex);
 	while (! list_empty(&mem_list_head)) {
 		p = mem_list_head.next;
 		mem = list_entry(p, struct snd_mem_list, list);
@@ -501,7 +501,7 @@ static void free_all_reserved_pages(void)
 		snd_dma_free_pages(&mem->buffer);
 		kfree(mem);
 	}
-	up(&list_mutex);
+	mutex_unlock(&list_mutex);
 }
 
 
@@ -522,7 +522,7 @@ static int snd_mem_proc_read(char *page, char **start, off_t off,
 	int devno;
 	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG", "SBUS" };
 
-	down(&list_mutex);
+	mutex_lock(&list_mutex);
 	len += snprintf(page + len, count - len,
 			"pages  : %li bytes (%li pages per %likB)\n",
 			pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
@@ -537,7 +537,7 @@ static int snd_mem_proc_read(char *page, char **start, off_t off,
 				"  addr = 0x%lx, size = %d bytes\n",
 				(unsigned long)mem->buffer.addr, (int)mem->buffer.bytes);
 	}
-	up(&list_mutex);
+	mutex_unlock(&list_mutex);
 	return len;
 }
 

commit d001544ded23ddb1116f945ccc2d89a7f98ab7e8
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:09:05 2005 +0100

    [ALSA] dynamic minors (6/6): increase maximum number of sound cards
    
    Modules: ALSA Core,Memalloc module,ALSA sequencer
    
    With dynamic minor numbers, we can increase the number of sound cards.
    
    This requires that the sequencer client numbers of some kernel drivers
    are allocated dynamically, too.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index e4b8959dd4bb..19b3dcbb09c2 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -43,10 +43,6 @@ MODULE_DESCRIPTION("Memory allocator for ALSA system.");
 MODULE_LICENSE("GPL");
 
 
-#ifndef SNDRV_CARDS
-#define SNDRV_CARDS	8
-#endif
-
 /*
  */
 

commit f3d48f0373c14a6203202f7b1dfc7b0d8aaf6ed2
Author: Hugh Dickins <hugh@veritas.com>
Date:   Mon Nov 21 21:32:22 2005 -0800

    [PATCH] unpaged: fix sound Bad page states
    
    Earlier I unifdefed PageCompound, so that snd_pcm_mmap_control_nopage and
    others can give out a 0-order component of a higher-order page, which won't
    be mistakenly freed when zap_pte_range unmaps it.  But many Bad page states
    reported a PG_reserved was freed after all: I had missed that we need to
    say __GFP_COMP to get compound page behaviour.
    
    Some of these higher-order pages are allocated by snd_malloc_pages, some by
    snd_malloc_dev_pages; or if SBUS, by sbus_alloc_consistent - but that has
    no gfp arg, so add __GFP_COMP into its sparc32/64 implementations.
    
    I'm still rather puzzled that DRM seems not to need a similar change.
    
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 129abab5ce98..e4b8959dd4bb 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -197,6 +197,7 @@ void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
 
 	snd_assert(size > 0, return NULL);
 	snd_assert(gfp_flags != 0, return NULL);
+	gfp_flags |= __GFP_COMP;	/* compound page lets parts be mapped */
 	pg = get_order(size);
 	if ((res = (void *) __get_free_pages(gfp_flags, pg)) != NULL) {
 		mark_pages(virt_to_page(res), pg);
@@ -241,6 +242,7 @@ static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *d
 	snd_assert(dma != NULL, return NULL);
 	pg = get_order(size);
 	gfp_flags = GFP_KERNEL
+		| __GFP_COMP	/* compound page lets parts be mapped */
 		| __GFP_NORETRY /* don't trigger OOM-killer */
 		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
 	res = dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);

commit 1ef64e670e3bc27e0c3c83810ca36e19924c35c6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:22:18 2005 -0400

    [PATCH] gfp_t: sound
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index e72cec77f0db..129abab5ce98 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -190,7 +190,7 @@ static void unmark_pages(struct page *page, int order)
  *
  * Returns the pointer of the buffer, or NULL if no enoguh memory.
  */
-void *snd_malloc_pages(size_t size, unsigned int gfp_flags)
+void *snd_malloc_pages(size_t size, gfp_t gfp_flags)
 {
 	int pg;
 	void *res;
@@ -235,7 +235,7 @@ static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *d
 {
 	int pg;
 	void *res;
-	unsigned int gfp_flags;
+	gfp_t gfp_flags;
 
 	snd_assert(size > 0, return NULL);
 	snd_assert(dma != NULL, return NULL);

commit dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Oct 7 07:46:04 2005 +0100

    [PATCH] gfp flags annotations - part 1
    
     - added typedef unsigned int __nocast gfp_t;
    
     - replaced __nocast uses for gfp flags with gfp_t - it gives exactly
       the same warnings as far as sparse is concerned, doesn't change
       generated code (from gcc point of view we replaced unsigned int with
       typedef) and documents what's going on far better.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 91124ddbdda9..e72cec77f0db 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -106,7 +106,7 @@ struct snd_mem_list {
 
 static void *snd_dma_hack_alloc_coherent(struct device *dev, size_t size,
 					 dma_addr_t *dma_handle,
-					 unsigned int __nocast flags)
+					 gfp_t flags)
 {
 	void *ret;
 	u64 dma_mask, coherent_dma_mask;

commit 0dd119f703d50759f0835f342e385f82cbf8b89e
Author: Jiri Slaby <xslaby@fi.muni.cz>
Date:   Wed Sep 7 14:28:33 2005 +0200

    [ALSA] pci_find_device remove
    
    Memalloc module,CS46xx driver,VIA82xx driver,ALI5451 driver
    au88x0 driver
    Replace pci_find_device() with pci_get_device() and pci_dev_put().
    
    Signed-off-by: Jiri Slaby <xslaby@fi.muni.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 39a54a415528..91124ddbdda9 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -590,7 +590,7 @@ static int snd_mem_proc_write(struct file *file, const char __user *buffer,
 
 		alloced = 0;
 		pci = NULL;
-		while ((pci = pci_find_device(vendor, device, pci)) != NULL) {
+		while ((pci = pci_get_device(vendor, device, pci)) != NULL) {
 			if (mask > 0 && mask < 0xffffffff) {
 				if (pci_set_dma_mask(pci, mask) < 0 ||
 				    pci_set_consistent_dma_mask(pci, mask) < 0) {
@@ -604,6 +604,7 @@ static int snd_mem_proc_write(struct file *file, const char __user *buffer,
 				if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
 							size, &dmab) < 0) {
 					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
+					pci_dev_put(pci);
 					return (int)count;
 				}
 				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));

commit e0be4d32bdae5cebc4e6d9dc65886e279aa69d08
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 23 11:11:03 2005 +0200

    [ALSA] Fix compilation without CONFIG_PROC_FS
    
    Memalloc module
    Fix an error when built without CONFIG_PROC_FS.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 371215cd9e8f..39a54a415528 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -655,8 +655,7 @@ static int __init snd_mem_init(void)
 
 static void __exit snd_mem_exit(void)
 {
-	if (snd_mem_proc)
-		remove_proc_entry(SND_MEM_PROC_FILE, NULL);
+	remove_proc_entry(SND_MEM_PROC_FILE, NULL);
 	free_all_reserved_pages();
 	if (snd_allocated_pages > 0)
 		printk(KERN_ERR "snd-malloc: Memory leak?  pages not freed = %li\n", snd_allocated_pages);

commit a53fc188ec6fc406276799da465fe789c40d96b2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Aug 11 15:59:17 2005 +0200

    [ALSA] make local objects static
    
    Memalloc module,PCM Midlevel,Timer Midlevel,GUS Library,AC97 Codec
    ALI5451 driver,RME9652 driver
    Make some functions/variables that are used in only one file static.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 02132561c3f8..371215cd9e8f 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -512,7 +512,7 @@ static void free_all_reserved_pages(void)
  * proc file interface
  */
 #define SND_MEM_PROC_FILE	"driver/snd-page-alloc"
-struct proc_dir_entry *snd_mem_proc;
+static struct proc_dir_entry *snd_mem_proc;
 
 static int snd_mem_proc_read(char *page, char **start, off_t off,
 			     int count, int *eof, void *data)

commit 5a0f217d96656068f0f1e5cda16c35945f979b16
Author: Victor Fusco <victor@cetuc.puc-rio.br>
Date:   Tue Jul 26 13:42:31 2005 +0200

    [ALSA] sound/core Fix the sparse warning 'implicit cast to nocast type'
    
    Memalloc module,ALSA Core,Instrument layer
    Fix the sparse warning 'implicit cast to nocast type'
    
    File/Subsystem:sound/core
    
    Signed-off-by: Victor Fusco <victor@cetuc.puc-rio.br>
    Signed-off-by: Domen Puncer <domen@coderock.org>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index dbc23e35fa06..02132561c3f8 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -105,7 +105,8 @@ struct snd_mem_list {
  */
 
 static void *snd_dma_hack_alloc_coherent(struct device *dev, size_t size,
-					 dma_addr_t *dma_handle, int flags)
+					 dma_addr_t *dma_handle,
+					 unsigned int __nocast flags)
 {
 	void *ret;
 	u64 dma_mask, coherent_dma_mask;

commit b6a969155b04416185f368bd4e2f1d49b17c1ee1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 30 18:27:03 2005 +0200

    [ALSA] Add write support to snd-page-alloc proc file
    
    Documentation,Memalloc module,RME HDSP driver,RME9652 driver
    Add the write support to snd-page-alloc proc file for buffer pre-allocation.
    Removed the pre-allocation codes via module options.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
index 344a83fd7c2e..dbc23e35fa06 100644
--- a/sound/core/memalloc.c
+++ b/sound/core/memalloc.c
@@ -28,6 +28,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
+#include <asm/uaccess.h>
 #include <linux/dma-mapping.h>
 #include <linux/moduleparam.h>
 #include <asm/semaphore.h>
@@ -46,13 +47,6 @@ MODULE_LICENSE("GPL");
 #define SNDRV_CARDS	8
 #endif
 
-/* FIXME: so far only some PCI devices have the preallocation table */
-#ifdef CONFIG_PCI
-static int enable[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};
-module_param_array(enable, bool, NULL, 0444);
-MODULE_PARM_DESC(enable, "Enable cards to allocate buffers.");
-#endif
-
 /*
  */
 
@@ -451,9 +445,13 @@ size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
 	list_for_each(p, &mem_list_head) {
 		mem = list_entry(p, struct snd_mem_list, list);
 		if (mem->id == id &&
-		    ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev))) {
+		    (mem->buffer.dev.dev == NULL || dmab->dev.dev == NULL ||
+		     ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev)))) {
+			struct device *dev = dmab->dev.dev;
 			list_del(p);
 			*dmab = mem->buffer;
+			if (dmab->dev.dev == NULL)
+				dmab->dev.dev = dev;
 			kfree(mem);
 			up(&list_mutex);
 			return dmab->bytes;
@@ -508,91 +506,13 @@ static void free_all_reserved_pages(void)
 }
 
 
-
-/*
- * allocation of buffers for pre-defined devices
- */
-
-#ifdef CONFIG_PCI
-/* FIXME: for pci only - other bus? */
-struct prealloc_dev {
-	unsigned short vendor;
-	unsigned short device;
-	unsigned long dma_mask;
-	unsigned int size;
-	unsigned int buffers;
-};
-
-#define HAMMERFALL_BUFFER_SIZE    (16*1024*4*(26+1)+0x10000)
-
-static struct prealloc_dev prealloc_devices[] __initdata = {
-	{
-		/* hammerfall */
-		.vendor = 0x10ee,
-		.device = 0x3fc4,
-		.dma_mask = 0xffffffff,
-		.size = HAMMERFALL_BUFFER_SIZE,
-		.buffers = 2
-	},
-	{
-		/* HDSP */
-		.vendor = 0x10ee,
-		.device = 0x3fc5,
-		.dma_mask = 0xffffffff,
-		.size = HAMMERFALL_BUFFER_SIZE,
-		.buffers = 2
-	},
-	{ }, /* terminator */
-};
-
-static void __init preallocate_cards(void)
-{
-	struct pci_dev *pci = NULL;
-	int card;
-
-	card = 0;
-
-	while ((pci = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pci)) != NULL) {
-		struct prealloc_dev *dev;
-		unsigned int i;
-		if (card >= SNDRV_CARDS)
-			break;
-		for (dev = prealloc_devices; dev->vendor; dev++) {
-			if (dev->vendor == pci->vendor && dev->device == pci->device)
-				break;
-		}
-		if (! dev->vendor)
-			continue;
-		if (! enable[card++]) {
-			printk(KERN_DEBUG "snd-page-alloc: skipping card %d, device %04x:%04x\n", card, pci->vendor, pci->device);
-			continue;
-		}
-			
-		if (pci_set_dma_mask(pci, dev->dma_mask) < 0 ||
-		    pci_set_consistent_dma_mask(pci, dev->dma_mask) < 0) {
-			printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", dev->dma_mask, dev->vendor, dev->device);
-			continue;
-		}
-		for (i = 0; i < dev->buffers; i++) {
-			struct snd_dma_buffer dmab;
-			memset(&dmab, 0, sizeof(dmab));
-			if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-						dev->size, &dmab) < 0)
-				printk(KERN_WARNING "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", dev->size);
-			else
-				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));
-		}
-	}
-}
-#else
-#define preallocate_cards()	/* NOP */
-#endif
-
-
 #ifdef CONFIG_PROC_FS
 /*
  * proc file interface
  */
+#define SND_MEM_PROC_FILE	"driver/snd-page-alloc"
+struct proc_dir_entry *snd_mem_proc;
+
 static int snd_mem_proc_read(char *page, char **start, off_t off,
 			     int count, int *eof, void *data)
 {
@@ -621,6 +541,97 @@ static int snd_mem_proc_read(char *page, char **start, off_t off,
 	up(&list_mutex);
 	return len;
 }
+
+/* FIXME: for pci only - other bus? */
+#ifdef CONFIG_PCI
+#define gettoken(bufp) strsep(bufp, " \t\n")
+
+static int snd_mem_proc_write(struct file *file, const char __user *buffer,
+			      unsigned long count, void *data)
+{
+	char buf[128];
+	char *token, *p;
+
+	if (count > ARRAY_SIZE(buf) - 1)
+		count = ARRAY_SIZE(buf) - 1;
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+	buf[ARRAY_SIZE(buf) - 1] = '\0';
+
+	p = buf;
+	token = gettoken(&p);
+	if (! token || *token == '#')
+		return (int)count;
+	if (strcmp(token, "add") == 0) {
+		char *endp;
+		int vendor, device, size, buffers;
+		long mask;
+		int i, alloced;
+		struct pci_dev *pci;
+
+		if ((token = gettoken(&p)) == NULL ||
+		    (vendor = simple_strtol(token, NULL, 0)) <= 0 ||
+		    (token = gettoken(&p)) == NULL ||
+		    (device = simple_strtol(token, NULL, 0)) <= 0 ||
+		    (token = gettoken(&p)) == NULL ||
+		    (mask = simple_strtol(token, NULL, 0)) < 0 ||
+		    (token = gettoken(&p)) == NULL ||
+		    (size = memparse(token, &endp)) < 64*1024 ||
+		    size > 16*1024*1024 /* too big */ ||
+		    (token = gettoken(&p)) == NULL ||
+		    (buffers = simple_strtol(token, NULL, 0)) <= 0 ||
+		    buffers > 4) {
+			printk(KERN_ERR "snd-page-alloc: invalid proc write format\n");
+			return (int)count;
+		}
+		vendor &= 0xffff;
+		device &= 0xffff;
+
+		alloced = 0;
+		pci = NULL;
+		while ((pci = pci_find_device(vendor, device, pci)) != NULL) {
+			if (mask > 0 && mask < 0xffffffff) {
+				if (pci_set_dma_mask(pci, mask) < 0 ||
+				    pci_set_consistent_dma_mask(pci, mask) < 0) {
+					printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", mask, vendor, device);
+					return (int)count;
+				}
+			}
+			for (i = 0; i < buffers; i++) {
+				struct snd_dma_buffer dmab;
+				memset(&dmab, 0, sizeof(dmab));
+				if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+							size, &dmab) < 0) {
+					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
+					return (int)count;
+				}
+				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));
+			}
+			alloced++;
+		}
+		if (! alloced) {
+			for (i = 0; i < buffers; i++) {
+				struct snd_dma_buffer dmab;
+				memset(&dmab, 0, sizeof(dmab));
+				/* FIXME: We can allocate only in ZONE_DMA
+				 * without a device pointer!
+				 */
+				if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, NULL,
+							size, &dmab) < 0) {
+					printk(KERN_ERR "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", size);
+					break;
+				}
+				snd_dma_reserve_buf(&dmab, (unsigned int)((vendor << 16) | device));
+			}
+		}
+	} else if (strcmp(token, "erase") == 0)
+		/* FIXME: need for releasing each buffer chunk? */
+		free_all_reserved_pages();
+	else
+		printk(KERN_ERR "snd-page-alloc: invalid proc cmd\n");
+	return (int)count;
+}
+#endif /* CONFIG_PCI */
 #endif /* CONFIG_PROC_FS */
 
 /*
@@ -630,15 +641,21 @@ static int snd_mem_proc_read(char *page, char **start, off_t off,
 static int __init snd_mem_init(void)
 {
 #ifdef CONFIG_PROC_FS
-	create_proc_read_entry("driver/snd-page-alloc", 0, NULL, snd_mem_proc_read, NULL);
+	snd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);
+	if (snd_mem_proc) {
+		snd_mem_proc->read_proc = snd_mem_proc_read;
+#ifdef CONFIG_PCI
+		snd_mem_proc->write_proc = snd_mem_proc_write;
+#endif
+	}
 #endif
-	preallocate_cards();
 	return 0;
 }
 
 static void __exit snd_mem_exit(void)
 {
-	remove_proc_entry("driver/snd-page-alloc", NULL);
+	if (snd_mem_proc)
+		remove_proc_entry(SND_MEM_PROC_FILE, NULL);
 	free_all_reserved_pages();
 	if (snd_allocated_pages > 0)
 		printk(KERN_ERR "snd-malloc: Memory leak?  pages not freed = %li\n", snd_allocated_pages);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c
new file mode 100644
index 000000000000..344a83fd7c2e
--- /dev/null
+++ b/sound/core/memalloc.c
@@ -0,0 +1,663 @@
+/*
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *                   Takashi Iwai <tiwai@suse.de>
+ * 
+ *  Generic memory allocators
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <linux/moduleparam.h>
+#include <asm/semaphore.h>
+#include <sound/memalloc.h>
+#ifdef CONFIG_SBUS
+#include <asm/sbus.h>
+#endif
+
+
+MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>, Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Memory allocator for ALSA system.");
+MODULE_LICENSE("GPL");
+
+
+#ifndef SNDRV_CARDS
+#define SNDRV_CARDS	8
+#endif
+
+/* FIXME: so far only some PCI devices have the preallocation table */
+#ifdef CONFIG_PCI
+static int enable[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable cards to allocate buffers.");
+#endif
+
+/*
+ */
+
+void *snd_malloc_sgbuf_pages(struct device *device,
+                             size_t size, struct snd_dma_buffer *dmab,
+			     size_t *res_size);
+int snd_free_sgbuf_pages(struct snd_dma_buffer *dmab);
+
+/*
+ */
+
+static DECLARE_MUTEX(list_mutex);
+static LIST_HEAD(mem_list_head);
+
+/* buffer preservation list */
+struct snd_mem_list {
+	struct snd_dma_buffer buffer;
+	unsigned int id;
+	struct list_head list;
+};
+
+/* id for pre-allocated buffers */
+#define SNDRV_DMA_DEVICE_UNUSED (unsigned int)-1
+
+#ifdef CONFIG_SND_DEBUG
+#define __ASTRING__(x) #x
+#define snd_assert(expr, args...) do {\
+	if (!(expr)) {\
+		printk(KERN_ERR "snd-malloc: BUG? (%s) (called from %p)\n", __ASTRING__(expr), __builtin_return_address(0));\
+		args;\
+	}\
+} while (0)
+#else
+#define snd_assert(expr, args...) /**/
+#endif
+
+/*
+ *  Hacks
+ */
+
+#if defined(__i386__) || defined(__ppc__) || defined(__x86_64__)
+/*
+ * A hack to allocate large buffers via dma_alloc_coherent()
+ *
+ * since dma_alloc_coherent always tries GFP_DMA when the requested
+ * pci memory region is below 32bit, it happens quite often that even
+ * 2 order of pages cannot be allocated.
+ *
+ * so in the following, we allocate at first without dma_mask, so that
+ * allocation will be done without GFP_DMA.  if the area doesn't match
+ * with the requested region, then realloate with the original dma_mask
+ * again.
+ *
+ * Really, we want to move this type of thing into dma_alloc_coherent()
+ * so dma_mask doesn't have to be messed with.
+ */
+
+static void *snd_dma_hack_alloc_coherent(struct device *dev, size_t size,
+					 dma_addr_t *dma_handle, int flags)
+{
+	void *ret;
+	u64 dma_mask, coherent_dma_mask;
+
+	if (dev == NULL || !dev->dma_mask)
+		return dma_alloc_coherent(dev, size, dma_handle, flags);
+	dma_mask = *dev->dma_mask;
+	coherent_dma_mask = dev->coherent_dma_mask;
+	*dev->dma_mask = 0xffffffff; 	/* do without masking */
+	dev->coherent_dma_mask = 0xffffffff; 	/* do without masking */
+	ret = dma_alloc_coherent(dev, size, dma_handle, flags);
+	*dev->dma_mask = dma_mask;	/* restore */
+	dev->coherent_dma_mask = coherent_dma_mask;	/* restore */
+	if (ret) {
+		/* obtained address is out of range? */
+		if (((unsigned long)*dma_handle + size - 1) & ~dma_mask) {
+			/* reallocate with the proper mask */
+			dma_free_coherent(dev, size, ret, *dma_handle);
+			ret = dma_alloc_coherent(dev, size, dma_handle, flags);
+		}
+	} else {
+		/* wish to success now with the proper mask... */
+		if (dma_mask != 0xffffffffUL) {
+			/* allocation with GFP_ATOMIC to avoid the long stall */
+			flags &= ~GFP_KERNEL;
+			flags |= GFP_ATOMIC;
+			ret = dma_alloc_coherent(dev, size, dma_handle, flags);
+		}
+	}
+	return ret;
+}
+
+/* redefine dma_alloc_coherent for some architectures */
+#undef dma_alloc_coherent
+#define dma_alloc_coherent snd_dma_hack_alloc_coherent
+
+#endif /* arch */
+
+#if ! defined(__arm__)
+#define NEED_RESERVE_PAGES
+#endif
+
+/*
+ *
+ *  Generic memory allocators
+ *
+ */
+
+static long snd_allocated_pages; /* holding the number of allocated pages */
+
+static inline void inc_snd_pages(int order)
+{
+	snd_allocated_pages += 1 << order;
+}
+
+static inline void dec_snd_pages(int order)
+{
+	snd_allocated_pages -= 1 << order;
+}
+
+static void mark_pages(struct page *page, int order)
+{
+	struct page *last_page = page + (1 << order);
+	while (page < last_page)
+		SetPageReserved(page++);
+}
+
+static void unmark_pages(struct page *page, int order)
+{
+	struct page *last_page = page + (1 << order);
+	while (page < last_page)
+		ClearPageReserved(page++);
+}
+
+/**
+ * snd_malloc_pages - allocate pages with the given size
+ * @size: the size to allocate in bytes
+ * @gfp_flags: the allocation conditions, GFP_XXX
+ *
+ * Allocates the physically contiguous pages with the given size.
+ *
+ * Returns the pointer of the buffer, or NULL if no enoguh memory.
+ */
+void *snd_malloc_pages(size_t size, unsigned int gfp_flags)
+{
+	int pg;
+	void *res;
+
+	snd_assert(size > 0, return NULL);
+	snd_assert(gfp_flags != 0, return NULL);
+	pg = get_order(size);
+	if ((res = (void *) __get_free_pages(gfp_flags, pg)) != NULL) {
+		mark_pages(virt_to_page(res), pg);
+		inc_snd_pages(pg);
+	}
+	return res;
+}
+
+/**
+ * snd_free_pages - release the pages
+ * @ptr: the buffer pointer to release
+ * @size: the allocated buffer size
+ *
+ * Releases the buffer allocated via snd_malloc_pages().
+ */
+void snd_free_pages(void *ptr, size_t size)
+{
+	int pg;
+
+	if (ptr == NULL)
+		return;
+	pg = get_order(size);
+	dec_snd_pages(pg);
+	unmark_pages(virt_to_page(ptr), pg);
+	free_pages((unsigned long) ptr, pg);
+}
+
+/*
+ *
+ *  Bus-specific memory allocators
+ *
+ */
+
+/* allocate the coherent DMA pages */
+static void *snd_malloc_dev_pages(struct device *dev, size_t size, dma_addr_t *dma)
+{
+	int pg;
+	void *res;
+	unsigned int gfp_flags;
+
+	snd_assert(size > 0, return NULL);
+	snd_assert(dma != NULL, return NULL);
+	pg = get_order(size);
+	gfp_flags = GFP_KERNEL
+		| __GFP_NORETRY /* don't trigger OOM-killer */
+		| __GFP_NOWARN; /* no stack trace print - this call is non-critical */
+	res = dma_alloc_coherent(dev, PAGE_SIZE << pg, dma, gfp_flags);
+	if (res != NULL) {
+#ifdef NEED_RESERVE_PAGES
+		mark_pages(virt_to_page(res), pg); /* should be dma_to_page() */
+#endif
+		inc_snd_pages(pg);
+	}
+
+	return res;
+}
+
+/* free the coherent DMA pages */
+static void snd_free_dev_pages(struct device *dev, size_t size, void *ptr,
+			       dma_addr_t dma)
+{
+	int pg;
+
+	if (ptr == NULL)
+		return;
+	pg = get_order(size);
+	dec_snd_pages(pg);
+#ifdef NEED_RESERVE_PAGES
+	unmark_pages(virt_to_page(ptr), pg); /* should be dma_to_page() */
+#endif
+	dma_free_coherent(dev, PAGE_SIZE << pg, ptr, dma);
+}
+
+#ifdef CONFIG_SBUS
+
+static void *snd_malloc_sbus_pages(struct device *dev, size_t size,
+				   dma_addr_t *dma_addr)
+{
+	struct sbus_dev *sdev = (struct sbus_dev *)dev;
+	int pg;
+	void *res;
+
+	snd_assert(size > 0, return NULL);
+	snd_assert(dma_addr != NULL, return NULL);
+	pg = get_order(size);
+	res = sbus_alloc_consistent(sdev, PAGE_SIZE * (1 << pg), dma_addr);
+	if (res != NULL)
+		inc_snd_pages(pg);
+	return res;
+}
+
+static void snd_free_sbus_pages(struct device *dev, size_t size,
+				void *ptr, dma_addr_t dma_addr)
+{
+	struct sbus_dev *sdev = (struct sbus_dev *)dev;
+	int pg;
+
+	if (ptr == NULL)
+		return;
+	pg = get_order(size);
+	dec_snd_pages(pg);
+	sbus_free_consistent(sdev, PAGE_SIZE * (1 << pg), ptr, dma_addr);
+}
+
+#endif /* CONFIG_SBUS */
+
+/*
+ *
+ *  ALSA generic memory management
+ *
+ */
+
+
+/**
+ * snd_dma_alloc_pages - allocate the buffer area according to the given type
+ * @type: the DMA buffer type
+ * @device: the device pointer
+ * @size: the buffer size to allocate
+ * @dmab: buffer allocation record to store the allocated data
+ *
+ * Calls the memory-allocator function for the corresponding
+ * buffer type.
+ * 
+ * Returns zero if the buffer with the given size is allocated successfuly,
+ * other a negative value at error.
+ */
+int snd_dma_alloc_pages(int type, struct device *device, size_t size,
+			struct snd_dma_buffer *dmab)
+{
+	snd_assert(size > 0, return -ENXIO);
+	snd_assert(dmab != NULL, return -ENXIO);
+
+	dmab->dev.type = type;
+	dmab->dev.dev = device;
+	dmab->bytes = 0;
+	switch (type) {
+	case SNDRV_DMA_TYPE_CONTINUOUS:
+		dmab->area = snd_malloc_pages(size, (unsigned long)device);
+		dmab->addr = 0;
+		break;
+#ifdef CONFIG_SBUS
+	case SNDRV_DMA_TYPE_SBUS:
+		dmab->area = snd_malloc_sbus_pages(device, size, &dmab->addr);
+		break;
+#endif
+	case SNDRV_DMA_TYPE_DEV:
+		dmab->area = snd_malloc_dev_pages(device, size, &dmab->addr);
+		break;
+	case SNDRV_DMA_TYPE_DEV_SG:
+		snd_malloc_sgbuf_pages(device, size, dmab, NULL);
+		break;
+	default:
+		printk(KERN_ERR "snd-malloc: invalid device type %d\n", type);
+		dmab->area = NULL;
+		dmab->addr = 0;
+		return -ENXIO;
+	}
+	if (! dmab->area)
+		return -ENOMEM;
+	dmab->bytes = size;
+	return 0;
+}
+
+/**
+ * snd_dma_alloc_pages_fallback - allocate the buffer area according to the given type with fallback
+ * @type: the DMA buffer type
+ * @device: the device pointer
+ * @size: the buffer size to allocate
+ * @dmab: buffer allocation record to store the allocated data
+ *
+ * Calls the memory-allocator function for the corresponding
+ * buffer type.  When no space is left, this function reduces the size and
+ * tries to allocate again.  The size actually allocated is stored in
+ * res_size argument.
+ * 
+ * Returns zero if the buffer with the given size is allocated successfuly,
+ * other a negative value at error.
+ */
+int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,
+				 struct snd_dma_buffer *dmab)
+{
+	int err;
+
+	snd_assert(size > 0, return -ENXIO);
+	snd_assert(dmab != NULL, return -ENXIO);
+
+	while ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {
+		if (err != -ENOMEM)
+			return err;
+		size >>= 1;
+		if (size <= PAGE_SIZE)
+			return -ENOMEM;
+	}
+	if (! dmab->area)
+		return -ENOMEM;
+	return 0;
+}
+
+
+/**
+ * snd_dma_free_pages - release the allocated buffer
+ * @dmab: the buffer allocation record to release
+ *
+ * Releases the allocated buffer via snd_dma_alloc_pages().
+ */
+void snd_dma_free_pages(struct snd_dma_buffer *dmab)
+{
+	switch (dmab->dev.type) {
+	case SNDRV_DMA_TYPE_CONTINUOUS:
+		snd_free_pages(dmab->area, dmab->bytes);
+		break;
+#ifdef CONFIG_SBUS
+	case SNDRV_DMA_TYPE_SBUS:
+		snd_free_sbus_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+		break;
+#endif
+	case SNDRV_DMA_TYPE_DEV:
+		snd_free_dev_pages(dmab->dev.dev, dmab->bytes, dmab->area, dmab->addr);
+		break;
+	case SNDRV_DMA_TYPE_DEV_SG:
+		snd_free_sgbuf_pages(dmab);
+		break;
+	default:
+		printk(KERN_ERR "snd-malloc: invalid device type %d\n", dmab->dev.type);
+	}
+}
+
+
+/**
+ * snd_dma_get_reserved - get the reserved buffer for the given device
+ * @dmab: the buffer allocation record to store
+ * @id: the buffer id
+ *
+ * Looks for the reserved-buffer list and re-uses if the same buffer
+ * is found in the list.  When the buffer is found, it's removed from the free list.
+ *
+ * Returns the size of buffer if the buffer is found, or zero if not found.
+ */
+size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
+{
+	struct list_head *p;
+	struct snd_mem_list *mem;
+
+	snd_assert(dmab, return 0);
+
+	down(&list_mutex);
+	list_for_each(p, &mem_list_head) {
+		mem = list_entry(p, struct snd_mem_list, list);
+		if (mem->id == id &&
+		    ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev))) {
+			list_del(p);
+			*dmab = mem->buffer;
+			kfree(mem);
+			up(&list_mutex);
+			return dmab->bytes;
+		}
+	}
+	up(&list_mutex);
+	return 0;
+}
+
+/**
+ * snd_dma_reserve_buf - reserve the buffer
+ * @dmab: the buffer to reserve
+ * @id: the buffer id
+ *
+ * Reserves the given buffer as a reserved buffer.
+ * 
+ * Returns zero if successful, or a negative code at error.
+ */
+int snd_dma_reserve_buf(struct snd_dma_buffer *dmab, unsigned int id)
+{
+	struct snd_mem_list *mem;
+
+	snd_assert(dmab, return -EINVAL);
+	mem = kmalloc(sizeof(*mem), GFP_KERNEL);
+	if (! mem)
+		return -ENOMEM;
+	down(&list_mutex);
+	mem->buffer = *dmab;
+	mem->id = id;
+	list_add_tail(&mem->list, &mem_list_head);
+	up(&list_mutex);
+	return 0;
+}
+
+/*
+ * purge all reserved buffers
+ */
+static void free_all_reserved_pages(void)
+{
+	struct list_head *p;
+	struct snd_mem_list *mem;
+
+	down(&list_mutex);
+	while (! list_empty(&mem_list_head)) {
+		p = mem_list_head.next;
+		mem = list_entry(p, struct snd_mem_list, list);
+		list_del(p);
+		snd_dma_free_pages(&mem->buffer);
+		kfree(mem);
+	}
+	up(&list_mutex);
+}
+
+
+
+/*
+ * allocation of buffers for pre-defined devices
+ */
+
+#ifdef CONFIG_PCI
+/* FIXME: for pci only - other bus? */
+struct prealloc_dev {
+	unsigned short vendor;
+	unsigned short device;
+	unsigned long dma_mask;
+	unsigned int size;
+	unsigned int buffers;
+};
+
+#define HAMMERFALL_BUFFER_SIZE    (16*1024*4*(26+1)+0x10000)
+
+static struct prealloc_dev prealloc_devices[] __initdata = {
+	{
+		/* hammerfall */
+		.vendor = 0x10ee,
+		.device = 0x3fc4,
+		.dma_mask = 0xffffffff,
+		.size = HAMMERFALL_BUFFER_SIZE,
+		.buffers = 2
+	},
+	{
+		/* HDSP */
+		.vendor = 0x10ee,
+		.device = 0x3fc5,
+		.dma_mask = 0xffffffff,
+		.size = HAMMERFALL_BUFFER_SIZE,
+		.buffers = 2
+	},
+	{ }, /* terminator */
+};
+
+static void __init preallocate_cards(void)
+{
+	struct pci_dev *pci = NULL;
+	int card;
+
+	card = 0;
+
+	while ((pci = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pci)) != NULL) {
+		struct prealloc_dev *dev;
+		unsigned int i;
+		if (card >= SNDRV_CARDS)
+			break;
+		for (dev = prealloc_devices; dev->vendor; dev++) {
+			if (dev->vendor == pci->vendor && dev->device == pci->device)
+				break;
+		}
+		if (! dev->vendor)
+			continue;
+		if (! enable[card++]) {
+			printk(KERN_DEBUG "snd-page-alloc: skipping card %d, device %04x:%04x\n", card, pci->vendor, pci->device);
+			continue;
+		}
+			
+		if (pci_set_dma_mask(pci, dev->dma_mask) < 0 ||
+		    pci_set_consistent_dma_mask(pci, dev->dma_mask) < 0) {
+			printk(KERN_ERR "snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\n", dev->dma_mask, dev->vendor, dev->device);
+			continue;
+		}
+		for (i = 0; i < dev->buffers; i++) {
+			struct snd_dma_buffer dmab;
+			memset(&dmab, 0, sizeof(dmab));
+			if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+						dev->size, &dmab) < 0)
+				printk(KERN_WARNING "snd-page-alloc: cannot allocate buffer pages (size = %d)\n", dev->size);
+			else
+				snd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));
+		}
+	}
+}
+#else
+#define preallocate_cards()	/* NOP */
+#endif
+
+
+#ifdef CONFIG_PROC_FS
+/*
+ * proc file interface
+ */
+static int snd_mem_proc_read(char *page, char **start, off_t off,
+			     int count, int *eof, void *data)
+{
+	int len = 0;
+	long pages = snd_allocated_pages >> (PAGE_SHIFT-12);
+	struct list_head *p;
+	struct snd_mem_list *mem;
+	int devno;
+	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG", "SBUS" };
+
+	down(&list_mutex);
+	len += snprintf(page + len, count - len,
+			"pages  : %li bytes (%li pages per %likB)\n",
+			pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
+	devno = 0;
+	list_for_each(p, &mem_list_head) {
+		mem = list_entry(p, struct snd_mem_list, list);
+		devno++;
+		len += snprintf(page + len, count - len,
+				"buffer %d : ID %08x : type %s\n",
+				devno, mem->id, types[mem->buffer.dev.type]);
+		len += snprintf(page + len, count - len,
+				"  addr = 0x%lx, size = %d bytes\n",
+				(unsigned long)mem->buffer.addr, (int)mem->buffer.bytes);
+	}
+	up(&list_mutex);
+	return len;
+}
+#endif /* CONFIG_PROC_FS */
+
+/*
+ * module entry
+ */
+
+static int __init snd_mem_init(void)
+{
+#ifdef CONFIG_PROC_FS
+	create_proc_read_entry("driver/snd-page-alloc", 0, NULL, snd_mem_proc_read, NULL);
+#endif
+	preallocate_cards();
+	return 0;
+}
+
+static void __exit snd_mem_exit(void)
+{
+	remove_proc_entry("driver/snd-page-alloc", NULL);
+	free_all_reserved_pages();
+	if (snd_allocated_pages > 0)
+		printk(KERN_ERR "snd-malloc: Memory leak?  pages not freed = %li\n", snd_allocated_pages);
+}
+
+
+module_init(snd_mem_init)
+module_exit(snd_mem_exit)
+
+
+/*
+ * exports
+ */
+EXPORT_SYMBOL(snd_dma_alloc_pages);
+EXPORT_SYMBOL(snd_dma_alloc_pages_fallback);
+EXPORT_SYMBOL(snd_dma_free_pages);
+
+EXPORT_SYMBOL(snd_dma_get_reserved_buf);
+EXPORT_SYMBOL(snd_dma_reserve_buf);
+
+EXPORT_SYMBOL(snd_malloc_pages);
+EXPORT_SYMBOL(snd_free_pages);
